<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Reference</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="소개"><a class="header" href="#소개">소개</a></h1>
<p>이 책은 러스트 프로그래밍 언어의 주요 참고 자료입니다. 이 책은 세 가지 종류의 자료를 제공합니다:</p>
<ul>
<li>각 언어 구성 요소와 그 사용법을 비공식적으로 설명하는 장.</li>
<li>메모리 모델, 동시성 모델, 런타임 서비스, 연결 모델 및 디버깅 기능을 비공식적으로 설명하는 장.</li>
<li>설계에 영향을 미친 언어에 대한 근거와 참조를 제공하는 부록 장.</li>
</ul>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 이 책은 미완성입니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 문서화되지 않은 내용은 <a href="https://github.com/rust-lang/reference/issues">GitHub 이슈</a>를 참조하십시오.</p>
</blockquote>
</div>
<h2 id="러스트-릴리스"><a class="header" href="#러스트-릴리스">러스트 릴리스</a></h2>
<p>러스트는 6주마다 새로운 언어 릴리스를 발표합니다. 언어의 첫 번째 안정 릴리스는 Rust 1.0.0이었고, 이어서 Rust 1.1.0 등이 출시되었습니다. 도구(<code>rustc</code>, <code>cargo</code> 등) 및 문서(<a href="../std/index.html">표준 라이브러리</a>, 이 책 등)는 언어 릴리스와 함께 출시됩니다.</p>
<p>최신 Rust 버전에 해당하는 이 책의 최신 릴리스는 항상 <a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a>에서 찾을 수 있습니다. 이전 버전은 “reference” 디렉토리 앞에 Rust 버전을 추가하여 찾을 수 있습니다. 예를 들어, Rust 1.49.0에 대한 참조는 <a href="https://doc.rust-lang.org/1.49.0/reference/">https://doc.rust-lang.org/1.49.0/reference/</a>에 있습니다.</p>
<h2 id="_참조_가-아닌-것"><a class="header" href="#_참조_가-아닌-것">_참조_가 아닌 것</a></h2>
<p>이 책은 언어 입문서가 아닙니다. 언어에 대한 기본적인 지식이 있다고 가정합니다. 이러한 배경 지식을 습득하는 데 도움이 되는 별도의 <a href="../book/index.html">책</a>이 있습니다.</p>
<p>이 책은 또한 언어 배포판에 포함된 <a href="../std/index.html">표준 라이브러리</a>에 대한 참조 역할을 하지 않습니다. 해당 라이브러리는 소스 코드에서 문서 속성을 추출하여 별도로 문서화됩니다. 언어 기능이라고 예상할 수 있는 많은 기능이 Rust에서는 라이브러리 기능이므로, 찾고 있는 것이 여기에 없을 수도 있습니다.</p>
<p>마찬가지로, 이 책은 일반적으로 <code>rustc</code> 도구 또는 Cargo의 세부 사항을 문서화하지 않습니다. <code>rustc</code>에는 자체 <a href="../rustc/index.html">책</a>이 있습니다. Cargo에는 <a href="../cargo/reference/index.html">참조</a>가 포함된 <a href="../cargo/index.html">책</a>이 있습니다. <a href="linkage.html">연결</a>과 같은 몇몇 페이지는 여전히 <code>rustc</code>의 작동 방식을 설명합니다.</p>
<p>이 책은 또한 안정적인 Rust에서 사용할 수 있는 기능에 대한 참조 역할만 합니다. 개발 중인 불안정한 기능에 대해서는 <a href="https://doc.rust-lang.org/nightly/unstable-book/">불안정 책</a>을 참조하십시오.</p>
<p><code>rustc</code>를 포함한 Rust 컴파일러는 최적화를 수행합니다. 참조는 어떤 최적화가 허용되거나 허용되지 않는지 명시하지 않습니다. 대신, 컴파일된 프로그램을 블랙박스로 생각하십시오. 프로그램을 실행하고 입력을 제공하며 출력을 관찰함으로써만 탐색할 수 있습니다. 그렇게 발생하는 모든 것은 참조가 말하는 바를 따라야 합니다.</p>
<p>마지막으로, 이 책은 규범적이지 않습니다. <code>rustc</code> 자체에 특정한 세부 사항을 포함할 수 있으며, Rust 언어에 대한 사양으로 간주되어서는 안 됩니다. 우리는 언젠가 그러한 책을 만들 계획이며, 그때까지는 이 참조가 가장 가까운 것입니다.</p>
<h2 id="이-책을-사용하는-방법"><a class="header" href="#이-책을-사용하는-방법">이 책을 사용하는 방법</a></h2>
<p>이 책은 순차적으로 읽는다고 가정하지 않습니다. 각 장은 일반적으로 독립적으로 읽을 수 있지만, 언급하지만 논의하지 않는 언어의 측면에 대해서는 다른 장으로 상호 연결됩니다.</p>
<p>이 문서를 읽는 두 가지 주요 방법이 있습니다.</p>
<p>첫 번째는 특정 질문에 답하는 것입니다. 해당 질문에 답하는 장을 알고 있다면 목차에서 해당 장으로 이동할 수 있습니다. 그렇지 않으면 <code>s</code>를 누르거나 상단 바의 돋보기를 클릭하여 질문과 관련된 키워드를 검색할 수 있습니다. 예를 들어, let 문에서 생성된 임시 값이 언제 삭제되는지 알고 싶다고 가정해 봅시다. <a href="expressions.html#temporaries">임시 값의 수명</a>이 <a href="expressions.html">표현식 장</a>에 정의되어 있다는 것을 이미 알고 있지 못했다면, “temporary let“을 검색하면 첫 번째 검색 결과가 해당 섹션으로 안내할 것입니다.</p>
<p>두 번째는 언어의 한 측면에 대한 지식을 일반적으로 향상시키는 것입니다. 이 경우, 더 알고 싶은 것을 볼 때까지 목차를 탐색하고 읽기 시작하십시오. 링크가 흥미로워 보이면 클릭하여 해당 섹션을 읽으십시오.</p>
<p>그렇다고 해서 이 책을 읽는 데 잘못된 방법은 없습니다. 가장 도움이 된다고 생각하는 방식으로 읽으십시오.</p>
<h3 id="규약"><a class="header" href="#규약">규약</a></h3>
<p>모든 기술 서적과 마찬가지로 이 책은 정보를 표시하는 방식에 있어 특정 규칙을 따릅니다. 이러한 규칙은 여기에 문서화되어 있습니다.</p>
<ul>
<li>
<p>용어를 정의하는 문장은 해당 용어를 _이탤릭체_로 포함합니다. 해당 용어가 해당 장 외부에서 사용될 때마다 일반적으로 이 정의가 있는 섹션에 대한 링크입니다.</p>
<p>_예시 용어_는 정의되는 용어의 예시입니다.</p>
</li>
<li>
<p>크레이트가 컴파일되는 에디션에 따른 언어의 차이점은 “에디션 차이:“라는 단어로 시작하는 <strong>굵은 글씨</strong>의 인용 블록에 있습니다.</p>
<blockquote>
<p><strong>에디션 차이</strong>: 2015년 에디션에서는 이 구문이 유효했지만, 2018년 에디션부터는 허용되지 않습니다.</p>
</blockquote>
</li>
<li>
<p>책의 상태에 대한 유용한 정보나 유용하지만 대부분 범위 외의 정보를 포함하는 노트는 <strong>굵은 글씨</strong>로 “참고:“라는 단어로 시작하는 인용 블록에 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 이것은 예시 노트입니다.</p>
</blockquote>
</li>
<li>
<p>언어의 불안정한 동작 또는 언어 기능의 혼란스러운 상호 작용을 보여주는 경고는 특별 경고 상자에 있습니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 이것은 예시 경고입니다.</p>
</blockquote>
</div>
</li>
<li>
<p>텍스트 내의 코드 스니펫은 <code>&lt;code&gt;</code> 태그 안에 있습니다.</p>
<p>더 긴 코드 예제는 구문 강조 표시된 상자에 있으며, 오른쪽 상단 모서리에 복사, 실행 및 숨겨진 줄 표시를 위한 컨트롤이 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">// 이것은 숨겨진 줄입니다.
</span>fn main() {
    println!("이것은 코드 예시입니다");
}</code></pre></pre>
<p>모든 예제는 별도로 명시되지 않는 한 최신 에디션을 기준으로 작성되었습니다.</p>
</li>
<li>
<p>문법 및 어휘 구조는 첫 줄에 <sup><strong>굵은 위첨자</strong></sup>로 “Lexer” 또는 “Syntax“가 있는 인용 블록에 있습니다.</p>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>예시문법</em>:<br />
      <code>~</code> <a href="expressions.html"><em>표현식</em></a><br />
   | <code>box</code> <a href="expressions.html"><em>표현식</em></a></p>
</blockquote>
<p>자세한 내용은 <a href="notation.html">표기법</a>을 참조하십시오.</p>
</li>
<li>
<p>규칙 식별자는 각 언어 규칙 앞에 대괄호로 묶여 나타납니다. 이러한 식별자는 언어의 특정 규칙을 참조하는 방법을 제공합니다. 규칙 식별자는 가장 일반적인 것부터 가장 구체적인 것까지 섹션을 구분하기 위해 마침표를 사용합니다(예: <a href="destructors.html#r-destructors.scope.nesting.function-body">destructors.scope.nesting.function-body</a>).</p>
<p>규칙 이름을 클릭하면 해당 규칙으로 연결됩니다.</p>
</li>
</ul>
<div class="rule" id="r-example.rule.label"><a class="rule-link" href="introduction.html#r-example.rule.label" title="example.rule.label"><span>[example<wbr>.rule<wbr>.label]<span/></a></div>
  <div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 규칙의 구성은 현재 유동적입니다. 당분간 이러한 식별자 이름은 릴리스 간에 안정적이지 않으며, 변경될 경우 이러한 규칙에 대한 링크가 실패할 수 있습니다. 우리는 구성이 안정화되면 규칙 이름에 대한 링크가 릴리스 간에 깨지지 않도록 이를 안정화할 계획입니다.</p>
</blockquote>
  </div>
<h2 id="기여하기"><a class="header" href="#기여하기">기여하기</a></h2>
<p>모든 종류의 기여를 환영합니다.</p>
<p>이 책에 기여하려면 <a href="https://github.com/rust-lang/reference/">Rust 참조 저장소</a>에 이슈를 열거나 풀 리퀘스트를 보내십시오. 이 책이 질문에 답하지 못하고 그 답이 이 책의 범위 내에 있다고 생각되면 주저하지 말고 <a href="https://github.com/rust-lang/reference/issues">이슈를 제출</a>하거나 <a href="https://rust-lang.zulipchat.com/#narrow/stream/237824-t-lang.2Fdoc">Zulip</a>의 <code>t-lang/doc</code> 스트림에서 문의하십시오. 사람들이 이 책을 가장 많이 사용하는 용도를 알면 해당 섹션을 최상으로 만드는 데 집중하는 데 도움이 됩니다. 또한 참조가 가능한 한 규범적이기를 원하므로, 잘못되었거나 비규범적이지만 특별히 언급되지 않은 부분이 있으면 <a href="https://github.com/rust-lang/reference/issues">이슈를 제출</a>해 주십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="표기법"><a class="header" href="#표기법">표기법</a></h1>
<h2 id="문법"><a class="header" href="#문법">문법</a></h2>
<p>다음 표기법은 <em>렉서</em> 및 <em>구문</em> 문법 스니펫에서 사용됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>표기법</th><th>예시</th><th>의미</th></tr></thead><tbody>
<tr><td>대문자</td><td>KW_IF, 정수_리터럴</td><td>렉서가 생성한 토큰</td></tr>
<tr><td><em>이탤릭카멜케이스</em></td><td><em>Let문</em>, <em>아이템</em></td><td>구문 생성</td></tr>
<tr><td><code>문자열</code></td><td><code>x</code>, <code>while</code>, <code>*</code></td><td>정확한 문자(들)</td></tr>
<tr><td>\x</td><td>\n, \r, \t, \0</td><td>이 이스케이프가 나타내는 문자</td></tr>
<tr><td>x<sup>?</sup></td><td><code>pub</code><sup>?</sup></td><td>선택적 항목</td></tr>
<tr><td>x<sup>*</sup></td><td><em>외부속성</em><sup>*</sup></td><td>x가 0개 이상</td></tr>
<tr><td>x<sup>+</sup></td><td><em>매크로매치</em><sup>+</sup></td><td>x가 1개 이상</td></tr>
<tr><td>x<sup>a..b</sup></td><td>16진수_숫자<sup>1..6</sup></td><td>x의 a부터 b까지 반복</td></tr>
<tr><td>|</td><td><code>u8</code> | <code>u16</code>, 블록 | 아이템</td><td>둘 중 하나</td></tr>
<tr><td>[ ]</td><td>[<code>b</code> <code>B</code>]</td><td>나열된 문자 중 하나</td></tr>
<tr><td>[ - ]</td><td>[<code>a</code>-<code>z</code>]</td><td>범위 내의 문자 중 하나</td></tr>
<tr><td>~[ ]</td><td>~[<code>b</code> <code>B</code>]</td><td>나열된 문자를 제외한 모든 문자</td></tr>
<tr><td>~<code>문자열</code></td><td>~<code> </code>, ~<code>*/</code></td><td>이 시퀀스를 제외한 모든 문자</td></tr>
<tr><td>( )</td><td>(<code>,</code> <em>매개변수</em>)<sup>?</sup></td><td>항목 그룹화</td></tr>
</tbody></table>
</div>
<h2 id="문자열-테이블-생성"><a class="header" href="#문자열-테이블-생성">문자열 테이블 생성</a></h2>
<p>문법의 일부 규칙(특히 <a href="expressions/operator-expr.html#borrow-operators">단항 연산자</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">이항 연산자</a> 및 <a href="keywords.html">키워드</a>)은 인쇄 가능한 문자열 목록으로 단순화된 형태로 제공됩니다. 이러한 경우는 <a href="tokens.html">토큰</a> 규칙에 관한 규칙의 하위 집합을 형성하며, <abbr title="결정론적 유한 오토마톤">DFA</abbr>에 의해 구동되는 어휘 분석 단계가 파서에 공급하는 결과로 간주되며, 이러한 모든 문자열 테이블 항목의 논리합에 대해 작동합니다.</p>
<p>문법 내에서 <code>monospace</code> 글꼴의 문자열이 나타나면, 이는 해당 문자열 테이블 생성의 단일 멤버에 대한 암시적 참조입니다. 자세한 내용은 <a href="tokens.html">토큰</a>을 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="어휘-구조"><a class="header" href="#어휘-구조">어휘 구조</a></h1>
<!-- Editor Note: Oh, there's nothing here -->
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-input"><a class="rule-link" href="input-format.html#r-input" title="input"><span>[input]<span/></a></div>
<h1 id="입력-형식"><a class="header" href="#입력-형식">입력 형식</a></h1>
<div class="rule" id="r-input.intro"><a class="rule-link" href="input-format.html#r-input.intro" title="input.intro"><span>[input<wbr>.intro]<span/></a></div>
<p>이 장에서는 소스 파일이 토큰 시퀀스로 해석되는 방법을 설명합니다.</p>
<p>프로그램이 파일로 구성되는 방법에 대한 설명은 <a href="crates-and-source-files.html">크레이트 및 소스 파일</a>을 참조하십시오.</p>
<div class="rule" id="r-input.encoding"><a class="rule-link" href="input-format.html#r-input.encoding" title="input.encoding"><span>[input<wbr>.encoding]<span/></a></div>
<h2 id="소스-인코딩"><a class="header" href="#소스-인코딩">소스 인코딩</a></h2>
<div class="rule" id="r-input.encoding.utf8"><a class="rule-link" href="input-format.html#r-input.encoding.utf8" title="input.encoding.utf8"><span>[input<wbr>.encoding<wbr>.utf8]<span/></a></div>
<p>각 소스 파일은 UTF-8로 인코딩된 유니코드 문자 시퀀스로 해석됩니다.</p>
<div class="rule" id="r-input.encoding.invalid"><a class="rule-link" href="input-format.html#r-input.encoding.invalid" title="input.encoding.invalid"><span>[input<wbr>.encoding<wbr>.invalid]<span/></a></div>
<p>파일이 유효한 UTF-8이 아니면 오류입니다.</p>
<div class="rule" id="r-input.byte-order-mark"><a class="rule-link" href="input-format.html#r-input.byte-order-mark" title="input.byte-order-mark"><span>[input<wbr>.byte-order-mark]<span/></a></div>
<h2 id="바이트-순서-마크-제거"><a class="header" href="#바이트-순서-마크-제거">바이트 순서 마크 제거</a></h2>
<p>시퀀스의 첫 번째 문자가 <code>U+FEFF</code>(<a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">바이트 순서 마크</a>)이면 제거됩니다.</p>
<div class="rule" id="r-input.crlf"><a class="rule-link" href="input-format.html#r-input.crlf" title="input.crlf"><span>[input<wbr>.crlf]<span/></a></div>
<h2 id="crlf-정규화"><a class="header" href="#crlf-정규화">CRLF 정규화</a></h2>
<p><code>U+000D</code> (CR) 문자와 그 뒤에 바로 오는 <code>U+000A</code> (LF) 문자의 각 쌍은 단일 <code>U+000A</code> (LF)로 대체됩니다.</p>
<p><code>U+000D</code> (CR) 문자의 다른 발생은 그대로 유지됩니다(이들은 <a href="whitespace.html">공백</a>으로 처리됩니다).</p>
<div class="rule" id="r-input.shebang"><a class="rule-link" href="input-format.html#r-input.shebang" title="input.shebang"><span>[input<wbr>.shebang]<span/></a></div>
<h2 id="쉬뱅-제거"><a class="header" href="#쉬뱅-제거">쉬뱅 제거</a></h2>
<div class="rule" id="r-input.shebang.intro"><a class="rule-link" href="input-format.html#r-input.shebang.intro" title="input.shebang.intro"><span>[input<wbr>.shebang<wbr>.intro]<span/></a></div>
<p>남은 시퀀스가 <code>#!</code> 문자로 시작하면, 첫 번째 <code>U+000A</code> (LF)까지의 문자가 시퀀스에서 제거됩니다.</p>
<p>예를 들어, 다음 파일의 첫 번째 줄은 무시됩니다:</p>
<!-- ignore: tests don't like shebang -->
<pre><code class="language-rust ignore">#!/usr/bin/env rustx

fn main() {
    println!("안녕하세요!");
}</code></pre>
<div class="rule" id="r-input.shebang.inner-attribute"><a class="rule-link" href="input-format.html#r-input.shebang.inner-attribute" title="input.shebang.inner-attribute"><span>[input<wbr>.shebang<wbr>.inner-attribute]<span/></a></div>
<p>예외적으로, <code>#!</code> 문자 뒤에 (중간에 있는 <a href="comments.html">주석</a>이나 <a href="whitespace.html">공백</a>을 무시하고) <code>[</code> 토큰이 오면 아무것도 제거되지 않습니다. 이는 소스 파일 시작 부분에 있는 <a href="attributes.html">내부 속성</a>이 제거되는 것을 방지합니다.</p>
<blockquote>
<p><strong>참고</strong>: 표준 라이브러리 <a href="../core/macro.include.html"><code>include!</code></a> 매크로는 읽는 파일에 바이트 순서 마크 제거, CRLF 정규화 및 쉬뱅 제거를 적용합니다. <a href="../core/macro.include_str.html"><code>include_str!</code></a> 및 <a href="../core/macro.include_bytes.html"><code>include_bytes!</code></a> 매크로는 그렇지 않습니다.</p>
</blockquote>
<div class="rule" id="r-input.tokenization"><a class="rule-link" href="input-format.html#r-input.tokenization" title="input.tokenization"><span>[input<wbr>.tokenization]<span/></a></div>
<h2 id="토큰화"><a class="header" href="#토큰화">토큰화</a></h2>
<p>결과 문자 시퀀스는 이 장의 나머지 부분에 설명된 대로 토큰으로 변환됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-lex.keywords"><a class="rule-link" href="keywords.html#r-lex.keywords" title="lex.keywords"><span>[lex<wbr>.keywords]<span/></a></div>
<h1 id="키워드"><a class="header" href="#키워드">키워드</a></h1>
<p>러스트는 키워드를 세 가지 범주로 나눕니다:</p>
<ul>
<li><a href="keywords.html#strict-keywords">엄격</a></li>
<li><a href="keywords.html#reserved-keywords">예약됨</a></li>
<li><a href="keywords.html#weak-keywords">약함</a></li>
</ul>
<div class="rule" id="r-lex.keywords.strict"><a class="rule-link" href="keywords.html#r-lex.keywords.strict" title="lex.keywords.strict"><span>[lex<wbr>.keywords<wbr>.strict]<span/></a></div>
<h2 id="엄격한-키워드"><a class="header" href="#엄격한-키워드">엄격한 키워드</a></h2>
<div class="rule" id="r-lex.keywords.strict.intro"><a class="rule-link" href="keywords.html#r-lex.keywords.strict.intro" title="lex.keywords.strict.intro"><span>[lex<wbr>.keywords<wbr>.strict<wbr>.intro]<span/></a></div>
<p>이 키워드는 올바른 컨텍스트에서만 사용할 수 있습니다. 다음 이름으로는 사용할 수 없습니다:</p>
<ul>
<li><a href="items.html">아이템</a></li>
<li><a href="variables.html">변수</a> 및 함수 매개변수</li>
<li>필드 및 <a href="items/enumerations.html">변형</a></li>
<li><a href="types/parameters.html">타입 매개변수</a></li>
<li>라이프타임 매개변수 또는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
<li><a href="macros.html">매크로</a> 또는 <a href="attributes.html">속성</a></li>
<li><a href="macros-by-example.html">매크로 플레이스홀더</a></li>
<li><a href="crates-and-source-files.html">크레이트</a></li>
</ul>
<div class="rule" id="r-lex.keywords.strict.list"><a class="rule-link" href="keywords.html#r-lex.keywords.strict.list" title="lex.keywords.strict.list"><span>[lex<wbr>.keywords<wbr>.strict<wbr>.list]<span/></a></div>
<blockquote>
<p><strong><sup>렉서:<sup></strong><br />
KW_AS             : <code>as</code><br />
KW_BREAK          : <code>break</code><br />
KW_CONST          : <code>const</code><br />
KW_CONTINUE       : <code>continue</code><br />
KW_CRATE          : <code>crate</code><br />
KW_ELSE           : <code>else</code><br />
KW_ENUM           : <code>enum</code><br />
KW_EXTERN         : <code>extern</code><br />
KW_FALSE          : <code>false</code><br />
KW_FN             : <code>fn</code><br />
KW_FOR            : <code>for</code><br />
KW_IF             : <code>if</code><br />
KW_IMPL           : <code>impl</code><br />
KW_IN             : <code>in</code><br />
KW_LET            : <code>let</code><br />
KW_LOOP           : <code>loop</code><br />
KW_MATCH          : <code>match</code><br />
KW_MOD            : <code>mod</code><br />
KW_MOVE           : <code>move</code><br />
KW_MUT            : <code>mut</code><br />
KW_PUB            : <code>pub</code><br />
KW_REF            : <code>ref</code><br />
KW_RETURN         : <code>return</code><br />
KW_SELFVALUE      : <code>self</code><br />
KW_SELFTYPE       : <code>Self</code><br />
KW_STATIC         : <code>static</code><br />
KW_STRUCT         : <code>struct</code><br />
KW_SUPER          : <code>super</code><br />
KW_TRAIT          : <code>trait</code><br />
KW_TRUE           : <code>true</code><br />
KW_TYPE           : <code>type</code><br />
KW_UNSAFE         : <code>unsafe</code><br />
KW_USE            : <code>use</code><br />
KW_WHERE          : <code>where</code><br />
KW_WHILE          : <code>while</code></p>
</blockquote>
<div class="rule" id="r-lex.keywords.strict.edition2018"><a class="rule-link" href="keywords.html#r-lex.keywords.strict.edition2018" title="lex.keywords.strict.edition2018"><span>[lex<wbr>.keywords<wbr>.strict<wbr>.edition2018]<span/></a></div>
<p>다음 키워드는 2018년 에디션부터 추가되었습니다.</p>
<blockquote>
<p><strong><sup>렉서 2018+</sup></strong><br />
KW_ASYNC          : <code>async</code><br />
KW_AWAIT          : <code>await</code><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<div class="rule" id="r-lex.keywords.reserved"><a class="rule-link" href="keywords.html#r-lex.keywords.reserved" title="lex.keywords.reserved"><span>[lex<wbr>.keywords<wbr>.reserved]<span/></a></div>
<h2 id="예약된-키워드"><a class="header" href="#예약된-키워드">예약된 키워드</a></h2>
<div class="rule" id="r-lex.keywords.reserved.intro"><a class="rule-link" href="keywords.html#r-lex.keywords.reserved.intro" title="lex.keywords.reserved.intro"><span>[lex<wbr>.keywords<wbr>.reserved<wbr>.intro]<span/></a></div>
<p>이 키워드들은 아직 사용되지 않지만, 미래를 위해 예약되어 있습니다. 이 키워드들은 엄격한 키워드와 동일한 제약 조건을 가집니다. 이 키워드들을 사용하지 못하게 함으로써 현재 프로그램이 미래 버전의 Rust와 호환되도록 하기 위함입니다.</p>
<div class="rule" id="r-lex.keywords.reserved.list"><a class="rule-link" href="keywords.html#r-lex.keywords.reserved.list" title="lex.keywords.reserved.list"><span>[lex<wbr>.keywords<wbr>.reserved<wbr>.list]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
KW_ABSTRACT       : <code>abstract</code><br />
KW_BECOME         : <code>become</code><br />
KW_BOX            : <code>box</code><br />
KW_DO             : <code>do</code><br />
KW_FINAL          : <code>final</code><br />
KW_MACRO          : <code>macro</code><br />
KW_OVERRIDE       : <code>override</code><br />
KW_PRIV           : <code>priv</code><br />
KW_TYPEOF         : <code>typeof</code><br />
KW_UNSIZED        : <code>unsized</code><br />
KW_VIRTUAL        : <code>virtual</code><br />
KW_YIELD          : <code>yield</code></p>
</blockquote>
<div class="rule" id="r-lex.keywords.reserved.edition2018"><a class="rule-link" href="keywords.html#r-lex.keywords.reserved.edition2018" title="lex.keywords.reserved.edition2018"><span>[lex<wbr>.keywords<wbr>.reserved<wbr>.edition2018]<span/></a></div>
<p>다음 키워드는 2018년 에디션부터 예약되었습니다.</p>
<blockquote>
<p><strong><sup>렉서 2018+</sup></strong><br />
KW_TRY   : <code>try</code></p>
</blockquote>
<p>다음 키워드는 2024년 에디션부터 예약되었습니다.</p>
<blockquote>
<p><strong><sup>렉서 2024+</sup></strong><br />
KW_GEN   : <code>gen</code></p>
</blockquote>
<div class="rule" id="r-lex.keywords.weak"><a class="rule-link" href="keywords.html#r-lex.keywords.weak" title="lex.keywords.weak"><span>[lex<wbr>.keywords<wbr>.weak]<span/></a></div>
<h2 id="약한-키워드"><a class="header" href="#약한-키워드">약한 키워드</a></h2>
<div class="rule" id="r-lex.keywords.weak.intro"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.intro" title="lex.keywords.weak.intro"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.intro]<span/></a></div>
<p>이 키워드는 특정 컨텍스트에서만 특별한 의미를 가집니다. 예를 들어, <code>union</code>이라는 이름으로 변수나 메서드를 선언할 수 있습니다.</p>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
KW_MACRO_RULES    : <code>macro_rules</code><br />
KW_UNION          : <code>union</code><br />
KW_STATICLIFETIME : <code>'static</code><br />
KW_SAFE           : <code>safe</code><br />
KW_RAW            : <code>raw</code></p>
<p><strong><sup>렉서 2015</sup></strong><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<div class="rule" id="r-lex.keywords.weak.macro_rules"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.macro_rules" title="lex.keywords.weak.macro_rules"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.macro_rules]<span/></a></div>
<ul>
<li><code>macro_rules</code>는 사용자 정의 <a href="macros.html">매크로</a>를 생성하는 데 사용됩니다.</li>
</ul>
<div class="rule" id="r-lex.keywords.weak.union"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.union" title="lex.keywords.weak.union"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.union]<span/></a></div>
<ul>
<li><code>union</code>은 <a href="items/unions.html">유니온</a>을 선언하는 데 사용되며, 유니온 선언에서 사용될 때만 키워드입니다.</li>
</ul>
<div class="rule" id="r-lex.keywords.weak.lifetime-static"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.lifetime-static" title="lex.keywords.weak.lifetime-static"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.lifetime-static]<span/></a></div>
<ul>
<li>
<p><code>'static</code>은 정적 라이프타임에 사용되며, <a href="items/generics.html">제네릭 라이프타임 매개변수</a> 또는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a>로 사용될 수 없습니다.</p>
<pre><code class="language-compile_fail">// error[E0262]: 잘못된 라이프타임 매개변수 이름: `'static`
fn invalid_lifetime_parameter&lt;'static&gt;(s: &amp;'static str) -&gt; &amp;'static str { s }
</code></pre>
</li>
</ul>
<div class="rule" id="r-lex.keywords.weak.dyn"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.dyn" title="lex.keywords.weak.dyn"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.dyn]<span/></a></div>
<ul>
<li>
<p>2015년 에디션에서 <a href="types/trait-object.html"><code>dyn</code></a>은 <code>::</code> 또는 <code>&lt;</code>로 시작하지 않는 경로, 라이프타임, 물음표, <code>for</code> 키워드 또는 여는 괄호가 뒤따르는 타입 위치에서 사용될 때 키워드입니다.</p>
<p>2018년 에디션부터 <code>dyn</code>은 엄격한 키워드로 승격되었습니다.</p>
</li>
</ul>
<div class="rule" id="r-lex.keywords.weak.safe"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.safe" title="lex.keywords.weak.safe"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.safe]<span/></a></div>
<ul>
<li><code>safe</code>는 함수와 정적에 사용되며, <a href="items/external-blocks.html">외부 블록</a>에서 의미를 가집니다.</li>
</ul>
<div class="rule" id="r-lex.keywords.weak.raw"><a class="rule-link" href="keywords.html#r-lex.keywords.weak.raw" title="lex.keywords.weak.raw"><span>[lex<wbr>.keywords<wbr>.weak<wbr>.raw]<span/></a></div>
<ul>
<li><code>raw</code>는 <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용 연산자</a>에 사용되며, 원시 차용 연산자 형식(예: <code>&amp;raw const expr</code> 또는 <code>&amp;raw mut expr</code>)과 일치할 때만 키워드입니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-ident"><a class="rule-link" href="identifiers.html#r-ident" title="ident"><span>[ident]<span/></a></div>
<h1 id="식별자"><a class="header" href="#식별자">식별자</a></h1>
<div class="rule" id="r-ident.syntax"><a class="rule-link" href="identifiers.html#r-ident.syntax" title="ident.syntax"><span>[ident<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서:</sup></strong><br />
식별자_또는_키워드 :<br />
      XID_시작 XID_계속<sup>*</sup><br />
   | <code>_</code> XID_계속<sup>+</sup></p>
<p>RAW_IDENTIFIER : <code>r#</code> 식별자_또는_키워드 <sub><em><code>crate</code>, <code>self</code>, <code>super</code>, <code>Self</code> 제외</em></sub></p>
<p>비_키워드_식별자 : 식별자_또는_키워드 <sub><em><a href="keywords.html#strict-keywords">엄격한</a> 또는 <a href="keywords.html#reserved-keywords">예약된</a> 키워드 제외</em></sub></p>
<p>식별자 :<br />
비_키워드_식별자 | 원시_식별자</p>
<p>예약된_원시_식별자 : <code>r#_</code></p>
</blockquote>
<!-- When updating the version, update the UAX links, too. -->
<div class="rule" id="r-ident.unicode"><a class="rule-link" href="identifiers.html#r-ident.unicode" title="ident.unicode"><span>[ident<wbr>.unicode]<span/></a></div>
<p>식별자는 유니코드 버전 16.0의 <a href="https://www.unicode.org/reports/tr31/tr31-41.html">유니코드 표준 부록 #31</a> 사양을 따르며, 아래에 설명된 추가 사항이 있습니다. 식별자의 몇 가지 예:</p>
<ul>
<li><code>foo</code></li>
<li><code>_identifier</code></li>
<li><code>r#true</code></li>
<li><code>Москва</code></li>
<li><code>東京</code></li>
</ul>
<div class="rule" id="r-ident.profile"><a class="rule-link" href="identifiers.html#r-ident.profile" title="ident.profile"><span>[ident<wbr>.profile]<span/></a></div>
<p>UAX #31에서 사용된 프로필은 다음과 같습니다:</p>
<ul>
<li>시작 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Start</code></a>, 더하기 밑줄 문자 (U+005F)</li>
<li>계속 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Continue</code></a></li>
<li>중간 := 비어 있음</li>
</ul>
<p>단일 밑줄 문자는 식별자가 아니라는 추가 제약 조건과 함께.</p>
<blockquote>
<p><strong>참고</strong>: 밑줄로 시작하는 식별자는 일반적으로 의도적으로 사용되지 않는 식별자를 나타내는 데 사용되며, <code>rustc</code>의 사용되지 않는 경고를 억제합니다.</p>
</blockquote>
<div class="rule" id="r-ident.keyword"><a class="rule-link" href="identifiers.html#r-ident.keyword" title="ident.keyword"><span>[ident<wbr>.keyword]<span/></a></div>
<p>식별자는 아래 <a href="identifiers.html#raw-identifiers">원시 식별자</a>에 설명된 <code>r#</code> 접두사 없이 <a href="keywords.html#strict-keywords">엄격한</a> 또는 <a href="keywords.html#reserved-keywords">예약된</a> 키워드일 수 없습니다.</p>
<div class="rule" id="r-ident.zero-width-chars"><a class="rule-link" href="identifiers.html#r-ident.zero-width-chars" title="ident.zero-width-chars"><span>[ident<wbr>.zero-width-chars]<span/></a></div>
<p>제로 너비 비결합자(ZWNJ U+200C) 및 제로 너비 결합자(ZWJ U+200D) 문자는 식별자에 허용되지 않습니다.</p>
<div class="rule" id="r-ident.ascii-limitations"><a class="rule-link" href="identifiers.html#r-ident.ascii-limitations" title="ident.ascii-limitations"><span>[ident<wbr>.ascii-limitations]<span/></a></div>
<p>식별자는 다음 상황에서 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Start</code></a> 및 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Continue</code></a>의 ASCII 서브셋으로 제한됩니다:</p>
<ul>
<li><a href="items/extern-crates.html"><code>extern crate</code></a> 선언 (<em>AsClause</em> 식별자 제외)</li>
<li><a href="paths.html">경로</a>에서 참조되는 외부 크레이트 이름</li>
<li><a href="items/modules.html#the-path-attribute"><code>path</code> 속성</a> 없이 파일 시스템에서 로드된 <a href="items/modules.html">모듈</a> 이름</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> 속성 항목</li>
<li><a href="items/external-blocks.html">외부 블록</a>의 아이템 이름</li>
</ul>
<div class="rule" id="r-ident.normalization"><a class="rule-link" href="identifiers.html#r-ident.normalization" title="ident.normalization"><span>[ident<wbr>.normalization]<span/></a></div>
<h2 id="정규화"><a class="header" href="#정규화">정규화</a></h2>
<p>식별자는 <a href="https://www.unicode.org/reports/tr15/tr15-56.html">유니코드 표준 부록 #15</a>에 정의된 정규화 형식 C(NFC)를 사용하여 정규화됩니다. 두 식별자는 NFC 형식이 같으면 동일합니다.</p>
<p><a href="procedural-macros.html">절차적</a> 및 <a href="macros-by-example.html">선언적</a> 매크로는 입력에서 정규화된 식별자를 받습니다.</p>
<div class="rule" id="r-ident.raw"><a class="rule-link" href="identifiers.html#r-ident.raw" title="ident.raw"><span>[ident<wbr>.raw]<span/></a></div>
<h2 id="원시-식별자"><a class="header" href="#원시-식별자">원시 식별자</a></h2>
<div class="rule" id="r-ident.raw.intro"><a class="rule-link" href="identifiers.html#r-ident.raw.intro" title="ident.raw.intro"><span>[ident<wbr>.raw<wbr>.intro]<span/></a></div>
<p>원시 식별자는 일반 식별자와 같지만 <code>r#</code> 접두사가 붙습니다. (<code>r#</code> 접두사는 실제 식별자의 일부로 포함되지 않습니다.)</p>
<div class="rule" id="r-ident.raw.allowed"><a class="rule-link" href="identifiers.html#r-ident.raw.allowed" title="ident.raw.allowed"><span>[ident<wbr>.raw<wbr>.allowed]<span/></a></div>
<p>일반 식별자와 달리, 원시 식별자는 <code>RAW_IDENTIFIER</code>에 대해 위에 나열된 키워드를 제외한 모든 엄격하거나 예약된 키워드일 수 있습니다.</p>
<div class="rule" id="r-ident.raw.reserved"><a class="rule-link" href="identifiers.html#r-ident.raw.reserved" title="ident.raw.reserved"><span>[ident<wbr>.raw<wbr>.reserved]<span/></a></div>
<p><a href="patterns.html#wildcard-pattern"><em>와일드카드 패턴</em></a>과의 혼동을 피하기 위해 RESERVED_RAW_IDENTIFIER 토큰 <code>r#_</code>를 사용하는 것은 오류입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-comments.syntax"><a class="rule-link" href="comments.html#r-comments.syntax" title="comments.syntax"><span>[comments<wbr>.syntax]<span/></a></div>
<h1 id="주석"><a class="header" href="#주석">주석</a></h1>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
라인_주석 :<br />
      <code>//</code> (~[<code>/</code> <code>!</code> <code>\n</code>] | <code>//</code>) ~<code>\n</code><sup>*</sup><br />
   | <code>//</code></p>
<p>블록_주석 :<br />
      <code>/*</code> (~[<code>*</code> <code>!</code>] | <code>**</code> | <em>블록주석또는문서</em>) (<em>블록주석또는문서</em> | ~<code>*/</code>)<sup>*</sup> <code>*/</code><br />
   | <code>/**/</code><br />
   | <code>/***/</code></p>
<p>INNER_LINE_DOC :<br />
   <code>//!</code> ~[<code>\n</code> <em>고립된CR</em>]<sup>*</sup></p>
<p>내부_블록_문서 :<br />
   <code>/*!</code> ( <em>블록주석또는문서</em> | ~[<code>*/</code> <em>고립된CR</em>] )<sup>*</sup> <code>*/</code></p>
<p>OUTER_LINE_DOC :<br />
   <code>///</code> (~<code>/</code> ~[<code>\n</code> <em>IsolatedCR</em>]<sup>*</sup>)<sup>?</sup></p>
<p>OUTER_BLOCK_DOC :<br />
   <code>/**</code> (~<code>*</code> | <em>BlockCommentOrDoc</em> ) (<em>BlockCommentOrDoc</em> | ~[<code>*/</code> <em>IsolatedCR</em>])<sup>*</sup> <code>*/</code></p>
<p><em>블록주석또는문서</em> :<br />
      블록_주석<br />
   | 외부_블록_문서<br />
   | 내부_블록_문서</p>
<p><em>고립된CR</em> :<br />
   \r</p>
</blockquote>
<div class="rule" id="r-comments.normal"><a class="rule-link" href="comments.html#r-comments.normal" title="comments.normal"><span>[comments<wbr>.normal]<span/></a></div>
<h2 id="비-문서-주석"><a class="header" href="#비-문서-주석">비 문서 주석</a></h2>
<p>주석은 일반적인 C++ 스타일의 라인 (<code>//</code>) 및 블록 (<code>/* ... */</code>) 주석 형식을 따릅니다. 중첩된 블록 주석이 지원됩니다.</p>
<div class="rule" id="r-comments.normal.tokenization"><a class="rule-link" href="comments.html#r-comments.normal.tokenization" title="comments.normal.tokenization"><span>[comments<wbr>.normal<wbr>.tokenization]<span/></a></div>
<p>비 문서 주석은 공백의 한 형태로 해석됩니다.</p>
<div class="rule" id="r-comments.doc"><a class="rule-link" href="comments.html#r-comments.doc" title="comments.doc"><span>[comments<wbr>.doc]<span/></a></div>
<h2 id="문서-주석"><a class="header" href="#문서-주석">문서 주석</a></h2>
<div class="rule" id="r-comments.doc.syntax"><a class="rule-link" href="comments.html#r-comments.doc.syntax" title="comments.doc.syntax"><span>[comments<wbr>.doc<wbr>.syntax]<span/></a></div>
<p>정확히 세 개의 슬래시(<code>///</code>)로 시작하는 라인 문서 주석과 블록 문서 주석(<code>/** ... */</code>), 이 두 가지 외부 문서 주석은 <a href="../rustdoc/the-doc-attribute.html"><code>doc</code> 속성</a>을 위한 특별한 구문으로 해석됩니다.</p>
<div class="rule" id="r-comments.doc.attributes"><a class="rule-link" href="comments.html#r-comments.doc.attributes" title="comments.doc.attributes"><span>[comments<wbr>.doc<wbr>.attributes]<span/></a></div>
<p>즉, 이들은 주석 본문 주위에 <code>#[doc="..."]</code>를 작성하는 것과 동일합니다. 즉, <code>/// Foo</code>는 <code>#[doc="Foo"]</code>로, <code>/** Bar */</code>는 <code>#[doc="Bar"]</code>로 바뀝니다. 따라서 외부 속성을 허용하는 것 앞에 나타나야 합니다.</p>
<div class="rule" id="r-comments.doc.inner-syntax"><a class="rule-link" href="comments.html#r-comments.doc.inner-syntax" title="comments.doc.inner-syntax"><span>[comments<wbr>.doc<wbr>.inner-syntax]<span/></a></div>
<p><code>//!</code>로 시작하는 라인 주석과 <code>/*! ... */</code> 블록 주석은 뒤따르는 항목이 아닌 주석의 부모에 적용되는 문서 주석입니다.</p>
<div class="rule" id="r-comments.doc.inner-attributes"><a class="rule-link" href="comments.html#r-comments.doc.inner-attributes" title="comments.doc.inner-attributes"><span>[comments<wbr>.doc<wbr>.inner-attributes]<span/></a></div>
<p>즉, 이들은 주석 본문 주위에 <code>#![doc="..."]</code>를 작성하는 것과 동일합니다. <code>//!</code> 주석은 일반적으로 소스 파일을 차지하는 모듈을 문서화하는 데 사용됩니다.</p>
<div class="rule" id="r-comments.doc.bare-crs"><a class="rule-link" href="comments.html#r-comments.doc.bare-crs" title="comments.doc.bare-crs"><span>[comments<wbr>.doc<wbr>.bare-crs]<span/></a></div>
<p>문서 주석에는 <code>U+000D</code> (CR) 문자가 허용되지 않습니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustdoc</code>에서 예상하는 바와 같이 문서 주석에 마크다운을 포함하는 것이 일반적입니다. 그러나 주석 구문은 내부 마크다운을 존중하지 않습니다. <code>/** `glob = "*/*.rs";` */</code>는 첫 번째 <code>*/</code>에서 주석을 종료하며, 나머지 코드는 구문 오류를 발생시킵니다. 이는 라인 문서 주석에 비해 블록 문서 주석의 내용을 약간 제한합니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: <code>U+000D</code> (CR) 문자와 그 뒤에 바로 오는 <code>U+000A</code> (LF) 문자의 시퀀스는 이전에 단일 <code>U+000A</code> (LF)로 변환되었을 것입니다.</p>
</blockquote>
<h2 id="예시"><a class="header" href="#예시">예시</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! 이 크레이트의 암시적 익명 모듈에 적용되는 문서 주석

pub mod outer_module {

    //!  - 내부 라인 문서
    //!! - 여전히 내부 라인 문서 (하지만 시작에 느낌표가 있음)

    /*!  - 내부 블록 문서 */
    /*!! - 여전히 내부 블록 문서 (하지만 시작에 느낌표가 있음) */

    //   - 단순 주석
    ///  - 외부 라인 문서 (정확히 슬래시 3개)
    //// - 단순 주석

    /*   - 단순 주석 */
    /**  - 외부 블록 문서 (정확히) 별표 2개 */
    /*** - 단순 주석 */

    pub mod inner_module {}

    pub mod nested_comments {
        /* Rust에서는 /* /* 주석을 중첩할 수 있습니다 */ */ */

        // 세 가지 유형의 블록 주석은 다른 유형 내에 포함되거나 중첩될 수 있습니다:

        /*   /* */  /** */  /*! */  */
        /*!  /* */  /** */  /*! */  */
        /**  /* */  /** */  /*! */  */
        pub mod dummy_item {}
    }

    pub mod degenerate_cases {
        // 비어 있는 내부 라인 문서
        //!

        // 비어 있는 내부 블록 문서
        /*!*/

        // 비어 있는 라인 주석
        //

        // 비어 있는 외부 라인 문서
        ///

        // 비어 있는 블록 주석
        /**/

        pub mod dummy_item {}

        // 비어 있는 2-별표 블록은 문서 블록이 아니라 블록 주석입니다.
        /***/

    }

    /* 다음은 외부 문서 주석이 문서를 받을 항목을 요구하기 때문에 허용되지 않습니다 */

    /// 내 항목은 어디에 있나요?
<span class="boring">  mod boo {}
</span>}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-lex.whitespace"><a class="rule-link" href="whitespace.html#r-lex.whitespace" title="lex.whitespace"><span>[lex<wbr>.whitespace]<span/></a></div>
<h1 id="공백"><a class="header" href="#공백">공백</a></h1>
<div class="rule" id="r-lex.whitespace.intro"><a class="rule-link" href="whitespace.html#r-lex.whitespace.intro" title="lex.whitespace.intro"><span>[lex<wbr>.whitespace<wbr>.intro]<span/></a></div>
<p>공백은 <a href="https://www.unicode.org/reports/tr31/"><code>Pattern_White_Space</code></a> 유니코드 속성을 가진 문자만 포함하는 비어 있지 않은 문자열입니다. 즉:</p>
<ul>
<li><code>U+0009</code> (수평 탭, <code>'\t'</code>)</li>
<li><code>U+000A</code> (줄 바꿈, <code>'\n'</code>)</li>
<li><code>U+000B</code> (수직 탭)</li>
<li><code>U+000C</code> (폼 피드)</li>
<li><code>U+000D</code> (캐리지 리턴, <code>'\r'</code>)</li>
<li><code>U+0020</code> (공백, <code>' '</code>)</li>
<li><code>U+0085</code> (다음 줄)</li>
<li><code>U+200E</code> (좌에서 우로 마크)</li>
<li><code>U+200F</code> (우에서 좌로 마크)</li>
<li><code>U+2028</code> (줄 구분자)</li>
<li><code>U+2029</code> (단락 구분자)</li>
</ul>
<div class="rule" id="r-lex.whitespace.token-sep"><a class="rule-link" href="whitespace.html#r-lex.whitespace.token-sep" title="lex.whitespace.token-sep"><span>[lex<wbr>.whitespace<wbr>.token-sep]<span/></a></div>
<p>Rust는 “자유 형식” 언어입니다. 즉, 모든 형태의 공백은 문법에서 _토큰_을 구분하는 역할만 하며, 의미론적 중요성은 없습니다.</p>
<div class="rule" id="r-lex.whitespace.replacement"><a class="rule-link" href="whitespace.html#r-lex.whitespace.replacement" title="lex.whitespace.replacement"><span>[lex<wbr>.whitespace<wbr>.replacement]<span/></a></div>
<p>Rust 프로그램은 각 공백 요소가 단일 공백 문자처럼 다른 유효한 공백 요소로 대체되어도 동일한 의미를 가집니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-lex.token"><a class="rule-link" href="tokens.html#r-lex.token" title="lex.token"><span>[lex<wbr>.token]<span/></a></div>
<h1 id="토큰"><a class="header" href="#토큰">토큰</a></h1>
<div class="rule" id="r-lex.token.intro"><a class="rule-link" href="tokens.html#r-lex.token.intro" title="lex.token.intro"><span>[lex<wbr>.token<wbr>.intro]<span/></a></div>
<p>토큰은 정규 (비재귀) 언어로 정의된 문법의 기본 생성물입니다. Rust 소스 입력은 다음 종류의 토큰으로 나눌 수 있습니다:</p>
<ul>
<li><a href="keywords.html">키워드</a></li>
<li><a href="identifiers.html">식별자</a></li>
<li><a href="tokens.html#literals">리터럴</a></li>
<li><a href="tokens.html#lifetimes-and-loop-labels">라이프타임</a></li>
<li><a href="tokens.html#punctuation">구두점</a></li>
<li><a href="tokens.html#delimiters">구분자</a></li>
</ul>
<p>이 문서의 문법에서 “단순” 토큰은 <a href="notation.html#string-table-productions">문자열 테이블 생성</a> 형식으로 주어지며, <code>monospace</code> 글꼴로 나타납니다.</p>
<div class="rule" id="r-lex.token.literal"><a class="rule-link" href="tokens.html#r-lex.token.literal" title="lex.token.literal"><span>[lex<wbr>.token<wbr>.literal]<span/></a></div>
<h2 id="리터럴"><a class="header" href="#리터럴">리터럴</a></h2>
<p>리터럴은 <a href="expressions/literal-expr.html">리터럴 표현식</a>에 사용되는 토큰입니다.</p>
<h3 id="예시-1"><a class="header" href="#예시-1">예시</a></h3>
<h4 id="문자와-문자열"><a class="header" href="#문자와-문자열">문자와 문자열</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>예시</th><th><code>#</code> 세트<sup class="footnote-reference"><a href="#nsets">1</a></sup></th><th>문자</th><th>이스케이프</th></tr></thead><tbody>
<tr><td><a href="tokens.html#character-literals">문자</a></td><td><code>'H'</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#string-literals">문자열</a></td><td><code>"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#raw-string-literals">원시 문자열</a></td><td><code>r#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#byte-literals">바이트</a></td><td><code>b'H'</code></td><td>0</td><td>모든 ASCII</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a></td></tr>
<tr><td><a href="tokens.html#byte-string-literals">바이트 문자열</a></td><td><code>b"hello"</code></td><td>0</td><td>모든 ASCII</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a></td></tr>
<tr><td><a href="tokens.html#raw-byte-string-literals">원시 바이트 문자열</a></td><td><code>br#"hello"#</code></td><td>&lt;256</td><td>모든 ASCII</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#c-string-literals">C 문자열</a></td><td><code>c"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#raw-c-string-literals">원시 C 문자열</a></td><td><code>cr#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nsets"><sup class="footnote-definition-label">1</sup>
<p>동일한 리터럴의 각 면에 있는 <code>#</code>의 수는 동일해야 합니다.</p>
</div>
<blockquote>
<p><strong>참고</strong>: 문자 및 문자열 리터럴 토큰은 <code>U+000D</code> (CR) 뒤에 <code>U+000A</code> (LF)가 즉시 오는 시퀀스를 포함하지 않습니다. 이 쌍은 이전에 단일 <code>U+000A</code> (LF)로 변환되었을 것입니다.</p>
</blockquote>
<h4 id="ascii-이스케이프"><a class="header" href="#ascii-이스케이프">ASCII 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x41</code></td><td>7비트 문자 코드 (정확히 2자리, 최대 0x7F)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="바이트-이스케이프"><a class="header" href="#바이트-이스케이프">바이트 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x7F</code></td><td>8비트 문자 코드 (정확히 2자리)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="유니코드-이스케이프"><a class="header" href="#유니코드-이스케이프">유니코드 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\u{7FFF}</code></td><td>24비트 유니코드 문자 코드 (최대 6자리)</td></tr>
</tbody></table>
</div>
<h4 id="인용-이스케이프"><a class="header" href="#인용-이스케이프">인용 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\'</code></td><td>작은따옴표</td></tr>
<tr><td>큰따옴표</td><td>큰따옴표</td></tr>
</tbody></table>
</div>
<h4 id="숫자"><a class="header" href="#숫자">숫자</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="tokens.html#number-literals">숫자 리터럴</a><sup class="footnote-reference"><a href="#nl">2</a></sup></th><th>예시</th><th>지수</th></tr></thead><tbody>
<tr><td>10진수 정수</td><td><code>98_222</code></td><td><code>N/A</code></td></tr>
<tr><td>16진수 정수</td><td><code>0xff</code></td><td><code>N/A</code></td></tr>
<tr><td>8진수 정수</td><td><code>0o77</code></td><td><code>N/A</code></td></tr>
<tr><td>2진수 정수</td><td><code>0b1111_0000</code></td><td><code>N/A</code></td></tr>
<tr><td>부동 소수점</td><td><code>123.0E+77</code></td><td><code>선택 사항</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nl"><sup class="footnote-definition-label">2</sup>
<p>모든 숫자 리터럴은 <code>_</code>를 시각적 구분자로 허용합니다: <code>1_234.0E+18f64</code></p>
</div>
<div class="rule" id="r-lex.token.literal.suffix"><a class="rule-link" href="tokens.html#r-lex.token.literal.suffix" title="lex.token.literal.suffix"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix]<span/></a></div>
<h4 id="접미사"><a class="header" href="#접미사">접미사</a></h4>
<div class="rule" id="r-lex.token.literal.literal.suffix.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.literal.suffix.intro" title="lex.token.literal.literal.suffix.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.literal<wbr>.suffix<wbr>.intro]<span/></a></div>
<p>접미사는 리터럴의 주요 부분 뒤에 오는 문자 시퀀스(중간 공백 없이)로, 비원시 식별자 또는 키워드와 동일한 형태입니다.</p>
<div class="rule" id="r-lex.token.literal.suffix.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.suffix.syntax" title="lex.token.literal.suffix.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
SUFFIX : 식별자_또는_키워드<br />
SUFFIX_NO_E : SUFFIX <sub><em><code>e</code> 또는 <code>E</code>로 시작하지 않음</em></sub><strong><sup>렉서</sup></strong><br />
SUFFIX : 식별자_또는_키워드<br />
SUFFIX_NO_E : SUFFIX <sub><em><code>e</code> 또는 <code>E</code>로 시작하지 않음</em></sub></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.suffix.validity"><a class="rule-link" href="tokens.html#r-lex.token.literal.suffix.validity" title="lex.token.literal.suffix.validity"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.validity]<span/></a></div>
<p>어떤 종류의 리터럴(문자열, 정수 등)이든 어떤 접미사와 함께 사용되어도 유효한 토큰입니다.</p>
<p>어떤 접미사가 붙은 리터럴 토큰도 오류 없이 매크로에 전달될 수 있습니다. 매크로 자체는 그러한 토큰을 해석하는 방법과 오류를 발생시킬지 여부를 결정합니다. 특히, 예제 매크로의 <code>literal</code> 프래그먼트 지정자는 임의의 접미사가 붙은 리터럴 토큰과 일치합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! blackhole { ($tt:tt) =&gt; () }
macro_rules! blackhole_lit { ($l:literal) =&gt; () }

blackhole!("string"suffix); // OK
blackhole_lit!(1suffix); // OK
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.suffix.parse"><a class="rule-link" href="tokens.html#r-lex.token.literal.suffix.parse" title="lex.token.literal.suffix.parse"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.parse]<span/></a></div>
<p>그러나 리터럴 표현식 또는 패턴으로 해석되는 리터럴 토큰의 접미사는 제한됩니다. 비숫자 리터럴 토큰의 모든 접미사는 거부되며, 숫자 리터럴 토큰은 아래 목록의 접미사만 허용됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>정수</th><th>부동 소수점</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, <code>isize</code></td><td><code>f32</code>, <code>f64</code></td></tr>
</tbody></table>
</div>
<h3 id="문자-및-문자열-리터럴"><a class="header" href="#문자-및-문자열-리터럴">문자 및 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.literal.char"><a class="rule-link" href="tokens.html#r-lex.token.literal.char" title="lex.token.literal.char"><span>[lex<wbr>.token<wbr>.literal<wbr>.char]<span/></a></div>
<h4 id="문자-리터럴"><a class="header" href="#문자-리터럴">문자 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.char.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.char.syntax" title="lex.token.literal.char.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.char<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
CHAR_LITERAL :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) <code>'</code> SUFFIX<sup>?</sup><strong><sup>렉서</sup></strong><br />
CHAR_LITERAL :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) <code>'</code> SUFFIX<sup>?</sup></p>
<p>QUOTE_ESCAPE :<br />
   <code>\'</code> | <code>\"</code></p>
<p>ASCII_ESCAPE :<br />
      <code>\x</code> 8진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code>ASCII_ESCAPE :<br />
      <code>\x</code> 8진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code></p>
<p>UNICODE_ESCAPE :<br />
   <code>\u{</code> ( 16진수_숫자 <code>_</code><sup><em></sup> )<sup>1..6</sup> <code>}</code>UNICODE_ESCAPE :<br />
   <code>\u{</code> ( 16진수_숫자 <code>_</code><sup></em></sup> )<sup>1..6</sup> <code>}</code></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.char.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.char.intro" title="lex.token.literal.char.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.char<wbr>.intro]<span/></a></div>
<p>_문자 리터럴_은 두 개의 <code>U+0027</code>(작은따옴표) 문자 안에 묶인 단일 유니코드 문자입니다. 단, <code>U+0027</code> 자체는 선행하는 <code>U+005C</code> 문자(<code>\</code>)로 _이스케이프_되어야 합니다.</p>
<div class="rule" id="r-lex.token.literal.str"><a class="rule-link" href="tokens.html#r-lex.token.literal.str" title="lex.token.literal.str"><span>[lex<wbr>.token<wbr>.literal<wbr>.str]<span/></a></div>
<h4 id="문자열-리터럴"><a class="header" href="#문자열-리터럴">문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.str.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.str.syntax" title="lex.token.literal.str.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
STRING_LITERAL :<br />
   <code>"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em>]<br />
      | QUOTE_ESCAPE<br />
      | ASCII_ESCAPE<br />
      | UNICODE_ESCAPE<br />
      | STRING_CONTINUE<br />
   )<sup><em></sup> <code>"</code> SUFFIX<sup>?</sup><strong><sup>렉서</sup></strong><br />
STRING_LITERAL :<br />
   <code>"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em>]<br />
      | QUOTE_ESCAPE<br />
      | ASCII_ESCAPE<br />
      | UNICODE_ESCAPE<br />
      | STRING_CONTINUE<br />
   )<sup></em></sup> <code>"</code> SUFFIX<sup>?</sup></p>
<p>STRING_CONTINUE :<br />
   <code>\</code> <em>뒤에</em> \nSTRING_CONTINUE :<br />
   <code>\</code> <em>뒤에</em> \n</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.str.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.str.intro" title="lex.token.literal.str.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.intro]<span/></a></div>
<p>_문자열 리터럴_은 두 개의 <code>U+0022</code>(큰따옴표) 문자 안에 묶인 모든 유니코드 문자 시퀀스입니다. 단, <code>U+0022</code> 자체는 선행하는 <code>U+005C</code> 문자(<code>\</code>)로 _이스케이프_되어야 합니다.</p>
<div class="rule" id="r-lex.token.literal.str.linefeed"><a class="rule-link" href="tokens.html#r-lex.token.literal.str.linefeed" title="lex.token.literal.str.linefeed"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.literal.char-escape"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape" title="lex.token.literal.char-escape"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape]<span/></a></div>
<h4 id="문자-이스케이프"><a class="header" href="#문자-이스케이프">문자 이스케이프</a></h4>
<div class="rule" id="r-lex.token.literal.char-escape.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.intro" title="lex.token.literal.char-escape.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.intro]<span/></a></div>
<p>문자 또는 비원시 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.literal.char-escape.ascii"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.ascii" title="lex.token.literal.char-escape.ascii"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.ascii]<span/></a></div>
<ul>
<li>_7비트 코드 포인트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, <code>0x7F</code>까지의 값을 가진 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 값을 가진 ASCII 문자를 나타냅니다. 더 높은 값은 유니코드 코드 포인트를 의미하는지 바이트 값을 의미하는지 모호하기 때문에 허용되지 않습니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.unicode"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.unicode" title="lex.token.literal.char-escape.unicode"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.unicode]<span/></a></div>
<ul>
<li>_24비트 코드 포인트 이스케이프_는 <code>U+0075</code>(<code>u</code>)로 시작하며, <code>U+007B</code>(<code>{</code>)와 <code>U+007D</code>(<code>}</code>) 중괄호로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.whitespace"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.whitespace" title="lex.token.literal.char-escape.whitespace"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 유니코드 값 <code>U+000A</code>(LF), <code>U+000D</code>(CR) 또는 <code>U+0009</code>(HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.null"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.null" title="lex.token.literal.char-escape.null"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.null]<span/></a></div>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 유니코드 값 <code>U+0000</code>(NUL)을 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.slash"><a class="rule-link" href="tokens.html#r-lex.token.literal.char-escape.slash" title="lex.token.literal.char-escape.slash"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote itself.</li>
</ul>
<div class="rule" id="r-lex.token.literal.str-raw"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-raw" title="lex.token.literal.str-raw"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw]<span/></a></div>
<h4 id="원시-문자열-리터럴"><a class="header" href="#원시-문자열-리터럴">원시 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.str-raw.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-raw.syntax" title="lex.token.literal.str-raw.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_STRING_LITERAL :<br />
   <code>r</code> 원시_문자열_내용 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
RAW_STRING_LITERAL :<br />
   <code>r</code> 원시_문자열_내용 접미사<sup>?</sup></p>
<p>RAW_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_문자열_내용 <code>#</code>RAW_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_문자열_내용 <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.str-raw.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-raw.intro" title="lex.token.literal.str-raw.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.intro]<span/></a></div>
<p>원시 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 <code>U+0072</code>(<code>r</code>) 문자로 시작하며, 256개 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.literal.str-raw.body"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-raw.body" title="lex.token.literal.str-raw.body"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.body]<span/></a></div>
<p>_원시 문자열 본문_은 <code>U+000D</code>(CR)를 제외한 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.literal.str-raw.content"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-raw.content" title="lex.token.literal.str-raw.content"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.content]<span/></a></div>
<p>원시 문자열 본문에 포함된 모든 유니코드 문자는 그 자체를 나타내며, <code>U+0022</code>(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<p>문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="바이트-및-바이트-문자열-리터럴"><a class="header" href="#바이트-및-바이트-문자열-리터럴">바이트 및 바이트 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.byte"><a class="rule-link" href="tokens.html#r-lex.token.byte" title="lex.token.byte"><span>[lex<wbr>.token<wbr>.byte]<span/></a></div>
<h4 id="바이트-리터럴"><a class="header" href="#바이트-리터럴">바이트 리터럴</a></h4>
<div class="rule" id="r-lex.token.byte.syntax"><a class="rule-link" href="tokens.html#r-lex.token.byte.syntax" title="lex.token.byte.syntax"><span>[lex<wbr>.token<wbr>.byte<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
BYTE_LITERAL :<br />
   <code>b'</code> ( ASCII_FOR_CHAR | BYTE_ESCAPE )  <code>'</code> 접미사<sup>?</sup></p>
<p>ASCII_FOR_CHAR :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>'</code>, <code>\</code>, \n, \r 또는 \t 제외_</p>
<p>BYTE_ESCAPE :<br />
      <code>\x</code> 16진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code> | <code>\'</code> | <code>\"</code></p>
</blockquote>
<div class="rule" id="r-lex.token.byte.intro"><a class="rule-link" href="tokens.html#r-lex.token.byte.intro" title="lex.token.byte.intro"><span>[lex<wbr>.token<wbr>.byte<wbr>.intro]<span/></a></div>
<p>_바이트 리터럴_은 <code>U+0062</code>(<code>b</code>)와 <code>U+0027</code>(작은따옴표) 문자로 시작하고 <code>U+0027</code> 문자로 끝나는 단일 ASCII 문자(<code>U+0000</code>에서 <code>U+007F</code> 범위) 또는 단일 _이스케이프_입니다. <code>U+0027</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 이는 <code>u8</code> 부호 없는 8비트 정수 _숫자 리터럴_과 동일합니다.</p>
<div class="rule" id="r-lex.token.str-byte"><a class="rule-link" href="tokens.html#r-lex.token.str-byte" title="lex.token.str-byte"><span>[lex<wbr>.token<wbr>.str-byte]<span/></a></div>
<h4 id="바이트-문자열-리터럴"><a class="header" href="#바이트-문자열-리터럴">바이트 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-byte.syntax"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.syntax" title="lex.token.str-byte.syntax"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
BYTE_STRING_LITERAL :<br />
   <code>b"</code> ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup><em></sup> <code>"</code> 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
BYTE_STRING_LITERAL :<br />
   <code>b"</code> ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup></em></sup> <code>"</code> 접미사<sup>?</sup></p>
<p>ASCII_FOR_STRING :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>"</code>, <code>\</code> _및 IsolatedCR 제외_ASCII_FOR_STRING :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>"</code>, <code>\</code> <em>및 IsolatedCR 제외</em></p>
</blockquote>
<div class="rule" id="r-lex.token.str-byte.intro"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.intro" title="lex.token.str-byte.intro"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.intro]<span/></a></div>
<p>비원시 _바이트 문자열 리터럴_은 <code>U+0062</code>(<code>b</code>)와 <code>U+0022</code>(큰따옴표) 문자로 시작하고 <code>U+0022</code> 문자로 끝나는 ASCII 문자와 <em>이스케이프</em> 시퀀스입니다. <code>U+0022</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 또는 바이트 문자열 리터럴은 아래에 정의된 _원시 바이트 문자열 리터럴_일 수 있습니다.</p>
<div class="rule" id="r-lex.token.str-byte.linefeed"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.linefeed" title="lex.token.str-byte.linefeed"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 바이트 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 바이트 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.str-byte.escape"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.escape" title="lex.token.str-byte.escape"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape]<span/></a></div>
<p>바이트 또는 비원시 바이트 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.str-byte.escape-byte"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.escape-byte" title="lex.token.str-byte.escape-byte"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-byte]<span/></a></div>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-whitespace"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.escape-whitespace" title="lex.token.str-byte.escape-whitespace"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-null"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.escape-null" title="lex.token.str-byte.escape-null"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-null]<span/></a></div>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 바이트 값 <code>0x00</code>(ASCII NUL)을 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-slash"><a class="rule-link" href="tokens.html#r-lex.token.str-byte.escape-slash" title="lex.token.str-byte.escape-slash"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte-raw"><a class="rule-link" href="tokens.html#r-lex.token.str-byte-raw" title="lex.token.str-byte-raw"><span>[lex<wbr>.token<wbr>.str-byte-raw]<span/></a></div>
<h4 id="원시-바이트-문자열-리터럴"><a class="header" href="#원시-바이트-문자열-리터럴">원시 바이트 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-byte-raw.syntax"><a class="rule-link" href="tokens.html#r-lex.token.str-byte-raw.syntax" title="lex.token.str-byte-raw.syntax"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_BYTE_STRING_LITERAL :<br />
   <code>br</code> 원시_바이트_문자열_내용 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
RAW_BYTE_STRING_LITERAL :<br />
   <code>br</code> 원시_바이트_문자열_내용 접미사<sup>?</sup></p>
<p>RAW_BYTE_STRING_CONTENT :<br />
      <code>"</code> ASCII_FOR_RAW<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_바이트_문자열_내용 <code>#</code>RAW_BYTE_STRING_CONTENT :<br />
      <code>"</code> ASCII_FOR_RAW<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_바이트_문자열_내용 <code>#</code></p>
<p>ASCII_FOR_RAW :<br />
   _모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외_ASCII_FOR_RAW :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외</em></p>
</blockquote>
<div class="rule" id="r-lex.token.str-byte-raw.intro"><a class="rule-link" href="tokens.html#r-lex.token.str-byte-raw.intro" title="lex.token.str-byte-raw.intro"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.intro]<span/></a></div>
<p>원시 바이트 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 <code>U+0062</code>(<code>b</code>) 문자로 시작하고 <code>U+0072</code>(<code>r</code>) 문자가 뒤따르며, 256개 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-byte-raw.body"><a class="rule-link" href="tokens.html#r-lex.token.str-byte-raw.body" title="lex.token.str-byte-raw.body"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.body]<span/></a></div>
<p>_원시 문자열 본문_은 <code>U+000D</code>(CR)를 제외한 모든 ASCII 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다. 원시 바이트 문자열 리터럴은 비 ASCII 바이트를 포함할 수 없습니다.</p>
<div class="rule" id="r-lex.token.literal.str-byte-raw.content"><a class="rule-link" href="tokens.html#r-lex.token.literal.str-byte-raw.content" title="lex.token.literal.str-byte-raw.content"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-byte-raw<wbr>.content]<span/></a></div>
<p>원시 문자열 본문에 포함된 모든 문자는 ASCII 인코딩을 나타내며, <code>U+0022</code>(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<p>바이트 문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="c-문자열-및-원시-c-문자열-리터럴"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴">C 문자열 및 원시 C 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.str-c"><a class="rule-link" href="tokens.html#r-lex.token.str-c" title="lex.token.str-c"><span>[lex<wbr>.token<wbr>.str-c]<span/></a></div>
<h4 id="c-문자열-리터럴"><a class="header" href="#c-문자열-리터럴">C 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-c.syntax"><a class="rule-link" href="tokens.html#r-lex.token.str-c.syntax" title="lex.token.str-c.syntax"><span>[lex<wbr>.token<wbr>.str-c<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
C_STRING_LITERAL :<br />
   <code>c"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em> <em>NUL</em>]<br />
      | BYTE_ESCAPE <em>단, <code>\0</code> 또는 <code>\x00</code> 제외</em><br />
      | UNICODE_ESCAPE <em>단, <code>\u{0}</code>, <code>\u{00}</code>, …, <code>\u{000000}</code> 제외</em><br />
      | STRING_CONTINUE<br />
   )<sup><em></sup> <code>"</code> 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
C_STRING_LITERAL :<br />
   <code>c"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em> <em>NUL</em>]<br />
      | BYTE_ESCAPE <em>단, <code>\0</code> 또는 <code>\x00</code> 제외</em><br />
      | UNICODE_ESCAPE <em>단, <code>\u{0}</code>, <code>\u{00}</code>, …, <code>\u{000000}</code> 제외</em><br />
      | STRING_CONTINUE<br />
   )<sup></em></sup> <code>"</code> 접미사<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.str-c.intro"><a class="rule-link" href="tokens.html#r-lex.token.str-c.intro" title="lex.token.str-c.intro"><span>[lex<wbr>.token<wbr>.str-c<wbr>.intro]<span/></a></div>
<p>_C 문자열 리터럴_은 <code>U+0063</code>(<code>c</code>)과 <code>U+0022</code>(큰따옴표) 문자로 시작하고 <code>U+0022</code> 문자로 끝나는 유니코드 문자와 <em>이스케이프</em> 시퀀스입니다. <code>U+0022</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 또는 C 문자열 리터럴은 아래에 정의된 _원시 C 문자열 리터럴_일 수 있습니다.</p>
<div class="rule" id="r-lex.token.str-c.null"><a class="rule-link" href="tokens.html#r-lex.token.str-c.null" title="lex.token.str-c.null"><span>[lex<wbr>.token<wbr>.str-c<wbr>.null]<span/></a></div>
<p>C 문자열은 바이트 <code>0x00</code>으로 암시적으로 종료되므로, C 문자열 리터럴 <code>c""</code>는 바이트 문자열 리터럴 <code>b"\x00"</code>에서 <code>&amp;CStr</code>를 수동으로 구성하는 것과 동일합니다. 암시적 종료자를 제외하고, 바이트 <code>0x00</code>은 C 문자열 내에서 허용되지 않습니다.</p>
<div class="rule" id="r-lex.token.str-c.linefeed"><a class="rule-link" href="tokens.html#r-lex.token.str-c.linefeed" title="lex.token.str-c.linefeed"><span>[lex<wbr>.token<wbr>.str-c<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 C 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 C 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.str-c.escape"><a class="rule-link" href="tokens.html#r-lex.token.str-c.escape" title="lex.token.str-c.escape"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape]<span/></a></div>
<p>비원시 C 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.str-c.escape-byte"><a class="rule-link" href="tokens.html#r-lex.token.str-c.escape-byte" title="lex.token.str-c.escape-byte"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-byte]<span/></a></div>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-unicode"><a class="rule-link" href="tokens.html#r-lex.token.str-c.escape-unicode" title="lex.token.str-c.escape-unicode"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-unicode]<span/></a></div>
<ul>
<li>_24비트 코드 포인트 이스케이프_는 <code>U+0075</code>(<code>u</code>)로 시작하고 중괄호 <code>U+007B</code>(<code>{</code>) 및 <code>U+007D</code>(<code>}</code>)로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타내며 UTF-8로 인코딩됩니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-whitespace"><a class="rule-link" href="tokens.html#r-lex.token.str-c.escape-whitespace" title="lex.token.str-c.escape-whitespace"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-slash"><a class="rule-link" href="tokens.html#r-lex.token.str-c.escape-slash" title="lex.token.str-c.escape-slash"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.char-unicode"><a class="rule-link" href="tokens.html#r-lex.token.str-c.char-unicode" title="lex.token.str-c.char-unicode"><span>[lex<wbr>.token<wbr>.str-c<wbr>.char-unicode]<span/></a></div>
<p>C 문자열은 정의된 인코딩이 없는 바이트를 나타내지만 C 문자열 리터럴에는 <code>U+007F</code> 이상의 유니코드 문자가 포함될 수 있습니다. 이러한 문자는 해당 문자의 UTF-8 표현 바이트로 대체됩니다.</p>
<p>다음 C 문자열 리터럴은 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"æ";        // 라틴어 소문자 AE (U+00E6)
c"\u{00E6}";
c"\xC3\xA6";
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.str-c.edition2021"><a class="rule-link" href="tokens.html#r-lex.token.str-c.edition2021" title="lex.token.str-c.edition2021"><span>[lex<wbr>.token<wbr>.str-c<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>c""</code> 토큰이 <code>c ""</code>로 분석됩니다.</p>
</blockquote>
<div class="rule" id="r-lex.token.str-c-raw"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw" title="lex.token.str-c-raw"><span>[lex<wbr>.token<wbr>.str-c-raw]<span/></a></div>
<h4 id="원시-c-문자열-리터럴"><a class="header" href="#원시-c-문자열-리터럴">원시 C 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-c-raw.syntax"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw.syntax" title="lex.token.str-c-raw.syntax"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_C_STRING_LITERAL :<br />
   <code>cr</code> RAW_C_STRING_CONTENT 접미사<sup>?</sup></p>
<p>RAW_C_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> <em>NUL</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> RAW_C_STRING_CONTENT <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.str-c-raw.intro"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw.intro" title="lex.token.str-c-raw.intro"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.intro]<span/></a></div>
<p>원시 C 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. <code>U+0063</code>(<code>c</code>) 문자로 시작하고 <code>U+0072</code>(<code>r</code>) 문자가 뒤따르며, 256자 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.body"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw.body" title="lex.token.str-c-raw.body"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.body]<span/></a></div>
<p>_원시 C 문자열 본문_은 <code>U+0000</code>(NUL) 및 <code>U+000D</code>(CR) 이외의 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.content"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw.content" title="lex.token.str-c-raw.content"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.content]<span/></a></div>
<p>원시 C 문자열 본문에 포함된 모든 문자는 UTF-8 인코딩으로 자신을 나타냅니다. <code>U+0022</code>(큰따옴표) 문자(원시 C 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.edition2021"><a class="rule-link" href="tokens.html#r-lex.token.str-c-raw.edition2021" title="lex.token.str-c-raw.edition2021"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 원시 C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>cr""</code> 토큰이 <code>cr ""</code>로, <code>cr#""#</code>는 <code>cr #""#</code>(문법에 맞지 않음)로 어휘 분석됩니다.</p>
</blockquote>
<h4 id="c-문자열-및-원시-c-문자열-리터럴의-예"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴의-예">C 문자열 및 원시 C 문자열 리터럴의 예</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"foo"; cr"foo";                     // foo
c"\"foo\""; cr#""foo""#;             // "foo"

c"foo #\"# bar";
cr##"foo #"# bar"##;                 // foo #"# bar

c"\x52"; c"R"; cr"R";                // R
c"\\x52"; cr"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.num"><a class="rule-link" href="tokens.html#r-lex.token.literal.num" title="lex.token.literal.num"><span>[lex<wbr>.token<wbr>.literal<wbr>.num]<span/></a></div>
<h3 id="숫자-리터럴"><a class="header" href="#숫자-리터럴">숫자 리터럴</a></h3>
<p>_숫자 리터럴_은 <em>정수 리터럴</em> 또는 _부동 소수점 리터럴_입니다. 두 종류의 리터럴을 인식하는 문법은 혼합되어 있습니다.</p>
<div class="rule" id="r-lex.token.literal.int"><a class="rule-link" href="tokens.html#r-lex.token.literal.int" title="lex.token.literal.int"><span>[lex<wbr>.token<wbr>.literal<wbr>.int]<span/></a></div>
<h4 id="정수-리터럴"><a class="header" href="#정수-리터럴">정수 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.int.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.syntax" title="lex.token.literal.int.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
INTEGER_LITERAL :<br />
   ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) SUFFIX_NO_E<sup>?</sup></p>
<p>DEC_LITERAL :<br />
   DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>BIN_LITERAL :<br />
   <code>0b</code> (BIN_DIGIT|<code>_</code>)<sup><em></sup> BIN_DIGIT (BIN_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>OCT_LITERAL :<br />
   <code>0o</code> (OCT_DIGIT|<code>_</code>)<sup><em></sup> OCT_DIGIT (OCT_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>HEX_LITERAL :<br />
   <code>0x</code> (HEX_DIGIT|<code>_</code>)<sup><em></sup> HEX_DIGIT (HEX_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>BIN_DIGIT : [<code>0</code>-<code>1</code>]</p>
<p>OCT_DIGIT : [<code>0</code>-<code>7</code>]</p>
<p>DEC_DIGIT : [<code>0</code>-<code>9</code>]</p>
<p>HEX_DIGIT : [<code>0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F</code>]</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.int.kind"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.kind" title="lex.token.literal.int.kind"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind]<span/></a></div>
<p>_정수 리터럴_은 네 가지 형태 중 하나를 갖습니다.</p>
<div class="rule" id="r-lex.token.literal.int.kind-dec"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.kind-dec" title="lex.token.literal.int.kind-dec"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-dec]<span/></a></div>
<ul>
<li>_십진수 리터럴_은 _십진수 숫자_로 시작하고 _십진수 숫자_와 _밑줄_의 혼합으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-hex"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.kind-hex" title="lex.token.literal.int.kind-hex"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-hex]<span/></a></div>
<ul>
<li>_16진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0078</code>(<code>0x</code>)로 시작하고 16진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-oct"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.kind-oct" title="lex.token.literal.int.kind-oct"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-oct]<span/></a></div>
<ul>
<li>_8진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+006F</code>(<code>0o</code>)로 시작하고 8진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-bin"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.kind-bin" title="lex.token.literal.int.kind-bin"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-bin]<span/></a></div>
<ul>
<li>_2진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0062</code>(<code>0b</code>)로 시작하고 2진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.restriction"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.restriction" title="lex.token.literal.int.restriction"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.restriction]<span/></a></div>
<p>모든 리터럴과 마찬가지로 정수 리터럴 뒤에는 위에서 설명한 대로 접미사가 (공백 없이) 바로 올 수 있습니다. 접미사는 <code>e</code> 또는 <code>E</code>로 시작할 수 없습니다. 이는 부동 소수점 리터럴의 지수로 해석되기 때문입니다. 이러한 접미사의 효과에 대해서는 <a href="expressions/literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>을 참조하십시오.</p>
<p>리터럴 표현식으로 허용되는 정수 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(overflowing_literals)]
</span>123;
123i32;
123u32;
123_u32;

0xff;
0xff_u8;
0x01_f32; // 정수 7986, 부동 소수점 1.0 아님
0x01_e3;  // 정수 483, 부동 소수점 1000.0 아님

0o70;
0o70_i16;

0b1111_1111_1001_0000;
0b1111_1111_1001_0000i64;
0b________1;

0usize;

// 이것들은 타입에 비해 너무 크지만, 리터럴 표현식으로 허용됩니다.
128_i8;
256_u8;

// 이것은 정수 리터럴이며, 부동 소수점 리터럴 표현식으로 허용됩니다.
5f32;
<span class="boring">}</span></code></pre></pre>
<p>예를 들어 <code>-1i8</code>은 <code>-</code>와 <code>1i8</code>의 두 토큰으로 분석됩니다.</p>
<p>리터럴 표현식으로 허용되지 않는 정수 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>0invalidSuffix;
123AFB43;
0b010a;
0xAB_CD_EF_GH;
0b1111_f32;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.int.tuple-field"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.tuple-field" title="lex.token.literal.int.tuple-field"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field]<span/></a></div>
<h4 id="튜플-인덱스"><a class="header" href="#튜플-인덱스">튜플 인덱스</a></h4>
<div class="rule" id="r-lex.token.literal.int.tuple-field.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.tuple-field.syntax" title="lex.token.literal.int.tuple-field.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
TUPLE_INDEX:<br />
   INTEGER_LITERAL</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.int.tuple-field.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.tuple-field.intro" title="lex.token.literal.int.tuple-field.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.intro]<span/></a></div>
<p>튜플 인덱스는 <a href="types/tuple.html">튜플</a>, <a href="items/structs.html">튜플 구조체</a> 및 <a href="items/enumerations.html">튜플 변형</a>의 필드를 참조하는 데 사용됩니다.</p>
<div class="rule" id="r-lex.token.literal.int.tuple-field.eq"><a class="rule-link" href="tokens.html#r-lex.token.literal.int.tuple-field.eq" title="lex.token.literal.int.tuple-field.eq"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.eq]<span/></a></div>
<p>튜플 인덱스는 리터럴 토큰과 직접 비교됩니다. 튜플 인덱스는 <code>0</code>으로 시작하고 각 연속 인덱스는 값을 1씩 10진수 값으로 증가시킵니다. 따라서 10진수 값만 일치하며 값에 추가 <code>0</code> 접두사 문자가 없어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example = (개, "cat", 말);
let dog = example.0;
let cat = example.1;
// 다음 예제는 유효하지 않습니다.
let cat = example.01;  // 오류: `01`이라는 필드가 없습니다
let horse = example.0b10;  // 오류: `0b10`이라는 필드가 없습니다
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 튜플 인덱스에는 특정 접미사가 포함될 수 있지만 이는 유효하도록 의도된 것이 아니며 향후 버전에서 제거될 수 있습니다. 자세한 내용은 <a href="https://github.com/rust-lang/rust/issues/60210">https://github.com/rust-lang/rust/issues/60210</a>을 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.float"><a class="rule-link" href="tokens.html#r-lex.token.literal.float" title="lex.token.literal.float"><span>[lex<wbr>.token<wbr>.literal<wbr>.float]<span/></a></div>
<h4 id="부동-소수점-리터럴"><a class="header" href="#부동-소수점-리터럴">부동 소수점 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.float.syntax"><a class="rule-link" href="tokens.html#r-lex.token.literal.float.syntax" title="lex.token.literal.float.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
FLOAT_LITERAL :<br />
      DEC_LITERAL <code>.</code> <em>(not immediately followed by <code>.</code>, <code>_</code> or an XID_Start character)</em><br />
   | DEC_LITERAL <code>.</code> DEC_LITERAL SUFFIX_NO_E<sup>?</sup><br />
   | DEC_LITERAL (<code>.</code> DEC_LITERAL)<sup>?</sup> FLOAT_EXPONENT SUFFIX<sup>?</sup></p>
<p>FLOAT_EXPONENT :<br />
   (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup> (DEC_DIGIT|<code>_</code>)<sup>*</sup> DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.float.form"><a class="rule-link" href="tokens.html#r-lex.token.literal.float.form" title="lex.token.literal.float.form"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.form]<span/></a></div>
<p>_부동 소수점 리터럴_은 두 가지 형태 중 하나를 갖습니다.</p>
<ul>
<li><em>십진수 리터럴</em> 뒤에 마침표 문자 <code>U+002E</code>(<code>.</code>)가 옵니다. 선택적으로 다른 십진수 리터럴과 선택적 _지수_가 뒤따를 수 있습니다.</li>
<li>단일 <em>십진수 리터럴</em> 뒤에 _지수_가 옵니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.float.suffix"><a class="rule-link" href="tokens.html#r-lex.token.literal.float.suffix" title="lex.token.literal.float.suffix"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.suffix]<span/></a></div>
<p>정수 리터럴과 마찬가지로 부동 소수점 리터럴 뒤에는 접미사가 올 수 있습니다. 단, 접미사 앞부분이 <code>U+002E</code>(<code>.</code>)로 끝나지 않아야 합니다. 리터럴에 지수가 포함되지 않은 경우 접미사는 <code>e</code> 또는 <code>E</code>로 시작할 수 없습니다. 이러한 접미사의 효과에 대해서는 <a href="expressions/literal-expr.html#floating-point-literal-expressions">부동 소수점 리터럴 표현식</a>을 참조하십시오.</p>
<p>리터럴 표현식으로 허용되는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;
0.1f64;
0.1f32;
12E+99_f64;
let x: f64 = 2.;
<span class="boring">}</span></code></pre></pre>
<p>마지막 예는 마침표로 끝나는 부동 소수점 리터럴에 접미사 구문을 사용할 수 없기 때문에 다릅니다. <code>2.f64</code>는 <code>2</code>에서 <code>f64</code>라는 이름의 메서드를 호출하려고 시도합니다.</p>
<p>예를 들어 <code>-1.0</code>은 <code>-</code>와 <code>1.0</code>의 두 토큰으로 분석됩니다.</p>
<p>리터럴 표현식으로 허용되지 않는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>2.0f80;
2e5f80;
2e5e6;
2.0e5e6;
1.3e10u64;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.reserved"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved" title="lex.token.literal.reserved"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved]<span/></a></div>
<h4 id="숫자-리터럴과-유사한-예약된-형식"><a class="header" href="#숫자-리터럴과-유사한-예약된-형식">숫자 리터럴과 유사한 예약된 형식</a></h4>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RESERVED_NUMBER :<br />
      BIN_LITERAL [<code>2</code>-<code>9</code>​]<br />
   | OCT_LITERAL [<code>8</code>-<code>9</code>​]<br />
   | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) <code>.</code><br />
         <em>(바로 뒤에 <code>.</code>, <code>_</code> 또는 XID_시작 문자가 오지 않음)</em><br />
   | ( BIN_LITERAL | OCT_LITERAL ) (<code>e</code>|<code>E</code>)<br />
   | <code>0b</code> <code>_</code><sup>*</sup> <em>입력의 끝 또는 2진수_숫자가 아님</em><br />
   | <code>0o</code> <code>_</code><sup>*</sup> <em>입력의 끝 또는 8진수_숫자가 아님</em><br />
   | <code>0x</code> <code>_</code><sup>*</sup> <em>입력의 끝 또는 16진수_숫자가 아님</em><br />
   | DEC_LITERAL ( . DEC_LITERAL)<sup>?</sup> (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup> <em>입력의 끝 또는 10진수_숫자가 아님</em></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.reserved.intro"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.intro" title="lex.token.literal.reserved.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.intro]<span/></a></div>
<p>숫자 리터럴과 유사한 다음 어휘 형식은 _예약된 형식_입니다. 이들이 제기하는 모호성 때문에 토크나이저는 이를 별도의 토큰으로 해석하는 대신 거부합니다.</p>
<div class="rule" id="r-lex.token.literal.reserved.out-of-range"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.out-of-range" title="lex.token.literal.reserved.out-of-range"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.out-of-range]<span/></a></div>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 해당 기수 범위를 벗어나는 10진수 숫자가 오는 경우.</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.period"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.period" title="lex.token.literal.reserved.period"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.period]<span/></a></div>
<ul>
<li>접미사가 없는 2진수, 8진수 또는 16진수 리터럴 뒤에 공백 없이 마침표 문자가 오는 경우(마침표 뒤에 오는 내용에 대한 제한은 부동 소수점 리터럴과 동일).</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.exp"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.exp" title="lex.token.literal.reserved.exp"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.exp]<span/></a></div>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 <code>e</code> 또는 <code>E</code> 문자가 오는 경우.</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.empty-with-radix"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.empty-with-radix" title="lex.token.literal.reserved.empty-with-radix"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.empty-with-radix]<span/></a></div>
<ul>
<li>기수 접두사 중 하나로 시작하지만 유효한 2진수, 8진수 또는 16진수 리터럴이 아닌 입력 (숫자를 포함하지 않기 때문에).</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.empty-exp"><a class="rule-link" href="tokens.html#r-lex.token.literal.reserved.empty-exp" title="lex.token.literal.reserved.empty-exp"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.empty-exp]<span/></a></div>
<ul>
<li>지수에 숫자가 없는 부동 소수점 리터럴 형식을 갖는 입력.</li>
</ul>
<p>예약된 형식의 예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0b0102;  // 이것은 `0b010` 뒤에 `2`가 오는 것이 아닙니다
0o1279;  // 이것은 `0o127` 뒤에 `9`가 오는 것이 아닙니다
0x80.0;  // 이것은 `0x80` 뒤에 `.`와 `0`이 오는 것이 아닙니다
0b101e;  // 이것은 접미사가 붙은 리터럴이 아니거나, `0b101` 뒤에 `e`가 오는 것이 아닙니다
0b;      // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b`가 오는 것이 아닙니다
0b_;     // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b_`가 오는 것이 아닙니다
2e;      // 이것은 부동 소수점 리터럴이 아니거나, `2` 뒤에 `e`가 오는 것이 아닙니다
2.0e;    // 이것은 부동 소수점 리터럴이 아니거나, `2.0` 뒤에 `e`가 오는 것이 아닙니다
2em;     // 이것은 접미사가 붙은 리터럴이 아니거나, `2` 뒤에 `em`이 오는 것이 아닙니다
2.0em;   // 이것은 접미사가 붙은 리터럴이 아니거나, `2.0` 뒤에 `em`이 오는 것이 아닙니다
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.life"><a class="rule-link" href="tokens.html#r-lex.token.life" title="lex.token.life"><span>[lex<wbr>.token<wbr>.life]<span/></a></div>
<h2 id="라이프타임과-루프-레이블"><a class="header" href="#라이프타임과-루프-레이블">라이프타임과 루프 레이블</a></h2>
<div class="rule" id="r-lex.token.life.syntax"><a class="rule-link" href="tokens.html#r-lex.token.life.syntax" title="lex.token.life.syntax"><span>[lex<wbr>.token<wbr>.life<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
LIFETIME_TOKEN :<br />
      <code>'</code> <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | <code>'_</code> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | RAW_LIFETIME</p>
<p>LIFETIME_OR_LABEL :<br />
      <code>'</code> <a href="identifiers.html">NON_KEYWORD_IDENTIFIER</a> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | RAW_LIFETIME</p>
<p>RAW_LIFETIME :<br />
   <code>'r#</code> <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <sub><em><code>crate</code>, <code>self</code>, <code>super</code>, <code>Self</code> 제외</em></sub> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em></p>
<p>RESERVED_RAW_LIFETIME : <code>'r#_</code> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em></p>
</blockquote>
<div class="rule" id="r-lex.token.life.intro"><a class="rule-link" href="tokens.html#r-lex.token.life.intro" title="lex.token.life.intro"><span>[lex<wbr>.token<wbr>.life<wbr>.intro]<span/></a></div>
<p>라이프타임 매개변수와 <a href="expressions/loop-expr.html">루프 레이블</a>은 LIFETIME_OR_LABEL 토큰을 사용합니다. 모든 LIFETIME_TOKEN은 렉서에 의해 허용되며, 예를 들어 매크로에서 사용될 수 있습니다.</p>
<div class="rule" id="r-lex.token.life.raw.intro"><a class="rule-link" href="tokens.html#r-lex.token.life.raw.intro" title="lex.token.life.raw.intro"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.intro]<span/></a></div>
<p>원시 라이프타임은 일반 라이프타임과 같지만 식별자 앞에 <code>r#</code> 접두사가 붙습니다. (<code>r#</code> 접두사는 실제 라이프타임의 일부로 포함되지 않습니다.)</p>
<div class="rule" id="r-lex.token.life.raw.allowed"><a class="rule-link" href="tokens.html#r-lex.token.life.raw.allowed" title="lex.token.life.raw.allowed"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.allowed]<span/></a></div>
<p>일반 라이프타임과 달리 원시 라이프타임은 <code>RAW_LIFETIME</code>에 대해 위에 나열된 키워드를 제외한 모든 엄격하거나 예약된 키워드일 수 있습니다.</p>
<div class="rule" id="r-lex.token.life.raw.reserved"><a class="rule-link" href="tokens.html#r-lex.token.life.raw.reserved" title="lex.token.life.raw.reserved"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.reserved]<span/></a></div>
<p><a href="lifetime-elision.html">자리표시자 라이프타임</a>과의 혼동을 피하기 위해 RESERVED_RAW_LIFETIME 토큰 <code>'r#_</code>를 사용하는 것은 오류입니다.</p>
<div class="rule" id="r-lex.token.life.raw.edition2021"><a class="rule-link" href="tokens.html#r-lex.token.life.raw.edition2021" title="lex.token.life.raw.edition2021"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 원시 라이프타임은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>'r#lt</code> 토큰이 <code>'r # lt</code>로 어휘 분석됩니다.</p>
</blockquote>
<div class="rule" id="r-lex.token.punct"><a class="rule-link" href="tokens.html#r-lex.token.punct" title="lex.token.punct"><span>[lex<wbr>.token<wbr>.punct]<span/></a></div>
<h2 id="구두점"><a class="header" href="#구두점">구두점</a></h2>
<div class="rule" id="r-lex.token.punct.intro"><a class="rule-link" href="tokens.html#r-lex.token.punct.intro" title="lex.token.punct.intro"><span>[lex<wbr>.token<wbr>.punct<wbr>.intro]<span/></a></div>
<p>구두점 기호 토큰은 완전성을 위해 여기에 나열됩니다. 개별적인 사용법과 의미는 링크된 페이지에 정의되어 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>이름</th><th>용법</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>더하기</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">더하기</a>, <a href="trait-bounds.html">트레이트 바운드</a>, <a href="macros-by-example.html">매크로 클리니 매처</a></td></tr>
<tr><td><code>-</code></td><td>빼기</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">빼기</a>, <a href="expressions/operator-expr.html#negation-operators">부정</a></td></tr>
<tr><td><code>*</code></td><td>별</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">곱하기</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a>, <a href="macros-by-example.html">매크로 클리니 매처</a>, <a href="items/use-declarations.html">와일드카드 사용</a></td></tr>
<tr><td><code>/</code></td><td>슬래시</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">나누기</a></td></tr>
<tr><td><code>%</code></td><td>백분율</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">나머지</a></td></tr>
<tr><td><code>^</code></td><td>캐럿</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 XOR</a></td></tr>
<tr><td><code>!</code></td><td>아님</td><td><a href="expressions/operator-expr.html#negation-operators">비트 및 논리 NOT</a>, <a href="macros-by-example.html">매크로 호출</a>, <a href="attributes.html">내부 속성</a>, <a href="types/never.html">Never 유형</a>, <a href="items/implementations.html">음수 impls</a></td></tr>
<tr><td><code>&amp;</code></td><td>그리고</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 AND</a>, <a href="expressions/operator-expr.html#borrow-operators">차용</a>, <a href="types/pointer.html">참조</a>, <a href="patterns.html#reference-patterns">참조 패턴</a></td></tr>
<tr><td><code>|</code></td><td>또는</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 OR</a>, <a href="expressions/closure-expr.html">클로저</a>, <a href="expressions/match-expr.html">match</a>, <a href="expressions/if-expr.html#if-let-expressions">if let</a> 및 <a href="expressions/loop-expr.html#predicate-pattern-loops">while let</a>의 패턴</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>그리고 그리고</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 AND</a>, <a href="expressions/operator-expr.html#borrow-operators">차용</a>, <a href="types/pointer.html">참조</a>, <a href="patterns.html#reference-patterns">참조 패턴</a></td></tr>
<tr><td><code>||</code></td><td>또는 또는</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 OR</a>, <a href="expressions/closure-expr.html">클로저</a></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Shl</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">왼쪽 시프트</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Shr</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">오른쪽 시프트</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>+=</code></td><td>PlusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">덧셈 할당</a></td></tr>
<tr><td><code>-=</code></td><td>MinusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">뺄셈 할당</a></td></tr>
<tr><td><code>*=</code></td><td>StarEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">곱셈 할당</a></td></tr>
<tr><td><code>/=</code></td><td>SlashEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">나눗셈 할당</a></td></tr>
<tr><td><code>%=</code></td><td>PercentEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">나머지 할당</a></td></tr>
<tr><td><code>^=</code></td><td>CaretEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 XOR 할당</a></td></tr>
<tr><td><code>&amp;=</code></td><td>AndEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 And 할당</a></td></tr>
<tr><td><code>|=</code></td><td>OrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 Or 할당</a></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>ShlEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">왼쪽 시프트 할당</a></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>ShrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">오른쪽 시프트 할당</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>=</code></td><td>Eq</td><td><a href="expressions/operator-expr.html#assignment-expressions">할당</a>, <a href="attributes.html">속성</a>, 다양한 유형 정의</td></tr>
<tr><td><code>==</code></td><td>EqEq</td><td><a href="expressions/operator-expr.html#comparison-operators">같음</a></td></tr>
<tr><td><code>!=</code></td><td>Ne</td><td><a href="expressions/operator-expr.html#comparison-operators">같지 않음</a></td></tr>
<tr><td><code>&gt;</code></td><td>Gt</td><td><a href="expressions/operator-expr.html#comparison-operators">보다 큼</a>, <a href="items/generics.html">제네릭</a>, <a href="paths.html">경로</a></td></tr>
<tr><td><code>&lt;</code></td><td>Lt</td><td><a href="expressions/operator-expr.html#comparison-operators">보다 작음</a>, <a href="items/generics.html">제네릭</a>, <a href="paths.html">경로</a></td></tr>
<tr><td><code>&gt;=</code></td><td>Ge</td><td><a href="expressions/operator-expr.html#comparison-operators">크거나 같음</a>, <a href="items/generics.html">제네릭</a></td></tr>
<tr><td><code>&lt;=</code></td><td>Le</td><td><a href="expressions/operator-expr.html#comparison-operators">작거나 같음</a></td></tr>
<tr><td><code>@</code></td><td>At</td><td><a href="patterns.html#identifier-patterns">하위 패턴 바인딩</a></td></tr>
<tr><td><code>_</code></td><td>밑줄</td><td><a href="patterns.html#wildcard-pattern">와일드카드 패턴</a>, <a href="types/inferred.html">추론된 유형</a>, <a href="items/constant-items.html">상수</a>의 명명되지 않은 항목, <a href="items/extern-crates.html">외부 상자</a>, <a href="items/use-declarations.html">사용 선언</a> 및 <a href="expressions/underscore-expr.html">구조 해체 할당</a></td></tr>
<tr><td><code>.</code></td><td>점</td><td><a href="expressions/field-expr.html">필드 접근</a>, <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스</a></td></tr>
<tr><td><code>..</code></td><td>점점</td><td><a href="expressions/range-expr.html">범위</a>, <a href="expressions/struct-expr.html">구조체 표현식</a>, <a href="patterns.html">패턴</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>...</code></td><td>점점점</td><td><a href="items/external-blocks.html">가변 함수</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>..=</code></td><td>DotDotEq</td><td><a href="expressions/range-expr.html">포함 범위</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>,</code></td><td>쉼표</td><td>다양한 구분자</td></tr>
<tr><td><code>;</code></td><td>세미콜론</td><td>다양한 항목 및 문의 종결자, <a href="types/array.html">배열 유형</a></td></tr>
<tr><td><code>:</code></td><td>콜론</td><td>다양한 구분자</td></tr>
<tr><td><code>::</code></td><td>PathSep</td><td><a href="paths.html">경로 구분자</a></td></tr>
<tr><td><code>-&gt;</code></td><td>RArrow</td><td><a href="items/functions.html">함수 반환 유형</a>, <a href="expressions/closure-expr.html">클로저 반환 유형</a>, <a href="types/function-pointer.html">함수 포인터 유형</a></td></tr>
<tr><td><code>=&gt;</code></td><td>FatArrow</td><td><a href="expressions/match-expr.html">일치 암</a>, <a href="macros-by-example.html">매크로</a></td></tr>
<tr><td><code>&lt;-</code></td><td>LArrow</td><td>왼쪽 화살표 기호는 Rust 1.0 이전부터 사용되지 않았지만 여전히 단일 토큰으로 처리됩니다.</td></tr>
<tr><td><code>#</code></td><td>파운드</td><td><a href="attributes.html">속성</a></td></tr>
<tr><td><code>$</code></td><td>달러</td><td><a href="macros-by-example.html">매크로</a></td></tr>
<tr><td><code>?</code></td><td>물음표</td><td><a href="expressions/operator-expr.html#the-question-mark-operator">물음표 연산자</a>, <a href="trait-bounds.html#sized">크기가 의심스러운</a>, <a href="macros-by-example.html">매크로 클리니 매처</a></td></tr>
<tr><td><code>~</code></td><td>물결표</td><td>물결 연산자는 Rust 1.0 이전부터 사용되지 않았지만 토큰은 여전히 사용될 수 있습니다.</td></tr>
</tbody></table>
</div><div class="rule" id="r-lex.token.delim"><a class="rule-link" href="tokens.html#r-lex.token.delim" title="lex.token.delim"><span>[lex<wbr>.token<wbr>.delim]<span/></a></div>
<h2 id="구분자"><a class="header" href="#구분자">구분자</a></h2>
<p>대괄호 구두점은 문법의 다양한 부분에서 사용됩니다. 여는 대괄호는 항상 닫는 대괄호와 짝을 이루어야 합니다. 대괄호와 그 안의 토큰은 <a href="macros-by-example.html">매크로</a>에서 “토큰 트리“라고 합니다. 세 가지 유형의 대괄호는 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>대괄호</th><th>유형</th></tr></thead><tbody>
<tr><td><code>{</code> <code>}</code></td><td>중괄호</td></tr>
<tr><td><code>[</code> <code>]</code></td><td>대괄호</td></tr>
<tr><td><code>(</code> <code>)</code></td><td>괄호</td></tr>
</tbody></table>
</div><div class="rule" id="r-lex.token.reserved-prefix"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix" title="lex.token.reserved-prefix"><span>[lex<wbr>.token<wbr>.reserved-prefix]<span/></a></div>
<h2 id="예약된-접두사"><a class="header" href="#예약된-접두사">예약된 접두사</a></h2>
<div class="rule" id="r-lex.token.reserved-prefix.syntax"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.syntax" title="lex.token.reserved-prefix.syntax"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer 2021+</sup></strong><br />
RESERVED_TOKEN_DOUBLE_QUOTE : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>b</code> or <code>c</code> or <code>r</code> or <code>br</code> or <code>cr</code></em></sub> | <code>_</code> ) <code>"</code><br />
RESERVED_TOKEN_SINGLE_QUOTE : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>b</code></em></sub> | <code>_</code> ) <code>'</code><br />
RESERVED_TOKEN_POUND : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>r</code> or <code>br</code> or <code>cr</code></em></sub> | <code>_</code> ) <code>#</code><br />
RESERVED_TOKEN_LIFETIME : <code>'</code> (IDENTIFIER_OR_KEYWORD <sub><em>Except <code>r</code></em></sub> | _) <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.reserved-prefix.intro"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.intro" title="lex.token.reserved-prefix.intro"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.intro]<span/></a></div>
<p>_예약된 접두사_로 알려진 일부 어휘 형식은 향후 사용을 위해 예약되어 있습니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.id"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.id" title="lex.token.reserved-prefix.id"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.id]<span/></a></div>
<p>Source input which would otherwise be lexically interpreted as a non-raw identifier (or a keyword or <code>_</code>) which is immediately followed by a <code>#</code>, <code>'</code>, or <code>"</code> character (without intervening whitespace) is identified as a reserved prefix.</p>
<div class="rule" id="r-lex.token.reserved-prefix.raw-token"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.raw-token" title="lex.token.reserved-prefix.raw-token"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.raw-token]<span/></a></div>
<p>원시 식별자, 원시 문자열 리터럴 및 원시 바이트 문자열 리터럴에는 <code>#</code> 문자가 포함될 수 있지만 예약된 접두사를 포함하는 것으로 해석되지 않습니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.strings"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.strings" title="lex.token.reserved-prefix.strings"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.strings]<span/></a></div>
<p>마찬가지로 원시 문자열 리터럴, 바이트 리터럴, 바이트 문자열 리터럴, 원시 바이트 문자열 리터럴, C 문자열 리터럴 및 원시 C 문자열 리터럴에 사용되는 <code>r</code>, <code>b</code>, <code>br</code>, <code>c</code> 및 <code>cr</code> 접두사는 예약된 접두사로 해석되지 않습니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.life"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.life" title="lex.token.reserved-prefix.life"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.life]<span/></a></div>
<p>그렇지 않으면 어휘적으로 비원시 라이프타임(또는 키워드 또는 <code>_</code>)으로 해석될 소스 입력은 <code>#</code> 문자가 바로 뒤에 오는(중간 공백 없이) 경우 예약된 라이프타임 접두사로 식별됩니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.edition2021"><a class="rule-link" href="tokens.html#r-lex.token.reserved-prefix.edition2021" title="lex.token.reserved-prefix.edition2021"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션부터 예약된 접두사는 렉서에 의해 오류로 보고됩니다(특히 매크로에 전달할 수 없음).</p>
<p>2021 에디션 이전에는 예약된 접두사가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다(예: 식별자 또는 키워드에 대한 하나의 토큰 뒤에 <code>#</code> 토큰이 옴).</p>
<p>모든 에디션에서 허용되는 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a #foo}
lexes!{continue 'foo}
lexes!{match "..." {}}
lexes!{r#let#foo}         // 세 개의 토큰: r#let # foo
lexes!{'prefix #lt}
<span class="boring">}</span></code></pre></pre>
<p>2021 에디션 이전에는 허용되었지만 이후에는 거부된 예:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a#foo}
lexes!{continue'foo}
lexes!{match"..." {}}
lexes!{'prefix#lt}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-lex.token.reserved-guards"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards" title="lex.token.reserved-guards"><span>[lex<wbr>.token<wbr>.reserved-guards]<span/></a></div>
<h2 id="예약된-가드"><a class="header" href="#예약된-가드">예약된 가드</a></h2>
<div class="rule" id="r-lex.token.reserved-guards.syntax"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards.syntax" title="lex.token.reserved-guards.syntax"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer 2024+</sup></strong><br />
RESERVED_GUARDED_STRING_LITERAL : <code>#</code><sup>+</sup> <a href="tokens.html#string-literals">STRING_LITERAL</a><br />
RESERVED_POUNDS : <code>#</code><sup>2..</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.reserved-guards.intro"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards.intro" title="lex.token.reserved-guards.intro"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.intro]<span/></a></div>
<p>예약된 가드는 향후 사용을 위해 예약된 구문이며 사용하면 컴파일 오류가 발생합니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.string-literal"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards.string-literal" title="lex.token.reserved-guards.string-literal"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.string-literal]<span/></a></div>
<p>_예약된 보호된 문자열 리터럴_은 하나 이상의 <code>U+0023</code>(<code>#</code>) 토큰 바로 뒤에 <a href="tokens.html#string-literals">STRING_LITERAL</a>이 오는 토큰입니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.pounds"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards.pounds" title="lex.token.reserved-guards.pounds"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.pounds]<span/></a></div>
<p>_예약된 파운드_는 두 개 이상의 <code>U+0023</code>(<code>#</code>) 토큰입니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.edition2024"><a class="rule-link" href="tokens.html#r-lex.token.reserved-guards.edition2024" title="lex.token.reserved-guards.edition2024"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 예약된 가드가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다. 예를 들어, <code>#"foo"#</code> 형식은 세 개의 토큰으로 해석됩니다. <code>##</code>은 두 개의 토큰으로 해석됩니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-macro"><a class="rule-link" href="macros.html#r-macro" title="macro"><span>[macro]<span/></a></div>
<h1 id="매크로"><a class="header" href="#매크로">매크로</a></h1>
<div class="rule" id="r-macro.intro"><a class="rule-link" href="macros.html#r-macro.intro" title="macro.intro"><span>[macro<wbr>.intro]<span/></a></div>
<p>Rust의 기능과 구문은 매크로라는 사용자 지정 정의로 확장할 수 있습니다. 이름이 주어지고 <code>some_extension!(...)</code>과 같은 일관된 구문을 통해 호출됩니다.</p>
<p>새 매크로를 정의하는 두 가지 방법이 있습니다.</p>
<ul>
<li><a href="macros-by-example.html">예제를 통한 매크로</a>는 더 높은 수준의 선언적 방식으로 새로운 구문을 정의합니다.</li>
<li><a href="procedural-macros.html">절차적 매크로</a>는 입력 토큰에 대해 작동하는 함수를 사용하여 함수와 유사한 매크로, 사용자 지정 파생 및 사용자 지정 속성을 정의합니다.</li>
</ul>
<div class="rule" id="r-macro.invocation"><a class="rule-link" href="macros.html#r-macro.invocation" title="macro.invocation"><span>[macro<wbr>.invocation]<span/></a></div>
<h2 id="매크로-호출"><a class="header" href="#매크로-호출">매크로 호출</a></h2>
<div class="rule" id="r-macro.invocation.syntax"><a class="rule-link" href="macros.html#r-macro.invocation.syntax" title="macro.invocation.syntax"><span>[macro<wbr>.invocation<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>매크로호출</em> :<br />
   <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>!</code> <em>구분된토큰트리</em></p>
<p><em>구분된토큰트리</em> :<br />
       <code>(</code> <em>토큰트리</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>토큰트리</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>토큰트리</em><sup>*</sup> <code>}</code></p>
<p><em>토큰트리</em> :<br />
   <a href="tokens.html"><em>토큰</em></a><sub><em>단, <a href="tokens.html#delimiters">구분자</a> 제외</em></sub> | <em>구분된토큰트리</em></p>
<p><em>세미콜론매크로호출</em> :<br />
      <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>!</code> <code>(</code> <em>토큰트리</em><sup>*</sup> <code>)</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>!</code> <code>[</code> <em>토큰트리</em><sup>*</sup> <code>]</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>!</code> <code>{</code> <em>토큰트리</em><sup>*</sup> <code>}</code></p>
</blockquote>
<div class="rule" id="r-macro.invocation.intro"><a class="rule-link" href="macros.html#r-macro.invocation.intro" title="macro.invocation.intro"><span>[macro<wbr>.invocation<wbr>.intro]<span/></a></div>
<p>매크로 호출은 컴파일 타임에 매크로를 확장하고 호출을 매크로의 결과로 바꿉니다. 다음과 같은 상황에서 매크로를 호출할 수 있습니다.</p>
<div class="rule" id="r-macro.invocation.expr"><a class="rule-link" href="macros.html#r-macro.invocation.expr" title="macro.invocation.expr"><span>[macro<wbr>.invocation<wbr>.expr]<span/></a></div>
<ul>
<li><a href="expressions.html">표현식</a> 및 <a href="statements.html">문</a></li>
</ul>
<div class="rule" id="r-macro.invocation.pattern"><a class="rule-link" href="macros.html#r-macro.invocation.pattern" title="macro.invocation.pattern"><span>[macro<wbr>.invocation<wbr>.pattern]<span/></a></div>
<ul>
<li><a href="patterns.html">패턴</a></li>
</ul>
<div class="rule" id="r-macro.invocation.type"><a class="rule-link" href="macros.html#r-macro.invocation.type" title="macro.invocation.type"><span>[macro<wbr>.invocation<wbr>.type]<span/></a></div>
<ul>
<li><a href="types.html">유형</a></li>
</ul>
<div class="rule" id="r-macro.invocation.item"><a class="rule-link" href="macros.html#r-macro.invocation.item" title="macro.invocation.item"><span>[macro<wbr>.invocation<wbr>.item]<span/></a></div>
<ul>
<li><a href="items.html">항목</a> 포함 <a href="items/associated-items.html">연관 항목</a></li>
</ul>
<div class="rule" id="r-macro.invocation.nested"><a class="rule-link" href="macros.html#r-macro.invocation.nested" title="macro.invocation.nested"><span>[macro<wbr>.invocation<wbr>.nested]<span/></a></div>
<ul>
<li><a href="macros-by-example.html"><code>macro_rules</code></a> 트랜스크라이버</li>
</ul>
<div class="rule" id="r-macro.invocation.extern"><a class="rule-link" href="macros.html#r-macro.invocation.extern" title="macro.invocation.extern"><span>[macro<wbr>.invocation<wbr>.extern]<span/></a></div>
<ul>
<li><a href="items/external-blocks.html">외부 블록</a></li>
</ul>
<div class="rule" id="r-macro.invocation.item-statement"><a class="rule-link" href="macros.html#r-macro.invocation.item-statement" title="macro.invocation.item-statement"><span>[macro<wbr>.invocation<wbr>.item-statement]<span/></a></div>
<p>항목 또는 문으로 사용될 때, <em>MacroInvocationSemi</em> 형식은 중괄호를 사용하지 않을 때 끝에 세미콜론이 필요한 경우에 사용됩니다. <a href="visibility-and-privacy.html">가시성 한정자</a>는 매크로 호출 또는 <a href="macros-by-example.html"><code>macro_rules</code></a> 정의 앞에 절대 허용되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 표현식으로 사용됩니다.
let x = vec![1,2,3];

// 문으로 사용됩니다.
println!("안녕하세요!");

// 패턴에서 사용됩니다.
macro_rules! pat {
    ($i:ident) =&gt; (Some($i))
}

if let pat!(x) = Some(1) {
    assert_eq!(x, 1);
}

// 유형에서 사용됩니다.
macro_rules! Tuple {
    { $A:ty, $B:ty } =&gt; { ($A, $B) };
}

type N2 = Tuple!(i32, i32);

// 항목으로 사용됩니다.
<span class="boring">use std::cell::RefCell;
</span>thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));

// Used as an associated item.
macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; { const CONST: $t = $v; };
}
trait T {
    const_maker!{i32, 7}
}

// Macro calls within macros.
macro_rules! example {
    () =&gt; { println!("매크로 내의 매크로 호출!") };
}
// 외부 매크로 `example`이 확장된 후, 내부 매크로 `println`이 확장됩니다.
example!();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-macro.decl"><a class="rule-link" href="macros-by-example.html#r-macro.decl" title="macro.decl"><span>[macro<wbr>.decl]<span/></a></div>
<h1 id="예제를-통한-매크로"><a class="header" href="#예제를-통한-매크로">예제를 통한 매크로</a></h1>
<div class="rule" id="r-macro.decl.syntax"><a class="rule-link" href="macros-by-example.html#r-macro.decl.syntax" title="macro.decl.syntax"><span>[macro<wbr>.decl<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>MacroRulesDefinition</em> :<br />
   <code>macro_rules</code> <code>!</code> <a href="identifiers.html">IDENTIFIER</a> <em>MacroRulesDef</em></p>
<p><em>MacroRulesDef</em> :<br />
      <code>(</code> <em>MacroRules</em> <code>)</code> <code>;</code><br />
   | <code>[</code> <em>MacroRules</em> <code>]</code> <code>;</code><br />
   | <code>{</code> <em>MacroRules</em> <code>}</code></p>
<p><em>MacroRules</em> :<br />
   <em>MacroRule</em> ( <code>;</code> <em>MacroRule</em> )<sup>*</sup> <code>;</code><sup>?</sup></p>
<p><em>MacroRule</em> :<br />
   <em>MacroMatcher</em> <code>=&gt;</code> <em>MacroTranscriber</em></p>
<p><em>MacroMatcher</em> :<br />
      <code>(</code> <em>MacroMatch</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>MacroMatch</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>MacroMatch</em><sup>*</sup> <code>}</code></p>
<p><em>MacroMatch</em> :<br />
      <a href="tokens.html"><em>Token</em></a><sub><em>except <code>$</code> and <a href="tokens.html#delimiters">delimiters</a></em></sub><br />
   | <em>MacroMatcher</em><br />
   | <code>$</code> ( <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <sub><em>except <code>crate</code></em></sub> | <a href="identifiers.html">RAW_IDENTIFIER</a> | <code>_</code> ) <code>:</code> <em>MacroFragSpec</em><br />
   | <code>$</code> <code>(</code> <em>MacroMatch</em><sup>+</sup> <code>)</code> <em>MacroRepSep</em><sup>?</sup> <em>MacroRepOp</em></p>
<p><em>MacroFragSpec</em> :<br />
      <code>block</code> | <code>expr</code> | <code>expr_2021</code> | <code>ident</code> | <code>item</code> | <code>lifetime</code> | <code>literal</code><br />
   | <code>meta</code> | <code>pat</code> | <code>pat_param</code> | <code>path</code> | <code>stmt</code> | <code>tt</code> | <code>ty</code> | <code>vis</code></p>
<p><em>MacroRepSep</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>except <a href="tokens.html#delimiters">delimiters</a> and MacroRepOp</em></sub></p>
<p><em>MacroRepOp</em> :<br />
   <code>*</code> | <code>+</code> | <code>?</code></p>
<p><em>MacroTranscriber</em> :<br />
   <a href="macros.html"><em>DelimTokenTree</em></a></p>
</blockquote>
<div class="rule" id="r-macro.decl.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.intro" title="macro.decl.intro"><span>[macro<wbr>.decl<wbr>.intro]<span/></a></div>
<p><code>macro_rules</code>는 사용자가 선언적인 방식으로 구문 확장을 정의할 수 있도록 합니다.  이러한 확장을 “예제를 통한 매크로” 또는 간단히 “매크로“라고 합니다.</p>
<p>각 예제별 매크로에는 이름과 하나 이상의 _규칙_이 있습니다. 각 규칙에는 두 부분이 있습니다. 일치하는 구문을 설명하는 _매처_와 성공적으로 일치한 호출을 대체할 구문을 설명하는 _트랜스크라이버_입니다. 매처와 트랜스크라이버는 모두 구분 기호로 둘러싸여 있어야 합니다. 매크로는 표현식, 문, 항목(트레이트, impl 및 외부 항목 포함), 유형 또는 패턴으로 확장될 수 있습니다.</p>
<div class="rule" id="r-macro.decl.transcription"><a class="rule-link" href="macros-by-example.html#r-macro.decl.transcription" title="macro.decl.transcription"><span>[macro<wbr>.decl<wbr>.transcription]<span/></a></div>
<h2 id="트랜스크라이빙"><a class="header" href="#트랜스크라이빙">트랜스크라이빙</a></h2>
<div class="rule" id="r-macro.decl.transcription.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.transcription.intro" title="macro.decl.transcription.intro"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.intro]<span/></a></div>
<p>매크로가 호출되면 매크로 확장기는 이름으로 매크로 호출을 조회하고 각 매크로 규칙을 차례로 시도합니다. 첫 번째 성공적인 일치를 트랜스크라이브합니다. 이로 인해 오류가 발생하면 이후 일치는 시도되지 않습니다.</p>
<div class="rule" id="r-macro.decl.transcription.lookahead"><a class="rule-link" href="macros-by-example.html#r-macro.decl.transcription.lookahead" title="macro.decl.transcription.lookahead"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.lookahead]<span/></a></div>
<p>일치시킬 때 미리 보기를 수행하지 않습니다. 컴파일러가 한 번에 하나의 토큰으로 매크로 호출을 구문 분석하는 방법을 명확하게 결정할 수 없으면 오류입니다. 다음 예에서 컴파일러는 다음 토큰이 ’)’인지 확인하기 위해 식별자를 지나 미리 보지 않습니다. 그렇게 하면 호출을 명확하게 구문 분석할 수 있음에도 불구하고 말입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // 오류: 지역적 모호성
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.transcription.syntax"><a class="rule-link" href="macros-by-example.html#r-macro.decl.transcription.syntax" title="macro.decl.transcription.syntax"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.syntax]<span/></a></div>
<p>매처와 트랜스크라이버 모두에서 ‘$’ 토큰은 매크로 엔진에서 특수 동작을 호출하는 데 사용됩니다(<a href="macros-by-example.html#metavariables">메타변수</a> 및 <a href="macros-by-example.html#repetitions">반복</a>에서 아래에 설명됨). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치되고 트랜스크라이브됩니다. 예외는 매처의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 ’(())’는 ’{()}’와 일치하지만 ’{{}}’와는 일치하지 않습니다. ‘$’ 문자는 문자 그대로 일치시키거나 트랜스크라이브할 수 없습니다.</p>
<div class="rule" id="r-macro.decl.transcription.fragment"><a class="rule-link" href="macros-by-example.html#r-macro.decl.transcription.fragment" title="macro.decl.transcription.fragment"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.fragment]<span/></a></div>
<h3 id="일치된-조각-전달"><a class="header" href="#일치된-조각-전달">일치된 조각 전달</a></h3>
<p>일치된 조각을 다른 예제별 매크로로 전달할 때 두 번째 매크로의 매처는 조각 유형의 불투명한 AST를 보게 됩니다. 두 번째 매크로는 매처의 조각을 일치시키기 위해 리터럴 토큰을 사용할 수 없으며 동일한 유형의 조각 지정자만 사용할 수 있습니다. <code>ident</code>, <code>lifetime</code> 및 <code>tt</code> 조각 유형은 예외이며 리터럴 토큰으로 일치시킬 수 있습니다. 다음은 이 제한 사항을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// 오류:               ^^ 매크로 호출에서 이 토큰을 예상한 규칙이 없습니다
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>다음은 ‘tt’ 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.meta"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta" title="macro.decl.meta"><span>[macro<wbr>.decl<wbr>.meta]<span/></a></div>
<h2 id="메타변수"><a class="header" href="#메타변수">메타변수</a></h2>
<div class="rule" id="r-macro.decl.meta.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.intro" title="macro.decl.meta.intro"><span>[macro<wbr>.decl<wbr>.meta<wbr>.intro]<span/></a></div>
<p>매처에서 <code>$</code> <em>이름</em> <code>:</code> _조각-지정자_는 지정된 종류의 Rust 구문 조각과 일치하고 메타변수 <code>$</code>_이름_에 바인딩합니다.</p>
<div class="rule" id="r-macro.decl.meta.specifier"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.specifier" title="macro.decl.meta.specifier"><span>[macro<wbr>.decl<wbr>.meta<wbr>.specifier]<span/></a></div>
<p>유효한 조각 지정자는 다음과 같습니다.</p>
<ul>
<li><code>block</code>: <a href="expressions/block-expr.html"><em>블록표현식</em></a></li>
<li><code>expr</code>: <a href="expressions.html"><em>표현식</em></a></li>
<li><code>expr_2021</code>: <a href="expressions/underscore-expr.html"><em>밑줄표현식</em></a> 및 <a href="expressions/block-expr.html#const-blocks"><em>상수블록표현식</em></a>을 제외한 <a href="expressions.html"><em>표현식</em></a> (<a href="macros-by-example.html#r-macro.decl.meta.edition2024">macro.decl.meta.edition2024</a> 참조)</li>
<li><code>ident</code>: <a href="identifiers.html">식별자_또는_키워드</a> 또는 <a href="identifiers.html">원시_식별자</a></li>
<li><code>item</code>: <a href="items.html"><em>아이템</em></a></li>
<li><code>lifetime</code>: <a href="tokens.html#lifetimes-and-loop-labels">라이프타임_토큰</a></li>
<li><code>literal</code>: <code>-</code><sup>?</sup><a href="expressions/literal-expr.html"><em>리터럴표현식</em></a>과 일치합니다</li>
<li><code>meta</code>: <a href="attributes.html"><em>속성</em></a>, 속성의 내용</li>
<li><code>pat</code>: <a href="patterns.html"><em>패턴</em></a> (<a href="macros-by-example.html#r-macro.decl.meta.edition2021">macro.decl.meta.edition2021</a> 참조)</li>
<li><code>pat_param</code>: <a href="patterns.html"><em>패턴상단대체없음</em></a></li>
<li><code>path</code>: <a href="paths.html#paths-in-types"><em>타입경로</em></a> 스타일 경로</li>
<li><code>stmt</code>: 후행 세미콜론이 없는 <a href="statements.html"><em>문</em></a> (세미콜론이 필요한 항목 문 제외)</li>
<li><code>tt</code>: <a href="macros.html#macro-invocation"><em>토큰트리</em></a> (단일 <a href="tokens.html">토큰</a> 또는 일치하는 구분 기호 <code>()</code>, <code>[]</code> 또는 <code>{}</code>의 토큰)</li>
<li><code>ty</code>: <a href="types.html#type-expressions"><em>타입</em></a></li>
<li><code>vis</code>: 비어 있을 수 있는 <a href="visibility-and-privacy.html"><em>가시성</em></a> 한정자</li>
</ul>
<div class="rule" id="r-macro.decl.meta.transcription"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.transcription" title="macro.decl.meta.transcription"><span>[macro<wbr>.decl<wbr>.meta<wbr>.transcription]<span/></a></div>
<p>트랜스크라이버에서 메타변수는 조각 종류가 매처에 지정되어 있으므로 간단히 <code>$</code>_이름_으로 참조됩니다. 메타변수는 일치하는 구문 요소로 대체됩니다.</p>
<div class="rule" id="r-macro.decl.meta.dollar-crate"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.dollar-crate" title="macro.decl.meta.dollar-crate"><span>[macro<wbr>.decl<wbr>.meta<wbr>.dollar-crate]<span/></a></div>
<p>키워드 메타변수 <code>$crate</code>는 현재 크레이트를 참조하는 데 사용할 수 있습니다. 아래 <a href="macros-by-example.html#hygiene">위생</a>을 참조하십시오. 메타변수는 두 번 이상 또는 전혀 트랜스크라이브되지 않을 수 있습니다.</p>
<div class="rule" id="r-macro.decl.meta.edition2021"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.edition2021" title="macro.decl.meta.edition2021"><span>[macro<wbr>.decl<wbr>.meta<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션부터 <code>pat</code> 조각 지정자는 최상위 또는 패턴과 일치합니다(즉, <a href="patterns.html"><em>패턴</em></a>을 허용합니다).</p>
<p>2021 에디션 이전에는 <code>pat_param</code>과 정확히 동일한 조각과 일치합니다(즉, <a href="patterns.html"><em>패턴상단대체없음</em></a>을 허용합니다).</p>
<p>관련 에디션은 <code>macro_rules!</code> 정의에 적용되는 에디션입니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.meta.edition2024"><a class="rule-link" href="macros-by-example.html#r-macro.decl.meta.edition2024" title="macro.decl.meta.edition2024"><span>[macro<wbr>.decl<wbr>.meta<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>expr</code> 조각 지정자가 최상위 수준에서 <a href="expressions/underscore-expr.html"><em>밑줄표현식</em></a> 또는 <a href="expressions/block-expr.html#const-blocks"><em>상수블록표현식</em></a>과 일치하지 않습니다. 하위 표현식 내에서는 허용됩니다.</p>
<p>The <code>expr_2021</code> 조각 지정자는 2024 이전 에디션과의 하위 호환성을 유지하기 위해 존재합니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.repetition"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition" title="macro.decl.repetition"><span>[macro<wbr>.decl<wbr>.repetition]<span/></a></div>
<h2 id="반복"><a class="header" href="#반복">반복</a></h2>
<div class="rule" id="r-macro.decl.repetition.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition.intro" title="macro.decl.repetition.intro"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.intro]<span/></a></div>
<p>매처와 트랜스크라이버 모두에서 반복은 반복할 토큰을 <code>$(</code>…<code>)</code> 안에 넣고 반복 연산자를 뒤에 붙여 표시하며, 선택적으로 사이에 구분 기호 토큰을 넣을 수 있습니다.</p>
<div class="rule" id="r-macro.decl.repetition.separator"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition.separator" title="macro.decl.repetition.separator"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.separator]<span/></a></div>
<p>구분 기호 토큰은 구분 기호나 반복 연산자 중 하나가 아닌 모든 토큰이 될 수 있지만 <code>;</code>와 <code>,</code>가 가장 일반적입니다. 예를 들어, <code>$( $i:ident ),*</code>는 쉼표로 구분된 임의의 수의 식별자를 나타냅니다. 중첩된 반복은 허용됩니다.</p>
<div class="rule" id="r-macro.decl.repetition.operators"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition.operators" title="macro.decl.repetition.operators"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.operators]<span/></a></div>
<p>반복 연산자는 다음과 같습니다.</p>
<ul>
<li><code>*</code> — 임의의 횟수 반복을 나타냅니다.</li>
<li><code>+</code> — 임의의 횟수이지만 최소 한 번 이상을 나타냅니다.</li>
<li><code>?</code> — 0 또는 1회 발생하는 선택적 조각을 나타냅니다.</li>
</ul>
<div class="rule" id="r-macro.decl.repetition.optional-restriction"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition.optional-restriction" title="macro.decl.repetition.optional-restriction"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.optional-restriction]<span/></a></div>
<p>Since <code>?</code>는 최대 한 번 발생함을 나타내므로 구분 기호와 함께 사용할 수 없습니다.</p>
<div class="rule" id="r-macro.decl.repetition.fragment"><a class="rule-link" href="macros-by-example.html#r-macro.decl.repetition.fragment" title="macro.decl.repetition.fragment"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.fragment]<span/></a></div>
<p>반복되는 조각은 구분 기호 토큰으로 구분된 지정된 수의 조각과 일치하고 트랜스크라이브됩니다. 메타변수는 해당 조각의 모든 반복과 일치합니다. 예를 들어, 위의 <code>$( $i:ident ),*</code> 예제는 목록의 모든 식별자에 <code>$i</code>를 일치시킵니다.</p>
<p>트랜스크립션 중에는 컴파일러가 반복을 올바르게 확장하는 방법을 알 수 있도록 반복에 추가 제한 사항이 적용됩니다.</p>
<ol>
<li>메타변수는 매처에서와 동일한 수, 종류 및 중첩 순서로 트랜스크라이버에 나타나야 합니다. 따라서 매처 <code>$( $i:ident ),*</code>의 경우 트랜스크라이버 <code>=&gt; { $i }</code>, <code>=&gt; { $( $( $i)* )* }</code> 및 <code>=&gt; { $( $i )+ }</code>는 모두 불법이지만 <code>=&gt; { $( $i );* }</code>는 올바르며 쉼표로 구분된 식별자 목록을 세미콜론으로 구분된 목록으로 바꿉니다.</li>
<li>트랜스크라이버의 각 반복에는 확장 횟수를 결정하기 위해 최소한 하나의 메타변수가 포함되어야 합니다. 동일한 반복에 여러 메타변수가 나타나면 동일한 수의 조각에 바인딩되어야 합니다. 예를 들어, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code>는 <code>$j</code> 조각과 동일한 수의 <code>$i</code> 조각을 바인딩해야 합니다. 즉, <code>(a, b, c; d, e, f)</code>로 매크로를 호출하는 것은 합법이며 <code>((a,d), (b,e), (c,f))</code>로 확장되지만, <code>(a, b, c; d, e)</code>는 동일한 수가 아니므로 불법입니다. 이 요구 사항은 중첩된 반복의 모든 계층에 적용됩니다.</li>
</ol>
<div class="rule" id="r-macro.decl.scope"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope" title="macro.decl.scope"><span>[macro<wbr>.decl<wbr>.scope]<span/></a></div>
<h2 id="스코핑-내보내기-및-가져오기"><a class="header" href="#스코핑-내보내기-및-가져오기">스코핑, 내보내기 및 가져오기</a></h2>
<div class="rule" id="r-macro.decl.scope.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.intro" title="macro.decl.scope.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.intro]<span/></a></div>
<p>역사적인 이유로 예제별 매크로의 범위 지정은 항목처럼 완전히 작동하지 않습니다. 매크로에는 텍스트 범위와 경로 기반 범위의 두 가지 범위 형식이 있습니다. 텍스트 범위는 소스 파일에 항목이 나타나는 순서 또는 여러 파일에 걸쳐 나타나는 순서를 기반으로 하며 기본 범위 지정입니다. 아래에서 자세히 설명합니다. 경로 기반 범위는 항목 범위 지정과 정확히 동일하게 작동합니다. 매크로의 범위 지정, 내보내기 및 가져오기는 주로 속성에 의해 제어됩니다.</p>
<div class="rule" id="r-macro.decl.scope.unqualified"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.unqualified" title="macro.decl.scope.unqualified"><span>[macro<wbr>.decl<wbr>.scope<wbr>.unqualified]<span/></a></div>
<p>매크로가 정규화되지 않은 식별자(다중 부분 경로의 일부가 아님)에 의해 호출되면 먼저 텍스트 범위에서 조회됩니다. 결과가 없으면 경로 기반 범위에서 조회됩니다. 매크로 이름이 경로로 정규화되면 경로 기반 범위에서만 조회됩니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // 경로 기반 가져오기.

macro_rules! lazy_static { // 텍스트 정의.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // 텍스트 조회는 먼저 우리 매크로를 찾습니다.
self::lazy_static!{} // 경로 기반 조회는 우리 매크로를 무시하고 가져온 매크로를 찾습니다.</code></pre>
<div class="rule" id="r-macro.decl.scope.textual"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.textual" title="macro.decl.scope.textual"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual]<span/></a></div>
<h3 id="텍스트-범위"><a class="header" href="#텍스트-범위">텍스트 범위</a></h3>
<div class="rule" id="r-macro.decl.scope.textual.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.textual.intro" title="macro.decl.scope.textual.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual<wbr>.intro]<span/></a></div>
<p>텍스트 범위는 주로 소스 파일에 항목이 나타나는 순서를 기반으로 하며 <code>let</code>으로 선언된 지역 변수의 범위와 유사하게 작동하지만 모듈 수준에서도 적용됩니다. <code>macro_rules!</code>를 사용하여 매크로를 정의하면 매크로는 정의 후 범위에 들어갑니다(이름은 호출 사이트에서 조회되므로 여전히 재귀적으로 사용할 수 있음). 일반적으로 모듈인 주변 범위가 닫힐 때까지입니다. 이것은 자식 모듈에 들어가거나 여러 파일에 걸쳐 있을 수도 있습니다.</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // 오류: m이 범위에 없습니다.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: m 선언 후에 나타납니다.

    mod uses_macro;
}

// m!{} // 오류: m이 범위에 없습니다.

//// src/has_macro/uses_macro.rs

m!{} // OK: src/lib.rs에서 m 선언 후에 나타납니다</code></pre>
<div class="rule" id="r-macro.decl.scope.textual.shadow"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.textual.shadow" title="macro.decl.scope.textual.shadow"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual<wbr>.shadow]<span/></a></div>
<p>매크로를 여러 번 정의하는 것은 오류가 아닙니다. 가장 최근 선언은 범위를 벗어나지 않는 한 이전 선언을 가립니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // 오류: '1'과 일치하는 규칙이 없습니다
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}</span></code></pre></pre>
<p>매크로는 함수 내부에서도 로컬로 선언하고 사용할 수 있으며 유사하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // 오류: m이 범위에 없습니다.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}

// m!(); // 오류: m이 범위에 없습니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.macro_use"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.macro_use" title="macro.decl.scope.macro_use"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use]<span/></a></div>
<h3 id="macro_use-속성"><a class="header" href="#macro_use-속성"><code>macro_use</code> 속성</a></h3>
<div class="rule" id="r-macro.decl.scope.macro_use.mod-decl"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.macro_use.mod-decl" title="macro.decl.scope.macro_use.mod-decl"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.mod-decl]<span/></a></div>
<p>The _<code>macro_use</code> 속성_은 두 가지 목적이 있습니다. 첫째, 모듈에 적용하여 모듈이 닫힐 때 모듈의 매크로 범위가 끝나지 않도록 하는 데 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}

m!();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.macro_use.prelude"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.macro_use.prelude" title="macro.decl.scope.macro_use.prelude"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.prelude]<span/></a></div>
<p>둘째, 크레이트의 루트 모듈에 나타나는 <code>extern crate</code> 선언에 첨부하여 다른 크레이트에서 매크로를 가져오는 데 사용할 수 있습니다. 이런 식으로 가져온 매크로는 텍스트가 아닌 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 전주곡</a>으로 가져오므로 다른 이름으로 가려질 수 있습니다. <code>#[macro_use]</code>로 가져온 매크로는 가져오기 문 앞에 사용할 수 있지만 충돌이 발생하면 마지막으로 가져온 매크로가 우선합니다. 선택적으로, <a href="attributes.html#meta-item-attribute-syntax"><em>MetaListIdents</em></a> 구문을 사용하여 가져올 매크로 목록을 지정할 수 있습니다. 이것은 <code>#[macro_use]</code>가 모듈에 적용될 때 지원되지 않습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // 또는 #[macro_use]를 사용하여 모든 매크로를 가져옵니다.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // 오류: `self`에 lazy_static이 정의되어 있지 않습니다</code></pre>
<div class="rule" id="r-macro.decl.scope.macro_use.export"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.macro_use.export" title="macro.decl.scope.macro_use.export"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.export]<span/></a></div>
<p><code>#[macro_use]</code>로 가져올 매크로는 아래에 설명된 <code>#[macro_export]</code>로 내보내야 합니다.</p>
<div class="rule" id="r-macro.decl.scope.path"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.path" title="macro.decl.scope.path"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path]<span/></a></div>
<h3 id="경로-기반-범위"><a class="header" href="#경로-기반-범위">경로 기반 범위</a></h3>
<div class="rule" id="r-macro.decl.scope.path.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.path.intro" title="macro.decl.scope.path.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path<wbr>.intro]<span/></a></div>
<p>기본적으로 매크로에는 경로 기반 범위가 없습니다. 그러나 <code>#[macro_export]</code> 속성이 있으면 크레이트 루트 범위에 선언되고 다음과 같이 정상적으로 참조할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self::m!();
m!(); // OK: 경로 기반 조회는 현재 모듈에서 m을 찾습니다.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.path.export"><a class="rule-link" href="macros-by-example.html#r-macro.decl.scope.path.export" title="macro.decl.scope.path.export"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path<wbr>.export]<span/></a></div>
<p><code>#[macro_export]</code>로 레이블이 지정된 매크로는 항상 <code>pub</code>이며 위에서 설명한 대로 경로 또는 <code>#[macro_use]</code>를 통해 다른 크레이트에서 참조할 수 있습니다.</p>
<div class="rule" id="r-macro.decl.hygiene"><a class="rule-link" href="macros-by-example.html#r-macro.decl.hygiene" title="macro.decl.hygiene"><span>[macro<wbr>.decl<wbr>.hygiene]<span/></a></div>
<h2 id="위생"><a class="header" href="#위생">위생</a></h2>
<div class="rule" id="r-macro.decl.hygiene.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.hygiene.intro" title="macro.decl.hygiene.intro"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.intro]<span/></a></div>
<p>매크로 바이 이그젬플은 _혼합-사이트 위생_을 가집니다. 이는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a>, <a href="expressions/loop-expr.html#labelled-block-expressions">블록 레이블</a> 및 지역 변수는 매크로 정의 사이트에서 조회되는 반면 다른 심볼은 매크로 호출 사이트에서 조회됨을 의미합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
fn func() {
    unreachable!("이것은 절대 호출되지 않습니다")
}

macro_rules! check {
    () =&gt; {
        assert_eq!(x, 1); // 정의 사이트의 `x`를 사용합니다.
        func();           // 호출 사이트의 `func`를 사용합니다.
    };
}

{
    let x = 2;
    fn func() { /* 패닉하지 않습니다 */ }
    check!();
}
<span class="boring">}</span></code></pre></pre>
<p>매크로 확장에서 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다.매크로 확장 시 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (define) =&gt; {
        let x = 1;
    };
    (refer) =&gt; {
        dbg!(x);
    };
}

m!(define);
m!(refer);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.hygiene.crate"><a class="rule-link" href="macros-by-example.html#r-macro.decl.hygiene.crate" title="macro.decl.hygiene.crate"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.crate]<span/></a></div>
<p>특별한 경우는 <code>$crate</code> 메타변수입니다. 이것은 매크로를 정의하는 크레이트를 참조하며, 호출 사이트에서 범위에 없는 아이템이나 매크로를 조회하기 위해 경로의 시작 부분에서 사용될 수 있습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// `helper_macro` 크레이트의 정의.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
// () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 가져오지 않았습니다!
//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 임포트되지 않았습니다!
use helper_macro::helped;

fn unit() {
    helped!();
}</code></pre>
<p>참고: <code>$crate</code>는 현재 크레이트를 참조하므로 매크로가 아닌 항목을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다.참고로, <code>$crate</code>는 현재 크레이트를 참조하므로, 매크로가 아닌 아이템을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.hygiene.vis"><a class="rule-link" href="macros-by-example.html#r-macro.decl.hygiene.vis" title="macro.decl.hygiene.vis"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.vis]<span/></a></div>
<p>또한 <code>$crate</code>를 사용하면 매크로가 확장될 때 자체 크레이트 내의 항목을 참조할 수 있지만 가시성에는 영향을 미치지 않습니다. 참조된 항목이나 매크로는 호출 사이트에서 계속 볼 수 있어야 합니다. 다음 예에서 <code>foo()</code>가 공개되지 않았기 때문에 크레이트 외부에서 <code>call_foo!()</code>를 호출하려는 모든 시도는 실패합니다.또한, <code>$crate</code>를 사용하면 매크로가 확장될 때 자신의 크레이트 내의 아이템을 참조할 수 있지만, 가시성에는 영향을 미치지 않습니다. 참조된 아이템이나 매크로는 호출 사이트에서 여전히 보여야 합니다. 다음 예제에서, <code>foo()</code>가 공개되지 않았기 때문에 크레이트 외부에서 <code>call_foo!()</code>를 호출하려는 모든 시도는 실패합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>버전 및 에디션 차이</strong>: Rust 1.30 이전에는 <code>$crate</code> 및 <code>local_inner_macros</code>(아래)가 지원되지 않았습니다. 매크로 내보내기 크레이트 사용자가 도우미 매크로를 수동으로 가져올 필요가 없도록 경로 기반 매크로 가져오기(위에 설명됨)와 함께 추가되었습니다. 도우미 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 가져오기와 잘 작동하도록 <code>$crate</code> 또는 <code>local_inner_macros</code>를 사용하도록 수정해야 합니다.<strong>버전 및 에디션 차이</strong>: Rust 1.30 이전에는 <code>$crate</code> 및 <code>local_inner_macros</code>(아래)가 지원되지 않았습니다. 이것들은 매크로를 내보내는 크레이트의 사용자가 헬퍼 매크로를 수동으로 임포트할 필요가 없도록 하기 위해 (위에서 설명한) 경로 기반 매크로 임포트와 함께 추가되었습니다. 헬퍼 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 임포트와 잘 작동하도록 <code>$crate</code> 또는 <code>local_inner_macros</code>를 사용하도록 수정해야 합니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.hygiene.local_inner_macros"><a class="rule-link" href="macros-by-example.html#r-macro.decl.hygiene.local_inner_macros" title="macro.decl.hygiene.local_inner_macros"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.local_inner_macros]<span/></a></div>
<p>매크로를 내보낼 때 <code>#[macro_export]</code> 속성에 <code>local_inner_macros</code> 키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 <code>$crate::</code> 접두사를 붙일 수 있습니다. 이것은 주로 <code>$crate</code>가 언어에 추가되기 전에 작성된 코드를 Rust 2018의 경로 기반 매크로 가져오기와 함께 작동하도록 마이그레이션하는 도구로 사용됩니다. 새 코드에서는 사용을 권장하지 않습니다.매크로가 내보내질 때, <code>#[macro_export]</code> 속성에 <code>local_inner_macros</code> 키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 <code>$crate::</code> 접두사를 붙일 수 있습니다. 이것은 주로 <code>$crate</code>가 언어에 추가되기 전에 작성된 코드를 Rust 2018의 경로 기반 매크로 임포트와 함께 작동하도록 마이그레이션하기 위한 도구로 의도되었습니다. 새 코드에서는 사용을 권장하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // 자동으로 $crate::helper!()로 변환됩니다.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.follow-set"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set" title="macro.decl.follow-set"><span>[macro<wbr>.decl<wbr>.follow-set]<span/></a></div>
<h2 id="후속-집합-모호성-제한"><a class="header" href="#후속-집합-모호성-제한">후속 집합 모호성 제한</a></h2>
<div class="rule" id="r-macro.decl.follow-set.intro"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.intro" title="macro.decl.follow-set.intro"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.intro]<span/></a></div>
<p>매크로 시스템에서 사용하는 파서는 상당히 강력하지만 현재 또는 미래 버전의 언어에서 모호성을 방지하기 위해 제한됩니다.매크로 시스템에서 사용하는 파서는 상당히 강력하지만, 현재 또는 미래 버전의 언어에서 모호성을 방지하기 위해 제한됩니다.</p>
<div class="rule" id="r-macro.decl.follow-set.token-restriction"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-restriction" title="macro.decl.follow-set.token-restriction"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-restriction]<span/></a></div>
<p>특히, 모호한 확장에 대한 규칙 외에도 메타변수와 일치하는 비단말은 해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 합니다.특히, 모호한 확장에 대한 규칙 외에도, 메타변수에 의해 일치된 비단말은 해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 합니다.</p>
<p>예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 <code>[,]</code>가 합법적인 표현식의 일부가 될 수 없으므로 구문 분석이 항상 명확하기 때문에 오늘날 Rust에서 이론적으로 허용될 수 있습니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있으므로 <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 나중에 Rust 버전에서 <code>[,]</code>가 허용되면 이 매처는 모호해지거나 잘못 구문 분석되어 작동하는 코드를 손상시킬 수 있습니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분 기호이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적입니다. 구체적인 규칙은 다음과 같습니다.예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 오늘날 Rust에서 이론적으로 받아들여질 수 있습니다. 왜냐하면 <code>[,]</code>는 합법적인 표현식의 일부가 될 수 없으므로 파싱이 항상 명확하기 때문입니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있기 때문에, <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 만약 <code>[,]</code>가 이후 버전의 Rust에서 허용된다면, 이 매처는 모호해지거나 잘못 파싱되어 작동하는 코드를 깨뜨릴 것입니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분자이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적일 것입니다. 구체적인 규칙은 다음과 같습니다:</p>
<div class="rule" id="r-macro.decl.follow-set.token-expr-stmt"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-expr-stmt" title="macro.decl.follow-set.token-expr-stmt"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-expr-stmt]<span/></a></div>
<ul>
<li><code>expr</code>과 <code>stmt</code>는 <code>=&gt;</code>, <code>,</code>, 또는 <code>;</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-pat_param"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-pat_param" title="macro.decl.follow-set.token-pat_param"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-pat_param]<span/></a></div>
<ul>
<li><code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code> 또는 <code>in</code> 중 하나만 뒤따를 수 있습니다.<code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-pat"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-pat" title="macro.decl.follow-set.token-pat"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-pat]<span/></a></div>
<ul>
<li><code>pat</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-path-ty"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-path-ty" title="macro.decl.follow-set.token-path-ty"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-path-ty]<span/></a></div>
<ul>
<li><code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 조각 지정자의 매크로 변수 중 하나만 뒤따를 수 있습니다.<code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 프래그먼트 지정자의 매크로 변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-vis"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-vis" title="macro.decl.follow-set.token-vis"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-vis]<span/></a></div>
<ul>
<li><code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 유형을 시작할 수 있는 모든 토큰 또는 <code>ident</code>, <code>ty</code> 또는 <code>path</code> 조각 지정자가 있는 메타변수 중 하나만 뒤따를 수 있습니다.<code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 타입을 시작할 수 있는 모든 토큰, 또는 <code>ident</code>, <code>ty</code>, 또는 <code>path</code> 프래그먼트 지정자를 가진 메타변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-other"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.token-other" title="macro.decl.follow-set.token-other"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-other]<span/></a></div>
<ul>
<li>다른 모든 조각 지정자에는 제한이 없습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.edition2021"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.edition2021" title="macro.decl.follow-set.edition2021"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션 이전에는 <code>pat</code> 뒤에 <code>|</code>가 올 수도 있습니다.<strong>에디션 차이</strong>: 2021 에디션 이전에는 <code>pat</code> 뒤에 <code>|</code>가 올 수도 있습니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.follow-set.repetition"><a class="rule-link" href="macros-by-example.html#r-macro.decl.follow-set.repetition" title="macro.decl.follow-set.repetition"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.repetition]<span/></a></div>
<p>반복이 포함된 경우 규칙은 구분 기호를 고려하여 가능한 모든 확장 수에 적용됩니다. 이는 다음을 의미합니다.반복이 포함된 경우, 구분 기호를 고려하여 가능한 모든 확장 수에 규칙이 적용됩니다. 이는 다음을 의미합니다:</p>
<ul>
<li>반복에 구분 기호가 포함된 경우, 해당 구분 기호는 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 여러 번 반복될 수 있는 경우(<code>*</code> 또는 <code>+</code>), 내용은 스스로를 따를 수 있어야 합니다.</li>
<li>반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.</li>
</ul>
<p>자세한 내용은 <a href="macro-ambiguity.html">공식 사양</a>을 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-macro.proc"><a class="rule-link" href="procedural-macros.html#r-macro.proc" title="macro.proc"><span>[macro<wbr>.proc]<span/></a></div>
<h2 id="절차적-매크로"><a class="header" href="#절차적-매크로">절차적 매크로</a></h2>
<div class="rule" id="r-macro.proc.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.intro" title="macro.proc.intro"><span>[macro<wbr>.proc<wbr>.intro]<span/></a></div>
<p>_절차적 매크로_는 함수의 실행으로 구문 확장을 생성할 수 있습니다. 절차적 매크로는 세 가지 종류 중 하나입니다:</p>
<ul>
<li><a href="procedural-macros.html#function-like-procedural-macros">함수형 매크로</a> - <code>custom!(...)</code></li>
<li><a href="procedural-macros.html#derive-macros">파생 매크로</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="procedural-macros.html#attribute-macros">속성 매크로</a> - <code>#[CustomAttribute]</code></li>
</ul>
<p>절차적 매크로를 사용하면 컴파일 타임에 Rust 구문을 사용하고 생성하는 코드를 실행할 수 있습니다. 절차적 매크로를 AST에서 다른 AST로의 함수로 생각할 수 있습니다.</p>
<div class="rule" id="r-macro.proc.def"><a class="rule-link" href="procedural-macros.html#r-macro.proc.def" title="macro.proc.def"><span>[macro<wbr>.proc<wbr>.def]<span/></a></div>
<p>절차적 매크로는 <code>proc-macro</code>의 <a href="linkage.html">크레이트 타입</a>을 가진 크레이트의 루트에 정의되어야 합니다. 매크로는 정의된 크레이트에서 사용할 수 없으며, 다른 크레이트에서 임포트될 때만 사용할 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: Cargo를 사용할 때, 절차적 매크로 크레이트는 매니페스트에서 <code>proc-macro</code> 키로 정의됩니다:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<div class="rule" id="r-macro.proc.result"><a class="rule-link" href="procedural-macros.html#r-macro.proc.result" title="macro.proc.result"><span>[macro<wbr>.proc<wbr>.result]<span/></a></div>
<p>함수로서, 그들은 구문을 반환하거나, 패닉하거나, 또는 무한정 반복해야 합니다. 반환된 구문은 절차적 매크로의 종류에 따라 구문을 대체하거나 추가합니다. 패닉은 컴파일러에 의해 잡혀 컴파일러 오류로 바뀝니다. 무한 루프는 컴파일러에 의해 잡히지 않아 컴파일러를 멈추게 합니다.</p>
<p>절차적 매크로는 컴파일 중에 실행되므로 컴파일러와 동일한 리소스를 갖습니다. 예를 들어, 표준 입력, 오류 및 출력은 컴파일러가 액세스할 수 있는 것과 동일합니다. 마찬가지로 파일 액세스도 동일합니다. 이 때문에 절차적 매크로는 <a href="../cargo/reference/build-scripts.html">Cargo의 빌드 스크립트</a>와 동일한 보안 문제를 가지고 있습니다.</p>
<div class="rule" id="r-macro.proc.error"><a class="rule-link" href="procedural-macros.html#r-macro.proc.error" title="macro.proc.error"><span>[macro<wbr>.proc<wbr>.error]<span/></a></div>
<p>절차적 매크로는 오류를 보고하는 두 가지 방법이 있습니다. 첫 번째는 패닉하는 것입니다. 두 번째는 <a href="../core/macro.compile_error.html"><code>compile_error</code></a> 매크로 호출을 내보내는 것입니다.</p>
<div class="rule" id="r-macro.proc.proc_macro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.proc_macro" title="macro.proc.proc_macro"><span>[macro<wbr>.proc<wbr>.proc_macro]<span/></a></div>
<h3 id="proc_macro-크레이트"><a class="header" href="#proc_macro-크레이트">proc_macro 크레이트</a></h3>
<div class="rule" id="r-macro.proc.proc_macro.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.proc_macro.intro" title="macro.proc.proc_macro.intro"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.intro]<span/></a></div>
<p>절차적 매크로 크레이트는 거의 항상 컴파일러에서 제공하는 <a href="../proc_macro/index.html"><code>proc_macro</code> 크레이트</a>에 링크됩니다. <code>proc_macro</code> 크레이트는 절차적 매크로를 작성하는 데 필요한 유형과 이를 더 쉽게 만드는 기능을 제공합니다.</p>
<div class="rule" id="r-macro.proc.proc_macro.token-stream"><a class="rule-link" href="procedural-macros.html#r-macro.proc.proc_macro.token-stream" title="macro.proc.proc_macro.token-stream"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.token-stream]<span/></a></div>
<p>이 크레이트는 주로 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 타입을 포함합니다. 절차적 매크로는 AST 노드 대신 _토큰 스트림_을 통해 작동하며, 이는 컴파일러와 절차적 매크로 모두에게 시간이 지나도 훨씬 더 안정적인 인터페이스입니다. _토큰 스트림_은 대략 <code>Vec&lt;TokenTree&gt;</code>와 동일하며, 여기서 <code>TokenTree</code>는 어휘 토큰으로 생각할 수 있습니다. 예를 들어 <code>foo</code>는 <code>Ident</code> 토큰이고, <code>.</code>는 <code>Punct</code> 토큰이며, <code>1.2</code>는 <code>Literal</code> 토큰입니다. <code>TokenStream</code> 타입은 <code>Vec&lt;TokenTree&gt;</code>와 달리 복제 비용이 저렴합니다.</p>
<div class="rule" id="r-macro.proc.proc_macro.span"><a class="rule-link" href="procedural-macros.html#r-macro.proc.proc_macro.span" title="macro.proc.proc_macro.span"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.span]<span/></a></div>
<p>모든 토큰에는 연관된 <code>Span</code>이 있습니다. <code>Span</code>은 수정할 수 없지만 제조할 수 있는 불투명한 값입니다. <code>Span</code>은 프로그램 내 소스 코드의 범위를 나타내며 주로 오류 보고에 사용됩니다. <code>Span</code> 자체를 수정할 수는 없지만, 다른 토큰에서 <code>Span</code>을 가져오는 것과 같이 모든 토큰과 <em>연관된</em> <code>Span</code>은 언제든지 변경할 수 있습니다.</p>
<div class="rule" id="r-macro.proc.hygiene"><a class="rule-link" href="procedural-macros.html#r-macro.proc.hygiene" title="macro.proc.hygiene"><span>[macro<wbr>.proc<wbr>.hygiene]<span/></a></div>
<h3 id="절차적-매크로-위생"><a class="header" href="#절차적-매크로-위생">절차적 매크로 위생</a></h3>
<p>절차적 매크로는 _비위생적_입니다. 이는 출력 토큰 스트림이 바로 옆 코드에 인라인으로 작성된 것처럼 동작함을 의미합니다. 이는 외부 항목의 영향을 받고 외부 임포트에도 영향을 미친다는 것을 의미합니다.</p>
<p>매크로 작성자는 이 제한 사항을 감안할 때 가능한 한 많은 컨텍스트에서 매크로가 작동하도록 주의해야 합니다. 여기에는 종종 라이브러리의 아이템에 대한 절대 경로를 사용하거나(예: <code>Option</code> 대신 <code>::std::option::Option</code>) 생성된 함수가 다른 함수와 충돌할 가능성이 없는 이름을 갖도록 하는 것(예: <code>foo</code> 대신 <code>__internal_foo</code>)이 포함됩니다.</p>
<div class="rule" id="r-macro.proc.function"><a class="rule-link" href="procedural-macros.html#r-macro.proc.function" title="macro.proc.function"><span>[macro<wbr>.proc<wbr>.function]<span/></a></div>
<h3 id="함수형-절차적-매크로"><a class="header" href="#함수형-절차적-매크로">함수형 절차적 매크로</a></h3>
<div class="rule" id="r-macro.proc.function.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.function.intro" title="macro.proc.function.intro"><span>[macro<wbr>.proc<wbr>.function<wbr>.intro]<span/></a></div>
<p>_함수형 절차적 매크로_는 매크로 호출 연산자(<code>!</code>)를 사용하여 호출되는 절차적 매크로입니다.</p>
<div class="rule" id="r-macro.proc.function.def"><a class="rule-link" href="procedural-macros.html#r-macro.proc.function.def" title="macro.proc.function.def"><span>[macro<wbr>.proc<wbr>.function<wbr>.def]<span/></a></div>
<p>이 매크로는 <code>proc_macro</code> <a href="attributes.html">속성</a>과 <code>(TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다. 입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 매크로 호출의 구분 기호 안에 있는 것이고 출력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 전체 매크로 호출을 대체합니다.</p>
<div class="rule" id="r-macro.proc.function.namespace"><a class="rule-link" href="procedural-macros.html#r-macro.proc.function.namespace" title="macro.proc.function.namespace"><span>[macro<wbr>.proc<wbr>.function<wbr>.namespace]<span/></a></div>
<p><code>proc_macro</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 매크로를 정의합니다.</p>
<p>예를 들어, 다음 매크로 정의는 입력을 무시하고 <code>answer</code> 함수를 해당 범위로 출력합니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>그런 다음 바이너리 크레이트에서 이를 사용하여 표준 출력으로 “42“를 출력합니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}</code></pre>
<div class="rule" id="r-macro.proc.function.invocation"><a class="rule-link" href="procedural-macros.html#r-macro.proc.function.invocation" title="macro.proc.function.invocation"><span>[macro<wbr>.proc<wbr>.function<wbr>.invocation]<span/></a></div>
<p>함수형 절차적 매크로는 <a href="statements.html">문</a>, <a href="expressions.html">표현식</a>, <a href="patterns.html">패턴</a>, <a href="types.html#type-expressions">타입 표현식</a>, <a href="items/external-blocks.html"><code>extern</code> 블록</a>의 아이템, 고유 및 트레잇 <a href="items/implementations.html">구현</a>, 그리고 <a href="items/traits.html">트레잇 정의</a>를 포함한 <a href="items.html">아이템</a> 위치 등 모든 매크로 호출 위치에서 호출될 수 있습니다.</p>
<div class="rule" id="r-macro.proc.derive"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive" title="macro.proc.derive"><span>[macro<wbr>.proc<wbr>.derive]<span/></a></div>
<h3 id="파생-매크로"><a class="header" href="#파생-매크로">파생 매크로</a></h3>
<div class="rule" id="r-macro.proc.derive.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.intro" title="macro.proc.derive.intro"><span>[macro<wbr>.proc<wbr>.derive<wbr>.intro]<span/></a></div>
<p>_파생 매크로_는 <a href="attributes/derive.html"><code>derive</code> 속성</a>에 대한 새로운 입력을 정의합니다. 이 매크로는 <a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형</a>, 또는 <a href="items/unions.html">공용체</a>의 토큰 스트림이 주어지면 새로운 <a href="items.html">아이템</a>을 생성할 수 있습니다. 또한 <a href="procedural-macros.html#derive-macro-helper-attributes">파생 매크로 헬퍼 속성</a>을 정의할 수도 있습니다.</p>
<div class="rule" id="r-macro.proc.derive.def"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.def" title="macro.proc.derive.def"><span>[macro<wbr>.proc<wbr>.derive<wbr>.def]<span/></a></div>
<p>사용자 정의 파생 매크로는 <code>proc_macro_derive</code> 속성과 <code>(TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다.</p>
<div class="rule" id="r-macro.proc.derive.namespace"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.namespace" title="macro.proc.derive.namespace"><span>[macro<wbr>.proc<wbr>.derive<wbr>.namespace]<span/></a></div>
<p><code>proc_macro_derive</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 사용자 정의 파생을 정의합니다.</p>
<div class="rule" id="r-macro.proc.derive.output"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.output" title="macro.proc.derive.output"><span>[macro<wbr>.proc<wbr>.derive<wbr>.output]<span/></a></div>
<p>입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <code>derive</code> 속성을 가진 아이템의 토큰 스트림입니다. 출력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>의 아이템이 있는 <a href="items/modules.html">모듈</a> 또는 <a href="expressions/block-expr.html">블록</a>에 추가되는 아이템 집합이어야 합니다.</p>
<p>다음은 파생 매크로의 예입니다. 입력으로 유용한 작업을 수행하는 대신 <code>answer</code> 함수를 추가하기만 합니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>그리고 나서 해당 파생 매크로를 사용합니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</code></pre>
<div class="rule" id="r-macro.proc.derive.attributes"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.attributes" title="macro.proc.derive.attributes"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes]<span/></a></div>
<h4 id="파생-매크로-헬퍼-속성"><a class="header" href="#파생-매크로-헬퍼-속성">파생 매크로 헬퍼 속성</a></h4>
<div class="rule" id="r-macro.proc.derive.attributes.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.attributes.intro" title="macro.proc.derive.attributes.intro"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes<wbr>.intro]<span/></a></div>
<p>파생 매크로는 자신이 있는 <a href="items.html">아이템</a>의 범위에 추가적인 <a href="attributes.html">속성</a>을 추가할 수 있습니다. 해당 속성은 _파생 매크로 헬퍼 속성_이라고 합니다. 이러한 속성은 <a href="attributes.html#active-and-inert-attributes">비활성</a>이며, 유일한 목적은 자신을 정의한 파생 매크로에 제공되는 것입니다. 즉, 모든 매크로에서 볼 수 있습니다.</p>
<div class="rule" id="r-macro.proc.derive.attributes.def"><a class="rule-link" href="procedural-macros.html#r-macro.proc.derive.attributes.def" title="macro.proc.derive.attributes.def"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes<wbr>.def]<span/></a></div>
<p>헬퍼 속성을 정의하는 방법은 <code>proc_macro_derive</code> 매크로에 <code>attributes</code> 키를 넣고 헬퍼 속성의 이름인 식별자의 쉼표로 구분된 목록을 사용하는 것입니다.</p>
<p>예를 들어, 다음 파생 매크로는 헬퍼 속성 <code>helper</code>를 정의하지만, 궁극적으로는 아무것도 하지 않습니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type="proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</code></pre>
<p>그리고 나서 구조체에서 파생 매크로를 사용합니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}</code></pre>
<div class="rule" id="r-macro.proc.attribute"><a class="rule-link" href="procedural-macros.html#r-macro.proc.attribute" title="macro.proc.attribute"><span>[macro<wbr>.proc<wbr>.attribute]<span/></a></div>
<h3 id="속성-매크로"><a class="header" href="#속성-매크로">속성 매크로</a></h3>
<div class="rule" id="r-macro.proc.attribute.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.attribute.intro" title="macro.proc.attribute.intro"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.intro]<span/></a></div>
<p>_속성 매크로_는 <a href="items/external-blocks.html"><code>extern</code> 블록</a>의 아이템, 고유 및 트레잇 <a href="items/implementations.html">구현</a>, 그리고 <a href="items/traits.html">트레잇 정의</a>를 포함한 <a href="items.html">아이템</a>에 첨부될 수 있는 새로운 <a href="attributes.html">외부 속성</a>을 정의합니다.</p>
<div class="rule" id="r-macro.proc.attribute.def"><a class="rule-link" href="procedural-macros.html#r-macro.proc.attribute.def" title="macro.proc.attribute.def"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.def]<span/></a></div>
<p>속성 매크로는 <code>(TokenStream, TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <code>proc_macro_attribute</code> <a href="attributes.html">속성</a>을 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다. 첫 번째 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 속성 이름을 따르는 구분된 토큰 트리이며, 외부 구분 기호는 포함하지 않습니다. 속성이 단순한 속성 이름으로 작성된 경우, 속성 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 비어 있습니다. 두 번째 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <a href="items.html">아이템</a>의 다른 <a href="attributes.html">속성</a>을 포함한 <a href="items.html">아이템</a>의 나머지 부분입니다. 반환된 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <a href="items.html">아이템</a>을 임의의 수의 <a href="items.html">아이템</a>으로 대체합니다.</p>
<div class="rule" id="r-macro.proc.attribute.namespace"><a class="rule-link" href="procedural-macros.html#r-macro.proc.attribute.namespace" title="macro.proc.attribute.namespace"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.namespace]<span/></a></div>
<p><code>proc_macro_attribute</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 속성을 정의합니다.</p>
<p>예를 들어, 이 속성 매크로는 입력 스트림을 받아서 그대로 반환하므로, 사실상 속성의 no-op입니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</code></pre>
<p>다음 예제는 속성 매크로가 보는 문자열화된 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code>s</a>을 보여줍니다. 출력은 컴파일러의 출력에 표시됩니다. 출력은 “out:” 접두사가 붙은 함수 뒤의 주석에 표시됩니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("attr: \"{attr}\"");
    println!("item: \"{item}\"");
    item
}</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// 예: 기본 함수
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() {}"

// 예: 입력이 있는 속성
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// 예: 입력에 여러 토큰이 있는 경우
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: "multiple =&gt; tokens"
// out: item: "fn invoke3() {}"

// 예:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"</code></pre>
<div class="rule" id="r-macro.proc.token"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token" title="macro.proc.token"><span>[macro<wbr>.proc<wbr>.token]<span/></a></div>
<h3 id="선언적-매크로-토큰과-절차적-매크로-토큰"><a class="header" href="#선언적-매크로-토큰과-절차적-매크로-토큰">선언적 매크로 토큰과 절차적 매크로 토큰</a></h3>
<div class="rule" id="r-macro.proc.token.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.intro" title="macro.proc.token.intro"><span>[macro<wbr>.proc<wbr>.token<wbr>.intro]<span/></a></div>
<p>선언적 <code>macro_rules</code> 매크로와 절차적 매크로는 토큰(또는 <a href="../proc_macro/enum.TokenTree.html"><code>TokenTree</code>s</a>)에 대해 비슷하지만 다른 정의를 사용합니다.</p>
<div class="rule" id="r-macro.proc.token.macro_rules"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.macro_rules" title="macro.proc.token.macro_rules"><span>[macro<wbr>.proc<wbr>.token<wbr>.macro_rules]<span/></a></div>
<p><code>macro_rules</code>의 토큰 트리(<code>tt</code> 매처에 해당)는 다음과 같이 정의됩니다.</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 모든 연산자, 단일 문자 및 다중 문자 연산자 모두 포함(<code>+</code>, <code>+=</code>).
<ul>
<li>이 집합에는 작은따옴표 <code>'</code>가 포함되지 않음에 유의하세요.</li>
</ul>
</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 절대 리터럴 토큰의 일부가 아니며, 별도의 연산자 토큰임에 유의하세요.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>라이프타임 (<code>'ident</code>)</li>
<li><code>macro_rules</code>의 메타변수 치환 (예: <code>mac</code>의 확장 후 <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code>에서의 <code>$my_expr</code>. 전달된 표현식과 관계없이 단일 토큰 트리로 간주됨)</li>
</ul>
<div class="rule" id="r-macro.proc.token.tree"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.tree" title="macro.proc.token.tree"><span>[macro<wbr>.proc<wbr>.token<wbr>.tree]<span/></a></div>
<p>절차적 매크로에서 토큰 트리는 다음과 같이 정의됩니다</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 연산자에 사용되는 모든 구두점 문자(<code>+</code>, 단 <code>+=</code>는 아님) 및 작은따옴표 <code>'</code> 문자(주로 라이프타임에 사용됨. 라이프타임 분리 및 결합 동작은 아래 참조)</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 정수 및 부동 소수점 리터럴의 일부로 지원됩니다.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
</ul>
<div class="rule" id="r-macro.proc.token.conversion.intro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.conversion.intro" title="macro.proc.token.conversion.intro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.intro]<span/></a></div>
<p>이 두 정의 간의 불일치는 토큰 스트림이 절차적 매크로로 전달되거나 반환될 때 고려됩니다.<br />
아래의 변환은 지연되어 발생할 수 있으므로, 토큰이 실제로 검사되지 않으면 발생하지 않을 수 있음에 유의하세요.</p>
<div class="rule" id="r-macro.proc.token.conversion.to-proc_macro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.conversion.to-proc_macro" title="macro.proc.token.conversion.to-proc_macro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.to-proc_macro]<span/></a></div>
<p>절차적 매크로로 전달될 때</p>
<ul>
<li>모든 다중 문자 연산자는 단일 문자로 분리됩니다.</li>
<li>라이프타임은 <code>'</code> 문자와 식별자로 분리됩니다.</li>
<li>모든 메타변수 치환은 기본 토큰 스트림으로 표현됩니다.
<ul>
<li>이러한 토큰 스트림은 파싱 우선순위를 보존하기 위해 필요한 경우 암시적 구분자(<a href="../proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>)를 가진 구분된 그룹(<a href="../proc_macro/struct.Group.html"><code>Group</code></a>)으로 래핑될 수 있습니다.</li>
<li><code>tt</code> 및 <code>ident</code> 치환은 절대 이러한 그룹으로 래핑되지 않으며 항상 기본 토큰 트리로 표현됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.proc.token.conversion.from-proc_macro"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.conversion.from-proc_macro" title="macro.proc.token.conversion.from-proc_macro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.from-proc_macro]<span/></a></div>
<p>절차적 매크로에서 방출될 때</p>
<ul>
<li>구두점 문자는 가능한 경우 다중 문자 연산자로 결합됩니다.</li>
<li>식별자와 결합된 작은따옴표 <code>'</code>는 라이프타임으로 결합됩니다.</li>
<li>음수 리터럴은 두 개의 토큰(<code>-</code>와 리터럴)으로 변환되며, 파싱 우선순위를 보존하기 위해 필요한 경우 암시적 구분자(<a href="../proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>)를 가진 구분된 그룹(<a href="../proc_macro/struct.Group.html"><code>Group</code></a>)으로 래핑될 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.proc.token.doc-comment"><a class="rule-link" href="procedural-macros.html#r-macro.proc.token.doc-comment" title="macro.proc.token.doc-comment"><span>[macro<wbr>.proc<wbr>.token<wbr>.doc-comment]<span/></a></div>
<p>선언적 매크로와 절차적 매크로 모두 문서 주석 토큰(예: <code>/// Doc</code>)을 지원하지 않으므로, 매크로로 전달될 때는 항상 이에 상응하는 <code>#[doc = r"str"]</code> 속성을 나타내는 토큰 스트림으로 변환된다는 점에 유의하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-crate"><a class="rule-link" href="crates-and-source-files.html#r-crate" title="crate"><span>[crate]<span/></a></div>
<h1 id="크레이트와-소스-파일"><a class="header" href="#크레이트와-소스-파일">크레이트와 소스 파일</a></h1>
<div class="rule" id="r-crate.syntax"><a class="rule-link" href="crates-and-source-files.html#r-crate.syntax" title="crate.syntax"><span>[crate<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>크레이트</em> :<br />
   <a href="attributes.html"><em>내부속성</em></a><sup>*</sup><br />
   <a href="items.html"><em>아이템</em></a><sup>*</sup></p>
</blockquote>
<blockquote>
<p>참고: 러스트는 다른 언어들과 마찬가지로 컴파일러뿐만 아니라 인터프리터로도 구현될 수 있지만, 현재 존재하는 유일한 구현은 컴파일러이며, 이 언어는 항상 컴파일되도록 설계되었습니다. 이러한 이유로 이 섹션에서는 컴파일러를 가정합니다.</p>
</blockquote>
<div class="rule" id="r-crate.compile-time"><a class="rule-link" href="crates-and-source-files.html#r-crate.compile-time" title="crate.compile-time"><span>[crate<wbr>.compile-time]<span/></a></div>
<p>러스트의 시맨틱은 컴파일 타임과 런타임 사이의 _단계 구분_을 따릅니다.<sup class="footnote-reference"><a href="#phase-distinction">1</a></sup> _정적 해석_을 갖는 시맨틱 규칙은 컴파일의 성공 여부를 결정하며, _동적 해석_을 갖는 시맨틱 규칙은 런타임에서의 프로그램 동작을 결정합니다.</p>
<div class="rule" id="r-crate.unit"><a class="rule-link" href="crates-and-source-files.html#r-crate.unit" title="crate.unit"><span>[crate<wbr>.unit]<span/></a></div>
<p>컴파일 모델은 _크레이트_라고 불리는 결과물을 중심으로 합니다. 각 컴파일 과정은 소스 형태의 단일 크레이트를 처리하며, 성공하면 실행 파일이나 라이브러리 형태의 단일 바이너리 크레이트를 생성합니다.<sup class="footnote-reference"><a href="#cratesourcefile">2</a></sup></p>
<div class="rule" id="r-crate.module"><a class="rule-link" href="crates-and-source-files.html#r-crate.module" title="crate.module"><span>[crate<wbr>.module]<span/></a></div>
<p>_크레이트_는 컴파일과 링크의 단위일 뿐만 아니라 버전 관리, 배포 및 런타임 로딩의 단위이기도 합니다. 크레이트는 중첩된 <a href="items/modules.html">모듈</a> 스코프의 _트리_를 포함합니다. 이 트리의 최상위 레벨은 (모듈 내 경로의 관점에서 볼 때) 익명 모듈이며, 크레이트 내의 모든 아이템은 크레이트의 모듈 트리 내 위치를 나타내는 정규 <a href="paths.html">모듈 경로</a>를 가집니다.</p>
<div class="rule" id="r-crate.input-source"><a class="rule-link" href="crates-and-source-files.html#r-crate.input-source" title="crate.input-source"><span>[crate<wbr>.input-source]<span/></a></div>
<p>러스트 컴파일러는 항상 단일 소스 파일을 입력으로 호출되며, 항상 단일 출력 크레이트를 생성합니다. 해당 소스 파일을 처리하는 과정에서 다른 소스 파일이 모듈로 로드될 수 있습니다. 소스 파일의 확장자는 <code>.rs</code>입니다.</p>
<div class="rule" id="r-crate.module-def"><a class="rule-link" href="crates-and-source-files.html#r-crate.module-def" title="crate.module-def"><span>[crate<wbr>.module-def]<span/></a></div>
<p>러스트 소스 파일은 모듈을 설명하며, 현재 크레이트의 모듈 트리 내에서의 이름과 위치는 소스 파일 외부에서 정의됩니다. 이는 참조하는 소스 파일 내의 명시적인 <a href="items/modules.html"><em>모듈</em></a> 아이템에 의하거나 크레이트 자체의 이름에 의해 결정됩니다.</p>
<div class="rule" id="r-crate.inline-module"><a class="rule-link" href="crates-and-source-files.html#r-crate.inline-module" title="crate.inline-module"><span>[crate<wbr>.inline-module]<span/></a></div>
<p>모든 소스 파일은 모듈이지만, 모든 모듈이 별도의 소스 파일을 가질 필요는 없습니다. <a href="items/modules.html">모듈 정의</a>는 하나의 파일 내에 중첩될 수 있습니다.</p>
<div class="rule" id="r-crate.items"><a class="rule-link" href="crates-and-source-files.html#r-crate.items" title="crate.items"><span>[crate<wbr>.items]<span/></a></div>
<p>각 소스 파일은 0개 이상의 <a href="items.html"><em>아이템</em></a> 정의 시퀀스를 포함하며, 선택적으로 해당 모듈에 적용되는 임의의 개수의 <a href="attributes.html">속성</a>으로 시작할 수 있습니다. 대부분의 속성은 컴파일러의 동작에 영향을 미칩니다.</p>
<div class="rule" id="r-crate.attributes"><a class="rule-link" href="crates-and-source-files.html#r-crate.attributes" title="crate.attributes"><span>[crate<wbr>.attributes]<span/></a></div>
<p>익명 크레이트 모듈은 크레이트 전체에 적용되는 추가 속성을 가질 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 파일 내용 앞에 <a href="input-format.html#shebang-removal">쉬뱅</a>이 올 수 있습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 크레이트 이름을 지정합니다.
#![crate_name = "projx"]

// 출력 아티팩트의 타입을 지정합니다.
#![crate_type = "lib"]

// 경고를 활성화합니다.
// 이 작업은 익명 크레이트 모듈뿐만 아니라 모든 모듈에서 수행할 수 있습니다.
#![warn(non_camel_case_types)]
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-crate.main"><a class="rule-link" href="crates-and-source-files.html#r-crate.main" title="crate.main"><span>[crate<wbr>.main]<span/></a></div>
<h2 id="메인-함수"><a class="header" href="#메인-함수">메인 함수</a></h2>
<div class="rule" id="r-crate.main.general"><a class="rule-link" href="crates-and-source-files.html#r-crate.main.general" title="crate.main.general"><span>[crate<wbr>.main<wbr>.general]<span/></a></div>
<p><code>main</code> <a href="items/functions.html">함수</a>를 포함하는 크레이트는 실행 파일로 컴파일될 수 있습니다.</p>
<div class="rule" id="r-crate.main.restriction"><a class="rule-link" href="crates-and-source-files.html#r-crate.main.restriction" title="crate.main.restriction"><span>[crate<wbr>.main<wbr>.restriction]<span/></a></div>
<p><code>main</code> 함수가 존재하는 경우, 인자를 받지 않아야 하며, 어떠한 <a href="trait-bounds.html">트레잇 또는 라이프타임 바운드</a>도 선언하지 않아야 하고, <a href="items/generics.html#where-clauses">where 절</a>을 가져서는 안 되며, 반환 타입은 <a href="../std/process/trait.Termination.html"><code>Termination</code></a> 트레잇을 구현해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; ! {
    std::process::exit(0);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; impl std::process::Termination {
    std::process::ExitCode::SUCCESS
}</code></pre></pre>
<div class="rule" id="r-crate.main.import"><a class="rule-link" href="crates-and-source-files.html#r-crate.main.import" title="crate.main.import"><span>[crate<wbr>.main<wbr>.import]<span/></a></div>
<p><code>main</code> 함수는 외부 크레이트나 현재 크레이트로부터 임포트된 것일 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    pub fn bar() {
        println!("Hello, world!");
    }
}
use foo::bar as main;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 표준 라이브러리에서 <a href="../std/process/trait.Termination.html"><code>Termination</code></a> 구현을 가진 타입은 다음과 같습니다:</p>
<ul>
<li><code>()</code></li>
<li><a href="types/never.html"><code>!</code></a></li>
<li><a href="../core/convert/enum.Infallible.html"><code>Infallible</code></a></li>
<li><a href="../std/process/struct.ExitCode.html"><code>ExitCode</code></a></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
</ul>
</blockquote>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the testing.md file -->
<div class="rule" id="r-crate.no_main"><a class="rule-link" href="crates-and-source-files.html#r-crate.no_main" title="crate.no_main"><span>[crate<wbr>.no_main]<span/></a></div>
<h3 id="no_main-속성"><a class="header" href="#no_main-속성"><code>no_main</code> 속성</a></h3>
<p>The _<code>no_main</code> <a href="attributes.html">속성</a>_은 실행 가능한 바이너리에 대해 <code>main</code> 기호 내보내기를 비활성화하기 위해 크레이트 수준에서 적용될 수 있습니다. 이것은 연결되는 다른 일부 개체가 <code>main</code>을 정의할 때 유용합니다.</p>
<div class="rule" id="r-crate.crate_name"><a class="rule-link" href="crates-and-source-files.html#r-crate.crate_name" title="crate.crate_name"><span>[crate<wbr>.crate_name]<span/></a></div>
<h2 id="crate_name-속성"><a class="header" href="#crate_name-속성"><code>crate_name</code> 속성</a></h2>
<div class="rule" id="r-crate.crate_name.general"><a class="rule-link" href="crates-and-source-files.html#r-crate.crate_name.general" title="crate.crate_name.general"><span>[crate<wbr>.crate_name<wbr>.general]<span/></a></div>
<p>The _<code>crate_name</code> <a href="attributes.html">속성</a>_은 <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용하여 크레이트의 이름을 지정하기 위해 크레이트 수준에서 적용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![crate_name = "mycrate"]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-crate.crate_name.restriction"><a class="rule-link" href="crates-and-source-files.html#r-crate.crate_name.restriction" title="crate.crate_name.restriction"><span>[crate<wbr>.crate_name<wbr>.restriction]<span/></a></div>
<p>크레이트 이름은 비어 있으면 안 되며, <a href="../std/primitive.char.html#method.is_alphanumeric">유니코드 영숫자</a> 또는 <code>_</code> (U+005F) 문자만 포함해야 합니다.</p>
<div class="footnote-definition" id="phase-distinction"><sup class="footnote-definition-label">1</sup>
<p>이러한 구별은 인터프리터에도 존재합니다. 구문 분석, 유형 검사 및 린트와 같은 정적 검사는 프로그램이 실행되는 시점과 관계없이 프로그램이 실행되기 전에 수행되어야 합니다.</p>
</div>
<div class="footnote-definition" id="cratesourcefile"><sup class="footnote-definition-label">2</sup>
<p>크레이트는 ECMA-335 CLI 모델의 <em>어셈블리</em>, SML/NJ 컴파일 관리자의 <em>라이브러리</em>, Owens 및 Flatt 모듈 시스템의 <em>단위</em> 또는 Mesa의 _구성_과 다소 유사합니다.</p>
</div>
<script>
(function() {
    var fragments = {
        "#preludes-and-no_std": "names/preludes.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-cfg"><a class="rule-link" href="conditional-compilation.html#r-cfg" title="cfg"><span>[cfg]<span/></a></div>
<h1 id="조건부-컴파일"><a class="header" href="#조건부-컴파일">조건부 컴파일</a></h1>
<div class="rule" id="r-cfg.syntax"><a class="rule-link" href="conditional-compilation.html#r-cfg.syntax" title="cfg.syntax"><span>[cfg<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ConfigurationPredicate</em> :<br />
      <em>ConfigurationOption</em><br />
   | <em>ConfigurationAll</em><br />
   | <em>ConfigurationAny</em><br />
   | <em>ConfigurationNot</em></p>
<p><em>ConfigurationOption</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> (<code>=</code> (<a href="tokens.html#string-literals">STRING_LITERAL</a> | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a>))<sup>?</sup></p>
<p><em>ConfigurationAll</em><br />
   <code>all</code> <code>(</code> <em>ConfigurationPredicateList</em><sup>?</sup> <code>)</code></p>
<p><em>ConfigurationAny</em><br />
   <code>any</code> <code>(</code> <em>ConfigurationPredicateList</em><sup>?</sup> <code>)</code></p>
<p><em>ConfigurationNot</em><br />
   <code>not</code> <code>(</code> <em>ConfigurationPredicate</em> <code>)</code></p>
<p><em>ConfigurationPredicateList</em><br />
   <em>ConfigurationPredicate</em> (<code>,</code> <em>ConfigurationPredicate</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-cfg.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.general" title="cfg.general"><span>[cfg<wbr>.general]<span/></a></div>
<p>_조건부로 컴파일된 소스 코드_는 특정 조건에서만 컴파일되는 소스 코드입니다.</p>
<div class="rule" id="r-cfg.attributes-macro"><a class="rule-link" href="conditional-compilation.html#r-cfg.attributes-macro" title="cfg.attributes-macro"><span>[cfg<wbr>.attributes-macro]<span/></a></div>
<p>소스 코드는 <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> 및 <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> <a href="attributes.html">속성</a>과 내장된 <a href="conditional-compilation.html#the-cfg-macro"><code>cfg</code> 매크로</a>를 사용하여 조건부로 컴파일할 수 있습니다.</p>
<div class="rule" id="r-cfg.conditional"><a class="rule-link" href="conditional-compilation.html#r-cfg.conditional" title="cfg.conditional"><span>[cfg<wbr>.conditional]<span/></a></div>
<p>컴파일 여부는 컴파일된 크레이트의 대상 아키텍처, 컴파일러에 전달된 임의의 값 및 아래에 자세히 설명된 기타 사항에 따라 달라질 수 있습니다.</p>
<div class="rule" id="r-cfg.predicate"><a class="rule-link" href="conditional-compilation.html#r-cfg.predicate" title="cfg.predicate"><span>[cfg<wbr>.predicate]<span/></a></div>
<p>각 형태의 조건부 컴파일은 참 또는 거짓으로 평가되는 _구성 술어_를 사용합니다. 술어는 다음 중 하나입니다.</p>
<div class="rule" id="r-cfg.predicate.option"><a class="rule-link" href="conditional-compilation.html#r-cfg.predicate.option" title="cfg.predicate.option"><span>[cfg<wbr>.predicate<wbr>.option]<span/></a></div>
<ul>
<li>구성 옵션. 옵션이 설정되면 술어는 참이고 설정되지 않으면 거짓입니다.</li>
</ul>
<div class="rule" id="r-cfg.predicate.all"><a class="rule-link" href="conditional-compilation.html#r-cfg.predicate.all" title="cfg.predicate.all"><span>[cfg<wbr>.predicate<wbr>.all]<span/></a></div>
<ul>
<li><code>all()</code>은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 모든 술어가 참이거나 목록이 비어 있으면 참입니다.</li>
</ul>
<div class="rule" id="r-cfg.predicate.any"><a class="rule-link" href="conditional-compilation.html#r-cfg.predicate.any" title="cfg.predicate.any"><span>[cfg<wbr>.predicate<wbr>.any]<span/></a></div>
<ul>
<li><code>any()</code>은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 술어 중 하나 이상이 참이면 참입니다. 술어가 없으면 거짓입니다.</li>
</ul>
<div class="rule" id="r-cfg.predicate.not"><a class="rule-link" href="conditional-compilation.html#r-cfg.predicate.not" title="cfg.predicate.not"><span>[cfg<wbr>.predicate<wbr>.not]<span/></a></div>
<ul>
<li><code>not()</code>은 구성 술어와 함께 사용됩니다. 술어가 거짓이면 참이고 술어가 참이면 거짓입니다.</li>
</ul>
<div class="rule" id="r-cfg.option-spec"><a class="rule-link" href="conditional-compilation.html#r-cfg.option-spec" title="cfg.option-spec"><span>[cfg<wbr>.option-spec]<span/></a></div>
<p>_구성 옵션_은 이름 또는 키-값 쌍이며 설정되거나 설정되지 않습니다.</p>
<div class="rule" id="r-cfg.option-name"><a class="rule-link" href="conditional-compilation.html#r-cfg.option-name" title="cfg.option-name"><span>[cfg<wbr>.option-name]<span/></a></div>
<p>이름은 <code>unix</code>와 같이 단일 식별자로 작성됩니다.</p>
<div class="rule" id="r-cfg.option-key-value"><a class="rule-link" href="conditional-compilation.html#r-cfg.option-key-value" title="cfg.option-key-value"><span>[cfg<wbr>.option-key-value]<span/></a></div>
<p>키-값 쌍은 식별자, <code>=</code>, 그리고 문자열로 작성됩니다(예: <code>target_arch = "x86_64"</code>).</p>
<blockquote>
<p><strong>참고</strong>: <code>=</code> 주변의 공백은 무시되므로 <code>foo="bar"</code>와 <code>foo = "bar"</code>는 동일합니다.</p>
</blockquote>
<div class="rule" id="r-cfg.option-key-uniqueness"><a class="rule-link" href="conditional-compilation.html#r-cfg.option-key-uniqueness" title="cfg.option-key-uniqueness"><span>[cfg<wbr>.option-key-uniqueness]<span/></a></div>
<p>키는 고유할 필요가 없습니다. 예를 들어, <code>feature = "std"</code>와 <code>feature = "serde"</code>를 동시에 설정할 수 있습니다.</p>
<div class="rule" id="r-cfg.options.set"><a class="rule-link" href="conditional-compilation.html#r-cfg.options.set" title="cfg.options.set"><span>[cfg<wbr>.options<wbr>.set]<span/></a></div>
<h2 id="구성-옵션-설정"><a class="header" href="#구성-옵션-설정">구성 옵션 설정</a></h2>
<div class="rule" id="r-cfg.options.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.options.general" title="cfg.options.general"><span>[cfg<wbr>.options<wbr>.general]<span/></a></div>
<p>어떤 구성 옵션이 설정되는지는 크레이트 컴파일 중에 정적으로 결정됩니다.</p>
<div class="rule" id="r-cfg.options.target"><a class="rule-link" href="conditional-compilation.html#r-cfg.options.target" title="cfg.options.target"><span>[cfg<wbr>.options<wbr>.target]<span/></a></div>
<p>일부 옵션은 컴파일에 대한 데이터를 기반으로 _컴파일러 설정_됩니다.</p>
<div class="rule" id="r-cfg.options.other"><a class="rule-link" href="conditional-compilation.html#r-cfg.options.other" title="cfg.options.other"><span>[cfg<wbr>.options<wbr>.other]<span/></a></div>
<p>다른 옵션은 코드 외부에서 컴파일러에 전달된 입력을 기반으로 _임의로 설정_됩니다.</p>
<div class="rule" id="r-cfg.options.crate"><a class="rule-link" href="conditional-compilation.html#r-cfg.options.crate" title="cfg.options.crate"><span>[cfg<wbr>.options<wbr>.crate]<span/></a></div>
<p>컴파일 중인 크레이트의 소스 코드 내에서 구성 옵션을 설정할 수 없습니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code>의 경우, 임의로 설정된 구성 옵션은 <a href="../rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment"><code>--cfg</code></a> 플래그를 사용하여 설정됩니다. 지정된 대상에 대한 구성 값은 <code>rustc --print cfg --target $TARGET</code>으로 표시할 수 있습니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: <code>feature</code> 키가 있는 구성 옵션은 컴파일 시간 옵션 및 선택적 종속성을 지정하기 위해 <a href="../cargo/reference/features.html">Cargo</a>에서 사용하는 규칙입니다.</p>
</blockquote>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 임의로 설정된 구성 옵션은 컴파일러 설정 구성 옵션과 충돌할 수 있습니다. 예를 들어, Windows 대상으로 컴파일하는 동안 <code>rustc --cfg "unix" program.rs</code>를 수행하고 <code>unix</code>와 <code>windows</code> 구성 옵션을 동시에 설정할 수 있습니다. 이렇게 하는 것은 현명하지 않습니다.</p>
</blockquote>
</div>
<div class="rule" id="r-cfg.target_arch"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_arch" title="cfg.target_arch"><span>[cfg<wbr>.target_arch]<span/></a></div>
<h3 id="target_arch"><a class="header" href="#target_arch"><code>target_arch</code></a></h3>
<div class="rule" id="r-cfg.target_arch.gen"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_arch.gen" title="cfg.target_arch.gen"><span>[cfg<wbr>.target_arch<wbr>.gen]<span/></a></div>
<p>키-값 옵션은 대상의 CPU 아키텍처로 한 번 설정됩니다. 값은 플랫폼의 대상 트리플의 첫 번째 요소와 유사하지만 동일하지는 않습니다.</p>
<div class="rule" id="r-cfg.target_arch.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_arch.values" title="cfg.target_arch.values"><span>[cfg<wbr>.target_arch<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"x86"</code></li>
<li><code>"x86_64"</code></li>
<li><code>"mips"</code></li>
<li><code>"powerpc"</code></li>
<li><code>"powerpc64"</code></li>
<li><code>"arm"</code></li>
<li><code>"aarch64"</code></li>
</ul>
<div class="rule" id="r-cfg.target_feature"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_feature" title="cfg.target_feature"><span>[cfg<wbr>.target_feature]<span/></a></div>
<h3 id="target_feature"><a class="header" href="#target_feature"><code>target_feature</code></a></h3>
<div class="rule" id="r-cfg.target_feature.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_feature.general" title="cfg.target_feature.general"><span>[cfg<wbr>.target_feature<wbr>.general]<span/></a></div>
<p>현재 컴파일 대상에 사용할 수 있는 각 플랫폼 기능에 대해 설정된 키-값 옵션입니다.</p>
<div class="rule" id="r-cfg.target_feature.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_feature.values" title="cfg.target_feature.values"><span>[cfg<wbr>.target_feature<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"avx"</code></li>
<li><code>"avx2"</code></li>
<li><code>"crt-static"</code></li>
<li><code>"rdrand"</code></li>
<li><code>"sse"</code></li>
<li><code>"sse2"</code></li>
<li><code>"sse4.1"</code></li>
</ul>
<p>사용 가능한 기능에 대한 자세한 내용은 <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code> 속성</a>을 참조하십시오.</p>
<div class="rule" id="r-cfg.target_feature.crt_static"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_feature.crt_static" title="cfg.target_feature.crt_static"><span>[cfg<wbr>.target_feature<wbr>.crt_static]<span/></a></div>
<p>An additional feature of <code>crt-static</code> is available to the <code>target_feature</code> option to indicate that a <a href="linkage.html#static-and-dynamic-c-runtimes">static C runtime</a> is available.</p>
<div class="rule" id="r-cfg.target_os"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_os" title="cfg.target_os"><span>[cfg<wbr>.target_os]<span/></a></div>
<h3 id="target_os"><a class="header" href="#target_os"><code>target_os</code></a></h3>
<div class="rule" id="r-cfg.target_os.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_os.general" title="cfg.target_os.general"><span>[cfg<wbr>.target_os<wbr>.general]<span/></a></div>
<p>키-값 옵션은 대상의 운영 체제로 한 번 설정됩니다. 이 값은 플랫폼의 대상 트리플의 두 번째 및 세 번째 요소와 유사합니다.</p>
<div class="rule" id="r-cfg.target_os.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_os.values" title="cfg.target_os.values"><span>[cfg<wbr>.target_os<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"windows"</code></li>
<li><code>"macos"</code></li>
<li><code>"ios"</code></li>
<li><code>"linux"</code></li>
<li><code>"android"</code></li>
<li><code>"freebsd"</code></li>
<li><code>"dragonfly"</code></li>
<li><code>"openbsd"</code></li>
<li><code>"netbsd"</code></li>
<li><code>"none"</code> (임베디드 대상의 경우 일반적)</li>
</ul>
<div class="rule" id="r-cfg.target_family"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_family" title="cfg.target_family"><span>[cfg<wbr>.target_family]<span/></a></div>
<h3 id="target_family"><a class="header" href="#target_family"><code>target_family</code></a></h3>
<div class="rule" id="r-cfg.target_family.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_family.general" title="cfg.target_family.general"><span>[cfg<wbr>.target_family<wbr>.general]<span/></a></div>
<p>키-값 옵션은 대상이 일반적으로 속하는 운영 체제 또는 아키텍처 제품군과 같이 대상에 대한 보다 일반적인 설명을 제공합니다. <code>target_family</code> 키-값 쌍은 여러 개 설정할 수 있습니다.</p>
<div class="rule" id="r-cfg.target_family.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_family.values" title="cfg.target_family.values"><span>[cfg<wbr>.target_family<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"unix"</code></li>
<li><code>"windows"</code></li>
<li><code>"wasm"</code></li>
<li><code>"unix"</code>와 <code>"wasm"</code> 모두</li>
</ul>
<div class="rule" id="r-cfg.target_family.unix"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_family.unix" title="cfg.target_family.unix"><span>[cfg<wbr>.target_family<wbr>.unix]<span/></a></div>
<h3 id="unix-및-windows"><a class="header" href="#unix-및-windows"><code>unix</code> 및 <code>windows</code></a></h3>
<p><code>unix</code>는 <code>target_family = "unix"</code>가 설정되면 설정됩니다.</p>
<div class="rule" id="r-cfg.target_family.windows"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_family.windows" title="cfg.target_family.windows"><span>[cfg<wbr>.target_family<wbr>.windows]<span/></a></div>
<p><code>windows</code>는 <code>target_family = "windows"</code>가 설정되면 설정됩니다.</p>
<div class="rule" id="r-cfg.target_env"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_env" title="cfg.target_env"><span>[cfg<wbr>.target_env]<span/></a></div>
<h3 id="target_env"><a class="header" href="#target_env"><code>target_env</code></a></h3>
<div class="rule" id="r-cfg.target_env.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_env.general" title="cfg.target_env.general"><span>[cfg<wbr>.target_env<wbr>.general]<span/></a></div>
<p>사용된 ABI 또는 <code>libc</code>에 대한 정보와 함께 대상 플랫폼에 대한 추가 명확화 정보로 설정된 키-값 옵션입니다. 역사적인 이유로 이 값은 실제로 명확화가 필요할 때만 빈 문자열이 아닌 것으로 정의됩니다. 따라서 예를 들어 많은 GNU 플랫폼에서 이 값은 비어 있습니다. 이 값은 플랫폼의 대상 트리플의 네 번째 요소와 유사합니다. 한 가지 차이점은 <code>gnueabihf</code>와 같은 임베디드 ABI는 단순히 <code>target_env</code>를 <code>"gnu"</code>로 정의한다는 것입니다.</p>
<div class="rule" id="r-cfg.target_env.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_env.values" title="cfg.target_env.values"><span>[cfg<wbr>.target_env<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>""</code></li>
<li><code>"gnu"</code></li>
<li><code>"msvc"</code></li>
<li><code>"musl"</code></li>
<li><code>"sgx"</code></li>
</ul>
<div class="rule" id="r-cfg.target_abi"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_abi" title="cfg.target_abi"><span>[cfg<wbr>.target_abi]<span/></a></div>
<h3 id="target_abi"><a class="header" href="#target_abi"><code>target_abi</code></a></h3>
<div class="rule" id="r-cfg.target_abi.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_abi.general" title="cfg.target_abi.general"><span>[cfg<wbr>.target_abi<wbr>.general]<span/></a></div>
<p>대상 ABI에 대한 정보로 <code>target_env</code>를 추가로 명확히 하기 위해 설정된 키-값 옵션입니다.</p>
<div class="rule" id="r-cfg.target_abi.disambiguation"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_abi.disambiguation" title="cfg.target_abi.disambiguation"><span>[cfg<wbr>.target_abi<wbr>.disambiguation]<span/></a></div>
<p>역사적인 이유로 이 값은 실제로 명확화가 필요할 때만 빈 문자열이 아닌 것으로 정의됩니다. 따라서 예를 들어 많은 GNU 플랫폼에서 이 값은 비어 있습니다.</p>
<div class="rule" id="r-cfg.target_abi.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_abi.values" title="cfg.target_abi.values"><span>[cfg<wbr>.target_abi<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>""</code></li>
<li><code>"llvm"</code></li>
<li><code>"eabihf"</code></li>
<li><code>"abi64"</code></li>
<li><code>"sim"</code></li>
<li><code>"macabi"</code></li>
</ul>
<div class="rule" id="r-cfg.target_endian"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_endian" title="cfg.target_endian"><span>[cfg<wbr>.target_endian]<span/></a></div>
<h3 id="target_endian"><a class="header" href="#target_endian"><code>target_endian</code></a></h3>
<p>키-값 옵션은 대상의 CPU 엔디안에 따라 “little” 또는 “big” 값으로 한 번 설정됩니다.</p>
<div class="rule" id="r-cfg.target_pointer_width"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_pointer_width" title="cfg.target_pointer_width"><span>[cfg<wbr>.target_pointer_width]<span/></a></div>
<h3 id="target_pointer_width"><a class="header" href="#target_pointer_width"><code>target_pointer_width</code></a></h3>
<div class="rule" id="r-cfg.target_pointer_width.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_pointer_width.general" title="cfg.target_pointer_width.general"><span>[cfg<wbr>.target_pointer_width<wbr>.general]<span/></a></div>
<p>키-값 옵션은 대상의 포인터 너비를 비트 단위로 한 번 설정합니다.</p>
<div class="rule" id="r-cfg.target_pointer_width.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_pointer_width.values" title="cfg.target_pointer_width.values"><span>[cfg<wbr>.target_pointer_width<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"16"</code></li>
<li><code>"32"</code></li>
<li><code>"64"</code></li>
</ul>
<div class="rule" id="r-cfg.target_vendor"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_vendor" title="cfg.target_vendor"><span>[cfg<wbr>.target_vendor]<span/></a></div>
<h3 id="target_vendor"><a class="header" href="#target_vendor"><code>target_vendor</code></a></h3>
<div class="rule" id="r-cfg.target_vendor.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_vendor.general" title="cfg.target_vendor.general"><span>[cfg<wbr>.target_vendor<wbr>.general]<span/></a></div>
<p>키-값 옵션은 대상의 공급업체로 한 번 설정됩니다.</p>
<div class="rule" id="r-cfg.target_vendor.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_vendor.values" title="cfg.target_vendor.values"><span>[cfg<wbr>.target_vendor<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"apple"</code></li>
<li><code>"fortanix"</code></li>
<li><code>"pc"</code></li>
<li><code>"unknown"</code></li>
</ul>
<div class="rule" id="r-cfg.target_has_atomic"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_has_atomic" title="cfg.target_has_atomic"><span>[cfg<wbr>.target_has_atomic]<span/></a></div>
<h3 id="target_has_atomic"><a class="header" href="#target_has_atomic"><code>target_has_atomic</code></a></h3>
<div class="rule" id="r-cfg.target_has_atomic.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_has_atomic.general" title="cfg.target_has_atomic.general"><span>[cfg<wbr>.target_has_atomic<wbr>.general]<span/></a></div>
<p>대상이 원자적 로드, 저장 및 비교-스왑 작업을 지원하는 각 비트 너비에 대해 설정된 키-값 옵션입니다.</p>
<div class="rule" id="r-cfg.target_has_atomic.stdlib"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_has_atomic.stdlib" title="cfg.target_has_atomic.stdlib"><span>[cfg<wbr>.target_has_atomic<wbr>.stdlib]<span/></a></div>
<p>이 cfg가 있으면 관련 원자 너비에 대해 안정적인 <a href="../core/sync/atomic/index.html"><code>core::sync::atomic</code></a> API를 모두 사용할 수 있습니다.</p>
<div class="rule" id="r-cfg.target_has_atomic.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.target_has_atomic.values" title="cfg.target_has_atomic.values"><span>[cfg<wbr>.target_has_atomic<wbr>.values]<span/></a></div>
<p>가능한 값:</p>
<ul>
<li><code>"8"</code></li>
<li><code>"16"</code></li>
<li><code>"32"</code></li>
<li><code>"64"</code></li>
<li><code>"128"</code></li>
<li><code>"ptr"</code></li>
</ul>
<div class="rule" id="r-cfg.test"><a class="rule-link" href="conditional-compilation.html#r-cfg.test" title="cfg.test"><span>[cfg<wbr>.test]<span/></a></div>
<h3 id="test"><a class="header" href="#test"><code>test</code></a></h3>
<p>테스트 하네스를 컴파일할 때 활성화됩니다. <code>rustc</code>로 <a href="../rustc/command-line-arguments.html#--test-build-a-test-harness"><code>--test</code></a> 플래그를 사용하여 수행됩니다. 테스트 지원에 대한 자세한 내용은 <a href="attributes/testing.html">테스팅</a>을 참조하십시오.</p>
<div class="rule" id="r-cfg.debug_assertions"><a class="rule-link" href="conditional-compilation.html#r-cfg.debug_assertions" title="cfg.debug_assertions"><span>[cfg<wbr>.debug_assertions]<span/></a></div>
<h3 id="debug_assertions"><a class="header" href="#debug_assertions"><code>debug_assertions</code></a></h3>
<p>최적화 없이 컴파일할 때 기본적으로 활성화됩니다. 이는 프로덕션이 아닌 개발 환경에서 추가 디버깅 코드를 활성화하는 데 사용할 수 있습니다. 예를 들어, 표준 라이브러리의 <a href="../core/macro.debug_assert.html"><code>debug_assert!</code></a> 매크로의 동작을 제어합니다.</p>
<div class="rule" id="r-cfg.proc_macro"><a class="rule-link" href="conditional-compilation.html#r-cfg.proc_macro" title="cfg.proc_macro"><span>[cfg<wbr>.proc_macro]<span/></a></div>
<h3 id="proc_macro"><a class="header" href="#proc_macro"><code>proc_macro</code></a></h3>
<p>컴파일 중인 크레이트가 <code>proc_macro</code> <a href="linkage.html">크레이트 타입</a>으로 컴파일될 때 설정됩니다.</p>
<div class="rule" id="r-cfg.panic"><a class="rule-link" href="conditional-compilation.html#r-cfg.panic" title="cfg.panic"><span>[cfg<wbr>.panic]<span/></a></div>
<h3 id="panic"><a class="header" href="#panic"><code>panic</code></a></h3>
<div class="rule" id="r-cfg.panic.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.panic.general" title="cfg.panic.general"><span>[cfg<wbr>.panic<wbr>.general]<span/></a></div>
<p>패닉 전략에 따라 설정되는 키-값 옵션입니다. 미래에 더 많은 값이 추가될 수 있음에 유의하세요.</p>
<div class="rule" id="r-cfg.panic.values"><a class="rule-link" href="conditional-compilation.html#r-cfg.panic.values" title="cfg.panic.values"><span>[cfg<wbr>.panic<wbr>.values]<span/></a></div>
<p>예제 값:</p>
<ul>
<li><code>"abort"</code></li>
<li><code>"unwind"</code></li>
</ul>
<h2 id="조건부-컴파일의-형태"><a class="header" href="#조건부-컴파일의-형태">조건부 컴파일의 형태</a></h2>
<div class="rule" id="r-cfg.attr"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr" title="cfg.attr"><span>[cfg<wbr>.attr]<span/></a></div>
<h3 id="cfg-속성"><a class="header" href="#cfg-속성"><code>cfg</code> 속성</a></h3>
<div class="rule" id="r-cfg.attr.syntax"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.syntax" title="cfg.attr.syntax"><span>[cfg<wbr>.attr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>CfgAttr속성</em> :<br />
   <code>cfg</code> <code>(</code> <em>구성조건자</em> <code>)</code></p>
</blockquote>
<!-- should we say they're active attributes here? -->
<div class="rule" id="r-cfg.attr.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.general" title="cfg.attr.general"><span>[cfg<wbr>.attr<wbr>.general]<span/></a></div>
<p><code>cfg</code> <a href="attributes.html">속성</a>은 구성 조건자에 따라 부착된 대상을 조건부로 포함합니다.</p>
<div class="rule" id="r-cfg.attr.syntax-explanation"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.syntax-explanation" title="cfg.attr.syntax-explanation"><span>[cfg<wbr>.attr<wbr>.syntax-explanation]<span/></a></div>
<p><code>cfg</code>, <code>(</code>, 구성 조건자, 그리고 마지막으로 <code>)</code>로 작성됩니다.</p>
<div class="rule" id="r-cfg.attr.effect"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.effect" title="cfg.attr.effect"><span>[cfg<wbr>.attr<wbr>.effect]<span/></a></div>
<p>조건자가 참이면, 대상은 <code>cfg</code> 속성이 없는 상태로 다시 작성됩니다. 조건자가 거짓이면, 대상은 소스 코드에서 제거됩니다.</p>
<div class="rule" id="r-cfg.attr.crate-level-attrs"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.crate-level-attrs" title="cfg.attr.crate-level-attrs"><span>[cfg<wbr>.attr<wbr>.crate-level-attrs]<span/></a></div>
<p>크레이트 수준의 <code>cfg</code>가 거짓 술어를 가질 때, 동작이 약간 다릅니다. <code>cfg</code> 앞에 오는 모든 크레이트 속성은 유지되고, <code>cfg</code> 뒤에 오는 모든 크레이트 속성은 제거됩니다. 이를 통해 <code>#![cfg(...)]</code>가 크레이트 전체를 제거하더라도 #![no_std]<code>및</code>#![no_core]<code>크레이트가</code>std<code>/</code>core`를 링크하지 않도록 할 수 있습니다.</p>
<p>함수에 대한 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 함수는 macOS용으로 컴파일할 때만 빌드에 포함됩니다.
#[cfg(target_os = "macos")]
fn macos_only() {
  // ...
}

// 이 함수는 foo 또는 bar 중 하나가 정의된 경우에만 포함됩니다.
#[cfg(any(foo, bar))]
fn needs_foo_or_bar() {
  // ...
}

// 이 함수는 32비트 아키텍처의 unix 계열 OS용으로 컴파일할 때만 포함됩니다.
#[cfg(all(unix, target_pointer_width = "32"))]
fn on_32bit_unix() {
  // ...
}

// 이 함수는 foo가 정의되지 않은 경우에만 포함됩니다.
#[cfg(not(foo))]
fn needs_not_foo() {
  // ...
}

// 이 함수는 패닉 전략이 unwind로 설정된 경우에만 포함됩니다.
#[cfg(panic = "unwind")]
fn when_unwinding() {
  // ...
}

<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-cfg.attr.restriction"><a class="rule-link" href="conditional-compilation.html#r-cfg.attr.restriction" title="cfg.attr.restriction"><span>[cfg<wbr>.attr<wbr>.restriction]<span/></a></div>
<p><code>cfg</code> 속성은 속성이 허용되는 모든 곳에서 허용됩니다.</p>
<div class="rule" id="r-cfg.cfg_attr"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr" title="cfg.cfg_attr"><span>[cfg<wbr>.cfg_attr]<span/></a></div>
<h3 id="cfg_attr-속성"><a class="header" href="#cfg_attr-속성"><code>cfg_attr</code> 속성</a></h3>
<div class="rule" id="r-cfg.cfg_attr.syntax"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr.syntax" title="cfg.cfg_attr.syntax"><span>[cfg<wbr>.cfg_attr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>CfgAttr속성</em> :<br />
   <code>cfg_attr</code> <code>(</code> <em>구성술어</em> <code>,</code> <em>Cfg속성들</em><sup>?</sup> <code>)</code></p>
<p><em>Cfg속성들</em> :<br />
   <a href="attributes.html"><em>속성</em></a> (<code>,</code> <a href="attributes.html"><em>속성</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-cfg.cfg_attr.general"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr.general" title="cfg.cfg_attr.general"><span>[cfg<wbr>.cfg_attr<wbr>.general]<span/></a></div>
<p><code>cfg_attr</code> <a href="attributes.html">속성</a>은 구성 술어에 기반하여 조건부로 <a href="attributes.html">속성</a>들을 포함합니다.</p>
<div class="rule" id="r-cfg.cfg_attr.behaviour"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr.behaviour" title="cfg.cfg_attr.behaviour"><span>[cfg<wbr>.cfg_attr<wbr>.behaviour]<span/></a></div>
<p>구성 술어가 참일 때, 이 속성은 술어 뒤에 나열된 속성들로 확장됩니다. 예를 들어, 다음 모듈은 대상에 따라 <code>linux.rs</code> 또는 <code>windows.rs</code>에서 발견됩니다.</p>
<!-- ignore: `mod` needs multiple files -->
<pre><code class="language-rust ignore">#[cfg_attr(target_os = "linux", path = "linux.rs")]
#[cfg_attr(windows, path = "windows.rs")]
mod os;</code></pre>
<div class="rule" id="r-cfg.cfg_attr.attribute-list"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr.attribute-list" title="cfg.cfg_attr.attribute-list"><span>[cfg<wbr>.cfg_attr<wbr>.attribute-list]<span/></a></div>
<p>0개, 1개 또는 그 이상의 속성이 나열될 수 있습니다. 여러 속성은 각각 별도의 속성으로 확장됩니다. 예를 들어:</p>
<!-- ignore: fake attributes -->
<pre><code class="language-rust ignore">#[cfg_attr(feature = "magic", sparkles, crackles)]
fn bewitched() {}

// `magic` 피처 플래그가 활성화되면, 위 코드는 다음과 같이 확장됩니다:
#[sparkles]
#[crackles]
fn bewitched() {}</code></pre>
<blockquote>
<p><strong>참고</strong>: <code>cfg_attr</code>은 다른 <code>cfg_attr</code>로 확장될 수 있습니다. 예를 들어, <code>#[cfg_attr(target_os = "linux", cfg_attr(feature = "multithreaded", some_other_attribute))]</code>는 유효합니다. 이 예제는 <code>#[cfg_attr(all(target_os = "linux", feature ="multithreaded"), some_other_attribute)]</code>와 동일합니다.</p>
</blockquote>
<div class="rule" id="r-cfg.cfg_attr.restriction"><a class="rule-link" href="conditional-compilation.html#r-cfg.cfg_attr.restriction" title="cfg.cfg_attr.restriction"><span>[cfg<wbr>.cfg_attr<wbr>.restriction]<span/></a></div>
<p><code>cfg_attr</code> 속성은 속성이 허용되는 모든 곳에 허용됩니다.</p>
<p><a href="linkage.html"><code>crate_type</code></a> 및 <a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> 속성은 <code>cfg_attr</code>과 함께 사용할 수 없습니다.</p>
<div class="rule" id="r-cfg.macro"><a class="rule-link" href="conditional-compilation.html#r-cfg.macro" title="cfg.macro"><span>[cfg<wbr>.macro]<span/></a></div>
<h3 id="cfg-매크로"><a class="header" href="#cfg-매크로"><code>cfg</code> 매크로</a></h3>
<p>내장된 <code>cfg</code> 매크로는 단일 구성 조건자를 취하며, 조건자가 참이면 <code>true</code> 리터럴로, 거짓이면 <code>false</code> 리터럴로 평가됩니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let machine_kind = if cfg!(unix) {
  "unix"
} else if cfg!(windows) {
  "windows"
} else {
  "unknown"
};

println!("저는 {} 머신에서 실행 중입니다!", machine_kind);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items"><a class="rule-link" href="items.html#r-items" title="items"><span>[items]<span/></a></div>
<h1 id="아이템"><a class="header" href="#아이템">아이템</a></h1>
<div class="rule" id="r-items.syntax"><a class="rule-link" href="items.html#r-items.syntax" title="items.syntax"><span>[items<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문:</sup></strong><br />
<em>아이템</em>:<br />
   <a href="attributes.html"><em>외부속성</em></a><sup>*</sup><br />
      <em>가시성아이템</em><br />
   | <em>매크로아이템</em></p>
<p><em>가시성아이템</em>:<br />
   <a href="visibility-and-privacy.html"><em>가시성</em></a><sup>?</sup><br />
   (<br />
          <a href="items/modules.html"><em>모듈</em></a><br />
      | <a href="items/extern-crates.html"><em>외부크레이트</em></a><br />
      | <a href="items/use-declarations.html"><em>사용선언</em></a><br />
      | <a href="items/functions.html"><em>함수</em></a><br />
      | <a href="items/type-aliases.html"><em>타입별칭</em></a><br />
      | <a href="items/structs.html"><em>구조체</em></a><br />
      | <a href="items/enumerations.html"><em>열거형</em></a><br />
      | <a href="items/unions.html"><em>공용체</em></a><br />
      | <a href="items/constant-items.html"><em>상수아이템</em></a><br />
      | <a href="items/static-items.html"><em>정적아이템</em></a><br />
      | <a href="items/traits.html"><em>트레잇</em></a><br />
      | <a href="items/implementations.html"><em>구현</em></a><br />
      | <a href="items/external-blocks.html"><em>외부블록</em></a><br />
   )</p>
<p><em>매크로아이템</em>:<br />
      <a href="macros.html#macro-invocation"><em>세미콜론매크로호출</em></a><br />
   | <a href="macros-by-example.html"><em>매크로규칙정의</em></a></p>
</blockquote>
<div class="rule" id="r-items.intro"><a class="rule-link" href="items.html#r-items.intro" title="items.intro"><span>[items<wbr>.intro]<span/></a></div>
<p>_아이템_은 크레이트의 구성 요소입니다. 아이템은 중첩된 <a href="items/modules.html">모듈</a> 집합으로 크레이트 내에 구성됩니다. 모든 크레이트는 단일 “최상위” 익명 모듈을 가지며, 크레이트 내의 모든 추가 아이템은 크레이트의 모듈 트리 내에서 <a href="paths.html">경로</a>를 가집니다.</p>
<div class="rule" id="r-items.static-def"><a class="rule-link" href="items.html#r-items.static-def" title="items.static-def"><span>[items<wbr>.static-def]<span/></a></div>
<p>아이템은 컴파일 타임에 완전히 결정되며, 실행 중에 일반적으로 고정되어 있고, 읽기 전용 메모리에 상주할 수 있습니다.</p>
<div class="rule" id="r-items.kinds"><a class="rule-link" href="items.html#r-items.kinds" title="items.kinds"><span>[items<wbr>.kinds]<span/></a></div>
<p>아이템에는 여러 종류가 있습니다:</p>
<ul>
<li><a href="items/modules.html">모듈</a></li>
<li><a href="items/extern-crates.html"><code>extern crate</code> 선언</a></li>
<li><a href="items/use-declarations.html"><code>use</code> 선언</a></li>
<li><a href="items/functions.html">함수 정의</a></li>
<li><a href="items/type-aliases.html">타입 정의</a></li>
<li><a href="items/structs.html">구조체 정의</a></li>
<li><a href="items/enumerations.html">열거형 정의</a></li>
<li><a href="items/unions.html">공용체 정의</a></li>
<li><a href="items/constant-items.html">상수 아이템</a></li>
<li><a href="items/static-items.html">정적 아이템</a></li>
<li><a href="items/traits.html">트레잇 정의</a></li>
<li><a href="items/implementations.html">구현</a></li>
<li><a href="items/external-blocks.html"><code>extern</code> 블록</a></li>
</ul>
<div class="rule" id="r-items.locations"><a class="rule-link" href="items.html#r-items.locations" title="items.locations"><span>[items<wbr>.locations]<span/></a></div>
<p>아이템은 <a href="crates-and-source-files.html">크레이트 루트</a>, <a href="items/modules.html">모듈</a>, 또는 <a href="expressions/block-expr.html">블록 표현식</a>에서 선언될 수 있습니다.</p>
<div class="rule" id="r-items.associated-locations"><a class="rule-link" href="items.html#r-items.associated-locations" title="items.associated-locations"><span>[items<wbr>.associated-locations]<span/></a></div>
<p><a href="items/associated-items.html">연관 아이템</a>이라고 불리는 아이템의 일부는 <a href="items/traits.html">트레잇</a>과 <a href="items/implementations.html">구현</a>에서 선언될 수 있습니다.</p>
<div class="rule" id="r-items.extern-locations"><a class="rule-link" href="items.html#r-items.extern-locations" title="items.extern-locations"><span>[items<wbr>.extern-locations]<span/></a></div>
<p>외부 아이템이라고 불리는 아이템의 일부는 <a href="items/external-blocks.html"><code>extern</code> 블록</a>에서 선언될 수 있습니다.</p>
<div class="rule" id="r-items.decl-order"><a class="rule-link" href="items.html#r-items.decl-order" title="items.decl-order"><span>[items<wbr>.decl-order]<span/></a></div>
<p>아이템은 임의의 순서로 정의될 수 있으나, 자체적인 스코프 동작을 갖는 <a href="macros-by-example.html"><code>macro_rules</code></a>는 예외입니다.</p>
<div class="rule" id="r-items.name-resolution"><a class="rule-link" href="items.html#r-items.name-resolution" title="items.name-resolution"><span>[items<wbr>.name-resolution]<span/></a></div>
<p>아이템 이름의 <a href="names/name-resolution.html">이름 확인</a>을 통해 아이템은 모듈이나 블록 내에서 참조되는 지점의 앞이나 뒤에서 정의될 수 있습니다.</p>
<p>아이템의 스코프 규칙에 대한 정보는 <a href="names/scopes.html#item-scopes">아이템 스코프</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.mod"><a class="rule-link" href="items/modules.html#r-items.mod" title="items.mod"><span>[items<wbr>.mod]<span/></a></div>
<h1 id="모듈"><a class="header" href="#모듈">모듈</a></h1>
<div class="rule" id="r-items.mod.syntax"><a class="rule-link" href="items/modules.html#r-items.mod.syntax" title="items.mod.syntax"><span>[items<wbr>.mod<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문:</sup></strong><br />
<em>모듈</em> :<br />
      <code>unsafe</code><sup>?</sup> <code>mod</code> <a href="items/../identifiers.html">식별자</a> <code>;</code><br />
   | <code>unsafe</code><sup>?</sup> <code>mod</code> <a href="items/../identifiers.html">식별자</a> <code>{</code><br />
        <a href="items/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
        <a href="items/../items.html"><em>아이템</em></a><sup>*</sup><br />
      <code>}</code></p>
</blockquote>
<div class="rule" id="r-items.mod.intro"><a class="rule-link" href="items/modules.html#r-items.mod.intro" title="items.mod.intro"><span>[items<wbr>.mod<wbr>.intro]<span/></a></div>
<p>모듈은 0개 이상의 <a href="items/../items.html">아이템</a>을 담는 컨테이너입니다.</p>
<div class="rule" id="r-items.mod.def"><a class="rule-link" href="items/modules.html#r-items.mod.def" title="items.mod.def"><span>[items<wbr>.mod<wbr>.def]<span/></a></div>
<p>_모듈 아이템_은 중괄호로 둘러싸여 있고, 이름이 지정되며, <code>mod</code> 키워드가 앞에 붙은 모듈입니다. 모듈 아이템은 크레이트를 구성하는 모듈 트리에 이름이 지정된 새로운 모듈을 도입합니다.</p>
<div class="rule" id="r-items.mod.nesting"><a class="rule-link" href="items/modules.html#r-items.mod.nesting" title="items.mod.nesting"><span>[items<wbr>.mod<wbr>.nesting]<span/></a></div>
<p>모듈은 임의로 중첩될 수 있습니다.</p>
<p>모듈의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn cos(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn tan(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.mod.namespace"><a class="rule-link" href="items/modules.html#r-items.mod.namespace" title="items.mod.namespace"><span>[items<wbr>.mod<wbr>.namespace]<span/></a></div>
<p>모듈은 해당 모듈이나 블록이 위치한 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 정의됩니다.</p>
<div class="rule" id="r-items.mod.multiple-items"><a class="rule-link" href="items/modules.html#r-items.mod.multiple-items" title="items.mod.multiple-items"><span>[items<wbr>.mod<wbr>.multiple-items]<span/></a></div>
<p>모듈 내 같은 네임스페이스에 같은 이름을 가진 아이템을 여러 개 정의하는 것은 오류입니다. 제약 사항 및 가려짐(shadowing) 동작에 대한 자세한 내용은 <a href="items/../names/scopes.html">스코프 챕터</a>를 참조하십시오.</p>
<div class="rule" id="r-items.mod.unsafe"><a class="rule-link" href="items/modules.html#r-items.mod.unsafe" title="items.mod.unsafe"><span>[items<wbr>.mod<wbr>.unsafe]<span/></a></div>
<p><code>unsafe</code> 키워드는 구문적으로 <code>mod</code> 키워드 앞에 나타나는 것이 허용되지만, 시맨틱 수준에서는 거부됩니다. 이는 매크로가 해당 구문을 소비하고 <code>unsafe</code> 키워드를 토큰 스트림에서 제거하기 전에 이를 사용할 수 있게 하기 위함입니다.</p>
<div class="rule" id="r-items.mod.outlined"><a class="rule-link" href="items/modules.html#r-items.mod.outlined" title="items.mod.outlined"><span>[items<wbr>.mod<wbr>.outlined]<span/></a></div>
<h2 id="모듈-소스-파일-이름"><a class="header" href="#모듈-소스-파일-이름">모듈 소스 파일 이름</a></h2>
<div class="rule" id="r-items.mod.outlined.intro"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.intro" title="items.mod.outlined.intro"><span>[items<wbr>.mod<wbr>.outlined<wbr>.intro]<span/></a></div>
<p>본문이 없는 모듈은 외부 파일에서 로드됩니다. 모듈에 <code>path</code> 속성이 없는 경우, 파일 경로는 논리적 <a href="items/../paths.html">모듈 경로</a>를 반영합니다.</p>
<div class="rule" id="r-items.mod.outlined.search"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.search" title="items.mod.outlined.search"><span>[items<wbr>.mod<wbr>.outlined<wbr>.search]<span/></a></div>
<p>상위 모듈 경로 구성 요소는 디렉터리이며, 모듈의 내용은 모듈 이름에 <code>.rs</code> 확장자를 더한 파일에 있습니다. 예를 들어, 다음 모듈 구조는 이에 해당하는 파일 시스템 구조를 가질 수 있습니다:</p>
<div class="table-wrapper"><table><thead><tr><th>모듈 경로</th><th>파일시스템 경로</th><th>파일 내용</th></tr></thead><tbody>
<tr><td><code>crate</code></td><td><code>lib.rs</code></td><td><code>mod util;</code></td></tr>
<tr><td><code>crate::util</code></td><td><code>util.rs</code></td><td><code>mod config;</code></td></tr>
<tr><td><code>crate::util::config</code></td><td><code>util/config.rs</code></td><td></td></tr>
</tbody></table>
</div><div class="rule" id="r-items.mod.outlined.search-mod"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.search-mod" title="items.mod.outlined.search-mod"><span>[items<wbr>.mod<wbr>.outlined<wbr>.search-mod]<span/></a></div>
<p>모듈 파일 이름은 해당 디렉토리 내의 <code>mod.rs</code>라는 이름의 파일에 내용이 있는 디렉토리로서의 모듈 이름일 수도 있습니다. 위의 예시는 <code>crate::util</code>의 내용을 <code>util/mod.rs</code>라는 이름의 파일로 표현할 수도 있습니다. <code>util.rs</code>와 <code>util/mod.rs</code>를 동시에 가질 수는 없습니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code> 1.30 이전에는 중첩된 자식을 가진 모듈을 로드하기 위해 <code>mod.rs</code> 파일을 사용하는 것이 방법이었습니다. 새로운 명명 규칙은 더 일관성이 있고 프로젝트 내에 <code>mod.rs</code>라는 이름의 파일이 너무 많아지는 것을 방지하므로 이를 사용하는 것이 권장됩니다.</p>
</blockquote>
<div class="rule" id="r-items.mod.outlined.path"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.path" title="items.mod.outlined.path"><span>[items<wbr>.mod<wbr>.outlined<wbr>.path]<span/></a></div>
<h3 id="path-속성"><a class="header" href="#path-속성"><code>path</code> 속성</a></h3>
<div class="rule" id="r-items.mod.outlined.path.intro"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.path.intro" title="items.mod.outlined.path.intro"><span>[items<wbr>.mod<wbr>.outlined<wbr>.path<wbr>.intro]<span/></a></div>
<p>외부 파일 모듈을 로드하는 데 사용되는 디렉토리와 파일은 <code>path</code> 속성의 영향을 받을 수 있습니다.</p>
<div class="rule" id="r-items.mod.outlined.path.search"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.path.search" title="items.mod.outlined.path.search"><span>[items<wbr>.mod<wbr>.outlined<wbr>.path<wbr>.search]<span/></a></div>
<p>인라인 모듈 블록 내에 있지 않은 모듈의 <code>path</code> 속성의 경우, 파일 경로는 소스 파일이 위치한 디렉토리에 상대적입니다. 예를 들어, 다음 코드 스니펫은 위치한 곳에 따라 표시된 경로를 사용합니다:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = "foo.rs"]
mod c;</code></pre>
<div class="table-wrapper"><table><thead><tr><th>소스 파일</th><th><code>c</code>의 파일 위치</th><th><code>c</code>의 모듈 경로</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::b::c</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::c</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-items.mod.outlined.path.search-nested"><a class="rule-link" href="items/modules.html#r-items.mod.outlined.path.search-nested" title="items.mod.outlined.path.search-nested"><span>[items<wbr>.mod<wbr>.outlined<wbr>.path<wbr>.search-nested]<span/></a></div>
<p>인라인 모듈 블록 내부의 <code>path</code> 속성의 경우, 파일 경로의 상대적 위치는 <code>path</code> 속성이 위치한 소스 파일의 종류에 따라 달라집니다. “mod-rs” 소스 파일은 루트 모듈(<code>lib.rs</code> 또는 <code>main.rs</code> 등) 및 <code>mod.rs</code>라는 이름의 파일을 가진 모듈입니다. “non-mod-rs” 소스 파일은 그 외의 모든 모듈 파일입니다. mod-rs 파일 내의 인라인 모듈 블록 내부의 <code>path</code> 속성에 대한 경로는 인라인 모듈 구성 요소를 디렉토리로 포함하여 mod-rs 파일의 디렉토리에 상대적입니다. non-mod-rs 파일의 경우, 경로가 non-mod-rs 모듈의 이름을 가진 디렉토리로 시작한다는 점을 제외하고는 동일합니다. 예를 들어, 다음 코드 스니펫은 위치한 곳에 따라 표시된 경로를 사용합니다:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">mod inline {
    #[path = "other.rs"]
    mod inner;
}</code></pre>
<div class="table-wrapper"><table><thead><tr><th>소스 파일</th><th><code>inner</code>의 파일 위치</th><th><code>inner</code>의 모듈 경로</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/b/inline/other.rs</code></td><td><code>crate::a::b::inline::inner</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/inline/other.rs</code></td><td><code>crate::a::inline::inner</code></td></tr>
</tbody></table>
</div>
<p>인라인 모듈의 <code>path</code> 속성 규칙과 그 내부의 중첩된 모듈 규칙을 결합한 예(mod-rs 파일과 non-mod-rs 파일 모두에 적용됨):</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = "thread_files"]
mod thread {
    // 이 소스 파일의 디렉토리를 기준으로 `thread_files/tls.rs`에서 `local_data` 모듈을 로드합니다.
    #[path = "tls.rs"]
    mod local_data;
}</code></pre>
<div class="rule" id="r-items.mod.attributes"><a class="rule-link" href="items/modules.html#r-items.mod.attributes" title="items.mod.attributes"><span>[items<wbr>.mod<wbr>.attributes]<span/></a></div>
<h2 id="모듈의-속성"><a class="header" href="#모듈의-속성">모듈의 속성</a></h2>
<div class="rule" id="r-items.mod.attributes.intro"><a class="rule-link" href="items/modules.html#r-items.mod.attributes.intro" title="items.mod.attributes.intro"><span>[items<wbr>.mod<wbr>.attributes<wbr>.intro]<span/></a></div>
<p>모듈은 다른 모든 아이템과 마찬가지로 외부 속성을 허용합니다. 또한 내부 속성도 허용하는데, 본문이 있는 모듈의 경우 <code>{</code> 뒤에, 또는 소스 파일의 시작 부분(선택적인 BOM과 셰뱅 뒤)에 위치합니다.</p>
<div class="rule" id="r-items.mod.attributes.supported"><a class="rule-link" href="items/modules.html#r-items.mod.attributes.supported" title="items.mod.attributes.supported"><span>[items<wbr>.mod<wbr>.attributes<wbr>.supported]<span/></a></div>
<p>모듈에서 의미를 갖는 내장 속성은 <a href="items/../conditional-compilation.html"><code>cfg</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="items/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>, <a href="items/modules.html#the-path-attribute"><code>path</code></a>, 그리고 <a href="items/../names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a>입니다. 모듈은 매크로 속성도 허용합니다.</p>
<script>
(function() {
    var fragments = {
        "#prelude-items": "../names/preludes.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.extern-crate"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate" title="items.extern-crate"><span>[items<wbr>.extern-crate]<span/></a></div>
<h1 id="외부-크레이트-선언"><a class="header" href="#외부-크레이트-선언">외부 크레이트 선언</a></h1>
<div class="rule" id="r-items.extern-crate.syntax"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.syntax" title="items.extern-crate.syntax"><span>[items<wbr>.extern-crate<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문:</sup></strong><br />
<em>외부크레이트</em> :<br />
   <code>extern</code> <code>crate</code> <em>크레이트참조</em> <em>As절</em><sup>?</sup> <code>;</code></p>
<p><em>크레이트참조</em> :<br />
   <a href="items/../identifiers.html">식별자</a> | <code>self</code></p>
<p><em>As절</em> :<br />
   <code>as</code> ( <a href="items/../identifiers.html">식별자</a> | <code>_</code> )</p>
</blockquote>
<div class="rule" id="r-items.extern-crate.intro"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.intro" title="items.extern-crate.intro"><span>[items<wbr>.extern-crate<wbr>.intro]<span/></a></div>
<p>_<code>extern crate</code> 선언_은 외부 크레이트에 대한 의존성을 명시합니다.</p>
<div class="rule" id="r-items.extern-crate.namespace"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.namespace" title="items.extern-crate.namespace"><span>[items<wbr>.extern-crate<wbr>.namespace]<span/></a></div>
<p>그러면 외부 크레이트는 선언 범위 내의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에서 주어진 <a href="items/../identifiers.html">식별자</a>로 바인딩됩니다.</p>
<div class="rule" id="r-items.extern-crate.extern-prelude"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.extern-prelude" title="items.extern-crate.extern-prelude"><span>[items<wbr>.extern-crate<wbr>.extern-prelude]<span/></a></div>
<p>또한, <code>extern crate</code>가 크레이트 루트에 나타나면, 크레이트 이름이 <a href="items/../names/preludes.html#extern-prelude">외부 프렐류드</a>에도 추가되어 모든 모듈의 스코프에 자동으로 포함됩니다.</p>
<div class="rule" id="r-items.extern-crate.as"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.as" title="items.extern-crate.as"><span>[items<wbr>.extern-crate<wbr>.as]<span/></a></div>
<p><code>as</code> 절은 임포트된 크레이트를 다른 이름으로 바인딩하는 데 사용할 수 있습니다.</p>
<div class="rule" id="r-items.extern-crate.lookup"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.lookup" title="items.extern-crate.lookup"><span>[items<wbr>.extern-crate<wbr>.lookup]<span/></a></div>
<p>외부 크레이트는 컴파일 타임에 특정 <code>soname</code>으로 해석되며, 해당 <code>soname</code>에 대한 런타임 연결 요구 사항은 런타임 로딩을 위해 링커로 전달됩니다. <code>soname</code>은 컴파일러의 라이브러리 경로를 스캔하고, 제공된 선택적 <code>crate_name</code>과 외부 크레이트가 컴파일될 때 선언된 <a href="items/../crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code> 속성</a>을 매칭하여 컴파일 타임에 해석됩니다. <code>crate_name</code>이 제공되지 않으면, <code>extern crate</code> 선언에 주어진 <a href="items/../identifiers.html">식별자</a>와 동일한 기본 <code>name</code> 속성이 가정됩니다.</p>
<div class="rule" id="r-items.extern-crate.self"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.self" title="items.extern-crate.self"><span>[items<wbr>.extern-crate<wbr>.self]<span/></a></div>
<p><code>self</code> 크레이트를 임포트하여 현재 크레이트에 대한 바인딩을 생성할 수 있습니다. 이 경우 바인딩할 이름을 지정하기 위해 <code>as</code> 절을 사용해야 합니다.</p>
<p><code>extern crate</code> 선언의 세 가지 예시:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate pcre;

extern crate std; // extern crate std as std;와 동일합니다.

extern crate std as ruststd; // 다른 이름으로 'std'를 링크합니다.</code></pre>
<div class="rule" id="r-items.extern-crate.name-restrictions"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.name-restrictions" title="items.extern-crate.name-restrictions"><span>[items<wbr>.extern-crate<wbr>.name-restrictions]<span/></a></div>
<p>러스트 크레이트의 이름을 지을 때 하이픈은 허용되지 않습니다. 그러나 Cargo 패키지는 이를 사용할 수 있습니다. 이러한 경우 <code>Cargo.toml</code>에서 크레이트 이름을 지정하지 않으면, Cargo는 투명하게 <code>-</code>를 <code>_</code>로 대체합니다. (자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">RFC 940</a>을 참조하십시오.)</p>
<p>예시는 다음과 같습니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// hello-world Cargo 패키지 임포트
extern crate hello_world; // 하이픈이 밑줄로 대체됨</code></pre>
<div class="rule" id="r-items.extern-crate.underscore"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.underscore" title="items.extern-crate.underscore"><span>[items<wbr>.extern-crate<wbr>.underscore]<span/></a></div>
<h2 id="밑줄-임포트"><a class="header" href="#밑줄-임포트">밑줄 임포트</a></h2>
<div class="rule" id="r-items.extern-crate.underscore.intro"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.underscore.intro" title="items.extern-crate.underscore.intro"><span>[items<wbr>.extern-crate<wbr>.underscore<wbr>.intro]<span/></a></div>
<p><code>extern crate foo as _</code>와 같은 형태로 밑줄을 사용하여 이름을 스코프에 바인딩하지 않고 외부 크레이트 의존성을 선언할 수 있습니다. 이는 링크만 필요하고 참조되지는 않는 크레이트에 유용할 수 있으며, 사용되지 않음으로 보고되는 것을 방지합니다.</p>
<div class="rule" id="r-items.extern-crate.underscore.macro_use"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.underscore.macro_use" title="items.extern-crate.underscore.macro_use"><span>[items<wbr>.extern-crate<wbr>.underscore<wbr>.macro_use]<span/></a></div>
<p><a href="items/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 속성</a>은 평소와 같이 작동하며 매크로 이름을 <a href="items/../names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a>로 가져옵니다.</p>
<div class="rule" id="r-items.extern-crate.no_link"><a class="rule-link" href="items/extern-crates.html#r-items.extern-crate.no_link" title="items.extern-crate.no_link"><span>[items<wbr>.extern-crate<wbr>.no_link]<span/></a></div>
<h2 id="no_link-속성"><a class="header" href="#no_link-속성"><code>no_link</code> 속성</a></h2>
<p>_<code>no_link</code> 속성_은 크레이트가 출력물에 링크되는 것을 방지하기 위해 <code>extern crate</code> 아이템에 지정될 수 있습니다. 이는 일반적으로 매크로에만 접근하기 위해 크레이트를 로드할 때 사용됩니다.</p>
<script>
(function() {
    var fragments = {
        "#extern-prelude": "../names/preludes.html#extern-prelude",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.use"><a class="rule-link" href="items/use-declarations.html#r-items.use" title="items.use"><span>[items<wbr>.use]<span/></a></div>
<h1 id="use-선언"><a class="header" href="#use-선언">Use 선언</a></h1>
<div class="rule" id="r-items.use.syntax"><a class="rule-link" href="items/use-declarations.html#r-items.use.syntax" title="items.use.syntax"><span>[items<wbr>.use<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문:</sup></strong><br />
<em>Use선언</em> :<br />
   <code>use</code> <em>Use트리</em> <code>;</code></p>
<p><em>Use트리</em> :<br />
      (<a href="items/../paths.html#simple-paths"><em>단순경로</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>*</code><br />
   | (<a href="items/../paths.html#simple-paths"><em>단순경로</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>{</code> (<em>Use트리</em> ( <code>,</code>  <em>Use트리</em> )<sup>*</sup> <code>,</code><sup>?</sup>)<sup>?</sup> <code>}</code><br />
   | <a href="items/../paths.html#simple-paths"><em>단순경로</em></a> ( <code>as</code> ( <a href="items/../identifiers.html">식별자</a> | <code>_</code> ) )<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-items.use.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.intro" title="items.use.intro"><span>[items<wbr>.use<wbr>.intro]<span/></a></div>
<p>_use 선언_은 다른 <a href="items/../paths.html">경로</a>와 동의어인 하나 이상의 로컬 이름 바인딩을 생성합니다. 일반적으로 <code>use</code> 선언은 모듈 아이템을 참조하는 데 필요한 경로를 단축하기 위해 사용됩니다. 이러한 선언은 <a href="items/modules.html">모듈</a>과 <a href="items/../expressions/block-expr.html">블록</a>에 나타날 수 있으며, 보통 최상단에 위치합니다. <code>use</code> 선언은 때때로 _임포트(import)_라고도 불리며, 공개된 경우에는 _재내보내기(re-export)_라고도 합니다.</p>
<div class="rule" id="r-items.use.forms"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms" title="items.use.forms"><span>[items<wbr>.use<wbr>.forms]<span/></a></div>
<p><code>use</code> 선언은 여러 편리한 단축 표기법을 지원합니다:</p>
<div class="rule" id="r-items.use.forms.multiple"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms.multiple" title="items.use.forms.multiple"><span>[items<wbr>.use<wbr>.forms<wbr>.multiple]<span/></a></div>
<ul>
<li><code>use a::b::{c, d, e::f, g::h::i};</code>와 같이 중괄호 구문을 사용하여 공통 접두사를 가진 경로 목록을 동시에 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.self"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms.self" title="items.use.forms.self"><span>[items<wbr>.use<wbr>.forms<wbr>.self]<span/></a></div>
<ul>
<li><code>use a::b::{self, c, d::e};</code>와 같이 <code>self</code> 키워드를 사용하여 공통 접두사를 가진 경로 목록과 그들의 공통 부모 모듈을 동시에 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.as"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms.as" title="items.use.forms.as"><span>[items<wbr>.use<wbr>.forms<wbr>.as]<span/></a></div>
<ul>
<li><code>use p::q::r as x;</code> 구문을 사용하여 대상 이름을 새로운 로컬 이름으로 다시 바인딩합니다. 이는 앞의 두 기능과 함께 사용될 수도 있습니다: <code>use a::b::{self as ab, c as abc}</code>.</li>
</ul>
<div class="rule" id="r-items.use.forms.glob"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms.glob" title="items.use.forms.glob"><span>[items<wbr>.use<wbr>.forms<wbr>.glob]<span/></a></div>
<ul>
<li>별표 와일드카드 구문인 <code>use a::b::*;</code>를 사용하여 주어진 접두사와 일치하는 모든 경로를 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.nesting"><a class="rule-link" href="items/use-declarations.html#r-items.use.forms.nesting" title="items.use.forms.nesting"><span>[items<wbr>.use<wbr>.forms<wbr>.nesting]<span/></a></div>
<ul>
<li><code>use a::b::{self as ab, c, d::{*, e::f}};</code>와 같이 이전 기능들의 그룹을 여러 번 중첩하여 사용합니다.</li>
</ul>
<p><code>use</code> 선언의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // use 선언은 함수 내부에도 존재할 수 있습니다
    use std::option::Option::{Some, None};

    // 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'와 동일합니다.
    foo(vec![Some(1.0f64), None]);

    // `hash_map`과 `HashMap` 모두 스코프에 있습니다.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</code></pre></pre>
<div class="rule" id="r-items.use.visibility"><a class="rule-link" href="items/use-declarations.html#r-items.use.visibility" title="items.use.visibility"><span>[items<wbr>.use<wbr>.visibility]<span/></a></div>
<h2 id="use-가시성"><a class="header" href="#use-가시성"><code>use</code> 가시성</a></h2>
<div class="rule" id="r-items.use.visibility.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.visibility.intro" title="items.use.visibility.intro"><span>[items<wbr>.use<wbr>.visibility<wbr>.intro]<span/></a></div>
<p>아이템과 마찬가지로, <code>use</code> 선언은 기본적으로 포함하는 모듈에 비공개(private)입니다. 또한 아이템과 마찬가지로 <code>use</code> 선언은 <code>pub</code> 키워드로 한정되면 공개(public)가 될 수 있습니다. 이러한 <code>use</code> 선언은 이름을 _다시 내보내기(re-export)_하는 역할을 합니다. 따라서 공개 <code>use</code> 선언은 일부 공개 이름을 다른 대상 정의로, 심지어 다른 모듈 내부의 비공개 정규 경로를 가진 정의로 _리디렉션_할 수 있습니다.</p>
<div class="rule" id="r-items.use.visibility.unambiguous"><a class="rule-link" href="items/use-declarations.html#r-items.use.visibility.unambiguous" title="items.use.visibility.unambiguous"><span>[items<wbr>.use<wbr>.visibility<wbr>.unambiguous]<span/></a></div>
<p>이러한 리디렉션의 시퀀스가 순환을 형성하거나 모호하지 않게 해석될 수 없는 경우, 컴파일 타임 오류를 나타냅니다.</p>
<p>다시 내보내기(re-exporting)의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod quux {
    pub use self::foo::{bar, baz};
    pub mod foo {
        pub fn bar() {}
        pub fn baz() {}
    }
}

fn main() {
    quux::bar();
    quux::baz();
}</code></pre></pre>
<p>이 예제에서 <code>quux</code> 모듈은 <code>foo</code>에 정의된 두 개의 공개 이름을 다시 내보냅니다.</p>
<div class="rule" id="r-items.use.path"><a class="rule-link" href="items/use-declarations.html#r-items.use.path" title="items.use.path"><span>[items<wbr>.use<wbr>.path]<span/></a></div>
<h2 id="use-경로"><a class="header" href="#use-경로"><code>use</code> 경로</a></h2>
<div class="rule" id="r-items.use.path.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.path.intro" title="items.use.path.intro"><span>[items<wbr>.use<wbr>.path<wbr>.intro]<span/></a></div>
<p><code>use</code> 아이템에서 허용되는 <a href="items/../paths.html">경로</a>는 <a href="items/../paths.html#simple-paths"><em>단순경로</em></a> 문법을 따르며 표현식에서 사용될 수 있는 경로와 유사합니다. 이들은 다음에 대한 바인딩을 생성할 수 있습니다:</p>
<ul>
<li>이름을 지을 수 있는 <a href="items/../items.html">아이템</a></li>
<li><a href="items/enumerations.html">열거형 변형</a></li>
<li><a href="items/../types.html">내장 타입</a></li>
<li><a href="items/../attributes.html">속성</a></li>
<li><a href="items/../procedural-macros.html#derive-macros">Derive 매크로</a></li>
</ul>
<div class="rule" id="r-items.use.path.disallowed"><a class="rule-link" href="items/use-declarations.html#r-items.use.path.disallowed" title="items.use.path.disallowed"><span>[items<wbr>.use<wbr>.path<wbr>.disallowed]<span/></a></div>
<p><a href="items/associated-items.html">연관 아이템</a>, <a href="items/generics.html">제네릭 매개변수</a>, <a href="items/../variables.html">지역 변수</a>, <a href="items/../paths.html#self"><code>Self</code></a>가 포함된 경로, 또는 <a href="items/../attributes.html#tool-attributes">도구 속성</a>은 임포트할 수 없습니다. 더 많은 제약 사항은 아래에 설명되어 있습니다.</p>
<div class="rule" id="r-items.use.path.namespace"><a class="rule-link" href="items/use-declarations.html#r-items.use.path.namespace" title="items.use.path.namespace"><span>[items<wbr>.use<wbr>.path<wbr>.namespace]<span/></a></div>
<p><code>use</code>는 임포트된 엔티티의 모든 <a href="items/../names/namespaces.html">네임스페이스</a>에 대한 바인딩을 생성합니다. 단, <code>self</code> 임포트는 타입 네임스페이스에서만 임포트합니다(아래 설명 참조). 예를 들어, 다음은 두 네임스페이스에서 동일한 이름에 대한 바인딩을 생성하는 것을 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod stuff {
    pub struct Foo(pub i32);
}

// `Foo` 타입과 `Foo` 생성자를 임포트합니다.
use stuff::Foo;

fn example() {
    let ctor = Foo; // 값 네임스페이스에서 `Foo`를 사용합니다.
    let x: Foo = ctor(123); // 타입 네임스페이스에서 `Foo`를 사용합니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.path.edition2015"><a class="rule-link" href="items/use-declarations.html#r-items.use.path.edition2015" title="items.use.path.edition2015"><span>[items<wbr>.use<wbr>.path<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 <code>use</code> 경로는 크레이트 루트에 상대적입니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2015">mod foo {
    pub mod example { pub mod iter {} }
    pub mod baz { pub fn foobaz() {} }
}
mod bar {
    // 크레이트 루트에서 `foo`를 확인합니다.
    use foo::example::iter;
    // `::` 접두사는 명시적으로 `foo`를 확인합니다.
    // 크레이트 루트로부터.
    use ::foo::baz::foobaz;
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>2015 에디션은 use 선언이 <a href="items/../names/preludes.html#extern-prelude">extern 프렐류드</a>를 참조하는 것을 허용하지 않습니다. 따라서 2015 에디션에서 use 선언으로 외부 크레이트를 참조하려면 여전히 <a href="items/extern-crates.html"><code>extern crate</code></a> 선언이 필요합니다. 2018 에디션부터는 <code>use</code> 선언에서 <code>extern crate</code>와 동일한 방식으로 외부 크레이트 의존성을 지정할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-items.use.as"><a class="rule-link" href="items/use-declarations.html#r-items.use.as" title="items.use.as"><span>[items<wbr>.use<wbr>.as]<span/></a></div>
<h2 id="as를-이용한-이름-변경"><a class="header" href="#as를-이용한-이름-변경"><code>as</code>를 이용한 이름 변경</a></h2>
<p><code>as</code> 키워드는 임포트된 엔티티의 이름을 변경하는 데 사용될 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 함수 `foo`에 대한 비공개 별칭 `bar`를 생성합니다.
use inner::foo as bar;

mod inner {
    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.multiple-syntax"><a class="rule-link" href="items/use-declarations.html#r-items.use.multiple-syntax" title="items.use.multiple-syntax"><span>[items<wbr>.use<wbr>.multiple-syntax]<span/></a></div>
<h2 id="중괄호-구문"><a class="header" href="#중괄호-구문">중괄호 구문</a></h2>
<div class="rule" id="r-items.use.multiple-syntax.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.multiple-syntax.intro" title="items.use.multiple-syntax.intro"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.intro]<span/></a></div>
<p>중괄호는 경로의 마지막 세그먼트에서 이전 세그먼트로부터 여러 엔티티를 임포트하거나, 이전 세그먼트가 없는 경우 현재 스코프에서 임포트하는 데 사용될 수 있습니다. 중괄호는 중첩될 수 있으며, 각 세그먼트 그룹이 부모와 논리적으로 결합되어 전체 경로를 형성하는 경로 트리를 생성합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
use std::collections::{BTreeSet, hash_map::{self, HashMap}};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.multiple-syntax.empty"><a class="rule-link" href="items/use-declarations.html#r-items.use.multiple-syntax.empty" title="items.use.multiple-syntax.empty"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.empty]<span/></a></div>
<p>빈 중괄호는 아무것도 임포트하지 않지만, 선행 경로가 접근 가능한지는 확인됩니다.</p>
<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->
<div class="rule" id="r-items.use.multiple-syntax.edition2015"><a class="rule-link" href="items/use-declarations.html#r-items.use.multiple-syntax.edition2015" title="items.use.multiple-syntax.edition2015"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, <code>use {foo, bar};</code>와 같은 임포트는 크레이트 루트에서 <code>foo</code>와 <code>bar</code>라는 이름을 임포트합니다. 반면 2018 에디션부터는 해당 이름들이 현재 스코프에 상대적입니다.</p>
</blockquote>
<div class="rule" id="r-items.use.self"><a class="rule-link" href="items/use-declarations.html#r-items.use.self" title="items.use.self"><span>[items<wbr>.use<wbr>.self]<span/></a></div>
<h2 id="self-임포트"><a class="header" href="#self-임포트"><code>self</code> 임포트</a></h2>
<div class="rule" id="r-items.use.self.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.self.intro" title="items.use.self.intro"><span>[items<wbr>.use<wbr>.self<wbr>.intro]<span/></a></div>
<p><code>self</code> 키워드는 <a href="items/use-declarations.html#brace-syntax">중괄호 구문</a> 내에서 부모 엔티티를 자신의 이름으로 바인딩하는 데 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod stuff {
    pub fn foo() {}
    pub fn bar() {}
}
mod example {
    // `stuff`와 `foo`에 대한 바인딩을 생성합니다.
    use crate::stuff::{self, foo};
    pub fn baz() {
        foo();
        stuff::bar();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-items.use.self.namespace"><a class="rule-link" href="items/use-declarations.html#r-items.use.self.namespace" title="items.use.self.namespace"><span>[items<wbr>.use<wbr>.self<wbr>.namespace]<span/></a></div>
<p><code>self</code>는 부모 엔티티의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에서만 바인딩을 생성합니다. 예를 들어, 다음 예시에서는 <code>foo</code> 모듈만 임포트됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">mod bar {
    pub mod foo {}
    pub fn foo() {}
}

// 이는 `foo` 모듈만 임포트합니다. `foo` 함수는 값 네임스페이스에 존재하므로 임포트되지 않습니다.
use bar::foo::{self};

fn main() {
    foo(); //~ 오류: `foo`는 모듈입니다.
}</code></pre></pre>
<blockquote>
<p><strong>참고</strong>: <code>self</code>는 경로의 첫 번째 세그먼트로도 사용될 수 있습니다. <code>self</code>를 첫 번째 세그먼트로 사용하는 것과 <code>use</code> 중괄호 내부에서 사용하는 것은 논리적으로 동일합니다. 이는 부모 세그먼트의 현재 모듈을 의미하거나, 부모 세그먼트가 없는 경우 현재 모듈을 의미합니다. 선행 <code>self</code>의 의미에 대한 자세한 내용은 경로 챕터의 <a href="items/../paths.html#self"><code>self</code></a>를 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-items.use.glob"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob" title="items.use.glob"><span>[items<wbr>.use<wbr>.glob]<span/></a></div>
<h2 id="글로브-임포트"><a class="header" href="#글로브-임포트">글로브 임포트</a></h2>
<div class="rule" id="r-items.use.glob.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob.intro" title="items.use.glob.intro"><span>[items<wbr>.use<wbr>.glob<wbr>.intro]<span/></a></div>
<p><code>*</code> 문자는 <code>use</code> 경로의 마지막 세그먼트로 사용하여 이전 세그먼트의 엔티티에서 임포트 가능한 모든 엔티티를 임포트하는 데 사용할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `bar`에 대한 비공개 별칭을 생성합니다.
use foo::*;

mod foo {
    fn i_am_private() {}
    enum Example {
        V1,
        V2,
    }
    pub fn bar() {
        // `Example` 열거형의 `V1`과 `V2`에 대한
        // 지역 별칭을 생성합니다.
        use Example::*;
        let x = V1;
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.glob.shadowing"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob.shadowing" title="items.use.glob.shadowing"><span>[items<wbr>.use<wbr>.glob<wbr>.shadowing]<span/></a></div>
<p>아이템과 명명된 임포트는 같은 <a href="items/../names/namespaces.html">네임스페이스</a>에서 글로브 임포트로 가져온 이름을 가리는(shadow) 것이 허용됩니다. 즉, 같은 네임스페이스에 다른 아이템에 의해 이미 정의된 이름이 있다면, 글로브 임포트는 가려집니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이것은 `clashing::Foo` 튜플 구조체 생성자에 대한 바인딩을 생성하지만,
// 여기에 정의된 `Foo` 구조체와 충돌하기 때문에 그 타입은 임포트하지
// 않습니다.
//
// 여기서 정의 순서는 중요하지 않음에 유의하세요.
use clashing::*;
struct Foo {
    field: f32,
}

fn do_stuff() {
    // `clashing::Foo`의 생성자를 사용합니다.
    let f1 = Foo(123);
    // 구조체 표현식은 위에서 정의된
    // `Foo` 구조체의 타입을 사용합니다.
    let f2 = Foo { field: 1.0 };
    // 글로브 임포트로 인해 `Bar`도 스코프에 있습니다.
    let z = Bar {};
}

mod clashing {
    pub struct Foo(pub i32);
    pub struct Bar {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.glob.last-segment-only"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob.last-segment-only" title="items.use.glob.last-segment-only"><span>[items<wbr>.use<wbr>.glob<wbr>.last-segment-only]<span/></a></div>
<p><code>*</code>는 첫 번째 또는 중간 세그먼트로 사용할 수 없습니다.</p>
<div class="rule" id="r-items.use.glob.self-import"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob.self-import" title="items.use.glob.self-import"><span>[items<wbr>.use<wbr>.glob<wbr>.self-import]<span/></a></div>
<p><code>*</code>는 모듈의 내용을 자기 자신에게 임포트하는 데 사용할 수 없습니다(예: <code>use self::*;</code>).</p>
<div class="rule" id="r-items.use.glob.edition2015"><a class="rule-link" href="items/use-declarations.html#r-items.use.glob.edition2015" title="items.use.glob.edition2015"><span>[items<wbr>.use<wbr>.glob<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, <code>use *;</code>와 같은 임포트는 유효하며 크레이트 루트의 모든 것을 임포트한다는 의미입니다. 이는 크레이트 루트 자체에서는 사용할 수 없습니다.</p>
</blockquote>
<div class="rule" id="r-items.use.as-underscore"><a class="rule-link" href="items/use-declarations.html#r-items.use.as-underscore" title="items.use.as-underscore"><span>[items<wbr>.use<wbr>.as-underscore]<span/></a></div>
<h2 id="밑줄-임포트-1"><a class="header" href="#밑줄-임포트-1">밑줄 임포트</a></h2>
<div class="rule" id="r-items.use.as-underscore.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.as-underscore.intro" title="items.use.as-underscore.intro"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.intro]<span/></a></div>
<p>아이템은 <code>use path as _</code> 형식을 사용하여 이름에 바인딩하지 않고 임포트할 수 있습니다. 이는 트레잇의 심볼을 임포트하지 않고 메서드를 사용하려 할 때(예: 트레잇 심볼이 다른 심볼과 충돌할 수 있는 경우) 특히 유용합니다. 다른 예로는 이름을 임포트하지 않고 외부 크레이트를 링크하는 경우가 있습니다.</p>
<div class="rule" id="r-items.use.as-underscore.glob"><a class="rule-link" href="items/use-declarations.html#r-items.use.as-underscore.glob" title="items.use.as-underscore.glob"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.glob]<span/></a></div>
<p>별표 글로브 임포트는 <code>_</code>로 임포트된 아이템을 이름 지을 수 없는 형태로 임포트합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // 밑줄 임포트는 이 아이템과의 이름 충돌을 방지합니다.

fn main() {
    let z = Zoo;
    z.zoo();
}</code></pre></pre>
<div class="rule" id="r-items.use.as-underscore.macro"><a class="rule-link" href="items/use-declarations.html#r-items.use.as-underscore.macro" title="items.use.as-underscore.macro"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.macro]<span/></a></div>
<p>고유하고 이름 지을 수 없는 심볼은 매크로 확장 후에 생성되므로, 매크로는 안전하게 <code>_</code> 임포트에 대한 다중 참조를 내보낼 수 있습니다. 예를 들어, 다음 코드는 오류를 생성하지 않아야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// 다음과 같이 확장됩니다:
// use std as _;
// use std as _;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.restrictions"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions" title="items.use.restrictions"><span>[items<wbr>.use<wbr>.restrictions]<span/></a></div>
<h2 id="제약-사항"><a class="header" href="#제약-사항">제약 사항</a></h2>
<p>다음은 유효한 <code>use</code> 선언에 대한 제약 사항입니다:</p>
<div class="rule" id="r-items.use.restrictions.crate"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions.crate" title="items.use.restrictions.crate"><span>[items<wbr>.use<wbr>.restrictions<wbr>.crate]<span/></a></div>
<ul>
<li><code>use crate;</code>는 크레이트 루트를 바인딩할 이름을 정의하기 위해 반드시 <code>as</code>를 사용해야 합니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.self"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions.self" title="items.use.restrictions.self"><span>[items<wbr>.use<wbr>.restrictions<wbr>.self]<span/></a></div>
<ul>
<li><code>use {self};</code>는 오류입니다. <code>self</code>를 사용할 때는 반드시 선행 세그먼트가 있어야 합니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.duplicate-name"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions.duplicate-name" title="items.use.restrictions.duplicate-name"><span>[items<wbr>.use<wbr>.restrictions<wbr>.duplicate-name]<span/></a></div>
<ul>
<li>다른 아이템 정의와 마찬가지로, <code>use</code> 임포트는 모듈이나 블록 내의 동일한 네임스페이스에서 같은 이름으로 중복 바인딩을 생성할 수 없습니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.macro-crate"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions.macro-crate" title="items.use.restrictions.macro-crate"><span>[items<wbr>.use<wbr>.restrictions<wbr>.macro-crate]<span/></a></div>
<ul>
<li><code>$crate</code>를 포함한 <code>use</code> 경로는 <a href="items/../macros-by-example.html"><code>macro_rules</code></a> 확장 내에서 허용되지 않습니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.variant"><a class="rule-link" href="items/use-declarations.html#r-items.use.restrictions.variant" title="items.use.restrictions.variant"><span>[items<wbr>.use<wbr>.restrictions<wbr>.variant]<span/></a></div>
<ul>
<li><code>use</code> 경로는 <a href="items/type-aliases.html">타입 별칭</a>을 통해 열거형 변형을 참조할 수 없습니다. 예를 들어:
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    MyVariant
}
type TypeAlias = MyEnum;

use MyEnum::MyVariant; //~ OK
use TypeAlias::MyVariant; //~ 오류
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-items.use.ambiguities"><a class="rule-link" href="items/use-declarations.html#r-items.use.ambiguities" title="items.use.ambiguities"><span>[items<wbr>.use<wbr>.ambiguities]<span/></a></div>
<h2 id="모호성"><a class="header" href="#모호성">모호성</a></h2>
<blockquote>
<p><strong>참고</strong>: 이 섹션은 미완성입니다.</p>
</blockquote>
<div class="rule" id="r-items.use.ambiguities.intro"><a class="rule-link" href="items/use-declarations.html#r-items.use.ambiguities.intro" title="items.use.ambiguities.intro"><span>[items<wbr>.use<wbr>.ambiguities<wbr>.intro]<span/></a></div>
<p><code>use</code> 선언이 어떤 이름을 참조하는지 모호한 경우 오류가 발생하는 상황이 있습니다. 이는 동일한 엔티티로 해석되지 않는 두 개의 이름 후보가 있을 때 발생합니다.</p>
<div class="rule" id="r-items.use.ambiguities.glob"><a class="rule-link" href="items/use-declarations.html#r-items.use.ambiguities.glob" title="items.use.ambiguities.glob"><span>[items<wbr>.use<wbr>.ambiguities<wbr>.glob]<span/></a></div>
<p>글로브(Glob) 임포트는 해당 이름이 사용되지 않는 한 동일한 네임스페이스에서 충돌하는 이름들을 임포트하는 것이 허용됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub struct Qux;
}

mod bar {
    pub struct Qux;
}

use foo::*;
use bar::*; //~ OK, 이름 충돌 없음.

fn main() {
    // 이는 모호성으로 인해 오류가 됩니다.
    //let x = Qux;
}</code></pre></pre>
<p>여러 글로브 임포트가 동일한 이름을 임포트할 수 있으며, 임포트된 항목들이 (재내보내기를 거쳐) 동일한 아이템인 경우 해당 이름을 사용할 수 있습니다. 이름의 가시성은 임포트된 것들 중 최대 가시성을 가집니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub struct Qux;
}

mod bar {
    pub use super::foo::Qux;
}

// 이 둘은 모두 동일한 `Qux`를 임포트합니다. `Qux`의 가시성은 이 두 `use` 선언 사이의 최대 가시성인 `pub`이 됩니다.
pub use bar::*;
use foo::*;

fn main() {
    let _: Qux = Qux;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.fn"><a class="rule-link" href="items/functions.html#r-items.fn" title="items.fn"><span>[items<wbr>.fn]<span/></a></div>
<h1 id="함수"><a class="header" href="#함수">함수</a></h1>
<div class="rule" id="r-items.fn.syntax"><a class="rule-link" href="items/functions.html#r-items.fn.syntax" title="items.fn.syntax"><span>[items<wbr>.fn<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>함수</em> :<br />
   <em>함수한정자</em> <code>fn</code> <a href="items/../identifiers.html">식별자</a> <a href="items/generics.html"><em>제네릭파라미터</em></a><sup>?</sup><br />
      <code>(</code> <em>함수매개변수</em><sup>?</sup> <code>)</code><br />
      <em>함수반환타입</em><sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup><br />
      ( <a href="items/../expressions/block-expr.html"><em>블록표현식</em></a> | <code>;</code> )</p>
<p><em>함수한정자</em> :<br />
   <code>const</code><sup>?</sup> <code>async</code><sup class="footnote-reference"><a href="#async-edition">1</a></sup><sup>?</sup> <em>아이템안전성</em><sup>?</sup><sup class="footnote-reference"><a href="#extern-qualifiers">2</a></sup> (<code>extern</code> <em>Abi</em><sup>?</sup>)<sup>?</sup></p>
<p><em>아이템안전성</em> :<br />
   <code>safe</code><sup class="footnote-reference"><a href="#extern-safe">3</a></sup> | <code>unsafe</code></p>
<p><em>Abi</em> :<br />
   <a href="items/../tokens.html#string-literals">문자열_리터럴</a> | <a href="items/../tokens.html#raw-string-literals">원시_문자열_리터럴</a></p>
<p><em>함수매개변수</em> :<br />
      <em>Self매개변수</em> <code>,</code><sup>?</sup><br />
   | (<em>Self매개변수</em> <code>,</code>)<sup>?</sup> <em>함수매개변수단일</em> (<code>,</code> <em>함수매개변수단일</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>Self매개변수</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup> ( <em>단축Self</em> | <em>타입Self</em> )</p>
<p><em>단축Self</em> :<br />
    (<code>&amp;</code> | <code>&amp;</code> <a href="items/../trait-bounds.html"><em>라이프타임</em></a>)<sup>?</sup> <code>mut</code><sup>?</sup> <code>self</code></p>
<p><em>타입Self</em> :<br />
   <code>mut</code><sup>?</sup> <code>self</code> <code>:</code> <a href="items/../types.html#type-expressions"><em>타입</em></a></p>
<p><em>함수매개변수단일</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup> ( <em>함수매개변수패턴</em> | <code>...</code> | <a href="items/../types.html#type-expressions"><em>타입</em></a> <sup class="footnote-reference"><a href="#fn-param-2015">4</a></sup> )</p>
<p><em>함수매개변수패턴</em> :<br />
   <a href="items/../patterns.html"><em>최상위대안없는패턴</em></a> <code>:</code> ( <a href="items/../types.html#type-expressions"><em>타입</em></a> | <code>...</code> )</p>
<p><em>함수반환타입</em> :<br />
   <code>-&gt;</code> <a href="items/../types.html#type-expressions"><em>타입</em></a></p>
<div class="footnote-definition" id="async-edition"><sup class="footnote-definition-label">1</sup>
<p><code>async</code> 한정자는 2015 에디션에서 허용되지 않습니다.</p>
</div>
<div class="footnote-definition" id="extern-safe"><sup class="footnote-definition-label">3</sup>
<p><code>safe</code> 함수 한정자는 시맨틱적으로 <code>extern</code> 블록 내에서만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="extern-qualifiers"><sup class="footnote-definition-label">2</sup>
<p><em>Rust 2024 이전 에디션 관련</em>: <code>extern</code> 블록 내에서, <code>safe</code> 또는 <code>unsafe</code> 함수 한정자는 <code>extern</code>이 <code>unsafe</code>로 한정될 때만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="fn-param-2015"><sup class="footnote-definition-label">4</sup>
<p>타입만 있는 함수 매개변수는 2015 에디션에서 <a href="items/traits.html">트레잇 아이템</a>의 연관 함수에서만 허용됩니다.</p>
</div>
</blockquote>
<div class="rule" id="r-items.fn.intro"><a class="rule-link" href="items/functions.html#r-items.fn.intro" title="items.fn.intro"><span>[items<wbr>.fn<wbr>.intro]<span/></a></div>
<p>_함수_는 <a href="items/../expressions/block-expr.html">블록</a>(함수의 <em>본문</em>)과 이름, 매개변수 집합, 출력 타입으로 구성됩니다. 이름을 제외한 나머지는 모두 선택 사항입니다.</p>
<div class="rule" id="r-items.fn.namespace"><a class="rule-link" href="items/functions.html#r-items.fn.namespace" title="items.fn.namespace"><span>[items<wbr>.fn<wbr>.namespace]<span/></a></div>
<p>함수는 <code>fn</code> 키워드로 선언되며, 이는 해당 함수가 위치한 모듈이나 블록의 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 주어진 이름을 정의합니다.</p>
<div class="rule" id="r-items.fn.signature"><a class="rule-link" href="items/functions.html#r-items.fn.signature" title="items.fn.signature"><span>[items<wbr>.fn<wbr>.signature]<span/></a></div>
<p>함수는 호출자가 함수에 인수를 전달하는 <em>입력</em> <a href="items/../variables.html"><em>변수</em></a> 집합을 매개변수로 선언할 수 있으며, 함수가 완료될 때 호출자에게 반환할 값의 <em>출력</em> <a href="items/../types.html#type-expressions"><em>타입</em></a>을 선언할 수 있습니다.</p>
<div class="rule" id="r-items.fn.implicit-return"><a class="rule-link" href="items/functions.html#r-items.fn.implicit-return" title="items.fn.implicit-return"><span>[items<wbr>.fn<wbr>.implicit-return]<span/></a></div>
<p>출력 타입이 명시적으로 지정되지 않은 경우, <a href="items/../types/tuple.html">유닛 타입</a>입니다.</p>
<div class="rule" id="r-items.fn.fn-item-type"><a class="rule-link" href="items/functions.html#r-items.fn.fn-item-type" title="items.fn.fn-item-type"><span>[items<wbr>.fn<wbr>.fn-item-type]<span/></a></div>
<p>참조될 때, _함수_는 해당 0 크기 <a href="items/../types/function-item.html"><em>함수 아이템 타입</em></a>의 일급(first-class) _값_을 산출합니다, 호출될 때 함수에 대한 직접 호출로 평가됩니다.</p>
<p>예를 들어, 이것은 간단한 함수입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.safety-qualifiers"><a class="rule-link" href="items/functions.html#r-items.fn.safety-qualifiers" title="items.fn.safety-qualifiers"><span>[items<wbr>.fn<wbr>.safety-qualifiers]<span/></a></div>
<p><code>safe</code> 함수는 시맨틱적으로 <a href="items/external-blocks.html"><code>extern</code> 블록</a>에서 사용될 때만 허용됩니다.</p>
<div class="rule" id="r-items.fn.params"><a class="rule-link" href="items/functions.html#r-items.fn.params" title="items.fn.params"><span>[items<wbr>.fn<wbr>.params]<span/></a></div>
<h2 id="함수-매개변수"><a class="header" href="#함수-매개변수">함수 매개변수</a></h2>
<div class="rule" id="r-items.fn.params.intro"><a class="rule-link" href="items/functions.html#r-items.fn.params.intro" title="items.fn.params.intro"><span>[items<wbr>.fn<wbr>.params<wbr>.intro]<span/></a></div>
<p>함수 매개변수는 반박 불가능한(irrefutable) <a href="items/../patterns.html">패턴</a>이므로, <code>else</code> 없는 <code>let</code> 바인딩에서 유효한 모든 패턴은 매개변수로도 유효합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first((value, _): (i32, i32)) -&gt; i32 { value }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.params.self-pat"><a class="rule-link" href="items/functions.html#r-items.fn.params.self-pat" title="items.fn.params.self-pat"><span>[items<wbr>.fn<wbr>.params<wbr>.self-pat]<span/></a></div>
<p>첫 번째 매개변수가 _Self매개변수_이면, 이는 해당 함수가 <a href="items/associated-items.html#methods">메서드</a>임을 나타냅니다.</p>
<div class="rule" id="r-items.fn.params.self-restriction"><a class="rule-link" href="items/functions.html#r-items.fn.params.self-restriction" title="items.fn.params.self-restriction"><span>[items<wbr>.fn<wbr>.params<wbr>.self-restriction]<span/></a></div>
<p>self 매개변수가 있는 함수는 <a href="items/traits.html">트레잇</a>이나 <a href="items/implementations.html">구현</a>의 <a href="items/associated-items.html#associated-functions-and-methods">연관 함수</a>로만 나타날 수 있습니다.</p>
<div class="rule" id="r-items.fn.params.varargs"><a class="rule-link" href="items/functions.html#r-items.fn.params.varargs" title="items.fn.params.varargs"><span>[items<wbr>.fn<wbr>.params<wbr>.varargs]<span/></a></div>
<p><code>...</code> 토큰이 있는 매개변수는 <a href="items/external-blocks.html#variadic-functions">가변 인자 함수</a>임을 나타내며, 오직 <a href="items/external-blocks.html">외부 블록</a> 함수의 마지막 매개변수로만 사용될 수 있습니다. 가변 인자 매개변수는 <code>args: ...</code>와 같이 선택적인 식별자를 가질 수 있습니다.</p>
<div class="rule" id="r-items.fn.body"><a class="rule-link" href="items/functions.html#r-items.fn.body" title="items.fn.body"><span>[items<wbr>.fn<wbr>.body]<span/></a></div>
<h2 id="함수-본문"><a class="header" href="#함수-본문">함수 본문</a></h2>
<div class="rule" id="r-items.fn.body.intro"><a class="rule-link" href="items/functions.html#r-items.fn.body.intro" title="items.fn.body.intro"><span>[items<wbr>.fn<wbr>.body<wbr>.intro]<span/></a></div>
<p>함수의 본문 블록은 개념적으로 인자 패턴을 먼저 바인딩한 다음 함수 본문의 값을 <code>return</code>하는 또 다른 블록으로 감싸져 있습니다. 이는 블록의 꼬리 표현식이 평가될 경우 결국 호출자에게 반환됨을 의미합니다. 평소와 같이, 함수 본문 내의 명시적인 return 표현식은 도달할 경우 해당 암시적 반환을 생략합니다.</p>
<p>예를 들어, 위의 함수는 마치 다음과 같이 작성된 것처럼 동작합니다:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">// argument_0은 호출자로부터 전달된 실제 첫 번째 인자입니다.
let (value, _) = argument_0;
return {
    value
};</code></pre>
<div class="rule" id="r-items.fn.body.bodyless"><a class="rule-link" href="items/functions.html#r-items.fn.body.bodyless" title="items.fn.body.bodyless"><span>[items<wbr>.fn<wbr>.body<wbr>.bodyless]<span/></a></div>
<p>본문 블록이 없는 함수는 세미콜론으로 종료됩니다. 이러한 형식은 <a href="items/traits.html">트레잇</a>이나 <a href="items/external-blocks.html">외부 블록</a>에서만 나타날 수 있습니다.</p>
<div class="rule" id="r-items.fn.generics"><a class="rule-link" href="items/functions.html#r-items.fn.generics" title="items.fn.generics"><span>[items<wbr>.fn<wbr>.generics]<span/></a></div>
<h2 id="제네릭-함수"><a class="header" href="#제네릭-함수">제네릭 함수</a></h2>
<div class="rule" id="r-items.fn.generics.intro"><a class="rule-link" href="items/functions.html#r-items.fn.generics.intro" title="items.fn.generics.intro"><span>[items<wbr>.fn<wbr>.generics<wbr>.intro]<span/></a></div>
<p>_제네릭 함수_는 하나 이상의 _매개변수화된 타입_이 해당 시그니처에 나타날 수 있도록 합니다. 각 타입 매개변수는 함수 이름 뒤에 오는 꺾쇠괄호로 둘러싸이고 쉼표로 구분된 목록에 명시적으로 선언되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo는 A와 B에 대해 제네릭합니다.

fn foo&lt;A, B&gt;(x: A, y: B) {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.generics.param-names"><a class="rule-link" href="items/functions.html#r-items.fn.generics.param-names" title="items.fn.generics.param-names"><span>[items<wbr>.fn<wbr>.generics<wbr>.param-names]<span/></a></div>
<p>함수 시그니처와 본문 내부에서, 타입 매개변수의 이름은 타입 이름으로 사용될 수 있습니다.</p>
<div class="rule" id="r-items.fn.generics.param-bounds"><a class="rule-link" href="items/functions.html#r-items.fn.generics.param-bounds" title="items.fn.generics.param-bounds"><span>[items<wbr>.fn<wbr>.generics<wbr>.param-bounds]<span/></a></div>
<p>타입 매개변수에 대해 <a href="items/traits.html">트레잇</a> 바운드를 지정하여 해당 트레잇의 메서드를 해당 타입의 값에 대해 호출할 수 있도록 할 수 있습니다. 이는 <code>where</code> 구문을 사용하여 지정됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;T&gt;(x: T) where T: Debug {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.generics.mono"><a class="rule-link" href="items/functions.html#r-items.fn.generics.mono" title="items.fn.generics.mono"><span>[items<wbr>.fn<wbr>.generics<wbr>.mono]<span/></a></div>
<p>제네릭 함수가 참조될 때, 그 타입은 참조의 컨텍스트에 따라 인스턴스화됩니다. 예를 들어, 여기서 <code>foo</code> 함수를 호출하면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // 세부 사항 생략
}

foo(&amp;[1, 2]);
<span class="boring">}</span></code></pre></pre>
<p>타입 매개변수 <code>T</code>를 <code>i32</code>로 인스턴스화할 것입니다.</p>
<div class="rule" id="r-items.fn.generics.explicit-arguments"><a class="rule-link" href="items/functions.html#r-items.fn.generics.explicit-arguments" title="items.fn.generics.explicit-arguments"><span>[items<wbr>.fn<wbr>.generics<wbr>.explicit-arguments]<span/></a></div>
<p>타입 매개변수는 함수 이름 뒤의 후행 <a href="items/../paths.html">경로</a> 구성 요소에 명시적으로 제공될 수도 있습니다. 이는 타입 매개변수를 결정하기 위한 컨텍스트가 충분하지 않은 경우 필요할 수 있습니다. 예를 들어, <code>mem::size_of::&lt;u32&gt;() == 4</code>와 같습니다.</p>
<div class="rule" id="r-items.fn.extern"><a class="rule-link" href="items/functions.html#r-items.fn.extern" title="items.fn.extern"><span>[items<wbr>.fn<wbr>.extern]<span/></a></div>
<h2 id="외부-함수-한정자"><a class="header" href="#외부-함수-한정자">외부 함수 한정자</a></h2>
<div class="rule" id="r-items.fn.extern.intro"><a class="rule-link" href="items/functions.html#r-items.fn.extern.intro" title="items.fn.extern.intro"><span>[items<wbr>.fn<wbr>.extern<wbr>.intro]<span/></a></div>
<p><code>extern</code> 함수 한정자는 특정 ABI로 호출될 수 있는 함수 _정의_를 제공할 수 있게 합니다:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">extern "ABI" fn foo() { /* ... */ }</code></pre>
<div class="rule" id="r-items.fn.extern.def"><a class="rule-link" href="items/functions.html#r-items.fn.extern.def" title="items.fn.extern.def"><span>[items<wbr>.fn<wbr>.extern<wbr>.def]<span/></a></div>
<p>이들은 종종 함수의 _정의_를 제공하지 않고도 함수를 호출할 수 있게 해주는 함수 _선언_을 제공하는 <a href="items/external-blocks.html">외부 블록</a> 아이템과 결합되어 사용됩니다.</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">unsafe extern "ABI" {
  unsafe fn foo(); /* 본문 없음 */
  safe fn bar(); /* 본문 없음 */
}
unsafe { foo() };
bar();</code></pre>
<div class="rule" id="r-items.fn.extern.default-abi"><a class="rule-link" href="items/functions.html#r-items.fn.extern.default-abi" title="items.fn.extern.default-abi"><span>[items<wbr>.fn<wbr>.extern<wbr>.default-abi]<span/></a></div>
<p>함수 아이템의 <code>FunctionQualifiers</code>에서 <code>"extern" Abi?*</code>가 생략되면, <code>"Rust"</code> ABI가 할당됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "Rust" fn foo() {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.extern.foreign-call"><a class="rule-link" href="items/functions.html#r-items.fn.extern.foreign-call" title="items.fn.extern.foreign-call"><span>[items<wbr>.fn<wbr>.extern<wbr>.foreign-call]<span/></a></div>
<p>함수는 외부 코드에 의해 호출될 수 있으며, Rust와 다른 ABI를 사용하면 C와 같은 다른 프로그래밍 언어에서 호출할 수 있는 함수를 제공할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// "C" ABI를 가진 함수를 선언합니다.
extern "C" fn new_i32() -&gt; i32 { 0 }

// "stdcall" ABI를 가진 함수를 선언합니다.
<span class="boring">#[cfg(any(windows, target_arch = "x86"))]
</span>extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.extern.default-extern"><a class="rule-link" href="items/functions.html#r-items.fn.extern.default-extern" title="items.fn.extern.default-extern"><span>[items<wbr>.fn<wbr>.extern<wbr>.default-extern]<span/></a></div>
<p><a href="items/external-blocks.html">외부 블록</a>과 마찬가지로, <code>extern</code> 키워드가 사용되고 <code>"ABI"</code>가 생략되면, 사용되는 ABI는 <code>"C"</code>가 기본값입니다. 즉, 다음은:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" fn new_i32() -&gt; i32 { 0 }
let fptr: extern "C" fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.extern.unwind"><a class="rule-link" href="items/functions.html#r-items.fn.extern.unwind" title="items.fn.extern.unwind"><span>[items<wbr>.fn<wbr>.extern<wbr>.unwind]<span/></a></div>
<p><code>"Rust"</code>와 다른 ABI를 가진 함수는 Rust와 정확히 같은 방식으로 언와인딩(unwinding)을 지원하지 않습니다. 따라서 이러한 ABI를 가진 함수의 끝을 지나서 언와인딩하면 프로세스가 중단(abort)됩니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code> 구현의 LLVM 백엔드는 잘못된 명령어를 실행하여 프로세스를 중단시킵니다.</p>
</blockquote>
<div class="rule" id="r-items.fn.const"><a class="rule-link" href="items/functions.html#r-items.fn.const" title="items.fn.const"><span>[items<wbr>.fn<wbr>.const]<span/></a></div>
<h2 id="const-함수"><a class="header" href="#const-함수">const 함수</a></h2>
<div class="rule" id="r-items.fn.const.intro"><a class="rule-link" href="items/functions.html#r-items.fn.const.intro" title="items.fn.const.intro"><span>[items<wbr>.fn<wbr>.const<wbr>.intro]<span/></a></div>
<p><code>const</code> 키워드로 한정된 함수는 <a href="items/../const_eval.html#const-functions">const 함수</a>이며, <a href="items/structs.html">튜플 구조체</a> 및 <a href="items/enumerations.html">튜플 변형</a> 생성자도 마찬가지입니다. _const 함수_는 <a href="items/../const_eval.html#const-context">const 컨텍스트</a> 내에서 호출될 수 있습니다.</p>
<div class="rule" id="r-items.fn.const.extern"><a class="rule-link" href="items/functions.html#r-items.fn.const.extern" title="items.fn.const.extern"><span>[items<wbr>.fn<wbr>.const<wbr>.extern]<span/></a></div>
<p>const 함수는 <a href="items/functions.html#extern-function-qualifier"><code>extern</code></a> 함수 한정자를 사용할 수 있습니다.</p>
<div class="rule" id="r-items.fn.const.exclusivity"><a class="rule-link" href="items/functions.html#r-items.fn.const.exclusivity" title="items.fn.const.exclusivity"><span>[items<wbr>.fn<wbr>.const<wbr>.exclusivity]<span/></a></div>
<p>const 함수는 <a href="items/functions.html#async-functions">async</a>가 될 수 없습니다.</p>
<div class="rule" id="r-items.fn.async"><a class="rule-link" href="items/functions.html#r-items.fn.async" title="items.fn.async"><span>[items<wbr>.fn<wbr>.async]<span/></a></div>
<h2 id="비동기-함수"><a class="header" href="#비동기-함수">비동기 함수</a></h2>
<div class="rule" id="r-items.fn.async.intro"><a class="rule-link" href="items/functions.html#r-items.fn.async.intro" title="items.fn.async.intro"><span>[items<wbr>.fn<wbr>.async<wbr>.intro]<span/></a></div>
<p>함수는 <code>async</code>로 한정될 수 있으며, 이는 <code>unsafe</code> 한정자와 결합될 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn regular_example() { }
async unsafe fn unsafe_example() { }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.async.future"><a class="rule-link" href="items/functions.html#r-items.fn.async.future" title="items.fn.async.future"><span>[items<wbr>.fn<wbr>.async<wbr>.future]<span/></a></div>
<p>비동기 함수는 호출될 때 작업을 수행하지 않습니다. 대신 인수를 퓨처(future)로 캡처합니다. 폴링(polled)될 때, 해당 퓨처는 함수의 본문을 실행합니다.</p>
<div class="rule" id="r-items.fn.async.desugar-brief"><a class="rule-link" href="items/functions.html#r-items.fn.async.desugar-brief" title="items.fn.async.desugar-brief"><span>[items<wbr>.fn<wbr>.async<wbr>.desugar-brief]<span/></a></div>
<p>비동기 함수(async function)는 <a href="items/../types/impl-trait.html"><code>impl Future</code></a>를 반환하고 <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> 블록</a>을 본문으로 갖는 함수와 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 소스
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::future::Future;
</span>// 디슈거링(Desugared)
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.async.desugar"><a class="rule-link" href="items/functions.html#r-items.fn.async.desugar" title="items.fn.async.desugar"><span>[items<wbr>.fn<wbr>.async<wbr>.desugar]<span/></a></div>
<p>실제 디슈거링은 더 복잡합니다:</p>
<div class="rule" id="r-items.fn.async.lifetime-capture"><a class="rule-link" href="items/functions.html#r-items.fn.async.lifetime-capture" title="items.fn.async.lifetime-capture"><span>[items<wbr>.fn<wbr>.async<wbr>.lifetime-capture]<span/></a></div>
<ul>
<li>디슈거링에서의 반환 타입은 <code>async fn</code> 선언의 모든 라이프타임 매개변수를 캡처한다고 가정합니다. 이는 위의 디슈거링 예시에서 <code>'a</code>보다 명시적으로 오래 살며, 따라서 이를 캡처하는 것에서 확인할 수 있습니다.</li>
</ul>
<div class="rule" id="r-items.fn.async.param-capture"><a class="rule-link" href="items/functions.html#r-items.fn.async.param-capture" title="items.fn.async.param-capture"><span>[items<wbr>.fn<wbr>.async<wbr>.param-capture]<span/></a></div>
<ul>
<li>본문의 <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> 블록</a>은 사용되지 않거나 <code>_</code> 패턴에 바인딩된 매개변수를 포함하여 모든 함수 매개변수를 캡처합니다. 이는 함수가 비동기가 아닐 때와 동일한 순서로 함수 매개변수가 드롭되도록 보장하지만, 드롭은 반환된 퓨처가 완전히 어웨이트(awaited)되었을 때 발생한다는 점이 다릅니다.</li>
</ul>
<p>비동기의 효과에 대한 자세한 내용은 <a href="items/../expressions/block-expr.html#async-blocks"><code>async</code> 블록</a>을 참조하십시오.</p>
<div class="rule" id="r-items.fn.async.edition2018"><a class="rule-link" href="items/functions.html#r-items.fn.async.edition2018" title="items.fn.async.edition2018"><span>[items<wbr>.fn<wbr>.async<wbr>.edition2018]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 비동기 함수는 러스트 2018부터 사용할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-items.fn.async.safety"><a class="rule-link" href="items/functions.html#r-items.fn.async.safety" title="items.fn.async.safety"><span>[items<wbr>.fn<wbr>.async<wbr>.safety]<span/></a></div>
<h3 id="async와-unsafe-결합하기"><a class="header" href="#async와-unsafe-결합하기"><code>async</code>와 <code>unsafe</code> 결합하기</a></h3>
<div class="rule" id="r-items.fn.async.safety.intro"><a class="rule-link" href="items/functions.html#r-items.fn.async.safety.intro" title="items.fn.async.safety.intro"><span>[items<wbr>.fn<wbr>.async<wbr>.safety<wbr>.intro]<span/></a></div>
<p>비동기이면서 동시에 안전하지 않은(unsafe) 함수를 선언하는 것은 합법입니다. 결과 함수는 호출하기에 안전하지 않으며 (다른 비동기 함수와 마찬가지로) 퓨처를 반환합니다. 이 퓨처는 일반적인 퓨처이므로 이를 “어웨이트(await)” 하는 데 <code>unsafe</code> 컨텍스트가 필요하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 어웨이트되었을 때 `x`를 역참조하는 퓨처를 반환합니다.
//
// 건전성 조건: 결과 퓨처가 완료될 때까지 `x`를 안전하게 역참조할 수 있어야 합니다.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // 함수를 처음 호출하려면 `unsafe` 블록이 필요합니다.
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // 하지만 여기서는 `unsafe` 블록이 필요하지 않습니다. 이는 `p`의 값을 읽을 것입니다.
    let q = future.await;
}
<span class="boring">}</span></code></pre></pre>
<p>이 동작은 <code>impl Future</code>를 반환하는 함수로의 디슈거링 결과입니다. 이 경우 디슈거링된 함수는 <code>unsafe</code> 함수이지만, 반환 값은 동일하게 유지됩니다.</p>
<p>Unsafe는 다른 함수에서 사용되는 것과 정확히 동일한 방식으로 비동기 함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 몇 가지 추가적인 의무를 부과함을 나타냅니다. 다른 모든 unsafe 함수와 마찬가지로, 이러한 조건은 초기 호출 자체를 넘어 확장될 수 있습니다. 예를 들어, 위의 스니펫에서 <code>unsafe_example</code> 함수는 포인터 <code>x</code>를 인자로 받았고, (어웨이트되었을 때) 해당 포인터를 역참조했습니다. 이는 퓨처가 실행을 마칠 때까지 <code>x</code>가 유효해야 함을 의미하며, 이를 보장하는 것은 호출자의 책임입니다.</p>
<div class="rule" id="r-items.fn.attributes"><a class="rule-link" href="items/functions.html#r-items.fn.attributes" title="items.fn.attributes"><span>[items<wbr>.fn<wbr>.attributes]<span/></a></div>
<h2 id="함수의-속성"><a class="header" href="#함수의-속성">함수의 속성</a></h2>
<div class="rule" id="r-items.fn.attributes.intro"><a class="rule-link" href="items/functions.html#r-items.fn.attributes.intro" title="items.fn.attributes.intro"><span>[items<wbr>.fn<wbr>.attributes<wbr>.intro]<span/></a></div>
<p><a href="items/../attributes.html">외부 속성</a>은 함수에 허용됩니다. <a href="items/../attributes.html">내부 속성</a>은 함수 본문 <a href="items/../expressions/block-expr.html">블록</a> 내부의 <code>{</code> 바로 뒤에 허용됩니다.</p>
<p>이 예시는 함수의 내부 속성을 보여줍니다. 이 함수는 단지 “Example“이라는 단어로 문서화됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn documented() {
    #![doc = "예시"]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: 린트(lints)를 제외하고, 함수 아이템에는 외부 속성만 사용하는 것이 관용적입니다.</p>
</blockquote>
<div class="rule" id="r-items.fn.attributes.builtin-attributes"><a class="rule-link" href="items/functions.html#r-items.fn.attributes.builtin-attributes" title="items.fn.attributes.builtin-attributes"><span>[items<wbr>.fn<wbr>.attributes<wbr>.builtin-attributes]<span/></a></div>
<p>함수에서 의미를 갖는 속성은 <a href="items/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a>, <a href="items/../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="items/../abi.html#the-export_name-attribute"><code>export_name</code></a>, <a href="items/../abi.html#the-link_section-attribute"><code>link_section</code></a>, <a href="items/../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a>, <a href="items/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>, <a href="items/../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a>, <a href="items/../procedural-macros.html">절차적 매크로 속성</a>, <a href="items/../attributes/testing.html">테스팅 속성</a>, 그리고 <a href="items/../attributes/codegen.html#optimization-hints">최적화 힌트 속성</a>입니다. 함수는 속성 매크로도 허용합니다.</p>
<div class="rule" id="r-items.fn.param-attributes"><a class="rule-link" href="items/functions.html#r-items.fn.param-attributes" title="items.fn.param-attributes"><span>[items<wbr>.fn<wbr>.param-attributes]<span/></a></div>
<h2 id="함수-매개변수의-속성"><a class="header" href="#함수-매개변수의-속성">함수 매개변수의 속성</a></h2>
<div class="rule" id="r-items.fn.param-attributes.intro"><a class="rule-link" href="items/functions.html#r-items.fn.param-attributes.intro" title="items.fn.param-attributes.intro"><span>[items<wbr>.fn<wbr>.param-attributes<wbr>.intro]<span/></a></div>
<p><a href="items/../attributes.html">외부 속성</a>은 함수 매개변수에 허용되며, 허용되는 <a href="items/../attributes.html#built-in-attributes-index">내장 속성</a>은 <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>로 제한됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.fn.param-attributes.parsed-attributes"><a class="rule-link" href="items/functions.html#r-items.fn.param-attributes.parsed-attributes" title="items.fn.param-attributes.parsed-attributes"><span>[items<wbr>.fn<wbr>.param-attributes<wbr>.parsed-attributes]<span/></a></div>
<p>아이템에 적용되는 절차적 매크로 속성에서 사용하는 비활성(inert) 도우미 속성도 허용되지만, 최종 <code>TokenStream</code>에 이러한 비활성 속성을 포함하지 않도록 주의해야 합니다.</p>
<p>예를 들어, 다음 코드는 어디에도 공식적으로 정의되지 않은 비활성 <code>some_inert_attribute</code> 속성을 정의하고, <code>some_proc_macro_attribute</code> 절차적 매크로가 그 존재를 감지하여 출력 토큰 스트림에서 제거하는 역할을 담당합니다.</p>
<!-- ignore: requires proc macro -->
<pre><code class="language-rust ignore">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.type"><a class="rule-link" href="items/type-aliases.html#r-items.type" title="items.type"><span>[items<wbr>.type]<span/></a></div>
<h1 id="타입-별칭"><a class="header" href="#타입-별칭">타입 별칭</a></h1>
<div class="rule" id="r-items.type.syntax"><a class="rule-link" href="items/type-aliases.html#r-items.type.syntax" title="items.type.syntax"><span>[items<wbr>.type<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>타입별칭</em> :<br />
   <code>type</code> <a href="items/../identifiers.html">식별자</a> <a href="items/generics.html"><em>제네릭매개변수</em></a><sup>?</sup> ( <code>:</code> <a href="items/../trait-bounds.html"><em>타입매개변수바운드</em></a> )<sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup> ( <code>=</code> <a href="items/../types.html#type-expressions"><em>타입</em></a> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup>)<sup>?</sup> <code>;</code></p>
</blockquote>
<div class="rule" id="r-items.type.intro"><a class="rule-link" href="items/type-aliases.html#r-items.type.intro" title="items.type.intro"><span>[items<wbr>.type<wbr>.intro]<span/></a></div>
<p>_타입 별칭_은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 있는 기존 <a href="items/../types.html">타입</a>에 대한 새로운 이름을 정의합니다. 타입 별칭은 <code>type</code> 키워드로 선언됩니다. 모든 값은 단일하고 구체적인 타입을 갖지만, 여러 다른 트레잇을 구현할 수 있으며, 여러 다른 타입 제약과 호환될 수 있습니다.</p>
<p>예를 들어, 다음은 <code>Point</code> 타입을 <code>(u8, u8)</code>(부호 없는 8비트 정수 쌍의 타입)의 동의어로 정의합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Point = (u8, u8);
let p: Point = (41, 68);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.type.constructor-alias"><a class="rule-link" href="items/type-aliases.html#r-items.type.constructor-alias" title="items.type.constructor-alias"><span>[items<wbr>.type<wbr>.constructor-alias]<span/></a></div>
<p>튜플 구조체나 유닛 구조체에 대한 타입 별칭은 해당 타입의 생성자를 한정하는 데 사용할 수 없습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct(u32);

use MyStruct as UseAlias;
type TypeAlias = MyStruct;

let _ = UseAlias(5); // OK
let _ = TypeAlias(5); // 작동하지 않음
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.type.associated-type"><a class="rule-link" href="items/type-aliases.html#r-items.type.associated-type" title="items.type.associated-type"><span>[items<wbr>.type<wbr>.associated-type]<span/></a></div>
<p><a href="items/associated-items.html#associated-types">연관 타입</a>으로 사용되지 않는 경우, 타입 별칭은 반드시 <a href="items/../types.html#type-expressions"><em>타입</em></a>을 포함해야 하며 <a href="items/../trait-bounds.html"><em>타입매개변수바운드</em></a>는 포함할 수 없습니다.</p>
<div class="rule" id="r-items.type.associated-trait"><a class="rule-link" href="items/type-aliases.html#r-items.type.associated-trait" title="items.type.associated-trait"><span>[items<wbr>.type<wbr>.associated-trait]<span/></a></div>
<p>A type alias, when used as an <a href="items/associated-items.html#associated-types">associated type</a> in a <a href="items/traits.html">trait</a>, must not include a <a href="items/../types.html#type-expressions"><em>Type</em></a> specification but may include <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a>.</p>
<div class="rule" id="r-items.type.associated-impl"><a class="rule-link" href="items/type-aliases.html#r-items.type.associated-impl" title="items.type.associated-impl"><span>[items<wbr>.type<wbr>.associated-impl]<span/></a></div>
<p>A type alias, when used as an <a href="items/associated-items.html#associated-types">associated type</a> in a <a href="items/implementations.html#trait-implementations">trait impl</a>, must include a <a href="items/../types.html#type-expressions"><em>Type</em></a> specification and may not include <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a>.</p>
<div class="rule" id="r-items.type.deprecated"><a class="rule-link" href="items/type-aliases.html#r-items.type.deprecated" title="items.type.deprecated"><span>[items<wbr>.type<wbr>.deprecated]<span/></a></div>
<p>Where clauses before the equals sign on a type alias in a <a href="items/implementations.html#trait-implementations">trait impl</a> (like <code>type TypeAlias&lt;T&gt; where T: Foo = Bar&lt;T&gt;</code>) are deprecated. Where clauses after the equals sign (like <code>type TypeAlias&lt;T&gt; = Bar&lt;T&gt; where T: Foo</code>) are preferred.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.struct"><a class="rule-link" href="items/structs.html#r-items.struct" title="items.struct"><span>[items<wbr>.struct]<span/></a></div>
<h1 id="구조체"><a class="header" href="#구조체">구조체</a></h1>
<div class="rule" id="r-items.struct.syntax"><a class="rule-link" href="items/structs.html#r-items.struct.syntax" title="items.struct.syntax"><span>[items<wbr>.struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Struct</em> :<br />
      <em>StructStruct</em><br />
   | <em>TupleStruct</em></p>
<p><em>StructStruct</em> :<br />
   <code>struct</code> <a href="items/../identifiers.html">IDENTIFIER</a>  <a href="items/generics.html"><em>GenericParams</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> ( <code>{</code> <em>StructFields</em><sup>?</sup> <code>}</code> | <code>;</code> )</p>
<p><em>TupleStruct</em> :<br />
   <code>struct</code> <a href="items/../identifiers.html">IDENTIFIER</a>  <a href="items/generics.html"><em>GenericParams</em></a><sup>?</sup> <code>(</code> <em>TupleFields</em><sup>?</sup> <code>)</code> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>;</code></p>
<p><em>StructFields</em> :<br />
   <em>StructField</em> (<code>,</code> <em>StructField</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>StructField</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">IDENTIFIER</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>튜플필드들</em> :<br />
   <em>튜플필드</em> (<code>,</code> <em>튜플필드</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>튜플필드</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>가시성</em></a><sup>?</sup><br />
   <a href="items/../types.html#type-expressions"><em>타입</em></a></p>
</blockquote>
<div class="rule" id="r-items.struct.intro"><a class="rule-link" href="items/structs.html#r-items.struct.intro" title="items.struct.intro"><span>[items<wbr>.struct<wbr>.intro]<span/></a></div>
<p>_구조체(struct)_는 <code>struct</code> 키워드로 정의된 명목상의 <a href="items/../types/struct.html">구조체 타입</a>입니다.</p>
<div class="rule" id="r-items.struct.namespace"><a class="rule-link" href="items/structs.html#r-items.struct.namespace" title="items.struct.namespace"><span>[items<wbr>.struct<wbr>.namespace]<span/></a></div>
<p>구조체 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 주어진 이름을 정의합니다.</p>
<p><code>struct</code> 아이템과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {x: i32, y: i32}
let p = Point {x: 10, y: 11};
let px: i32 = p.x;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.struct.tuple"><a class="rule-link" href="items/structs.html#r-items.struct.tuple" title="items.struct.tuple"><span>[items<wbr>.struct<wbr>.tuple]<span/></a></div>
<p>_튜플 구조체_는 명목상의 <a href="items/../types/tuple.html">튜플 타입</a>이며, 역시 <code>struct</code> 키워드로 정의됩니다. 타입을 정의하는 것 외에도, <a href="items/../names/namespaces.html">값 네임스페이스</a>에 동일한 이름의 생성자를 정의합니다. 생성자는 구조체의 새 인스턴스를 생성하기 위해 호출할 수 있는 함수입니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
let p = Point(10, 11);
let px: i32 = match p { Point(x, _) =&gt; x };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.struct.unit"><a class="rule-link" href="items/structs.html#r-items.struct.unit" title="items.struct.unit"><span>[items<wbr>.struct<wbr>.unit]<span/></a></div>
<p>_유닛 유사 구조체(unit-like struct)_는 필드 목록을 완전히 생략하여 정의된, 필드가 없는 구조체입니다. 이러한 구조체는 암시적으로 동일한 이름의 해당 타입 <a href="items/constant-items.html">상수</a>를 정의합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.struct.layout"><a class="rule-link" href="items/structs.html#r-items.struct.layout" title="items.struct.layout"><span>[items<wbr>.struct<wbr>.layout]<span/></a></div>
<p>구조체의 정확한 메모리 레이아웃은 지정되어 있지 않습니다. <a href="items/../type-layout.html#representations"><code>repr</code> 속성</a>을 사용하여 특정 레이아웃을 지정할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.enum"><a class="rule-link" href="items/enumerations.html#r-items.enum" title="items.enum"><span>[items<wbr>.enum]<span/></a></div>
<h1 id="열거형"><a class="header" href="#열거형">열거형</a></h1>
<div class="rule" id="r-items.enum.syntax"><a class="rule-link" href="items/enumerations.html#r-items.enum.syntax" title="items.enum.syntax"><span>[items<wbr>.enum<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>열거형</em> :<br />
   <code>enum</code> <a href="items/../identifiers.html">식별자</a>  <a href="items/generics.html"><em>제네릭파라미터</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup> <code>{</code> <em>열거형항목들</em><sup>?</sup> <code>}</code></p>
<p><em>열거형항목들</em> :<br />
   <em>열거형항목</em> ( <code>,</code> <em>열거형항목</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>열거형항목</em> :<br />
   <em>외부속성</em><sup>*</sup> <a href="items/../visibility-and-privacy.html"><em>가시성</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">식별자</a> ( <em>튜플형열거형항목</em> | <em>구조체형열거형항목</em> )<sup>?</sup> <em>열거형항목판별자</em><sup>?</sup></p>
<p><em>튜플형열거형항목</em> :<br />
   <code>(</code> <a href="items/structs.html"><em>튜플필드들</em></a><sup>?</sup> <code>)</code></p>
<p><em>구조체형열거형항목</em> :<br />
   <code>{</code> <a href="items/structs.html"><em>구조체필드들</em></a><sup>?</sup> <code>}</code></p>
<p><em>열거형항목판별자</em> :<br />
   <code>=</code> <a href="items/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-items.enum.intro"><a class="rule-link" href="items/enumerations.html#r-items.enum.intro" title="items.enum.intro"><span>[items<wbr>.enum<wbr>.intro]<span/></a></div>
<p><em>열거형(enumeration)</em> 또는 줄여서 _enum_은 명목상의 <a href="items/../types/enum.html">열거 타입</a>과 함께, 해당 열거 타입의 값을 생성하거나 패턴 매칭하는 데 사용할 수 있는 <em>생성자</em> 세트를 동시에 정의하는 것입니다.</p>
<div class="rule" id="r-items.enum.decl"><a class="rule-link" href="items/enumerations.html#r-items.enum.decl" title="items.enum.decl"><span>[items<wbr>.enum<wbr>.decl]<span/></a></div>
<p>열거형은 <code>enum</code> 키워드로 선언됩니다.</p>
<div class="rule" id="r-items.enum.namespace"><a class="rule-link" href="items/enumerations.html#r-items.enum.namespace" title="items.enum.namespace"><span>[items<wbr>.enum<wbr>.namespace]<span/></a></div>
<p><code>enum</code> 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 열거형 타입을 정의합니다.</p>
<p><code>enum</code> 아이템과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.constructor"><a class="rule-link" href="items/enumerations.html#r-items.enum.constructor" title="items.enum.constructor"><span>[items<wbr>.enum<wbr>.constructor]<span/></a></div>
<p>열거형 생성자는 이름을 가진 필드나 이름이 없는 필드를 가질 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog("Cocoa".to_string(), 37.2);
a = Animal::Cat { name: "Spotty".to_string(), weight: 2.7 };
<span class="boring">}</span></code></pre></pre>
<p>이 예제에서 <code>Cat</code>은 _구조체형 열거형 변형(struct-like enum variant)_인 반면, <code>Dog</code>는 단순히 열거형 변형이라고 부릅니다.</p>
<div class="rule" id="r-items.enum.fieldless"><a class="rule-link" href="items/enumerations.html#r-items.enum.fieldless" title="items.enum.fieldless"><span>[items<wbr>.enum<wbr>.fieldless]<span/></a></div>
<p>생성자에 필드가 포함되지 않은 열거형을 _<span id="field-less-enum">필드 없는 열거형(field-less enum)</span>_이라고 합니다. 예를 들어, 다음은 필드 없는 열거형입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.unit-only"><a class="rule-link" href="items/enumerations.html#r-items.enum.unit-only" title="items.enum.unit-only"><span>[items<wbr>.enum<wbr>.unit-only]<span/></a></div>
<p>필드 없는 열거형이 유닛 변형만 포함하는 경우, 해당 열거형을 _<span id="unit-only-enum">유닛 전용 열거형(unit-only enum)</span>_이라고 합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo = 3,
    Bar = 2,
    Baz = 1,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.constructor-names"><a class="rule-link" href="items/enumerations.html#r-items.enum.constructor-names" title="items.enum.constructor-names"><span>[items<wbr>.enum<wbr>.constructor-names]<span/></a></div>
<p>변형 생성자는 <a href="items/structs.html">구조체</a> 정의와 유사하며, <a href="items/use-declarations.html">use 선언</a>을 포함하여 열거형 이름의 경로로 참조할 수 있습니다.</p>
<div class="rule" id="r-items.enum.constructor-namespace"><a class="rule-link" href="items/enumerations.html#r-items.enum.constructor-namespace" title="items.enum.constructor-namespace"><span>[items<wbr>.enum<wbr>.constructor-namespace]<span/></a></div>
<p>각 변형은 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 해당 타입을 정의하지만, 그 타입은 타입 지정자로 사용할 수 없습니다. 튜플형 및 유닛형 변형은 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 생성자도 정의합니다.</p>
<div class="rule" id="r-items.enum.struct-expr"><a class="rule-link" href="items/enumerations.html#r-items.enum.struct-expr" title="items.enum.struct-expr"><span>[items<wbr>.enum<wbr>.struct-expr]<span/></a></div>
<p>구조체형 변형은 <a href="items/../expressions/struct-expr.html">구조체 표현식</a>으로 인스턴스화할 수 있습니다.</p>
<div class="rule" id="r-items.enum.tuple-expr"><a class="rule-link" href="items/enumerations.html#r-items.enum.tuple-expr" title="items.enum.tuple-expr"><span>[items<wbr>.enum<wbr>.tuple-expr]<span/></a></div>
<p>튜플형 변형은 <a href="items/../expressions/call-expr.html">호출 표현식</a>이나 <a href="items/../expressions/struct-expr.html">구조체 표현식</a>으로 인스턴스화할 수 있습니다.</p>
<div class="rule" id="r-items.enum.path-expr"><a class="rule-link" href="items/enumerations.html#r-items.enum.path-expr" title="items.enum.path-expr"><span>[items<wbr>.enum<wbr>.path-expr]<span/></a></div>
<p>유닛형 변형은 <a href="items/../expressions/path-expr.html">경로 표현식</a>이나 <a href="items/../expressions/struct-expr.html">구조체 표현식</a>으로 인스턴스화할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Examples {
    UnitLike,
    TupleLike(i32),
    StructLike { value: i32 },
}

use Examples::*; // 모든 변형에 대한 별칭을 생성합니다.
let x = UnitLike; // 상수 아이템의 경로 표현식.
let x = UnitLike {}; // 구조체 표현식.
let y = TupleLike(123); // 호출 표현식.
let y = TupleLike { 0: 123 }; // 정수 필드 이름을 사용하는 구조체 표현식.
let z = StructLike { value: 123 }; // 구조체 표현식.
<span class="boring">}</span></code></pre></pre>
<p><span id="custom-discriminant-values-for-fieldless-enumerations"></span></p>
<div class="rule" id="r-items.enum.discriminant"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant" title="items.enum.discriminant"><span>[items<wbr>.enum<wbr>.discriminant]<span/></a></div>
<h2 id="판별자"><a class="header" href="#판별자">판별자</a></h2>
<div class="rule" id="r-items.enum.discriminant.intro"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.intro" title="items.enum.discriminant.intro"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.intro]<span/></a></div>
<p>각 열거형 인스턴스는 _판별자(discriminant)_를 가집니다. 이는 어떤 변형을 보유하고 있는지 결정하는 데 사용되는 논리적으로 연결된 정수입니다.</p>
<div class="rule" id="r-items.enum.discriminant.repr-rust"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.repr-rust" title="items.enum.discriminant.repr-rust"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.repr-rust]<span/></a></div>
<p><a href="items/../type-layout.html#the-rust-representation"><code>Rust</code> 표현</a> 하에서, 판별자는 <code>isize</code> 값으로 해석됩니다. 하지만, 컴파일러는 실제 메모리 레이아웃에서 더 작은 타입(또는 변형을 구별하는 다른 수단)을 사용하는 것이 허용됩니다.</p>
<h3 id="판별자-값-할당"><a class="header" href="#판별자-값-할당">판별자 값 할당</a></h3>
<div class="rule" id="r-items.enum.discriminant.explicit"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.explicit" title="items.enum.discriminant.explicit"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.explicit]<span/></a></div>
<h4 id="명시적-판별자"><a class="header" href="#명시적-판별자">명시적 판별자</a></h4>
<div class="rule" id="r-items.enum.discriminant.explicit.intro"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.explicit.intro" title="items.enum.discriminant.explicit.intro"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.explicit<wbr>.intro]<span/></a></div>
<p>두 가지 상황에서, 변형 이름 뒤에 <code>=</code>와 <a href="items/../const_eval.html#constant-expressions">상수 표현식</a>을 붙여 변형의 판별자를 명시적으로 설정할 수 있습니다:</p>
<div class="rule" id="r-items.enum.discriminant.explicit.unit-only"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.explicit.unit-only" title="items.enum.discriminant.explicit.unit-only"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.explicit<wbr>.unit-only]<span/></a></div>
<ol>
<li>열거형이 “<a href="items/enumerations.html#unit-only-enum">유닛 전용</a>“인 경우.</li>
</ol>
<div class="rule" id="r-items.enum.discriminant.explicit.primitive-repr"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.explicit.primitive-repr" title="items.enum.discriminant.explicit.primitive-repr"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.explicit<wbr>.primitive-repr]<span/></a></div>
<ol start="2">
<li>
<p><a href="items/../type-layout.html#primitive-representations">원시 표현(primitive representation)</a>이 사용되는 경우. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16),
    Struct {
        a: u8,
        b: u16,
    } = 1,
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<div class="rule" id="r-items.enum.discriminant.implicit"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.implicit" title="items.enum.discriminant.implicit"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.implicit]<span/></a></div>
<h4 id="암시적-판별자"><a class="header" href="#암시적-판별자">암시적 판별자</a></h4>
<p>변형에 대한 판별자가 지정되지 않으면, 선언 내 이전 변형의 판별자보다 1 큰 값으로 설정됩니다. 선언의 첫 번째 변형의 판별자가 지정되지 않으면, 0으로 설정됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,            // 0
    Baz = 123,      // 123
    Quux,           // 124
}

let baz_discriminant = Foo::Baz as u32;
assert_eq!(baz_discriminant, 123);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.discriminant.restrictions"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.restrictions" title="items.enum.discriminant.restrictions"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.restrictions]<span/></a></div>
<h4 id="제약-사항-1"><a class="header" href="#제약-사항-1">제약 사항</a></h4>
<div class="rule" id="r-items.enum.discriminant.restrictions.same-discriminant"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.restrictions.same-discriminant" title="items.enum.discriminant.restrictions.same-discriminant"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.restrictions<wbr>.same-discriminant]<span/></a></div>
<p>두 변형이 동일한 판별자를 공유하면 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SharedDiscriminantError {
    SharedA = 1,
    SharedB = 1
}

enum SharedDiscriminantError2 {
    Zero,       // 0
    One,        // 1
    OneToo = 1  // 1 (이전과 충돌!)
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.discriminant.restrictions.above-max-discriminant"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.restrictions.above-max-discriminant" title="items.enum.discriminant.restrictions.above-max-discriminant"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.restrictions<wbr>.above-max-discriminant]<span/></a></div>
<p>이전 판별자가 판별자 크기의 최댓값일 때 판별자를 지정하지 않는 것도 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum OverflowingDiscriminantError {
    Max = 255,
    MaxPlusOne // 256이어야 하지만, 열거형을 오버플로합니다.
}

#[repr(u8)]
enum OverflowingDiscriminantError2 {
    MaxMinusOne = 254, // 254
    Max,               // 255
    MaxPlusOne         // 256이어야 하지만, 열거형을 오버플로합니다.
}
<span class="boring">}</span></code></pre></pre>
<h3 id="판별자-접근"><a class="header" href="#판별자-접근">판별자 접근</a></h3>
<h4 id="memdiscriminant를-통해"><a class="header" href="#memdiscriminant를-통해"><code>mem::discriminant</code>를 통해</a></h4>
<div class="rule" id="r-items.enum.discriminant.access-opaque"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.access-opaque" title="items.enum.discriminant.access-opaque"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.access-opaque]<span/></a></div>
<p><a href="items/../../core/mem/fn.discriminant.html"><code>std::mem::discriminant</code></a>는 비교 가능한 열거형 값의 판별자에 대한 불투명한(opaque) 참조를 반환합니다. 이는 판별자의 값을 얻는 데 사용할 수 없습니다.</p>
<div class="rule" id="r-items.enum.discriminant.coercion"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.coercion" title="items.enum.discriminant.coercion"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.coercion]<span/></a></div>
<h4 id="캐스팅"><a class="header" href="#캐스팅">캐스팅</a></h4>
<div class="rule" id="r-items.enum.discriminant.coercion.intro"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.coercion.intro" title="items.enum.discriminant.coercion.intro"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.coercion<wbr>.intro]<span/></a></div>
<p>열거형이 <a href="items/enumerations.html#unit-only-enum">유닛 전용</a>(튜플 및 구조체 변형이 없음)인 경우, <a href="items/../expressions/operator-expr.html#semantics">숫자 캐스트</a>를 사용하여 판별자에 직접 접근할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo,
    Bar,
    Baz,
}

assert_eq!(0, Enum::Foo as isize);
assert_eq!(1, Enum::Bar as isize);
assert_eq!(2, Enum::Baz as isize);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.discriminant.coercion.fieldless"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.coercion.fieldless" title="items.enum.discriminant.coercion.fieldless"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.coercion<wbr>.fieldless]<span/></a></div>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>은 명시적 판별자가 없거나 유닛 변형만 명시적인 경우 캐스팅될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}

assert_eq!(0, Fieldless::Tuple() as isize);
assert_eq!(1, Fieldless::Struct{} as isize);
assert_eq!(2, Fieldless::Unit as isize);

#[repr(u8)]
enum FieldlessWithDiscrimants {
    First = 10,
    Tuple(),
    Second = 20,
    Struct{},
    Unit,
}

assert_eq!(10, FieldlessWithDiscrimants::First as u8);
assert_eq!(11, FieldlessWithDiscrimants::Tuple() as u8);
assert_eq!(20, FieldlessWithDiscrimants::Second as u8);
assert_eq!(21, FieldlessWithDiscrimants::Struct{} as u8);
assert_eq!(22, FieldlessWithDiscrimants::Unit as u8);
<span class="boring">}</span></code></pre></pre>
<h4 id="포인터-캐스팅"><a class="header" href="#포인터-캐스팅">포인터 캐스팅</a></h4>
<div class="rule" id="r-items.enum.discriminant.access-memory"><a class="rule-link" href="items/enumerations.html#r-items.enum.discriminant.access-memory" title="items.enum.discriminant.access-memory"><span>[items<wbr>.enum<wbr>.discriminant<wbr>.access-memory]<span/></a></div>
<p>열거형이 <a href="items/../type-layout.html#primitive-representations">원시 표현</a>을 지정하는 경우, <code>unsafe</code> 포인터 캐스팅을 통해 판별자에 안정적으로 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit,
    Tuple(bool),
    Struct{a: bool},
}

impl Enum {
    fn discriminant(&amp;self) -&gt; u8 {
        unsafe { *(self as *const Self as *const u8) }
    }
}

let unit_like = Enum::Unit;
let tuple_like = Enum::Tuple(true);
let struct_like = Enum::Struct{a: false};

assert_eq!(0, unit_like.discriminant());
assert_eq!(1, tuple_like.discriminant());
assert_eq!(2, struct_like.discriminant());
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.empty"><a class="rule-link" href="items/enumerations.html#r-items.enum.empty" title="items.enum.empty"><span>[items<wbr>.enum<wbr>.empty]<span/></a></div>
<h2 id="0-변형-열거형"><a class="header" href="#0-변형-열거형">0-변형 열거형</a></h2>
<div class="rule" id="r-items.enum.empty.intro"><a class="rule-link" href="items/enumerations.html#r-items.enum.empty.intro" title="items.enum.empty.intro"><span>[items<wbr>.enum<wbr>.empty<wbr>.intro]<span/></a></div>
<p>변형이 0개인 열거형을 _0-변형 열거형(zero-variant enums)_이라고 합니다. 유효한 값이 없으므로 인스턴스화할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ZeroVariants {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.empty.uninhabited"><a class="rule-link" href="items/enumerations.html#r-items.enum.empty.uninhabited" title="items.enum.empty.uninhabited"><span>[items<wbr>.enum<wbr>.empty<wbr>.uninhabited]<span/></a></div>
<p>0-변형 열거형은 <a href="items/../types/never.html">never 타입</a>과 동일하지만, 다른 타입으로 강제 변환(coerced)될 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum ZeroVariants {}
</span>let x: ZeroVariants = panic!();
let y: u32 = x; // 타입 불일치 오류
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.enum.variant-visibility"><a class="rule-link" href="items/enumerations.html#r-items.enum.variant-visibility" title="items.enum.variant-visibility"><span>[items<wbr>.enum<wbr>.variant-visibility]<span/></a></div>
<h2 id="변형-가시성"><a class="header" href="#변형-가시성">변형 가시성</a></h2>
<p>열거형 변형은 구문적으로 <a href="items/../visibility-and-privacy.html"><em>가시성</em></a> 주석을 허용하지만, 열거형이 검증될 때 거부됩니다. 이는 아이템이 사용되는 여러 컨텍스트에서 통일된 구문으로 파싱될 수 있도록 하기 위함입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! mac_variant {
    ($vis:vis $name:ident) =&gt; {
        enum $name {
            $vis Unit,

            $vis Tuple(u8, u16),

            $vis Struct { f: u8 },
        }
    }
}

// 빈 `vis`는 허용됩니다.
mac_variant! { E }

// 검증되기 전에 제거되므로 허용됩니다.
#[cfg(FALSE)]
enum E {
    pub U,
    pub(crate) T(u8),
    pub(super) T { f: String }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.union"><a class="rule-link" href="items/unions.html#r-items.union" title="items.union"><span>[items<wbr>.union]<span/></a></div>
<h1 id="공용체"><a class="header" href="#공용체">공용체</a></h1>
<div class="rule" id="r-items.union.syntax"><a class="rule-link" href="items/unions.html#r-items.union.syntax" title="items.union.syntax"><span>[items<wbr>.union<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>공용체</em> :<br />
   <code>union</code> <a href="items/../identifiers.html">식별자</a> <a href="items/generics.html"><em>제네릭매개변수</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup> <code>{</code><a href="items/structs.html"><em>구조체필드들</em></a><sup>?</sup> <code>}</code></p>
</blockquote>
<div class="rule" id="r-items.union.intro"><a class="rule-link" href="items/unions.html#r-items.union.intro" title="items.union.intro"><span>[items<wbr>.union<wbr>.intro]<span/></a></div>
<p>공용체 선언은 <code>struct</code> 대신 <code>union</code>을 사용한다는 점을 제외하면 구조체 선언과 동일한 구문을 사용합니다.</p>
<div class="rule" id="r-items.union.namespace"><a class="rule-link" href="items/unions.html#r-items.union.namespace" title="items.union.namespace"><span>[items<wbr>.union<wbr>.namespace]<span/></a></div>
<p>공용체 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 주어진 이름을 정의합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.common-storage"><a class="rule-link" href="items/unions.html#r-items.union.common-storage" title="items.union.common-storage"><span>[items<wbr>.union<wbr>.common-storage]<span/></a></div>
<p>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</p>
<div class="rule" id="r-items.union.field-restrictions"><a class="rule-link" href="items/unions.html#r-items.union.field-restrictions" title="items.union.field-restrictions"><span>[items<wbr>.union<wbr>.field-restrictions]<span/></a></div>
<p>공용체 필드 타입은 다음 타입의 하위 집합으로 제한됩니다:</p>
<div class="rule" id="r-items.union.field-copy"><a class="rule-link" href="items/unions.html#r-items.union.field-copy" title="items.union.field-copy"><span>[items<wbr>.union<wbr>.field-copy]<span/></a></div>
<ul>
<li><code>Copy</code> 타입</li>
</ul>
<div class="rule" id="r-items.union.field-references"><a class="rule-link" href="items/unions.html#r-items.union.field-references" title="items.union.field-references"><span>[items<wbr>.union<wbr>.field-references]<span/></a></div>
<ul>
<li>참조(임의의 <code>T</code>에 대한 <code>&amp;T</code> 및 <code>&amp;mut T</code>)</li>
</ul>
<div class="rule" id="r-items.union.field-manually-drop"><a class="rule-link" href="items/unions.html#r-items.union.field-manually-drop" title="items.union.field-manually-drop"><span>[items<wbr>.union<wbr>.field-manually-drop]<span/></a></div>
<ul>
<li><code>ManuallyDrop&lt;T&gt;</code> (임의의 <code>T</code>에 대해)</li>
</ul>
<div class="rule" id="r-items.union.field-tuple"><a class="rule-link" href="items/unions.html#r-items.union.field-tuple" title="items.union.field-tuple"><span>[items<wbr>.union<wbr>.field-tuple]<span/></a></div>
<ul>
<li>허용된 공용체 필드 타입만 포함하는 튜플 및 배열</li>
</ul>
<div class="rule" id="r-items.union.drop"><a class="rule-link" href="items/unions.html#r-items.union.drop" title="items.union.drop"><span>[items<wbr>.union<wbr>.drop]<span/></a></div>
<p>이 제약은 특히 공용체 필드가 절대 드롭(drop)될 필요가 없음을 보장합니다. 구조체나 열거형과 마찬가지로, 공용체에 대해 <code>impl Drop</code>을 구현하여 드롭될 때 일어날 일을 수동으로 정의할 수 있습니다.</p>
<div class="rule" id="r-items.union.fieldless"><a class="rule-link" href="items/unions.html#r-items.union.fieldless" title="items.union.fieldless"><span>[items<wbr>.union<wbr>.fieldless]<span/></a></div>
<p>필드가 없는 공용체는 컴파일러에서 허용되지 않지만, 매크로에서는 허용될 수 있습니다.</p>
<div class="rule" id="r-items.union.init"><a class="rule-link" href="items/unions.html#r-items.union.init" title="items.union.init"><span>[items<wbr>.union<wbr>.init]<span/></a></div>
<h2 id="공용체-초기화"><a class="header" href="#공용체-초기화">공용체 초기화</a></h2>
<div class="rule" id="r-items.union.init.intro"><a class="rule-link" href="items/unions.html#r-items.union.init.intro" title="items.union.init.intro"><span>[items<wbr>.union<wbr>.init<wbr>.intro]<span/></a></div>
<p>공용체 타입의 값은 구조체 타입에 사용되는 것과 동일한 구문을 사용하여 생성할 수 있지만, 정확히 하나의 필드만 지정해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>let u = MyUnion { f1: 1 };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.init.result"><a class="rule-link" href="items/unions.html#r-items.union.init.result" title="items.union.init.result"><span>[items<wbr>.union<wbr>.init<wbr>.result]<span/></a></div>
<p>위의 표현식은 <code>MyUnion</code> 타입의 값을 생성하고 <code>f1</code> 필드를 사용하여 저장 공간을 초기화합니다. 공용체는 구조체 필드와 동일한 구문을 사용하여 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span><span class="boring">let u = MyUnion { f1: 1 };
</span>let f = unsafe { u.f1 };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.fields"><a class="rule-link" href="items/unions.html#r-items.union.fields" title="items.union.fields"><span>[items<wbr>.union<wbr>.fields]<span/></a></div>
<h2 id="공용체-필드-읽기-및-쓰기"><a class="header" href="#공용체-필드-읽기-및-쓰기">공용체 필드 읽기 및 쓰기</a></h2>
<div class="rule" id="r-items.union.fields.intro"><a class="rule-link" href="items/unions.html#r-items.union.fields.intro" title="items.union.fields.intro"><span>[items<wbr>.union<wbr>.fields<wbr>.intro]<span/></a></div>
<p>공용체에는 “활성 필드(active field)“라는 개념이 없습니다. 대신, 모든 공용체 접근은 저장 공간을 접근에 사용된 필드의 타입으로 해석할 뿐입니다.</p>
<div class="rule" id="r-items.union.fields.read"><a class="rule-link" href="items/unions.html#r-items.union.fields.read" title="items.union.fields.read"><span>[items<wbr>.union<wbr>.fields<wbr>.read]<span/></a></div>
<p>공용체 필드를 읽는 것은 필드의 타입에서 공용체의 비트를 읽는 것입니다.</p>
<div class="rule" id="r-items.union.fields.offset"><a class="rule-link" href="items/unions.html#r-items.union.fields.offset" title="items.union.fields.offset"><span>[items<wbr>.union<wbr>.fields<wbr>.offset]<span/></a></div>
<p>필드는 0이 아닌 오프셋을 가질 수 있습니다(<a href="items/../type-layout.html#reprc-unions">C 표현</a>이 사용된 경우 제외). 이 경우 필드의 오프셋에서 시작하는 비트를 읽습니다</p>
<div class="rule" id="r-items.union.fields.validity"><a class="rule-link" href="items/unions.html#r-items.union.fields.validity" title="items.union.fields.validity"><span>[items<wbr>.union<wbr>.fields<wbr>.validity]<span/></a></div>
<p>데이터가 필드의 타입에서 유효한지 확인하는 것은 프로그래머의 책임입니다. 이를 지키지 않으면 <a href="items/../behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>이 발생합니다. 예를 들어, <a href="items/../types/boolean.html">불리언 타입</a>의 필드에서 값 <code>3</code>을 읽는 것은 정의되지 않은 동작입니다. 사실상, <a href="items/../type-layout.html#reprc-unions">C 표현</a>을 사용하는 공용체에 쓴 다음 읽는 것은 쓰기에 사용된 타입에서 읽기에 사용된 타입으로의 <a href="items/../../core/intrinsics/fn.transmute.html"><code>transmute</code></a>와 유사합니다.</p>
<div class="rule" id="r-items.union.fields.read-safety"><a class="rule-link" href="items/unions.html#r-items.union.fields.read-safety" title="items.union.fields.read-safety"><span>[items<wbr>.union<wbr>.fields<wbr>.read-safety]<span/></a></div>
<p>결과적으로, 공용체 필드의 모든 읽기는 <code>unsafe</code> 블록 내에 배치되어야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">let u = MyUnion { f1: 1 };
</span><span class="boring">
</span>unsafe {
    let f = u.f1;
}
<span class="boring">}</span></code></pre></pre>
<p>일반적으로 공용체를 사용하는 코드는 안전하지 않은 공용체 필드 접근에 대한 안전한 래퍼를 제공합니다.</p>
<div class="rule" id="r-items.union.fields.write-safety"><a class="rule-link" href="items/unions.html#r-items.union.fields.write-safety" title="items.union.fields.write-safety"><span>[items<wbr>.union<wbr>.fields<wbr>.write-safety]<span/></a></div>
<p>반면에 공용체 필드에 쓰는 것은 안전합니다. 임의의 데이터를 덮어쓸 뿐이며 정의되지 않은 동작을 유발할 수 없기 때문입니다. (공용체 필드 타입은 절대 드롭 글루(drop glue)를 가질 수 없으므로, 공용체 필드 쓰기는 절대 암시적으로 아무것도 드롭하지 않음에 유의하십시오.)</p>
<div class="rule" id="r-items.union.pattern"><a class="rule-link" href="items/unions.html#r-items.union.pattern" title="items.union.pattern"><span>[items<wbr>.union<wbr>.pattern]<span/></a></div>
<h2 id="공용체-패턴-매칭"><a class="header" href="#공용체-패턴-매칭">공용체 패턴 매칭</a></h2>
<div class="rule" id="r-items.union.pattern.intro"><a class="rule-link" href="items/unions.html#r-items.union.pattern.intro" title="items.union.pattern.intro"><span>[items<wbr>.union<wbr>.pattern<wbr>.intro]<span/></a></div>
<p>공용체 필드에 접근하는 또 다른 방법은 패턴 매칭을 사용하는 것입니다.</p>
<div class="rule" id="r-items.union.pattern.one-field"><a class="rule-link" href="items/unions.html#r-items.union.pattern.one-field" title="items.union.pattern.one-field"><span>[items<wbr>.union<wbr>.pattern<wbr>.one-field]<span/></a></div>
<p>공용체 필드에 대한 패턴 매칭은 구조체 패턴과 동일한 구문을 사용하지만, 패턴이 정확히 하나의 필드만 지정해야 한다는 점이 다릅니다.</p>
<div class="rule" id="r-items.union.pattern.safety"><a class="rule-link" href="items/unions.html#r-items.union.pattern.safety" title="items.union.pattern.safety"><span>[items<wbr>.union<wbr>.pattern<wbr>.safety]<span/></a></div>
<p>패턴 매칭은 특정 필드로 공용체를 읽는 것과 같으므로, 마찬가지로 <code>unsafe</code> 블록 내에 배치되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!("ten"); }
            MyUnion { f2 } =&gt; { println!("{}", f2); }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.pattern.subpattern"><a class="rule-link" href="items/unions.html#r-items.union.pattern.subpattern" title="items.union.pattern.subpattern"><span>[items<wbr>.union<wbr>.pattern<wbr>.subpattern]<span/></a></div>
<p>패턴 매칭은 더 큰 구조체의 필드로서 공용체와 매칭할 수 있습니다. 특히, FFI를 통해 C 태그가 지정된 공용체(C tagged union)를 구현하기 위해 Rust 공용체를 사용할 때, 이를 통해 태그와 해당 필드에 동시에 매칭할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
enum Tag { I, F }

#[repr(C)]
union U {
    i: i32,
    f: f32,
}

#[repr(C)]
struct Value {
    tag: Tag,
    u: U,
}

fn is_zero(v: Value) -&gt; bool {
    unsafe {
        match v {
            Value { tag: Tag::I, u: U { i: 0 } } =&gt; true,
            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 =&gt; true,
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.ref"><a class="rule-link" href="items/unions.html#r-items.union.ref" title="items.union.ref"><span>[items<wbr>.union<wbr>.ref]<span/></a></div>
<h2 id="공용체-필드에-대한-참조"><a class="header" href="#공용체-필드에-대한-참조">공용체 필드에 대한 참조</a></h2>
<div class="rule" id="r-items.union.ref.intro"><a class="rule-link" href="items/unions.html#r-items.union.ref.intro" title="items.union.ref.intro"><span>[items<wbr>.union<wbr>.ref<wbr>.intro]<span/></a></div>
<p>공용체 필드는 공통 저장 공간을 공유하므로, 공용체의 한 필드에 대한 쓰기 접근 권한을 얻으면 나머지 모든 필드에 대한 쓰기 접근 권한을 얻을 수 있습니다.</p>
<div class="rule" id="r-items.union.ref.borrow"><a class="rule-link" href="items/unions.html#r-items.union.ref.borrow" title="items.union.ref.borrow"><span>[items<wbr>.union<wbr>.ref<wbr>.borrow]<span/></a></div>
<p>대여 검사(borrow checking) 규칙은 이 사실을 고려하여 조정되어야 합니다. 결과적으로 공용체의 한 필드가 대여되면 나머지 모든 필드도 동일한 수명 동안 대여됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span>// 오류: `u`를 (`u.f2`를 통해) 한 번에 두 번 이상 가변으로 대여할 수 없습니다
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- 첫 번째 가변 대여가 여기서 발생합니다 (`u.f1`을 통해)
        let b2 = &amp;mut u.f2;
//                    ^^^^ 두 번째 가변 대여가 여기서 발생합니다 (`u.f2`를 통해)
        *b1 = 5;
    }
//  - 첫 번째 대여가 여기서 끝납니다
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.union.ref.usage"><a class="rule-link" href="items/unions.html#r-items.union.ref.usage" title="items.union.ref.usage"><span>[items<wbr>.union<wbr>.ref<wbr>.usage]<span/></a></div>
<p>보시다시피, 많은 측면(레이아웃, 안전성, 소유권 제외)에서 공용체는 구조체와 정확히 동일하게 동작하며, 이는 주로 구조체로부터 구문적 형태를 상속받았기 때문입니다. 이는 Rust 언어의 언급되지 않은 많은 측면(예: 비공개(privacy), 이름 해석, 타입 추론, 제네릭, 트레잇 구현, 고유 구현(inherent implementations), 일관성(coherence), 패턴 검사 등등)에서도 마찬가지입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.const"><a class="rule-link" href="items/constant-items.html#r-items.const" title="items.const"><span>[items<wbr>.const]<span/></a></div>
<h1 id="상수-아이템"><a class="header" href="#상수-아이템">상수 아이템</a></h1>
<div class="rule" id="r-items.const.syntax"><a class="rule-link" href="items/constant-items.html#r-items.const.syntax" title="items.const.syntax"><span>[items<wbr>.const<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>상수아이템</em> :<br />
   <code>const</code> ( <a href="items/../identifiers.html">식별자</a> | <code>_</code> ) <code>:</code> <a href="items/../types.html#type-expressions"><em>타입</em></a> ( <code>=</code> <a href="items/../expressions.html"><em>표현식</em></a> )<sup>?</sup> <code>;</code></p>
</blockquote>
<div class="rule" id="r-items.const.intro"><a class="rule-link" href="items/constant-items.html#r-items.const.intro" title="items.const.intro"><span>[items<wbr>.const<wbr>.intro]<span/></a></div>
<p>_상수 아이템_은 프로그램의 특정 메모리 위치와 연관되지 않은 선택적으로 명명된 _<a href="items/../const_eval.html#constant-expressions">상수 값</a>_입니다.</p>
<div class="rule" id="r-items.const.behavior"><a class="rule-link" href="items/constant-items.html#r-items.const.behavior" title="items.const.behavior"><span>[items<wbr>.const<wbr>.behavior]<span/></a></div>
<p>상수는 사용되는 모든 곳에 본질적으로 인라인(inlined)되므로, 사용될 때 관련 컨텍스트로 직접 복사됩니다. 여기에는 외부 크레이트의 상수 사용과, 비-<a href="items/../special-types-and-traits.html#copy"><code>Copy</code></a> 타입의 상수가 포함됩니다. 동일한 상수에 대한 참조가 동일한 메모리 주소를 참조한다고 보장할 수는 없습니다.</p>
<div class="rule" id="r-items.const.namespace"><a class="rule-link" href="items/constant-items.html#r-items.const.namespace" title="items.const.namespace"><span>[items<wbr>.const<wbr>.namespace]<span/></a></div>
<p>상수 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 상수 값을 정의합니다.</p>
<div class="rule" id="r-items.const.static"><a class="rule-link" href="items/constant-items.html#r-items.const.static" title="items.const.static"><span>[items<wbr>.const<wbr>.static]<span/></a></div>
<p>상수는 명시적으로 타입을 지정해야 합니다. 타입은 <code>'static</code> 라이프타임을 가져야 합니다. 초기화 식의 모든 참조는 <code>'static</code> 라이프타임을 가져야 합니다. 상수 타입 내의 참조는 기본적으로 <code>'static</code> 라이프타임입니다. <a href="items/../lifetime-elision.html#const-and-static-elision">정적 라이프타임 생략</a>을 참조하십시오.</p>
<div class="rule" id="r-items.const.static-temporary"><a class="rule-link" href="items/constant-items.html#r-items.const.static-temporary" title="items.const.static-temporary"><span>[items<wbr>.const<wbr>.static-temporary]<span/></a></div>
<p>상수 값이 <a href="items/../destructors.html#constant-promotion">승격(promotion)</a>될 수 있는 경우 상수에 대한 참조는 <code>'static</code> 라이프타임을 갖습니다. 그렇지 않으면 임시 값이 생성됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.const.final-value-immutable"><a class="rule-link" href="items/constant-items.html#r-items.const.final-value-immutable" title="items.const.final-value-immutable"><span>[items<wbr>.const<wbr>.final-value-immutable]<span/></a></div>
<p><code>const</code> 아이템의 최종 값은 가변적인 것에 대한 참조를 포함할 수 없습니다.</p>
<div class="rule" id="r-items.const.expr-omission"><a class="rule-link" href="items/constant-items.html#r-items.const.expr-omission" title="items.const.expr-omission"><span>[items<wbr>.const<wbr>.expr-omission]<span/></a></div>
<p>상수 표현식은 <a href="items/traits.html">트레잇 정의</a>에서만 생략될 수 있습니다.</p>
<div class="rule" id="r-items.const.destructor"><a class="rule-link" href="items/constant-items.html#r-items.const.destructor" title="items.const.destructor"><span>[items<wbr>.const<wbr>.destructor]<span/></a></div>
<h2 id="소멸자가-있는-상수"><a class="header" href="#소멸자가-있는-상수">소멸자가 있는 상수</a></h2>
<p>상수는 소멸자를 포함할 수 있습니다. 소멸자는 값이 스코프를 벗어날 때 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeWithDestructor(i32);

impl Drop for TypeWithDestructor {
    fn drop(&amp;mut self) {
        println!("Dropped. Held {}.", self.0);
    }
}

const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);

fn create_and_drop_zero_with_destructor() {
    let x = ZERO_WITH_DESTRUCTOR;
    // x는 함수가 끝날 때 드롭되어 drop을 호출합니다.
    // "Dropped. Held 0."을 출력합니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.const.unnamed"><a class="rule-link" href="items/constant-items.html#r-items.const.unnamed" title="items.const.unnamed"><span>[items<wbr>.const<wbr>.unnamed]<span/></a></div>
<h2 id="이름-없는-상수"><a class="header" href="#이름-없는-상수">이름 없는 상수</a></h2>
<div class="rule" id="r-items.const.unnamed.intro"><a class="rule-link" href="items/constant-items.html#r-items.const.unnamed.intro" title="items.const.unnamed.intro"><span>[items<wbr>.const<wbr>.unnamed<wbr>.intro]<span/></a></div>
<p><a href="items/../items/associated-items.html#associated-constants">연관 상수</a>와 달리, <a href="items/../glossary.html#free-item">자유(free)</a> 상수는 이름 대신 밑줄을 사용하여 이름 없이 선언할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _: () =  { struct _SameNameTwice; };

// 위와 같은 이름이지만 괜찮습니다:
const _: () =  { struct _SameNameTwice; };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.const.unnamed.repetition"><a class="rule-link" href="items/constant-items.html#r-items.const.unnamed.repetition" title="items.const.unnamed.repetition"><span>[items<wbr>.const<wbr>.unnamed<wbr>.repetition]<span/></a></div>
<p><a href="items/use-declarations.html#underscore-imports">밑줄 임포트</a>와 마찬가지로, 매크로는 동일한 스코프에서 동일한 이름 없는 상수를 안전하게 두 번 이상 내보낼 수 있습니다. 예를 들어, 다음 코드는 오류를 생성하지 않아야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(const _: () = (););
// 다음과 같이 확장됩니다:
// const _: () = ();
// const _: () = ();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.const.eval"><a class="rule-link" href="items/constant-items.html#r-items.const.eval" title="items.const.eval"><span>[items<wbr>.const<wbr>.eval]<span/></a></div>
<h2 id="평가"><a class="header" href="#평가">평가</a></h2>
<p><a href="items/../glossary.html#free-item">자유(Free)</a> 상수는 항상 컴파일 타임에 <a href="items/../const_eval.html">평가되어</a> 패닉을 드러냅니다. 이는 사용되지 않는 함수 내에서도 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 타임 패닉
const PANIC: () = std::unimplemented!();

fn unused_generic_function&lt;T&gt;() {
    // 실패하는 컴파일 타임 어설션
    const _: () = assert!(usize::BITS == 0);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.static"><a class="rule-link" href="items/static-items.html#r-items.static" title="items.static"><span>[items<wbr>.static]<span/></a></div>
<h1 id="정적-아이템"><a class="header" href="#정적-아이템">정적 아이템</a></h1>
<div class="rule" id="r-items.static.syntax"><a class="rule-link" href="items/static-items.html#r-items.static.syntax" title="items.static.syntax"><span>[items<wbr>.static<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>정적아이템</em> :<br />
   <a href="items/functions.html"><em>아이템안전성</em></a><sup>?</sup><sup class="footnote-reference"><a href="#extern-safety">1</a></sup> <code>static</code> <code>mut</code><sup>?</sup> <a href="items/../identifiers.html">식별자</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>타입</em></a> ( <code>=</code> <a href="items/../expressions.html"><em>표현식</em></a> )<sup>?</sup> <code>;</code></p>
<div class="footnote-definition" id="extern-safety"><sup class="footnote-definition-label">1</sup>
<p><code>safe</code> 및 <code>unsafe</code> 함수 한정자는 시맨틱적으로 <code>extern</code> 블록 내에서만 허용됩니다.</p>
</div>
</blockquote>
<div class="rule" id="r-items.static.intro"><a class="rule-link" href="items/static-items.html#r-items.static.intro" title="items.static.intro"><span>[items<wbr>.static<wbr>.intro]<span/></a></div>
<p>_정적 아이템_은 <a href="items/constant-items.html">상수</a>와 유사하지만, 프로그램 내에서 초기화 표현식으로 초기화되는 할당된 객체를 나타낸다는 점이 다릅니다. 정적 아이템에 대한 모든 참조와 원시 포인터는 동일한 할당된 객체를 참조합니다.</p>
<div class="rule" id="r-items.static.lifetime"><a class="rule-link" href="items/static-items.html#r-items.static.lifetime" title="items.static.lifetime"><span>[items<wbr>.static<wbr>.lifetime]<span/></a></div>
<p>정적 아이템은 <code>static</code> 라이프타임을 가지며, 이는 Rust 프로그램의 다른 모든 라이프타임보다 오래 지속됩니다. 정적 아이템은 프로그램이 끝날 때 <a href="items/../destructors.html"><code>drop</code></a>을 호출하지 않습니다.</p>
<div class="rule" id="r-items.static.storage-disjointness"><a class="rule-link" href="items/static-items.html#r-items.static.storage-disjointness" title="items.static.storage-disjointness"><span>[items<wbr>.static<wbr>.storage-disjointness]<span/></a></div>
<p><code>static</code>의 크기가 최소 1바이트 이상이면, 할당된 이 객체는 다른 모든 <code>static</code> 객체, 힙 할당, 스택 할당 변수와 서로 겹치지 않습니다. 그러나 불변 <code>static</code> 아이템의 저장 공간은 <a href="items/../destructors.html#constant-promotion">승격된 값(promoteds)</a>이나 <a href="items/constant-items.html"><code>const</code> 아이템</a>과 같이 고유 주소가 없는 객체와 겹칠 수 있습니다.</p>
<div class="rule" id="r-items.static.namespace"><a class="rule-link" href="items/static-items.html#r-items.static.namespace" title="items.static.namespace"><span>[items<wbr>.static<wbr>.namespace]<span/></a></div>
<p>정적 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 정적 값을 정의합니다.</p>
<div class="rule" id="r-items.static.init"><a class="rule-link" href="items/static-items.html#r-items.static.init" title="items.static.init"><span>[items<wbr>.static<wbr>.init]<span/></a></div>
<p>정적 초기화자는 컴파일 타임에 평가되는 <a href="items/../const_eval.html#constant-expressions">상수 표현식</a>입니다. 정적 초기화자는 다른 정적 아이템을 참조하고 읽을 수 있습니다. 가변 정적 아이템에서 읽을 때는 해당 정적 아이템의 초기 값을 읽습니다.</p>
<div class="rule" id="r-items.static.read-only"><a class="rule-link" href="items/static-items.html#r-items.static.read-only" title="items.static.read-only"><span>[items<wbr>.static<wbr>.read-only]<span/></a></div>
<p><a href="items/../interior-mutability.html">내부 가변성(interior mutable)</a>이 없는 타입을 포함하는 <code>mut</code>가 아닌 정적 아이템은 읽기 전용 메모리에 배치될 수 있습니다.</p>
<div class="rule" id="r-items.static.safety"><a class="rule-link" href="items/static-items.html#r-items.static.safety" title="items.static.safety"><span>[items<wbr>.static<wbr>.safety]<span/></a></div>
<p>정적 아이템에 대한 모든 접근은 안전하지만, 정적 아이템에는 몇 가지 제약 사항이 있습니다:</p>
<div class="rule" id="r-items.static.sync"><a class="rule-link" href="items/static-items.html#r-items.static.sync" title="items.static.sync"><span>[items<wbr>.static<wbr>.sync]<span/></a></div>
<ul>
<li>스레드 안전한 접근을 허용하려면 타입에 <a href="items/../../core/marker/trait.Sync.html"><code>Sync</code></a> 트레잇 바운드가 있어야 합니다.</li>
</ul>
<div class="rule" id="r-items.static.init.omission"><a class="rule-link" href="items/static-items.html#r-items.static.init.omission" title="items.static.init.omission"><span>[items<wbr>.static<wbr>.init<wbr>.omission]<span/></a></div>
<p>초기화 표현식은 <a href="items/external-blocks.html">외부 블록</a>에서는 생략되어야 하며, 자유(free) 정적 아이템의 경우에는 반드시 제공되어야 합니다.</p>
<div class="rule" id="r-items.static.safety-qualifiers"><a class="rule-link" href="items/static-items.html#r-items.static.safety-qualifiers" title="items.static.safety-qualifiers"><span>[items<wbr>.static<wbr>.safety-qualifiers]<span/></a></div>
<p><code>safe</code> 및 <code>unsafe</code> 한정자는 시맨틱적으로 <a href="items/external-blocks.html">외부 블록</a>에서 사용될 때만 허용됩니다.</p>
<div class="rule" id="r-items.static.generics"><a class="rule-link" href="items/static-items.html#r-items.static.generics" title="items.static.generics"><span>[items<wbr>.static<wbr>.generics]<span/></a></div>
<h2 id="정적-아이템과-제네릭"><a class="header" href="#정적-아이템과-제네릭">정적 아이템과 제네릭</a></h2>
<p>제네릭 스코프(예: blanket 또는 기본 구현)에 정의된 정적 아이템은 정적 정의가 현재 스코프 밖으로 나와 모듈로 이동한 것처럼 정확히 하나의 정적 아이템만 정의되는 결과를 낳습니다. 모노모르포화(monomorphization)마다 하나의 아이템이 생성되는 것은 <em>아닙니다</em>.</p>
<p>이 코드는:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::atomic::{AtomicUsize, Ordering};

trait Tr {
    fn default_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!("default_impl: 카운터는 {}였습니다", COUNTER.fetch_add(1, Ordering::Relaxed));
    }

    fn blanket_impl();
}

struct Ty1 {}
struct Ty2 {}

impl&lt;T&gt; Tr for T {
    fn blanket_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!("blanket_impl: 카운터는 {}였습니다", COUNTER.fetch_add(1, Ordering::Relaxed));
    }
}

fn main() {
    &lt;Ty1 as Tr&gt;::default_impl();
    &lt;Ty2 as Tr&gt;::default_impl();
    &lt;Ty1 as Tr&gt;::blanket_impl();
    &lt;Ty2 as Tr&gt;::blanket_impl();
}</code></pre></pre>
<p>다음과 같이 출력합니다:</p>
<pre><code class="language-text">default_impl: counter was 0
default_impl: counter was 1
blanket_impl: counter was 0
blanket_impl: counter was 1
</code></pre>
<div class="rule" id="r-items.static.mut"><a class="rule-link" href="items/static-items.html#r-items.static.mut" title="items.static.mut"><span>[items<wbr>.static<wbr>.mut]<span/></a></div>
<h2 id="가변-정적-아이템"><a class="header" href="#가변-정적-아이템">가변 정적 아이템</a></h2>
<div class="rule" id="r-items.static.mut.intro"><a class="rule-link" href="items/static-items.html#r-items.static.mut.intro" title="items.static.mut.intro"><span>[items<wbr>.static<wbr>.mut<wbr>.intro]<span/></a></div>
<p>정적 아이템이 <code>mut</code> 키워드로 선언되면, 프로그램에 의해 수정되는 것이 허용됩니다. Rust의 목표 중 하나는 동시성 버그가 발생하기 어렵게 만드는 것인데, 이것은 분명히 경쟁 상태(race conditions)나 다른 버그의 매우 큰 원인이 됩니다.</p>
<div class="rule" id="r-items.static.mut.safety"><a class="rule-link" href="items/static-items.html#r-items.static.mut.safety" title="items.static.mut.safety"><span>[items<wbr>.static<wbr>.mut<wbr>.safety]<span/></a></div>
<p>이러한 이유로, 가변 정적 변수를 읽거나 쓸 때는 <code>unsafe</code> 블록이 필요합니다. 가변 정적 변수에 대한 수정이 동일한 프로세스에서 실행되는 다른 스레드에 대해 안전한지 주의해야 합니다.</p>
<div class="rule" id="r-items.static.mut.extern"><a class="rule-link" href="items/static-items.html#r-items.static.mut.extern" title="items.static.mut.extern"><span>[items<wbr>.static<wbr>.mut<wbr>.extern]<span/></a></div>
<p>하지만 가변 정적 아이템은 여전히 매우 유용합니다. C 라이브러리와 함께 사용할 수 있으며 <code>extern</code> 블록 내에서 C 라이브러리로부터 바인딩될 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn atomic_add(_: *mut u32, _: u32) -&gt; u32 { 2 }
</span>
static mut LEVELS: u32 = 0;

// 이것은 공유 상태가 없다는 아이디어를 위반하며, 내부적으로 경쟁 상태로부터
// 보호하지 않으므로, 이 함수는 `unsafe`입니다
unsafe fn bump_levels_unsafe() -&gt; u32 {
    unsafe {
        let ret = LEVELS;
        LEVELS += 1;
        return ret;
    }
}

// `bump_levels_unsafe`의 대안으로, 이전 값을 반환하는 atomic_add 함수가
// 있다고 가정할 때 이 함수는 안전합니다. 이 함수는 다른 코드가 비원자적(non-atomic)
// 방식으로 정적 변수에 접근하지 않는 경우에만 안전합니다. 만약 그러한 접근이 가능하다면
// (`bump_levels_unsafe`에서처럼), 호출자에게 동시 접근을 여전히 막아야 함을
// 알리기 위해 `unsafe`여야 합니다.
fn bump_levels_safe() -&gt; u32 {
    unsafe {
        return atomic_add(&amp;raw mut LEVELS, 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.static.mut.sync"><a class="rule-link" href="items/static-items.html#r-items.static.mut.sync" title="items.static.mut.sync"><span>[items<wbr>.static<wbr>.mut<wbr>.sync]<span/></a></div>
<p>가변 정적 아이템은 타입이 <code>Sync</code> 트레잇을 구현하지 않아도 된다는 점을 제외하면 일반 정적 아이템과 동일한 제약 사항을 가집니다.</p>
<div class="rule" id="r-items.static.alternate"><a class="rule-link" href="items/static-items.html#r-items.static.alternate" title="items.static.alternate"><span>[items<wbr>.static<wbr>.alternate]<span/></a></div>
<h2 id="정적-아이템-또는-상수-사용하기"><a class="header" href="#정적-아이템-또는-상수-사용하기">정적 아이템 또는 상수 사용하기</a></h2>
<p>상수 아이템을 사용해야 할지 정적 아이템을 사용해야 할지 혼란스러울 수 있습니다. 다음 중 하나가 참이 아니라면 일반적으로 상수가 정적 아이템보다 선호되어야 합니다:</p>
<ul>
<li>대량의 데이터를 저장하고 있다.</li>
<li>정적 아이템의 단일 주소 속성이 필요하다.</li>
<li>내부 가변성(interior mutability)이 필요하다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.traits"><a class="rule-link" href="items/traits.html#r-items.traits" title="items.traits"><span>[items<wbr>.traits]<span/></a></div>
<h1 id="트레잇"><a class="header" href="#트레잇">트레잇</a></h1>
<div class="rule" id="r-items.traits.syntax"><a class="rule-link" href="items/traits.html#r-items.traits.syntax" title="items.traits.syntax"><span>[items<wbr>.traits<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>트레잇</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>trait</code> <a href="items/../identifiers.html">식별자</a>  <a href="items/generics.html"><em>제네릭매개변수</em></a><sup>?</sup> ( <code>:</code> <a href="items/../trait-bounds.html"><em>타입매개변수바운드</em></a><sup>?</sup> )<sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup> <code>{</code><br />
     <a href="items/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
     <a href="items/associated-items.html"><em>연관아이템</em></a><sup>*</sup><br />
   <code>}</code></p>
</blockquote>
<div class="rule" id="r-items.traits.intro"><a class="rule-link" href="items/traits.html#r-items.traits.intro" title="items.traits.intro"><span>[items<wbr>.traits<wbr>.intro]<span/></a></div>
<p>_트레잇_은 타입이 구현할 수 있는 추상 인터페이스를 설명합니다. 이 인터페이스는 세 가지 종류의 <a href="items/associated-items.html">연관 아이템</a>으로 구성됩니다:</p>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">함수</a></li>
<li><a href="items/associated-items.html#associated-types">타입</a></li>
<li><a href="items/associated-items.html#associated-constants">상수</a></li>
</ul>
<div class="rule" id="r-items.traits.namespace"><a class="rule-link" href="items/traits.html#r-items.traits.namespace" title="items.traits.namespace"><span>[items<wbr>.traits<wbr>.namespace]<span/></a></div>
<p>트레잇 선언은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">타입 네임스페이스</a>에 트레잇을 정의합니다.</p>
<div class="rule" id="r-items.traits.associated-item-namespaces"><a class="rule-link" href="items/traits.html#r-items.traits.associated-item-namespaces" title="items.traits.associated-item-namespaces"><span>[items<wbr>.traits<wbr>.associated-item-namespaces]<span/></a></div>
<p>연관 아이템은 트레잇의 멤버로서 각각의 네임스페이스 내에 정의됩니다. 연관 타입은 타입 네임스페이스에 정의됩니다. 연관 상수와 연관 함수는 값 네임스페이스에 정의됩니다.</p>
<div class="rule" id="r-items.traits.self-param"><a class="rule-link" href="items/traits.html#r-items.traits.self-param" title="items.traits.self-param"><span>[items<wbr>.traits<wbr>.self-param]<span/></a></div>
<p>모든 트레잇은 “이 인터페이스를 구현하는 타입“을 참조하는 암시적 타입 매개변수 <code>Self</code>를 정의합니다. 트레잇은 추가적인 타입 매개변수도 포함할 수 있습니다. <code>Self</code>를 포함한 이러한 타입 매개변수는 <a href="items/generics.html">일반적인 방식대로</a> 다른 트레잇 등에 의해 제약될 수 있습니다.</p>
<div class="rule" id="r-items.traits.impls"><a class="rule-link" href="items/traits.html#r-items.traits.impls" title="items.traits.impls"><span>[items<wbr>.traits<wbr>.impls]<span/></a></div>
<p>트레잇은 별도의 <a href="items/implementations.html">구현</a>을 통해 특정 타입에 대해 구현됩니다.</p>
<div class="rule" id="r-items.traits.associated-item-decls"><a class="rule-link" href="items/traits.html#r-items.traits.associated-item-decls" title="items.traits.associated-item-decls"><span>[items<wbr>.traits<wbr>.associated-item-decls]<span/></a></div>
<p>트레잇 함수는 함수 본문을 세미콜론으로 대체하여 생략할 수 있습니다. 이는 구현에서 함수를 정의해야 함을 나타냅니다. 트레잇 함수가 본문을 정의하면, 이 정의는 이를 오버라이드하지 않는 구현에 대한 기본값으로 작동합니다. 마찬가지로, 연관 상수는 등호와 표현식을 생략하여 구현에서 상수 값을 정의해야 함을 나타낼 수 있습니다. 연관 타입은 타입을 절대 정의해서는 안 되며, 타입은 오직 구현에서만 지정될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 정의가 있거나 없는 연관 트레잇 아이템의 예시.
trait Example {
    const CONST_NO_DEFAULT: i32;
    const CONST_WITH_DEFAULT: i32 = 99;
    type TypeNoDefault;
    fn method_without_default(&amp;self);
    fn method_with_default(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.traits.const-fn"><a class="rule-link" href="items/traits.html#r-items.traits.const-fn" title="items.traits.const-fn"><span>[items<wbr>.traits<wbr>.const-fn]<span/></a></div>
<p>트레잇 함수는 <a href="items/functions.html#const-functions"><code>const</code></a>가 될 수 없습니다.</p>
<div class="rule" id="r-items.traits.bounds"><a class="rule-link" href="items/traits.html#r-items.traits.bounds" title="items.traits.bounds"><span>[items<wbr>.traits<wbr>.bounds]<span/></a></div>
<h2 id="트레잇-바운드"><a class="header" href="#트레잇-바운드">트레잇 바운드</a></h2>
<p>제네릭 아이템은 타입 매개변수에 대한 <a href="items/../trait-bounds.html">바운드</a>로 트레잇을 사용할 수 있습니다.</p>
<div class="rule" id="r-items.traits.generic"><a class="rule-link" href="items/traits.html#r-items.traits.generic" title="items.traits.generic"><span>[items<wbr>.traits<wbr>.generic]<span/></a></div>
<h2 id="제네릭-트레잇"><a class="header" href="#제네릭-트레잇">제네릭 트레잇</a></h2>
<p>타입 매개변수를 지정하여 트레잇을 제네릭으로 만들 수 있습니다. 이는 <a href="items/functions.html#generic-functions">제네릭 함수</a>에서 사용되는 것과 동일한 구문을 사용하여 트레잇 이름 뒤에 나타납니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, f: F) where F: Fn(T);
}
<span class="boring">}</span></code></pre></pre>
<p><a id="object-safety"></a></p>
<div class="rule" id="r-items.traits.dyn-compatible"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible" title="items.traits.dyn-compatible"><span>[items<wbr>.traits<wbr>.dyn-compatible]<span/></a></div>
<h2 id="dyn-호환성"><a class="header" href="#dyn-호환성">Dyn 호환성</a></h2>
<div class="rule" id="r-items.traits.dyn-compatible.intro"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.intro" title="items.traits.dyn-compatible.intro"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.intro]<span/></a></div>
<p>dyn 호환(dyn-compatible) 트레잇은 <a href="items/../types/trait-object.html">트레잇 객체</a>의 기본 트레잇이 될 수 있습니다. 트레잇은 다음 조건을 충족하면 _dyn 호환_입니다:</p>
<div class="rule" id="r-items.traits.dyn-compatible.supertraits"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.supertraits" title="items.traits.dyn-compatible.supertraits"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.supertraits]<span/></a></div>
<ul>
<li>모든 <a href="items/traits.html#supertraits">슈퍼트레잇</a>도 dyn 호환이어야 합니다.</li>
</ul>
<div class="rule" id="r-items.traits.dyn-compatible.sized"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.sized" title="items.traits.dyn-compatible.sized"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.sized]<span/></a></div>
<ul>
<li><code>Sized</code>는 <a href="items/traits.html#supertraits">슈퍼트레잇</a>이 아니어야 합니다. 다시 말해, <code>Self: Sized</code>를 요구하지 않아야 합니다.</li>
</ul>
<div class="rule" id="r-items.traits.dyn-compatible.associated-consts"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.associated-consts" title="items.traits.dyn-compatible.associated-consts"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.associated-consts]<span/></a></div>
<ul>
<li>연관 상수를 갖지 않아야 합니다.</li>
</ul>
<div class="rule" id="r-items.traits.dyn-compatible.associated-types"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.associated-types" title="items.traits.dyn-compatible.associated-types"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.associated-types]<span/></a></div>
<ul>
<li>제네릭을 포함한 연관 타입을 갖지 않아야 합니다.</li>
</ul>
<div class="rule" id="r-items.traits.dyn-compatible.associated-functions"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.associated-functions" title="items.traits.dyn-compatible.associated-functions"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.associated-functions]<span/></a></div>
<ul>
<li>모든 연관 함수는 트레잇 객체에서 디스패치 가능하거나(dispatchable) 명시적으로 디스패치 불가능해야 합니다:
<ul>
<li>디스패치 가능한 함수는 다음 조건을 만족해야 합니다:
<ul>
<li>타입 매개변수를 갖지 않아야 합니다(라이프타임 매개변수는 허용됨).</li>
<li>수신자(receiver)의 타입 이외에는 <code>Self</code>를 사용하지 않는 <a href="items/associated-items.html#methods">메서드</a>여야 합니다.</li>
<li>다음 중 하나의 타입을 가진 수신자를 가져야 합니다:
<ul>
<li><code>&amp;Self</code> (즉, <code>&amp;self</code>)</li>
<li><code>&amp;mut Self</code> (즉, <code>&amp;mut self</code>)</li>
<li><a href="items/../special-types-and-traits.html#boxt"><code>Box&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#rct"><code>Rc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#arct"><code>Arc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#pinp"><code>Pin&lt;P&gt;</code></a> (여기서 <code>P</code>는 위의 타입 중 하나)</li>
</ul>
</li>
<li>불투명한(opaque) 반환 타입을 갖지 않아야 합니다. 즉,
<ul>
<li><code>async fn</code>이 아니어야 합니다(숨겨진 <code>Future</code> 타입을 가짐).</li>
<li>반환 위치 <code>impl Trait</code> 타입을 갖지 않아야 합니다(<code>fn example(&amp;self) -&gt; impl Trait</code>).</li>
</ul>
</li>
<li><code>where Self: Sized</code> 바운드를 갖지 않아야 합니다(<code>Self</code> 수신자 타입(즉, <code>self</code>)은 이를 암시합니다).</li>
</ul>
</li>
<li>명시적으로 디스패치 불가능한 함수는 다음을 요구합니다:
<ul>
<li><code>where Self: Sized</code> 바운드를 가져야 합니다(<code>Self</code> 수신자 타입(즉, <code>self</code>)은 이를 암시합니다).</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-items.traits.dyn-compatible.async-traits"><a class="rule-link" href="items/traits.html#r-items.traits.dyn-compatible.async-traits" title="items.traits.dyn-compatible.async-traits"><span>[items<wbr>.traits<wbr>.dyn-compatible<wbr>.async-traits]<span/></a></div>
<ul>
<li><a href="items/../../core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a>, <a href="items/../../core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a>, 및 <a href="items/../../core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a> 트레잇은 dyn 호환이 아닙니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 이 개념은 이전에 _객체 안전성(object safety)_으로 알려져 있었습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// dyn 호환 메서드의 예시.
trait TraitMethods {
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested_pin(self: Pin&lt;Arc&lt;Self&gt;&gt;) {}
}
<span class="boring">struct S;
</span><span class="boring">impl TraitMethods for S {}
</span><span class="boring">let t: Box&lt;dyn TraitMethods&gt; = Box::new(S);
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 트레잇은 dyn 호환이지만, 이 메서드들은 트레잇 객체에서 디스패치될 수 없습니다.
trait NonDispatchable {
    // 비-메서드(Non-methods)는 디스패치될 수 없습니다.
    fn foo() where Self: Sized {}
    // Self 타입은 런타임까지 알 수 없습니다.
    fn returns(&amp;self) -&gt; Self where Self: Sized;
    // `other`는 수신자와 다른 구체적인 타입일 수 있습니다.
    fn param(&amp;self, other: Self) where Self: Sized {}
    // 제네릭은 vtable과 호환되지 않습니다.
    fn typed&lt;T&gt;(&amp;self, x: T) where Self: Sized {}
}

struct S;
impl NonDispatchable for S {
    fn returns(&amp;self) -&gt; Self where Self: Sized { S }
}
let obj: Box&lt;dyn NonDispatchable&gt; = Box::new(S);
obj.returns(); // 오류: Self 반환으로 호출할 수 없음
obj.param(S);  // 오류: Self 매개변수로 호출할 수 없음
obj.typed(1);  // 오류: 제네릭 타입으로 호출할 수 없음
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span>// dyn 호환이 아닌 트레잇의 예시.
trait DynIncompatible {
    const CONST: i32 = 1;  // 오류: 연관 상수를 가질 수 없음

    fn foo() {}  // 오류: Sized 없는 연관 함수
    fn returns(&amp;self) -&gt; Self; // 오류: 반환 타입에 `Self`가 있음
    fn typed&lt;T&gt;(&amp;self, x: T) {} // 오류: 제네릭 타입 매개변수가 있음
    fn nested(self: Rc&lt;Box&lt;Self&gt;&gt;) {} // 오류: 중첩된 수신자는 아직 지원되지 않음
}

struct S;
impl DynIncompatible for S {
    fn returns(&amp;self) -&gt; Self { S }
}
let obj: Box&lt;dyn DynIncompatible&gt; = Box::new(S); // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Self: Sized` 트레잇은 dyn 호환이 아닙니다.
trait TraitWithSize where Self: Sized {}

struct S;
impl TraitWithSize for S {}
let obj: Box&lt;dyn TraitWithSize&gt; = Box::new(S); // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Self`가 타입 인수인 경우 dyn 호환이 아닙니다.
trait Super&lt;A&gt; {}
trait WithSelf: Super&lt;Self&gt; where Self: Sized {}

struct S;
impl&lt;A&gt; Super&lt;A&gt; for S {}
impl WithSelf for S {}
let obj: Box&lt;dyn WithSelf&gt; = Box::new(S); // 오류: `Self` 타입 매개변수를 사용할 수 없음
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.traits.supertraits"><a class="rule-link" href="items/traits.html#r-items.traits.supertraits" title="items.traits.supertraits"><span>[items<wbr>.traits<wbr>.supertraits]<span/></a></div>
<h2 id="슈퍼트레잇"><a class="header" href="#슈퍼트레잇">슈퍼트레잇</a></h2>
<div class="rule" id="r-items.traits.supertraits.intro"><a class="rule-link" href="items/traits.html#r-items.traits.supertraits.intro" title="items.traits.supertraits.intro"><span>[items<wbr>.traits<wbr>.supertraits<wbr>.intro]<span/></a></div>
<p>**슈퍼트레잇(Supertraits)**은 특정 트레잇을 구현하기 위해 타입이 반드시 구현해야 하는 트레잇입니다. 또한, <a href="items/generics.html">제네릭</a>이나 <a href="items/../types/trait-object.html">트레잇 객체</a>가 트레잇으로 바운딩된 곳이면 어디서나 그 슈퍼트레잇의 연관 아이템에 접근할 수 있습니다.</p>
<div class="rule" id="r-items.traits.supertraits.decl"><a class="rule-link" href="items/traits.html#r-items.traits.supertraits.decl" title="items.traits.supertraits.decl"><span>[items<wbr>.traits<wbr>.supertraits<wbr>.decl]<span/></a></div>
<p>슈퍼트레잇은 트레잇의 <code>Self</code> 타입에 대한 트레잇 바운드와, 해당 트레잇 바운드에 선언된 트레잇의 슈퍼트레잇을 통해 추이적으로 선언됩니다. 트레잇이 자기 자신의 슈퍼트레잇이 되는 것은 오류입니다.</p>
<div class="rule" id="r-items.traits.supertraits.subtrait"><a class="rule-link" href="items/traits.html#r-items.traits.supertraits.subtrait" title="items.traits.supertraits.subtrait"><span>[items<wbr>.traits<wbr>.supertraits<wbr>.subtrait]<span/></a></div>
<p>슈퍼트레잇을 가진 트레잇을 그 슈퍼트레잇의 **서브트레잇(subtrait)**이라고 합니다.</p>
<p>다음은 <code>Shape</code>를 <code>Circle</code>의 슈퍼트레잇으로 선언하는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>그리고 다음은 <a href="items/generics.html#where-clauses">Where 절</a>을 사용한 것을 제외하고는 동일한 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle where Self: Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>다음 예제는 <code>Shape</code>의 <code>area</code> 함수를 사용하여 <code>radius</code>에 기본 구현을 제공합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span>trait Circle where Self: Shape {
    fn radius(&amp;self) -&gt; f64 {
        // A = pi * r^2
        // 따라서 대수적으로,
        // r = sqrt(A / pi)
        (self.area() /std::f64::consts::PI).sqrt()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>다음 예제는 제네릭 매개변수에서 슈퍼트레잇 메서드를 호출합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span>fn print_area_and_radius&lt;C: Circle&gt;(c: C) {
    // 여기서 우리는 `Circle`의 슈퍼트레잇 `Shape`의 area 메서드를 호출합니다.
    println!("면적: {}", c.area());
    println!("반지름: {}", c.radius());
}
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 다음은 트레잇 객체에서 슈퍼트레잇 메서드를 호출하는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span><span class="boring">struct UnitCircle;
</span><span class="boring">impl Shape for UnitCircle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI } }
</span><span class="boring">impl Circle for UnitCircle { fn radius(&amp;self) -&gt; f64 { 1.0 } }
</span><span class="boring">let circle = UnitCircle;
</span>let circle = Box::new(circle) as Box&lt;dyn Circle&gt;;
let nonsense = circle.radius() * circle.area();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.traits.safety"><a class="rule-link" href="items/traits.html#r-items.traits.safety" title="items.traits.safety"><span>[items<wbr>.traits<wbr>.safety]<span/></a></div>
<h2 id="unsafe-트레잇"><a class="header" href="#unsafe-트레잇">Unsafe 트레잇</a></h2>
<div class="rule" id="r-items.traits.safety.intro"><a class="rule-link" href="items/traits.html#r-items.traits.safety.intro" title="items.traits.safety.intro"><span>[items<wbr>.traits<wbr>.safety<wbr>.intro]<span/></a></div>
<p><code>unsafe</code> 키워드로 시작하는 트레잇 아이템은 해당 트레잇을 _구현_하는 것이 <a href="items/../unsafety.html">안전하지 않을 수 있음</a>을 나타냅니다. 올바르게 구현된 unsafe 트레잇을 사용하는 것은 안전합니다. <a href="items/implementations.html#trait-implementations">트레잇 구현</a> 역시 <code>unsafe</code> 키워드로 시작해야 합니다.</p>
<p><a href="items/../special-types-and-traits.html#sync"><code>Sync</code></a>와 <a href="items/../special-types-and-traits.html#send"><code>Send</code></a>는 unsafe 트레잇의 예입니다.</p>
<div class="rule" id="r-items.traits.params"><a class="rule-link" href="items/traits.html#r-items.traits.params" title="items.traits.params"><span>[items<wbr>.traits<wbr>.params]<span/></a></div>
<h2 id="매개변수-패턴"><a class="header" href="#매개변수-패턴">매개변수 패턴</a></h2>
<div class="rule" id="r-items.traits.params.allowed-patterns"><a class="rule-link" href="items/traits.html#r-items.traits.params.allowed-patterns" title="items.traits.params.allowed-patterns"><span>[items<wbr>.traits<wbr>.params<wbr>.allowed-patterns]<span/></a></div>
<p>본문이 없는 함수 또는 메서드 선언은 <a href="items/../identifiers.html">식별자</a> 또는 <code>_</code> <a href="items/../patterns.html#wildcard-pattern">와일드카드</a> 패턴만 허용합니다. <code>mut</code> <a href="items/../identifiers.html">식별자</a>는 현재 허용되지만, 더 이상 사용되지 않으며(deprecated) 미래에는 오류가 될 것입니다.</p>
<!-- https://github.com/rust-lang/rust/issues/35203 -->
<div class="rule" id="r-items.traits.params.edition2015"><a class="rule-link" href="items/traits.html#r-items.traits.params.edition2015" title="items.traits.params.edition2015"><span>[items<wbr>.traits<wbr>.params<wbr>.edition2015]<span/></a></div>
<p>2015 에디션에서 트레잇 함수 또는 메서드 매개변수의 패턴은 선택 사항입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2015"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2015 에디션
trait T {
    fn f(i32);  // 매개변수 식별자는 필요하지 않습니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.traits.params.restriction"><a class="rule-link" href="items/traits.html#r-items.traits.params.restriction" title="items.traits.params.restriction"><span>[items<wbr>.traits<wbr>.params<wbr>.restriction]<span/></a></div>
<p>매개변수에 대한 패턴의 종류는 다음 중 하나로 제한됩니다:</p>
<ul>
<li><a href="items/../identifiers.html">식별자</a></li>
<li><code>mut</code> <a href="items/../identifiers.html">식별자</a></li>
<li><a href="items/../patterns.html#wildcard-pattern"><code>_</code></a></li>
<li><code>&amp;</code> <a href="items/../identifiers.html">식별자</a></li>
<li><code>&amp;&amp;</code> <a href="items/../identifiers.html">식별자</a></li>
</ul>
<div class="rule" id="r-items.traits.params.restriction.edition2018"><a class="rule-link" href="items/traits.html#r-items.traits.params.restriction.edition2018" title="items.traits.params.restriction.edition2018"><span>[items<wbr>.traits<wbr>.params<wbr>.restriction<wbr>.edition2018]<span/></a></div>
<p>2018 에디션부터는 함수 또는 메서드 매개변수 패턴이 더 이상 선택 사항이 아닙니다. 또한, 본문이 있는 한 모든 반박 불가능한(irrefutable) 패턴이 허용됩니다. 본문이 없는 경우 위에 나열된 제한 사항이 여전히 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1((a, b): (i32, i32)) {}
    fn f2(_: (i32, i32));  // 본문 없이는 튜플 패턴을 사용할 수 없습니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.traits.associated-visibility"><a class="rule-link" href="items/traits.html#r-items.traits.associated-visibility" title="items.traits.associated-visibility"><span>[items<wbr>.traits<wbr>.associated-visibility]<span/></a></div>
<h2 id="아이템-가시성"><a class="header" href="#아이템-가시성">아이템 가시성</a></h2>
<div class="rule" id="r-items.traits.associated-visibility.intro"><a class="rule-link" href="items/traits.html#r-items.traits.associated-visibility.intro" title="items.traits.associated-visibility.intro"><span>[items<wbr>.traits<wbr>.associated-visibility<wbr>.intro]<span/></a></div>
<p>트레잇 아이템은 구문적으로 <a href="items/../visibility-and-privacy.html"><em>가시성</em></a> 주석을 허용하지만, 트레잇이 검증될 때 거부됩니다. 이는 아이템이 사용되는 여러 컨텍스트에서 통일된 구문으로 파싱될 수 있도록 하기 위함입니다. 예를 들어, 빈 <code>vis</code> 매크로 조각(fragment) 지정자는 트레잇 아이템에 사용될 수 있으며, 여기서 매크로 규칙은 가시성이 허용되는 다른 상황에서도 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">macro_rules! create_method {
    ($vis:vis $name:ident) =&gt; {
        $vis fn $name(&amp;self) {}
    };
}

trait T1 {
    // 빈 `vis`는 허용됩니다.
    create_method! { method_of_t1 }
}

struct S;

impl S {
    // 여기서 가시성은 허용됩니다.
    create_method! { pub method_of_s }
}

impl T1 for S {}

fn main() {
    let s = S;
    s.method_of_t1();
    s.method_of_s();
}</code></pre></pre>
<script>
(function() {
    var fragments = {
        "#object-safety": "traits.html#dyn-compatibility",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.impl"><a class="rule-link" href="items/implementations.html#r-items.impl" title="items.impl"><span>[items<wbr>.impl]<span/></a></div>
<h1 id="구현"><a class="header" href="#구현">구현</a></h1>
<div class="rule" id="r-items.impl.syntax"><a class="rule-link" href="items/implementations.html#r-items.impl.syntax" title="items.impl.syntax"><span>[items<wbr>.impl<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>구현</em> :<br />
   <em>고유구현</em> | <em>트레잇구현</em></p>
<p><em>고유구현</em> :<br />
   <code>impl</code> <a href="items/generics.html"><em>제네릭매개변수</em></a><sup>?</sup> <a href="items/../types.html#type-expressions"><em>타입</em></a> <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
      <a href="items/associated-items.html"><em>연관아이템</em></a><sup>*</sup><br />
   <code>}</code></p>
<p><em>트레잇구현</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>impl</code> <a href="items/generics.html"><em>제네릭매개변수</em></a><sup>?</sup> <code>!</code><sup>?</sup> <a href="items/../paths.html#paths-in-types"><em>타입경로</em></a> <code>for</code> <a href="items/../types.html#type-expressions"><em>타입</em></a><br />
   <a href="items/generics.html#where-clauses"><em>Where절</em></a><sup>?</sup><br />
   <code>{</code><br />
      <a href="items/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
      <a href="items/associated-items.html"><em>연관아이템</em></a><sup>*</sup><br />
   <code>}</code></p>
</blockquote>
<div class="rule" id="r-items.impl.intro"><a class="rule-link" href="items/implementations.html#r-items.impl.intro" title="items.impl.intro"><span>[items<wbr>.impl<wbr>.intro]<span/></a></div>
<p>_구현(implementation)_은 아이템을 _구현 타입(implementing type)_과 연관시키는 아이템입니다. 구현은 <code>impl</code> 키워드로 정의되며, 구현되는 타입의 인스턴스에 속하거나 타입에 정적으로 속하는 함수들을 포함합니다.</p>
<div class="rule" id="r-items.impl.kinds"><a class="rule-link" href="items/implementations.html#r-items.impl.kinds" title="items.impl.kinds"><span>[items<wbr>.impl<wbr>.kinds]<span/></a></div>
<p>구현에는 두 가지 유형이 있습니다.</p>
<ul>
<li>고유 구현(inherent implementations)</li>
<li><a href="items/traits.html">트레잇(trait)</a> 구현</li>
</ul>
<div class="rule" id="r-items.impl.inherent"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent" title="items.impl.inherent"><span>[items<wbr>.impl<wbr>.inherent]<span/></a></div>
<h2 id="고유-구현"><a class="header" href="#고유-구현">고유 구현</a></h2>
<div class="rule" id="r-items.impl.inherent.intro"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.intro" title="items.impl.inherent.intro"><span>[items<wbr>.impl<wbr>.inherent<wbr>.intro]<span/></a></div>
<p>고유 구현은 <code>impl</code> 키워드, 제네릭 타입 선언, 명목상 타입(nominal type)으로의 경로, Where 절, 그리고 중괄호로 묶인 연관 가능한 아이템 집합의 시퀀스로 정의됩니다.</p>
<div class="rule" id="r-items.impl.inherent.implementing-type"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.implementing-type" title="items.impl.inherent.implementing-type"><span>[items<wbr>.impl<wbr>.inherent<wbr>.implementing-type]<span/></a></div>
<p>이 명목상 타입을 _구현 타입_이라고 하며, 연관 가능한 아이템들은 구현 타입에 대한 _연관 아이템(associated items)_입니다.</p>
<div class="rule" id="r-items.impl.inherent.associated-items"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.associated-items" title="items.impl.inherent.associated-items"><span>[items<wbr>.impl<wbr>.inherent<wbr>.associated-items]<span/></a></div>
<p>고유 구현은 포함된 아이템들을 구현 타입과 연관시킵니다.</p>
<div class="rule" id="r-items.impl.inherent.associated-items.allowed-items"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.associated-items.allowed-items" title="items.impl.inherent.associated-items.allowed-items"><span>[items<wbr>.impl<wbr>.inherent<wbr>.associated-items<wbr>.allowed-items]<span/></a></div>
<p>고유 구현은 <a href="items/associated-items.html#associated-functions-and-methods">연관 함수</a>(<a href="items/associated-items.html#methods">메서드</a> 포함)와 <a href="items/associated-items.html#associated-constants">연관 상수</a>를 포함할 수 있습니다.</p>
<div class="rule" id="r-items.impl.inherent.type-alias"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.type-alias" title="items.impl.inherent.type-alias"><span>[items<wbr>.impl<wbr>.inherent<wbr>.type-alias]<span/></a></div>
<p>연관 타입 별칭은 포함할 수 없습니다.</p>
<div class="rule" id="r-items.impl.inherent.associated-item-path"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.associated-item-path" title="items.impl.inherent.associated-item-path"><span>[items<wbr>.impl<wbr>.inherent<wbr>.associated-item-path]<span/></a></div>
<p>연관 아이템으로의 <a href="items/../paths.html">경로</a>는 구현 타입으로의 임의의 경로 뒤에, 마지막 경로 구성 요소로서 연관 아이템의 식별자가 오는 형태입니다.</p>
<div class="rule" id="r-items.impl.inherent.coherence"><a class="rule-link" href="items/implementations.html#r-items.impl.inherent.coherence" title="items.impl.inherent.coherence"><span>[items<wbr>.impl<wbr>.inherent<wbr>.coherence]<span/></a></div>
<p>하나의 타입은 여러 개의 고유 구현을 가질 수도 있습니다. 구현 타입은 반드시 원본 타입 정의와 동일한 크레이트 내에서 정의되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub mod color {
    pub struct Color(pub u8, pub u8, pub u8);

    impl Color {
        pub const WHITE: Color = Color(255, 255, 255);
    }
}

mod values {
    use super::color::Color;
    impl Color {
        pub fn red() -&gt; Color {
            Color(255, 0, 0)
        }
    }
}

pub use self::color::Color;
fn main() {
    // 같은 모듈 내의 구현 타입과 구현에 대한 실제 경로.
    color::Color::WHITE;

    // 서로 다른 모듈에 있는 구현 블록들도 여전히 타입을 통한 경로로 접근됩니다.
    color::Color::red();

    // 구현 타입에 대해 다시 내보내기(re-exported)된 경로들도 작동합니다.
    Color::red();

    // 작동하지 않습니다. `values` 내의 사용(use)이 pub이 아니기 때문입니다.
    // values::Color::red();
}</code></pre></pre>
<div class="rule" id="r-items.impl.trait"><a class="rule-link" href="items/implementations.html#r-items.impl.trait" title="items.impl.trait"><span>[items<wbr>.impl<wbr>.trait]<span/></a></div>
<h2 id="트레잇-구현"><a class="header" href="#트레잇-구현">트레잇 구현</a></h2>
<div class="rule" id="r-items.impl.trait.intro"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.intro" title="items.impl.trait.intro"><span>[items<wbr>.impl<wbr>.trait<wbr>.intro]<span/></a></div>
<p>_트레잇 구현_은 고유 구현과 비슷하게 정의되지만, 선택적인 제네릭 타입 선언 뒤에 <a href="items/traits.html">트레잇</a>이 오고, 그 뒤에 <code>for</code> 키워드와 명목상 타입으로의 경로가 온다는 점이 다릅니다.</p>
<!-- To understand this, you have to back-reference to the previous section. :( -->
<div class="rule" id="r-items.impl.trait.implemented-trait"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.implemented-trait" title="items.impl.trait.implemented-trait"><span>[items<wbr>.impl<wbr>.trait<wbr>.implemented-trait]<span/></a></div>
<p>이 트레잇을 _구현된 트레잇_이라고 합니다. 구현 타입은 구현된 트레잇을 구현합니다.</p>
<div class="rule" id="r-items.impl.trait.def-requirement"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.def-requirement" title="items.impl.trait.def-requirement"><span>[items<wbr>.impl<wbr>.trait<wbr>.def-requirement]<span/></a></div>
<p>트레잇 구현은 구현된 트레잇에 선언된 기본값이 없는 모든 연관 아이템을 정의해야 하며, 구현된 트레잇에 정의된 기본 연관 아이템을 재정의할 수 있습니다. 그 외의 다른 아이템은 정의할 수 없습니다.</p>
<div class="rule" id="r-items.impl.trait.associated-item-path"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.associated-item-path" title="items.impl.trait.associated-item-path"><span>[items<wbr>.impl<wbr>.trait<wbr>.associated-item-path]<span/></a></div>
<p>연관 아이템으로의 경로는, 경로 구성 요소로서 <code>&lt;</code> 뒤에 구현 타입 경로, 그 뒤에 <code>as</code>, 그 뒤에 트레잇 경로, 그 뒤에 <code>&gt;</code>가 오고, 그 다음에 연관 아이템의 경로 구성 요소가 오는 형태입니다.</p>
<div class="rule" id="r-items.impl.trait.safety"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.safety" title="items.impl.trait.safety"><span>[items<wbr>.impl<wbr>.trait<wbr>.safety]<span/></a></div>
<p><a href="items/traits.html#unsafe-traits">Unsafe 트레잇</a>은 트레잇 구현이 <code>unsafe</code> 키워드로 시작할 것을 요구합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span><span class="boring">struct Point {x: f64, y: f64};
</span><span class="boring">type Surface = i32;
</span><span class="boring">struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
</span><span class="boring">trait Shape { fn draw(&amp;self, s: Surface); fn bounding_box(&amp;self) -&gt; BoundingBox; }
</span><span class="boring">fn do_draw_circle(s: Surface, c: Circle) { }
</span>struct Circle {
    radius: f64,
    center: Point,
}

impl Copy for Circle {}

impl Clone for Circle {
    fn clone(&amp;self) -&gt; Circle { *self }
}

impl Shape for Circle {
    fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&amp;self) -&gt; BoundingBox {
        let r = self.radius;
        BoundingBox {
            x: self.center.x - r,
            y: self.center.y - r,
            width: 2.0 * r,
            height: 2.0 * r,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.impl.trait.coherence"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.coherence" title="items.impl.trait.coherence"><span>[items<wbr>.impl<wbr>.trait<wbr>.coherence]<span/></a></div>
<h3 id="트레잇-구현-일관성"><a class="header" href="#트레잇-구현-일관성">트레잇 구현 일관성</a></h3>
<div class="rule" id="r-items.impl.trait.coherence.intro"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.coherence.intro" title="items.impl.trait.coherence.intro"><span>[items<wbr>.impl<wbr>.trait<wbr>.coherence<wbr>.intro]<span/></a></div>
<p>트레잇 구현은 고아 규칙(orphan rules) 검사에 실패하거나 중복되는 구현 인스턴스가 있는 경우 일관성이 없는(incoherent) 것으로 간주됩니다.</p>
<div class="rule" id="r-items.impl.trait.coherence.overlapping"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.coherence.overlapping" title="items.impl.trait.coherence.overlapping"><span>[items<wbr>.impl<wbr>.trait<wbr>.coherence<wbr>.overlapping]<span/></a></div>
<p>두 트레잇 구현은 구현 대상 트레잇들의 교집합이 비어 있지 않고, 해당 구현들이 동일한 타입으로 인스턴스화될 수 있을 때 중복(overlap)됩니다. <!-- 이것은 아마도 틀렸을 수 있습니다? 출처: 입력 타입 매개변수에 대해 동일한 타입 집합으로 인스턴스화할 수 있는 구현은 둘 이상 존재할 수 없습니다. --></p>
<div class="rule" id="r-items.impl.trait.orphan-rule"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.orphan-rule" title="items.impl.trait.orphan-rule"><span>[items<wbr>.impl<wbr>.trait<wbr>.orphan-rule]<span/></a></div>
<h4 id="고아-규칙"><a class="header" href="#고아-규칙">고아 규칙</a></h4>
<div class="rule" id="r-items.impl.trait.orphan-rule.general"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.orphan-rule.general" title="items.impl.trait.orphan-rule.general"><span>[items<wbr>.impl<wbr>.trait<wbr>.orphan-rule<wbr>.general]<span/></a></div>
<p><code>impl&lt;P1..=Pn&gt; Trait&lt;T1..=Tn&gt; for T0</code>가 주어졌을 때, <code>impl</code>은 다음 중 최소 하나가 참인 경우에만 유효합니다.</p>
<ul>
<li><code>Trait</code>가 <a href="items/../glossary.html#local-trait">로컬 트레잇</a>인 경우</li>
<li>다음 모두를 만족하는 경우
<ul>
<li>타입 <code>T0..=Tn</code> 중 적어도 하나는 <a href="items/../glossary.html#local-type">로컬 타입</a>이어야 합니다. 이러한 첫 번째 타입을 <code>Ti</code>라고 합시다.</li>
<li><code>T0..Ti</code>(<code>Ti</code> 제외)에는 <a href="items/../glossary.html#uncovered-type">덮이지 않은 타입(uncovered type)</a> 매개변수 <code>P1..=Pn</code>이 나타날 수 없습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-items.impl.trait.uncovered-param"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.uncovered-param" title="items.impl.trait.uncovered-param"><span>[items<wbr>.impl<wbr>.trait<wbr>.uncovered-param]<span/></a></div>
<p><em>덮이지 않은</em> 타입 매개변수의 출현만이 제한됩니다.</p>
<div class="rule" id="r-items.impl.trait.fundamental"><a class="rule-link" href="items/implementations.html#r-items.impl.trait.fundamental" title="items.impl.trait.fundamental"><span>[items<wbr>.impl<wbr>.trait<wbr>.fundamental]<span/></a></div>
<p>일관성을 위해 <a href="items/../glossary.html#fundamental-type-constructors">기초 타입(fundamental types)</a>은 특별하게 취급된다는 점에 유의하세요. <code>Box&lt;T&gt;</code>에서 <code>T</code>는 덮인 것으로 간주되지 않으며, <code>Box&lt;LocalType&gt;</code>은 로컬로 간주됩니다.</p>
<div class="rule" id="r-items.impl.generics"><a class="rule-link" href="items/implementations.html#r-items.impl.generics" title="items.impl.generics"><span>[items<wbr>.impl<wbr>.generics]<span/></a></div>
<h2 id="제네릭-구현"><a class="header" href="#제네릭-구현">제네릭 구현</a></h2>
<div class="rule" id="r-items.impl.generics.intro"><a class="rule-link" href="items/implementations.html#r-items.impl.generics.intro" title="items.impl.generics.intro"><span>[items<wbr>.impl<wbr>.generics<wbr>.intro]<span/></a></div>
<p>구현은 <a href="items/generics.html">제네릭 매개변수</a>를 가질 수 있으며, 이는 구현의 나머지 부분에서 사용될 수 있습니다. 구현 매개변수는 <code>impl</code> 키워드 바로 뒤에 작성됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Seq&lt;T&gt; { fn dummy(&amp;self, _: T) { } }
</span>impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* ... */
}
impl Seq&lt;bool&gt; for u32 {
    /* 정수를 비트 시퀀스로 취급 */
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.impl.generics.usage"><a class="rule-link" href="items/implementations.html#r-items.impl.generics.usage" title="items.impl.generics.usage"><span>[items<wbr>.impl<wbr>.generics<wbr>.usage]<span/></a></div>
<p>제네릭 매개변수가 다음 중 하나에 한 번이라도 나타나면 해당 구현을 _제약(constrain)_합니다.</p>
<ul>
<li>구현된 트레잇(있는 경우)</li>
<li>구현 타입</li>
<li>구현을 제약하는 다른 매개변수를 포함하는 타입의 <a href="items/../trait-bounds.html">바운드</a>에 있는 <a href="items/associated-items.html#associated-types">연관 타입</a>으로서</li>
</ul>
<div class="rule" id="r-items.impl.generics.constrain"><a class="rule-link" href="items/implementations.html#r-items.impl.generics.constrain" title="items.impl.generics.constrain"><span>[items<wbr>.impl<wbr>.generics<wbr>.constrain]<span/></a></div>
<p>타입 및 상수(const) 매개변수는 반드시 구현을 제약해야 합니다. 라이프타임은 연관 타입에서 사용되는 경우 반드시 구현을 제약해야 합니다.</p>
<p>제약하는 상황의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait{}
</span><span class="boring">trait GenericTrait&lt;T&gt; {}
</span><span class="boring">trait HasAssocType { type Ty; }
</span><span class="boring">struct Struct;
</span><span class="boring">struct GenericStruct&lt;T&gt;(T);
</span><span class="boring">struct ConstGenericStruct&lt;const N: usize&gt;([(); N]);
</span>// T는 GenericTrait의 인수가 됨으로써 제약합니다.
impl&lt;T&gt; GenericTrait&lt;T&gt; for i32 { /* ... */ }

// T는 GenericStruct의 인수가 됨으로써 제약합니다.
impl&lt;T&gt; Trait for GenericStruct&lt;T&gt; { /* ... */ }

// 마찬가지로, N은 ConstGenericStruct의 인수가 됨으로써 제약합니다.
impl&lt;const N: usize&gt; Trait for ConstGenericStruct&lt;N&gt; { /* ... */ }

// T는 트레잇을 제약하는 제네릭 매개변수인 타입 `U`에 대한 바운드의
// 연관 타입 안에 있음으로써 제약합니다.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// 이전과 비슷하지만, 타입이 `(U, isize)`라는 점이 다릅니다. `U`는 `T`를 포함하는
// 타입 내부에 나타나며, 타입 자체는 아닙니다.
impl&lt;T, U&gt; GenericStruct&lt;U&gt; where (U, isize): HasAssocType&lt;Ty = T&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>제약하지 않는 상황의 예시:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The rest of these are errors, since they have type or const parameters that
// do not constrain.

// T는 전혀 나타나지 않으므로 제약하지 않습니다.
impl&lt;T&gt; Struct { /* ... */ }

// N도 같은 이유로 제약하지 않습니다.
impl&lt;const N: usize&gt; Struct { /* ... */ }

// 구현 내부에서의 T의 사용은 구현을 제약하지 않습니다.
impl&lt;T&gt; Struct {
    fn uses_t(t: &amp;T) { /* ... */ }
}

// T는 U에 대한 바운드의 연관 타입으로 사용되지만, U가 제약하지 않습니다.
impl&lt;T, U&gt; Struct where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// T는 바운드에서 사용되지만, 연관 타입으로서가 아니므로 제약하지 않습니다.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: GenericTrait&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>허용되는, 제약하지 않는 라이프타임 매개변수의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span>impl&lt;'a&gt; Struct {}
<span class="boring">}</span></code></pre></pre>
<p>허용되지 않는, 제약하지 않는 라이프타임 매개변수의 예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span><span class="boring">trait HasAssocType { type Ty; }
</span>impl&lt;'a&gt; HasAssocType for Struct {
    type Ty = &amp;'a Struct;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.impl.attributes"><a class="rule-link" href="items/implementations.html#r-items.impl.attributes" title="items.impl.attributes"><span>[items<wbr>.impl<wbr>.attributes]<span/></a></div>
<h2 id="구현의-속성"><a class="header" href="#구현의-속성">구현의 속성</a></h2>
<p>구현은 <code>impl</code> 키워드 앞에 외부 <a href="items/../attributes.html">속성</a>을, 연관 아이템을 포함하는 중괄호 안에 내부 <a href="items/../attributes.html">속성</a>을 가질 수 있습니다. 내부 속성은 반드시 모든 연관 아이템보다 먼저 와야 합니다. 여기서 의미를 갖는 속성은 <a href="items/../conditional-compilation.html"><code>cfg</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, 그리고 <a href="items/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.extern"><a class="rule-link" href="items/external-blocks.html#r-items.extern" title="items.extern"><span>[items<wbr>.extern]<span/></a></div>
<h1 id="외부-블록"><a class="header" href="#외부-블록">외부 블록</a></h1>
<div class="rule" id="r-items.extern.syntax"><a class="rule-link" href="items/external-blocks.html#r-items.extern.syntax" title="items.extern.syntax"><span>[items<wbr>.extern<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>외부블록</em> :<br />
   <code>unsafe</code><sup>?</sup><sup class="footnote-reference"><a href="#unsafe-2024">1</a></sup> <code>extern</code> <a href="items/functions.html"><em>Abi</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
      <em>외부아이템</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>외부아이템</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>세미콜론매크로호출</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>가시성</em></a><sup>?</sup> ( <a href="items/static-items.html"><em>정적아이템</em></a> | <a href="items/functions.html"><em>함수</em></a> ) )<br />
   )</p>
<div class="footnote-definition" id="unsafe-2024"><sup class="footnote-definition-label">1</sup>
<p>2024 에디션부터는 <code>unsafe</code> 키워드가 시맨틱적으로 요구됩니다.</p>
</div>
</blockquote>
<div class="rule" id="r-items.extern.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.intro" title="items.extern.intro"><span>[items<wbr>.extern<wbr>.intro]<span/></a></div>
<p>외부 블록은 현재 크레이트에서 _정의_되지 않은 아이템의 _선언_을 제공하며, Rust의 외부 함수 인터페이스(foreign function interface)의 기초가 됩니다. 이들은 검사되지 않은 임포트(unchecked imports)와 유사합니다.</p>
<div class="rule" id="r-items.extern.allowed-kinds"><a class="rule-link" href="items/external-blocks.html#r-items.extern.allowed-kinds" title="items.extern.allowed-kinds"><span>[items<wbr>.extern<wbr>.allowed-kinds]<span/></a></div>
<p>외부 블록에서는 두 가지 종류의 아이템 _선언_이 허용됩니다: <a href="items/functions.html">함수</a>와 <a href="items/static-items.html">정적 아이템(statics)</a>입니다.</p>
<div class="rule" id="r-items.extern.fn-safety"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn-safety" title="items.extern.fn-safety"><span>[items<wbr>.extern<wbr>.fn-safety]<span/></a></div>
<p>외부 블록에 선언된 함수를 호출하거나 정적 아이템에 접근하는 것은 오직 <code>unsafe</code> 컨텍스트에서만 허용됩니다.</p>
<div class="rule" id="r-items.extern.namespace"><a class="rule-link" href="items/external-blocks.html#r-items.extern.namespace" title="items.extern.namespace"><span>[items<wbr>.extern<wbr>.namespace]<span/></a></div>
<p>외부 블록은 해당 모듈이나 블록의 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 함수와 정적 아이템을 정의합니다.</p>
<div class="rule" id="r-items.extern.unsafe-required"><a class="rule-link" href="items/external-blocks.html#r-items.extern.unsafe-required" title="items.extern.unsafe-required"><span>[items<wbr>.extern<wbr>.unsafe-required]<span/></a></div>
<p><code>unsafe</code> 키워드는 외부 블록의 <code>extern</code> 키워드 앞에 나타나도록 시맨틱적으로 요구됩니다.</p>
<div class="rule" id="r-items.extern.edition2024"><a class="rule-link" href="items/external-blocks.html#r-items.extern.edition2024" title="items.extern.edition2024"><span>[items<wbr>.extern<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>unsafe</code> 키워드가 선택 사항입니다. <code>safe</code> 및 <code>unsafe</code> 아이템 한정자는 외부 블록 자체가 <code>unsafe</code>로 표시된 경우에만 허용됩니다.</p>
</blockquote>
<div class="rule" id="r-items.extern.fn"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn" title="items.extern.fn"><span>[items<wbr>.extern<wbr>.fn]<span/></a></div>
<h2 id="함수-1"><a class="header" href="#함수-1">함수</a></h2>
<div class="rule" id="r-items.extern.fn.body"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.body" title="items.extern.fn.body"><span>[items<wbr>.extern<wbr>.fn<wbr>.body]<span/></a></div>
<p>외부 블록 내의 함수는 다른 Rust 함수와 동일한 방식으로 선언되지만, 본문을 가질 수 없으며 대신 세미콜론으로 끝난다는 점이 다릅니다.</p>
<div class="rule" id="r-items.extern.fn.param-patterns"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.param-patterns" title="items.extern.fn.param-patterns"><span>[items<wbr>.extern<wbr>.fn<wbr>.param-patterns]<span/></a></div>
<p>매개변수에는 패턴이 허용되지 않으며, <a href="items/../identifiers.html">식별자</a> 또는 <code>_</code>만 사용할 수 있습니다.</p>
<div class="rule" id="r-items.extern.fn.qualifiers"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.qualifiers" title="items.extern.fn.qualifiers"><span>[items<wbr>.extern<wbr>.fn<wbr>.qualifiers]<span/></a></div>
<p><code>safe</code> 및 <code>unsafe</code> 함수 한정자는 허용되지만, 다른 함수 한정자(예: <code>const</code>, <code>async</code>, <code>extern</code>)는 허용되지 않습니다.</p>
<div class="rule" id="r-items.extern.fn.foreign-abi"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.foreign-abi" title="items.extern.fn.foreign-abi"><span>[items<wbr>.extern<wbr>.fn<wbr>.foreign-abi]<span/></a></div>
<p>외부 블록 내의 함수는 Rust에서 정의된 함수와 마찬가지로 Rust 코드에서 호출될 수 있습니다. Rust 컴파일러는 Rust ABI와 외부 ABI 간의 변환을 자동으로 처리합니다.</p>
<div class="rule" id="r-items.extern.fn.safety"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.safety" title="items.extern.fn.safety"><span>[items<wbr>.extern<wbr>.fn<wbr>.safety]<span/></a></div>
<p>외부 블록에 선언된 함수는 <code>safe</code> 함수 한정자가 없는 한 암시적으로 <code>unsafe</code>입니다.</p>
<div class="rule" id="r-items.extern.fn.fn-ptr"><a class="rule-link" href="items/external-blocks.html#r-items.extern.fn.fn-ptr" title="items.extern.fn.fn-ptr"><span>[items<wbr>.extern<wbr>.fn<wbr>.fn-ptr]<span/></a></div>
<p>함수 포인터로 강제 변환될 때, 외부 블록에 선언된 함수는 <code>extern "abi" for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code> 타입을 갖습니다. 여기서 <code>'l1</code>, …, <code>'lm</code>은 라이프타임 매개변수이고, <code>A1</code>, …, <code>An</code>은 선언된 매개변수 타입이며, <code>R</code>은 선언된 반환 타입입니다.</p>
<div class="rule" id="r-items.extern.static"><a class="rule-link" href="items/external-blocks.html#r-items.extern.static" title="items.extern.static"><span>[items<wbr>.extern<wbr>.static]<span/></a></div>
<h2 id="정적-아이템-1"><a class="header" href="#정적-아이템-1">정적 아이템</a></h2>
<div class="rule" id="r-items.extern.static.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.static.intro" title="items.extern.static.intro"><span>[items<wbr>.extern<wbr>.static<wbr>.intro]<span/></a></div>
<p>외부 블록 내의 정적 아이템은 외부 블록 밖의 <a href="items/static-items.html">정적 아이템</a>과 동일한 방식으로 선언되지만, 값을 초기화하는 표현식을 갖지 않는다는 점이 다릅니다.</p>
<div class="rule" id="r-items.extern.static.safety"><a class="rule-link" href="items/external-blocks.html#r-items.extern.static.safety" title="items.extern.static.safety"><span>[items<wbr>.extern<wbr>.static<wbr>.safety]<span/></a></div>
<p>외부 블록에 선언된 정적 아이템이 <code>safe</code>로 한정되지 않는 한, 해당 아이템에 접근하는 것은 가변성 여부와 상관없이 <code>unsafe</code>입니다. 왜냐하면 임의의 (예: C) 코드가 정적 아이템의 초기화를 담당하므로, 해당 메모리의 비트 패턴이 선언된 타입에 대해 유효하다는 보장이 없기 때문입니다.</p>
<div class="rule" id="r-items.extern.static.mut"><a class="rule-link" href="items/external-blocks.html#r-items.extern.static.mut" title="items.extern.static.mut"><span>[items<wbr>.extern<wbr>.static<wbr>.mut]<span/></a></div>
<p>외부 정적 아이템은 외부 블록 밖의 <a href="items/static-items.html">정적 아이템</a>과 마찬가지로 불변이거나 가변일 수 있습니다.</p>
<div class="rule" id="r-items.extern.static.read-only"><a class="rule-link" href="items/external-blocks.html#r-items.extern.static.read-only" title="items.extern.static.read-only"><span>[items<wbr>.extern<wbr>.static<wbr>.read-only]<span/></a></div>
<p>불변 정적 아이템은 어떠한 Rust 코드가 실행되기 전에 반드시 초기화되어야 합니다. Rust 코드가 그것을 읽기 전에 초기화되는 것만으로는 충분하지 않습니다. 일단 Rust 코드가 실행되면, 불변 정적 아이템을 (Rust 내부에서든 외부에서든) 수정하는 것은 <code>UnsafeCell</code> 내부의 바이트에 대한 수정이 아닌 한 정의되지 않은 동작(UB)입니다.</p>
<div class="rule" id="r-items.extern.abi"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi" title="items.extern.abi"><span>[items<wbr>.extern<wbr>.abi]<span/></a></div>
<h2 id="abi"><a class="header" href="#abi">ABI</a></h2>
<div class="rule" id="r-items.extern.abi.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.intro" title="items.extern.abi.intro"><span>[items<wbr>.extern<wbr>.abi<wbr>.intro]<span/></a></div>
<p>기본적으로 외부 블록은 호출하는 라이브러리가 해당 플랫폼의 표준 C ABI를 사용한다고 가정합니다. 다음 예시와 같이 <code>abi</code> 문자열을 사용하여 다른 ABI를 지정할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(any(windows, target_arch = "x86"))]
</span>// Windows API 인터페이스
unsafe extern "stdcall" { }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.extern.abi.standard"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.standard" title="items.extern.abi.standard"><span>[items<wbr>.extern<wbr>.abi<wbr>.standard]<span/></a></div>
<p>모든 컴파일러가 지원하도록 보장된 세 가지 크로스 플랫폼 ABI 문자열이 있습니다.</p>
<div class="rule" id="r-items.extern.abi.rust"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.rust" title="items.extern.abi.rust"><span>[items<wbr>.extern<wbr>.abi<wbr>.rust]<span/></a></div>
<ul>
<li><code>unsafe extern "Rust"</code> – Rust 코드에서 일반적인 <code>fn foo()</code>를 작성할 때의 기본 ABI입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.c"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.c" title="items.extern.abi.c"><span>[items<wbr>.extern<wbr>.abi<wbr>.c]<span/></a></div>
<ul>
<li><code>unsafe extern "C"</code> – <code>extern fn foo()</code>와 동일합니다. C 컴파일러가 지원하는 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.system"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.system" title="items.extern.abi.system"><span>[items<wbr>.extern<wbr>.abi<wbr>.system]<span/></a></div>
<ul>
<li><code>unsafe extern "system"</code> – 보통 <code>extern "C"</code>와 동일하지만, Win32에서는 <code>"stdcall"</code>이며, Windows API 자체에 링크할 때 사용해야 하는 ABI입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.platform"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.platform" title="items.extern.abi.platform"><span>[items<wbr>.extern<wbr>.abi<wbr>.platform]<span/></a></div>
<p>플랫폼별로 특화된 ABI 문자열들도 있습니다.</p>
<div class="rule" id="r-items.extern.abi.cdecl"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.cdecl" title="items.extern.abi.cdecl"><span>[items<wbr>.extern<wbr>.abi<wbr>.cdecl]<span/></a></div>
<ul>
<li><code>unsafe extern "cdecl"</code> – x86_32 C 코드의 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.stdcall"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.stdcall" title="items.extern.abi.stdcall"><span>[items<wbr>.extern<wbr>.abi<wbr>.stdcall]<span/></a></div>
<ul>
<li><code>unsafe extern "stdcall"</code> – x86_32 환경의 Win32 API 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.win64"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.win64" title="items.extern.abi.win64"><span>[items<wbr>.extern<wbr>.abi<wbr>.win64]<span/></a></div>
<ul>
<li><code>unsafe extern "win64"</code> – x86_64 Windows 환경의 C 코드 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.sysv64"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.sysv64" title="items.extern.abi.sysv64"><span>[items<wbr>.extern<wbr>.abi<wbr>.sysv64]<span/></a></div>
<ul>
<li><code>unsafe extern "sysv64"</code> – Windows가 아닌 x86_64 환경의 C 코드 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.aapcs"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.aapcs" title="items.extern.abi.aapcs"><span>[items<wbr>.extern<wbr>.abi<wbr>.aapcs]<span/></a></div>
<ul>
<li><code>unsafe extern "aapcs"</code> – ARM의 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.fastcall"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.fastcall" title="items.extern.abi.fastcall"><span>[items<wbr>.extern<wbr>.abi<wbr>.fastcall]<span/></a></div>
<ul>
<li><code>unsafe extern "fastcall"</code> – <code>fastcall</code> ABI입니다. MSVC의 <code>__fastcall</code> 및 GCC와 clang의 <code>__attribute__((fastcall))</code>에 해당합니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.thiscall"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.thiscall" title="items.extern.abi.thiscall"><span>[items<wbr>.extern<wbr>.abi<wbr>.thiscall]<span/></a></div>
<ul>
<li><code>unsafe extern "thiscall"</code> – MSVC 환경의 C++ 멤버 함수 기본값입니다. MSVC의 <code>__thiscall</code> 및 GCC와 clang의 <code>__attribute__((thiscall))</code>에 해당합니다.</li>
</ul>
<div class="rule" id="r-items.extern.abi.efiapi"><a class="rule-link" href="items/external-blocks.html#r-items.extern.abi.efiapi" title="items.extern.abi.efiapi"><span>[items<wbr>.extern<wbr>.abi<wbr>.efiapi]<span/></a></div>
<ul>
<li><code>unsafe extern "efiapi"</code> – <a href="https://uefi.org/specifications">UEFI</a> 함수에 사용되는 ABI입니다.</li>
</ul>
<div class="rule" id="r-items.extern.variadic"><a class="rule-link" href="items/external-blocks.html#r-items.extern.variadic" title="items.extern.variadic"><span>[items<wbr>.extern<wbr>.variadic]<span/></a></div>
<h2 id="가변-인자-함수"><a class="header" href="#가변-인자-함수">가변 인자 함수</a></h2>
<p>외부 블록 내의 함수는 마지막 인수로 <code>...</code>을 지정하여 가변 인자 함수가 될 수 있습니다. 가변 인자 매개변수는 선택적으로 식별자를 가질 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    safe fn foo(...);
    unsafe fn bar(x: i32, ...);
    unsafe fn with_name(format: *const u8, args: ...);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.extern.attributes"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes" title="items.extern.attributes"><span>[items<wbr>.extern<wbr>.attributes]<span/></a></div>
<h2 id="외부-블록의-속성"><a class="header" href="#외부-블록의-속성">외부 블록의 속성</a></h2>
<div class="rule" id="r-items.extern.attributes.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.intro" title="items.extern.attributes.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.intro]<span/></a></div>
<p>다음 <a href="items/../attributes.html">속성들</a>은 외부 블록의 동작을 제어합니다.</p>
<div class="rule" id="r-items.extern.attributes.link"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link" title="items.extern.attributes.link"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link]<span/></a></div>
<h3 id="link-속성"><a class="header" href="#link-속성"><code>link</code> 속성</a></h3>
<div class="rule" id="r-items.extern.attributes.link.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.intro" title="items.extern.attributes.link.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.intro]<span/></a></div>
<p>_<code>link</code> 속성_은 <code>extern</code> 블록 내의 아이템들을 위해 컴파일러가 링크해야 할 네이티브 라이브러리의 이름을 지정합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.syntax"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.syntax" title="items.extern.attributes.link.syntax"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.syntax]<span/></a></div>
<p>이 속성은 입력을 지정하기 위해 <a href="items/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용합니다. <code>name</code> 키는 링크할 네이티브 라이브러리의 이름입니다. <code>kind</code> 키는 라이브러리의 종류를 지정하는 선택적 값이며, 다음과 같은 값들이 가능합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.dylib"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.dylib" title="items.extern.attributes.link.dylib"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.dylib]<span/></a></div>
<ul>
<li><code>dylib</code> — 동적 라이브러리임을 나타냅니다. <code>kind</code>가 지정되지 않은 경우의 기본값입니다.</li>
</ul>
<div class="rule" id="r-items.extern.attributes.link.static"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.static" title="items.extern.attributes.link.static"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.static]<span/></a></div>
<ul>
<li><code>static</code> — 정적 라이브러리임을 나타냅니다.</li>
</ul>
<div class="rule" id="r-items.extern.attributes.link.framework"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.framework" title="items.extern.attributes.link.framework"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.framework]<span/></a></div>
<ul>
<li><code>framework</code> — macOS 프레임워크임을 나타냅니다. macOS 타겟인 경우에만 유효합니다.</li>
</ul>
<div class="rule" id="r-items.extern.attributes.link.raw-dylib"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.raw-dylib" title="items.extern.attributes.link.raw-dylib"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.raw-dylib]<span/></a></div>
<ul>
<li><code>raw-dylib</code> — 컴파일러가 링크를 위해 임포트 라이브러리를 생성할 동적 라이브러리임을 나타냅니다(자세한 내용은 아래의 <a href="items/external-blocks.html#dylib-versus-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a> 섹션을 참조하세요). Windows 타겟인 경우에만 유효합니다.</li>
</ul>
<div class="rule" id="r-items.extern.attributes.link.name-requirement"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.name-requirement" title="items.extern.attributes.link.name-requirement"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.name-requirement]<span/></a></div>
<p><code>kind</code>가 지정된 경우 <code>name</code> 키가 반드시 포함되어야 합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers" title="items.extern.attributes.link.modifiers"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers]<span/></a></div>
<p>선택적인 <code>modifiers</code> 인수는 링크할 라이브러리에 대해 링크 수정자(linking modifiers)를 지정하는 방법입니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.syntax"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.syntax" title="items.extern.attributes.link.modifiers.syntax"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.syntax]<span/></a></div>
<p>수정자들은 쉼표로 구분된 문자열로 지정하며, 각 수정자 앞에 <code>+</code> 또는 <code>-</code>를 붙여서 각각 해당 수정자의 활성화 또는 비활성화 여부를 나타냅니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.multiple"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.multiple" title="items.extern.attributes.link.modifiers.multiple"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.multiple]<span/></a></div>
<p>단일 <code>link</code> 속성 내에 여러 <code>modifiers</code> 인수를 지정하거나, 동일한 <code>modifiers</code> 인수 내에 중복된 수정자를 지정하는 것은 현재 지원되지 않습니다.<br />
예시: <code>#[link(name = "mylib", kind = "static", modifiers = "+whole-archive")]</code>.</p>
<div class="rule" id="r-items.extern.attributes.link.wasm_import_module"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.wasm_import_module" title="items.extern.attributes.link.wasm_import_module"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.wasm_import_module]<span/></a></div>
<p><code>wasm_import_module</code> 키는 호스트 환경으로부터 심볼을 임포트할 때 <code>extern</code> 블록 내 아이템들에 대한 <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly 모듈</a> 이름을 지정하는 데 사용될 수 있습니다. <code>wasm_import_module</code>이 지정되지 않은 경우 기본 모듈 이름은 <code>env</code>입니다.</p>
<!-- ignore: requires extern linking -->
<pre><code class="language-rust ignore">#[link(name = "crypto")]
unsafe extern {
    // …
}

#[link(name = "CoreFoundation", kind = "framework")]
unsafe extern {
    // …
}

#[link(wasm_import_module = "foo")]
unsafe extern {
    // …
}</code></pre>
<div class="rule" id="r-items.extern.attributes.link.empty-block"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.empty-block" title="items.extern.attributes.link.empty-block"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.empty-block]<span/></a></div>
<p>비어 있는 외부 블록에 <code>link</code> 속성을 추가하는 것도 유효합니다. 이를 통해 각 외부 블록마다 속성을 추가하는 대신, 코드의 다른 부분(업스트림 크레이트 포함)에 있는 외부 블록들의 링크 요구 사항을 충족시킬 수 있습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle" title="items.extern.attributes.link.modifiers.bundle"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle]<span/></a></div>
<h4 id="링크-수정자-bundle"><a class="header" href="#링크-수정자-bundle">링크 수정자: <code>bundle</code></a></h4>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.allowed-kinds"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.allowed-kinds" title="items.extern.attributes.link.modifiers.bundle.allowed-kinds"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle<wbr>.allowed-kinds]<span/></a></div>
<p>이 수정자는 <code>static</code> 링크 종류와만 호환됩니다. 다른 종류를 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.behavior"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.behavior" title="items.extern.attributes.link.modifiers.bundle.behavior"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle<wbr>.behavior]<span/></a></div>
<p>rlib나 staticlib을 빌드할 때 <code>+bundle</code>은 네이티브 정적 라이브러리가 rlib나 staticlib 아카이브에 포함되고, 나중에 최종 바이너리를 링크할 때 그곳에서 추출된다는 것을 의미합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.behavior-negative"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.behavior-negative" title="items.extern.attributes.link.modifiers.bundle.behavior-negative"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle<wbr>.behavior-negative]<span/></a></div>
<p>rlib를 빌드할 때 <code>-bundle</code>은 네이티브 정적 라이브러리가 해당 rlib의 의존성으로 “이름에 의해” 등록되며, 해당 라이브러리의 객체 파일들은 최종 바이너리를 링크할 때만 포함된다는 것을 의미합니다. 해당 이름에 의한 파일 검색 또한 최종 링크 시점에 수행됩니다.<br />
staticlib을 빌드할 때 <code>-bundle</code>은 네이티브 정적 라이브러리가 아카이브에 포함되지 않으며, 나중에 최종 바이너리를 링크할 때 더 높은 수준의 빌드 시스템에서 이를 추가해야 함을 의미합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.no-effect"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.no-effect" title="items.extern.attributes.link.modifiers.bundle.no-effect"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle<wbr>.no-effect]<span/></a></div>
<p>이 수정자는 실행 파일이나 동적 라이브러리와 같은 다른 타겟을 빌드할 때는 아무런 효과가 없습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.bundle.default"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.default" title="items.extern.attributes.link.modifiers.bundle.default"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.bundle<wbr>.default]<span/></a></div>
<p>이 수정자의 기본값은 <code>+bundle</code>입니다.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-bundle">rustc의 <code>bundle</code> 문서</a>에서 확인할 수 있습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive" title="items.extern.attributes.link.modifiers.whole-archive"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.whole-archive]<span/></a></div>
<h4 id="링크-수정자-whole-archive"><a class="header" href="#링크-수정자-whole-archive">링크 수정자: <code>whole-archive</code></a></h4>
<div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.allowed-kinds"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.allowed-kinds" title="items.extern.attributes.link.modifiers.whole-archive.allowed-kinds"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.whole-archive<wbr>.allowed-kinds]<span/></a></div>
<p>이 수정자는 <code>static</code> 링크 종류와만 호환됩니다. 다른 종류를 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.behavior"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.behavior" title="items.extern.attributes.link.modifiers.whole-archive.behavior"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.whole-archive<wbr>.behavior]<span/></a></div>
<p><code>+whole-archive</code>는 정적 라이브러리가 객체 파일을 하나도 버리지 않고 아카이브 전체로서 링크된다는 것을 의미합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.whole-archive.default"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.default" title="items.extern.attributes.link.modifiers.whole-archive.default"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.whole-archive<wbr>.default]<span/></a></div>
<p>이 수정자의 기본값은 <code>-whole-archive</code>입니다.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-whole-archive">rustc의 <code>whole-archive</code> 문서</a>에서 확인할 수 있습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim" title="items.extern.attributes.link.modifiers.verbatim"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.verbatim]<span/></a></div>
<h3 id="링크-수정자-verbatim"><a class="header" href="#링크-수정자-verbatim">링크 수정자: <code>verbatim</code></a></h3>
<div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.allowed-kinds"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.allowed-kinds" title="items.extern.attributes.link.modifiers.verbatim.allowed-kinds"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.verbatim<wbr>.allowed-kinds]<span/></a></div>
<p>이 수정자는 모든 링크 종류와 호환됩니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.behavior"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.behavior" title="items.extern.attributes.link.modifiers.verbatim.behavior"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.verbatim<wbr>.behavior]<span/></a></div>
<p><code>+verbatim</code>은 rustc가 라이브러리 이름에 타겟별 라이브러리 접두사나 접미사(<code>lib</code> 또는 <code>.a</code> 등)를 직접 추가하지 않으며, 링커에게도 동일하게 요청하도록 최선을 다한다는 것을 의미합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.behavior-negative"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.behavior-negative" title="items.extern.attributes.link.modifiers.verbatim.behavior-negative"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.verbatim<wbr>.behavior-negative]<span/></a></div>
<p><code>-verbatim</code>은 rustc가 라이브러리 이름을 링커에 전달하기 전에 타겟별 접두사와 접미사를 추가하거나, 링커가 암시적으로 이를 추가하는 것을 막지 않는다는 것을 의미합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.modifiers.verbatim.default"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.default" title="items.extern.attributes.link.modifiers.verbatim.default"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.modifiers<wbr>.verbatim<wbr>.default]<span/></a></div>
<p>이 수정자의 기본값은 <code>-verbatim</code>입니다.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-verbatim">rustc의 <code>verbatim</code> 문서</a>에서 확인할 수 있습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib" title="items.extern.attributes.link.kind-raw-dylib"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.kind-raw-dylib]<span/></a></div>
<h4 id="dylib-대-raw-dylib"><a class="header" href="#dylib-대-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a></h4>
<div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.intro" title="items.extern.attributes.link.kind-raw-dylib.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.kind-raw-dylib<wbr>.intro]<span/></a></div>
<p>Windows에서 동적 라이브러리에 링크하려면 링커에 임포트 라이브러리(import library)를 제공해야 합니다. 이것은 동적 라이브러리가 내보내는 모든 심볼을 선언하여, 링커가 해당 심볼들이 런타임에 동적으로 로드되어야 함을 알 수 있게 해주는 특별한 정적 라이브러리입니다.</p>
<div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.import"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.import" title="items.extern.attributes.link.kind-raw-dylib.import"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.kind-raw-dylib<wbr>.import]<span/></a></div>
<p><code>kind = "dylib"</code>을 지정하면 Rust 컴파일러가 <code>name</code> 키에 기반한 임포트 라이브러리를 링크하도록 지시합니다. 그러면 링커는 일반적인 라이브러리 해석 로직을 사용하여 해당 임포트 라이브러리를 찾습니다. 반면에, <code>kind = "raw-dylib"</code>을 지정하면 컴파일러가 컴파일 중에 직접 임포트 라이브러리를 생성하여 링커에 제공하도록 지시합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.kind-raw-dylib.platform-specific"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.platform-specific" title="items.extern.attributes.link.kind-raw-dylib.platform-specific"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.kind-raw-dylib<wbr>.platform-specific]<span/></a></div>
<p><code>raw-dylib</code>은 Windows에서만 지원됩니다. 다른 플랫폼을 타겟으로 할 때 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link.import_name_type"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type" title="items.extern.attributes.link.import_name_type"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type]<span/></a></div>
<h4 id="import_name_type-키"><a class="header" href="#import_name_type-키"><code>import_name_type</code> 키</a></h4>
<div class="rule" id="r-items.extern.attributes.link.import_name_type.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.intro" title="items.extern.attributes.link.import_name_type.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type<wbr>.intro]<span/></a></div>
<p>x86 Windows에서 함수 이름은 호출 규약(calling convention)을 나타내기 위해 “장식(decorated)“됩니다(즉, 특정 접두사나 접미사가 추가됩니다). 예를 들어, 인수가 없는 <code>fn1</code>이라는 이름의 <code>stdcall</code> 호출 규약 함수는 <code>_fn1@0</code>으로 장식됩니다. 하지만 <a href="https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type">PE 포맷</a>은 접두사가 없거나 장식되지 않은 이름도 허용합니다. 또한 MSVC와 GNU 툴체인은 동일한 호출 규약에 대해 서로 다른 장식을 사용하므로, 기본적으로 일부 Win32 함수들은 GNU 툴체인을 통해 <code>raw-dylib</code> 링크 종류를 사용하여 호출할 수 없습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.import_name_type.values"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.values" title="items.extern.attributes.link.import_name_type.values"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type<wbr>.values]<span/></a></div>
<p>이러한 차이점을 해결하기 위해, <code>raw-dylib</code> 링크 종류를 사용할 때 <code>import_name_type</code> 키에 다음 값 중 하나를 지정하여 생성된 임포트 라이브러리 내 함수 이름 지정 방식을 변경할 수 있습니다.</p>
<ul>
<li><code>decorated</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 완전히 장식됩니다.</li>
<li><code>noprefix</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 장식되지만, 앞의 <code>?</code>, <code>@</code> 또는 선택적으로 <code>_</code>를 생략합니다.</li>
<li><code>undecorated</code>: 함수 이름이 장식되지 않습니다.</li>
</ul>
<div class="rule" id="r-items.extern.attributes.link.import_name_type.default"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.default" title="items.extern.attributes.link.import_name_type.default"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type<wbr>.default]<span/></a></div>
<p><code>import_name_type</code> 키가 지정되지 않으면, 함수 이름은 타겟 툴체인의 형식을 사용하여 완전히 장식됩니다.</p>
<div class="rule" id="r-items.extern.attributes.link.import_name_type.variables"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.variables" title="items.extern.attributes.link.import_name_type.variables"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type<wbr>.variables]<span/></a></div>
<p>변수는 절대 장식되지 않으므로, <code>import_name_type</code> 키는 생성된 임포트 라이브러리 내 변수 이름에 아무런 영향을 주지 않습니다.</p>
<div class="rule" id="r-items.extern.attributes.link.import_name_type.platform-specific"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.platform-specific" title="items.extern.attributes.link.import_name_type.platform-specific"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link<wbr>.import_name_type<wbr>.platform-specific]<span/></a></div>
<p><code>import_name_type</code> 키는 x86 Windows에서만 지원됩니다. 다른 플랫폼을 타겟으로 할 때 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link_name"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_name" title="items.extern.attributes.link_name"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_name]<span/></a></div>
<h3 id="link_name-속성"><a class="header" href="#link_name-속성"><code>link_name</code> 속성</a></h3>
<div class="rule" id="r-items.extern.attributes.link_name.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_name.intro" title="items.extern.attributes.link_name.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_name<wbr>.intro]<span/></a></div>
<p>_<code>link_name</code> 속성_은 <code>extern</code> 블록 내의 선언에 지정되어 해당 함수나 정적 아이템을 위해 임포트할 심볼을 나타낼 수 있습니다.</p>
<div class="rule" id="r-items.extern.attributes.link_name.syntax"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_name.syntax" title="items.extern.attributes.link_name.syntax"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_name<wbr>.syntax]<span/></a></div>
<p>심볼의 이름을 지정하기 위해 <a href="items/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern {
    #[link_name = "actual_symbol_name"]
    safe fn name_in_rust();
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.extern.attributes.link_name.exclusive"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_name.exclusive" title="items.extern.attributes.link_name.exclusive"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_name<wbr>.exclusive]<span/></a></div>
<p>이 속성을 <code>link_ordinal</code> 속성과 함께 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link_ordinal"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_ordinal" title="items.extern.attributes.link_ordinal"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_ordinal]<span/></a></div>
<h3 id="link_ordinal-속성"><a class="header" href="#link_ordinal-속성"><code>link_ordinal</code> 속성</a></h3>
<div class="rule" id="r-items.extern.attributes.link_ordinal.intro"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.intro" title="items.extern.attributes.link_ordinal.intro"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_ordinal<wbr>.intro]<span/></a></div>
<p>_<code>link_ordinal</code> 속성_은 <code>extern</code> 블록 내의 선언에 적용되어, 링크할 임포트 라이브러리를 생성할 때 사용할 숫자 오디널(ordinal)을 나타낼 수 있습니다. 오디널은 Windows의 동적 라이브러리에서 내보내는 심볼마다 부여되는 고유한 번호이며, 라이브러리가 로드될 때 이름을 검색하는 대신 이 번호를 사용하여 심볼을 찾는 데 사용될 수 있습니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> <code>link_ordinal</code>은 심볼의 오디널이 안정적임이 보장되는 경우에만 사용해야 합니다. 심볼을 포함하는 바이너리가 빌드될 때 심볼의 오디널이 명시적으로 설정되지 않으면 자동으로 할당되며, 이 할당된 오디널은 바이너리 빌드 간에 변경될 수 있습니다.</p>
</blockquote>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(all(windows, target_arch = "x86"))]
</span>#[link(name = "exporter", kind = "raw-dylib")]
unsafe extern "stdcall" {
    #[link_ordinal(15)]
    safe fn imported_function_stdcall(i: i32);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.extern.attributes.link_ordinal.allowed-kinds"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.allowed-kinds" title="items.extern.attributes.link_ordinal.allowed-kinds"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_ordinal<wbr>.allowed-kinds]<span/></a></div>
<p>이 속성은 오직 <code>raw-dylib</code> 링크 종류와 함께 사용됩니다. 다른 종류를 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.link_ordinal.exclusive"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.exclusive" title="items.extern.attributes.link_ordinal.exclusive"><span>[items<wbr>.extern<wbr>.attributes<wbr>.link_ordinal<wbr>.exclusive]<span/></a></div>
<p>이 속성을 <code>link_name</code> 속성과 함께 사용하면 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-items.extern.attributes.fn-parameters"><a class="rule-link" href="items/external-blocks.html#r-items.extern.attributes.fn-parameters" title="items.extern.attributes.fn-parameters"><span>[items<wbr>.extern<wbr>.attributes<wbr>.fn-parameters]<span/></a></div>
<h3 id="함수-매개변수의-속성-1"><a class="header" href="#함수-매개변수의-속성-1">함수 매개변수의 속성</a></h3>
<p>외부 함수의 매개변수에 붙는 속성들은 <a href="items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.generics"><a class="rule-link" href="items/generics.html#r-items.generics" title="items.generics"><span>[items<wbr>.generics]<span/></a></div>
<h1 id="제네릭-파라미터"><a class="header" href="#제네릭-파라미터">제네릭 파라미터</a></h1>
<div class="rule" id="r-items.generics.syntax"><a class="rule-link" href="items/generics.html#r-items.generics.syntax" title="items.generics.syntax"><span>[items<wbr>.generics<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>제네릭매개변수들</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
    | <code>&lt;</code> (<em>제네릭매개변수</em> <code>,</code>)<sup>*</sup> <em>제네릭매개변수</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>제네릭매개변수</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup> ( <em>라이프타임매개변수</em> | <em>타입매개변수</em> | <em>상수매개변수</em> )</p>
<p><em>라이프타임매개변수</em> :<br />
   <a href="items/../trait-bounds.html"><em>라이프타임</em></a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>라이프타임바운드</em></a> )<sup>?</sup></p>
<p><em>타입매개변수</em> :<br />
   <a href="items/../identifiers.html">식별자</a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>타입매개변수바운드</em></a><sup>?</sup> )<sup>?</sup> ( <code>=</code> <a href="items/../types.html#type-expressions"><em>타입</em></a> )<sup>?</sup></p>
<p><em>상수매개변수</em>:<br />
   <code>const</code> <a href="items/../identifiers.html">식별자</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>타입</em></a> ( <code>=</code> <em><a href="items/../expressions/block-expr.html">블록</a></em> | <a href="items/../identifiers.html">식별자</a> | -<sup>?</sup><a href="items/../expressions/literal-expr.html">리터럴</a> )<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-items.generics.syntax.intro"><a class="rule-link" href="items/generics.html#r-items.generics.syntax.intro" title="items.generics.syntax.intro"><span>[items<wbr>.generics<wbr>.syntax<wbr>.intro]<span/></a></div>
<p><a href="items/functions.html">함수</a>, <a href="items/type-aliases.html">타입 별칭</a>, <a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형</a>, <a href="items/unions.html">공용체</a>, <a href="items/traits.html">트레잇</a>, 그리고 <a href="items/implementations.html">구현</a>은 타입, 상수, 라이프타임에 의해 _매개변수화_될 수 있습니다. 이러한 매개변수들은 꺽쇠 <span class="parenthetical">괄호(<code>&lt;...&gt;</code>)</span> 안에 나열되며, 보통 아이템의 이름 바로 뒤이자 정의 앞에 위치합니다. 이름이 없는 구현의 경우, <code>impl</code> 바로 뒤에 옵니다.</p>
<div class="rule" id="r-items.generics.syntax.decl-order"><a class="rule-link" href="items/generics.html#r-items.generics.syntax.decl-order" title="items.generics.syntax.decl-order"><span>[items<wbr>.generics<wbr>.syntax<wbr>.decl-order]<span/></a></div>
<p>제네릭 매개변수의 순서는 라이프타임 매개변수가 먼저 오고, 그 뒤에 타입 매개변수와 상수 매개변수가 섞여서 오는 것으로 제한됩니다.</p>
<div class="rule" id="r-items.generics.syntax.duplicate-params"><a class="rule-link" href="items/generics.html#r-items.generics.syntax.duplicate-params" title="items.generics.syntax.duplicate-params"><span>[items<wbr>.generics<wbr>.syntax<wbr>.duplicate-params]<span/></a></div>
<p>동일한 매개변수 이름을 하나의 <em>제네릭매개변수들</em> 목록 내에서 두 번 이상 선언할 수 없습니다.</p>
<p>타입, 상수, 라이프타임 매개변수를 가진 아이템의 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, T&gt;() {}
trait A&lt;U&gt; {}
struct Ref&lt;'a, T&gt; where T: 'a { r: &amp;'a T }
struct InnerArray&lt;T, const N: usize&gt;([T; N]);
struct EitherOrderWorks&lt;const N: bool, U&gt;(U);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.syntax.scope"><a class="rule-link" href="items/generics.html#r-items.generics.syntax.scope" title="items.generics.syntax.scope"><span>[items<wbr>.generics<wbr>.syntax<wbr>.scope]<span/></a></div>
<p>제네릭 매개변수는 그것이 선언된 아이템 정의 내의 스코프에 있습니다. <a href="items/../statements.html#item-declarations">아이템 선언</a>에서 설명한 대로, 함수 본문 내에 선언된 아이템들에 대해서는 스코프에 있지 않습니다. 자세한 내용은 <a href="items/../names/scopes.html#generic-parameter-scopes">제네릭 매개변수 스코프</a>를 참조하세요.</p>
<div class="rule" id="r-items.generics.builtin-generic-types"><a class="rule-link" href="items/generics.html#r-items.generics.builtin-generic-types" title="items.generics.builtin-generic-types"><span>[items<wbr>.generics<wbr>.builtin-generic-types]<span/></a></div>
<p><a href="items/../types/pointer.html#shared-references-">참조</a>, <a href="items/../types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a>, <a href="items/../types/array.html">배열</a>, <a href="items/../types/slice.html">슬라이스</a>, <a href="items/../types/tuple.html">튜플</a>, 그리고 <a href="items/../types/function-pointer.html">함수 포인터</a> 또한 라이프타임 또는 타입 매개변수를 가지지만, 경로 구문을 통해 참조되지는 않습니다.</p>
<div class="rule" id="r-items.generics.invalid-lifetimes"><a class="rule-link" href="items/generics.html#r-items.generics.invalid-lifetimes" title="items.generics.invalid-lifetimes"><span>[items<wbr>.generics<wbr>.invalid-lifetimes]<span/></a></div>
<p><code>'_</code>와 <code>'static</code>은 유효한 라이프타임 매개변수 이름이 아닙니다.</p>
<div class="rule" id="r-items.generics.const"><a class="rule-link" href="items/generics.html#r-items.generics.const" title="items.generics.const"><span>[items<wbr>.generics<wbr>.const]<span/></a></div>
<h3 id="상수-제네릭"><a class="header" href="#상수-제네릭">상수 제네릭</a></h3>
<div class="rule" id="r-items.generics.const.intro"><a class="rule-link" href="items/generics.html#r-items.generics.const.intro" title="items.generics.const.intro"><span>[items<wbr>.generics<wbr>.const<wbr>.intro]<span/></a></div>
<p>_상수 제네릭 매개변수_를 통해 아이템이 상수 값에 대해 제네릭해질 수 있습니다.</p>
<div class="rule" id="r-items.generics.const.namespace"><a class="rule-link" href="items/generics.html#r-items.generics.const.namespace" title="items.generics.const.namespace"><span>[items<wbr>.generics<wbr>.const<wbr>.namespace]<span/></a></div>
<p>상수 식별자는 <a href="items/../names/namespaces.html">값 네임스페이스</a>에 상수 매개변수를 위한 이름을 도입하며, 해당 아이템의 모든 인스턴스는 주어진 타입의 값으로 인스턴스화되어야 합니다.</p>
<div class="rule" id="r-items.generics.const.allowed-types"><a class="rule-link" href="items/generics.html#r-items.generics.const.allowed-types" title="items.generics.const.allowed-types"><span>[items<wbr>.generics<wbr>.const<wbr>.allowed-types]<span/></a></div>
<p>상수 매개변수로 허용되는 타입은 <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>, <code>char</code> 그리고 <code>bool</code> 뿐입니다.</p>
<div class="rule" id="r-items.generics.const.usage"><a class="rule-link" href="items/generics.html#r-items.generics.const.usage" title="items.generics.const.usage"><span>[items<wbr>.generics<wbr>.const<wbr>.usage]<span/></a></div>
<p>상수 매개변수는 <a href="items/constant-items.html">상수 아이템</a>이 사용될 수 있는 모든 곳에서 사용될 수 있습니다. 단, <a href="items/../types.html">타입</a>이나 <a href="items/../expressions/array-expr.html">배열 반복 표현식</a>에서 사용될 때는 (아래에서 설명하듯이) 단독으로(standalone) 사용되어야 합니다. 즉, 다음과 같은 장소에서 허용됩니다.</p>
<ol>
<li>해당 아이템 시그니처의 일부를 형성하는 모든 타입에 적용된 상수로 사용될 때.</li>
<li><a href="items/associated-items.html#associated-constants">연관 상수</a>를 정의하는 데 사용되는 상수 표현식의 일부로 사용되거나, <a href="items/associated-items.html#associated-types">연관 타입</a>의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에 있는 모든 런타임 표현식의 값으로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에서 사용되는 모든 타입의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 필드의 타입의 일부로 사용될 때.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 있는 예시.

// 아이템 자체의 시그니처에서 사용됨.
fn foo&lt;const N: usize&gt;(arr: [i32; N]) {
    // 함수 본문 내에서 타입으로 사용됨.
    let x: [i32; N];
    // 표현식으로 사용됩니다.
    println!("{}", N * 2);
}

// 구조체의 필드로 사용됨.
struct Foo&lt;const N: usize&gt;([i32; N]);

impl&lt;const N: usize&gt; Foo&lt;N&gt; {
    // 연관 상수로 사용됨.
    const CONST: usize = N * 4;
}

trait Trait {
    type Output;
}

impl&lt;const N: usize&gt; Trait for Foo&lt;N&gt; {
    // 연관 타입으로 사용됨.
    type Output = [i32; N];
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 없는 예시.
fn foo&lt;const N: usize&gt;() {
    // 함수 본문 내의 아이템 정의에서는 사용할 수 없음.
    const BAD_CONST: [usize; N] = [1; N];
    static BAD_STATIC: [usize; N] = [1; N];
    fn inner(bad_arg: [usize; N]) {
        let bad_value = N * 2;
    }
    type BadAlias = [usize; N];
    struct BadStruct([usize; N]);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.const.standalone"><a class="rule-link" href="items/generics.html#r-items.generics.const.standalone" title="items.generics.const.standalone"><span>[items<wbr>.generics<wbr>.const<wbr>.standalone]<span/></a></div>
<p>추가적인 제약 사항으로, 상수 매개변수는 <a href="items/../types.html">타입</a>이나 <a href="items/../expressions/array-expr.html">배열 반복 표현식</a> 내부에서 오직 단독(standalone) 인수로만 나타날 수 있습니다. 이러한 컨텍스트에서 상수 매개변수는 오직 단일 세그먼트 <a href="items/../expressions/path-expr.html">경로 표현식</a>으로만 사용될 수 있으며, 필요한 경우 <a href="items/../expressions/block-expr.html">블록</a> 내부(예: <code>N</code> 또는 <code>{N}</code>)에 있을 수 있습니다. 즉, 다른 표현식과 결합될 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 매개변수를 사용할 수 없는 예시.

// 타입 내에서 다른 표현식과 결합하는 것은 허용되지 않습니다. 예를 들어
// 여기 반환 타입에 있는 산술 표현식과 같은 경우입니다.
fn bad_function&lt;const N: usize&gt;() -&gt; [u8; {N + 1}] {
    // 배열 반복 표현식에서도 마찬가지로 허용되지 않습니다.
    [1; {N + 1}]
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.const.argument"><a class="rule-link" href="items/generics.html#r-items.generics.const.argument" title="items.generics.const.argument"><span>[items<wbr>.generics<wbr>.const<wbr>.argument]<span/></a></div>
<p><a href="items/../paths.html">경로</a>에 있는 상수 인수는 해당 아이템에 사용할 상수 값을 지정합니다.</p>
<div class="rule" id="r-items.generics.const.argument.const-expr"><a class="rule-link" href="items/generics.html#r-items.generics.const.argument.const-expr" title="items.generics.const.argument.const-expr"><span>[items<wbr>.generics<wbr>.const<wbr>.argument<wbr>.const-expr]<span/></a></div>
<p>The argument must be a <a href="items/../const_eval.html#constant-expressions">const expression</a> of the type ascribed to the const parameter. The const expression must be a <a href="items/../expressions/block-expr.html">block expression</a> (surrounded with braces) unless it is a single path segment (an <a href="items/../identifiers.html">IDENTIFIER</a>) or a <a href="items/../expressions/literal-expr.html">literal</a> (with a possibly leading <code>-</code> token).</p>
<blockquote>
<p><strong>참고</strong>: 이 구문적 제약은 타입 내부에서 표현식을 파싱할 때 무한한 lookahead를 피하기 위해 필요합니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn double&lt;const N: i32&gt;() {
    println!("두 배: {}", N * 2);
}

const SOME_CONST: i32 = 12;

fn example() {
    // 상수 인수의 사용 예시.
    double::&lt;9&gt;();
    double::&lt;-123&gt;();
    double::&lt;{7 + 8}&gt;();
    double::&lt;SOME_CONST&gt;();
    double::&lt;{ SOME_CONST + 5 }&gt;();
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.const.type-ambiguity"><a class="rule-link" href="items/generics.html#r-items.generics.const.type-ambiguity" title="items.generics.const.type-ambiguity"><span>[items<wbr>.generics<wbr>.const<wbr>.type-ambiguity]<span/></a></div>
<p>제네릭 인수가 타입 인수와 상수 인수 중 어느 것으로도 해석될 수 있어 모호한 경우, 항상 타입으로 해석됩니다. 인수를 블록 표현식 안에 배치하면 강제로 상수 인수로 해석되게 할 수 있습니다.</p>
<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once
    namespaces are introduced, and it is clear which namespace each parameter
    lives in. -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type N = u32;
struct Foo&lt;const N: usize&gt;;
// 다음은 오류입니다. `N`이 타입 별칭 `N`으로 해석되기 때문입니다.
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // 오류
// 중괄호로 감싸서 강제로 상수 매개변수 `N`으로 해석되게 함으로써
// 해결할 수 있습니다.
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.const.variance"><a class="rule-link" href="items/generics.html#r-items.generics.const.variance" title="items.generics.const.variance"><span>[items<wbr>.generics<wbr>.const<wbr>.variance]<span/></a></div>
<p>타입 및 라이프타임 매개변수와 달리, 상수 매개변수는 <a href="items/implementations.html#generic-implementations">제네릭 구현</a>에서 설명한 구현의 경우를 제외하고는 매개변수화된 아이템 내부에서 사용되지 않고도 선언될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ok
struct Foo&lt;const N: usize&gt;;
enum Bar&lt;const M: usize&gt; { A, B }

// 오류: 사용되지 않은 매개변수
struct Baz&lt;T&gt;;
struct Biz&lt;'a&gt;;
struct Unconstrained;
impl&lt;const N: usize&gt; Unconstrained {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.const.exhaustiveness"><a class="rule-link" href="items/generics.html#r-items.generics.const.exhaustiveness" title="items.generics.const.exhaustiveness"><span>[items<wbr>.generics<wbr>.const<wbr>.exhaustiveness]<span/></a></div>
<p>트레잇 바운드 의무를 해결할 때, 바운드가 충족되는지 여부를 판단하기 위해 상수 매개변수의 모든 구현에 대한 완전성(exhaustiveness)은 고려되지 않습니다. 예를 들어, 다음 코드에서는 <code>bool</code> 타입에 대해 가능한 모든 상수 값들이 구현되었음에도 불구하고, 여전히 트레잇 바운드가 충족되지 않았다는 오류가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;const B: bool&gt;;
trait Bar {}
impl Bar for Foo&lt;true&gt; {}
impl Bar for Foo&lt;false&gt; {}

fn needs_bar(_: impl Bar) {}
fn generic&lt;const B: bool&gt;() {
    let v = Foo::&lt;B&gt;;
    needs_bar(v); // 오류: 트레잇 바운드 `Foo&lt;B&gt;: Bar`가 충족되지 않음
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.where"><a class="rule-link" href="items/generics.html#r-items.generics.where" title="items.generics.where"><span>[items<wbr>.generics<wbr>.where]<span/></a></div>
<h2 id="where-절"><a class="header" href="#where-절">Where 절</a></h2>
<div class="rule" id="r-items.generics.where.syntax"><a class="rule-link" href="items/generics.html#r-items.generics.where.syntax" title="items.generics.where.syntax"><span>[items<wbr>.generics<wbr>.where<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Where절</em> :<br />
   <code>where</code> ( <em>Where절항목</em> <code>,</code> )<sup>*</sup> <em>Where절항목</em> <sup>?</sup></p>
<p><em>Where절항목</em> :<br />
      <em>라이프타임Where절항목</em><br />
   | <em>타입바운드Where절항목</em></p>
<p><em>라이프타임Where절항목</em> :<br />
   <a href="items/../trait-bounds.html"><em>라이프타임</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>라이프타임바운드</em></a></p>
<p><em>타입바운드Where절항목</em> :<br />
   <a href="items/../trait-bounds.html#higher-ranked-trait-bounds"><em>For라이프타임</em></a><sup>?</sup> <a href="items/../types.html#type-expressions"><em>타입</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>타입매개변수바운드</em></a><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-items.generics.where.intro"><a class="rule-link" href="items/generics.html#r-items.generics.where.intro" title="items.generics.where.intro"><span>[items<wbr>.generics<wbr>.where<wbr>.intro]<span/></a></div>
<p>_Where 절_은 타입 및 라이프타임 매개변수에 대한 바운드를 지정하는 또 다른 방법이자, 타입 매개변수가 아닌 타입에 대해 바운드를 지정하는 방법을 제공합니다.</p>
<div class="rule" id="r-items.generics.where.higher-ranked-lifetimes"><a class="rule-link" href="items/generics.html#r-items.generics.where.higher-ranked-lifetimes" title="items.generics.where.higher-ranked-lifetimes"><span>[items<wbr>.generics<wbr>.where<wbr>.higher-ranked-lifetimes]<span/></a></div>
<p><code>for</code> 키워드는 <a href="items/../trait-bounds.html#higher-ranked-trait-bounds">고위 라이프타임(higher-ranked lifetimes)</a>을 도입하는 데 사용될 수 있습니다. 오직 <a href="items/generics.html#generic-parameters"><em>라이프타임매개변수</em></a>만 허용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt;
where
    T: Iterator,            // 대신 A&lt;T: Iterator&gt;를 사용할 수 있습니다.
    T::Item: Copy,          // 연관 타입에 대한 바운드
    String: PartialEq&lt;T&gt;,   // 타입 매개변수를 사용하여 `String`에 대한 바운드 지정
    i32: Default,           // 허용되지만 유용하지는 않음
{
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.generics.attributes"><a class="rule-link" href="items/generics.html#r-items.generics.attributes" title="items.generics.attributes"><span>[items<wbr>.generics<wbr>.attributes]<span/></a></div>
<h2 id="속성"><a class="header" href="#속성">속성</a></h2>
<p>제네릭 라이프타임 및 타입 매개변수에는 <a href="items/../attributes.html">속성</a>을 붙일 수 있습니다. 이 위치에서 무언가를 수행하는 내장 속성은 없지만, 커스텀 derive 속성이 여기에 의미를 부여할 수 있습니다.</p>
<p>이 예시는 커스텀 derive 속성을 사용하여 제네릭 매개변수의 의미를 수정하는 방법을 보여줍니다.</p>
<!-- ignore: requires proc macro derive -->
<pre><code class="language-rust ignore">// MyFlexibleClone에 대한 derive가 `my_flexible_clone`을 이해할 수 있는
// 속성으로 선언했다고 가정합니다.
#[derive(MyFlexibleClone)]
struct Foo&lt;#[my_flexible_clone(unbounded)] H&gt; {
    a: *const H
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-items.associated"><a class="rule-link" href="items/associated-items.html#r-items.associated" title="items.associated"><span>[items<wbr>.associated]<span/></a></div>
<h1 id="연관-아이템"><a class="header" href="#연관-아이템">연관 아이템</a></h1>
<div class="rule" id="r-items.associated.syntax"><a class="rule-link" href="items/associated-items.html#r-items.associated.syntax" title="items.associated.syntax"><span>[items<wbr>.associated<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>연관아이템</em> :<br />
   <a href="items/../attributes.html"><em>외부속성</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>세미콜론매크로호출</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>가시성</em></a><sup>?</sup> ( <a href="items/type-aliases.html"><em>타입별칭</em></a> | <a href="items/constant-items.html"><em>상수아이템</em></a> | <a href="items/functions.html"><em>함수</em></a> ) )<br />
   )</p>
</blockquote>
<div class="rule" id="r-items.associated.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.intro" title="items.associated.intro"><span>[items<wbr>.associated<wbr>.intro]<span/></a></div>
<p>_연관 아이템(Associated Items)_은 <a href="items/traits.html">트레잇</a>에 선언되거나 <a href="items/implementations.html">구현</a>에 정의된 아이템들을 말합니다. 연관 아이템이라고 불리는 이유는 그것들이 연관된 타입 — 즉 구현 내의 타입 — 에 정의되기 때문입니다.</p>
<div class="rule" id="r-items.associated.kinds"><a class="rule-link" href="items/associated-items.html#r-items.associated.kinds" title="items.associated.kinds"><span>[items<wbr>.associated<wbr>.kinds]<span/></a></div>
<p>이들은 모듈에서 선언할 수 있는 아이템 종류의 하위 집합입니다. 구체적으로 <a href="items/associated-items.html#associated-functions-and-methods">연관 함수</a>(메서드 포함), <a href="items/associated-items.html#associated-types">연관 타입</a>, 그리고 <a href="items/associated-items.html#associated-constants">연관 상수</a>가 있습니다.</p>
<div class="rule" id="r-items.associated.related"><a class="rule-link" href="items/associated-items.html#r-items.associated.related" title="items.associated.related"><span>[items<wbr>.associated<wbr>.related]<span/></a></div>
<p>연관 아이템은 해당 아이템이 논리적으로 다음 대상과 관련이 있을 때 유용합니다. 예를 들어, <code>Option</code>의 <code>is_some</code> 메서드는 본질적으로 Option과 관련이 있으므로 연관되어야 합니다.</p>
<div class="rule" id="r-items.associated.decl-def"><a class="rule-link" href="items/associated-items.html#r-items.associated.decl-def" title="items.associated.decl-def"><span>[items<wbr>.associated<wbr>.decl-def]<span/></a></div>
<p>모든 종류의 연관 아이템은 두 가지 변형으로 제공됩니다: 실제 구현을 포함하는 정의(definitions)와 정의를 위한 시그니처를 선언하는 선언(declarations)입니다.</p>
<div class="rule" id="r-items.associated.trait-items"><a class="rule-link" href="items/associated-items.html#r-items.associated.trait-items" title="items.associated.trait-items"><span>[items<wbr>.associated<wbr>.trait-items]<span/></a></div>
<p>트레잇의 계약을 구성하고 제네릭 타입에서 무엇을 사용할 수 있는지를 결정하는 것은 바로 선언입니다.</p>
<div class="rule" id="r-items.associated.fn"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn" title="items.associated.fn"><span>[items<wbr>.associated<wbr>.fn]<span/></a></div>
<h2 id="연관-함수와-메서드"><a class="header" href="#연관-함수와-메서드">연관 함수와 메서드</a></h2>
<div class="rule" id="r-items.associated.fn.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.intro" title="items.associated.fn.intro"><span>[items<wbr>.associated<wbr>.fn<wbr>.intro]<span/></a></div>
<p>_연관 함수_는 타입과 연관된 <a href="items/functions.html">함수</a>입니다.</p>
<div class="rule" id="r-items.associated.fn.decl"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.decl" title="items.associated.fn.decl"><span>[items<wbr>.associated<wbr>.fn<wbr>.decl]<span/></a></div>
<p>_연관 함수 선언_은 연관 함수 정의를 위한 시그니처를 선언합니다. 함수 본문이 <code>;</code>로 대체된다는 점을 제외하면 함수 아이템과 동일하게 작성됩니다.</p>
<div class="rule" id="r-items.associated.name"><a class="rule-link" href="items/associated-items.html#r-items.associated.name" title="items.associated.name"><span>[items<wbr>.associated<wbr>.name]<span/></a></div>
<p>식별자는 함수의 이름입니다.</p>
<div class="rule" id="r-items.associated.same-signature"><a class="rule-link" href="items/associated-items.html#r-items.associated.same-signature" title="items.associated.same-signature"><span>[items<wbr>.associated<wbr>.same-signature]<span/></a></div>
<p>연관 함수의 제네릭, 매개변수 목록, 반환 타입, 그리고 Where 절은 연관 함수 선언과 동일해야 합니다.</p>
<div class="rule" id="r-items.associated.fn.def"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.def" title="items.associated.fn.def"><span>[items<wbr>.associated<wbr>.fn<wbr>.def]<span/></a></div>
<p>_연관 함수 정의_는 다른 타입과 연관된 함수를 정의합니다. <a href="items/../types/function-item.html">함수 아이템</a>과 동일하게 작성됩니다.</p>
<p>일반적인 연관 함수의 예로, 연관 함수가 연결된 타입의 값을 반환하는 <code>new</code> 함수가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}</code></pre></pre>
<div class="rule" id="r-items.associated.fn.qualified-self"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.qualified-self" title="items.associated.fn.qualified-self"><span>[items<wbr>.associated<wbr>.fn<wbr>.qualified-self]<span/></a></div>
<p>연관 함수가 트레잇에 선언된 경우, 해당 함수는 트레잇으로의 경로 뒤에 트레잇 이름이 붙은 <a href="items/../paths.html">경로</a>로도 호출될 수 있습니다. 이 경우, <code>&lt;_ as Trait&gt;::function_name</code>으로 대체됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// 이 경우 이 4가지는 모두 동일합니다.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.associated.fn.method"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.method" title="items.associated.fn.method"><span>[items<wbr>.associated<wbr>.fn<wbr>.method]<span/></a></div>
<h3 id="메서드"><a class="header" href="#메서드">메서드</a></h3>
<div class="rule" id="r-items.associated.fn.method.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.method.intro" title="items.associated.fn.method.intro"><span>[items<wbr>.associated<wbr>.fn<wbr>.method<wbr>.intro]<span/></a></div>
<p>첫 번째 매개변수의 이름이 <code>self</code>인 연관 함수를 _메서드_라고 하며, <a href="items/../expressions/method-call-expr.html">메서드 호출 연산자</a>(예: <code>x.foo()</code>)를 사용하거나 일반적인 함수 호출 표기법을 사용하여 호출할 수 있습니다.</p>
<div class="rule" id="r-items.associated.fn.method.self-ty"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.method.self-ty" title="items.associated.fn.method.self-ty"><span>[items<wbr>.associated<wbr>.fn<wbr>.method<wbr>.self-ty]<span/></a></div>
<p><code>self</code> 매개변수의 타입이 지정된 경우, 다음 문법에 의해 생성된 타입 중 하나로 해석되는 타입으로 제한됩니다(여기서 <code>'lt</code>는 임의의 라이프타임을 나타냄):</p>
<pre><code class="language-text">P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</code></pre>
<p>이 문법에서 <code>Self</code> 터미널(terminal)은 구현 타입으로 해석되는 타입을 나타냅니다. 여기에는 문맥적 타입 별칭 <code>Self</code>, 다른 타입 별칭, 또는 구현 타입으로 해석되는 연관 타입 투영(associated type projections)이 포함될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// `Example` 구조체에 구현된 메서드의 예시.
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-associated.fn.method.self-pat-shorthands"><a class="rule-link" href="items/associated-items.html#r-associated.fn.method.self-pat-shorthands" title="associated.fn.method.self-pat-shorthands"><span>[associated<wbr>.fn<wbr>.method<wbr>.self-pat-shorthands]<span/></a></div>
<p>타입을 지정하지 않고 단축 구문을 사용할 수 있으며, 이는 다음과 동일합니다:</p>
<div class="table-wrapper"><table><thead><tr><th>단축 구문</th><th>동등한 표현</th></tr></thead><tbody>
<tr><td><code>self</code></td><td><code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code></td><td><code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code></td><td><code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>: 이 단축 구문을 사용하면 라이프타임이 생략될 수 있으며, 보통 생략됩니다.</p>
</blockquote>
<div class="rule" id="r-associated.fn.method.self-pat-mut"><a class="rule-link" href="items/associated-items.html#r-associated.fn.method.self-pat-mut" title="associated.fn.method.self-pat-mut"><span>[associated<wbr>.fn<wbr>.method<wbr>.self-pat-mut]<span/></a></div>
<p><code>self</code> 매개변수 앞에 <code>mut</code>가 붙으면, <code>mut</code> <a href="items/../patterns.html#identifier-patterns">식별자 패턴</a>을 사용하는 일반 매개변수와 마찬가지로 가변 변수가 됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
<span class="boring">}</span></code></pre></pre>
<p>트레잇의 메서드 예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
<span class="boring">}</span></code></pre></pre>
<p>이것은 두 개의 메서드를 가진 트레잇을 정의합니다. 트레잇이 스코프 내에 있는 동안 이 트레잇의 <a href="items/implementations.html">구현</a>을 가진 모든 값은 <code>draw</code> 및 <code>bounding_box</code> 메서드를 호출할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span><span class="boring">trait Shape {
</span><span class="boring">    fn draw(&amp;self, surface: Surface);
</span><span class="boring">    fn bounding_box(&amp;self) -&gt; BoundingBox;
</span><span class="boring">}
</span><span class="boring">
</span>struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
<span class="boring">  fn draw(&amp;self, _: Surface) {}
</span><span class="boring">  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
</span>}

<span class="boring">impl Circle {
</span><span class="boring">    fn new() -&gt; Circle { Circle{} }
</span><span class="boring">}
</span><span class="boring">
</span>let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.associated.fn.params.edition2015"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.params.edition2015" title="items.associated.fn.params.edition2015"><span>[items<wbr>.associated<wbr>.fn<wbr>.params<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서는 익명 매개변수(예: <code>fn foo(u8)</code>)로 트레잇 메서드를 선언하는 것이 가능했습니다. 이는 2018 에디션부터 사용 중단(deprecated)되었으며 오류입니다. 모든 매개변수는 인수 이름을 가져야 합니다.</p>
</blockquote>
<div class="rule" id="r-items.associated.fn.param-attributes"><a class="rule-link" href="items/associated-items.html#r-items.associated.fn.param-attributes" title="items.associated.fn.param-attributes"><span>[items<wbr>.associated<wbr>.fn<wbr>.param-attributes]<span/></a></div>
<h4 id="메서드-매개변수의-속성"><a class="header" href="#메서드-매개변수의-속성">메서드 매개변수의 속성</a></h4>
<p>메서드 매개변수의 속성은 <a href="items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>
<div class="rule" id="r-items.associated.type"><a class="rule-link" href="items/associated-items.html#r-items.associated.type" title="items.associated.type"><span>[items<wbr>.associated<wbr>.type]<span/></a></div>
<h2 id="연관-타입"><a class="header" href="#연관-타입">연관 타입</a></h2>
<div class="rule" id="r-items.associated.type.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.intro" title="items.associated.type.intro"><span>[items<wbr>.associated<wbr>.type<wbr>.intro]<span/></a></div>
<p>_연관 타입_은 다른 타입과 연관된 <a href="items/type-aliases.html">타입 별칭</a>입니다.</p>
<div class="rule" id="r-items.associated.type.restrictions"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.restrictions" title="items.associated.type.restrictions"><span>[items<wbr>.associated<wbr>.type<wbr>.restrictions]<span/></a></div>
<p>연관 타입은 <a href="items/implementations.html#inherent-implementations">고유 구현</a>에서 정의될 수 없으며 트레잇에서 기본 구현을 가질 수도 없습니다.</p>
<div class="rule" id="r-items.associated.type.decl"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.decl" title="items.associated.type.decl"><span>[items<wbr>.associated<wbr>.type<wbr>.decl]<span/></a></div>
<p>_연관 타입 선언_은 연관 타입 정의를 위한 시그니처를 선언합니다. 다음 형식 중 하나로 작성되며, <code>Assoc</code>은 연관 타입의 이름, <code>Params</code>는 쉼표로 구분된 타입, 라이프타임 또는 상수 매개변수 목록, <code>Bounds</code>는 연관 타입이 충족해야 하는 더하기로 구분된 트레잇 바운드 목록, <code>WhereBounds</code>는 매개변수가 충족해야 하는 쉼표로 구분된 바운드 목록입니다:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc;
type Assoc: Bounds;
type Assoc&lt;Params&gt;;
type Assoc&lt;Params&gt;: Bounds;
type Assoc&lt;Params&gt; where WhereBounds;
type Assoc&lt;Params&gt;: Bounds where WhereBounds;</code></pre>
<div class="rule" id="r-items.associated.type.name"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.name" title="items.associated.type.name"><span>[items<wbr>.associated<wbr>.type<wbr>.name]<span/></a></div>
<p>식별자는 선언된 타입 별칭의 이름입니다.</p>
<div class="rule" id="r-items.associated.type.impl-fulfillment"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.impl-fulfillment" title="items.associated.type.impl-fulfillment"><span>[items<wbr>.associated<wbr>.type<wbr>.impl-fulfillment]<span/></a></div>
<p>선택적 트레잇 바운드는 타입 별칭의 구현에 의해 충족되어야 합니다.</p>
<div class="rule" id="r-items.associated.type.sized"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.sized" title="items.associated.type.sized"><span>[items<wbr>.associated<wbr>.type<wbr>.sized]<span/></a></div>
<p>연관 타입에는 암시적인 <a href="items/../special-types-and-traits.html#sized"><code>Sized</code></a> 바운드가 있으며, 이는 특수한 <code>?Sized</code> 바운드를 사용하여 완화할 수 있습니다.</p>
<div class="rule" id="r-items.associated.type.def"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.def" title="items.associated.type.def"><span>[items<wbr>.associated<wbr>.type<wbr>.def]<span/></a></div>
<p>_연관 타입 정의_는 타입에 대한 트레잇 구현을 위한 타입 별칭을 정의합니다.</p>
<div class="rule" id="r-items.associated.type.def.restriction"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.def.restriction" title="items.associated.type.def.restriction"><span>[items<wbr>.associated<wbr>.type<wbr>.def<wbr>.restriction]<span/></a></div>
<p>이들은 _연관 타입 선언_과 유사하게 작성되지만, <code>Bounds</code>를 포함할 수 없고 대신 <code>Type</code>을 포함해야 합니다:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc = Type;
type Assoc&lt;Params&gt; = Type; // 여기서 `Type` 타입은 `Params`를 참조할 수 있습니다
type Assoc&lt;Params&gt; = Type where WhereBounds;
type Assoc&lt;Params&gt; where WhereBounds = Type; // 사용 중단됨(deprecated), 위의 형식을 선호하세요</code></pre>
<div class="rule" id="r-items.associated.type.alias"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.alias" title="items.associated.type.alias"><span>[items<wbr>.associated<wbr>.type<wbr>.alias]<span/></a></div>
<p>타입 <code>Item</code>이 트레잇 <code>Trait</code>으로부터 연관 타입 <code>Assoc</code>을 가진다면, <code>&lt;Item as Trait&gt;::Assoc</code>은 연관 타입 정의에 명시된 타입의 별칭인 타입입니다.</p>
<div class="rule" id="r-items.associated.type.param"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.param" title="items.associated.type.param"><span>[items<wbr>.associated<wbr>.type<wbr>.param]<span/></a></div>
<p>또한, <code>Item</code>이 타입 매개변수인 경우, <code>Item::Assoc</code>은 타입 매개변수 내에서 사용될 수 있습니다.</p>
<div class="rule" id="r-items.associated.type.generic"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic" title="items.associated.type.generic"><span>[items<wbr>.associated<wbr>.type<wbr>.generic]<span/></a></div>
<p>연관 타입은 <a href="items/generics.html">제네릭 매개변수</a>와 <a href="items/generics.html#where-clauses">where 절</a>을 포함할 수 있습니다. 이들은 종종 <em>제네릭 연관 타입(generic associated types)</em> 또는 _GAT_라고 불립니다. 타입 <code>Thing</code>이 제네릭 <code>&lt;'a&gt;</code>를 가진 트레잇 <code>Trait</code>으로부터 연관 타입 <code>Item</code>을 가진다면, 이 타입은 <code>&lt;Thing as Trait&gt;::Item&lt;'x&gt;</code>와 같이 명명될 수 있으며, 여기서 <code>'x</code>는 스코프 내의 어떤 라이프타임입니다. 이 경우, 구현(impl)의 연관 타입 정의에서 <code>'a</code>가 나타나는 모든 곳에 <code>'x</code>가 사용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait AssociatedType {
    // 연관 타입 선언
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // 연관 타입 정의
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // &lt;Struct as AssociatedType&gt;::Assoc와 같이 OtherStruct를 참조하기 위해 연관 타입을 사용함
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}</code></pre></pre>
<p>제네릭과 where 절을 사용한 연관 타입의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct ArrayLender&lt;'a, T&gt;(&amp;'a mut [T; 16]);

trait Lend {
    // 제네릭 연관 타입 선언
    type Lender&lt;'a&gt; where Self: 'a;
    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt;;
}

impl&lt;T&gt; Lend for [T; 16] {
    // 제네릭 연관 타입 정의
    type Lender&lt;'a&gt; = ArrayLender&lt;'a, T&gt; where Self: 'a;

    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt; {
        ArrayLender(self)
    }
}

fn borrow&lt;'a, T: Lend&gt;(array: &amp;'a mut T) -&gt; &lt;T as Lend&gt;::Lender&lt;'a&gt; {
    array.lend()
}

fn main() {
    let mut array = [0usize; 16];
    let lender = borrow(&amp;mut array);
}</code></pre></pre>
<h3 id="연관-타입-컨테이너-예시"><a class="header" href="#연관-타입-컨테이너-예시">연관 타입 컨테이너 예시</a></h3>
<p>다음 <code>Container</code> 트레잇 예시를 고려해 보세요. 해당 타입이 메서드 시그니처에서 사용 가능하다는 점에 주목하세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}</span></code></pre></pre>
<p>어떤 타입이 이 트레잇을 구현하기 위해서는, 모든 메서드에 대한 구현을 제공해야 할 뿐만 아니라 타입 <code>E</code>를 명시해야 합니다. 다음은 표준 라이브러리 타입 <code>Vec</code>에 대한 <code>Container</code> 구현입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Container {
</span><span class="boring">    type E;
</span><span class="boring">    fn empty() -&gt; Self;
</span><span class="boring">    fn insert(&amp;mut self, elem: Self::E);
</span><span class="boring">}
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounds와-wherebounds-사이의-관계"><a class="header" href="#bounds와-wherebounds-사이의-관계"><code>Bounds</code>와 <code>WhereBounds</code> 사이의 관계</a></h3>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;X as Example&gt;::Output&lt;Y&gt;</code>와 같은 연관 타입에 대한 참조가 주어지면, 연관 타입 자체는 반드시 <code>Ord</code>여야 하고, 타입 <code>Y</code>는 반드시 <code>Debug</code>여야 합니다.</p>
<div class="rule" id="r-items.associated.type.generic-where-clause"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause" title="items.associated.type.generic-where-clause"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause]<span/></a></div>
<h3 id="제네릭-연관-타입에-요구되는-where-절"><a class="header" href="#제네릭-연관-타입에-요구되는-where-절">제네릭 연관 타입에 요구되는 where 절</a></h3>
<div class="rule" id="r-items.associated.type.generic-where-clause.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause.intro" title="items.associated.type.generic-where-clause.intro"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause<wbr>.intro]<span/></a></div>
<p>트레잇의 제네릭 연관 타입 선언은 현재 트레잇의 함수들과 GAT가 어떻게 사용되는지에 따라 where 절 목록을 요구할 수 있습니다. 이러한 규칙들은 미래에 완화될 수 있습니다. 업데이트는 <a href="https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html">제네릭 연관 타입 이니셔티브 저장소</a>에서 확인할 수 있습니다.</p>
<div class="rule" id="r-items.associated.type.generic-where-clause.valid-fn"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause.valid-fn" title="items.associated.type.generic-where-clause.valid-fn"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause<wbr>.valid-fn]<span/></a></div>
<p>간단히 말해서, 이러한 where 절은 구현(impl)에서 연관 타입의 허용되는 정의를 최대화하기 위해 필요합니다. 이를 위해, GAT가 입력 또는 출력으로 나타나는 함수에서 (함수나 트레잇의 매개변수를 사용하여) <em>성립한다고 증명될 수 있는</em> 모든 절은 GAT 자체에도 작성되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'x&gt; where Self: 'x;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>위의 <code>next</code> 함수에서, <code>&amp;'a mut self</code>로부터 암시된 바운드 덕분에 <code>Self: 'a</code>임을 증명할 수 있습니다. 따라서 GAT 자체에 동일한 바운드인 <code>where Self: 'x</code>를 작성해야 합니다.</p>
<div class="rule" id="r-items.associated.type.generic-where-clause.intersection"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause.intersection" title="items.associated.type.generic-where-clause.intersection"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause<wbr>.intersection]<span/></a></div>
<p>트레잇에 GAT를 사용하는 함수가 여러 개 있는 경우, 합집합이 아닌 각 함수의 바운드들의 _교집합_이 사용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Check&lt;T&gt; {
    type Checker&lt;'x&gt;;
    fn create_checker&lt;'a&gt;(item: &amp;'a T) -&gt; Self::Checker&lt;'a&gt;;
    fn do_check(checker: Self::Checker&lt;'_&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시에서는 <code>type Checker&lt;'a&gt;;</code>에 아무런 바운드가 요구되지 않습니다. <code>create_checker</code>에서는 <code>T: 'a</code>임을 알 수 있지만, <code>do_check</code>에서는 이를 알 수 없기 때문입니다. 하지만 만약 <code>do_check</code>가 주석 처리된다면, <code>Checker</code>에 <code>where T: 'x</code> 바운드가 요구될 것입니다.</p>
<div class="rule" id="r-items.associated.type.generic-where-clause.forward"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause.forward" title="items.associated.type.generic-where-clause.forward"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause<wbr>.forward]<span/></a></div>
<p>연관 타입에 대한 바운드는 요구되는 where 절을 전파하기도 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt; where Self: 'a;
    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt; where Self: 'a;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>iter</code> 때문에 <code>Item</code>에 <code>where Self: 'a</code>가 요구됩니다. 그런데 <code>Item</code>이 <code>Iterator</code>의 바운드에서 사용되므로, <code>where Self: 'a</code> 절이 거기서도 요구됩니다.</p>
<div class="rule" id="r-items.associated.type.generic-where-clause.static"><a class="rule-link" href="items/associated-items.html#r-items.associated.type.generic-where-clause.static" title="items.associated.type.generic-where-clause.static"><span>[items<wbr>.associated<wbr>.type<wbr>.generic-where-clause<wbr>.static]<span/></a></div>
<p>마지막으로, 트레잇의 GAT에서 <code>'static</code>을 명시적으로 사용하는 것은 요구되는 바운드에 포함되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StaticReturn {
    type Y&lt;'a&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.associated.const"><a class="rule-link" href="items/associated-items.html#r-items.associated.const" title="items.associated.const"><span>[items<wbr>.associated<wbr>.const]<span/></a></div>
<h2 id="연관-상수"><a class="header" href="#연관-상수">연관 상수</a></h2>
<div class="rule" id="r-items.associated.const.intro"><a class="rule-link" href="items/associated-items.html#r-items.associated.const.intro" title="items.associated.const.intro"><span>[items<wbr>.associated<wbr>.const<wbr>.intro]<span/></a></div>
<p>_연관 상수_는 타입과 연관된 <a href="items/constant-items.html">상수</a>입니다.</p>
<div class="rule" id="r-items.associated.const.decl"><a class="rule-link" href="items/associated-items.html#r-items.associated.const.decl" title="items.associated.const.decl"><span>[items<wbr>.associated<wbr>.const<wbr>.decl]<span/></a></div>
<p>_연관 상수 선언_은 연관 상수 정의를 위한 시그니처를 선언합니다. <code>const</code>, 식별자, <code>:</code>, 타입 순으로 작성하고 <code>;</code>로 마칩니다.</p>
<div class="rule" id="r-items.associated.const.name"><a class="rule-link" href="items/associated-items.html#r-items.associated.const.name" title="items.associated.const.name"><span>[items<wbr>.associated<wbr>.const<wbr>.name]<span/></a></div>
<p>식별자는 경로에서 사용되는 상수의 이름입니다. 타입은 정의에서 구현해야 하는 타입입니다.</p>
<div class="rule" id="r-items.associated.const.def"><a class="rule-link" href="items/associated-items.html#r-items.associated.const.def" title="items.associated.const.def"><span>[items<wbr>.associated<wbr>.const<wbr>.def]<span/></a></div>
<p>_연관 상수 정의_는 타입과 연관된 상수를 정의합니다. <a href="items/constant-items.html">상수 아이템</a>과 동일하게 작성됩니다.</p>
<div class="rule" id="r-items.associated.const.eval"><a class="rule-link" href="items/associated-items.html#r-items.associated.const.eval" title="items.associated.const.eval"><span>[items<wbr>.associated<wbr>.const<wbr>.eval]<span/></a></div>
<p>연관 상수 정의는 참조될 때만 <a href="items/../const_eval.html">상수 평가</a>를 거칩니다. 또한, <a href="items/generics.html">제네릭 매개변수</a>를 포함하는 정의는 모노모르포화(monomorphization) 후에 평가됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Struct;
struct GenericStruct&lt;const ID: i32&gt;;

impl Struct {
    // 정의가 즉시 평가되지 않음
    const PANIC: () = panic!("컴파일 타임 패닉");
}

impl&lt;const ID: i32&gt; GenericStruct&lt;ID&gt; {
    // 정의가 즉시 평가되지 않음
    const NON_ZERO: () = if ID == 0 {
        panic!("모순")
    };
}

fn main() {
    // Struct::PANIC을 참조하면 컴파일 오류가 발생함
    let _ = Struct::PANIC;

    // 괜찮음, ID가 0이 아님
    let _ = GenericStruct::&lt;1&gt;::NON_ZERO;

    // ID=0으로 NON_ZERO를 평가할 때 발생하는 컴파일 오류
    let _ = GenericStruct::&lt;0&gt;::NON_ZERO;
}</code></pre></pre>
<h3 id="연관-상수-예시"><a class="header" href="#연관-상수-예시">연관 상수 예시</a></h3>
<p>기본 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}</code></pre></pre>
<p>기본값 사용하기:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
(function() {
    var fragments = {
        "#cold-attribute": "attributes/codegen.html#the-cold-attribute",
        "#conditional-compilation": "conditional-compilation.html",
        "#deprecation": "attributes/diagnostics.html#the-deprecated-attribute",
        "#derive": "attributes/derive.html",
        "#documentation": "../rustdoc/the-doc-attribute.html",
        "#ffi-attributes": "attributes.html#built-in-attributes-index",
        "#inline-attribute": "attributes/codegen.html#the-inline-attribute",
        "#lint-check-attributes": "attributes/diagnostics.html#lint-check-attributes",
        "#macro-related-attributes": "attributes.html#built-in-attributes-index",
        "#miscellaneous-attributes": "attributes.html#built-in-attributes-index",
        "#must_use": "attributes/diagnostics.html#the-must_use-attribute",
        "#optimization-hints": "attributes/codegen.html#optimization-hints",
        "#path": "items/modules.html#the-path-attribute",
        "#preludes": "crates-and-source-files.html#preludes-and-no_std",
        "#testing": "attributes/testing.html",
        "#tool-lint-attributes": "attributes/diagnostics.html#tool-lint-attributes",
        "#crate-only-attributes": "attributes.html#built-in-attributes-index",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<h1 id="속성-1"><a class="header" href="#속성-1">속성</a></h1>
<div class="rule" id="r-attributes.syntax"><a class="rule-link" href="attributes.html#r-attributes.syntax" title="attributes.syntax"><span>[attributes<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>내부속성</em> :<br />
   <code>#</code> <code>!</code> <code>[</code> <em>속성</em> <code>]</code></p>
<p><em>외부속성</em> :<br />
   <code>#</code> <code>[</code> <em>속성</em> <code>]</code></p>
<p><em>속성</em> :<br />
      <a href="paths.html#simple-paths"><em>단순경로</em></a> <em>속성입력</em><sup>?</sup><br />
   | <code>unsafe</code> <code>(</code> <a href="paths.html#simple-paths"><em>단순경로</em></a> <em>속성입력</em><sup>?</sup> <code>)</code></p>
<p><em>속성입력</em> :<br />
      <a href="macros.html"><em>구분된토큰트리</em></a><br />
   | <code>=</code> <a href="expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-attributes.intro"><a class="rule-link" href="attributes.html#r-attributes.intro" title="attributes.intro"><span>[attributes<wbr>.intro]<span/></a></div>
<p>_속성(attribute)_은 이름, 관례, 언어, 컴파일러 버전에 따라 해석되는 일반적이고 자유로운 형식의 메타데이터입니다. 속성은 <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">ECMA-335</a>의 속성을 모델로 하며, 구문은 <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-334/">ECMA-334</a>(C#)에서 유래했습니다.</p>
<div class="rule" id="r-attributes.inner"><a class="rule-link" href="attributes.html#r-attributes.inner" title="attributes.inner"><span>[attributes<wbr>.inner]<span/></a></div>
<p>해시(<code>#</code>) 뒤에 느낌표(<code>!</code>)를 붙여 작성하는 _내부 속성_은 속성이 선언된 아이템 내부에 적용됩니다. 해시 뒤에 느낌표 없이 작성하는 _외부 속성_은 속성 뒤에 오는 대상에 적용됩니다.</p>
<div class="rule" id="r-attributes.input"><a class="rule-link" href="attributes.html#r-attributes.input" title="attributes.input"><span>[attributes<wbr>.input]<span/></a></div>
<p>속성은 속성으로의 경로와, 속성에 의해 해석이 정의되는 선택적인 구분된 토큰 트리로 구성됩니다. 매크로 속성을 제외한 속성들은 등호(<code>=</code>) 뒤에 표현식이 오는 입력도 허용합니다. 자세한 내용은 아래의 <a href="attributes.html#meta-item-attribute-syntax">메타 아이템 구문</a>을 참조하세요.</p>
<div class="rule" id="r-attributes.safety"><a class="rule-link" href="attributes.html#r-attributes.safety" title="attributes.safety"><span>[attributes<wbr>.safety]<span/></a></div>
<p>어떤 속성은 적용하기에 안전하지(unsafe) 않을 수 있습니다. 이러한 속성을 사용할 때 정의되지 않은 동작을 피하기 위해, 컴파일러가 확인할 수 없는 특정 의무사항들을 준수해야 합니다. 이러한 사항들이 준수되었음을 단언하기 위해, 속성을 <code>unsafe(..)</code>로 감쌉니다. 예: <code>#[unsafe(no_mangle)]</code>.</p>
<p>다음 속성들은 안전하지 않습니다:</p>
<ul>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a></li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a></li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a></li>
</ul>
<div class="rule" id="r-attributes.kind"><a class="rule-link" href="attributes.html#r-attributes.kind" title="attributes.kind"><span>[attributes<wbr>.kind]<span/></a></div>
<p>속성은 다음과 같은 종류로 분류될 수 있습니다:</p>
<ul>
<li><a href="attributes.html#built-in-attributes-index">내장 속성</a></li>
<li><a href="procedural-macros.html#attribute-macros">절차적 매크로 속성</a></li>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">Derive 매크로 도우미 속성</a></li>
<li><a href="attributes.html#tool-attributes">도구 속성</a></li>
</ul>
<div class="rule" id="r-attributes.allowed-position"><a class="rule-link" href="attributes.html#r-attributes.allowed-position" title="attributes.allowed-position"><span>[attributes<wbr>.allowed-position]<span/></a></div>
<p>속성은 언어의 많은 요소에 적용될 수 있습니다:</p>
<ul>
<li>모든 <a href="items.html">아이템 선언</a>은 외부 속성을 허용하며, <a href="items/external-blocks.html">외부 블록</a>, <a href="items/functions.html">함수</a>, <a href="items/implementations.html">구현</a>, <a href="items/modules.html">모듈</a>은 내부 속성을 허용합니다.</li>
<li>대부분의 <a href="statements.html">구문</a>은 외부 속성을 허용합니다 (표현식 구문에 대한 제약 사항은 <a href="expressions.html#expression-attributes">표현식 속성</a>을 참조하세요).</li>
<li><a href="expressions/block-expr.html">블록 표현식</a>은 외부 및 내부 속성을 허용하지만, <a href="statements.html#expression-statements">표현식 구문</a>의 외부 표현식이거나 다른 블록 표현식의 마지막 표현식인 경우에만 해당합니다.</li>
<li><a href="items/enumerations.html">열거형</a> 변형과 <a href="items/structs.html">구조체</a> 및 <a href="items/unions.html">공용체</a> 필드는 외부 속성을 허용합니다.</li>
<li><a href="expressions/match-expr.html">매치 표현식 암(Match expression arms)</a>은 외부 속성을 허용합니다.</li>
<li><a href="items/generics.html">제네릭 라이프타임 또는 타입 매개변수</a>는 외부 속성을 허용합니다.</li>
<li>표현식은 제한적인 상황에서 외부 속성을 허용합니다. 자세한 내용은 <a href="expressions.html#expression-attributes">표현식 속성</a>을 참조하세요.</li>
<li><a href="items/functions.html">함수</a>, <a href="expressions/closure-expr.html">클로저</a> 및 <a href="types/function-pointer.html">함수 포인터</a> 매개변수는 외부 속성을 허용합니다. 여기에는 함수 포인터와 <a href="items/external-blocks.html#variadic-functions">외부 블록</a>에서 <code>...</code>로 표시된 가변 매개변수에 대한 속성도 포함됩니다.</li>
</ul>
<p>속성의 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 둘러싼 모듈이나 크레이트에 적용되는 일반 메타데이터입니다.
#![crate_type = "lib"]

// 유닛 테스트로 표시된 함수입니다.
#[test]
fn test_foo() {
    /* ... */
}

// 조건부 컴파일되는 모듈입니다.
#[cfg(target_os = "linux")]
mod bar {
    /* ... */
}

// 경고/오류를 억제하기 위해 사용되는 린트(lint) 속성입니다.
#[allow(non_camel_case_types)]
type int8_t = i8;

// 내부 속성은 함수 전체에 적용됩니다.
fn some_unused_variables() {
  #![allow(unused_variables)]

  let x = ();
  let y = ();
  let z = ();
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.meta"><a class="rule-link" href="attributes.html#r-attributes.meta" title="attributes.meta"><span>[attributes<wbr>.meta]<span/></a></div>
<h2 id="메타-아이템-속성-구문"><a class="header" href="#메타-아이템-속성-구문">메타 아이템 속성 구문</a></h2>
<div class="rule" id="r-attributes.meta.intro"><a class="rule-link" href="attributes.html#r-attributes.meta.intro" title="attributes.meta.intro"><span>[attributes<wbr>.meta<wbr>.intro]<span/></a></div>
<p>“메타 아이템(meta item)“은 대부분의 <a href="attributes.html#built-in-attributes-index">내장 속성</a>에서 <em>Attr</em> 규칙을 위해 사용하는 구문입니다. 다음과 같은 문법을 가집니다:</p>
<div class="rule" id="r-attributes.meta.syntax"><a class="rule-link" href="attributes.html#r-attributes.meta.syntax" title="attributes.meta.syntax"><span>[attributes<wbr>.meta<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>메타아이템</em> :<br />
      <a href="paths.html#simple-paths"><em>단순경로</em></a><br />
   | <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>=</code> <a href="expressions.html"><em>표현식</em></a><br />
   | <a href="paths.html#simple-paths"><em>단순경로</em></a> <code>(</code> <em>메타시퀀스</em><sup>?</sup> <code>)</code></p>
<p><em>메타시퀀스</em> :<br />
   <em>내부메타아이템</em> ( <code>,</code> 내부메타아이템 )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>내부메타아이템</em> :<br />
      <em>메타아이템</em><br />
   | <a href="expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-attributes.meta.literal-expr"><a class="rule-link" href="attributes.html#r-attributes.meta.literal-expr" title="attributes.meta.literal-expr"><span>[attributes<wbr>.meta<wbr>.literal-expr]<span/></a></div>
<p>메타 아이템 내의 표현식은 반드시 리터럴 표현식으로 매크로 확장되어야 하며, 여기에는 정수 또는 부동 소수점 타입 접미사가 포함되어서는 안 됩니다. 리터럴 표현식이 아닌 표현식은 구문적으로는 허용되지만(절차적 매크로로 전달될 수 있음), 파싱 후에는 거부됩니다.</p>
<div class="rule" id="r-attributes.meta.order"><a class="rule-link" href="attributes.html#r-attributes.meta.order" title="attributes.meta.order"><span>[attributes<wbr>.meta<wbr>.order]<span/></a></div>
<p>속성이 다른 매크로 내에 나타나는 경우, 해당 외부 매크로 다음에 확장된다는 점에 유의하세요. 예를 들어, 다음 코드는 <code>Serialize</code> 절차적 매크로를 먼저 확장하며, <code>include_str!</code> 호출이 확장되기 위해서는 이 매크로가 해당 호출을 보존해야 합니다.</p>
<pre><code class="language-rust ignore">#[derive(Serialize)]
struct Foo {
    #[doc = include_str!("x.md")]
    x: u32
}</code></pre>
<div class="rule" id="r-attributes.meta.order-macro"><a class="rule-link" href="attributes.html#r-attributes.meta.order-macro" title="attributes.meta.order-macro"><span>[attributes<wbr>.meta<wbr>.order-macro]<span/></a></div>
<p>추가적으로, 속성 내의 매크로는 아이템에 적용된 다른 모든 속성들이 확장된 후에만 확장됩니다.</p>
<pre><code class="language-rust ignore">#[macro_attr1] // 첫 번째로 확장됨
#[doc = mac!()] // `mac!`은 네 번째로 확장됨
#[macro_attr2] // 두 번째로 확장됨
#[derive(MacroDerive1, MacroDerive2)] // 세 번째로 확장됨
fn foo() {}</code></pre>
<div class="rule" id="r-attributes.meta.builtin"><a class="rule-link" href="attributes.html#r-attributes.meta.builtin" title="attributes.meta.builtin"><span>[attributes<wbr>.meta<wbr>.builtin]<span/></a></div>
<p>여러 내장 속성들은 입력을 지정하기 위해 메타 아이템 구문의 서로 다른 하위 집합을 사용합니다. 다음 문법 규칙들은 자주 사용되는 몇 가지 형식을 보여줍니다:</p>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>메타단어</em>:<br />
   <a href="identifiers.html">식별자</a></p>
<p><em>메타이름값문자열</em>:<br />
   <a href="identifiers.html">식별자</a> <code>=</code> (<a href="tokens.html#string-literals">문자열_리터럴</a> | <a href="tokens.html#raw-string-literals">원시_문자열_리터럴</a>)</p>
<p><em>메타목록경로</em>:<br />
   <a href="identifiers.html">식별자</a> <code>(</code> ( <a href="paths.html#simple-paths"><em>단순경로</em></a> (<code>,</code> <a href="paths.html#simple-paths"><em>단순경로</em></a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>메타목록식별자</em>:<br />
   <a href="identifiers.html">식별자</a> <code>(</code> ( <a href="identifiers.html">식별자</a> (<code>,</code> <a href="identifiers.html">식별자</a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>메타목록이름값문자열</em>:<br />
   <a href="identifiers.html">식별자</a> <code>(</code> ( <em>메타이름값문자열</em> (<code>,</code> <em>메타이름값문자열</em>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
</blockquote>
<p>메타 아이템의 몇 가지 예시는 다음과 같습니다:</p>
<div class="table-wrapper"><table><thead><tr><th>스타일</th><th>예시</th></tr></thead><tbody>
<tr><td><em>메타단어</em></td><td><code>no_std</code></td></tr>
<tr><td><em>메타이름값문자열</em></td><td><code>doc = "example"</code></td></tr>
<tr><td><em>메타목록경로</em></td><td><code>allow(unused, clippy::inline_always)</code></td></tr>
<tr><td><em>메타목록식별자</em></td><td><code>macro_use(foo, bar)</code></td></tr>
<tr><td><em>메타목록이름값문자열</em></td><td><code>link(name = "CoreFoundation", kind = "framework")</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-attributes.activity"><a class="rule-link" href="attributes.html#r-attributes.activity" title="attributes.activity"><span>[attributes<wbr>.activity]<span/></a></div>
<h2 id="활성-및-비활성-속성"><a class="header" href="#활성-및-비활성-속성">활성 및 비활성 속성</a></h2>
<div class="rule" id="r-attributes.activity.intro"><a class="rule-link" href="attributes.html#r-attributes.activity.intro" title="attributes.activity.intro"><span>[attributes<wbr>.activity<wbr>.intro]<span/></a></div>
<p>속성은 활성(active) 또는 비활성(inert) 상태입니다. 속성 처리 과정에서 _활성 속성_은 자신이 붙어 있는 대상에서 스스로를 제거하는 반면, _비활성 속성_은 그대로 유지됩니다.</p>
<p><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> 및 <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> 속성은 활성 속성입니다. <a href="procedural-macros.html#attribute-macros">속성 매크로</a>도 활성 속성입니다. 그 외의 모든 속성들은 비활성 속성입니다.</p>
<div class="rule" id="r-attributes.tool"><a class="rule-link" href="attributes.html#r-attributes.tool" title="attributes.tool"><span>[attributes<wbr>.tool]<span/></a></div>
<h2 id="도구-속성"><a class="header" href="#도구-속성">도구 속성</a></h2>
<div class="rule" id="r-attributes.tool.intro"><a class="rule-link" href="attributes.html#r-attributes.tool.intro" title="attributes.tool.intro"><span>[attributes<wbr>.tool<wbr>.intro]<span/></a></div>
<p>컴파일러는 각 도구가 <a href="names/preludes.html#tool-prelude">도구 프렐류드(tool prelude)</a>의 자체 모듈에 상주하는 외부 도구들을 위한 속성을 허용할 수 있습니다. 속성 경로의 첫 번째 세그먼트는 도구의 이름이며, 하나 이상의 추가 세그먼트의 해석은 도구에 달려 있습니다.</p>
<div class="rule" id="r-attributes.tool.ignored"><a class="rule-link" href="attributes.html#r-attributes.tool.ignored" title="attributes.tool.ignored"><span>[attributes<wbr>.tool<wbr>.ignored]<span/></a></div>
<p>도구가 사용되지 않을 때, 해당 도구의 속성은 경고 없이 수용됩니다. 도구가 사용 중일 때, 도구는 해당 속성의 처리 및 해석을 담당합니다.</p>
<div class="rule" id="r-attributes.tool.prelude"><a class="rule-link" href="attributes.html#r-attributes.tool.prelude" title="attributes.tool.prelude"><span>[attributes<wbr>.tool<wbr>.prelude]<span/></a></div>
<p><a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> 속성이 사용되는 경우 도구 속성을 사용할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rustfmt 도구에게 다음 요소를 포맷팅하지 않도록 지시합니다.
#[rustfmt::skip]
struct S {
}

// clippy 도구의 "순환 복잡도(cyclomatic complexity)" 임계값을 제어합니다.
#[clippy::cyclomatic_complexity = "100"]
pub fn f() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>rustc</code>는 현재 “clippy”, “rustfmt”, “diagnostic”, “miri”, “rust_analyzer” 도구를 인식합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.builtin"><a class="rule-link" href="attributes.html#r-attributes.builtin" title="attributes.builtin"><span>[attributes<wbr>.builtin]<span/></a></div>
<h2 id="내장-속성-색인"><a class="header" href="#내장-속성-색인">내장 속성 색인</a></h2>
<p>다음은 모든 내장 속성의 색인입니다.</p>
<ul>
<li>
<p>조건부 컴파일</p>
<ul>
<li><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> — 조건부 컴파일을 제어합니다.</li>
<li><a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> — 속성을 조건부로 포함합니다.</li>
</ul>
</li>
<li>
<p>테스팅</p>
<ul>
<li><a href="attributes/testing.html#the-test-attribute"><code>test</code></a> — 함수를 테스트로 표시합니다.</li>
<li><a href="attributes/testing.html#the-ignore-attribute"><code>ignore</code></a> — 테스트 함수를 비활성화합니다.</li>
<li><a href="attributes/testing.html#the-should_panic-attribute"><code>should_panic</code></a> — 테스트가 패닉을 발생시켜야 함을 나타냅니다.</li>
</ul>
</li>
<li>
<p>파생</p>
<ul>
<li><a href="attributes/derive.html"><code>derive</code></a> — 트레잇 자동 구현.</li>
<li><a href="attributes/derive.html#the-automatically_derived-attribute"><code>automatically_derived</code></a> — <code>derive</code>에 의해 생성된 구현을 위한 마커입니다.</li>
</ul>
</li>
<li>
<p>매크로</p>
<ul>
<li><a href="macros-by-example.html#path-based-scope"><code>macro_export</code></a> — 크레이트 간 사용을 위해 <code>macro_rules</code> 매크로를 내보냅니다.</li>
<li><a href="macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> — 매크로 가시성을 확장하거나 다른 크레이트에서 매크로를 임포트합니다.</li>
<li><a href="procedural-macros.html#function-like-procedural-macros"><code>proc_macro</code></a> — 함수 유사 매크로(function-like macro)를 정의합니다.</li>
<li><a href="procedural-macros.html#derive-macros"><code>proc_macro_derive</code></a> — derive 매크로를 정의합니다.</li>
<li><a href="procedural-macros.html#attribute-macros"><code>proc_macro_attribute</code></a> — 속성 매크로(attribute macro)를 정의합니다.</li>
</ul>
</li>
<li>
<p>진단</p>
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes"><code>allow</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>expect</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>warn</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>deny</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>forbid</code></a> — 기본 린트(lint) 레벨을 변경합니다.</li>
<li><a href="attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> — 사용 중단(deprecation) 공지를 생성합니다.</li>
<li><a href="attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a> — 사용되지 않은 값에 대해 린트를 생성합니다.</li>
<li><a href="attributes/diagnostics.html#the-diagnosticon_unimplemented-attribute"><code>diagnostic::on_unimplemented</code></a> — 트레잇이 구현되지 않은 경우 특정 에러 메시지를 내보내도록 컴파일러에 힌트를 줍니다.</li>
<li><a href="attributes/diagnostics.html#the-diagnosticdo_not_recommend-attribute"><code>diagnostic::do_not_recommend</code></a> — 에러 메시지에서 특정 트레잇 구현을 표시하지 않도록 컴파일러에 힌트를 줍니다.</li>
</ul>
</li>
<li>
<p>ABI, 링크, 심볼 및 FFI</p>
<ul>
<li><a href="items/external-blocks.html#the-link-attribute"><code>link</code></a> — <code>extern</code> 블록과 링크할 네이티브 라이브러리를 지정합니다.</li>
<li><a href="items/external-blocks.html#the-link_name-attribute"><code>link_name</code></a> — <code>extern</code> 블록 내의 함수나 정적 아이템을 위한 심볼 이름을 지정합니다.</li>
<li><a href="items/external-blocks.html#the-link_ordinal-attribute"><code>link_ordinal</code></a> — <code>extern</code> 블록 내의 함수나 정적 아이템을 위한 심볼의 오디널(ordinal)을 지정합니다.</li>
<li><a href="items/extern-crates.html#the-no_link-attribute"><code>no_link</code></a> — 외부 크레이트가 링크되는 것을 방지합니다.</li>
<li><a href="type-layout.html#representations"><code>repr</code></a> — 타입 레이아웃을 제어합니다.</li>
<li><a href="linkage.html"><code>crate_type</code></a> — 크레이트의 종류(라이브러리, 실행 파일 등)를 지정합니다.</li>
<li><a href="crates-and-source-files.html#the-no_main-attribute"><code>no_main</code></a> — <code>main</code> 심볼 내보내기를 비활성화합니다.</li>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a> — 함수나 정적 아이템에 대해 내보낼 심볼 이름을 지정합니다.</li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a> — 함수나 정적 아이템에 사용할 객체 파일의 섹션을 지정합니다.</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> — 심볼 이름 인코딩(mangling)을 비활성화합니다.</li>
<li><a href="abi.html#the-used-attribute"><code>used</code></a> — 컴파일러가 출력 객체 파일에서 정적 아이템을 유지하도록 강제합니다.</li>
<li><a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> — 크레이트 이름을 지정합니다.</li>
</ul>
</li>
<li>
<p>코드 생성</p>
<ul>
<li><a href="attributes/codegen.html#the-inline-attribute"><code>inline</code></a> — 코드 인라이닝에 대한 힌트입니다.</li>
<li><a href="attributes/codegen.html#the-cold-attribute"><code>cold</code></a> — 함수가 거의 호출되지 않을 것임을 나타내는 힌트입니다.</li>
<li><a href="attributes/codegen.html#the-no_builtins-attribute"><code>no_builtins</code></a> — 특정 내장 함수들의 사용을 비활성화합니다.</li>
<li><a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> — 플랫폼별 코드 생성을 구성합니다.</li>
<li><a href="attributes/codegen.html#the-track_caller-attribute"><code>track_caller</code></a> — 부모 호출 위치를 <code>std::panic::Location::caller()</code>로 전달합니다.</li>
<li><a href="attributes/codegen.html#the-instruction_set-attribute"><code>instruction_set</code></a> — 함수 코드 생성에 사용될 명령어 집합을 지정합니다.</li>
</ul>
</li>
<li>
<p>문서화</p>
<ul>
<li><code>doc</code> — 문서를 지정합니다. 자세한 내용은 <a href="../rustdoc/the-doc-attribute.html">Rustdoc 책</a>을 참조하세요. <a href="comments.html#doc-comments">문서 주석</a>은 <code>doc</code> 속성으로 변환됩니다.</li>
</ul>
</li>
<li>
<p>프렐류드</p>
<ul>
<li><a href="names/preludes.html#the-no_std-attribute"><code>no_std</code></a> — 프렐류드에서 std를 제거합니다.</li>
<li><a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> — 모듈 내에서 프렐류드 조회를 비활성화합니다.</li>
</ul>
</li>
<li>
<p>모듈</p>
<ul>
<li><a href="items/modules.html#the-path-attribute"><code>path</code></a> — 모듈의 파일 이름을 지정합니다.</li>
</ul>
</li>
<li>
<p>제한</p>
<ul>
<li><a href="attributes/limits.html#the-recursion_limit-attribute"><code>recursion_limit</code></a> — 특정 컴파일 타임 연산에 대한 최대 재귀 한도를 설정합니다.</li>
<li><a href="attributes/limits.html#the-type_length_limit-attribute"><code>type_length_limit</code></a> — 다형성 타입(polymorphic type)의 최대 크기를 설정합니다.</li>
</ul>
</li>
<li>
<p>런타임</p>
<ul>
<li><a href="runtime.html#the-panic_handler-attribute"><code>panic_handler</code></a> — 패닉을 처리할 함수를 설정합니다.</li>
<li><a href="runtime.html#the-global_allocator-attribute"><code>global_allocator</code></a> — 전역 메모리 할당자를 설정합니다.</li>
<li><a href="runtime.html#the-windows_subsystem-attribute"><code>windows_subsystem</code></a> — 링크할 Windows 하위 시스템을 지정합니다.</li>
</ul>
</li>
<li>
<p>기능(Features)</p>
<ul>
<li><code>feature</code> — 불안정하거나 실험적인 컴파일러 기능을 활성화하는 데 사용됩니다. <code>rustc</code>에 구현된 기능들에 대해서는 <a href="../unstable-book/index.html">Unstable Book</a>을 참조하세요.</li>
</ul>
</li>
<li>
<p>타입 시스템</p>
<ul>
<li><a href="attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> — 미래에 타입에 더 많은 필드나 변형이 추가될 것임을 나타냅니다.</li>
</ul>
</li>
<li>
<p>디버거</p>
<ul>
<li><a href="attributes/debugger.html#the-debugger_visualizer-attribute"><code>debugger_visualizer</code></a> — 타입에 대한 디버거 출력을 지정하는 파일을 포함시킵니다.</li>
<li><a href="attributes/debugger.html#the-collapse_debuginfo-attribute"><code>collapse_debuginfo</code></a> — 디버그 정보에서 매크로 호출이 인코딩되는 방식을 제어합니다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.testing"><a class="rule-link" href="attributes/testing.html#r-attributes.testing" title="attributes.testing"><span>[attributes<wbr>.testing]<span/></a></div>
<h1 id="테스팅-속성"><a class="header" href="#테스팅-속성">테스팅 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 테스트를 수행하기 위한 함수를 지정하는 데 사용됩니다. 크레이트를 “test” 모드로 컴파일하면 테스트를 실행하기 위한 테스트 하네스와 함께 테스트 함수들이 빌드됩니다. 테스트 모드를 활성화하면 <a href="attributes/../conditional-compilation.html#test"><code>test</code> 조건부 컴파일 옵션</a>도 활성화됩니다.</p>
<div class="rule" id="r-attributes.testing.test"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.test" title="attributes.testing.test"><span>[attributes<wbr>.testing<wbr>.test]<span/></a></div>
<h2 id="test-속성"><a class="header" href="#test-속성"><code>test</code> 속성</a></h2>
<div class="rule" id="r-attributes.testing.test.intro"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.test.intro" title="attributes.testing.test.intro"><span>[attributes<wbr>.testing<wbr>.test<wbr>.intro]<span/></a></div>
<p>_<code>test</code> 속성_은 함수를 테스트로서 실행되도록 표시합니다.</p>
<div class="rule" id="r-attributes.testing.test.enabled"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.test.enabled" title="attributes.testing.test.enabled"><span>[attributes<wbr>.testing<wbr>.test<wbr>.enabled]<span/></a></div>
<p>이러한 함수들은 테스트 모드일 때만 컴파일됩니다.</p>
<div class="rule" id="r-attributes.testing.test.allowed-positions"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.test.allowed-positions" title="attributes.testing.test.allowed-positions"><span>[attributes<wbr>.testing<wbr>.test<wbr>.allowed-positions]<span/></a></div>
<p>테스트 함수는 인수를 받지 않는 자유(free) 함수이자 모노모르픽(monomorphic) 함수여야 하며, 반환 타입은 <a href="attributes/../../std/process/trait.Termination.html"><code>Termination</code></a> 트레잇을 구현해야 합니다. 예를 들어:</p>
<ul>
<li><code>()</code></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
<li><code>!</code></li>
</ul>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the crates-and-source-files.md file -->
<blockquote>
<p>참고: 테스트 모드는 <code>rustc</code>에 <code>--test</code> 인수를 전달하거나 <code>cargo test</code>를 사용하여 활성화됩니다.</p>
</blockquote>
<div class="rule" id="r-attributes.testing.test.success"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.test.success" title="attributes.testing.test.success"><span>[attributes<wbr>.testing<wbr>.test<wbr>.success]<span/></a></div>
<p>테스트 하네스는 반환된 값의 <a href="attributes/../../std/process/trait.Termination.html#tymethod.report"><code>report</code></a> 메서드를 호출하며, 결과 <a href="attributes/../../std/process/struct.ExitCode.html"><code>ExitCode</code></a>가 성공적인 종료를 나타내는지 여부에 따라 테스트를 통과 또는 실패로 분류합니다. 특히:</p>
<ul>
<li><code>()</code>를 반환하는 테스트는 종료되고 패닉이 발생하지 않는 한 통과합니다.</li>
<li><code>Result&lt;(), E&gt;</code>를 반환하는 테스트는 <code>Ok(())</code>를 반환하는 한 통과합니다.</li>
<li><code>ExitCode::SUCCESS</code>를 반환하는 테스트는 통과하고, <code>ExitCode::FAILURE</code>를 반환하는 테스트는 실패합니다.</li>
<li>종료되지 않는 테스트는 통과도 실패도 하지 않습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">fn setup_the_thing() -&gt; io::Result&lt;i32&gt; { Ok(1) }
</span><span class="boring">fn do_the_thing(s: &amp;i32) -&gt; io::Result&lt;()&gt; { Ok(()) }
</span>#[test]
fn test_the_thing() -&gt; io::Result&lt;()&gt; {
    let state = setup_the_thing()?; // 성공할 것으로 예상됨
    do_the_thing(&amp;state)?;          // 성공할 것으로 예상됨
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.testing.ignore"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.ignore" title="attributes.testing.ignore"><span>[attributes<wbr>.testing<wbr>.ignore]<span/></a></div>
<h2 id="ignore-속성"><a class="header" href="#ignore-속성"><code>ignore</code> 속성</a></h2>
<div class="rule" id="r-attributes.testing.ignore.intro"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.ignore.intro" title="attributes.testing.ignore.intro"><span>[attributes<wbr>.testing<wbr>.ignore<wbr>.intro]<span/></a></div>
<p><code>test</code> 속성이 지정된 함수에는 <code>ignore</code> 속성도 지정할 수 있습니다. _<code>ignore</code> 속성_은 테스트 하네스에게 해당 함수를 테스트로 실행하지 않도록 지시합니다. 테스트 모드일 때 여전히 컴파일은 됩니다.</p>
<div class="rule" id="r-attributes.testing.ignore.syntax"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.ignore.syntax" title="attributes.testing.ignore.syntax"><span>[attributes<wbr>.testing<wbr>.ignore<wbr>.syntax]<span/></a></div>
<p><code>ignore</code> 속성은 선택적으로 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용하여 테스트가 무시되는 이유를 명시할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore = "아직 구현되지 않음"]
fn mytest() {
    // …
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code> 테스트 하네스는 무시된 테스트를 강제로 실행하기 위한 <code>--include-ignored</code> 플래그를 지원합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.testing.should_panic"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.should_panic" title="attributes.testing.should_panic"><span>[attributes<wbr>.testing<wbr>.should_panic]<span/></a></div>
<h2 id="should_panic-속성"><a class="header" href="#should_panic-속성"><code>should_panic</code> 속성</a></h2>
<div class="rule" id="r-attributes.testing.should_panic.intro"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.should_panic.intro" title="attributes.testing.should_panic.intro"><span>[attributes<wbr>.testing<wbr>.should_panic<wbr>.intro]<span/></a></div>
<p><code>()</code>를 반환하고 <code>test</code> 속성이 지정된 함수에는 <code>should_panic</code> 속성도 지정할 수 있습니다.</p>
<div class="rule" id="r-attributes.testing.should_panic.behavior"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.should_panic.behavior" title="attributes.testing.should_panic.behavior"><span>[attributes<wbr>.testing<wbr>.should_panic<wbr>.behavior]<span/></a></div>
<p>_<code>should_panic</code> 속성_은 테스트가 실제로 패닉이 발생한 경우에만 통과하도록 만듭니다.</p>
<div class="rule" id="r-attributes.testing.should_panic.syntax"><a class="rule-link" href="attributes/testing.html#r-attributes.testing.should_panic.syntax" title="attributes.testing.should_panic.syntax"><span>[attributes<wbr>.testing<wbr>.should_panic<wbr>.syntax]<span/></a></div>
<p><code>should_panic</code> 속성은 선택적으로 패닉 메시지 내에 나타나야 하는 입력 문자열을 받을 수 있습니다. 해당 문자열이 메시지 내에서 발견되지 않으면 테스트는 실패합니다. 이 문자열은 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문이나 <code>expected</code> 필드가 있는 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용하여 전달할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = "값들이 일치하지 않음")]
fn mytest() {
    assert_eq!(1, 2, "값들이 일치하지 않음");
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.derive"><a class="rule-link" href="attributes/derive.html#r-attributes.derive" title="attributes.derive"><span>[attributes<wbr>.derive]<span/></a></div>
<h1 id="파생"><a class="header" href="#파생">파생</a></h1>
<div class="rule" id="r-attributes.derive.intro"><a class="rule-link" href="attributes/derive.html#r-attributes.derive.intro" title="attributes.derive.intro"><span>[attributes<wbr>.derive<wbr>.intro]<span/></a></div>
<p>_<code>derive</code> 속성_은 데이터 구조에 대해 새로운 <a href="attributes/../items.html">아이템들</a>이 자동으로 생성되도록 합니다.</p>
<div class="rule" id="r-attributes.derive.syntax"><a class="rule-link" href="attributes/derive.html#r-attributes.derive.syntax" title="attributes.derive.syntax"><span>[attributes<wbr>.derive<wbr>.syntax]<span/></a></div>
<p>이 속성은 구현할 트레잇 목록이나 처리할 <a href="attributes/../procedural-macros.html#derive-macros">derive 매크로</a> 경로를 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> 구문을 사용합니다.</p>
<p>예를 들어, 다음 코드는 <code>Foo</code>에 대해 <a href="attributes/../../core/cmp/trait.PartialEq.html"><code>PartialEq</code></a> 및 <a href="attributes/../../core/clone/trait.Clone.html"><code>Clone</code></a> 트레잇을 위한 <a href="attributes/../items/implementations.html"><code>impl</code> 아이템</a>을 생성하며, 타입 매개변수 <code>T</code>에는 적절한 <code>impl</code>을 위한 <code>PartialEq</code> 또는 <code>Clone</code> 제약 조건이 부여됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
<span class="boring">}</span></code></pre></pre>
<p><code>PartialEq</code>를 위해 생성된 <code>impl</code>은 다음과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt; { a: i32, b: T }
</span>impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.derive.proc-macro"><a class="rule-link" href="attributes/derive.html#r-attributes.derive.proc-macro" title="attributes.derive.proc-macro"><span>[attributes<wbr>.derive<wbr>.proc-macro]<span/></a></div>
<p><a href="attributes/../procedural-macros.html#derive-macros">절차적 매크로</a>를 통해 여러분의 트레잇에 대해서도 <code>derive</code>를 구현할 수 있습니다.</p>
<div class="rule" id="r-attributes.derive.automatically_derived"><a class="rule-link" href="attributes/derive.html#r-attributes.derive.automatically_derived" title="attributes.derive.automatically_derived"><span>[attributes<wbr>.derive<wbr>.automatically_derived]<span/></a></div>
<h2 id="automatically_derived-속성"><a class="header" href="#automatically_derived-속성"><code>automatically_derived</code> 속성</a></h2>
<p>_<code>automatically_derived</code> 속성_은 내장 트레잇에 대해 <code>derive</code> 속성에 의해 생성된 <a href="attributes/../items/implementations.html">구현들</a>에 자동으로 추가됩니다. 이 속성은 직접적인 효과는 없지만, 도구나 진단 린트에서 이렇게 자동으로 생성된 구현들을 감지하는 데 사용될 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.diagnostics"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics" title="attributes.diagnostics"><span>[attributes<wbr>.diagnostics]<span/></a></div>
<h1 id="진단-속성"><a class="header" href="#진단-속성">진단 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 컴파일 중에 진단 메시지를 제어하거나 생성하는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint" title="attributes.diagnostics.lint"><span>[attributes<wbr>.diagnostics<wbr>.lint]<span/></a></div>
<h2 id="린트lint-체크-속성"><a class="header" href="#린트lint-체크-속성">린트(Lint) 체크 속성</a></h2>
<p>린트 체크는 도달할 수 없는 코드나 누락된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴을 지적합니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint.level"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.level" title="attributes.diagnostics.lint.level"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.level]<span/></a></div>
<p>린트 속성 <code>allow</code>, <code>expect</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>는 속성이 적용되는 엔티티의 린트 레벨을 변경하기 위한 린트 이름 목록을 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> 구문을 사용합니다.</p>
<p>임의의 린트 체크 <code>C</code>에 대해:</p>
<div class="rule" id="r-attributes.diagnostics.lint.allow"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.allow" title="attributes.diagnostics.lint.allow"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.allow]<span/></a></div>
<ul>
<li><code>#[allow(C)]</code>는 <code>C</code>에 대한 체크를 무시하여 위반 사항이 보고되지 않도록 합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.expect"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.expect" title="attributes.diagnostics.lint.expect"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.expect]<span/></a></div>
<ul>
<li><code>#[expect(C)]</code>는 린트 <code>C</code>가 발생할 것으로 예상됨을 나타냅니다. 이 속성은 <code>C</code>의 발생을 억제하거나, 예상이 충족되지 않은 경우 경고를 발생시킵니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.warn"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.warn" title="attributes.diagnostics.lint.warn"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.warn]<span/></a></div>
<ul>
<li><code>#[warn(C)]</code>는 <code>C</code> 위반에 대해 경고하지만 컴파일을 계속합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.deny"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.deny" title="attributes.diagnostics.lint.deny"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.deny]<span/></a></div>
<ul>
<li><code>#[deny(C)]</code>는 <code>C</code> 위반을 발견하면 에러를 발생시킵니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.forbid"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.forbid" title="attributes.diagnostics.lint.forbid"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.forbid]<span/></a></div>
<ul>
<li><code>#[forbid(C)]</code>는 <code>deny(C)</code>와 동일하지만, 이후에 린트 레벨을 변경하는 것도 금지합니다.</li>
</ul>
<blockquote>
<p>참고: <code>rustc</code>에서 지원하는 린트 체크 목록과 기본 설정은 <code>rustc -W help</code>를 통해 확인할 수 있으며, <a href="attributes/../../rustc/lints/index.html">rustc 책</a>에도 문서화되어 있습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // 여기서 누락된 문서는 무시됩니다.
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // 여기서 누락된 문서는 에러를 발생시킵니다.
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.override"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.override" title="attributes.diagnostics.lint.override"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.override]<span/></a></div>
<p>린트 속성은 이전 속성에서 지정된 레벨을 오버라이드할 수 있습니다. 단, 금지된(forbidden) 린트 레벨을 변경하려고 시도해서는 안 됩니다 (단, <code>deny</code>는 <code>forbid</code> 컨텍스트 내부에서 허용되지만 무시됩니다). 이전 속성이란 구문 트리에서 상위 레벨에 있는 속성이나, 소스 코드 순서상 왼쪽에서 오른쪽으로 나열된 동일한 엔티티의 이전 속성을 의미합니다.</p>
<p>이 예시는 <code>allow</code>와 <code>warn</code>을 사용하여 특정 체크를 켜고 끄는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // 여기서 누락된 문서는 무시됩니다.
        pub fn undocumented_one() -&gt; i32 { 1 }

        // 위의 allow에도 불구하고,
        // 여기서 누락된 문서는 경고를 발생시킵니다.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시는 특정 린트 체크에 대해 <code>allow</code>나 <code>expect</code>를 사용하는 것을 금지하기 위해 <code>forbid</code>를 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // 경고를 토글하려고 시도하면 여기서 에러가 발생합니다.
    #[allow(missing_docs)]
    /// 2를 반환합니다.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>rustc</code>는 <a href="attributes/../../rustc/lints/levels.html#via-compiler-flag">커맨드 라인</a>에서 린트 레벨을 설정하는 것을 허용하며, 보고되는 린트에 대해 <a href="attributes/../../rustc/lints/levels.html#capping-lints">상한(caps) 설정</a>도 지원합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.lint.reason"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.reason" title="attributes.diagnostics.lint.reason"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.reason]<span/></a></div>
<h3 id="린트-사유lint-reasons"><a class="header" href="#린트-사유lint-reasons">린트 사유(Lint Reasons)</a></h3>
<p>모든 린트 속성은 특정 속성이 추가된 이유에 대한 문맥을 제공하기 위해 추가적인 <code>reason</code> 매개변수를 지원합니다. 이 사유는 린트가 정의된 레벨에서 내보내질 때 린트 메시지의 일부로 표시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `keyword_idents`는 기본적으로 허용됩니다. 여기서는 에디션을 업데이트할 때
// 식별자 마이그레이션을 피하기 위해 이를 거부(deny)합니다.
#![deny(
    keyword_idents,
    reason = "미래 호환성을 위해 이러한 식별자들을 피하고 싶습니다"
)]

// 이 이름은 Rust 2015 에디션에서 허용되었습니다. 우리는 여전히 피하고자 합니다
// 미래 호환성을 확보하고 최종 사용자에게 혼란을 주지 않기 위함입니다.
fn dyn() {}
<span class="boring">}</span></code></pre></pre>
<p>사유와 함께 린트를 허용한 또 다른 예시입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

pub fn get_path() -&gt; PathBuf {
    // `allow` 속성의 `reason` 매개변수는 독자를 위한 문서 역할을 합니다.
    #[allow(unused_mut, reason = "이것은 일부 플랫폼에서만 수정됩니다")]
    let mut file_name = PathBuf::from("git");

    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");

    file_name
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.expect" title="attributes.diagnostics.expect"><span>[attributes<wbr>.diagnostics<wbr>.expect]<span/></a></div>
<h3 id="expect-속성"><a class="header" href="#expect-속성"><code>#[expect]</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostics.expect.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.expect.intro" title="attributes.diagnostics.expect.intro"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.intro]<span/></a></div>
<p><code>#[expect(C)]</code> 속성은 린트 <code>C</code>에 대한 린트 기대를 생성합니다. 동일한 위치의 <code>#[warn(C)]</code> 속성이 린트를 발생시키는 경우 기대가 충족됩니다. 린트 <code>C</code>가 발생하지 않아 기대가 충족되지 않으면, 해당 속성 위치에서 <code>unfulfilled_lint_expectations</code> 린트가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // 이 `#[expect]` 속성은 `unused_variables` 린트가 다음 문장에서 발생할 것이라는
    // 린트 기대를 생성합니다. `question` 변수가 `println!` 매크로에 의해
    // 사용되므로 이 기대는 충족되지 않습니다. 따라서 해당 속성 위치에서
    // `unfulfilled_lint_expectations` 린트가 발생합니다.
    #[expect(unused_variables)]
    let question = "누가 바다 저 깊은 곳 파인애플에 살까요?";
    println!("{question}");

    // 이 `#[expect]` 속성은 `answer` 변수가 전혀 사용되지 않으므로 충족될
    // 린트 기대를 생성합니다. 평소라면 발생했을 `unused_variables` 린트는
    // 억제됩니다. 해당 문장이나 속성에 대해 어떤 경고도 발생하지 않습니다.
    #[expect(unused_variables)]
    let answer = "네모네모 스폰지밥!";
}</code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect.fulfillment"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.expect.fulfillment" title="attributes.diagnostics.expect.fulfillment"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.fulfillment]<span/></a></div>
<p>린트 기대는 <code>expect</code> 속성에 의해 억제된 린트 발생에 의해서만 충족됩니다. 만약 <code>allow</code>나 <code>warn</code> 같은 다른 레벨 속성에 의해 해당 스코프에서 린트 레벨이 수정되면, 린트 발생은 그에 맞춰 처리되며 기대는 충족되지 않은 상태로 남습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[expect(unused_variables)]
fn select_song() {
    // 이것은 `warn` 속성에 정의된 대로 `unused_variables` 린트를 warn 레벨로
    // 내보낼 것입니다. 이는 함수 위에 있는 기대를 충족시키지 못합니다.
    #[warn(unused_variables)]
    let song_name = "Crab Rave";

    // `allow` 속성은 린트 발생을 억제합니다. 이는 `expect` 속성이 아닌
    // `allow` 속성에 의해 억제되었으므로 함수 위의 기대를
    // 충족시키지 못합니다.
    #[allow(unused_variables)]
    let song_creator = "Noisestorm";

    // 이 `expect` 속성은 변수 위치에서 `unused_variables` 린트 발생을
    // 억제할 것입니다. 이 린트 발생은 지역적인 expect 속성에 의해
    // 억제되었으므로 함수 위의 `expect` 속성은 여전히 충족되지 않습니다.
    #[expect(unused_variables)]
    let song_version = "Monstercat Release";
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect.independent"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.expect.independent" title="attributes.diagnostics.expect.independent"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.independent]<span/></a></div>
<p><code>expect</code> 속성이 여러 린트를 포함하는 경우, 각각은 개별적으로 기대됩니다. 린트 그룹의 경우 그룹 내의 한 린트라도 발생했다면 충분합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 기대는 함수 내부의 사용되지 않은 값에 의해 충족될 것입니다.
// 발생한 `unused_variables` 린트가 `unused` 린트 그룹에 속하기 때문입니다.
#[expect(unused)]
pub fn thoughts() {
    let unused = "예시가 떨어져 가고 있어요";
}

pub fn another_example() {
    // 이 속성은 두 개의 린트 기대를 생성합니다. `unused_mut` 린트는
    // 억제되며 첫 번째 기대를 충족시킬 것입니다. `unused_variables` 린트는
    // 변수가 사용되므로 발생하지 않을 것입니다. 따라서 그 기대는 충족되지
    // 않은 상태로 남게 되며, 경고가 발생할 것입니다.
    #[expect(unused_mut, unused_variables)]
    let mut link = "https://www.rust-lang.org/";

    println!("우리 커뮤니티에 오신 것을 환영합니다: {link}");
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>#[expect(unfulfilled_lint_expectations)]</code>의 동작은 현재 항상 <code>unfulfilled_lint_expectations</code> 린트를 생성하도록 정의되어 있습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.lint.group"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.group" title="attributes.diagnostics.lint.group"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.group]<span/></a></div>
<h3 id="린트-그룹"><a class="header" href="#린트-그룹">린트 그룹</a></h3>
<p>린트들은 관련된 린트들의 레벨을 함께 조정할 수 있도록 명명된 그룹으로 조직될 수 있습니다. 명명된 그룹을 사용하는 것은 해당 그룹 내의 린트들을 나열하는 것과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 "unused" 그룹의 모든 린트를 허용합니다.
#[allow(unused)]
// 이는 "unused" 그룹의 "unused_must_use" 린트를
// deny 레벨로 오버라이드합니다.
#[deny(unused_must_use)]
fn example() {
    // "unused_variables" 린트가 "unused" 그룹에 속해 있으므로
    // 경고를 생성하지 않습니다.
    let x = 1;
    // 결과가 사용되지 않았고 "unused_must_use"가 "deny"로 설정되었으므로
    // 에러를 생성합니다.
    std::fs::remove_file("some_file"); // 에러: 반드시 사용되어야 할 `Result`가 사용되지 않음
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.group.warnings"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.group.warnings" title="attributes.diagnostics.lint.group.warnings"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.group<wbr>.warnings]<span/></a></div>
<p>“warnings“라는 이름의 특별한 그룹이 있는데, 이는 “warn” 레벨의 모든 린트를 포함합니다. “warnings” 그룹은 속성 순서를 무시하며, 해당 엔티티 내에서 경고를 발생시킬 모든 린트에 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">unsafe fn an_unsafe_fn() {}
</span>// 이 두 속성의 순서는 중요하지 않습니다.
#[deny(warnings)]
// unsafe_code 린트는 보통 기본적으로 "allow"입니다.
#[warn(unsafe_code)]
fn example_err() {
    // `unsafe_code` 경고가 "deny"로 격상되었으므로 이것은 에러입니다.
    unsafe { an_unsafe_fn() } // 에러: `unsafe` 블록 사용
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.tool"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool" title="attributes.diagnostics.lint.tool"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool]<span/></a></div>
<h3 id="도구-린트-속성"><a class="header" href="#도구-린트-속성">도구 린트 속성</a></h3>
<div class="rule" id="r-attributes.diagnostics.lint.tool.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool.intro" title="attributes.diagnostics.lint.tool.intro"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool<wbr>.intro]<span/></a></div>
<p>도구 린트를 사용하면 범위가 지정된(scoped) 린트를 사용하여 특정 도구의 린트를 <code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code> 할 수 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint.tool.activation"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool.activation" title="attributes.diagnostics.lint.tool.activation"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool<wbr>.activation]<span/></a></div>
<p>도구 린트는 관련 도구가 활성화된 경우에만 체크됩니다. 만약 <code>allow</code>와 같은 린트 속성이 존재하지 않는 도구 린트를 참조하더라도, 컴파일러는 해당 도구를 사용하기 전까지는 존재하지 않는 린트에 대해 경고하지 않습니다.</p>
<p>그 외에는 일반 린트 속성과 동일하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// clippy의 `pedantic` 린트 그룹 전체를 warn으로 설정합니다.
#![warn(clippy::pedantic)]
// clippy의 `filter_map` 린트 경고를 억제합니다.
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// 이 함수에서만 clippy의 `cmp_nan` 린트를 억제합니다.
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}</code></pre></pre>
<blockquote>
<p>참고: <code>rustc</code>는 현재 “<a href="https://github.com/rust-lang/rust-clippy">clippy</a>“와 “<a href="attributes/../../rustdoc/lints.html">rustdoc</a>” 도구 린트를 인식합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.deprecated"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated" title="attributes.diagnostics.deprecated"><span>[attributes<wbr>.diagnostics<wbr>.deprecated]<span/></a></div>
<h2 id="deprecated-속성"><a class="header" href="#deprecated-속성"><code>deprecated</code> 속성</a></h2>
<div class="rule" id="r-attributes.diagnostics.deprecated.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated.intro" title="attributes.diagnostics.deprecated.intro"><span>[attributes<wbr>.diagnostics<wbr>.deprecated<wbr>.intro]<span/></a></div>
<p>_<code>deprecated</code> 속성_은 아이템을 사용 중단된 것(deprecated)으로 표시합니다. <code>rustc</code>는 <code>#[deprecated]</code> 아이템 사용 시 경고를 발생시킵니다. <code>rustdoc</code>은 사용 가능한 경우 <code>since</code> 버전과 <code>note</code>를 포함하여 아이템의 사용 중단 여부를 표시합니다.</p>
<div class="rule" id="r-attributes.diagnostics.deprecated.syntax"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated.syntax" title="attributes.diagnostics.deprecated.syntax"><span>[attributes<wbr>.diagnostics<wbr>.deprecated<wbr>.syntax]<span/></a></div>
<p><code>deprecated</code> 속성은 여러 형식을 가집니다:</p>
<ul>
<li><code>deprecated</code> — 일반적인 메시지를 발생시킵니다.</li>
<li><code>deprecated = "message"</code> — 사용 중단 메시지에 주어진 문자열을 포함합니다.</li>
<li>두 개의 선택적 필드가 있는 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문:
<ul>
<li><code>since</code> — 아이템이 사용 중단된 버전 번호를 지정합니다. <code>rustc</code>는 현재 이 문자열을 해석하지 않지만, <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>와 같은 외부 도구가 이 값의 유효성을 검사할 수 있습니다.</li>
<li><code>note</code> — 사용 중단 메시지에 포함되어야 할 문자열을 지정합니다. 이는 일반적으로 사용 중단에 대한 설명과 권장되는 대안을 제공하는 데 사용됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.deprecated.allowed-positions"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.deprecated.allowed-positions" title="attributes.diagnostic.deprecated.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.deprecated<wbr>.allowed-positions]<span/></a></div>
<p><code>deprecated</code> 속성은 모든 <a href="attributes/../items.html">아이템</a>, <a href="attributes/../items/traits.html">트레잇 아이템</a>, <a href="attributes/../items/enumerations.html">열거형 변형</a>, <a href="attributes/../items/structs.html">구조체 필드</a>, <a href="attributes/../items/external-blocks.html">외부 블록 아이템</a> 또는 <a href="attributes/../macros-by-example.html">매크로 정의</a>에 적용될 수 있습니다. <a href="attributes/../items/implementations.html#trait-implementations">트레잇 구현 아이템</a>에는 적용할 수 없습니다. <a href="attributes/../items/modules.html">모듈</a>이나 <a href="attributes/../items/implementations.html">구현</a>과 같이 다른 아이템을 포함하는 아이템에 적용되면 모든 자식 아이템이 사용 중단 속성을 상속받습니다.</p>
<!-- NOTE: It is only rejected for trait impl items
(AnnotationKind::Prohibited). In all other locations, it is silently ignored.
Tuple struct fields are ignored.
-->
<p>예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = "5.2.0", note = "foo는 거의 사용되지 않았습니다. 사용자들은 대신 bar를 사용해야 합니다")]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a>에 동기와 자세한 내용이 포함되어 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use" title="attributes.diagnostics.must_use"><span>[attributes<wbr>.diagnostics<wbr>.must_use]<span/></a></div>
<h2 id="must_use-속성"><a class="header" href="#must_use-속성"><code>must_use</code> 속성</a></h2>
<div class="rule" id="r-attributes.diagnostics.must_use.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.intro" title="attributes.diagnostics.must_use.intro"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.intro]<span/></a></div>
<p>_<code>must_use</code> 속성_은 값이 “사용“되지 않았을 때 진단 경고를 발생시키는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.allowed-positions"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.allowed-positions" title="attributes.diagnostics.must_use.allowed-positions"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.allowed-positions]<span/></a></div>
<p><code>must_use</code> 속성은 사용자 정의 복합 타입(<a href="attributes/../items/structs.html">구조체</a>, <a href="attributes/../items/enumerations.html">열거형</a>, <a href="attributes/../items/unions.html">공용체</a>), <a href="attributes/../items/functions.html">함수</a>, 그리고 <a href="attributes/../items/traits.html">트레잇</a>에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.message"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.message" title="attributes.diagnostics.must_use.message"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.message]<span/></a></div>
<p><code>must_use</code> 속성은 <code>#[must_use = "예시 메시지"]</code>와 같이 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용하여 메시지를 포함할 수 있습니다. 메시지는 경고와 함께 표시됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.type"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.type" title="attributes.diagnostics.must_use.type"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.type]<span/></a></div>
<p>사용자 정의 복합 타입에 사용된 경우, <a href="attributes/../statements.html#expression-statements">표현식 구문</a>의 <a href="attributes/../expressions.html">표현식</a>이 해당 타입을 가지면 <code>unused_must_use</code> 린트를 위반하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // 몇몇 필드들
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// `unused_must_use` 린트를 위반합니다.
MustUse::new();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.fn"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.fn" title="attributes.diagnostics.must_use.fn"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.fn]<span/></a></div>
<p>함수에 사용된 경우, <a href="attributes/../statements.html#expression-statements">표현식 구문</a>의 <a href="attributes/../expressions.html">표현식</a>이 해당 함수에 대한 <a href="attributes/../expressions/call-expr.html">호출 표현식</a>이면 <code>unused_must_use</code> 린트를 위반하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반합니다.
five();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait" title="attributes.diagnostics.must_use.trait"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait]<span/></a></div>
<p><a href="attributes/../items/traits.html">트레잇 선언</a>에 사용된 경우, 해당 트레잇의 <a href="attributes/../types/impl-trait.html">impl 트레잇</a> 또는 <a href="attributes/../types/trait-object.html">dyn 트레잇</a>을 반환하는 함수에 대한 <a href="attributes/../statements.html#expression-statements">표현식 구문</a>의 <a href="attributes/../expressions/call-expr.html">호출 표현식</a>은 <code>unused_must_use</code> 린트를 위반합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// `unused_must_use` 린트를 위반합니다.
get_critical();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait-function"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait-function" title="attributes.diagnostics.must_use.trait-function"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait-function]<span/></a></div>
<p>트레잇 선언 내의 함수에 사용된 경우, 호출 표현식이 해당 트레잇 구현체의 함수인 경우에도 동일하게 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// `unused_must_use` 린트를 위반합니다.
5i32.use_me();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait-impl-function"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait-impl-function" title="attributes.diagnostics.must_use.trait-impl-function"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait-impl-function]<span/></a></div>
<p>트레잇 구현 내의 함수에 사용된 경우, 이 속성은 아무런 동작도 하지 않습니다.</p>
<blockquote>
<p>참고: 값을 포함하는 사소한 무부하(no-op) 표현식은 린트를 위반하지 않습니다. 예시로는 <a href="attributes/../special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않는 타입으로 값을 감싼 후 해당 타입을 사용하지 않거나, 사용되지 않는 <a href="attributes/../expressions/block-expr.html">블록 표현식</a>의 마지막 표현식이 되는 경우가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 이들 중 어느 것도 `unused_must_use` 린트를 위반하지 않습니다.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>참고: <code>must_use</code> 값이 의도적으로 버려질 때는 패턴이 <code>_</code>인 <a href="attributes/../statements.html#let-statements">let 문</a>을 사용하는 것이 관용적입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반하지 않습니다.
let _ = five();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-attributes.diagnostic.namespace"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.namespace" title="attributes.diagnostic.namespace"><span>[attributes<wbr>.diagnostic<wbr>.namespace]<span/></a></div>
<h2 id="diagnostic-도구-속성-네임스페이스"><a class="header" href="#diagnostic-도구-속성-네임스페이스"><code>diagnostic</code> 도구 속성 네임스페이스</a></h2>
<div class="rule" id="r-attributes.diagnostic.namespace.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.namespace.intro" title="attributes.diagnostic.namespace.intro"><span>[attributes<wbr>.diagnostic<wbr>.namespace<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic]</code> 속성 네임스페이스는 컴파일 타임 에러 메시지에 영향을 주는 속성들을 위한 공간입니다. 이러한 속성들이 제공하는 힌트가 반드시 사용된다는 보장은 없습니다.</p>
<div class="rule" id="r-attributes.diagnostic.namespace.unknown-invalid-syntax"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.namespace.unknown-invalid-syntax" title="attributes.diagnostic.namespace.unknown-invalid-syntax"><span>[attributes<wbr>.diagnostic<wbr>.namespace<wbr>.unknown-invalid-syntax]<span/></a></div>
<p>이 네임스페이스 내의 알 수 없는 속성들은 수용되지만, 사용되지 않는 속성에 대해 경고를 내보낼 수 있습니다. 추가적으로, 알려진 속성에 대한 유효하지 않은 입력은 보통 경고가 됩니다 (자세한 내용은 속성 정의를 참조하세요). 이는 의미 없는 속성이나 옵션들을 계속 유지할 필요 없이 미래에 속성을 추가하거나 제거하고 입력을 변경할 수 있도록 하기 위함입니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented" title="attributes.diagnostic.on_unimplemented"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented]<span/></a></div>
<h3 id="diagnosticon_unimplemented-속성"><a class="header" href="#diagnosticon_unimplemented-속성"><code>diagnostic::on_unimplemented</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.intro" title="attributes.diagnostic.on_unimplemented.intro"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic::on_unimplemented]</code> 속성은 트레잇이 요구되지만 특정 타입에 구현되지 않은 상황에서 보통 생성되는 에러 메시지를 보완하도록 컴파일러에 주는 힌트입니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.allowed-positions"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.allowed-positions" title="attributes.diagnostic.on_unimplemented.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.allowed-positions]<span/></a></div>
<p>이 속성은 <a href="attributes/../items/traits.html">트레잇 선언</a>에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.syntax"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.syntax" title="attributes.diagnostic.on_unimplemented.syntax"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.syntax]<span/></a></div>
<p>이 속성은 입력을 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용하지만, 전방 및 후방 호환성을 제공하기 위해 속성에 대한 잘못된 형식의 입력은 에러로 간주되지 않습니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.keys"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.keys" title="attributes.diagnostic.on_unimplemented.keys"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.keys]<span/></a></div>
<p>다음 키들은 주어진 의미를 갖습니다:</p>
<ul>
<li><code>message</code> — 최상위 레벨 에러 메시지를 위한 텍스트입니다.</li>
<li><code>label</code> — 에러 메시지에서 잘못된 코드 내에 표시될 라벨을 위한 텍스트입니다.</li>
<li><code>note</code> — 추가적인 노트를 제공합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.note-repetition"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.note-repetition" title="attributes.diagnostic.on_unimplemented.note-repetition"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.note-repetition]<span/></a></div>
<p><code>note</code> 옵션은 여러 번 나타날 수 있으며, 그 결과 여러 개의 노트 메시지가 내보내집니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.repetition"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.repetition" title="attributes.diagnostic.on_unimplemented.repetition"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.repetition]<span/></a></div>
<p>다른 옵션들이 여러 번 나타나는 경우, 해당 옵션의 첫 번째 출현이 실제로 사용되는 값을 지정합니다. 이후의 출현은 경고를 발생시킵니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.unknown-keys"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.unknown-keys" title="attributes.diagnostic.on_unimplemented.unknown-keys"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.unknown-keys]<span/></a></div>
<p>알 수 없는 키에 대해서는 경고가 발생합니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-string"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.format-string" title="attributes.diagnostic.on_unimplemented.format-string"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.format-string]<span/></a></div>
<p>세 가지 옵션 모두 문자열을 인수로 받으며, <a href="attributes/../../alloc/fmt/index.html"><code>std::fmt</code></a> 문자열과 동일한 포맷팅 방식을 사용하여 해석됩니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-parameters"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.format-parameters" title="attributes.diagnostic.on_unimplemented.format-parameters"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.format-parameters]<span/></a></div>
<p>주어진 이름을 가진 포맷 매개변수들은 다음 텍스트로 대체됩니다:</p>
<ul>
<li><code>{Self}</code> — 트레잇을 구현하는 타입의 이름입니다.</li>
<li><code>{</code> <em>제네릭매개변수이름</em> <code>}</code> — 주어진 제네릭 매개변수에 대한 제네릭 인수의 타입 이름입니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-formats"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.invalid-formats" title="attributes.diagnostic.on_unimplemented.invalid-formats"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.invalid-formats]<span/></a></div>
<p>그 외의 포맷 매개변수는 경고를 발생시키지만, 문자열에는 그대로 포함됩니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-string"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.invalid-string" title="attributes.diagnostic.on_unimplemented.invalid-string"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.invalid-string]<span/></a></div>
<p>유효하지 않은 포맷 문자열은 경고를 발생시킬 수 있지만, 허용은 됩니다. 다만 의도한 대로 표시되지 않을 수 있습니다. 포맷 지정자(Format specifiers)는 경고를 발생시킬 수 있지만, 무시됩니다.</p>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024">#[diagnostic::on_unimplemented(
    message = "`{Self}`에 구현된 `ImportantTrait&lt;{A}&gt;`에 대한 메시지",
    label = "나의 라벨",
    note = "노트 1",
    note = "노트 2"
)]
trait ImportantTrait&lt;A&gt; {}

fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {}

fn main() {
    use_my_trait(String::new());
}</code></pre></pre>
<p>컴파일러는 다음과 같은 에러 메시지를 생성할 수 있습니다:</p>
<pre><code class="language-text">error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` implemented for `String`
  --&gt; src/main.rs:14:18
   |
14 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String`
   = note: Note 1
   = note: Note 2
</code></pre>
<h3 id="diagnosticdo_not_recommend-속성"><a class="header" href="#diagnosticdo_not_recommend-속성"><code>diagnostic::do_not_recommend</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend" title="attributes.diagnostic.do_not_recommend"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend]<span/></a></div>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.intro"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.intro" title="attributes.diagnostic.do_not_recommend.intro"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic::do_not_recommend]</code> 속성은 진단 메시지의 일부로 해당 트레잇 구현을 표시하지 않도록 컴파일러에 주는 힌트입니다.</p>
<blockquote>
<p><strong>참고</strong>: 권장 사항을 억제하는 것은 해당 권장 사항이 프로그래머에게 보통 유용하지 않을 것임을 알고 있는 경우에 유용할 수 있습니다. 이는 광범위한 blanket 구현에서 종종 발생합니다. 권장 사항이 프로그래머를 잘못된 길로 안내할 수 있거나, 트레잇 구현이 노출하고 싶지 않은 내부 상세 정보일 수 있거나, 프로그래머가 바운드를 충족시킬 수 없는 경우 등이 해당됩니다.</p>
<p>예를 들어, 요구되는 트레잇을 구현하지 않은 타입에 대한 에러 메시지에서, 컴파일러는 트레잇 구현 내의 특정 바운드만 아니었다면 요구 사항을 충족했을 트레잇 구현을 찾을 수도 있습니다. 컴파일러는 사용자에게 구현이 존재하지만 트레잇 구현 내의 바운드가 문제라고 말할 수 있습니다. <code>#[diagnostic::do_not_recommend]</code> 속성은 컴파일러에게 해당 트레잇 구현에 대해 사용자에게 알리지 <em>말고</em>, 대신 단순히 해당 타입이 요구되는 트레잇을 구현하지 않는다고 알리도록 하는 데 사용될 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.allowed-positions"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.allowed-positions" title="attributes.diagnostic.do_not_recommend.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.allowed-positions]<span/></a></div>
<p>이 속성은 <a href="attributes/../items/implementations.html#trait-implementations">트레잇 구현 아이템</a>에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다.</p>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.syntax"><a class="rule-link" href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.syntax" title="attributes.diagnostic.do_not_recommend.syntax"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.syntax]<span/></a></div>
<p>이 속성은 어떤 인수도 받지 않지만, 예상치 못한 인수가 있어도 에러로 간주되지 않습니다.</p>
<p>다음 예시에는 SQL 라이브러리에서 사용되는 <code>Expression</code> 타입으로 임의의 타입을 캐스팅하는 데 사용되는 <code>AsExpression</code>이라는 트레잇이 있습니다. 여기에는 <code>AsExpression</code>을 인수로 받는 <code>check</code>라는 메서드가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">pub trait Expression {
</span><span class="boring">    type SqlType;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait AsExpression&lt;ST&gt; {
</span><span class="boring">    type Expression: Expression&lt;SqlType = ST&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Text;
</span><span class="boring">pub struct Integer;
</span><span class="boring">
</span><span class="boring">pub struct Bound&lt;T&gt;(T);
</span><span class="boring">pub struct SelectInt;
</span><span class="boring">
</span><span class="boring">impl Expression for SelectInt {
</span><span class="boring">    type SqlType = Integer;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Expression for Bound&lt;T&gt; {
</span><span class="boring">    type SqlType = T;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Integer&gt; for i32 {
</span><span class="boring">    type Expression = Bound&lt;Integer&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Text&gt; for &amp;'_ str {
</span><span class="boring">    type Expression = Bound&lt;Text&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Foo for T where T: Expression {}
</span>
// 권장 사항을 변경하려면 이 라인의 주석을 해제하세요.
// #[diagnostic::do_not_recommend]
impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
where
    T: Expression&lt;SqlType = ST&gt;,
{
    type Expression = T;
}

trait Foo: Expression + Sized {
    fn check&lt;T&gt;(&amp;self, _: T) -&gt; &lt;T as AsExpression&lt;&lt;Self as Expression&gt;::SqlType&gt;&gt;::Expression
    where
        T: AsExpression&lt;Self::SqlType&gt;,
    {
        todo!()
    }
}

fn main() {
    SelectInt.check("bar");
}</code></pre></pre>
<p><code>SelectInt</code> 타입의 <code>check</code> 메서드는 <code>Integer</code> 타입을 기대합니다. <code>AsExpression</code> 트레잇에 의해 <code>i32</code> 타입이 <code>Integer</code>로 변환되므로 <code>i32</code> 타입으로 호출하는 것은 작동합니다. 하지만 문자열로 호출하는 것은 작동하지 않으며, 다음과 같은 에러를 발생시킬 수 있습니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: Expression` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `Expression` is not implemented for `&amp;str`
   |
   = help: the following other types implement trait `Expression`:
             Bound&lt;T&gt;
             SelectInt
note: required for `&amp;str` to implement `AsExpression&lt;Integer&gt;`
  --&gt; src/main.rs:45:13
   |
45 | impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
   |             ^^^^^^^^^^^^^^^^     ^
46 | where
47 |     T: Expression&lt;SqlType = ST&gt;,
   |        ------------------------ unsatisfied trait bound introduced here
</code></pre>
<p><code>AsExpression</code>에 대한 blanket <code>impl</code>에 <code>#[diagnostic::do_no_recommend]</code> 속성을 추가하면 메시지가 다음과 같이 변경됩니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: AsExpression&lt;Integer&gt;` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
   |
   = help: the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
           but trait `AsExpression&lt;Text&gt;` is implemented for it
   = help: for that trait implementation, expected `Text`, found `Integer`
</code></pre>
<p>첫 번째 에러 메시지는 <code>&amp;str</code>과 <code>Expression</code> 사이의 관계에 대한 다소 혼란스러운 에러 메시지와, blanket 구현에서의 충족되지 않은 트레잇 바운드를 포함합니다. <code>#[diagnostic::do_no_recommend]</code>를 추가한 후에는 권장 사항을 위해 blanket 구현을 더 이상 고려하지 않습니다. 메시지는 문자열을 <code>Integer</code>로 변환할 수 없음을 나타내며 조금 더 명확해질 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.codegen"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen" title="attributes.codegen"><span>[attributes<wbr>.codegen]<span/></a></div>
<h1 id="코드-생성-속성"><a class="header" href="#코드-생성-속성">코드 생성 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 코드 생성을 제어하는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.codegen.hint"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.hint" title="attributes.codegen.hint"><span>[attributes<wbr>.codegen<wbr>.hint]<span/></a></div>
<h2 id="최적화-힌트"><a class="header" href="#최적화-힌트">최적화 힌트</a></h2>
<div class="rule" id="r-attributes.codegen.hint.cold-inline"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.hint.cold-inline" title="attributes.codegen.hint.cold-inline"><span>[attributes<wbr>.codegen<wbr>.hint<wbr>.cold-inline]<span/></a></div>
<p><code>cold</code>와 <code>inline</code> <a href="attributes/../attributes.html">속성들</a>은 힌트가 없을 때보다 더 빠를 수 있는 방식으로 코드를 생성하도록 제안을 줍니다. 이러한 속성들은 단지 힌트일 뿐이며 무시될 수 있습니다.</p>
<div class="rule" id="r-attributes.codegen.hint.usage"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.hint.usage" title="attributes.codegen.hint.usage"><span>[attributes<wbr>.codegen<wbr>.hint<wbr>.usage]<span/></a></div>
<p>두 속성 모두 <a href="attributes/../items/functions.html">함수</a>에 사용될 수 있습니다. <a href="attributes/../items/traits.html">트레잇</a> 내의 함수에 적용될 때, 이들은 트레잇 구현의 기본 함수로 사용될 때만 해당 함수에 적용되며 모든 트레잇 구현에 적용되지는 않습니다. 본문이 없는 트레잇 함수에는 이 속성들이 아무런 영향을 주지 않습니다.</p>
<div class="rule" id="r-attributes.codegen.inline"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.inline" title="attributes.codegen.inline"><span>[attributes<wbr>.codegen<wbr>.inline]<span/></a></div>
<h3 id="inline-속성"><a class="header" href="#inline-속성"><code>inline</code> 속성</a></h3>
<div class="rule" id="r-attributes.codegen.inline.intro"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.inline.intro" title="attributes.codegen.inline.intro"><span>[attributes<wbr>.codegen<wbr>.inline<wbr>.intro]<span/></a></div>
<p>_<code>inline</code> <a href="attributes/../attributes.html">속성</a>_은 해당 함수가 정의된 곳에서 함수를 호출하는 코드를 생성하는 대신, 호출자 내부에 해당 함수의 복사본을 배치하도록 제안합니다.</p>
<blockquote>
<p><em><strong>참고</strong></em>: <code>rustc</code> 컴파일러는 내부 휴리스틱에 기반하여 함수를 자동으로 인라인화합니다. 잘못된 인라인화는 프로그램을 더 느리게 만들 수 있으므로, 이 속성은 주의해서 사용해야 합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.codegen.inline.modes"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.inline.modes" title="attributes.codegen.inline.modes"><span>[attributes<wbr>.codegen<wbr>.inline<wbr>.modes]<span/></a></div>
<p>inline 속성을 사용하는 세 가지 방법이 있습니다:</p>
<ul>
<li><code>#[inline]</code>은 인라인 확장을 수행할 것을 _제안_합니다.</li>
<li><code>#[inline(always)]</code>는 항상 인라인 확장이 수행되어야 함을 _제안_합니다.</li>
<li><code>#[inline(never)]</code>는 인라인 확장이 절대 수행되지 않아야 함을 _제안_합니다.</li>
</ul>
<blockquote>
<p><em><strong>참고</strong></em>: 모든 형식의 <code>#[inline]</code>은 힌트일 뿐이며, 언어 사양상 호출자 내부에 해당 함수의 복사본을 배치해야 한다는 _요구 사항_은 없습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.codegen.cold"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.cold" title="attributes.codegen.cold"><span>[attributes<wbr>.codegen<wbr>.cold]<span/></a></div>
<h3 id="cold-속성"><a class="header" href="#cold-속성"><code>cold</code> 속성</a></h3>
<p>_<code>cold</code> <a href="attributes/../attributes.html">속성</a>_은 해당 함수가 호출될 가능성이 낮음을 제안합니다.</p>
<div class="rule" id="r-attributes.codegen.no_builtins"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.no_builtins" title="attributes.codegen.no_builtins"><span>[attributes<wbr>.codegen<wbr>.no_builtins]<span/></a></div>
<h2 id="no_builtins-속성"><a class="header" href="#no_builtins-속성"><code>no_builtins</code> 속성</a></h2>
<p>_<code>no_builtins</code> <a href="attributes/../attributes.html">속성</a>_은 특정 코드 패턴을 존재한다고 가정되는 라이브러리 함수의 호출로 최적화하는 것을 비활성화하기 위해 크레이트 레벨에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature" title="attributes.codegen.target_feature"><span>[attributes<wbr>.codegen<wbr>.target_feature]<span/></a></div>
<h2 id="target_feature-속성"><a class="header" href="#target_feature-속성"><code>target_feature</code> 속성</a></h2>
<div class="rule" id="r-attributes.codegen.target_feature.intro"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.intro" title="attributes.codegen.target_feature.intro"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.intro]<span/></a></div>
<p>_<code>target_feature</code> <a href="attributes/../attributes.html">속성</a>_은 특정 플랫폼 아키텍처 기능을 위한 함수 코드 생성을 활성화하기 위해 함수에 적용될 수 있습니다. 활성화할 기능 이름들을 쉼표로 구분한 문자열을 값으로 가지는 단일 키 <code>enable</code>과 함께 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = "avx2")]
</span>#[target_feature(enable = "avx2")]
fn foo_avx2() {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.codegen.target_feature.arch"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.arch" title="attributes.codegen.target_feature.arch"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.arch]<span/></a></div>
<p>각 <a href="attributes/../conditional-compilation.html#target_arch">타겟 아키텍처</a>는 활성화할 수 있는 일련의 기능들을 가지고 있습니다. 크레이트가 컴파일되지 않는 타겟 아키텍처에 대한 기능을 지정하는 것은 에러입니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.closures"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.closures" title="attributes.codegen.target_feature.closures"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.closures]<span/></a></div>
<p><code>target_feature</code>가 주석 처리된 함수 내에 정의된 클로저는 둘러싼 함수의 속성을 상속받습니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.target-ub"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.target-ub" title="attributes.codegen.target_feature.target-ub"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.target-ub]<span/></a></div>
<p>코드가 실행 중인 현재 플랫폼에서 지원하지 않는 기능으로 컴파일된 함수를 호출하는 것은 <a href="attributes/../behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>입니다. 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 예외입니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.safety-restrictions"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions" title="attributes.codegen.target_feature.safety-restrictions"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.safety-restrictions]<span/></a></div>
<p>아래 플랫폼 규칙에서 달리 명시하지 않는 한 다음 제약 사항이 적용됩니다.</p>
<ul>
<li>안전한(safe) <code>#[target_feature]</code> 함수(및 속성을 상속받은 클로저)는 호출자가 피호출자가 활성화한 모든 <code>target_feature</code>를 활성화한 경우에만 안전하게 호출될 수 있습니다. 이 제약 사항은 <code>unsafe</code> 컨텍스트에서는 적용되지 않습니다.</li>
<li>안전한 <code>#[target_feature]</code> 함수(및 속성을 상속받은 클로저)는 강제 변환되는 위치가 피강제변환자가 활성화한 모든 <code>target_feature</code>를 활성화한 컨텍스트인 경우에만 <em>안전한</em> 함수 포인터로 강제 변환될 수 있습니다. 이 제약 사항은 <code>unsafe</code> 함수 포인터에는 적용되지 않습니다.</li>
</ul>
<p>암시적으로 활성화된 기능들도 이 규칙에 포함됩니다. 예를 들어 <code>sse2</code> 함수는 <code>sse</code>로 표시된 함수를 호출할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = "sse2")] {
</span>#[target_feature(enable = "sse")]
fn foo_sse() {}

fn bar() {
    // 여기서 `foo_sse`를 호출하는 것은 안전하지 않습니다. 비록 타겟 플랫폼에서
    // `sse`가 기본적으로 활성화되어 있거나 컴파일러 플래그로 수동 활성화되어 있더라도,
    // 먼저 SSE를 사용할 수 있는지 확인해야 하기 때문입니다.
    unsafe {
        foo_sse();
    }
}

#[target_feature(enable = "sse")]
fn bar_sse() {
    // 여기서 `foo_sse`를 호출하는 것은 안전합니다.
    foo_sse();
    || foo_sse();
}

#[target_feature(enable = "sse2")]
fn bar_sse2() {
    // `sse2`는 `sse`를 포함하므로 여기서 `foo_sse`를 호출하는 것은 안전합니다.
    foo_sse();
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.codegen.target_feature.fn-traits"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.fn-traits" title="attributes.codegen.target_feature.fn-traits"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.fn-traits]<span/></a></div>
<p><code>#[target_feature]</code> 속성이 있는 함수는 <em>절대</em> <code>Fn</code> 계열 트레잇을 구현하지 않습니다. 단, 둘러싼 함수로부터 기능을 상속받은 클로저는 예외입니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.allowed-positions"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.allowed-positions" title="attributes.codegen.target_feature.allowed-positions"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.allowed-positions]<span/></a></div>
<p><code>#[target_feature]</code> 속성은 다음 위치에서 허용되지 않습니다:</p>
<ul>
<li><a href="attributes/../crates-and-source-files.html#r-crate.main"><code>main</code> 함수</a></li>
<li><a href="attributes/../runtime.html#r-runtime.panic_handler"><code>panic_handler</code> 함수</a></li>
<li>안전한 트레잇 메서드</li>
<li>트레잇의 안전한 기본 함수</li>
</ul>
<div class="rule" id="r-attributes.codegen.target_feature.inline"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.inline" title="attributes.codegen.target_feature.inline"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.inline]<span/></a></div>
<p><code>target_feature</code>가 표시된 함수는 주어진 기능을 지원하지 않는 컨텍스트로 인라인화되지 않습니다. <code>#[inline(always)]</code> 속성은 <code>target_feature</code> 속성과 함께 사용될 수 없습니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.availability"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.availability" title="attributes.codegen.target_feature.availability"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.availability]<span/></a></div>
<h3 id="사용-가능한-기능"><a class="header" href="#사용-가능한-기능">사용 가능한 기능</a></h3>
<p>다음은 사용 가능한 기능 이름의 목록입니다.</p>
<div class="rule" id="r-attributes.codegen.target_feature.x86"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.x86" title="attributes.codegen.target_feature.x86"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.x86]<span/></a></div>
<h4 id="x86-또는-x86_64"><a class="header" href="#x86-또는-x86_64"><code>x86</code> 또는 <code>x86_64</code></a></h4>
<p>지원하지 않는 기능으로 코드를 실행하는 것은 이 플랫폼에서 정의되지 않은 동작입니다. 따라서 이 플랫폼에서 <code>#[target_feature]</code> 함수의 사용은 <a href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions">위의 제약 사항</a>을 따릅니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>adx</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Intel_ADX">ADX</a> — 다중 정밀도 덧셈-올림수(Multi-Precision Add-Carry) 명령어 확장</td></tr>
<tr><td><code>aes</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES</a> — 고급 암호화 표준(Advanced Encryption Standard)</td></tr>
<tr><td><code>avx</code></td><td><code>sse4.2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> — 고급 벡터 확장(Advanced Vector Extensions)</td></tr>
<tr><td><code>avx2</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2">AVX2</a> — 고급 벡터 확장 2(Advanced Vector Extensions 2)</td></tr>
<tr><td><code>bmi1</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI1</a> — 비트 조작 명령어 집합(Bit Manipulation Instruction Sets)</td></tr>
<tr><td><code>bmi2</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2">BMI2</a> — 비트 조작 명령어 집합 2(Bit Manipulation Instruction Sets 2)</td></tr>
<tr><td><code>cmpxchg16b</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/cmpxchg8b:cmpxchg16b"><code>cmpxchg16b</code></a> — 16바이트(128비트) 데이터를 원자적으로 비교 및 교환</td></tr>
<tr><td><code>f16c</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/F16C">F16C</a> — 16비트 부동 소수점 변환 명령어</td></tr>
<tr><td><code>fma</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/FMA_instruction_set">FMA3</a> — 3-피연산자 융합 곱셈-더하기(Three-operand fused multiply-add)</td></tr>
<tr><td><code>fxsr</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/fxsave"><code>fxsave</code></a> 및 <a href="https://www.felixcloutier.com/x86/fxrstor"><code>fxrstor</code></a> — x87 FPU, MMX 기술 및 SSE 상태 저장 및 복원</td></tr>
<tr><td><code>lzcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/lzcnt"><code>lzcnt</code></a> — 선행 제로 카운트(Leading zeros count)</td></tr>
<tr><td><code>movbe</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/movbe"><code>movbe</code></a> — 바이트 스왑 후 데이터 이동</td></tr>
<tr><td><code>pclmulqdq</code></td><td><code>sse2</code></td><td><a href="https://www.felixcloutier.com/x86/pclmulqdq"><code>pclmulqdq</code></a> — 팩형 올림수 없는 곱셈 쿼드워드(Packed carry-less multiplication quadword)</td></tr>
<tr><td><code>popcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/popcnt"><code>popcnt</code></a> — 1로 설정된 비트의 개수</td></tr>
<tr><td><code>rdrand</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdrand</code></a> — 난수 읽기</td></tr>
<tr><td><code>rdseed</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdseed</code></a> — 난수 시드 읽기</td></tr>
<tr><td><code>sha</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/Intel_SHA_extensions">SHA</a> — 안전한 해시 알고리즘(Secure Hash Algorithm)</td></tr>
<tr><td><code>sse</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> — 스트리밍 <abbr title="Single Instruction Multiple Data">SIMD</abbr> 확장</td></tr>
<tr><td><code>sse2</code></td><td><code>sse</code></td><td><a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> — 스트리밍 SIMD 확장 2</td></tr>
<tr><td><code>sse3</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/SSE3">SSE3</a> — 스트리밍 SIMD 확장 3</td></tr>
<tr><td><code>sse4.1</code></td><td><code>ssse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.1">SSE4.1</a> — 스트리밍 SIMD 확장 4.1</td></tr>
<tr><td><code>sse4.2</code></td><td><code>sse4.1</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.2">SSE4.2</a> — 스트리밍 SIMD 확장 4.2</td></tr>
<tr><td><code>ssse3</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSSE3">SSSE3</a> — Supplemental Streaming SIMD Extensions 3</td></tr>
<tr><td><code>xsave</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsave"><code>xsave</code></a> — 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsavec</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsavec"><code>xsavec</code></a> — 압축을 사용한 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsaveopt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaveopt"><code>xsaveopt</code></a> — 최적화된 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsaves</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaves"><code>xsaves</code></a> — 관리자용 프로세서 확장 상태 저장</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<div class="rule" id="r-attributes.codegen.target_feature.aarch64"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.aarch64" title="attributes.codegen.target_feature.aarch64"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.aarch64]<span/></a></div>
<h4 id="aarch64"><a class="header" href="#aarch64"><code>aarch64</code></a></h4>
<p>이 플랫폼에서 <code>#[target_feature]</code> 함수의 사용은 <a href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions">위의 제약 사항</a>을 따릅니다.</p>
<p>이러한 기능들에 대한 추가 문서는 <a href="https://developer.arm.com/documentation/ddi0487/latest">ARM 아키텍처 참조 매뉴얼</a> 또는 <a href="https://developer.arm.com">developer.arm.com</a>에서 찾을 수 있습니다.</p>
<blockquote>
<p><em><strong>참고</strong></em>: 다음 기능 쌍들은 사용 시 둘 다 활성화되거나 비활성화되도록 표시되어야 합니다:</p>
<ul>
<li><code>paca</code> 및 <code>pacg</code> (LLVM은 현재 이를 하나의 기능으로 구현함).</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>기능 이름</th></tr></thead><tbody>
<tr><td><code>aes</code></td><td><code>neon</code></td><td>FEAT_AES &amp; FEAT_PMULL — 고급 <abbr title="Single Instruction Multiple Data">SIMD</abbr> AES 및 PMULL 명령어</td></tr>
<tr><td><code>bf16</code></td><td></td><td>FEAT_BF16 — BFloat16 명령어</td></tr>
<tr><td><code>bti</code></td><td></td><td>FEAT_BTI — 분기 타겟 식별(Branch Target Identification)</td></tr>
<tr><td><code>crc</code></td><td></td><td>FEAT_CRC — CRC32 체크섬 명령어</td></tr>
<tr><td><code>dit</code></td><td></td><td>FEAT_DIT — 데이터 독립 타이밍(Data Independent Timing) 명령어</td></tr>
<tr><td><code>dotprod</code></td><td></td><td>FEAT_DotProd — 고급 SIMD Int8 내적(dot product) 명령어</td></tr>
<tr><td><code>dpb</code></td><td></td><td>FEAT_DPB — 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of persistence)</td></tr>
<tr><td><code>dpb2</code></td><td></td><td>FEAT_DPB2 — 깊은 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of deep persistence)</td></tr>
<tr><td><code>f32mm</code></td><td><code>sve</code></td><td>FEAT_F32MM — SVE 단정밀도 부동 소수점 행렬 곱셈 명령어</td></tr>
<tr><td><code>f64mm</code></td><td><code>sve</code></td><td>FEAT_F64MM — SVE 배정밀도 부동 소수점 행렬 곱셈 명령어</td></tr>
<tr><td><code>fcma</code></td><td><code>neon</code></td><td>FEAT_FCMA — 부동 소수점 복소수 지원</td></tr>
<tr><td><code>fhm</code></td><td><code>fp16</code></td><td>FEAT_FHM — 반정밀도 부동 소수점 FMLAL 명령어</td></tr>
<tr><td><code>flagm</code></td><td></td><td>FEAT_FlagM — 조건부 플래그 조작</td></tr>
<tr><td><code>fp16</code></td><td><code>neon</code></td><td>FEAT_FP16 — 반정밀도 부동 소수점 데이터 처리</td></tr>
<tr><td><code>frintts</code></td><td></td><td>FEAT_FRINTTS — 부동 소수점에서 정수로의 변환 도우미 명령어</td></tr>
<tr><td><code>i8mm</code></td><td></td><td>FEAT_I8MM — Int8 행렬 곱셈</td></tr>
<tr><td><code>jsconv</code></td><td><code>neon</code></td><td>FEAT_JSCVT — 자바스크립트 변환 명령어</td></tr>
<tr><td><code>lse</code></td><td></td><td>FEAT_LSE — 대규모 시스템 확장(Large System Extension)</td></tr>
<tr><td><code>lor</code></td><td></td><td>FEAT_LOR — 제한된 순서 영역(Limited Ordering Regions) 확장</td></tr>
<tr><td><code>mte</code></td><td></td><td>FEAT_MTE &amp; FEAT_MTE2 — 메모리 태깅 확장(Memory Tagging Extension)</td></tr>
<tr><td><code>neon</code></td><td></td><td>FEAT_FP &amp; FEAT_AdvSIMD — 부동 소수점 및 고급 SIMD 확장</td></tr>
<tr><td><code>pan</code></td><td></td><td>FEAT_PAN — 특권층 액세스 금지(Privileged Access-Never) 확장</td></tr>
<tr><td><code>paca</code></td><td></td><td>FEAT_PAuth — 포인터 인증 (주소 인증)</td></tr>
<tr><td><code>pacg</code></td><td></td><td>FEAT_PAuth — 포인터 인증 (일반 인증)</td></tr>
<tr><td><code>pmuv3</code></td><td></td><td>FEAT_PMUv3 — 성능 모니터 확장 (v3)</td></tr>
<tr><td><code>rand</code></td><td></td><td>FEAT_RNG — 난수 생성기(Random Number Generator)</td></tr>
<tr><td><code>ras</code></td><td></td><td>FEAT_RAS &amp; FEAT_RASv1p1 — 신뢰성, 가용성 및 서비스성(Reliability, Availability and Serviceability) 확장</td></tr>
<tr><td><code>rcpc</code></td><td></td><td>FEAT_LRCPC — 릴리스 일관성 프로세서 일관성(Release consistent Processor Consistent)</td></tr>
<tr><td><code>rcpc2</code></td><td><code>rcpc</code></td><td>FEAT_LRCPC2 — 즉시 오프셋을 포함한 RcPc</td></tr>
<tr><td><code>rdm</code></td><td></td><td>FEAT_RDM — 반올림 이중 곱셈 누산(Rounding Double Multiply accumulate)</td></tr>
<tr><td><code>sb</code></td><td></td><td>FEAT_SB — 투기적 실행 배리어(Speculation Barrier)</td></tr>
<tr><td><code>sha2</code></td><td><code>neon</code></td><td>FEAT_SHA1 &amp; FEAT_SHA256 — 고급 SIMD SHA 명령어</td></tr>
<tr><td><code>sha3</code></td><td><code>sha2</code></td><td>FEAT_SHA512 &amp; FEAT_SHA3 — 고급 SIMD SHA 명령어</td></tr>
<tr><td><code>sm4</code></td><td><code>neon</code></td><td>FEAT_SM3 &amp; FEAT_SM4 — 고급 SIMD SM3/4 명령어</td></tr>
<tr><td><code>spe</code></td><td></td><td>FEAT_SPE — 통계적 프로파일링 확장(Statistical Profiling Extension)</td></tr>
<tr><td><code>ssbs</code></td><td></td><td>FEAT_SSBS &amp; FEAT_SSBS2 — 투기적 저장소 우회 안전(Speculative Store Bypass Safe)</td></tr>
<tr><td><code>sve</code></td><td><code>fp16</code></td><td>FEAT_SVE — 가변 벡터 확장(Scalable Vector Extension)</td></tr>
<tr><td><code>sve2</code></td><td><code>sve</code></td><td>FEAT_SVE2 — 가변 벡터 확장 2</td></tr>
<tr><td><code>sve2-aes</code></td><td><code>sve2</code>, <code>aes</code></td><td>FEAT_SVE_AES — SVE AES 명령어</td></tr>
<tr><td><code>sve2-sm4</code></td><td><code>sve2</code>, <code>sm4</code></td><td>FEAT_SVE_SM4 — SVE SM4 명령어</td></tr>
<tr><td><code>sve2-sha3</code></td><td><code>sve2</code>, <code>sha3</code></td><td>FEAT_SVE_SHA3 — SVE SHA3 명령어</td></tr>
<tr><td><code>sve2-bitperm</code></td><td><code>sve2</code></td><td>FEAT_SVE_BitPerm — SVE 비트 치환(Bit Permute)</td></tr>
<tr><td><code>tme</code></td><td></td><td>FEAT_TME — 트랜잭셔널 메모리 확장(Transactional Memory Extension)</td></tr>
<tr><td><code>vh</code></td><td></td><td>FEAT_VHE — 가상화 호스트 확장(Virtualization Host Extensions)</td></tr>
</tbody></table>
</div><div class="rule" id="r-attributes.codegen.target_feature.riscv"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.riscv" title="attributes.codegen.target_feature.riscv"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.riscv]<span/></a></div>
<h4 id="riscv32-또는-riscv64"><a class="header" href="#riscv32-또는-riscv64"><code>riscv32</code> 또는 <code>riscv64</code></a></h4>
<p>이 플랫폼에서 <code>#[target_feature]</code> 함수의 사용은 <a href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions">위의 제약 사항</a>을 따릅니다.</p>
<p>이러한 기능들에 대한 추가 문서는 각각의 명세서에서 찾을 수 있습니다. 많은 명세들이 <a href="https://github.com/riscv/riscv-isa-manual">RISC-V ISA 매뉴얼</a>이나 <a href="https://github.com/riscv">RISC-V GitHub 계정</a>에서 호스팅되는 다른 매뉴얼들에 설명되어 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>a</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/a-st-ext.adoc">A</a> — 원자적(Atomic) 명령어</td></tr>
<tr><td><code>c</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/c-st-ext.adoc">C</a> — 압축(Compressed) 명령어</td></tr>
<tr><td><code>m</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/m-st-ext.adoc">M</a> — 정수 곱셈 및 나눗셈 명령어</td></tr>
<tr><td><code>zb</code></td><td><code>zba</code>, <code>zbc</code>, <code>zbs</code></td><td><a href="https://github.com/riscv/riscv-bitmanip">Zb</a> — 비트 조작 명령어</td></tr>
<tr><td><code>zba</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zba.adoc">Zba</a> — 주소 생성 명령어</td></tr>
<tr><td><code>zbb</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbb.adoc">Zbb</a> — 기본 비트 조작</td></tr>
<tr><td><code>zbc</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc">Zbc</a> — 올림수 없는 곱셈(Carry-less multiplication)</td></tr>
<tr><td><code>zbkb</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkb.adoc">Zbkb</a> — 암호화용 비트 조작 명령어</td></tr>
<tr><td><code>zbkc</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc">Zbkc</a> — 암호화용 올림수 없는 곱셈</td></tr>
<tr><td><code>zbkx</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkx.adoc">Zbkx</a> — 크로스바 치환(Crossbar permutations)</td></tr>
<tr><td><code>zbs</code></td><td></td><td><a href="https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbs.adoc">Zbs</a> — 단일 비트 명령어</td></tr>
<tr><td><code>zk</code></td><td><code>zkn</code>, <code>zkr</code>, <code>zks</code>, <code>zkt</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zk.adoc">Zk</a> — 스칼라 암호화(Scalar Cryptography)</td></tr>
<tr><td><code>zkn</code></td><td><code>zknd</code>, <code>zkne</code>, <code>zknh</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkn.adoc">Zkn</a> — NIST 알고리즘 스위트 확장</td></tr>
<tr><td><code>zknd</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zknd.adoc">Zknd</a> — NIST 스위트: AES 복호화</td></tr>
<tr><td><code>zkne</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkne.adoc">Zkne</a> — NIST 스위트: AES 암호화</td></tr>
<tr><td><code>zknh</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zknh.adoc">Zknh</a> — NIST 스위트: 해시 함수 명령어</td></tr>
<tr><td><code>zkr</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkr.adoc">Zkr</a> — 엔트로피 소스 확장</td></tr>
<tr><td><code>zks</code></td><td><code>zksed</code>, <code>zksh</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zks.adoc">Zks</a> — ShangMi 알고리즘 스위트</td></tr>
<tr><td><code>zksed</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zksed.adoc">Zksed</a> — ShangMi 스위트: SM4 블록 암호 명령어</td></tr>
<tr><td><code>zksh</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zksh.adoc">Zksh</a> — ShangMi 스위트: SM3 해시 함수 명령어</td></tr>
<tr><td><code>zkt</code></td><td></td><td><a href="https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkt.adoc">Zkt</a> — 데이터 독립적 실행 지연 시간(Data Independent Execution Latency) 서브셋</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<div class="rule" id="r-attributes.codegen.target_feature.wasm"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.wasm" title="attributes.codegen.target_feature.wasm"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.wasm]<span/></a></div>
<h4 id="wasm32-또는-wasm64"><a class="header" href="#wasm32-또는-wasm64"><code>wasm32</code> 또는 <code>wasm64</code></a></h4>
<p>Wasm 플랫폼에서 안전한(safe) <code>#[target_feature]</code> 함수는 항상 안전한 컨텍스트에서 사용될 수 있습니다. <code>#[target_feature]</code> 속성을 통해 정의되지 않은 동작을 유발하는 것은 불가능합니다. 왜냐하면 Wasm 엔진이 지원하지 않는 명령어를 사용하려는 시도는 로드 시점에 실패하며, 컴파일러가 예상한 것과 다르게 해석될 위험이 없기 때문입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>bulk-memory</code></td><td></td><td><a href="https://github.com/WebAssembly/bulk-memory-operations">WebAssembly 대량 메모리 연산 제안(bulk memory operations proposal)</a></td></tr>
<tr><td><code>extended-const</code></td><td></td><td><a href="https://github.com/WebAssembly/extended-const">WebAssembly 확장 상수 표현식 제안(extended const expressions proposal)</a></td></tr>
<tr><td><code>mutable-globals</code></td><td></td><td><a href="https://github.com/WebAssembly/mutable-global">WebAssembly 가변 전역 변수 제안(mutable global proposal)</a></td></tr>
<tr><td><code>nontrapping-fptoint</code></td><td></td><td><a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">WebAssembly 비-트래핑 부동 소수점-정수 변환 제안(non-trapping float-to-int conversion proposal)</a></td></tr>
<tr><td><code>relaxed-simd</code></td><td><code>simd128</code></td><td><a href="https://github.com/WebAssembly/relaxed-simd">WebAssembly relaxed SIMD 제안</a></td></tr>
<tr><td><code>sign-ext</code></td><td></td><td><a href="https://github.com/WebAssembly/sign-extension-ops">WebAssembly 부호 확장 연산자 제안(sign extension operators Proposal)</a></td></tr>
<tr><td><code>simd128</code></td><td></td><td><a href="https://github.com/webassembly/simd">WebAssembly SIMD 제안</a></td></tr>
<tr><td><code>multivalue</code></td><td></td><td><a href="https://github.com/webassembly/multi-value">WebAssembly multivalue 제안</a></td></tr>
<tr><td><code>reference-types</code></td><td></td><td><a href="https://github.com/webassembly/reference-types">WebAssembly reference-types 제안</a></td></tr>
<tr><td><code>tail-call</code></td><td></td><td><a href="https://github.com/webassembly/tail-call">WebAssembly tail-call 제안</a></td></tr>
</tbody></table>
</div><div class="rule" id="r-attributes.codegen.target_feature.info"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.info" title="attributes.codegen.target_feature.info"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.info]<span/></a></div>
<h3 id="추가-정보"><a class="header" href="#추가-정보">추가 정보</a></h3>
<div class="rule" id="r-attributes.codegen.target_feature.remark-cfg"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.remark-cfg" title="attributes.codegen.target_feature.remark-cfg"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.remark-cfg]<span/></a></div>
<p>컴파일 타임 설정에 기반하여 코드 컴파일을 선택적으로 활성화하거나 비활성화하려면 <a href="attributes/../conditional-compilation.html#target_feature"><code>target_feature</code> 조건부 컴파일 옵션</a>을 참조하세요. 이 옵션은 <code>target_feature</code> 속성의 영향을 받지 않으며, 오직 크레이트 전체에 대해 활성화된 기능들에 의해서만 구동된다는 점에 유의하세요.</p>
<div class="rule" id="r-attributes.codegen.target_feature.remark-rt"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.target_feature.remark-rt" title="attributes.codegen.target_feature.remark-rt"><span>[attributes<wbr>.codegen<wbr>.target_feature<wbr>.remark-rt]<span/></a></div>
<p>이러한 플랫폼에서의 런타임 기능 감지에 대해서는 표준 라이브러리의 <a href="attributes/../../std/arch/macro.is_x86_feature_detected.html"><code>is_x86_feature_detected</code></a> 또는 <a href="attributes/../../std/arch/macro.is_aarch64_feature_detected.html"><code>is_aarch64_feature_detected</code></a> 매크로를 참조하세요.</p>
<blockquote>
<p>참고: <code>rustc</code>는 각 타겟 및 CPU에 대해 기본적으로 활성화된 일련의 기능들을 가지고 있습니다. CPU는 <a href="attributes/../../rustc/codegen-options/index.html#target-cpu"><code>-C target-cpu</code></a> 플래그로 선택할 수 있습니다. 개별 기능들은 <a href="attributes/../../rustc/codegen-options/index.html#target-feature"><code>-C target-feature</code></a> 플래그를 사용하여 크레이트 전체에 대해 활성화하거나 비활성화할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.codegen.track_caller"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller" title="attributes.codegen.track_caller"><span>[attributes<wbr>.codegen<wbr>.track_caller]<span/></a></div>
<h2 id="track_caller-속성"><a class="header" href="#track_caller-속성"><code>track_caller</code> 속성</a></h2>
<div class="rule" id="r-attributes.codegen.track_caller.allowed-positions"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.allowed-positions" title="attributes.codegen.track_caller.allowed-positions"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.allowed-positions]<span/></a></div>
<p><code>track_caller</code> 속성은 <code>fn main</code> 엔트리 포인트를 제외하고, <a href="attributes/../items/external-blocks.html#abi"><code>"Rust"</code> ABI</a>를 가진 모든 함수에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.codegen.track_caller.traits"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.traits" title="attributes.codegen.track_caller.traits"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.traits]<span/></a></div>
<p>트레잇 선언의 함수와 메서드에 적용될 경우, 이 속성은 모든 구현체에 적용됩니다. 만약 트레잇이 속성과 함께 기본 구현을 제공한다면, 이 속성은 오버라이드된 구현체들에도 적용됩니다.</p>
<div class="rule" id="r-attributes.codegen.track_caller.extern"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.extern" title="attributes.codegen.track_caller.extern"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.extern]<span/></a></div>
<p><code>extern</code> 블록 내의 함수에 적용될 경우, 이 속성은 연결된 모든 구현체에도 반드시 적용되어야 합니다. 그렇지 않으면 정의되지 않은 동작(undefined behavior)이 발생합니다. <code>extern</code> 블록에서 사용 가능하도록 만들어진 함수에 적용될 경우, <code>extern</code> 블록 내의 선언부에도 반드시 이 속성이 있어야 합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</p>
<div class="rule" id="r-attributes.codegen.track_caller.behavior"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.behavior" title="attributes.codegen.track_caller.behavior"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.behavior]<span/></a></div>
<h3 id="동작"><a class="header" href="#동작">동작</a></h3>
<p>함수 <code>f</code>에 이 속성을 적용하면 <code>f</code> 내부의 코드가 <code>f</code>를 호출하게 만든 “최상위” 추적 호출의 <a href="attributes/../../core/panic/location/struct.Location.html"><code>Location</code></a> 힌트를 얻을 수 있게 됩니다. 관찰 시점에, 구현체는 <code>f</code>의 프레임에서 스택을 거슬러 올라가 속성이 붙지 않은 가장 가까운 함수 <code>outer</code>의 프레임을 찾고, <code>outer</code>에서의 추적된 호출 위치(<a href="attributes/../../core/panic/location/struct.Location.html"><code>Location</code></a>)를 반환하는 것처럼 동작합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[track_caller]
fn f() {
    println!("{}", std::panic::Location::caller());
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>core</code>는 호출자의 위치를 관찰하기 위해 <a href="attributes/../../core/panic/location/struct.Location.html#method.caller"><code>core::panic::Location::caller</code></a>를 제공합니다. 이는 <code>rustc</code>에 의해 구현된 <a href="attributes/../../core/intrinsics/fn.caller_location.html"><code>core::intrinsics::caller_location</code></a> 내장(intrinsic) 기능을 감싸고 있습니다.</p>
</blockquote>
<blockquote>
<p>참고: 결과로 나오는 <code>Location</code>은 힌트이므로, 구현체는 스택을 거슬러 올라가는 과정을 일찍 중단할 수 있습니다. 중요한 주의 사항에 대해서는 <a href="attributes/codegen.html#limitations">제한 사항</a>을 참조하세요.</p>
</blockquote>
<h4 id="예시-2"><a class="header" href="#예시-2">예시</a></h4>
<p><code>f</code>가 <code>calls_f</code>에 의해 직접 호출될 때, <code>f</code> 내부의 코드는 <code>calls_f</code> 내의 호출 지점(callsite)을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span>fn calls_f() {
    f(); // &lt;-- f()가 이 위치를 출력함
}
<span class="boring">}</span></code></pre></pre>
<p><code>f</code>가 속성이 붙은 다른 함수 <code>g</code>에 의해 호출되고, <code>g</code>가 다시 <code>calls_g</code>에 의해 호출될 때, <code>f</code>와 <code>g</code> 모두의 코드는 <code>calls_g</code> 내의 <code>g</code> 호출 지점을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span>#[track_caller]
fn g() {
    println!("{}", std::panic::Location::caller());
    f();
}

fn calls_g() {
    g(); // &lt;-- g()가 이 위치를 두 번 출력함 (한 번은 자기 자신, 한 번은 f()로부터)
}
<span class="boring">}</span></code></pre></pre>
<p><code>g</code>가 속성이 붙은 다른 함수 <code>h</code>에 의해 호출되고, <code>h</code>가 다시 <code>calls_h</code>에 의해 호출될 때, <code>f</code>, <code>g</code>, <code>h</code> 내부의 모든 코드는 <code>calls_h</code> 내의 <code>h</code> 호출 지점을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span><span class="boring">#[track_caller]
</span><span class="boring">fn g() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">    f();
</span><span class="boring">}
</span>#[track_caller]
fn h() {
    println!("{}", std::panic::Location::caller());
    g();
}

fn calls_h() {
    h(); // &lt;-- 이 위치를 세 번 출력함 (한 번은 자기 자신, 한 번은 g()로부터, 한 번은 f()로부터)
}
<span class="boring">}</span></code></pre></pre>
<p>기타 등등.</p>
<div class="rule" id="r-attributes.codegen.track_caller.limits"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.limits" title="attributes.codegen.track_caller.limits"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.limits]<span/></a></div>
<h3 id="제한-사항"><a class="header" href="#제한-사항">제한 사항</a></h3>
<div class="rule" id="r-attributes.codegen.track_caller.hint"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.hint" title="attributes.codegen.track_caller.hint"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.hint]<span/></a></div>
<p>이 정보는 힌트일 뿐이며 구현체가 이를 반드시 보존해야 할 요구 사항은 없습니다.</p>
<div class="rule" id="r-attributes.codegen.track_caller.decay"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.track_caller.decay" title="attributes.codegen.track_caller.decay"><span>[attributes<wbr>.codegen<wbr>.track_caller<wbr>.decay]<span/></a></div>
<p>특히, <code>#[track_caller]</code>가 붙은 함수를 함수 포인터로 강제 변환하면 심(shim)이 생성됩니다. 이 심은 관찰자에게 해당 함수가 정의된 위치에서 호출된 것처럼 보이게 하여, 가상 호출(virtual calls) 시 실제 호출자 정보를 잃게 만듭니다. 이러한 강제 변환의 흔한 예시는 메서드에 속성이 붙은 트레잇 객체를 생성하는 경우입니다.</p>
<blockquote>
<p>참고: 앞서 언급한 함수 포인터를 위한 심(shim)이 필요한 이유는, <code>rustc</code>가 함수 ABI에 암시적 매개변수를 추가함으로써 코드 생성 컨텍스트에서 <code>track_caller</code>를 구현하기 때문입니다. 하지만 이는 간접 호출(indirect call)의 경우 불안정할 수 있는데, 해당 매개변수가 함수의 타입의 일부가 아니며 주어진 함수 포인터 타입이 속성이 있는 함수를 참조할 수도 있고 아닐 수도 있기 때문입니다. 심을 생성함으로써 함수 포인터 호출자로부터 암시적 매개변수를 숨겨서 안정성을 유지합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.codegen.instruction_set"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set" title="attributes.codegen.instruction_set"><span>[attributes<wbr>.codegen<wbr>.instruction_set]<span/></a></div>
<h2 id="instruction_set-속성"><a class="header" href="#instruction_set-속성"><code>instruction_set</code> 속성</a></h2>
<div class="rule" id="r-attributes.codegen.instruction_set.allowed-positions"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set.allowed-positions" title="attributes.codegen.instruction_set.allowed-positions"><span>[attributes<wbr>.codegen<wbr>.instruction_set<wbr>.allowed-positions]<span/></a></div>
<p>_<code>instruction_set</code> <a href="attributes/../attributes.html">속성</a>_은 해당 함수가 어떤 명령어 집합(instruction set)으로 생성될지를 제어하기 위해 함수에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.codegen.instruction_set.behavior"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set.behavior" title="attributes.codegen.instruction_set.behavior"><span>[attributes<wbr>.codegen<wbr>.instruction_set<wbr>.behavior]<span/></a></div>
<p>이를 통해 이를 지원하는 CPU 아키텍처에서 단일 프로그램 내에 하나 이상의 명령어 집합을 혼용할 수 있습니다.</p>
<div class="rule" id="r-attributes.codegen.instruction_set.syntax"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set.syntax" title="attributes.codegen.instruction_set.syntax"><span>[attributes<wbr>.codegen<wbr>.instruction_set<wbr>.syntax]<span/></a></div>
<p>이 속성은 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPath</em></a> 구문을 사용하며, 아키텍처 계열 이름과 명령어 집합 이름으로 구성된 경로를 인수로 받습니다.</p>
<div class="rule" id="r-attributes.codegen.instruction_set.target-limits"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set.target-limits" title="attributes.codegen.instruction_set.target-limits"><span>[attributes<wbr>.codegen<wbr>.instruction_set<wbr>.target-limits]<span/></a></div>
<p>지원을 하지 않는 타겟에서 <code>instruction_set</code> 속성을 사용하는 것은 컴파일 에러입니다.</p>
<div class="rule" id="r-attributes.codegen.instruction_set.arm"><a class="rule-link" href="attributes/codegen.html#r-attributes.codegen.instruction_set.arm" title="attributes.codegen.instruction_set.arm"><span>[attributes<wbr>.codegen<wbr>.instruction_set<wbr>.arm]<span/></a></div>
<h3 id="arm에서"><a class="header" href="#arm에서">ARM에서</a></h3>
<p><code>ARMv4T</code> 및 <code>ARMv5te</code> 아키텍처의 경우, 다음이 지원됩니다:</p>
<ul>
<li><code>arm::a32</code> — 함수를 A32 “ARM” 코드로 생성합니다.</li>
<li><code>arm::t32</code> — 함수를 T32 “Thumb” 코드로 생성합니다.</li>
</ul>
<!-- ignore: arm-only -->
<pre><code class="language-rust ignore">#[instruction_set(arm::a32)]
fn foo_arm_code() {}

#[instruction_set(arm::t32)]
fn bar_thumb_code() {}</code></pre>
<p><code>instruction_set</code> 속성을 사용하는 것은 다음과 같은 효과를 가집니다:</p>
<ul>
<li>함수의 주소를 함수 포인터로 취하는 경우, 명령어 집합에 따라 주소의 하위 비트가 0(arm) 또는 1(thumb)로 설정됩니다.</li>
<li>함수 내의 모든 인라인 어셈블리는 타겟 기본값 대신 지정된 명령어 집합을 사용해야 합니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.limits"><a class="rule-link" href="attributes/limits.html#r-attributes.limits" title="attributes.limits"><span>[attributes<wbr>.limits]<span/></a></div>
<h1 id="제한"><a class="header" href="#제한">제한</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 컴파일 타임 제한에 영향을 줍니다.</p>
<div class="rule" id="r-attributes.limits.recursion_limit"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.recursion_limit" title="attributes.limits.recursion_limit"><span>[attributes<wbr>.limits<wbr>.recursion_limit]<span/></a></div>
<h2 id="recursion_limit-속성"><a class="header" href="#recursion_limit-속성"><code>recursion_limit</code> 속성</a></h2>
<div class="rule" id="r-attributes.limits.recursion_limit.intro"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.recursion_limit.intro" title="attributes.limits.recursion_limit.intro"><span>[attributes<wbr>.limits<wbr>.recursion_limit<wbr>.intro]<span/></a></div>
<p>_<code>recursion_limit</code> 속성_은 매크로 확장이나 자동 역참조(auto-dereference)와 같이 잠재적으로 무한히 재귀적인 컴파일 타임 연산의 최대 깊이를 설정하기 위해 <a href="attributes/../crates-and-source-files.html">크레이트</a> 레벨에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.limits.recursion_limit.syntax"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.recursion_limit.syntax" title="attributes.limits.recursion_limit.syntax"><span>[attributes<wbr>.limits<wbr>.recursion_limit<wbr>.syntax]<span/></a></div>
<p>이 속성은 재귀 깊이를 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용합니다.</p>
<blockquote>
<p>참고: <code>rustc</code>의 기본값은 128입니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = "4"]

<span class="boring">fn main() {
</span>macro_rules! a {
    () =&gt; { a!(1); };
    (1) =&gt; { a!(2); };
    (2) =&gt; { a!(3); };
    (3) =&gt; { a!(4); };
    (4) =&gt; { };
}

// 이는 4보다 큰 재귀 깊이를 요구하므로 확장에 실패합니다.
a!{}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = "1"]

<span class="boring">fn main() {
</span>// 이는 자동 역참조를 위해 두 번의 재귀 단계가 필요하므로 실패합니다.
(|_: &amp;u8| {})(&amp;&amp;&amp;1);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.limits.type_length_limit"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.type_length_limit" title="attributes.limits.type_length_limit"><span>[attributes<wbr>.limits<wbr>.type_length_limit]<span/></a></div>
<h2 id="type_length_limit-속성"><a class="header" href="#type_length_limit-속성"><code>type_length_limit</code> 속성</a></h2>
<blockquote>
<p><strong>참고</strong>: 이 제한은 나이틀리(nightly) <code>-Zenforce-type-length-limit</code> 플래그가 활성화된 경우에만 적용됩니다.</p>
<p>자세한 내용은 <a href="https://github.com/rust-lang/rust/pull/127670">https://github.com/rust-lang/rust/pull/127670</a>을 참조하세요.</p>
</blockquote>
<div class="rule" id="r-attributes.limits.type_length_limit.intro"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.type_length_limit.intro" title="attributes.limits.type_length_limit.intro"><span>[attributes<wbr>.limits<wbr>.type_length_limit<wbr>.intro]<span/></a></div>
<p>_<code>type_length_limit</code> 속성_은 모노모르포화 과정에서 구체적인 타입을 생성할 때 수행되는 타입 치환(type substitutions)의 최대 횟수를 제한합니다.</p>
<div class="rule" id="r-attributes.limits.type_length_limit.syntax"><a class="rule-link" href="attributes/limits.html#r-attributes.limits.type_length_limit.syntax" title="attributes.limits.type_length_limit.syntax"><span>[attributes<wbr>.limits<wbr>.type_length_limit<wbr>.syntax]<span/></a></div>
<p>이 속성은 <a href="attributes/../crates-and-source-files.html">크레이트</a> 레벨에 적용되며, 타입 치환 횟수에 기반하여 제한을 설정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용합니다.</p>
<blockquote>
<p>참고: <code>rustc</code>의 기본값은 1048576입니다.</p>
</blockquote>
<pre><code class="language-rust ignore">#![type_length_limit = "4"]

fn f&lt;T&gt;(x: T) {}

// 이는 `f::&lt;((((i32,), i32), i32), i32)&gt;`로 모노모르포화하는 데 4개 이상의 타입
// 요소가 필요하므로 컴파일에 실패합니다.
f(((((1,), 2), 3), 4));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.type-system"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system" title="attributes.type-system"><span>[attributes<wbr>.type-system]<span/></a></div>
<h1 id="타입-시스템-속성"><a class="header" href="#타입-시스템-속성">타입 시스템 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 타입이 사용되는 방식을 변경하는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.type-system.non_exhaustive"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive" title="attributes.type-system.non_exhaustive"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive]<span/></a></div>
<h2 id="non_exhaustive-속성"><a class="header" href="#non_exhaustive-속성"><code>non_exhaustive</code> 속성</a></h2>
<div class="rule" id="r-attributes.type-system.non_exhaustive.intro"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.intro" title="attributes.type-system.non_exhaustive.intro"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.intro]<span/></a></div>
<p>_<code>non_exhaustive</code> 속성_은 타입이나 변형에 미래에 더 많은 필드나 변형이 추가될 수 있음을 나타냅니다.</p>
<div class="rule" id="r-attributes.type-system.non_exhaustive.allowed-positions"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.allowed-positions" title="attributes.type-system.non_exhaustive.allowed-positions"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.allowed-positions]<span/></a></div>
<p>이 속성은 <a href="attributes/../items/structs.html">구조체</a>, <a href="attributes/../items/enumerations.html">열거형</a>, 그리고 열거형 변형에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.type-system.non_exhaustive.syntax"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.syntax" title="attributes.type-system.non_exhaustive.syntax"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.syntax]<span/></a></div>
<p><code>non_exhaustive</code> 속성은 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaWord</em></a> 구문을 사용하며, 따라서 어떠한 입력도 받지 않습니다.</p>
<div class="rule" id="r-attributes.type-system.non_exhaustive.same-crate"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.same-crate" title="attributes.type-system.non_exhaustive.same-crate"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.same-crate]<span/></a></div>
<p>정의하는 크레이트 내에서 <code>non_exhaustive</code>는 아무런 효과가 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Config {
    pub window_width: u16,
    pub window_height: u16,
}

#[non_exhaustive]
pub struct Token;

#[non_exhaustive]
pub struct Id(pub u64);

#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

pub enum Message {
    #[non_exhaustive] Send { from: u32, to: u32, contents: String },
    #[non_exhaustive] Reaction(u32),
    #[non_exhaustive] Quit,
}

// 비완전(non-exhaustive) 구조체는 정의하는 크레이트 내에서 평소와 같이 생성될 수 있습니다.
let config = Config { window_width: 640, window_height: 480 };
let token = Token;
let id = Id(4);

// 비완전 구조체는 정의하는 크레이트 내에서 완전하게(exhaustively) 매칭될 수 있습니다.
let Config { window_width, window_height } = config;
let Token = token;
let Id(id_number) = id;

let error = Error::Other;
let message = Message::Reaction(3);

// 비완전 열거형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.
match error {
    Error::Message(ref s) =&gt; { },
    Error::Other =&gt; { },
}

match message {
    // 비완전 변형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.
    Message::Send { from, to, contents } =&gt; { },
    Message::Reaction(id) =&gt; { },
    Message::Quit =&gt; { },
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.type-system.non_exhaustive.external-crate"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.external-crate" title="attributes.type-system.non_exhaustive.external-crate"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.external-crate]<span/></a></div>
<p>정의하는 크레이트 외부에서, <code>non_exhaustive</code>가 주석 처리된 타입은 새로운 필드나 변형이 추가될 때 하위 호환성을 유지하기 위한 제약 사항을 가집니다.</p>
<div class="rule" id="r-attributes.type-system.non_exhaustive.construction"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.construction" title="attributes.type-system.non_exhaustive.construction"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.construction]<span/></a></div>
<p>비완전 타입은 정의하는 크레이트 외부에서 생성될 수 없습니다.</p>
<ul>
<li>비완전 변형(<a href="attributes/../items/structs.html">구조체</a> 또는 <a href="attributes/../items/enumerations.html">열거형 변형</a>)은 <a href="attributes/../expressions/struct-expr.html"><em>구조체표현식</em></a>(<a href="attributes/../expressions/struct-expr.html#functional-update-syntax">함수형 업데이트 구문</a> 포함)으로 생성될 수 없습니다.</li>
<li><a href="attributes/../items/structs.html">유닛 유사 구조체</a>의 암시적으로 정의된 동일 이름의 상수나, <a href="attributes/../items/structs.html">튜플 구조체</a>의 동일 이름의 생성자 함수는 <code>pub(crate)</code>보다 크지 않은 <a href="attributes/../visibility-and-privacy.html">가시성</a>을 가집니다. 즉, 구조체의 가시성이 <code>pub</code>인 경우 상수나 생성자의 가시성은 <code>pub(crate)</code>가 되며, 그 외의 경우 두 아이템의 가시성은 동일합니다 (<code>#[non_exhaustive]</code>가 없는 경우와 같습니다).</li>
<li><a href="attributes/../items/enumerations.html"><code>열거형(enum)</code></a> 인스턴스는 생성될 수 있습니다.</li>
</ul>
<p>정의하는 크레이트 외부에서는 다음과 같은 생성 예시들이 컴파일되지 않습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// 이들은 업스트림 크레이트에서 `#[non_exhaustive]`가 주석 처리된 상태로 정의된 타입들입니다.
use upstream::{Config, Token, Id, Error, Message};

// `Config` 인스턴스를 생성할 수 없습니다. 만약 업스트림의 새로운 버전에서
// 새로운 필드가 추가된다면 컴파일에 실패할 것이므로, 이를 불허합니다.
let config = Config { window_width: 640, window_height: 480 };

// `Token` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면
// 더 이상 유닛 유사 구조체가 아닐 것이므로, 유닛 유사 구조체로서 생성된
// 동일 이름의 상수는 크레이트 외부에서 공개되지 않습니다.
// 이 코드는 컴파일에 실패합니다.
let token = Token;

// `Id` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면
// 생성자 함수의 시그니처가 변경될 것이므로, 생성자 함수가 크레이트 외부에서
// 공개되지 않습니다. 이 코드는 컴파일에 실패합니다.
let id = Id(5);

// `Error` 인스턴스는 생성할 수 있습니다. 새로운 변형이 도입되더라도
// 이 코드가 컴파일에 실패하는 결과로 이어지지는 않기 때문입니다.
let error = Error::Message("foo".to_string());

// `Message::Send` 또는 `Message::Reaction` 인스턴스를 생성할 수 없습니다.
// 만약 업스트림의 새로운 버전에서 새로운 필드가 추가된다면
// 컴파일에 실패할 것이므로, 이를 불허합니다.
let message = Message::Send { from: 0, to: 1, contents: "foo".to_string(), };
let message = Message::Reaction(0);

// `Message::Quit` 인스턴스를 생성할 수 없습니다. 만약 업스트림에서
// 이를 튜플 변형으로 변환한다면 컴파일에 실패할 것이기 때문입니다.
let message = Message::Quit;</code></pre>
<div class="rule" id="r-attributes.type-system.non_exhaustive.match"><a class="rule-link" href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.match" title="attributes.type-system.non_exhaustive.match"><span>[attributes<wbr>.type-system<wbr>.non_exhaustive<wbr>.match]<span/></a></div>
<p>정의하는 크레이트 외부에서 비완전 타입을 매칭할 때 다음과 같은 제약 사항이 있습니다.</p>
<ul>
<li>비완전 변형(<a href="attributes/../items/structs.html">구조체</a> 또는 <a href="attributes/../items/enumerations.html">열거형 변형</a>)에 대해 패턴 매칭을 할 때, 반드시 <code>..</code>을 포함하는 <a href="attributes/../patterns.html#struct-patterns"><em>구조체패턴</em></a>을 사용해야 합니다. 튜플 변형 생성자의 <a href="attributes/../visibility-and-privacy.html">가시성</a>은 <code>pub(crate)</code>보다 크지 않도록 축소됩니다.</li>
<li>비완전 <a href="attributes/../items/enumerations.html"><code>열거형(enum)</code></a>에 대해 패턴 매칭을 할 때, 특정 변형에 대해 매치하는 것은 매치 암(arms)의 완전성(exhaustiveness)에 기여하지 않습니다.</li>
</ul>
<p>정의하는 크레이트 외부에서는 다음과 같은 매칭 예시들이 컴파일되지 않습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust  ignore">// 이들은 업스트림 크레이트에서 `#[non_exhaustive]`가 주석 처리된 상태로 정의된 타입들입니다.
use upstream::{Config, Token, Id, Error, Message};

// 와일드카드 암(arm)을 포함하지 않고는 비완전 열거형을 매칭할 수 없습니다.
match error {
  Error::Message(ref s) =&gt; { },
  Error::Other =&gt; { },
  // `_ =&gt; {},`를 추가하면 컴파일됩니다.
}

// 와일드카드 없이 비완전 구조체를 매칭할 수 없습니다.
if let Ok(Config { window_width, window_height }) = config {
    // `..`을 추가하면 컴파일됩니다.
}

// 중괄호 구조체 구문과 와일드카드를 사용하지 않고는 비완전 유닛 유사 또는 튜플 구조체를 매칭할 수 없습니다.
// 이는 `let Token { .. } = token;`으로 작성해야 컴파일됩니다.
let Token = token;
// 이는 `let Id { 0: id_number, .. } = id;`로 작성해야 컴파일됩니다.
let Id(id_number) = id;

match message {
  // 와일드카드를 포함하지 않고는 비완전 구조체형 열거형 변형을 매칭할 수 없습니다.
  Message::Send { from, to, contents } =&gt; { },
  // 비완전 튜플형 또는 유닛형 열거형 변형은 매칭할 수 없습니다.
  Message::Reaction(type) =&gt; { },
  Message::Quit =&gt; { },
}</code></pre>
<p>또한 하나 이상의 비완전 변형을 포함하는 열거형에 대해서는 숫자 캐스팅(<code>as</code>)을 사용하는 것이 허용되지 않습니다.</p>
<p>예를 들어, 다음 열거형은 비완전 변형을 포함하지 않으므로 캐스팅할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum Example {
    First,
    Second
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 열거형이 단 하나의 비완전 변형이라도 포함하고 있다면, 캐스팅은 에러가 됩니다. 동일한 열거형의 수정된 버전을 고려해 보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum EnumWithNonExhaustiveVariants {
    First,
    #[non_exhaustive]
    Second
}
<span class="boring">}</span></code></pre></pre>
<!-- ignore: needs multiple crates -->
<pre><code class="language-rust ignore">use othercrate::EnumWithNonExhaustiveVariants;

// 에러: 다른 크레이트에 정의된 비완전 변형을 가진 열거형은 캐스팅할 수 없습니다.
let _ = EnumWithNonExhaustiveVariants::First as u8;</code></pre>
<p>비완전 타입은 다운스트림 크레이트에서 항상 거주하는(inhabited) 타입으로 간주됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-attributes.debugger"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger" title="attributes.debugger"><span>[attributes<wbr>.debugger]<span/></a></div>
<h1 id="디버거-속성"><a class="header" href="#디버거-속성">디버거 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 GDB나 WinDbg와 같은 서드파티 디버거를 사용할 때 디버깅 경험을 향상시키기 위해 사용됩니다.</p>
<div class="rule" id="r-attributes.debugger.debugger_visualizer"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer" title="attributes.debugger.debugger_visualizer"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer]<span/></a></div>
<h2 id="debugger_visualizer-속성"><a class="header" href="#debugger_visualizer-속성"><code>debugger_visualizer</code> 속성</a></h2>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.intro"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.intro" title="attributes.debugger.debugger_visualizer.intro"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.intro]<span/></a></div>
<p>_<code>debugger_visualizer</code> 속성_은 디버거 시각화 도구 파일을 디버그 정보에 포함시키는 데 사용될 수 있습니다. 이를 통해 디버거에서 값을 표시할 때 더 나은 디버깅 경험을 제공합니다.</p>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.syntax"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.syntax" title="attributes.debugger.debugger_visualizer.syntax"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.syntax]<span/></a></div>
<p>이 속성은 입력을 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용하며, 크레이트 속성으로 지정되어야 합니다.</p>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.natvis"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis" title="attributes.debugger.debugger_visualizer.natvis"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.natvis]<span/></a></div>
<h3 id="natvis와-함께-debugger_visualizer-사용하기"><a class="header" href="#natvis와-함께-debugger_visualizer-사용하기">Natvis와 함께 <code>debugger_visualizer</code> 사용하기</a></h3>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.natvis.intro"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.intro" title="attributes.debugger.debugger_visualizer.natvis.intro"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.natvis<wbr>.intro]<span/></a></div>
<p>Natvis는 타입 표시를 사용자 정의하기 위해 선언적 규칙을 사용하는 Microsoft 디버거(예: Visual Studio 및 WinDbg)를 위한 XML 기반 프레임워크입니다. Natvis 형식에 대한 자세한 내용은 Microsoft의 <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects">Natvis 문서</a>를 참조하세요.</p>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.natvis.msvc"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.msvc" title="attributes.debugger.debugger_visualizer.natvis.msvc"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.natvis<wbr>.msvc]<span/></a></div>
<p>이 속성은 <code>-windows-msvc</code> 타겟에서만 Natvis 파일 포함을 지원합니다.</p>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.natvis.path"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.path" title="attributes.debugger.debugger_visualizer.natvis.path"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.natvis<wbr>.path]<span/></a></div>
<p>Natvis 파일의 경로는 <code>natvis_file</code> 키로 지정하며, 크레이트 소스 파일에 대한 상대 경로입니다.</p>
<!-- ignore: requires external files, and msvc -->
<pre><code class="language-rust ignore">#![debugger_visualizer(natvis_file = "Rectangle.natvis")]

struct FancyRect {
    x: f32,
    y: f32,
    dx: f32,
    dy: f32,
}

fn main() {
    let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 };
    println!("set breakpoint here");
}</code></pre>
<p>그리고 <code>Rectangle.natvis</code>는 다음을 포함합니다:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010"&gt;
    &lt;Type Name="foo::FancyRect"&gt;
      &lt;DisplayString&gt;({x},{y}) + ({dx}, {dy})&lt;/DisplayString&gt;
      &lt;Expand&gt;
        &lt;Synthetic Name="LowerLeft"&gt;
          &lt;DisplayString&gt;({x}, {y})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="UpperLeft"&gt;
          &lt;DisplayString&gt;({x}, {y + dy})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="UpperRight"&gt;
          &lt;DisplayString&gt;({x + dx}, {y + dy})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="LowerRight"&gt;
          &lt;DisplayString&gt;({x + dx}, {y})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
      &lt;/Expand&gt;
    &lt;/Type&gt;
&lt;/AutoVisualizer&gt;
</code></pre>
<p>WinDbg에서 볼 때, <code>fancy_rect</code> 변수는 다음과 같이 표시될 것입니다:</p>
<pre><code class="language-text">&gt; Variables:
  &gt; fancy_rect: (10.0, 10.0) + (5.0, 5.0)
    &gt; LowerLeft: (10.0, 10.0)
    &gt; UpperLeft: (10.0, 15.0)
    &gt; UpperRight: (15.0, 15.0)
    &gt; LowerRight: (15.0, 10.0)
</code></pre>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.gdb"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb" title="attributes.debugger.debugger_visualizer.gdb"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.gdb]<span/></a></div>
<h3 id="gdb와-함께-debugger_visualizer-사용하기"><a class="header" href="#gdb와-함께-debugger_visualizer-사용하기">GDB와 함께 <code>debugger_visualizer</code> 사용하기</a></h3>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.gdb.pretty"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb.pretty" title="attributes.debugger.debugger_visualizer.gdb.pretty"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.gdb<wbr>.pretty]<span/></a></div>
<p>GDB는 타입이 디버거 뷰에서 시각화되는 방식을 설명하는 _프리티 프린터(pretty printer)_라고 불리는 구조화된 파이썬 스크립트의 사용을 지원합니다. 프리티 프린터에 대한 자세한 내용은 GDB의 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html">프리티 프린팅 문서</a>를 참조하세요.</p>
<p>임베디드 프리티 프린터는 GDB에서 바이너리를 디버깅할 때 자동으로 로드되지 않습니다. 임베디드 프리티 프린터의 자동 로드를 활성화하는 두 가지 방법이 있습니다.</p>
<ol>
<li>자동 로드 안전 경로에 디렉터리나 바이너리를 명시적으로 추가하기 위해 추가 인수를 사용하여 GDB를 실행합니다: <code>gdb -iex "add-auto-load-safe-path safe-path path/to/binary" path/to/binary</code>. 자세한 내용은 GDB의 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-safe-path.html">자동 로드 문서</a>를 참조하세요.</li>
<li><code>$HOME/.config/gdb</code> 아래에 <code>gdbinit</code>이라는 파일을 생성합니다(디렉터리가 없으면 생성해야 할 수도 있습니다). 해당 파일에 다음 라인을 추가합니다: <code>add-auto-load-safe-path path/to/binary</code>.</li>
</ol>
<div class="rule" id="r-attributes.debugger.debugger_visualizer.gdb.path"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb.path" title="attributes.debugger.debugger_visualizer.gdb.path"><span>[attributes<wbr>.debugger<wbr>.debugger_visualizer<wbr>.gdb<wbr>.path]<span/></a></div>
<p>이러한 스크립트들은 <code>gdb_script_file</code> 키를 사용하여 포함되며, 크레이트 소스 파일에 대한 상대 경로입니다.</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#![debugger_visualizer(gdb_script_file = "printer.py")]

struct Person {
    name: String,
    age: i32,
}

fn main() {
    let bob = Person { name: String::from("Bob"), age: 10 };
    println!("set breakpoint here");
}</code></pre>
<p>그리고 <code>printer.py</code>는 다음을 포함합니다:</p>
<pre><code class="language-python">import gdb

class PersonPrinter:
    "Person 출력"

    def __init__(self, val):
        self.val = val
        self.name = val["이름"]
        self.age = int(val["나이"])

    def to_string(self):
        return "{}는 {}살입니다.".format(self.name, self.age)

def lookup(val):
    lookup_tag = val.type.tag
    if lookup_tag is None:
        return None
    if "foo::Person" == lookup_tag:
        return PersonPrinter(val)

    return None

gdb.current_objfile().pretty_printers.append(lookup)
</code></pre>
<p>크레이트의 디버그 실행 파일이 GDB<sup class="footnote-reference"><a href="#rust-gdb">1</a></sup>로 전달되면, <code>print bob</code>은 다음과 같이 표시될 것입니다:</p>
<pre><code class="language-text">"Bob" is 10 years old.
</code></pre>
<div class="footnote-definition" id="rust-gdb"><sup class="footnote-definition-label">1</sup>
<p>참고: 이는 <code>String</code>과 같은 표준 라이브러리 타입에 대해 프리티 프린터를 구성하는 <code>rust-gdb</code> 스크립트를 사용하고 있다고 가정합니다.</p>
</div>
<div class="rule" id="r-attributes.debugger.collapse_debuginfo"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo" title="attributes.debugger.collapse_debuginfo"><span>[attributes<wbr>.debugger<wbr>.collapse_debuginfo]<span/></a></div>
<h2 id="collapse_debuginfo-속성"><a class="header" href="#collapse_debuginfo-속성"><code>collapse_debuginfo</code> 속성</a></h2>
<div class="rule" id="r-attributes.debugger.collapse_debuginfo.intro"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.intro" title="attributes.debugger.collapse_debuginfo.intro"><span>[attributes<wbr>.debugger<wbr>.collapse_debuginfo<wbr>.intro]<span/></a></div>
<p>_<code>collapse_debuginfo</code> <a href="attributes/../attributes.html">속성</a>_은 해당 매크로를 호출하는 코드에 대한 디버그 정보를 생성할 때, 매크로 정의로부터의 코드 위치들을 매크로 호출 지점과 연관된 단일 위치로 축소할지 여부를 제어합니다.</p>
<div class="rule" id="r-attributes.debugger.collapse_debuginfo.syntax"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.syntax" title="attributes.debugger.collapse_debuginfo.syntax"><span>[attributes<wbr>.debugger<wbr>.collapse_debuginfo<wbr>.syntax]<span/></a></div>
<p>이 속성은 입력을 지정하기 위해 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListIdents</em></a> 구문을 사용하며, 오직 매크로 정의에만 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.debugger.collapse_debuginfo.options"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.options" title="attributes.debugger.collapse_debuginfo.options"><span>[attributes<wbr>.debugger<wbr>.collapse_debuginfo<wbr>.options]<span/></a></div>
<p>허용되는 옵션:</p>
<ul>
<li><code>#[collapse_debuginfo(yes)]</code> — 디버그 정보의 코드 위치들이 축소됩니다.</li>
<li><code>#[collapse_debuginfo(no)]</code> — 디버그 정보의 코드 위치들이 축소되지 않습니다.</li>
<li><code>#[collapse_debuginfo(external)]</code> — 매크로가 다른 크레이트에서 온 경우에만 디버그 정보의 코드 위치들이 축소됩니다.</li>
</ul>
<div class="rule" id="r-attributes.debugger.collapse_debuginfo.default"><a class="rule-link" href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.default" title="attributes.debugger.collapse_debuginfo.default"><span>[attributes<wbr>.debugger<wbr>.collapse_debuginfo<wbr>.default]<span/></a></div>
<p><code>external</code> 동작은 이 속성이 없는 매크로들의 기본값입니다(내장 매크로 제외). 내장 매크로의 경우 기본값은 <code>yes</code>입니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code>는 기본 축소 동작과 <code>#[collapse_debuginfo]</code> 속성 모두를 오버라이드하기 위한 <code>-C collapse-macro-debuginfo</code> CLI 옵션을 가지고 있습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[collapse_debuginfo(yes)]
macro_rules! example {
    () =&gt; {
        println!("hello!");
    };
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-stmt-expr"><a class="rule-link" href="statements-and-expressions.html#r-stmt-expr" title="stmt-expr"><span>[stmt-expr]<span/></a></div>
<h1 id="구문과-표현식"><a class="header" href="#구문과-표현식">구문과 표현식</a></h1>
<p>Rust는 <em>주로</em> 표현식(expression) 언어입니다. 이는 대부분의 값을 생성하거나 부수 효과를 일으키는 평가가 _표현식_이라는 통일된 구문 범주에 의해 유도됨을 의미합니다. 각 종류의 표현식은 일반적으로 다른 종류의 표현식 내에 _중첩_될 수 있으며, 표현식의 평가 규칙에는 표현식에 의해 생성되는 값과 그 하위 표현식들이 평가되는 순서를 모두 명시하는 것이 포함됩니다.</p>
<p>반면, 구문(statement)은 <em>주로</em> 표현식 평가를 포함하고 명시적으로 순서를 지정하는 역할을 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-statement"><a class="rule-link" href="statements.html#r-statement" title="statement"><span>[statement]<span/></a></div>
<h1 id="구문"><a class="header" href="#구문">구문</a></h1>
<div class="rule" id="r-statement.syntax"><a class="rule-link" href="statements.html#r-statement.syntax" title="statement.syntax"><span>[statement<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>구문</em> :<br />
      <code>;</code><br />
   | <a href="items.html"><em>아이템</em></a><br />
   | <a href="statements.html#let-statements"><em>Let구문</em></a><br />
   | <a href="statements.html#expression-statements"><em>표현식구문</em></a><br />
   | <a href="macros.html#macro-invocation"><em>세미콜론매크로호출</em></a></p>
</blockquote>
<div class="rule" id="r-statement.intro"><a class="rule-link" href="statements.html#r-statement.intro" title="statement.intro"><span>[statement<wbr>.intro]<span/></a></div>
<p>_구문(statement)_은 <a href="expressions/block-expr.html">블록</a>의 구성 요소이며, 블록은 다시 외부 <a href="expressions.html">표현식</a>이나 <a href="items/functions.html">함수</a>의 구성 요소가 됩니다.</p>
<div class="rule" id="r-statement.kind"><a class="rule-link" href="statements.html#r-statement.kind" title="statement.kind"><span>[statement<wbr>.kind]<span/></a></div>
<p>Rust에는 두 가지 종류의 구문이 있습니다: <a href="statements.html#declaration-statements">선언 구문</a>과 <a href="statements.html#expression-statements">표현식 구문</a>.</p>
<div class="rule" id="r-statement.decl"><a class="rule-link" href="statements.html#r-statement.decl" title="statement.decl"><span>[statement<wbr>.decl]<span/></a></div>
<h2 id="선언-구문"><a class="header" href="#선언-구문">선언 구문</a></h2>
<p>_선언 구문(declaration statement)_은 둘러싼 구문 블록에 하나 이상의 _이름_을 도입하는 구문입니다. 선언된 이름은 새로운 변수나 새로운 <a href="items.html">아이템</a>을 나타낼 수 있습니다.</p>
<p>선언 구문의 두 가지 종류는 아이템 선언과 <code>let</code> 구문입니다.</p>
<div class="rule" id="r-statement.item"><a class="rule-link" href="statements.html#r-statement.item" title="statement.item"><span>[statement<wbr>.item]<span/></a></div>
<h3 id="아이템-선언"><a class="header" href="#아이템-선언">아이템 선언</a></h3>
<div class="rule" id="r-statement.item.intro"><a class="rule-link" href="statements.html#r-statement.item.intro" title="statement.item.intro"><span>[statement<wbr>.item<wbr>.intro]<span/></a></div>
<p>_아이템 선언 구문_은 <a href="items/modules.html">모듈</a> 내의 <a href="items.html">아이템 선언</a>과 동일한 구문 형식을 가집니다.</p>
<div class="rule" id="r-statement.item.scope"><a class="rule-link" href="statements.html#r-statement.item.scope" title="statement.item.scope"><span>[statement<wbr>.item<wbr>.scope]<span/></a></div>
<p>구문 블록 내에서 아이템을 선언하면 해당 아이템의 <a href="names/scopes.html">스코프(scope)</a>는 해당 구문을 포함하는 블록으로 제한됩니다. 아이템에는 <a href="paths.html#canonical-paths">정규 경로(canonical path)</a>가 주어지지 않으며, 해당 아이템이 선언할 수 있는 하위 아이템들도 마찬가지입니다.</p>
<div class="rule" id="r-statement.item.associated-scope"><a class="rule-link" href="statements.html#r-statement.item.associated-scope" title="statement.item.associated-scope"><span>[statement<wbr>.item<wbr>.associated-scope]<span/></a></div>
<p>이에 대한 예외로, <a href="items/implementations.html">구현(implementations)</a>에 의해 정의된 연관 아이템들은 해당 아이템과 (해당되는 경우) 트레잇에 접근 가능한 한 외부 스코프에서도 여전히 접근 가능합니다. 그 외의 경우에는 모듈 내부에 아이템을 선언하는 것과 의미상 동일합니다.</p>
<div class="rule" id="r-statement.item.outer-generics"><a class="rule-link" href="statements.html#r-statement.item.outer-generics" title="statement.item.outer-generics"><span>[statement<wbr>.item<wbr>.outer-generics]<span/></a></div>
<p>둘러싼 함수의 제네릭 매개변수, 매개변수, 지역 변수들을 암시적으로 캡처하지 않습니다. 예를 들어, <code>inner</code>는 <code>outer_var</code>에 접근할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn outer() {
  let outer_var = true;

  fn inner() { /* 여기서 outer_var는 스코프에 없습니다 */ }

  inner();
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-statement.let"><a class="rule-link" href="statements.html#r-statement.let" title="statement.let"><span>[statement<wbr>.let]<span/></a></div>
<h3 id="let-구문"><a class="header" href="#let-구문"><code>let</code> 구문</a></h3>
<div class="rule" id="r-statement.let.syntax"><a class="rule-link" href="statements.html#r-statement.let.syntax" title="statement.let.syntax"><span>[statement<wbr>.let<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Let구문</em> :<br />
   <a href="attributes.html"><em>외부속성</em></a><sup>*</sup> <code>let</code> <a href="patterns.html"><em>최상위대안없는패턴</em></a> ( <code>:</code> <a href="types.html"><em>타입</em></a> )<sup>?</sup> (<code>=</code> <a href="expressions.html"><em>표현식</em></a> <a href="statements.html#let-else-restriction">†</a> ( <code>else</code> <a href="expressions/block-expr.html"><em>블록표현식</em></a>) <sup>?</sup> ) <sup>?</sup> <code>;</code></p>
<p><span id="let-else-restriction">† <code>else</code> 블록이 지정된 경우, _표현식_은 <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>지연 불리언 표현식(LazyBooleanExpression)</em></a>이 아니어야 하며, <code>}</code>로 끝나서도 안 됩니다.</span></p>
</blockquote>
<div class="rule" id="r-statement.let.intro"><a class="rule-link" href="statements.html#r-statement.let.intro" title="statement.let.intro"><span>[statement<wbr>.let<wbr>.intro]<span/></a></div>
<p>_<code>let</code> 구문_은 <a href="patterns.html">패턴</a>에 의해 주어지는 새로운 <a href="variables.html">변수</a> 집합을 도입합니다. 패턴 뒤에는 선택적으로 타입 주석이 올 수 있으며, 그 후 구문이 끝나거나 초기화 표현식과 선택적인 <code>else</code> 블록이 뒤따릅니다.</p>
<div class="rule" id="r-statement.let.inference"><a class="rule-link" href="statements.html#r-statement.let.inference" title="statement.let.inference"><span>[statement<wbr>.let<wbr>.inference]<span/></a></div>
<p>타입 주석이 주어지지 않으면 컴파일러가 타입을 추론하며, 확정적인 추론을 위한 타입 정보가 부족하면 에러를 발생시킵니다.</p>
<div class="rule" id="r-statement.let.scope"><a class="rule-link" href="statements.html#r-statement.let.scope" title="statement.let.scope"><span>[statement<wbr>.let<wbr>.scope]<span/></a></div>
<p>변수 선언에 의해 도입된 모든 변수들은 선언 지점부터 해당 블록 스코프가 끝날 때까지 가시성을 가집니다. 단, 다른 변수 선언에 의해 가려지는(shadowed) 경우는 제외합니다.</p>
<div class="rule" id="r-statement.let.constraint"><a class="rule-link" href="statements.html#r-statement.let.constraint" title="statement.let.constraint"><span>[statement<wbr>.let<wbr>.constraint]<span/></a></div>
<p><code>else</code> 블록이 없는 경우 패턴은 반박 불가능(irrefutable)해야 합니다. <code>else</code> 블록이 있는 경우 패턴은 반박 가능(refutable)할 수 있습니다.</p>
<div class="rule" id="r-statement.let.behavior"><a class="rule-link" href="statements.html#r-statement.let.behavior" title="statement.let.behavior"><span>[statement<wbr>.let<wbr>.behavior]<span/></a></div>
<p>패턴이 일치하지 않으면(<code>else</code>가 있으므로 반박 가능한 패턴이어야 함) <code>else</code> 블록이 실행됩니다. <code>else</code> 블록은 반드시 발산(diverge)해야 합니다 (즉, <a href="types/never.html">never 타입</a>으로 평가되어야 함).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut v, w) = (vec![1, 2, 3], 42); // 바인딩은 mut 또는 const일 수 있습니다
let Some(t) = v.pop() else { // 반박 가능한 패턴은 else 블록을 요구합니다
    panic!(); // else 블록은 반드시 발산해야 합니다
};
let [u, v] = [v[0], v[1]] else { // 이 패턴은 반박 불가능하므로, 컴파일러는 else 블록이
                                 // 불필요하다는 린트를 발생시킬 것입니다.
    panic!();
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-statement.expr"><a class="rule-link" href="statements.html#r-statement.expr" title="statement.expr"><span>[statement<wbr>.expr]<span/></a></div>
<h2 id="표현식-구문"><a class="header" href="#표현식-구문">표현식 구문</a></h2>
<div class="rule" id="r-statement.expr.syntax"><a class="rule-link" href="statements.html#r-statement.expr.syntax" title="statement.expr.syntax"><span>[statement<wbr>.expr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>표현식구문</em> :<br />
      <a href="expressions.html"><em>블록없는표현식</em></a> <code>;</code><br />
   | <a href="expressions.html"><em>블록있는표현식</em></a> <code>;</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-statement.expr.intro"><a class="rule-link" href="statements.html#r-statement.expr.intro" title="statement.expr.intro"><span>[statement<wbr>.expr<wbr>.intro]<span/></a></div>
<p>_표현식 구문(expression statement)_은 <a href="expressions.html">표현식</a>을 평가하고 그 결과를 무시하는 구문입니다. 일반적으로 표현식 구문의 목적은 표현식 평가에 따른 부수 효과를 일으키는 것입니다.</p>
<div class="rule" id="r-statement.expr.restriction-semicolon"><a class="rule-link" href="statements.html#r-statement.expr.restriction-semicolon" title="statement.expr.restriction-semicolon"><span>[statement<wbr>.expr<wbr>.restriction-semicolon]<span/></a></div>
<p>블록 표현식이나 제어 흐름 표현식으로만 구성된 표현식이 구문이 허용되는 컨텍스트에서 사용되는 경우, 뒤따르는 세미콜론을 생략할 수 있습니다. 이는 독립적인 구문으로 파싱되는 것과 다른 표현식의 일부로 파싱되는 것 사이의 모호함을 유발할 수 있는데, 이 경우 구문으로 파싱됩니다.</p>
<div class="rule" id="r-statement.expr.constraint-block"><a class="rule-link" href="statements.html#r-statement.expr.constraint-block" title="statement.expr.constraint-block"><span>[statement<wbr>.expr<wbr>.constraint-block]<span/></a></div>
<p>구문으로 사용될 때 <a href="expressions.html"><em>블록있는표현식</em></a>의 타입은 반드시 유닛 타입(unit type)이어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut v = vec![1, 2, 3];
</span>v.pop();          // pop에서 반환된 요소를 무시합니다
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // 세미콜론은 생략될 수 있습니다.
[1];              // 별개의 표현식 구문이며, 인덱싱 표현식이 아닙니다.
<span class="boring">}</span></code></pre></pre>
<p>마지막 세미콜론이 생략된 경우, 결과는 반드시 <code>()</code> 타입이어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 나쁨: 블록의 타입이 ()가 아니라 i32임
// 에러: 기본 반환 타입 때문에 `()`가 기대됨
// if true {
//   1
// }

// 좋음: 블록의 타입이 i32임
if true {
  1
} else {
  2
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-statement.attribute"><a class="rule-link" href="statements.html#r-statement.attribute" title="statement.attribute"><span>[statement<wbr>.attribute]<span/></a></div>
<h2 id="구문의-속성"><a class="header" href="#구문의-속성">구문의 속성</a></h2>
<p>구문은 <a href="attributes.html">외부 속성</a>을 허용합니다. 구문에서 의미를 갖는 속성은 <a href="conditional-compilation.html"><code>cfg</code></a>와 <a href="attributes/diagnostics.html#lint-check-attributes">린트 체크 속성</a>입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr"><a class="rule-link" href="expressions.html#r-expr" title="expr"><span>[expr]<span/></a></div>
<h1 id="표현식"><a class="header" href="#표현식">표현식</a></h1>
<div class="rule" id="r-expr.syntax"><a class="rule-link" href="expressions.html#r-expr.syntax" title="expr.syntax"><span>[expr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>표현식</em> :<br />
      <em>블록없는표현식</em><br />
   | <em>블록있는표현식</em></p>
<p><em>ExpressionWithoutBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
      | <a href="expressions/path-expr.html"><em>PathExpression</em></a><br />
      | <a href="expressions/operator-expr.html"><em>OperatorExpression</em></a><br />
      | <a href="expressions/grouped-expr.html"><em>GroupedExpression</em></a><br />
      | <a href="expressions/array-expr.html"><em>ArrayExpression</em></a><br />
      | <a href="expressions/await-expr.html"><em>AwaitExpression</em></a><br />
      | <a href="expressions/array-expr.html#array-and-slice-indexing-expressions"><em>IndexExpression</em></a><br />
      | <a href="expressions/tuple-expr.html"><em>TupleExpression</em></a><br />
      | <a href="expressions/tuple-expr.html#tuple-indexing-expressions"><em>TupleIndexingExpression</em></a><br />
      | <a href="expressions/struct-expr.html"><em>StructExpression</em></a><br />
      | <a href="expressions/call-expr.html"><em>CallExpression</em></a><br />
      | <a href="expressions/method-call-expr.html"><em>MethodCallExpression</em></a><br />
      | <a href="expressions/field-expr.html"><em>FieldExpression</em></a><br />
      | <a href="expressions/closure-expr.html"><em>ClosureExpression</em></a><br />
      | <a href="expressions/block-expr.html#async-blocks"><em>AsyncBlockExpression</em></a><br />
      | <a href="expressions/loop-expr.html#continue-expressions"><em>ContinueExpression</em></a><br />
      | <a href="expressions/loop-expr.html#break-expressions"><em>BreakExpression</em></a><br />
      | <a href="expressions/range-expr.html"><em>RangeExpression</em></a><br />
      | <a href="expressions/return-expr.html"><em>ReturnExpression</em></a><br />
      | <a href="expressions/underscore-expr.html"><em>UnderscoreExpression</em></a><br />
      | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a><br />
   )</p>
<p><em>블록있는표현식</em> :<br />
   <a href="attributes.html"><em>외부속성</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
          <a href="expressions/block-expr.html"><em>블록표현식</em></a><br />
      | <a href="expressions/block-expr.html#const-blocks"><em>Const블록표현식</em></a><br />
      | <a href="expressions/block-expr.html#unsafe-blocks"><em>Unsafe블록표현식</em></a><br />
      | <a href="expressions/loop-expr.html"><em>루프표현식</em></a><br />
      | <a href="expressions/if-expr.html#if-expressions"><em>If표현식</em></a><br />
      | <a href="expressions/if-expr.html#if-let-expressions"><em>IfLet표현식</em></a><br />
      | <a href="expressions/match-expr.html"><em>매치표현식</em></a><br />
   )</p>
</blockquote>
<div class="rule" id="r-expr.intro"><a class="rule-link" href="expressions.html#r-expr.intro" title="expr.intro"><span>[expr<wbr>.intro]<span/></a></div>
<p>표현식은 두 가지 역할을 가질 수 있습니다: 항상 _값(value)_을 생성하며, <em>효과(effects)</em> (또는 “부수 효과”)를 가질 수 있습니다.</p>
<div class="rule" id="r-expr.evaluation"><a class="rule-link" href="expressions.html#r-expr.evaluation" title="expr.evaluation"><span>[expr<wbr>.evaluation]<span/></a></div>
<p>표현식은 값으로 _평가(evaluates to)_되며, <em>평가</em> 중에 효과를 가집니다.</p>
<div class="rule" id="r-expr.operands"><a class="rule-link" href="expressions.html#r-expr.operands" title="expr.operands"><span>[expr<wbr>.operands]<span/></a></div>
<p>많은 표현식은 하위 표현식을 포함하며, 이를 표현식의 _피연산자(operands)_라고 부릅니다.</p>
<div class="rule" id="r-expr.behavior"><a class="rule-link" href="expressions.html#r-expr.behavior" title="expr.behavior"><span>[expr<wbr>.behavior]<span/></a></div>
<p>각 종류의 표현식의 의미는 몇 가지 사항을 결정합니다:</p>
<ul>
<li>표현식을 평가할 때 피연산자를 평가할지 여부</li>
<li>피연산자를 평가하는 순서</li>
<li>표현식의 값을 얻기 위해 피연산자들의 값을 결합하는 방법</li>
</ul>
<div class="rule" id="r-expr.structure"><a class="rule-link" href="expressions.html#r-expr.structure" title="expr.structure"><span>[expr<wbr>.structure]<span/></a></div>
<p>이러한 방식으로 표현식의 구조는 실행 구조를 결정합니다. 블록은 단지 또 다른 종류의 표현식일 뿐이므로, 블록, 구문, 표현식 그리고 다시 블록이 임의의 깊이로 서로 재귀적으로 중첩될 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 논의를 위해 표현식의 피연산자에 이름을 붙였지만, 이러한 이름은 고정된 것이 아니며 변경될 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-expr.precedence"><a class="rule-link" href="expressions.html#r-expr.precedence" title="expr.precedence"><span>[expr<wbr>.precedence]<span/></a></div>
<h2 id="표현식-우선순위"><a class="header" href="#표현식-우선순위">표현식 우선순위</a></h2>
<p>Rust 연산자와 표현식의 우선순위는 다음과 같으며, 강한 것부터 약한 것 순으로 나열되어 있습니다. 동일한 우선순위 수준의 이항 연산자들은 그들의 결합성(associativity)에 따라 그룹화됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>연산자/표현식</th><th>결합성</th></tr></thead><tbody>
<tr><td>경로</td><td></td></tr>
<tr><td>메서드 호출</td><td></td></tr>
<tr><td>필드 표현식</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>함수 호출, 배열 인덱싱</td><td></td></tr>
<tr><td><code>?</code></td><td></td></tr>
<tr><td>단항 <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code></td><td></td></tr>
<tr><td><code>as</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>&amp;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>^</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>|</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>괄호 필요</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>||</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>..</code> <code>..=</code></td><td>괄호 필요</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>오른쪽에서 왼쪽으로</td></tr>
<tr><td><code>return</code> <code>break</code> 클로저</td><td></td></tr>
</tbody></table>
</div><div class="rule" id="r-expr.operand-order"><a class="rule-link" href="expressions.html#r-expr.operand-order" title="expr.operand-order"><span>[expr<wbr>.operand-order]<span/></a></div>
<h2 id="피연산자의-평가-순서"><a class="header" href="#피연산자의-평가-순서">피연산자의 평가 순서</a></h2>
<div class="rule" id="r-expr.operand-order.default"><a class="rule-link" href="expressions.html#r-expr.operand-order.default" title="expr.operand-order.default"><span>[expr<wbr>.operand-order<wbr>.default]<span/></a></div>
<p>다음 목록의 표현식들은 모두 목록 뒤에 설명된 것과 동일한 방식으로 피연산자를 평가합니다. 다른 표현식들은 피연산자를 취하지 않거나, 각각의 페이지에 설명된 대로 조건부로 평가합니다.</p>
<ul>
<li>역참조 표현식</li>
<li>에러 전파 표현식</li>
<li>부정 표현식</li>
<li>산술 및 논리 이항 연산자</li>
<li>비교 연산자</li>
<li>타입 캐스트 표현식</li>
<li>그룹화된 표현식</li>
<li>배열 표현식</li>
<li>Await 표현식</li>
<li>인덱스 표현식</li>
<li>튜플 표현식</li>
<li>튜플 인덱스 표현식</li>
<li>구조체 표현식</li>
<li>호출 표현식</li>
<li>메서드 호출 표현식</li>
<li>필드 표현식</li>
<li>Break 표현식</li>
<li>범위 표현식</li>
<li>Return 표현식</li>
</ul>
<div class="rule" id="r-expr.operand-order.operands-before-primary"><a class="rule-link" href="expressions.html#r-expr.operand-order.operands-before-primary" title="expr.operand-order.operands-before-primary"><span>[expr<wbr>.operand-order<wbr>.operands-before-primary]<span/></a></div>
<p>이러한 표현식의 피연산자들은 표현식의 효과가 적용되기 전에 평가됩니다. 여러 피연산자를 취하는 표현식은 소스 코드에 작성된 대로 왼쪽에서 오른쪽으로 평가됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 어떤 하위 표현식이 표현식의 피연산자인지는 이전 섹션에서 설명한 표현식 우선순위에 의해 결정됩니다.</p>
</blockquote>
<p>예를 들어, 두 개의 <code>next</code> 메서드 호출은 항상 동일한 순서로 호출됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// 참조를 피하기 위해 배열 대신 vec를 사용합니다.
</span><span class="boring">// 이 예제가 작성된 시점에는 안정적인 소유권 있는(owned) 배열 반복자가
</span><span class="boring">// 없었기 때문입니다.
</span>let mut one_two = vec![1, 2].into_iter();
assert_eq!(
    (1, 2),
    (one_two.next().unwrap(), one_two.next().unwrap())
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 이는 재귀적으로 적용되므로, 이러한 표현식들은 또한 가장 안쪽에서 바깥쪽 순서로 평가되며, 내부에 더 이상의 하위 표현식이 없을 때까지 형제 노드들을 무시합니다.</p>
</blockquote>
<div class="rule" id="r-expr.place-value"><a class="rule-link" href="expressions.html#r-expr.place-value" title="expr.place-value"><span>[expr<wbr>.place-value]<span/></a></div>
<h2 id="장소-표현식과-값-표현식"><a class="header" href="#장소-표현식과-값-표현식">장소 표현식과 값 표현식</a></h2>
<div class="rule" id="r-expr.place-value.intro"><a class="rule-link" href="expressions.html#r-expr.place-value.intro" title="expr.place-value.intro"><span>[expr<wbr>.place-value<wbr>.intro]<span/></a></div>
<p>표현식은 두 가지 주요 범주로 나뉩니다: 장소 표현식(place expressions)과 값 표현식(value expressions). 또한 피할당자 표현식(assignee expressions)이라고 불리는 세 번째 보조 범주도 있습니다. 각 표현식 내에서 피연산자들은 마찬가지로 장소 컨텍스트나 값 컨텍스트 중 하나에서 나타날 수 있습니다. 표현식의 평가는 표현식 자체의 범주와 표현식이 나타나는 컨텍스트 모두에 달려 있습니다.</p>
<div class="rule" id="r-expr.place-value.place-memory-location"><a class="rule-link" href="expressions.html#r-expr.place-value.place-memory-location" title="expr.place-value.place-memory-location"><span>[expr<wbr>.place-value<wbr>.place-memory-location]<span/></a></div>
<p>_장소 표현식(place expression)_은 메모리 위치를 나타내는 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.place-expr-kinds"><a class="rule-link" href="expressions.html#r-expr.place-value.place-expr-kinds" title="expr.place-value.place-expr-kinds"><span>[expr<wbr>.place-value<wbr>.place-expr-kinds]<span/></a></div>
<p>이러한 표현식들은 지역 변수, <a href="items/static-items.html">정적 변수</a>를 참조하는 <a href="expressions/path-expr.html">경로</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a> 표현식 (<code>expr[expr]</code>), <a href="expressions/field-expr.html">필드</a> 참조 (<code>expr.f</code>) 및 괄호로 둘러싸인 장소 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.value-expr-kinds"><a class="rule-link" href="expressions.html#r-expr.place-value.value-expr-kinds" title="expr.place-value.value-expr-kinds"><span>[expr<wbr>.place-value<wbr>.value-expr-kinds]<span/></a></div>
<p>다른 모든 표현식은 값 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.value-result"><a class="rule-link" href="expressions.html#r-expr.place-value.value-result" title="expr.place-value.value-result"><span>[expr<wbr>.place-value<wbr>.value-result]<span/></a></div>
<p>_값 표현식(value expression)_은 실제 값을 나타내는 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.place-context"><a class="rule-link" href="expressions.html#r-expr.place-value.place-context" title="expr.place-value.place-context"><span>[expr<wbr>.place-value<wbr>.place-context]<span/></a></div>
<p>다음 컨텍스트들은 <em>장소 표현식</em> 컨텍스트입니다:</p>
<ul>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a> 표현식의 왼쪽 피연산자.</li>
<li>단항 <a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용(raw borrow)</a> 또는 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a> 연산자의 피연산자.</li>
<li>필드 표현식의 피연산자.</li>
<li>배열 인덱싱 표현식의 인덱스된 피연산자.</li>
<li>임의의 <a href="expressions.html#implicit-borrows">암시적 차용(implicit borrow)</a>의 피연산자.</li>
<li><a href="statements.html#let-statements">let 문</a>의 초기화 식(initializer).</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a> 또는 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 표현식의 <a href="glossary.html#scrutinee">피검사대상(scrutinee)</a>.</li>
<li><a href="expressions/struct-expr.html#functional-update-syntax">함수형 업데이트(functional update)</a> 구조체 표현식의 베이스(base).</li>
</ul>
<blockquote>
<p>참고: 역사적으로 장소 표현식은 _lvalues_로, 값 표현식은 _rvalues_로 불렸습니다.</p>
</blockquote>
<div class="rule" id="r-expr.place-value.assignee"><a class="rule-link" href="expressions.html#r-expr.place-value.assignee" title="expr.place-value.assignee"><span>[expr<wbr>.place-value<wbr>.assignee]<span/></a></div>
<p>_피할당자 표현식(assignee expression)_은 <a href="expressions/operator-expr.html#assignment-expressions">할당(assignment)</a> 표현식의 왼쪽 피연산자로 나타나는 표현식입니다. 명시적으로, 피할당자 표현식은 다음과 같습니다:</p>
<ul>
<li>장소 표현식.</li>
<li><a href="expressions/underscore-expr.html">밑줄(Underscores)</a>.</li>
<li>피할당자 표현식의 <a href="expressions/tuple-expr.html">튜플</a>.</li>
<li>피할당자 표현식의 <a href="expressions/array-expr.html">슬라이스</a>.</li>
<li>피할당자 표현식의 <a href="expressions/struct-expr.html">튜플 구조체</a>.</li>
<li>피할당자 표현식의 <a href="expressions/struct-expr.html">구조체</a> (선택적으로 이름이 붙은 필드 포함).</li>
<li><a href="expressions/struct-expr.html">유닛 구조체</a>.</li>
</ul>
<div class="rule" id="r-expr.place-value.parenthesis"><a class="rule-link" href="expressions.html#r-expr.place-value.parenthesis" title="expr.place-value.parenthesis"><span>[expr<wbr>.place-value<wbr>.parenthesis]<span/></a></div>
<p>피할당자 표현식 내에서는 임의의 괄호 사용이 허용됩니다.</p>
<div class="rule" id="r-expr.move"><a class="rule-link" href="expressions.html#r-expr.move" title="expr.move"><span>[expr<wbr>.move]<span/></a></div>
<h3 id="이동-및-복사-타입"><a class="header" href="#이동-및-복사-타입">이동 및 복사 타입</a></h3>
<div class="rule" id="r-expr.move.intro"><a class="rule-link" href="expressions.html#r-expr.move.intro" title="expr.move.intro"><span>[expr<wbr>.move<wbr>.intro]<span/></a></div>
<p>장소 표현식이 값 표현식 컨텍스트에서 평가되거나 패턴에서 값으로 바인딩될 때, 이는 해당 메모리 위치_에_ 저장된 값을 나타냅니다.</p>
<div class="rule" id="r-expr.move.copy"><a class="rule-link" href="expressions.html#r-expr.move.copy" title="expr.move.copy"><span>[expr<wbr>.move<wbr>.copy]<span/></a></div>
<p>해당 값의 타입이 <a href="special-types-and-traits.html#copy"><code>Copy</code></a>를 구현한다면, 값이 복사됩니다.</p>
<div class="rule" id="r-expr.move.requires-sized"><a class="rule-link" href="expressions.html#r-expr.move.requires-sized" title="expr.move.requires-sized"><span>[expr<wbr>.move<wbr>.requires-sized]<span/></a></div>
<p>그 외의 상황에서 해당 타입이 <a href="special-types-and-traits.html#sized"><code>Sized</code></a>라면, 값을 이동(move)시키는 것이 가능할 수 있습니다.</p>
<div class="rule" id="r-expr.move.movable-place"><a class="rule-link" href="expressions.html#r-expr.move.movable-place" title="expr.move.movable-place"><span>[expr<wbr>.move<wbr>.movable-place]<span/></a></div>
<p>오직 다음 장소 표현식들로부터만 값을 이동시킬 수 있습니다:</p>
<ul>
<li>현재 차용(borrow)되지 않은 <a href="variables.html">변수</a>.</li>
<li><a href="expressions.html#temporaries">임시 값</a>.</li>
<li>값을 이동시킬 수 있는 장소 표현식의 <a href="expressions/field-expr.html">필드</a>들 중 <a href="special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않은 것.</li>
<li><a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 타입을 가진 표현식을 <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a>한 결과로서, 마찬가지로 값을 이동시킬 수 있는 경우.</li>
</ul>
<div class="rule" id="r-expr.move.deinitialization"><a class="rule-link" href="expressions.html#r-expr.move.deinitialization" title="expr.move.deinitialization"><span>[expr<wbr>.move<wbr>.deinitialization]<span/></a></div>
<p>지역 변수로 평가되는 장소 표현식에서 값을 이동시킨 후에는 해당 위치가 초기화 해제(deinitialized)되며, 다시 초기화될 때까지 다시 읽을 수 없습니다.</p>
<div class="rule" id="r-expr.move.place-invalid"><a class="rule-link" href="expressions.html#r-expr.move.place-invalid" title="expr.move.place-invalid"><span>[expr<wbr>.move<wbr>.place-invalid]<span/></a></div>
<p>그 외의 모든 경우, 값 표현식 컨텍스트에서 장소 표현식을 사용하려고 시도하는 것은 에러입니다.</p>
<div class="rule" id="r-expr.mut"><a class="rule-link" href="expressions.html#r-expr.mut" title="expr.mut"><span>[expr<wbr>.mut]<span/></a></div>
<h3 id="가변성mutability"><a class="header" href="#가변성mutability">가변성(Mutability)</a></h3>
<div class="rule" id="r-expr.mut.intro"><a class="rule-link" href="expressions.html#r-expr.mut.intro" title="expr.mut.intro"><span>[expr<wbr>.mut<wbr>.intro]<span/></a></div>
<p>장소 표현식에 <a href="expressions/operator-expr.html#assignment-expressions">할당(assigned)</a>하거나, 가변적으로 <a href="expressions/operator-expr.html#borrow-operators">차용(borrowed)</a>하거나, <a href="expressions.html#implicit-borrows">암시적으로 가변 차용</a>하거나, <code>ref mut</code>를 포함하는 패턴에 바인딩하려면 해당 표현식은 반드시 _가변(mutable)_이어야 합니다. 이를 _가변 장소 표현식(mutable place expressions)_이라고 부릅니다. 반면에 다른 장소 표현식들은 _불변 장소 표현식(immutable place expressions)_이라고 부릅니다.</p>
<div class="rule" id="r-expr.mut.valid-places"><a class="rule-link" href="expressions.html#r-expr.mut.valid-places" title="expr.mut.valid-places"><span>[expr<wbr>.mut<wbr>.valid-places]<span/></a></div>
<p>다음 표현식들은 가변 장소 표현식 컨텍스트가 될 수 있습니다:</p>
<ul>
<li>현재 차용되지 않은 가변 <a href="variables.html">변수(variables)</a>.</li>
<li><a href="items/static-items.html#mutable-statics">가변 <code>static</code> 아이템</a>.</li>
<li><a href="expressions.html#temporaries">임시 값</a>.</li>
<li><a href="expressions/field-expr.html">필드(Fields)</a>: 이는 하위 표현식을 가변 장소 표현식 컨텍스트에서 평가합니다.</li>
<li><code>*mut T</code> 포인터의 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(Dereferences)</a>.</li>
<li><code>&amp;mut T</code> 타입을 가진 변수 또는 변수 필드의 역참조. 참고: 이는 다음 규칙의 요구 사항에 대한 예외입니다.</li>
<li><code>DerefMut</code>를 구현하는 타입의 역참조: 이는 역참조되는 값이 가변 장소 표현식 컨텍스트에서 평가될 것을 요구합니다.</li>
<li><code>IndexMut</code>를 구현하는 타입의 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(Array indexing)</a>: 이는 인덱싱되는 값을 가변 장소 표현식 컨텍스트에서 평가하지만, 인덱스는 그렇지 않습니다.</li>
</ul>
<div class="rule" id="r-expr.temporary"><a class="rule-link" href="expressions.html#r-expr.temporary" title="expr.temporary"><span>[expr<wbr>.temporary]<span/></a></div>
<h3 id="임시-값temporaries"><a class="header" href="#임시-값temporaries">임시 값(Temporaries)</a></h3>
<p>대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용할 때, 이름 없는 임시 메모리 위치가 생성되고 해당 값으로 초기화됩니다. 표현식은 <code>static</code>으로 <a href="destructors.html#constant-promotion">승격(promoted)</a>되지 않는 한 해당 위치로 평가됩니다. 임시 값의 <a href="destructors.html#drop-scopes">드롭 스코프(drop scope)</a>는 보통 이를 둘러싼 구문의 끝입니다.</p>
<div class="rule" id="r-expr.implicit-borrow"><a class="rule-link" href="expressions.html#r-expr.implicit-borrow" title="expr.implicit-borrow"><span>[expr<wbr>.implicit-borrow]<span/></a></div>
<h3 id="암시적-차용implicit-borrows"><a class="header" href="#암시적-차용implicit-borrows">암시적 차용(Implicit Borrows)</a></h3>
<div class="rule" id="r-expr.implicit-borrow-intro"><a class="rule-link" href="expressions.html#r-expr.implicit-borrow-intro" title="expr.implicit-borrow-intro"><span>[expr<wbr>.implicit-borrow-intro]<span/></a></div>
<p>특정 표현식들은 표현식을 암시적으로 차용함으로써 장소 표현식으로 취급합니다. 예를 들어, <code>==</code> 연산자는 피연산자를 암시적으로 차용하기 때문에 두 개의 크기 미지정 <a href="types/slice.html">슬라이스(slices)</a>의 동등성을 직접 비교하는 것이 가능합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// 동등한 형태:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.implicit-borrow.application"><a class="rule-link" href="expressions.html#r-expr.implicit-borrow.application" title="expr.implicit-borrow.application"><span>[expr<wbr>.implicit-borrow<wbr>.application]<span/></a></div>
<p>암시적 차용은 다음 표현식들에서 발생할 수 있습니다:</p>
<ul>
<li><a href="expressions/method-call-expr.html">메서드 호출(method-call)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/field-expr.html">필드(field)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/call-expr.html">호출 표현식(call expressions)</a>의 왼쪽 피연산자.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(array indexing)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a> (<code>*</code>)의 피연산자.</li>
<li><a href="expressions/operator-expr.html#comparison-operators">비교(comparison)</a>의 피연산자들.</li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a>의 왼쪽 피연산자들.</li>
</ul>
<div class="rule" id="r-expr.overload"><a class="rule-link" href="expressions.html#r-expr.overload" title="expr.overload"><span>[expr<wbr>.overload]<span/></a></div>
<h2 id="오버로딩-트레잇"><a class="header" href="#오버로딩-트레잇">오버로딩 트레잇</a></h2>
<p>다음 중 많은 연산자와 표현식들은 <code>std::ops</code>나 <code>std::cmp</code>에 있는 트레잇들을 사용하여 다른 타입에 대해 오버로드될 수 있습니다. 이러한 트레잇들은 <code>core::ops</code> 및 <code>core::cmp</code>에도 동일한 이름으로 존재합니다.</p>
<div class="rule" id="r-expr.attr"><a class="rule-link" href="expressions.html#r-expr.attr" title="expr.attr"><span>[expr<wbr>.attr]<span/></a></div>
<h2 id="표현식-속성"><a class="header" href="#표현식-속성">표현식 속성</a></h2>
<div class="rule" id="r-expr.attr.restriction"><a class="rule-link" href="expressions.html#r-expr.attr.restriction" title="expr.attr.restriction"><span>[expr<wbr>.attr<wbr>.restriction]<span/></a></div>
<p>표현식 앞의 <a href="attributes.html">외부 속성(Outer attributes)</a>은 오직 다음 몇 가지 구체적인 경우에만 허용됩니다:</p>
<ul>
<li><a href="statements.html">구문(statement)</a>으로 사용된 표현식 앞에 올 때.</li>
<li><a href="expressions/array-expr.html">배열 표현식(array expressions)</a>, <a href="expressions/tuple-expr.html">튜플 표현식(tuple expressions)</a>, <a href="expressions/call-expr.html">호출 표현식(call expressions)</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체(struct)</a> 표현식의 요소들에 올 때.</li>
<li><a href="expressions/block-expr.html">블록 표현식(block expressions)</a>의 마지막 표현식(tail expression)에 올 때.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<div class="rule" id="r-expr.attr.never-before"><a class="rule-link" href="expressions.html#r-expr.attr.never-before" title="expr.attr.never-before"><span>[expr<wbr>.attr<wbr>.never-before]<span/></a></div>
<p>다음의 경우에는 절대 허용되지 않습니다:</p>
<ul>
<li><a href="expressions/range-expr.html">범위(Range)</a> 표현식 앞.</li>
<li>이항 연산자 표현식 (<a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>산술또는논리표현식</em></a>, <a href="expressions/operator-expr.html#comparison-operators"><em>비교표현식</em></a>, <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>지연불리언표현식</em></a>, <a href="expressions/operator-expr.html#type-cast-expressions"><em>타입캐스트표현식</em></a>, <a href="expressions/operator-expr.html#assignment-expressions"><em>할당표현식</em></a>, <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>복합할당표현식</em></a>) 앞.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.literal"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal" title="expr.literal"><span>[expr<wbr>.literal]<span/></a></div>
<h1 id="리터럴-표현식"><a class="header" href="#리터럴-표현식">리터럴 표현식</a></h1>
<div class="rule" id="r-expr.literal.syntax"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.syntax" title="expr.literal.syntax"><span>[expr<wbr>.literal<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>리터럴표현식</em> :<br />
      <a href="expressions/../tokens.html#character-literals">문자리터럴</a><br />
   | <a href="expressions/../tokens.html#string-literals">문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#raw-string-literals">원시문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#byte-literals">바이트리터럴</a><br />
   | <a href="expressions/../tokens.html#byte-string-literals">바이트문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#raw-byte-string-literals">원시바이트문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#c-string-literals">C문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#raw-c-string-literals">원시C문자열리터럴</a><br />
   | <a href="expressions/../tokens.html#integer-literals">정수리터럴</a><br />
   | <a href="expressions/../tokens.html#floating-point-literals">부동소수점리터럴</a><br />
   | <code>true</code> | <code>false</code></p>
</blockquote>
<div class="rule" id="r-expr.literal.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.intro" title="expr.literal.intro"><span>[expr<wbr>.literal<wbr>.intro]<span/></a></div>
<p>_리터럴 표현식(literal expression)_은 단일 토큰으로 구성된 표현식으로, 이름을 통해 참조하거나 다른 평가 규칙을 따르는 대신, 그것이 평가되는 값을 즉시 그리고 직접적으로 나타냅니다.</p>
<div class="rule" id="r-expr.literal.const-expr"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.const-expr" title="expr.literal.const-expr"><span>[expr<wbr>.literal<wbr>.const-expr]<span/></a></div>
<p>리터럴은 <a href="expressions/../const_eval.html#constant-expressions">상수 표현식</a>의 한 형태이므로, (주로) 컴파일 타임에 평가됩니다.</p>
<div class="rule" id="r-expr.literal.literal-token"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.literal-token" title="expr.literal.literal-token"><span>[expr<wbr>.literal<wbr>.literal-token]<span/></a></div>
<p>앞서 설명한 어휘적 <a href="expressions/../tokens.html#literals">리터럴</a> 형식들은 각각 리터럴 표현식을 구성할 수 있으며, <code>true</code>와 <code>false</code> 키워드도 마찬가지입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"hello";   // 문자열 타입
'5';       // 문자 타입
5;         // 정수 타입
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.string-representation"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string-representation" title="expr.literal.string-representation"><span>[expr<wbr>.literal<wbr>.string-representation]<span/></a></div>
<p>아래 설명에서 토큰의 _문자열 표현(string representation)_은 <em>렉서</em> 문법 스니펫의 토큰 생성물과 일치하는 입력 문자 시퀀스를 의미합니다.</p>
<blockquote>
<p><strong>참고</strong>: 이 문자열 표현에는 <code>U+000D</code> (CR) 뒤에 바로 <code>U+000A</code> (LF)가 오는 문자가 포함되지 않습니다. 이 쌍은 이전에 이미 단일 <code>U+000A</code> (LF)로 변환되었을 것이기 때문입니다.</p>
</blockquote>
<div class="rule" id="r-expr.literal.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape" title="expr.literal.escape"><span>[expr<wbr>.literal<wbr>.escape]<span/></a></div>
<h2 id="이스케이프"><a class="header" href="#이스케이프">이스케이프</a></h2>
<div class="rule" id="r-expr.literal.escape.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.intro" title="expr.literal.escape.intro"><span>[expr<wbr>.literal<wbr>.escape<wbr>.intro]<span/></a></div>
<p>아래의 텍스트 리터럴 표현식에 대한 설명에서는 여러 형태의 _이스케이프(escape)_를 사용합니다.</p>
<div class="rule" id="r-expr.literal.escape.sequence"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.sequence" title="expr.literal.escape.sequence"><span>[expr<wbr>.literal<wbr>.escape<wbr>.sequence]<span/></a></div>
<p>각 이스케이프 형태는 다음으로 특징지어집니다:</p>
<ul>
<li><em>이스케이프 시퀀스(escape sequence)</em>: 항상 <code>U+005C</code> (<code>\</code>)로 시작하는 문자 시퀀스</li>
<li><em>이스케이프된 값(escaped value)</em>: 단일 문자 또는 빈 문자 시퀀스</li>
</ul>
<p>아래의 이스케이프 정의에서:</p>
<ul>
<li>_8진수 숫자(octal digit)_는 <code>0</code>-<code>7</code> 범위의 문자 중 하나입니다.</li>
<li>_16진수 숫자(hexadecimal digit)_는 <code>0</code>-<code>9</code>, <code>a</code>-<code>f</code>, 또는 <code>A</code>-<code>F</code> 범위의 문자 중 하나입니다.</li>
</ul>
<div class="rule" id="r-expr.literal.escape.simple"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.simple" title="expr.literal.escape.simple"><span>[expr<wbr>.literal<wbr>.escape<wbr>.simple]<span/></a></div>
<h3 id="단순-이스케이프"><a class="header" href="#단순-이스케이프">단순 이스케이프</a></h3>
<p>다음 표의 첫 번째 열에 나타나는 각 문자 시퀀스는 이스케이프 시퀀스입니다.</p>
<p>각 경우에, 이스케이프된 값은 두 번째 열의 해당 항목에 주어진 문자입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>이스케이프 시퀀스</th><th>이스케이프된 값</th></tr></thead><tbody>
<tr><td><code>\0</code></td><td>U+0000 (NUL)</td></tr>
<tr><td><code>\t</code></td><td>U+0009 (HT)</td></tr>
<tr><td><code>\n</code></td><td>U+000A (LF)</td></tr>
<tr><td><code>\r</code></td><td>U+000D (CR)</td></tr>
<tr><td>큰따옴표</td><td>U+0022 (큰따옴표)</td></tr>
<tr><td><code>\'</code></td><td>U+0027 (작은따옴표)</td></tr>
<tr><td><code>\\</code></td><td>U+005C (역슬래시)</td></tr>
</tbody></table>
</div><div class="rule" id="r-expr.literal.escape.hex-octet"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.hex-octet" title="expr.literal.escape.hex-octet"><span>[expr<wbr>.literal<wbr>.escape<wbr>.hex-octet]<span/></a></div>
<h3 id="8비트-이스케이프"><a class="header" href="#8비트-이스케이프">8비트 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\x</code> 뒤에 두 개의 16진수 숫자가 오는 것으로 구성됩니다.</p>
<p>이스케이프된 값은 이스케이프 시퀀스의 마지막 두 문자를 16진수 정수로 해석한 결과(기수가 16인 <a href="expressions/../../std/primitive.u8.html#method.from_str_radix"><code>u8::from_str_radix</code></a>를 사용한 것과 같음)를 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값(Unicode scalar value)</a>으로 가지는 문자입니다.</p>
<blockquote>
<p><strong>참고</strong>: 따라서 이스케이프된 값은 <a href="expressions/../types/numeric.html"><code>u8</code></a> 범위 내의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>을 가집니다.</p>
</blockquote>
<div class="rule" id="r-expr.literal.escape.hex-ascii"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.hex-ascii" title="expr.literal.escape.hex-ascii"><span>[expr<wbr>.literal<wbr>.escape<wbr>.hex-ascii]<span/></a></div>
<h3 id="7비트-이스케이프"><a class="header" href="#7비트-이스케이프">7비트 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\x</code> 뒤에 8진수 숫자 하나와 16진수 숫자 하나가 차례로 오는 것으로 구성됩니다.</p>
<p>이스케이프된 값은 이스케이프 시퀀스의 마지막 두 문자를 16진수 정수로 해석한 결과(기수가 16인 <a href="expressions/../../std/primitive.u8.html#method.from_str_radix"><code>u8::from_str_radix</code></a>를 사용한 것과 같음)를 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값(Unicode scalar value)</a>으로 가지는 문자입니다.</p>
<div class="rule" id="r-expr.literal.escape.unicode"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.escape.unicode" title="expr.literal.escape.unicode"><span>[expr<wbr>.literal<wbr>.escape<wbr>.unicode]<span/></a></div>
<h3 id="유니코드-이스케이프-1"><a class="header" href="#유니코드-이스케이프-1">유니코드 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\u{</code> 뒤에 16진수 숫자 또는 <code>_</code>로 구성된 문자 시퀀스가 오고, 그 뒤에 <code>}</code>가 오는 것으로 구성됩니다.</p>
<p>이스케이프된 값은 이스케이프 시퀀스에 포함된 16진수 숫자들을 16진수 정수로 해석한 결과(기수가 16인 <a href="expressions/../../std/primitive.u32.html#method.from_str_radix"><code>u32::from_str_radix</code></a>를 사용한 것과 같음)를 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>으로 가지는 문자입니다.</p>
<blockquote>
<p><strong>참고</strong>: 허용되는 <a href="expressions/../tokens.html#character-literals">문자리터럴(CHAR_LITERAL)</a> 또는 <a href="expressions/../tokens.html#string-literals">문자열리터럴(STRING_LITERAL)</a> 토큰의 형식은 그러한 문자가 반드시 존재함을 보장합니다.</p>
</blockquote>
<div class="rule" id="r-expr.literal.continuation"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.continuation" title="expr.literal.continuation"><span>[expr<wbr>.literal<wbr>.continuation]<span/></a></div>
<h3 id="문자열-연속-이스케이프"><a class="header" href="#문자열-연속-이스케이프">문자열 연속 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\</code> 뒤에 즉시 <code>U+000A</code> (LF)가 오고, 그다음 비-공백 문자 전까지의 모든 공백 문자들로 구성됩니다. 이 목적을 위해 공백 문자는 <code>U+0009</code> (HT), <code>U+000A</code> (LF), <code>U+000D</code> (CR), 그리고 <code>U+0020</code> (SPACE)입니다.</p>
<p>이스케이프된 값은 빈 문자 시퀀스입니다.</p>
<blockquote>
<p><strong>참고</strong>: 이 형태의 이스케이프 효과는 문자열 연속 시퀀스가 뒤따르는 공백(추가적인 줄 바꿈 포함)을 건너뛴다는 것입니다. 따라서 <code>a</code>, <code>b</code>, <code>c</code>는 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = "foobar";
let b = "foo\
         bar";
let c = "foo\

     bar";

assert_eq!(a, b);
assert_eq!(b, c);
<span class="boring">}</span></code></pre></pre>
<p>추가적인 줄 바꿈을 건너뛰는 것(예시 c와 같은 경우)은 잠재적으로 혼란스럽고 예상치 못한 일일 수 있습니다. 이 동작은 미래에 조정될 수 있습니다. 결정이 내려지기 전까지는 라인 연속 기능을 사용하여 여러 줄 바꿈을 건너뛰는 것에 의존하지 않는 것이 권장됩니다. 자세한 내용은 <a href="https://github.com/rust-lang/reference/pull/1042">이 이슈</a>를 참조하세요.</p>
</blockquote>
<div class="rule" id="r-expr.literal.char"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char" title="expr.literal.char"><span>[expr<wbr>.literal<wbr>.char]<span/></a></div>
<h2 id="문자-리터럴-표현식"><a class="header" href="#문자-리터럴-표현식">문자 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.char.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.intro" title="expr.literal.char.intro"><span>[expr<wbr>.literal<wbr>.char<wbr>.intro]<span/></a></div>
<p>문자 리터럴 표현식은 단일 <a href="expressions/../tokens.html#character-literals">문자리터럴(CHAR_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.char.type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.type" title="expr.literal.char.type"><span>[expr<wbr>.literal<wbr>.char<wbr>.type]<span/></a></div>
<p>표현식의 타입은 기본 <a href="expressions/../types/textual.html"><code>char</code></a> 타입입니다.</p>
<div class="rule" id="r-expr.literal.char.no-suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.no-suffix" title="expr.literal.char.no-suffix"><span>[expr<wbr>.literal<wbr>.char<wbr>.no-suffix]<span/></a></div>
<p>토큰은 접미사(suffix)를 가져서는 안 됩니다.</p>
<div class="rule" id="r-expr.literal.char.literal-content"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.literal-content" title="expr.literal.char.literal-content"><span>[expr<wbr>.literal<wbr>.char<wbr>.literal-content]<span/></a></div>
<p>토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 <code>U+0027</code> (<code>'</code>) 뒤에 오고 마지막 <code>U+0027</code> (<code>'</code>) 앞에 오는 문자 시퀀스입니다.</p>
<div class="rule" id="r-expr.literal.char.represented"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.represented" title="expr.literal.char.represented"><span>[expr<wbr>.literal<wbr>.char<wbr>.represented]<span/></a></div>
<p>리터럴 표현식의 _표현된 문자(represented character)_는 다음과 같이 리터럴 내용으로부터 유도됩니다:</p>
<div class="rule" id="r-expr.literal.char.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.escape" title="expr.literal.char.escape"><span>[expr<wbr>.literal<wbr>.char<wbr>.escape]<span/></a></div>
<ul>
<li>리터럴 내용이 다음 형태의 이스케이프 시퀀스 중 하나인 경우, 표현된 문자는 해당 이스케이프 시퀀스의 이스케이프된 값입니다.
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#7-bit-escapes">7비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.char.single"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.single" title="expr.literal.char.single"><span>[expr<wbr>.literal<wbr>.char<wbr>.single]<span/></a></div>
<ul>
<li>그렇지 않은 경우, 표현된 문자는 리터럴 내용을 구성하는 단일 문자입니다.</li>
</ul>
<div class="rule" id="r-expr.literal.char.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.char.result" title="expr.literal.char.result"><span>[expr<wbr>.literal<wbr>.char<wbr>.result]<span/></a></div>
<p>표현식의 값은 표현된 문자의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>에 해당하는 <a href="expressions/../types/textual.html"><code>char</code></a>입니다.</p>
<blockquote>
<p><strong>참고</strong>: 허용되는 <a href="expressions/../tokens.html#character-literals">문자리터럴(CHAR_LITERAL)</a> 토큰의 형식은 이러한 규칙들이 항상 단일 문자를 생성함을 보장합니다.</p>
</blockquote>
<p>문자 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'R';                               // R
'\'';                              // '
'\x52';                            // R
'\u{00E6}';                        // 라틴어 소문자 AE (U+00E6)
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.string"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string" title="expr.literal.string"><span>[expr<wbr>.literal<wbr>.string]<span/></a></div>
<h2 id="문자열-리터럴-표현식"><a class="header" href="#문자열-리터럴-표현식">문자열 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.string.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.intro" title="expr.literal.string.intro"><span>[expr<wbr>.literal<wbr>.string<wbr>.intro]<span/></a></div>
<p>문자열 리터럴 표현식은 단일 <a href="expressions/../tokens.html#string-literals">문자열리터럴(STRING_LITERAL)</a> 또는 <a href="expressions/../tokens.html#raw-string-literals">원시문자열리터럴(RAW_STRING_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.string.type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.type" title="expr.literal.string.type"><span>[expr<wbr>.literal<wbr>.string<wbr>.type]<span/></a></div>
<p>표현식의 타입은 기본 <a href="expressions/../types/textual.html"><code>str</code></a> 타입에 대한 공유 참조(<code>static</code> 라이프타임을 가짐)입니다. 즉, 타입은 <code>&amp;'static str</code>입니다.</p>
<div class="rule" id="r-expr.literal.string.no-suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.no-suffix" title="expr.literal.string.no-suffix"><span>[expr<wbr>.literal<wbr>.string<wbr>.no-suffix]<span/></a></div>
<p>토큰은 접미사(suffix)를 가져서는 안 됩니다.</p>
<div class="rule" id="r-expr.literal.string.literal-content"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.literal-content" title="expr.literal.string.literal-content"><span>[expr<wbr>.literal<wbr>.string<wbr>.literal-content]<span/></a></div>
<p>토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 <code>U+0022</code> (<code>"</code>) 뒤에 오고 마지막 <code>U+0022</code> (<code>"</code>) 앞에 오는 문자 시퀀스입니다.</p>
<div class="rule" id="r-expr.literal.string.represented"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.represented" title="expr.literal.string.represented"><span>[expr<wbr>.literal<wbr>.string<wbr>.represented]<span/></a></div>
<p>리터럴 표현식의 _표현된 문자열(represented string)_은 다음과 같이 리터럴 내용으로부터 유도된 문자 시퀀스입니다:</p>
<div class="rule" id="r-expr.literal.string.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.escape" title="expr.literal.string.escape"><span>[expr<wbr>.literal<wbr>.string<wbr>.escape]<span/></a></div>
<ul>
<li>
<p>토큰이 <a href="expressions/../tokens.html#string-literals">문자열리터럴(STRING_LITERAL)</a>인 경우, 리터럴 내용에서 나타나는 다음 형태의 각 이스케이프 시퀀스는 해당 이스케이프 시퀀스의 이스케이프된 값으로 대체됩니다.</p>
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#7-bit-escapes">7비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>
이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, <code>"\\x41"</code> 토큰은 문자 <code>\</code>, <code>x</code>, <code>4</code>, <code>1</code>로 변환됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.string.raw"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.raw" title="expr.literal.string.raw"><span>[expr<wbr>.literal<wbr>.string<wbr>.raw]<span/></a></div>
<ul>
<li>토큰이 <a href="expressions/../tokens.html#raw-string-literals">원시문자열리터럴(RAW_STRING_LITERAL)</a>인 경우, 표현된 문자열은 리터럴 내용과 동일합니다.</li>
</ul>
<div class="rule" id="r-expr.literal.string.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.string.result" title="expr.literal.string.result"><span>[expr<wbr>.literal<wbr>.string<wbr>.result]<span/></a></div>
<p>표현식의 값은 표현된 문자열의 UTF-8 인코딩을 포함하는 정적으로 할당된 <a href="expressions/../types/textual.html"><code>str</code></a>에 대한 참조입니다.</p>
<p>문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.byte-char"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char" title="expr.literal.byte-char"><span>[expr<wbr>.literal<wbr>.byte-char]<span/></a></div>
<h2 id="바이트-리터럴-표현식"><a class="header" href="#바이트-리터럴-표현식">바이트 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.byte-char.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.intro" title="expr.literal.byte-char.intro"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.intro]<span/></a></div>
<p>바이트 리터럴 표현식은 단일 <a href="expressions/../tokens.html#byte-literals">바이트리터럴(BYTE_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.byte-char.literal"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.literal" title="expr.literal.byte-char.literal"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.literal]<span/></a></div>
<p>표현식의 타입은 기본 <a href="expressions/../types/numeric.html"><code>u8</code></a> 타입입니다.</p>
<div class="rule" id="r-expr.literal.byte-char.no-suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.no-suffix" title="expr.literal.byte-char.no-suffix"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.no-suffix]<span/></a></div>
<p>토큰은 접미사(suffix)를 가져서는 안 됩니다.</p>
<div class="rule" id="r-expr.literal.byte-char.literal-content"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.literal-content" title="expr.literal.byte-char.literal-content"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.literal-content]<span/></a></div>
<p>토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 <code>U+0027</code> (<code>'</code>) 뒤에 오고 마지막 <code>U+0027</code> (<code>'</code>) 앞에 오는 문자 시퀀스입니다.</p>
<div class="rule" id="r-expr.literal.byte-char.represented"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.represented" title="expr.literal.byte-char.represented"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.represented]<span/></a></div>
<p>리터럴 표현식의 _표현된 문자(represented character)_는 다음과 같이 리터럴 내용으로부터 유도됩니다:</p>
<div class="rule" id="r-expr.literal.byte-char.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.escape" title="expr.literal.byte-char.escape"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.escape]<span/></a></div>
<ul>
<li>리터럴 내용이 다음 형태의 이스케이프 시퀀스 중 하나인 경우, 표현된 문자는 해당 이스케이프 시퀀스의 이스케이프된 값입니다.
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.byte-char.single"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.single" title="expr.literal.byte-char.single"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.single]<span/></a></div>
<ul>
<li>그렇지 않은 경우, 표현된 문자는 리터럴 내용을 구성하는 단일 문자입니다.</li>
</ul>
<div class="rule" id="r-expr.literal.byte-char.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-char.result" title="expr.literal.byte-char.result"><span>[expr<wbr>.literal<wbr>.byte-char<wbr>.result]<span/></a></div>
<p>표현식의 값은 표현된 문자의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>입니다.</p>
<blockquote>
<p><strong>참고</strong>: 허용되는 <a href="expressions/../tokens.html#byte-literals">바이트리터럴(BYTE_LITERAL)</a> 토큰의 형식은 이러한 규칙들이 항상 <a href="expressions/../types/numeric.html"><code>u8</code></a> 범위의 유니코드 스칼라 값을 가지는 단일 문자를 생성함을 보장합니다.</p>
</blockquote>
<p>바이트 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b'R';                              // 82
b'\'';                             // 39
b'\x52';                           // 82
b'\xA0';                           // 160
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.byte-string"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string" title="expr.literal.byte-string"><span>[expr<wbr>.literal<wbr>.byte-string]<span/></a></div>
<h2 id="바이트-문자열-리터럴-표현식"><a class="header" href="#바이트-문자열-리터럴-표현식">바이트 문자열 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.byte-string.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.intro" title="expr.literal.byte-string.intro"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.intro]<span/></a></div>
<p>바이트 문자열 리터럴 표현식은 단일 <a href="expressions/../tokens.html#byte-string-literals">바이트문자열리터럴(BYTE_STRING_LITERAL)</a> 또는 <a href="expressions/../tokens.html#raw-byte-string-literals">원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.byte-string.type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.type" title="expr.literal.byte-string.type"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.type]<span/></a></div>
<p>표현식의 타입은 요소 타입이 <a href="expressions/../types/numeric.html"><code>u8</code></a>인 배열에 대한 공유 참조(<code>static</code> 라이프타임을 가짐)입니다. 즉, 타입은 <code>&amp;'static [u8; N]</code>이며, 여기서 <code>N</code>은 아래에서 설명하는 표현된 문자열의 바이트 수입니다.</p>
<div class="rule" id="r-expr.literal.byte-string.no-suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.no-suffix" title="expr.literal.byte-string.no-suffix"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.no-suffix]<span/></a></div>
<p>토큰은 접미사(suffix)를 가져서는 안 됩니다.</p>
<div class="rule" id="r-expr.literal.byte-string.literal-content"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.literal-content" title="expr.literal.byte-string.literal-content"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.literal-content]<span/></a></div>
<p>토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 <code>U+0022</code> (<code>"</code>) 뒤에 오고 마지막 <code>U+0022</code> (<code>"</code>) 앞에 오는 문자 시퀀스입니다.</p>
<div class="rule" id="r-expr.literal.byte-string.represented"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.represented" title="expr.literal.byte-string.represented"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.represented]<span/></a></div>
<p>리터럴 표현식의 _표현된 문자열(represented string)_은 다음과 같이 리터럴 내용으로부터 유도된 문자 시퀀스입니다:</p>
<div class="rule" id="r-expr.literal.byte-string.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.escape" title="expr.literal.byte-string.escape"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.escape]<span/></a></div>
<ul>
<li>
<p>토큰이 <a href="expressions/../tokens.html#byte-string-literals">바이트문자열리터럴(BYTE_STRING_LITERAL)</a>인 경우, 리터럴 내용에서 나타나는 다음 형태의 각 이스케이프 시퀀스는 해당 이스케이프 시퀀스의 이스케이프된 값으로 대체됩니다.</p>
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>
이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, <code>b"\\x41"</code> 토큰은 문자 <code>\</code>, <code>x</code>, <code>4</code>, <code>1</code>로 변환됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.byte-string.raw"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.raw" title="expr.literal.byte-string.raw"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.raw]<span/></a></div>
<ul>
<li>토큰이 <a href="expressions/../tokens.html#raw-byte-string-literals">원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)</a>인 경우, 표현된 문자열은 리터럴 내용과 동일합니다.</li>
</ul>
<div class="rule" id="r-expr.literal.byte-string.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.byte-string.result" title="expr.literal.byte-string.result"><span>[expr<wbr>.literal<wbr>.byte-string<wbr>.result]<span/></a></div>
<p>표현식의 값은 표현된 문자열 속 문자들의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>들을 동일한 순서로 포함하는 정적으로 할당된 배열에 대한 참조입니다.</p>
<blockquote>
<p><strong>참고</strong>: 허용되는 <a href="expressions/../tokens.html#byte-string-literals">바이트문자열리터럴(BYTE_STRING_LITERAL)</a> 및 <a href="expressions/../tokens.html#raw-byte-string-literals">원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)</a> 토큰의 형식은 이러한 규칙들이 항상 <a href="expressions/../types/numeric.html"><code>u8</code></a> 범위의 배열 요소 값을 생성함을 보장합니다.</p>
</blockquote>
<p>바이트 문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.c-string"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string" title="expr.literal.c-string"><span>[expr<wbr>.literal<wbr>.c-string]<span/></a></div>
<h2 id="c-문자열-리터럴-표현식"><a class="header" href="#c-문자열-리터럴-표현식">C 문자열 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.c-string.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.intro" title="expr.literal.c-string.intro"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.intro]<span/></a></div>
<p>C 문자열 리터럴 표현식은 단일 <a href="expressions/../tokens.html#c-string-literals">C문자열리터럴(C_STRING_LITERAL)</a> 또는 <a href="expressions/../tokens.html#raw-c-string-literals">원시C문자열리터럴(RAW_C_STRING_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.c-string.type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.type" title="expr.literal.c-string.type"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.type]<span/></a></div>
<p>표현식의 타입은 표준 라이브러리 <a href="expressions/../../core/ffi/c_str/struct.CStr.html">CStr</a> 타입에 대한 공유 참조(<code>static</code> 라이프타임을 가짐)입니다. 즉, 타입은 <code>&amp;'static core::ffi::CStr</code>입니다.</p>
<div class="rule" id="r-expr.literal.c-string.no-suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.no-suffix" title="expr.literal.c-string.no-suffix"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.no-suffix]<span/></a></div>
<p>토큰은 접미사(suffix)를 가져서는 안 됩니다.</p>
<div class="rule" id="r-expr.literal.c-string.literal-content"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.literal-content" title="expr.literal.c-string.literal-content"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.literal-content]<span/></a></div>
<p>토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 <code>U+0022</code> (<code>"</code>) 뒤에 오고 마지막 <code>U+0022</code> (<code>"</code>) 앞에 오는 문자 시퀀스입니다.</p>
<div class="rule" id="r-expr.literal.c-string.represented"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.represented" title="expr.literal.c-string.represented"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.represented]<span/></a></div>
<p>리터럴 표현식의 _표현된 바이트(represented bytes)_는 다음과 같이 리터럴 내용으로부터 유도된 바이트 시퀀스입니다:</p>
<div class="rule" id="r-expr.literal.c-string.escape"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.escape" title="expr.literal.c-string.escape"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.escape]<span/></a></div>
<ul>
<li>토큰이 <a href="expressions/../tokens.html#c-string-literals">C문자열리터럴(C_STRING_LITERAL)</a>인 경우, 리터럴 내용은 <code>\</code>가 아닌 단일 유니코드 문자 또는 <a href="expressions/literal-expr.html#escapes">이스케이프</a>인 항목들의 시퀀스로 취급됩니다. 항목들의 시퀀스는 다음과 같이 바이트 시퀀스로 변환됩니다:
<ul>
<li>각 단일 유니코드 문자는 자신의 UTF-8 표현을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a>는 이스케이프된 값의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a>는 이스케이프된 값의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>을 포함하는 단일 바이트를 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a>는 이스케이프된 값의 UTF-8 표현을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>는 어떠한 바이트도 기여하지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.c-string.raw"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.raw" title="expr.literal.c-string.raw"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.raw]<span/></a></div>
<ul>
<li>토큰이 <a href="expressions/../tokens.html#raw-c-string-literals">원시C문자열리터럴(RAW_C_STRING_LITERAL)</a>인 경우, 표현된 바이트는 리터럴 내용의 UTF-8 인코딩입니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 허용되는 <a href="expressions/../tokens.html#c-string-literals">C문자열리터럴(C_STRING_LITERAL)</a> 및 <a href="expressions/../tokens.html#raw-c-string-literals">원시C문자열리터럴(RAW_C_STRING_LITERAL)</a> 토큰의 형식은 표현된 바이트에 널 바이트가 포함되지 않음을 보장합니다.</p>
</blockquote>
<div class="rule" id="r-expr.literal.c-string.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.c-string.result" title="expr.literal.c-string.result"><span>[expr<wbr>.literal<wbr>.c-string<wbr>.result]<span/></a></div>
<p>표현식의 값은 표현된 바이트 뒤에 널 바이트가 뒤따르는 바이트 배열을 포함하는 정적으로 할당된 <a href="expressions/../../core/ffi/c_str/struct.CStr.html">CStr</a>에 대한 참조입니다.</p>
<p>C 문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"foo"; cr"foo";                     // foo
c"\"foo\""; cr#""foo""#;             // "foo"

c"foo #\"# bar";
cr##"foo #"# bar"##;                 // foo #"# bar

c"\x52"; c"R"; cr"R";                // R
c"\\x52"; cr"\x52";                  // \x52

c"æ";                                // 라틴어 소문자 AE (U+00E6)
c"\u{00E6}";                         // 라틴어 소문자 AE (U+00E6)
c"\xC3\xA6";                         // 라틴어 소문자 AE (U+00E6)

c"\xE6".to_bytes();                  // [230]
c"\u{00E6}".to_bytes();              // [195, 166]
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.int"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int" title="expr.literal.int"><span>[expr<wbr>.literal<wbr>.int]<span/></a></div>
<h2 id="정수-리터럴-표현식"><a class="header" href="#정수-리터럴-표현식">정수 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.int.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.intro" title="expr.literal.int.intro"><span>[expr<wbr>.literal<wbr>.int<wbr>.intro]<span/></a></div>
<p>정수 리터럴 표현식은 단일 <a href="expressions/../tokens.html#integer-literals">정수리터럴(INTEGER_LITERAL)</a> 토큰으로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.int.suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.suffix" title="expr.literal.int.suffix"><span>[expr<wbr>.literal<wbr>.int<wbr>.suffix]<span/></a></div>
<p>토큰에 <a href="expressions/../tokens.html#suffixes">접미사(suffix)</a>가 있는 경우, 접미사는 <a href="expressions/../types/numeric.html">기본 정수 타입</a> 중 하나인 <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, 또는 <code>isize</code>여야 하며, 표현식은 해당 타입을 가집니다.</p>
<div class="rule" id="r-expr.literal.int.infer"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.infer" title="expr.literal.int.infer"><span>[expr<wbr>.literal<wbr>.int<wbr>.infer]<span/></a></div>
<p>토큰에 접미사가 없는 경우, 표현식의 타입은 타입 추론에 의해 결정됩니다.</p>
<div class="rule" id="r-expr.literal.int.inference-unique-type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.inference-unique-type" title="expr.literal.int.inference-unique-type"><span>[expr<wbr>.literal<wbr>.int<wbr>.inference-unique-type]<span/></a></div>
<ul>
<li>주변 프로그램 문맥으로부터 정수 타입을 <em>유일하게</em> 결정할 수 있다면, 표현식은 해당 타입을 가집니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.inference-default"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.inference-default" title="expr.literal.int.inference-default"><span>[expr<wbr>.literal<wbr>.int<wbr>.inference-default]<span/></a></div>
<ul>
<li>프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 부호 있는 32비트 정수인 <code>i32</code>가 사용됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.inference-error"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.inference-error" title="expr.literal.int.inference-error"><span>[expr<wbr>.literal<wbr>.int<wbr>.inference-error]<span/></a></div>
<ul>
<li>프로그램 문맥이 타입을 과도하게 제약하는 경우, 정적 타입 에러로 간주됩니다.</li>
</ul>
<p>정수 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123;                               // i32 타입
123i32;                            // i32 타입
123u32;                            // u32 타입
123_u32;                           // u32 타입
let a: u64 = 123;                  // u64 타입

0xff;                              // i32 타입
0xff_u8;                           // u8 타입

0o70;                              // i32 타입
0o70_i16;                          // i16 타입

0b1111_1111_1001_0000;             // i32 타입
0b1111_1111_1001_0000i64;          // i64 타입

0usize;                            // usize 타입
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.int.representation"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.representation" title="expr.literal.int.representation"><span>[expr<wbr>.literal<wbr>.int<wbr>.representation]<span/></a></div>
<p>표현식의 값은 다음과 같이 토큰의 문자열 표현으로부터 결정됩니다:</p>
<div class="rule" id="r-expr.literal.int.radix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.radix" title="expr.literal.int.radix"><span>[expr<wbr>.literal<wbr>.int<wbr>.radix]<span/></a></div>
<ul>
<li>
<p>정수 기수(radix)는 문자열의 처음 두 문자를 조사하여 다음과 같이 결정됩니다:</p>
<ul>
<li><code>0b</code>는 기수 2를 나타냅니다.</li>
<li><code>0o</code>는 기수 8을 나타냅니다.</li>
<li><code>0x</code>는 기수 16을 나타냅니다.</li>
<li>그 외의 경우 기수는 10입니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-expr.literal.int.radix-prefix-stripped"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.radix-prefix-stripped" title="expr.literal.int.radix-prefix-stripped"><span>[expr<wbr>.literal<wbr>.int<wbr>.radix-prefix-stripped]<span/></a></div>
<ul>
<li>기수가 10이 아닌 경우, 처음 두 문자가 문자열에서 제거됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.type-suffix-stripped"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.type-suffix-stripped" title="expr.literal.int.type-suffix-stripped"><span>[expr<wbr>.literal<wbr>.int<wbr>.type-suffix-stripped]<span/></a></div>
<ul>
<li>모든 접미사는 문자열에서 제거됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.separators-stripped"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.separators-stripped" title="expr.literal.int.separators-stripped"><span>[expr<wbr>.literal<wbr>.int<wbr>.separators-stripped]<span/></a></div>
<ul>
<li>모든 밑줄(<code>_</code>)은 문자열에서 제거됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.u128-value"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.u128-value" title="expr.literal.int.u128-value"><span>[expr<wbr>.literal<wbr>.int<wbr>.u128-value]<span/></a></div>
<ul>
<li>문자열은 선택된 기수와 함께 <a href="expressions/../../std/primitive.u128.html#method.from_str_radix"><code>u128::from_str_radix</code></a>를 사용한 것처럼 <code>u128</code> 값으로 변환됩니다. 만약 값이 <code>u128</code>에 맞지 않으면 컴파일 에러입니다.</li>
</ul>
<div class="rule" id="r-expr.literal.int.cast"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.int.cast" title="expr.literal.int.cast"><span>[expr<wbr>.literal<wbr>.int<wbr>.cast]<span/></a></div>
<ul>
<li><code>u128</code> 값은 <a href="expressions/operator-expr.html#numeric-cast">숫자 캐스트(numeric cast)</a>를 통해 표현식의 타입으로 변환됩니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 최종 캐스트는 리터럴의 값이 표현식의 타입에 맞지 않을 경우 값을 잘라냅니다(truncate). <code>rustc</code>에는 <code>overflowing_literals</code>라는 이름의 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">린트 체크</a>가 포함되어 있으며 기본값은 <code>deny</code>로, 이러한 상황이 발생하는 표현식을 거부합니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: 예를 들어 <code>-1i8</code>은 리터럴 표현식 <code>1i8</code>에 <a href="expressions/operator-expr.html#negation-operators">부정 연산자(negation operator)</a>를 적용한 것이지, 단일 정수 리터럴 표현식이 아닙니다. 부호 있는 타입에서 가장 작은 음수 값을 표현하는 방식에 대한 노트는 <a href="expressions/operator-expr.html#overflow">오버플로(Overflow)</a>를 참조하세요.</p>
</blockquote>
<div class="rule" id="r-expr.literal.float"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float" title="expr.literal.float"><span>[expr<wbr>.literal<wbr>.float]<span/></a></div>
<h2 id="부동-소수점-리터럴-표현식"><a class="header" href="#부동-소수점-리터럴-표현식">부동 소수점 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.float.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.intro" title="expr.literal.float.intro"><span>[expr<wbr>.literal<wbr>.float<wbr>.intro]<span/></a></div>
<p>부동 소수점 리터럴 표현식은 다음 두 가지 형식 중 하나를 가집니다:</p>
<ul>
<li>단일 <a href="expressions/../tokens.html#floating-point-literals">부동소수점리터럴(FLOAT_LITERAL)</a> 토큰</li>
<li>접미사가 있고 기수 표시가 없는 단일 <a href="expressions/../tokens.html#integer-literals">정수리터럴(INTEGER_LITERAL)</a> 토큰</li>
</ul>
<div class="rule" id="r-expr.literal.float.suffix"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.suffix" title="expr.literal.float.suffix"><span>[expr<wbr>.literal<wbr>.float<wbr>.suffix]<span/></a></div>
<p>토큰에 <a href="expressions/../tokens.html#suffixes">접미사(suffix)</a>가 있는 경우, 접미사는 <a href="expressions/../types/numeric.html#floating-point-types">기본 부동 소수점 타입</a> 중 하나인 <code>f32</code> 또는 <code>f64</code>여야 하며, 표현식은 해당 타입을 가집니다.</p>
<div class="rule" id="r-expr.literal.float.infer"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.infer" title="expr.literal.float.infer"><span>[expr<wbr>.literal<wbr>.float<wbr>.infer]<span/></a></div>
<p>토큰에 접미사가 없는 경우, 표현식의 타입은 타입 추론에 의해 결정됩니다.</p>
<div class="rule" id="r-expr.literal.float.inference-unique-type"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.inference-unique-type" title="expr.literal.float.inference-unique-type"><span>[expr<wbr>.literal<wbr>.float<wbr>.inference-unique-type]<span/></a></div>
<ul>
<li>주변 프로그램 문맥으로부터 부동 소수점 타입을 <em>유일하게</em> 결정할 수 있다면, 표현식은 해당 타입을 가집니다.</li>
</ul>
<div class="rule" id="r-expr.literal.float.inference-default"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.inference-default" title="expr.literal.float.inference-default"><span>[expr<wbr>.literal<wbr>.float<wbr>.inference-default]<span/></a></div>
<ul>
<li>프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 <code>f64</code>가 사용됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.float.inference-error"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.inference-error" title="expr.literal.float.inference-error"><span>[expr<wbr>.literal<wbr>.float<wbr>.inference-error]<span/></a></div>
<ul>
<li>프로그램 문맥이 타입을 과도하게 제약하는 경우, 정적 타입 에러로 간주됩니다.</li>
</ul>
<p>부동 소수점 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;        // f64 타입
0.1f64;          // f64 타입
0.1f32;          // f32 타입
12E+99_f64;      // f64 타입
5f32;            // f32 타입
let x: f64 = 2.; // f64 타입
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.literal.float.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.result" title="expr.literal.float.result"><span>[expr<wbr>.literal<wbr>.float<wbr>.result]<span/></a></div>
<p>표현식의 값은 다음과 같이 토큰의 문자열 표현으로부터 결정됩니다:</p>
<div class="rule" id="r-expr.literal.float.type-suffix-stripped"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.type-suffix-stripped" title="expr.literal.float.type-suffix-stripped"><span>[expr<wbr>.literal<wbr>.float<wbr>.type-suffix-stripped]<span/></a></div>
<ul>
<li>모든 접미사는 문자열에서 제거됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.float.separators-stripped"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.separators-stripped" title="expr.literal.float.separators-stripped"><span>[expr<wbr>.literal<wbr>.float<wbr>.separators-stripped]<span/></a></div>
<ul>
<li>모든 밑줄(<code>_</code>)은 문자열에서 제거됩니다.</li>
</ul>
<div class="rule" id="r-expr.literal.float.value"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.float.value" title="expr.literal.float.value"><span>[expr<wbr>.literal<wbr>.float<wbr>.value]<span/></a></div>
<ul>
<li>문자열은 <a href="expressions/../../core/primitive.f32.html#method.from_str"><code>f32::from_str</code></a> 또는 <a href="expressions/../../core/primitive.f64.html#method.from_str"><code>f64::from_str</code></a>을 사용한 것처럼 표현식의 타입으로 변환됩니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 예를 들어 <code>-1.0</code>은 리터럴 표현식 <code>1.0</code>에 <a href="expressions/operator-expr.html#negation-operators">부정 연산자(negation operator)</a>를 적용한 것이지, 단일 부동 소수점 리터럴 표현식이 아닙니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: <code>inf</code>와 <code>NaN</code>은 리터럴 토큰이 아닙니다. 리터럴 표현식 대신 <a href="expressions/../../std/primitive.f32.html#associatedconstant.INFINITY"><code>f32::INFINITY</code></a>, <a href="expressions/../../std/primitive.f64.html#associatedconstant.INFINITY"><code>f64::INFINITY</code></a>, <a href="expressions/../../std/primitive.f32.html#associatedconstant.NAN"><code>f32::NAN</code></a>, <a href="expressions/../../std/primitive.f64.html#associatedconstant.NAN"><code>f64::NAN</code></a> 상수들을 사용할 수 있습니다. <code>rustc</code>에서 무한대로 평가될 만큼 큰 리터럴은 <code>overflowing_literals</code> 린트 체크를 발생시킵니다.</p>
</blockquote>
<div class="rule" id="r-expr.literal.bool"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.bool" title="expr.literal.bool"><span>[expr<wbr>.literal<wbr>.bool]<span/></a></div>
<h2 id="불리언-리터럴-표현식"><a class="header" href="#불리언-리터럴-표현식">불리언 리터럴 표현식</a></h2>
<div class="rule" id="r-expr.literal.bool.intro"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.bool.intro" title="expr.literal.bool.intro"><span>[expr<wbr>.literal<wbr>.bool<wbr>.intro]<span/></a></div>
<p>불리언 리터럴 표현식은 <code>true</code> 또는 <code>false</code> 키워드 중 하나로 구성됩니다.</p>
<div class="rule" id="r-expr.literal.bool.result"><a class="rule-link" href="expressions/literal-expr.html#r-expr.literal.bool.result" title="expr.literal.bool.result"><span>[expr<wbr>.literal<wbr>.bool<wbr>.result]<span/></a></div>
<p>표현식의 타입은 기본 <a href="expressions/../types/boolean.html">불리언 타입</a>이며, 그 값은 다음과 같습니다:</p>
<ul>
<li>키워드가 <code>true</code>인 경우 true</li>
<li>키워드가 <code>false</code>인 경우 false</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.path"><a class="rule-link" href="expressions/path-expr.html#r-expr.path" title="expr.path"><span>[expr<wbr>.path]<span/></a></div>
<h1 id="경로-표현식"><a class="header" href="#경로-표현식">경로 표현식</a></h1>
<div class="rule" id="r-expr.path.syntax"><a class="rule-link" href="expressions/path-expr.html#r-expr.path.syntax" title="expr.path.syntax"><span>[expr<wbr>.path<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>경로표현식</em> :<br />
      <a href="expressions/../paths.html#paths-in-expressions"><em>표현식내경로</em></a><br />
   | <a href="expressions/../paths.html#qualified-paths"><em>한정된표현식내경로</em></a></p>
</blockquote>
<div class="rule" id="r-expr.path.intro"><a class="rule-link" href="expressions/path-expr.html#r-expr.path.intro" title="expr.path.intro"><span>[expr<wbr>.path<wbr>.intro]<span/></a></div>
<p>표현식 컨텍스트에서 사용된 <a href="expressions/../paths.html">경로</a>는 지역 변수 또는 아이템을 나타냅니다.</p>
<div class="rule" id="r-expr.path.place"><a class="rule-link" href="expressions/path-expr.html#r-expr.path.place" title="expr.path.place"><span>[expr<wbr>.path<wbr>.place]<span/></a></div>
<p>지역 변수 또는 정적 변수로 해석되는 경로 표현식은 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>이며, 그 외의 경로는 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>입니다.</p>
<div class="rule" id="r-expr.path.safety"><a class="rule-link" href="expressions/path-expr.html#r-expr.path.safety" title="expr.path.safety"><span>[expr<wbr>.path<wbr>.safety]<span/></a></div>
<p><a href="expressions/../items/static-items.html#mutable-statics"><code>static mut</code></a> 변수를 사용하는 것은 <a href="expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> 블록</a>을 요구합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod globals {
</span><span class="boring">    pub static STATIC_VAR: i32 = 5;
</span><span class="boring">    pub static mut STATIC_MUT_VAR: i32 = 7;
</span><span class="boring">}
</span><span class="boring">let local_var = 3;
</span>local_var;
globals::STATIC_VAR;
unsafe { globals::STATIC_MUT_VAR };
let some_constructor = Some::&lt;i32&gt;;
let push_integer = Vec::&lt;i32&gt;::push;
let slice_reverse = &lt;[i32]&gt;::reverse;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.path.const"><a class="rule-link" href="expressions/path-expr.html#r-expr.path.const" title="expr.path.const"><span>[expr<wbr>.path<wbr>.const]<span/></a></div>
<p>연관 상수의 평가는 <a href="expressions/block-expr.html#const-blocks"><code>const</code> 블록</a>과 동일한 방식으로 처리됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.block"><a class="rule-link" href="expressions/block-expr.html#r-expr.block" title="expr.block"><span>[expr<wbr>.block]<span/></a></div>
<h1 id="블록-표현식"><a class="header" href="#블록-표현식">블록 표현식</a></h1>
<div class="rule" id="r-expr.block.syntax"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.syntax" title="expr.block.syntax"><span>[expr<wbr>.block<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>블록표현식</em> :<br />
   <code>{</code><br />
      <a href="expressions/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
      <em>구문들</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>구문들</em> :<br />
      <a href="expressions/../statements.html"><em>구문</em></a><sup>+</sup><br />
   | <a href="expressions/../statements.html"><em>구문</em></a><sup>+</sup> <a href="expressions/../expressions.html"><em>블록없는표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>블록없는표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.block.intro"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.intro" title="expr.block.intro"><span>[expr<wbr>.block<wbr>.intro]<span/></a></div>
<p><em>블록 표현식(block expression)</em> 또는 줄여서 _블록_은 제어 흐름 표현식이자 아이템 및 변수 선언을 위한 익명 네임스페이스 스코프입니다.</p>
<div class="rule" id="r-expr.block.sequential-evaluation"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.sequential-evaluation" title="expr.block.sequential-evaluation"><span>[expr<wbr>.block<wbr>.sequential-evaluation]<span/></a></div>
<p>제어 흐름 표현식으로서 블록은 구성 요소인 비-아이템 선언 구문들을 순차적으로 실행한 후, 마지막의 선택적 표현식을 실행합니다.</p>
<div class="rule" id="r-expr.block.namepsace"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.namepsace" title="expr.block.namepsace"><span>[expr<wbr>.block<wbr>.namepsace]<span/></a></div>
<p>익명 네임스페이스 스코프로서 아이템 선언은 블록 내부에서만 스코프 내에 있으며, <code>let</code> 문에 의해 선언된 변수들은 다음 구문부터 블록 끝까지 스코프 내에 있습니다. 자세한 내용은 <a href="expressions/../names/scopes.html">스코프</a> 장을 참조하세요.</p>
<div class="rule" id="r-expr.block.inner-attributes"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.inner-attributes" title="expr.block.inner-attributes"><span>[expr<wbr>.block<wbr>.inner-attributes]<span/></a></div>
<p>블록의 구문은 <code>{</code>로 시작하여 내부 속성들(../attributes.md), 임의의 개수의 구문들(../statements.md), 마지막 피연산자라고 불리는 선택적 표현식, 그리고 마지막으로 <code>}</code>가 오는 형태입니다.</p>
<div class="rule" id="r-expr.block.statements"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.statements" title="expr.block.statements"><span>[expr<wbr>.block<wbr>.statements]<span/></a></div>
<p>구문 뒤에는 보통 세미콜론이 붙어야 하지만, 다음 두 가지 예외가 있습니다:</p>
<ol>
<li>아이템 선언 구문 뒤에는 세미콜론이 붙을 필요가 없습니다.</li>
<li>표현식 구문은 보통 뒤에 세미콜론이 필요하지만, 해당 구문의 외부 표현식이 흐름 제어 표현식인 경우는 제외합니다.</li>
</ol>
<div class="rule" id="r-expr.block.null-statement"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.null-statement" title="expr.block.null-statement"><span>[expr<wbr>.block<wbr>.null-statement]<span/></a></div>
<p>또한, 구문들 사이에 추가적인 세미콜론을 사용하는 것이 허용되지만, 이러한 세미콜론들은 시맨틱(의미론)에 영향을 주지 않습니다.</p>
<div class="rule" id="r-expr.block.evaluation"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.evaluation" title="expr.block.evaluation"><span>[expr<wbr>.block<wbr>.evaluation]<span/></a></div>
<p>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially.</p>
<div class="rule" id="r-expr.block.result"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.result" title="expr.block.result"><span>[expr<wbr>.block<wbr>.result]<span/></a></div>
<p>그 후, 마지막 피연산자가 주어진 경우 이를 실행합니다.</p>
<div class="rule" id="r-expr.block.type"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.type" title="expr.block.type"><span>[expr<wbr>.block<wbr>.type]<span/></a></div>
<p>블록의 타입은 마지막 피연산자의 타입이며, 마지막 피연산자가 생략된 경우 <code>()</code>입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn fn_call() {}
</span>let _: () = {
    fn_call();
};

let five: i32 = {
    fn_call();
    5
};

assert_eq!(5, five);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: 제어 흐름 표현식으로서, 블록 표현식이 표현식 구문의 외부 표현식인 경우, 뒤에 즉시 세미콜론이 오지 않는 한 기대되는 타입은 <code>()</code>입니다.</p>
</blockquote>
<div class="rule" id="r-expr.block.value"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.value" title="expr.block.value"><span>[expr<wbr>.block<wbr>.value]<span/></a></div>
<p>블록은 항상 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>이며, 마지막 피연산자를 값 표현식 컨텍스트에서 평가합니다.</p>
<blockquote>
<p><strong>참고</strong>: 이는 정말 필요한 경우 값을 강제로 이동(move)시키는 데 사용될 수 있습니다. 예를 들어, 다음 예제는 블록 표현식 내에서 구조체가 <code>s</code>로부터 이동되었기 때문에 <code>consume_self</code> 호출에서 실패합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;

impl Struct {
    fn consume_self(self) {}
    fn borrow_self(&amp;self) {}
}

fn move_by_block_expression() {
    let s = Struct;

    // 블록 표현식 내에서 `s`로부터 값을 이동시킵니다.
    (&amp;{ s }).borrow_self();

    // `s`가 이동되었으므로 실행에 실패합니다.
    s.consume_self();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-expr.block.async"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async" title="expr.block.async"><span>[expr<wbr>.block<wbr>.async]<span/></a></div>
<h2 id="async-블록"><a class="header" href="#async-블록"><code>async</code> 블록</a></h2>
<div class="rule" id="r-expr.block.async.syntax"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.syntax" title="expr.block.async.syntax"><span>[expr<wbr>.block<wbr>.async<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>비동기블록표현식</em> :<br />
   <code>async</code> <code>move</code><sup>?</sup> <em>블록표현식</em></p>
</blockquote>
<div class="rule" id="r-expr.block.async.intro"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.intro" title="expr.block.async.intro"><span>[expr<wbr>.block<wbr>.async<wbr>.intro]<span/></a></div>
<p>_비동기 블록(async block)_은 퓨처(future)로 평가되는 블록 표현식의 변형입니다.</p>
<div class="rule" id="r-expr.block.async.future-result"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.future-result" title="expr.block.async.future-result"><span>[expr<wbr>.block<wbr>.async<wbr>.future-result]<span/></a></div>
<p>블록의 마지막 표현식이 존재하는 경우, 퓨처의 결과 값을 결정합니다.</p>
<div class="rule" id="r-expr.block.async.anonymous-type"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.anonymous-type" title="expr.block.async.anonymous-type"><span>[expr<wbr>.block<wbr>.async<wbr>.anonymous-type]<span/></a></div>
<p>비동기 블록을 실행하는 것은 클로저 표현식을 실행하는 것과 유사합니다. 즉각적인 효과는 익명 타입을 생성하고 반환하는 것입니다.</p>
<div class="rule" id="r-expr.block.async.future"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.future" title="expr.block.async.future"><span>[expr<wbr>.block<wbr>.async<wbr>.future]<span/></a></div>
<p>클로저는 하나 이상의 <a href="expressions/../../core/ops/function/trait.Fn.html"><code>std::ops::Fn</code></a> 트레잇을 구현하는 타입을 반환하는 반면, 비동기 블록에 대해 반환되는 타입은 <a href="expressions/../../core/future/future/trait.Future.html"><code>std::future::Future</code></a> 트레잇을 구현합니다.</p>
<div class="rule" id="r-expr.block.async.layout-unspecified"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.layout-unspecified" title="expr.block.async.layout-unspecified"><span>[expr<wbr>.block<wbr>.async<wbr>.layout-unspecified]<span/></a></div>
<p>이 타입의 실제 데이터 형식은 지정되어 있지 않습니다.</p>
<blockquote>
<p><strong>참고:</strong> rustc가 생성하는 퓨처 타입은 각 <code>await</code> 지점마다 하나의 변형(variant)을 가진 열거형과 거의 동일하며, 각 변형은 해당 지점에서 재개하는 데 필요한 데이터를 저장합니다.</p>
</blockquote>
<blockquote>
<p><strong>에디션 차이</strong>: 비동기 블록은 러스트 2018부터만 사용할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-expr.block.async.capture"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.capture" title="expr.block.async.capture"><span>[expr<wbr>.block<wbr>.async<wbr>.capture]<span/></a></div>
<h3 id="캡처-모드"><a class="header" href="#캡처-모드">캡처 모드</a></h3>
<p>비동기 블록은 클로저와 동일한 <a href="expressions/../types/closure.html#capture-modes">캡처 모드</a>를 사용하여 환경으로부터 변수를 캡처합니다. 클로저와 마찬가지로, <code>async { .. }</code>라고 작성하면 각 변수에 대한 캡처 모드가 블록의 내용으로부터 추론됩니다. 반면 <code>async move { .. }</code> 블록은 참조된 모든 변수를 결과 퓨처로 이동(move)시킵니다.</p>
<div class="rule" id="r-expr.block.async.context"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.context" title="expr.block.async.context"><span>[expr<wbr>.block<wbr>.async<wbr>.context]<span/></a></div>
<h3 id="비동기-컨텍스트"><a class="header" href="#비동기-컨텍스트">비동기 컨텍스트</a></h3>
<p>비동기 블록은 퓨처를 생성하므로, 다시 <a href="expressions/await-expr.html"><code>await</code> 표현식</a>을 포함할 수 있는 **비동기 컨텍스트(async context)**를 정의합니다. 비동기 컨텍스트는 비동기 블록뿐만 아니라, 비동기 블록의 관점에서 시맨틱이 정의되는 비동기 함수의 본문에 의해 형성됩니다.</p>
<div class="rule" id="r-expr.block.async.function"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.function" title="expr.block.async.function"><span>[expr<wbr>.block<wbr>.async<wbr>.function]<span/></a></div>
<h3 id="제어-흐름-연산자"><a class="header" href="#제어-흐름-연산자">제어 흐름 연산자</a></h3>
<div class="rule" id="r-expr.block.async.function.intro"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.function.intro" title="expr.block.async.function.intro"><span>[expr<wbr>.block<wbr>.async<wbr>.function<wbr>.intro]<span/></a></div>
<p>비동기 블록은 클로저와 매우 비슷하게 함수의 경계처럼 작동합니다.</p>
<div class="rule" id="r-expr.block.async.function.return-try"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.function.return-try" title="expr.block.async.function.return-try"><span>[expr<wbr>.block<wbr>.async<wbr>.function<wbr>.return-try]<span/></a></div>
<p>따라서 <code>?</code> 연산자와 <code>return</code> 표현식은 모두 둘러싼 함수나 다른 컨텍스트가 아닌, 퓨처의 출력에 영향을 줍니다. 즉, 비동기 블록 내에서의 <code>return &lt;expr&gt;</code>은 <code>&lt;expr&gt;</code>의 결과를 퓨처의 출력으로 반환합니다. 마찬가지로, <code>&lt;expr&gt;?</code>가 에러를 전파하면, 해당 에러는 퓨처의 결과로서 전파됩니다.</p>
<div class="rule" id="r-expr.block.async.function.control-flow"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.async.function.control-flow" title="expr.block.async.function.control-flow"><span>[expr<wbr>.block<wbr>.async<wbr>.function<wbr>.control-flow]<span/></a></div>
<p>마지막으로, <code>break</code>와 <code>continue</code> 키워드는 비동기 블록 밖으로 분기하는 데 사용될 수 없습니다. 따라서 다음은 유효하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    async move {
        break; // error[E0267]: `async` 블록 내부의 `break`
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.block.const"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const" title="expr.block.const"><span>[expr<wbr>.block<wbr>.const]<span/></a></div>
<h2 id="const-블록"><a class="header" href="#const-블록"><code>const</code> 블록</a></h2>
<div class="rule" id="r-expr.block.const.syntax"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.syntax" title="expr.block.const.syntax"><span>[expr<wbr>.block<wbr>.const<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Const블록표현식</em> :<br />
   <code>const</code> <em>블록표현식</em></p>
</blockquote>
<div class="rule" id="r-expr.block.const.intro"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.intro" title="expr.block.const.intro"><span>[expr<wbr>.block<wbr>.const<wbr>.intro]<span/></a></div>
<p>_const 블록_은 본문이 런타임이 아닌 컴파일 타임에 평가되는 블록 표현식의 변형입니다.</p>
<div class="rule" id="r-expr.block.const.context"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.context" title="expr.block.const.context"><span>[expr<wbr>.block<wbr>.const<wbr>.context]<span/></a></div>
<p>const 블록을 사용하면 새로운 <a href="expressions/../items/constant-items.html">상수 아이템</a>을 정의할 필요 없이 상수 값을 정의할 수 있으며, 이러한 이유로 때때로 _인라인 상수(inline consts)_라고도 불립니다. 또한 타입 추론을 지원하므로 <a href="expressions/../items/constant-items.html">상수 아이템</a>과 달리 타입을 명시할 필요가 없습니다.</p>
<div class="rule" id="r-expr.block.const.generic-params"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.generic-params" title="expr.block.const.generic-params"><span>[expr<wbr>.block<wbr>.const<wbr>.generic-params]<span/></a></div>
<p>const 블록은 <a href="expressions/../glossary.html#free-item">자유(free)</a> 상수 아이템과 달리 스코프 내의 제네릭 매개변수를 참조할 수 있는 능력이 있습니다. 이들은 스코프 내의 제네릭 매개변수를 가진 상수 아이템으로 디슈거링(desugared)됩니다 (연관 상수와 유사하지만, 연관된 트레잇이나 타입이 없는 형태입니다). 예를 들어, 다음 코드는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    const { std::mem::size_of::&lt;T&gt;() + 1 }
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    {
        struct Const&lt;T&gt;(T);
        impl&lt;T&gt; Const&lt;T&gt; {
            const CONST: usize = std::mem::size_of::&lt;T&gt;() + 1;
        }
        Const::&lt;T&gt;::CONST
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.block.const.evaluation"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.evaluation" title="expr.block.const.evaluation"><span>[expr<wbr>.block<wbr>.const<wbr>.evaluation]<span/></a></div>
<p>const 블록 표현식이 런타임에 실행되면, 반환 값이 무시되더라도 해당 상수는 반드시 평가됨이 보장됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    // 이 코드가 실행된다면, 해당 어설션(assertion)은 분명히 컴파일 타임에
    // 평가된 것입니다.
    const { assert!(std::mem::size_of::&lt;T&gt;() &gt; 0); }
    // 여기서 타입이 0 크기가 아님에 의존하는 unsafe 코드를 가질 수 있습니다.
    /* ... */
    42
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.block.const.not-executed"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.const.not-executed" title="expr.block.const.not-executed"><span>[expr<wbr>.block<wbr>.const<wbr>.not-executed]<span/></a></div>
<p>const 블록 표현식이 런타임에 실행되지 않는 경우, 평가될 수도 있고 되지 않을 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if false {
    // 프로그램이 빌드될 때 패닉이 발생할 수도 있고 발생하지 않을 수도 있습니다.
    const { panic!(); }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.block.unsafe"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.unsafe" title="expr.block.unsafe"><span>[expr<wbr>.block<wbr>.unsafe]<span/></a></div>
<h2 id="unsafe-블록"><a class="header" href="#unsafe-블록"><code>unsafe</code> 블록</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Unsafe블록표현식</em> :<br />
   <code>unsafe</code> <em>블록표현식</em></p>
</blockquote>
<p><em><code>unsafe</code>를 언제 사용해야 하는지에 대한 자세한 내용은 <a href="expressions/../unsafe-keyword.html#unsafe-blocks-unsafe-"><code>unsafe</code> 블록</a>을 참조하세요.</em></p>
<p>코드 블록 앞에 <code>unsafe</code> 키워드를 붙여 <a href="expressions/../unsafety.html">안전하지 않은 연산(unsafe operations)</a>을 허용할 수 있습니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let b = [13u8, 17u8];
    let a = &amp;b[0] as *const u8;
    assert_eq!(*a, 13);
    assert_eq!(*a.offset(1), 17);
}

<span class="boring">unsafe fn an_unsafe_fn() -&gt; i32 { 10 }
</span>let a = unsafe { an_unsafe_fn() };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.block.label"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.label" title="expr.block.label"><span>[expr<wbr>.block<wbr>.label]<span/></a></div>
<h2 id="레이블이-붙은-블록-표현식"><a class="header" href="#레이블이-붙은-블록-표현식">레이블이 붙은 블록 표현식</a></h2>
<p>레이블이 붙은 블록 표현식은 <a href="expressions/loop-expr.html#labelled-block-expressions">루프 및 기타 중단 가능한 표현식</a> 섹션에 문서화되어 있습니다.</p>
<div class="rule" id="r-expr.block.attributes"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.attributes" title="expr.block.attributes"><span>[expr<wbr>.block<wbr>.attributes]<span/></a></div>
<h2 id="블록-표현식의-속성"><a class="header" href="#블록-표현식의-속성">블록 표현식의 속성</a></h2>
<div class="rule" id="r-expr.block.attributes.inner-attributes"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.attributes.inner-attributes" title="expr.block.attributes.inner-attributes"><span>[expr<wbr>.block<wbr>.attributes<wbr>.inner-attributes]<span/></a></div>
<p><a href="expressions/../attributes.html">내부 속성</a>은 다음 상황에서 블록 표현식의 여는 중괄호 바로 뒤에 허용됩니다.</p>
<ul>
<li><a href="expressions/../items/functions.html">함수</a> 및 <a href="expressions/../items/associated-items.html#methods">메서드</a> 본문.</li>
<li>루프 본문(<a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a>, <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>, 그리고 <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>).</li>
<li><a href="expressions/../statements.html">구문</a>으로 사용된 블록 표현식.</li>
<li><a href="expressions/array-expr.html">배열 표현식</a>, <a href="expressions/tuple-expr.html">튜플 표현식</a>, <a href="expressions/call-expr.html">호출 표현식</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체</a> 표현식의 요소로서의 블록 표현식.</li>
<li>다른 블록 표현식의 꼬리 표현식으로서의 블록 표현식.</li>
</ul>
<!-- Keep list in sync with expressions.md -->
<div class="rule" id="r-expr.block.attributes.valid"><a class="rule-link" href="expressions/block-expr.html#r-expr.block.attributes.valid" title="expr.block.attributes.valid"><span>[expr<wbr>.block<wbr>.attributes<wbr>.valid]<span/></a></div>
<p>블록 표현식에서 의미가 있는 속성은 <a href="expressions/../conditional-compilation.html"><code>cfg</code></a>와 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>입니다.</p>
<p>예를 들어, 이 함수는 유닉스 플랫폼에서는 <code>true</code>를 반환하고 다른 플랫폼에서는 <code>false</code>를 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_unix_platform() -&gt; bool {
    #[cfg(unix)] { true }
    #[cfg(not(unix))] { false }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.operator"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator" title="expr.operator"><span>[expr<wbr>.operator]<span/></a></div>
<h1 id="연산자-표현식"><a class="header" href="#연산자-표현식">연산자 표현식</a></h1>
<div class="rule" id="r-expr.operator.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.syntax" title="expr.operator.syntax"><span>[expr<wbr>.operator<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>연산자표현식</em> :<br />
      <a href="expressions/operator-expr.html#borrow-operators"><em>차용표현식</em></a><br />
   | <a href="expressions/operator-expr.html#the-dereference-operator"><em>역참조표현식</em></a><br />
   | <a href="expressions/operator-expr.html#the-question-mark-operator"><em>오류전파표현식</em></a><br />
   | <a href="expressions/operator-expr.html#negation-operators"><em>부정표현식</em></a><br />
   | <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>산술또는논리표현식</em></a><br />
   | <a href="expressions/operator-expr.html#comparison-operators"><em>비교표현식</em></a><br />
   | <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>지연불리언표현식</em></a><br />
   | <a href="expressions/operator-expr.html#type-cast-expressions"><em>타입캐스트표현식</em></a><br />
   | <a href="expressions/operator-expr.html#assignment-expressions"><em>할당표현식</em></a><br />
   | <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>복합할당표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.operator.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.intro" title="expr.operator.intro"><span>[expr<wbr>.operator<wbr>.intro]<span/></a></div>
<p>연산자는 러스트 언어에 의해 내장 타입에 대해 정의됩니다.</p>
<div class="rule" id="r-expr.operator.trait"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.trait" title="expr.operator.trait"><span>[expr<wbr>.operator<wbr>.trait]<span/></a></div>
<p>다음 연산자 중 다수는 <code>std::ops</code> 또는 <code>std::cmp</code>의 트레잇을 사용하여 오버로딩할 수도 있습니다.</p>
<div class="rule" id="r-expr.operator.int-overflow"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow" title="expr.operator.int-overflow"><span>[expr<wbr>.operator<wbr>.int-overflow]<span/></a></div>
<h2 id="오버플로"><a class="header" href="#오버플로">오버플로</a></h2>
<div class="rule" id="r-expr.operator.int-overflow.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow.intro" title="expr.operator.int-overflow.intro"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.intro]<span/></a></div>
<p>정수 연산자는 디버그 모드에서 컴파일될 때 오버플로가 발생하면 패닉을 일으킵니다. <code>-C debug-assertions</code> 및 <code>-C overflow-checks</code> 컴파일러 플래그를 사용하여 이를 더 직접적으로 제어할 수 있습니다. 다음 사항들은 오버플로로 간주됩니다:</p>
<div class="rule" id="r-expr.operator.int-overflow.binary-arith"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow.binary-arith" title="expr.operator.int-overflow.binary-arith"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.binary-arith]<span/></a></div>
<ul>
<li><code>+</code>, <code>*</code> 또는 이항 <code>-</code>가 저장할 수 있는 최대값보다 크거나 최소값보다 작은 값을 생성할 때.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.unary-neg"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow.unary-neg" title="expr.operator.int-overflow.unary-neg"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.unary-neg]<span/></a></div>
<ul>
<li>피연산자가 <a href="expressions/literal-expr.html#integer-literal-expressions">리터럴 표현식</a> (또는 하나 이상의 <a href="expressions/grouped-expr.html">그룹화된 표현식</a> 내에 단독으로 있는 리터럴 표현식)이 아닌 경우, 부호 있는 정수 타입의 가장 작은 음수 값에 단항 <code>-</code>를 적용할 때.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.div"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow.div" title="expr.operator.int-overflow.div"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.div]<span/></a></div>
<ul>
<li>왼쪽 인수가 부호 있는 정수 타입의 가장 작은 정수이고 오른쪽 인수가 <code>-1</code>인 경우 <code>/</code> 또는 <code>%</code> 사용. 이러한 검사는 레거시 이유로 <code>-C overflow-checks</code>가 비활성화된 경우에도 발생합니다.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.shift"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.int-overflow.shift" title="expr.operator.int-overflow.shift"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.shift]<span/></a></div>
<ul>
<li>오른쪽 인수가 왼쪽 인수 타입의 비트 수보다 크거나 같거나 음수인 경우 <code>&lt;&lt;</code> 또는 <code>&gt;&gt;</code> 사용.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 단항 <code>-</code> 뒤의 리터럴 표현식에 대한 예외는 <code>-128_i8</code> 또는 <code>let j: i8 = -(128)</code>과 같은 형식은 절대 패닉을 일으키지 않으며 예상 값 -128을 갖는다는 것을 의미합니다.</p>
<p>이러한 경우, <a href="expressions/literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>의 설명에 따라 정수 리터럴이 해당 타입으로 잘리기 때문에 리터럴 표현식은 이미 해당 타입에 대해 가장 작은 음수 값을 가집니다(예: <code>128_i8</code>은 값 -128을 가짐).</p>
<p>이러한 가장 작은 음수 값의 부정은 2의 보수 오버플로 규칙으로 인해 값이 변경되지 않고 그대로 유지됩니다.</p>
<p><code>rustc</code>에서 이러한 가장 작은 음수 표현식은 <code>overflowing_literals</code> 린트 검사에서도 무시됩니다.</p>
</blockquote>
<div class="rule" id="r-expr.operator.borrow"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow" title="expr.operator.borrow"><span>[expr<wbr>.operator<wbr>.borrow]<span/></a></div>
<h2 id="차용-연산자"><a class="header" href="#차용-연산자">차용 연산자</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>차용표현식</em> :<br />
      (<code>&amp;</code>|<code>&amp;&amp;</code>) <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>raw</code> <code>const</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>raw</code> <code>mut</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.operator.borrow.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow.intro" title="expr.operator.borrow.intro"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.intro]<span/></a></div>
<p><code>&amp;</code> (공유 차용) 및 <code>&amp;mut</code> (가변 차용) 연산자는 단항 접두사 연산자입니다.</p>
<div class="rule" id="r-expr.operator.borrow.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow.result" title="expr.operator.borrow.result"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.result]<span/></a></div>
<p><a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>에 적용될 때, 이 표현식은 값이 참조하는 위치에 대한 참조(포인터)를 생성합니다.</p>
<div class="rule" id="r-expr.operator.borrow.lifetime"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow.lifetime" title="expr.operator.borrow.lifetime"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.lifetime]<span/></a></div>
<p>메모리 위치는 또한 참조 기간 동안 차용 상태로 놓입니다. 공유 차용(<code>&amp;</code>)의 경우, 이는 장소를 변경할 수 없지만 읽거나 다시 공유할 수 있음을 의미합니다. 가변 차용(<code>&amp;mut</code>)의 경우, 차용이 만료될 때까지 어떤 방식으로도 장소에 접근할 수 없습니다.</p>
<div class="rule" id="r-expr.operator.borrow.mut"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow.mut" title="expr.operator.borrow.mut"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.mut]<span/></a></div>
<p><code>&amp;mut</code>은 피연산자를 가변 장소 표현식 컨텍스트에서 평가합니다.</p>
<div class="rule" id="r-expr.operator.borrow.temporary"><a class="rule-link" href="expressions/operator-expr.html#r-expr.operator.borrow.temporary" title="expr.operator.borrow.temporary"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.temporary]<span/></a></div>
<p><code>&amp;</code> 또는 <code>&amp;mut</code> 연산자가 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>에 적용되면 <a href="expressions/../expressions.html#temporaries">임시 값</a>이 생성됩니다.</p>
<p>이 연산자들은 오버로딩할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 이 스코프 동안 지속되는 값 7을 가진 임시 값이 생성됩니다.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // 이 스코프 동안 `array`를 가변적으로 차용합니다.
    // `array`는 `mutable_reference`를 통해서만 사용할 수 있습니다.
    let mutable_reference = &amp;mut array;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.borrow.and-and-syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.and-and-syntax" title="expr.borrow.and-and-syntax"><span>[expr<wbr>.borrow<wbr>.and-and-syntax]<span/></a></div>
<p><code>&amp;&amp;</code>가 단일 토큰(<a href="expressions/operator-expr.html#lazy-boolean-operators">지연 ‘and’ 연산자</a>)임에도 불구하고, 차용 표현식의 컨텍스트에서 사용될 때는 두 번의 차용으로 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 같은 의미:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// 같은 의미:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.borrow.raw"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.raw" title="expr.borrow.raw"><span>[expr<wbr>.borrow<wbr>.raw]<span/></a></div>
<h3 id="원시-차용-연산자"><a class="header" href="#원시-차용-연산자">원시 차용 연산자</a></h3>
<div class="rule" id="r-expr.borrow.raw.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.raw.intro" title="expr.borrow.raw.intro"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.intro]<span/></a></div>
<p><code>&amp;raw const</code>와 <code>&amp;raw mut</code>는 _원시 차용 연산자_입니다.</p>
<div class="rule" id="r-expr.borrow.raw.place"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.raw.place" title="expr.borrow.raw.place"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.place]<span/></a></div>
<p>이 연산자들의 피연산자 표현식은 장소 표현식 컨텍스트에서 평가됩니다.</p>
<div class="rule" id="r-expr.borrow.raw.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.raw.result" title="expr.borrow.raw.result"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.result]<span/></a></div>
<p><code>&amp;raw const expr</code>은 주어진 장소에 대한 <code>*const T</code> 타입의 상수 원시 포인터를 생성하고, <code>&amp;raw mut expr</code>은 <code>*mut T</code> 타입의 가변 원시 포인터를 생성합니다.</p>
<div class="rule" id="r-expr.borrow.raw.invalid-ref"><a class="rule-link" href="expressions/operator-expr.html#r-expr.borrow.raw.invalid-ref" title="expr.borrow.raw.invalid-ref"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.invalid-ref]<span/></a></div>
<p>장소 표현식이 적절하게 정렬되지 않은 장소로 평가되거나 해당 타입에 의해 결정된 유효한 값을 저장하지 않을 수 있는 경우, 또는 참조를 생성하면 잘못된 앨리어싱 가정이 도입되는 경우 항상 차용 연산자 대신 원시 차용 연산자를 사용해야 합니다. 이러한 상황에서 차용 연산자를 사용하면 잘못된 참조가 생성되어 <a href="expressions/../behavior-considered-undefined.html">정의되지 않은 동작</a>을 유발할 수 있지만, 원시 포인터는 여전히 생성될 수 있습니다.</p>
<p>다음은 <code>packed</code> 구조체를 통해 정렬되지 않은 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2`는 정렬되지 않은 참조를 생성하므로 정의되지 않은 동작이 됩니다!
let raw_f2 = &amp;raw const packed.f2;
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
<span class="boring">}</span></code></pre></pre>
<p>다음은 유효한 값을 포함하지 않는 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하므로,
// 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.deref"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref" title="expr.deref"><span>[expr<wbr>.deref]<span/></a></div>
<h2 id="역참조-연산자"><a class="header" href="#역참조-연산자">역참조 연산자</a></h2>
<div class="rule" id="r-expr.deref.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.syntax" title="expr.deref.syntax"><span>[expr<wbr>.deref<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>역참조표현식</em> :<br />
   <code>*</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.deref.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.intro" title="expr.deref.intro"><span>[expr<wbr>.deref<wbr>.intro]<span/></a></div>
<p><code>*</code> (역참조) 연산자는 또한 단항 접두사 연산자입니다.</p>
<div class="rule" id="r-expr.deref.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.result" title="expr.deref.result"><span>[expr<wbr>.deref<wbr>.result]<span/></a></div>
<p><a href="expressions/../types/pointer.html">포인터</a>에 적용될 때, 이는 가리키는 위치를 나타냅니다.</p>
<div class="rule" id="r-expr.deref.mut"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.mut" title="expr.deref.mut"><span>[expr<wbr>.deref<wbr>.mut]<span/></a></div>
<p>표현식이 <code>&amp;mut T</code> 또는 <code>*mut T</code> 타입이고, 지역 변수, 지역 변수의 (중첩된) 필드 또는 가변 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>인 경우, 결과 메모리 위치에 할당할 수 있습니다.</p>
<div class="rule" id="r-expr.deref.safety"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.safety" title="expr.deref.safety"><span>[expr<wbr>.deref<wbr>.safety]<span/></a></div>
<p>원시 포인터를 역참조하려면 <code>unsafe</code>가 필요합니다.</p>
<div class="rule" id="r-expr.deref.traits"><a class="rule-link" href="expressions/operator-expr.html#r-expr.deref.traits" title="expr.deref.traits"><span>[expr<wbr>.deref<wbr>.traits]<span/></a></div>
<p>비 포인터 타입에서 <code>*x</code>는 <a href="expressions/../expressions.html#mutability">불변 장소 표현식 컨텍스트</a>에서는 <code>*std::ops::Deref::deref(&amp;x)</code>와 동일하고, 가변 장소 표현식 컨텍스트에서는 <code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code>와 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try" title="expr.try"><span>[expr<wbr>.try]<span/></a></div>
<h2 id="물음표-연산자"><a class="header" href="#물음표-연산자">물음표 연산자</a></h2>
<div class="rule" id="r-expr.try.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.syntax" title="expr.try.syntax"><span>[expr<wbr>.try<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>오류전파표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>?</code></p>
</blockquote>
<div class="rule" id="r-expr.try.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.intro" title="expr.try.intro"><span>[expr<wbr>.try<wbr>.intro]<span/></a></div>
<p>물음표 연산자 (<code>?</code>)는 유효한 값을 풀거나(unwrap) 오류 값을 반환하여 호출 함수로 전파합니다.</p>
<div class="rule" id="r-expr.try.restricted-types"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.restricted-types" title="expr.try.restricted-types"><span>[expr<wbr>.try<wbr>.restricted-types]<span/></a></div>
<p>이것은 <code>Result&lt;T, E&gt;</code> 및 <code>Option&lt;T&gt;</code> 타입에만 적용할 수 있는 단항 후위 연산자입니다.</p>
<div class="rule" id="r-expr.try.behavior-std-result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.behavior-std-result" title="expr.try.behavior-std-result"><span>[expr<wbr>.try<wbr>.behavior-std-result]<span/></a></div>
<p><code>Result&lt;T, E&gt;</code> 타입의 값에 적용되면 오류를 전파합니다.</p>
<div class="rule" id="r-expr.try.effects-err"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.effects-err" title="expr.try.effects-err"><span>[expr<wbr>.try<wbr>.effects-err]<span/></a></div>
<p>값이 <code>Err(e)</code>이면, 둘러싼 함수나 클로저에서 <code>Err(From::from(e))</code>를 반환합니다.</p>
<div class="rule" id="r-expr.try.result-ok"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.result-ok" title="expr.try.result-ok"><span>[expr<wbr>.try<wbr>.result-ok]<span/></a></div>
<p><code>Ok(x)</code>에 적용되면 값을 풀어 <code>x</code>로 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = "123".parse()?; // x = 123
    let y: i32 = "24a".parse()?; // 즉시 Err()를 반환합니다
    Ok(x + y)                    // 실행되지 않습니다.
}

let res = try_to_parse();
println!("{:?}", res);
<span class="boring">assert!(res.is_err())
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try.behavior-std-option"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.behavior-std-option" title="expr.try.behavior-std-option"><span>[expr<wbr>.try<wbr>.behavior-std-option]<span/></a></div>
<p><code>Option&lt;T&gt;</code> 타입의 값에 적용되면 <code>None</code>을 전파합니다.</p>
<div class="rule" id="r-expr.try.effects-none"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.effects-none" title="expr.try.effects-none"><span>[expr<wbr>.try<wbr>.effects-none]<span/></a></div>
<p>값이 <code>None</code>이면 <code>None</code>을 반환합니다.</p>
<div class="rule" id="r-expr.try.result-some"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.result-some" title="expr.try.result-some"><span>[expr<wbr>.try<wbr>.result-some]<span/></a></div>
<p><code>Some(x)</code>에 적용되면 값을 풀어 <code>x</code>로 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try.trait"><a class="rule-link" href="expressions/operator-expr.html#r-expr.try.trait" title="expr.try.trait"><span>[expr<wbr>.try<wbr>.trait]<span/></a></div>
<p><code>?</code>는 오버로딩할 수 없습니다.</p>
<div class="rule" id="r-expr.negate"><a class="rule-link" href="expressions/operator-expr.html#r-expr.negate" title="expr.negate"><span>[expr<wbr>.negate]<span/></a></div>
<h2 id="부정-연산자"><a class="header" href="#부정-연산자">부정 연산자</a></h2>
<div class="rule" id="r-expr.negate.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.negate.syntax" title="expr.negate.syntax"><span>[expr<wbr>.negate<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>부정표현식</em> :<br />
      <code>-</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <code>!</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.negate.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.negate.intro" title="expr.negate.intro"><span>[expr<wbr>.negate<wbr>.intro]<span/></a></div>
<p>이것들은 마지막 두 단항 연산자입니다.</p>
<div class="rule" id="r-expr.negate.results"><a class="rule-link" href="expressions/operator-expr.html#r-expr.negate.results" title="expr.negate.results"><span>[expr<wbr>.negate<wbr>.results]<span/></a></div>
<p>이 표는 기본 타입에 대한 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식 컨텍스트</a>에서 평가되므로 이동하거나 복사됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>부정*</td><td></td><td>부정</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>비트 NOT</td><td><a href="expressions/../types/boolean.html#logical-not">논리적 NOT</a></td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
</div>
<ul>
<li>부호 있는 정수 타입에만 해당.</li>
</ul>
<p>다음은 이러한 연산자의 몇 가지 예입니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.arith-logic"><a class="rule-link" href="expressions/operator-expr.html#r-expr.arith-logic" title="expr.arith-logic"><span>[expr<wbr>.arith-logic]<span/></a></div>
<h2 id="산술-및-논리-이항-연산자"><a class="header" href="#산술-및-논리-이항-연산자">산술 및 논리 이항 연산자</a></h2>
<div class="rule" id="r-expr.arith-logic.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.arith-logic.syntax" title="expr.arith-logic.syntax"><span>[expr<wbr>.arith-logic<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>산술또는논리표현식</em> :<br />
      <a href="expressions/../expressions.html"><em>표현식</em></a> <code>+</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>-</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>*</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>/</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>%</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&amp;</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>|</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>^</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&lt;&lt;</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&gt;&gt;</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.arith-logic.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.arith-logic.intro" title="expr.arith-logic.intro"><span>[expr<wbr>.arith-logic<wbr>.intro]<span/></a></div>
<p>이항 연산자 표현식은 모두 중위 표기법으로 작성됩니다.</p>
<div class="rule" id="r-expr.arith-logic.behavior"><a class="rule-link" href="expressions/operator-expr.html#r-expr.arith-logic.behavior" title="expr.arith-logic.behavior"><span>[expr<wbr>.arith-logic<wbr>.behavior]<span/></a></div>
<p>이 표는 기본 타입에 대한 산술 및 논리 이항 연산자의 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식 컨텍스트</a>에서 평가되므로 이동하거나 복사됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th><th>복합 할당 트레잇 오버로딩</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>덧셈</td><td></td><td>덧셈</td><td><code>std::ops::Add</code></td><td><code>std::ops::AddAssign</code></td></tr>
<tr><td><code>-</code></td><td>뺄셈</td><td></td><td>뺄셈</td><td><code>std::ops::Sub</code></td><td><code>std::ops::SubAssign</code></td></tr>
<tr><td><code>*</code></td><td>곱셈</td><td></td><td>곱셈</td><td><code>std::ops::Mul</code></td><td><code>std::ops::MulAssign</code></td></tr>
<tr><td><code>/</code></td><td>나눗셈*†</td><td></td><td>나눗셈</td><td><code>std::ops::Div</code></td><td><code>std::ops::DivAssign</code></td></tr>
<tr><td><code>%</code></td><td>나머지**†</td><td></td><td>나머지</td><td><code>std::ops::Rem</code></td><td><code>std::ops::RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td>비트 AND</td><td><a href="expressions/../types/boolean.html#logical-and">논리적 AND</a></td><td></td><td><code>std::ops::BitAnd</code></td><td><code>std::ops::BitAndAssign</code></td></tr>
<tr><td><code>|</code></td><td>비트 OR</td><td><a href="expressions/../types/boolean.html#logical-or">논리적 OR</a></td><td></td><td><code>std::ops::BitOr</code></td><td><code>std::ops::BitOrAssign</code></td></tr>
<tr><td><code>^</code></td><td>비트 XOR</td><td><a href="expressions/../types/boolean.html#logical-xor">논리적 XOR</a></td><td></td><td><code>std::ops::BitXor</code></td><td><code>std::ops::BitXorAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>왼쪽 시프트</td><td></td><td></td><td><code>std::ops::Shl</code></td><td><code>std::ops::ShlAssign</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>오른쪽 시프트***</td><td></td><td></td><td><code>std::ops::Shr</code></td><td><code>std::ops::ShrAssign</code></td></tr>
</tbody></table>
</div>
<ul>
<li>정수 나눗셈은 0을 향해 반올림합니다.</li>
</ul>
<p>** Rust는 <a href="https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition">절단 나눗셈</a>으로 정의된 나머지를 사용합니다. <code>remainder = dividend % divisor</code>라고 할 때, 나머지는 피제수(dividend)와 같은 부호를 가집니다.</p>
<p>*** 부호 있는 정수 타입에서는 산술 오른쪽 시프트, 부호 없는 정수 타입에서는 논리 오른쪽 시프트입니다.</p>
<p>† 정수 타입의 경우, 0으로 나누면 패닉이 발생합니다.</p>
<p>다음은 이러한 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.cmp"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp" title="expr.cmp"><span>[expr<wbr>.cmp]<span/></a></div>
<h2 id="비교-연산자"><a class="header" href="#비교-연산자">비교 연산자</a></h2>
<div class="rule" id="r-expr.cmp.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.syntax" title="expr.cmp.syntax"><span>[expr<wbr>.cmp<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>비교표현식</em> :<br />
      <a href="expressions/../expressions.html"><em>표현식</em></a> <code>==</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>!=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&gt;</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&lt;</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&gt;=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&lt;=</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.cmp.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.intro" title="expr.cmp.intro"><span>[expr<wbr>.cmp<wbr>.intro]<span/></a></div>
<p>비교 연산자는 기본 타입과 표준 라이브러리의 많은 타입에 대해 정의되어 있습니다.</p>
<div class="rule" id="r-expr.cmp.paren-chaining"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.paren-chaining" title="expr.cmp.paren-chaining"><span>[expr<wbr>.cmp<wbr>.paren-chaining]<span/></a></div>
<p>비교 연산자를 연결할 때는 괄호가 필요합니다. 예를 들어, 표현식 <code>a == b == c</code>는 유효하지 않으며 <code>(a == b) == c</code>로 작성해야 합니다.</p>
<div class="rule" id="r-expr.cmp.trait"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.trait" title="expr.cmp.trait"><span>[expr<wbr>.cmp<wbr>.trait]<span/></a></div>
<p>산술 및 논리 연산자와 달리, 이 연산자를 오버로딩하는 트레잇은 타입이 비교되는 방식을 보여주는 데 더 일반적으로 사용되며, 이러한 트레잇을 바운드로 사용하는 함수에 의해 실제 비교를 정의한다고 가정될 가능성이 높습니다. 표준 라이브러리의 많은 함수와 매크로는 이러한 가정을 사용할 수 있습니다(안전성을 보장하기 위한 것은 아니지만).</p>
<div class="rule" id="r-expr.cmp.place"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.place" title="expr.cmp.place"><span>[expr<wbr>.cmp<wbr>.place]<span/></a></div>
<p>위의 산술 및 논리 연산자와 달리, 이 연산자들은 암시적으로 피연산자의 공유 차용을 취하여 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식 컨텍스트</a>에서 평가합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// 다음과 동일합니다
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}</span></code></pre></pre>
<p>이는 피연산자를 밖으로 이동시킬 필요가 없음을 의미합니다.</p>
<div class="rule" id="r-expr.cmp.behavior"><a class="rule-link" href="expressions/operator-expr.html#r-expr.cmp.behavior" title="expr.cmp.behavior"><span>[expr<wbr>.cmp<wbr>.behavior]<span/></a></div>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>의미</th><th>오버로딩 메서드</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>같음</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>같지 않음</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>보다 큼</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>보다 작음</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>보다 크거나 같음</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>보다 작거나 같음</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
</div>
<p>다음은 비교 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!("World" &gt;= "Hello");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.bool-logic"><a class="rule-link" href="expressions/operator-expr.html#r-expr.bool-logic" title="expr.bool-logic"><span>[expr<wbr>.bool-logic]<span/></a></div>
<h2 id="지연-불리언-연산자"><a class="header" href="#지연-불리언-연산자">지연 불리언 연산자</a></h2>
<div class="rule" id="r-expr.bool-logic.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.bool-logic.syntax" title="expr.bool-logic.syntax"><span>[expr<wbr>.bool-logic<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>지연불리언표현식</em> :<br />
      <a href="expressions/../expressions.html"><em>표현식</em></a> <code>||</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&amp;&amp;</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.bool-logic.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.bool-logic.intro" title="expr.bool-logic.intro"><span>[expr<wbr>.bool-logic<wbr>.intro]<span/></a></div>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The <code>||</code> operator denotes logical ‘or’, and the <code>&amp;&amp;</code> operator denotes logical ‘and’.</p>
<div class="rule" id="r-expr.bool-logic.conditional-evaluation"><a class="rule-link" href="expressions/operator-expr.html#r-expr.bool-logic.conditional-evaluation" title="expr.bool-logic.conditional-evaluation"><span>[expr<wbr>.bool-logic<wbr>.conditional-evaluation]<span/></a></div>
<p>이들은 <code>|</code> 및 <code>&amp;</code>와 달리, 왼쪽 피연산자가 표현식의 결과를 이미 결정하지 않은 경우에만 오른쪽 피연산자가 평가된다는 점에서 다릅니다. 즉, <code>||</code>는 왼쪽 피연산자가 <code>false</code>로 평가될 때만 오른쪽 피연산자를 평가하고, <code>&amp;&amp;</code>는 <code>true</code>로 평가될 때만 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = false || true; // 참(true)
let y = false &amp;&amp; panic!(); // 거짓(false), `panic!()`을 평가하지 않음
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as" title="expr.as"><span>[expr<wbr>.as]<span/></a></div>
<h2 id="타입-캐스트-표현식"><a class="header" href="#타입-캐스트-표현식">타입 캐스트 표현식</a></h2>
<div class="rule" id="r-expr.as.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.syntax" title="expr.as.syntax"><span>[expr<wbr>.as<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>타입캐스트표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>as</code> <a href="expressions/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
</blockquote>
<div class="rule" id="r-expr.as.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.intro" title="expr.as.intro"><span>[expr<wbr>.as<wbr>.intro]<span/></a></div>
<p>타입 캐스트 표현식은 이항 연산자 <code>as</code>로 표시됩니다.</p>
<div class="rule" id="r-expr.as.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.result" title="expr.as.result"><span>[expr<wbr>.as<wbr>.result]<span/></a></div>
<p><code>as</code> 표현식을 실행하면 왼쪽의 값이 오른쪽의 타입으로 캐스팅됩니다.</p>
<p><code>as</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.coercions"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.coercions" title="expr.as.coercions"><span>[expr<wbr>.as<wbr>.coercions]<span/></a></div>
<p><code>as</code>는 <a href="expressions/../type-coercions.html">강제 변환</a>을 명시적으로 수행하는 데 사용될 수 있으며, 다음의 추가 캐스트에도 사용됩니다. 강제 변환 규칙이나 표의 항목에 맞지 않는 캐스트는 컴파일러 오류입니다. 여기서 <code>*T</code>는 <code>*const T</code> 또는 <code>*mut T</code>를 의미합니다. <code>m</code>은 참조 타입에서 선택적 <code>mut</code>를 나타내고, 포인터 타입에서는 <code>mut</code> 또는 <code>const</code>를 나타냅니다.</p>
<div class="table-wrapper"><table><thead><tr><th><code>e</code>의 타입</th><th><code>U</code></th><th><code>e as U</code>에 의해 수행되는 캐스트</th></tr></thead><tbody>
<tr><td>정수 또는 부동 소수점 타입</td><td>정수 또는 부동 소수점 타입</td><td><a href="expressions/operator-expr.html#r-expr.as.numeric">숫자 캐스트</a></td></tr>
<tr><td>열거형</td><td>정수 타입</td><td><a href="expressions/operator-expr.html#r-expr.as.enum">열거형 캐스트</a></td></tr>
<tr><td><code>bool</code> 또는 <code>char</code></td><td>정수 타입</td><td><a href="expressions/operator-expr.html#r-expr.as.bool-char-as-int">기본 타입에서 정수로의 캐스트</a></td></tr>
<tr><td><code>u8</code></td><td><code>char</code></td><td><a href="expressions/operator-expr.html#r-expr.as.u8-as-char"><code>u8</code>에서 <code>char</code>로의 캐스트</a></td></tr>
<tr><td><code>*T</code></td><td><code>*V</code> <sup class="footnote-reference"><a href="#meta-compat">1</a></sup></td><td><a href="expressions/operator-expr.html#r-expr.as.pointer">포인터에서 포인터로의 캐스트</a></td></tr>
<tr><td><code>*T</code> (여기서 <code>T: Sized</code>)</td><td>정수 타입</td><td><a href="expressions/operator-expr.html#r-expr.as.pointer-as-int">포인터에서 주소로의 캐스트</a></td></tr>
<tr><td>정수 타입</td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td><a href="expressions/operator-expr.html#r-expr.as.int-as-pointer">주소에서 포인터로의 캐스트</a></td></tr>
<tr><td><code>&amp;m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><code>*m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td>함수 아이템에서 함수 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 아이템에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td>정수</td><td>함수 아이템에서 주소로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 포인터에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td>정수</td><td>함수 포인터에서 주소로의 캐스트</td></tr>
<tr><td>클로저 <sup class="footnote-reference"><a href="#no-capture">3</a></sup></td><td>함수 포인터</td><td>클로저에서 함수 포인터로의 캐스트</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="meta-compat"><sup class="footnote-definition-label">1</sup>
<p><code>T</code>와 <code>V</code>가 호환되는 메타데이터를 갖는 경우: * <code>V: Sized</code>이거나, * 둘 다 슬라이스 메타데이터(<code>*[u16]</code> -&gt; <code>*[u8]</code>, <code>*str</code> -&gt; <code>*(u8, [u32])</code>)이거나, * 둘 다 동일한 트레잇 객체 메타데이터(자동 트레잇 제거 제외) (<code>*dyn Debug</code> -&gt; <code>*(u16, dyn Debug)</code>, <code>*dyn Debug + Send</code> -&gt; <code>*dyn Debug</code>) * <strong>참고</strong>: 자동 트레잇 _추가_는 주 트레잇이 해당 자동 트레잇을 슈퍼 트레잇으로 갖는 경우에만 허용됩니다(<code>trait T: Send {}</code>가 주어졌을 때, <code>*dyn T</code> -&gt; <code>*dyn T + Send</code>는 유효하지만 <code>*dyn Debug</code> -&gt; <code>*dyn Debug + Send</code>는 유효하지 않음) * <strong>참고</strong>: 제네릭(라이프타임 포함)은 일치해야 합니다(<code>*dyn T&lt;'a, A&gt;</code> -&gt; <code>*dyn T&lt;'b, B&gt;</code>는 <code>'a = 'b</code> 및 <code>A = B</code>를 요구함)</p>
</div>
<div class="footnote-definition" id="lessmut"><sup class="footnote-definition-label">2</sup>
<p><code>m₁</code>이 <code>mut</code>이거나 <code>m₂</code>가 <code>const</code>인 경우에만 해당합니다. <code>mut</code> 참조/포인터를 <code>const</code> 포인터로 캐스팅하는 것은 허용됩니다.</p>
</div>
<div class="footnote-definition" id="no-capture"><sup class="footnote-definition-label">3</sup>
<p>지역 변수를 캡처(close over)하지 않는 클로저만 함수 포인터로 캐스팅될 수 있습니다.</p>
</div>
<h3 id="의미론"><a class="header" href="#의미론">의미론</a></h3>
<div class="rule" id="r-expr.as.numeric"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric" title="expr.as.numeric"><span>[expr<wbr>.as<wbr>.numeric]<span/></a></div>
<h4 id="숫자-캐스트"><a class="header" href="#숫자-캐스트">숫자 캐스트</a></h4>
<div class="rule" id="r-expr.as.numeric.int-same-size"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.int-same-size" title="expr.as.numeric.int-same-size"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-same-size]<span/></a></div>
<ul>
<li>
<p>같은 크기의 두 정수 간 캐스팅(예: i32 -&gt; u32)은 무연산(no-op)입니다(러스트는 고정 정수의 음수 값에 2의 보수를 사용합니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as u8, 42u8);
assert_eq!(-1i8 as u8, 255u8);
assert_eq!(255u8 as i8, -1i8);
assert_eq!(-1i16 as u16, 65535u16);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-truncation"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.int-truncation" title="expr.as.numeric.int-truncation"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-truncation]<span/></a></div>
<ul>
<li>
<p>더 큰 정수에서 더 작은 정수로의 캐스팅(예: u32 -&gt; u8)은 잘라냅니다(truncate).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42u16 as u8, 42u8);
assert_eq!(1234u16 as u8, 210u8);
assert_eq!(0xabcdu16 as u8, 0xcdu8);

assert_eq!(-42i16 as i8, -42i8);
assert_eq!(1234u16 as i8, -46i8);
assert_eq!(0xabcdi32 as i8, -51i8);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-extension"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.int-extension" title="expr.as.numeric.int-extension"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-extension]<span/></a></div>
<ul>
<li>
<p>더 작은 정수에서 더 큰 정수로의 캐스팅(예: u8 -&gt; u32)은 다음과 같습니다.</p>
<ul>
<li>소스가 부호 없으면 0으로 확장(zero-extend)</li>
<li>소스가 부호 있으면 부호 확장(sign-extend)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as i16, 42i16);
assert_eq!(-17i8 as i16, -17i16);
assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, "0으로 확장");
assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, "부호 확장 0");
assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, "부호 확장 1");
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-as-int"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.float-as-int" title="expr.as.numeric.float-as-int"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-as-int]<span/></a></div>
<ul>
<li>
<p>부동 소수점에서 정수로의 캐스팅은 부동 소수점을 0을 향해 반올림합니다.</p>
<ul>
<li><code>NaN</code>은 <code>0</code>을 반환합니다.</li>
<li><code>INFINITY</code>를 포함하여 최대 정수 값보다 큰 값은 정수 타입의 최대 값으로 포화(saturate)됩니다.</li>
<li><code>NEG_INFINITY</code>를 포함하여 최소 정수 값보다 작은 값은 정수 타입의 최소 값으로 포화(saturate)됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42.9f32 as i32, 42);
assert_eq!(-42.9f32 as i32, -42);
assert_eq!(42_000_000f32 as i32, 42_000_000);
assert_eq!(std::f32::NAN as i32, 0);
assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);
assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-as-float"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.int-as-float" title="expr.as.numeric.int-as-float"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-as-float]<span/></a></div>
<ul>
<li>
<p>정수에서 부동 소수점으로의 캐스팅은 가능한 가장 가까운 부동 소수점을 생성합니다 *</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
<li>참고: 현재 숫자 타입 세트에서는 <code>f32::MAX + (0.5 ULP)</code>보다 크거나 같은 값에 대해 <code>u128 as f32</code>에서만 오버플로가 발생할 수 있습니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1337i32 as f32, 1337f32);
assert_eq!(123_456_789i32 as f32, 123_456_790f32, "반올림됨");
assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-widening"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.float-widening" title="expr.as.numeric.float-widening"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-widening]<span/></a></div>
<ul>
<li>
<p>f32에서 f64로의 캐스팅은 완벽하며 손실이 없습니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f32 as f64, 1_234.5f64);
assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);
assert!((std::f32::NAN as f64).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-narrowing"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.numeric.float-narrowing" title="expr.as.numeric.float-narrowing"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-narrowing]<span/></a></div>
<ul>
<li>
<p>f64에서 f32로의 캐스팅은 가능한 가장 가까운 f32를 생성합니다 **</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f64 as f32, 1_234.5f32);
assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, "반올림됨");
assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);
assert!((std::f64::NAN as f32).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>* 이 반올림 모드와 오버플로 동작을 사용하는 정수-부동 소수점 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>** 이 반올림 모드와 오버플로 동작을 사용하는 f64-f32 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>*** IEEE 754-2008 §4.3.1에 정의된 대로: 가장 가까운 부동 소수점 숫자를 선택하고, 두 부동 소수점 숫자 사이의 정확히 중간인 경우 최하위 자릿수가 짝수인 것을 선호합니다.</p>
<div class="rule" id="r-expr.as.enum"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.enum" title="expr.as.enum"><span>[expr<wbr>.as<wbr>.enum]<span/></a></div>
<h4 id="열거형-캐스트"><a class="header" href="#열거형-캐스트">열거형 캐스트</a></h4>
<div class="rule" id="r-expr.as.enum.discriminant"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.enum.discriminant" title="expr.as.enum.discriminant"><span>[expr<wbr>.as<wbr>.enum<wbr>.discriminant]<span/></a></div>
<p>열거형을 판별자(discriminant)로 캐스팅한 다음 필요한 경우 숫자 캐스트를 사용합니다. 캐스팅은 다음 종류의 열거형으로 제한됩니다:</p>
<ul>
<li><a href="expressions/../items/enumerations.html#unit-only-enum">유닛 전용 열거형</a></li>
<li><a href="expressions/../items/enumerations.html#explicit-discriminants">명시적 판별자</a>가 없는 <a href="expressions/../items/enumerations.html#field-less-enum">필드 없는 열거형</a>, 또는 유닛 변형만 명시적 판별자를 갖는 경우</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum { A, B, C }
assert_eq!(Enum::A as i32, 0);
assert_eq!(Enum::B as i32, 1);
assert_eq!(Enum::C as i32, 2);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.enum.no-drop"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.enum.no-drop" title="expr.as.enum.no-drop"><span>[expr<wbr>.as<wbr>.enum<wbr>.no-drop]<span/></a></div>
<p>열거형이 <a href="expressions/../../core/ops/drop/trait.Drop.html"><code>Drop</code></a>을 구현하는 경우 캐스팅이 허용되지 않습니다.</p>
<div class="rule" id="r-expr.as.bool-char-as-int"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.bool-char-as-int" title="expr.as.bool-char-as-int"><span>[expr<wbr>.as<wbr>.bool-char-as-int]<span/></a></div>
<h4 id="기본-타입에서-정수로의-캐스트"><a class="header" href="#기본-타입에서-정수로의-캐스트">기본 타입에서 정수로의 캐스트</a></h4>
<ul>
<li><code>false</code>는 <code>0</code>으로, <code>true</code>는 <code>1</code>로 캐스팅됩니다</li>
<li><code>char</code>는 코드 포인트 값으로 캐스팅된 다음 필요한 경우 숫자 캐스트를 사용합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
assert_eq!('A' as i32, 65);
assert_eq!('Ö' as i32, 214);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.u8-as-char"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.u8-as-char" title="expr.as.u8-as-char"><span>[expr<wbr>.as<wbr>.u8-as-char]<span/></a></div>
<h4 id="u8에서-char로의-캐스트"><a class="header" href="#u8에서-char로의-캐스트"><code>u8</code>에서 <code>char</code>로의 캐스트</a></h4>
<p>해당 코드 포인트를 가진 <code>char</code>로 캐스팅합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(65u8 as char, 'A');
assert_eq!(214u8 as char, 'Ö');
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.pointer-as-int"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer-as-int" title="expr.as.pointer-as-int"><span>[expr<wbr>.as<wbr>.pointer-as-int]<span/></a></div>
<h4 id="포인터에서-주소로의-캐스트"><a class="header" href="#포인터에서-주소로의-캐스트">포인터에서 주소로의 캐스트</a></h4>
<p>원시 포인터에서 정수로의 캐스팅은 참조된 메모리의 기계 주소를 생성합니다. 정수 타입이 포인터 타입보다 작은 경우 주소가 잘릴 수 있습니다. <code>usize</code>를 사용하면 이를 방지할 수 있습니다.</p>
<div class="rule" id="r-expr.as.int-as-pointer"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.int-as-pointer" title="expr.as.int-as-pointer"><span>[expr<wbr>.as<wbr>.int-as-pointer]<span/></a></div>
<h4 id="주소에서-포인터로의-캐스트"><a class="header" href="#주소에서-포인터로의-캐스트">주소에서 포인터로의 캐스트</a></h4>
<p>정수에서 원시 포인터로의 캐스팅은 정수를 메모리 주소로 해석하고 해당 메모리를 참조하는 포인터를 생성합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 이것은 아직 개발 중인 러스트 메모리 모델과 상호 작용합니다. 이 캐스트에서 얻은 포인터는 유효한 포인터와 비트 단위로 동일하더라도 추가적인 제한을 받을 수 있습니다. 이러한 포인터를 역참조하는 것은 앨리어싱 규칙을 따르지 않을 경우 <a href="expressions/../behavior-considered-undefined.html">정의되지 않은 동작</a>이 될 수 있습니다.</p>
</blockquote>
</div>
<p>건전한 주소 연산의 간단한 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize;
let second_address = first_address + 4; // 4 == size_of::&lt;i32&gt;()
let p2 = second_address as *mut i32;
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.pointer"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer" title="expr.as.pointer"><span>[expr<wbr>.as<wbr>.pointer]<span/></a></div>
<h4 id="포인터에서-포인터로의-캐스트"><a class="header" href="#포인터에서-포인터로의-캐스트">포인터에서 포인터로의 캐스트</a></h4>
<div class="rule" id="r-expr.as.pointer.behavior"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer.behavior" title="expr.as.pointer.behavior"><span>[expr<wbr>.as<wbr>.pointer<wbr>.behavior]<span/></a></div>
<p><code>*const T</code> / <code>*mut T</code>는 다음과 같은 동작으로 <code>*const U</code> / <code>*mut U</code>로 캐스팅될 수 있습니다:</p>
<div class="rule" id="r-expr.as.pointer.sized"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer.sized" title="expr.as.pointer.sized"><span>[expr<wbr>.as<wbr>.pointer<wbr>.sized]<span/></a></div>
<ul>
<li><code>T</code>와 <code>U</code>가 모두 크기가 있는(sized) 경우, 포인터는 변경되지 않고 반환됩니다.</li>
</ul>
<div class="rule" id="r-expr.as.pointer.unsized"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer.unsized" title="expr.as.pointer.unsized"><span>[expr<wbr>.as<wbr>.pointer<wbr>.unsized]<span/></a></div>
<ul>
<li>
<p><code>T</code>와 <code>U</code>가 모두 크기가 없는(unsized) 경우, 포인터도 변경되지 않고 반환됩니다. 특히 메타데이터는 정확하게 보존됩니다.</p>
<p>예를 들어, <code>*const [T]</code>에서 <code>*const [U]</code>로의 캐스트는 요소 수를 보존합니다. 결과적으로 이러한 캐스트는 포인터가 참조하는 대상의 크기를 반드시 보존하지는 않는다는 점에 유의하십시오(예: <code>*const [u16]</code>을 <code>*const [u8]</code>로 캐스팅하면 원본 크기의 절반인 객체를 참조하는 원시 포인터가 됩니다). <code>str</code> 및 <code>struct Foo(i32, [u8])</code> 또는 <code>(u64, Foo)</code>와 같이 크기가 없는 꼬리가 슬라이스 타입인 복합 타입에도 동일하게 적용됩니다.</p>
</li>
</ul>
<div class="rule" id="r-expr.as.pointer.discard-metadata"><a class="rule-link" href="expressions/operator-expr.html#r-expr.as.pointer.discard-metadata" title="expr.as.pointer.discard-metadata"><span>[expr<wbr>.as<wbr>.pointer<wbr>.discard-metadata]<span/></a></div>
<ul>
<li><code>T</code>는 크기가 없고 <code>U</code>는 크기가 있는 경우, 캐스트는 넓은 포인터(wide pointer) <code>T</code>를 완성하는 모든 메타데이터를 버리고 크기가 없는 포인터의 데이터 부분으로 구성된 얇은 포인터(thin pointer) <code>U</code>를 생성합니다.</li>
</ul>
<div class="rule" id="r-expr.assign"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign" title="expr.assign"><span>[expr<wbr>.assign]<span/></a></div>
<h2 id="할당-표현식"><a class="header" href="#할당-표현식">할당 표현식</a></h2>
<div class="rule" id="r-expr.assign.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.syntax" title="expr.assign.syntax"><span>[expr<wbr>.assign<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>할당표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>=</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.assign.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.intro" title="expr.assign.intro"><span>[expr<wbr>.assign<wbr>.intro]<span/></a></div>
<p>_할당 표현식_은 값을 지정된 장소로 이동합니다.</p>
<div class="rule" id="r-expr.assign.assignee"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.assignee" title="expr.assign.assignee"><span>[expr<wbr>.assign<wbr>.assignee]<span/></a></div>
<p>할당 표현식은 <a href="expressions/../expressions.html#mutability">가변</a> <a href="expressions/../expressions.html#place-expressions-and-value-expressions">피할당자 표현식</a>(<em>피할당자 피연산자</em>)과 그 뒤에 오는 등호(<code>=</code>), 그리고 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>할당된 값 피연산자</em>)으로 구성됩니다.</p>
<div class="rule" id="r-expr.assign.behavior-basic"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.behavior-basic" title="expr.assign.behavior-basic"><span>[expr<wbr>.assign<wbr>.behavior-basic]<span/></a></div>
<p>가장 기본적인 형태에서, 피할당자 표현식은 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>이며, 이 경우를 먼저 논의합니다.</p>
<div class="rule" id="r-expr.assign.behavior-destructring"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.behavior-destructring" title="expr.assign.behavior-destructring"><span>[expr<wbr>.assign<wbr>.behavior-destructring]<span/></a></div>
<p>더 일반적인 구조 분해 할당의 경우는 아래에서 논의되지만, 이 경우는 항상 장소 표현식에 대한 순차적인 할당으로 분해되므로, 장소 표현식 할당이 더 근본적인 경우로 간주될 수 있습니다.</p>
<div class="rule" id="r-expr.assign.basic"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.basic" title="expr.assign.basic"><span>[expr<wbr>.assign<wbr>.basic]<span/></a></div>
<h3 id="기본-할당"><a class="header" href="#기본-할당">기본 할당</a></h3>
<div class="rule" id="r-expr.assign.evaluation-order"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.evaluation-order" title="expr.assign.evaluation-order"><span>[expr<wbr>.assign<wbr>.evaluation-order]<span/></a></div>
<p>할당 표현식의 평가는 피연산자의 평가로 시작됩니다. 할당된 값 피연산자가 먼저 평가되고, 그 다음에 피할당자 표현식이 평가됩니다.</p>
<div class="rule" id="r-expr.assign.destructring-order"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructring-order" title="expr.assign.destructring-order"><span>[expr<wbr>.assign<wbr>.destructring-order]<span/></a></div>
<p>구조 분해 할당의 경우, 피할당자 표현식의 하위 표현식은 왼쪽에서 오른쪽으로 평가됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 이것은 오른쪽 피연산자가 왼쪽 피연산자보다 먼저 평가된다는 점에서 다른 표현식과 다릅니다.</p>
</blockquote>
<div class="rule" id="r-expr.assign.drop-target"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.drop-target" title="expr.assign.drop-target"><span>[expr<wbr>.assign<wbr>.drop-target]<span/></a></div>
<p>그런 다음 할당된 장소의 값이 초기화되지 않은 지역 변수나 초기화되지 않은 지역 변수의 필드가 아닌 경우, 할당된 장소의 값을 먼저 <a href="expressions/../destructors.html">드랍</a>하는 효과를 가집니다.</p>
<div class="rule" id="r-expr.assign.behavior"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.behavior" title="expr.assign.behavior"><span>[expr<wbr>.assign<wbr>.behavior]<span/></a></div>
<p>그 다음 할당된 값을 할당된 장소로 <a href="expressions/../expressions.html#moved-and-copied-types">복사하거나 이동</a>합니다.</p>
<div class="rule" id="r-expr.assign.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.result" title="expr.assign.result"><span>[expr<wbr>.assign<wbr>.result]<span/></a></div>
<p>할당 표현식은 항상 <a href="expressions/../types/tuple.html">유닛 값</a>을 생성합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
let y = 0;
x = y;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure" title="expr.assign.destructure"><span>[expr<wbr>.assign<wbr>.destructure]<span/></a></div>
<h3 id="구조-분해-할당"><a class="header" href="#구조-분해-할당">구조 분해 할당</a></h3>
<div class="rule" id="r-expr.assign.destructure.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.intro" title="expr.assign.destructure.intro"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.intro]<span/></a></div>
<p>구조 분해 할당은 변수 선언을 위한 구조 분해 패턴 매칭의 대응으로, 튜플이나 구조체와 같은 복합 값에 대한 할당을 허용합니다. 예를 들어, 두 개의 가변 변수를 교환할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (0, 1);
// 구조 분해 할당을 사용하여 `a`와 `b`를 교환합니다.
(b, a) = (a, b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure.assignee"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.assignee" title="expr.assign.destructure.assignee"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.assignee]<span/></a></div>
<p><code>let</code>을 사용한 구조 분해 선언과 달리, 구문상의 모호성 때문에 패턴은 할당의 왼쪽에 나타날 수 없습니다. 대신 패턴에 해당하는 표현식 그룹이 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">피할당자 표현식</a>으로 지정되어 할당의 왼쪽에 허용됩니다. 피할당자 표현식은 그런 다음 패턴 매칭과 순차적 할당으로 탈설탕(desugared)됩니다.</p>
<div class="rule" id="r-expr.assign.destructure.irrefutable"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.irrefutable" title="expr.assign.destructure.irrefutable"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.irrefutable]<span/></a></div>
<p>탈설탕된 패턴은 반박할 수 없어야 합니다(irrefutable). 특히 이는 컴파일 타임에 길이가 알려진 슬라이스 패턴과 사소한 슬라이스 <code>[..]</code>만이 구조 분해 할당에 허용됨을 의미합니다.</p>
<p>탈설탕 방법은 간단하며, 예제로 설명하는 것이 가장 좋습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct { x: u32, y: u32 }
</span><span class="boring">let (mut a, mut b) = (0, 0);
</span>(a, b) = (3, 4);

[a, b] = [3, 4];

Struct { x: a, y: b } = Struct { x: 3, y: 4};

// 다음과 같이 탈설탕됩니다:

{
    let (_a, _b) = (3, 4);
    a = _a;
    b = _b;
}

{
    let [_a, _b] = [3, 4];
    a = _a;
    b = _b;
}

{
    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};
    a = _a;
    b = _b;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure.repeat-ident"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.repeat-ident" title="expr.assign.destructure.repeat-ident"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.repeat-ident]<span/></a></div>
<p>단일 피할당자 표현식에서 식별자를 여러 번 사용하는 것은 금지되지 않습니다.</p>
<div class="rule" id="r-expr.assign.destructure.discard-value"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.discard-value" title="expr.assign.destructure.discard-value"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.discard-value]<span/></a></div>
<p><a href="expressions/./underscore-expr.html">밑줄 표현식</a>과 빈 <a href="expressions/./range-expr.html">범위 표현식</a>을 사용하여 특정 값을 바인딩하지 않고 무시할 수 있습니다.</p>
<div class="rule" id="r-expr.assign.destructure.default-binding"><a class="rule-link" href="expressions/operator-expr.html#r-expr.assign.destructure.default-binding" title="expr.assign.destructure.default-binding"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.default-binding]<span/></a></div>
<p>탈설탕된 표현식에는 기본 바인딩 모드가 적용되지 않는다는 점에 유의하십시오.</p>
<div class="rule" id="r-expr.compound-assign"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign" title="expr.compound-assign"><span>[expr<wbr>.compound-assign]<span/></a></div>
<h2 id="복합-할당-표현식"><a class="header" href="#복합-할당-표현식">복합 할당 표현식</a></h2>
<div class="rule" id="r-expr.compound-assign.syntax"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.syntax" title="expr.compound-assign.syntax"><span>[expr<wbr>.compound-assign<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>복합할당표현식</em> :<br />
      <a href="expressions/../expressions.html"><em>표현식</em></a> <code>+=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>-=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>*=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>/=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>%=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&amp;=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>|=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>^=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&lt;&lt;=</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>&gt;&gt;=</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.compound-assign.intro"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.intro" title="expr.compound-assign.intro"><span>[expr<wbr>.compound-assign<wbr>.intro]<span/></a></div>
<p>_복합 할당 표현식_은 산술 및 논리 이항 연산자와 할당 표현식을 결합한 것입니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 1;
assert!(x == 6);
<span class="boring">}</span></code></pre></pre>
<p>복합 할당의 구문은 <a href="expressions/../expressions.html#mutability">가변</a> <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>(<em>할당된 피연산자</em>), 그 다음에 단일 토큰(공백 없음)으로 <code>=</code>이 뒤따르는 연산자 중 하나, 그리고 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>수정하는 피연산자</em>)입니다.</p>
<div class="rule" id="r-expr.compound-assign.place"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.place" title="expr.compound-assign.place"><span>[expr<wbr>.compound-assign<wbr>.place]<span/></a></div>
<p>다른 장소 피연산자와 달리, 할당된 장소 피연산자는 반드시 장소 표현식이어야 합니다.</p>
<div class="rule" id="r-expr.compound-assign.no-value"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.no-value" title="expr.compound-assign.no-value"><span>[expr<wbr>.compound-assign<wbr>.no-value]<span/></a></div>
<p>값 표현식을 사용하려고 시도하면 이를 임시 값으로 승격시키는 대신 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-expr.compound-assign.operand-order"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.operand-order" title="expr.compound-assign.operand-order"><span>[expr<wbr>.compound-assign<wbr>.operand-order]<span/></a></div>
<p>복합 할당 표현식의 평가는 연산자의 타입에 따라 다릅니다.</p>
<div class="rule" id="r-expr.compound-assign.primitive-order"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.primitive-order" title="expr.compound-assign.primitive-order"><span>[expr<wbr>.compound-assign<wbr>.primitive-order]<span/></a></div>
<p>두 타입이 모두 기본 타입인 경우, 수정하는 피연산자가 먼저 평가된 다음 할당된 피연산자가 평가됩니다. 그런 다음 할당된 피연산자와 수정하는 피연산자의 값으로 연산자의 연산을 수행한 값으로 할당된 피연산자 장소의 값을 설정합니다.</p>
<blockquote>
<p><strong>참고</strong>: 이것은 오른쪽 피연산자가 왼쪽 피연산자보다 먼저 평가된다는 점에서 다른 표현식과 다릅니다.</p>
</blockquote>
<div class="rule" id="r-expr.compound-assign.trait"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.trait" title="expr.compound-assign.trait"><span>[expr<wbr>.compound-assign<wbr>.trait]<span/></a></div>
<p>그렇지 않으면, 이 표현식은 연산자의 오버로딩 복합 할당 트레잇의 함수를 호출하기 위한 구문 설탕입니다(이 장의 앞부분에 있는 표 참조). 할당된 피연산자의 가변 차용이 자동으로 취해집니다.</p>
<p>예를 들어, <code>example</code>의 다음 표현식 문은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Addable;
</span><span class="boring">use std::ops::AddAssign;
</span>
impl AddAssign&lt;Addable&gt; for Addable {
    /* */
<span class="boring">fn add_assign(&amp;mut self, other: Addable) {}
</span>}

fn example() {
<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  a1 += a2;

<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  AddAssign::add_assign(&amp;mut a1, a2);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.compound-assign.result"><a class="rule-link" href="expressions/operator-expr.html#r-expr.compound-assign.result" title="expr.compound-assign.result"><span>[expr<wbr>.compound-assign<wbr>.result]<span/></a></div>
<p>할당 표현식과 마찬가지로, 복합 할당 표현식은 항상 <a href="expressions/../types/tuple.html">유닛 값</a>을 생성합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 피연산자의 평가 순서는 피연산자의 타입에 따라 바뀝니다. 기본 타입의 경우 오른쪽이 먼저 평가되고, 비기본 타입의 경우 왼쪽이 먼저 평가됩니다. 복합 할당 표현식에서 피연산자의 평가 순서에 의존하는 코드를 작성하지 않도록 하십시오. 이 의존성을 사용하는 예는 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs">이 테스트</a>를 참조하십시오.</p>
</blockquote>
</div>
<script>
(function() {
    var fragments = {
        "#slice-dst-pointer-to-pointer-cast": "operator-expr.html#pointer-to-pointer-cast",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.paren"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren" title="expr.paren"><span>[expr<wbr>.paren]<span/></a></div>
<h1 id="그룹화된-표현식"><a class="header" href="#그룹화된-표현식">그룹화된 표현식</a></h1>
<div class="rule" id="r-expr.paren.syntax"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren.syntax" title="expr.paren.syntax"><span>[expr<wbr>.paren<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>그룹화된표현식</em> :<br />
   <code>(</code> <a href="expressions/../expressions.html"><em>표현식</em></a> <code>)</code></p>
</blockquote>
<div class="rule" id="r-expr.paren.intro"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren.intro" title="expr.paren.intro"><span>[expr<wbr>.paren<wbr>.intro]<span/></a></div>
<p>_괄호로 묶인 표현식_은 단일 표현식을 감싸며 해당 표현식으로 평가됩니다. 괄호로 묶인 표현식의 구문은 <code>(</code>, 그 다음에 _둘러싸인 피연산자_라고 하는 표현식, 그리고 <code>)</code>입니다.</p>
<div class="rule" id="r-expr.paren.evaluation"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren.evaluation" title="expr.paren.evaluation"><span>[expr<wbr>.paren<wbr>.evaluation]<span/></a></div>
<p>괄호로 묶인 표현식은 둘러싸인 피연산자의 값으로 평가됩니다.</p>
<div class="rule" id="r-expr.paren.place-or-value"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren.place-or-value" title="expr.paren.place-or-value"><span>[expr<wbr>.paren<wbr>.place-or-value]<span/></a></div>
<p>다른 표현식과 달리, 괄호로 묶인 표현식은 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식이자 값 표현식</a>입니다. 둘러싸인 피연산자가 장소 표현식이면 장소 표현식이고, 둘러싸인 피연산자가 값 표현식이면 값 표현식입니다.</p>
<div class="rule" id="r-expr.paren.override-precedence"><a class="rule-link" href="expressions/grouped-expr.html#r-expr.paren.override-precedence" title="expr.paren.override-precedence"><span>[expr<wbr>.paren<wbr>.override-precedence]<span/></a></div>
<p>괄호는 표현식 내의 하위 표현식의 우선 순위를 명시적으로 수정하는 데 사용할 수 있습니다.</p>
<p>괄호로 묶인 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 2 + 3 * 4; // 괄호로 묶이지 않음
let y: i32 = (2 + 3) * 4; // 괄호로 묶임
assert_eq!(x, 14);
assert_eq!(y, 20);
<span class="boring">}</span></code></pre></pre>
<p>괄호가 반드시 필요한 경우의 예는 구조체의 멤버인 함수 포인터를 호출할 때입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct A {
</span><span class="boring">   f: fn() -&gt; &amp;'static str
</span><span class="boring">}
</span><span class="boring">impl A {
</span><span class="boring">   fn f(&amp;self) -&gt; &amp;'static str {
</span><span class="boring">       "메서드 f"
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let a = A{f: || "필드 f"};
</span><span class="boring">
</span>assert_eq!( a.f (), "메서드 f");
assert_eq!((a.f)(), "필드 f");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.array"><a class="rule-link" href="expressions/array-expr.html#r-expr.array" title="expr.array"><span>[expr<wbr>.array]<span/></a></div>
<h1 id="배열-및-배열-인덱스-표현식"><a class="header" href="#배열-및-배열-인덱스-표현식">배열 및 배열 인덱스 표현식</a></h1>
<h2 id="배열-표현식"><a class="header" href="#배열-표현식">배열 표현식</a></h2>
<div class="rule" id="r-expr.array.syntax"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.syntax" title="expr.array.syntax"><span>[expr<wbr>.array<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>배열표현식</em> :<br />
   <code>[</code> <em>배열요소</em><sup>?</sup> <code>]</code></p>
<p><em>배열요소</em> :<br />
      <a href="expressions/../expressions.html"><em>표현식</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>표현식</em></a> )<sup>*</sup> <code>,</code><sup>?</sup><br />
   | <a href="expressions/../expressions.html"><em>표현식</em></a> <code>;</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.array.constructor"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.constructor" title="expr.array.constructor"><span>[expr<wbr>.array<wbr>.constructor]<span/></a></div>
<p>_배열 표현식_은 <a href="expressions/../types/array.html">배열</a>을 생성합니다. 배열 표현식에는 두 가지 형식이 있습니다.</p>
<div class="rule" id="r-expr.array.array"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.array" title="expr.array.array"><span>[expr<wbr>.array<wbr>.array]<span/></a></div>
<p>첫 번째 형식은 배열의 모든 값을 나열합니다.</p>
<div class="rule" id="r-expr.array.array-syntax"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.array-syntax" title="expr.array.array-syntax"><span>[expr<wbr>.array<wbr>.array-syntax]<span/></a></div>
<p>이 형식의 구문은 대괄호 안에 쉼표로 구분된 동일한 타입의 표현식 목록입니다.</p>
<div class="rule" id="r-expr.array.array-behavior"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.array-behavior" title="expr.array.array-behavior"><span>[expr<wbr>.array<wbr>.array-behavior]<span/></a></div>
<p>이것은 각 값을 작성된 순서대로 포함하는 배열을 생성합니다.</p>
<div class="rule" id="r-expr.array.repeat"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat" title="expr.array.repeat"><span>[expr<wbr>.array<wbr>.repeat]<span/></a></div>
<p>두 번째 형식의 구문은 대괄호 안에 세미콜론(<code>;</code>)으로 구분된 두 개의 표현식입니다.</p>
<div class="rule" id="r-expr.array.repeat-operand"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-operand" title="expr.array.repeat-operand"><span>[expr<wbr>.array<wbr>.repeat-operand]<span/></a></div>
<p><code>;</code> 앞의 표현식을 _반복 피연산자_라고 합니다.</p>
<div class="rule" id="r-expr.array.length-operand"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.length-operand" title="expr.array.length-operand"><span>[expr<wbr>.array<wbr>.length-operand]<span/></a></div>
<p><code>;</code> 뒤의 표현식을 _길이 피연산자_라고 합니다.</p>
<div class="rule" id="r-expr.array.length-restriction"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.length-restriction" title="expr.array.length-restriction"><span>[expr<wbr>.array<wbr>.length-restriction]<span/></a></div>
<p>이것은 <code>usize</code> 타입이어야 하며, <a href="expressions/../tokens.html#literals">리터럴</a>이나 <a href="expressions/../items/constant-items.html">상수 아이템</a>과 같은 <a href="expressions/../const_eval.html#constant-expressions">상수 표현식</a>이어야 합니다.</p>
<div class="rule" id="r-expr.array.repeat-behavior"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-behavior" title="expr.array.repeat-behavior"><span>[expr<wbr>.array<wbr>.repeat-behavior]<span/></a></div>
<p>이 형식의 배열 표현식은 길이 피연산자의 값만큼의 길이를 가지며, 각 요소가 반복 피연산자의 복사본인 배열을 생성합니다. 즉, <code>[a; b]</code>는 <code>a</code> 값의 복사본 <code>b</code>개를 포함하는 배열을 생성합니다.</p>
<div class="rule" id="r-expr.array.repeat-copy"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-copy" title="expr.array.repeat-copy"><span>[expr<wbr>.array<wbr>.repeat-copy]<span/></a></div>
<p>길이 피연산자의 값이 1보다 큰 경우, 반복 피연산자의 타입이 <a href="expressions/../special-types-and-traits.html#copy"><code>Copy</code></a>이거나 상수 아이템에 대한 <a href="expressions/path-expr.html">경로</a>여야 합니다.</p>
<div class="rule" id="r-expr.array.repeat-const-item"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-const-item" title="expr.array.repeat-const-item"><span>[expr<wbr>.array<wbr>.repeat-const-item]<span/></a></div>
<p>반복 피연산자가 상수 아이템인 경우, 길이 피연산자의 값만큼 평가됩니다.</p>
<div class="rule" id="r-expr.array.repeat-evaluation-zero"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-evaluation-zero" title="expr.array.repeat-evaluation-zero"><span>[expr<wbr>.array<wbr>.repeat-evaluation-zero]<span/></a></div>
<p>그 값이 <code>0</code>이면, 상수 아이템은 전혀 평가되지 않습니다.</p>
<div class="rule" id="r-expr.array.repeat-non-const"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.repeat-non-const" title="expr.array.repeat-non-const"><span>[expr<wbr>.array<wbr>.repeat-non-const]<span/></a></div>
<p>상수 아이템이 아닌 표현식의 경우, 정확히 한 번 평가되고 결과는 길이 피연산자의 값만큼 복사됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[1, 2, 3, 4];
["a", "b", "c", "d"];
[0; 128];              // 128개의 0을 가진 배열
[0u8, 0u8, 0u8, 0u8,];
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2차원 배열
const EMPTY: Vec&lt;i32&gt; = Vec::new();
[EMPTY; 2];
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.array.index"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index" title="expr.array.index"><span>[expr<wbr>.array<wbr>.index]<span/></a></div>
<h2 id="배열-및-슬라이스-인덱싱-표현식"><a class="header" href="#배열-및-슬라이스-인덱싱-표현식">배열 및 슬라이스 인덱싱 표현식</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>인덱스표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>[</code> <a href="expressions/../expressions.html"><em>표현식</em></a> <code>]</code></p>
</blockquote>
<div class="rule" id="r-expr.array.index.array"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index.array" title="expr.array.index.array"><span>[expr<wbr>.array<wbr>.index<wbr>.array]<span/></a></div>
<p><a href="expressions/../types/array.html">배열</a> 및 <a href="expressions/../types/slice.html">슬라이스</a> 타입의 값은 그 뒤에 <code>usize</code> 타입의 대괄호로 묶인 표현식(인덱스)을 작성하여 인덱싱할 수 있습니다. 배열이 가변인 경우 결과 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">메모리 위치</a>에 할당할 수 있습니다.</p>
<div class="rule" id="r-expr.array.index.trait"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index.trait" title="expr.array.index.trait"><span>[expr<wbr>.array<wbr>.index<wbr>.trait]<span/></a></div>
<p>다른 타입의 경우 인덱스 표현식 <code>a[b]</code>는 <code>*std::ops::Index::index(&amp;a, b)</code>와 동일하며, 가변 장소 표현식 컨텍스트에서는 <code>*std::ops::IndexMut::index_mut(&amp;mut a, b)</code>와 동일합니다. 메서드와 마찬가지로, Rust는 구현을 찾기 위해 <code>a</code>에 대해 반복적으로 역참조 작업을 수행합니다.</p>
<div class="rule" id="r-expr.array.index.zero-index"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index.zero-index" title="expr.array.index.zero-index"><span>[expr<wbr>.array<wbr>.index<wbr>.zero-index]<span/></a></div>
<p>배열과 슬라이스의 인덱스는 0부터 시작합니다.</p>
<div class="rule" id="r-expr.array.index.const"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index.const" title="expr.array.index.const"><span>[expr<wbr>.array<wbr>.index<wbr>.const]<span/></a></div>
<p>배열 접근은 <a href="expressions/../const_eval.html#constant-expressions">상수 표현식</a>이므로 상수 인덱스 값을 사용하여 컴파일 타임에 범위를 확인할 수 있습니다. 그렇지 않으면 런타임에 확인이 수행되며, 실패할 경우 스레드가 _패닉 상태_가 됩니다.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 린트는 기본적으로 거부(deny)됩니다.
#![warn(unconditional_panic)]

([1, 2, 3, 4])[2];        // 3으로 평가됩니다

let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
b[1][2];                  // 다차원 배열 인덱싱

let x = (["a", "b"])[10]; // 경고: 인덱스가 범위를 벗어남

let n = 10;
let y = (["a", "b"])[n];  // 패닉 발생

let arr = ["a", "b"];
arr[10];                  // 경고: 인덱스가 범위를 벗어남
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.array.index.trait-impl"><a class="rule-link" href="expressions/array-expr.html#r-expr.array.index.trait-impl" title="expr.array.index.trait-impl"><span>[expr<wbr>.array<wbr>.index<wbr>.trait-impl]<span/></a></div>
<p>배열 인덱스 표현식은 <a href="expressions/../../core/ops/index/trait.Index.html">Index</a> 및 <a href="expressions/../../core/ops/index/trait.IndexMut.html">IndexMut</a> 트레잇을 구현하여 배열 및 슬라이스 이외의 타입에 대해 구현할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.tuple"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple" title="expr.tuple"><span>[expr<wbr>.tuple]<span/></a></div>
<h1 id="튜플-및-튜플-인덱싱-표현식"><a class="header" href="#튜플-및-튜플-인덱싱-표현식">튜플 및 튜플 인덱싱 표현식</a></h1>
<h2 id="튜플-표현식"><a class="header" href="#튜플-표현식">튜플 표현식</a></h2>
<div class="rule" id="r-expr.tuple.syntax"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.syntax" title="expr.tuple.syntax"><span>[expr<wbr>.tuple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플표현식</em> :<br />
   <code>(</code> <em>튜플요소</em><sup>?</sup> <code>)</code></p>
<p><em>튜플요소</em> :<br />
   ( <a href="expressions/../expressions.html"><em>표현식</em></a> <code>,</code> )<sup>+</sup> <a href="expressions/../expressions.html"><em>표현식</em></a><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.tuple.result"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.result" title="expr.tuple.result"><span>[expr<wbr>.tuple<wbr>.result]<span/></a></div>
<p>_튜플 표현식_은 <a href="expressions/../types/tuple.html">튜플 값</a>을 생성합니다.</p>
<div class="rule" id="r-expr.tuple.intro"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.intro" title="expr.tuple.intro"><span>[expr<wbr>.tuple<wbr>.intro]<span/></a></div>
<p>튜플 표현식의 구문은 _튜플 초기화 피연산자_라고 하는 괄호로 묶인 쉼표로 구분된 표현식 목록입니다.</p>
<div class="rule" id="r-expr.tuple.unary-tuple-restriction"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.unary-tuple-restriction" title="expr.tuple.unary-tuple-restriction"><span>[expr<wbr>.tuple<wbr>.unary-tuple-restriction]<span/></a></div>
<p>단항(1-ary) 튜플 표현식은 <a href="expressions/grouped-expr.html">괄호로 묶인 표현식</a>과 구분하기 위해 튜플 초기화 피연산자 뒤에 쉼표가 필요합니다.</p>
<div class="rule" id="r-expr.tuple.value"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.value" title="expr.tuple.value"><span>[expr<wbr>.tuple<wbr>.value]<span/></a></div>
<p>튜플 표현식은 새로 생성된 튜플 타입 값으로 평가되는 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>입니다.</p>
<div class="rule" id="r-expr.tuple.type"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.type" title="expr.tuple.type"><span>[expr<wbr>.tuple<wbr>.type]<span/></a></div>
<p>튜플 초기화 피연산자의 수는 생성된 튜플의 항수(arity)입니다.</p>
<div class="rule" id="r-expr.tuple.unit"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.unit" title="expr.tuple.unit"><span>[expr<wbr>.tuple<wbr>.unit]<span/></a></div>
<p>튜플 초기화 피연산자가 없는 튜플 표현식은 유닛 튜플을 생성합니다.</p>
<div class="rule" id="r-expr.tuple.fields"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple.fields" title="expr.tuple.fields"><span>[expr<wbr>.tuple<wbr>.fields]<span/></a></div>
<p>다른 튜플 표현식의 경우, 첫 번째로 작성된 튜플 초기화 피연산자는 필드 <code>0</code>을 초기화하고 후속 피연산자는 다음으로 높은 필드를 초기화합니다. 예를 들어, 튜플 표현식 <code>('a', 'b', 'c')</code>에서 <code>'a'</code>는 필드 <code>0</code>의 값을 초기화하고, <code>'b'</code>는 필드 <code>1</code>, <code>'c'</code>는 필드 <code>2</code>를 초기화합니다.</p>
<p>튜플 표현식과 그 타입의 예:</p>
<div class="table-wrapper"><table><thead><tr><th>표현식</th><th>유형</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>()</code> (유닛)</td></tr>
<tr><td><code>(0.0, 4.5)</code></td><td><code>(f64, f64)</code></td></tr>
<tr><td><code>("x".to_string(), )</code></td><td><code>(String, )</code></td></tr>
<tr><td><code>("a", 4usize, true)</code></td><td><code>(&amp;'static str, usize, bool)</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-expr.tuple-index"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index" title="expr.tuple-index"><span>[expr<wbr>.tuple-index]<span/></a></div>
<h2 id="튜플-인덱싱-표현식"><a class="header" href="#튜플-인덱싱-표현식">튜플 인덱싱 표현식</a></h2>
<div class="rule" id="r-expr.tuple-index.syntax"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.syntax" title="expr.tuple-index.syntax"><span>[expr<wbr>.tuple-index<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플인덱싱표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>.</code> <a href="expressions/../tokens.html#tuple-index">튜플_인덱스</a></p>
</blockquote>
<div class="rule" id="r-expr.tuple-index.intro"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.intro" title="expr.tuple-index.intro"><span>[expr<wbr>.tuple-index<wbr>.intro]<span/></a></div>
<p>_튜플 인덱싱 표현식_은 <a href="expressions/../types/tuple.html">튜플</a>과 <a href="expressions/../types/struct.html">튜플 구조체</a>의 필드에 접근합니다.</p>
<p>튜플 인덱스 표현식의 구문은 _튜플 피연산자_라고 하는 표현식, 그 다음 <code>.</code>, 그리고 마지막으로 튜플 인덱스입니다.</p>
<div class="rule" id="r-expr.tuple-index.index-syntax"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.index-syntax" title="expr.tuple-index.index-syntax"><span>[expr<wbr>.tuple-index<wbr>.index-syntax]<span/></a></div>
<p>_튜플 인덱스_의 구문은 선행 0, 밑줄 또는 접미사가 없는 <a href="expressions/../tokens.html#integer-literals">십진 리터럴</a>입니다. 예를 들어 <code>0</code>과 <code>2</code>는 유효한 튜플 인덱스이지만, <code>01</code>, <code>0_</code>, <code>0i32</code>는 그렇지 않습니다.</p>
<div class="rule" id="r-expr.tuple-index.required-type"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.required-type" title="expr.tuple-index.required-type"><span>[expr<wbr>.tuple-index<wbr>.required-type]<span/></a></div>
<p>튜플 피연산자의 타입은 <a href="expressions/../types/tuple.html">튜플 타입</a> 또는 <a href="expressions/../types/struct.html">튜플 구조체</a>여야 합니다.</p>
<div class="rule" id="r-expr.tuple-index.index-name-operand"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.index-name-operand" title="expr.tuple-index.index-name-operand"><span>[expr<wbr>.tuple-index<wbr>.index-name-operand]<span/></a></div>
<p>튜플 인덱스는 튜플 피연산자 타입의 필드 이름이어야 합니다.</p>
<div class="rule" id="r-expr.tuple-index.result"><a class="rule-link" href="expressions/tuple-expr.html#r-expr.tuple-index.result" title="expr.tuple-index.result"><span>[expr<wbr>.tuple-index<wbr>.result]<span/></a></div>
<p>튜플 인덱스 표현식의 평가는 튜플 피연산자의 평가 외에 부작용이 없습니다. <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>으로서, 튜플 인덱스와 이름이 같은 튜플 피연산자 필드의 위치로 평가됩니다.</p>
<p>튜플 인덱싱 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 튜플 인덱싱
let pair = ("문자열", 2);
assert_eq!(pair.1, 2);

// 튜플 구조체 인덱싱
<span class="boring">struct Point(f32, f32);
</span>let point = Point(1.0, 0.0);
assert_eq!(point.0, 1.0);
assert_eq!(point.1, 0.0);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 필드 접근 표현식과 달리, 튜플 인덱스 표현식은 메서드 이름이 숫자가 될 수 없으므로 메서드 호출과 혼동될 수 없기 때문에 <a href="expressions/./call-expr.html">호출 표현식</a>의 함수 피연산자가 될 수 있습니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: 배열과 슬라이스에도 요소가 있지만, 해당 요소에 접근하려면 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 또는 슬라이스 인덱싱 표현식</a>이나 <a href="expressions/../patterns.html#slice-patterns">슬라이스 패턴</a>을 사용해야 합니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.struct"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct" title="expr.struct"><span>[expr<wbr>.struct]<span/></a></div>
<h1 id="구조체-표현식"><a class="header" href="#구조체-표현식">구조체 표현식</a></h1>
<div class="rule" id="r-expr.struct.syntax"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.syntax" title="expr.struct.syntax"><span>[expr<wbr>.struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>구조체표현식</em> :<br />
      <em>구조체표현식구조체</em><br />
   | <em>구조체표현식튜플</em><br />
   | <em>구조체표현식유닛</em></p>
<p><em>구조체표현식구조체</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>{</code> (<em>구조체표현식필드</em> | <em>구조체베이스</em>)<sup>?</sup> <code>}</code></p>
<p><em>구조체표현식필드</em> :<br />
   <em>구조체표현식필드</em> (<code>,</code> <em>구조체표현식필드</em>)<sup>*</sup> (<code>,</code> <em>구조체베이스</em> | <code>,</code><sup>?</sup>)</p>
<p><em>구조체표현식필드</em> :<br />
   <a href="expressions/../attributes.html"><em>외부속성</em></a> <sup>*</sup><br />
   (<br />
         <a href="expressions/../identifiers.html">식별자</a><br />
      | (<a href="expressions/../identifiers.html">식별자</a> | <a href="expressions/../tokens.html#tuple-index">튜플_인덱스</a>) <code>:</code> <a href="expressions/../expressions.html"><em>표현식</em></a><br />
   )</p>
<p><em>구조체베이스</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
<p><em>구조체표현식튜플</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>(</code><br />
      ( <a href="expressions/../expressions.html"><em>표현식</em></a> (<code>,</code> <a href="expressions/../expressions.html"><em>표현식</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> )<sup>?</sup><br />
   <code>)</code></p>
<p><em>구조체표현식유닛</em> : <a href="expressions/../paths.html#paths-in-expressions"><em>표현식내경로</em></a></p>
</blockquote>
<div class="rule" id="r-expr.struct.intro"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.intro" title="expr.struct.intro"><span>[expr<wbr>.struct<wbr>.intro]<span/></a></div>
<p>_구조체 표현식_은 구조체, 열거형 또는 공용체 값을 생성합니다. 이는 <a href="expressions/../items/structs.html">구조체</a>, <a href="expressions/../items/enumerations.html">열거형 변형</a> 또는 <a href="expressions/../items/unions.html">공용체</a> 아이템에 대한 경로와 그 뒤에 오는 아이템의 필드 값들로 구성됩니다. 구조체 표현식에는 구조체, 튜플, 유닛의 세 가지 형식이 있습니다.</p>
<p>다음은 구조체 표현식의 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point { x: f64, y: f64 }
</span><span class="boring">struct NothingInMe { }
</span><span class="boring">struct TuplePoint(f64, f64);
</span><span class="boring">mod game { pub struct User&lt;'a&gt; { pub name: &amp;'a str, pub age: u32, pub score: usize } }
</span><span class="boring">struct Cookie; fn some_fn&lt;T&gt;(t: T) {}
</span>Point {x: 10.0, y: 20.0};
NothingInMe {};
TuplePoint(10.0, 20.0);
TuplePoint { 0: 10.0, 1: 20.0 }; // 윗줄과 같은 결과를 가집니다
let u = game::User {name: "Joe", age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.struct.field"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.field" title="expr.struct.field"><span>[expr<wbr>.struct<wbr>.field]<span/></a></div>
<h2 id="필드-구조체-표현식"><a class="header" href="#필드-구조체-표현식">필드 구조체 표현식</a></h2>
<div class="rule" id="r-expr.struct.field.intro"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.field.intro" title="expr.struct.field.intro"><span>[expr<wbr>.struct<wbr>.field<wbr>.intro]<span/></a></div>
<p>중괄호로 묶인 필드가 있는 구조체 표현식을 사용하면 각 개별 필드의 값을 순서에 관계없이 지정할 수 있습니다. 필드 이름은 콜론으로 값과 구분됩니다.</p>
<div class="rule" id="r-expr.struct.field.union-constraint"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.field.union-constraint" title="expr.struct.field.union-constraint"><span>[expr<wbr>.struct<wbr>.field<wbr>.union-constraint]<span/></a></div>
<p><a href="expressions/../items/unions.html">공용체</a> 타입의 값은 이 구문을 사용하여 생성할 수 있으며, 정확히 하나의 필드를 지정해야 합니다.</p>
<div class="rule" id="r-expr.struct.update"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.update" title="expr.struct.update"><span>[expr<wbr>.struct<wbr>.update]<span/></a></div>
<h2 id="함수형-업데이트-구문"><a class="header" href="#함수형-업데이트-구문">함수형 업데이트 구문</a></h2>
<div class="rule" id="r-expr.struct.update.intro"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.update.intro" title="expr.struct.update.intro"><span>[expr<wbr>.struct<wbr>.update<wbr>.intro]<span/></a></div>
<p>구조체 타입의 값을 생성하는 구조체 표현식은 함수형 업데이트를 나타내기 위해 <code>..</code> 뒤에 표현식이 오는 구문으로 끝날 수 있습니다.</p>
<div class="rule" id="r-expr.struct.update.base-same-type"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.update.base-same-type" title="expr.struct.update.base-same-type"><span>[expr<wbr>.struct<wbr>.update<wbr>.base-same-type]<span/></a></div>
<p><code>..</code> 뒤에 오는 표현식(베이스)은 생성되는 새 구조체 타입과 동일한 구조체 타입을 가져야 합니다.</p>
<div class="rule" id="r-expr.struct.update.fields"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.update.fields" title="expr.struct.update.fields"><span>[expr<wbr>.struct<wbr>.update<wbr>.fields]<span/></a></div>
<p>전체 표현식은 지정된 필드에 대해 주어진 값을 사용하고 베이스 표현식에서 나머지 필드를 이동하거나 복사합니다.</p>
<div class="rule" id="r-expr.struct.update.visibility-constraint"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.update.visibility-constraint" title="expr.struct.update.visibility-constraint"><span>[expr<wbr>.struct<wbr>.update<wbr>.visibility-constraint]<span/></a></div>
<p>모든 구조체 표현식과 마찬가지로, 명시적으로 명명되지 않은 필드를 포함하여 구조체의 모든 필드는 <a href="expressions/../visibility-and-privacy.html">보여야</a> 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span>let mut base = Point3d {x: 1, y: 2, z: 3};
let y_ref = &amp;mut base.y;
Point3d {y: 0, z: 10, .. base}; // OK, base.x만 접근됩니다
drop(y_ref);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.struct.brace-restricted-positions"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.brace-restricted-positions" title="expr.struct.brace-restricted-positions"><span>[expr<wbr>.struct<wbr>.brace-restricted-positions]<span/></a></div>
<p>중괄호가 있는 구조체 표현식은 <a href="expressions/loop-expr.html">loop</a> 또는 <a href="expressions/if-expr.html#if-expressions">if</a> 표현식의 헤드, 또는 <a href="expressions/if-expr.html#if-let-expressions">if let</a>이나 <a href="expressions/match-expr.html">match</a> 표현식의 <a href="expressions/../glossary.html#scrutinee">scrutinee</a>에서 직접 사용할 수 없습니다. 그러나 구조체 표현식이 다른 표현식 내에 있는 경우(예: <a href="expressions/grouped-expr.html">괄호</a> 내부), 이러한 상황에서 사용할 수 있습니다.</p>
<div class="rule" id="r-expr.struct.tuple-field"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.tuple-field" title="expr.struct.tuple-field"><span>[expr<wbr>.struct<wbr>.tuple-field]<span/></a></div>
<p>필드 이름은 십진 정수 값이 되어 튜플 구조체 생성 시 인덱스를 지정할 수 있습니다. 이것은 기본 구조체와 함께 사용하여 지정되지 않은 나머지 인덱스를 채우는 데 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(u8, u8, u8);
let c1 = Color(0, 0, 0);  // 튜플 구조체를 생성하는 전형적인 방법.
let c2 = Color{0: 255, 1: 127, 2: 0};  // 인덱스로 필드 지정.
let c3 = Color{1: 0, ..c2};  // 기본 구조체를 사용하여 다른 모든 필드를 채웁니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.struct.field.named"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.field.named" title="expr.struct.field.named"><span>[expr<wbr>.struct<wbr>.field<wbr>.named]<span/></a></div>
<h3 id="구조체-필드-초기화-단축형"><a class="header" href="#구조체-필드-초기화-단축형">구조체 필드 초기화 단축형</a></h3>
<p>명명된(번호가 매겨지지 않은) 필드가 있는 데이터 구조(구조체, 열거형, 공용체)를 초기화할 때, <code>fieldname: fieldname</code>의 약어로 <code>fieldname</code>을 작성할 수 있습니다. 이를 통해 중복이 적은 간결한 구문을 사용할 수 있습니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span><span class="boring">let x = 0;
</span><span class="boring">let y_value = 0;
</span><span class="boring">let z = 0;
</span>Point3d { x: x, y: y_value, z: z };
Point3d { x, y: y_value, z };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.struct.tuple"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.tuple" title="expr.struct.tuple"><span>[expr<wbr>.struct<wbr>.tuple]<span/></a></div>
<h2 id="튜플-구조체-표현식"><a class="header" href="#튜플-구조체-표현식">튜플 구조체 표현식</a></h2>
<p>괄호로 묶인 필드가 있는 구조체 표현식은 튜플 구조체를 생성합니다. 완전성을 위해 여기에 특정 표현식으로 나열되어 있지만, 이는 튜플 구조체의 생성자에 대한 <a href="expressions/call-expr.html">호출 표현식</a>과 동일합니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Position(i32, i32, i32);
Position(0, 0, 0);  // 튜플 구조체를 생성하는 전형적인 방법.
let c = Position;  // `c`는 3개의 인수를 받는 함수입니다.
let pos = c(8, 6, 7);  // `Position` 값을 생성합니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.struct.unit"><a class="rule-link" href="expressions/struct-expr.html#r-expr.struct.unit" title="expr.struct.unit"><span>[expr<wbr>.struct<wbr>.unit]<span/></a></div>
<h2 id="유닛-구조체-표현식"><a class="header" href="#유닛-구조체-표현식">유닛 구조체 표현식</a></h2>
<p>유닛 구조체 표현식은 단순히 유닛 구조체 아이템에 대한 경로입니다. 이는 유닛 구조체 값의 암시적 상수를 나타냅니다. 유닛 구조체 값은 필드 없는 구조체 표현식으로도 생성할 수 있습니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Gamma;
let a = Gamma;  // Gamma 유닛 값.
let b = Gamma{};  // `a`와 정확히 같은 값.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.call"><a class="rule-link" href="expressions/call-expr.html#r-expr.call" title="expr.call"><span>[expr<wbr>.call]<span/></a></div>
<h1 id="호출-표현식"><a class="header" href="#호출-표현식">호출 표현식</a></h1>
<div class="rule" id="r-expr.call.syntax"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.syntax" title="expr.call.syntax"><span>[expr<wbr>.call<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>호출표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>(</code> <em>호출매개변수</em><sup>?</sup> <code>)</code></p>
<p><em>호출매개변수</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>표현식</em></a> )<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.call.intro"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.intro" title="expr.call.intro"><span>[expr<wbr>.call<wbr>.intro]<span/></a></div>
<p>_호출 표현식_은 함수를 호출합니다. 호출 표현식의 구문은 _함수 피연산자_라고 하는 표현식과 그 뒤에 오는 _인수 피연산자_라고 하는 괄호로 묶인 쉼표로 구분된 표현식 목록입니다.</p>
<div class="rule" id="r-expr.call.convergence"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.convergence" title="expr.call.convergence"><span>[expr<wbr>.call<wbr>.convergence]<span/></a></div>
<p>함수가 결국 반환되면 표현식이 완료됩니다.</p>
<div class="rule" id="r-expr.call.trait"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.trait" title="expr.call.trait"><span>[expr<wbr>.call<wbr>.trait]<span/></a></div>
<p><a href="expressions/../types/function-item.html">비 함수 타입</a>의 경우, 표현식 <code>f(...)</code>는 함수 피연산자에 따라 다음 트레잇 중 하나의 메서드를 사용합니다:</p>
<ul>
<li><a href="expressions/../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 또는 <a href="expressions/../../core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a> — 공유 참조.</li>
<li><a href="expressions/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 또는 <a href="expressions/../../core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a> — 가변 참조.</li>
<li><a href="expressions/../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> 또는 <a href="expressions/../../core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a> — 값.</li>
</ul>
<div class="rule" id="r-expr.call.autoref-deref"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.autoref-deref" title="expr.call.autoref-deref"><span>[expr<wbr>.call<wbr>.autoref-deref]<span/></a></div>
<p>An automatic borrow will be taken if needed. The function operand will also be <a href="expressions/field-expr.html#automatic-dereferencing">automatically dereferenced</a> as required.</p>
<p>호출 표현식의 몇 가지 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn add(x: i32, y: i32) -&gt; i32 { 0 }
</span>let three: i32 = add(1i32, 2i32);
let name: &amp;'static str = (|| "Rust")();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.call.desugar"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.desugar" title="expr.call.desugar"><span>[expr<wbr>.call<wbr>.desugar]<span/></a></div>
<h2 id="함수-호출의-모호성-해결"><a class="header" href="#함수-호출의-모호성-해결">함수 호출의 모호성 해결</a></h2>
<div class="rule" id="r-expr.call.desugar.fully-qualified"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.desugar.fully-qualified" title="expr.call.desugar.fully-qualified"><span>[expr<wbr>.call<wbr>.desugar<wbr>.fully-qualified]<span/></a></div>
<p>모든 함수 호출은 더 명시적인 <a href="expressions/../paths.html#qualified-paths">정규화된 구문</a>에 대한 설탕입니다.</p>
<div class="rule" id="r-expr.call.desugar.ambiguity"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.desugar.ambiguity" title="expr.call.desugar.ambiguity"><span>[expr<wbr>.call<wbr>.desugar<wbr>.ambiguity]<span/></a></div>
<p>함수 호출은 스코프 내 아이템에 비추어 호출의 모호성에 따라 완전히 정규화되어야 할 수도 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 과거에는 문서, 이슈, RFC 및 기타 커뮤니티 글에서 “모호하지 않은 함수 호출 구문(Unambiguous Function Call Syntax)”, “범용 함수 호출 구문(Universal Function Call Syntax)” 또는 “UFCS“라는 용어가 사용되었습니다. 그러나 이러한 용어는 설명력이 부족하고 당면한 문제를 혼란스럽게 할 수 있습니다. 검색 가능성을 위해 여기에서 언급합니다.</p>
</blockquote>
<div class="rule" id="r-expr.call.desugar.limits"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.desugar.limits" title="expr.call.desugar.limits"><span>[expr<wbr>.call<wbr>.desugar<wbr>.limits]<span/></a></div>
<p>메서드 또는 연관 함수 호출의 수신자 또는 참조 대상에 대한 모호성을 초래하는 상황이 종종 발생합니다. 이러한 상황은 다음을 포함할 수 있습니다:</p>
<ul>
<li>여러 스코프 내 트레잇이 동일한 타입에 대해 동일한 이름의 메서드를 정의하는 경우</li>
<li>자동 <code>deref</code>가 바람직하지 않은 경우; 예를 들어, 스마트 포인터 자체의 메서드와 포인터가 참조하는 대상의 메서드를 구별하는 경우</li>
<li><a href="expressions/../../core/default/trait.Default.html#tymethod.default"><code>default()</code></a>와 같이 인수를 받지 않는 메서드, 그리고 <a href="expressions/../../core/mem/fn.size_of.html"><code>size_of()</code></a>와 같이 타입의 속성을 반환하는 메서드</li>
</ul>
<div class="rule" id="r-expr.call.desugar.explicit-path"><a class="rule-link" href="expressions/call-expr.html#r-expr.call.desugar.explicit-path" title="expr.call.desugar.explicit-path"><span>[expr<wbr>.call<wbr>.desugar<wbr>.explicit-path]<span/></a></div>
<p>모호성을 해결하기 위해, 프로그래머는 더 구체적인 경로, 타입 또는 트레잇을 사용하여 원하는 메서드나 함수를 참조할 수 있습니다.</p>
<p>예를 들어,</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Pretty {
    fn print(&amp;self);
}

trait Ugly {
    fn print(&amp;self);
}

struct Foo;
impl Pretty for Foo {
    fn print(&amp;self) {}
}

struct Bar;
impl Pretty for Bar {
    fn print(&amp;self) {}
}
impl Ugly for Bar {
    fn print(&amp;self) {}
}

fn main() {
    let f = Foo;
    let b = Bar;

    // `Foo`에 대해 `print`라고 불리는 아이템이 하나만 있기 때문에 이렇게 할 수 있습니다
    f.print();
    // 더 명시적이며, `Foo`의 경우 필요하지 않습니다
    Foo::print(&amp;f);
    // 간결함을 선호하지 않는다면
    &lt;Foo as Pretty&gt;::print(&amp;f);

    // b.print(); // 오류: 여러 개의 'print' 발견됨
    // Bar::print(&amp;b); // 여전히 오류: 여러 개의 `print` 발견됨

    // `print`를 정의하는 스코프 내 아이템 때문에 필요함
    &lt;Bar as Pretty&gt;::print(&amp;b);
}</code></pre></pre>
<p>자세한 내용과 동기는 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">RFC 132</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.method"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method" title="expr.method"><span>[expr<wbr>.method]<span/></a></div>
<h1 id="메서드-호출-표현식"><a class="header" href="#메서드-호출-표현식">메서드 호출 표현식</a></h1>
<div class="rule" id="r-expr.method.syntax"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.syntax" title="expr.method.syntax"><span>[expr<wbr>.method<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>메서드호출표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>.</code> <a href="expressions/../paths.html#paths-in-expressions"><em>경로표현식세그먼트</em></a> <code>(</code><a href="expressions/call-expr.html"><em>호출매개변수</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<div class="rule" id="r-expr.method.intro"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.intro" title="expr.method.intro"><span>[expr<wbr>.method<wbr>.intro]<span/></a></div>
<p>_메서드 호출_은 표현식(<em>수신자</em>), 그 뒤에 오는 단일 점, 표현식 경로 세그먼트, 괄호로 묶인 표현식 목록으로 구성됩니다.</p>
<div class="rule" id="r-expr.method.target"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.target" title="expr.method.target"><span>[expr<wbr>.method<wbr>.target]<span/></a></div>
<p>메서드 호출은 특정 트레잇의 연관 <a href="expressions/../items/associated-items.html#methods">메서드</a>로 확인되며, 왼쪽의 정확한 <code>self</code> 타입이 알려진 경우 메서드에 정적으로 디스패치하거나, 왼쪽 표현식이 간접 <a href="expressions/../types/trait-object.html">트레잇 객체</a>인 경우 동적으로 디스패치합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi: Result&lt;f32, _&gt; = "3.14".parse();
let log_pi = pi.unwrap_or(1.0).log(2.72);
<span class="boring">assert!(1.14 &lt; log_pi &amp;&amp; log_pi &lt; 1.15)
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.method.autoref-deref"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.autoref-deref" title="expr.method.autoref-deref"><span>[expr<wbr>.method<wbr>.autoref-deref]<span/></a></div>
<p>메서드 호출을 찾을 때, 메서드를 호출하기 위해 수신자가 자동으로 역참조되거나 차용될 수 있습니다. 호출할 수 있는 메서드가 여러 개일 수 있으므로 다른 함수보다 더 복잡한 조회 과정이 필요합니다. 다음 절차가 사용됩니다:</p>
<div class="rule" id="r-expr.method.candidate-receivers"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.candidate-receivers" title="expr.method.candidate-receivers"><span>[expr<wbr>.method<wbr>.candidate-receivers]<span/></a></div>
<p>첫 번째 단계는 후보 수신자 타입 목록을 작성하는 것입니다. 수신자 표현식의 타입을 반복적으로 <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a>하여 얻은 각 타입을 목록에 추가한 다음, 마지막으로 <a href="expressions/../type-coercions.html#unsized-coercions">크기 없는 강제 변환</a>을 시도하고 성공하면 결과 타입을 추가합니다.</p>
<div class="rule" id="r-expr.method.candidate-receivers-refs"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.candidate-receivers-refs" title="expr.method.candidate-receivers-refs"><span>[expr<wbr>.method<wbr>.candidate-receivers-refs]<span/></a></div>
<p>그런 다음 각 후보 <code>T</code>에 대해, <code>T</code> 바로 뒤에 목록에 <code>&amp;T</code>와 <code>&amp;mut T</code>를 추가합니다.</p>
<p>예를 들어, 수신자의 타입이 <code>Box&lt;[i32;2]&gt;</code>인 경우 후보 타입은 <code>Box&lt;[i32;2]&gt;</code>, <code>&amp;Box&lt;[i32;2]&gt;</code>, <code>&amp;mut Box&lt;[i32;2]&gt;</code>, <code>[i32; 2]</code> (역참조에 의해), <code>&amp;[i32; 2]</code>, <code>&amp;mut [i32; 2]</code>, <code>[i32]</code> (크기 없는 강제 변환에 의해), <code>&amp;[i32]</code>, 마지막으로 <code>&amp;mut [i32]</code>가 됩니다.</p>
<div class="rule" id="r-expr.method.candidate-search"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.candidate-search" title="expr.method.candidate-search"><span>[expr<wbr>.method<wbr>.candidate-search]<span/></a></div>
<p>그런 다음 각 후보 타입 <code>T</code>에 대해 다음 위치에서 해당 타입의 수신자가 있는 <a href="expressions/../visibility-and-privacy.html">보이는</a> 메서드를 검색합니다:</p>
<ol>
<li><code>T</code>의 고유 메서드 (<code>T</code>에 직접 구현된 메서드).</li>
<li><code>T</code>에 의해 구현된 <a href="expressions/../visibility-and-privacy.html">보이는</a> 트레잇이 제공하는 메서드 중 하나. <code>T</code>가 타입 매개변수인 경우 <code>T</code>의 트레잇 바운드가 제공하는 메서드가 먼저 조회됩니다. 그런 다음 스코프에 있는 나머지 모든 메서드가 조회됩니다.</li>
</ol>
<blockquote>
<p>참고: 조회는 각 타입에 대해 순서대로 수행되므로 때때로 놀라운 결과가 발생할 수 있습니다. 아래 코드는 “In trait impl!“을 출력하는데, 이는 <code>&amp;self</code> 메서드가 먼저 조회되어 구조체의 <code>&amp;mut self</code> 메서드가 발견되기 전에 트레잇 메서드가 발견되기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Foo {}

trait Bar {
  fn bar(&amp;self);
}

impl Foo {
  fn bar(&amp;mut self) {
    println!("In struct impl!")
  }
}

impl Bar for Foo {
  fn bar(&amp;self) {
    println!("In trait impl!")
  }
}

fn main() {
  let mut f = Foo{};
  f.bar();
}</code></pre></pre>
</blockquote>
<div class="rule" id="r-expr.method.ambiguous-target"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.ambiguous-target" title="expr.method.ambiguous-target"><span>[expr<wbr>.method<wbr>.ambiguous-target]<span/></a></div>
<p>만약 여러 가능한 후보가 생성되면 오류이며, 메서드 호출을 하려면 수신자를 적절한 수신자 타입으로 <a href="expressions/call-expr.html#disambiguating-function-calls">변환</a>해야 합니다.</p>
<div class="rule" id="r-expr.method.receiver-constraints"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.receiver-constraints" title="expr.method.receiver-constraints"><span>[expr<wbr>.method<wbr>.receiver-constraints]<span/></a></div>
<p>이 과정은 수신자의 가변성이나 라이프타임, 또는 메서드가 <code>unsafe</code>인지 여부를 고려하지 않습니다. 메서드가 조회된 후, 이러한 이유 중 하나(또는 그 이상)로 호출할 수 없는 경우 결과는 컴파일러 오류입니다.</p>
<div class="rule" id="r-expr.method.ambiguous-search"><a class="rule-link" href="expressions/method-call-expr.html#r-expr.method.ambiguous-search" title="expr.method.ambiguous-search"><span>[expr<wbr>.method<wbr>.ambiguous-search]<span/></a></div>
<p>제네릭 메서드나 트레잇이 동일하게 간주되는 등 가능한 메서드가 하나 이상 있는 단계에 도달하면 컴파일러 오류입니다. 이러한 경우 메서드 및 함수 호출을 위해 <a href="expressions/call-expr.html#disambiguating-function-calls">모호하지 않은 함수 호출 구문</a>이 필요합니다.</p>
<blockquote>
<p><strong>에디션 차이</strong>: 2021년 에디션 이전에는 보이는 메서드를 검색하는 동안 후보 수신자 타입이 <a href="expressions/../types/array.html">배열 타입</a>인 경우 표준 라이브러리 <a href="expressions/../../core/iter/traits/collect/trait.IntoIterator.html"><code>IntoIterator</code></a> 트레잇에서 제공하는 메서드는 무시됩니다.</p>
<p>이 목적에 사용되는 에디션은 메서드 이름을 나타내는 토큰에 의해 결정됩니다.</p>
<p>이 특별한 경우는 나중에 제거될 수 있습니다.</p>
</blockquote>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> <a href="expressions/../types/trait-object.html">트레잇 객체</a>의 경우, 트레잇 메서드와 동일한 이름의 고유 메서드가 있으면 메서드 호출 표현식에서 해당 메서드를 호출하려고 할 때 컴파일러 오류가 발생합니다. 대신 <a href="expressions/call-expr.html#disambiguating-function-calls">모호하지 않은 함수 호출 구문</a>을 사용하여 메서드를 호출할 수 있는데, 이 경우 고유 메서드가 아니라 트레잇 메서드를 호출합니다. 고유 메서드를 호출할 방법은 없습니다. 트레잇 객체에 트레잇 메서드와 동일한 이름의 고유 메서드를 정의하지 않으면 괜찮습니다.</p>
</blockquote>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.field"><a class="rule-link" href="expressions/field-expr.html#r-expr.field" title="expr.field"><span>[expr<wbr>.field]<span/></a></div>
<h1 id="필드-접근-표현식"><a class="header" href="#필드-접근-표현식">필드 접근 표현식</a></h1>
<div class="rule" id="r-expr.field.syntax"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.syntax" title="expr.field.syntax"><span>[expr<wbr>.field<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>필드표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>.</code> <a href="expressions/../identifiers.html">식별자</a></p>
</blockquote>
<div class="rule" id="r-expr.field.intro"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.intro" title="expr.field.intro"><span>[expr<wbr>.field<wbr>.intro]<span/></a></div>
<p>_필드 표현식_은 <a href="expressions/../items/structs.html">구조체</a> 또는 <a href="expressions/../items/unions.html">공용체</a> 필드의 위치로 평가되는 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>입니다.</p>
<div class="rule" id="r-expr.field.mut"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.mut" title="expr.field.mut"><span>[expr<wbr>.field<wbr>.mut]<span/></a></div>
<p>피연산자가 <a href="expressions/../expressions.html#mutability">가변</a>이면 필드 표현식도 가변입니다.</p>
<div class="rule" id="r-expr.field.form"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.form" title="expr.field.form"><span>[expr<wbr>.field<wbr>.form]<span/></a></div>
<p>필드 표현식의 구문은 _컨테이너 피연산자_라고 하는 표현식, 그 다음 <code>.</code>, 그리고 마지막으로 <a href="expressions/../identifiers.html">식별자</a>입니다.</p>
<div class="rule" id="r-expr.field.not-method-call"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.not-method-call" title="expr.field.not-method-call"><span>[expr<wbr>.field<wbr>.not-method-call]<span/></a></div>
<p>필드 표현식 뒤에는 괄호로 묶인 쉼표로 구분된 표현식 목록이 올 수 없습니다. 이는 대신 <a href="expressions/method-call-expr.html">메서드 호출 표현식</a>으로 파싱되기 때문입니다. 즉, <a href="expressions/call-expr.html">호출 표현식</a>의 함수 피연산자가 될 수 없습니다.</p>
<blockquote>
<p><strong>참고</strong>: 필드 표현식을 호출 표현식에서 사용하려면 <a href="expressions/grouped-expr.html">괄호로 묶인 표현식</a>으로 감싸십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct HoldsCallable&lt;F: Fn()&gt; { callable: F }
</span>let holds_callable = HoldsCallable { callable: || () };

// 잘못됨: 메서드 "callable" 호출로 파싱됨
// holds_callable.callable();

// 유효함
(holds_callable.callable)();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>예:</p>
<!-- ignore: needs lots of support code -->
<pre><code class="language-rust ignore">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
(mystruct.function_field)() // 필드 표현식을 포함하는 호출 표현식</code></pre>
<div class="rule" id="r-expr.field.autoref-deref"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.autoref-deref" title="expr.field.autoref-deref"><span>[expr<wbr>.field<wbr>.autoref-deref]<span/></a></div>
<h2 id="자동-역참조"><a class="header" href="#자동-역참조">자동 역참조</a></h2>
<p>컨테이너 피연산자의 타입이 피연산자의 <a href="expressions/../expressions.html#mutability">가변성</a>에 따라 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 또는 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>DerefMut</code></a>를 구현하는 경우, 필드 접근이 가능하도록 필요한 횟수만큼 _자동으로 역참조_됩니다. 이 과정을 줄여서 _자동 역참조(autoderef)_라고도 합니다.</p>
<div class="rule" id="r-expr.field.borrow"><a class="rule-link" href="expressions/field-expr.html#r-expr.field.borrow" title="expr.field.borrow"><span>[expr<wbr>.field<wbr>.borrow]<span/></a></div>
<h2 id="차용"><a class="header" href="#차용">차용</a></h2>
<p>구조체의 필드 또는 구조체에 대한 참조는 차용 시 별개의 엔티티로 취급됩니다. 구조체가 <a href="expressions/../special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않고 지역 변수에 저장되어 있는 경우, 이는 각 필드에서 이동하는 것에도 적용됩니다. 이는 자동 역참조가 <a href="expressions/../special-types-and-traits.html#boxt"><code>Box</code></a> 이외의 사용자 정의 타입을 통해 수행되는 경우에는 적용되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A { f1: String, f2: String, f3: String }
let mut x: A;
<span class="boring">x = A {
</span><span class="boring">    f1: "f1".to_string(),
</span><span class="boring">    f2: "f2".to_string(),
</span><span class="boring">    f3: "f3".to_string()
</span><span class="boring">};
</span>let a: &amp;mut String = &amp;mut x.f1; // x.f1 가변적으로 차용됨
let b: &amp;String = &amp;x.f2;         // x.f2 불변적으로 차용됨
let c: &amp;String = &amp;x.f2;         // 다시 차용 가능
let d: String = x.f3;           // x.f3에서 이동
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.closure"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure" title="expr.closure"><span>[expr<wbr>.closure]<span/></a></div>
<h1 id="클로저-표현식"><a class="header" href="#클로저-표현식">클로저 표현식</a></h1>
<div class="rule" id="r-expr.closure.syntax"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.syntax" title="expr.closure.syntax"><span>[expr<wbr>.closure<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>클로저표현식</em> :<br />
   <code>async</code><sup class="footnote-reference"><a href="#cl-async-edition">1</a></sup><sup>?</sup><br />
   <code>move</code><sup>?</sup><br />
   ( <code>||</code> | <code>|</code> <em>클로저매개변수</em><sup>?</sup> <code>|</code> )<br />
   (<a href="expressions/../expressions.html"><em>표현식</em></a> | <code>-&gt;</code> <a href="expressions/../types.html#type-expressions"><em>경계없는타입</em></a> <a href="expressions/block-expr.html"><em>블록표현식</em></a>)</p>
<p><em>클로저매개변수</em> :<br />
   <em>클로저인자</em> (<code>,</code> <em>클로저인자</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>클로저인자</em> :<br />
   <a href="expressions/../attributes.html"><em>외부속성</em></a><sup>*</sup> <a href="expressions/../patterns.html"><em>최상위대안없는패턴</em></a> ( <code>:</code> <a href="expressions/../types.html#type-expressions"><em>타입</em></a> )<sup>?</sup></p>
<div class="footnote-definition" id="cl-async-edition"><sup class="footnote-definition-label">1</sup>
<p><code>async</code> 한정자는 2015 에디션에서 허용되지 않습니다.</p>
</div>
</blockquote>
<div class="rule" id="r-expr.closure.intro"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.intro" title="expr.closure.intro"><span>[expr<wbr>.closure<wbr>.intro]<span/></a></div>
<p><em>클로저 표현식</em>(람다 표현식 또는 람다로도 알려짐)은 <a href="expressions/../types/closure.html">클로저 타입</a>을 정의하고 해당 타입의 값으로 평가됩니다. 클로저 표현식의 구문은 선택적인 <code>async</code> 키워드, 선택적인 <code>move</code> 키워드, 그 다음 파이프 기호(<code>|</code>)로 구분된 쉼표로 구분된 <a href="expressions/../patterns.html">패턴</a> 목록(_클로저 매개변수_라고 함, 각 패턴 뒤에는 선택적으로 <code>:</code>와 타입이 올 수 있음), 그 다음 선택적인 <code>-&gt;</code>와 타입(_반환 타입_이라고 함), 그리고 마지막으로 표현식(_클로저 본문 피연산자_라고 함)입니다.</p>
<div class="rule" id="r-expr.closure.param-type"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.param-type" title="expr.closure.param-type"><span>[expr<wbr>.closure<wbr>.param-type]<span/></a></div>
<p>각 패턴 뒤의 선택적 타입은 패턴에 대한 타입 주석입니다.</p>
<div class="rule" id="r-expr.closure.explicit-type-body"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.explicit-type-body" title="expr.closure.explicit-type-body"><span>[expr<wbr>.closure<wbr>.explicit-type-body]<span/></a></div>
<p>반환 타입이 있는 경우 클로저 본문은 <a href="expressions/block-expr.html">블록</a>이어야 합니다.</p>
<div class="rule" id="r-expr.closure.parameter-restriction"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.parameter-restriction" title="expr.closure.parameter-restriction"><span>[expr<wbr>.closure<wbr>.parameter-restriction]<span/></a></div>
<p>클로저 표현식은 매개변수 목록을 매개변수 뒤에 오는 표현식에 매핑하는 함수를 나타냅니다. <a href="expressions/../statements.html#let-statements"><code>let</code> 바인딩</a>과 마찬가지로, 클로저 매개변수는 반박할 수 없는 <a href="expressions/../patterns.html">패턴</a>이며, 타입 주석은 선택 사항이고 주어지지 않은 경우 문맥에서 유추됩니다.</p>
<div class="rule" id="r-expr.closure.unique-type"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.unique-type" title="expr.closure.unique-type"><span>[expr<wbr>.closure<wbr>.unique-type]<span/></a></div>
<p>각 클로저 표현식은 고유하고 익명인 타입을 가집니다.</p>
<div class="rule" id="r-expr.closure.captures"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.captures" title="expr.closure.captures"><span>[expr<wbr>.closure<wbr>.captures]<span/></a></div>
<p>중요한 점은 클로저 표현식이 _환경을 캡처_한다는 것인데, 이는 일반적인 <a href="expressions/../items/functions.html">함수 정의</a>와 다른 점입니다.</p>
<div class="rule" id="r-expr.closure.capture-inference"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.capture-inference" title="expr.closure.capture-inference"><span>[expr<wbr>.closure<wbr>.capture-inference]<span/></a></div>
<p><code>move</code> 키워드가 없으면 클로저 표현식은 <a href="expressions/../types/closure.html#capture-modes">환경에서 각 변수를 캡처하는 방법을 추론</a>하며, 공유 참조로 캡처하는 것을 선호하여 클로저 본문 내에서 언급된 모든 외부 변수를 효과적으로 차용합니다.</p>
<div class="rule" id="r-expr.closure.capture-mut-ref"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.capture-mut-ref" title="expr.closure.capture-mut-ref"><span>[expr<wbr>.closure<wbr>.capture-mut-ref]<span/></a></div>
<p>필요한 경우 컴파일러는 대신 가변 참조를 취하거나, 값(타입에 따라)을 환경에서 이동하거나 복사해야 한다고 추론합니다.</p>
<div class="rule" id="r-expr.closure.capture-move"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.capture-move" title="expr.closure.capture-move"><span>[expr<wbr>.closure<wbr>.capture-move]<span/></a></div>
<p>클로저 앞에 <code>move</code> 키워드를 붙여 값을 복사하거나 이동함으로써 환경을 강제로 캡처하게 할 수 있습니다. 이는 종종 클로저의 라이프타임이 <code>'static</code>임을 보장하기 위해 사용됩니다.</p>
<div class="rule" id="r-expr.closure.trait-impl"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.trait-impl" title="expr.closure.trait-impl"><span>[expr<wbr>.closure<wbr>.trait-impl]<span/></a></div>
<h2 id="클로저-트레잇-구현"><a class="header" href="#클로저-트레잇-구현">클로저 트레잇 구현</a></h2>
<p>클로저 타입이 구현하는 트레잇은 변수가 캡처되는 방식, 캡처된 변수의 타입, 그리고 <code>async</code>의 존재 여부에 따라 달라집니다. 클로저가 <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>를 어떻게 그리고 언제 구현하는지에 대해서는 <a href="expressions/../types/closure.html#call-traits-and-coercions">호출 트레잇 및 강제 변환</a> 장을 참조하십시오. 캡처된 모든 변수의 타입도 해당 트레잇을 구현하는 경우 클로저 타입은 <a href="expressions/../special-types-and-traits.html#send"><code>Send</code></a> 및 <a href="expressions/../special-types-and-traits.html#sync"><code>Sync</code></a>를 구현합니다.</p>
<div class="rule" id="r-expr.closure.async"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.async" title="expr.closure.async"><span>[expr<wbr>.closure<wbr>.async]<span/></a></div>
<h2 id="비동기-클로저"><a class="header" href="#비동기-클로저">비동기 클로저</a></h2>
<div class="rule" id="r-expr.closure.async.intro"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.async.intro" title="expr.closure.async.intro"><span>[expr<wbr>.closure<wbr>.async<wbr>.intro]<span/></a></div>
<p><code>async</code> 키워드로 표시된 클로저는 <a href="expressions/../items/functions.html#r-items.fn.async">비동기 함수</a>와 유사한 방식으로 비동기임을 나타냅니다.</p>
<div class="rule" id="r-expr.closure.async.future"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.async.future" title="expr.closure.async.future"><span>[expr<wbr>.closure<wbr>.async<wbr>.future]<span/></a></div>
<p>비동기 클로저를 호출하면 아무 작업도 수행되지 않는 대신 클로저 본문의 계산에 해당하는 <a href="expressions/../../core/future/future/trait.Future.html"><code>Future</code></a>를 구현하는 값으로 평가됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn takes_async_callback(f: impl AsyncFn(u64)) {
    f(0).await;
    f(1).await;
}

async fn example() {
    takes_async_callback(async |i| {
        core::future::ready(i).await;
        println!("{i} 완료.");
    }).await;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.closure.async.edition2018"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.async.edition2018" title="expr.closure.async.edition2018"><span>[expr<wbr>.closure<wbr>.async<wbr>.edition2018]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 비동기 클로저는 Rust 2018부터 사용할 수 있습니다.</p>
</blockquote>
<h2 id="예시-3"><a class="header" href="#예시-3">예시</a></h2>
<p>이 예제에서는 고차 함수 인수를 받는 함수 <code>ten_times</code>를 정의한 다음, 이를 클로저 표현식을 인수로 호출하고, 그 뒤에 환경에서 값을 이동하는 클로저 표현식을 사용하여 호출합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    for index in 0..10 {
        f(index);
    }
}

ten_times(|j| println!("안녕하세요, {}", j));
// 타입 주석 포함
ten_times(|j: i32| -&gt; () { println!("안녕하세요, {}", j) });

let word = "곤니찌와".to_owned();
ten_times(move |j| println!("{}, {}", word, j));
<span class="boring">}</span></code></pre></pre>
<h2 id="클로저-매개변수의-속성"><a class="header" href="#클로저-매개변수의-속성">클로저 매개변수의 속성</a></h2>
<div class="rule" id="r-expr.closure.param-attributes"><a class="rule-link" href="expressions/closure-expr.html#r-expr.closure.param-attributes" title="expr.closure.param-attributes"><span>[expr<wbr>.closure<wbr>.param-attributes]<span/></a></div>
<p>클로저 매개변수의 속성은 <a href="expressions/../items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제한 사항을 따릅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.loop"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop" title="expr.loop"><span>[expr<wbr>.loop]<span/></a></div>
<h1 id="루프-및-기타-중단-가능한-표현식"><a class="header" href="#루프-및-기타-중단-가능한-표현식">루프 및 기타 중단 가능한 표현식</a></h1>
<div class="rule" id="r-expr.loop.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.syntax" title="expr.loop.syntax"><span>[expr<wbr>.loop<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>루프표현식</em> :<br />
   <a href="expressions/loop-expr.html#loop-labels"><em>루프레이블</em></a><sup>?</sup> (<br />
         <a href="expressions/loop-expr.html#infinite-loops"><em>무한루프표현식</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-loops"><em>조건루프표현식</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-pattern-loops"><em>조건패턴루프표현식</em></a><br />
      | <a href="expressions/loop-expr.html#iterator-loops"><em>반복자루프표현식</em></a><br />
      | <a href="expressions/loop-expr.html#labelled-block-expressions"><em>레이블블록표현식</em></a><br />
   )</p>
</blockquote>
<div class="rule" id="r-expr.loop.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.intro" title="expr.loop.intro"><span>[expr<wbr>.loop<wbr>.intro]<span/></a></div>
<p>Rust는 다섯 가지 루프 표현식을 지원합니다:</p>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops"><code>loop</code> 표현식</a>은 무한 루프를 나타냅니다.</li>
<li><a href="expressions/loop-expr.html#predicate-loops"><code>while</code> 표현식</a>은 조건자가 거짓이 될 때까지 반복합니다.</li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 표현식</a>은 패턴을 검사합니다.</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a>은 반복자에서 값을 추출하여 반복자가 빌 때까지 반복합니다.</li>
<li><a href="expressions/loop-expr.html#labelled-block-expressions">레이블 블록 표현식</a>은 루프를 정확히 한 번 실행하지만 <code>break</code>로 루프를 일찍 종료할 수 있습니다.</li>
</ul>
<div class="rule" id="r-expr.loop.break-label"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break-label" title="expr.loop.break-label"><span>[expr<wbr>.loop<wbr>.break-label]<span/></a></div>
<p>다섯 가지 유형의 루프 모두 <a href="expressions/loop-expr.html#break-expressions"><code>break</code> 표현식</a>과 <a href="expressions/loop-expr.html#loop-labels">레이블</a>을 지원합니다.</p>
<div class="rule" id="r-expr.loop.continue-label"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue-label" title="expr.loop.continue-label"><span>[expr<wbr>.loop<wbr>.continue-label]<span/></a></div>
<p>레이블 블록 표현식을 제외한 모든 루프는 <a href="expressions/loop-expr.html#continue-expressions"><code>continue</code> 표현식</a>을 지원합니다.</p>
<div class="rule" id="r-expr.loop.explicit-result"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.explicit-result" title="expr.loop.explicit-result"><span>[expr<wbr>.loop<wbr>.explicit-result]<span/></a></div>
<p><code>loop</code>와 레이블 블록 표현식만이 <a href="expressions/loop-expr.html#break-and-loop-values">의미 있는 값으로의 평가</a>를 지원합니다.</p>
<div class="rule" id="r-expr.loop.infinite"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.infinite" title="expr.loop.infinite"><span>[expr<wbr>.loop<wbr>.infinite]<span/></a></div>
<h2 id="무한-루프"><a class="header" href="#무한-루프">무한 루프</a></h2>
<div class="rule" id="r-expr.loop.infinite.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.infinite.syntax" title="expr.loop.infinite.syntax"><span>[expr<wbr>.loop<wbr>.infinite<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>무한루프표현식</em> :<br />
   <code>loop</code> <a href="expressions/block-expr.html"><em>블록표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.loop.infinite.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.infinite.intro" title="expr.loop.infinite.intro"><span>[expr<wbr>.loop<wbr>.infinite<wbr>.intro]<span/></a></div>
<p><code>loop</code> 표현식은 본문 실행을 지속적으로 반복합니다: <code>loop { println!("I live."); }</code>.</p>
<div class="rule" id="r-expr.loop.infinite.diverging"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.infinite.diverging" title="expr.loop.infinite.diverging"><span>[expr<wbr>.loop<wbr>.infinite<wbr>.diverging]<span/></a></div>
<p>연관된 <code>break</code> 표현식이 없는 <code>loop</code> 표현식은 발산하며 <a href="expressions/../types/never.html"><code>!</code></a> 타입을 가집니다.</p>
<div class="rule" id="r-expr.loop.infinite.break"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.infinite.break" title="expr.loop.infinite.break"><span>[expr<wbr>.loop<wbr>.infinite<wbr>.break]<span/></a></div>
<p>연관된 <a href="expressions/loop-expr.html#break-expressions"><code>break</code> 표현식(들)</a>을 포함하는 <code>loop</code> 표현식은 종료될 수 있으며, <code>break</code> 표현식(들)의 값과 호환되는 타입을 가져야 합니다.</p>
<div class="rule" id="r-expr.loop.while"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while" title="expr.loop.while"><span>[expr<wbr>.loop<wbr>.while]<span/></a></div>
<h2 id="조건자-루프"><a class="header" href="#조건자-루프">조건자 루프</a></h2>
<div class="rule" id="r-expr.loop.while.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.syntax" title="expr.loop.while.syntax"><span>[expr<wbr>.loop<wbr>.while<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>조건루프표현식</em> :<br />
   <code>while</code> <a href="expressions/../expressions.html"><em>표현식</em></a><sub><em>구조체 표현식 제외</em></sub> <a href="expressions/block-expr.html"><em>블록표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.loop.while.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.intro" title="expr.loop.while.intro"><span>[expr<wbr>.loop<wbr>.while<wbr>.intro]<span/></a></div>
<p><code>while</code> 루프는 <a href="expressions/../types/boolean.html">불리언</a> 루프 조건 피연산자를 평가하는 것으로 시작합니다.</p>
<div class="rule" id="r-expr.loop.while.condition"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.condition" title="expr.loop.while.condition"><span>[expr<wbr>.loop<wbr>.while<wbr>.condition]<span/></a></div>
<p>루프 조건 피연산자가 <code>true</code>로 평가되면 루프 본문 블록이 실행된 다음 제어가 루프 조건 피연산자로 돌아갑니다. 루프 조건 표현식이 <code>false</code>로 평가되면 <code>while</code> 표현식이 완료됩니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;

while i &lt; 10 {
    println!("hello");
    i = i + 1;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.while.let"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let" title="expr.loop.while.let"><span>[expr<wbr>.loop<wbr>.while<wbr>.let]<span/></a></div>
<h2 id="조건-패턴-루프"><a class="header" href="#조건-패턴-루프">조건 패턴 루프</a></h2>
<div class="rule" id="r-expr.loop.while.let.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.syntax" title="expr.loop.while.let.syntax"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<a href="expressions/loop-expr.html#predicate-pattern-loops"><em>조건패턴루프표현식</em></a> :<br />
   <code>while</code> <code>let</code> <a href="expressions/../patterns.html"><em>패턴</em></a> <code>=</code> <a href="expressions/match-expr.html"><em>검사대상</em></a><sub><em>지연 불리언 연산자 표현식 제외</em></sub> <a href="expressions/block-expr.html"><em>블록표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.loop.while.let.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.intro" title="expr.loop.while.let.intro"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.intro]<span/></a></div>
<p><code>while let</code> 루프는 의미상 <code>while</code> 루프와 유사하지만, 조건 표현식 대신 키워드 <code>let</code>, 그 뒤에 패턴, <code>=</code>, <a href="expressions/../glossary.html#scrutinee">검사 대상(scrutinee)</a> 표현식 및 블록 표현식이 옵니다.</p>
<div class="rule" id="r-expr.loop.while.let.condition"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.condition" title="expr.loop.while.let.condition"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.condition]<span/></a></div>
<p>검사 대상의 값이 패턴과 일치하면 루프 본문 블록이 실행된 다음 제어가 패턴 매칭 구문으로 돌아갑니다. 그렇지 않으면 while 표현식이 완료됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = vec![1, 2, 3];

while let Some(y) = x.pop() {
    println!("y = {}", y);
}

while let _ = 5 {
    println!("반박할 수 없는 패턴은 항상 참입니다");
    break;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.while.let.desugar"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.desugar" title="expr.loop.while.let.desugar"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.desugar]<span/></a></div>
<p><code>while let</code> 루프는 다음과 같이 <a href="expressions/match-expr.html"><code>match</code> 표현식</a>을 포함하는 <code>loop</code> 표현식과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: while let PATS = EXPR {
    /* 루프 본문 */
}</code></pre>
<p>다음과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: loop {
    match EXPR {
        PATS =&gt; { /* 루프 본문 */ },
        _ =&gt; break,
    }
}</code></pre>
<div class="rule" id="r-expr.loop.while.let.or-pattern"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.or-pattern" title="expr.loop.while.let.or-pattern"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.or-pattern]<span/></a></div>
<p>여러 패턴을 <code>|</code> 연산자로 지정할 수 있습니다. 이는 <code>match</code> 표현식의 <code>|</code>와 동일한 의미를 갖습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vals = vec![2, 3, 1, 2, 2];
while let Some(v @ 1) | Some(v @ 2) = vals.pop() {
    // 2, 2, 그 다음 1을 출력합니다
    println!("{}", v);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.while.let.lazy-bool"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.while.let.lazy-bool" title="expr.loop.while.let.lazy-bool"><span>[expr<wbr>.loop<wbr>.while<wbr>.let<wbr>.lazy-bool]<span/></a></div>
<p><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code> 표현식</a>의 경우와 마찬가지로, 검사 대상은 <a href="expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 연산자 표현식</a>이 될 수 없습니다.</p>
<div class="rule" id="r-expr.loop.for"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for" title="expr.loop.for"><span>[expr<wbr>.loop<wbr>.for]<span/></a></div>
<h2 id="반복자-루프"><a class="header" href="#반복자-루프">반복자 루프</a></h2>
<div class="rule" id="r-expr.loop.for.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for.syntax" title="expr.loop.for.syntax"><span>[expr<wbr>.loop<wbr>.for<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>반복자루프표현식</em> :<br />
   <code>for</code> <a href="expressions/../patterns.html"><em>패턴</em></a> <code>in</code> <a href="expressions/../expressions.html"><em>표현식</em></a><sub><em>구조체 표현식 제외</em></sub> <a href="expressions/block-expr.html"><em>블록표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.loop.for.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for.intro" title="expr.loop.for.intro"><span>[expr<wbr>.loop<wbr>.for<wbr>.intro]<span/></a></div>
<p><code>for</code> 표현식은 <code>std::iter::IntoIterator</code> 구현에서 제공하는 요소를 반복하기 위한 구문 구조입니다.</p>
<div class="rule" id="r-expr.loop.for.condition"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for.condition" title="expr.loop.for.condition"><span>[expr<wbr>.loop<wbr>.for<wbr>.condition]<span/></a></div>
<p>반복자가 값을 산출하면 해당 값은 반박할 수 없는 패턴과 매칭되고 루프 본문이 실행된 다음 제어가 <code>for</code> 루프의 헤드로 돌아갑니다. 반복자가 비어 있으면 <code>for</code> 표현식이 완료됩니다.</p>
<p>배열의 내용에 대한 <code>for</code> 루프의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = &amp;["사과", "케이크", "커피"];

for text in v {
    println!("저는 {}를 좋아합니다.", text);
}
<span class="boring">}</span></code></pre></pre>
<p>일련의 정수에 대한 for 루프의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for n in 1..11 {
    sum += n;
}
assert_eq!(sum, 55);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.for.desugar"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for.desugar" title="expr.loop.for.desugar"><span>[expr<wbr>.loop<wbr>.for<wbr>.desugar]<span/></a></div>
<p><code>for</code> 루프는 다음과 같이 <a href="expressions/match-expr.html"><code>match</code> 표현식</a>을 포함하는 <code>loop</code> 표현식과 동일합니다:</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: for PATTERN in iter_expr {
    /* 루프 본문 */
}</code></pre>
<p>다음과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">{
    let result = match IntoIterator::into_iter(iter_expr) {
        mut iter =&gt; 'label: loop {
            let mut next;
            match Iterator::next(&amp;mut iter) {
                Option::Some(val) =&gt; next = val,
                Option::None =&gt; break,
            };
            let PATTERN = next;
            let () = { /* 루프 본문 */ };
        },
    };
    result
}</code></pre>
<div class="rule" id="r-expr.loop.for.lang-items"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.for.lang-items" title="expr.loop.for.lang-items"><span>[expr<wbr>.loop<wbr>.for<wbr>.lang-items]<span/></a></div>
<p>여기서 <code>IntoIterator</code>, <code>Iterator</code>, <code>Option</code>은 현재 스코프에서 해당 이름이 무엇으로 확인되든 상관없이 항상 표준 라이브러리 항목입니다.</p>
<p>변수 이름 <code>next</code>, <code>iter</code>, <code>val</code>은 설명용일 뿐이며, 실제로 사용자가 입력할 수 있는 이름은 아닙니다.</p>
<blockquote>
<p><strong>참고</strong>: 외부 <code>match</code>는 <code>iter_expr</code>의 <a href="expressions/../expressions.html#temporaries">임시 값</a>이 루프가 끝나기 전에 드랍되지 않도록 하는 데 사용됩니다. <code>next</code>는 할당되기 전에 선언되는데, 이는 타입이 더 자주 올바르게 추론되도록 하기 때문입니다.</p>
</blockquote>
<div class="rule" id="r-expr.loop.label"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.label" title="expr.loop.label"><span>[expr<wbr>.loop<wbr>.label]<span/></a></div>
<h2 id="루프-레이블"><a class="header" href="#루프-레이블">루프 레이블</a></h2>
<div class="rule" id="r-expr.loop.label.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.label.syntax" title="expr.loop.label.syntax"><span>[expr<wbr>.loop<wbr>.label<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>루프레이블</em> :<br />
   <a href="expressions/../tokens.html#lifetimes-and-loop-labels">라이프타임_또는_레이블</a> <code>:</code></p>
</blockquote>
<div class="rule" id="r-expr.loop.label.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.label.intro" title="expr.loop.label.intro"><span>[expr<wbr>.loop<wbr>.label<wbr>.intro]<span/></a></div>
<p>루프 표현식은 선택적으로 _레이블_을 가질 수 있습니다. 레이블은 <code>'foo: loop { break 'foo; }</code>, <code>'bar: while false {}</code>, <code>'humbug: for _ in 0..0 {}</code>과 같이 루프 표현식 앞에 라이프타임으로 작성됩니다.</p>
<div class="rule" id="r-expr.loop.label.control-flow"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.label.control-flow" title="expr.loop.label.control-flow"><span>[expr<wbr>.loop<wbr>.label<wbr>.control-flow]<span/></a></div>
<p>레이블이 있는 경우, 이 루프 내에 중첩된 레이블이 있는 <code>break</code> 및 <code>continue</code> 표현식은 이 루프를 빠져나가거나 제어를 루프 헤드로 반환할 수 있습니다. <a href="expressions/loop-expr.html#break-expressions">break 표현식</a> 및 <a href="expressions/loop-expr.html#continue-expressions">continue 표현식</a>을 참조하십시오.</p>
<div class="rule" id="r-expr.loop.label.ref"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.label.ref" title="expr.loop.label.ref"><span>[expr<wbr>.loop<wbr>.label<wbr>.ref]<span/></a></div>
<p>레이블은 지역 변수의 위생(hygiene) 및 섀도잉 규칙을 따릅니다. 예를 들어, 이 코드는 “outer loop“를 출력합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    'a: loop {
        break 'a;
    }
    print!("outer loop");
    break 'a;
}
<span class="boring">}</span></code></pre></pre>
<p><code>'_</code>는 유효한 루프 레이블이 아닙니다.</p>
<div class="rule" id="r-expr.loop.break"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break" title="expr.loop.break"><span>[expr<wbr>.loop<wbr>.break]<span/></a></div>
<h2 id="break-표현식"><a class="header" href="#break-표현식"><code>break</code> 표현식</a></h2>
<div class="rule" id="r-expr.loop.break.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break.syntax" title="expr.loop.break.syntax"><span>[expr<wbr>.loop<wbr>.break<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>중단표현식</em> :<br />
   <code>break</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">라이프타임_또는_레이블</a><sup>?</sup> <a href="expressions/../expressions.html"><em>표현식</em></a><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.loop.break.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break.intro" title="expr.loop.break.intro"><span>[expr<wbr>.loop<wbr>.break<wbr>.intro]<span/></a></div>
<p><code>break</code>를 만나면 연관된 루프 본문의 실행이 즉시 종료됩니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut last = 0;
for x in 1..100 {
    if x &gt; 12 {
        break;
    }
    last = x;
}
assert_eq!(last, 12);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.break.label"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break.label" title="expr.loop.break.label"><span>[expr<wbr>.loop<wbr>.break<wbr>.label]<span/></a></div>
<p><code>break</code> 표현식은 일반적으로 <code>break</code> 표현식을 감싸는 가장 안쪽의 <code>loop</code>, <code>for</code> 또는 <code>while</code> 루프와 연관되지만, <a href="expressions/loop-expr.html#loop-labels">레이블</a>을 사용하여 영향을 받는 둘러싸는 루프를 지정할 수 있습니다. 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    while true {
        break 'outer;
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.break.value"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break.value" title="expr.loop.break.value"><span>[expr<wbr>.loop<wbr>.break<wbr>.value]<span/></a></div>
<p><code>break</code> 표현식은 루프 본문에서만 허용되며, <code>break</code>, <code>break 'label</code> 또는 (<a href="expressions/loop-expr.html#break-and-loop-values">아래 참조</a>) <code>break EXPR</code> 또는 <code>break 'label EXPR</code> 중 하나의 형식을 가집니다.</p>
<div class="rule" id="r-expr.loop.block-labels"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.block-labels" title="expr.loop.block-labels"><span>[expr<wbr>.loop<wbr>.block-labels]<span/></a></div>
<h2 id="레이블이-붙은-블록-표현식-1"><a class="header" href="#레이블이-붙은-블록-표현식-1">레이블이 붙은 블록 표현식</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>레이블블록표현식</em> :<br />
   <a href="expressions/block-expr.html"><em>블록표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.loop.block-labels.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.block-labels.intro" title="expr.loop.block-labels.intro"><span>[expr<wbr>.loop<wbr>.block-labels<wbr>.intro]<span/></a></div>
<p>레이블 블록 표현식은 블록 내에서 <code>break</code> 표현식을 사용할 수 있다는 점을 제외하고는 블록 표현식과 정확히 같습니다.</p>
<div class="rule" id="r-expr.loop.block-labels.break"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.block-labels.break" title="expr.loop.block-labels.break"><span>[expr<wbr>.loop<wbr>.block-labels<wbr>.break]<span/></a></div>
<p>루프와 달리, 레이블 블록 표현식 내의 <code>break</code> 표현식은 <em>반드시</em> 레이블을 가져야 합니다(즉, 레이블은 선택 사항이 아닙니다).</p>
<div class="rule" id="r-expr.loop.block-labels.label-required"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.block-labels.label-required" title="expr.loop.block-labels.label-required"><span>[expr<wbr>.loop<wbr>.block-labels<wbr>.label-required]<span/></a></div>
<p>마찬가지로, 레이블 블록 표현식은 <em>반드시</em> 레이블로 시작해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn do_thing() {}
</span><span class="boring">fn condition_not_met() -&gt; bool { true }
</span><span class="boring">fn do_next_thing() {}
</span><span class="boring">fn do_last_thing() {}
</span>let result = 'block: {
    do_thing();
    if condition_not_met() {
        break 'block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break 'block 2;
    }
    do_last_thing();
    3
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.continue"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue" title="expr.loop.continue"><span>[expr<wbr>.loop<wbr>.continue]<span/></a></div>
<h2 id="continue-표현식"><a class="header" href="#continue-표현식"><code>continue</code> 표현식</a></h2>
<div class="rule" id="r-expr.loop.continue.syntax"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.syntax" title="expr.loop.continue.syntax"><span>[expr<wbr>.loop<wbr>.continue<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>계속표현식</em> :<br />
   <code>continue</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">라이프타임_또는_레이블</a><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.loop.continue.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.intro" title="expr.loop.continue.intro"><span>[expr<wbr>.loop<wbr>.continue<wbr>.intro]<span/></a></div>
<p><code>continue</code>를 만나면 연관된 루프 본문의 현재 반복이 즉시 종료되고, 제어가 루프 _헤드_로 반환됩니다.</p>
<div class="rule" id="r-expr.loop.continue.while"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.while" title="expr.loop.continue.while"><span>[expr<wbr>.loop<wbr>.continue<wbr>.while]<span/></a></div>
<p><code>while</code> 루프의 경우, 헤드는 루프를 제어하는 조건 표현식입니다.</p>
<div class="rule" id="r-expr.loop.continue.for"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.for" title="expr.loop.continue.for"><span>[expr<wbr>.loop<wbr>.continue<wbr>.for]<span/></a></div>
<p><code>for</code> 루프의 경우, 헤드는 루프를 제어하는 호출 표현식입니다.</p>
<div class="rule" id="r-expr.loop.continue.label"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.label" title="expr.loop.continue.label"><span>[expr<wbr>.loop<wbr>.continue<wbr>.label]<span/></a></div>
<p><code>break</code>와 마찬가지로, <code>continue</code>는 일반적으로 가장 안쪽의 둘러싸는 루프와 연관되지만, <code>continue 'label</code>을 사용하여 영향을 받는 루프를 지정할 수 있습니다.</p>
<div class="rule" id="r-expr.loop.continue.in-loop-only"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.continue.in-loop-only" title="expr.loop.continue.in-loop-only"><span>[expr<wbr>.loop<wbr>.continue<wbr>.in-loop-only]<span/></a></div>
<p><code>continue</code> 표현식은 루프 본문에서만 허용됩니다.</p>
<div class="rule" id="r-expr.loop.break-value"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break-value" title="expr.loop.break-value"><span>[expr<wbr>.loop<wbr>.break-value]<span/></a></div>
<h2 id="break와-루프-값"><a class="header" href="#break와-루프-값"><code>break</code>와 루프 값</a></h2>
<div class="rule" id="r-expr.loop.break-value.intro"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break-value.intro" title="expr.loop.break-value.intro"><span>[expr<wbr>.loop<wbr>.break-value<wbr>.intro]<span/></a></div>
<p>When associated with a <code>loop</code>, a break expression may be used to return a value from that loop, via one of the forms <code>break EXPR</code> or <code>break 'label EXPR</code>, where <code>EXPR</code> is an expression whose result is returned from the <code>loop</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (1, 1);
let result = loop {
    if b &gt; 10 {
        break b;
    }
    let c = a + b;
    a = b;
    b = c;
};
// 피보나치 수열에서 10을 넘는 첫 번째 수:
assert_eq!(result, 13);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.loop.break-value.loop"><a class="rule-link" href="expressions/loop-expr.html#r-expr.loop.break-value.loop" title="expr.loop.break-value.loop"><span>[expr<wbr>.loop<wbr>.break-value<wbr>.loop]<span/></a></div>
<p><code>loop</code>에 연관된 <code>break</code>가 있는 경우 발산하는 것으로 간주되지 않으며, <code>loop</code>는 각 <code>break</code> 표현식과 호환되는 타입을 가져야 합니다. 표현식이 없는 <code>break</code>는 표현식 <code>()</code>가 있는 <code>break</code>와 동일한 것으로 간주됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.range"><a class="rule-link" href="expressions/range-expr.html#r-expr.range" title="expr.range"><span>[expr<wbr>.range]<span/></a></div>
<h1 id="범위-표현식"><a class="header" href="#범위-표현식">범위 표현식</a></h1>
<div class="rule" id="r-expr.range.syntax"><a class="rule-link" href="expressions/range-expr.html#r-expr.range.syntax" title="expr.range.syntax"><span>[expr<wbr>.range<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>범위표현식</em> :<br />
      <em>범위표현식</em><br />
   | <em>시작범위표현식</em><br />
   | <em>끝범위표현식</em><br />
   | <em>전체범위표현식</em><br />
   | <em>포함범위표현식</em><br />
   | <em>끝포함범위표현식</em></p>
<p><em>범위표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>..</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
<p><em>시작범위표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>..</code></p>
<p><em>끝범위표현식</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
<p><em>전체범위표현식</em> :<br />
   <code>..</code></p>
<p><em>포함범위표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>..=</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
<p><em>끝포함범위표현식</em> :<br />
   <code>..=</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.range.behavior"><a class="rule-link" href="expressions/range-expr.html#r-expr.range.behavior" title="expr.range.behavior"><span>[expr<wbr>.range<wbr>.behavior]<span/></a></div>
<p><code>..</code> 및 <code>..=</code> 연산자는 다음 표에 따라 <code>std::ops::Range</code>(또는 <code>core::ops::Range</code>) 변형 중 하나의 객체를 생성합니다:</p>
<div class="table-wrapper"><table><thead><tr><th>생성</th><th>구문</th><th>유형</th><th>범위</th></tr></thead><tbody>
<tr><td><em>범위표현식</em></td><td>start<code>..</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.Range.html">std::ops::Range</a></td><td>start ≤ x &lt; end</td></tr>
<tr><td><em>시작범위표현식</em></td><td>start<code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFrom.html">std::ops::RangeFrom</a></td><td>start ≤ x</td></tr>
<tr><td><em>끝범위표현식</em></td><td><code>..</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeTo.html">std::ops::RangeTo</a></td><td>x &lt; end</td></tr>
<tr><td><em>전체범위표현식</em></td><td><code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFull.html">std::ops::RangeFull</a></td><td>-</td></tr>
<tr><td><em>포함범위표현식</em></td><td>start<code>..=</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html">std::ops::RangeInclusive</a></td><td>start ≤ x ≤ end</td></tr>
<tr><td><em>끝포함범위표현식</em></td><td><code>..=</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html">std::ops::RangeToInclusive</a></td><td>x ≤ end</td></tr>
</tbody></table>
</div>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.range.equivalence"><a class="rule-link" href="expressions/range-expr.html#r-expr.range.equivalence" title="expr.range.equivalence"><span>[expr<wbr>.range<wbr>.equivalence]<span/></a></div>
<p>다음 표현식들은 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.range.for"><a class="rule-link" href="expressions/range-expr.html#r-expr.range.for" title="expr.range.for"><span>[expr<wbr>.range<wbr>.for]<span/></a></div>
<p>범위는 <code>for</code> 루프에서 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..11 {
    println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.if"><a class="rule-link" href="expressions/if-expr.html#r-expr.if" title="expr.if"><span>[expr<wbr>.if]<span/></a></div>
<h1 id="if-및-if-let-표현식"><a class="header" href="#if-및-if-let-표현식"><code>if</code> 및 <code>if let</code> 표현식</a></h1>
<h2 id="if-표현식"><a class="header" href="#if-표현식"><code>if</code> 표현식</a></h2>
<div class="rule" id="r-expr.if.syntax"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.syntax" title="expr.if.syntax"><span>[expr<wbr>.if<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>If표현식</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>표현식</em></a><sub><em>구조체 표현식 제외</em></sub> <a href="expressions/block-expr.html"><em>블록표현식</em></a><br />
   (<code>else</code> ( <a href="expressions/block-expr.html"><em>블록표현식</em></a> | <em>If표현식</em> | <em>IfLet표현식</em> ) )<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.if.intro"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.intro" title="expr.if.intro"><span>[expr<wbr>.if<wbr>.intro]<span/></a></div>
<p><code>if</code> 표현식은 프로그램 제어의 조건부 분기입니다. <code>if</code> 표현식의 구문은 조건 피연산자, 그 뒤에 오는 결과 블록, 임의의 수의 <code>else if</code> 조건 및 블록, 그리고 선택적 후행 <code>else</code> 블록입니다.</p>
<div class="rule" id="r-expr.if.condition-bool"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.condition-bool" title="expr.if.condition-bool"><span>[expr<wbr>.if<wbr>.condition-bool]<span/></a></div>
<p>조건 피연산자는 <a href="expressions/../types/boolean.html">불리언 타입</a>이어야 합니다.</p>
<div class="rule" id="r-expr.if.condition-true"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.condition-true" title="expr.if.condition-true"><span>[expr<wbr>.if<wbr>.condition-true]<span/></a></div>
<p>조건 피연산자가 <code>true</code>로 평가되면 결과 블록이 실행되고 후속 <code>else if</code> 또는 <code>else</code> 블록은 건너뜁니다.</p>
<div class="rule" id="r-expr.if.else-if"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.else-if" title="expr.if.else-if"><span>[expr<wbr>.if<wbr>.else-if]<span/></a></div>
<p>조건 피연산자가 <code>false</code>로 평가되면 결과 블록은 건너뛰고 후속 <code>else if</code> 조건이 평가됩니다.</p>
<div class="rule" id="r-expr.if.else"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.else" title="expr.if.else"><span>[expr<wbr>.if<wbr>.else]<span/></a></div>
<p>모든 <code>if</code> 및 <code>else if</code> 조건이 <code>false</code>로 평가되면 <code>else</code> 블록이 실행됩니다.</p>
<div class="rule" id="r-expr.if.result"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.result" title="expr.if.result"><span>[expr<wbr>.if<wbr>.result]<span/></a></div>
<p>if 표현식은 실행된 블록과 동일한 값으로 평가되거나, 어떤 블록도 평가되지 않으면 <code>()</code>로 평가됩니다.</p>
<div class="rule" id="r-expr.if.type"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.type" title="expr.if.type"><span>[expr<wbr>.if<wbr>.type]<span/></a></div>
<p><code>if</code> 표현식은 모든 상황에서 동일한 타입을 가져야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 3;
</span>if x == 4 {
    println!("x는 4");
} else if x == 3 {
    println!("x는 3");
} else {
    println!("x는 다른 것");
}

let y = if 12 * 15 &gt; 150 {
    "더 큼"
} else {
    "더 작음"
};
assert_eq!(y, "더 큼");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.if.let"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let" title="expr.if.let"><span>[expr<wbr>.if<wbr>.let]<span/></a></div>
<h2 id="if-let-표현식"><a class="header" href="#if-let-표현식"><code>if let</code> 표현식</a></h2>
<div class="rule" id="r-expr.if.let.syntax"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.syntax" title="expr.if.let.syntax"><span>[expr<wbr>.if<wbr>.let<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>IfLet표현식</em> :<br />
   <code>if</code> <code>let</code> <a href="expressions/../patterns.html"><em>패턴</em></a> <code>=</code> <a href="expressions/match-expr.html"><em>검사대상</em></a><sub><em>지연 불리언 연산자 표현식 제외</em></sub> <a href="expressions/block-expr.html"><em>블록표현식</em></a><br />
   (<code>else</code> ( <a href="expressions/block-expr.html"><em>블록표현식</em></a> | <em>If표현식</em> | <em>IfLet표현식</em> ) )<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.if.let.intro"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.intro" title="expr.if.let.intro"><span>[expr<wbr>.if<wbr>.let<wbr>.intro]<span/></a></div>
<p><code>if let</code> 표현식은 의미상 <code>if</code> 표현식과 유사하지만, 조건 피연산자 대신 키워드 <code>let</code>, 그 뒤에 패턴, <code>=</code> 그리고 <a href="expressions/../glossary.html#scrutinee">검사 대상(scrutinee)</a> 피연산자가 옵니다.</p>
<div class="rule" id="r-expr.if.let.pattern"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.pattern" title="expr.if.let.pattern"><span>[expr<wbr>.if<wbr>.let<wbr>.pattern]<span/></a></div>
<p>검사 대상의 값이 패턴과 일치하면 해당 블록이 실행됩니다.</p>
<div class="rule" id="r-expr.if.let.else"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.else" title="expr.if.let.else"><span>[expr<wbr>.if<wbr>.let<wbr>.else]<span/></a></div>
<p>그렇지 않으면 흐름은 다음 <code>else</code> 블록(있는 경우)으로 진행됩니다.</p>
<div class="rule" id="r-expr.if.let.result"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.result" title="expr.if.let.result"><span>[expr<wbr>.if<wbr>.let<wbr>.result]<span/></a></div>
<p><code>if</code> 표현식과 마찬가지로 <code>if let</code> 표현식은 평가되는 블록에 의해 결정되는 값을 가집니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dish = ("햄", "달걀");

// 패턴이 반박되므로 이 본문은 건너뜁니다
if let ("베이컨", b) = dish {
    println!("베이컨은 {}와(과) 함께 제공됩니다", b);
} else {
    // 대신 이 블록이 평가됩니다.
    println!("베이컨은 제공되지 않습니다");
}

// 이 본문이 실행됩니다
if let ("햄", b) = dish {
    println!("햄은 {}와(과) 함께 제공됩니다", b);
}

if let _ = 5 {
    println!("반박할 수 없는 패턴은 항상 참입니다");
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.if.let.else-if"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.else-if" title="expr.if.let.else-if"><span>[expr<wbr>.if<wbr>.let<wbr>.else-if]<span/></a></div>
<p><code>if</code> 및 <code>if let</code> 표현식을 섞어 쓸 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(3);
let a = if let Some(1) = x {
    1
} else if x == Some(2) {
    2
} else if let Some(y) = x {
    y
} else {
    -1
};
assert_eq!(a, 3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.if.let.desugaring"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.desugaring" title="expr.if.let.desugaring"><span>[expr<wbr>.if<wbr>.let<wbr>.desugaring]<span/></a></div>
<p><code>if let</code> 표현식은 다음과 같이 <a href="expressions/match-expr.html"><code>match</code> 표현식</a>과 동일합니다:</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">if let PATS = EXPR {
    /* 본문 */
} else {
    /* else */
}</code></pre>
<p>다음과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">match EXPR {
    PATS =&gt; { /* 본문 */ },
    _ =&gt; { /* else */ },    // else가 없으면 ()
}</code></pre>
<div class="rule" id="r-expr.if.let.or-pattern"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.or-pattern" title="expr.if.let.or-pattern"><span>[expr<wbr>.if<wbr>.let<wbr>.or-pattern]<span/></a></div>
<p>여러 패턴을 <code>|</code> 연산자로 지정할 수 있습니다. 이는 <code>match</code> 표현식의 <code>|</code>와 동일한 의미를 갖습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    X(u8),
    Y(u8),
    Z(u8),
}
let v = E::Y(12);
if let E::X(n) | E::Y(n) = v {
    assert_eq!(n, 12);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.if.let.lazy-bool"><a class="rule-link" href="expressions/if-expr.html#r-expr.if.let.lazy-bool" title="expr.if.let.lazy-bool"><span>[expr<wbr>.if<wbr>.let<wbr>.lazy-bool]<span/></a></div>
<p>표현식은 <a href="expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 연산자 표현식</a>이 될 수 없습니다. 지연 불리언 연산자의 사용은 언어의 계획된 기능 변경(if-let 체인의 구현 - <a href="https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018">eRFC 2947</a> 참조)과 모호합니다. 지연 불리언 연산자 표현식을 사용하려면 다음과 같이 괄호를 사용하여 달성할 수 있습니다:</p>
<!-- ignore: pseudo code -->
<pre><code class="language-rust ignore">// 전...
if let PAT = EXPR &amp;&amp; EXPR { .. }

// 후...
if let PAT = ( EXPR &amp;&amp; EXPR ) { .. }

// 전...
if let PAT = EXPR || EXPR { .. }

// 후...
if let PAT = ( EXPR || EXPR ) { .. }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.match"><a class="rule-link" href="expressions/match-expr.html#r-expr.match" title="expr.match"><span>[expr<wbr>.match]<span/></a></div>
<h1 id="match-표현식"><a class="header" href="#match-표현식"><code>match</code> 표현식</a></h1>
<div class="rule" id="r-expr.match.syntax"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.syntax" title="expr.match.syntax"><span>[expr<wbr>.match<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Match표현식</em> :<br />
   <code>match</code> <em>검사대상</em> <code>{</code><br />
      <a href="expressions/../attributes.html"><em>내부속성</em></a><sup>*</sup><br />
      <em>Match분기</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>검사대상</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a><sub><em>구조체 표현식 제외</em></sub></p>
<p><em>Match분기</em> :<br />
   ( <em>Match분기항목</em> <code>=&gt;</code> ( <a href="expressions/../expressions.html"><em>블록없는표현식</em></a> <code>,</code> | <a href="expressions/../expressions.html"><em>블록있는표현식</em></a> <code>,</code><sup>?</sup> ) )<sup>*</sup><br />
   <em>Match분기항목</em> <code>=&gt;</code> <a href="expressions/../expressions.html"><em>표현식</em></a> <code>,</code><sup>?</sup></p>
<p><em>Match분기항목</em> :<br />
   <a href="expressions/../attributes.html"><em>외부속성</em></a><sup>*</sup> <a href="expressions/../patterns.html"><em>패턴</em></a> <em>Match분기가드</em><sup>?</sup></p>
<p><em>Match분기가드</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.match.intro"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.intro" title="expr.match.intro"><span>[expr<wbr>.match<wbr>.intro]<span/></a></div>
<p>_<code>match</code> 표현식_은 패턴에 따라 분기합니다. 발생하는 매칭의 정확한 형태는 <a href="expressions/../patterns.html">패턴</a>에 따라 다릅니다.</p>
<div class="rule" id="r-expr.match.scrutinee"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.scrutinee" title="expr.match.scrutinee"><span>[expr<wbr>.match<wbr>.scrutinee]<span/></a></div>
<p><code>match</code> 표현식에는 패턴과 비교할 값인 _<a href="expressions/../glossary.html#scrutinee">검사 대상</a> 표현식_이 있습니다.</p>
<div class="rule" id="r-expr.match.scrutinee-constraint"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.scrutinee-constraint" title="expr.match.scrutinee-constraint"><span>[expr<wbr>.match<wbr>.scrutinee-constraint]<span/></a></div>
<p>검사 대상 표현식과 패턴은 동일한 타입을 가져야 합니다.</p>
<div class="rule" id="r-expr.match.scrutinee-behavior"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.scrutinee-behavior" title="expr.match.scrutinee-behavior"><span>[expr<wbr>.match<wbr>.scrutinee-behavior]<span/></a></div>
<p><code>match</code>는 검사 대상 표현식이 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식인지 값 표현식인지</a>에 따라 다르게 동작합니다.</p>
<div class="rule" id="r-expr.match.scrutinee-value"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.scrutinee-value" title="expr.match.scrutinee-value"><span>[expr<wbr>.match<wbr>.scrutinee-value]<span/></a></div>
<p>검사 대상 표현식이 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>인 경우, 먼저 임시 위치로 평가되고, 결과 값은 일치하는 항목을 찾을 때까지 분기의 패턴과 순차적으로 비교됩니다. 일치하는 패턴이 있는 첫 번째 분기가 <code>match</code>의 분기 대상으로 선택되고, 패턴에 의해 바인딩된 모든 변수는 분기 블록의 지역 변수에 할당되며, 제어가 블록으로 들어갑니다.</p>
<div class="rule" id="r-expr.match.scrutinee-place"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.scrutinee-place" title="expr.match.scrutinee-place"><span>[expr<wbr>.match<wbr>.scrutinee-place]<span/></a></div>
<p>검사 대상 표현식이 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>인 경우, 매치는 임시 위치를 할당하지 않습니다. 그러나 값에 의한 바인딩은 메모리 위치에서 복사하거나 이동할 수 있습니다. 가능한 경우 장소 표현식에 대해 매칭하는 것이 바람직한데, 이러한 매칭의 라이프타임은 매치 내부로 제한되지 않고 장소 표현식의 라이프타임을 상속하기 때문입니다.</p>
<p><code>match</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!("하나"),
    2 =&gt; println!("둘"),
    3 =&gt; println!("셋"),
    4 =&gt; println!("넷"),
    5 =&gt; println!("다섯"),
    _ =&gt; println!("그 외의 것"),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.match.pattern-vars"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.pattern-vars" title="expr.match.pattern-vars"><span>[expr<wbr>.match<wbr>.pattern-vars]<span/></a></div>
<p>패턴 내에 바인딩된 변수의 스코프는 매치 가드와 분기의 표현식으로 제한됩니다.</p>
<div class="rule" id="r-expr.match.pattern-var-binding"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.pattern-var-binding" title="expr.match.pattern-var-binding"><span>[expr<wbr>.match<wbr>.pattern-var-binding]<span/></a></div>
<p><a href="expressions/../patterns.html#binding-modes">바인딩 모드</a>(이동, 복사 또는 참조)는 패턴에 따라 다릅니다.</p>
<div class="rule" id="r-expr.match.or-pattern"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.or-pattern" title="expr.match.or-pattern"><span>[expr<wbr>.match<wbr>.or-pattern]<span/></a></div>
<p>여러 매치 패턴을 <code>|</code> 연산자로 결합할 수 있습니다. 성공적인 매치를 찾을 때까지 각 패턴을 왼쪽에서 오른쪽 순서로 테스트합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 9;
let message = match x {
    0 | 1  =&gt; "많지 않음",
    2 ..= 9 =&gt; "약간",
    _      =&gt; "많음"
};

assert_eq!(message, "약간");

// 패턴 매칭 순서 예시.
struct S(i32, i32);

match S(1, 2) {
    S(z @ 1, _) | S(_, z @ 2) =&gt; assert_eq!(z, 1),
    _ =&gt; panic!(),
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>2..=9</code>는 <a href="expressions/range-expr.html">범위 표현식</a>이 아니라 <a href="expressions/../patterns.html#range-patterns">범위 패턴</a>입니다. 따라서 범위 패턴에서 지원하는 범위 타입만 매치 분기에서 사용할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-expr.match.or-patterns-restriction"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.or-patterns-restriction" title="expr.match.or-patterns-restriction"><span>[expr<wbr>.match<wbr>.or-patterns-restriction]<span/></a></div>
<p>각 <code>|</code>로 구분된 패턴의 모든 바인딩은 분기의 모든 패턴에 나타나야 합니다.</p>
<div class="rule" id="r-expr.match.binding-restriction"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.binding-restriction" title="expr.match.binding-restriction"><span>[expr<wbr>.match<wbr>.binding-restriction]<span/></a></div>
<p>동일한 이름의 모든 바인딩은 동일한 타입과 동일한 바인딩 모드를 가져야 합니다.</p>
<div class="rule" id="r-expr.match.guard"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard" title="expr.match.guard"><span>[expr<wbr>.match<wbr>.guard]<span/></a></div>
<h2 id="매치-가드"><a class="header" href="#매치-가드">매치 가드</a></h2>
<div class="rule" id="r-expr.match.guard.intro"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.intro" title="expr.match.guard.intro"><span>[expr<wbr>.match<wbr>.guard<wbr>.intro]<span/></a></div>
<p>매치 분기는 케이스 일치 기준을 더 구체화하기 위해 _매치 가드_를 허용할 수 있습니다.</p>
<div class="rule" id="r-expr.match.guard.type"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.type" title="expr.match.guard.type"><span>[expr<wbr>.match<wbr>.guard<wbr>.type]<span/></a></div>
<p>패턴 가드는 패턴 뒤에 나타나며 <code>if</code> 키워드 뒤에 오는 <code>bool</code> 타입 표현식으로 구성됩니다.</p>
<div class="rule" id="r-expr.match.guard.behavior"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.behavior" title="expr.match.guard.behavior"><span>[expr<wbr>.match<wbr>.guard<wbr>.behavior]<span/></a></div>
<p>패턴이 성공적으로 일치하면 패턴 가드 표현식이 실행됩니다. 표현식이 참으로 평가되면 패턴이 성공적으로 일치한 것입니다.</p>
<div class="rule" id="r-expr.match.guard.next"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.next" title="expr.match.guard.next"><span>[expr<wbr>.match<wbr>.guard<wbr>.next]<span/></a></div>
<p>그렇지 않으면, 동일한 분기의 <code>|</code> 연산자를 사용한 다른 일치 항목을 포함하여 다음 패턴이 테스트됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let maybe_digit = Some(0);
</span><span class="boring">fn process_digit(i: i32) { }
</span><span class="boring">fn process_other(i: i32) { }
</span>let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>|</code> 연산자를 사용한 다중 매치는 패턴 가드와 그 부작용을 여러 번 실행하게 할 수 있습니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span>let i : Cell&lt;i32&gt; = Cell::new(0);
match 1 {
    1 | _ if { i.set(i.get() + 1); false } =&gt; {}
    _ =&gt; {}
}
assert_eq!(i.get(), 2);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-expr.match.guard.bound-variables"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.bound-variables" title="expr.match.guard.bound-variables"><span>[expr<wbr>.match<wbr>.guard<wbr>.bound-variables]<span/></a></div>
<p>패턴 가드는 뒤따르는 패턴 내에 바인딩된 변수를 참조할 수 있습니다.</p>
<div class="rule" id="r-expr.match.guard.shared-ref"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.shared-ref" title="expr.match.guard.shared-ref"><span>[expr<wbr>.match<wbr>.guard<wbr>.shared-ref]<span/></a></div>
<p>가드를 평가하기 전에, 변수가 일치하는 검사 대상의 부분에 대한 공유 참조가 취해집니다. 가드를 평가하는 동안 변수에 접근할 때 이 공유 참조가 사용됩니다.</p>
<div class="rule" id="r-expr.match.guard.value"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.value" title="expr.match.guard.value"><span>[expr<wbr>.match<wbr>.guard<wbr>.value]<span/></a></div>
<p>가드가 참으로 평가될 때만 값이 검사 대상에서 변수로 이동되거나 복사됩니다. 이를 통해 가드가 일치에 실패할 경우 검사 대상에서 이동하지 않고도 가드 내부에서 공유 참조를 사용할 수 있습니다.</p>
<div class="rule" id="r-expr.match.guard.no-mutation"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.guard.no-mutation" title="expr.match.guard.no-mutation"><span>[expr<wbr>.match<wbr>.guard<wbr>.no-mutation]<span/></a></div>
<p>게다가, 가드를 평가하는 동안 공유 참조를 유지함으로써 가드 내부에서의 변경도 방지됩니다.</p>
<div class="rule" id="r-expr.match.attributes"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.attributes" title="expr.match.attributes"><span>[expr<wbr>.match<wbr>.attributes]<span/></a></div>
<h2 id="매치-분기의-속성"><a class="header" href="#매치-분기의-속성">매치 분기의 속성</a></h2>
<div class="rule" id="r-expr.match.attributes.outer"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.attributes.outer" title="expr.match.attributes.outer"><span>[expr<wbr>.match<wbr>.attributes<wbr>.outer]<span/></a></div>
<p>매치 분기에 외부 속성이 허용됩니다. 매치 분기에서 의미가 있는 속성은 <a href="expressions/../conditional-compilation.html"><code>cfg</code></a>와 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>뿐입니다.</p>
<div class="rule" id="r-expr.match.attributes.inner"><a class="rule-link" href="expressions/match-expr.html#r-expr.match.attributes.inner" title="expr.match.attributes.inner"><span>[expr<wbr>.match<wbr>.attributes<wbr>.inner]<span/></a></div>
<p><a href="expressions/../attributes.html">내부 속성</a>은 <a href="expressions/block-expr.html#attributes-on-block-expressions">블록 표현식의 속성</a>과 동일한 표현식 문맥에서 매치 표현식의 여는 중괄호 바로 뒤에 허용됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.return"><a class="rule-link" href="expressions/return-expr.html#r-expr.return" title="expr.return"><span>[expr<wbr>.return]<span/></a></div>
<h1 id="return-표현식"><a class="header" href="#return-표현식"><code>return</code> 표현식</a></h1>
<div class="rule" id="r-expr.return.syntax"><a class="rule-link" href="expressions/return-expr.html#r-expr.return.syntax" title="expr.return.syntax"><span>[expr<wbr>.return<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>리턴표현식</em> :<br />
   <code>return</code> <a href="expressions/../expressions.html"><em>표현식</em></a><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-expr.return.intro"><a class="rule-link" href="expressions/return-expr.html#r-expr.return.intro" title="expr.return.intro"><span>[expr<wbr>.return<wbr>.intro]<span/></a></div>
<p>리턴 표현식은 키워드 <code>return</code>으로 표시됩니다.</p>
<div class="rule" id="r-expr.return.behavior"><a class="rule-link" href="expressions/return-expr.html#r-expr.return.behavior" title="expr.return.behavior"><span>[expr<wbr>.return<wbr>.behavior]<span/></a></div>
<p><code>return</code> 표현식을 평가하면 인수를 현재 함수 호출에 지정된 출력 위치로 이동하고, 현재 함수 활성화 프레임을 파괴하며, 제어를 호출자 프레임으로 전달합니다.</p>
<p><code>return</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.await"><a class="rule-link" href="expressions/await-expr.html#r-expr.await" title="expr.await"><span>[expr<wbr>.await]<span/></a></div>
<h1 id="await-표현식"><a class="header" href="#await-표현식">await 표현식</a></h1>
<div class="rule" id="r-expr.await.syntax"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.syntax" title="expr.await.syntax"><span>[expr<wbr>.await<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Await표현식</em> :<br />
   <a href="expressions/../expressions.html"><em>표현식</em></a> <code>.</code> <code>await</code></p>
</blockquote>
<div class="rule" id="r-expr.await.intro"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.intro" title="expr.await.intro"><span>[expr<wbr>.await<wbr>.intro]<span/></a></div>
<p><code>await</code> 표현식은 <code>std::future::IntoFuture</code> 구현에서 제공하는 계산을 주어진 퓨처가 값을 생성할 준비가 될 때까지 일시 중단하기 위한 구문 구조입니다.</p>
<div class="rule" id="r-expr.await.construct"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.construct" title="expr.await.construct"><span>[expr<wbr>.await<wbr>.construct]<span/></a></div>
<p>await 표현식의 구문은 <a href="expressions/../../core/future/into_future/trait.IntoFuture.html"><code>IntoFuture</code></a> 트레잇을 구현하는 타입의 표현식(_퓨처 피연산자_라고 함), 그 다음 토큰 <code>.</code>, 그리고 <code>await</code> 키워드입니다.</p>
<div class="rule" id="r-expr.await.allowed-positions"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.allowed-positions" title="expr.await.allowed-positions"><span>[expr<wbr>.await<wbr>.allowed-positions]<span/></a></div>
<p>Await 표현식은 <a href="expressions/../items/functions.html#async-functions"><code>async fn</code></a>, <a href="expressions/closure-expr.html#async-closures"><code>async</code> 클로저</a> 또는 <a href="expressions/block-expr.html#async-blocks"><code>async</code> 블록</a>과 같은 <a href="expressions/../expressions/block-expr.html#async-context">비동기 컨텍스트</a> 내에서만 유효합니다.</p>
<div class="rule" id="r-expr.await.effects"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.effects" title="expr.await.effects"><span>[expr<wbr>.await<wbr>.effects]<span/></a></div>
<p>더 구체적으로, await 표현식은 다음과 같은 효과를 가집니다.</p>
<ol>
<li>퓨처 피연산자에서 <a href="expressions/../../core/future/into_future/trait.IntoFuture.html#tymethod.into_future"><code>IntoFuture::into_future</code></a>를 호출하여 퓨처를 생성합니다.</li>
<li>퓨처를 <a href="expressions/../../core/future/future/trait.Future.html">퓨처</a> <code>tmp</code>로 평가합니다;</li>
<li><a href="expressions/../../core/pin/struct.Pin.html#method.new_unchecked"><code>Pin::new_unchecked</code></a>를 사용하여 <code>tmp</code>를 고정(pin)합니다;</li>
<li>그런 다음 이 고정된 퓨처는 <a href="expressions/../../core/future/future/trait.Future.html#tymethod.poll"><code>Future::poll</code></a> 메서드를 호출하고 현재 <a href="expressions/await-expr.html#task-context">태스크 컨텍스트</a>를 전달하여 폴링됩니다;</li>
<li><code>poll</code> 호출이 <a href="expressions/../../core/task/poll/enum.Poll.html#variant.Pending"><code>Poll::Pending</code></a>을 반환하면, 퓨처는 <code>Poll::Pending</code>을 반환하고, 상태를 일시 중단하여 둘러싼 비동기 컨텍스트가 다시 폴링될 때 실행이 3단계로 돌아가게 합니다;</li>
<li>그렇지 않으면 <code>poll</code> 호출은 <a href="expressions/../../core/task/poll/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a>를 반환했어야 하며, 이 경우 <a href="expressions/../../core/task/poll/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a> 변형에 포함된 값이 <code>await</code> 표현식 자체의 결과로 사용됩니다.</li>
</ol>
<blockquote>
<p><strong>에디션 차이</strong>: Await 표현식은 Rust 2018부터 사용할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-expr.await.task"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.task" title="expr.await.task"><span>[expr<wbr>.await<wbr>.task]<span/></a></div>
<h2 id="태스크-컨텍스트"><a class="header" href="#태스크-컨텍스트">태스크 컨텍스트</a></h2>
<p>태스크 컨텍스트는 비동기 컨텍스트 자체가 폴링될 때 현재 <a href="expressions/../expressions/block-expr.html#async-context">비동기 컨텍스트</a>에 제공된 <a href="expressions/../../core/task/wake/struct.Context.html"><code>Context</code></a>를 나타냅니다. <code>await</code> 표현식은 비동기 컨텍스트에서만 유효하기 때문에, 사용 가능한 태스크 컨텍스트가 있어야 합니다.</p>
<div class="rule" id="r-expr.await.desugar"><a class="rule-link" href="expressions/await-expr.html#r-expr.await.desugar" title="expr.await.desugar"><span>[expr<wbr>.await<wbr>.desugar]<span/></a></div>
<h2 id="대략적인-탈설탕"><a class="header" href="#대략적인-탈설탕">대략적인 탈설탕</a></h2>
<p>사실상, await 표현식은 다음의 비규범적 탈설탕과 대략적으로 동일합니다:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">match operand.into_future() {
    mut pinned =&gt; loop {
        let mut pin = unsafe { Pin::new_unchecked(&amp;mut pinned) };
        match Pin::future::poll(Pin::borrow(&amp;mut pin), &amp;mut current_context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; yield Poll::Pending,
        }
    }
}</code></pre>
<p>여기서 <code>yield</code> 의사 코드는 <code>Poll::Pending</code>을 반환하고, 다시 호출될 때 해당 지점에서 실행을 재개합니다. 변수 <code>current_context</code>는 비동기 환경에서 가져온 컨텍스트를 나타냅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-expr.placeholder"><a class="rule-link" href="expressions/underscore-expr.html#r-expr.placeholder" title="expr.placeholder"><span>[expr<wbr>.placeholder]<span/></a></div>
<h1 id="_-표현식"><a class="header" href="#_-표현식"><code>_</code> 표현식</a></h1>
<div class="rule" id="r-expr.placeholder.syntax"><a class="rule-link" href="expressions/underscore-expr.html#r-expr.placeholder.syntax" title="expr.placeholder.syntax"><span>[expr<wbr>.placeholder<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>밑줄표현식</em> :<br />
   <code>_</code></p>
</blockquote>
<div class="rule" id="r-expr.placeholder.intro"><a class="rule-link" href="expressions/underscore-expr.html#r-expr.placeholder.intro" title="expr.placeholder.intro"><span>[expr<wbr>.placeholder<wbr>.intro]<span/></a></div>
<p><code>_</code> 기호로 표시되는 밑줄 표현식은 구조 분해 할당에서 플레이스홀더를 나타내는 데 사용됩니다.</p>
<div class="rule" id="r-expr.placeholder.lhs-assignment-only"><a class="rule-link" href="expressions/underscore-expr.html#r-expr.placeholder.lhs-assignment-only" title="expr.placeholder.lhs-assignment-only"><span>[expr<wbr>.placeholder<wbr>.lhs-assignment-only]<span/></a></div>
<p>이들은 할당의 왼쪽에만 나타날 수 있습니다.</p>
<div class="rule" id="r-expr.placeholder.pattern"><a class="rule-link" href="expressions/underscore-expr.html#r-expr.placeholder.pattern" title="expr.placeholder.pattern"><span>[expr<wbr>.placeholder<wbr>.pattern]<span/></a></div>
<p>이것은 <a href="expressions/../patterns.html#wildcard-pattern">와일드카드 패턴</a>과는 구별된다는 점에 유의하십시오.</p>
<p><code>_</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = (1, 2);
let mut a = 0;
(_, a) = p;

struct Position {
    x: u32,
    y: u32,
}

Position { x: a, y: _ } = Position{ x: 2, y: 3 };

// 사용되지 않는 결과, 의도를 선언하고 경고를 제거하기 위해 `_`에 할당함
_ = 2 + 2;
// unused_must_use 경고 발생
// 2 + 2;

// let 바인딩에서 와일드카드 패턴을 사용하는 동일한 기법
let _ = 2 + 2;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-patterns"><a class="rule-link" href="patterns.html#r-patterns" title="patterns"><span>[patterns]<span/></a></div>
<h1 id="패턴"><a class="header" href="#패턴">패턴</a></h1>
<div class="rule" id="r-patterns.syntax"><a class="rule-link" href="patterns.html#r-patterns.syntax" title="patterns.syntax"><span>[patterns<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>패턴</em> :<br />
      <code>|</code><sup>?</sup> <em>최상위대안없는패턴</em>  ( <code>|</code> <em>최상위대안없는패턴</em> )<sup>*</sup></p>
<p><em>최상위대안없는패턴</em> :<br />
      <em>범위없는패턴</em><br />
   | <a href="patterns.html#range-patterns"><em>범위패턴</em></a></p>
<p><em>범위없는패턴</em> :<br />
      <a href="patterns.html#literal-patterns"><em>리터럴패턴</em></a><br />
   | <a href="patterns.html#identifier-patterns"><em>식별자패턴</em></a><br />
   | <a href="patterns.html#wildcard-pattern"><em>와일드카드패턴</em></a><br />
   | <a href="patterns.html#rest-patterns"><em>나머지패턴</em></a><br />
   | <a href="patterns.html#reference-patterns"><em>참조패턴</em></a><br />
   | <a href="patterns.html#struct-patterns"><em>구조체패턴</em></a><br />
   | <a href="patterns.html#tuple-struct-patterns"><em>튜플구조체패턴</em></a><br />
   | <a href="patterns.html#tuple-patterns"><em>튜플패턴</em></a><br />
   | <a href="patterns.html#grouped-patterns"><em>그룹화된패턴</em></a><br />
   | <a href="patterns.html#slice-patterns"><em>슬라이스패턴</em></a><br />
   | <a href="patterns.html#path-patterns"><em>경로패턴</em></a><br />
   | <a href="macros.html#macro-invocation"><em>매크로호출</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.intro"><a class="rule-link" href="patterns.html#r-patterns.intro" title="patterns.intro"><span>[patterns<wbr>.intro]<span/></a></div>
<p>패턴은 값을 구조에 대해 매칭하고, 선택적으로 구조 내부의 값에 변수를 바인딩하는 데 사용됩니다. 또한 변수 선언과 함수 및 클로저의 매개변수에도 사용됩니다.</p>
<p>다음 예제의 패턴은 네 가지 작업을 수행합니다:</p>
<ul>
<li><code>person</code>의 <code>car</code> 필드가 무언가로 채워져 있는지 테스트합니다.</li>
<li>사람의 <code>age</code> 필드가 13에서 19 사이인지 테스트하고, 그 값을 <code>person_age</code> 변수에 바인딩합니다.</li>
<li><code>name</code> 필드에 대한 참조를 <code>person_name</code> 변수에 바인딩합니다.</li>
<li><code>person</code>의 나머지 필드를 무시합니다. 나머지 필드는 어떤 값이든 가질 수 있으며 어떤 변수에도 바인딩되지 않습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from("John"),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!("{}는 차가 있고 {}살입니다.", person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.usage"><a class="rule-link" href="patterns.html#r-patterns.usage" title="patterns.usage"><span>[patterns<wbr>.usage]<span/></a></div>
<p>패턴은 다음에서 사용됩니다:</p>
<div class="rule" id="r-patterns.let"><a class="rule-link" href="patterns.html#r-patterns.let" title="patterns.let"><span>[patterns<wbr>.let]<span/></a></div>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 선언</a></li>
</ul>
<div class="rule" id="r-patterns.param"><a class="rule-link" href="patterns.html#r-patterns.param" title="patterns.param"><span>[patterns<wbr>.param]<span/></a></div>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
</ul>
<div class="rule" id="r-patterns.match"><a class="rule-link" href="patterns.html#r-patterns.match" title="patterns.match"><span>[patterns<wbr>.match]<span/></a></div>
<ul>
<li><a href="expressions/match-expr.html"><code>match</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.if-let"><a class="rule-link" href="patterns.html#r-patterns.if-let" title="patterns.if-let"><span>[patterns<wbr>.if-let]<span/></a></div>
<ul>
<li><a href="expressions/if-expr.html"><code>if let</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.while-let"><a class="rule-link" href="patterns.html#r-patterns.while-let" title="patterns.while-let"><span>[patterns<wbr>.while-let]<span/></a></div>
<ul>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.for"><a class="rule-link" href="patterns.html#r-patterns.for" title="patterns.for"><span>[patterns<wbr>.for]<span/></a></div>
<ul>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.destructure"><a class="rule-link" href="patterns.html#r-patterns.destructure" title="patterns.destructure"><span>[patterns<wbr>.destructure]<span/></a></div>
<h2 id="구조-분해"><a class="header" href="#구조-분해">구조 분해</a></h2>
<div class="rule" id="r-patterns.destructure.intro"><a class="rule-link" href="patterns.html#r-patterns.destructure.intro" title="patterns.destructure.intro"><span>[patterns<wbr>.destructure<wbr>.intro]<span/></a></div>
<p>패턴은 <a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형</a>, <a href="types/tuple.html">튜플</a>을 _구조 분해_하는 데 사용될 수 있습니다. 구조 분해는 값을 구성 요소로 나눕니다. 사용되는 구문은 해당 값을 생성할 때와 거의 동일합니다.</p>
<div class="rule" id="r-patterns.destructure.placeholder"><a class="rule-link" href="patterns.html#r-patterns.destructure.placeholder" title="patterns.destructure.placeholder"><span>[patterns<wbr>.destructure<wbr>.placeholder]<span/></a></div>
<p><a href="glossary.html#scrutinee">조사 대상</a> 표현식이 <code>struct</code>, <code>enum</code> 또는 <code>tuple</code> 타입인 패턴에서, 플레이스홀더(<code>_</code>)는 <em>단일</em> 데이터 필드를 나타내며, 와일드카드 <code>..</code>는 특정 변형의 <em>모든</em> 나머지 필드를 나타냅니다.</p>
<div class="rule" id="r-patterns.destructure.named-field-shorthand"><a class="rule-link" href="patterns.html#r-patterns.destructure.named-field-shorthand" title="patterns.destructure.named-field-shorthand"><span>[patterns<wbr>.destructure<wbr>.named-field-shorthand]<span/></a></div>
<p>이름이 있는(번호가 아닌) 필드를 가진 데이터 구조를 구조 분해할 때, <code>fieldname: fieldname</code>의 단축형으로 <code>fieldname</code>을 작성할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!("Quit"),
    Message::WriteString(write) =&gt; println!("{}", &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!("가로로 {}만큼 이동", x),
    Message::Move{ .. } =&gt; println!("다른 이동"),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!("색상 변경, 빨강: {}, 초록: {}", red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.refutable"><a class="rule-link" href="patterns.html#r-patterns.refutable" title="patterns.refutable"><span>[patterns<wbr>.refutable]<span/></a></div>
<h2 id="반박-가능성"><a class="header" href="#반박-가능성">반박 가능성</a></h2>
<p>패턴이 비교 대상 값과 일치하지 않을 가능성이 있는 경우를 _반박 가능(refutable)_하다고 합니다. 반면에 _반박 불가능(irrefutable)_한 패턴은 비교 대상 값과 항상 일치합니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // "(x, y)"는 반박 불가능한 패턴입니다

if let (a, 3) = (1, 2) {           // "(a, 3)"은 반박 가능하며, 일치하지 않을 수 있습니다
    panic!("여기에 도달해서는 안 됩니다");
} else if let (a, 4) = (3, 4) {    // "(a, 4)"는 반박 가능하며, 일치하게 됩니다
    println!("({}, 4)와 일치함", a);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.literal"><a class="rule-link" href="patterns.html#r-patterns.literal" title="patterns.literal"><span>[patterns<wbr>.literal]<span/></a></div>
<h2 id="리터럴-패턴"><a class="header" href="#리터럴-패턴">리터럴 패턴</a></h2>
<div class="rule" id="r-patterns.literal.syntax"><a class="rule-link" href="patterns.html#r-patterns.literal.syntax" title="patterns.literal.syntax"><span>[patterns<wbr>.literal<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>리터럴패턴</em> :<br />
      <code>true</code> | <code>false</code><br />
   | <a href="tokens.html#character-literals">문자리터럴</a><br />
   | <a href="tokens.html#byte-literals">바이트리터럴</a><br />
   | <a href="tokens.html#string-literals">문자열리터럴</a><br />
   | <a href="tokens.html#raw-string-literals">원시문자열리터럴</a><br />
   | <a href="tokens.html#byte-string-literals">바이트문자열리터럴</a><br />
   | <a href="tokens.html#raw-byte-string-literals">원시바이트문자열리터럴</a><br />
   | <a href="tokens.html#c-string-literals">C문자열리터럴</a><br />
   | <a href="tokens.html#raw-c-string-literals">원시C문자열리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">정수리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">부동소수점리터럴</a></p>
</blockquote>
<div class="rule" id="r-patterns.literal.intro"><a class="rule-link" href="patterns.html#r-patterns.literal.intro" title="patterns.literal.intro"><span>[patterns<wbr>.literal<wbr>.intro]<span/></a></div>
<p>_리터럴 패턴_은 리터럴에 의해 생성된 값과 정확히 동일한 값에 매치됩니다. 음수는 <a href="expressions/literal-expr.html">리터럴</a>이 아니므로, 리터럴 패턴은 리터럴 앞에 선택적으로 마이너스 기호를 허용하며, 이는 부정 연산자처럼 작동합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> C 문자열 및 원시 C 문자열 리터럴은 리터럴 패턴에서 허용되지만, <code>&amp;CStr</code>은 구조적 동등성(<code>#[derive(Eq, PartialEq)]</code>)을 구현하지 않으므로 <code>&amp;CStr</code>에 대한 어떠한 <code>match</code>도 타입 오류로 인해 거부됩니다.</p>
</blockquote>
</div>
<div class="rule" id="r-patterns.literal.refutable"><a class="rule-link" href="patterns.html#r-patterns.literal.refutable" title="patterns.literal.refutable"><span>[patterns<wbr>.literal<wbr>.refutable]<span/></a></div>
<p>리터럴 패턴은 항상 반박 가능합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!("마이너스 1입니다"),
        1 =&gt; println!("1입니다"),
        2|4 =&gt; println!("2 또는 4입니다"),
        _ =&gt; println!("어떠한 매치 암(arm)과도 일치하지 않았습니다"),
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident"><a class="rule-link" href="patterns.html#r-patterns.ident" title="patterns.ident"><span>[patterns<wbr>.ident]<span/></a></div>
<h2 id="식별자-패턴"><a class="header" href="#식별자-패턴">식별자 패턴</a></h2>
<div class="rule" id="r-patterns.ident.syntax"><a class="rule-link" href="patterns.html#r-patterns.ident.syntax" title="patterns.ident.syntax"><span>[patterns<wbr>.ident<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>식별자패턴</em> :<br />
      <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">식별자</a> (<code>@</code> <a href="patterns.html#patterns"><em>최상위대안없는패턴</em></a> ) <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.ident.intro"><a class="rule-link" href="patterns.html#r-patterns.ident.intro" title="patterns.ident.intro"><span>[patterns<wbr>.ident<wbr>.intro]<span/></a></div>
<p>식별자 패턴은 매치된 값을 <a href="names/namespaces.html">값 네임스페이스</a>의 변수에 바인딩합니다.</p>
<div class="rule" id="r-patterns.ident.unique"><a class="rule-link" href="patterns.html#r-patterns.ident.unique" title="patterns.ident.unique"><span>[patterns<wbr>.ident<wbr>.unique]<span/></a></div>
<p>식별자는 패턴 내에서 유일해야 합니다.</p>
<div class="rule" id="r-patterns.ident.scope"><a class="rule-link" href="patterns.html#r-patterns.ident.scope" title="patterns.ident.scope"><span>[patterns<wbr>.ident<wbr>.scope]<span/></a></div>
<p>변수는 스코프 내의 동일한 이름을 가진 다른 변수를 섀도잉(shadowing)합니다. 새 바인딩의 <a href="names/scopes.html">스코프</a>는 패턴이 사용되는 컨텍스트(<code>let</code> 바인딩 또는 <code>match</code> 암 등)에 따라 달라집니다.</p>
<div class="rule" id="r-patterns.ident.bare"><a class="rule-link" href="patterns.html#r-patterns.ident.bare" title="patterns.ident.bare"><span>[patterns<wbr>.ident<wbr>.bare]<span/></a></div>
<p>식별자만으로 구성된(선택적으로 <code>mut</code>가 붙은) 패턴은 모든 값과 매치되며 그 값을 해당 식별자에 바인딩합니다. 이는 변수 선언과 함수 및 클로저의 매개변수에서 가장 흔히 사용되는 패턴입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.scrutinized"><a class="rule-link" href="patterns.html#r-patterns.ident.scrutinized" title="patterns.ident.scrutinized"><span>[patterns<wbr>.ident<wbr>.scrutinized]<span/></a></div>
<p>패턴의 매치된 값을 변수에 바인딩하려면 <code>variable @ 서브패턴</code> 구문을 사용합니다. 예를 들어, 다음은 값 2를 <code>e</code>에 바인딩합니다(전체 범위가 아니라, 여기서 범위는 범위 서브패턴입니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!("범위 요소 {}를 얻음", e),
    _ =&gt; println!("아무거나"),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.move"><a class="rule-link" href="patterns.html#r-patterns.ident.move" title="patterns.ident.move"><span>[patterns<wbr>.ident<wbr>.move]<span/></a></div>
<p>기본적으로 식별자 패턴은 매치된 값이 <a href="special-types-and-traits.html#copy"><code>Copy</code></a>를 구현하는지 여부에 따라 매치된 값을 복사하거나 이동하여 변수에 바인딩합니다.</p>
<div class="rule" id="r-patterns.ident.ref"><a class="rule-link" href="patterns.html#r-patterns.ident.ref" title="patterns.ident.ref"><span>[patterns<wbr>.ident<wbr>.ref]<span/></a></div>
<p><code>ref</code> 키워드를 사용하여 참조로 바인딩하거나, <code>ref mut</code>를 사용하여 가변 참조로 바인딩하도록 변경할 수 있습니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 match 표현식에서 값은 복사(또는 이동)됩니다. 두 번째 match에서 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 구조 분해 서브패턴에서는 <code>&amp;</code> 연산자를 값의 필드에 적용할 수 없기 때문에 이 구문이 필요합니다. 예를 들어, 다음은 유효하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>이를 유효하게 만들려면 다음과 같이 작성하십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.ref-ignored"><a class="rule-link" href="patterns.html#r-patterns.ident.ref-ignored" title="patterns.ident.ref-ignored"><span>[patterns<wbr>.ident<wbr>.ref-ignored]<span/></a></div>
<p>따라서 <code>ref</code>는 매치 대상이 아닙니다. 이것의 목적은 오로지 매치된 바인딩을 복사하거나 이동하는 대신 참조로 만드는 것입니다.</p>
<div class="rule" id="r-patterns.ident.precedent"><a class="rule-link" href="patterns.html#r-patterns.ident.precedent" title="patterns.ident.precedent"><span>[patterns<wbr>.ident<wbr>.precedent]<span/></a></div>
<p><a href="patterns.html#path-patterns">경로 패턴</a>은 식별자 패턴보다 우선순위가 높습니다.</p>
<div class="rule" id="r-patterns.ident.constraint"><a class="rule-link" href="patterns.html#r-patterns.ident.constraint" title="patterns.ident.constraint"><span>[patterns<wbr>.ident<wbr>.constraint]<span/></a></div>
<p><code>ref</code> 또는 <code>ref mut</code>가 지정되고 식별자가 상수를 섀도잉하면 오류입니다.</p>
<div class="rule" id="r-patterns.ident.refutable"><a class="rule-link" href="patterns.html#r-patterns.ident.refutable" title="patterns.ident.refutable"><span>[patterns<wbr>.ident<wbr>.refutable]<span/></a></div>
<p><code>@</code> 서브패턴이 반박 불가능하거나 서브패턴이 지정되지 않은 경우 식별자 패턴은 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.ident.binding"><a class="rule-link" href="patterns.html#r-patterns.ident.binding" title="patterns.ident.binding"><span>[patterns<wbr>.ident<wbr>.binding]<span/></a></div>
<h3 id="바인딩-모드"><a class="header" href="#바인딩-모드">바인딩 모드</a></h3>
<div class="rule" id="r-patterns.ident.binding.intro"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.intro" title="patterns.ident.binding.intro"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.intro]<span/></a></div>
<p>더 나은 편의성을 제공하기 위해, 패턴은 값에 참조를 더 쉽게 바인딩할 수 있도록 서로 다른 _바인딩 모드_에서 작동합니다. 참조 값이 비참조 패턴에 의해 매치될 때, 자동으로 <code>ref</code> 또는 <code>ref mut</code> 바인딩으로 취급됩니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);
if let Some(y) = x {
    // y는 `ref y`로 변환되었으며 타입은 &amp;i32입니다
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.non-reference"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.non-reference" title="patterns.ident.binding.non-reference"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.non-reference]<span/></a></div>
<p>_비참조 패턴_에는 바인딩, <a href="patterns.html#wildcard-pattern">와일드카드 패턴</a> (<code>_</code>), 참조 타입의 <a href="patterns.html#path-patterns"><code>const</code> 패턴</a>, <a href="patterns.html#reference-patterns">참조 패턴</a>을 제외한 모든 패턴이 포함됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.default-mode"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.default-mode" title="patterns.ident.binding.default-mode"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.default-mode]<span/></a></div>
<p>바인딩 패턴에 <code>ref</code>, <code>ref mut</code>, 또는 <code>mut</code>가 명시적으로 없는 경우, 변수가 바인딩되는 방식을 결정하기 위해 _기본 바인딩 모드_를 사용합니다.</p>
<div class="rule" id="r-patterns.ident.binding.move"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.move" title="patterns.ident.binding.move"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.move]<span/></a></div>
<p>기본 바인딩 모드는 이동 시맨틱을 사용하는 “move” 모드에서 시작합니다.</p>
<div class="rule" id="r-patterns.ident.binding.top-down"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.top-down" title="patterns.ident.binding.top-down"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.top-down]<span/></a></div>
<p>패턴을 매치할 때, 컴파일러는 패턴의 바깥쪽에서 시작하여 안쪽으로 진행합니다.</p>
<div class="rule" id="r-patterns.ident.binding.auto-deref"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.auto-deref" title="patterns.ident.binding.auto-deref"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.auto-deref]<span/></a></div>
<p>비참조 패턴을 사용하여 참조를 매치할 때마다, 자동으로 값을 역참조하고 기본 바인딩 모드를 업데이트합니다.</p>
<div class="rule" id="r-patterns.ident.binding.ref"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.ref" title="patterns.ident.binding.ref"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.ref]<span/></a></div>
<p>참조는 기본 바인딩 모드를 <code>ref</code>로 설정합니다.</p>
<div class="rule" id="r-patterns.ident.binding.ref-mut"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.ref-mut" title="patterns.ident.binding.ref-mut"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.ref-mut]<span/></a></div>
<p>가변 참조는 모드가 이미 <code>ref</code>가 아닌 한 <code>ref mut</code>로 설정하며, 이미 <code>ref</code>인 경우에는 <code>ref</code>로 유지됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.nested-references"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.nested-references" title="patterns.ident.binding.nested-references"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.nested-references]<span/></a></div>
<p>자동으로 역참조된 값이 여전히 참조인 경우, 다시 역참조되며 이 과정이 반복됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-binding"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.mode-limitations-binding" title="patterns.ident.binding.mode-limitations-binding"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-binding]<span/></a></div>
<p>바인딩 패턴은 기본 바인딩 모드가 “move“일 때만 <code>ref</code> 또는 <code>ref mut</code> 바인딩 모드를 명시적으로 지정하거나 <code>mut</code>로 가변성을 지정할 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [mut x] = &amp;[()]; //~ 오류
let [ref x] = &amp;[()]; //~ 오류
let [ref mut x] = &amp;mut [()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.mode-limitations.edition2024"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.mode-limitations.edition2024" title="patterns.ident.binding.mode-limitations.edition2024"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 기본 바인딩 모드가 “move“가 아닐 때도 바인딩에 <code>ref</code> 또는 <code>ref mut</code> 바인딩 모드를 명시적으로 지정할 수 있었고, 이러한 바인딩에 <code>mut</code>로 가변성을 지정할 수 있었습니다. 이 에디션들에서는 바인딩에 <code>mut</code>를 지정하면 현재 기본 바인딩 모드에 상관없이 바인딩 모드가 “move“로 설정되었습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-reference"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.mode-limitations-reference" title="patterns.ident.binding.mode-limitations-reference"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-reference]<span/></a></div>
<p>마찬가지로, 참조 패턴은 기본 바인딩 모드가 “move“일 때만 나타날 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [&amp;x] = &amp;[&amp;()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-reference.edition2024"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.mode-limitations-reference.edition2024" title="patterns.ident.binding.mode-limitations-reference.edition2024"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-reference<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 기본 바인딩 모드가 “move“가 아닐 때도 참조 패턴이 나타날 수 있었으며, 이는 조사 대상(scrutinee)과 매치되는 효과와 기본 바인딩 모드를 “move“로 재설정하는 효과를 모두 가졌습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ident.binding.mixed"><a class="rule-link" href="patterns.html#r-patterns.ident.binding.mixed" title="patterns.ident.binding.mixed"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mixed]<span/></a></div>
<p>이동 바인딩과 참조 바인딩은 동일한 패턴에서 혼합될 수 있습니다. 이렇게 하면 바인딩된 객체의 부분 이동(partial move)이 발생하며, 해당 객체는 이후에 사용할 수 없습니다. 이는 타입이 복사 가능하지 않은 경우에만 적용됩니다.</p>
<p>아래 예시에서 <code>name</code>은 <code>person</code>에서 이동됩니다. <code>person</code> 전체를 사용하거나 <code>person.name</code>을 사용하려고 하면 _부분 이동_으로 인해 오류가 발생합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from("John"), age: 23 };
</span>// `name`은 person에서 이동되고 `age`는 참조됩니다
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.wildcard"><a class="rule-link" href="patterns.html#r-patterns.wildcard" title="patterns.wildcard"><span>[patterns<wbr>.wildcard]<span/></a></div>
<h2 id="와일드카드-패턴"><a class="header" href="#와일드카드-패턴">와일드카드 패턴</a></h2>
<div class="rule" id="r-patterns.wildcard.syntax"><a class="rule-link" href="patterns.html#r-patterns.wildcard.syntax" title="patterns.wildcard.syntax"><span>[patterns<wbr>.wildcard<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>와일드카드패턴</em> :<br />
   <code>_</code></p>
</blockquote>
<div class="rule" id="r-patterns.wildcard.intro"><a class="rule-link" href="patterns.html#r-patterns.wildcard.intro" title="patterns.wildcard.intro"><span>[patterns<wbr>.wildcard<wbr>.intro]<span/></a></div>
<p><em>와일드카드 패턴</em>(밑줄 기호)은 모든 값과 매치됩니다. 이는 값이 중요하지 않을 때 값을 무시하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.wildcard.struct-matcher"><a class="rule-link" href="patterns.html#r-patterns.wildcard.struct-matcher" title="patterns.wildcard.struct-matcher"><span>[patterns<wbr>.wildcard<wbr>.struct-matcher]<span/></a></div>
<p>다른 패턴 내부에서 이는 단일 데이터 필드와 매치됩니다(나머지 필드들과 매치되는 <code>..</code>와 대조적임).</p>
<div class="rule" id="r-patterns.wildcard.no-binding"><a class="rule-link" href="patterns.html#r-patterns.wildcard.no-binding" title="patterns.wildcard.no-binding"><span>[patterns<wbr>.wildcard<wbr>.no-binding]<span/></a></div>
<p>식별자 패턴과 달리, 매치되는 값을 복사, 이동 또는 차용하지 않습니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x는 항상 _와 매치됩니다
<span class="boring">assert_eq!(a, 10);
</span>
// 함수/클로저 매개변수를 무시합니다
let real_part = |a: f64, _: f64| { a };

// 구조체의 필드를 무시합니다
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 어떤 값이든 Some이면 허용합니다
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.wildcard.refutable"><a class="rule-link" href="patterns.html#r-patterns.wildcard.refutable" title="patterns.wildcard.refutable"><span>[patterns<wbr>.wildcard<wbr>.refutable]<span/></a></div>
<p>와일드카드 패턴은 항상 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.rest"><a class="rule-link" href="patterns.html#r-patterns.rest" title="patterns.rest"><span>[patterns<wbr>.rest]<span/></a></div>
<h2 id="나머지-패턴"><a class="header" href="#나머지-패턴">나머지 패턴</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>나머지패턴</em> :<br />
   <code>..</code></p>
</blockquote>
<div class="rule" id="r-patterns.rest.intro"><a class="rule-link" href="patterns.html#r-patterns.rest.intro" title="patterns.rest.intro"><span>[patterns<wbr>.rest<wbr>.intro]<span/></a></div>
<p><em>나머지 패턴</em>(<code>..</code> 토큰)은 가변 길이 패턴으로 작동하며, 앞뒤에서 이미 매치되지 않은 0개 이상의 요소와 매치됩니다.</p>
<div class="rule" id="r-patterns.rest.allowed-patterns"><a class="rule-link" href="patterns.html#r-patterns.rest.allowed-patterns" title="patterns.rest.allowed-patterns"><span>[patterns<wbr>.rest<wbr>.allowed-patterns]<span/></a></div>
<p>이는 <a href="patterns.html#tuple-patterns">튜플</a>, <a href="patterns.html#tuple-struct-patterns">튜플 구조체</a>, <a href="patterns.html#slice-patterns">슬라이스</a> 패턴에서만 사용될 수 있으며, 해당 패턴의 요소 중 하나로 단 한 번만 나타날 수 있습니다. 또한 <a href="patterns.html#slice-patterns">슬라이스 패턴</a>에 한해서만 <a href="patterns.html#identifier-patterns">식별자 패턴</a>에서도 허용됩니다.</p>
<div class="rule" id="r-patterns.rest.refutable"><a class="rule-link" href="patterns.html#r-patterns.rest.refutable" title="patterns.rest.refutable"><span>[patterns<wbr>.rest<wbr>.refutable]<span/></a></div>
<p>나머지 패턴은 항상 반박 불가능합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec!["a", "b", "c"];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!("슬라이스가 비어 있음"),
    [one] =&gt; println!("단일 요소 {}", one),
    [head, tail @ ..] =&gt; println!("head={} tail={:?}", head, tail),
}

match slice {
    // "!"여야 하는 마지막 요소를 제외한 모든 것을 무시합니다.
    [.., "!"] =&gt; println!("!!!"),

    // `start`는 "z"여야 하는 마지막 요소를 제외한 모든 것의 슬라이스입니다.
    [start @ .., "z"] =&gt; println!("다음으로 시작함: {:?}", start),

    // `end`는 "a"여야 하는 첫 번째 요소를 제외한 모든 것의 슬라이스입니다.
    ["a", end @ ..] =&gt; println!("다음으로 끝남: {:?}", end),

    // 'whole'은 전체 슬라이스이고 `last`는 마지막 요소입니다
    whole @ [.., last] =&gt; println!("{:?}의 마지막 요소는 {}입니다", whole, last),

    rest =&gt; println!("{:?}", rest),
}

if let [.., penultimate, _] = slice {
    println!("마지막에서 두 번째는 {}입니다", penultimate);
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// 나머지 패턴은 튜플 및 튜플 구조체 패턴에서도 사용될 수 있습니다.
match tuple {
    (1, .., y, z) =&gt; println!("y={} z={}", y, z),
    (.., 5) =&gt; println!("꼬리(tail)는 5여야 함"),
    (..) =&gt; println!("그 외 모든 것과 일치함"),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.range"><a class="rule-link" href="patterns.html#r-patterns.range" title="patterns.range"><span>[patterns<wbr>.range]<span/></a></div>
<h2 id="범위-패턴"><a class="header" href="#범위-패턴">범위 패턴</a></h2>
<div class="rule" id="r-patterns.range.syntax"><a class="rule-link" href="patterns.html#r-patterns.range.syntax" title="patterns.range.syntax"><span>[patterns<wbr>.range<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>범위패턴</em> :<br />
      <em>포함범위패턴</em><br />
   | <em>시작범위패턴</em><br />
   | <em>끝포함범위패턴</em><br />
   | <em>오래된범위패턴</em></p>
<p><em>배타범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..</code> <em>범위패턴경계</em></p>
<p><em>포함범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..=</code> <em>범위패턴경계</em></p>
<p><em>시작범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..</code></p>
<p><em>끝포함범위패턴</em> :<br />
      <code>..=</code> <em>범위패턴경계</em></p>
<p><em>오래된범위패턴</em> :<br />
   <em>범위패턴경계</em> <code>...</code> <em>범위패턴경계</em></p>
<p><em>범위패턴경계</em> :<br />
      <a href="tokens.html#character-literals">문자리터럴</a><br />
   | <a href="tokens.html#byte-literals">바이트리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">정수리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">부동소수점리터럴</a><br />
   | <a href="expressions/path-expr.html"><em>경로표현식</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.range.intro"><a class="rule-link" href="patterns.html#r-patterns.range.intro" title="patterns.range.intro"><span>[patterns<wbr>.range<wbr>.intro]<span/></a></div>
<p>_범위 패턴_은 경계로 정의된 범위 내의 스칼라 값과 매치됩니다. 이들은 <em>기호(sigil)</em>(<code>..</code>, <code>..=</code>, <code>...</code> 중 하나)와 한쪽 또는 양쪽의 경계로 구성됩니다.</p>
<div class="rule" id="r-patterns.range.lower-bound"><a class="rule-link" href="patterns.html#r-patterns.range.lower-bound" title="patterns.range.lower-bound"><span>[patterns<wbr>.range<wbr>.lower-bound]<span/></a></div>
<p>기호 왼쪽의 경계는 _하한(lower bound)_입니다.</p>
<div class="rule" id="r-patterns.range.upper-bound"><a class="rule-link" href="patterns.html#r-patterns.range.upper-bound" title="patterns.range.upper-bound"><span>[patterns<wbr>.range<wbr>.upper-bound]<span/></a></div>
<p>오른쪽의 경계는 _상한(upper bound)_입니다.</p>
<div class="rule" id="r-patterns.range.closed"><a class="rule-link" href="patterns.html#r-patterns.range.closed" title="patterns.range.closed"><span>[patterns<wbr>.range<wbr>.closed]<span/></a></div>
<p>하한과 상한을 모두 가진 범위 패턴은 두 경계 사이의 모든 값(경계 포함)과 매치됩니다. 이는 하한 뒤에 끝을 제외하는 <code>..</code> 또는 끝을 포함하는 <code>..=</code>가 오고, 그 뒤에 상한이 오는 방식으로 작성됩니다.</p>
<div class="rule" id="r-patterns.range.type"><a class="rule-link" href="patterns.html#r-patterns.range.type" title="patterns.range.type"><span>[patterns<wbr>.range<wbr>.type]<span/></a></div>
<p>범위 패턴의 타입은 상한과 하한 타입의 통합된 타입입니다.</p>
<p>예를 들어, <code>'m'..='p'</code> 패턴은 <code>'m'</code>, <code>'n'</code>, <code>'o'</code>, <code>'p'</code> 값과만 매치됩니다. 마찬가지로 <code>'m'..'p'</code>는 <code>'m'</code>, <code>'n'</code>, <code>'o'</code>와만 매치되며, 특히 <code>'p'</code>는 포함되지 <strong>않습니다</strong>.</p>
<div class="rule" id="r-patterns.range.constraint-less-than"><a class="rule-link" href="patterns.html#r-patterns.range.constraint-less-than" title="patterns.range.constraint-less-than"><span>[patterns<wbr>.range<wbr>.constraint-less-than]<span/></a></div>
<p>하한은 상한보다 클 수 없습니다. 즉, <code>a..=b</code>에서 a ≤ b여야 합니다. 예를 들어, <code>10..=0</code>과 같은 범위 패턴은 오류입니다.</p>
<div class="rule" id="r-patterns.range.open-below"><a class="rule-link" href="patterns.html#r-patterns.range.open-below" title="patterns.range.open-below"><span>[patterns<wbr>.range<wbr>.open-below]<span/></a></div>
<p>하한만 있는 범위 패턴은 하한보다 크거나 같은 모든 값과 매치됩니다. 이는 하한 뒤에 <code>..</code>가 오는 방식으로 작성되며, 하한과 동일한 타입을 갖습니다. 예를 들어, <code>1..</code>은 1, 9, 9001, 또는 (적절한 크기인 경우) 9007199254740991과 매치되지만, 0이나 부호 있는 정수의 경우 음수와는 매치되지 않습니다.</p>
<div class="rule" id="r-patterns.range.open-above"><a class="rule-link" href="patterns.html#r-patterns.range.open-above" title="patterns.range.open-above"><span>[patterns<wbr>.range<wbr>.open-above]<span/></a></div>
<p>상한만 있는 범위 패턴은 상한보다 작거나 같은 모든 값과 매치됩니다. 이는 <code>..=</code> 뒤에 상한이 오는 방식으로 작성되며, 상한과 동일한 타입을 갖습니다. 예를 들어, <code>..=10</code>은 10, 1, 0, 그리고 부호 있는 정수 타입의 경우 모든 음수 값과 매치됩니다.</p>
<div class="rule" id="r-patterns.range.constraint-slice"><a class="rule-link" href="patterns.html#r-patterns.range.constraint-slice" title="patterns.range.constraint-slice"><span>[patterns<wbr>.range<wbr>.constraint-slice]<span/></a></div>
<p>하나의 경계만 있는 범위 패턴은 <a href="patterns.html#slice-patterns">슬라이스 패턴</a>의 서브패턴에서 최상위 패턴으로 사용될 수 없습니다.</p>
<div class="rule" id="r-patterns.range.bound"><a class="rule-link" href="patterns.html#r-patterns.range.bound" title="patterns.range.bound"><span>[patterns<wbr>.range<wbr>.bound]<span/></a></div>
<p>경계는 다음 중 하나로 작성됩니다:</p>
<ul>
<li>문자, 바이트, 정수 또는 부동 소수점 리터럴.</li>
<li>정수 또는 부동 소수점 리터럴 앞에 <code>-</code>가 붙은 형태.</li>
<li><a href="expressions/path-expr.html">경로</a></li>
</ul>
<div class="rule" id="r-patterns.range.constraint-bound-path"><a class="rule-link" href="patterns.html#r-patterns.range.constraint-bound-path" title="patterns.range.constraint-bound-path"><span>[patterns<wbr>.range<wbr>.constraint-bound-path]<span/></a></div>
<p>경계가 경로로 작성된 경우, 매크로 확인 후에 해당 경로는 <code>char</code>, 정수 타입 또는 부동 소수점 타입의 상수 아이템으로 해석되어야 합니다.</p>
<div class="rule" id="r-patterns.range.value"><a class="rule-link" href="patterns.html#r-patterns.range.value" title="patterns.range.value"><span>[patterns<wbr>.range<wbr>.value]<span/></a></div>
<p>경계의 타입과 값은 그것이 어떻게 작성되었느냐에 따라 달라집니다.</p>
<div class="rule" id="r-patterns.range.path-value"><a class="rule-link" href="patterns.html#r-patterns.range.path-value" title="patterns.range.path-value"><span>[patterns<wbr>.range<wbr>.path-value]<span/></a></div>
<p>경계가 <a href="expressions/path-expr.html">경로</a>인 경우, 패턴은 해당 경로가 해석되는 <a href="items/constant-items.html">상수</a>의 타입과 값을 갖습니다.</p>
<div class="rule" id="r-patterns.range.float-restriction"><a class="rule-link" href="patterns.html#r-patterns.range.float-restriction" title="patterns.range.float-restriction"><span>[patterns<wbr>.range<wbr>.float-restriction]<span/></a></div>
<p>부동 소수점 범위 패턴의 경우, 상수는 <code>NaN</code>일 수 없습니다.</p>
<div class="rule" id="r-patterns.range.literal-value"><a class="rule-link" href="patterns.html#r-patterns.range.literal-value" title="patterns.range.literal-value"><span>[patterns<wbr>.range<wbr>.literal-value]<span/></a></div>
<p>리터럴인 경우, 해당 <a href="expressions/literal-expr.html">리터럴 표현식</a>의 타입과 값을 갖습니다.</p>
<div class="rule" id="r-patterns.range.negation"><a class="rule-link" href="patterns.html#r-patterns.range.negation" title="patterns.range.negation"><span>[patterns<wbr>.range<wbr>.negation]<span/></a></div>
<p>리터럴 앞에 <code>-</code>가 붙은 경우, 해당 <a href="expressions/literal-expr.html">리터럴 표현식</a>과 동일한 타입을 가지며, 해당 리터럴 표현식의 값을 <a href="expressions/operator-expr.html#negation-operators">부정한(negating)</a> 값을 갖습니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!("{}", match ph {
    0..7 =&gt; "산성",
    7 =&gt; "중성",
    8..=14 =&gt; "염기성",
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; "0입니다!",
    1.. =&gt; "양수입니다!",
};

// 상수에 대한 경로 사용:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!("{}", match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; "대류권",
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; "성층권",
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; "중간권",
    _ =&gt; "아마도 외계 공간",
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!("크기가 적절하며 {}바이트를 차지함", size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// 정규화된 경로 사용:
println!("{}", match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; "u8에 맞음",
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; "u16에 맞음",
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; "u32에 맞음",
    _ =&gt; "너무 큼",
});
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.range.refutable"><a class="rule-link" href="patterns.html#r-patterns.range.refutable" title="patterns.range.refutable"><span>[patterns<wbr>.range<wbr>.refutable]<span/></a></div>
<p>고정 너비 정수 및 <code>char</code> 타입에 대한 범위 패턴이 타입의 가능한 모든 값 세트를 포괄하는 경우 반박 불가능(irrefutable)합니다. 예를 들어, <code>0u8..=255u8</code>은 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.range.refutable-integer"><a class="rule-link" href="patterns.html#r-patterns.range.refutable-integer" title="patterns.range.refutable-integer"><span>[patterns<wbr>.range<wbr>.refutable-integer]<span/></a></div>
<p>정수 타입의 값 범위는 최소값부터 최대값까지의 닫힌 범위입니다.</p>
<div class="rule" id="r-patterns.range.refutable-char"><a class="rule-link" href="patterns.html#r-patterns.range.refutable-char" title="patterns.range.refutable-char"><span>[patterns<wbr>.range<wbr>.refutable-char]<span/></a></div>
<p><code>char</code> 타입의 값 범위는 정확히 모든 유니코드 스칼라 값을 포함하는 범위인 <code>'\u{0000}'..='\u{D7FF}'</code>와 <code>'\u{E000}'..='\u{10FFFF}'</code>입니다.</p>
<div class="rule" id="r-patterns.range.edition2021"><a class="rule-link" href="patterns.html#r-patterns.range.edition2021" title="patterns.range.edition2021"><span>[patterns<wbr>.range<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션 이전에는 하한과 상한을 모두 가진 범위 패턴을 <code>..=</code> 대신 <code>...</code>를 사용하여 동일한 의미로 작성할 수도 있었습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ref"><a class="rule-link" href="patterns.html#r-patterns.ref" title="patterns.ref"><span>[patterns<wbr>.ref]<span/></a></div>
<h2 id="참조-패턴"><a class="header" href="#참조-패턴">참조 패턴</a></h2>
<div class="rule" id="r-patterns.ref.syntax"><a class="rule-link" href="patterns.html#r-patterns.ref.syntax" title="patterns.ref.syntax"><span>[patterns<wbr>.ref<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>참조패턴</em> :<br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <a href="patterns.html#patterns"><em>범위없는패턴</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.ref.intro"><a class="rule-link" href="patterns.html#r-patterns.ref.intro" title="patterns.ref.intro"><span>[patterns<wbr>.ref<wbr>.intro]<span/></a></div>
<p>참조 패턴은 매치되는 포인터를 역참조하며, 따라서 이를 차용합니다.</p>
<p>예를 들어, <code>x: &amp;i32</code>에 대한 다음 두 매치는 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; "0", _ =&gt; "some" };
let b = match int_reference { &amp;0 =&gt; "0", _ =&gt; "some" };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ref.ref-ref"><a class="rule-link" href="patterns.html#r-patterns.ref.ref-ref" title="patterns.ref.ref-ref"><span>[patterns<wbr>.ref<wbr>.ref-ref]<span/></a></div>
<p>참조 패턴에 대한 문법 생성물은 참조의 참조를 매치하기 위해 <code>&amp;&amp;</code> 토큰과 매치되어야 합니다. 이는 그 자체로 하나의 토큰이며, 두 개의 <code>&amp;</code> 토큰이 아니기 때문입니다.</p>
<div class="rule" id="r-patterns.ref.mut"><a class="rule-link" href="patterns.html#r-patterns.ref.mut" title="patterns.ref.mut"><span>[patterns<wbr>.ref<wbr>.mut]<span/></a></div>
<p><code>mut</code> 키워드를 추가하면 가변 참조를 역참조합니다. 가변성은 참조의 가변성과 일치해야 합니다.</p>
<div class="rule" id="r-patterns.ref.refutable"><a class="rule-link" href="patterns.html#r-patterns.ref.refutable" title="patterns.ref.refutable"><span>[patterns<wbr>.ref<wbr>.refutable]<span/></a></div>
<p>참조 패턴은 항상 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.struct"><a class="rule-link" href="patterns.html#r-patterns.struct" title="patterns.struct"><span>[patterns<wbr>.struct]<span/></a></div>
<h2 id="구조체-패턴"><a class="header" href="#구조체-패턴">구조체 패턴</a></h2>
<div class="rule" id="r-patterns.struct.syntax"><a class="rule-link" href="patterns.html#r-patterns.struct.syntax" title="patterns.struct.syntax"><span>[patterns<wbr>.struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>구조체패턴</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>{</code><br />
      <em>구조체패턴요소</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>구조체패턴요소</em> :<br />
      <em>구조체패턴필드</em> (<code>,</code> | <code>,</code> <em>구조체패턴기타</em>)<sup>?</sup><br />
   | <em>구조체패턴기타</em></p>
<p><em>구조체패턴필드</em> :<br />
   <em>구조체패턴필드</em> (<code>,</code> <em>구조체패턴필드</em>) <sup>*</sup></p>
<p><em>구조체패턴필드</em> :<br />
   <a href="attributes.html"><em>외부속성</em></a> <sup>*</sup><br />
   (<br />
         <a href="tokens.html#tuple-index">튜플인덱스</a> <code>:</code> <a href="patterns.html#patterns"><em>패턴</em></a><br />
      | <a href="identifiers.html">식별자</a> <code>:</code> <a href="patterns.html#patterns"><em>패턴</em></a><br />
      | <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">식별자</a><br />
   )</p>
<p><em>구조체패턴기타</em> :<br />
   <code>..</code></p>
</blockquote>
<div class="rule" id="r-patterns.struct.intro"><a class="rule-link" href="patterns.html#r-patterns.struct.intro" title="patterns.struct.intro"><span>[patterns<wbr>.struct<wbr>.intro]<span/></a></div>
<p>구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 구조체, 열거형 및 공용체 값과 매치됩니다. 또한 구조체, 열거형 또는 공용체 값을 <a href="patterns.html#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.struct.ignore-rest"><a class="rule-link" href="patterns.html#r-patterns.struct.ignore-rest" title="patterns.struct.ignore-rest"><span>[patterns<wbr>.struct<wbr>.ignore-rest]<span/></a></div>
<p>구조체 패턴에서 필드는 이름이나 인덱스(튜플 구조체의 경우)로 참조되거나 <code>..</code>을 사용하여 무시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // 순서는 중요하지 않음
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // 순서는 중요하지 않음
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}

<span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">}
</span><span class="boring">let m = Message::Quit;
</span><span class="boring">
</span>match m {
    Message::Quit =&gt; (),
    Message::Move {x: 10, y: 20} =&gt; (),
    Message::Move {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.constraint-struct"><a class="rule-link" href="patterns.html#r-patterns.struct.constraint-struct" title="patterns.struct.constraint-struct"><span>[patterns<wbr>.struct<wbr>.constraint-struct]<span/></a></div>
<p><code>..</code>이 사용되지 않으면, 구조체를 매치하는 데 사용되는 구조체 패턴은 모든 필드를 명시해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.constraint-union"><a class="rule-link" href="patterns.html#r-patterns.struct.constraint-union" title="patterns.struct.constraint-union"><span>[patterns<wbr>.struct<wbr>.constraint-union]<span/></a></div>
<p>공용체(union)를 매치하는 데 사용되는 구조체 패턴은 정확히 하나의 필드만 지정해야 합니다 (<a href="items/unions.html#pattern-matching-on-unions">공용체에서의 패턴 매칭</a> 참조)。</p>
<div class="rule" id="r-patterns.struct.binding-shorthand"><a class="rule-link" href="patterns.html#r-patterns.struct.binding-shorthand" title="patterns.struct.binding-shorthand"><span>[patterns<wbr>.struct<wbr>.binding-shorthand]<span/></a></div>
<p><code>ref</code> 및/또는 <code>mut</code> <em>식별자</em> 구문은 모든 값과 매치되며, 주어진 필드와 동일한 이름을 가진 변수에 바인딩합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct{a: x, b: y, c: z} = struct_value;          // 모든 필드 구조 분해
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.refutable"><a class="rule-link" href="patterns.html#r-patterns.struct.refutable" title="patterns.struct.refutable"><span>[patterns<wbr>.struct<wbr>.refutable]<span/></a></div>
<p>_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다.</p>
<div class="rule" id="r-patterns.tuple-struct"><a class="rule-link" href="patterns.html#r-patterns.tuple-struct" title="patterns.tuple-struct"><span>[patterns<wbr>.tuple-struct]<span/></a></div>
<h2 id="튜플-구조체-패턴"><a class="header" href="#튜플-구조체-패턴">튜플 구조체 패턴</a></h2>
<div class="rule" id="r-patterns.tuple-struct.syntax"><a class="rule-link" href="patterns.html#r-patterns.tuple-struct.syntax" title="patterns.tuple-struct.syntax"><span>[patterns<wbr>.tuple-struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플구조체패턴</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>(</code> <em>튜플구조체항목</em> <sup>?</sup> <code>)</code></p>
<p><em>튜플구조체항목</em> :<br />
   <a href="patterns.html#patterns"><em>패턴</em></a> ( <code>,</code> <a href="patterns.html#patterns"><em>패턴</em></a> ) <sup>*</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.tuple-struct.intro"><a class="rule-link" href="patterns.html#r-patterns.tuple-struct.intro" title="patterns.tuple-struct.intro"><span>[patterns<wbr>.tuple-struct<wbr>.intro]<span/></a></div>
<p>튜플 구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 구조체 및 열거형 값과 매치됩니다. 또한 튜플 구조체 또는 열거형 값을 <a href="patterns.html#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.tuple-struct.refutable"><a class="rule-link" href="patterns.html#r-patterns.tuple-struct.refutable" title="patterns.tuple-struct.refutable"><span>[patterns<wbr>.tuple-struct<wbr>.refutable]<span/></a></div>
<p>_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 튜플 구조체 패턴은 반박 가능합니다.</p>
<div class="rule" id="r-patterns.tuple"><a class="rule-link" href="patterns.html#r-patterns.tuple" title="patterns.tuple"><span>[patterns<wbr>.tuple]<span/></a></div>
<h2 id="튜플-패턴"><a class="header" href="#튜플-패턴">튜플 패턴</a></h2>
<div class="rule" id="r-patterns.tuple.syntax"><a class="rule-link" href="patterns.html#r-patterns.tuple.syntax" title="patterns.tuple.syntax"><span>[patterns<wbr>.tuple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플패턴</em> :<br />
   <code>(</code> <em>튜플패턴항목</em> <sup>?</sup> <code>)</code></p>
<p><em>튜플패턴항목</em> :<br />
      <a href="patterns.html#patterns"><em>패턴</em></a> <code>,</code><br />
   | <a href="patterns.html#rest-patterns"><em>나머지패턴</em></a><br />
   | <a href="patterns.html#patterns"><em>패턴</em></a> ( <code>,</code> <a href="patterns.html#patterns"><em>패턴</em></a> ) <sup>+</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.tuple.intro"><a class="rule-link" href="patterns.html#r-patterns.tuple.intro" title="patterns.tuple.intro"><span>[patterns<wbr>.tuple<wbr>.intro]<span/></a></div>
<p>튜플 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 값과 매치됩니다. 또한 튜플을 <a href="patterns.html#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.tuple.rest-syntax"><a class="rule-link" href="patterns.html#r-patterns.tuple.rest-syntax" title="patterns.tuple.rest-syntax"><span>[patterns<wbr>.tuple<wbr>.rest-syntax]<span/></a></div>
<p>단일 <a href="patterns.html#rest-patterns"><em>나머지 패턴</em></a>을 포함하는 <code>(..)</code> 형식은 쉼표가 필요하지 않은 특별한 형식으로, 모든 크기의 튜플과 매치됩니다.</p>
<div class="rule" id="r-patterns.tuple.refutable"><a class="rule-link" href="patterns.html#r-patterns.tuple.refutable" title="patterns.tuple.refutable"><span>[patterns<wbr>.tuple<wbr>.refutable]<span/></a></div>
<p>튜플 패턴은 서브패턴 중 하나가 반박 가능한 경우 반박 가능합니다.</p>
<p>튜플 패턴 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, "ten");
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, "ten");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.paren"><a class="rule-link" href="patterns.html#r-patterns.paren" title="patterns.paren"><span>[patterns<wbr>.paren]<span/></a></div>
<h2 id="그룹화된-패턴"><a class="header" href="#그룹화된-패턴">그룹화된 패턴</a></h2>
<div class="rule" id="r-patterns.paren.syntax"><a class="rule-link" href="patterns.html#r-patterns.paren.syntax" title="patterns.paren.syntax"><span>[patterns<wbr>.paren<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>그룹화된패턴</em> :<br />
   <code>(</code> <a href="patterns.html#patterns"><em>패턴</em></a> <code>)</code></p>
</blockquote>
<div class="rule" id="r-patterns.paren.intro"><a class="rule-link" href="patterns.html#r-patterns.paren.intro" title="patterns.paren.intro"><span>[patterns<wbr>.paren<wbr>.intro]<span/></a></div>
<p>패턴을 괄호로 묶으면 복합 패턴의 우선순위를 명시적으로 제어할 수 있습니다. 예를 들어, <code>&amp;0..=5</code>와 같이 참조 패턴이 범위 패턴 옆에 오는 것은 모호하여 허용되지 않지만, 괄호를 사용하여 표현할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.slice"><a class="rule-link" href="patterns.html#r-patterns.slice" title="patterns.slice"><span>[patterns<wbr>.slice]<span/></a></div>
<h2 id="슬라이스-패턴"><a class="header" href="#슬라이스-패턴">슬라이스 패턴</a></h2>
<div class="rule" id="r-patterns.slice.syntax"><a class="rule-link" href="patterns.html#r-patterns.slice.syntax" title="patterns.slice.syntax"><span>[patterns<wbr>.slice<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>슬라이스패턴</em> :<br />
   <code>[</code> <em>슬라이스패턴항목</em> <sup>?</sup> <code>]</code></p>
<p><em>슬라이스패턴항목</em> :<br />
   <a href="patterns.html#patterns"><em>패턴</em></a> ( <code>,</code> <a href="patterns.html#patterns"><em>패턴</em></a> ) <sup>*</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.slice.intro"><a class="rule-link" href="patterns.html#r-patterns.slice.intro" title="patterns.slice.intro"><span>[patterns<wbr>.slice<wbr>.intro]<span/></a></div>
<p>슬라이스 패턴은 고정 크기 배열과 동적 크기 슬라이스 모두와 매치될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 고정 크기
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; "1로 시작함",
    [a, b, c] =&gt; "다른 것으로 시작함",
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 동적 크기
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 이 암(arm)은 길이가 일치하지 않으므로 적용되지 않습니다 */ }
    [a, b, c] =&gt; { /* 이 암(arm)이 적용됩니다 */ }
    _ =&gt; { /* 길이를 정적으로 알 수 없으므로 이 와일드카드가 필요합니다 */ }
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.slice.refutable-array"><a class="rule-link" href="patterns.html#r-patterns.slice.refutable-array" title="patterns.slice.refutable-array"><span>[patterns<wbr>.slice<wbr>.refutable-array]<span/></a></div>
<p>슬라이스 패턴은 배열을 매치할 때 각 요소가 반박 불가능하다면 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.slice.refutable-slice"><a class="rule-link" href="patterns.html#r-patterns.slice.refutable-slice" title="patterns.slice.refutable-slice"><span>[patterns<wbr>.slice<wbr>.refutable-slice]<span/></a></div>
<p>슬라이스를 매치할 때, 단일 <code>..</code> <a href="patterns.html#rest-patterns">나머지 패턴</a>이거나 <code>..</code> 나머지 패턴을 서브패턴으로 가진 <a href="patterns.html#identifier-patterns">식별자 패턴</a> 형식인 경우에만 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.slice.restriction"><a class="rule-link" href="patterns.html#r-patterns.slice.restriction" title="patterns.slice.restriction"><span>[patterns<wbr>.slice<wbr>.restriction]<span/></a></div>
<p>슬라이스 내에서 하한과 상한이 모두 있지 않은 범위 패턴은 단일 슬라이스 요소와 매치하려는 의도임을 명확히 하기 위해 <code>(a..)</code>와 같이 괄호로 묶어야 합니다. <code>a..=b</code>와 같이 하한과 상한이 모두 있는 범위 패턴은 괄호로 묶을 필요가 없습니다.</p>
<div class="rule" id="r-patterns.path"><a class="rule-link" href="patterns.html#r-patterns.path" title="patterns.path"><span>[patterns<wbr>.path]<span/></a></div>
<h2 id="경로-패턴"><a class="header" href="#경로-패턴">경로 패턴</a></h2>
<div class="rule" id="r-patterns.path.syntax"><a class="rule-link" href="patterns.html#r-patterns.path.syntax" title="patterns.path.syntax"><span>[patterns<wbr>.path<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>경로패턴</em> :<br />
      <a href="expressions/path-expr.html"><em>경로표현식</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.path.intro"><a class="rule-link" href="patterns.html#r-patterns.path.intro" title="patterns.path.intro"><span>[patterns<wbr>.path<wbr>.intro]<span/></a></div>
<p>_경로 패턴_은 상수 값이나 필드가 없는 구조체 또는 열거형 변형을 참조하는 패턴입니다.</p>
<div class="rule" id="r-patterns.path.unqualified"><a class="rule-link" href="patterns.html#r-patterns.path.unqualified" title="patterns.path.unqualified"><span>[patterns<wbr>.path<wbr>.unqualified]<span/></a></div>
<p>수식되지 않은(unqualified) 경로 패턴은 다음을 참조할 수 있습니다:</p>
<ul>
<li>열거형 변형</li>
<li>구조체</li>
<li>상수</li>
<li>연관 상수</li>
</ul>
<div class="rule" id="r-patterns.path.qualified"><a class="rule-link" href="patterns.html#r-patterns.path.qualified" title="patterns.path.qualified"><span>[patterns<wbr>.path<wbr>.qualified]<span/></a></div>
<p>수식된(qualified) 경로 패턴은 연관 상수만 참조할 수 있습니다.</p>
<div class="rule" id="r-patterns.path.refutable"><a class="rule-link" href="patterns.html#r-patterns.path.refutable" title="patterns.path.refutable"><span>[patterns<wbr>.path<wbr>.refutable]<span/></a></div>
<p>경로 패턴은 구조체를 참조하거나, 열거형이 단 하나의 변형만 가질 때 해당 열거형 변형을 참조하거나, 타입이 반박 불가능한 상수를 참조할 때 반박 불가능합니다. 여러 변형을 가진 열거형의 변형이나 반박 가능한 상수를 참조할 때는 반박 가능합니다.</p>
<div class="rule" id="r-patterns.const"><a class="rule-link" href="patterns.html#r-patterns.const" title="patterns.const"><span>[patterns<wbr>.const]<span/></a></div>
<h3 id="상수-패턴"><a class="header" href="#상수-패턴">상수 패턴</a></h3>
<div class="rule" id="r-patterns.const.partial-eq"><a class="rule-link" href="patterns.html#r-patterns.const.partial-eq" title="patterns.const.partial-eq"><span>[patterns<wbr>.const<wbr>.partial-eq]<span/></a></div>
<p><code>T</code> 타입의 상수 <code>C</code>가 패턴으로 사용될 때, 먼저 <code>T: PartialEq</code>인지 확인합니다.</p>
<div class="rule" id="r-patterns.const.structural-equality"><a class="rule-link" href="patterns.html#r-patterns.const.structural-equality" title="patterns.const.structural-equality"><span>[patterns<wbr>.const<wbr>.structural-equality]<span/></a></div>
<p>나아가 상수 <code>C</code>의 값이 _(재귀적) 구조적 동등성_을 가져야 하며, 이는 다음과 같이 재귀적으로 정의됩니다:</p>
<div class="rule" id="r-patterns.const.primitive"><a class="rule-link" href="patterns.html#r-patterns.const.primitive" title="patterns.const.primitive"><span>[patterns<wbr>.const<wbr>.primitive]<span/></a></div>
<ul>
<li>정수뿐만 아니라 <code>str</code>, <code>bool</code>, <code>char</code> 값은 항상 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.builtin-aggregate"><a class="rule-link" href="patterns.html#r-patterns.const.builtin-aggregate" title="patterns.const.builtin-aggregate"><span>[patterns<wbr>.const<wbr>.builtin-aggregate]<span/></a></div>
<ul>
<li>튜플, 배열, 슬라이스는 모든 필드/요소가 구조적 동등성을 가지면 구조적 동등성을 갖습니다. (특히, <code>()</code>와 <code>[]</code>는 항상 구조적 동등성을 갖습니다.)</li>
</ul>
<div class="rule" id="r-patterns.const.ref"><a class="rule-link" href="patterns.html#r-patterns.const.ref" title="patterns.const.ref"><span>[patterns<wbr>.const<wbr>.ref]<span/></a></div>
<ul>
<li>참조는 가리키는 값이 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.aggregate"><a class="rule-link" href="patterns.html#r-patterns.const.aggregate" title="patterns.const.aggregate"><span>[patterns<wbr>.const<wbr>.aggregate]<span/></a></div>
<ul>
<li><code>struct</code> 또는 <code>enum</code> 타입의 값은 <code>PartialEq</code> 인스턴스가 <code>#[derive(PartialEq)]</code>를 통해 파생되었고, 모든 필드(열거형의 경우 현재 활성화된 변형의 필드)가 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.pointer"><a class="rule-link" href="patterns.html#r-patterns.const.pointer" title="patterns.const.pointer"><span>[patterns<wbr>.const<wbr>.pointer]<span/></a></div>
<ul>
<li>원시 포인터는 상수 정수로 정의된 경우(그 후 캐스팅되거나 transmute된 경우) 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.float"><a class="rule-link" href="patterns.html#r-patterns.const.float" title="patterns.const.float"><span>[patterns<wbr>.const<wbr>.float]<span/></a></div>
<ul>
<li>부동 소수점 값은 <code>NaN</code>이 아니면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.exhaustive"><a class="rule-link" href="patterns.html#r-patterns.const.exhaustive" title="patterns.const.exhaustive"><span>[patterns<wbr>.const<wbr>.exhaustive]<span/></a></div>
<ul>
<li>그 외에는 구조적 동등성을 갖지 않습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.generic"><a class="rule-link" href="patterns.html#r-patterns.const.generic" title="patterns.const.generic"><span>[patterns<wbr>.const<wbr>.generic]<span/></a></div>
<p>특히, 상수 <code>C</code>의 값은 패턴 구축 시점(단형성화(monomorphization) 이전)에 알려져야 합니다. 이는 제네릭 파라미터가 포함된 연관 상수는 패턴으로 사용될 수 없음을 의미합니다.</p>
<div class="rule" id="r-patterns.const.translation"><a class="rule-link" href="patterns.html#r-patterns.const.translation" title="patterns.const.translation"><span>[patterns<wbr>.const<wbr>.translation]<span/></a></div>
<p>모든 조건이 충족되면, 상수 값은 패턴으로 번역되며 이제 해당 패턴을 직접 작성한 것과 정확히 동일하게 동작합니다. 특히, 이는 망라성 검사(exhaustiveness checking)에 완전히 참여합니다. (원시 포인터의 경우, 상수가 이러한 패턴을 작성하는 유일한 방법입니다. 이러한 타입들에 대해서는 오직 <code>_</code>만이 망라적인 것으로 간주됩니다.)</p>
<div class="rule" id="r-patterns.or"><a class="rule-link" href="patterns.html#r-patterns.or" title="patterns.or"><span>[patterns<wbr>.or]<span/></a></div>
<h2 id="or-패턴"><a class="header" href="#or-패턴">Or 패턴</a></h2>
<p>_Or 패턴_은 둘 이상의 서브패턴 중 하나와 매치되는 패턴입니다(예: <code>A | B | C</code>). 이들은 임의로 중첩될 수 있습니다. 구문상으로 Or 패턴은 다른 패턴이 허용되는 모든 위치(<em>패턴</em> 생성물로 표현됨)에서 허용되지만, <code>let</code> 바인딩과 함수 및 클로저의 인자(<em>최상위대안없는패턴</em> 생성물로 표현됨)는 제외됩니다.</p>
<div class="rule" id="r-patterns.constraints"><a class="rule-link" href="patterns.html#r-patterns.constraints" title="patterns.constraints"><span>[patterns<wbr>.constraints]<span/></a></div>
<h3 id="정적-시맨틱"><a class="header" href="#정적-시맨틱">정적 시맨틱</a></h3>
<div class="rule" id="r-patterns.constraints.pattern"><a class="rule-link" href="patterns.html#r-patterns.constraints.pattern" title="patterns.constraints.pattern"><span>[patterns<wbr>.constraints<wbr>.pattern]<span/></a></div>
<ol>
<li>
<p>임의의 패턴 <code>p</code>와 <code>q</code>에 대해 어떤 깊이에서든 <code>p | q</code> 패턴이 주어졌을 때, 다음의 경우 해당 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다:</p>
<ul>
<li><code>p</code>에 대해 추론된 타입이 <code>q</code>에 대해 추론된 타입과 통합(unify)되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에서 동일한 바인딩 집합이 도입되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에 있는 동일한 이름의 두 바인딩 타입이 타입 또는 바인딩 모드 관점에서 통합되지 않는 경우.
타입 통합은 모든 인스턴스에서 앞서 언급한 대로 정확해야 하며, 암시적인 <a href="type-coercions.html">타입 강제 변환</a>은 적용되지 않습니다.</li>
</ul>
</li>
</ol>
<div class="rule" id="r-patterns.constraints.match-type-check"><a class="rule-link" href="patterns.html#r-patterns.constraints.match-type-check" title="patterns.constraints.match-type-check"><span>[patterns<wbr>.constraints<wbr>.match-type-check]<span/></a></div>
<ol start="2">
<li><code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code> 표현식을 타입 검사할 때, <code>p_i | q_i</code> 형식의 패턴을 포함하는 각 매치 암 <code>a_i</code>에 대해, 해당 패턴이 존재하는 깊이 <code>d</code>에서 <code>e_s</code>의 깊이 <code>d</code> 조각의 타입이 <code>p_i | q_i</code>와 통합(unify)되지 않으면 <code>p_i | q_i</code> 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다.</li>
</ol>
<div class="rule" id="r-patterns.constraints.exhaustiveness-or-pattern"><a class="rule-link" href="patterns.html#r-patterns.constraints.exhaustiveness-or-pattern" title="patterns.constraints.exhaustiveness-or-pattern"><span>[patterns<wbr>.constraints<wbr>.exhaustiveness-or-pattern]<span/></a></div>
<ol start="3">
<li>
<p>망라성 검사와 관련하여, <code>p | q</code> 패턴은 <code>p</code>와 <code>q</code>를 모두 포괄하는 것으로 간주됩니다. 어떤 생성자 <code>c(x, ..)</code>에 대해 분배 법칙이 적용되어, <code>c(p | q, ..rest)</code>는 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 값 집합을 포괄합니다. 이는 최상위 레벨에 존재하는 패턴을 제외하고 <code>p | q</code> 형식의 중첩된 패턴이 더 이상 없을 때까지 재귀적으로 적용될 수 있습니다.</p>
<p>여기서 _“생성자”_는 튜플 구조체 패턴만을 가리키는 것이 아니라, 모든 곱 타입(product type)에 대한 패턴을 의미합니다. 여기에는 열거형 변형, 튜플 구조체, 이름 있는 필드가 있는 구조체, 배열, 튜플, 슬라이스가 포함됩니다.</p>
</li>
</ol>
<div class="rule" id="r-patterns.behavior"><a class="rule-link" href="patterns.html#r-patterns.behavior" title="patterns.behavior"><span>[patterns<wbr>.behavior]<span/></a></div>
<h3 id="동적-시맨틱"><a class="header" href="#동적-시맨틱">동적 시맨틱</a></h3>
<div class="rule" id="r-patterns.behavior.nested-or-patterns"><a class="rule-link" href="patterns.html#r-patterns.behavior.nested-or-patterns" title="patterns.behavior.nested-or-patterns"><span>[patterns<wbr>.behavior<wbr>.nested-or-patterns]<span/></a></div>
<ol>
<li>조사 대상 표현식 <code>e_s</code>를 깊이 <code>d</code>에서 <code>c(p | q, ..rest)</code> 패턴(여기서 <code>c</code>는 어떤 생성자, <code>p</code>와 <code>q</code>는 임의의 패턴, <code>rest</code>는 <code>c</code>의 나머지 선택적 요소)과 매치하는 동적 시맨틱은 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 것으로 정의됩니다.</li>
</ol>
<div class="rule" id="r-patterns.precedence"><a class="rule-link" href="patterns.html#r-patterns.precedence" title="patterns.precedence"><span>[patterns<wbr>.precedence]<span/></a></div>
<h3 id="구분-기호가-없는-다른-패턴과의-우선순위"><a class="header" href="#구분-기호가-없는-다른-패턴과의-우선순위">구분 기호가 없는 다른 패턴과의 우선순위</a></h3>
<p>이 장의 다른 곳에서 보여준 것처럼, 식별자 패턴, 참조 패턴, Or 패턴을 포함하여 구문상으로 구분 기호가 없는(undelimited) 여러 유형의 패턴이 있습니다. Or 패턴은 항상 가장 낮은 우선순위를 갖습니다. 이를 통해 향후 타입 어스크립션(type ascription) 기능을 위한 구문적 공간을 확보하고 모호성을 줄일 수 있습니다. 예를 들어, <code>x @ A(..) | B(..)</code>는 <code>x</code>가 모든 패턴에 바인딩되지 않았다는 오류를 발생시킵니다. <code>&amp;A(x) | B(x)</code>는 서로 다른 서브패턴에 있는 <code>x</code> 사이의 타입 불일치를 발생시킵니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="타입-시스템"><a class="header" href="#타입-시스템">타입 시스템</a></h1>
<div style="break-before: page; page-break-before: always;"></div><script>
(function() {
    var fragments = {
        "#boolean-type": "types/boolean.html",
        "#numeric-types": "types/numeric.html",
        "#machine-types": "types/numeric.html",
        "#machine-dependent-integer-types": "types/numeric.html#machine-dependent-integer-types",
        "#textual-types": "types/textual.html",
        "#never-type": "types/never.html",
        "#tuple-types": "types/tuple.html",
        "#array-and-slice-types": "types/array.html",
        "#struct-types": "types/struct.html",
        "#enumerated-types": "types/enum.html",
        "#union-types": "types/union.html",
        "#pointer-types": "types/pointer.html",
        "#shared-references-": "types/pointer.html#shared-references-",
        "#mutable-references-": "types/pointer.html#mutable-references-mut",
        "#raw-pointers-const-and-mut": "types/pointer.html#raw-pointers-const-and-mut",
        "#smart-pointers": "types/pointer.html#smart-pointers",
        "#function-item-types": "types/function-item.html",
        "#function-pointer-types": "types/function-pointer.html",
        "#closure-types": "types/closure.html",
        "#capture-modes": "types/closure.html#capture-modes",
        "#unique-immutable-borrows-in-captures": "types/closure.html#unique-immutable-borrows-in-captures",
        "#call-traits-and-coercions": "types/closure.html#call-traits-and-coercions",
        "#other-traits": "types/closure.html#other-traits",
        "#trait-objects": "types/trait-object.html",
        "#trait-object-lifetime-bounds": "types/trait-object.html#trait-object-lifetime-bounds",
        "#impl-trait": "types/impl-trait.html",
        "#anonymous-type-parameters": "types/impl-trait.html#anonymous-type-parameters",
        "#abstract-return-types": "types/impl-trait.html#abstract-return-types",
        "#self-types": "paths.html#self-1",
        "#inferred-type": "types/inferred.html",
        "#type-parameters": "types/parameters.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div class="rule" id="r-type"><a class="rule-link" href="types.html#r-type" title="type"><span>[type]<span/></a></div>
<h1 id="타입"><a class="header" href="#타입">타입</a></h1>
<div class="rule" id="r-type.intro"><a class="rule-link" href="types.html#r-type.intro" title="type.intro"><span>[type<wbr>.intro]<span/></a></div>
<p>러스트 프로그램의 모든 변수, 아이템, 값은 타입을 가집니다. _값_의 _타입_은 해당 값을 보유한 메모리의 해석 방식과 해당 값에 대해 수행할 수 있는 연산을 정의합니다.</p>
<div class="rule" id="r-type.builtin"><a class="rule-link" href="types.html#r-type.builtin" title="type.builtin"><span>[type<wbr>.builtin]<span/></a></div>
<p>내장 타입(Built-in types)은 언어에 긴밀하게 통합되어 있으며, 사용자 정의 타입으로는 흉내 낼 수 없는 복잡한 방식으로 작동합니다.</p>
<div class="rule" id="r-type.user-defined"><a class="rule-link" href="types.html#r-type.user-defined" title="type.user-defined"><span>[type<wbr>.user-defined]<span/></a></div>
<p>사용자 정의 타입은 제한된 능력을 갖습니다.</p>
<div class="rule" id="r-type.kinds"><a class="rule-link" href="types.html#r-type.kinds" title="type.kinds"><span>[type<wbr>.kinds]<span/></a></div>
<p>타입 목록은 다음과 같습니다:</p>
<ul>
<li>기본 타입(Primitive types):
<ul>
<li><a href="types/boolean.html">불리언</a> — <code>bool</code></li>
<li><a href="types/numeric.html">숫자</a> — 정수 및 부동 소수점</li>
<li><a href="types/textual.html">텍스트</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="types/never.html">네버</a> — <code>!</code> — 값이 없는 타입</li>
</ul>
</li>
<li>시퀀스 타입:
<ul>
<li><a href="types/tuple.html">튜플</a></li>
<li><a href="types/array.html">배열</a></li>
<li><a href="types/slice.html">슬라이스</a></li>
</ul>
</li>
<li>사용자 정의 타입:
<ul>
<li><a href="types/struct.html">구조체</a></li>
<li><a href="types/enum.html">열거형</a></li>
<li><a href="types/union.html">공용체</a></li>
</ul>
</li>
<li>함수 타입:
<ul>
<li><a href="types/function-item.html">함수</a></li>
<li><a href="types/closure.html">클로저</a></li>
</ul>
</li>
<li>포인터 타입:
<ul>
<li><a href="types/pointer.html#shared-references-">참조</a></li>
<li><a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a></li>
<li><a href="types/function-pointer.html">함수 포인터</a></li>
</ul>
</li>
<li>트레잇 타입:
<ul>
<li><a href="types/trait-object.html">트레잇 객체</a></li>
<li><a href="types/impl-trait.html">Impl 트레잇</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-type.name"><a class="rule-link" href="types.html#r-type.name" title="type.name"><span>[type<wbr>.name]<span/></a></div>
<h2 id="타입-표현식"><a class="header" href="#타입-표현식">타입 표현식</a></h2>
<div class="rule" id="r-type.name.syntax"><a class="rule-link" href="types.html#r-type.name.syntax" title="type.name.syntax"><span>[type<wbr>.name<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>타입</em> :<br />
      <em>바운드없는타입</em><br />
   | <a href="types/impl-trait.html"><em>Impl트레잇타입</em></a><br />
   | <a href="types/trait-object.html"><em>트레잇객체타입</em></a></p>
<p><em>바운드없는타입</em> :<br />
      <a href="types.html#parenthesized-types"><em>괄호로둘러싸인타입</em></a><br />
   | <a href="types/impl-trait.html"><em>하나의바운드를가진Impl트레잇타입</em></a><br />
   | <a href="types/trait-object.html"><em>하나의바운드를가진트레잇객체타입</em></a><br />
   | <a href="paths.html#paths-in-types"><em>타입경로</em></a><br />
   | <a href="types/tuple.html#tuple-types"><em>튜플타입</em></a><br />
   | <a href="types/never.html"><em>네버타입</em></a><br />
   | <a href="types/pointer.html#raw-pointers-const-and-mut"><em>원시포인터타입</em></a><br />
   | <a href="types/pointer.html#shared-references-"><em>참조타입</em></a><br />
   | <a href="types/array.html"><em>배열타입</em></a><br />
   | <a href="types/slice.html"><em>슬라이스타입</em></a><br />
   | <a href="types/inferred.html"><em>추론된타입</em></a><br />
   | <a href="paths.html#qualified-paths"><em>타입내한정된경로</em></a><br />
   | <a href="types/function-pointer.html"><em>Bare함수타입</em></a><br />
   | <a href="macros.html#macro-invocation"><em>매크로호출</em></a></p>
</blockquote>
<div class="rule" id="r-type.name.intro"><a class="rule-link" href="types.html#r-type.name.intro" title="type.name.intro"><span>[type<wbr>.name<wbr>.intro]<span/></a></div>
<p>위의 <em>Type</em> 구문 규칙에 정의된 _타입 표현식_은 타입을 참조하기 위한 구문입니다. 이는 다음을 참조할 수 있습니다:</p>
<div class="rule" id="r-type.name.sequence"><a class="rule-link" href="types.html#r-type.name.sequence" title="type.name.sequence"><span>[type<wbr>.name<wbr>.sequence]<span/></a></div>
<ul>
<li>시퀀스 타입 (<a href="types/tuple.html">튜플</a>, <a href="types/array.html">배열</a>, <a href="types/slice.html">슬라이스</a>).</li>
</ul>
<div class="rule" id="r-type.name.path"><a class="rule-link" href="types.html#r-type.name.path" title="type.name.path"><span>[type<wbr>.name<wbr>.path]<span/></a></div>
<ul>
<li>다음을 참조할 수 있는 <a href="paths.html#paths-in-types">타입 경로</a>:
<ul>
<li>기본 타입 (<a href="types/boolean.html">불리언</a>, <a href="types/numeric.html">숫자</a>, <a href="types/textual.html">텍스트</a>).</li>
<li><a href="items.html">아이템</a>으로의 경로 (<a href="types/struct.html">구조체</a>, <a href="types/enum.html">열거형</a>, <a href="types/union.html">공용체</a>, <a href="items/type-aliases.html">타입 별칭</a>, <a href="types/trait-object.html">트레잇</a>).</li>
<li><code>Self</code>가 구현 타입인 <a href="paths.html#self-1"><code>Self</code> 경로</a>.</li>
<li>제네릭 <a href="types/parameters.html">타입 파라미터</a>.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-type.name.pointer"><a class="rule-link" href="types.html#r-type.name.pointer" title="type.name.pointer"><span>[type<wbr>.name<wbr>.pointer]<span/></a></div>
<ul>
<li>포인터 타입 (<a href="types/pointer.html#shared-references-">참조</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a>, <a href="types/function-pointer.html">함수 포인터</a>).</li>
</ul>
<div class="rule" id="r-type.name.inference"><a class="rule-link" href="types.html#r-type.name.inference" title="type.name.inference"><span>[type<wbr>.name<wbr>.inference]<span/></a></div>
<ul>
<li>컴파일러에게 타입을 결정하도록 요청하는 <a href="types/inferred.html">추론된 타입</a>.</li>
</ul>
<div class="rule" id="r-type.name.grouped"><a class="rule-link" href="types.html#r-type.name.grouped" title="type.name.grouped"><span>[type<wbr>.name<wbr>.grouped]<span/></a></div>
<ul>
<li>모호성을 제거하기 위해 사용되는 <a href="types.html#parenthesized-types">괄호</a>.</li>
</ul>
<div class="rule" id="r-type.name.trait"><a class="rule-link" href="types.html#r-type.name.trait" title="type.name.trait"><span>[type<wbr>.name<wbr>.trait]<span/></a></div>
<ul>
<li>트레잇 타입: <a href="types/trait-object.html">트레잇 객체</a> 및 <a href="types/impl-trait.html">impl 트레잇</a>.</li>
</ul>
<div class="rule" id="r-type.name.never"><a class="rule-link" href="types.html#r-type.name.never" title="type.name.never"><span>[type<wbr>.name<wbr>.never]<span/></a></div>
<ul>
<li><a href="types/never.html">네버</a> 타입.</li>
</ul>
<div class="rule" id="r-type.name.macro-expansion"><a class="rule-link" href="types.html#r-type.name.macro-expansion" title="type.name.macro-expansion"><span>[type<wbr>.name<wbr>.macro-expansion]<span/></a></div>
<ul>
<li>타입 표현식으로 확장되는 <a href="macros.html">매크로</a>.</li>
</ul>
<div class="rule" id="r-type.name.parenthesized"><a class="rule-link" href="types.html#r-type.name.parenthesized" title="type.name.parenthesized"><span>[type<wbr>.name<wbr>.parenthesized]<span/></a></div>
<h3 id="괄호로-둘러싸인-타입"><a class="header" href="#괄호로-둘러싸인-타입">괄호로 둘러싸인 타입</a></h3>
<div class="rule" id="r-type.name.parenthesized.syntax"><a class="rule-link" href="types.html#r-type.name.parenthesized.syntax" title="type.name.parenthesized.syntax"><span>[type<wbr>.name<wbr>.parenthesized<wbr>.syntax]<span/></a></div>
<blockquote>
<p><em>괄호로둘러싸인타입</em> :<br />
   <code>(</code> <a href="types.html#type-expressions"><em>타입</em></a> <code>)</code></p>
</blockquote>
<div class="rule" id="r-type.name.parenthesized.intro"><a class="rule-link" href="types.html#r-type.name.parenthesized.intro" title="type.name.parenthesized.intro"><span>[type<wbr>.name<wbr>.parenthesized<wbr>.intro]<span/></a></div>
<p>어떤 상황에서는 타입의 조합이 모호할 수 있습니다. 모호성을 피하기 위해 타입 주위에 괄호를 사용하십시오. 예를 들어, <a href="types/pointer.html#shared-references-">참조 타입</a> 내의 <a href="trait-bounds.html">타입 바운드</a>를 위한 <code>+</code> 연산자는 바운드가 어디에 적용되는지 불분명하므로 괄호를 사용해야 합니다. 이러한 모호성 제거가 필요한 구문 규칙은 <a href="types.html#type-expressions"><em>Type</em></a> 규칙 대신 <a href="types.html#type-expressions"><em>TypeNoBounds</em></a> 규칙을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>type T&lt;'a&gt; = &amp;'a (dyn Any + Send);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.recursive"><a class="rule-link" href="types.html#r-type.recursive" title="type.recursive"><span>[type<wbr>.recursive]<span/></a></div>
<h2 id="재귀적-타입"><a class="header" href="#재귀적-타입">재귀적 타입</a></h2>
<div class="rule" id="r-type.recursive.intro"><a class="rule-link" href="types.html#r-type.recursive.intro" title="type.recursive.intro"><span>[type<wbr>.recursive<wbr>.intro]<span/></a></div>
<p>명목적 타입(Nominal types)인 <a href="types/struct.html">구조체</a>, <a href="types/enum.html">열거형</a>, <a href="types/union.html">공용체</a>는 재귀적일 수 있습니다. 즉, 각 <code>enum</code> 변형이나 <code>struct</code> 또는 <code>union</code> 필드는 자신을 둘러싼 <code>enum</code> 또는 <code>struct</code> 타입 자체를 직접적 또는 간접적으로 참조할 수 있습니다.</p>
<div class="rule" id="r-type.recursive.constraint"><a class="rule-link" href="types.html#r-type.recursive.constraint" title="type.recursive.constraint"><span>[type<wbr>.recursive<wbr>.constraint]<span/></a></div>
<p>이러한 재귀에는 제한 사항이 있습니다:</p>
<ul>
<li>재귀적 타입은 재귀 과정에 반드시 명목적 타입을 포함해야 합니다(단순한 <a href="items/type-aliases.html">타입 별칭</a>이나 <a href="types/array.html">배열</a>, <a href="types/tuple.html">튜플</a>과 같은 다른 구조적 타입만으로는 안 됩니다). 따라서 <code>type Rec = &amp;'static [Rec]</code>은 허용되지 않습니다.</li>
<li>재귀적 타입의 크기는 유한해야 합니다. 다시 말해, 해당 타입의 재귀적 필드는 반드시 <a href="types/pointer.html">포인터 타입</a>이어야 합니다.</li>
</ul>
<p><em>재귀적</em> 타입과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.bool"><a class="rule-link" href="types/boolean.html#r-type.bool" title="type.bool"><span>[type<wbr>.bool]<span/></a></div>
<h1 id="불리언-타입"><a class="header" href="#불리언-타입">불리언 타입</a></h1>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: bool = true;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.bool.intro"><a class="rule-link" href="types/boolean.html#r-type.bool.intro" title="type.bool.intro"><span>[type<wbr>.bool<wbr>.intro]<span/></a></div>
<p><em>불리언 타입</em> 또는 _bool_은 _true_와 _false_라고 불리는 두 가지 값 중 하나를 가질 수 있는 기본 데이터 타입입니다.</p>
<div class="rule" id="r-type.bool.literal"><a class="rule-link" href="types/boolean.html#r-type.bool.literal" title="type.bool.literal"><span>[type<wbr>.bool<wbr>.literal]<span/></a></div>
<p>이 타입의 값은 같은 이름의 값에 해당하는 <code>true</code> 및 <code>false</code> 키워드를 사용한 <a href="types/../expressions/literal-expr.html">리터럴 표현식</a>을 통해 생성될 수 있습니다.</p>
<div class="rule" id="r-type.bool.namespace"><a class="rule-link" href="types/boolean.html#r-type.bool.namespace" title="type.bool.namespace"><span>[type<wbr>.bool<wbr>.namespace]<span/></a></div>
<p>이 타입은 <a href="types/../names.html"><code>bool</code></a>이라는 이름으로 <a href="types/../names/preludes.html#language-prelude">언어 프렐류드</a>의 일부입니다.</p>
<div class="rule" id="r-type.bool.layout"><a class="rule-link" href="types/boolean.html#r-type.bool.layout" title="type.bool.layout"><span>[type<wbr>.bool<wbr>.layout]<span/></a></div>
<p>불리언 타입을 가진 객체는 <a href="types/../type-layout.html#size-and-alignment">크기와 정렬</a>이 각각 1입니다.</p>
<div class="rule" id="r-type.bool.repr"><a class="rule-link" href="types/boolean.html#r-type.bool.repr" title="type.bool.repr"><span>[type<wbr>.bool<wbr>.repr]<span/></a></div>
<p>false 값은 비트 패턴 <code>0x00</code>을 가지며, true 값은 비트 패턴 <code>0x01</code>을 가집니다. 불리언 타입을 가진 객체가 그 외의 비트 패턴을 갖는 것은 <a href="types/../behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>입니다.</p>
<div class="rule" id="r-type.bool.usage"><a class="rule-link" href="types/boolean.html#r-type.bool.usage" title="type.bool.usage"><span>[type<wbr>.bool<wbr>.usage]<span/></a></div>
<p>불리언 타입은 다양한 <a href="types/../expressions.html">표현식</a>에서 많은 피연산자의 타입으로 사용됩니다:</p>
<div class="rule" id="r-type.bool.usage-condition"><a class="rule-link" href="types/boolean.html#r-type.bool.usage-condition" title="type.bool.usage-condition"><span>[type<wbr>.bool<wbr>.usage-condition]<span/></a></div>
<ul>
<li><a href="types/../expressions/if-expr.html#if-expressions"><code>if</code> 표현식</a> 및 <a href="types/../expressions/loop-expr.html#predicate-loops"><code>while</code> 표현식</a>의 조건 피연산자</li>
</ul>
<div class="rule" id="r-type.bool.usage-lazy-operator"><a class="rule-link" href="types/boolean.html#r-type.bool.usage-lazy-operator" title="type.bool.usage-lazy-operator"><span>[type<wbr>.bool<wbr>.usage-lazy-operator]<span/></a></div>
<ul>
<li><a href="types/../expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 연산자 표현식</a>의 피연산자</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 불리언 타입은 <a href="types/enum.html">열거형 타입</a>과 유사하게 작동하지만 열거형은 아닙니다. 실제로 이는 주로 생성자가 타입에 연관되지 않음을 의미합니다 (예: <code>bool::true</code>).</p>
</blockquote>
<div class="rule" id="r-type.bool.traits"><a class="rule-link" href="types/boolean.html#r-type.bool.traits" title="type.bool.traits"><span>[type<wbr>.bool<wbr>.traits]<span/></a></div>
<p>모든 기본 타입과 마찬가지로, 불리언 타입은 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a>, <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>, <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> <a href="types/../items/traits.html">트레잇</a>을 <a href="types/../items/implementations.html">구현</a>합니다.</p>
<blockquote>
<p><strong>참고</strong>: 라이브러리 연산에 대해서는 <a href="types/../../std/primitive.bool.html">표준 라이브러리 문서</a>를 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-type.bool.expr"><a class="rule-link" href="types/boolean.html#r-type.bool.expr" title="type.bool.expr"><span>[type<wbr>.bool<wbr>.expr]<span/></a></div>
<h2 id="불리언-값에-대한-연산"><a class="header" href="#불리언-값에-대한-연산">불리언 값에 대한 연산</a></h2>
<!-- This is washy wording --> When using certain operator expressions with a
<p>피연산자로 불리언 타입을 사용하며, <a href="https://ko.wikipedia.org/wiki/%EB%B6%88_%EB%8C%80%EC%88%98">불리언 로직</a> 규칙을 사용하여 평가됩니다.</p>
<div class="rule" id="r-type.bool.expr.not"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.not" title="type.bool.expr.not"><span>[type<wbr>.bool<wbr>.expr<wbr>.not]<span/></a></div>
<h3 id="논리-부정-logical-not"><a class="header" href="#논리-부정-logical-not">논리 부정 (Logical not)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#negation-operators"><code>!b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.or"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.or" title="type.bool.expr.or"><span>[type<wbr>.bool<wbr>.expr<wbr>.or]<span/></a></div>
<h3 id="논리-합-logical-or"><a class="header" href="#논리-합-logical-or">논리 합 (Logical or)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a | b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.and"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.and" title="type.bool.expr.and"><span>[type<wbr>.bool<wbr>.expr<wbr>.and]<span/></a></div>
<h3 id="논리-곱-logical-and"><a class="header" href="#논리-곱-logical-and">논리 곱 (Logical and)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a &amp; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.xor"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.xor" title="type.bool.expr.xor"><span>[type<wbr>.bool<wbr>.expr<wbr>.xor]<span/></a></div>
<h3 id="논리-배타적-합-logical-xor"><a class="header" href="#논리-배타적-합-logical-xor">논리 배타적 합 (Logical xor)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a ^ b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.cmp"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp" title="type.bool.expr.cmp"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp]<span/></a></div>
<h3 id="비교"><a class="header" href="#비교">비교</a></h3>
<div class="rule" id="r-type.bool.expr.cmp.eq"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.eq" title="type.bool.expr.cmp.eq"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.eq]<span/></a></div>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a == b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.cmp.greater"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.greater" title="type.bool.expr.cmp.greater"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.greater]<span/></a></div>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a &gt; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div><div class="rule" id="r-type.bool.expr.cmp.not-eq"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.not-eq" title="type.bool.expr.cmp.not-eq"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.not-eq]<span/></a></div>
<ul>
<li><code>a != b</code>는 <code>!(a == b)</code>와 동일합니다</li>
</ul>
<div class="rule" id="r-type.bool.expr.cmp.greater-eq"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.greater-eq" title="type.bool.expr.cmp.greater-eq"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.greater-eq]<span/></a></div>
<ul>
<li><code>a &gt;= b</code>는 <code>a == b | a &gt; b</code>와 동일합니다</li>
</ul>
<div class="rule" id="r-type.bool.expr.cmp.less"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.less" title="type.bool.expr.cmp.less"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.less]<span/></a></div>
<ul>
<li><code>a &lt; b</code>는 <code>!(a &gt;= b)</code>와 동일합니다</li>
</ul>
<div class="rule" id="r-type.bool.expr.cmp.less-eq"><a class="rule-link" href="types/boolean.html#r-type.bool.expr.cmp.less-eq" title="type.bool.expr.cmp.less-eq"><span>[type<wbr>.bool<wbr>.expr<wbr>.cmp<wbr>.less-eq]<span/></a></div>
<ul>
<li><code>a &lt;= b</code>는 <code>a == b | a &lt; b</code>와 동일합니다</li>
</ul>
<div class="rule" id="r-type.bool.validity"><a class="rule-link" href="types/boolean.html#r-type.bool.validity" title="type.bool.validity"><span>[type<wbr>.bool<wbr>.validity]<span/></a></div>
<h2 id="비트-유효성"><a class="header" href="#비트-유효성">비트 유효성</a></h2>
<p><code>bool</code>의 단일 바이트는 초기화됨이 보장됩니다 (다시 말해, <code>transmute::&lt;bool, u8&gt;(...)</code>는 항상 안전(sound)합니다. 하지만 일부 비트 패턴은 유효하지 않은 <code>bool</code> 값이므로, 그 역은 항상 안전하지는 않습니다).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.numeric"><a class="rule-link" href="types/numeric.html#r-type.numeric" title="type.numeric"><span>[type<wbr>.numeric]<span/></a></div>
<h1 id="숫자-타입"><a class="header" href="#숫자-타입">숫자 타입</a></h1>
<div class="rule" id="r-type.numeric.int"><a class="rule-link" href="types/numeric.html#r-type.numeric.int" title="type.numeric.int"><span>[type<wbr>.numeric<wbr>.int]<span/></a></div>
<h2 id="정수-타입"><a class="header" href="#정수-타입">정수 타입</a></h2>
<div class="rule" id="r-type.numeric.int.unsigned"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.unsigned" title="type.numeric.int.unsigned"><span>[type<wbr>.numeric<wbr>.int<wbr>.unsigned]<span/></a></div>
<p>부호 없는 정수 타입은 다음과 같이 구성됩니다:</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th>최소값</th><th>최대값</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td></tr>
</tbody></table>
</div><div class="rule" id="r-type.numeric.int.signed"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.signed" title="type.numeric.int.signed"><span>[type<wbr>.numeric<wbr>.int<wbr>.signed]<span/></a></div>
<p>부호 있는 2의 보수 정수 타입은 다음과 같이 구성됩니다:</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th>최소값</th><th>최대값</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td></tr>
</tbody></table>
</div><div class="rule" id="r-type.numeric.float"><a class="rule-link" href="types/numeric.html#r-type.numeric.float" title="type.numeric.float"><span>[type<wbr>.numeric<wbr>.float]<span/></a></div>
<h2 id="부동-소수점-타입"><a class="header" href="#부동-소수점-타입">부동 소수점 타입</a></h2>
<p>IEEE 754-2008 “binary32” 및 “binary64” 부동 소수점 타입은 각각 <code>f32</code>와 <code>f64</code>입니다.</p>
<div class="rule" id="r-type.numeric.int.size"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.size" title="type.numeric.int.size"><span>[type<wbr>.numeric<wbr>.int<wbr>.size]<span/></a></div>
<h2 id="머신-의존적-정수-타입"><a class="header" href="#머신-의존적-정수-타입">머신 의존적 정수 타입</a></h2>
<div class="rule" id="r-type.numeric.int.size.usize"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.size.usize" title="type.numeric.int.size.usize"><span>[type<wbr>.numeric<wbr>.int<wbr>.size<wbr>.usize]<span/></a></div>
<p><code>usize</code> 타입은 플랫폼의 포인터 타입과 동일한 비트 수를 가진 부호 없는 정수 타입입니다. 이는 프로세스의 모든 메모리 주소를 나타낼 수 있습니다.</p>
<div class="rule" id="r-type.numeric.int.size.isize"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.size.isize" title="type.numeric.int.size.isize"><span>[type<wbr>.numeric<wbr>.int<wbr>.size<wbr>.isize]<span/></a></div>
<p><code>isize</code> 타입은 플랫폼의 포인터 타입과 동일한 비트 수를 가진 부호 있는 정수 타입입니다. 객체 및 배열 크기의 이론적 상한선은 <code>isize</code>의 최대값입니다. 이를 통해 <code>isize</code>를 사용하여 객체나 배열 내부의 포인터 간 차이를 계산할 수 있으며, 객체 내의 모든 바이트와 끝에서 한 바이트 더 뒤의 주소를 가리킬 수 있음을 보장합니다.</p>
<div class="rule" id="r-type.numeric.int.size.minimum"><a class="rule-link" href="types/numeric.html#r-type.numeric.int.size.minimum" title="type.numeric.int.size.minimum"><span>[type<wbr>.numeric<wbr>.int<wbr>.size<wbr>.minimum]<span/></a></div>
<p><code>usize</code> 및 <code>isize</code>는 최소 16비트 너비입니다.</p>
<blockquote>
<p><strong>참고</strong>: 많은 러스트 코드들이 포인터, <code>usize</code>, <code>isize</code>가 32비트 또는 64비트라고 가정할 수 있습니다. 결과적으로 16비트 포인터 지원은 제한적이며, 라이브러리에서 이를 지원하려면 명시적인 주의와 인지가 필요할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-type.numeric.validity"><a class="rule-link" href="types/numeric.html#r-type.numeric.validity" title="type.numeric.validity"><span>[type<wbr>.numeric<wbr>.validity]<span/></a></div>
<h2 id="비트-유효성-1"><a class="header" href="#비트-유효성-1">비트 유효성</a></h2>
<p>모든 숫자 타입 <code>T</code>에 대해, <code>T</code>의 비트 유효성은 <code>[u8; size_of::&lt;T&gt;()]</code>의 비트 유효성과 동일합니다. 초기화되지 않은 바이트는 유효한 <code>u8</code>이 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.text"><a class="rule-link" href="types/textual.html#r-type.text" title="type.text"><span>[type<wbr>.text]<span/></a></div>
<h1 id="텍스트-타입"><a class="header" href="#텍스트-타입">텍스트 타입</a></h1>
<div class="rule" id="r-type.text.intro"><a class="rule-link" href="types/textual.html#r-type.text.intro" title="type.text.intro"><span>[type<wbr>.text<wbr>.intro]<span/></a></div>
<p><code>char</code> 및 <code>str</code> 타입은 텍스트 데이터를 보유합니다.</p>
<div class="rule" id="r-type.text.char-value"><a class="rule-link" href="types/textual.html#r-type.text.char-value" title="type.text.char-value"><span>[type<wbr>.text<wbr>.char-value]<span/></a></div>
<p><code>char</code> 타입의 값은 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>(즉, 서로게이트가 아닌 코드 포인트)이며, 0x0000에서 0xD7FF 또는 0xE000에서 0x10FFFF 범위의 32비트 부호 없는 워드로 표현됩니다.</p>
<div class="rule" id="r-type.text.char-precondition"><a class="rule-link" href="types/textual.html#r-type.text.char-precondition" title="type.text.char-precondition"><span>[type<wbr>.text<wbr>.char-precondition]<span/></a></div>
<p>이 범위를 벗어나는 <code>char</code>를 생성하는 것은 즉각적인 <a href="types/../behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>입니다. <code>[char]</code>는 실질적으로 길이가 1인 UCS-4 / UTF-32 문자열입니다.</p>
<div class="rule" id="r-type.text.str-value"><a class="rule-link" href="types/textual.html#r-type.text.str-value" title="type.text.str-value"><span>[type<wbr>.text<wbr>.str-value]<span/></a></div>
<p><code>str</code> 타입의 값은 8비트 부호 없는 바이트의 슬라이스인 <code>[u8]</code>과 동일한 방식으로 표현됩니다. 그러나 러스트 표준 라이브러리는 <code>str</code>에 대해 추가적인 가정을 합니다. <code>str</code>에서 작동하는 메서드들은 그 안의 데이터가 유효한 UTF-8이라고 가정하고 이를 보장합니다. UTF-8이 아닌 버퍼로 <code>str</code> 메서드를 호출하는 것은 현재 또는 미래에 <a href="types/../behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>을 유발할 수 있습니다.</p>
<div class="rule" id="r-type.text.str-unsized"><a class="rule-link" href="types/textual.html#r-type.text.str-unsized" title="type.text.str-unsized"><span>[type<wbr>.text<wbr>.str-unsized]<span/></a></div>
<p><code>str</code>은 <a href="types/../dynamically-sized-types.html">동적 크기 타입(dynamically sized type)</a>이므로, <code>&amp;str</code>과 같은 포인터 타입을 통해서만 인스턴스화할 수 있습니다.</p>
<div class="rule" id="r-type.text.layout"><a class="rule-link" href="types/textual.html#r-type.text.layout" title="type.text.layout"><span>[type<wbr>.text<wbr>.layout]<span/></a></div>
<h2 id="레이아웃-및-비트-유효성"><a class="header" href="#레이아웃-및-비트-유효성">레이아웃 및 비트 유효성</a></h2>
<div class="rule" id="r-type.layout.char-layout"><a class="rule-link" href="types/textual.html#r-type.layout.char-layout" title="type.layout.char-layout"><span>[type<wbr>.layout<wbr>.char-layout]<span/></a></div>
<p><code>char</code>는 모든 플랫폼에서 <code>u32</code>와 동일한 크기 및 정렬을 가짐이 보장됩니다.</p>
<div class="rule" id="r-type.layout.char-validity"><a class="rule-link" href="types/textual.html#r-type.layout.char-validity" title="type.layout.char-validity"><span>[type<wbr>.layout<wbr>.char-validity]<span/></a></div>
<p><code>char</code>의 모든 바이트는 초기화됨이 보장됩니다 (다시 말해, <code>transmute::&lt;char, [u8; size_of::&lt;char&gt;()]&gt;(...)</code>는 항상 안전(sound)합니다. 하지만 일부 비트 패턴은 유효하지 않은 <code>char</code> 값이므로, 그 역은 항상 안전하지는 않습니다).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.never"><a class="rule-link" href="types/never.html#r-type.never" title="type.never"><span>[type<wbr>.never]<span/></a></div>
<h1 id="결코-리턴하지-않는-타입"><a class="header" href="#결코-리턴하지-않는-타입">결코 리턴하지 않는 타입</a></h1>
<div class="rule" id="r-type.never.syntax"><a class="rule-link" href="types/never.html#r-type.never.syntax" title="type.never.syntax"><span>[type<wbr>.never<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>네버타입</em> : <code>!</code><strong><sup>구문</sup></strong><br />
<em>네버타입</em> : <code>!</code></p>
</blockquote>
<div class="rule" id="r-type.never.intro"><a class="rule-link" href="types/never.html#r-type.never.intro" title="type.never.intro"><span>[type<wbr>.never<wbr>.intro]<span/></a></div>
<p>네버 타입 <code>!</code>은 값이 없는 타입으로, 결코 완료되지 않는 계산의 결과를 나타냅니다.</p>
<div class="rule" id="r-type.never.coercion"><a class="rule-link" href="types/never.html#r-type.never.coercion" title="type.never.coercion"><span>[type<wbr>.never<wbr>.coercion]<span/></a></div>
<p><code>!</code> 타입의 표현식은 다른 어떤 타입으로도 강제 변환(coerced)될 수 있습니다.</p>
<div class="rule" id="r-type.never.constraint"><a class="rule-link" href="types/never.html#r-type.never.constraint" title="type.never.constraint"><span>[type<wbr>.never<wbr>.constraint]<span/></a></div>
<p>현재 <code>!</code> 타입은 함수의 반환 타입에만 나타날 수 있으며, 이는 함수가 결코 반환되지 않는 발산 함수(diverging function)임을 나타냅니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!("이 호출은 결코 반환되지 않습니다.");
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    pub safe fn no_return_extern_func() -&gt; !;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.tuple"><a class="rule-link" href="types/tuple.html#r-type.tuple" title="type.tuple"><span>[type<wbr>.tuple]<span/></a></div>
<h1 id="튜플-타입"><a class="header" href="#튜플-타입">튜플 타입</a></h1>
<div class="rule" id="r-type.tuple.syntax"><a class="rule-link" href="types/tuple.html#r-type.tuple.syntax" title="type.tuple.syntax"><span>[type<wbr>.tuple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플타입</em> :<br />
      <code>( )</code><br />
   | <code>(</code> ( <a href="types/../types.html#type-expressions"><em>타입</em></a> <code>,</code> )<sup>+</sup> <a href="types/../types.html#type-expressions"><em>타입</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<div class="rule" id="r-type.tuple.intro"><a class="rule-link" href="types/tuple.html#r-type.tuple.intro" title="type.tuple.intro"><span>[type<wbr>.tuple<wbr>.intro]<span/></a></div>
<p>_튜플 타입_은 다른 타입들의 이종 목록(heterogeneous list)을 위한 구조적 타입<sup class="footnote-reference"><a href="#1">1</a></sup> 군입니다.</p>
<p>튜플 타입의 구문은 괄호로 둘러싸인, 쉼표로 구분된 타입 목록입니다.</p>
<div class="rule" id="r-type.tuple.restriction"><a class="rule-link" href="types/tuple.html#r-type.tuple.restriction" title="type.tuple.restriction"><span>[type<wbr>.tuple<wbr>.restriction]<span/></a></div>
<p>1-ary tuples require a comma after their element type to be disambiguated with a <a href="types/../types.html#parenthesized-types">parenthesized type</a>.</p>
<div class="rule" id="r-type.tuple.field-number"><a class="rule-link" href="types/tuple.html#r-type.tuple.field-number" title="type.tuple.field-number"><span>[type<wbr>.tuple<wbr>.field-number]<span/></a></div>
<p>튜플 타입은 타입 목록의 길이와 동일한 수의 필드를 가집니다. 이 필드의 수는 튜플의 _항수(arity)_를 결정합니다. <code>n</code>개의 필드를 가진 튜플을 _n-항 튜플(n-ary tuple)_이라고 합니다. 예를 들어, 2개의 필드를 가진 튜플은 2-항 튜플입니다.</p>
<div class="rule" id="r-type.tuple.field-name"><a class="rule-link" href="types/tuple.html#r-type.tuple.field-name" title="type.tuple.field-name"><span>[type<wbr>.tuple<wbr>.field-name]<span/></a></div>
<p>튜플의 필드 이름은 타입 목록에서의 위치에 따라 증가하는 숫자를 사용하여 명명됩니다. 첫 번째 필드는 <code>0</code>, 두 번째 필드는 <code>1</code>과 같은 식입니다. 각 필드의 타입은 튜플의 타입 목록에서 동일한 위치에 있는 타입입니다.</p>
<div class="rule" id="r-type.tuple.unit"><a class="rule-link" href="types/tuple.html#r-type.tuple.unit" title="type.tuple.unit"><span>[type<wbr>.tuple<wbr>.unit]<span/></a></div>
<p>편의상 그리고 역사적인 이유로, 필드가 없는 튜플 타입(<code>()</code>)은 흔히 <em>유닛(unit)</em> 또는 _유닛 타입_이라고 불립니다. 이 타입의 유일한 값 또한 <em>유닛</em> 또는 _유닛 값_이라고 불립니다.</p>
<p>튜플 타입의 몇 가지 예시:</p>
<ul>
<li><code>()</code> (유닛)</li>
<li><code>(i32,)</code> (1-항 튜플)</li>
<li><code>(f64, f64)</code></li>
<li><code>(String, i32)</code></li>
<li><code>(i32, String)</code> (이전 예시와는 다른 타입임)</li>
<li><code>(i32, f64, Vec&lt;String&gt;, Option&lt;bool&gt;)</code></li>
</ul>
<div class="rule" id="r-type.tuple.constructor"><a class="rule-link" href="types/tuple.html#r-type.tuple.constructor" title="type.tuple.constructor"><span>[type<wbr>.tuple<wbr>.constructor]<span/></a></div>
<p>이 타입의 값은 <a href="types/../expressions/tuple-expr.html#tuple-expressions">튜플 표현식</a>을 사용하여 생성됩니다. 나아가, 다양한 표현식들이 평가할 다른 의미 있는 값이 없을 때 유닛 값을 생성합니다.</p>
<div class="rule" id="r-type.tuple.access"><a class="rule-link" href="types/tuple.html#r-type.tuple.access" title="type.tuple.access"><span>[type<wbr>.tuple<wbr>.access]<span/></a></div>
<p>튜플 필드는 <a href="types/../expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스 표현식</a>이나 <a href="types/../patterns.html#tuple-patterns">패턴 매칭</a>을 통해 접근할 수 있습니다.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>구조적 타입은 내부 타입들이 동일하면 항상 동일한 것으로 간주됩니다. 튜플의 명목적 버전(nominal version)에 대해서는 <a href="types/./struct.html">튜플 구조체</a>를 참조하십시오.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.array"><a class="rule-link" href="types/array.html#r-type.array" title="type.array"><span>[type<wbr>.array]<span/></a></div>
<h1 id="배열-타입"><a class="header" href="#배열-타입">배열 타입</a></h1>
<div class="rule" id="r-type.array.syntax"><a class="rule-link" href="types/array.html#r-type.array.syntax" title="type.array.syntax"><span>[type<wbr>.array<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>배열타입</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>타입</em></a> <code>;</code> <a href="types/../expressions.html"><em>표현식</em></a> <code>]</code></p>
</blockquote>
<div class="rule" id="r-type.array.intro"><a class="rule-link" href="types/array.html#r-type.array.intro" title="type.array.intro"><span>[type<wbr>.array<wbr>.intro]<span/></a></div>
<p>배열은 <code>T</code> 타입의 요소 <code>N</code>개로 구성된 고정 크기 시퀀스입니다. 배열 타입은 <code>[T; N]</code>으로 작성됩니다.</p>
<div class="rule" id="r-type.array.constraint"><a class="rule-link" href="types/array.html#r-type.array.constraint" title="type.array.constraint"><span>[type<wbr>.array<wbr>.constraint]<span/></a></div>
<p>크기는 <a href="types/numeric.html#machine-dependent-integer-types"><code>usize</code></a>로 평가되는 <a href="types/../const_eval.html#constant-expressions">상수 표현식</a>입니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 스택에 할당된 배열
let array: [i32; 3] = [1, 2, 3];

// 힙에 할당된 배열, 슬라이스로 강제 변환됨
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.array.index"><a class="rule-link" href="types/array.html#r-type.array.index" title="type.array.index"><span>[type<wbr>.array<wbr>.index]<span/></a></div>
<p>배열의 모든 요소는 항상 초기화되며, 안전한 메서드 및 연산자에서의 배열 접근은 항상 경계 검사(bounds-checked)가 이루어집니다.</p>
<blockquote>
<p>참고: <a href="types/../../alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 표준 라이브러리 타입은 힙에 할당되는 크기 조정 가능한 배열 타입을 제공합니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.slice"><a class="rule-link" href="types/slice.html#r-type.slice" title="type.slice"><span>[type<wbr>.slice]<span/></a></div>
<h1 id="슬라이스-타입"><a class="header" href="#슬라이스-타입">슬라이스 타입</a></h1>
<div class="rule" id="r-type.slice.syntax"><a class="rule-link" href="types/slice.html#r-type.slice.syntax" title="type.slice.syntax"><span>[type<wbr>.slice<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>슬라이스타입</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>타입</em></a> <code>]</code></p>
</blockquote>
<div class="rule" id="r-type.slice.intro"><a class="rule-link" href="types/slice.html#r-type.slice.intro" title="type.slice.intro"><span>[type<wbr>.slice<wbr>.intro]<span/></a></div>
<p>슬라이스는 <code>T</code> 타입 요소 시퀀스에 대한 ’뷰(view)’를 나타내는 <a href="types/../dynamically-sized-types.html">동적 크기 타입(dynamically sized type)</a>입니다. 슬라이스 타입은 <code>[T]</code>로 작성됩니다.</p>
<div class="rule" id="r-type.slice.unsized"><a class="rule-link" href="types/slice.html#r-type.slice.unsized" title="type.slice.unsized"><span>[type<wbr>.slice<wbr>.unsized]<span/></a></div>
<p>슬라이스 타입은 일반적으로 포인터 타입을 통해 사용됩니다. 예시:</p>
<ul>
<li><code>&amp;[T]</code>: ’공유 슬라이스’로, 흔히 그냥 ’슬라이스’라고 불립니다. 가리키는 데이터를 소유하지 않고 차용합니다.</li>
<li><code>&amp;mut [T]</code>: ’가변 슬라이스’입니다. 가리키는 데이터를 가변적으로 차용합니다.</li>
<li><code>Box&lt;[T]&gt;</code>: ‘박스드 슬라이스(boxed slice)’</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 힙에 할당된 배열, 슬라이스로 강제 변환됨
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// 배열에 대한 (공유) 슬라이스
let slice: &amp;[i32] = &amp;boxed_array[..];
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.slice.safe"><a class="rule-link" href="types/slice.html#r-type.slice.safe" title="type.slice.safe"><span>[type<wbr>.slice<wbr>.safe]<span/></a></div>
<p>슬라이스의 모든 요소는 항상 초기화되며, 안전한 메서드 및 연산자에서의 슬라이스 접근은 항상 경계 검사(bounds-checked)가 이루어집니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.struct"><a class="rule-link" href="types/struct.html#r-type.struct" title="type.struct"><span>[type<wbr>.struct]<span/></a></div>
<h1 id="구조체-타입"><a class="header" href="#구조체-타입">구조체 타입</a></h1>
<div class="rule" id="r-type.struct.intro"><a class="rule-link" href="types/struct.html#r-type.struct.intro" title="type.struct.intro"><span>[type<wbr>.struct<wbr>.intro]<span/></a></div>
<p><code>struct</code> _타입_은 해당 타입의 _필드_라고 불리는 다른 타입들의 이종 곱(heterogeneous product)입니다.<sup class="footnote-reference"><a href="#structtype">1</a></sup></p>
<div class="rule" id="r-type.struct.constructor"><a class="rule-link" href="types/struct.html#r-type.struct.constructor" title="type.struct.constructor"><span>[type<wbr>.struct<wbr>.constructor]<span/></a></div>
<p><code>struct</code>의 새 인스턴스는 <a href="types/../expressions/struct-expr.html">구조체 표현식</a>을 통해 생성될 수 있습니다.</p>
<div class="rule" id="r-type.struct.layout"><a class="rule-link" href="types/struct.html#r-type.struct.layout" title="type.struct.layout"><span>[type<wbr>.struct<wbr>.layout]<span/></a></div>
<p><code>struct</code>의 메모리 레이아웃은 필드 재정렬과 같은 컴파일러 최적화를 허용하기 위해 기본적으로 정의되지 않지만, <a href="types/../type-layout.html#representations"><code>repr</code> 속성</a>을 사용하여 고정할 수 있습니다. 어떤 경우든 대응하는 구조체 _표현식_에서는 필드를 어떤 순서로든 제공할 수 있으며, 결과물인 <code>struct</code> 값은 항상 동일한 메모리 레이아웃을 갖습니다.</p>
<div class="rule" id="r-type.struct.field-visibility"><a class="rule-link" href="types/struct.html#r-type.struct.field-visibility" title="type.struct.field-visibility"><span>[type<wbr>.struct<wbr>.field-visibility]<span/></a></div>
<p><code>struct</code>의 필드는 모듈 외부에서 구조체 데이터에 접근할 수 있도록 <a href="types/../visibility-and-privacy.html">가시성 수정자(visibility modifiers)</a>로 수식될 수 있습니다.</p>
<div class="rule" id="r-type.struct.tuple"><a class="rule-link" href="types/struct.html#r-type.struct.tuple" title="type.struct.tuple"><span>[type<wbr>.struct<wbr>.tuple]<span/></a></div>
<p><em>튜플 구조체</em> 타입은 필드가 익명이라는 점을 제외하면 구조체 타입과 동일합니다.</p>
<div class="rule" id="r-type.struct.unit"><a class="rule-link" href="types/struct.html#r-type.struct.unit" title="type.struct.unit"><span>[type<wbr>.struct<wbr>.unit]<span/></a></div>
<p><em>유닛 형태 구조체</em> 타입은 필드가 없다는 점을 제외하면 구조체 타입과 같습니다. 연관된 <a href="types/../expressions/struct-expr.html">구조체 표현식</a>에 의해 생성된 유일한 값이 이 타입에 속하는 유일한 값입니다.</p>
<div class="footnote-definition" id="structtype"><sup class="footnote-definition-label">1</sup>
<p><code>struct</code> 타입은 C의 <code>struct</code> 타입, ML 언어군의 <em>레코드(record)</em> 타입, 또는 Lisp 언어군의 <em>struct</em> 타입과 유사합니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.enum"><a class="rule-link" href="types/enum.html#r-type.enum" title="type.enum"><span>[type<wbr>.enum]<span/></a></div>
<h1 id="열거-타입"><a class="header" href="#열거-타입">열거 타입</a></h1>
<div class="rule" id="r-type.enum.intro"><a class="rule-link" href="types/enum.html#r-type.enum.intro" title="type.enum.intro"><span>[type<wbr>.enum<wbr>.intro]<span/></a></div>
<p>_열거형 타입(enumerated type)_은 명목적이고 이종의 서로소 합집합(disjoint union) 타입이며, <a href="types/../items/enumerations.html"><code>enum</code> 아이템</a>의 이름으로 나타내어집니다. <sup class="footnote-reference"><a href="#enumtype">1</a></sup></p>
<div class="rule" id="r-type.enum.declaration"><a class="rule-link" href="types/enum.html#r-type.enum.declaration" title="type.enum.declaration"><span>[type<wbr>.enum<wbr>.declaration]<span/></a></div>
<p><a href="types/../items/enumerations.html"><code>enum</code> 아이템</a>은 타입과 여러 개의 _변형(variants)_을 선언하며, 각 변형은 독립적인 이름을 가지고 구조체, 튜플 구조체 또는 유닛 형태 구조체의 구문을 가집니다.</p>
<div class="rule" id="r-type.enum.constructor"><a class="rule-link" href="types/enum.html#r-type.enum.constructor" title="type.enum.constructor"><span>[type<wbr>.enum<wbr>.constructor]<span/></a></div>
<p><code>enum</code>의 새 인스턴스는 <a href="types/../expressions/struct-expr.html">구조체 표현식</a>을 통해 생성될 수 있습니다.</p>
<div class="rule" id="r-type.enum.value"><a class="rule-link" href="types/enum.html#r-type.enum.value" title="type.enum.value"><span>[type<wbr>.enum<wbr>.value]<span/></a></div>
<p>모든 <code>enum</code> 값은 대응하는 <code>enum</code> 타입의 가장 큰 변형만큼의 메모리와 판별자(discriminant)를 저장하는 데 필요한 크기를 소비합니다.</p>
<div class="rule" id="r-type.enum.name"><a class="rule-link" href="types/enum.html#r-type.enum.name" title="type.enum.name"><span>[type<wbr>.enum<wbr>.name]<span/></a></div>
<p>열거형 타입은 타입으로서 <em>구조적으로</em> 나타낼 수 없으며, 반드시 <a href="types/../items/enumerations.html"><code>enum</code> 아이템</a>에 대한 이름 있는 참조로 나타내어야 합니다.</p>
<div class="footnote-definition" id="enumtype"><sup class="footnote-definition-label">1</sup>
<p><code>enum</code> 타입은 Haskell의 <code>data</code> 생성자 선언이나 Limbo의 _pick ADT_와 유사합니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.union"><a class="rule-link" href="types/union.html#r-type.union" title="type.union"><span>[type<wbr>.union]<span/></a></div>
<h1 id="공용체-타입"><a class="header" href="#공용체-타입">공용체 타입</a></h1>
<div class="rule" id="r-type.union.intro"><a class="rule-link" href="types/union.html#r-type.union.intro" title="type.union.intro"><span>[type<wbr>.union<wbr>.intro]<span/></a></div>
<p>_공용체 타입(union type)_은 명목적이고 이종의 C와 유사한 공용체이며, <a href="types/../items/unions.html"><code>union</code> 아이템</a>의 이름으로 나타내어집니다.</p>
<div class="rule" id="r-type.union.access"><a class="rule-link" href="types/union.html#r-type.union.access" title="type.union.access"><span>[type<wbr>.union<wbr>.access]<span/></a></div>
<p>공용체에는 “활성 필드“라는 개념이 없습니다. 대신, 모든 공용체 접근은 공용체 내용의 일부를 접근된 필드의 타입으로 transmute합니다.</p>
<div class="rule" id="r-type.union.safety"><a class="rule-link" href="types/union.html#r-type.union.safety" title="type.union.safety"><span>[type<wbr>.union<wbr>.safety]<span/></a></div>
<p>transmute는 예기치 않거나 정의되지 않은 동작을 유발할 수 있으므로, 공용체 필드에서 읽으려면 <code>unsafe</code>가 필요합니다.</p>
<div class="rule" id="r-type.union.constraint"><a class="rule-link" href="types/union.html#r-type.union.constraint" title="type.union.constraint"><span>[type<wbr>.union<wbr>.constraint]<span/></a></div>
<p>공용체 필드 타입은 또한 드롭(drop)이 전혀 필요하지 않음을 보장하는 타입의 서브셋으로 제한됩니다. 자세한 내용은 <a href="types/../items/unions.html">아이템</a> 문서를 참조하십시오.</p>
<div class="rule" id="r-type.union.layout"><a class="rule-link" href="types/union.html#r-type.union.layout" title="type.union.layout"><span>[type<wbr>.union<wbr>.layout]<span/></a></div>
<p><code>union</code>의 메모리 레이아웃은 기본적으로 정의되지 않으며(특히, 필드가 오프셋 0에 위치할 필요가 없음), <code>#[repr(...)]</code> 속성을 사용하여 레이아웃을 고정할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.fn-item"><a class="rule-link" href="types/function-item.html#r-type.fn-item" title="type.fn-item"><span>[type<wbr>.fn-item]<span/></a></div>
<h1 id="함수-아이템-타입"><a class="header" href="#함수-아이템-타입">함수 아이템 타입</a></h1>
<div class="rule" id="r-type.fn-item.intro"><a class="rule-link" href="types/function-item.html#r-type.fn-item.intro" title="type.fn-item.intro"><span>[type<wbr>.fn-item<wbr>.intro]<span/></a></div>
<p>참조될 때, 함수 아이템이나 튜플 형태 구조체 또는 열거형 변형의 생성자는 해당 _함수 아이템 타입_의 크기가 0인 값을 생성합니다.</p>
<div class="rule" id="r-type.fn-item.unique"><a class="rule-link" href="types/function-item.html#r-type.fn-item.unique" title="type.fn-item.unique"><span>[type<wbr>.fn-item<wbr>.unique]<span/></a></div>
<p>해당 타입은 함수(이름, 타입 인자, 조기 바인딩된(early-bound) 라이프타임 인자 등. 단, 함수 호출 시에만 할당되는 지연 바인딩된(late-bound) 라이프타임 인자는 제외)를 명시적으로 식별합니다. 따라서 값에 실제 함수 포인터를 포함할 필요가 없으며, 함수 호출 시 간접 참조(indirection)가 필요하지 않습니다.</p>
<div class="rule" id="r-type.fn-item.name"><a class="rule-link" href="types/function-item.html#r-type.fn-item.name" title="type.fn-item.name"><span>[type<wbr>.fn-item<wbr>.name]<span/></a></div>
<p>함수 아이템 타입을 직접 참조하는 구문은 없지만, 컴파일러는 오류 메시지에서 해당 타입을 <code>fn(u32) -&gt; i32 {fn_name}</code>과 같이 표시합니다.</p>
<p>함수 아이템 타입은 함수를 명시적으로 식별하기 때문에, 서로 다른 함수(서로 다른 아이템, 또는 제네릭이 다른 동일 아이템)의 아이템 타입은 구별되며, 이들을 혼합하면 타입 오류가 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0308 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() { }
let x = &amp;mut foo::&lt;i32&gt;;
*x = foo::&lt;u32&gt;; //~ ERROR 타입 불일치
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.fn-item.coercion"><a class="rule-link" href="types/function-item.html#r-type.fn-item.coercion" title="type.fn-item.coercion"><span>[type<wbr>.fn-item<wbr>.coercion]<span/></a></div>
<p>그러나 함수 아이템에서 동일한 시그니처를 가진 <a href="types/function-pointer.html">함수 포인터</a>로의 <a href="types/../type-coercions.html">강제 변환(coercion)</a>이 존재합니다. 이는 함수 포인터가 직접 요구되는 위치에 함수 아이템이 사용될 때뿐만 아니라, 동일한 시그니처를 가진 서로 다른 함수 아이템 타입들이 동일한 <code>if</code> 또는 <code>match</code>의 서로 다른 암(arm)에서 만날 때도 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let want_i32 = false;
</span><span class="boring">fn foo&lt;T&gt;() { }
</span>
// 여기서 `foo_ptr_1`은 함수 포인터 타입 `fn()`을 가집니다
let foo_ptr_1: fn() = foo::&lt;i32&gt;;

// ... `foo_ptr_2`도 마찬가지입니다 - 이 코드는 타입 검사를 통과합니다.
let foo_ptr_2 = if want_i32 {
    foo::&lt;i32&gt;
} else {
    foo::&lt;u32&gt;
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.fn-item.traits"><a class="rule-link" href="types/function-item.html#r-type.fn-item.traits" title="type.fn-item.traits"><span>[type<wbr>.fn-item<wbr>.traits]<span/></a></div>
<p>모든 함수 아이템은 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a>, <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>, <a href="types/../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>, <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>, <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>을 구현합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.closure"><a class="rule-link" href="types/closure.html#r-type.closure" title="type.closure"><span>[type<wbr>.closure]<span/></a></div>
<h1 id="클로저-타입"><a class="header" href="#클로저-타입">클로저 타입</a></h1>
<div class="rule" id="r-type.closure.intro"><a class="rule-link" href="types/closure.html#r-type.closure.intro" title="type.closure.intro"><span>[type<wbr>.closure<wbr>.intro]<span/></a></div>
<p><a href="types/../expressions/closure-expr.html">클로저 표현식</a>은 직접 작성할 수 없는 고유하고 익명인 타입을 가진 클로저 값을 생성합니다. 클로저 타입은 캡처된 값들을 포함하는 구조체와 거의 동일합니다. 예를 들어, 다음과 같은 클로저는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // "Point { x: 2, y: 1 }"을 출력합니다.
<span class="boring">}</span></code></pre></pre>
<p>대략 다음과 같은 클로저 타입을 생성합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// 참고: 이것은 실제 번역되는 방식과 정확히 일치하지 않으며, 단지 설명을 위한 것입니다.

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>그리하여 <code>f</code>에 대한 호출이 다음과 같이 작동하도록 합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">// 참고: 중복된 가변 차용으로 인해 이는 유효한 러스트 코드가 아닙니다.
// 이는 오직 설명을 위해서만 제공됩니다.
f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.left_top.x });</code></pre>
<div class="rule" id="r-type.closure.capture"><a class="rule-link" href="types/closure.html#r-type.closure.capture" title="type.closure.capture"><span>[type<wbr>.closure<wbr>.capture]<span/></a></div>
<h2 id="캡처-모드-1"><a class="header" href="#캡처-모드-1">캡처 모드</a></h2>
<div class="rule" id="r-type.closure.capture.intro"><a class="rule-link" href="types/closure.html#r-type.closure.capture.intro" title="type.closure.capture.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.intro]<span/></a></div>
<p>_캡처 모드_는 환경의 <a href="types/../expressions.html#place-expressions-and-value-expressions">장소 표현식(place expression)</a>이 클로저 내부로 어떻게 차용되거나 이동되는지를 결정합니다. 캡처 모드는 다음과 같습니다:</p>
<ol>
<li>불변 차용 (<code>ImmBorrow</code>) — 장소 표현식이 <a href="types/pointer.html#references--and-mut">공유 참조</a>로 캡처됩니다.</li>
<li>고유 불변 차용 (<code>UniqueImmBorrow</code>) — 이는 불변 차용과 유사하지만, <a href="types/closure.html#unique-immutable-borrows-in-captures">아래</a>에 설명된 대로 고유해야 합니다.</li>
<li>가변 차용 (<code>MutBorrow</code>) — 장소 표현식이 <a href="types/pointer.html#mutable-references-mut">가변 참조</a>로 캡처됩니다.</li>
<li>이동 (<code>ByValue</code>) — <a href="types/../expressions.html#moved-and-copied-types">값을 이동</a>시켜서 장소 표현식을 캡처합니다.</li>
</ol>
<div class="rule" id="r-type.closure.capture.precedence"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precedence" title="type.closure.capture.precedence"><span>[type<wbr>.closure<wbr>.capture<wbr>.precedence]<span/></a></div>
<p>환경의 장소 표현식은 클로저 본문 내에서 캡처된 값이 사용되는 방식과 호환되는 첫 번째 모드로 캡처됩니다. 캡처 모드는 관련된 변수나 필드의 라이프타임, 또는 클로저 자체의 라이프타임과 같은 클로저 주변의 코드에 의해 영향을 받지 않습니다.</p>
<div class="rule" id="r-type.closure.capture.copy"><a class="rule-link" href="types/closure.html#r-type.closure.capture.copy" title="type.closure.capture.copy"><span>[type<wbr>.closure<wbr>.capture<wbr>.copy]<span/></a></div>
<h3 id="copy-값"><a class="header" href="#copy-값"><code>Copy</code> 값</a></h3>
<p>클로저 내부로 이동된 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>를 구현하는 값은 <code>ImmBorrow</code> 모드로 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x는 ImmBorrow로 캡처됨
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.async.input"><a class="rule-link" href="types/closure.html#r-type.closure.async.input" title="type.closure.async.input"><span>[type<wbr>.closure<wbr>.async<wbr>.input]<span/></a></div>
<h3 id="비동기-입력-캡처"><a class="header" href="#비동기-입력-캡처">비동기 입력 캡처</a></h3>
<p>비동기 클로저는 본문에서 사용되는지 여부에 관계없이 항상 모든 입력 인자를 캡처합니다.</p>
<h2 id="캡처-정밀도"><a class="header" href="#캡처-정밀도">캡처 정밀도</a></h2>
<div class="rule" id="r-type.closure.capture.precision.capture-path"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.capture-path" title="type.closure.capture.precision.capture-path"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.capture-path]<span/></a></div>
<p>_캡처 경로_는 환경의 변수에서 시작하여 해당 변수에 적용된 0개 이상의 장소 투영(place projection)으로 이어지는 시퀀스입니다.</p>
<div class="rule" id="r-type.closure.capture.precision.place-projection"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.place-projection" title="type.closure.capture.precision.place-projection"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.place-projection]<span/></a></div>
<p>_장소 투영_은 변수에 적용된 <a href="types/../expressions/field-expr.html">필드 접근</a>, <a href="types/../expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스</a>, <a href="types/../expressions/operator-expr.html#the-dereference-operator">역참조</a>(및 자동 역참조), 또는 <a href="types/../expressions/array-expr.html#array-and-slice-indexing-expressions">배열이나 슬라이스 인덱스</a> 표현식입니다.</p>
<div class="rule" id="r-type.closure.capture.precision.intro"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.intro" title="type.closure.capture.precision.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.intro]<span/></a></div>
<p>클로저는 캡처 경로를 차용하거나 이동하며, 이는 아래에 설명된 규칙에 따라 잘릴(truncated) 수 있습니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1은 ImmBorrow로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>여기서 캡처 경로는 로컬 변수 <code>s</code>, 필드 접근 <code>.f1</code>, 그리고 튜플 인덱스 <code>.1</code>로 이어집니다. 이 클로저는 <code>s.f1.1</code>의 불변 차용을 캡처합니다.</p>
<div class="rule" id="r-type.closure.capture.precision.shared-prefix"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.shared-prefix" title="type.closure.capture.precision.shared-prefix"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.shared-prefix]<span/></a></div>
<h3 id="공유-접두어"><a class="header" href="#공유-접두어">공유 접두어</a></h3>
<p>캡처 경로와 그 경로의 조상 중 하나가 모두 클로저에 의해 캡처되는 경우, 조상 경로는 두 캡처 중 가장 높은 캡처 모드로 캡처됩니다. <code>CaptureMode = max(조상캡처모드, 자손캡처모드)</code>이며, 다음의 엄격한 약순서(strict weak ordering)를 사용합니다:</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>이는 재귀적으로 적용되어야 할 수도 있음에 유의하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 예시에서, 공유된 조상을 가진 세 가지 서로 다른 캡처 경로가 있습니다:
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u는 ImmBorrow로 캡처됨
    u.1.truncate(0); // u.0은 MutBorrow로 캡처됨
    move_value(u.0.0); // u.0.0은 ByValue로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>전체적으로 이 클로저는 <code>u</code>를 <code>ByValue</code>로 캡처하게 됩니다.</p>
<div class="rule" id="r-type.closure.capture.precision.dereference-shared"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.dereference-shared" title="type.closure.capture.precision.dereference-shared"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.dereference-shared]<span/></a></div>
<h3 id="가장-오른쪽-공유-참조-자르기"><a class="header" href="#가장-오른쪽-공유-참조-자르기">가장 오른쪽 공유 참조 자르기</a></h3>
<p>공유 참조에 대해 역참조가 적용되는 경우, 캡처 경로는 가장 오른쪽 역참조 지점에서 잘립니다.</p>
<p>이러한 자르기가 허용되는 이유는 공유 참조를 통해 읽는 필드는 항상 공유 참조나 복사를 통해 읽히기 때문입니다. 이는 추가적인 정밀도가 차용 검사 관점에서 아무런 이득을 주지 않을 때 캡처 크기를 줄이는 데 도움이 됩니다.</p>
<p><em>가장 오른쪽</em> 역참조인 이유는 필요 이상으로 짧은 라이프타임을 피하기 위해서입니다. 다음 예시를 보십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre></pre>
<p>만약 이것이 <code>m</code>을 캡처한다면, <code>m</code>은 <code>'a</code>로 제한되어 있으므로 클로저는 더 이상 <code>'static</code>보다 오래 살 수 없게 됩니다. 대신, <code>(*(*m).a)</code>를 <code>ImmBorrow</code>로 캡처합니다.</p>
<div class="rule" id="r-type.closure.capture.precision.wildcard"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.wildcard" title="type.closure.capture.precision.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard]<span/></a></div>
<h3 id="와일드카드-패턴-바인딩"><a class="header" href="#와일드카드-패턴-바인딩">와일드카드 패턴 바인딩</a></h3>
<p>클로저는 읽어야 할 필요가 있는 데이터만 캡처합니다. <a href="types/../patterns.html#wildcard-pattern">와일드카드 패턴</a>으로 값을 바인딩하는 것은 읽기로 간주되지 않으며, 따라서 캡처되지 않습니다. 예를 들어, 다음 클로저들은 <code>x</code>를 캡처하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = String::from("hello");
let c = || {
    let _ = x;  // x는 캡처되지 않음
};
c();

let c = || match x {  // x는 캡처되지 않음
    _ =&gt; println!("Hello World!")
};
c();
<span class="boring">}</span></code></pre></pre>
<p>이는 튜플, 구조체, 열거형의 구조 분해에도 포함됩니다. <a href="types/../patterns.html#rest-patterns"><em>나머지 패턴</em></a>이나 <a href="types/../patterns.html#struct-patterns"><em>구조체패턴기타</em></a>와 매치되는 필드들도 읽기로 간주되지 않으며, 따라서 해당 필드들은 캡처되지 않습니다. 다음은 이에 대한 몇 가지 설명입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (String::from("a"), String::from("b"));
let c = || {
    let (first, ..) = x;  // `x.0`을 ByValue로 캡처함
};
// 첫 번째 튜플 필드는 클로저 내부로 이동되었습니다.
// 두 번째 튜플 필드는 여전히 접근 가능합니다.
println!("{:?}", x.1);
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example {
    f1: String,
    f2: String,
}

let e = Example {
    f1: String::from("first"),
    f2: String::from("second"),
};
let c = || {
    let Example { f2, .. } = e; // `e.f2`를 ByValue로 캡처함
};
// f2 필드는 클로저 내부로 이동되었으므로 접근할 수 없습니다.
// f1 필드는 여전히 접근 가능합니다.
println!("{:?}", e.f1);
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.array-slice"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.wildcard.array-slice" title="type.closure.capture.precision.wildcard.array-slice"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.array-slice]<span/></a></div>
<p>배열과 슬라이스의 부분 캡처는 지원되지 않습니다. 와일드카드 패턴 매칭, 인덱싱 또는 서브 슬라이싱과 함께 사용되더라도 항상 전체 슬라이스나 배열이 캡처됩니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Example;
let x = [Example, Example];

let c = || {
    let [first, _] = x; // `x` 전체를 ByValue로 캡처함
};
c();
println!("{:?}", x[1]); // ERROR: 이동된 값의 차용: `x`
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.initialized"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.wildcard.initialized" title="type.closure.capture.precision.wildcard.initialized"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.initialized]<span/></a></div>
<p>와일드카드와 매치되는 값들도 여전히 초기화되어 있어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;
let c = || {
    let _ = x; // ERROR: 사용된 바인딩 `x`가 초기화되지 않음
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.move-dereference"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.move-dereference" title="type.closure.capture.precision.move-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.move-dereference]<span/></a></div>
<h3 id="이동-컨텍스트에서의-참조-캡처"><a class="header" href="#이동-컨텍스트에서의-참조-캡처">이동 컨텍스트에서의 참조 캡처</a></h3>
<p>참조에서 필드를 끄집어내어 이동하는 것은 허용되지 않으므로, <code>move</code> 클로저는 참조의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다. 참조 자체는 클로저 내부로 이동됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // `t_mut_ref`를 ByValue로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.raw-pointer-dereference"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.raw-pointer-dereference" title="type.closure.capture.precision.raw-pointer-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.raw-pointer-dereference]<span/></a></div>
<h3 id="원시-포인터-역참조"><a class="header" href="#원시-포인터-역참조">원시 포인터 역참조</a></h3>
<p>원시 포인터를 역참조하는 것은 <code>unsafe</code>하므로, 클로저는 원시 포인터의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // `t_ptr`을 ImmBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.union"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.union" title="type.closure.capture.precision.union"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.union]<span/></a></div>
<h3 id="공용체-필드"><a class="header" href="#공용체-필드">공용체 필드</a></h3>
<p>공용체 필드에 접근하는 것은 <code>unsafe</code>하므로, 클로저는 공용체 자체까지만의 캡처 경로 접두어를 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // `u`를 ByValue로 캡처함
};
c();

// 이는 필드에 쓰는 경우도 포함합니다.
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // `u`를 MutBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.unaligned"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.unaligned" title="type.closure.capture.precision.unaligned"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.unaligned]<span/></a></div>
<h3 id="정렬되지-않은-struct로의-참조"><a class="header" href="#정렬되지-않은-struct로의-참조">정렬되지 않은 <code>struct</code>로의 참조</a></h3>
<p>Because it is <a href="types/../behavior-considered-undefined.html">undefined behavior</a> to create references to unaligned fields in a structure, closures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses <a href="types/../type-layout.html#the-alignment-modifiers">the <code>packed</code> representation</a>. This includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // `t`를 ImmBorrow로 캡처함
};
// `t`에서 복사하는 것은 괜찮습니다.
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 정렬되지 않은 필드의 주소를 취하는 것도 구조체 전체를 캡처합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t`를 ImmBorrow로 캡처함
};
let a = t.0; // ERROR: `t.0`이 차용되었으므로 이동할 수 없음
c();
<span class="boring">}</span></code></pre></pre>
<p>하지만 packed가 아니라면 필드를 정밀하게 캡처하므로 위 코드가 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t.1`을 ImmBorrow로 캡처함
};
// 여기서의 이동은 허용됩니다.
let a = t.0;
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-deref"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.box-deref" title="type.closure.capture.precision.box-deref"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-deref]<span/></a></div>
<h3 id="box-대-다른-deref-구현체"><a class="header" href="#box-대-다른-deref-구현체"><code>Box</code> 대 다른 <code>Deref</code> 구현체</a></h3>
<p><code>Box</code>에 대한 <a href="types/../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 트레잇 구현은 특별한 엔티티로 간주되어 다른 <code>Deref</code> 구현과 다르게 취급됩니다.</p>
<p>예를 들어, <code>Rc</code>와 <code>Box</code>가 포함된 예시를 보겠습니다. <code>*rc</code>는 <code>Rc</code>에 정의된 트레잇 메서드 <code>deref</code>의 호출로 디슈거링(desugar)되지만, <code>*box</code>는 다르게 취급되므로 <code>Box</code> 내부 콘텐츠의 정밀한 캡처가 가능합니다.</p>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.not-moved"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.box-non-move.not-moved" title="type.closure.capture.precision.box-non-move.not-moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.not-moved]<span/></a></div>
<h4 id="non-move-클로저에서의-box"><a class="header" href="#non-move-클로저에서의-box">non-<code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용물이 클로저 본문으로 이동되지 않는다면, <code>Box</code>의 내용물은 정밀하게 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // `(*b).0`을 ImmBorrow로 캡처함
};
c_box();

// `Box`를 Deref를 구현하는 다른 타입과 비교해 보십시오:
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // `r`을 ImmBorrow로 캡처함
};
c_rc();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.moved"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.box-non-move.moved" title="type.closure.capture.precision.box-non-move.moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.moved]<span/></a></div>
<p>그러나 <code>Box</code>의 내용물이 클로저로 이동된다면, 박스 전체가 캡처됩니다. 이는 클로저로 이동해야 하는 데이터의 양을 최소화하기 위함입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 클로저가 참조를 취하는 대신 값을 이동시킨다는 점을 제외하면 위 예시와 동일합니다.

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
c_box();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-move.read"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.box-move.read" title="type.closure.capture.precision.box-move.read"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-move<wbr>.read]<span/></a></div>
<h4 id="move-클로저에서의-box"><a class="header" href="#move-클로저에서의-box"><code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용을 이동시키는 것과 유사하게, <code>move</code> 클로저에서 <code>Box</code>의 내용을 읽는 것은 <code>Box</code> 전체를 캡처하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.unique-immutable"><a class="rule-link" href="types/closure.html#r-type.closure.unique-immutable" title="type.closure.unique-immutable"><span>[type<wbr>.closure<wbr>.unique-immutable]<span/></a></div>
<h2 id="캡처에서의-고유-불변-차용"><a class="header" href="#캡처에서의-고유-불변-차용">캡처에서의 고유 불변 차용</a></h2>
<p>캡처는 _고유 불변 차용(unique immutable borrow)_이라고 불리는 특수한 종류의 차용을 통해 발생할 수 있습니다. 이는 언어의 다른 어디에서도 사용될 수 없으며 명시적으로 작성할 수도 없습니다. 다음 예시와 같이 가변 참조의 대상(referent)을 수정할 때 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // `x`의 ImmBorrow 및 MutBorrow.
    let a = &amp;x;
    *x = true; // `x`는 UniqueImmBorrow로 캡처됨
};
// 다음 줄은 오류입니다:
// let y = &amp;x;
c();
// 그러나 다음은 괜찮습니다.
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>. But at the same time, borrowing <code>x</code> immutably would make the assignment illegal, because a <code>&amp; &amp;mut</code> reference might not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</p>
<p>위의 예시에서 <code>y</code>의 선언을 주석 해제하면 클로저의 <code>x</code> 차용에 대한 고유성을 위반하므로 오류가 발생합니다. z의 선언은 블록 끝에서 클로저의 라이프타임이 만료되어 차용이 해제되었으므로 유효합니다.</p>
<div class="rule" id="r-type.closure.call"><a class="rule-link" href="types/closure.html#r-type.closure.call" title="type.closure.call"><span>[type<wbr>.closure<wbr>.call]<span/></a></div>
<h2 id="호출-트레잇-및-강제-변환"><a class="header" href="#호출-트레잇-및-강제-변환">호출 트레잇 및 강제 변환</a></h2>
<div class="rule" id="r-type.closure.call.intro"><a class="rule-link" href="types/closure.html#r-type.closure.call.intro" title="type.closure.call.intro"><span>[type<wbr>.closure<wbr>.call<wbr>.intro]<span/></a></div>
<p>모든 클로저 타입은 <a href="types/../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>를 구현하며, 이는 클로저의 소유권을 소비함으로써 한 번 호출될 수 있음을 나타냅니다. 또한 일부 클로저는 더 구체적인 호출 트레잇을 구현합니다:</p>
<div class="rule" id="r-type.closure.call.fn-mut"><a class="rule-link" href="types/closure.html#r-type.closure.call.fn-mut" title="type.closure.call.fn-mut"><span>[type<wbr>.closure<wbr>.call<wbr>.fn-mut]<span/></a></div>
<ul>
<li>캡처된 변수 중 어느 것도 밖으로 이동시키지 않는 클로저는 <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>를 구현하며, 이는 가변 참조로 호출될 수 있음을 나타냅니다.</li>
</ul>
<div class="rule" id="r-type.closure.call.fn"><a class="rule-link" href="types/closure.html#r-type.closure.call.fn" title="type.closure.call.fn"><span>[type<wbr>.closure<wbr>.call<wbr>.fn]<span/></a></div>
<ul>
<li>캡처된 변수를 변경하거나 밖으로 이동시키지 않는 클로저는 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a>를 구현하며, 이는 공유 참조로 호출될 수 있음을 나타냅니다.</li>
</ul>
<blockquote>
<p>참고: <code>move</code> 클로저는 변수를 이동으로 캡처하더라도 여전히 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 또는 <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>을 구현할 수 있습니다. 이는 클로저 타입이 구현하는 트레잇이 변수를 어떻게 캡처하느냐가 아니라, 캡처된 값으로 무엇을 하느냐에 따라 결정되기 때문입니다.</p>
</blockquote>
<div class="rule" id="r-type.closure.non-capturing"><a class="rule-link" href="types/closure.html#r-type.closure.non-capturing" title="type.closure.non-capturing"><span>[type<wbr>.closure<wbr>.non-capturing]<span/></a></div>
<p>_비캡처 클로저(Non-capturing closures)_는 환경에서 아무것도 캡처하지 않는 클로저입니다. 비동기가 아닌 비캡처 클로저는 일치하는 시그니처를 가진 함수 포인터(예: <code>fn()</code>)로 강제 변환될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.async.traits"><a class="rule-link" href="types/closure.html#r-type.closure.async.traits" title="type.closure.async.traits"><span>[type<wbr>.closure<wbr>.async<wbr>.traits]<span/></a></div>
<h3 id="비동기-클로저-트레잇"><a class="header" href="#비동기-클로저-트레잇">비동기 클로저 트레잇</a></h3>
<div class="rule" id="r-type.closure.async.traits.fn-family"><a class="rule-link" href="types/closure.html#r-type.closure.async.traits.fn-family" title="type.closure.async.traits.fn-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.fn-family]<span/></a></div>
<p>비동기 클로저는 <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 또는 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 구현 여부에 대해 추가적인 제한을 가집니다.</p>
<p>비동기 클로저가 반환하는 <a href="types/../../core/future/future/trait.Future.html"><code>Future</code></a>는 클로저와 유사한 캡처 특성을 가집니다. 이는 사용 방식에 따라 비동기 클로저로부터 장소 표현식을 캡처합니다. 비동기 클로저가 다음 속성 중 하나를 가지면 <a href="types/../../core/future/future/trait.Future.html"><code>Future</code></a>에게 <em>대여(lending)</em> 중이라고 합니다:</p>
<ul>
<li><code>Future</code>가 가변 캡처를 포함하는 경우.</li>
<li>비동기 클로저가 값으로 캡처하는 경우 (단, 역참조 투영을 통해 값에 접근하는 경우는 제외).</li>
</ul>
<p>비동기 클로저가 <code>Future</code>에게 대여 중인 경우, <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 및 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a>은 구현되지 <em>않습니다</em>. <a href="types/../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>는 항상 구현됩니다.</p>
<blockquote>
<p><strong>예시</strong>: 가변 캡처에 대한 첫 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x는 MutBorrow로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `FnMut`를 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>일반 값 캡처에 대한 두 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x는 ByValue로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `Fn`을 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>두 번째 조건의 예외는 역참조를 사용하여 설명될 수 있으며, 이 경우 <code>Fn</code> 및 <code>FnMut</code> 구현이 허용됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK: `Fn`을 구현함
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-type.closure.async.traits.async-family"><a class="rule-link" href="types/closure.html#r-type.closure.async.traits.async-family" title="type.closure.async.traits.async-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.async-family]<span/></a></div>
<p>비동기 클로저는 일반 클로저가 <a href="types/../../core/ops/function/trait.Fn.html"><code>Fn</code></a>, <a href="types/../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>, <a href="types/../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>을 구현하는 것과 유사한 방식으로 <a href="types/../../core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a>, <a href="types/../../core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a>, <a href="types/../../core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a>을 구현합니다. 즉, 본문에서 캡처된 변수들이 어떻게 사용되느냐에 따라 결정됩니다.</p>
<div class="rule" id="r-type.closure.traits"><a class="rule-link" href="types/closure.html#r-type.closure.traits" title="type.closure.traits"><span>[type<wbr>.closure<wbr>.traits]<span/></a></div>
<h3 id="기타-트레잇"><a class="header" href="#기타-트레잇">기타 트레잇</a></h3>
<div class="rule" id="r-type.closure.traits.intro"><a class="rule-link" href="types/closure.html#r-type.closure.traits.intro" title="type.closure.traits.intro"><span>[type<wbr>.closure<wbr>.traits<wbr>.intro]<span/></a></div>
<p>모든 클로저 타입은 <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a>를 구현합니다. 또한 클로저 타입은 저장된 캡처 타입들이 허용하는 경우 다음 트레잇들을 구현합니다:</p>
<ul>
<li><a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="types/../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<div class="rule" id="r-type.closure.traits.behavior"><a class="rule-link" href="types/closure.html#r-type.closure.traits.behavior" title="type.closure.traits.behavior"><span>[type<wbr>.closure<wbr>.traits<wbr>.behavior]<span/></a></div>
<p><a href="types/../special-types-and-traits.html#send"><code>Send</code></a> 및 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>에 대한 규칙은 일반 구조체 타입과 일치하며, <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 및 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>는 마치 <a href="types/../attributes/derive.html">파생(derived)</a>된 것처럼 작동합니다. <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>의 경우, 캡처된 값들이 클로닝되는 순서는 지정되지 않습니다.</p>
<p>캡처는 종종 참조에 의해 발생하므로 다음과 같은 일반적인 규칙이 나타납니다:</p>
<ul>
<li>모든 캡처된 값이 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>입니다.</li>
<li>비고유 불변 참조로 캡처된 모든 값이 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>이고, 고유 불변 참조나 가변 참조, 복사 또는 이동으로 캡처된 모든 값이 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>입니다.</li>
<li>클로저가 고유 불변 참조나 가변 참조로 값을 캡처하지 않고, 복사나 이동으로 캡처하는 모든 값이 각각 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>입니다.</li>
</ul>
<div class="rule" id="r-type.closure.drop-order"><a class="rule-link" href="types/closure.html#r-type.closure.drop-order" title="type.closure.drop-order"><span>[type<wbr>.closure<wbr>.drop-order]<span/></a></div>
<h2 id="드롭-순서"><a class="header" href="#드롭-순서">드롭 순서</a></h2>
<p>클로저가 구조체, 튜플, 열거형과 같은 복합 타입의 필드를 값으로 캡처하면, 해당 필드의 라이프타임은 이제 클로저에 묶이게 됩니다. 결과적으로 복합 타입의 서로 다른 필드들이 서로 다른 시점에 드롭될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0은 클로저 내부로 캡처됨 |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c'와 'tuple.0'이 여기서 드롭됨 ------------+  |
} // tuple.1이 여기서 드롭됨 -----------------------------+
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.entirety"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.edition2018.entirety" title="type.closure.capture.precision.edition2018.entirety"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.entirety]<span/></a></div>
<h2 id="2018-에디션-및-이전"><a class="header" href="#2018-에디션-및-이전">2018 에디션 및 이전</a></h2>
<h3 id="클로저-타입의-차이점"><a class="header" href="#클로저-타입의-차이점">클로저 타입의 차이점</a></h3>
<p>2018 에디션 및 이전 버전에서, 클로저는 항상 변수 전체를 캡처하며 정밀한 캡처 경로를 사용하지 않습니다. 이는 <a href="types/closure.html#closure-types">클로저 타입</a> 섹션에서 사용된 예시의 경우, 생성된 클로저 타입이 대신 다음과 같은 모습이 됨을 의미합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>그리고 <code>f</code>에 대한 호출은 다음과 같이 작동합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.composite"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.edition2018.composite" title="type.closure.capture.precision.edition2018.composite"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.composite]<span/></a></div>
<h3 id="캡처-정밀도의-차이"><a class="header" href="#캡처-정밀도의-차이">캡처 정밀도의 차이</a></h3>
<p>구조체, 튜플, 열거형과 같은 복합 타입은 개별 필드가 아니라 항상 전체가 캡처됩니다. 결과적으로, 단일 필드만 캡처하려면 로컬 변수로 차용해야 할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>만약 클로저가 <code>self.vec</code>을 직접 사용했다면 <code>self</code>를 가변 참조로 캡처하려고 시도했을 것입니다. 하지만 <code>self.set</code>이 이미 반복을 위해 차용된 상태이므로 코드가 컴파일되지 않았을 것입니다.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.move"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.edition2018.move" title="type.closure.capture.precision.edition2018.move"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.move]<span/></a></div>
<p><code>move</code> 키워드가 사용되면, 차용이 가능하더라도 모든 캡처는 이동(또는 <code>Copy</code> 타입의 경우 복사)에 의해 이루어집니다. <code>move</code> 키워드는 보통 클로저가 반환되거나 새 스레드를 생성하는 데 사용되는 경우와 같이, 클로저가 캡처된 값보다 더 오래 살아남을 수 있도록 하기 위해 사용됩니다.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.wildcard"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.edition2018.wildcard" title="type.closure.capture.precision.edition2018.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.wildcard]<span/></a></div>
<p>와일드카드 패턴의 경우처럼 클로저가 데이터를 실제로 읽는지 여부와 관계없이, 클로저 외부에서 정의된 변수가 클로저 내부에서 언급되면 해당 변수는 전체가 캡처됩니다.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.drop-order"><a class="rule-link" href="types/closure.html#r-type.closure.capture.precision.edition2018.drop-order" title="type.closure.capture.precision.edition2018.drop-order"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.drop-order]<span/></a></div>
<h3 id="드롭-순서의-차이"><a class="header" href="#드롭-순서의-차이">드롭 순서의 차이</a></h3>
<p>복합 타입은 전체가 캡처되므로, 이러한 복합 타입 중 하나를 값으로 캡처하는 클로저는 클로저가 드롭될 때 캡처된 변수 전체를 동시에 드롭합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
// --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c'와 'tuple'이 여기서 드롭됨 ------------+
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.pointer"><a class="rule-link" href="types/pointer.html#r-type.pointer" title="type.pointer"><span>[type<wbr>.pointer]<span/></a></div>
<h1 id="포인터-타입"><a class="header" href="#포인터-타입">포인터 타입</a></h1>
<div class="rule" id="r-type.pointer.intro"><a class="rule-link" href="types/pointer.html#r-type.pointer.intro" title="type.pointer.intro"><span>[type<wbr>.pointer<wbr>.intro]<span/></a></div>
<p>모든 포인터는 명시적인 일급 객체(first-class values)입니다. 이들은 이동하거나 복사할 수 있고, 데이터 구조체에 저장할 수 있으며, 함수에서 반환될 수도 있습니다.</p>
<div class="rule" id="r-type.pointer.reference"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference" title="type.pointer.reference"><span>[type<wbr>.pointer<wbr>.reference]<span/></a></div>
<h2 id="참조--및-mut"><a class="header" href="#참조--및-mut">참조 (<code>&amp;</code> 및 <code>&amp;mut</code>)</a></h2>
<div class="rule" id="r-type.pointer.reference.syntax"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.syntax" title="type.pointer.reference.syntax"><span>[type<wbr>.pointer<wbr>.reference<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>참조타입</em> :<br />
   <code>&amp;</code> <a href="types/../trait-bounds.html"><em>라이프타임</em></a><sup>?</sup> <code>mut</code><sup>?</sup> <a href="types/../types.html#type-expressions"><em>바운드없는타입</em></a><strong><sup>구문</sup></strong><br />
<em>참조타입</em> :<br />
   <code>&amp;</code> <a href="types/../trait-bounds.html"><em>라이프타임</em></a><sup>?</sup> <code>mut</code><sup>?</sup> <a href="types/../types.html#type-expressions"><em>바운드없는타입</em></a></p>
</blockquote>
<div class="rule" id="r-type.pointer.reference.shared"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.shared" title="type.pointer.reference.shared"><span>[type<wbr>.pointer<wbr>.reference<wbr>.shared]<span/></a></div>
<h3 id="공유-참조-"><a class="header" href="#공유-참조-">공유 참조 (<code>&amp;</code>)</a></h3>
<div class="rule" id="r-type.pointer.reference.shared.intro"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.shared.intro" title="type.pointer.reference.shared.intro"><span>[type<wbr>.pointer<wbr>.reference<wbr>.shared<wbr>.intro]<span/></a></div>
<p>공유 참조는 다른 어떤 값에 의해 소유된 메모리를 가리킵니다.</p>
<div class="rule" id="r-type.pointer.reference.shared.constraint-mutation"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.shared.constraint-mutation" title="type.pointer.reference.shared.constraint-mutation"><span>[type<wbr>.pointer<wbr>.reference<wbr>.shared<wbr>.constraint-mutation]<span/></a></div>
<p>값에 대한 공유 참조가 생성되면, 해당 값의 직접적인 변경이 방지됩니다. <a href="types/../interior-mutability.html">내부 가변성</a>은 특정 상황에서 이에 대한 예외를 제공합니다. 이름에서 알 수 있듯이, 값에 대한 공유 참조는 몇 개든지 존재할 수 있습니다. 공유 참조 타입은 <code>&amp;type</code>으로 작성되거나, 명시적인 라이프타임을 지정해야 할 경우 <code>&amp;'a type</code>으로 작성됩니다.</p>
<div class="rule" id="r-type.pointer.reference.shared.copy"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.shared.copy" title="type.pointer.reference.shared.copy"><span>[type<wbr>.pointer<wbr>.reference<wbr>.shared<wbr>.copy]<span/></a></div>
<p>참조 복사는 “얕은(shallow)” 연산입니다. 이는 포인터 자체만 복사하며, 즉 포인터는 <code>Copy</code>입니다. 참조를 해제하는 것은 가리키는 값에 아무런 영향을 주지 않지만, <a href="types/../expressions.html#temporaries">임시 값</a>을 참조하는 경우 참조 자체의 스코프 동안 그 값을 유지합니다.</p>
<div class="rule" id="r-type.pointer.reference.mut"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.mut" title="type.pointer.reference.mut"><span>[type<wbr>.pointer<wbr>.reference<wbr>.mut]<span/></a></div>
<h3 id="가변-참조-mut"><a class="header" href="#가변-참조-mut">가변 참조 (<code>&amp;mut</code>)</a></h3>
<div class="rule" id="r-type.pointer.reference.mut.intro"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.mut.intro" title="type.pointer.reference.mut.intro"><span>[type<wbr>.pointer<wbr>.reference<wbr>.mut<wbr>.intro]<span/></a></div>
<p>가변 참조는 다른 어떤 값에 의해 소유된 메모리를 가리킵니다. 가변 참조 타입은 <code>&amp;mut type</code> 또는 <code>&amp;'a mut type</code>으로 작성됩니다.</p>
<div class="rule" id="r-type.pointer.reference.mut.copy"><a class="rule-link" href="types/pointer.html#r-type.pointer.reference.mut.copy" title="type.pointer.reference.mut.copy"><span>[type<wbr>.pointer<wbr>.reference<wbr>.mut<wbr>.copy]<span/></a></div>
<p>(차용되지 않은) 가변 참조는 가리키는 값에 접근할 수 있는 유일한 방법이므로, <code>Copy</code>가 아닙니다.</p>
<div class="rule" id="r-type.pointer.raw"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw" title="type.pointer.raw"><span>[type<wbr>.pointer<wbr>.raw]<span/></a></div>
<h2 id="원시-포인터-const-및-mut"><a class="header" href="#원시-포인터-const-및-mut">원시 포인터 (<code>*const</code> 및 <code>*mut</code>)</a></h2>
<div class="rule" id="r-type.pointer.raw.syntax"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.syntax" title="type.pointer.raw.syntax"><span>[type<wbr>.pointer<wbr>.raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>원시포인터타입</em> :<br />
   <code>*</code> ( <code>mut</code> | <code>const</code> ) <a href="types/../types.html#type-expressions"><em>바운드없는타입</em></a></p>
</blockquote>
<div class="rule" id="r-type.pointer.raw.intro"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.intro" title="type.pointer.raw.intro"><span>[type<wbr>.pointer<wbr>.raw<wbr>.intro]<span/></a></div>
<p>원시 포인터는 안전성이나 생존성(liveness) 보장이 없는 포인터입니다. 원시 포인터는 <code>*const T</code> 또는 <code>*mut T</code>로 작성됩니다. 예를 들어 <code>*const i32</code>는 32비트 정수에 대한 원시 포인터를 의미합니다.</p>
<div class="rule" id="r-type.pointer.raw.copy"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.copy" title="type.pointer.raw.copy"><span>[type<wbr>.pointer<wbr>.raw<wbr>.copy]<span/></a></div>
<p>원시 포인터를 복사하거나 드롭하는 것은 다른 어떤 값의 수명 주기에도 영향을 미치지 않습니다.</p>
<div class="rule" id="r-type.pointer.raw.safety"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.safety" title="type.pointer.raw.safety"><span>[type<wbr>.pointer<wbr>.raw<wbr>.safety]<span/></a></div>
<p>원시 포인터를 역참조하는 것은 <a href="types/../unsafety.html"><code>unsafe</code> 연산</a>입니다.</p>
<p>이는 원시 포인터를 다시 차용(<code>&amp;*</code> 또는 <code>&amp;mut *</code>)하여 참조로 변환하는 데에도 사용될 수 있습니다. 원시 포인터는 일반적으로 권장되지 않습니다. 이들은 외부 코드와의 상호 운용성을 지원하고, 성능에 민감하거나 저수준 함수를 작성하기 위해 존재합니다.</p>
<div class="rule" id="r-type.pointer.raw.cmp"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.cmp" title="type.pointer.raw.cmp"><span>[type<wbr>.pointer<wbr>.raw<wbr>.cmp]<span/></a></div>
<p>원시 포인터를 비교할 때는 가리키는 대상이 아니라 주소로 비교합니다. <a href="types/../dynamically-sized-types.html">동적 크기 타입</a>에 대한 원시 포인터를 비교할 때는 추가 데이터도 함께 비교됩니다.</p>
<div class="rule" id="r-type.pointer.raw.constructor"><a class="rule-link" href="types/pointer.html#r-type.pointer.raw.constructor" title="type.pointer.raw.constructor"><span>[type<wbr>.pointer<wbr>.raw<wbr>.constructor]<span/></a></div>
<p>원시 포인터는 <code>*const</code> 포인터의 경우 <code>&amp;raw const</code>를, <code>*mut</code> 포인터의 경우 <code>&amp;raw mut</code>을 사용하여 직접 생성할 수 있습니다.</p>
<div class="rule" id="r-type.pointer.smart"><a class="rule-link" href="types/pointer.html#r-type.pointer.smart" title="type.pointer.smart"><span>[type<wbr>.pointer<wbr>.smart]<span/></a></div>
<h2 id="스마트-포인터"><a class="header" href="#스마트-포인터">스마트 포인터</a></h2>
<p>표준 라이브러리는 참조와 원시 포인터 외에도 추가적인 ‘스마트 포인터’ 타입을 포함합니다.</p>
<div class="rule" id="r-type.pointer.validity"><a class="rule-link" href="types/pointer.html#r-type.pointer.validity" title="type.pointer.validity"><span>[type<wbr>.pointer<wbr>.validity]<span/></a></div>
<h2 id="비트-유효성-2"><a class="header" href="#비트-유효성-2">비트 유효성</a></h2>
<div class="rule" id="r-type.pointer.validity.pointer-fragment"><a class="rule-link" href="types/pointer.html#r-type.pointer.validity.pointer-fragment" title="type.pointer.validity.pointer-fragment"><span>[type<wbr>.pointer<wbr>.validity<wbr>.pointer-fragment]<span/></a></div>
<p>대부분의 플랫폼에서 방출되는 기계어 코드상으로 포인터와 참조가 <code>usize</code>와 유사함에도 불구하고, 참조나 포인터 타입을 비포인터 타입으로 transmute하는 것의 의미론은 현재 미정입니다. 따라서 포인터나 참조 타입 <code>P</code>를 <code>[u8; size_of::&lt;P&gt;()]</code>로 transmute하는 것은 유효하지 않을 수 있습니다.</p>
<div class="rule" id="r-type.pointer.validity.raw"><a class="rule-link" href="types/pointer.html#r-type.pointer.validity.raw" title="type.pointer.validity.raw"><span>[type<wbr>.pointer<wbr>.validity<wbr>.raw]<span/></a></div>
<p>얇은(thin) 원시 포인터의 경우(즉, <code>T: Sized</code>에 대해 <code>P = *const T</code> 또는 <code>P = *mut T</code>), 역방향(정수 또는 정수 배열에서 <code>P</code>로 transmute)은 항상 유효합니다. 그러나 이러한 transmute를 통해 생성된 포인터는 역참조할 수 없습니다(<code>T</code>의 크기가 0이어도 마찬가지입니다).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.fn-pointer"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer" title="type.fn-pointer"><span>[type<wbr>.fn-pointer]<span/></a></div>
<h1 id="함수-포인터-타입"><a class="header" href="#함수-포인터-타입">함수 포인터 타입</a></h1>
<div class="rule" id="r-type.fn-pointer.syntax"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.syntax" title="type.fn-pointer.syntax"><span>[type<wbr>.fn-pointer<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Bare함수타입</em> :<br />
   <a href="types/../trait-bounds.html#higher-ranked-trait-bounds"><em>라이프타임</em></a><sup>?</sup> <em>함수타입한정자</em> <code>fn</code><br />
       <code>(</code> <em>이름있을수있는함수매개변수가변</em><sup>?</sup> <code>)</code> <em>Bare함수반환타입</em><sup>?</sup></p>
<p><em>함수타입한정자</em>:<br />
   <code>unsafe</code><sup>?</sup> (<code>extern</code> <a href="types/../items/functions.html"><em>Abi</em></a><sup>?</sup>)<sup>?</sup></p>
<p><em>Bare함수반환타입</em>:<br />
   <code>-&gt;</code> <a href="types/../types.html#type-expressions"><em>바운드없는타입</em></a></p>
<p><em>이름있을수있는함수매개변수가변</em> :<br />
   <em>이름있을수있는함수매개변수</em> | <em>이름있을수있는함수매개변수가변형</em></p>
<p><em>이름있을수있는함수매개변수</em> :<br />
   <em>이름있을수있는매개변수</em> ( <code>,</code> <em>이름있을수있는매개변수</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>이름있을수있는매개변수</em> :<br />
   <a href="types/../attributes.html"><em>외부속성</em></a><sup>*</sup> ( ( <a href="types/../identifiers.html">식별자</a> | <code>_</code> ) <code>:</code> )<sup>?</sup> <a href="types/../types.html#type-expressions"><em>타입</em></a></p>
<p><em>이름있을수있는함수매개변수가변형</em> :<br />
   ( <em>이름있을수있는매개변수</em> <code>,</code> )<sup><em></sup> <em>이름있을수있는매개변수</em> <code>,</code> <a href="types/../attributes.html"><em>외부속성</em></a><sup></em></sup> <code>...</code></p>
</blockquote>
<div class="rule" id="r-type.fn-pointer.intro"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.intro" title="type.fn-pointer.intro"><span>[type<wbr>.fn-pointer<wbr>.intro]<span/></a></div>
<p><code>fn</code> 키워드를 사용하여 작성된 함수 포인터 타입은 컴파일 타임에 그 정체가 반드시 알려져 있지는 않은 함수를 참조합니다.</p>
<p><code>Binop</code>이 함수 포인터 타입으로 정의된 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.fn-pointer.coercion"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.coercion" title="type.fn-pointer.coercion"><span>[type<wbr>.fn-pointer<wbr>.coercion]<span/></a></div>
<p>함수 포인터는 <a href="types/function-item.html">함수 아이템</a> 및 비캡처, 비동기가 아닌 <a href="types/closure.html">클로저</a>로부터의 강제 변환을 통해 생성될 수 있습니다.</p>
<div class="rule" id="r-type.fn-pointer.qualifiers"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.qualifiers" title="type.fn-pointer.qualifiers"><span>[type<wbr>.fn-pointer<wbr>.qualifiers]<span/></a></div>
<p><code>unsafe</code> 한정자는 해당 타입의 값이 <a href="types/../unsafe-keyword.html">unsafe 함수</a>임을 나타내며, <code>extern</code> 한정자는 이것이 <a href="types/../items/functions.html#extern-function-qualifier">extern 함수</a>임을 나타냅니다.</p>
<div class="rule" id="r-type.fn-pointer.constraint-variadic"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.constraint-variadic" title="type.fn-pointer.constraint-variadic"><span>[type<wbr>.fn-pointer<wbr>.constraint-variadic]<span/></a></div>
<p>가변 인자(variadic parameters)는 <code>"C"</code> 또는 <code>"cdecl"</code> 호출 규약(calling convention)을 사용하는 <a href="types/../items/external-blocks.html"><code>extern</code></a> 함수 타입에서만 지정될 수 있습니다.</p>
<div class="rule" id="r-type.fn-pointer.attributes"><a class="rule-link" href="types/function-pointer.html#r-type.fn-pointer.attributes" title="type.fn-pointer.attributes"><span>[type<wbr>.fn-pointer<wbr>.attributes]<span/></a></div>
<h2 id="함수-포인터-매개변수의-속성"><a class="header" href="#함수-포인터-매개변수의-속성">함수 포인터 매개변수의 속성</a></h2>
<p>함수 포인터 매개변수의 속성은 <a href="types/../items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제한을 따릅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.trait-object"><a class="rule-link" href="types/trait-object.html#r-type.trait-object" title="type.trait-object"><span>[type<wbr>.trait-object]<span/></a></div>
<h1 id="트레잇-객체"><a class="header" href="#트레잇-객체">트레잇 객체</a></h1>
<div class="rule" id="r-type.trait-object.syntax"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.syntax" title="type.trait-object.syntax"><span>[type<wbr>.trait-object<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>트레잇객체타입</em> :<br />
   <code>dyn</code><sup>?</sup> <a href="types/../trait-bounds.html"><em>타입매개변수바운드</em></a></p>
<p><em>하나의바운드를가진트레잇객체타입</em> :<br />
   <code>dyn</code><sup>?</sup> <a href="types/../trait-bounds.html"><em>트레잇바운드</em></a></p>
</blockquote>
<div class="rule" id="r-type.trait-object.intro"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.intro" title="type.trait-object.intro"><span>[type<wbr>.trait-object<wbr>.intro]<span/></a></div>
<p>_트레잇 객체_는 트레잇 집합을 구현하는 다른 타입의 불투명한(opaque) 값입니다. 트레잇 집합은 <a href="types/../items/traits.html#dyn-compatibility">dyn 호환(dyn compatible)</a> _기반 트레잇_과 임의 개수의 <a href="types/../special-types-and-traits.html#auto-traits">자동 트레잇</a>으로 구성됩니다.</p>
<div class="rule" id="r-type.trait-object.impls"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.impls" title="type.trait-object.impls"><span>[type<wbr>.trait-object<wbr>.impls]<span/></a></div>
<p>트레잇 객체는 기반 트레잇, 해당 자동 트레잇, 그리고 기반 트레잇의 모든 <a href="types/../items/traits.html#supertraits">상위 트레잇(supertraits)</a>을 구현합니다.</p>
<div class="rule" id="r-type.trait-object.name"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.name" title="type.trait-object.name"><span>[type<wbr>.trait-object<wbr>.name]<span/></a></div>
<p>트레잇 객체는 <code>dyn</code> 키워드 뒤에 트레잇 바운드 집합이 오는 형태로 작성되지만, 트레잇 바운드에 다음과 같은 제한이 있습니다.</p>
<div class="rule" id="r-type.trait-object.constraint"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.constraint" title="type.trait-object.constraint"><span>[type<wbr>.trait-object<wbr>.constraint]<span/></a></div>
<p>비자동 트레잇은 하나를 초과할 수 없고, 라이프타임도 하나를 초과할 수 없으며, 제외(opt-out) 바운드(예: <code>?Sized</code>)는 허용되지 않습니다. 또한, 트레잇 경로는 괄호로 묶을 수 있습니다.</p>
<p>예를 들어, <code>Trait</code>라는 트레잇이 주어졌을 때, 다음은 모두 트레잇 객체입니다:</p>
<ul>
<li><code>dyn Trait</code></li>
<li><code>dyn Trait + Send</code></li>
<li><code>dyn Trait + Send + Sync</code></li>
<li><code>dyn Trait + 'static</code></li>
<li><code>dyn Trait + Send + 'static</code></li>
<li><code>dyn Trait +</code></li>
<li><code>dyn 'static + Trait</code>.</li>
<li><code>dyn (Trait)</code></li>
</ul>
<div class="rule" id="r-type.trait-object.syntax-edition2021"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.syntax-edition2021" title="type.trait-object.syntax-edition2021"><span>[type<wbr>.trait-object<wbr>.syntax-edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션 이전에는 <code>dyn</code> 키워드를 생략할 수 있었습니다.</p>
<p>참고: 코드베이스가 Rust 1.26 이하에서의 컴파일을 지원해야 하는 경우가 아니라면, 명확성을 위해 트레잇 객체에 항상 <code>dyn</code> 키워드를 사용하는 것이 권장됩니다.</p>
</blockquote>
<div class="rule" id="r-type.trait-object.syntax-edition2015"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.syntax-edition2015" title="type.trait-object.syntax-edition2015"><span>[type<wbr>.trait-object<wbr>.syntax-edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 트레잇 객체의 첫 번째 바운드가 <code>::</code>로 시작하는 경로인 경우, <code>dyn</code>은 경로의 일부로 취급됩니다. 첫 번째 경로를 괄호로 묶으면 이를 피할 수 있습니다. 따라서 <code>::your_module::Trait</code> 트레잇을 가진 트레잇 객체를 원한다면, <code>dyn (::your_module::Trait)</code>라고 작성해야 합니다.</p>
<p>2018 에디션부터 <code>dyn</code>은 진정한 키워드이며 경로에 허용되지 않으므로, 괄호가 필요하지 않습니다.</p>
</blockquote>
<div class="rule" id="r-type.trait-object.alias"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.alias" title="type.trait-object.alias"><span>[type<wbr>.trait-object<wbr>.alias]<span/></a></div>
<p>기반 트레잇이 서로 별칭(alias) 관계이고 자동 트레잇 집합과 라이프타임 바운드가 동일하다면, 두 트레잇 객체 타입은 서로 별칭 관계입니다. 예를 들어, <code>dyn Trait + Send + UnwindSafe</code>는 <code>dyn Trait + UnwindSafe + Send</code>와 같습니다.</p>
<div class="rule" id="r-type.trait-object.unsized"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.unsized" title="type.trait-object.unsized"><span>[type<wbr>.trait-object<wbr>.unsized]<span/></a></div>
<p>값이 어떤 구체적인 타입인지 불투명하기 때문에, 트레잇 객체는 <a href="types/../dynamically-sized-types.html">동적 크기 타입</a>입니다. 모든 <abbr title="dynamically sized types">DST</abbr>와 마찬가지로, 트레잇 객체는 <code>&amp;dyn SomeTrait</code> 또는 <code>Box&lt;dyn SomeTrait&gt;</code>와 같이 어떤 포인터 타입 뒤에서 사용됩니다. 트레잇 객체에 대한 포인터의 각 인스턴스는 다음을 포함합니다:</p>
<ul>
<li><code>SomeTrait</code>를 구현하는 타입 <code>T</code>의 인스턴스에 대한 포인터</li>
<li><em>가상 메서드 테이블</em>(흔히 _vtable_이라고 함)은 <code>T</code>가 구현하는 <code>SomeTrait</code> 및 그 <a href="types/../items/traits.html#supertraits">상위 트레잇</a>의 각 메서드에 대해 <code>T</code>의 구현에 대한 포인터(즉, 함수 포인터)를 포함합니다.</li>
</ul>
<p>트레잇 객체의 목적은 메서드의 “지연 바인딩(late binding)“을 허용하는 것입니다. 트레잇 객체에서 메서드를 호출하면 런타임에 가상 디스패치(virtual dispatch)가 발생합니다. 즉, 트레잇 객체 vtable에서 함수 포인터를 로드하여 간접적으로 호출합니다. 각 vtable 항목에 대한 실제 구현은 객체마다 다를 수 있습니다.</p>
<p>트레잇 객체의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;dyn Printable&gt;) {
    println!("{}", a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;dyn Printable&gt;);
}</code></pre></pre>
<p>이 예시에서, 트레잇 <code>Printable</code>은 <code>print</code>의 타입 시그니처와 <code>main</code>의 캐스트 표현식 양쪽 모두에서 트레잇 객체로 나타납니다.</p>
<div class="rule" id="r-type.trait-object.lifetime-bounds"><a class="rule-link" href="types/trait-object.html#r-type.trait-object.lifetime-bounds" title="type.trait-object.lifetime-bounds"><span>[type<wbr>.trait-object<wbr>.lifetime-bounds]<span/></a></div>
<h2 id="트레잇-객체-라이프타임-바운드"><a class="header" href="#트레잇-객체-라이프타임-바운드">트레잇 객체 라이프타임 바운드</a></h2>
<p>트레잇 객체는 참조를 포함할 수 있으므로, 해당 참조들의 라이프타임은 트레잇 객체의 일부로 표현되어야 합니다. 이 라이프타임은 <code>Trait + 'a</code>로 작성됩니다. <a href="types/../lifetime-elision.html#default-trait-object-lifetimes">기본값</a>이 있어 보통은 이 라이프타임이 합리적인 선택으로 추론될 수 있게 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.impl-trait"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait" title="type.impl-trait"><span>[type<wbr>.impl-trait]<span/></a></div>
<h1 id="impl-트레잇"><a class="header" href="#impl-트레잇">Impl 트레잇</a></h1>
<div class="rule" id="r-type.impl-trait.syntax"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.syntax" title="type.impl-trait.syntax"><span>[type<wbr>.impl-trait<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Impl트레잇타입</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>타입매개변수바운드</em></a></p>
<p><em>하나의바운드를가진Impl트레잇타입</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>트레잇바운드</em></a></p>
</blockquote>
<div class="rule" id="r-type.impl-trait.intro"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.intro" title="type.impl-trait.intro"><span>[type<wbr>.impl-trait<wbr>.intro]<span/></a></div>
<p><code>impl Trait</code>는 특정 트레잇을 구현하는 이름은 없지만 구체적인 타입을 지정하는 방법을 제공합니다. 이는 두 가지 위치에 나타날 수 있습니다: 인자 위치(함수에 대한 익명 타입 매개변수 역할)와 반환 위치(추상 반환 타입 역할)입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
<span class="boring">impl Trait for () {}
</span>
// 인자 위치: 익명 타입 매개변수
fn foo(arg: impl Trait) {
}

// 반환 위치: 추상 반환 타입
fn bar() -&gt; impl Trait {
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.impl-trait.param"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.param" title="type.impl-trait.param"><span>[type<wbr>.impl-trait<wbr>.param]<span/></a></div>
<h2 id="익명-타입-매개변수"><a class="header" href="#익명-타입-매개변수">익명 타입 매개변수</a></h2>
<blockquote>
<p>참고: 이는 흔히 “인자 위치의 impl Trait“라고 불립니다. (여기서는 “매개변수“라는 용어가 더 정확하지만, “인자 위치의 impl Trait“는 이 기능의 개발 중에 사용된 표현이며 구현의 일부에 남아 있습니다.)</p>
</blockquote>
<div class="rule" id="r-type.impl-trait.param.intro"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.param.intro" title="type.impl-trait.param.intro"><span>[type<wbr>.impl-trait<wbr>.param<wbr>.intro]<span/></a></div>
<p>함수는 <code>impl</code> 뒤에 트레잇 바운드 집합을 사용하여 매개변수가 익명 타입을 갖도록 선언할 수 있습니다. 호출자는 익명 타입 매개변수에 선언된 바운드를 만족하는 타입을 제공해야 하며, 함수는 익명 타입 매개변수의 트레잇 바운드를 통해 사용할 수 있는 메서드만 사용할 수 있습니다.</p>
<p>예를 들어, 다음 두 형식은 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// 제네릭 타입 매개변수
fn with_generic_type&lt;T: Trait&gt;(arg: T) {
}

// 인자 위치의 impl Trait
fn with_impl_trait(arg: impl Trait) {
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.impl-trait.param.generic"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.param.generic" title="type.impl-trait.param.generic"><span>[type<wbr>.impl-trait<wbr>.param<wbr>.generic]<span/></a></div>
<p>즉, 인자 위치의 <code>impl Trait</code>는 <code>&lt;T: Trait&gt;</code>와 같은 제네릭 타입 매개변수에 대한 문법적 설탕(syntactic sugar)입니다. 단, 타입이 익명이며 <a href="types/../items/generics.html"><em>제네릭 매개변수</em></a> 목록에 나타나지 않는다는 점이 다릅니다.</p>
<blockquote>
<p><strong>참고:</strong> 함수 매개변수의 경우, 제네릭 타입 매개변수와 <code>impl Trait</code>가 정확히 동일하지는 않습니다. <code>&lt;T: Trait&gt;</code>와 같은 제네릭 매개변수를 사용하면, 호출자는 호출 지점에서 <a href="types/../paths.html#paths-in-expressions"><em>제네릭 인자</em></a>를 사용하여 <code>T</code>에 대한 제네릭 인자를 명시적으로 지정할 수 있는 옵션이 있습니다(예: <code>foo::&lt;usize&gt;(1)</code>). 매개변수를 둘 중 하나에서 다른 것으로 변경하는 것은 제네릭 인자의 수를 변경하므로 함수 호출자에게 주요 변경 사항(breaking change)이 될 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-type.impl-trait.return"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return" title="type.impl-trait.return"><span>[type<wbr>.impl-trait<wbr>.return]<span/></a></div>
<h2 id="추상-반환-타입"><a class="header" href="#추상-반환-타입">추상 반환 타입</a></h2>
<blockquote>
<p>참고: 이는 흔히 “반환 위치의 impl Trait“라고 불립니다.</p>
</blockquote>
<div class="rule" id="r-type.impl-trait.return.intro"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return.intro" title="type.impl-trait.return.intro"><span>[type<wbr>.impl-trait<wbr>.return<wbr>.intro]<span/></a></div>
<p>함수는 <code>impl Trait</code>를 사용하여 추상 반환 타입을 반환할 수 있습니다. 이러한 타입은 호출자가 지정된 <code>Trait</code>에 의해 선언된 메서드만 사용할 수 있는 다른 구체적인 타입을 대신합니다.</p>
<div class="rule" id="r-type.impl-trait.return.constraint-body"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return.constraint-body" title="type.impl-trait.return.constraint-body"><span>[type<wbr>.impl-trait<wbr>.return<wbr>.constraint-body]<span/></a></div>
<p>함수에서 가능한 각 반환 값은 동일한 구체적인 타입으로 해석되어야 합니다.</p>
<p>반환 위치의 <code>impl Trait</code>는 함수가 박싱되지 않은(unboxed) 추상 타입을 반환할 수 있게 합니다. 이는 <a href="types/closure.html">클로저</a> 및 반복자와 함께 사용할 때 특히 유용합니다. 예를 들어, 클로저는 작성할 수 없는 고유한 타입을 가집니다. 이전에는 함수에서 클로저를 반환하는 유일한 방법이 <a href="types/trait-object.html">트레잇 객체</a>를 사용하는 것이었습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}</span></code></pre></pre>
<p>이는 힙 할당 및 동적 디스패치로 인한 성능 저하를 초래할 수 있습니다. 클로저의 타입을 완전히 명시하는 것은 불가능했고, 오직 <code>Fn</code> 트레잇만 사용할 수 있었습니다. 즉, 트레잇 객체가 필요하다는 뜻입니다. 하지만 <code>impl Trait</code>를 사용하면 이를 더 간단하게 작성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>이는 또한 박싱된 트레잇 객체 사용의 단점을 피할 수 있게 해줍니다.</p>
<p>마찬가지로, 반복자의 구체적인 타입은 체인에 있는 이전의 모든 반복자의 타입을 포함하여 매우 복잡해질 수 있습니다. <code>impl Iterator</code>를 반환한다는 것은 함수가 관련된 다른 모든 반복자 타입을 명시적으로 지정하는 대신, 반환 타입에 대한 바운드로서 <code>Iterator</code> 트레잇만을 노출한다는 것을 의미합니다.</p>
<div class="rule" id="r-type.impl-trait.return-in-trait"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return-in-trait" title="type.impl-trait.return-in-trait"><span>[type<wbr>.impl-trait<wbr>.return-in-trait]<span/></a></div>
<h2 id="트레잇-및-트레잇-구현에서의-반환-위치-impl-trait"><a class="header" href="#트레잇-및-트레잇-구현에서의-반환-위치-impl-trait">트레잇 및 트레잇 구현에서의 반환 위치 <code>impl Trait</code></a></h2>
<div class="rule" id="r-type.impl-trait.return-in-trait.intro"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return-in-trait.intro" title="type.impl-trait.return-in-trait.intro"><span>[type<wbr>.impl-trait<wbr>.return-in-trait<wbr>.intro]<span/></a></div>
<p>트레잇 내의 함수들도 익명 연관 타입을 위한 구문으로 <code>impl Trait</code>를 사용할 수 있습니다.</p>
<div class="rule" id="r-type.impl-trait.return-in-trait.desugaring"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.return-in-trait.desugaring" title="type.impl-trait.return-in-trait.desugaring"><span>[type<wbr>.impl-trait<wbr>.return-in-trait<wbr>.desugaring]<span/></a></div>
<p>트레잇 내 연관 함수의 반환 타입에 있는 모든 <code>impl Trait</code>는 익명 연관 타입으로 디슈거링(desugared)됩니다. 구현의 함수 시그니처에 나타나는 반환 타입이 연관 타입의 값을 결정하는 데 사용됩니다.</p>
<div class="rule" id="r-type.impl-trait.generic-captures"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-captures" title="type.impl-trait.generic-captures"><span>[type<wbr>.impl-trait<wbr>.generic-captures]<span/></a></div>
<h2 id="캡처링"><a class="header" href="#캡처링">캡처링</a></h2>
<p>각 반환 위치 <code>impl Trait</code> 추상 타입 뒤에는 숨겨진 구체적인 타입이 있습니다. 이 구체적인 타입이 제네릭 매개변수를 사용하려면, 해당 제네릭 매개변수가 추상 타입에 의해 _캡처_되어야 합니다.</p>
<div class="rule" id="r-type.impl-trait.generic-capture.auto"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.auto" title="type.impl-trait.generic-capture.auto"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.auto]<span/></a></div>
<h2 id="자동-캡처링"><a class="header" href="#자동-캡처링">자동 캡처링</a></h2>
<div class="rule" id="r-type.impl-trait.generic-capture.auto.intro"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.auto.intro" title="type.impl-trait.generic-capture.auto.intro"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.auto<wbr>.intro]<span/></a></div>
<p>반환 위치의 <code>impl Trait</code> 추상 타입은 제네릭 타입, 상수, 라이프타임 매개변수(고차원(higher-ranked) 매개변수 포함)를 포함한 스코프 내의 모든 제네릭 매개변수를 자동으로 캡처합니다.</p>
<div class="rule" id="r-type.impl-trait.generic-capture.edition2024"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.edition2024" title="type.impl-trait.generic-capture.edition2024"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는, 자유 함수(free functions)와 고유 구현(inherent impls)의 연관 함수 및 메서드에서, 추상 반환 타입의 바운드에 나타나지 않는 제네릭 라이프타임 매개변수는 자동으로 캡처되지 않습니다.</p>
</blockquote>
<div class="rule" id="r-type.impl-trait.generic-capture.precise"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise" title="type.impl-trait.generic-capture.precise"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.precise]<span/></a></div>
<h2 id="정밀-캡처링"><a class="header" href="#정밀-캡처링">정밀 캡처링</a></h2>
<div class="rule" id="r-type.impl-trait.generic-capture.precise.use"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.use" title="type.impl-trait.generic-capture.precise.use"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.precise<wbr>.use]<span/></a></div>
<p>반환 위치의 <code>impl Trait</code> 추상 타입에 의해 캡처되는 제네릭 매개변수 집합은 <a href="types/../trait-bounds.html#use-bounds"><code>use&lt;..&gt;</code> 바운드</a>를 사용하여 명시적으로 제어할 수 있습니다. 이것이 존재하면, <code>use&lt;..&gt;</code> 바운드에 나열된 제네릭 매개변수만 캡처됩니다. 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capture&lt;'a, 'b, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + use&lt;'a, T&gt; {
  //                                      ~~~~~~~~~~~~~~~~~~~~~~~
  //                                     오직 `'a`와 `T`만 캡처합니다.
  (x, y)
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.impl-trait.generic-capture.precise.constraint-single"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-single" title="type.impl-trait.generic-capture.precise.constraint-single"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.precise<wbr>.constraint-single]<span/></a></div>
<p>현재 바운드 목록에는 <code>use&lt;..&gt;</code> 바운드가 하나만 존재할 수 있으며, 트레잇 정의의 아이템 시그니처에는 이러한 바운드가 허용되지 않습니다. 또한 스코프 내의 모든 타입 및 상수 제네릭 매개변수가 포함되어야 하며, 추상 타입의 다른 바운드에 나타나는 모든 라이프타임 매개변수도 포함되어야 합니다.</p>
<div class="rule" id="r-type.impl-trait.generic-capture.precise.constraint-lifetime"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-lifetime" title="type.impl-trait.generic-capture.precise.constraint-lifetime"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.precise<wbr>.constraint-lifetime]<span/></a></div>
<p><code>use&lt;..&gt;</code> 바운드 내에서, 존재하는 모든 라이프타임 매개변수는 모든 타입 및 상수 제네릭 매개변수보다 앞에 나타나야 하며, <code>impl Trait</code> 반환 타입 내에서 허용되는 경우 생략된 라이프타임(<code>'_</code>)이 나타날 수 있습니다.</p>
<div class="rule" id="r-type.impl-trait.generic-capture.precise.constraint-param-impl-trait"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-param-impl-trait" title="type.impl-trait.generic-capture.precise.constraint-param-impl-trait"><span>[type<wbr>.impl-trait<wbr>.generic-capture<wbr>.precise<wbr>.constraint-param-impl-trait]<span/></a></div>
<p>스코프 내의 모든 타입 매개변수가 이름으로 포함되어야 하므로, 인자 위치 <code>impl Trait</code>를 사용하는 아이템의 시그니처에는 <code>use&lt;..&gt;</code> 바운드를 사용할 수 없습니다. 해당 아이템들은 스코프 내에 익명 타입 매개변수를 갖기 때문입니다.</p>
<h2 id="반환-위치에서의-제네릭과-impl-trait의-차이점"><a class="header" href="#반환-위치에서의-제네릭과-impl-trait의-차이점">반환 위치에서의 제네릭과 <code>impl Trait</code>의 차이점</a></h2>
<p>인자 위치에서 <code>impl Trait</code>는 의미론적으로 제네릭 타입 매개변수와 매우 유사합니다. 그러나 반환 위치에서는 둘 사이에 중요한 차이가 있습니다. <code>impl Trait</code>를 사용하면 제네릭 타입 매개변수와 달리 함수가 반환 타입을 선택하며, 호출자는 반환 타입을 선택할 수 없습니다.</p>
<p>다음 함수는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn foo&lt;T: Trait&gt;() -&gt; T {
    // ...
<span class="boring">panic!()
</span>}
<span class="boring">}</span></code></pre></pre>
<p>호출자가 반환 타입 <code>T</code>를 결정하도록 허용하며, 함수는 해당 타입을 반환합니다.</p>
<p>다음 함수는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>fn foo() -&gt; impl Trait {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>호출자가 반환 타입을 결정하는 것을 허용하지 않습니다. 대신 함수가 반환 타입을 선택하지만, 오직 그 타입이 <code>Trait</code>를 구현한다는 것만 약속합니다.</p>
<div class="rule" id="r-type.impl-trait.constraint"><a class="rule-link" href="types/impl-trait.html#r-type.impl-trait.constraint" title="type.impl-trait.constraint"><span>[type<wbr>.impl-trait<wbr>.constraint]<span/></a></div>
<h2 id="제한-사항-1"><a class="header" href="#제한-사항-1">제한 사항</a></h2>
<p><code>impl Trait</code>는 <code>extern</code>이 아닌 함수의 매개변수 또는 반환 타입으로만 나타날 수 있습니다. <code>let</code> 바인딩의 타입이나 필드 타입이 될 수 없으며, 타입 별칭 내부에 나타날 수 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.generic"><a class="rule-link" href="types/parameters.html#r-type.generic" title="type.generic"><span>[type<wbr>.generic]<span/></a></div>
<h1 id="타입-파라미터"><a class="header" href="#타입-파라미터">타입 파라미터</a></h1>
<p>타입 매개변수 선언이 있는 아이템의 본문 내에서, 해당 타입 매개변수의 이름은 타입입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    if xs.is_empty() {
        return vec![];
    }
    let first: A = xs[0].clone();
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    rest.insert(0, first);
    rest
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>first</code>는 <code>to_vec</code>의 <code>A</code> 타입 매개변수를 참조하는 <code>A</code> 타입을 가지며, <code>rest</code>는 요소 타입이 <code>A</code>인 벡터 <code>Vec&lt;A&gt;</code> 타입을 가집니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-type.inferred"><a class="rule-link" href="types/inferred.html#r-type.inferred" title="type.inferred"><span>[type<wbr>.inferred]<span/></a></div>
<h1 id="추론된-타입"><a class="header" href="#추론된-타입">추론된 타입</a></h1>
<div class="rule" id="r-type.inferred.syntax"><a class="rule-link" href="types/inferred.html#r-type.inferred.syntax" title="type.inferred.syntax"><span>[type<wbr>.inferred<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>추론된타입</em> : <code>_</code></p>
</blockquote>
<div class="rule" id="r-type.inferred.intro"><a class="rule-link" href="types/inferred.html#r-type.inferred.intro" title="type.inferred.intro"><span>[type<wbr>.inferred<wbr>.intro]<span/></a></div>
<p>추론된 타입은 컴파일러에게 사용 가능한 주변 정보를 기반으로 가능한 경우 타입을 추론하도록 요청합니다.</p>
<div class="rule" id="r-type.inferred.constraint"><a class="rule-link" href="types/inferred.html#r-type.inferred.constraint" title="type.inferred.constraint"><span>[type<wbr>.inferred<wbr>.constraint]<span/></a></div>
<p>이는 아이템 시그니처에서 사용될 수 없습니다.</p>
<p>이는 흔히 제네릭 인자에서 사용됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = (0..10).collect();
<span class="boring">}</span></code></pre></pre>
<!--
  What else should be said here?
  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html
  There should be a broader discussion of type inference somewhere.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="동적-크기-타입"><a class="header" href="#동적-크기-타입">동적 크기 타입</a></h1>
<div class="rule" id="r-dynamic-sized"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized" title="dynamic-sized"><span>[dynamic-sized]<span/></a></div>
<div class="rule" id="r-dynamic-sized.intro"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.intro" title="dynamic-sized.intro"><span>[dynamic-sized<wbr>.intro]<span/></a></div>
<p>대부분의 타입은 컴파일 타임에 알려진 고정된 크기를 가지며 <a href="special-types-and-traits.html#sized"><code>Sized</code></a> 트레잇을 구현합니다. 런타임에만 크기가 알려지는 타입을 <em>동적 크기 타입</em>(<em>DST</em>) 또는 비공식적으로 크기가 없는(unsized) 타입이라고 부릅니다. <a href="types/slice.html">슬라이스</a>와 <a href="types/trait-object.html">트레잇 객체</a>는 <abbr title="dynamically sized types">DST</abbr>의 두 가지 예입니다.</p>
<div class="rule" id="r-dynamic-sized.restriction"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.restriction" title="dynamic-sized.restriction"><span>[dynamic-sized<wbr>.restriction]<span/></a></div>
<p>이러한 타입은 특정 경우에만 사용될 수 있습니다:</p>
<div class="rule" id="r-dynamic-sized.pointer-types"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.pointer-types" title="dynamic-sized.pointer-types"><span>[dynamic-sized<wbr>.pointer-types]<span/></a></div>
<ul>
<li><abbr title="dynamically sized types">DST</abbr>에 대한 <a href="types/pointer.html">포인터 타입</a>은 크기가 있지만, 크기가 있는 타입에 대한 포인터보다 두 배의 크기를 가집니다.
<ul>
<li>슬라이스에 대한 포인터는 슬라이스의 요소 수도 저장합니다.</li>
<li>트레잇 객체에 대한 포인터는 vtable에 대한 포인터도 저장합니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-dynamic-sized.question-sized"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.question-sized" title="dynamic-sized.question-sized"><span>[dynamic-sized<wbr>.question-sized]<span/></a></div>
<ul>
<li><abbr title="dynamically sized types">DST</abbr>는 특별한 <code>?Sized</code> 바운드를 가진 제네릭 타입 매개변수에 타입 인자로 제공될 수 있습니다. 또한 대응하는 연관 타입 선언에 <code>?Sized</code> 바운드가 있을 때 연관 타입 정의에도 사용될 수 있습니다. 기본적으로 모든 타입 매개변수나 연관 타입은 <code>?Sized</code>를 사용하여 완화되지 않는 한 <code>Sized</code> 바운드를 가집니다.</li>
</ul>
<div class="rule" id="r-dynamic-sized.trait-impl"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.trait-impl" title="dynamic-sized.trait-impl"><span>[dynamic-sized<wbr>.trait-impl]<span/></a></div>
<ul>
<li>트레잇은 <abbr title="dynamically sized types">DST</abbr>에 대해 구현될 수 있습니다. 제네릭 타입 매개변수와 달리, 트레잇 정의에서는 <code>Self: ?Sized</code>가 기본값입니다.</li>
</ul>
<div class="rule" id="r-dynamic-sized.struct-field"><a class="rule-link" href="dynamically-sized-types.html#r-dynamic-sized.struct-field" title="dynamic-sized.struct-field"><span>[dynamic-sized<wbr>.struct-field]<span/></a></div>
<ul>
<li>구조체는 마지막 필드로 <abbr title="dynamically sized type">DST</abbr>를 포함할 수 있으며, 이 경우 구조체 자체도 <abbr title="dynamically sized type">DST</abbr>가 됩니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: <a href="variables.html">변수</a>, 함수 매개변수, <a href="items/constant-items.html">const</a> 아이템, <a href="items/static-items.html">static</a> 아이템은 반드시 <code>Sized</code>여야 합니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-layout"><a class="rule-link" href="type-layout.html#r-layout" title="layout"><span>[layout]<span/></a></div>
<h1 id="타입-레이아웃"><a class="header" href="#타입-레이아웃">타입 레이아웃</a></h1>
<div class="rule" id="r-layout.intro"><a class="rule-link" href="type-layout.html#r-layout.intro" title="layout.intro"><span>[layout<wbr>.intro]<span/></a></div>
<p>타입의 레이아웃은 크기, 정렬, 그리고 필드들의 상대적 오프셋을 의미합니다. 열거형의 경우, 판별자(discriminant)가 어떻게 배치되고 해석되는지 또한 타입 레이아웃의 일부입니다.</p>
<div class="rule" id="r-layout.guarantees"><a class="rule-link" href="type-layout.html#r-layout.guarantees" title="layout.guarantees"><span>[layout<wbr>.guarantees]<span/></a></div>
<p>타입 레이아웃은 컴파일할 때마다 변경될 수 있습니다. 정확히 어떻게 수행되는지 문서화하려고 시도하는 대신, 우리는 현재 보장되는 내용만을 문서화합니다.</p>
<p>동일한 레이아웃을 가진 타입이라도 함수 경계를 넘어 전달되는 방식은 다를 수 있다는 점에 유의하십시오. 타입의 함수 호출 ABI 호환성에 대해서는 <a href="../core/primitive.fn.html#abi-compatibility">여기</a>를 참조하십시오.</p>
<div class="rule" id="r-layout.properties"><a class="rule-link" href="type-layout.html#r-layout.properties" title="layout.properties"><span>[layout<wbr>.properties]<span/></a></div>
<h2 id="크기와-정렬"><a class="header" href="#크기와-정렬">크기와 정렬</a></h2>
<p>모든 값은 정렬과 크기를 가집니다.</p>
<div class="rule" id="r-layout.properties.align"><a class="rule-link" href="type-layout.html#r-layout.properties.align" title="layout.properties.align"><span>[layout<wbr>.properties<wbr>.align]<span/></a></div>
<p>값의 _정렬(alignment)_은 해당 값을 저장하기에 유효한 주소가 무엇인지 지정합니다. 정렬이 <code>n</code>인 값은 반드시 n의 배수인 주소에만 저장되어야 합니다. 예를 들어, 정렬이 2인 값은 짝수 주소에 저장되어야 하며, 정렬이 1인 값은 아무 주소에나 저장될 수 있습니다. 정렬은 바이트 단위로 측정되며, 최소 1이어야 하고 항상 2의 거듭제곱이어야 합니다. 값의 정렬은 <a href="../core/mem/fn.align_of_val.html"><code>align_of_val</code></a> 함수로 확인할 수 있습니다.</p>
<div class="rule" id="r-layout.properties.size"><a class="rule-link" href="type-layout.html#r-layout.properties.size" title="layout.properties.size"><span>[layout<wbr>.properties<wbr>.size]<span/></a></div>
<p>값의 _크기(size)_는 해당 아이템 타입을 가진 배열에서 연속된 요소 사이의 바이트 단위 오프셋이며, 정렬 패딩을 포함합니다. 값의 크기는 항상 정렬의 배수입니다. 일부 타입은 크기가 0일 수 있음에 유의하십시오; 0은 모든 정렬의 배수로 간주됩니다(예를 들어, 일부 플랫폼에서 <code>[u16; 0]</code> 타입은 크기가 0이고 정렬이 2입니다). 값의 크기는 <a href="../core/mem/fn.size_of_val.html"><code>size_of_val</code></a> 함수로 확인할 수 있습니다.</p>
<div class="rule" id="r-layout.properties.sized"><a class="rule-link" href="type-layout.html#r-layout.properties.sized" title="layout.properties.sized"><span>[layout<wbr>.properties<wbr>.sized]<span/></a></div>
<p>모든 값이 동일한 크기와 정렬을 가지며 컴파일 타임에 둘 다 알려진 타입은 <a href="../core/marker/trait.Sized.html"><code>Sized</code></a> 트레잇을 구현하고, <a href="../core/mem/fn.size_of.html"><code>size_of</code></a> 및 <a href="../core/mem/fn.align_of.html"><code>align_of</code></a> 함수로 확인할 수 있습니다. <a href="../core/marker/trait.Sized.html"><code>Sized</code></a>가 아닌 타입은 <a href="dynamically-sized-types.html">동적 크기 타입</a>으로 알려져 있습니다. <code>Sized</code> 타입의 모든 값은 동일한 크기와 정렬을 공유하므로, 이러한 공유된 값을 각각 해당 타입의 크기와 타입의 정렬이라고 부릅니다.</p>
<div class="rule" id="r-layout.primitive"><a class="rule-link" href="type-layout.html#r-layout.primitive" title="layout.primitive"><span>[layout<wbr>.primitive]<span/></a></div>
<h2 id="기본-데이터-레이아웃"><a class="header" href="#기본-데이터-레이아웃">기본 데이터 레이아웃</a></h2>
<div class="rule" id="r-layout.primitive.size"><a class="rule-link" href="type-layout.html#r-layout.primitive.size" title="layout.primitive.size"><span>[layout<wbr>.primitive<wbr>.size]<span/></a></div>
<p>대부분의 기본 타입들의 크기는 이 표에 주어져 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>usize</code> / <code>isize</code></td><td>아래 참조</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
</div><div class="rule" id="r-layout.primitive.size-int"><a class="rule-link" href="type-layout.html#r-layout.primitive.size-int" title="layout.primitive.size-int"><span>[layout<wbr>.primitive<wbr>.size-int]<span/></a></div>
<p><code>usize</code>와 <code>isize</code>는 대상 플랫폼의 모든 주소를 포함할 수 있을 만큼 큰 크기를 가집니다. 예를 들어, 32비트 대상에서는 4바이트이고, 64비트 대상에서는 8바이트입니다.</p>
<div class="rule" id="r-layout.primitive.align"><a class="rule-link" href="type-layout.html#r-layout.primitive.align" title="layout.primitive.align"><span>[layout<wbr>.primitive<wbr>.align]<span/></a></div>
<p>기본 타입의 정렬은 플랫폼에 따라 다릅니다. 대부분의 경우 정렬은 크기와 같지만, 더 작을 수도 있습니다. 특히 <code>i128</code>과 <code>u128</code>은 크기가 16임에도 불구하고 종종 4 또는 8 바이트로 정렬되며, 많은 32비트 플랫폼에서 <code>i64</code>, <code>u64</code>, <code>f64</code>는 8이 아닌 4 바이트로만 정렬됩니다.</p>
<div class="rule" id="r-layout.pointer"><a class="rule-link" href="type-layout.html#r-layout.pointer" title="layout.pointer"><span>[layout<wbr>.pointer]<span/></a></div>
<h2 id="포인터-및-참조-레이아웃"><a class="header" href="#포인터-및-참조-레이아웃">포인터 및 참조 레이아웃</a></h2>
<div class="rule" id="r-layout.pointer.intro"><a class="rule-link" href="type-layout.html#r-layout.pointer.intro" title="layout.pointer.intro"><span>[layout<wbr>.pointer<wbr>.intro]<span/></a></div>
<p>포인터와 참조는 동일한 레이아웃을 가집니다. 포인터나 참조의 가변성은 레이아웃을 변경하지 않습니다.</p>
<div class="rule" id="r-layout.pointer.thin"><a class="rule-link" href="type-layout.html#r-layout.pointer.thin" title="layout.pointer.thin"><span>[layout<wbr>.pointer<wbr>.thin]<span/></a></div>
<p>크기가 있는 타입에 대한 포인터는 <code>usize</code>와 동일한 크기와 정렬을 가집니다.</p>
<div class="rule" id="r-layout.pointer.unsized"><a class="rule-link" href="type-layout.html#r-layout.pointer.unsized" title="layout.pointer.unsized"><span>[layout<wbr>.pointer<wbr>.unsized]<span/></a></div>
<p>크기가 없는 타입(unsized types)에 대한 포인터는 크기를 가집니다. 크기와 정렬은 적어도 포인터의 크기 및 정렬과 동일함이 보장됩니다.</p>
<blockquote>
<p>참고: 이에 의존해서는 안 되지만, 현재 모든 <abbr title="Dynamically Sized Types">DST</abbr>에 대한 포인터는 <code>usize</code> 크기의 두 배이며 정렬은 동일합니다.</p>
</blockquote>
<div class="rule" id="r-layout.array"><a class="rule-link" href="type-layout.html#r-layout.array" title="layout.array"><span>[layout<wbr>.array]<span/></a></div>
<h2 id="배열-레이아웃"><a class="header" href="#배열-레이아웃">배열 레이아웃</a></h2>
<p><code>[T; N]</code> 배열은 <code>size_of::&lt;T&gt;() * N</code>의 크기를 가지며 <code>T</code>와 동일한 정렬을 가집니다. 배열은 0부터 시작하는 <code>nth</code> 요소가 배열 시작점으로부터 <code>n * size_of::&lt;T&gt;()</code> 바이트만큼 오프셋되도록 배치됩니다.</p>
<div class="rule" id="r-layout.slice"><a class="rule-link" href="type-layout.html#r-layout.slice" title="layout.slice"><span>[layout<wbr>.slice]<span/></a></div>
<h2 id="슬라이스-레이아웃"><a class="header" href="#슬라이스-레이아웃">슬라이스 레이아웃</a></h2>
<p>슬라이스는 자신이 슬라이싱하는 배열 섹션과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>참고: 이것은 슬라이스에 대한 포인터(<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code> 등)가 아니라 원시 <code>[T]</code> 타입에 대한 내용입니다.</p>
</blockquote>
<div class="rule" id="r-layout.str"><a class="rule-link" href="type-layout.html#r-layout.str" title="layout.str"><span>[layout<wbr>.str]<span/></a></div>
<h2 id="str-레이아웃"><a class="header" href="#str-레이아웃"><code>str</code> 레이아웃</a></h2>
<p>문자열 슬라이스는 <code>[u8]</code> 타입의 슬라이스와 동일한 레이아웃을 가진 문자의 UTF-8 표현입니다.</p>
<div class="rule" id="r-layout.tuple"><a class="rule-link" href="type-layout.html#r-layout.tuple" title="layout.tuple"><span>[layout<wbr>.tuple]<span/></a></div>
<h2 id="튜플-레이아웃"><a class="header" href="#튜플-레이아웃">튜플 레이아웃</a></h2>
<div class="rule" id="r-layout.tuple.general"><a class="rule-link" href="type-layout.html#r-layout.tuple.general" title="layout.tuple.general"><span>[layout<wbr>.tuple<wbr>.general]<span/></a></div>
<p>튜플은 <a href="type-layout.html#the-rust-representation"><code>Rust</code> 표현</a>에 따라 배치됩니다.</p>
<div class="rule" id="r-layout.tuple.unit"><a class="rule-link" href="type-layout.html#r-layout.tuple.unit" title="layout.tuple.unit"><span>[layout<wbr>.tuple<wbr>.unit]<span/></a></div>
<p>이에 대한 예외는 유닛 튜플(<code>()</code>)로, 크기가 0이고 정렬이 1인 0크기 타입(zero-sized type)으로 보장됩니다.</p>
<div class="rule" id="r-layout.trait-object"><a class="rule-link" href="type-layout.html#r-layout.trait-object" title="layout.trait-object"><span>[layout<wbr>.trait-object]<span/></a></div>
<h2 id="트레잇-객체-레이아웃"><a class="header" href="#트레잇-객체-레이아웃">트레잇 객체 레이아웃</a></h2>
<p>트레잇 객체는 해당 트레잇 객체가 나타내는 값과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>참고: 이것은 트레잇 객체에 대한 포인터(<code>&amp;dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code> 등)가 아니라 원시 트레잇 객체 타입에 대한 내용입니다.</p>
</blockquote>
<div class="rule" id="r-layout.closure"><a class="rule-link" href="type-layout.html#r-layout.closure" title="layout.closure"><span>[layout<wbr>.closure]<span/></a></div>
<h2 id="클로저-레이아웃"><a class="header" href="#클로저-레이아웃">클로저 레이아웃</a></h2>
<p>클로저는 레이아웃 보장이 없습니다.</p>
<div class="rule" id="r-layout.repr"><a class="rule-link" href="type-layout.html#r-layout.repr" title="layout.repr"><span>[layout<wbr>.repr]<span/></a></div>
<h2 id="표현-representations"><a class="header" href="#표현-representations">표현 (Representations)</a></h2>
<div class="rule" id="r-layout.repr.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.intro" title="layout.repr.intro"><span>[layout<wbr>.repr<wbr>.intro]<span/></a></div>
<p>모든 사용자 정의 복합 타입(<code>struct</code>, <code>enum</code>, <code>union</code>)은 해당 타입의 레이아웃이 무엇인지 지정하는 _표현(representation)_을 가집니다.</p>
<div class="rule" id="r-layout.repr.kinds"><a class="rule-link" href="type-layout.html#r-layout.repr.kinds" title="layout.repr.kinds"><span>[layout<wbr>.repr<wbr>.kinds]<span/></a></div>
<p>타입에 대해 가능한 표현은 다음과 같습니다:</p>
<ul>
<li><a href="type-layout.html#the-rust-representation"><code>Rust</code></a> (기본값)</li>
<li><a href="type-layout.html#the-c-representation"><code>C</code></a></li>
<li><a href="type-layout.html#primitive-representations">기본 표현(primitive representations)</a></li>
<li><a href="type-layout.html#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<div class="rule" id="r-layout.repr.attribute"><a class="rule-link" href="type-layout.html#r-layout.repr.attribute" title="layout.repr.attribute"><span>[layout<wbr>.repr<wbr>.attribute]<span/></a></div>
<p>타입의 표현은 <code>repr</code> 속성을 적용하여 변경할 수 있습니다. 다음 예시는 <code>C</code> 표현을 가진 구조체를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-layout.repr.align-packed"><a class="rule-link" href="type-layout.html#r-layout.repr.align-packed" title="layout.repr.align-packed"><span>[layout<wbr>.repr<wbr>.align-packed]<span/></a></div>
<p>정렬은 각각 <code>align</code>과 <code>packed</code> 수정자를 사용하여 높이거나 낮출 수 있습니다. 이들은 속성에 지정된 표현을 변경합니다. 지정된 표현이 없으면 기본 표현이 변경됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 기본 표현, 정렬이 2로 낮아짐.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 표현, 정렬이 8로 높아짐
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: 표현이 아이템의 속성이라는 점 때문에, 표현은 제네릭 매개변수에 의존하지 않습니다. 동일한 이름을 가진 두 타입은 동일한 표현을 가집니다. 예를 들어, <code>Foo&lt;Bar&gt;</code>와 <code>Foo&lt;Baz&gt;</code>는 둘 다 동일한 표현을 가집니다.</p>
</blockquote>
<div class="rule" id="r-layout.repr.inter-field"><a class="rule-link" href="type-layout.html#r-layout.repr.inter-field" title="layout.repr.inter-field"><span>[layout<wbr>.repr<wbr>.inter-field]<span/></a></div>
<p>타입의 표현은 필드 간의 패딩을 변경할 수 있지만, 필드 자체의 레이아웃은 변경하지 않습니다. 예를 들어, <code>Rust</code> 표현을 가진 <code>Inner</code> 구조체를 포함하는 <code>C</code> 표현의 구조체는 <code>Inner</code>의 레이아웃을 변경하지 않습니다.</p>
<p><a id="the-default-representation"></a></p>
<div class="rule" id="r-layout.repr.rust"><a class="rule-link" href="type-layout.html#r-layout.repr.rust" title="layout.repr.rust"><span>[layout<wbr>.repr<wbr>.rust]<span/></a></div>
<h3 id="rust-표현"><a class="header" href="#rust-표현"><code>Rust</code> 표현</a></h3>
<div class="rule" id="r-layout.repr.rust.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.rust.intro" title="layout.repr.rust.intro"><span>[layout<wbr>.repr<wbr>.rust<wbr>.intro]<span/></a></div>
<p><code>Rust</code> 표현은 <code>repr</code> 속성이 없는 명목적 타입의 기본 표현입니다. <code>repr</code> 속성을 통해 이 표현을 명시적으로 사용하는 것은 속성을 완전히 생략하는 것과 동일함이 보장됩니다.</p>
<div class="rule" id="r-layout.repr.rust.layout"><a class="rule-link" href="type-layout.html#r-layout.repr.rust.layout" title="layout.repr.rust.layout"><span>[layout<wbr>.repr<wbr>.rust<wbr>.layout]<span/></a></div>
<p>이 표현이 제공하는 유일한 데이터 레이아웃 보장은 안전성(soundness)을 위해 필요한 것들뿐입니다. 그 보장들은 다음과 같습니다:</p>
<ol>
<li>필드들이 올바르게 정렬됩니다.</li>
<li>필드들이 겹치지 않습니다.</li>
<li>타입의 정렬은 최소한 그 필드들의 최대 정렬 이상입니다.</li>
</ol>
<div class="rule" id="r-layout.repr.rust.alignment"><a class="rule-link" href="type-layout.html#r-layout.repr.rust.alignment" title="layout.repr.rust.alignment"><span>[layout<wbr>.repr<wbr>.rust<wbr>.alignment]<span/></a></div>
<p>형식적으로, 첫 번째 보장은 모든 필드의 오프셋이 해당 필드의 정렬로 나누어떨어진다는 것을 의미합니다.</p>
<div class="rule" id="r-layout.repr.rust.field-storage"><a class="rule-link" href="type-layout.html#r-layout.repr.rust.field-storage" title="layout.repr.rust.field-storage"><span>[layout<wbr>.repr<wbr>.rust<wbr>.field-storage]<span/></a></div>
<p>두 번째 보장은 필드들이 순서대로 정렬될 때, 어떤 필드의 오프셋 더하기 크기가 다음 필드의 오프셋보다 작거나 같도록 정렬될 수 있음을 의미합니다. 이 순서는 타입 선언에 필드가 지정된 순서와 동일할 필요는 없습니다.</p>
<p>두 번째 보장이 필드들이 서로 다른 주소를 갖는다는 것을 의미하지는 않음에 유의하십시오. 크기가 0인 타입은 동일한 구조체 내의 다른 필드와 같은 주소를 가질 수 있습니다.</p>
<div class="rule" id="r-layout.repr.rust.unspecified"><a class="rule-link" href="type-layout.html#r-layout.repr.rust.unspecified" title="layout.repr.rust.unspecified"><span>[layout<wbr>.repr<wbr>.rust<wbr>.unspecified]<span/></a></div>
<p>이 표현이 제공하는 데이터 레이아웃에 대한 다른 보장은 없습니다.</p>
<div class="rule" id="r-layout.repr.c"><a class="rule-link" href="type-layout.html#r-layout.repr.c" title="layout.repr.c"><span>[layout<wbr>.repr<wbr>.c]<span/></a></div>
<h3 id="c-표현"><a class="header" href="#c-표현"><code>C</code> 표현</a></h3>
<div class="rule" id="r-layout.repr.c.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.c.intro" title="layout.repr.c.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.intro]<span/></a></div>
<p><code>C</code> 표현은 이중 목적으로 설계되었습니다. 첫 번째 목적은 C 언어와 상호 운용 가능한 타입을 생성하는 것입니다. 두 번째 목적은 값을 다른 타입으로 재해석하는 것과 같이 데이터 레이아웃에 의존하는 연산을 안전하게 수행할 수 있는 타입을 생성하는 것입니다.</p>
<p>이러한 이중 목적 때문에, C 프로그래밍 언어와의 인터페이스에는 유용하지 않은 타입을 생성하는 것도 가능합니다.</p>
<div class="rule" id="r-layout.repr.c.constraint"><a class="rule-link" href="type-layout.html#r-layout.repr.c.constraint" title="layout.repr.c.constraint"><span>[layout<wbr>.repr<wbr>.c<wbr>.constraint]<span/></a></div>
<p>이 표현은 구조체, 공용체, 열거형에 적용될 수 있습니다. 예외는 <a href="items/enumerations.html#zero-variant-enums">변형이 없는 열거형</a>으로, 이에 대해 <code>C</code> 표현을 사용하는 것은 오류입니다.</p>
<div class="rule" id="r-layout.repr.c.struct"><a class="rule-link" href="type-layout.html#r-layout.repr.c.struct" title="layout.repr.c.struct"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct]<span/></a></div>
<h4 id="reprc-구조체"><a class="header" href="#reprc-구조체"><code>#[repr(C)]</code> 구조체</a></h4>
<div class="rule" id="r-layout.repr.c.struct.align"><a class="rule-link" href="type-layout.html#r-layout.repr.c.struct.align" title="layout.repr.c.struct.align"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct<wbr>.align]<span/></a></div>
<p>구조체의 정렬은 그 안에 있는 가장 크게 정렬된 필드의 정렬입니다.</p>
<div class="rule" id="r-layout.repr.c.struct.size-field-offset"><a class="rule-link" href="type-layout.html#r-layout.repr.c.struct.size-field-offset" title="layout.repr.c.struct.size-field-offset"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct<wbr>.size-field-offset]<span/></a></div>
<p>필드의 크기와 오프셋은 다음 알고리즘에 의해 결정됩니다.</p>
<p>현재 오프셋 0바이트로 시작합니다.</p>
<p>구조체의 선언 순서대로 각 필드에 대해, 먼저 필드의 크기와 정렬을 결정합니다. 현재 오프셋이 필드의 정렬의 배수가 아니라면, 필드 정렬의 배수가 될 때까지 현재 오프셋에 패딩 바이트를 추가합니다. 해당 필드의 오프셋은 현재 오프셋 값이 됩니다. 그런 다음 현재 오프셋을 필드의 크기만큼 증가시킵니다.</p>
<p>마지막으로, 구조체의 크기는 현재 오프셋을 구조체의 정렬의 가장 가까운 배수로 올림한 값입니다.</p>
<p>다음은 의사코드로 설명된 이 알고리즘입니다.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 다음 주소가 `alignment`에 맞춰 정렬되도록 하기 위해
/// `offset` 뒤에 필요한 패딩의 양을 반환합니다.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // `alignment`의 다음 배수로 올림
        alignment - misalignment
    } else {
        // 이미 `alignment`의 배수임
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 현재 오프셋을 증가시켜 이 필드의 정렬의 배수가 되도록 합니다.
    // 첫 번째 필드의 경우, 이는 항상 0이 됩니다.
    // 건너뛴 바이트를 패딩 바이트라고 합니다.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 이 의사코드는 명확성을 위해 오버플로 문제를 무시하는 단순한 알고리즘을 사용합니다. 실제 코드에서 메모리 레이아웃 계산을 수행하려면 <a href="../core/alloc/layout/struct.Layout.html"><code>Layout</code></a>을 사용하십시오.</p>
</blockquote>
</div>
<blockquote>
<p>참고: 이 알고리즘은 크기가 0인 구조체를 생성할 수 있습니다. C에서 <code>struct Foo { }</code>와 같은 빈 구조체 선언은 불법입니다. 그러나 gcc와 clang 모두 이러한 구조체를 활성화하고 크기를 0으로 할당하는 옵션을 지원합니다. 대조적으로 C++는 빈 구조체에 크기 1을 부여합니다. 단, 상속받았거나 <code>[[no_unique_address]]</code> 속성을 가진 필드인 경우는 제외하며, 이 경우 구조체의 전체 크기를 증가시키지 않습니다.</p>
</blockquote>
<div class="rule" id="r-layout.repr.c.union"><a class="rule-link" href="type-layout.html#r-layout.repr.c.union" title="layout.repr.c.union"><span>[layout<wbr>.repr<wbr>.c<wbr>.union]<span/></a></div>
<h4 id="reprc-공용체"><a class="header" href="#reprc-공용체"><code>#[repr(C)]</code> 공용체</a></h4>
<div class="rule" id="r-layout.repr.c.union.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.c.union.intro" title="layout.repr.c.union.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.union<wbr>.intro]<span/></a></div>
<p><code>#[repr(C)]</code>로 선언된 공용체는 대상 플랫폼의 C 언어에서 동등한 C 공용체 선언과 동일한 크기와 정렬을 가집니다.</p>
<div class="rule" id="r-layout.repr.c.union.size-align"><a class="rule-link" href="type-layout.html#r-layout.repr.c.union.size-align" title="layout.repr.c.union.size-align"><span>[layout<wbr>.repr<wbr>.c<wbr>.union<wbr>.size-align]<span/></a></div>
<p>공용체는 모든 필드의 최대 크기를 정렬에 맞춰 올림한 크기와, 모든 필드의 최대 정렬인 정렬을 가집니다. 이러한 최대값들은 서로 다른 필드에서 올 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // f2에서 옴
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // f1에서 옴

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // b에서 크기 6,
                                                      // a의 정렬에 따라
                                                      // 8로 올림.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // a에서 옴
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-layout.repr.c.enum"><a class="rule-link" href="type-layout.html#r-layout.repr.c.enum" title="layout.repr.c.enum"><span>[layout<wbr>.repr<wbr>.c<wbr>.enum]<span/></a></div>
<h4 id="reprc-필드-없는-열거형"><a class="header" href="#reprc-필드-없는-열거형"><code>#[repr(C)]</code> 필드 없는 열거형</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, <code>C</code> 표현은 대상 플랫폼의 C ABI에 대한 기본 <code>enum</code> 크기 및 정렬과 동일한 크기 및 정렬을 가집니다.</p>
<blockquote>
<p>참고: C의 열거형 표현은 구현 정의(implementation defined)이므로 이는 사실상 “최선의 추측“입니다. 특히, 관심 있는 C 코드가 특정 플래그로 컴파일된 경우 이것이 부정확할 수 있습니다.</p>
</blockquote>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> C 언어의 <code>enum</code>과 이 표현을 사용하는 러스트의 <a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a> 사이에는 결정적인 차이가 있습니다. C의 <code>enum</code>은 주로 <code>typedef</code>에 이름 있는 상수를 더한 것입니다. 다시 말해, <code>enum</code> 타입의 객체는 어떤 정수 값이든 가질 수 있습니다. 예를 들어, 이는 <code>C</code>에서 비트 플래그로 자주 사용됩니다. 대조적으로, 러스트의 <a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>은 판별자 값만을 합법적으로 가질 수 있으며, 그 외의 모든 것은 <a href="behavior-considered-undefined.html">정의되지 않은 동작(undefined behavior)</a>입니다. 따라서 C <code>enum</code>을 모델링하기 위해 FFI에서 필드 없는 열거형을 사용하는 것은 종종 잘못된 것입니다.</p>
</blockquote>
</div>
<div class="rule" id="r-layout.repr.c.adt"><a class="rule-link" href="type-layout.html#r-layout.repr.c.adt" title="layout.repr.c.adt"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt]<span/></a></div>
<h4 id="reprc-필드-있는-열거형"><a class="header" href="#reprc-필드-있는-열거형"><code>#[repr(C)]</code> 필드 있는 열거형</a></h4>
<div class="rule" id="r-layout.repr.c.adt.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.c.adt.intro" title="layout.repr.c.adt.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.intro]<span/></a></div>
<p>필드가 있는 <code>repr(C)</code> 열거형의 표현은 두 개의 필드를 가진 <code>repr(C)</code> 구조체이며, C에서는 “태그된 공용체(tagged union)“라고도 불립니다:</p>
<div class="rule" id="r-layout.repr.c.adt.tag"><a class="rule-link" href="type-layout.html#r-layout.repr.c.adt.tag" title="layout.repr.c.adt.tag"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.tag]<span/></a></div>
<ul>
<li>모든 필드가 제거된 열거형의 <code>repr(C)</code> 버전 (“태그”)</li>
</ul>
<div class="rule" id="r-layout.repr.c.adt.fields"><a class="rule-link" href="type-layout.html#r-layout.repr.c.adt.fields" title="layout.repr.c.adt.fields"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.fields]<span/></a></div>
<ul>
<li>필드를 가진 각 변형의 필드들을 위한 <code>repr(C)</code> 구조체들의 <code>repr(C)</code> 공용체 (“페이로드”)</li>
</ul>
<blockquote>
<p>참고: <code>repr(C)</code> 구조체 및 공용체의 표현 방식으로 인해, 변형이 단일 필드를 가질 경우 해당 필드를 공용체에 직접 넣는 것과 구조체로 감싸는 것 사이에 차이가 없습니다. 따라서 그러한 <code>enum</code>의 표현을 조작하려는 시스템은 자신에게 더 편리하거나 일관된 형태를 사용할 수 있습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 Enum은 다음 구조체와 동일한 표현을 가집니다 ...
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 구조체와.
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant,
    payload: MyEnumFields,
}

// 이것은 판별자 열거형입니다.
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 이것은 변형 공용체입니다.
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 이 구조체는 생략될 수 있으며(0크기 타입임), C/C++ 헤더에 있어야 합니다.
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>Copy</code>가 아닌 필드를 가진 <code>union</code>은 불안정합니다. <a href="https://github.com/rust-lang/rust/issues/55149">55149</a>를 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-layout.repr.primitive"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive" title="layout.repr.primitive"><span>[layout<wbr>.repr<wbr>.primitive]<span/></a></div>
<h3 id="기본-표현-primitive-representations"><a class="header" href="#기본-표현-primitive-representations">기본 표현 (Primitive representations)</a></h3>
<div class="rule" id="r-layout.repr.primitive.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive.intro" title="layout.repr.primitive.intro"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.intro]<span/></a></div>
<p>_기본 표현_은 기본 정수 타입과 동일한 이름을 가진 표현입니다. 즉: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>입니다.</p>
<div class="rule" id="r-layout.repr.primitive.constraint"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive.constraint" title="layout.repr.primitive.constraint"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.constraint]<span/></a></div>
<p>기본 표현은 열거형에만 적용될 수 있으며 열거형에 필드가 있는지 없는지에 따라 다르게 동작합니다. <a href="items/enumerations.html#zero-variant-enums">변형이 없는 열거형</a>이 기본 표현을 갖는 것은 오류입니다. 두 개의 기본 표현을 결합하는 것은 오류입니다.</p>
<div class="rule" id="r-layout.repr.primitive.enum"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive.enum" title="layout.repr.primitive.enum"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.enum]<span/></a></div>
<h4 id="필드-없는-열거형의-기본-표현"><a class="header" href="#필드-없는-열거형의-기본-표현">필드 없는 열거형의 기본 표현</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, 기본 표현은 크기와 정렬을 동일한 이름의 기본 타입과 같게 설정합니다. 예를 들어, <code>u8</code> 표현을 가진 필드 없는 열거형은 0에서 255(포함) 사이의 판별자만 가질 수 있습니다.</p>
<div class="rule" id="r-layout.repr.primitive.adt"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive.adt" title="layout.repr.primitive.adt"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.adt]<span/></a></div>
<h4 id="필드-있는-열거형의-기본-표현"><a class="header" href="#필드-있는-열거형의-기본-표현">필드 있는 열거형의 기본 표현</a></h4>
<p>기본 표현 열거형의 표현은 <code>repr(C)</code> 공용체입니다</p>
<blockquote>
<p>참고: 만약 조작을 더 명확하게 하기 위해 태그에 공용체 내의 별도 멤버를 부여하더라도 이 표현은 변경되지 않습니다(단, C++ 표준을 따르려면 태그 멤버는 <code>struct</code>로 감싸져야 합니다).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 열거형은 다음 공용체와 동일한 표현을 가집니다 ...
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 공용체와.
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 이것은 판별자 열거형입니다.
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>Copy</code>가 아닌 필드를 가진 <code>union</code>은 불안정합니다. <a href="https://github.com/rust-lang/rust/issues/55149">55149</a>를 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-layout.repr.primitive-c"><a class="rule-link" href="type-layout.html#r-layout.repr.primitive-c" title="layout.repr.primitive-c"><span>[layout<wbr>.repr<wbr>.primitive-c]<span/></a></div>
<h4 id="필드가-있는-열거형의-기본-표현과-reprc-결합하기"><a class="header" href="#필드가-있는-열거형의-기본-표현과-reprc-결합하기">필드가 있는 열거형의 기본 표현과 <code>#[repr(C)]</code> 결합하기</a></h4>
<p>필드가 있는 열거형의 경우, <code>repr(C)</code>와 기본 표현을 결합하는 것도 가능합니다(예: <code>repr(C, u8)</code>). 이는 판별자 열거형의 표현을 선택된 기본 타입으로 변경함으로써 <a href="type-layout.html#reprc-enums-with-fields"><code>repr(C)</code></a>를 수정합니다. 따라서 <code>u8</code> 표현을 선택했다면, 판별자 열거형은 1바이트의 크기와 정렬을 갖게 됩니다.</p>
<p><a href="type-layout.html#reprc-enums-with-fields">앞서</a> 나온 예시의 판별자 열거형은 다음과 같이 됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // `u8`이 추가됨
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 따라서 여기서 `C` 대신 `u8`이 사용됨
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre></pre>
<p>예를 들어, <code>repr(C, u8)</code> 열거형은 257개의 고유한 판별자(“태그”)를 가질 수 없는 반면, <code>repr(C)</code> 속성만 있는 동일한 열거형은 문제없이 컴파일됩니다.</p>
<p><code>repr(C)</code>에 더해 기본 표현을 사용하면 <code>repr(C)</code> 형태로부터 열거형의 크기가 변경될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// C 표현의 크기는 플랫폼에 따라 다릅니다
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// 판별자를 위한 1바이트와 Enum8::Variant0의 값을 위한 1바이트
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// 판별자를 위한 2바이트와 Enum16::Variant0의 값을 위한 1바이트
// 더하기 1바이트의 패딩.
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-layout.repr.alignment"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment" title="layout.repr.alignment"><span>[layout<wbr>.repr<wbr>.alignment]<span/></a></div>
<h3 id="정렬-수정자"><a class="header" href="#정렬-수정자">정렬 수정자</a></h3>
<div class="rule" id="r-layout.repr.alignment.intro"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.intro" title="layout.repr.alignment.intro"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.intro]<span/></a></div>
<p><code>align</code>과 <code>packed</code> 수정자는 각각 <code>struct</code>와 <code>union</code>의 정렬을 높이거나 낮출 때 사용할 수 있습니다. <code>packed</code>는 필드 사이의 패딩을 변경할 수도 있습니다(단, 필드 내부의 패딩은 변경하지 않습니다). <code>align</code>과 <code>packed</code>는 그 자체로는 구조체 레이아웃이나 열거형 변형 레이아웃의 필드 순서에 대한 보장을 제공하지 않지만, 그러한 보장을 제공하는 표현(예: <code>C</code>)과 결합될 수 있습니다.</p>
<div class="rule" id="r-layout.repr.alignment.constraint-alignment"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.constraint-alignment" title="layout.repr.alignment.constraint-alignment"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.constraint-alignment]<span/></a></div>
<p>The alignment is specified as an integer parameter in the form of <code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given, as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<div class="rule" id="r-layout.repr.alignment.align"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.align" title="layout.repr.alignment.align"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.align]<span/></a></div>
<p><code>align</code>의 경우, 지정된 정렬이 <code>align</code> 수정자가 없을 때의 타입 정렬보다 작으면 정렬은 영향을 받지 않습니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.packed" title="layout.repr.alignment.packed"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed]<span/></a></div>
<p><code>packed</code>의 경우, 지정된 정렬이 <code>packed</code> 수정자가 없을 때의 타입 정렬보다 크면 정렬과 레이아웃은 영향을 받지 않습니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed-fields"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.packed-fields" title="layout.repr.alignment.packed-fields"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed-fields]<span/></a></div>
<p>필드 배치를 위한 각 필드의 정렬은 지정된 정렬과 필드 타입의 정렬 중 더 작은 값입니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed-padding"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.packed-padding" title="layout.repr.alignment.packed-padding"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed-padding]<span/></a></div>
<p>필드 간 패딩은 각 필드의 (변경되었을 수 있는) 정렬을 충족하기 위해 필요한 최소한의 양으로 보장됩니다(단, <code>packed</code> 자체는 필드 순서에 대한 어떤 보장도 제공하지 않음에 유의하십시오). 이 규칙의 중요한 결과는 <code>#[repr(packed(1))]</code>(또는 <code>#[repr(packed)]</code>)을 가진 타입은 필드 간 패딩이 없다는 것입니다.</p>
<div class="rule" id="r-layout.repr.alignment.constraint-exclusive"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.constraint-exclusive" title="layout.repr.alignment.constraint-exclusive"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.constraint-exclusive]<span/></a></div>
<p><code>align</code>과 <code>packed</code> 수정자는 동일한 타입에 적용될 수 없으며, <code>packed</code> 타입은 전이적으로 다른 <code>align</code>된 타입을 포함할 수 없습니다. <code>align</code>과 <code>packed</code>는 <a href="type-layout.html#the-rust-representation"><code>Rust</code></a> 및 <a href="type-layout.html#the-c-representation"><code>C</code></a> 표현에만 적용될 수 있습니다.</p>
<div class="rule" id="r-layout.repr.alignment.enum"><a class="rule-link" href="type-layout.html#r-layout.repr.alignment.enum" title="layout.repr.alignment.enum"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.enum]<span/></a></div>
<p><code>align</code> 수정자는 <code>enum</code>에도 적용될 수 있습니다. 이 경우, <code>enum</code>의 정렬에 미치는 효과는 <code>enum</code>이 동일한 <code>align</code> 수정자를 가진 뉴타입 <code>struct</code>로 감싸진 경우와 동일합니다.</p>
<blockquote>
<p>Note: References to unaligned fields are not allowed because it is <a href="behavior-considered-undefined.html">undefined behavior</a>. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}
let mut e = Packed { f1: 1, f2: 2 };
// 필드에 대한 참조를 생성하는 대신, 값을 로컬 변수로 복사하십시오.
let x = e.f2;
// 또는 참조를 생성하는 `println!`과 같은 상황에서는 중괄호를 사용하여
// 값의 복사본으로 변경하십시오.
println!("{}", {e.f2});
// 포인터가 필요한 경우, 포인터를 직접 역참조하는 대신
// 읽기 및 쓰기에 정렬되지 않은 메서드를 사용하십시오.
let ptr: *const u16 = &amp;raw const e.f2;
let value = unsafe { ptr.read_unaligned() };
let mut_ptr: *mut u16 = &amp;raw mut e.f2;
unsafe { mut_ptr.write_unaligned(3) }
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-layout.repr.transparent"><a class="rule-link" href="type-layout.html#r-layout.repr.transparent" title="layout.repr.transparent"><span>[layout<wbr>.repr<wbr>.transparent]<span/></a></div>
<h3 id="transparent-표현"><a class="header" href="#transparent-표현"><code>transparent</code> 표현</a></h3>
<div class="rule" id="r-layout.repr.transparent.constraint-field"><a class="rule-link" href="type-layout.html#r-layout.repr.transparent.constraint-field" title="layout.repr.transparent.constraint-field"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.constraint-field]<span/></a></div>
<p><code>transparent</code> 표현은 다음을 가진 <a href="items/structs.html"><code>struct</code></a> 또는 단일 변형 <a href="items/enumerations.html"><code>enum</code></a>에서만 사용될 수 있습니다:</p>
<ul>
<li>크기가 0이고 정렬이 1인 임의 개수의 필드 (예: <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>), 그리고</li>
<li>최대 하나의 다른 필드.</li>
</ul>
<div class="rule" id="r-layout.repr.transparent.layout-abi"><a class="rule-link" href="type-layout.html#r-layout.repr.transparent.layout-abi" title="layout.repr.transparent.layout-abi"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.layout-abi]<span/></a></div>
<p>이 표현을 가진 구조체와 열거형은 크기가 0이 아니고 정렬이 1이 아닌 유일한 필드(존재하는 경우)와 동일한 레이아웃 및 ABI를 가지며, 그렇지 않으면 유닛과 동일합니다.</p>
<p>이는 <code>C</code> 표현과는 다릅니다. <code>C</code> 표현을 가진 구조체는 항상 <code>C</code> <code>struct</code>의 ABI를 갖는 반면, 예를 들어 기본(primitive) 필드를 가진 <code>transparent</code> 표현의 구조체는 해당 기본 필드의 ABI를 갖기 때문입니다.</p>
<div class="rule" id="r-layout.repr.transparent.constraint-exclusive"><a class="rule-link" href="type-layout.html#r-layout.repr.transparent.constraint-exclusive" title="layout.repr.transparent.constraint-exclusive"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.constraint-exclusive]<span/></a></div>
<p>이 표현은 타입 레이아웃을 다른 타입에 위임하므로, 다른 어떤 표현과도 함께 사용될 수 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-interior-mut"><a class="rule-link" href="interior-mutability.html#r-interior-mut" title="interior-mut"><span>[interior-mut]<span/></a></div>
<h1 id="내부-가변성-interior-mutability"><a class="header" href="#내부-가변성-interior-mutability">내부 가변성 (Interior Mutability)</a></h1>
<div class="rule" id="r-interior-mut.intro"><a class="rule-link" href="interior-mutability.html#r-interior-mut.intro" title="interior-mut.intro"><span>[interior-mut<wbr>.intro]<span/></a></div>
<p>때로는 여러 별칭(aliases)을 가진 상태에서 타입을 변경해야 할 때가 있습니다. 러스트에서는 _내부 가변성_이라는 패턴을 사용하여 이를 달성합니다.</p>
<div class="rule" id="r-interior-mut.shared-ref"><a class="rule-link" href="interior-mutability.html#r-interior-mut.shared-ref" title="interior-mut.shared-ref"><span>[interior-mut<wbr>.shared-ref]<span/></a></div>
<p>타입에 대한 <a href="types/pointer.html#shared-references-">공유 참조</a>를 통해 내부 상태를 변경할 수 있다면 그 타입은 내부 가변성을 가집니다.</p>
<div class="rule" id="r-interior-mut.no-constraint"><a class="rule-link" href="interior-mutability.html#r-interior-mut.no-constraint" title="interior-mut.no-constraint"><span>[interior-mut<wbr>.no-constraint]<span/></a></div>
<p>이는 공유 참조가 가리키는 값은 변경되지 않는다는 일반적인 <a href="behavior-considered-undefined.html">요구사항</a>에 반하는 것입니다.</p>
<div class="rule" id="r-interior-mut.unsafe-cell"><a class="rule-link" href="interior-mutability.html#r-interior-mut.unsafe-cell" title="interior-mut.unsafe-cell"><span>[interior-mut<wbr>.unsafe-cell]<span/></a></div>
<p><a href="../core/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> 타입은 이 요구사항을 비활성화하는 유일한 허용된 방법입니다. <code>UnsafeCell&lt;T&gt;</code>가 불변으로 별칭이 지정되어 있더라도, 그 안에 포함된 <code>T</code>를 변경하거나 <code>T</code>에 대한 가변 참조를 얻는 것은 여전히 안전합니다.</p>
<div class="rule" id="r-interior-mut.mut-unsafe-cell"><a class="rule-link" href="interior-mutability.html#r-interior-mut.mut-unsafe-cell" title="interior-mut.mut-unsafe-cell"><span>[interior-mut<wbr>.mut-unsafe-cell]<span/></a></div>
<p>다른 모든 타입과 마찬가지로, 여러 개의 <code>&amp;mut UnsafeCell&lt;T&gt;</code> 별칭을 갖는 것은 정의되지 않은 동작입니다.</p>
<div class="rule" id="r-interior-mut.abstraction"><a class="rule-link" href="interior-mutability.html#r-interior-mut.abstraction" title="interior-mut.abstraction"><span>[interior-mut<wbr>.abstraction]<span/></a></div>
<p>내부 가변성을 가진 다른 타입들은 <code>UnsafeCell&lt;T&gt;</code>를 필드로 사용하여 생성될 수 있습니다. 표준 라이브러리는 안전한 내부 가변성 API를 제공하는 다양한 타입을 제공합니다.</p>
<div class="rule" id="r-interior-mut.ref-cell"><a class="rule-link" href="interior-mutability.html#r-interior-mut.ref-cell" title="interior-mut.ref-cell"><span>[interior-mut<wbr>.ref-cell]<span/></a></div>
<p>예를 들어, <a href="../core/cell/struct.RefCell.html"><code>std::cell::RefCell&lt;T&gt;</code></a>은 런타임 차용 검사를 사용하여 다중 참조에 대한 일반적인 규칙을 보장합니다.</p>
<div class="rule" id="r-interior-mut.atomic"><a class="rule-link" href="interior-mutability.html#r-interior-mut.atomic" title="interior-mut.atomic"><span>[interior-mut<wbr>.atomic]<span/></a></div>
<p><a href="../core/sync/atomic/index.html"><code>std::sync::atomic</code></a> 모듈은 원자적 연산으로만 접근되는 값을 감싸는 타입을 포함하여, 값이 스레드 간에 공유되고 변경될 수 있도록 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-subtype"><a class="rule-link" href="subtyping.html#r-subtype" title="subtype"><span>[subtype]<span/></a></div>
<h1 id="서브타이핑과-가변성"><a class="header" href="#서브타이핑과-가변성">서브타이핑과 가변성</a></h1>
<div class="rule" id="r-subtype.intro"><a class="rule-link" href="subtyping.html#r-subtype.intro" title="subtype.intro"><span>[subtype<wbr>.intro]<span/></a></div>
<p>서브타이핑은 암시적이며 타입 검사나 추론의 어느 단계에서든 발생할 수 있습니다.</p>
<div class="rule" id="r-subtype.kinds"><a class="rule-link" href="subtyping.html#r-subtype.kinds" title="subtype.kinds"><span>[subtype<wbr>.kinds]<span/></a></div>
<p>서브타이핑은 두 가지 경우로 제한됩니다: 라이프타임에 대한 가변성(variance)과 고차원(higher ranked) 라이프타임을 가진 타입 간의 관계입니다. 만약 타입에서 라이프타임을 제거한다면, 유일한 서브타이핑은 타입 동등성 때문일 것입니다.</p>
<p>다음 예시를 고려해보십시오: 문자열 리터럴은 항상 <code>'static</code> 라이프타임을 가집니다. 그럼에도 불구하고 우리는 <code>s</code>를 <code>t</code>에 할당할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;'a&gt;() {
    let s: &amp;'static str = "hi";
    let t: &amp;'a str = s;
}
<span class="boring">}</span></code></pre></pre>
<p><code>'static</code>은 라이프타임 매개변수 <code>'a</code>보다 오래 생존하므로, <code>&amp;'static str</code>은 <code>&amp;'a str</code>의 서브타입입니다.</p>
<div class="rule" id="r-subtype.higher-ranked"><a class="rule-link" href="subtyping.html#r-subtype.higher-ranked" title="subtype.higher-ranked"><span>[subtype<wbr>.higher-ranked]<span/></a></div>
<p><a href="../nomicon/hrtb.html">고차원(Higher-ranked)</a> <a href="types/function-pointer.html">함수 포인터</a>와 <a href="types/trait-object.html">트레잇 객체</a>는 또 다른 서브타입 관계를 가집니다. 이들은 고차원 라이프타임의 대체로 주어지는 타입들의 서브타입입니다. 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 여기서 'a는 'static으로 대체됩니다
let subtype: &amp;(for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;((|x| x) as fn(&amp;_) -&gt; &amp;_);
let supertype: &amp;(fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 이는 트레잇 객체에 대해서도 유사하게 작동합니다
let subtype: &amp;(dyn for&lt;'a&gt; Fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;|x| x;
let supertype: &amp;(dyn Fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 하나의 고차원 라이프타임을 다른 것으로 대체할 수도 있습니다
let subtype: &amp;(for&lt;'a, 'b&gt; fn(&amp;'a i32, &amp;'b i32))= &amp;((|x, y| {}) as fn(&amp;_, &amp;_));
let supertype: &amp;for&lt;'c&gt; fn(&amp;'c i32, &amp;'c i32) = subtype;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-subtyping.variance"><a class="rule-link" href="subtyping.html#r-subtyping.variance" title="subtyping.variance"><span>[subtyping<wbr>.variance]<span/></a></div>
<h2 id="가변성-variance"><a class="header" href="#가변성-variance">가변성 (Variance)</a></h2>
<div class="rule" id="r-subtyping.variance.intro"><a class="rule-link" href="subtyping.html#r-subtyping.variance.intro" title="subtyping.variance.intro"><span>[subtyping<wbr>.variance<wbr>.intro]<span/></a></div>
<p>가변성은 제네릭 타입이 그 인자에 대해 갖는 속성입니다. 매개변수에 대한 제네릭 타입의 _가변성_은 매개변수의 서브타이핑이 타입의 서브타이핑에 어떻게 영향을 미치는지를 나타냅니다.</p>
<div class="rule" id="r-subtyping.variance.covariant"><a class="rule-link" href="subtyping.html#r-subtyping.variance.covariant" title="subtyping.variance.covariant"><span>[subtyping<wbr>.variance<wbr>.covariant]<span/></a></div>
<ul>
<li><code>T</code>가 <code>U</code>의 서브타입일 때 <code>F&lt;T&gt;</code>가 <code>F&lt;U&gt;</code>의 서브타입이면, <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _공변적(covariant)_입니다 (서브타이핑이 “통과“함).</li>
</ul>
<div class="rule" id="r-subtyping.variance.contravariant"><a class="rule-link" href="subtyping.html#r-subtyping.variance.contravariant" title="subtyping.variance.contravariant"><span>[subtyping<wbr>.variance<wbr>.contravariant]<span/></a></div>
<ul>
<li><code>T</code>가 <code>U</code>의 서브타입일 때 <code>F&lt;U&gt;</code>가 <code>F&lt;T&gt;</code>의 서브타입이면, <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _반변적(contravariant)_입니다.</li>
</ul>
<div class="rule" id="r-subtyping.variance.invariant"><a class="rule-link" href="subtyping.html#r-subtyping.variance.invariant" title="subtyping.variance.invariant"><span>[subtyping<wbr>.variance<wbr>.invariant]<span/></a></div>
<ul>
<li>그렇지 않으면 <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _불변적(invariant)_입니다 (서브타입 관계가 유도될 수 없음)</li>
</ul>
<div class="rule" id="r-subtyping.variance.builtin-types"><a class="rule-link" href="subtyping.html#r-subtyping.variance.builtin-types" title="subtyping.variance.builtin-types"><span>[subtyping<wbr>.variance<wbr>.builtin-types]<span/></a></div>
<p>타입의 가변성은 다음과 같이 자동으로 결정됩니다</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th><code>'a</code>에 대한 가변성</th><th><code>T</code>에 대한 가변성</th></tr></thead><tbody>
<tr><td><code>&amp;'a T</code></td><td>공변적</td><td>공변적</td></tr>
<tr><td><code>&amp;'a mut T</code></td><td>공변적</td><td>불변적</td></tr>
<tr><td><code>*const T</code></td><td></td><td>공변적</td></tr>
<tr><td><code>*mut T</code></td><td></td><td>불변적</td></tr>
<tr><td><code>[T]</code> 및 <code>[T; n]</code></td><td></td><td>공변적</td></tr>
<tr><td><code>fn() -&gt; T</code></td><td></td><td>공변적</td></tr>
<tr><td><code>fn(T) -&gt; ()</code></td><td></td><td>반변적</td></tr>
<tr><td><code>std::cell::UnsafeCell&lt;T&gt;</code></td><td></td><td>불변적</td></tr>
<tr><td><code>std::marker::PhantomData&lt;T&gt;</code></td><td></td><td>공변적</td></tr>
<tr><td><code>dyn Trait&lt;T&gt; + 'a</code></td><td>공변적</td><td>불변적</td></tr>
</tbody></table>
</div><div class="rule" id="r-subtyping.variance.user-composite-types"><a class="rule-link" href="subtyping.html#r-subtyping.variance.user-composite-types" title="subtyping.variance.user-composite-types"><span>[subtyping<wbr>.variance<wbr>.user-composite-types]<span/></a></div>
<p>다른 <code>struct</code>, <code>enum</code>, <code>union</code> 타입의 가변성은 필드 타입의 가변성을 보고 결정됩니다. 매개변수가 서로 다른 가변성을 가진 위치에서 사용되면 해당 매개변수는 불변적입니다. 예를 들어, 다음 구조체는 <code>'a</code>와 <code>T</code>에 대해 공변적이며, <code>'b</code>, <code>'c</code>, <code>U</code>에 대해서는 불변적입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;
struct Variance&lt;'a, 'b, 'c, T, U: 'a&gt; {
    x: &amp;'a U,               // 이것은 `Variance`를 'a에 대해 공변적으로 만들고,
// U에 대해서도 공변적으로 만들겠지만, U는 나중에 사용됩니다
    y: *const T,            // T에 대해 공변적
    z: UnsafeCell&lt;&amp;'b f64&gt;, // 'b에 대해 불변적
    w: *mut U,              // U에 대해 불변적이며, 전체 구조체를 불변적으로 만듦

    f: fn(&amp;'c ()) -&gt; &amp;'c () // 공변적이면서 동시에 반변적이므로, 구조체 내에서 'c를 불변적으로 만듭니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-subtyping.variance.builtin-composite-types"><a class="rule-link" href="subtyping.html#r-subtyping.variance.builtin-composite-types" title="subtyping.variance.builtin-composite-types"><span>[subtyping<wbr>.variance<wbr>.builtin-composite-types]<span/></a></div>
<p><code>struct</code>, <code>enum</code>, <code>union</code> 외부에서 사용될 때, 매개변수의 가변성은 각 위치에서 개별적으로 확인됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::UnsafeCell;
</span>fn generic_tuple&lt;'short, 'long: 'short&gt;(
    // 'long은 튜플 내부의 공변적 위치와 불변적 위치 모두에서 사용됩니다.
    x: (&amp;'long u32, UnsafeCell&lt;&amp;'long u32&gt;),
) {
    // 이 위치들에서의 가변성은 개별적으로 계산되므로,
    // 공변적 위치에서 'long을 자유롭게 줄일 수 있습니다.
    let _: (&amp;'short u32, UnsafeCell&lt;&amp;'long u32&gt;) = x;
}

fn takes_fn_ptr&lt;'short, 'middle: 'short&gt;(
    // 'middle은 공변적 위치와 반변적 위치 모두에서 사용됩니다.
    f: fn(&amp;'middle ()) -&gt; &amp;'middle (),
) {
    // 이 위치들에서의 가변성은 개별적으로 계산되므로,
    // 공변적 위치에서 'middle을 자유롭게 줄일 수 있고
    // 반변적 위치에서 늘릴 수 있습니다.
    let _: fn(&amp;'static ()) -&gt; &amp;'short () = f;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-bound"><a class="rule-link" href="trait-bounds.html#r-bound" title="bound"><span>[bound]<span/></a></div>
<h1 id="트레잇과-라이프타임-바운드"><a class="header" href="#트레잇과-라이프타임-바운드">트레잇과 라이프타임 바운드</a></h1>
<div class="rule" id="r-bound.syntax"><a class="rule-link" href="trait-bounds.html#r-bound.syntax" title="bound.syntax"><span>[bound<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>타입매개변수바운드</em> :<br />
   <em>타입매개변수바운드</em> ( <code>+</code> <em>타입매개변수바운드</em> )<sup>*</sup> <code>+</code><sup>?</sup></p>
<p><em>타입매개변수바운드</em> :<br />
      <em>라이프타임</em> | <em>트레잇바운드</em> | <em>사용바운드</em></p>
<p><em>트레잇바운드</em> :<br />
      ( <code>?</code> | <a href="trait-bounds.html#higher-ranked-trait-bounds"><em>For라이프타임</em></a> )<sup>?</sup> <a href="paths.html#paths-in-types"><em>타입경로</em></a><br />
   | <code>(</code> ( <code>?</code> | <a href="trait-bounds.html#higher-ranked-trait-bounds"><em>For라이프타임</em></a> )<sup>?</sup> <a href="paths.html#paths-in-types"><em>타입경로</em></a> <code>)</code></p>
<p><em>라이프타임바운드</em> :<br />
   ( <em>라이프타임</em> <code>+</code> )<sup>*</sup> <em>라이프타임</em><sup>?</sup></p>
<p><em>라이프타임</em> :<br />
      <a href="tokens.html#lifetimes-and-loop-labels">라이프타임또는레이블</a><br />
   | <code>'static</code><br />
   | <code>'_</code></p>
<p><em>사용바운드</em> :<br />
   <code>use</code> <em>사용바운드제네릭인자</em></p>
<p><em>사용바운드제네릭인자</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
   | <code>&lt;</code><br />
      ( <em>사용바운드제네릭인자요소</em> <code>,</code>)<sup>*</sup><br />
      <em>사용바운드제네릭인자요소</em> <code>,</code><sup>?</sup><br />
      <code>&gt;</code></p>
<p><em>사용바운드제네릭인자요소</em> :<br />
      <em>라이프타임</em><br />
   | <a href="identifiers.html">식별자</a><br />
   | <code>Self</code></p>
</blockquote>
<div class="rule" id="r-bound.intro"><a class="rule-link" href="trait-bounds.html#r-bound.intro" title="bound.intro"><span>[bound<wbr>.intro]<span/></a></div>
<p><a href="items/traits.html#trait-bounds">트레잇</a> 및 라이프타임 바운드는 <a href="items/generics.html">제네릭 아이템</a>이 매개변수로 사용될 수 있는 타입과 라이프타임을 제한하는 방법을 제공합니다. 바운드는 <a href="items/generics.html#where-clauses">where 절</a>의 모든 타입에 대해 제공될 수 있습니다. 특정 일반적인 경우에 대한 더 짧은 형식도 있습니다:</p>
<ul>
<li><a href="items/generics.html">제네릭 매개변수</a> 선언 뒤에 작성된 바운드: <code>fn f&lt;A: Copy&gt;() {}</code>는 <code>fn f&lt;A&gt;() where A: Copy {}</code>와 같습니다.</li>
<li>트레잇 선언에서 <a href="items/traits.html#supertraits">상위 트레잇(supertraits)</a>으로서: <code>trait Circle : Shape {}</code>는 <code>trait Circle where Self : Shape {}</code>와 동일합니다.</li>
<li>트레잇 선언에서 <a href="items/associated-items.html#associated-types">연관 타입</a>에 대한 바운드로서: <code>trait A { type B: Copy; }</code>는 <code>trait A where Self::B: Copy { type B; }</code>와 동일합니다.</li>
</ul>
<div class="rule" id="r-bound.satisfaction"><a class="rule-link" href="trait-bounds.html#r-bound.satisfaction" title="bound.satisfaction"><span>[bound<wbr>.satisfaction]<span/></a></div>
<p>아이템의 바운드는 아이템을 사용할 때 만족되어야 합니다. 제네릭 아이템을 타입 검사하고 차용 검사할 때, 바운드는 어떤 타입에 대해 트레잇이 구현되었는지를 판단하는 데 사용될 수 있습니다. 예를 들어, <code>Ty: Trait</code>가 주어졌을 때</p>
<ul>
<li>제네릭 함수의 본문에서, <code>Trait</code>의 메서드를 <code>Ty</code> 값에 대해 호출할 수 있습니다. 마찬가지로 <code>Trait</code>의 연관 상수도 사용할 수 있습니다.</li>
<li><code>Trait</code>의 연관 타입을 사용할 수 있습니다.</li>
<li><code>T: Trait</code> 바운드가 있는 제네릭 함수 및 타입은 <code>T</code> 대신 <code>Ty</code>를 사용하여 사용될 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn name() -&gt; &amp;'static str;
}

fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);           // T: Shape이므로 메서드 호출 가능
    sh.draw(surface);
}

fn copy_and_draw_twice&lt;T: Copy&gt;(surface: Surface, sh: T) where T: Shape {
    let shape_copy = sh;        // T: Copy이므로 sh를 이동시키지 않음
    draw_twice(surface, sh);    // T: Shape이므로 제네릭 함수 사용 가능
}

struct Figure&lt;S: Shape&gt;(S, S);

fn name_figure&lt;U: Shape&gt;(
    figure: Figure&lt;U&gt;,          // U: Shape이므로 타입 Figure&lt;U&gt;는 잘 형성됨(well-formed)
) {
    println!(
        "두 개의 {} 모양",
        U::name(),              // 연관 함수 사용 가능
    );
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.trivial"><a class="rule-link" href="trait-bounds.html#r-bound.trivial" title="bound.trivial"><span>[bound<wbr>.trivial]<span/></a></div>
<p>아이템의 매개변수나 <a href="trait-bounds.html#higher-ranked-trait-bounds">고차원 라이프타임</a>을 사용하지 않는 바운드는 아이템이 정의될 때 검사됩니다. 그러한 바운드가 거짓이면 오류입니다.</p>
<div class="rule" id="r-bound.special"><a class="rule-link" href="trait-bounds.html#r-bound.special" title="bound.special"><span>[bound<wbr>.special]<span/></a></div>
<p>아이템을 사용할 때, <a href="special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="special-types-and-traits.html#sized"><code>Sized</code></a> 바운드는 사용 시 구체적인 타입이 제공되지 않더라도 특정 제네릭 타입에 대해 검사됩니다. 가변 참조, <a href="types/trait-object.html">트레잇 객체</a>, 또는 <a href="types/slice.html">슬라이스</a>에 대해 <code>Copy</code>나 <code>Clone</code>을 바운드로 갖는 것은 오류입니다. 트레잇 객체나 슬라이스에 대해 <code>Sized</code>를 바운드로 갖는 것도 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a, T&gt;
where
    i32: Default,           // 허용되지만 유용하지는 않음
    i32: Iterator,          // 오류: `i32`는 반복자가 아님
    &amp;'a mut T: Copy,        // (사용 시) 오류: 트레잇 바운드가 만족되지 않음
    [T]: Sized,             // (사용 시) 오류: 컴파일 시에 크기를 알 수 없음
{
    f: &amp;'a T,
}
struct UsesA&lt;'a, T&gt;(A&lt;'a, T&gt;);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.trait-object"><a class="rule-link" href="trait-bounds.html#r-bound.trait-object" title="bound.trait-object"><span>[bound<wbr>.trait-object]<span/></a></div>
<p>트레잇 및 라이프타임 바운드는 <a href="types/trait-object.html">트레잇 객체</a>를 명명하는 데에도 사용됩니다.</p>
<div class="rule" id="r-bound.sized"><a class="rule-link" href="trait-bounds.html#r-bound.sized" title="bound.sized"><span>[bound<wbr>.sized]<span/></a></div>
<h2 id="sized"><a class="header" href="#sized"><code>?Sized</code></a></h2>
<p><code>?</code>는 <a href="types/parameters.html">타입 매개변수</a> 또는 <a href="items/associated-items.html#associated-types">연관 타입</a>에 대한 암시적인 <a href="special-types-and-traits.html#sized"><code>Sized</code></a> 트레잇 바운드를 완화하는 데에만 사용됩니다. <code>?Sized</code>는 다른 타입에 대한 바운드로 사용될 수 없습니다.</p>
<div class="rule" id="r-bound.lifetime"><a class="rule-link" href="trait-bounds.html#r-bound.lifetime" title="bound.lifetime"><span>[bound<wbr>.lifetime]<span/></a></div>
<h2 id="라이프타임-바운드"><a class="header" href="#라이프타임-바운드">라이프타임 바운드</a></h2>
<div class="rule" id="r-bound.lifetime.intro"><a class="rule-link" href="trait-bounds.html#r-bound.lifetime.intro" title="bound.lifetime.intro"><span>[bound<wbr>.lifetime<wbr>.intro]<span/></a></div>
<p>라이프타임 바운드는 타입이나 다른 라이프타임에 적용될 수 있습니다.</p>
<div class="rule" id="r-bound.lifetime.outlive-lifetime"><a class="rule-link" href="trait-bounds.html#r-bound.lifetime.outlive-lifetime" title="bound.lifetime.outlive-lifetime"><span>[bound<wbr>.lifetime<wbr>.outlive-lifetime]<span/></a></div>
<p><code>'a: 'b</code> 바운드는 보통 <code>'a</code>가 <code>'b</code>보다 _오래 산다(outlives)_라고 읽습니다. <code>'a: 'b</code>는 <code>'a</code>가 적어도 <code>'b</code>만큼 오래 지속됨을 의미하므로, <code>&amp;'b ()</code>가 유효할 때마다 <code>&amp;'a ()</code> 참조도 유효합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) where 'a: 'b {
    y = x;                      // 'a: 'b이므로 &amp;'a i32는 &amp;'b i32의 서브타입입니다
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   // 'a: 'b이므로 &amp;'b &amp;'a i32는 잘 형성되었습니다
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.lifetime.outlive-type"><a class="rule-link" href="trait-bounds.html#r-bound.lifetime.outlive-type" title="bound.lifetime.outlive-type"><span>[bound<wbr>.lifetime<wbr>.outlive-type]<span/></a></div>
<p><code>T: 'a</code>는 <code>T</code>의 모든 라이프타임 매개변수가 <code>'a</code>보다 오래 산다는 것을 의미합니다. 예를 들어, <code>'a</code>가 제약 없는 라이프타임 매개변수라면 <code>i32: 'static</code>과 <code>&amp;'static str: 'a</code>는 만족되지만, <code>Vec&lt;&amp;'a ()&gt;: 'static</code>은 만족되지 않습니다.</p>
<div class="rule" id="r-bound.higher-ranked"><a class="rule-link" href="trait-bounds.html#r-bound.higher-ranked" title="bound.higher-ranked"><span>[bound<wbr>.higher-ranked]<span/></a></div>
<h2 id="고차원-트레잇-바운드"><a class="header" href="#고차원-트레잇-바운드">고차원 트레잇 바운드</a></h2>
<div class="rule" id="r-bound.higher-ranked.syntax"><a class="rule-link" href="trait-bounds.html#r-bound.higher-ranked.syntax" title="bound.higher-ranked.syntax"><span>[bound<wbr>.higher-ranked<wbr>.syntax]<span/></a></div>
<blockquote>
<p><em>ForLifetimes</em> :<br />
   <code>for</code> <a href="items/generics.html"><em>GenericParams</em></a></p>
</blockquote>
<div class="rule" id="r-bound.higher-ranked.intro"><a class="rule-link" href="trait-bounds.html#r-bound.higher-ranked.intro" title="bound.higher-ranked.intro"><span>[bound<wbr>.higher-ranked<wbr>.intro]<span/></a></div>
<p>트레잇 바운드는 라이프타임에 대해 _고차원(higher ranked)_일 수 있습니다. 이 바운드들은 <em>모든</em> 라이프타임에 대해 참인 바운드를 지정합니다. 예를 들어, <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code>와 같은 바운드는 다음과 같은 구현을 요구합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct T;
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
<span class="boring">   fn eq(&amp;self, other: &amp;i32) -&gt; bool {true}
</span>}
<span class="boring">}</span></code></pre></pre>
<p>그러면 어떤 라이프타임을 가진 <code>&amp;'a T</code>라도 <code>i32</code>와 비교하는 데 사용될 수 있습니다.</p>
<p>여기서는 고차원 바운드만 사용될 수 있는데, 이는 참조의 라이프타임이 함수의 모든 가능한 라이프타임 매개변수보다 짧기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;'a&gt; F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.higher-ranked.trait"><a class="rule-link" href="trait-bounds.html#r-bound.higher-ranked.trait" title="bound.higher-ranked.trait"><span>[bound<wbr>.higher-ranked<wbr>.trait]<span/></a></div>
<p>고차원 라이프타임은 트레잇 바로 앞에서 지정될 수도 있습니다. 유일한 차이점은 라이프타임 매개변수의 <a href="names/scopes.html#higher-ranked-trait-bound-scopes">스코프(scope)</a>이며, 이는 전체 바운드가 아닌 뒤따르는 트레잇의 끝까지만 확장됩니다. 이 함수는 이전 함수와 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;'a&gt; Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.implied"><a class="rule-link" href="trait-bounds.html#r-bound.implied" title="bound.implied"><span>[bound<wbr>.implied]<span/></a></div>
<h2 id="함축된-바운드"><a class="header" href="#함축된-바운드">함축된 바운드</a></h2>
<div class="rule" id="r-bound.implied.intro"><a class="rule-link" href="trait-bounds.html#r-bound.implied.intro" title="bound.implied.intro"><span>[bound<wbr>.implied<wbr>.intro]<span/></a></div>
<p>타입이 잘 형성되기 위해 필요한 라이프타임 바운드는 때때로 추론됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn requires_t_outlives_a&lt;'a, T&gt;(x: &amp;'a T) {}
<span class="boring">}</span></code></pre></pre>
<p>타입 <code>&amp;'a T</code>가 잘 형성되기 위해서는 타입 매개변수 <code>T</code>가 <code>'a</code>보다 오래 살아야 합니다. 이는 함수 시그니처에 <code>T: 'a</code>가 성립해야만 유효한 <code>&amp;'a T</code> 타입이 포함되어 있기 때문에 추론됩니다.</p>
<div class="rule" id="r-bound.implied.context"><a class="rule-link" href="trait-bounds.html#r-bound.implied.context" title="bound.implied.context"><span>[bound<wbr>.implied<wbr>.context]<span/></a></div>
<p>함수의 모든 매개변수와 출력에 대해 함축된 바운드가 추가됩니다. <code>requires_t_outlives_a</code> 내부에서는 명시적으로 지정하지 않더라도 <code>T: 'a</code>가 성립한다고 가정할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn requires_t_outlives_a_not_implied&lt;'a, T: 'a&gt;() {}

fn requires_t_outlives_a&lt;'a, T&gt;(x: &amp;'a T) {
    // 이 코드는 컴파일됩니다. 참조 타입 `&amp;'a T`에 의해
    // `T: 'a`가 함축되기 때문입니다.
    requires_t_outlives_a_not_implied::&lt;'a, T&gt;();
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0309 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn requires_t_outlives_a_not_implied&lt;'a, T: 'a&gt;() {}
</span>fn not_implied&lt;'a, T&gt;() {
    // 이 코드는 오류가 발생합니다. 함수 시그니처에 의해
    // `T: 'a`가 함축되지 않기 때문입니다.
    requires_t_outlives_a_not_implied::&lt;'a, T&gt;();
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.implied.trait"><a class="rule-link" href="trait-bounds.html#r-bound.implied.trait" title="bound.implied.trait"><span>[bound<wbr>.implied<wbr>.trait]<span/></a></div>
<p>라이프타임 바운드만 함축될 뿐이며, 트레잇 바운드는 여전히 명시적으로 추가해야 합니다. 따라서 다음 예제는 오류를 발생시킵니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
struct IsDebug&lt;T: Debug&gt;(T);
// error[E0277]: `T`가 `Debug`를 구현하지 않음
fn doesnt_specify_t_debug&lt;T&gt;(x: IsDebug&lt;T&gt;) {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.implied.def"><a class="rule-link" href="trait-bounds.html#r-bound.implied.def" title="bound.implied.def"><span>[bound<wbr>.implied<wbr>.def]<span/></a></div>
<p>라이프타임 바운드는 타입 정의 및 모든 타입에 대한 impl 블록에서도 추론됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct&lt;'a, T&gt; {
    // 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,
    // 이는 컴파일러에 의해 추론됩니다.
    field: &amp;'a T,
}

enum Enum&lt;'a, T&gt; {
    // 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,
    // 이는 컴파일러에 의해 추론됩니다.
    //
    // `Enum::OtherVariant`만 사용하는 경우에도
    // `T: 'a`가 필요함에 유의하세요.
    SomeVariant(&amp;'a T),
    OtherVariant,
}

trait Trait&lt;'a, T: 'a&gt; {}

// 이 코드는 오류가 발생합니다. impl 헤더의 어떤 타입에 의해서도
// `T: 'a`가 함축되지 않기 때문입니다.
//     impl&lt;'a, T&gt; Trait&lt;'a, T&gt; for () {}

// 이 코드는 컴파일됩니다. 셀프 타입 `&amp;'a T`에 의해 `T: 'a`가 함축되기 때문입니다.
impl&lt;'a, T&gt; Trait&lt;'a, T&gt; for &amp;'a T {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-bound.use"><a class="rule-link" href="trait-bounds.html#r-bound.use" title="bound.use"><span>[bound<wbr>.use]<span/></a></div>
<h2 id="사용-바운드"><a class="header" href="#사용-바운드">사용 바운드</a></h2>
<p>일부 바운드 목록에는 <code>impl Trait</code> <a href="types/impl-trait.html#abstract-return-types">추상 반환 타입(abstract return type)</a>에 의해 캡처되는 제네릭 매개변수를 제어하기 위해 <code>use&lt;..&gt;</code> 바운드가 포함될 수 있습니다. 자세한 내용은 <a href="types/impl-trait.html#precise-capturing">정밀한 캡처(precise capturing)</a>를 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-coerce"><a class="rule-link" href="type-coercions.html#r-coerce" title="coerce"><span>[coerce]<span/></a></div>
<h1 id="타입-강제-변환"><a class="header" href="#타입-강제-변환">타입 강제 변환</a></h1>
<div class="rule" id="r-coerce.intro"><a class="rule-link" href="type-coercions.html#r-coerce.intro" title="coerce.intro"><span>[coerce<wbr>.intro]<span/></a></div>
<p>**타입 강제 변환(Type coercions)**은 값의 타입을 변경하는 암시적 연산입니다. 프로그램의 특정 위치에서 자동으로 발생하며, 실제로 강제 변환이 가능한 타입은 엄격히 제한됩니다.</p>
<div class="rule" id="r-coerce.as"><a class="rule-link" href="type-coercions.html#r-coerce.as" title="coerce.as"><span>[coerce<wbr>.as]<span/></a></div>
<p>강제 변환에 의해 허용되는 모든 변환은 <a href="expressions/operator-expr.html#type-cast-expressions">타입 캐스트 연산자(type cast operator)</a>인 <code>as</code>를 통해 명시적으로 수행될 수도 있습니다.</p>
<p>강제 변환은 원래 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>에서 정의되었으며, <a href="https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md">RFC 1558</a>에서 확장되었습니다.</p>
<div class="rule" id="r-coerce.site"><a class="rule-link" href="type-coercions.html#r-coerce.site" title="coerce.site"><span>[coerce<wbr>.site]<span/></a></div>
<h2 id="강제-변환-지점"><a class="header" href="#강제-변환-지점">강제 변환 지점</a></h2>
<div class="rule" id="r-coerce.site.intro"><a class="rule-link" href="type-coercions.html#r-coerce.site.intro" title="coerce.site.intro"><span>[coerce<wbr>.site<wbr>.intro]<span/></a></div>
<p>강제 변환은 프로그램의 특정 강제 변환 지점에서만 발생할 수 있습니다. 이러한 지점은 일반적으로 원하는 타입이 명시되어 있거나, 명시적인 타입으로부터 (타입 추론 없이) 전파되어 유도될 수 있는 곳입니다. 가능한 강제 변환 지점은 다음과 같습니다.</p>
<div class="rule" id="r-coerce.site.let"><a class="rule-link" href="type-coercions.html#r-coerce.site.let" title="coerce.site.let"><span>[coerce<wbr>.site<wbr>.let]<span/></a></div>
<ul>
<li>
<p>명시적인 타입이 주어진 <code>let</code> 구문.</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: &amp;i8 = &amp;mut 42;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-coerce.site.value"><a class="rule-link" href="type-coercions.html#r-coerce.site.value" title="coerce.site.value"><span>[coerce<wbr>.site<wbr>.value]<span/></a></div>
<ul>
<li><code>static</code> 및 <code>const</code> 아이템 선언 (<code>let</code> 구문과 유사함).</li>
</ul>
<div class="rule" id="r-coerce.site.argument"><a class="rule-link" href="type-coercions.html#r-coerce.site.argument" title="coerce.site.argument"><span>[coerce<wbr>.site<wbr>.argument]<span/></a></div>
<ul>
<li>
<p>함수 호출 인자</p>
<p>강제 변환되는 값은 실제 매개변수(actual parameter)이며, 이는 형식 매개변수(formal parameter)의 타입으로 강제 변환됩니다.</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn bar(_: &amp;i8) { }

fn main() {
    bar(&amp;mut 42);
}</code></pre></pre>
<p>메서드 호출의 경우, 리시버(<code>self</code> 매개변수) 타입은 다르게 강제 변환됩니다. 자세한 내용은 <a href="expressions/method-call-expr.html">메서드 호출 표현식(method-call expressions)</a> 문서를 참조하세요.</p>
</li>
</ul>
<div class="rule" id="r-coerce.site.constructor"><a class="rule-link" href="type-coercions.html#r-coerce.site.constructor" title="coerce.site.constructor"><span>[coerce<wbr>.site<wbr>.constructor]<span/></a></div>
<ul>
<li>
<p>구조체, 공용체, 또는 열거형 변형 필드의 인스턴스화</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Foo&lt;'a&gt; { x: &amp;'a i8 }

fn main() {
    Foo { x: &amp;mut 42 };
}</code></pre></pre>
</li>
</ul>
<div class="rule" id="r-coerce.site.return"><a class="rule-link" href="type-coercions.html#r-coerce.site.return" title="coerce.site.return"><span>[coerce<wbr>.site<wbr>.return]<span/></a></div>
<ul>
<li>
<p>함수 결과 — 세미콜론으로 끝나지 않은 블록의 마지막 줄 또는 <code>return</code> 구문의 모든 표현식</p>
<p>예를 들어, 다음 코드에서 <code>x</code>는 <code>&amp;dyn Display</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;
fn foo(x: &amp;u32) -&gt; &amp;dyn Display {
    x
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-coerce.site.subexpr"><a class="rule-link" href="type-coercions.html#r-coerce.site.subexpr" title="coerce.site.subexpr"><span>[coerce<wbr>.site<wbr>.subexpr]<span/></a></div>
<p>만약 이러한 강제 변환 지점 중 하나에 있는 표현식이 강제 변환 전파 표현식인 경우, 해당 표현식의 관련 하위 표현식들 또한 강제 변환 지점이 됩니다. 전파는 이러한 새로운 강제 변환 지점들로부터 재귀적으로 발생합니다. 전파 표현식과 그와 관련된 하위 표현식들은 다음과 같습니다.</p>
<div class="rule" id="r-coerce.site.array"><a class="rule-link" href="type-coercions.html#r-coerce.site.array" title="coerce.site.array"><span>[coerce<wbr>.site<wbr>.array]<span/></a></div>
<ul>
<li>배열 리터럴 (배열의 타입이 <code>[U; n]</code>인 경우). 배열 리터럴의 각 하위 표현식은 <code>U</code> 타입으로의 강제 변환을 위한 강제 변환 지점입니다.</li>
</ul>
<div class="rule" id="r-coerce.site.repeat"><a class="rule-link" href="type-coercions.html#r-coerce.site.repeat" title="coerce.site.repeat"><span>[coerce<wbr>.site<wbr>.repeat]<span/></a></div>
<ul>
<li>반복 구문을 사용하는 배열 리터럴 (배열의 타입이 <code>[U; n]</code>인 경우). 반복되는 하위 표현식은 <code>U</code> 타입으로의 강제 변환을 위한 강제 변환 지점입니다.</li>
</ul>
<div class="rule" id="r-coerce.site.tuple"><a class="rule-link" href="type-coercions.html#r-coerce.site.tuple" title="coerce.site.tuple"><span>[coerce<wbr>.site<wbr>.tuple]<span/></a></div>
<ul>
<li>튜플 (튜플이 <code>(U_0, U_1, ..., U_n)</code> 타입으로의 강제 변환 지점인 경우). 각 하위 표현식은 해당 타입으로의 강제 변환 지점입니다. 예를 들어, 0번째 하위 표현식은 <code>U_0</code> 타입으로의 강제 변환 지점입니다.</li>
</ul>
<div class="rule" id="r-coerce.site.parenthesis"><a class="rule-link" href="type-coercions.html#r-coerce.site.parenthesis" title="coerce.site.parenthesis"><span>[coerce<wbr>.site<wbr>.parenthesis]<span/></a></div>
<ul>
<li>괄호로 묶인 하위 표현식 (<code>(e)</code>): 표현식의 타입이 <code>U</code>인 경우, 하위 표현식은 <code>U</code>로의 강제 변환 지점입니다.</li>
</ul>
<div class="rule" id="r-coerce.site.block"><a class="rule-link" href="type-coercions.html#r-coerce.site.block" title="coerce.site.block"><span>[coerce<wbr>.site<wbr>.block]<span/></a></div>
<ul>
<li>블록: 블록의 타입이 <code>U</code>인 경우, 블록의 마지막 표현식(세미콜론으로 끝나지 않은 경우)은 <code>U</code>로의 강제 변환 지점입니다. 여기에는 블록이 알려진 타입을 가진 경우 <code>if</code>/<code>else</code>와 같은 제어 흐름 구문의 일부인 블록도 포함됩니다.</li>
</ul>
<div class="rule" id="r-coerce.types"><a class="rule-link" href="type-coercions.html#r-coerce.types" title="coerce.types"><span>[coerce<wbr>.types]<span/></a></div>
<h2 id="강제-변환-타입"><a class="header" href="#강제-변환-타입">강제 변환 타입</a></h2>
<div class="rule" id="r-coerce.types.intro"><a class="rule-link" href="type-coercions.html#r-coerce.types.intro" title="coerce.types.intro"><span>[coerce<wbr>.types<wbr>.intro]<span/></a></div>
<p>강제 변환은 다음 타입들 사이에서 허용됩니다.</p>
<div class="rule" id="r-coerce.types.reflexive"><a class="rule-link" href="type-coercions.html#r-coerce.types.reflexive" title="coerce.types.reflexive"><span>[coerce<wbr>.types<wbr>.reflexive]<span/></a></div>
<ul>
<li><code>T</code>가 <code>U</code>의 <a href="subtyping.html">서브타입(subtype)</a>인 경우 <code>T</code>에서 <code>U</code>로 (<em>반사적 사례</em>)</li>
</ul>
<div class="rule" id="r-coerce.types.transitive"><a class="rule-link" href="type-coercions.html#r-coerce.types.transitive" title="coerce.types.transitive"><span>[coerce<wbr>.types<wbr>.transitive]<span/></a></div>
<ul>
<li>
<p><code>T_1</code>이 <code>T_2</code>로 강제 변환되고 <code>T_2</code>가 <code>T_3</code>으로 강제 변환되는 경우 <code>T_1</code>에서 <code>T_3</code>으로 (<em>이행적 사례</em>)</p>
<p>이는 아직 완전히 지원되지 않음에 유의하세요.</p>
</li>
</ul>
<div class="rule" id="r-coerce.types.mut-reborrow"><a class="rule-link" href="type-coercions.html#r-coerce.types.mut-reborrow" title="coerce.types.mut-reborrow"><span>[coerce<wbr>.types<wbr>.mut-reborrow]<span/></a></div>
<ul>
<li><code>&amp;mut T</code>에서 <code>&amp;T</code>로</li>
</ul>
<div class="rule" id="r-coerce.types.mut-pointer"><a class="rule-link" href="type-coercions.html#r-coerce.types.mut-pointer" title="coerce.types.mut-pointer"><span>[coerce<wbr>.types<wbr>.mut-pointer]<span/></a></div>
<ul>
<li><code>*mut T</code>에서 <code>*const T</code>로</li>
</ul>
<div class="rule" id="r-coerce.types.ref-to-pointer"><a class="rule-link" href="type-coercions.html#r-coerce.types.ref-to-pointer" title="coerce.types.ref-to-pointer"><span>[coerce<wbr>.types<wbr>.ref-to-pointer]<span/></a></div>
<ul>
<li><code>&amp;T</code>에서 <code>*const T</code>로</li>
</ul>
<div class="rule" id="r-coerce.types.mut-to-pointer"><a class="rule-link" href="type-coercions.html#r-coerce.types.mut-to-pointer" title="coerce.types.mut-to-pointer"><span>[coerce<wbr>.types<wbr>.mut-to-pointer]<span/></a></div>
<ul>
<li><code>&amp;mut T</code>에서 <code>*mut T</code>로</li>
</ul>
<div class="rule" id="r-coerce.types.deref"><a class="rule-link" href="type-coercions.html#r-coerce.types.deref" title="coerce.types.deref"><span>[coerce<wbr>.types<wbr>.deref]<span/></a></div>
<ul>
<li>
<p><code>T</code>가 <code>Deref&lt;Target = U&gt;</code>를 구현하는 경우 <code>&amp;T</code> 또는 <code>&amp;mut T</code>에서 <code>&amp;U</code>로. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

struct CharContainer {
    value: char,
}

impl Deref for CharContainer {
    type Target = char;

    fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a char {
        &amp;self.value
    }
}

fn foo(arg: &amp;char) {}

fn main() {
    let x = &amp;mut CharContainer { value: 'y' };
    foo(x); //&amp;mut CharContainer가 &amp;char로 강제 변환됩니다.
}</code></pre></pre>
</li>
</ul>
<div class="rule" id="r-coerce.types.deref-mut"><a class="rule-link" href="type-coercions.html#r-coerce.types.deref-mut" title="coerce.types.deref-mut"><span>[coerce<wbr>.types<wbr>.deref-mut]<span/></a></div>
<ul>
<li><code>T</code>가 <code>DerefMut&lt;Target = U&gt;</code>를 구현하는 경우 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로.</li>
</ul>
<div class="rule" id="r-coerce.types.unsize"><a class="rule-link" href="type-coercions.html#r-coerce.types.unsize" title="coerce.types.unsize"><span>[coerce<wbr>.types<wbr>.unsize]<span/></a></div>
<ul>
<li>
<p>TyCtor(<code>T</code>)에서 TyCtor(<code>U</code>)로. 여기서 TyCtor(<code>T</code>)는 다음 중 하나입니다.</p>
<ul>
<li>
<p><code>&amp;T</code></p>
</li>
<li>
<p><code>&amp;mut T</code></p>
</li>
<li>
<p><code>*const T</code></p>
</li>
<li>
<p><code>*mut T</code></p>
</li>
<li>
<p><code>Box&lt;T&gt;</code>
여기서 <code>U</code>는 <a href="type-coercions.html#unsized-coercions">크기 미지정 강제 변환(unsized coercion)</a>을 통해 <code>T</code>로부터 얻을 수 있는 타입입니다.</p>
<!--In the future, coerce_inner will be recursively extended to tuples and
structs. In addition, coercions from subtraits to supertraits will be
added. See [RFC 401] for more details.-->
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-coerce.types.fn"><a class="rule-link" href="type-coercions.html#r-coerce.types.fn" title="coerce.types.fn"><span>[coerce<wbr>.types<wbr>.fn]<span/></a></div>
<ul>
<li>함수 아이템 타입에서 <code>fn</code> 포인터로</li>
</ul>
<div class="rule" id="r-coerce.types.closure"><a class="rule-link" href="type-coercions.html#r-coerce.types.closure" title="coerce.types.closure"><span>[coerce<wbr>.types<wbr>.closure]<span/></a></div>
<ul>
<li>캡처하지 않는 클로저에서 <code>fn</code> 포인터로</li>
</ul>
<div class="rule" id="r-coerce.types.never"><a class="rule-link" href="type-coercions.html#r-coerce.types.never" title="coerce.types.never"><span>[coerce<wbr>.types<wbr>.never]<span/></a></div>
<ul>
<li><code>!</code>에서 임의의 <code>T</code>로</li>
</ul>
<div class="rule" id="r-coerce.unsize"><a class="rule-link" href="type-coercions.html#r-coerce.unsize" title="coerce.unsize"><span>[coerce<wbr>.unsize]<span/></a></div>
<h3 id="크기-미지정-강제-변환"><a class="header" href="#크기-미지정-강제-변환">크기 미지정 강제 변환</a></h3>
<div class="rule" id="r-coerce.unsize.intro"><a class="rule-link" href="type-coercions.html#r-coerce.unsize.intro" title="coerce.unsize.intro"><span>[coerce<wbr>.unsize<wbr>.intro]<span/></a></div>
<p>다음 강제 변환들은 타입을 크기 미지정 타입으로 변환하는 것과 관련이 있기 때문에 <code>크기 미지정 강제 변환(unsized coercions)</code>이라고 불립니다. 위에서 설명한 것처럼 다른 강제 변환이 허용되지 않는 몇 가지 경우에도 허용되지만, 여전히 다른 강제 변환이 발생할 수 있는 모든 곳에서도 발생할 수 있습니다.</p>
<div class="rule" id="r-coerce.unsize.trait"><a class="rule-link" href="type-coercions.html#r-coerce.unsize.trait" title="coerce.unsize.trait"><span>[coerce<wbr>.unsize<wbr>.trait]<span/></a></div>
<p>이 과정을 돕고 라이브러리에서 사용할 수 있도록 노출하기 위해 <a href="../core/marker/trait.Unsize.html"><code>Unsize</code></a>와 <a href="../core/ops/unsize/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a>라는 두 트레잇이 사용됩니다. 다음 강제 변환들은 내장된 기능이며, 만약 <code>T</code>가 이들 중 하나를 통해 <code>U</code>로 강제 변환될 수 있다면, <code>T</code>에 대한 <code>Unsize&lt;U&gt;</code> 구현이 제공됩니다.</p>
<div class="rule" id="r-coerce.unsize.slice"><a class="rule-link" href="type-coercions.html#r-coerce.unsize.slice" title="coerce.unsize.slice"><span>[coerce<wbr>.unsize<wbr>.slice]<span/></a></div>
<ul>
<li><code>[T; n]</code>에서 <code>[T]</code>로.</li>
</ul>
<div class="rule" id="r-coerce.unsize.trait-object"><a class="rule-link" href="type-coercions.html#r-coerce.unsize.trait-object" title="coerce.unsize.trait-object"><span>[coerce<wbr>.unsize<wbr>.trait-object]<span/></a></div>
<ul>
<li><code>T</code>가 <code>U + Sized</code>를 구현하고 <code>U</code>가 <a href="items/traits.html#dyn-compatibility">dyn 호환(dyn compatible)</a>인 경우, <code>T</code>에서 <code>dyn U</code>로.</li>
</ul>
<div class="rule" id="r-coerce.unsize.trait-upcast"><a class="rule-link" href="type-coercions.html#r-coerce.unsize.trait-upcast" title="coerce.unsize.trait-upcast"><span>[coerce<wbr>.unsize<wbr>.trait-upcast]<span/></a></div>
<ul>
<li><code>U</code>가 <code>T</code>의 <a href="items/traits.html#supertraits">상위 트레잇(supertraits)</a> 중 하나인 경우, <code>dyn T</code>에서 <code>dyn U</code>로.
<ul>
<li>이는 자동 트레잇을 제거하는 것을 허용합니다. 즉, <code>dyn T + Auto</code>에서 <code>dyn U</code>로의 강제 변환이 허용됩니다.</li>
<li>주요 트레잇(principal trait)이 자동 트레잇을 상위 트레잇으로 가지고 있는 경우 자동 트레잇을 추가하는 것을 허용합니다. 즉, <code>trait T: U + Send {}</code>가 주어지면, <code>dyn T</code>에서 <code>dyn T + Send</code> 또는 <code>dyn U + Send</code>로의 강제 변환이 허용됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-coerce.unsized.composite"><a class="rule-link" href="type-coercions.html#r-coerce.unsized.composite" title="coerce.unsized.composite"><span>[coerce<wbr>.unsized<wbr>.composite]<span/></a></div>
<ul>
<li>다음의 경우, <code>Foo&lt;..., T, ...&gt;</code>에서 <code>Foo&lt;..., U, ...&gt;</code>로.
<ul>
<li><code>Foo</code>는 구조체입니다.</li>
<li><code>T</code>가 <code>Unsize&lt;U&gt;</code>를 구현합니다.</li>
<li><code>Foo</code>의 마지막 필드가 <code>T</code>를 포함하는 타입을 가집니다.</li>
<li>해당 필드의 타입이 <code>Bar&lt;T&gt;</code>라면, <code>Bar&lt;T&gt;</code>는 <code>Unsize&lt;Bar&lt;U&gt;&gt;</code>를 구현합니다.</li>
<li><code>T</code>가 다른 필드의 타입에는 포함되지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-coerce.unsized.pointer"><a class="rule-link" href="type-coercions.html#r-coerce.unsized.pointer" title="coerce.unsized.pointer"><span>[coerce<wbr>.unsized<wbr>.pointer]<span/></a></div>
<p>추가적으로, <code>T</code>가 <code>Unsize&lt;U&gt;</code> 또는 <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>를 구현하는 경우 타입 <code>Foo&lt;T&gt;</code>는 <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>를 구현할 수 있습니다. 이를 통해 <code>Foo&lt;U&gt;</code>로의 크기 미지정 강제 변환을 제공할 수 있습니다.</p>
<blockquote>
<p>참고: 크기 미지정 강제 변환의 정의와 그 구현은 안정화되었지만, 트레잇 자체는 아직 안정화되지 않았으므로 안정 버전의 Rust에서 직접 사용할 수는 없습니다.</p>
</blockquote>
<div class="rule" id="r-coerce.least-upper-bound"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound" title="coerce.least-upper-bound"><span>[coerce<wbr>.least-upper-bound]<span/></a></div>
<h2 id="최소-상한-강제-변환"><a class="header" href="#최소-상한-강제-변환">최소 상한 강제 변환</a></h2>
<div class="rule" id="r-coerce.least-upper-bound.intro"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.intro" title="coerce.least-upper-bound.intro"><span>[coerce<wbr>.least-upper-bound<wbr>.intro]<span/></a></div>
<p>일부 문맥에서 컴파일러는 가장 일반적인 타입을 찾기 위해 여러 타입을 함께 강제 변환해야 합니다. 이를 “최소 상한(Least Upper Bound)” 강제 변환이라고 합니다. LUB 강제 변환은 오직 다음과 같은 상황에서만 사용됩니다.</p>
<ul>
<li>일련의 if 분기들에 대한 공통 타입을 찾을 때.</li>
<li>일련의 매치 암(match arms)들에 대한 공통 타입을 찾을 때.</li>
<li>배열 요소들에 대한 공통 타입을 찾을 때.</li>
<li>여러 개의 return 문이 있는 클로저의 반환 타입을 찾을 때.</li>
<li>여러 개의 return 문이 있는 함수의 반환 타입을 검사할 때.</li>
</ul>
<div class="rule" id="r-coerce.least-upper-bound.target"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.target" title="coerce.least-upper-bound.target"><span>[coerce<wbr>.least-upper-bound<wbr>.target]<span/></a></div>
<p>이러한 각 사례에서, 시작 시점에는 알 수 없는 어떤 대상 타입 <code>T_t</code>로 서로 강제 변환되어야 하는 일련의 타입 <code>T0..Tn</code>이 존재합니다.</p>
<div class="rule" id="r-coerce.least-upper-bound.computation"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.computation" title="coerce.least-upper-bound.computation"><span>[coerce<wbr>.least-upper-bound<wbr>.computation]<span/></a></div>
<p>LUB 강제 변환 계산은 반복적으로 수행됩니다. 대상 타입 <code>T_t</code>는 타입 <code>T0</code>에서 시작합니다. 각각의 새로운 타입 <code>Ti</code>에 대해 다음을 고려합니다.</p>
<div class="rule" id="r-coerce.least-upper-bound.computation-identity"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.computation-identity" title="coerce.least-upper-bound.computation-identity"><span>[coerce<wbr>.least-upper-bound<wbr>.computation-identity]<span/></a></div>
<ul>
<li><code>Ti</code>가 현재 대상 타입 <code>T_t</code>로 강제 변환될 수 있다면, 아무런 변경도 하지 않습니다.</li>
</ul>
<div class="rule" id="r-coerce.least-upper-bound.computation-replace"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.computation-replace" title="coerce.least-upper-bound.computation-replace"><span>[coerce<wbr>.least-upper-bound<wbr>.computation-replace]<span/></a></div>
<ul>
<li>그렇지 않은 경우, <code>T_t</code>가 <code>Ti</code>로 강제 변환될 수 있는지 확인합니다. 만약 가능하다면, <code>T_t</code>는 <code>Ti</code>로 변경됩니다. (이 확인 과정은 지금까지 고려된 모든 소스 표현식들에 암시적 강제 변환이 있는지 여부도 조건으로 합니다.)</li>
</ul>
<div class="rule" id="r-coerce.least-upper-bound.computation-unify"><a class="rule-link" href="type-coercions.html#r-coerce.least-upper-bound.computation-unify" title="coerce.least-upper-bound.computation-unify"><span>[coerce<wbr>.least-upper-bound<wbr>.computation-unify]<span/></a></div>
<ul>
<li>그렇지 않다면, <code>T_t</code>와 <code>Ti</code> 사이의 상호 상위 타입(mutual supertype) 계산을 시도하며, 이것이 새로운 대상 타입이 됩니다.</li>
</ul>
<h3 id="예"><a class="header" href="#예">예:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let (a, b, c) = (0, 1, 2);
</span>// if 분기들의 경우
let bar = if true {
    a
} else if false {
    b
} else {
    c
};

// 매치 암들의 경우
let baw = match 42 {
    0 =&gt; a,
    1 =&gt; b,
    _ =&gt; c,
};

// 배열 요소들의 경우
let bax = [a, b, c];

// 여러 개의 return 문이 있는 클로저의 경우
let clo = || {
    if true {
        a
    } else if false {
        b
    } else {
        c
    }
};
let baz = clo();

// 여러 개의 return 문이 있는 함수의 타입 검사의 경우
fn foo() -&gt; i32 {
    let (a, b, c) = (0, 1, 2);
    match 42 {
        0 =&gt; a,
        1 =&gt; b,
        _ =&gt; c,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예제들에서 <code>ba*</code> 변수들의 타입은 LUB 강제 변환을 통해 찾아집니다. 그리고 컴파일러는 함수 <code>foo</code>를 처리하는 과정에서 <code>a</code>, <code>b</code>, <code>c</code>의 LUB 강제 변환 결과가 <code>i32</code>인지 확인합니다.</p>
<h3 id="주의-사항"><a class="header" href="#주의-사항">주의 사항</a></h3>
<p>이 설명은 분명히 비공식적인 것입니다. 이를 더 정밀하게 만드는 작업은 러스트 타입 검사기를 더 정밀하게 명세하려는 전반적인 노력의 일환으로 진행될 예정입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소멸자"><a class="header" href="#소멸자">소멸자</a></h1>
<div class="rule" id="r-destructors.intro"><a class="rule-link" href="destructors.html#r-destructors.intro" title="destructors.intro"><span>[destructors<wbr>.intro]<span/></a></div>
<p><a href="glossary.html#initialized">초기화된(initialized)</a> <a href="variables.html">변수</a> 또는 <a href="expressions.html#temporaries">임시 값(temporary)</a>이 <a href="destructors.html#drop-scopes">스코프(scope)</a>를 벗어나면, 해당 값의 _소멸자(destructor)_가 실행되거나 해당 값이 _드롭(dropped)_됩니다. <a href="expressions/operator-expr.html#assignment-expressions">할당(Assignment)</a> 또한 좌항 피연산자가 초기화된 상태라면 그 소멸자를 실행합니다. 변수가 부분적으로만 초기화된 경우, 초기화된 필드만 드롭됩니다.</p>
<div class="rule" id="r-destructors.operation"><a class="rule-link" href="destructors.html#r-destructors.operation" title="destructors.operation"><span>[destructors<wbr>.operation]<span/></a></div>
<p>타입 <code>T</code>의 소멸자는 다음과 같이 구성됩니다.</p>
<ol>
<li><code>T: Drop</code>인 경우, <a href="../core/ops/drop/trait.Drop.html#tymethod.drop"><code>&lt;T as std::ops::Drop&gt;::drop</code></a> 호출</li>
<li>모든 필드에 대해 재귀적으로 소멸자 실행.
<ul>
<li><a href="types/struct.html">구조체(struct)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li>활성 <a href="types/enum.html">열거형 변형(enum variant)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li><a href="types/tuple.html">튜플(tuple)</a>의 필드들은 순서대로 드롭됩니다.</li>
<li><a href="types/array.html">배열(array)</a> 또는 소유권이 있는 <a href="types/slice.html">슬라이스(slice)</a>의 요소들은 첫 번째 요소부터 마지막 요소 순으로 드롭됩니다.</li>
<li><a href="types/closure.html">클로저(closure)</a>가 이동(move)으로 캡처한 변수들은 지정되지 않은 순서대로 드롭됩니다.</li>
<li><a href="types/trait-object.html">트레잇 객체(Trait objects)</a>는 기저 타입(underlying type)의 소멸자를 실행합니다.</li>
<li>다른 타입들은 추가적인 드롭을 발생시키지 않습니다.</li>
</ul>
</li>
</ol>
<div class="rule" id="r-destructors.drop_in_place"><a class="rule-link" href="destructors.html#r-destructors.drop_in_place" title="destructors.drop_in_place"><span>[destructors<wbr>.drop_in_place]<span/></a></div>
<p>자신만의 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야 하는 경우, <a href="../core/ptr/fn.drop_in_place.html"><code>std::ptr::drop_in_place</code></a>를 사용할 수 있습니다.</p>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!("{}", self.0);
    }
}

let mut overwritten = PrintOnDrop("덮어써질 때 드롭됨");
overwritten = PrintOnDrop("스코프가 끝날 때 드롭됨");

let tuple = (PrintOnDrop("튜플 첫 번째"), PrintOnDrop("튜플 두 번째"));

let moved;
// 할당 시 소멸자가 실행되지 않음.
moved = PrintOnDrop("이동될 때 드롭됨");
// 지금 드롭되지만, 그 후에는 초기화되지 않은 상태가 됩니다.
moved;

// 초기화되지 않은 상태에서는 드롭되지 않습니다.
let uninitialized: PrintOnDrop;

// 부분 이동 후에는 남아 있는 필드만 드롭됩니다.
let mut partial_move = (PrintOnDrop("first"), PrintOnDrop("잊힘(forgotten)"));
// 부분 이동을 수행하여 `partial_move.0`만 초기화된 상태로 남깁니다.
core::mem::forget(partial_move.1);
// partial_move의 스코프가 끝나면 첫 번째 필드만 드롭됩니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope"><a class="rule-link" href="destructors.html#r-destructors.scope" title="destructors.scope"><span>[destructors<wbr>.scope]<span/></a></div>
<h2 id="드롭-스코프"><a class="header" href="#드롭-스코프">드롭 스코프</a></h2>
<div class="rule" id="r-destructors.scope.intro"><a class="rule-link" href="destructors.html#r-destructors.scope.intro" title="destructors.scope.intro"><span>[destructors<wbr>.scope<wbr>.intro]<span/></a></div>
<p>각 변수나 임시 값은 _드롭 스코프(drop scope)_와 연관됩니다. 제어 흐름이 드롭 스코프를 벗어나면 해당 스코프와 연관된 모든 변수는 선언된 역순으로, 임시 값은 생성된 역순으로 드롭됩니다.</p>
<div class="rule" id="r-destructors.scope.desugaring"><a class="rule-link" href="destructors.html#r-destructors.scope.desugaring" title="destructors.scope.desugaring"><span>[destructors<wbr>.scope<wbr>.desugaring]<span/></a></div>
<p>드롭 스코프는 <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>, <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 표현식을 <a href="expressions/match-expr.html"><code>match</code></a>를 사용한 등가의 표현식으로 대체한 후에 결정됩니다.</p>
<div class="rule" id="r-destructors.scope.operators"><a class="rule-link" href="destructors.html#r-destructors.scope.operators" title="destructors.scope.operators"><span>[destructors<wbr>.scope<wbr>.operators]<span/></a></div>
<p>오버로드된 연산자는 내장 연산자와 구별되지 않으며, <a href="patterns.html#binding-modes">바인딩 모드(binding modes)</a>는 고려되지 않습니다.</p>
<div class="rule" id="r-destructors.scope.list"><a class="rule-link" href="destructors.html#r-destructors.scope.list" title="destructors.scope.list"><span>[destructors<wbr>.scope<wbr>.list]<span/></a></div>
<p>함수 또는 클로저가 주어지면, 다음과 같은 것들에 대한 드롭 스코프가 존재합니다.</p>
<div class="rule" id="r-destructors.scope.function"><a class="rule-link" href="destructors.html#r-destructors.scope.function" title="destructors.scope.function"><span>[destructors<wbr>.scope<wbr>.function]<span/></a></div>
<ul>
<li>함수 전체</li>
</ul>
<div class="rule" id="r-destructors.scope.statement"><a class="rule-link" href="destructors.html#r-destructors.scope.statement" title="destructors.scope.statement"><span>[destructors<wbr>.scope<wbr>.statement]<span/></a></div>
<ul>
<li>각 <a href="statements.html">구문(statement)</a></li>
</ul>
<div class="rule" id="r-destructors.scope.expression"><a class="rule-link" href="destructors.html#r-destructors.scope.expression" title="destructors.scope.expression"><span>[destructors<wbr>.scope<wbr>.expression]<span/></a></div>
<ul>
<li>각 <a href="expressions.html">표현식(expression)</a></li>
</ul>
<div class="rule" id="r-destructors.scope.block"><a class="rule-link" href="destructors.html#r-destructors.scope.block" title="destructors.scope.block"><span>[destructors<wbr>.scope<wbr>.block]<span/></a></div>
<ul>
<li>함수 본문을 포함한 각 블록
<ul>
<li><a href="expressions/block-expr.html">블록 표현식(block expression)</a>의 경우, 블록의 스코프와 표현식의 스코프는 동일합니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-destructors.scope.match-arm"><a class="rule-link" href="destructors.html#r-destructors.scope.match-arm" title="destructors.scope.match-arm"><span>[destructors<wbr>.scope<wbr>.match-arm]<span/></a></div>
<ul>
<li><code>match</code> 표현식의 각 암(arm)</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting" title="destructors.scope.nesting"><span>[destructors<wbr>.scope<wbr>.nesting]<span/></a></div>
<p>드롭 스코프들은 다음과 같이 서로 중첩됩니다. 함수에서 반환될 때와 같이 여러 스코프를 한꺼번에 벗어날 때, 변수들은 안쪽에서 바깥쪽 순서로 드롭됩니다.</p>
<div class="rule" id="r-destructors.scope.nesting.function"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.function" title="destructors.scope.nesting.function"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.function]<span/></a></div>
<ul>
<li>함수 전체 스코프가 최외곽 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.function-body"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.function-body" title="destructors.scope.nesting.function-body"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.function-body]<span/></a></div>
<ul>
<li>함수 본문 블록은 함수 전체 스코프 내에 포함됩니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.expr-statement"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.expr-statement" title="destructors.scope.nesting.expr-statement"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.expr-statement]<span/></a></div>
<ul>
<li>표현식 구문 내 표현식의 부모는 해당 구문의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.let-initializer"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.let-initializer" title="destructors.scope.nesting.let-initializer"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.let-initializer]<span/></a></div>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 구문(let statement)</a>의 초기화식의 부모는 해당 <code>let</code> 구문의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.statement"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.statement" title="destructors.scope.nesting.statement"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.statement]<span/></a></div>
<ul>
<li>구문 스코프의 부모는 해당 구문을 포함하는 블록의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match-guard"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.match-guard" title="destructors.scope.nesting.match-guard"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match-guard]<span/></a></div>
<ul>
<li><code>match</code> 가드(guard) 표현식의 부모는 해당 가드가 속한 매치 암의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match-arm"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.match-arm" title="destructors.scope.nesting.match-arm"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match-arm]<span/></a></div>
<ul>
<li><code>match</code> 표현식에서 <code>=&gt;</code> 뒤에 오는 표현식의 부모는 그것이 속한 매치 암의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.match" title="destructors.scope.nesting.match"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match]<span/></a></div>
<ul>
<li>매치 암 스코프의 부모는 그것이 속한 <code>match</code> 표현식의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.other"><a class="rule-link" href="destructors.html#r-destructors.scope.nesting.other" title="destructors.scope.nesting.other"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.other]<span/></a></div>
<ul>
<li>그 외 모든 스코프의 부모는 그것을 직접 감싸고 있는 표현식의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.params"><a class="rule-link" href="destructors.html#r-destructors.scope.params" title="destructors.scope.params"><span>[destructors<wbr>.scope<wbr>.params]<span/></a></div>
<h3 id="함수-매개변수의-스코프"><a class="header" href="#함수-매개변수의-스코프">함수 매개변수의 스코프</a></h3>
<p>모든 함수 매개변수는 함수 본문 전체의 스코프에 속하므로, 함수가 평가될 때 가장 마지막에 드롭됩니다. 각 실제 함수 매개변수는 해당 매개변수의 패턴에서 도입된 모든 바인딩이 드롭된 후에 드롭됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>// `y`가 드롭되고, 그다음 두 번째 매개변수, 그다음 `x`, 그다음 첫 번째 매개변수 순으로 드롭됩니다.
fn patterns_in_parameters(
    (x, _): (PrintOnDrop, PrintOnDrop),
    (_, y): (PrintOnDrop, PrintOnDrop),
) {}

// 드롭 순서는 3 2 0 1입니다.
patterns_in_parameters(
    (PrintOnDrop("0"), PrintOnDrop("1")),
    (PrintOnDrop("2"), PrintOnDrop("3")),
);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.bindings"><a class="rule-link" href="destructors.html#r-destructors.scope.bindings" title="destructors.scope.bindings"><span>[destructors<wbr>.scope<wbr>.bindings]<span/></a></div>
<h3 id="지역-변수의-스코프"><a class="header" href="#지역-변수의-스코프">지역 변수의 스코프</a></h3>
<div class="rule" id="r-destructors.scope.bindings.intro"><a class="rule-link" href="destructors.html#r-destructors.scope.bindings.intro" title="destructors.scope.bindings.intro"><span>[destructors<wbr>.scope<wbr>.bindings<wbr>.intro]<span/></a></div>
<p><code>let</code> 구문에서 선언된 지역 변수는 해당 <code>let</code> 구문을 포함하는 블록의 스코프와 연관됩니다. <code>match</code> 표현식에서 선언된 지역 변수는 그것이 선언된 <code>match</code> 암의 암 스코프와 연관됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let declared_first = PrintOnDrop("바깥쪽 스코프에서 마지막에 드롭됨");
{
    let declared_in_block = PrintOnDrop("안쪽 스코프에서 드롭됨");
}
let declared_last = PrintOnDrop("바깥쪽 스코프에서 먼저 드롭됨");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.bindings.match-pattern-order"><a class="rule-link" href="destructors.html#r-destructors.scope.bindings.match-pattern-order" title="destructors.scope.bindings.match-pattern-order"><span>[destructors<wbr>.scope<wbr>.bindings<wbr>.match-pattern-order]<span/></a></div>
<p><code>match</code> 표현식의 동일한 암(arm)에서 여러 패턴이 사용되는 경우, 지정되지 않은 패턴 중 하나가 드롭 순서를 결정하는 데 사용됩니다.</p>
<div class="rule" id="r-destructors.scope.temporary"><a class="rule-link" href="destructors.html#r-destructors.scope.temporary" title="destructors.scope.temporary"><span>[destructors<wbr>.scope<wbr>.temporary]<span/></a></div>
<h3 id="임시-스코프"><a class="header" href="#임시-스코프">임시 스코프</a></h3>
<div class="rule" id="r-destructors.scope.temporary.intro"><a class="rule-link" href="destructors.html#r-destructors.scope.temporary.intro" title="destructors.scope.temporary.intro"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.intro]<span/></a></div>
<p>어떤 표현식의 _임시 스코프(temporary scope)_는 해당 표현식이 <a href="expressions.html#place-expressions-and-value-expressions">장소 컨텍스트(place context)</a>에서 사용될 때 그 결과를 보관하는 임시 변수에 사용되는 스코프입니다. 다만 해당 표현식이 <a href="destructors.html#constant-promotion">승격(promoted)</a>된 경우는 제외합니다.</p>
<div class="rule" id="r-destructors.scope.temporary.enclosing"><a class="rule-link" href="destructors.html#r-destructors.scope.temporary.enclosing" title="destructors.scope.temporary.enclosing"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.enclosing]<span/></a></div>
<p>라이프타임 확장을 제외하면, 표현식의 임시 스코프는 해당 표현식을 포함하는 가장 작은 스코프이며 다음 중 하나입니다.</p>
<ul>
<li>함수 전체.</li>
<li>구문(statement).</li>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> 또는 <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> 표현식의 본문.</li>
<li><code>if</code> 표현식의 <code>else</code> 블록.</li>
<li><code>if</code> 또는 <code>while</code> 표현식의 조건식, 혹은 <code>match</code> 가드(guard).</li>
<li>매치 암의 본문 표현식.</li>
<li><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 표현식(lazy boolean expression)</a>의 각 피연산자.</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>의 패턴 매칭 조건과 그에 따른 본문 (<a href="destructors.html#r-destructors.scope.temporary.edition2024">destructors.scope.temporary.edition2024</a>).</li>
<li>블록 꼬리 표현식(tail expression)의 전체 (<a href="destructors.html#r-destructors.scope.temporary.edition2024">destructors.scope.temporary.edition2024</a>).</li>
</ul>
<blockquote>
<p><strong>참고</strong>:</p>
<p><code>match</code> 표현식의 <a href="glossary.html#scrutinee">스크루티니(scrutinee)</a>는 임시 스코프가 아니므로, 스크루티니 내의 임시 값들은 <code>match</code> 표현식 이후에 드롭될 수 있습니다. 예를 들어, <code>match 1 { ref mut z =&gt; z };</code>에서 <code>1</code>을 위한 임시 값은 구문이 끝날 때까지 유지됩니다.</p>
</blockquote>
<div class="rule" id="r-destructors.scope.temporary.edition2024"><a class="rule-link" href="destructors.html#r-destructors.scope.temporary.edition2024" title="destructors.scope.temporary.edition2024"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션에는 두 가지 새로운 임시 스코프 축소 규칙이 추가되었습니다. <code>if let</code> 임시 값은 <code>else</code> 블록 이전에 드롭되며, 블록 꼬리 표현식의 임시 값은 꼬리 표현식이 평가된 직후에 드롭됩니다.</p>
</blockquote>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let local_var = PrintOnDrop("지역 변수");

// 조건이 평가되면 드롭됨
if PrintOnDrop("If 조건").0 == "If 조건" {
    // 블록 끝에서 드롭됨
    PrintOnDrop("If 본문").0
} else {
    unreachable!()
};

if let "if let 스크루티니" = PrintOnDrop("if let 스크루티니").0 {
    PrintOnDrop("if let 결과절").0
    // `if let 결과절`이 여기서 드롭됨
}
// `if let 스크루티니`가 여기서 드롭됨
else {
    PrintOnDrop("if let else").0
    // `if let else`가 여기서 드롭됨
};

// 첫 번째 || 이전에 드롭됨
(PrintOnDrop("첫 번째 피연산자").0 == ""
// ) 이전에 드롭됨
|| PrintOnDrop("두 번째 피연산자").0 == "")
// ; 이전에 드롭됨
|| PrintOnDrop("세 번째 피연산자").0 == "";

// 스크루티니는 함수의 끝에서 지역 변수들 이전에 드롭됩니다
// (이것이 함수 본문 블록의 꼬리 표현식이기 때문입니다).
match PrintOnDrop("최종 표현식의 매치된 값") {
    // 조건이 평가되면 드롭됨
    _ if PrintOnDrop("가드 조건").0 == "" =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.operands"><a class="rule-link" href="destructors.html#r-destructors.scope.operands" title="destructors.scope.operands"><span>[destructors<wbr>.scope<wbr>.operands]<span/></a></div>
<h3 id="피연산자"><a class="header" href="#피연산자">피연산자</a></h3>
<p>다른 피연산자가 평가되는 동안 표현식의 피연산자 결과를 보관하기 위해 임시 값이 생성되기도 합니다. 이러한 임시 값은 해당 피연산자가 속한 표현식의 스코프와 연관됩니다. 표현식이 평가되면 임시 값으로부터 데이터가 이동하므로, 표현식의 피연산자 중 하나가 표현식을 벗어나거나(break), 반환되거나(return), 패닉(panic)이 발생하지 않는 한 이들을 드롭하는 것은 아무런 효과가 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>loop {
    // 튜플 표현식의 평가가 완료되지 않았으므로 피연산자들이 역순으로 드롭됩니다.
    (
        PrintOnDrop("바깥쪽 튜플 첫 번째"),
        PrintOnDrop("바깥쪽 튜플 두 번째"),
        (
            PrintOnDrop("안쪽 튜플 첫 번째"),
            PrintOnDrop("안쪽 튜플 두 번째"),
            break,
        ),
        PrintOnDrop("절대로 생성되지 않음"),
    );
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.const-promotion"><a class="rule-link" href="destructors.html#r-destructors.scope.const-promotion" title="destructors.scope.const-promotion"><span>[destructors<wbr>.scope<wbr>.const-promotion]<span/></a></div>
<h3 id="상수-승격"><a class="header" href="#상수-승격">상수 승격</a></h3>
<p>값 표현식을 <code>'static</code> 슬롯으로 승격시키는 것은, 해당 표현식을 상수로 작성하여 차용할 수 있고, 그 차용을 원래 표현식이 작성된 위치에서 런타임 동작의 변경 없이 역참조할 수 있을 때 발생합니다. 즉, 승격된 표현식은 컴파일 타임에 평가될 수 있어야 하며, 그 결과값은 <a href="interior-mutability.html">내부 가변성(interior mutability)</a>이나 <a href="destructors.html">소멸자(destructors)</a>를 포함하지 않아야 합니다 (이러한 속성들은 가능한 경우 값을 기반으로 결정됩니다. 예를 들어, <code>&amp;None</code>은 허용되지 않는 것을 아무것도 포함하지 않으므로 항상 <code>&amp;'static Option&lt;_&gt;</code> 타입을 가집니다).</p>
<div class="rule" id="r-destructors.scope.lifetime-extension"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension" title="destructors.scope.lifetime-extension"><span>[destructors<wbr>.scope<wbr>.lifetime-extension]<span/></a></div>
<h3 id="임시-라이프타임-확장"><a class="header" href="#임시-라이프타임-확장">임시 라이프타임 확장</a></h3>
<blockquote>
<p><strong>참고</strong>: 임시 라이프타임 확장의 정확한 규칙은 변경될 수 있습니다. 여기서는 현재의 동작만을 설명합니다.</p>
</blockquote>
<div class="rule" id="r-destructors.scope.lifetime-extension.let"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.let" title="destructors.scope.lifetime-extension.let"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.let]<span/></a></div>
<p><code>let</code> 구문의 표현식에 대한 임시 스코프는 때때로 <code>let</code> 구문을 포함하는 블록의 스코프로 _확장(extended)_되기도 합니다. 이는 특정한 구문 규칙에 따라 일반적인 임시 스코프가 너무 작을 때 수행됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut 0;
// 보통이라면 임시 값은 지금쯤 드롭되었겠지만, `0`을 위한 임시 값은 블록 끝까지 유지됩니다.
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.lifetime-extension.static"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.static" title="destructors.scope.lifetime-extension.static"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.static]<span/></a></div>
<p>라이프타임 확장은 <code>static</code> 및 <code>const</code> 아이템에도 적용되어, 임시 값이 프로그램이 종료될 때까지 유지되게 합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;Vec&lt;i32&gt; = &amp;Vec::new();
// 보통이라면 `Vec`은 `C`의 초기화식 내부에만 존재하므로 이는 댕글링 참조(dangling reference)가 되겠지만,
// 대신 차용(borrow)이 라이프타임 확장되어 사실상 `'static` 라이프타임을 갖게 됩니다.
println!("{:?}", C);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.lifetime-extension.sub-expressions"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.sub-expressions" title="destructors.scope.lifetime-extension.sub-expressions"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.sub-expressions]<span/></a></div>
<p><a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a>, <a href="expressions/field-expr.html">필드(field)</a>, 또는 <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱싱 표현식(tuple indexing expression)</a>이 연장된 임시 스코프를 갖는다면 그 피연산자도 마찬가지입니다. 만약 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">인덱싱 표현식(indexing expression)</a>이 연장된 임시 스코프를 갖는다면 인덱싱되는 표현식도 연장된 임시 스코프를 갖습니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.patterns" title="destructors.scope.lifetime-extension.patterns"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns]<span/></a></div>
<h4 id="패턴에-기반한-연장"><a class="header" href="#패턴에-기반한-연장">패턴에 기반한 연장</a></h4>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns.extending"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.patterns.extending" title="destructors.scope.lifetime-extension.patterns.extending"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns<wbr>.extending]<span/></a></div>
<p>_연장 패턴(extending pattern)_은 다음 중 하나입니다.</p>
<ul>
<li>참조 또는 가변 참조로 바인딩하는 <a href="patterns.html#identifier-patterns">식별자 패턴(identifier pattern)</a>.</li>
<li>직접적인 하위 패턴 중 적어도 하나가 연장 패턴인 <a href="patterns.html#struct-patterns">구조체(struct)</a>, <a href="patterns.html#tuple-patterns">튜플(tuple)</a>, <a href="patterns.html#tuple-struct-patterns">튜플 구조체(tuple struct)</a>, 또는 <a href="patterns.html#slice-patterns">슬라이스(slice)</a> 패턴.</li>
</ul>
<p>따라서 <code>ref x</code>, <code>V(ref x)</code>, <code>[ref x, y]</code>는 모두 연장 패턴이지만, <code>x</code>, <code>&amp;ref x</code>, <code>&amp;(ref x,)</code>는 그렇지 않습니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns.let"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.patterns.let" title="destructors.scope.lifetime-extension.patterns.let"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns<wbr>.let]<span/></a></div>
<p><code>let</code> 구문의 패턴이 연장 패턴이면 초기화식 표현식의 임시 스코프가 연장됩니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.exprs"><a class="rule-link" href="destructors.html#r-destructors.scope.lifetime-extension.exprs" title="destructors.scope.lifetime-extension.exprs"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.exprs]<span/></a></div>
<h4 id="표현식에-기반한-연장"><a class="header" href="#표현식에-기반한-연장">표현식에 기반한 연장</a></h4>
<p>초기화식이 있는 let 구문의 경우, _연장 표현식(extending expression)_은 다음 중 하나인 표현식입니다.</p>
<ul>
<li>초기화식 표현식.</li>
<li>연장 <a href="expressions/operator-expr.html#borrow-operators">차용 표현식(borrow expression)</a>의 피연산자.</li>
<li>연장 <a href="expressions/array-expr.html#array-expressions">배열(array)</a>, <a href="expressions/operator-expr.html#type-cast-expressions">캐스트(cast)</a>, <a href="expressions/struct-expr.html">중괄호 구조체(braced struct)</a>, 또는 <a href="expressions/tuple-expressions">튜플(tuple)</a> 표현식의 피연산자(들).</li>
<li>모든 연장 <a href="expressions/block-expr.html">블록 표현식(block expression)</a>의 최종 표현식.</li>
</ul>
<p>따라서 <code>&amp;mut 0</code>, <code>(&amp;1, &amp;mut 2)</code>, <code>Some { 0: &amp;mut 3 }</code>에 있는 차용 표현식은 모두 연장 표현식입니다. <code>&amp;0 + &amp;1</code>과 <code>Some(&amp;mut 0)</code>에 있는 차용은 연장 표현식이 아닙니다. 후자는 구문론적으로 함수 호출 표현식이기 때문입니다.</p>
<p>모든 연장 차용 표현식의 피연산자는 그 임시 스코프가 연장됩니다.</p>
<h4 id="예시-4"><a class="header" href="#예시-4">예시</a></h4>
<p>다음은 표현식이 연장된 임시 스코프를 갖는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 이 경우 `temp()`의 결과를 저장하는 임시 값은
// x와 동일한 스코프 동안 유지됩니다.
let x = &amp;temp();
let x = &amp;temp() as &amp;dyn Send;
let x = (&amp;*&amp;temp(),);
let x = { [Some { 0: &amp;temp(), }] };
let ref x = temp();
let ref x = *&amp;temp();
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<p>다음은 표현식이 연장된 임시 스코프를 갖지 않는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 이 경우 `temp()`의 결과를 저장하는 임시 값은
// let 구문이 끝날 때까지만 유지됩니다.

let x = Some(&amp;temp());         // 오류
let x = (&amp;temp()).use_temp();  // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.forget"><a class="rule-link" href="destructors.html#r-destructors.forget" title="destructors.forget"><span>[destructors<wbr>.forget]<span/></a></div>
<h2 id="소멸자를-실행하지-않는-경우"><a class="header" href="#소멸자를-실행하지-않는-경우">소멸자를 실행하지 않는 경우</a></h2>
<p><a href="../core/mem/fn.forget.html"><code>std::mem::forget</code></a>은 변수의 소멸자가 실행되는 것을 방지하기 위해 사용될 수 있으며, <a href="../core/mem/manually_drop/struct.ManuallyDrop.html"><code>std::mem::ManuallyDrop</code></a>은 변수나 필드가 자동으로 드롭되는 것을 방지하는 래퍼를 제공합니다.</p>
<blockquote>
<p>참고: <a href="../core/mem/fn.forget.html"><code>std::mem::forget</code></a> 또는 다른 수단을 통해 소멸자가 실행되는 것을 방지하는 것은 해당 타입이 <code>'static</code>이 아니더라도 안전합니다. 이 문서에서 정의된 소멸자 실행이 보장되는 장소들 외에, 타입들은 건전성(soundness)을 위해 소멸자가 실행되는 것에 안전하게 의존할 수 <em>없을</em> 수도 있습니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-lifetime-elision"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision" title="lifetime-elision"><span>[lifetime-elision]<span/></a></div>
<h1 id="라이프타임-생략"><a class="header" href="#라이프타임-생략">라이프타임 생략</a></h1>
<p>러스트에는 컴파일러가 합리적인 기본 선택을 추론할 수 있는 다양한 위치에서 라이프타임을 생략할 수 있게 해주는 규칙들이 있습니다.</p>
<div class="rule" id="r-lifetime-elision.function"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function" title="lifetime-elision.function"><span>[lifetime-elision<wbr>.function]<span/></a></div>
<h2 id="함수에서의-라이프타임-생략"><a class="header" href="#함수에서의-라이프타임-생략">함수에서의 라이프타임 생략</a></h2>
<div class="rule" id="r-lifetime-elision.function.intro"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.intro" title="lifetime-elision.function.intro"><span>[lifetime-elision<wbr>.function<wbr>.intro]<span/></a></div>
<p>일반적인 패턴을 더 인체공학적으로 만들기 위해, <a href="types/function-item.html">함수 아이템(function item)</a>, <a href="types/function-pointer.html">함수 포인터(function pointer)</a>, <a href="types/closure.html">클로저 트레잇(closure trait)</a> 시그니처에서 라이프타임 인자가 _생략(elided)_될 수 있습니다. 생략된 라이프타임에 대한 라이프타임 파라미터를 추론하기 위해 다음 규칙들이 사용됩니다.</p>
<div class="rule" id="r-lifetime-elision.function.lifetimes-not-inferred"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.lifetimes-not-inferred" title="lifetime-elision.function.lifetimes-not-inferred"><span>[lifetime-elision<wbr>.function<wbr>.lifetimes-not-inferred]<span/></a></div>
<p>추론할 수 없는 라이프타임 파라미터를 생략하는 것은 오류입니다.</p>
<div class="rule" id="r-lifetime-elision.function.explicit-placeholder"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.explicit-placeholder" title="lifetime-elision.function.explicit-placeholder"><span>[lifetime-elision<wbr>.function<wbr>.explicit-placeholder]<span/></a></div>
<p>플레이스홀더 라이프타임인 <code>'_</code>도 동일한 방식으로 라이프타임을 추론하도록 하기 위해 사용될 수 있습니다. 경로에서의 라이프타임에 대해서는 <code>'_</code>를 사용하는 것이 선호됩니다.</p>
<div class="rule" id="r-lifetime-elision.function.only-functions"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.only-functions" title="lifetime-elision.function.only-functions"><span>[lifetime-elision<wbr>.function<wbr>.only-functions]<span/></a></div>
<p>트레잇 객체 라이프타임은 <a href="lifetime-elision.html#default-trait-object-lifetimes">아래</a>에서 논의될 다른 규칙을 따릅니다.</p>
<div class="rule" id="r-lifetime-elision.function.implicit-lifetime-parameters"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.implicit-lifetime-parameters" title="lifetime-elision.function.implicit-lifetime-parameters"><span>[lifetime-elision<wbr>.function<wbr>.implicit-lifetime-parameters]<span/></a></div>
<ul>
<li>파라미터에서 생략된 각 라이프타임은 별개의 라이프타임 파라미터가 됩니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.function.output-lifetime"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.output-lifetime" title="lifetime-elision.function.output-lifetime"><span>[lifetime-elision<wbr>.function<wbr>.output-lifetime]<span/></a></div>
<ul>
<li>파라미터에서 사용된 라이프타임(생략되었든 아니든)이 정확히 하나라면, 그 라이프타임이 <em>모든</em> 생략된 출력 라이프타임에 할당됩니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.function.receiver-lifetime"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.function.receiver-lifetime" title="lifetime-elision.function.receiver-lifetime"><span>[lifetime-elision<wbr>.function<wbr>.receiver-lifetime]<span/></a></div>
<p>메서드 시그니처에는 또 다른 규칙이 있습니다</p>
<ul>
<li>리시버(receiver)가 <code>&amp;Self</code> 또는 <code>&amp;mut Self</code> 타입을 가지면, 그 <code>Self</code>에 대한 참조의 라이프타임이 모든 생략된 출력 라이프타임 파라미터에 할당됩니다.</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {}
</span><span class="boring">trait ToCStr {}
</span><span class="boring">struct Thing&lt;'a&gt; {f: &amp;'a i32}
</span><span class="boring">struct Command;
</span><span class="boring">
</span><span class="boring">trait Example {
</span>fn print1(s: &amp;str);                                   // 생략됨
fn print2(s: &amp;'_ str);                                // 역시 생략됨
fn print3&lt;'a&gt;(s: &amp;'a str);                            // 확장됨

fn debug1(lvl: usize, s: &amp;str);                       // 생략됨
fn debug2&lt;'a&gt;(lvl: usize, s: &amp;'a str);                // 확장됨

fn substr1(s: &amp;str, until: usize) -&gt; &amp;str;            // 생략됨
fn substr2&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;  // 확장됨

fn get_mut1(&amp;mut self) -&gt; &amp;mut dyn T;                 // 생략됨
fn get_mut2&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut dyn T;       // 확장됨

fn args1&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command;                  // 생략됨
fn args2&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // 확장됨

fn other_args1&lt;'a&gt;(arg: &amp;str) -&gt; &amp;'a str;             // 생략됨
fn other_args2&lt;'a, 'b&gt;(arg: &amp;'b str) -&gt; &amp;'a str;      // 확장됨

fn new1(buf: &amp;mut [u8]) -&gt; Thing&lt;'_&gt;;                 // 생략됨 - 선호됨
fn new2(buf: &amp;mut [u8]) -&gt; Thing;                     // 생략됨
fn new3&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; Thing&lt;'a&gt;;          // 확장됨
<span class="boring">}
</span>
type FunPtr1 = fn(&amp;str) -&gt; &amp;str;                      // 생략됨
type FunPtr2 = for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str;        // 확장됨

type FunTrait1 = dyn Fn(&amp;str) -&gt; &amp;str;                // 생략됨
type FunTrait2 = dyn for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str;  // 확장됨
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 예제들은 라이프타임 파라미터를 생략할 수 없는 상황들을 보여줍니다.

<span class="boring">trait Example {
</span>// 추론할 수 있는 파라미터가 없기 때문에 추론할 수 없습니다.
fn get_str() -&gt; &amp;str;                                 // 허용되지 않음

// 첫 번째 파라미터에서 차용된 것인지 두 번째 파라미터에서 차용된 것인지 모호하기 때문에 추론할 수 없습니다.
fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                    // 허용되지 않음
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lifetime-elision.trait-object"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object" title="lifetime-elision.trait-object"><span>[lifetime-elision<wbr>.trait-object]<span/></a></div>
<h2 id="기본-트레잇-객체-라이프타임"><a class="header" href="#기본-트레잇-객체-라이프타임">기본 트레잇 객체 라이프타임</a></h2>
<div class="rule" id="r-lifetime-elision.trait-object.intro"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.intro" title="lifetime-elision.trait-object.intro"><span>[lifetime-elision<wbr>.trait-object<wbr>.intro]<span/></a></div>
<p><a href="types/trait-object.html">트레잇 객체(trait object)</a>가 보유한 참조의 추정 라이프타임을 _기본 객체 라이프타임 바운드(default object lifetime bound)_라고 합니다. 이들은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a>에서 정의되었고 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>에서 개정되었습니다.</p>
<div class="rule" id="r-lifetime-elision.trait-object.explicit-bound"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.explicit-bound" title="lifetime-elision.trait-object.explicit-bound"><span>[lifetime-elision<wbr>.trait-object<wbr>.explicit-bound]<span/></a></div>
<p>이러한 기본 객체 라이프타임 바운드는 라이프타임 바운드가 완전히 생략되었을 때 위에서 정의된 라이프타임 파라미터 생략 규칙 대신 사용됩니다.</p>
<div class="rule" id="r-lifetime-elision.trait-object.explicit-placeholder"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.explicit-placeholder" title="lifetime-elision.trait-object.explicit-placeholder"><span>[lifetime-elision<wbr>.trait-object<wbr>.explicit-placeholder]<span/></a></div>
<p><code>'_</code>가 라이프타임 바운드로 사용되면 해당 바운드는 일반적인 생략 규칙을 따릅니다.</p>
<div class="rule" id="r-lifetime-elision.trait-object.containing-type"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type" title="lifetime-elision.trait-object.containing-type"><span>[lifetime-elision<wbr>.trait-object<wbr>.containing-type]<span/></a></div>
<p>트레잇 객체가 제네릭 타입의 타입 인자로 사용되면, 먼저 이를 포함하는 타입을 사용하여 바운드를 추론하려고 시도합니다.</p>
<div class="rule" id="r-lifetime-elision.trait-object.containing-type-unique"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type-unique" title="lifetime-elision.trait-object.containing-type-unique"><span>[lifetime-elision<wbr>.trait-object<wbr>.containing-type-unique]<span/></a></div>
<ul>
<li>포함하는 타입으로부터 유일한 바운드가 있다면 그것이 기본값이 됩니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.trait-object.containing-type-explicit"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type-explicit" title="lifetime-elision.trait-object.containing-type-explicit"><span>[lifetime-elision<wbr>.trait-object<wbr>.containing-type-explicit]<span/></a></div>
<ul>
<li>포함하는 타입으로부터 둘 이상의 바운드가 있다면 명시적인 바운드를 지정해야 합니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.trait-object.trait-bounds"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.trait-bounds" title="lifetime-elision.trait-object.trait-bounds"><span>[lifetime-elision<wbr>.trait-object<wbr>.trait-bounds]<span/></a></div>
<p>두 규칙 모두 적용되지 않는 경우, 트레잇에 지정된 바운드가 사용됩니다.</p>
<div class="rule" id="r-lifetime-elision.trait-object.trait-unique"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.trait-unique" title="lifetime-elision.trait-object.trait-unique"><span>[lifetime-elision<wbr>.trait-object<wbr>.trait-unique]<span/></a></div>
<ul>
<li>트레잇이 단일 라이프타임 _바운드_와 함께 정의되었다면 그 바운드가 사용됩니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.trait-object.static-lifetime"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.static-lifetime" title="lifetime-elision.trait-object.static-lifetime"><span>[lifetime-elision<wbr>.trait-object<wbr>.static-lifetime]<span/></a></div>
<ul>
<li>어떤 라이프타임 바운드에라도 <code>'static</code>이 사용되었다면 <code>'static</code>이 사용됩니다.</li>
</ul>
<div class="rule" id="r-lifetime-elision.trait-object.default"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.default" title="lifetime-elision.trait-object.default"><span>[lifetime-elision<wbr>.trait-object<wbr>.default]<span/></a></div>
<ul>
<li>트레잇에 라이프타임 바운드가 없다면, 라이프타임은 표현식 내에서는 추론되고 표현식 외부에서는 <code>'static</code>이 됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 트레잇에 대하여...
trait Foo { }

// Box&lt;T&gt;는 T에 대한 라이프타임 바운드가 없으므로 이 둘은 동일합니다.
type T1 = Box&lt;dyn Foo&gt;;
type T2 = Box&lt;dyn Foo + 'static&gt;;

// ...그리고 다음의 경우들도 그렇습니다:
impl dyn Foo {}
impl dyn Foo + 'static {}

// ...&amp;'a T가 T: 'a를 요구하므로 다음의 경우들도 그렇습니다:
type T3&lt;'a&gt; = &amp;'a dyn Foo;
type T4&lt;'a&gt; = &amp;'a (dyn Foo + 'a);

// std::cell::Ref&lt;'a, T&gt; 역시 T: 'a를 요구하므로 이들은 동일합니다.
type T5&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo&gt;;
type T6&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo + 'a&gt;;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 오류의 한 예입니다.
<span class="boring">trait Foo { }
</span>struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt; {
    f1: &amp;'a i32,
    f2: &amp;'b i32,
    f3: T,
}
type T7&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Foo&gt;;
//                                  ^^^^^^^
// 오류: 이 객체 타입에 대한 라이프타임 바운드를 문맥으로부터 추론할 수 없습니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lifetime-elision.trait-object.innermost-type"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.trait-object.innermost-type" title="lifetime-elision.trait-object.innermost-type"><span>[lifetime-elision<wbr>.trait-object<wbr>.innermost-type]<span/></a></div>
<p>가장 안쪽의 객체가 바운드를 설정하므로, <code>&amp;'a Box&lt;dyn Foo&gt;</code>는 여전히 <code>&amp;'a Box&lt;dyn Foo + 'static&gt;</code>임에 유의하세요.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 트레잇에 대하여...
trait Bar&lt;'a&gt;: 'a { }

// ...이 둘은 동일합니다:
type T1&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt;&gt;;
type T2&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt; + 'a&gt;;

// ...그리고 다음의 경우들도 그렇습니다:
impl&lt;'a&gt; dyn Bar&lt;'a&gt; {}
impl&lt;'a&gt; dyn Bar&lt;'a&gt; + 'a {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lifetime-elision.const-static"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.const-static" title="lifetime-elision.const-static"><span>[lifetime-elision<wbr>.const-static]<span/></a></div>
<h2 id="const-및-static-생략"><a class="header" href="#const-및-static-생략"><code>const</code> 및 <code>static</code> 생략</a></h2>
<div class="rule" id="r-lifetime-elision.const-static.implicit-static"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.const-static.implicit-static" title="lifetime-elision.const-static.implicit-static"><span>[lifetime-elision<wbr>.const-static<wbr>.implicit-static]<span/></a></div>
<p><a href="items/constant-items.html">상수(constant)</a> 및 <a href="items/static-items.html">정적(static)</a> 참조 타입 선언은 명시적인 라이프타임이 지정되지 않는 한 <em>암시적인</em> <code>'static</code> 라이프타임을 갖습니다. 따라서 위에서 <code>'static</code>을 포함하는 상수 선언들은 라이프타임 없이 작성될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// STRING: &amp;'static str
const STRING: &amp;str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

// BITS_N_STRINGS: BitsNStrings&lt;'static&gt;
const BITS_N_STRINGS: BitsNStrings&lt;'_&gt; = BitsNStrings {
    mybits: [1, 2],
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lifetime-elision.const-static.fn-references"><a class="rule-link" href="lifetime-elision.html#r-lifetime-elision.const-static.fn-references" title="lifetime-elision.const-static.fn-references"><span>[lifetime-elision<wbr>.const-static<wbr>.fn-references]<span/></a></div>
<p><code>static</code> 또는 <code>const</code> 아이템이 함수나 클로저 참조를 포함하고, 그 함수나 클로저가 다시 참조를 포함하는 경우, 컴파일러는 먼저 표준 생략 규칙을 시도합니다. 일반적인 규칙으로 라이프타임을 해결할 수 없다면 오류가 발생합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc(a: &amp;Foo, b: &amp;Bar, c: &amp;Baz) -&gt; usize {42}
</span>// `for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str`로 해결됩니다.
const RESOLVED_SINGLE: fn(&amp;str) -&gt; &amp;str = |x| x;

// `for&lt;'a, 'b, 'c&gt; Fn(&amp;'a Foo, &amp;'b Bar, &amp;'c Baz) -&gt; usize`로 해결됩니다.
const RESOLVED_MULTIPLE: &amp;dyn Fn(&amp;Foo, &amp;Bar, &amp;Baz) -&gt; usize = &amp;somefunc;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc&lt;'a,'b&gt;(a: &amp;'a Foo, b: &amp;'b Bar) -&gt; &amp;'a Baz {unimplemented!()}
</span>// 인자 라이프타임과 관련하여 반환 참조 라이프타임을 제한할 정보가 충분하지 않으므로, 이는 오류입니다.
const RESOLVED_STATIC: &amp;dyn Fn(&amp;Foo, &amp;Bar) -&gt; &amp;Baz = &amp;somefunc;
//                                            ^
// 이 함수의 반환 타입은 차용된 값을 포함하지만, 시그니처에는 이것이 인자 1에서 차용된 것인지 인자 2에서 차용된 것인지 명시되어 있지 않습니다.
<span class="boring">}</span></code></pre></pre>
<script>
(function() {
    var fragments = {
        "#static-lifetime-elision": "lifetime-elision.html#const-and-static-elision",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-lang-types"><a class="rule-link" href="special-types-and-traits.html#r-lang-types" title="lang-types"><span>[lang-types]<span/></a></div>
<h1 id="특수-타입과-트레잇"><a class="header" href="#특수-타입과-트레잇">특수 타입과 트레잇</a></h1>
<div class="rule" id="r-lang-types.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.intro" title="lang-types.intro"><span>[lang-types<wbr>.intro]<span/></a></div>
<p><a href="../std/index.html">표준 라이브러리</a>에 존재하는 특정 타입과 트레잇은 러스트 컴파일러에게 알려져 있습니다. 이 장에서는 이러한 타입과 트레잇의 특별한 기능들을 문서화합니다.</p>
<div class="rule" id="r-lang-types.box"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.box" title="lang-types.box"><span>[lang-types<wbr>.box]<span/></a></div>
<h2 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h2>
<div class="rule" id="r-lang-types.box.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.box.intro" title="lang-types.box.intro"><span>[lang-types<wbr>.box<wbr>.intro]<span/></a></div>
<p><a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>는 현재 러스트가 사용자 정의 타입에 대해서는 허용하지 않는 몇 가지 특별한 기능을 가지고 있습니다.</p>
<div class="rule" id="r-lang-types.box.deref"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.box.deref" title="lang-types.box.deref"><span>[lang-types<wbr>.box<wbr>.deref]<span/></a></div>
<ul>
<li><code>Box&lt;T&gt;</code>에 대한 <a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a>는 데이터를 이동(move)할 수 있는 장소(place)를 생성합니다. 이는 <code>*</code> 연산자와 <code>Box&lt;T&gt;</code>의 소멸자가 언어 자체에 내장되어 있음을 의미합니다.</li>
</ul>
<div class="rule" id="r-lang-types.box.receiver"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.box.receiver" title="lang-types.box.receiver"><span>[lang-types<wbr>.box<wbr>.receiver]<span/></a></div>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">메서드(Methods)</a>는 <code>Box&lt;Self&gt;</code>를 리시버로 취할 수 있습니다.</li>
</ul>
<div class="rule" id="r-lang-types.box.fundamental"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.box.fundamental" title="lang-types.box.fundamental"><span>[lang-types<wbr>.box<wbr>.fundamental]<span/></a></div>
<ul>
<li><a href="items/implementations.html#trait-implementation-coherence">고아 규칙(orphan rules)</a>이 다른 제네릭 타입에 대해서는 금지하는 것과 달리, <code>T</code>와 동일한 크레이트에서 <code>Box&lt;T&gt;</code>에 대해 트레잇을 구현할 수 있습니다.</li>
</ul>
<!-- Editor Note: This is nowhere close to an exhaustive list -->
<div class="rule" id="r-lang-types.rc"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.rc" title="lang-types.rc"><span>[lang-types<wbr>.rc]<span/></a></div>
<h2 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h2>
<div class="rule" id="r-lang-types.rc.receiver"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.rc.receiver" title="lang-types.rc.receiver"><span>[lang-types<wbr>.rc<wbr>.receiver]<span/></a></div>
<p><a href="items/associated-items.html#associated-functions-and-methods">메서드(Methods)</a>는 <a href="../alloc/rc/struct.Rc.html"><code>Rc&lt;Self&gt;</code></a>를 리시버로 취할 수 있습니다.</p>
<div class="rule" id="r-lang-types.arc"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.arc" title="lang-types.arc"><span>[lang-types<wbr>.arc]<span/></a></div>
<h2 id="arct"><a class="header" href="#arct"><code>Arc&lt;T&gt;</code></a></h2>
<div class="rule" id="r-lang-types.arc.receiver"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.arc.receiver" title="lang-types.arc.receiver"><span>[lang-types<wbr>.arc<wbr>.receiver]<span/></a></div>
<p><a href="items/associated-items.html#associated-functions-and-methods">메서드(Methods)</a>는 <a href="../alloc/sync/struct.Arc.html"><code>Arc&lt;Self&gt;</code></a>를 리시버로 취할 수 있습니다.</p>
<div class="rule" id="r-lang-types.pin"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.pin" title="lang-types.pin"><span>[lang-types<wbr>.pin]<span/></a></div>
<h2 id="pinp"><a class="header" href="#pinp"><code>Pin&lt;P&gt;</code></a></h2>
<div class="rule" id="r-lang-types.pin.receiver"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.pin.receiver" title="lang-types.pin.receiver"><span>[lang-types<wbr>.pin<wbr>.receiver]<span/></a></div>
<p><a href="items/associated-items.html#associated-functions-and-methods">메서드(Methods)</a>는 <a href="../core/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a>를 리시버로 취할 수 있습니다.</p>
<div class="rule" id="r-lang-types.unsafe-cell"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.unsafe-cell" title="lang-types.unsafe-cell"><span>[lang-types<wbr>.unsafe-cell]<span/></a></div>
<h2 id="unsafecellt"><a class="header" href="#unsafecellt"><code>UnsafeCell&lt;T&gt;</code></a></h2>
<div class="rule" id="r-lang-types.unsafe-cell.interior-mut"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.unsafe-cell.interior-mut" title="lang-types.unsafe-cell.interior-mut"><span>[lang-types<wbr>.unsafe-cell<wbr>.interior-mut]<span/></a></div>
<p><a href="../core/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a>는 <a href="interior-mutability.html">내부 가변성(interior mutability)</a>을 위해 사용됩니다. 이는 컴파일러가 해당 타입들에 대해 부적절한 최적화를 수행하지 않도록 보장합니다.</p>
<div class="rule" id="r-lang-types.unsafe-cell.read-only-alloc"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.unsafe-cell.read-only-alloc" title="lang-types.unsafe-cell.read-only-alloc"><span>[lang-types<wbr>.unsafe-cell<wbr>.read-only-alloc]<span/></a></div>
<p>또한 내부 가변성을 가진 타입을 가진 <a href="items/static-items.html"><code>static</code> 아이템</a>이 읽기 전용으로 표시된 메모리에 배치되지 않도록 보장합니다.</p>
<div class="rule" id="r-lang-types.phantom-data"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.phantom-data" title="lang-types.phantom-data"><span>[lang-types<wbr>.phantom-data]<span/></a></div>
<h2 id="phantomdatat"><a class="header" href="#phantomdatat"><code>PhantomData&lt;T&gt;</code></a></h2>
<p><a href="../core/marker/struct.PhantomData.html"><code>std::marker::PhantomData&lt;T&gt;</code></a>는 크기가 0이고 정렬(alignment)이 최소인 타입으로, <a href="subtyping.html#variance">가변성(variance)</a>, <a href="../nomicon/dropck.html">드롭 검사(drop check)</a>, 그리고 <a href="special-types-and-traits.html#auto-traits">자동 트레잇(auto traits)</a>의 목적을 위해 <code>T</code>를 소유하는 것으로 간주됩니다.</p>
<div class="rule" id="r-lang-types.ops"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.ops" title="lang-types.ops"><span>[lang-types<wbr>.ops]<span/></a></div>
<h2 id="연산자-트레잇"><a class="header" href="#연산자-트레잇">연산자 트레잇</a></h2>
<p><a href="../core/ops/index.html"><code>std::ops</code></a> 및 <a href="../core/cmp/index.html"><code>std::cmp</code></a>에 있는 트레잇들은 <a href="expressions/operator-expr.html">연산자(operators)</a>, <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">인덱싱 표현식(indexing expressions)</a>, 그리고 <a href="expressions/call-expr.html">호출 표현식(call expressions)</a>을 오버로드하는 데 사용됩니다.</p>
<div class="rule" id="r-lang-types.deref"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.deref" title="lang-types.deref"><span>[lang-types<wbr>.deref]<span/></a></div>
<h2 id="deref-및-derefmut"><a class="header" href="#deref-및-derefmut"><code>Deref</code> 및 <code>DerefMut</code></a></h2>
<p>단항 <code>*</code> 연산자를 오버로드하는 것뿐만 아니라, <a href="../core/ops/deref/trait.Deref.html"><code>Deref</code></a>와 <a href="../core/ops/deref/trait.DerefMut.html"><code>DerefMut</code></a>는 <a href="expressions/method-call-expr.html">메서드 확인(method resolution)</a> 및 <a href="type-coercions.html#coercion-types">deref 강제 변환(deref coercions)</a>에서도 사용됩니다.</p>
<div class="rule" id="r-lang-types.drop"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.drop" title="lang-types.drop"><span>[lang-types<wbr>.drop]<span/></a></div>
<h2 id="drop"><a class="header" href="#drop"><code>Drop</code></a></h2>
<p><a href="../core/ops/drop/trait.Drop.html"><code>Drop</code></a> 트레잇은 이 타입의 값이 파괴될 때마다 실행될 <a href="destructors.html">소멸자(destructor)</a>를 제공합니다.</p>
<div class="rule" id="r-lang-types.copy"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy" title="lang-types.copy"><span>[lang-types<wbr>.copy]<span/></a></div>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<div class="rule" id="r-lang-types.copy.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.intro" title="lang-types.copy.intro"><span>[lang-types<wbr>.copy<wbr>.intro]<span/></a></div>
<p><a href="../core/marker/trait.Copy.html"><code>Copy</code></a> 트레잇은 이를 구현하는 타입의 의미론(semantics)을 변경합니다.</p>
<div class="rule" id="r-lang-types.copy.behavior"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.behavior" title="lang-types.copy.behavior"><span>[lang-types<wbr>.copy<wbr>.behavior]<span/></a></div>
<p><code>Copy</code>를 구현하는 타입의 값은 할당 시 이동(move)되지 않고 복사(copy)됩니다.</p>
<div class="rule" id="r-lang-types.copy.constraint"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.constraint" title="lang-types.copy.constraint"><span>[lang-types<wbr>.copy<wbr>.constraint]<span/></a></div>
<p><code>Copy</code>는 <code>Drop</code>을 구현하지 않고 모든 필드가 <code>Copy</code>인 타입에 대해서만 구현될 수 있습니다. 열거형의 경우 모든 변형(variant)의 모든 필드가 <code>Copy</code>여야 함을 의미합니다. 공용체(union)의 경우 모든 변형이 <code>Copy</code>여야 함을 의미합니다.</p>
<div class="rule" id="r-lang-types.copy.builtin-types"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.builtin-types" title="lang-types.copy.builtin-types"><span>[lang-types<wbr>.copy<wbr>.builtin-types]<span/></a></div>
<p>컴파일러는 다음의 경우들에 대해 <code>Copy</code>를 구현합니다.</p>
<div class="rule" id="r-lang-types.copy.tuple"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.tuple" title="lang-types.copy.tuple"><span>[lang-types<wbr>.copy<wbr>.tuple]<span/></a></div>
<ul>
<li><code>Copy</code> 타입들로 구성된 <a href="types/tuple.html">튜플(Tuples)</a></li>
</ul>
<div class="rule" id="r-lang-types.copy.fn-pointer"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.fn-pointer" title="lang-types.copy.fn-pointer"><span>[lang-types<wbr>.copy<wbr>.fn-pointer]<span/></a></div>
<ul>
<li><a href="types/function-pointer.html">함수 포인터</a></li>
</ul>
<div class="rule" id="r-lang-types.copy.fn-item"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.fn-item" title="lang-types.copy.fn-item"><span>[lang-types<wbr>.copy<wbr>.fn-item]<span/></a></div>
<ul>
<li><a href="types/function-item.html">함수 아이템(Function items)</a></li>
</ul>
<div class="rule" id="r-lang-types.copy.closure"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.copy.closure" title="lang-types.copy.closure"><span>[lang-types<wbr>.copy<wbr>.closure]<span/></a></div>
<ul>
<li>아무 값도 캡처하지 않거나 <code>Copy</code> 타입의 값만 캡처하는 <a href="types/closure.html">클로저(Closures)</a></li>
</ul>
<div class="rule" id="r-lang-types.clone"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone" title="lang-types.clone"><span>[lang-types<wbr>.clone]<span/></a></div>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<div class="rule" id="r-lang-types.clone.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone.intro" title="lang-types.clone.intro"><span>[lang-types<wbr>.clone<wbr>.intro]<span/></a></div>
<p><a href="../core/clone/trait.Clone.html"><code>Clone</code></a> 트레잇은 <code>Copy</code>의 상위 트레잇(supertrait)이므로, 역시 컴파일러가 생성한 구현이 필요합니다.</p>
<div class="rule" id="r-lang-types.clone.builtin-types"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone.builtin-types" title="lang-types.clone.builtin-types"><span>[lang-types<wbr>.clone<wbr>.builtin-types]<span/></a></div>
<p>컴파일러는 다음 타입들에 대해 이를 구현합니다.</p>
<div class="rule" id="r-lang-types.clone.builtin-copy"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone.builtin-copy" title="lang-types.clone.builtin-copy"><span>[lang-types<wbr>.clone<wbr>.builtin-copy]<span/></a></div>
<ul>
<li>내장된 <code>Copy</code> 구현을 가진 타입 (위 참조)</li>
</ul>
<div class="rule" id="r-lang-types.clone.tuple"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone.tuple" title="lang-types.clone.tuple"><span>[lang-types<wbr>.clone<wbr>.tuple]<span/></a></div>
<ul>
<li><code>Clone</code> 타입들로 구성된 <a href="types/tuple.html">튜플(Tuples)</a></li>
</ul>
<div class="rule" id="r-lang-types.clone.closure"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.clone.closure" title="lang-types.clone.closure"><span>[lang-types<wbr>.clone<wbr>.closure]<span/></a></div>
<ul>
<li><code>Clone</code> 타입의 값만 캡처하거나 환경에서 아무 값도 캡처하지 않는 <a href="types/closure.html">클로저(Closures)</a></li>
</ul>
<div class="rule" id="r-lang-types.send"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.send" title="lang-types.send"><span>[lang-types<wbr>.send]<span/></a></div>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><a href="../core/marker/trait.Send.html"><code>Send</code></a> 트레잇은 이 타입의 값이 한 스레드에서 다른 스레드로 안전하게 전달될 수 있음을 나타냅니다.</p>
<div class="rule" id="r-lang-types.sync"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sync" title="lang-types.sync"><span>[lang-types<wbr>.sync]<span/></a></div>
<h2 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h2>
<div class="rule" id="r-lang-types.sync.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sync.intro" title="lang-types.sync.intro"><span>[lang-types<wbr>.sync<wbr>.intro]<span/></a></div>
<p><a href="../core/marker/trait.Sync.html"><code>Sync</code></a> 트레잇은 이 타입의 값을 여러 스레드 간에 안전하게 공유할 수 있음을 나타냅니다.</p>
<div class="rule" id="r-lang-types.sync.static-constraint"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sync.static-constraint" title="lang-types.sync.static-constraint"><span>[lang-types<wbr>.sync<wbr>.static-constraint]<span/></a></div>
<p>이 트레잇은 불변 <a href="items/static-items.html"><code>static</code> 아이템(static items)</a>에 사용되는 모든 타입에 대해 구현되어야 합니다.</p>
<div class="rule" id="r-lang-types.termination"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.termination" title="lang-types.termination"><span>[lang-types<wbr>.termination]<span/></a></div>
<h2 id="termination"><a class="header" href="#termination"><code>Termination</code></a></h2>
<p><a href="../std/process/trait.Termination.html"><code>Termination</code></a> 트레잇은 <a href="crates-and-source-files.html#main-functions">메인 함수(main function)</a> 및 <a href="attributes/testing.html#the-test-attribute">테스트 함수(test functions)</a>에서 허용되는 반환 타입들을 나타냅니다.</p>
<div class="rule" id="r-lang-types.auto-traits"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits" title="lang-types.auto-traits"><span>[lang-types<wbr>.auto-traits]<span/></a></div>
<h2 id="자동-트레잇auto-traits"><a class="header" href="#자동-트레잇auto-traits">자동 트레잇(Auto traits)</a></h2>
<p><a href="../core/marker/trait.Send.html"><code>Send</code></a>, <a href="../core/marker/trait.Sync.html"><code>Sync</code></a>, <a href="../core/marker/trait.Unpin.html"><code>Unpin</code></a>, <a href="../core/panic/unwind_safe/trait.UnwindSafe.html"><code>UnwindSafe</code></a>, 그리고 <a href="../core/panic/unwind_safe/trait.RefUnwindSafe.html"><code>RefUnwindSafe</code></a> 트레잇은 _자동 트레잇(auto traits)_입니다. 자동 트레잇은 특별한 속성을 가집니다.</p>
<div class="rule" id="r-lang-types.auto-traits.auto-impl"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.auto-impl" title="lang-types.auto-traits.auto-impl"><span>[lang-types<wbr>.auto-traits<wbr>.auto-impl]<span/></a></div>
<p>주어진 타입에 대해 자동 트레잇에 대한 명시적인 구현이나 부정적인 구현(negative implementation)이 작성되어 있지 않다면, 컴파일러는 다음 규칙에 따라 자동으로 이를 구현합니다.</p>
<div class="rule" id="r-lang-types.auto-traits.builtin-composite"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.builtin-composite" title="lang-types.auto-traits.builtin-composite"><span>[lang-types<wbr>.auto-traits<wbr>.builtin-composite]<span/></a></div>
<ul>
<li><code>T</code>가 해당 트레잇을 구현하면 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>*const T</code>, <code>*mut T</code>, <code>[T; n]</code>, 그리고 <code>[T]</code>도 이를 구현합니다.</li>
</ul>
<div class="rule" id="r-lang-types.auto-traits.fn-item-pointer"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.fn-item-pointer" title="lang-types.auto-traits.fn-item-pointer"><span>[lang-types<wbr>.auto-traits<wbr>.fn-item-pointer]<span/></a></div>
<ul>
<li>함수 아이템 타입과 함수 포인터는 자동으로 트레잇을 구현합니다.</li>
</ul>
<div class="rule" id="r-lang-types.auto-traits.aggregate"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.aggregate" title="lang-types.auto-traits.aggregate"><span>[lang-types<wbr>.auto-traits<wbr>.aggregate]<span/></a></div>
<ul>
<li>구조체, 열거형, 공용체, 그리고 튜플은 모든 필드가 해당 트레잇을 구현하면 이를 구현합니다.</li>
</ul>
<div class="rule" id="r-lang-types.auto-traits.closure"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.closure" title="lang-types.auto-traits.closure"><span>[lang-types<wbr>.auto-traits<wbr>.closure]<span/></a></div>
<ul>
<li>클로저는 캡처한 모든 것의 타입이 해당 트레잇을 구현하면 이를 구현합니다. <code>T</code>를 공유 참조로 캡처하고 <code>U</code>를 값으로 캡처하는 클로저는 <code>&amp;T</code>와 <code>U</code>가 모두 구현하는 자동 트레잇들을 구현합니다.</li>
</ul>
<div class="rule" id="r-lang-types.auto-traits.generic-impl"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.generic-impl" title="lang-types.auto-traits.generic-impl"><span>[lang-types<wbr>.auto-traits<wbr>.generic-impl]<span/></a></div>
<p>제네릭 타입의 경우 (위의 내장 타입들도 <code>T</code>에 대한 제네릭으로 간주함), 제네릭 구현이 가능하다면 컴파일러는 필요한 트레잇 바운드를 충족하지 못해 해당 구현을 사용할 수 없는 타입들에 대해 자동으로 이를 구현하지 않습니다. 예를 들어, 표준 라이브러리는 <code>T</code>가 <code>Sync</code>인 모든 <code>&amp;T</code>에 대해 <code>Send</code>를 구현합니다. 이는 <code>T</code>가 <code>Send</code>이지만 <code>Sync</code>가 아닌 경우 컴파일러가 <code>&amp;T</code>에 대해 <code>Send</code>를 구현하지 않음을 의미합니다.</p>
<div class="rule" id="r-lang-types.auto-traits.negative"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.negative" title="lang-types.auto-traits.negative"><span>[lang-types<wbr>.auto-traits<wbr>.negative]<span/></a></div>
<p>자동 트레잇은 또한 부정적인 구현을 가질 수 있으며, 이는 표준 라이브러리 문서에서 <code>impl !AutoTrait for T</code>로 표시되어 자동 구현을 재정의(override)합니다. 예를 들어 <code>*mut T</code>는 <code>Send</code>에 대한 부정적인 구현을 가지고 있으므로, <code>T</code>가 <code>Send</code>이더라도 <code>*mut T</code>는 <code>Send</code>가 아닙니다. 현재 추가적인 부정적인 구현을 지정하는 안정적인 방법은 없으며, 표준 라이브러리에만 존재합니다.</p>
<div class="rule" id="r-lang-types.auto-traits.trait-object-marker"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.auto-traits.trait-object-marker" title="lang-types.auto-traits.trait-object-marker"><span>[lang-types<wbr>.auto-traits<wbr>.trait-object-marker]<span/></a></div>
<p>자동 트레잇은 보통 하나의 트레잇만 허용되는 <a href="types/trait-object.html">트레잇 객체(trait object)</a>에도 추가적인 바운드로 추가될 수 있습니다. 예를 들어, <code>Box&lt;dyn Debug + Send + UnwindSafe&gt;</code>는 유효한 타입입니다.</p>
<div class="rule" id="r-lang-types.sized"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sized" title="lang-types.sized"><span>[lang-types<wbr>.sized]<span/></a></div>
<h2 id="sized-1"><a class="header" href="#sized-1"><code>Sized</code></a></h2>
<div class="rule" id="r-lang-types.sized.intro"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sized.intro" title="lang-types.sized.intro"><span>[lang-types<wbr>.sized<wbr>.intro]<span/></a></div>
<p><a href="../core/marker/trait.Sized.html"><code>Sized</code></a> 트레잇은 이 타입의 크기가 컴파일 타임에 알려져 있음을 나타냅니다. 즉, <a href="dynamically-sized-types.html">동적 크기 타입(dynamically sized type)</a>이 아님을 의미합니다.</p>
<div class="rule" id="r-lang-types.sized.implicit-sized"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sized.implicit-sized" title="lang-types.sized.implicit-sized"><span>[lang-types<wbr>.sized<wbr>.implicit-sized]<span/></a></div>
<p><a href="types/parameters.html">타입 파라미터(Type parameters)</a> (트레잇의 <code>Self</code> 제외)와 <a href="items/associated-items.html#associated-types">연관 타입(associated types)</a>은 기본적으로 <code>Sized</code>입니다.</p>
<div class="rule" id="r-lang-types.sized.implicit-impl"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sized.implicit-impl" title="lang-types.sized.implicit-impl"><span>[lang-types<wbr>.sized<wbr>.implicit-impl]<span/></a></div>
<p><code>Sized</code>는 항상 <a href="items/implementations.html">구현 아이템(implementation items)</a>이 아니라 컴파일러에 의해 자동으로 구현됩니다.</p>
<div class="rule" id="r-lang-types.sized.relaxation"><a class="rule-link" href="special-types-and-traits.html#r-lang-types.sized.relaxation" title="lang-types.sized.relaxation"><span>[lang-types<wbr>.sized<wbr>.relaxation]<span/></a></div>
<p>이러한 암시적인 <code>Sized</code> 바운드는 특별한 <code>?Sized</code> 바운드를 사용하여 완화될 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-names"><a class="rule-link" href="names.html#r-names" title="names"><span>[names]<span/></a></div>
<h1 id="이름"><a class="header" href="#이름">이름</a></h1>
<div class="rule" id="r-names.intro"><a class="rule-link" href="names.html#r-names.intro" title="names.intro"><span>[names<wbr>.intro]<span/></a></div>
<p>_엔티티(entity)_는 소스 프로그램 내에서 어떤 방식으로든(보통 <a href="paths.html">경로(path)</a>를 통해) 참조될 수 있는 언어 구성 요소입니다. 엔티티에는 <a href="types.html">타입</a>, <a href="items.html">아이템</a>, <a href="items/generics.html">제네릭 파라미터</a>, <a href="patterns.html">변수 바인딩</a>, <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a>, <a href="tokens.html#lifetimes-and-loop-labels">라이프타임</a>, <a href="expressions/field-expr.html">필드</a>, <a href="attributes.html">속성(attributes)</a>, 그리고 <a href="attributes/diagnostics.html#lint-check-attributes">린트(lints)</a>가 포함됩니다.</p>
<div class="rule" id="r-names.decl"><a class="rule-link" href="names.html#r-names.decl" title="names.decl"><span>[names<wbr>.decl]<span/></a></div>
<p>_선언(declaration)_은 엔티티를 참조하기 위한 _이름_을 도입할 수 있는 구문론적 구성 요소입니다. 엔티티 이름은 <a href="names/scopes.html"><em>스코프(scope)</em></a>(해당 이름이 참조될 수 있는 소스 텍스트의 영역) 내에서 유효합니다.</p>
<div class="rule" id="r-names.explicit-decl"><a class="rule-link" href="names.html#r-names.explicit-decl" title="names.explicit-decl"><span>[names<wbr>.explicit-decl]<span/></a></div>
<p>일부 엔티티는 소스 코드에서 <a href="names.html#explicitly-declared-entities">명시적으로 선언</a>되며, 일부는 언어의 일부나 컴파일러 확장의 일환으로 <a href="names.html#implicitly-declared-entities">암시적으로 선언</a>됩니다.</p>
<div class="rule" id="r-names.path"><a class="rule-link" href="names.html#r-names.path" title="names.path"><span>[names<wbr>.path]<span/></a></div>
<p><a href="paths.html"><em>경로(Paths)</em></a>는 엔티티(다른 모듈이나 타입에 있을 수 있음)를 참조하는 데 사용됩니다.</p>
<div class="rule" id="r-names.lifetime"><a class="rule-link" href="names.html#r-names.lifetime" title="names.lifetime"><span>[names<wbr>.lifetime]<span/></a></div>
<p>라이프타임과 루프 레이블은 앞에 따옴표가 붙는 <a href="tokens.html#lifetimes-and-loop-labels">전용 구문</a>을 사용합니다.</p>
<div class="rule" id="r-names.namespace"><a class="rule-link" href="names.html#r-names.namespace" title="names.namespace"><span>[names<wbr>.namespace]<span/></a></div>
<p>이름은 서로 다른 <a href="names/namespaces.html"><em>네임스페이스(namespaces)</em></a>로 격리되어, 서로 다른 네임스페이스에 있는 엔티티들이 충돌 없이 동일한 이름을 공유할 수 있게 합니다.</p>
<div class="rule" id="r-names.resolution"><a class="rule-link" href="names.html#r-names.resolution" title="names.resolution"><span>[names<wbr>.resolution]<span/></a></div>
<p><a href="names/name-resolution.html"><em>이름 확인(Name resolution)</em></a>은 경로, 식별자, 레이블을 엔티티 선언에 연결하는 컴파일 타임 프로세스입니다.</p>
<div class="rule" id="r-names.visibility"><a class="rule-link" href="names.html#r-names.visibility" title="names.visibility"><span>[names<wbr>.visibility]<span/></a></div>
<p>특정 이름에 대한 접근은 해당 이름의 <a href="visibility-and-privacy.html"><em>가시성(visibility)</em></a>에 따라 제한될 수 있습니다.</p>
<div class="rule" id="r-names.explicit"><a class="rule-link" href="names.html#r-names.explicit" title="names.explicit"><span>[names<wbr>.explicit]<span/></a></div>
<h2 id="명시적으로-선언된-엔티티"><a class="header" href="#명시적으로-선언된-엔티티">명시적으로 선언된 엔티티</a></h2>
<div class="rule" id="r-names.explicit.list"><a class="rule-link" href="names.html#r-names.explicit.list" title="names.explicit.list"><span>[names<wbr>.explicit<wbr>.list]<span/></a></div>
<p>소스 코드에서 명시적으로 이름을 도입하는 엔티티는 다음과 같습니다.</p>
<div class="rule" id="r-names.explicit.item-decl"><a class="rule-link" href="names.html#r-names.explicit.item-decl" title="names.explicit.item-decl"><span>[names<wbr>.explicit<wbr>.item-decl]<span/></a></div>
<ul>
<li><a href="items.html">아이템(Items)</a>:
<ul>
<li><a href="items/modules.html">모듈 선언</a></li>
<li><a href="items/extern-crates.html">외부 크레이트 선언</a></li>
<li><a href="items/use-declarations.html">Use 선언</a></li>
<li><a href="items/functions.html">함수 선언</a> 및 <a href="items/functions.html#function-parameters">함수 매개변수</a></li>
<li><a href="items/type-aliases.html">타입 별칭</a></li>
<li><a href="items/structs.html">구조체</a>, <a href="items/unions.html">공용체</a>, <a href="items/enumerations.html">열거형</a>, 열거형 변형 선언 및 이름 있는 필드들</li>
<li><a href="items/constant-items.html">상수 아이템 선언</a></li>
<li><a href="items/static-items.html">정적 아이템 선언</a></li>
<li><a href="items/traits.html">트레잇 아이템 선언</a> 및 <a href="items/associated-items.html">연관 아이템</a></li>
<li><a href="items/external-blocks.html">외부 블록 아이템</a></li>
<li><a href="macros-by-example.html"><code>macro_rules</code> 선언</a> 및 <a href="macros-by-example.html#metavariables">매처 메타변수</a></li>
<li><a href="items/implementations.html">구현</a> 연관 아이템</li>
</ul>
</li>
</ul>
<div class="rule" id="r-names.explicit.expr"><a class="rule-link" href="names.html#r-names.explicit.expr" title="names.explicit.expr"><span>[names<wbr>.explicit<wbr>.expr]<span/></a></div>
<ul>
<li><a href="expressions.html">표현식</a>:
<ul>
<li><a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 패턴 바인딩</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a> 패턴 바인딩</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 패턴 바인딩</li>
<li><a href="expressions/match-expr.html"><code>match</code></a> 패턴 바인딩</li>
<li><a href="expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-names.explicit.generics"><a class="rule-link" href="names.html#r-names.explicit.generics" title="names.explicit.generics"><span>[names<wbr>.explicit<wbr>.generics]<span/></a></div>
<ul>
<li><a href="items/generics.html">제네릭 파라미터</a></li>
</ul>
<div class="rule" id="r-names.explicit.higher-ranked-bounds"><a class="rule-link" href="names.html#r-names.explicit.higher-ranked-bounds" title="names.explicit.higher-ranked-bounds"><span>[names<wbr>.explicit<wbr>.higher-ranked-bounds]<span/></a></div>
<ul>
<li><a href="trait-bounds.html#higher-ranked-trait-bounds">고차 트레잇 바운드</a></li>
</ul>
<div class="rule" id="r-names.explicit.binding"><a class="rule-link" href="names.html#r-names.explicit.binding" title="names.explicit.binding"><span>[names<wbr>.explicit<wbr>.binding]<span/></a></div>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 문</a> 패턴 바인딩</li>
</ul>
<div class="rule" id="r-names.explicit.macro_use"><a class="rule-link" href="names.html#r-names.explicit.macro_use" title="names.explicit.macro_use"><span>[names<wbr>.explicit<wbr>.macro_use]<span/></a></div>
<ul>
<li><code>macro_use</code> 속성](macros-by-example.md#the-macro_use-attribute)은 다른 크레이트에서 매크로 이름을 가져올 수 있습니다.</li>
</ul>
<div class="rule" id="r-names.explicit.macro_export"><a class="rule-link" href="names.html#r-names.explicit.macro_export" title="names.explicit.macro_export"><span>[names<wbr>.explicit<wbr>.macro_export]<span/></a></div>
<ul>
<li><code>macro_export</code> 속성](macros-by-example.md#path-based-scope)은 크레이트 루트에 매크로 별칭을 도입할 수 있습니다.</li>
</ul>
<div class="rule" id="r-names.explicit.macro-invocation"><a class="rule-link" href="names.html#r-names.explicit.macro-invocation" title="names.explicit.macro-invocation"><span>[names<wbr>.explicit<wbr>.macro-invocation]<span/></a></div>
<p>또한, <a href="macros.html#macro-invocation">매크로 호출</a> 및 <a href="attributes.html">속성</a>은 위의 항목 중 하나로 확장되어 이름을 도입할 수 있습니다.</p>
<div class="rule" id="r-names.implicit"><a class="rule-link" href="names.html#r-names.implicit" title="names.implicit"><span>[names<wbr>.implicit]<span/></a></div>
<h2 id="암시적으로-선언된-엔티티"><a class="header" href="#암시적으로-선언된-엔티티">암시적으로 선언된 엔티티</a></h2>
<div class="rule" id="r-names.implicit.list"><a class="rule-link" href="names.html#r-names.implicit.list" title="names.implicit.list"><span>[names<wbr>.implicit<wbr>.list]<span/></a></div>
<p>다음 엔티티들은 언어에 의해 암시적으로 정의되거나, 컴파일러 옵션 및 확장 기능을 통해 도입됩니다.</p>
<div class="rule" id="r-names.implicit.primitive-types"><a class="rule-link" href="names.html#r-names.implicit.primitive-types" title="names.implicit.primitive-types"><span>[names<wbr>.implicit<wbr>.primitive-types]<span/></a></div>
<ul>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a>:
<ul>
<li><a href="types/boolean.html">불리언 타입</a> — <code>bool</code></li>
<li><a href="types/textual.html">텍스트 타입</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="types/numeric.html#integer-types">정수 타입</a> — <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><a href="types/numeric.html#machine-dependent-integer-types">머신 의존적 정수 타입</a> — <code>usize</code> 및 <code>isize</code></li>
<li><a href="types/numeric.html#floating-point-types">부동 소수점 타입</a> — <code>f32</code> 및 <code>f64</code></li>
</ul>
</li>
</ul>
<div class="rule" id="r-names.implicit.builtin-attributes"><a class="rule-link" href="names.html#r-names.implicit.builtin-attributes" title="names.implicit.builtin-attributes"><span>[names<wbr>.implicit<wbr>.builtin-attributes]<span/></a></div>
<ul>
<li><a href="attributes.html#built-in-attributes-index">내장 속성</a></li>
</ul>
<div class="rule" id="r-names.implicit.prelude"><a class="rule-link" href="names.html#r-names.implicit.prelude" title="names.implicit.prelude"><span>[names<wbr>.implicit<wbr>.prelude]<span/></a></div>
<ul>
<li><a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a> 아이템, 속성 및 매크로</li>
</ul>
<div class="rule" id="r-names.implicit.stdlib"><a class="rule-link" href="names.html#r-names.implicit.stdlib" title="names.implicit.stdlib"><span>[names<wbr>.implicit<wbr>.stdlib]<span/></a></div>
<ul>
<li>루트 모듈의 <a href="names/preludes.html#extern-prelude">표준 라이브러리</a> 크레이트</li>
</ul>
<div class="rule" id="r-names.implicit.extern-prelude"><a class="rule-link" href="names.html#r-names.implicit.extern-prelude" title="names.implicit.extern-prelude"><span>[names<wbr>.implicit<wbr>.extern-prelude]<span/></a></div>
<ul>
<li>컴파일러에 의해 링크된 <a href="names/preludes.html#extern-prelude">외부 크레이트</a></li>
</ul>
<div class="rule" id="r-names.implicit.tool-attributes"><a class="rule-link" href="names.html#r-names.implicit.tool-attributes" title="names.implicit.tool-attributes"><span>[names<wbr>.implicit<wbr>.tool-attributes]<span/></a></div>
<ul>
<li><a href="attributes.html#tool-attributes">도구 속성</a></li>
</ul>
<div class="rule" id="r-names.implicit.lints"><a class="rule-link" href="names.html#r-names.implicit.lints" title="names.implicit.lints"><span>[names<wbr>.implicit<wbr>.lints]<span/></a></div>
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes">린트</a> 및 <a href="attributes/diagnostics.html#tool-lint-attributes">도구 린트 속성</a></li>
</ul>
<div class="rule" id="r-names.implicit.derive-helpers"><a class="rule-link" href="names.html#r-names.implicit.derive-helpers" title="names.implicit.derive-helpers"><span>[names<wbr>.implicit<wbr>.derive-helpers]<span/></a></div>
<ul>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">Derive 헬퍼 속성</a>은 명시적으로 가져오지 않아도 아이템 내에서 유효합니다.</li>
</ul>
<div class="rule" id="r-names.implicit.lifetime-static"><a class="rule-link" href="names.html#r-names.implicit.lifetime-static" title="names.implicit.lifetime-static"><span>[names<wbr>.implicit<wbr>.lifetime-static]<span/></a></div>
<ul>
<li><a href="keywords.html#weak-keywords"><code>'static</code></a> 라이프타임</li>
</ul>
<div class="rule" id="r-names.implicit.root"><a class="rule-link" href="names.html#r-names.implicit.root" title="names.implicit.root"><span>[names<wbr>.implicit<wbr>.root]<span/></a></div>
<p>또한, 크레이트 루트 모듈은 이름을 가지지 않지만, 특정 <a href="paths.html#path-qualifiers">경로 한정자</a>나 별칭을 통해 참조될 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-names.namespaces"><a class="rule-link" href="names/namespaces.html#r-names.namespaces" title="names.namespaces"><span>[names<wbr>.namespaces]<span/></a></div>
<h1 id="네임스페이스"><a class="header" href="#네임스페이스">네임스페이스</a></h1>
<div class="rule" id="r-names.namespaces.intro"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.intro" title="names.namespaces.intro"><span>[names<wbr>.namespaces<wbr>.intro]<span/></a></div>
<p>_네임스페이스_는 선언된 <a href="names/../names.html">이름</a>의 논리적 그룹입니다. 이름은 해당 이름이 참조하는 엔티티의 종류에 따라 별도의 네임스페이스로 분리됩니다. 네임스페이스를 사용하면 한 네임스페이스에 있는 이름이 다른 네임스페이스에 있는 같은 이름과 충돌하지 않습니다.</p>
<p>각각 다른 종류의 엔티티를 포함하는 여러 가지 네임스페이스가 있습니다. 이름의 사용은 <a href="names/name-resolution.html">이름 해석</a> 장에서 설명한 대로 문맥에 따라 다른 네임스페이스에서 해당 이름의 선언을 찾습니다.</p>
<div class="rule" id="r-names.namespaces.kinds"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.kinds" title="names.namespaces.kinds"><span>[names<wbr>.namespaces<wbr>.kinds]<span/></a></div>
<p>다음은 네임스페이스와 그에 해당하는 엔티티의 목록입니다:</p>
<ul>
<li>타입 네임스페이스
<ul>
<li><a href="names/../items/modules.html">모듈 선언</a></li>
<li><a href="names/../items/extern-crates.html">외부 크레이트 선언</a></li>
<li><a href="names/preludes.html#extern-prelude">외부 크레이트 프렐류드</a> 아이템</li>
<li><a href="names/../items/structs.html">구조체</a>, <a href="names/../items/unions.html">공용체</a>, <a href="names/../items/enumerations.html">열거형</a>, 열거형 변형 선언</li>
<li><a href="names/../items/traits.html">트레잇 아이템 선언</a></li>
<li><a href="names/../items/type-aliases.html">타입 별칭</a></li>
<li><a href="names/../items/associated-items.html#associated-types">연관 타입 선언</a></li>
<li>내장 타입: <a href="names/../types/boolean.html">불리언</a>, <a href="names/../types/numeric.html">숫자</a>, <a href="names/../types/textual.html">텍스트</a></li>
<li><a href="names/../items/generics.html">제네릭 타입 매개변수</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 타입</a></li>
<li><a href="names/../attributes.html#tool-attributes">도구 속성 모듈</a></li>
</ul>
</li>
<li>값 네임스페이스
<ul>
<li><a href="names/../items/functions.html">함수 선언</a></li>
<li><a href="names/../items/constant-items.html">상수 아이템 선언</a></li>
<li><a href="names/../items/static-items.html">정적 아이템 선언</a></li>
<li><a href="names/../items/structs.html">구조체 생성자</a></li>
<li><a href="names/../items/enumerations.html">열거형 변형 생성자</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 생성자</a></li>
<li><a href="names/../items/generics.html#const-generics">제네릭 상수 매개변수</a></li>
<li><a href="names/../items/associated-items.html#associated-constants">연관 상수 선언</a></li>
<li><a href="names/../items/associated-items.html#associated-functions-and-methods">연관 함수 선언</a></li>
<li>지역 바인딩 — <a href="names/../statements.html#let-statements"><code>let</code></a>, <a href="names/../expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="names/../expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>, <a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code></a>, <a href="names/../expressions/match-expr.html"><code>match</code></a> 분기, <a href="names/../items/functions.html#function-parameters">함수 매개변수</a>, <a href="names/../expressions/closure-expr.html">클로저 매개변수</a></li>
<li>캡처된 <a href="names/../expressions/closure-expr.html">클로저</a> 변수</li>
</ul>
</li>
<li>매크로 네임스페이스
<ul>
<li><a href="names/../macros-by-example.html"><code>macro_rules</code> 선언</a></li>
<li><a href="names/../attributes.html#built-in-attributes-index">내장 속성</a></li>
<li><a href="names/../attributes.html#tool-attributes">도구 속성</a></li>
<li><a href="names/../procedural-macros.html#function-like-procedural-macros">함수형 절차적 매크로</a></li>
<li><a href="names/../procedural-macros.html#derive-macros">Derive 매크로</a></li>
<li><a href="names/../procedural-macros.html#derive-macro-helper-attributes">Derive 매크로 도우미</a></li>
<li><a href="names/../procedural-macros.html#attribute-macros">속성 매크로</a></li>
</ul>
</li>
<li>라이프타임 네임스페이스
<ul>
<li><a href="names/../items/generics.html">제네릭 라이프타임 매개변수</a></li>
</ul>
</li>
<li>레이블 네임스페이스
<ul>
<li><a href="names/../expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
<li><a href="names/../expressions/loop-expr.html#labelled-block-expressions">블록 레이블</a></li>
</ul>
</li>
</ul>
<p>다른 네임스페이스에서 겹치는 이름을 모호하지 않게 사용하는 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Foo는 타입 네임스페이스에 타입을 도입하고 값 네임스페이스에
// 생성자를 도입합니다.
struct Foo(u32);

// `Foo` 매크로는 매크로 네임스페이스에 선언됩니다.
macro_rules! Foo {
    () =&gt; {};
}

// `f` 매개변수 타입의 `Foo`는 타입 네임스페이스의 `Foo`를 참조합니다.
// `'Foo`는 라이프타임 네임스페이스에 새로운 라이프타임을 도입합니다.
fn example&lt;'Foo&gt;(f: Foo) {
    // `Foo`는 값 네임스페이스의 `Foo` 생성자를 참조합니다.
    let ctor = Foo;
    // `Foo`는 매크로 네임스페이스의 `Foo` 매크로를 참조합니다.
    Foo!{}
    // `'Foo`는 레이블 네임스페이스에 레이블을 도입합니다.
    'Foo: loop {
        // `'Foo`는 `'Foo` 라이프타임 매개변수를 참조하며, `Foo`는
        // 타입 네임스페이스를 참조합니다.
        let x: &amp;'Foo Foo;
        // `'Foo`는 레이블을 참조합니다.
        break 'Foo;
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.namespaces.without"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.without" title="names.namespaces.without"><span>[names<wbr>.namespaces<wbr>.without]<span/></a></div>
<h2 id="네임스페이스가-없는-명명된-엔터티"><a class="header" href="#네임스페이스가-없는-명명된-엔터티">네임스페이스가 없는 명명된 엔터티</a></h2>
<p>다음 엔터티는 명시적인 이름을 가지고 있지만, 그 이름은 특정 네임스페이스의 일부가 아닙니다.</p>
<h3 id="필드"><a class="header" href="#필드">필드</a></h3>
<div class="rule" id="r-names.namespaces.without.fields"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.without.fields" title="names.namespaces.without.fields"><span>[names<wbr>.namespaces<wbr>.without<wbr>.fields]<span/></a></div>
<p>구조체, 열거형 및 유니온 필드에 이름이 지정되어 있더라도, 명명된 필드는 명시적 네임스페이스에 존재하지 않습니다. 이들은 <a href="names/../expressions/field-expr.html">필드 표현식</a>을 통해서만 접근할 수 있으며, 이는 접근하려는 특정 타입의 필드 이름만 검사합니다.</p>
<h3 id="use-선언-1"><a class="header" href="#use-선언-1">Use 선언</a></h3>
<div class="rule" id="r-names.namespaces.without.use"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.without.use" title="names.namespaces.without.use"><span>[names<wbr>.namespaces<wbr>.without<wbr>.use]<span/></a></div>
<p><a href="names/../items/use-declarations.html">Use 선언</a>은 스코프로 가져오는 명명된 별칭을 가지지만, <code>use</code> 아이템 자체는 특정 네임스페이스에 속하지 않습니다. 대신, 가져오는 아이템 종류에 따라 여러 네임스페이스에 별칭을 도입할 수 있습니다.</p>
<div class="rule" id="r-names.namespaces.sub-namespaces"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.sub-namespaces" title="names.namespaces.sub-namespaces"><span>[names<wbr>.namespaces<wbr>.sub-namespaces]<span/></a></div>
<h2 id="서브-네임스페이스"><a class="header" href="#서브-네임스페이스">서브 네임스페이스</a></h2>
<div class="rule" id="r-names.namespaces.sub-namespaces.intro"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.sub-namespaces.intro" title="names.namespaces.sub-namespaces.intro"><span>[names<wbr>.namespaces<wbr>.sub-namespaces<wbr>.intro]<span/></a></div>
<p>매크로 네임스페이스는 두 개의 서브 네임스페이스로 나뉩니다: 하나는 <a href="names/../macros.html">느낌표 스타일 매크로</a>용이고 다른 하나는 <a href="names/../attributes.html">속성</a>용입니다. 속성이 확인될 때, 스코프 내의 느낌표 스타일 매크로는 무시됩니다. 반대로 느낌표 스타일 매크로를 확인할 때는 스코프 내의 속성 매크로가 무시됩니다. 이는 한 스타일이 다른 스타일을 가리는 것을 방지합니다.</p>
<p>예를 들어, <a href="names/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a>과 <a href="names/../conditional-compilation.html#the-cfg-macro"><code>cfg</code> 매크로</a>는 매크로 네임스페이스에서 같은 이름을 가진 서로 다른 두 엔터티이지만, 여전히 각각의 컨텍스트에서 사용할 수 있습니다.</p>
<div class="rule" id="r-names.namespaces.sub-namespaces.use-shadow"><a class="rule-link" href="names/namespaces.html#r-names.namespaces.sub-namespaces.use-shadow" title="names.namespaces.sub-namespaces.use-shadow"><span>[names<wbr>.namespaces<wbr>.sub-namespaces<wbr>.use-shadow]<span/></a></div>
<p>서브 네임스페이스와 관계없이 <a href="names/../items/use-declarations.html"><code>use</code> 임포트</a>가 다른 매크로를 가리는 것은 여전히 오류입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-names.scopes"><a class="rule-link" href="names/scopes.html#r-names.scopes" title="names.scopes"><span>[names<wbr>.scopes]<span/></a></div>
<h1 id="스코프"><a class="header" href="#스코프">스코프</a></h1>
<div class="rule" id="r-names.scopes.intro"><a class="rule-link" href="names/scopes.html#r-names.scopes.intro" title="names.scopes.intro"><span>[names<wbr>.scopes<wbr>.intro]<span/></a></div>
<p>_스코프_는 명명된 <a href="names/../names.html">엔터티</a>가 해당 이름으로 참조될 수 있는 소스 텍스트 영역입니다. 다음 섹션에서는 엔터티의 종류와 선언된 위치에 따라 달라지는 스코핑 규칙 및 동작에 대한 세부 정보를 제공합니다. 이름이 엔터티로 확인되는 과정은 <a href="names/name-resolution.html">이름 확인</a> 장에 설명되어 있습니다. 소멸자를 실행하기 위해 사용되는 “드롭 스코프“에 대한 자세한 정보는 <a href="names/../destructors.html">소멸자</a> 장에서 찾을 수 있습니다.</p>
<div class="rule" id="r-names.scopes.items"><a class="rule-link" href="names/scopes.html#r-names.scopes.items" title="names.scopes.items"><span>[names<wbr>.scopes<wbr>.items]<span/></a></div>
<h2 id="아이템-스코프"><a class="header" href="#아이템-스코프">아이템 스코프</a></h2>
<div class="rule" id="r-names.scopes.items.module"><a class="rule-link" href="names/scopes.html#r-names.scopes.items.module" title="names.scopes.items.module"><span>[names<wbr>.scopes<wbr>.items<wbr>.module]<span/></a></div>
<p><a href="names/../items/modules.html">모듈</a>에 직접 선언된 <a href="names/../items.html">아이템</a>의 이름은 모듈의 시작부터 모듈의 끝까지 확장되는 스코프를 가집니다. 이 아이템들은 또한 모듈의 멤버이며 해당 모듈에서 이어지는 <a href="names/../paths.html">경로</a>로 참조할 수 있습니다.</p>
<div class="rule" id="r-names.scopes.items.statement"><a class="rule-link" href="names/scopes.html#r-names.scopes.items.statement" title="names.scopes.items.statement"><span>[names<wbr>.scopes<wbr>.items<wbr>.statement]<span/></a></div>
<p><a href="names/../statements.html">구문</a>으로 선언된 아이템의 이름은 아이템 구문이 있는 블록의 시작부터 블록의 끝까지 확장되는 스코프를 가집니다.</p>
<div class="rule" id="r-names.scopes.items.duplicate"><a class="rule-link" href="names/scopes.html#r-names.scopes.items.duplicate" title="names.scopes.items.duplicate"><span>[names<wbr>.scopes<wbr>.items<wbr>.duplicate]<span/></a></div>
<p>동일한 모듈이나 블록 내의 동일한 <a href="names/namespaces.html">네임스페이스</a>에 있는 다른 아이템과 중복된 이름으로 아이템을 도입하는 것은 오류입니다. <a href="names/../items/use-declarations.html">별표 글롭 임포트</a>는 중복된 이름과 가림을 처리하는 데 특별한 동작을 가지고 있으며, 자세한 내용은 링크된 장을 참조하십시오.</p>
<div class="rule" id="r-names.scopes.items.shadow-prelude"><a class="rule-link" href="names/scopes.html#r-names.scopes.items.shadow-prelude" title="names.scopes.items.shadow-prelude"><span>[names<wbr>.scopes<wbr>.items<wbr>.shadow-prelude]<span/></a></div>
<p>모듈의 아이템은 <a href="names/scopes.html#prelude-scopes">프렐류드</a>의 아이템을 가릴 수 있습니다.</p>
<div class="rule" id="r-names.scopes.items.nested-modules"><a class="rule-link" href="names/scopes.html#r-names.scopes.items.nested-modules" title="names.scopes.items.nested-modules"><span>[names<wbr>.scopes<wbr>.items<wbr>.nested-modules]<span/></a></div>
<p>외부 모듈의 아이템 이름은 중첩된 모듈 내의 스코프에 없습니다. <a href="names/../paths.html">경로</a>를 사용하여 다른 모듈의 아이템을 참조할 수 있습니다.</p>
<div class="rule" id="r-names.scopes.associated-items"><a class="rule-link" href="names/scopes.html#r-names.scopes.associated-items" title="names.scopes.associated-items"><span>[names<wbr>.scopes<wbr>.associated-items]<span/></a></div>
<h3 id="연관-아이템-스코프"><a class="header" href="#연관-아이템-스코프">연관 아이템 스코프</a></h3>
<div class="rule" id="r-names.scopes.associated-items.scope"><a class="rule-link" href="names/scopes.html#r-names.scopes.associated-items.scope" title="names.scopes.associated-items.scope"><span>[names<wbr>.scopes<wbr>.associated-items<wbr>.scope]<span/></a></div>
<p><a href="names/../items/associated-items.html">연관 아이템</a>은 스코프가 지정되지 않으며 연관된 타입이나 트레잇에서 이어지는 <a href="names/../paths.html">경로</a>를 사용해야만 참조할 수 있습니다. <a href="names/../items/associated-items.html#methods">메서드</a>는 <a href="names/../expressions/call-expr.html">호출 표현식</a>을 통해서도 참조할 수 있습니다.</p>
<div class="rule" id="r-names.scopes.associated-items.duplicate"><a class="rule-link" href="names/scopes.html#r-names.scopes.associated-items.duplicate" title="names.scopes.associated-items.duplicate"><span>[names<wbr>.scopes<wbr>.associated-items<wbr>.duplicate]<span/></a></div>
<p>모듈이나 블록 내의 아이템과 마찬가지로, 동일한 네임스페이스의 트레잇이나 구현 내에 다른 아이템과 중복되는 아이템을 트레잇이나 구현 내에 도입하는 것은 오류입니다.</p>
<div class="rule" id="r-names.scopes.pattern-bindings"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings" title="names.scopes.pattern-bindings"><span>[names<wbr>.scopes<wbr>.pattern-bindings]<span/></a></div>
<h2 id="패턴-바인딩-스코프"><a class="header" href="#패턴-바인딩-스코프">패턴 바인딩 스코프</a></h2>
<p>지역 변수 <a href="names/../patterns.html">패턴</a> 바인딩의 스코프는 사용되는 위치에 따라 다릅니다:</p>
<div class="rule" id="r-names.scopes.pattern-bindings.let"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.let" title="names.scopes.pattern-bindings.let"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.let]<span/></a></div>
<ul>
<li><a href="names/../statements.html#let-statements"><code>let</code> 구문</a> 바인딩은 <code>let</code> 구문 바로 뒤부터 선언된 블록의 끝까지 범위가 지정됩니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.parameter"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.parameter" title="names.scopes.pattern-bindings.parameter"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.parameter]<span/></a></div>
<ul>
<li><a href="names/../items/functions.html#function-parameters">함수 매개변수</a> 바인딩은 함수 본문 내에 있습니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.closure"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.closure" title="names.scopes.pattern-bindings.closure"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.closure]<span/></a></div>
<ul>
<li><a href="names/../expressions/closure-expr.html">클로저 매개변수</a> 바인딩은 클로저 본문 내에 있습니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.loop"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.loop" title="names.scopes.pattern-bindings.loop"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.loop]<span/></a></div>
<ul>
<li><a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code></a> 및 <a href="names/../expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 바인딩은 루프 본문 내에 있습니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.if-let"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.if-let" title="names.scopes.pattern-bindings.if-let"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.if-let]<span/></a></div>
<ul>
<li><a href="names/../expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 바인딩은 후속 블록 내에 있습니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.match-arm"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.match-arm" title="names.scopes.pattern-bindings.match-arm"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.match-arm]<span/></a></div>
<ul>
<li><a href="names/../expressions/match-expr.html"><code>match</code> 암</a> 바인딩은 <a href="names/../expressions/match-expr.html#match-guards">매치 가드</a> 및 매치 암 표현식 내에 있습니다.</li>
</ul>
<div class="rule" id="r-names.scopes.pattern-bindings.items"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.items" title="names.scopes.pattern-bindings.items"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.items]<span/></a></div>
<p>지역 변수 스코프는 아이템 선언으로 확장되지 않습니다.</p>
<!-- Not entirely, see https://github.com/rust-lang/rust/issues/33118 -->
<h3 id="패턴-바인딩-가림"><a class="header" href="#패턴-바인딩-가림">패턴 바인딩 가림</a></h3>
<div class="rule" id="r-names.scopes.pattern-bindings.shadow"><a class="rule-link" href="names/scopes.html#r-names.scopes.pattern-bindings.shadow" title="names.scopes.pattern-bindings.shadow"><span>[names<wbr>.scopes<wbr>.pattern-bindings<wbr>.shadow]<span/></a></div>
<p>패턴 바인딩은 오류인 다음 예외를 제외하고 스코프 내의 모든 이름을 가릴 수 있습니다:</p>
<ul>
<li><a href="names/../items/generics.html#const-generics">상수 제네릭 매개변수</a></li>
<li><a href="names/../items/static-items.html">정적 아이템</a></li>
<li><a href="names/../items/constant-items.html">상수 아이템</a></li>
<li><a href="names/../items/structs.html">구조체</a> 및 <a href="names/../items/enumerations.html">열거형</a>의 생성자</li>
</ul>
<p>다음 예제는 지역 바인딩이 아이템 선언을 어떻게 가릴 수 있는지 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shadow_example() {
    // 아직 스코프에 지역 변수가 없으므로, 이것은 함수로 확인됩니다.
    foo(); // `function` 출력
    let foo = || println!("클로저");
    fn foo() { println!("함수"); }
    // 아이템을 가리므로 이것은 지역 클로저로 확인됩니다.
    foo(); // `closure` 출력
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.generic-parameters"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters" title="names.scopes.generic-parameters"><span>[names<wbr>.scopes<wbr>.generic-parameters]<span/></a></div>
<h2 id="제네릭-매개변수-스코프"><a class="header" href="#제네릭-매개변수-스코프">제네릭 매개변수 스코프</a></h2>
<div class="rule" id="r-names.scopes.generic-parameters.param-list"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters.param-list" title="names.scopes.generic-parameters.param-list"><span>[names<wbr>.scopes<wbr>.generic-parameters<wbr>.param-list]<span/></a></div>
<p>제네릭 매개변수는 <a href="names/../items/generics.html"><em>제네릭매개변수</em></a> 목록에 선언됩니다. 제네릭 매개변수의 스코프는 그것이 선언된 아이템 내부입니다.</p>
<div class="rule" id="r-names.scopes.generic-parameters.order-independent"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters.order-independent" title="names.scopes.generic-parameters.order-independent"><span>[names<wbr>.scopes<wbr>.generic-parameters<wbr>.order-independent]<span/></a></div>
<p>모든 매개변수는 선언된 순서와 관계없이 제네릭 매개변수 목록 내에서 스코프에 있습니다. 다음은 매개변수가 선언되기 전에 참조될 수 있는 몇 가지 예시를 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 'b 바운드는 선언되기 전에 참조됩니다.
fn params_scope&lt;'a: 'b, 'b&gt;() {}

<span class="boring">trait SomeTrait&lt;const Z: usize&gt; {}
</span>// 상수 N은 선언되기 전에 트레잇 바운드에서 참조됩니다.
fn f&lt;T: SomeTrait&lt;N&gt;, const N: usize&gt;() {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.generic-parameters.bounds"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters.bounds" title="names.scopes.generic-parameters.bounds"><span>[names<wbr>.scopes<wbr>.generic-parameters<wbr>.bounds]<span/></a></div>
<p>제네릭 매개변수는 타입 바운드와 where 절에서도 스코프에 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait&lt;'a, T&gt; {}
</span>// `SomeTrait`의 &lt;'a, U&gt;는 `bounds_scope`의 'a와 U 매개변수를 참조합니다.
fn bounds_scope&lt;'a, T: SomeTrait&lt;'a, U&gt;, U&gt;() {}

fn where_scope&lt;'a, T, U&gt;()
    where T: SomeTrait&lt;'a, U&gt;
{}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.generic-parameters.inner-items"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters.inner-items" title="names.scopes.generic-parameters.inner-items"><span>[names<wbr>.scopes<wbr>.generic-parameters<wbr>.inner-items]<span/></a></div>
<p>함수 내부에 선언된 <a href="names/../items.html">아이템</a>이 외부 스코프의 제네릭 매개변수를 참조하는 것은 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;T&gt;() {
    fn inner(x: T) {} // 오류: 외부 함수의 제네릭 매개변수를 사용할 수 없습니다
}
<span class="boring">}</span></code></pre></pre>
<h3 id="제네릭-매개변수-가리기shadowing"><a class="header" href="#제네릭-매개변수-가리기shadowing">제네릭 매개변수 가리기(Shadowing)</a></h3>
<div class="rule" id="r-names.scopes.generic-parameters.shadow"><a class="rule-link" href="names/scopes.html#r-names.scopes.generic-parameters.shadow" title="names.scopes.generic-parameters.shadow"><span>[names<wbr>.scopes<wbr>.generic-parameters<wbr>.shadow]<span/></a></div>
<p>함수 내에 선언된 아이템이 함수의 제네릭 매개변수 이름을 가리는 것이 허용되는 경우를 제외하고, 제네릭 매개변수를 가리는 것은 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;'a, T, const N: usize&gt;() {
    // 함수 내의 아이템은 스코프 내의 제네릭 매개변수를 가릴 수 있습니다.
    fn inner_lifetime&lt;'a&gt;() {} // OK
    fn inner_type&lt;T&gt;() {} // OK
    fn inner_const&lt;const N: usize&gt;() {} // OK
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait&lt;'a, T, const N: usize&gt; {
    fn example_lifetime&lt;'a&gt;() {} // 오류: 'a는 이미 사용 중입니다
    fn example_type&lt;T&gt;() {} // 오류: T는 이미 사용 중입니다
    fn example_const&lt;const N: usize&gt;() {} // 오류: N은 이미 사용 중입니다
    fn example_mixed&lt;const T: usize&gt;() {} // 오류: T는 이미 사용 중입니다
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.lifetimes"><a class="rule-link" href="names/scopes.html#r-names.scopes.lifetimes" title="names.scopes.lifetimes"><span>[names<wbr>.scopes<wbr>.lifetimes]<span/></a></div>
<h3 id="라이프타임-스코프"><a class="header" href="#라이프타임-스코프">라이프타임 스코프</a></h3>
<p>라이프타임 매개변수는 <a href="names/../items/generics.html"><em>제네릭매개변수</em></a> 목록과 <a href="names/../trait-bounds.html#higher-ranked-trait-bounds">고차 트레잇 바운드</a>에서 선언됩니다.</p>
<div class="rule" id="r-names.scopes.lifetimes.special"><a class="rule-link" href="names/scopes.html#r-names.scopes.lifetimes.special" title="names.scopes.lifetimes.special"><span>[names<wbr>.scopes<wbr>.lifetimes<wbr>.special]<span/></a></div>
<p>‘static<code>라이프타임과 [플레이스홀더 라이프타임](../lifetime-elision.md)</code>’_`는 특별한 의미를 가지며 매개변수로 선언될 수 없습니다.</p>
<h4 id="라이프타임-제네릭-매개변수-스코프"><a class="header" href="#라이프타임-제네릭-매개변수-스코프">라이프타임 제네릭 매개변수 스코프</a></h4>
<div class="rule" id="r-names.scopes.lifetimes.generic"><a class="rule-link" href="names/scopes.html#r-names.scopes.lifetimes.generic" title="names.scopes.lifetimes.generic"><span>[names<wbr>.scopes<wbr>.lifetimes<wbr>.generic]<span/></a></div>
<p><a href="names/../items/constant-items.html">상수</a> 및 <a href="names/../items/static-items.html">정적</a> 아이템과 <a href="names/../const_eval.html#const-context">const 컨텍스트</a>는 오직 <code>'static</code> 라이프타임 참조만 허용하므로, 그 안에는 다른 어떤 라이프타임도 스코프에 있을 수 없습니다. <a href="names/../items/associated-items.html#associated-constants">연관 상수</a>는 트레잇이나 구현에 선언된 라이프타임을 참조하는 것을 허용합니다.</p>
<h4 id="고차-트레잇-바운드-스코프"><a class="header" href="#고차-트레잇-바운드-스코프">고차 트레잇 바운드 스코프</a></h4>
<div class="rule" id="r-names.scopes.lifetimes.higher-ranked"><a class="rule-link" href="names/scopes.html#r-names.scopes.lifetimes.higher-ranked" title="names.scopes.lifetimes.higher-ranked"><span>[names<wbr>.scopes<wbr>.lifetimes<wbr>.higher-ranked]<span/></a></div>
<p><a href="names/../trait-bounds.html#higher-ranked-trait-bounds">고차 트레잇 바운드</a>로 선언된 라이프타임 매개변수의 스코프는 그것이 사용되는 시나리오에 따라 다릅니다.</p>
<ul>
<li><a href="names/../items/generics.html"><em>타입바운드Where절항목</em></a>으로서 선언된 라이프타임은 타입과 타입 바운드 내에서 스코프에 있습니다.</li>
<li><a href="names/../trait-bounds.html"><em>트레잇바운드</em></a>으로서 선언된 라이프타임은 바운드 타입 경로 내에서 스코프에 있습니다.</li>
<li><a href="names/../types/function-pointer.html"><em>Bare함수타입</em></a>으로서 선언된 라이프타임은 함수 매개변수와 반환 타입 내에서 스코프에 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait&lt;'a&gt;{}
</span>
fn where_clause&lt;T&gt;()
    // 'a는 타입과 타입 바운드 모두에서 스코프에 있습니다.
    where for &lt;'a&gt; &amp;'a T: Trait&lt;'a&gt;
{}

fn bound&lt;T&gt;()
    // 'a는 바운드 내에서 스코프에 있습니다.
    where T: for &lt;'a&gt; Trait&lt;'a&gt;
{}

<span class="boring">struct Example&lt;'a&gt; {
</span><span class="boring">    field: &amp;'a u32
</span><span class="boring">}
</span>
// 'a는 매개변수와 반환 타입 모두에서 스코프에 있습니다.
type FnExample = for&lt;'a&gt; fn(x: Example&lt;'a&gt;) -&gt; Example&lt;'a&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="impl-트레잇-제약"><a class="header" href="#impl-트레잇-제약">Impl 트레잇 제약</a></h4>
<div class="rule" id="r-names.scopes.lifetimes.impl-trait"><a class="rule-link" href="names/scopes.html#r-names.scopes.lifetimes.impl-trait" title="names.scopes.lifetimes.impl-trait"><span>[names<wbr>.scopes<wbr>.lifetimes<wbr>.impl-trait]<span/></a></div>
<p><a href="names/../types/impl-trait.html">Impl 트레잇</a> 타입은 함수나 구현에 선언된 라이프타임만 참조할 수 있습니다.</p>
<!-- not able to demonstrate the scope error because the compiler panics
     https://github.com/rust-lang/rust/issues/67830
-->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait1 {
</span><span class="boring">    type Item;
</span><span class="boring">}
</span><span class="boring">trait Trait2&lt;'a&gt; {}
</span><span class="boring">
</span><span class="boring">struct Example;
</span><span class="boring">
</span><span class="boring">impl Trait1 for Example {
</span><span class="boring">    type Item = Element;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Element;
</span><span class="boring">impl&lt;'a&gt; Trait2&lt;'a&gt; for Element {}
</span><span class="boring">
</span>// 여기의 `impl Trait2`는 'b를 참조할 수 없지만 'a를 참조하는 것은
// 허용됩니다.
fn foo&lt;'a&gt;() -&gt; impl for&lt;'b&gt; Trait1&lt;Item = impl Trait2&lt;'a&gt; + use&lt;'a&gt;&gt; {
    // ...
<span class="boring">   Example
</span>}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.loop-label"><a class="rule-link" href="names/scopes.html#r-names.scopes.loop-label" title="names.scopes.loop-label"><span>[names<wbr>.scopes<wbr>.loop-label]<span/></a></div>
<h2 id="루프-레이블-스코프"><a class="header" href="#루프-레이블-스코프">루프 레이블 스코프</a></h2>
<div class="rule" id="r-names.scopes.loop-label.scope"><a class="rule-link" href="names/scopes.html#r-names.scopes.loop-label.scope" title="names.scopes.loop-label.scope"><span>[names<wbr>.scopes<wbr>.loop-label<wbr>.scope]<span/></a></div>
<p><a href="names/../expressions/loop-expr.html#loop-labels">루프 레이블</a>은 <a href="names/../expressions/loop-expr.html">루프 표현식</a>에 의해 선언될 수 있습니다. 루프 레이블의 스코프는 선언된 지점부터 루프 표현식이 끝날 때까지입니다. 스코프는 <a href="names/../items.html">아이템</a>, <a href="names/../expressions/closure-expr.html">클로저</a>, <a href="names/../expressions/block-expr.html#async-blocks">비동기 블록</a>, <a href="names/../items/generics.html#const-generics">상수 인수</a>, <a href="names/../const_eval.html#const-context">const 컨텍스트</a>, 그리고 정의하는 <a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code> 루프</a>의 반복자 표현식으로 확장되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: for n in 0..3 {
    if n % 2 == 0 {
        break 'a;
    }
    fn inner() {
        // 여기서 'a를 사용하는 것은 오류입니다.
        // break 'a;
    }
}

// 레이블은 `while` 루프의 표현식에 대한 스코프에 있습니다.
'a: while break 'a {}         // 루프가 실행되지 않습니다.
'a: while let _ = break 'a {} // 루프가 실행되지 않습니다.

// 레이블은 정의하는 `for` 루프에서 스코프에 있지 않습니다:
'a: for outer in 0..5 {
    // 이것은 외부 루프를 중단하여 내부 루프를 건너뛰고
    // 외부 루프를 멈춥니다.
    'a: for inner in { break 'a; 0..1 } {
        println!("{}", inner); // 이것은 실행되지 않습니다.
    }
    println!("{}", outer); // 이것도 실행되지 않습니다.
}

<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.loop-label.shadow"><a class="rule-link" href="names/scopes.html#r-names.scopes.loop-label.shadow" title="names.scopes.loop-label.shadow"><span>[names<wbr>.scopes<wbr>.loop-label<wbr>.shadow]<span/></a></div>
<p>루프 레이블은 외부 스코프에 있는 같은 이름의 레이블을 가릴 수 있습니다. 레이블에 대한 참조는 가장 가까운 정의를 가리킵니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 루프 레이블 가림 예제.
'a: for outer in 0..5 {
    'a: for inner in 0..5 {
        // 이것은 내부 루프를 종료하지만, 외부 루프는 계속 실행됩니다.
        break 'a;
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-names.scopes.prelude"><a class="rule-link" href="names/scopes.html#r-names.scopes.prelude" title="names.scopes.prelude"><span>[names<wbr>.scopes<wbr>.prelude]<span/></a></div>
<h2 id="프렐류드-스코프"><a class="header" href="#프렐류드-스코프">프렐류드 스코프</a></h2>
<div class="rule" id="r-names.scopes.prelude.intro"><a class="rule-link" href="names/scopes.html#r-names.scopes.prelude.intro" title="names.scopes.prelude.intro"><span>[names<wbr>.scopes<wbr>.prelude<wbr>.intro]<span/></a></div>
<p><a href="names/preludes.html">프렐류드</a>는 엔티티를 모든 모듈의 스코프로 가져옵니다. 엔티티는 모듈의 멤버는 아니지만, <a href="names/name-resolution.html">이름 해석</a> 중에 암시적으로 조회됩니다.</p>
<div class="rule" id="r-names.scopes.prelude.shadow"><a class="rule-link" href="names/scopes.html#r-names.scopes.prelude.shadow" title="names.scopes.prelude.shadow"><span>[names<wbr>.scopes<wbr>.prelude<wbr>.shadow]<span/></a></div>
<p>프렐류드 이름은 모듈 내의 선언에 의해 가려질 수 있습니다.</p>
<div class="rule" id="r-names.scopes.prelude.layers"><a class="rule-link" href="names/scopes.html#r-names.scopes.prelude.layers" title="names.scopes.prelude.layers"><span>[names<wbr>.scopes<wbr>.prelude<wbr>.layers]<span/></a></div>
<p>프렐류드는 계층화되어 있어 동일한 이름의 엔티티를 포함할 경우 하나가 다른 하나를 가립니다. 프렐류드가 다른 프렐류드를 가릴 수 있는 순서는 다음과 같으며, 앞의 항목이 뒤의 항목을 가릴 수 있습니다:</p>
<ol>
<li><a href="names/preludes.html#extern-prelude">외부 프렐류드</a></li>
<li><a href="names/preludes.html#tool-prelude">도구 프렐류드</a></li>
<li><a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a></li>
<li><a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a></li>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a></li>
</ol>
<div class="rule" id="r-names.scopes.macro_rules"><a class="rule-link" href="names/scopes.html#r-names.scopes.macro_rules" title="names.scopes.macro_rules"><span>[names<wbr>.scopes<wbr>.macro_rules]<span/></a></div>
<h2 id="macro_rules-스코프"><a class="header" href="#macro_rules-스코프"><code>macro_rules</code> 스코프</a></h2>
<p><code>macro_rules</code> 매크로의 스코프는 <a href="names/../macros-by-example.html">예제를 통한 매크로</a> 장에 설명되어 있습니다. 이 동작은 <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> 및 <a href="names/../macros-by-example.html#path-based-scope"><code>macro_export</code></a> 속성의 사용에 따라 달라집니다.</p>
<div class="rule" id="r-names.scopes.derive"><a class="rule-link" href="names/scopes.html#r-names.scopes.derive" title="names.scopes.derive"><span>[names<wbr>.scopes<wbr>.derive]<span/></a></div>
<h2 id="파생-매크로-헬퍼-속성-1"><a class="header" href="#파생-매크로-헬퍼-속성-1">파생 매크로 헬퍼 속성</a></h2>
<div class="rule" id="r-names.scopes.derive.scope"><a class="rule-link" href="names/scopes.html#r-names.scopes.derive.scope" title="names.scopes.derive.scope"><span>[names<wbr>.scopes<wbr>.derive<wbr>.scope]<span/></a></div>
<p><a href="names/../procedural-macros.html#derive-macro-helper-attributes">Derive 매크로 도우미 속성</a>은 해당 <a href="names/../attributes/derive.html"><code>derive</code> 속성</a>이 지정된 아이템 내에서 스코프에 있습니다. 스코프는 <code>derive</code> 속성 직후부터 아이템의 끝까지 확장됩니다. <!-- 참고: 엄격하게 사실은 아니지만, https://github.com/rust-lang/rust/issues/79202를 참조하십시오. 이것이 의도된 바입니다. --></p>
<div class="rule" id="r-names.scopes.derive.shadow"><a class="rule-link" href="names/scopes.html#r-names.scopes.derive.shadow" title="names.scopes.derive.shadow"><span>[names<wbr>.scopes<wbr>.derive<wbr>.shadow]<span/></a></div>
<p>도우미 속성은 스코프 내의 같은 이름을 가진 다른 속성을 가립니다.</p>
<div class="rule" id="r-names.scopes.self"><a class="rule-link" href="names/scopes.html#r-names.scopes.self" title="names.scopes.self"><span>[names<wbr>.scopes<wbr>.self]<span/></a></div>
<h2 id="self-스코프"><a class="header" href="#self-스코프"><code>Self</code> 스코프</a></h2>
<div class="rule" id="r-names.scopes.self.intro"><a class="rule-link" href="names/scopes.html#r-names.scopes.self.intro" title="names.scopes.self.intro"><span>[names<wbr>.scopes<wbr>.self<wbr>.intro]<span/></a></div>
<p><a href="names/../paths.html#self-1"><code>Self</code></a>는 특별한 의미를 가진 키워드이지만, 일반 이름과 유사한 방식으로 이름 확인과 상호 작용합니다.</p>
<div class="rule" id="r-names.scopes.self.def-scope"><a class="rule-link" href="names/scopes.html#r-names.scopes.self.def-scope" title="names.scopes.self.def-scope"><span>[names<wbr>.scopes<wbr>.self<wbr>.def-scope]<span/></a></div>
<p><a href="names/../items/structs.html">구조체</a>, <a href="names/../items/enumerations.html">열거형</a>, <a href="names/../items/unions.html">유니온</a>, <a href="names/../items/traits.html">트레잇</a>, 또는 <a href="names/../items/implementations.html">구현</a>의 정의에 있는 암시적 <code>Self</code> 타입은 <a href="names/scopes.html#generic-parameter-scopes">제네릭 매개변수</a>와 유사하게 처리되며, 제네릭 타입 매개변수와 동일한 방식으로 스코프에 있습니다.</p>
<div class="rule" id="r-names.scopes.self.impl-scope"><a class="rule-link" href="names/scopes.html#r-names.scopes.self.impl-scope" title="names.scopes.self.impl-scope"><span>[names<wbr>.scopes<wbr>.self<wbr>.impl-scope]<span/></a></div>
<p><a href="names/../items/implementations.html">구현</a>의 값 <a href="names/namespaces.html">네임스페이스</a>에 있는 암시적 <code>Self</code> 생성자는 구현의 본문(구현의 <a href="names/../items/associated-items.html">연관 아이템</a>) 내에서 스코프에 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 구조체 정의 내의 Self 타입.
struct Recursive {
    f1: Option&lt;Box&lt;Self&gt;&gt;
}

// 제네릭 매개변수 내의 Self 타입.
struct SelfGeneric&lt;T: Into&lt;Self&gt;&gt;(T);

// 구현 내의 Self 값 생성자.
struct ImplExample();
impl ImplExample {
    fn example() -&gt; Self { // Self 타입
        Self() // Self 값 생성자
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-names.preludes"><a class="rule-link" href="names/preludes.html#r-names.preludes" title="names.preludes"><span>[names<wbr>.preludes]<span/></a></div>
<h1 id="프렐류드"><a class="header" href="#프렐류드">프렐류드</a></h1>
<div class="rule" id="r-names.preludes.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.intro" title="names.preludes.intro"><span>[names<wbr>.preludes<wbr>.intro]<span/></a></div>
<p>_프렐류드(prelude)_는 크레이트의 모든 모듈 스코프에 자동으로 도입되는 이름들의 집합입니다.</p>
<p>이러한 프렐류드 이름은 모듈 자체의 일부가 아닙니다. 이들은 <a href="names/name-resolution.html">이름 확인</a> 중에 암시적으로 조회됩니다. 예를 들어, <a href="names/../../alloc/boxed/struct.Box.html"><code>Box</code></a>와 같은 것이 모든 모듈의 스코프에 있더라도, 현재 모듈의 멤버가 아니기 때문에 <code>self::Box</code>로 참조할 수 없습니다.</p>
<div class="rule" id="r-names.preludes.kinds"><a class="rule-link" href="names/preludes.html#r-names.preludes.kinds" title="names.preludes.kinds"><span>[names<wbr>.preludes<wbr>.kinds]<span/></a></div>
<p>여러 가지 다른 프렐류드가 있습니다:</p>
<ul>
<li><a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a></li>
<li><a href="names/preludes.html#extern-prelude">외부 프렐류드</a></li>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a></li>
<li><a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a></li>
<li><a href="names/preludes.html#tool-prelude">도구 프렐류드</a></li>
</ul>
<div class="rule" id="r-names.preludes.std"><a class="rule-link" href="names/preludes.html#r-names.preludes.std" title="names.preludes.std"><span>[names<wbr>.preludes<wbr>.std]<span/></a></div>
<h2 id="표준-라이브러리-프렐류드"><a class="header" href="#표준-라이브러리-프렐류드">표준 라이브러리 프렐류드</a></h2>
<div class="rule" id="r-names.preludes.std.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.std.intro" title="names.preludes.std.intro"><span>[names<wbr>.preludes<wbr>.std<wbr>.intro]<span/></a></div>
<p>각 크레이트에는 단일 표준 라이브러리 모듈의 이름으로 구성된 표준 라이브러리 프렐류드가 있습니다.</p>
<div class="rule" id="r-names.preludes.std.module"><a class="rule-link" href="names/preludes.html#r-names.preludes.std.module" title="names.preludes.std.module"><span>[names<wbr>.preludes<wbr>.std<wbr>.module]<span/></a></div>
<p>사용되는 모듈은 크레이트의 에디션과 크레이트에 <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code> 속성</a>이 적용되었는지 여부에 따라 달라집니다.</p>
<div class="table-wrapper"><table><thead><tr><th>에디션</th><th><code>no_std</code> 적용되지 않음</th><th><code>no_std</code> 적용됨</th></tr></thead><tbody>
<tr><td>2015</td><td><a href="names/../../std/prelude/rust_2015/index.html"><code>std::prelude::rust_2015</code></a></td><td><a href="names/../../core/prelude/rust_2015/index.html"><code>core::prelude::rust_2015</code></a></td></tr>
<tr><td>2018</td><td><a href="names/../../std/prelude/rust_2018/index.html"><code>std::prelude::rust_2018</code></a></td><td><a href="names/../../core/prelude/rust_2018/index.html"><code>core::prelude::rust_2018</code></a></td></tr>
<tr><td>2021</td><td><a href="names/../../std/prelude/rust_2021/index.html"><code>std::prelude::rust_2021</code></a></td><td><a href="names/../../core/prelude/rust_2021/index.html"><code>core::prelude::rust_2021</code></a></td></tr>
<tr><td>2024</td><td><a href="names/../../std/prelude/rust_2024/index.html"><code>std::prelude::rust_2024</code></a></td><td><a href="names/../../core/prelude/rust_2024/index.html"><code>core::prelude::rust_2024</code></a></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>:</p>
<p><a href="names/../../std/prelude/rust_2015/index.html"><code>std::prelude::rust_2015</code></a> 및 <a href="names/../../std/prelude/rust_2018/index.html"><code>std::prelude::rust_2018</code></a>은 <a href="names/../../std/prelude/v1/index.html"><code>std::prelude::v1</code></a>과 동일한 내용을 가집니다.</p>
<p><a href="names/../../core/prelude/rust_2015/index.html"><code>core::prelude::rust_2015</code></a> 및 <a href="names/../../core/prelude/rust_2018/index.html"><code>core::prelude::rust_2018</code></a>은 <a href="names/../../core/prelude/v1/index.html"><code>core::prelude::v1</code></a>과 동일한 내용을 가집니다.</p>
</blockquote>
<div class="rule" id="r-names.preludes.extern"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern" title="names.preludes.extern"><span>[names<wbr>.preludes<wbr>.extern]<span/></a></div>
<h2 id="외부-프렐류드"><a class="header" href="#외부-프렐류드">외부 프렐류드</a></h2>
<div class="rule" id="r-names.preludes.extern.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.intro" title="names.preludes.extern.intro"><span>[names<wbr>.preludes<wbr>.extern<wbr>.intro]<span/></a></div>
<p>루트 모듈에서 <a href="names/../items/extern-crates.html"><code>extern crate</code></a>로 임포트되거나 컴파일러에 제공된(예: <code>rustc</code>의 <code>--extern</code> 플래그) 외부 크레이트들은 _외부 프렐류드_에 추가됩니다. 만약 <code>extern crate orig_name as new_name</code>과 같이 별칭으로 임포트했다면, 대신 <code>new_name</code> 심볼이 프렐류드에 추가됩니다.</p>
<div class="rule" id="r-names.preludes.extern.core"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.core" title="names.preludes.extern.core"><span>[names<wbr>.preludes<wbr>.extern<wbr>.core]<span/></a></div>
<p><a href="names/../../core/index.html"><code>core</code></a> 크레이트는 항상 외부 프렐류드에 추가됩니다.</p>
<div class="rule" id="r-names.preludes.extern.std"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.std" title="names.preludes.extern.std"><span>[names<wbr>.preludes<wbr>.extern<wbr>.std]<span/></a></div>
<p>크레이트 루트에 <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code> 속성</a>이 지정되지 않은 한 <a href="names/../../std/index.html"><code>std</code></a> 크레이트가 추가됩니다.</p>
<div class="rule" id="r-names.preludes.extern.edition2018"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.edition2018" title="names.preludes.extern.edition2018"><span>[names<wbr>.preludes<wbr>.extern<wbr>.edition2018]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서는 외부 프렐류드에 있는 크레이트들을 <a href="names/../items/use-declarations.html">use 선언</a>을 통해 참조할 수 없습니다. 따라서 일반적으로 이들을 스코프로 가져오기 위해 <code>extern crate</code> 선언을 포함하는 것이 표준적인 관례입니다.</p>
<p>2018 에디션부터 <a href="names/../items/use-declarations.html">use 선언</a>은 외부 프렐류드의 크레이트를 참조할 수 있으므로, <code>extern crate</code>를 사용하는 것은 관용적이지(unidiomatic) 않은 것으로 간주됩니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: Cargo를 사용할 때 <a href="names/../../alloc/index.html"><code>alloc</code></a> 및 <a href="names/../../test/index.html"><code>test</code></a>와 같이 <code>rustc</code>와 함께 제공되는 추가 크레이트들은 <code>--extern</code> 플래그로 자동으로 포함되지 않습니다. 이들은 2018 에디션에서도 <code>extern crate</code> 선언을 통해 스코프로 가져와야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate alloc;
use alloc::rc::Rc;
<span class="boring">}</span></code></pre></pre>
<p>Cargo는 오직 절차적 매크로(proc-macro) 크레이트에 대해서만 <code>proc_macro</code>를 외부 프렐류드로 가져옵니다.</p>
</blockquote>
<!--
See https://github.com/rust-lang/rust/issues/57288 for more about the
alloc/test limitation.
-->
<div class="rule" id="r-names.preludes.extern.no_std"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std" title="names.preludes.extern.no_std"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std]<span/></a></div>
<h3 id="no_std-속성"><a class="header" href="#no_std-속성"><code>no_std</code> 속성</a></h3>
<div class="rule" id="r-names.preludes.extern.no_std.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std.intro" title="names.preludes.extern.no_std.intro"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std<wbr>.intro]<span/></a></div>
<p>기본적으로 표준 라이브러리는 크레이트 루트 모듈에 자동으로 포함됩니다. <a href="names/../../std/index.html"><code>std</code></a> 크레이트가 루트에 추가되며, 암시적인 <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 속성</a>과 함께 <code>std</code>에서 내보낸 모든 매크로를 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a>로 가져옵니다. <a href="names/../../core/index.html"><code>core</code></a>와 <a href="names/../../std/index.html"><code>std</code></a> 모두 <a href="names/preludes.html#extern-prelude">외부 프렐류드</a>에 추가됩니다.</p>
<div class="rule" id="r-names.preludes.extern.no_std.allowed-positions"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std.allowed-positions" title="names.preludes.extern.no_std.allowed-positions"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std<wbr>.allowed-positions]<span/></a></div>
<p><a href="names/../../std/index.html"><code>std</code></a> 크레이트가 자동으로 스코프에 추가되는 것을 방지하기 위해 크레이트 레벨에서 _<code>no_std</code> <a href="names/../attributes.html">속성</a>_을 적용할 수 있습니다.</p>
<p>이 속성은 다음 세 가지 일을 수행합니다:</p>
<div class="rule" id="r-names.preludes.extern.no_std.extern"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std.extern" title="names.preludes.extern.no_std.extern"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std<wbr>.extern]<span/></a></div>
<ul>
<li><code>std</code>가 <a href="names/preludes.html#extern-prelude">외부 프렐류드</a>에 추가되는 것을 방지합니다.</li>
</ul>
<div class="rule" id="r-names.preludes.extern.no_std.module"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std.module" title="names.preludes.extern.no_std.module"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std<wbr>.module]<span/></a></div>
<ul>
<li>(위에서 설명한 대로) 어떤 모듈이 <a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a>를 구성하는 데 사용될지에 영향을 줍니다.</li>
</ul>
<div class="rule" id="r-names.preludes.extern.no_std.core"><a class="rule-link" href="names/preludes.html#r-names.preludes.extern.no_std.core" title="names.preludes.extern.no_std.core"><span>[names<wbr>.preludes<wbr>.extern<wbr>.no_std<wbr>.core]<span/></a></div>
<ul>
<li><a href="names/../../std/index.html"><code>std</code></a> 대신 <a href="names/../../core/index.html"><code>core</code></a> 크레이트를 크레이트 루트에 주입하고, <code>core</code>에서 내보낸 모든 매크로를 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a>로 가져옵니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 표준 프렐류드 대신 코어 프렐류드를 사용하는 것은 크레이트가 표준 라이브러리를 지원하지 않는 플랫폼을 대상으로 하거나, 의도적으로 표준 라이브러리의 기능을 사용하지 않으려는 경우에 유용합니다. 이러한 기능들은 주로 동적 메모리 할당(예: <code>Box</code> 및 <code>Vec</code>), 파일 및 네트워크 기능(예: <code>std::fs</code> 및 <code>std::io</code>)입니다.</p>
</blockquote>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> <code>no_std</code>를 사용한다고 해서 표준 라이브러리가 링크되는 것을 방지하지는 않습니다. 크레이트에 <code>extern crate std;</code>를 넣는 것은 여전히 유효하며, 의존성(dependencies)들이 이를 링크할 수도 있습니다.</p>
</blockquote>
</div>
<div class="rule" id="r-names.preludes.lang"><a class="rule-link" href="names/preludes.html#r-names.preludes.lang" title="names.preludes.lang"><span>[names<wbr>.preludes<wbr>.lang]<span/></a></div>
<h2 id="언어-프렐류드"><a class="header" href="#언어-프렐류드">언어 프렐류드</a></h2>
<div class="rule" id="r-names.preludes.lang.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.lang.intro" title="names.preludes.lang.intro"><span>[names<wbr>.preludes<wbr>.lang<wbr>.intro]<span/></a></div>
<p>언어 프렐류드에는 언어에 내장된 타입과 속성들의 이름이 포함됩니다. 언어 프렐류드는 항상 스코프에 있습니다.</p>
<div class="rule" id="r-names.preludes.lang.entities"><a class="rule-link" href="names/preludes.html#r-names.preludes.lang.entities" title="names.preludes.lang.entities"><span>[names<wbr>.preludes<wbr>.lang<wbr>.entities]<span/></a></div>
<p>여기에는 다음이 포함됩니다:</p>
<ul>
<li><a href="names/namespaces.html">타입 네임스페이스</a>
<ul>
<li><a href="names/../types/boolean.html">불리언 타입</a> — <code>bool</code></li>
<li><a href="names/../types/textual.html">텍스트 타입</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="names/../types/numeric.html#integer-types">정수 타입</a> — <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><a href="names/../types/numeric.html#machine-dependent-integer-types">머신 의존적 정수 타입</a> — <code>usize</code> 및 <code>isize</code></li>
<li><a href="names/../types/numeric.html#floating-point-types">부동 소수점 타입</a> — <code>f32</code> 및 <code>f64</code></li>
</ul>
</li>
<li><a href="names/namespaces.html">매크로 네임스페이스</a>
<ul>
<li><a href="names/../attributes.html#built-in-attributes-index">내장 속성</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-names.preludes.macro_use"><a class="rule-link" href="names/preludes.html#r-names.preludes.macro_use" title="names.preludes.macro_use"><span>[names<wbr>.preludes<wbr>.macro_use]<span/></a></div>
<h2 id="macro_use-프렐류드"><a class="header" href="#macro_use-프렐류드"><code>macro_use</code> 프렐류드</a></h2>
<div class="rule" id="r-names.preludes.macro_use.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.macro_use.intro" title="names.preludes.macro_use.intro"><span>[names<wbr>.preludes<wbr>.macro_use<wbr>.intro]<span/></a></div>
<p><code>macro_use</code> 프렐류드에는 <a href="names/../items/extern-crates.html"><code>extern crate</code></a>에 적용된 <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 속성</a>을 통해 임포트된 외부 크레이트의 매크로들이 포함됩니다.</p>
<div class="rule" id="r-names.preludes.tool"><a class="rule-link" href="names/preludes.html#r-names.preludes.tool" title="names.preludes.tool"><span>[names<wbr>.preludes<wbr>.tool]<span/></a></div>
<h2 id="도구-프렐류드"><a class="header" href="#도구-프렐류드">도구 프렐류드</a></h2>
<div class="rule" id="r-names.preludes.tool.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.tool.intro" title="names.preludes.tool.intro"><span>[names<wbr>.preludes<wbr>.tool<wbr>.intro]<span/></a></div>
<p>도구 프렐류드에는 <a href="names/namespaces.html">타입 네임스페이스</a>에 있는 외부 도구들의 이름이 포함됩니다. 자세한 내용은 <a href="names/../attributes.html#tool-attributes">도구 속성</a> 섹션을 참조하십시오.</p>
<div class="rule" id="r-names.preludes.no_implicit_prelude"><a class="rule-link" href="names/preludes.html#r-names.preludes.no_implicit_prelude" title="names.preludes.no_implicit_prelude"><span>[names<wbr>.preludes<wbr>.no_implicit_prelude]<span/></a></div>
<h2 id="no_implicit_prelude-속성"><a class="header" href="#no_implicit_prelude-속성"><code>no_implicit_prelude</code> 속성</a></h2>
<div class="rule" id="r-names.preludes.no_implicit_prelude.intro"><a class="rule-link" href="names/preludes.html#r-names.preludes.no_implicit_prelude.intro" title="names.preludes.no_implicit_prelude.intro"><span>[names<wbr>.preludes<wbr>.no_implicit_prelude<wbr>.intro]<span/></a></div>
<p>_<code>no_implicit_prelude</code> <a href="names/../attributes.html">속성</a>_은 크레이트 레벨이나 모듈에 적용되어, 해당 모듈 또는 그 하위 모듈들의 스코프에 <a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a>, <a href="names/preludes.html#extern-prelude">외부 프렐류드</a>, 또는 <a href="names/preludes.html#tool-prelude">도구 프렐류드</a>를 자동으로 가져오지 않아야 함을 나타낼 수 있습니다.</p>
<div class="rule" id="r-names.preludes.no_implicit_prelude.lang"><a class="rule-link" href="names/preludes.html#r-names.preludes.no_implicit_prelude.lang" title="names.preludes.no_implicit_prelude.lang"><span>[names<wbr>.preludes<wbr>.no_implicit_prelude<wbr>.lang]<span/></a></div>
<p>이 속성은 <a href="names/preludes.html#language-prelude">언어 프렐류드</a>에는 영향을 주지 않습니다.</p>
<div class="rule" id="r-names.preludes.no_implicit_prelude.edition2018"><a class="rule-link" href="names/preludes.html#r-names.preludes.no_implicit_prelude.edition2018" title="names.preludes.no_implicit_prelude.edition2018"><span>[names<wbr>.preludes<wbr>.no_implicit_prelude<wbr>.edition2018]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 <code>no_implicit_prelude</code> 속성은 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a>에 영향을 주지 않으며, 표준 라이브러리에서 내보낸 모든 매크로가 여전히 <code>macro_use</code> 프렐류드에 포함됩니다. 2018 에디션부터는 <code>macro_use</code> 프렐류드도 제거합니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-paths"><a class="rule-link" href="paths.html#r-paths" title="paths"><span>[paths]<span/></a></div>
<h1 id="경로"><a class="header" href="#경로">경로</a></h1>
<div class="rule" id="r-paths.intro"><a class="rule-link" href="paths.html#r-paths.intro" title="paths.intro"><span>[paths<wbr>.intro]<span/></a></div>
<p>_경로(path)_는 <code>::</code> 토큰으로 구분된 하나 이상의 경로 세그먼트 시퀀스입니다. 경로는 <a href="items.html">아이템</a>, 값, <a href="types.html">타입</a>, <a href="macros.html">매크로</a> 및 <a href="attributes.html">속성</a>을 참조하는 데 사용됩니다.</p>
<p>식별자 세그먼트로만 구성된 단순 경로의 두 가지 예:</p>
<!-- ignore: syntax fragment -->
<pre><code class="language-rust ignore">x;
x::y::z;</code></pre>
<h2 id="경로의-종류"><a class="header" href="#경로의-종류">경로의 종류</a></h2>
<div class="rule" id="r-paths.simple"><a class="rule-link" href="paths.html#r-paths.simple" title="paths.simple"><span>[paths<wbr>.simple]<span/></a></div>
<h3 id="단순-경로"><a class="header" href="#단순-경로">단순 경로</a></h3>
<div class="rule" id="r-paths.simple.syntax"><a class="rule-link" href="paths.html#r-paths.simple.syntax" title="paths.simple.syntax"><span>[paths<wbr>.simple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>SimplePath</em> :<br />
   <code>::</code><sup>?</sup> <em>SimplePathSegment</em> (<code>::</code> <em>SimplePathSegment</em>)<sup>*</sup></p>
<p><em>SimplePathSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>crate</code> | <code>$crate</code></p>
</blockquote>
<div class="rule" id="r-paths.simple.intro"><a class="rule-link" href="paths.html#r-paths.simple.intro" title="paths.simple.intro"><span>[paths<wbr>.simple<wbr>.intro]<span/></a></div>
<p>단순 경로는 <a href="visibility-and-privacy.html">가시성</a> 표시어, <a href="attributes.html">속성</a>, <a href="macros-by-example.html">매크로</a> 및 <a href="items/use-declarations.html"><code>use</code></a> 아이템에서 사용됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = "0"]
    pub (in super) fn f1() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.expr"><a class="rule-link" href="paths.html#r-paths.expr" title="paths.expr"><span>[paths<wbr>.expr]<span/></a></div>
<h3 id="표현식에서의-경로"><a class="header" href="#표현식에서의-경로">표현식에서의 경로</a></h3>
<div class="rule" id="r-paths.expr.syntax"><a class="rule-link" href="paths.html#r-paths.expr.syntax" title="paths.expr.syntax"><span>[paths<wbr>.expr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>PathInExpression</em> :<br />
   <code>::</code><sup>?</sup> <em>PathExprSegment</em> (<code>::</code> <em>PathExprSegment</em>)<sup>*</sup></p>
<p><em>PathExprSegment</em> :<br />
   <em>PathIdentSegment</em> (<code>::</code> <em>GenericArgs</em>)<sup>?</sup></p>
<p><em>PathIdentSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>Self</code> | <code>crate</code> | <code>$crate</code></p>
<p><em>GenericArgs</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
   | <code>&lt;</code> ( <em>GenericArg</em> <code>,</code> )<sup>*</sup> <em>GenericArg</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>GenericArg</em> :<br />
   <a href="trait-bounds.html"><em>Lifetime</em></a> | <a href="types.html#type-expressions"><em>Type</em></a> | <em>GenericArgsConst</em> | <em>GenericArgsBinding</em> | <em>GenericArgsBounds</em></p>
<p><em>GenericArgsConst</em> :<br />
      <a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
   | <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
   | <code>-</code> <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
   | <a href="paths.html#simple-paths"><em>SimplePathSegment</em></a></p>
<p><em>GenericArgsBinding</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> <em>GenericArgs</em><sup>?</sup> <code>=</code> <a href="types.html#type-expressions"><em>Type</em></a></p>
<p><em>GenericArgsBounds</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> <em>GenericArgs</em><sup>?</sup> <code>:</code> <a href="trait-bounds.html"><em>TypeParamBounds</em></a></p>
</blockquote>
<div class="rule" id="r-paths.expr.intro"><a class="rule-link" href="paths.html#r-paths.expr.intro" title="paths.expr.intro"><span>[paths<wbr>.expr<wbr>.intro]<span/></a></div>
<p>표현식에서의 경로는 제네릭 인자가 포함된 경로를 지정할 수 있게 해줍니다. 이들은 <a href="expressions.html">표현식</a>과 <a href="patterns.html">패턴</a>의 다양한 곳에서 사용됩니다.</p>
<div class="rule" id="r-paths.expr.turbofish"><a class="rule-link" href="paths.html#r-paths.expr.turbofish" title="paths.expr.turbofish"><span>[paths<wbr>.expr<wbr>.turbofish]<span/></a></div>
<p>제네릭 인자를 위한 여는 <code>&lt;</code> 앞에는 작음(less-than) 연산자와의 모호성을 피하기 위해 <code>::</code> 토큰이 필요합니다. 이것은 구어체로 “터보피쉬(turbofish)” 구문이라고 알려져 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.expr.argument-order"><a class="rule-link" href="paths.html#r-paths.expr.argument-order" title="paths.expr.argument-order"><span>[paths<wbr>.expr<wbr>.argument-order]<span/></a></div>
<p>제네릭 인자의 순서는 라이프타임 인자, 그 다음 타입 인자, 그 다음 상수 인자, 그 다음 등치 제약 조건(equality constraints) 순으로 제한됩니다.</p>
<div class="rule" id="r-paths.expr.complex-const-params"><a class="rule-link" href="paths.html#r-paths.expr.complex-const-params" title="paths.expr.complex-const-params"><span>[paths<wbr>.expr<wbr>.complex-const-params]<span/></a></div>
<p>상수 인자가 <a href="expressions/literal-expr.html">리터럴</a>이거나 단일 세그먼트 경로가 아닌 경우에는 중괄호로 둘러싸야 합니다.</p>
<div class="rule" id="r-paths.expr.impl-trait-params"><a class="rule-link" href="paths.html#r-paths.expr.impl-trait-params" title="paths.expr.impl-trait-params"><span>[paths<wbr>.expr<wbr>.impl-trait-params]<span/></a></div>
<p><code>impl Trait</code> 타입에 대응하는 합성 타입 파라미터(synthetic type parameters)는 암시적이며, 이를 명시적으로 지정할 수 없습니다.</p>
<div class="rule" id="r-paths.qualified"><a class="rule-link" href="paths.html#r-paths.qualified" title="paths.qualified"><span>[paths<wbr>.qualified]<span/></a></div>
<h2 id="정규화된-경로qualified-paths"><a class="header" href="#정규화된-경로qualified-paths">정규화된 경로(Qualified paths)</a></h2>
<div class="rule" id="r-paths.qualified.syntax"><a class="rule-link" href="paths.html#r-paths.qualified.syntax" title="paths.qualified.syntax"><span>[paths<wbr>.qualified<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>QualifiedPathInExpression</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>PathExprSegment</em>)<sup>+</sup></p>
<p><em>QualifiedPathType</em> :<br />
   <code>&lt;</code> <a href="types.html#type-expressions"><em>Type</em></a> (<code>as</code> <em>TypePath</em>)<sup>?</sup> <code>&gt;</code></p>
<p><em>QualifiedPathInType</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>TypePathSegment</em>)<sup>+</sup></p>
</blockquote>
<div class="rule" id="r-paths.qualified.intro"><a class="rule-link" href="paths.html#r-paths.qualified.intro" title="paths.qualified.intro"><span>[paths<wbr>.qualified<wbr>.intro]<span/></a></div>
<p>완전하게 정규화된 경로(Fully qualified paths)는 <a href="items/implementations.html#trait-implementations">트레잇 구현</a>에 대한 경로의 모호성을 제거하고 <a href="paths.html#canonical-paths">표준 경로(canonical paths)</a>를 지정할 수 있게 해줍니다. 타입 명세에서 사용될 때는 아래에 명시된 타입 구문을 사용하는 것을 지원합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S;
impl S {
    fn f() { println!("S"); }
}
trait T1 {
    fn f() { println!("T1 f"); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!("T2 f"); }
}
impl T2 for S {}
S::f();  // 내재적 구현(inherent impl)을 호출합니다.
&lt;S as T1&gt;::f();  // T1 트레잇 함수를 호출합니다.
&lt;S as T2&gt;::f();  // T2 트레잇 함수를 호출합니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.type"><a class="rule-link" href="paths.html#r-paths.type" title="paths.type"><span>[paths<wbr>.type]<span/></a></div>
<h3 id="타입에서의-경로"><a class="header" href="#타입에서의-경로">타입에서의 경로</a></h3>
<div class="rule" id="r-paths.type.syntax"><a class="rule-link" href="paths.html#r-paths.type.syntax" title="paths.type.syntax"><span>[paths<wbr>.type<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>TypePath</em> :<br />
   <code>::</code><sup>?</sup> <em>TypePathSegment</em> (<code>::</code> <em>TypePathSegment</em>)<sup>*</sup></p>
<p><em>TypePathSegment</em> :<br />
   <em>PathIdentSegment</em> (<code>::</code><sup>?</sup> (<a href="paths.html#paths-in-expressions"><em>GenericArgs</em></a> | <em>TypePathFn</em>))<sup>?</sup></p>
<p><em>TypePathFn</em> :<br />
<code>(</code> <em>TypePathFnInputs</em><sup>?</sup> <code>)</code> (<code>-&gt;</code> <a href="types.html#type-expressions"><em>TypeNoBounds</em></a>)<sup>?</sup></p>
<p><em>TypePathFnInputs</em> :<br />
<a href="types.html#type-expressions"><em>Type</em></a> (<code>,</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-paths.type.intro"><a class="rule-link" href="paths.html#r-paths.type.intro" title="paths.type.intro"><span>[paths<wbr>.type<wbr>.intro]<span/></a></div>
<p>타입 경로는 타입 정의, 트레잇 바운드, 타입 파라미터 바운드 및 정규화된 경로 내에서 사용됩니다.</p>
<div class="rule" id="r-paths.type.turbofish"><a class="rule-link" href="paths.html#r-paths.type.turbofish" title="paths.type.turbofish"><span>[paths<wbr>.type<wbr>.turbofish]<span/></a></div>
<p>제네릭 인자 앞에 <code>::</code> 토큰을 사용할 수 있지만, _PathInExpression_에서와 같은 모호성이 없기 때문에 필수사항은 아닙니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ops {
</span><span class="boring">    pub struct Range&lt;T&gt; {f1: T}
</span><span class="boring">    pub trait Index&lt;T&gt; {}
</span><span class="boring">    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
</span><span class="boring">}
</span><span class="boring">struct S;
</span>impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
<span class="boring">   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
</span><span class="boring">   EXAMPLE.into_iter()
</span>}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers"><a class="rule-link" href="paths.html#r-paths.qualifiers" title="paths.qualifiers"><span>[paths<wbr>.qualifiers]<span/></a></div>
<h2 id="경로-한정자path-qualifiers"><a class="header" href="#경로-한정자path-qualifiers">경로 한정자(Path qualifiers)</a></h2>
<p>경로는 해석 방식의 의미를 변경하기 위해 앞에 다양한 한정자를 붙여 표시할 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.global-root"><a class="rule-link" href="paths.html#r-paths.qualifiers.global-root" title="paths.qualifiers.global-root"><span>[paths<wbr>.qualifiers<wbr>.global-root]<span/></a></div>
<h3 id=""><a class="header" href="#"><code>::</code></a></h3>
<div class="rule" id="r-paths.qualifiers.global-root.intro"><a class="rule-link" href="paths.html#r-paths.qualifiers.global-root.intro" title="paths.qualifiers.global-root.intro"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.intro]<span/></a></div>
<p><code>::</code>로 시작하는 경로는 _전역 경로(global paths)_로 간주되며, 경로의 세그먼트가 해석되기 시작하는 위치는 에디션에 따라 다릅니다. 경로의 각 식별자는 아이템으로 해석되어야 합니다.</p>
<div class="rule" id="r-paths.qualifiers.global-root.edition2015"><a class="rule-link" href="paths.html#r-paths.qualifiers.global-root.edition2015" title="paths.qualifiers.global-root.edition2015"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 식별자는 “크레이트 루트(crate root)”(2018 에디션의 <code>crate::</code>)에서 해석됩니다. 여기에는 외부 크레이트, <code>std</code> 또는 <code>core</code>와 같은 기본 크레이트, 그리고 크레이트 최상위 레벨의 아이템들(<code>use</code> 임포트 포함)을 포함한 다양한 아이템들이 들어 있습니다.</p>
<p>2018 에디션부터 <code>::</code>로 시작하는 경로는 <a href="names/preludes.html#extern-prelude">외부 프렐류드(extern prelude)</a>에 있는 크레이트에서 해석됩니다. 즉, 그 뒤에는 반드시 크레이트 이름이 와야 합니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {
    // 2018 에디션에서는 외부 프렐류드를 통해 `std`에 접근합니다.
    // 2015 에디션에서는 크레이트 루트를 통해 `std`에 접근합니다.
    let now = ::std::time::Instant::now();
    println!("{:?}", now);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2015">// 2015 에디션
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // `a`의 foo 함수를 호출합니다.
        // Rust 2018에서 `::a`는 크레이트 `a`로 해석됩니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.mod-self"><a class="rule-link" href="paths.html#r-paths.qualifiers.mod-self" title="paths.qualifiers.mod-self"><span>[paths<wbr>.qualifiers<wbr>.mod-self]<span/></a></div>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<div class="rule" id="r-paths.qualifiers.mod-self.intro"><a class="rule-link" href="paths.html#r-paths.qualifiers.mod-self.intro" title="paths.qualifiers.mod-self.intro"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.intro]<span/></a></div>
<p><code>self</code>는 현재 모듈을 기준으로 상대적인 경로를 해석합니다.</p>
<div class="rule" id="r-paths.qualifiers.mod-self.restriction"><a class="rule-link" href="paths.html#r-paths.qualifiers.mod-self.restriction" title="paths.qualifiers.mod-self.restriction"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.restriction]<span/></a></div>
<p><code>self</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.self-pat"><a class="rule-link" href="paths.html#r-paths.qualifiers.self-pat" title="paths.qualifiers.self-pat"><span>[paths<wbr>.qualifiers<wbr>.self-pat]<span/></a></div>
<p>메서드 본문에서 단일 <code>self</code> 세그먼트로 구성된 경로는 해당 메서드의 self 파라미터로 해석됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
fn bar() {
    self::foo();
}
struct S(bool);
impl S {
  fn baz(self) {
        self.0;
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.type-self"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self" title="paths.qualifiers.type-self"><span>[paths<wbr>.qualifiers<wbr>.type-self]<span/></a></div>
<h3 id="self-1"><a class="header" href="#self-1"><code>Self</code></a></h3>
<div class="rule" id="r-paths.qualifiers.type-self.intro"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.intro" title="paths.qualifiers.type-self.intro"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.intro]<span/></a></div>
<p>대문자 “S“로 시작하는 <code>Self</code>는 현재 구현되거나 정의되고 있는 타입을 참조하는 데 사용됩니다. 다음과 같은 상황에서 사용될 수 있습니다:</p>
<div class="rule" id="r-paths.qualifiers.type-self.trait"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.trait" title="paths.qualifiers.type-self.trait"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.trait]<span/></a></div>
<ul>
<li><a href="items/traits.html">트레잇(trait)</a> 정의에서, 이는 해당 트레잇을 구현하는 타입을 참조합니다.</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.impl"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.impl" title="paths.qualifiers.type-self.impl"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.impl]<span/></a></div>
<ul>
<li><a href="items/implementations.html">구현(implementation)</a>에서, 이는 구현되고 있는 타입을 참조합니다. 튜플 또는 유닛 <a href="items/structs.html">구조체(struct)</a>를 구현할 때는 <a href="names/namespaces.html">값 네임스페이스</a>의 생성자도 참조합니다.</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.type"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.type" title="paths.qualifiers.type-self.type"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.type]<span/></a></div>
<ul>
<li><a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형(enumeration)</a> 또는 <a href="items/unions.html">공용체(union)</a>의 정의에서, 이는 정의되고 있는 타입을 참조합니다. 정의가 무한히 재귀적일 수는 없습니다(반드시 간접 참조(indirection)가 있어야 합니다).</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.scope"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.scope" title="paths.qualifiers.type-self.scope"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.scope]<span/></a></div>
<p><code>Self</code>의 스코프는 제네릭 파라미터와 유사하게 동작합니다. 자세한 내용은 <a href="names/scopes.html#self-scope"><code>Self</code> 스코프</a> 섹션을 참조하십시오.</p>
<div class="rule" id="r-paths.qualifiers.type-self.allowed-positions"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.allowed-positions" title="paths.qualifiers.type-self.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.allowed-positions]<span/></a></div>
<p><code>Self</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.type-self.no-generics"><a class="rule-link" href="paths.html#r-paths.qualifiers.type-self.no-generics" title="paths.qualifiers.type-self.no-generics"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.no-generics]<span/></a></div>
<p><code>Self</code> 경로는 (<code>Self::&lt;i32&gt;</code>와 같이) 제네릭 인자를 포함할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    type Item;
    const C: i32;
    // `Self`는 `T`를 구현하는 어떤 타입이든 될 수 있습니다.
    fn new() -&gt; Self;
    // `Self::Item`은 구현체에서의 타입 별칭(type alias)이 됩니다.
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self`는 `S` 타입입니다.
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item`은 `i32` 타입입니다.
        Self::C                  // `Self::C`는 상수 값 `9`입니다.
    }
}

// `Self`는 트레잇 정의의 제네릭 내에서 스코프에 있으며,
// 정의되고 있는 타입을 참조합니다.
trait Add&lt;Rhs = Self&gt; {
    type Output;
    // `Self`는 또한 구현되고 있는 타입의
    // 연관 아이템을 참조할 수 있습니다.
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct NonEmptyList&lt;T&gt; {
    head: T,
    // 구조체는 자기 자신을 참조할 수 있습니다(무한히
    // 재귀적이지 않은 한).
    tail: Option&lt;Box&lt;Self&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.super"><a class="rule-link" href="paths.html#r-paths.qualifiers.super" title="paths.qualifiers.super"><span>[paths<wbr>.qualifiers<wbr>.super]<span/></a></div>
<h3 id="super"><a class="header" href="#super"><code>super</code></a></h3>
<div class="rule" id="r-paths.qualifiers.super.intro"><a class="rule-link" href="paths.html#r-paths.qualifiers.super.intro" title="paths.qualifiers.super.intro"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.intro]<span/></a></div>
<p>경로에서의 <code>super</code>는 부모 모듈로 해석됩니다.</p>
<div class="rule" id="r-paths.qualifiers.super.allowed-positions"><a class="rule-link" href="paths.html#r-paths.qualifiers.super.allowed-positions" title="paths.qualifiers.super.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.allowed-positions]<span/></a></div>
<p>이는 경로의 앞부분 세그먼트에서만 사용될 수 있으며, 초기 <code>self</code> 세그먼트 뒤에 올 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // a의 foo 함수를 호출합니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.super.repetition"><a class="rule-link" href="paths.html#r-paths.qualifiers.super.repetition" title="paths.qualifiers.super.repetition"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.repetition]<span/></a></div>
<p><code>super</code>는 조상 모듈을 참조하기 위해 첫 번째 <code>super</code> 또는 <code>self</code> 뒤에 여러 번 반복될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // a의 foo 함수를 호출합니다.
                self::super::super::foo(); // a의 foo 함수를 호출합니다.
            }
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.crate"><a class="rule-link" href="paths.html#r-paths.qualifiers.crate" title="paths.qualifiers.crate"><span>[paths<wbr>.qualifiers<wbr>.crate]<span/></a></div>
<h3 id="crate"><a class="header" href="#crate"><code>crate</code></a></h3>
<div class="rule" id="r-paths.qualifiers.crate.intro"><a class="rule-link" href="paths.html#r-paths.qualifiers.crate.intro" title="paths.qualifiers.crate.intro"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.intro]<span/></a></div>
<p><code>crate</code>는 현재 크레이트를 기준으로 상대적인 경로를 해석합니다.</p>
<div class="rule" id="r-paths.qualifiers.crate.allowed-positions"><a class="rule-link" href="paths.html#r-paths.qualifiers.crate.allowed-positions" title="paths.qualifiers.crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.allowed-positions]<span/></a></div>
<p><code>crate</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.macro-crate"><a class="rule-link" href="paths.html#r-paths.qualifiers.macro-crate" title="paths.qualifiers.macro-crate"><span>[paths<wbr>.qualifiers<wbr>.macro-crate]<span/></a></div>
<h3 id="crate-1"><a class="header" href="#crate-1"><code>$crate</code></a></h3>
<div class="rule" id="r-paths.qualifiers.macro-crate.allowed-positions"><a class="rule-link" href="paths.html#r-paths.qualifiers.macro-crate.allowed-positions" title="paths.qualifiers.macro-crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.allowed-positions]<span/></a></div>
<p><code>$crate</code>는 <a href="macros-by-example.html">매크로 전사기(macro transcribers)</a> 내에서만 사용되며, 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.macro-crate.hygiene"><a class="rule-link" href="paths.html#r-paths.qualifiers.macro-crate.hygiene" title="paths.qualifiers.macro-crate.hygiene"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.hygiene]<span/></a></div>
<p><code>$crate</code>는 매크로가 호출된 크레이트에 관계없이, 매크로가 정의된 크레이트의 최상위 레벨에 있는 아이템에 접근하기 위한 경로로 확장됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">fn main() { }</span></code></pre></pre>
<div class="rule" id="r-paths.canonical"><a class="rule-link" href="paths.html#r-paths.canonical" title="paths.canonical"><span>[paths<wbr>.canonical]<span/></a></div>
<h2 id="표준-경로canonical-paths"><a class="header" href="#표준-경로canonical-paths">표준 경로(Canonical paths)</a></h2>
<div class="rule" id="r-paths.canonical.intro"><a class="rule-link" href="paths.html#r-paths.canonical.intro" title="paths.canonical.intro"><span>[paths<wbr>.canonical<wbr>.intro]<span/></a></div>
<p>모듈이나 구현체에 정의된 아이템은 해당 크레이트 내의 정의된 위치에 대응하는 _표준 경로(canonical path)_를 갖습니다.</p>
<div class="rule" id="r-paths.canonical.alias"><a class="rule-link" href="paths.html#r-paths.canonical.alias" title="paths.canonical.alias"><span>[paths<wbr>.canonical<wbr>.alias]<span/></a></div>
<p>이러한 아이템들에 대한 다른 모든 경로들은 별칭(aliases)입니다.</p>
<div class="rule" id="r-paths.canonical.def"><a class="rule-link" href="paths.html#r-paths.canonical.def" title="paths.canonical.def"><span>[paths<wbr>.canonical<wbr>.def]<span/></a></div>
<p>표준 경로는 아이템 자체가 정의하는 경로 세그먼트가 추가된 _경로 접두사(path prefix)_로 정의됩니다.</p>
<div class="rule" id="r-paths.canonical.non-canonical"><a class="rule-link" href="paths.html#r-paths.canonical.non-canonical" title="paths.canonical.non-canonical"><span>[paths<wbr>.canonical<wbr>.non-canonical]<span/></a></div>
<p><a href="items/implementations.html">구현체(Implementations)</a>와 <a href="items/use-declarations.html">use 선언(use declarations)</a>은 표준 경로를 갖지 않지만, 구현체가 정의하는 아이템들은 표준 경로를 갖습니다. 블록 표현식에 정의된 아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 모듈에 정의된 아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 아이템(예: 구현하는 타입, 구현되는 트레잇, 타입 파라미터 또는 타입 파라미터의 바운드)을 참조하는 구현체에 정의된 연관 아이템들은 표준 경로를 갖지 않습니다.</p>
<div class="rule" id="r-paths.canonical.module-prefix"><a class="rule-link" href="paths.html#r-paths.canonical.module-prefix" title="paths.canonical.module-prefix"><span>[paths<wbr>.canonical<wbr>.module-prefix]<span/></a></div>
<p>모듈의 경로 접두사는 해당 모듈에 대한 표준 경로입니다.</p>
<div class="rule" id="r-paths.canonical.bare-impl-prefix"><a class="rule-link" href="paths.html#r-paths.canonical.bare-impl-prefix" title="paths.canonical.bare-impl-prefix"><span>[paths<wbr>.canonical<wbr>.bare-impl-prefix]<span/></a></div>
<p>단순 구현체(bare implementations)의 경우, 구현되고 있는 아이템의 표준 경로를 <span class="parenthetical">화살괄호(<code>&lt;&gt;</code>)</span>로 둘러싼 형태가 접두사가 됩니다.</p>
<div class="rule" id="r-paths.canonical.trait-impl-prefix"><a class="rule-link" href="paths.html#r-paths.canonical.trait-impl-prefix" title="paths.canonical.trait-impl-prefix"><span>[paths<wbr>.canonical<wbr>.trait-impl-prefix]<span/></a></div>
<p><a href="items/implementations.html#trait-implementations">트레잇 구현체(trait implementations)</a>의 경우, 구현되고 있는 아이템의 표준 경로 뒤에 <code>as</code>와 트레잇의 표준 경로를 붙인 후 전체를 <span class="parenthetical">화살괄호(<code>&lt;&gt;</code>)</span>로 둘러싼 형태가 접두사가 됩니다.</p>
<div class="rule" id="r-paths.canonical.local-canonical-path"><a class="rule-link" href="paths.html#r-paths.canonical.local-canonical-path" title="paths.canonical.local-canonical-path"><span>[paths<wbr>.canonical<wbr>.local-canonical-path]<span/></a></div>
<p>표준 경로는 오직 주어진 크레이트 내에서만 의미가 있습니다. 크레이트들 사이에 공통된 전역 네임스페이스는 존재하지 않습니다. 아이템의 표준 경로는 단지 크레이트 내에서 아이템을 식별할 뿐입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 주석은 아이템의 표준 경로를 나타냅니다.

mod a { // crate::a
    pub struct Struct; // crate::a::Struct

    pub trait Trait { // crate::a::Trait
        fn f(&amp;self); // crate::a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;crate::a::Struct as crate::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;crate::a::Struct&gt;::g
    }
}

mod without { // crate::without
    fn canonicals() { // crate::without::canonicals
        struct OtherStruct; // 없음(None)

        trait OtherTrait { // 없음(None)
            fn g(&amp;self); // 없음(None)
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl OtherTrait for crate::a::Struct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl crate::a::Trait for OtherStruct {
            fn f(&amp;self) {} // 없음(None)
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="이름-확인"><a class="header" href="#이름-확인">이름 확인</a></h1>
<blockquote>
<p><strong>참고</strong>: 이것은 향후 확장을 위한 플레이스홀더입니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-vis"><a class="rule-link" href="visibility-and-privacy.html#r-vis" title="vis"><span>[vis]<span/></a></div>
<h1 id="가시성과-프라이버시"><a class="header" href="#가시성과-프라이버시">가시성과 프라이버시</a></h1>
<div class="rule" id="r-vis.syntax"><a class="rule-link" href="visibility-and-privacy.html#r-vis.syntax" title="vis.syntax"><span>[vis<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>Visibility</em> :<br />
      <code>pub</code><br />
   | <code>pub</code> <code>(</code> <code>crate</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>self</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>super</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>in</code> <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>)</code></p>
</blockquote>
<div class="rule" id="r-vis.intro"><a class="rule-link" href="visibility-and-privacy.html#r-vis.intro" title="vis.intro"><span>[vis<wbr>.intro]<span/></a></div>
<p>이 두 용어는 종종 혼용되어 사용되며, 이들이 전달하고자 하는 것은 “이 아이템을 이 위치에서 사용할 수 있는가?“라는 질문에 대한 답변입니다.</p>
<div class="rule" id="r-vis.name-hierarchy"><a class="rule-link" href="visibility-and-privacy.html#r-vis.name-hierarchy" title="vis.name-hierarchy"><span>[vis<wbr>.name-hierarchy]<span/></a></div>
<p>러스트의 이름 확인(name resolution)은 네임스페이스의 전역 계층 구조 위에서 작동합니다. 계층 구조의 각 레벨은 어떤 아이템으로 생각할 수 있습니다. 아이템은 위에서 언급된 것들 중 하나이거나 외부 크레이트도 포함합니다. 새로운 모듈을 선언하거나 정의하는 것은 정의된 위치의 계층 구조에 새로운 트리를 삽입하는 것으로 생각할 수 있습니다.</p>
<div class="rule" id="r-vis.privacy"><a class="rule-link" href="visibility-and-privacy.html#r-vis.privacy" title="vis.privacy"><span>[vis<wbr>.privacy]<span/></a></div>
<p>인터페이스가 모듈 간에 사용될 수 있는지 제어하기 위해, 러스트는 각 아이템의 사용이 허용되어야 하는지 여부를 확인합니다. 여기서 프라이버시 경고가 생성되거나, 그렇지 않으면 “다른 모듈의 비공개 아이템을 사용했으며 이는 허용되지 않습니다“라는 오류가 발생합니다.</p>
<div class="rule" id="r-vis.default"><a class="rule-link" href="visibility-and-privacy.html#r-vis.default" title="vis.default"><span>[vis<wbr>.default]<span/></a></div>
<p>기본적으로 모든 것은 _비공개(private)_이며, 두 가지 예외가 있습니다: <code>pub</code> 트레잇의 연관 아이템은 기본적으로 공개이며, <code>pub</code> 열거형의 열거형 변형(Enum variants) 또한 기본적으로 공개입니다. 아이템이 <code>pub</code>으로 선언되면 외부에서 접근 가능한 것으로 생각할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>// 비공개(private) 구조체를 선언합니다.
struct Foo;

// 비공개 필드를 가진 공개(public) 구조체를 선언합니다.
pub struct Bar {
    field: i32,
}

// 두 개의 공개 변형(variants)을 가진 공개 열거형을 선언합니다.
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}</code></pre></pre>
<div class="rule" id="r-vis.access"><a class="rule-link" href="visibility-and-privacy.html#r-vis.access" title="vis.access"><span>[vis<wbr>.access]<span/></a></div>
<p>아이템이 공개 또는 비공개라는 개념과 함께, 러스트는 다음 두 가지 경우에 아이템 접근을 허용합니다:</p>
<ol>
<li>아이템이 공개라면, 모듈 <code>m</code>에서 아이템의 모든 조상 모듈에 접근할 수 있는 경우 <code>m</code> 외부에서 해당 아이템에 접근할 수 있습니다. 또한 재내보내기(re-exports)를 통해 해당 아이템의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</li>
<li>아이템이 비공개라면, 현재 모듈과 그 하위 모듈들에서만 접근할 수 있습니다.</li>
</ol>
<p>이 두 가지 경우는 내부 구현 세부 사항을 숨기면서 공개 API를 노출하는 모듈 계층 구조를 만드는 데 매우 강력합니다. 설명을 돕기 위해 몇 가지 유스케이스와 그에 따른 결과를 소개합니다:</p>
<ul>
<li>
<p>라이브러리 개발자는 자신의 라이브러리에 링크하는 크레이트들에 기능을 노출해야 합니다. 첫 번째 경우의 결과로서, 이는 외부에서 사용 가능한 모든 것이 루트부터 대상 아이템까지 <code>pub</code>이어야 함을 의미합니다. 체인의 어느 한 아이템이라도 비공개라면 외부 접근이 허용되지 않습니다.</p>
</li>
<li>
<p>크레이트 내에서 전역적으로 사용 가능한 “도우미 모듈“이 필요하지만, 이를 공개 API로 노출하고 싶지 않을 수 있습니다. 이를 위해 크레이트 계층 구조의 루트에 비공개 모듈을 두고, 그 내부에 “공개 API“를 갖게 합니다. 크레이트 전체가 루트의 하위 모듈이므로, 두 번째 경우를 통해 로컬 크레이트 전체가 이 비공개 모듈에 접근할 수 있습니다.</p>
</li>
<li>
<p>모듈에 대한 유닛 테스트를 작성할 때, 테스트 대상 모듈의 직계 자식 모듈로 <code>mod test</code>를 두는 것이 일반적인 관례입니다. 이 모듈은 두 번째 경우를 통해 부모 모듈의 모든 아이템에 접근할 수 있으며, 이는 내부 구현 세부 사항도 자식 모듈에서 원활하게 테스트될 수 있음을 의미합니다.</p>
</li>
</ul>
<p>두 번째 경우에서 비공개 아이템이 현재 모듈과 그 하위 모듈들에 의해 “접근될 수 있다“고 언급했는데, 아이템에 접근한다는 것의 정확한 의미는 아이템이 무엇인지에 따라 다릅니다.</p>
<div class="rule" id="r-vis.usage"><a class="rule-link" href="visibility-and-privacy.html#r-vis.usage" title="vis.usage"><span>[vis<wbr>.usage]<span/></a></div>
<p>예를 들어, 모듈에 접근한다는 것은 그 내부를 들여다보는 것(더 많은 아이템을 임포트하기 위해)을 의미합니다. 반면, 함수에 접근한다는 것은 그것을 호출하는 것을 의미합니다. 또한, 경로 표현식과 임포트 문은 대상이 현재 가시성 스코프 내에 있는 경우에만 유효하다는 의미에서 아이템에 접근하는 것으로 간주됩니다.</p>
<p>위에서 설명한 세 가지 경우를 보여주는 프로그램의 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 이 모듈은 비공개이므로 외부 크레이트가 접근할 수 없습니다.
// 하지만 이 현재 크레이트의 루트에서는 비공개이므로,
// 크레이트 내의 모든 모듈은 이 모듈 내의 공개적으로 표시되는 아이템에 접근할 수 있습니다.
mod crate_helper_module {

    // 이 함수는 현재 크레이트 내의 무엇이든 사용할 수 있습니다.
    pub fn crate_helper() {}

    // 이 함수는 크레이트 내의 다른 어떤 곳에서도 사용할 수 *없습니다*.
// `crate_helper_module` 외부에서는 공개적으로 보이지 않으므로,
// 오직 이 현재 모듈과 그 하위 모듈들만 접근할 수 있습니다.
    fn implementation_detail() {}
}

// 이 함수는 "루트에 공개"되어 있으므로 이 라이브러리에 링크하는
// 외부 크레이트가 사용할 수 있습니다.
pub fn public_api() {}

// 'public_api'와 마찬가지로 이 모듈은 공개되어 있어 외부 크레이트가
// 내부를 들여다볼 수 있습니다.
pub mod submodule {
    use crate::crate_helper_module;

    pub fn my_method() {
        // 로컬 크레이트의 모든 아이템은 위의 두 규칙의 조합을 통해
        // 도우미 모듈의 공개 인터페이스를 호출할 수 있습니다.
        crate_helper_module::crate_helper();
    }

    // 이 함수는 `submodule`의 하위 모듈이 아닌 모듈에는 숨겨집니다.
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // 이 모듈은 `submodule`의 하위 모듈이므로 프라이버시 위반 없이
            // `submodule` 내부의 비공개 아이템에 접근하는 것이 허용됩니다.
            super::my_implementation();
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>러스트 프로그램이 프라이버시 검사 단계를 통과하려면 모든 경로가 위에서 언급한 두 규칙에 따라 유효한 접근이어야 합니다. 여기에는 모든 use 문, 표현식, 타입 등이 포함됩니다.</p>
<div class="rule" id="r-vis.scoped"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped" title="vis.scoped"><span>[vis<wbr>.scoped]<span/></a></div>
<h2 id="pubin-path-pubcrate-pubsuper-그리고-pubself"><a class="header" href="#pubin-path-pubcrate-pubsuper-그리고-pubself"><code>pub(in path)</code>, <code>pub(crate)</code>, <code>pub(super)</code>, 그리고 <code>pub(self)</code></a></h2>
<div class="rule" id="r-vis.scoped.intro"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.intro" title="vis.scoped.intro"><span>[vis<wbr>.scoped<wbr>.intro]<span/></a></div>
<p>공개와 비공개 외에도, 러스트는 아이템을 특정 스코프 내에서만 볼 수 있도록 선언할 수 있게 해줍니다. <code>pub</code> 제약 조건에 대한 규칙은 다음과 같습니다:</p>
<div class="rule" id="r-vis.scoped.in"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.in" title="vis.scoped.in"><span>[vis<wbr>.scoped<wbr>.in]<span/></a></div>
<ul>
<li><code>pub(in path)</code>는 제공된 <code>path</code> 내에서 아이템을 볼 수 있게 합니다. <code>path</code>는 가시성이 선언되는 아이템의 조상 모듈로 해석되는 단순 경로(simple path)여야 합니다. <code>path</code> 내의 각 식별자는 모듈을 직접 참조해야 합니다(<code>use</code> 문에 의해 도입된 이름이 아니어야 합니다).</li>
</ul>
<div class="rule" id="r-vis.scoped.crate"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.crate" title="vis.scoped.crate"><span>[vis<wbr>.scoped<wbr>.crate]<span/></a></div>
<ul>
<li><code>pub(crate)</code>는 현재 크레이트 내에서 아이템을 볼 수 있게 합니다.</li>
</ul>
<div class="rule" id="r-vis.scoped.super"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.super" title="vis.scoped.super"><span>[vis<wbr>.scoped<wbr>.super]<span/></a></div>
<ul>
<li><code>pub(super)</code>는 부모 모듈에서 아이템을 볼 수 있게 합니다. 이는 <code>pub(in super)</code>와 동일합니다.</li>
</ul>
<div class="rule" id="r-vis.scoped.self"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.self" title="vis.scoped.self"><span>[vis<wbr>.scoped<wbr>.self]<span/></a></div>
<ul>
<li><code>pub(self)</code>는 현재 모듈에서 아이템을 볼 수 있게 합니다. 이는 <code>pub(in self)</code>와 동일하거나 <code>pub</code>을 전혀 사용하지 않는 것과 같습니다.</li>
</ul>
<div class="rule" id="r-vis.scoped.edition2018"><a class="rule-link" href="visibility-and-privacy.html#r-vis.scoped.edition2018" title="vis.scoped.edition2018"><span>[vis<wbr>.scoped<wbr>.edition2018]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2018 에디션부터 <code>pub(in path)</code>의 경로는 <code>crate</code>, <code>self</code>, 또는 <code>super</code>로 시작해야 합니다. 2015 에디션은 <code>::</code>로 시작하는 경로나 크레이트 루트의 모듈을 사용할 수도 있습니다.</p>
</blockquote>
<p>예제입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2015">pub mod outer_mod {
    pub mod inner_mod {
        // 이 함수는 `outer_mod` 내에서 볼 수 있습니다.
        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}
        // 위와 동일하며, 2015 에디션에서만 유효합니다.
        pub(in outer_mod) fn outer_mod_visible_fn_2015() {}

        // 이 함수는 크레이트 전체에서 볼 수 있습니다.
        pub(crate) fn crate_visible_fn() {}

        // 이 함수는 `outer_mod` 내에서 볼 수 있습니다.
        pub(super) fn super_mod_visible_fn() {
            // 동일한 `mod`에 있으므로 이 함수를 볼 수 있습니다.
            inner_mod_visible_fn();
        }

        // 이 함수는 오직 `inner_mod` 내에서만 볼 수 있으며,
        // 이는 비공개로 두는 것과 같습니다.
        pub(self) fn inner_mod_visible_fn() {}
    }
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();

        // `inner_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
        // 오류! `inner_mod_visible_fn`은 비공개입니다.
        //inner_mod::inner_mod_visible_fn();
    }
}

fn bar() {
    // 동일한 크레이트에 있으므로 이 함수는 여전히 보입니다.
    outer_mod::inner_mod::crate_visible_fn();

    // `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
    // 오류! `super_mod_visible_fn`은 비공개입니다.
    //outer_mod::inner_mod::super_mod_visible_fn();

    // `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
    // 오류! `outer_mod_visible_fn`은 비공개입니다.
    //outer_mod::inner_mod::outer_mod_visible_fn();

    outer_mod::foo();
}

fn main() { bar() }</code></pre></pre>
<blockquote>
<p><strong>참고:</strong> 이 구문은 아이템의 가시성에 또 다른 제약 조건을 추가할 뿐입니다. 아이템이 지정된 스코프의 모든 부분에서 보인다는 것을 보장하지는 않습니다. 아이템에 접근하려면, 현재 스코프에 이르기까지의 모든 부모 아이템들도 보여야 합니다.</p>
</blockquote>
<div class="rule" id="r-vis.reexports"><a class="rule-link" href="visibility-and-privacy.html#r-vis.reexports" title="vis.reexports"><span>[vis<wbr>.reexports]<span/></a></div>
<h2 id="재내보내기re-exporting와-가시성"><a class="header" href="#재내보내기re-exporting와-가시성">재내보내기(Re-exporting)와 가시성</a></h2>
<div class="rule" id="r-vis.reexports.intro"><a class="rule-link" href="visibility-and-privacy.html#r-vis.reexports.intro" title="vis.reexports.intro"><span>[vis<wbr>.reexports<wbr>.intro]<span/></a></div>
<p>러스트는 <code>pub use</code> 지시어를 통해 아이템을 공개적으로 재내보낼 수 있게 해줍니다. 이것은 공개 지시어이므로, 위의 규칙에 따라 현재 모듈에서 해당 아이템을 사용할 수 있게 됩니다. 본질적으로 재내보낸 아이템에 대한 공개 접근을 허용하는 것입니다. 예를 들어, 다음 프로그램은 유효합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub use self::implementation::api;

mod implementation {
    pub mod api {
        pub fn f() {}
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>즉, <code>implementation::api::f</code>를 참조하는 외부 크레이트는 프라이버시 위반 오류를 받게 되지만, <code>api::f</code> 경로는 허용됩니다.</p>
<div class="rule" id="r-vis.reexports.private-item"><a class="rule-link" href="visibility-and-privacy.html#r-vis.reexports.private-item" title="vis.reexports.private-item"><span>[vis<wbr>.reexports<wbr>.private-item]<span/></a></div>
<p>비공개 아이템을 재내보낼 때, 이는 “프라이버시 체인“이 일반적인 네임스페이스 계층 구조를 거치지 않고 재내보내기를 통해 단락(short-circuited)되는 것을 허용하는 것으로 생각할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-모델"><a class="header" href="#메모리-모델">메모리 모델</a></h1>
<p>러스트는 아직 정의된 메모리 모델이 없습니다. 다양한 학계 및 산업계 전문가들이 여러 제안을 작업 중이지만, 현재로서는 언어에서 명확히 정의되지 않은 부분입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-alloc"><a class="rule-link" href="memory-allocation-and-lifetime.html#r-alloc" title="alloc"><span>[alloc]<span/></a></div>
<h1 id="메모리-할당과-라이프타임"><a class="header" href="#메모리-할당과-라이프타임">메모리 할당과 라이프타임</a></h1>
<div class="rule" id="r-alloc.static"><a class="rule-link" href="memory-allocation-and-lifetime.html#r-alloc.static" title="alloc.static"><span>[alloc<wbr>.static]<span/></a></div>
<p>프로그램의 _아이템(items)_은 컴파일 시간에 값이 계산되고 러스트 프로세스의 메모리 이미지에 고유하게 저장되는 함수, 모듈, 타입들입니다. 아이템은 동적으로 할당되거나 해제되지 않습니다.</p>
<div class="rule" id="r-alloc.dynamic"><a class="rule-link" href="memory-allocation-and-lifetime.html#r-alloc.dynamic" title="alloc.dynamic"><span>[alloc<wbr>.dynamic]<span/></a></div>
<p>_힙(heap)_은 박스(boxes)를 설명하는 일반적인 용어입니다. 힙 할당의 수명은 이를 가리키는 박스 값의 수명에 따라 달라집니다. 박스 값 자체가 스택 프레임(frame) 내외부로 전달되거나 힙에 저장될 수 있으므로, 힙 할당은 할당된 프레임보다 더 오래 지속될 수 있습니다. 힙 할당은 할당된 전체 수명 동안 힙의 단일 위치에 머무르는 것이 보장됩니다. 즉, 박스 값을 이동하더라도 재배치되지 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-variable"><a class="rule-link" href="variables.html#r-variable" title="variable"><span>[variable]<span/></a></div>
<h1 id="변수"><a class="header" href="#변수">변수</a></h1>
<div class="rule" id="r-variable.intro"><a class="rule-link" href="variables.html#r-variable.intro" title="variable.intro"><span>[variable<wbr>.intro]<span/></a></div>
<p>_변수(variable)_는 스택 프레임의 구성 요소로, 이름을 가진 함수 파라미터, 익명 <a href="expressions.html#temporaries">임시 값(temporary)</a>, 또는 이름을 가진 지역 변수입니다.</p>
<div class="rule" id="r-variable.local"><a class="rule-link" href="variables.html#r-variable.local" title="variable.local"><span>[variable<wbr>.local]<span/></a></div>
<p><em>지역 변수(local variable)</em>(또는 <em>스택-로컬</em> 할당)는 스택 메모리 내에 할당되어 값을 직접 보관합니다. 이 값은 스택 프레임의 일부입니다.</p>
<div class="rule" id="r-variable.local-mut"><a class="rule-link" href="variables.html#r-variable.local-mut" title="variable.local-mut"><span>[variable<wbr>.local-mut]<span/></a></div>
<p>지역 변수는 별도로 선언하지 않는 한 불변(immutable)입니다. 예: <code>let mut x = ...</code>.</p>
<div class="rule" id="r-variable.param-mut"><a class="rule-link" href="variables.html#r-variable.param-mut" title="variable.param-mut"><span>[variable<wbr>.param-mut]<span/></a></div>
<p>함수 파라미터는 <code>mut</code>로 선언되지 않는 한 불변입니다. <code>mut</code> 키워드는 바로 다음에 오는 파라미터에만 적용됩니다. 예를 들어, <code>|mut x, y|</code>와 <code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code>는 가변 변수 <code>x</code> 하나와 불변 변수 <code>y</code> 하나를 선언합니다.</p>
<div class="rule" id="r-variable.init"><a class="rule-link" href="variables.html#r-variable.init" title="variable.init"><span>[variable<wbr>.init]<span/></a></div>
<p>지역 변수는 할당될 때 초기화되지 않습니다. 대신, 프레임에 진입할 때 프레임에 해당하는 전체 지역 변수가 초기화되지 않은 상태로 할당됩니다. 함수 내의 후속 구문들이 지역 변수를 초기화할 수도 있고 그렇지 않을 수도 있습니다. 지역 변수는 모든 도달 가능한 제어 흐름 경로를 통해 초기화된 후에만 사용할 수 있습니다.</p>
<p>다음 예제에서 <code>init_after_if</code>는 <a href="expressions/if-expr.html#if-expressions"><code>if</code> 표현식</a> 이후에 초기화되지만, <code>uninit_after_if</code>는 <code>else</code> 케이스에서 초기화되지 않으므로 초기화되지 않은 상태로 남습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn random_bool() -&gt; bool { true }
</span>fn initialization_example() {
    let init_after_if: ();
    let uninit_after_if: ();

    if random_bool() {
        init_after_if = ();
        uninit_after_if = ();
    } else {
        init_after_if = ();
    }

    init_after_if; // ok
    // uninit_after_if; // err: 초기화되지 않았을 가능성이 있는 `uninit_after_if` 사용
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-link"><a class="rule-link" href="linkage.html#r-link" title="link"><span>[link]<span/></a></div>
<h1 id="연결"><a class="header" href="#연결">연결</a></h1>
<blockquote>
<p>참고: 이 섹션은 언어 자체보다는 컴파일러 관점에서 설명됩니다.</p>
</blockquote>
<div class="rule" id="r-link.intro"><a class="rule-link" href="linkage.html#r-link.intro" title="link.intro"><span>[link<wbr>.intro]<span/></a></div>
<p>컴파일러는 크레이트들을 정적 및 동적으로 링크하는 다양한 방법을 지원합니다. 이 섹션에서는 크레이트를 연결하는 여러 방법들을 살펴볼 것이며, 네이티브 라이브러리에 대한 더 자세한 정보는 <a href="../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">책의 FFI 섹션</a>에서 찾을 수 있습니다.</p>
<div class="rule" id="r-link.type"><a class="rule-link" href="linkage.html#r-link.type" title="link.type"><span>[link<wbr>.type]<span/></a></div>
<p>한 번의 컴파일 세션에서 컴파일러는 커맨드 라인 플래그나 <code>crate_type</code> 속성을 사용하여 여러 결과물(artifacts)을 생성할 수 있습니다. 하나 이상의 커맨드 라인 플래그가 지정되면 모든 <code>crate_type</code> 속성은 무시되고 커맨드 라인에서 지정된 결과물만 빌드됩니다.</p>
<div class="rule" id="r-link.bin"><a class="rule-link" href="linkage.html#r-link.bin" title="link.bin"><span>[link<wbr>.bin]<span/></a></div>
<ul>
<li><code>--crate-type=bin</code>, <code>#![crate_type = "bin"]</code> - 실행 가능한 프로그램이 생성됩니다. 이 경우 프로그램이 실행될 때 호출될 <code>main</code> 함수가 크레이트 내에 반드시 있어야 합니다. 모든 러스트 및 네이티브 의존성을 링크하여 배포 가능한 단일 바이너리를 생성합니다. 이것이 기본 크레이트 타입입니다.</li>
</ul>
<div class="rule" id="r-link.lib"><a class="rule-link" href="linkage.html#r-link.lib" title="link.lib"><span>[link<wbr>.lib]<span/></a></div>
<ul>
<li><code>--crate-type=lib</code>, <code>#![crate_type = "lib"]</code> - 러스트 라이브러리가 생성됩니다. 라이브러리는 여러 형태로 나타날 수 있기 때문에 무엇이 정확히 생성되는지는 모호할 수 있습니다. 이 일반적인 <code>lib</code> 옵션의 목적은 “컴파일러가 권장하는” 스타일의 라이브러리를 생성하는 것입니다. 생성된 라이브러리는 항상 rustc에서 사용할 수 있지만, 실제 라이브러리 타입은 수시로 바뀔 수 있습니다. 나머지 출력 타입들은 모두 서로 다른 종류의 라이브러리들이며, <code>lib</code> 타입은 그 중 하나에 대한 별칭으로 볼 수 있습니다(실제 타입은 컴파일러가 정의합니다).</li>
</ul>
<div class="rule" id="r-link.dylib"><a class="rule-link" href="linkage.html#r-link.dylib" title="link.dylib"><span>[link<wbr>.dylib]<span/></a></div>
<ul>
<li><code>--crate-type=dylib</code>, <code>#![crate_type = "dylib"]</code> - 동적 러스트 라이브러리가 생성됩니다. 이는 <code>lib</code> 출력 타입과 달리 동적 라이브러리 생성을 강제합니다. 생성된 동적 라이브러리는 다른 라이브러리나 실행 파일의 의존성으로 사용될 수 있습니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<div class="rule" id="r-link.staticlib"><a class="rule-link" href="linkage.html#r-link.staticlib" title="link.staticlib"><span>[link<wbr>.staticlib]<span/></a></div>
<ul>
<li>
<p><code>--crate-type=staticlib</code>, <code>#![crate_type = "staticlib"]</code> - 정적 시스템 라이브러리가 생성됩니다. 이는 다른 라이브러리 출력과 달리, 컴파일러가 <code>staticlib</code> 출력에 링크하려고 시도하지 않습니다. 이 출력 타입의 목적은 로컬 크레이트의 모든 코드와 모든 업스트림 의존성을 포함하는 정적 라이브러리를 만드는 것입니다. 이 출력 타입은 리눅스, macOS 및 윈도우(MinGW)에서는 <code>*.a</code> 파일을, 윈도우(MSVC)에서는 <code>*.lib</code> 파일을 생성합니다. 이 형식은 다른 러스트 코드에 대한 동적 의존성이 없기 때문에, 기존의 비-러스트 애플리케이션에 러스트 코드를 링크하는 것과 같은 상황에서 사용하는 것을 권장합니다.</p>
<p>정적 라이브러리가 가질 수 있는 모든 동적 의존성(예: 시스템 라이브러리에 대한 의존성, 또는 동적 라이브러리로 컴파일된 러스트 라이브러리에 대한 의존성)은 해당 정적 라이브러리를 어딘가에서 링크할 때 수동으로 지정해야 함에 유의하십시오. <code>--print=native-static-libs</code> 플래그가 이 작업에 도움이 될 수 있습니다.</p>
<p>생성된 정적 라이브러리는 표준 라이브러리를 포함한 모든 의존성의 코드를 포함하고 이들의 모든 공개 심볼을 내보내기 때문에, 정적 라이브러리를 실행 파일이나 공유 라이브러리에 링크할 때는 특별한 주의가 필요할 수 있음에 유의하십시오. 공유 라이브러리의 경우, 내보낼 심볼 목록을 링커나 심볼 버전 스크립트, 내보낸 심볼 목록(macOS) 또는 모듈 정의 파일(윈도우) 등을 통해 제한해야 합니다. 또한, 실제로 사용되지 않는 의존성 코드를 모두 제거하기 위해 사용되지 않는 섹션을 제거할 수 있습니다 (예: <code>--gc-sections</code> 또는 macOS의 <code>-dead_strip</code>).</p>
</li>
</ul>
<div class="rule" id="r-link.cdylib"><a class="rule-link" href="linkage.html#r-link.cdylib" title="link.cdylib"><span>[link<wbr>.cdylib]<span/></a></div>
<ul>
<li><code>--crate-type=cdylib</code>, <code>#![crate_type = "cdylib"]</code> - 동적 시스템 라이브러리가 생성됩니다. 이는 다른 언어에서 로드할 동적 라이브러리를 컴파일할 때 사용됩니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<div class="rule" id="r-link.rlib"><a class="rule-link" href="linkage.html#r-link.rlib" title="link.rlib"><span>[link<wbr>.rlib]<span/></a></div>
<ul>
<li><code>--crate-type=rlib</code>, <code>#![crate_type = "rlib"]</code> - “러스트 라이브러리” 파일이 생성됩니다. 이는 중간 생성물로 사용되며 “정적 러스트 라이브러리“라고 생각할 수 있습니다. 이러한 <code>rlib</code> 파일은 <code>staticlib</code> 파일과 달리 향후 링크 시 컴파일러에 의해 해석됩니다. 이는 본질적으로 <code>rustc</code>가 동적 라이브러리에서 메타데이터를 찾는 것처럼 <code>rlib</code> 파일에서도 메타데이터를 찾는다는 것을 의미합니다. 이 출력 형식은 정적으로 링크된 실행 파일과 <code>staticlib</code> 출력을 생성하는 데 사용됩니다.</li>
</ul>
<div class="rule" id="r-link.proc-macro"><a class="rule-link" href="linkage.html#r-link.proc-macro" title="link.proc-macro"><span>[link<wbr>.proc-macro]<span/></a></div>
<ul>
<li><code>--crate-type=proc-macro</code>, <code>#![crate_type = "proc-macro"]</code> - 생성되는 출력은 명시되지 않았지만, <code>-L</code> 경로가 제공되면 컴파일러는 출력 결과물을 매크로로 인식하고 프로그램에 로드할 수 있습니다. 이 크레이트 타입으로 컴파일된 크레이트는 반드시 <a href="procedural-macros.html">절차적 매크로</a>만 내보내야 합니다. 컴파일러는 자동으로 <code>proc_macro</code> <a href="conditional-compilation.html">설정 옵션</a>을 설정합니다. 크레이트는 항상 컴파일러 자체가 빌드된 것과 동일한 타겟으로 컴파일됩니다. 예를 들어, 리눅스 <code>x86_64</code> CPU에서 컴파일러를 실행 중이라면, 다른 타겟을 위해 빌드 중인 다른 크레이트의 의존성일지라도 타겟은 <code>x86_64-unknown-linux-gnu</code>가 됩니다.</li>
</ul>
<div class="rule" id="r-link.repetition"><a class="rule-link" href="linkage.html#r-link.repetition" title="link.repetition"><span>[link<wbr>.repetition]<span/></a></div>
<p>이러한 출력들은 여러 개가 지정된 경우 컴파일러가 재컴파일 없이 각 형식의 출력을 생성한다는 의미에서 중첩 가능함에 유의하십시오. 하지만 이는 동일한 방법으로 지정된 출력에만 적용됩니다. <code>crate_type</code> 속성만 지정된 경우 모두 빌드되지만, 하나 이상의 <code>--crate-type</code> 커맨드 라인 플래그가 지정된 경우 해당 출력들만 빌드됩니다.</p>
<div class="rule" id="r-link.dependency"><a class="rule-link" href="linkage.html#r-link.dependency" title="link.dependency"><span>[link<wbr>.dependency]<span/></a></div>
<p>이러한 다양한 종류의 출력들과 함께, 만약 크레이트 A가 크레이트 B에 의존한다면 컴파일러는 시스템 전체에서 B를 여러 가지 다른 형식으로 찾을 수 있습니다. 하지만 컴파일러가 찾는 유일한 형식은 <code>rlib</code> 형식과 동적 라이브러리 형식입니다. 의존 라이브러리에 대한 이 두 가지 옵션 중에서 컴파일러는 어느 시점에 이 두 형식 중 하나를 선택해야 합니다. 이를 염두에 두고, 컴파일러는 어떤 형식의 의존성을 사용할지 결정할 때 다음 규칙을 따릅니다.</p>
<div class="rule" id="r-link.dependency-staticlib"><a class="rule-link" href="linkage.html#r-link.dependency-staticlib" title="link.dependency-staticlib"><span>[link<wbr>.dependency-staticlib]<span/></a></div>
<ol>
<li>
<p>정적 라이브러리가 생성되는 경우, 모든 업스트림 의존성은 <code>rlib</code> 형식으로 사용 가능해야 합니다. 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환할 수 없다는 이유에서 비롯됩니다.</p>
<p>정적 라이브러리에 네이티브 동적 의존성을 링크하는 것은 불가능하며, 이 경우 링크되지 않은 모든 네이티브 동적 의존성에 대한 경고가 출력됨에 유의하십시오.</p>
</li>
</ol>
<div class="rule" id="r-link.dependency-rlib"><a class="rule-link" href="linkage.html#r-link.dependency-rlib" title="link.dependency-rlib"><span>[link<wbr>.dependency-rlib]<span/></a></div>
<ol start="2">
<li>
<p><code>rlib</code> 파일이 생성되는 경우, 업스트림 의존성이 어떤 형식으로 제공되는지에 대한 제한은 없습니다. 단지 메타데이터를 읽기 위해 모든 업스트림 의존성이 사용 가능해야 합니다.</p>
<p><code>rlib</code> 파일이 <code>libstd.rlib</code> 사본을 포함한다면 그다지 효율적이지 않을 것입니다!</p>
</li>
</ol>
<div class="rule" id="r-link.dependency-prefer-dynamic"><a class="rule-link" href="linkage.html#r-link.dependency-prefer-dynamic" title="link.dependency-prefer-dynamic"><span>[link<wbr>.dependency-prefer-dynamic]<span/></a></div>
<ol start="3">
<li>실행 파일이 생성되고 <code>-C prefer-dynamic</code> 플래그가 지정되지 않은 경우, 먼저 <code>rlib</code> 형식의 의존성을 찾으려고 시도합니다. 일부 의존성을 rlib 형식으로 사용할 수 없는 경우, 동적 링크가 시도됩니다(아래 참조).</li>
</ol>
<div class="rule" id="r-link.dependency-dynamic"><a class="rule-link" href="linkage.html#r-link.dependency-dynamic" title="link.dependency-dynamic"><span>[link<wbr>.dependency-dynamic]<span/></a></div>
<ol start="4">
<li>
<p>동적 라이브러리나 동적으로 링크되는 실행 파일이 생성되는 경우, 컴파일러는 최종 결과물을 만들기 위해 사용 가능한 의존성들을 rlib 또는 dylib 형식 중에서 조정하려고 시도합니다.</p>
<p>컴파일러의 주요 목표는 라이브러리가 어떤 결과물에서도 두 번 이상 나타나지 않도록 보장하는 것입니다. 예를 들어, 만약 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크되어 있다면, A의 사본이 두 개가 되기 때문에 어떤 크레이트도 B와 C를 동시에 링크할 수 없습니다. 컴파일러는 rlib와 dylib 형식의 혼합을 허용하지만, 이 제한 사항은 반드시 준수되어야 합니다.</p>
<p>컴파일러는 현재 라이브러리를 어떤 형식으로 링크해야 하는지에 대한 힌트를 제공하는 방법을 구현하고 있지 않습니다. 동적 링크 시 컴파일러는 일부 의존성을 rlib를 통해 링크하는 것을 허용하면서도 동적 의존성을 최대화하려고 시도합니다.</p>
<p>대부분의 상황에서, 동적 링크를 하는 경우 모든 라이브러리를 dylib로 사용할 수 있도록 하는 것이 권장됩니다. 다른 상황에서 컴파일러는 각 라이브러리를 어떤 형식으로 링크해야 할지 결정할 수 없는 경우 경고를 출력합니다.</p>
</li>
</ol>
<p>일반적으로 모든 컴파일 요구 사항에 대해 <code>--crate-type=bin</code> 또는 <code>--crate-type=lib</code>로 충분하며, 다른 옵션들은 크레이트의 출력 형식에 대해 더 세밀한 제어가 필요한 경우에만 사용 가능합니다.</p>
<div class="rule" id="r-link.crt"><a class="rule-link" href="linkage.html#r-link.crt" title="link.crt"><span>[link<wbr>.crt]<span/></a></div>
<h2 id="정적-및-동적-c-런타임"><a class="header" href="#정적-및-동적-c-런타임">정적 및 동적 C 런타임</a></h2>
<div class="rule" id="r-link.crt.intro"><a class="rule-link" href="linkage.html#r-link.crt.intro" title="link.crt.intro"><span>[link<wbr>.crt<wbr>.intro]<span/></a></div>
<p>표준 라이브러리는 일반적으로 타겟에 적절하게 정적 링크 및 동적 링크 C 런타임을 모두 지원하려고 노력합니다. 예를 들어 <code>x86_64-pc-windows-msvc</code> 및 <code>x86_64-unknown-linux-musl</code> 타겟은 일반적으로 두 런타임을 모두 제공하며 사용자가 원하는 것을 선택합니다. 컴파일러의 모든 타겟은 C 런타임에 링크하는 기본 모드를 가지고 있습니다. 일반적으로 타겟은 기본적으로 동적으로 링크되지만, 다음과 같이 기본적으로 정적인 예외도 있습니다.</p>
<ul>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>i686-unknown-linux-musl</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
</ul>
<div class="rule" id="r-link.crt.crt-static"><a class="rule-link" href="linkage.html#r-link.crt.crt-static" title="link.crt.crt-static"><span>[link<wbr>.crt<wbr>.crt-static]<span/></a></div>
<p>C 런타임의 링크는 <code>crt-static</code> 타겟 기능을 준수하도록 설정됩니다. 이러한 타겟 기능은 일반적으로 컴파일러 자체에 대한 플래그를 통해 커맨드 라인에서 설정됩니다. 예를 들어 정적 런타임을 활성화하려면 다음과 같이 실행합니다.</p>
<pre><code class="language-sh">rustc -C target-feature=+crt-static foo.rs
</code></pre>
<p>반면 C 런타임에 동적으로 링크하려면 다음과 같이 실행합니다.</p>
<pre><code class="language-sh">rustc -C target-feature=-crt-static foo.rs
</code></pre>
<div class="rule" id="r-link.crt.ineffective"><a class="rule-link" href="linkage.html#r-link.crt.ineffective" title="link.crt.ineffective"><span>[link<wbr>.crt<wbr>.ineffective]<span/></a></div>
<p>C 런타임 링크 방식의 전환을 지원하지 않는 타겟은 이 플래그를 무시합니다. 컴파일러가 성공적으로 종료된 후 결과 바이너리를 검사하여 예상대로 링크되었는지 확인하는 것이 좋습니다.</p>
<div class="rule" id="r-link.crt.target_feature"><a class="rule-link" href="linkage.html#r-link.crt.target_feature" title="link.crt.target_feature"><span>[link<wbr>.crt<wbr>.target_feature]<span/></a></div>
<p>크레이트 또한 C 런타임이 어떻게 링크되었는지 알 수 있습니다. 예를 들어, MSVC에서의 코드는 링크되는 런타임에 따라 다르게 컴파일되어야 합니다(예: <code>/MT</code> 또는 <code>/MD</code>). 이 정보는 현재 <a href="conditional-compilation.html#target_feature"><code>cfg</code> 속성의 <code>target_feature</code> 옵션</a>을 통해 제공됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_feature = "crt-static")]
fn foo() {
    println!("C 런타임은 정적으로 링크되어야 함");
}

#[cfg(not(target_feature = "crt-static"))]
fn foo() {
    println!("C 런타임은 동적으로 링크되어야 함");
}
<span class="boring">}</span></code></pre></pre>
<p>또한 Cargo 빌드 스크립트는 <a href="../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">환경 변수</a>를 통해 이 기능에 대해 알 수 있습니다. 빌드 스크립트에서는 다음과 같이 링크 여부를 감지할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::env;

fn main() {
    let linkage = env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or(String::new());

    if linkage.contains("crt-static") {
        println!("C 런타임은 정적으로 링크될 것임");
    } else {
        println!("C 런타임은 동적으로 링크될 것임");
    }
}</code></pre></pre>
<p>로컬에서 이 기능을 사용하려면 일반적으로 <code>RUSTFLAGS</code> 환경 변수를 사용하여 Cargo를 통해 컴파일러 플래그를 지정합니다. 예를 들어 MSVC에서 정적으로 링크된 바이너리를 컴파일하려면 다음과 같이 실행합니다:</p>
<pre><code class="language-sh">RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc
</code></pre>
<h2 id="러스트와-외부-코드베이스의-혼합"><a class="header" href="#러스트와-외부-코드베이스의-혼합">러스트와 외부 코드베이스의 혼합</a></h2>
<p>러스트를 외부 코드(예: C, C++)와 혼합하여 두 종류의 코드를 모두 포함하는 단일 바이너리를 만들고자 한다면, 최종 바이너리 링크를 위해 두 가지 접근 방식이 있습니다.</p>
<ul>
<li><code>rustc</code>를 사용합니다. 비-러스트 라이브러리는 <code>rustc</code> 인자인 <code>-L &lt;directory&gt;</code> 및 <code>-l&lt;library&gt;</code>를 사용하거나 러스트 코드의 <code>#[link]</code> 지시어를 통해 전달합니다. <code>.o</code> 파일에 링크해야 한다면 <code>-Clink-arg=file.o</code>를 사용할 수 있습니다.</li>
<li>외부 링커를 사용합니다. 이 경우, 먼저 러스트 <code>staticlib</code> 타겟을 생성하고 이를 외부 링커 호출 시 전달해야 합니다. 여러 개의 러스트 서브시스템을 링크해야 한다면, 여러 개의 <code>extern crate</code> 문을 사용하여 여러 러스트 <code>rlib</code>를 포함하는 단일 <code>staticlib</code>를 생성해야 할 수도 있습니다. 여러 개의 러스트 <code>staticlib</code> 파일은 충돌할 가능성이 높습니다.</li>
</ul>
<p>러스트 <code>rlib</code>를 외부 링커에 직접 전달하는 것은 현재 지원되지 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-asm"><a class="rule-link" href="inline-assembly.html#r-asm" title="asm"><span>[asm]<span/></a></div>
<h1 id="인라인-어셈블리"><a class="header" href="#인라인-어셈블리">인라인 어셈블리</a></h1>
<div class="rule" id="r-asm.intro"><a class="rule-link" href="inline-assembly.html#r-asm.intro" title="asm.intro"><span>[asm<wbr>.intro]<span/></a></div>
<p>인라인 어셈블리에 대한 지원은 <a href="../core/arch/macro.asm.html"><code>asm!</code></a> 및 <a href="../core/arch/macro.global_asm.html"><code>global_asm!</code></a> 매크로를 통해 제공됩니다. 이들은 컴파일러가 생성하는 어셈블리 출력에 직접 작성한 어셈블리를 삽입하는 데 사용됩니다.</p>
<div class="rule" id="r-asm.stable-targets"><a class="rule-link" href="inline-assembly.html#r-asm.stable-targets" title="asm.stable-targets"><span>[asm<wbr>.stable-targets]<span/></a></div>
<p>인라인 어셈블리 지원은 다음 아키텍처에서 안정화되었습니다:</p>
<ul>
<li>x86 및 x86-64</li>
<li>ARM</li>
<li>AArch64 및 Arm64EC</li>
<li>RISC-V</li>
<li>LoongArch</li>
<li>s390x</li>
</ul>
<p>지원되지 않는 타겟에서 <code>asm!</code>을 사용하면 컴파일러가 오류를 발생시킵니다.</p>
<div class="rule" id="r-asm.example"><a class="rule-link" href="inline-assembly.html#r-asm.example" title="asm.example"><span>[asm<wbr>.example]<span/></a></div>
<h2 id="예시-5"><a class="header" href="#예시-5">예시</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

// 시프트와 덧셈을 사용하여 x에 6을 곱합니다.
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.syntax"><a class="rule-link" href="inline-assembly.html#r-asm.syntax" title="asm.syntax"><span>[asm<wbr>.syntax]<span/></a></div>
<h2 id="구문-1"><a class="header" href="#구문-1">구문</a></h2>
<p>다음 ABNF는 일반적인 구문을 명시합니다:</p>
<pre><code class="language-text">format_string := STRING_LITERAL / RAW_STRING_LITERAL
dir_spec := "in" / "out" / "lateout" / "inout" / "inlateout"
reg_spec := &lt;register class&gt; / "\"" &lt;explicit register&gt; "\""
operand_expr := expr / "_" / expr "=&gt;" expr / expr "=&gt;" "_"
reg_operand := [ident "="] dir_spec "(" reg_spec ")" operand_expr / sym &lt;path&gt; / const &lt;expr&gt;
clobber_abi := "clobber_abi(" &lt;abi&gt; *("," &lt;abi&gt;) [","] ")"
option := "pure" / "nomem" / "readonly" / "preserves_flags" / "noreturn" / "nostack" / "att_syntax" / "raw"
options := "options(" option *("," option) [","] ")"
operand := reg_operand / clobber_abi / options
asm := "asm!(" format_string *("," format_string) *("," operand) [","] ")"
global_asm := "global_asm!(" format_string *("," format_string) *("," operand) [","] ")"
</code></pre>
<div class="rule" id="r-asm.scope"><a class="rule-link" href="inline-assembly.html#r-asm.scope" title="asm.scope"><span>[asm<wbr>.scope]<span/></a></div>
<h2 id="스코프-1"><a class="header" href="#스코프-1">스코프</a></h2>
<div class="rule" id="r-asm.scope.intro"><a class="rule-link" href="inline-assembly.html#r-asm.scope.intro" title="asm.scope.intro"><span>[asm<wbr>.scope<wbr>.intro]<span/></a></div>
<p>인라인 어셈블리는 두 가지 방법 중 하나로 사용될 수 있습니다.</p>
<div class="rule" id="r-asm.scope.asm"><a class="rule-link" href="inline-assembly.html#r-asm.scope.asm" title="asm.scope.asm"><span>[asm<wbr>.scope<wbr>.asm]<span/></a></div>
<p><code>asm!</code> 매크로를 사용하면, 어셈블리 코드는 함수 스코프에서 배출되어 컴파일러가 생성한 함수의 어셈블리 코드와 통합됩니다. 이 어셈블리 코드는 정의되지 않은 동작을 피하기 위해 <a href="inline-assembly.html#rules-for-inline-assembly">엄격한 규칙</a>을 따라야 합니다. 경우에 따라 컴파일러는 어셈블리 코드를 별도의 함수로 배출하고 그 함수에 대한 호출을 생성할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>unsafe { core::arch::asm!("/* {} */", in(reg) 0); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.scope.global_asm"><a class="rule-link" href="inline-assembly.html#r-asm.scope.global_asm" title="asm.scope.global_asm"><span>[asm<wbr>.scope<wbr>.global_asm]<span/></a></div>
<p>With the <code>global_asm!</code> macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly code, and generally provides much more freedom to use arbitrary registers and assembler directives.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>core::arch::global_asm!("/* {} */", const 0);</code></pre></pre>
<div class="rule" id="r-asm.ts-args"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args" title="asm.ts-args"><span>[asm<wbr>.ts-args]<span/></a></div>
<h2 id="템플릿-문자열-인자"><a class="header" href="#템플릿-문자열-인자">템플릿 문자열 인자</a></h2>
<div class="rule" id="r-asm.ts-args.syntax"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.syntax" title="asm.ts-args.syntax"><span>[asm<wbr>.ts-args<wbr>.syntax]<span/></a></div>
<p>어셈블러 템플릿은 <a href="../alloc/fmt/index.html#syntax">포맷 문자열</a>과 동일한 구문을 사용합니다 (즉, 플레이스홀더는 중괄호로 지정됩니다).</p>
<div class="rule" id="r-asm.ts-args.order"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.order" title="asm.ts-args.order"><span>[asm<wbr>.ts-args<wbr>.order]<span/></a></div>
<p>해당 인자들은 순서대로, 인덱스로, 또는 이름으로 접근됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
let y: i64;
let z: i64;
// 이것과
unsafe { core::arch::asm!("mov {}, {}", out(reg) x, in(reg) 5); }
// ... 이것
unsafe { core::arch::asm!("mov {0}, {1}", out(reg) y, in(reg) 5); }
// ... 그리고 이것은
unsafe { core::arch::asm!("mov {out}, {in}", out = out(reg) z, in = in(reg) 5); }
// 모두 동일하게 동작합니다.
assert_eq!(x, y);
assert_eq!(y, z);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.no-implicit"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.no-implicit" title="asm.ts-args.no-implicit"><span>[asm<wbr>.ts-args<wbr>.no-implicit]<span/></a></div>
<p>하지만, (<a href="https://github.com/rust-lang/rfcs/pull/2795">RFC #2795</a>에서 도입된) 암시적 명명된 인자(implicit named arguments)는 지원되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 스코프에서 직접 `x`를 참조할 수 없으며, `in(reg) x`와 같은 피연산자가 필요합니다.
unsafe { core::arch::asm!("/* {x} */"); } // 오류: x라는 이름의 인자가 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.one-or-more"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.one-or-more" title="asm.ts-args.one-or-more"><span>[asm<wbr>.ts-args<wbr>.one-or-more]<span/></a></div>
<p><code>asm!</code> 호출은 하나 이상의 템플릿 문자열 인자를 가질 수 있습니다. 여러 개의 템플릿 문자열 인자가 있는 <code>asm!</code>은 모든 문자열이 사이에 <code>\n</code>을 두고 연결된 것처럼 처리됩니다. 권장되는 사용법은 각 템플릿 문자열 인자가 어셈블리 코드의 한 줄에 대응하도록 하는 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
let y: i64;
// 여러 문자열을 마치 함께 작성된 것처럼 분리할 수 있습니다.
unsafe { core::arch::asm!("mov eax, 5", "mov ecx, eax", out("rax") x, out("rcx") y); }
assert_eq!(x, y);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.before-other-args"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.before-other-args" title="asm.ts-args.before-other-args"><span>[asm<wbr>.ts-args<wbr>.before-other-args]<span/></a></div>
<p>모든 템플릿 문자열 인자는 다른 인자들보다 먼저 나타나야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 템플릿 문자열은 asm 호출에서 가장 먼저 나타나야 합니다.
unsafe { core::arch::asm!("/* {x} */", x = const 5, "ud2"); } // 오류: 예상치 못한 토큰
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.positional-first"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.positional-first" title="asm.ts-args.positional-first"><span>[asm<wbr>.ts-args<wbr>.positional-first]<span/></a></div>
<p>포맷 문자열과 마찬가지로, 위치 기반 인자(positional arguments)는 명명된 인자나 명시적 <a href="inline-assembly.html#register-operands">레지스터 피연산자</a>보다 먼저 나타나야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 명명된 피연산자는 위치 기반 피연산자 뒤에 와야 합니다.
unsafe { core::arch::asm!("/* {x} {} */", x = const 5, in(reg) 5); }
// 오류: 위치 기반 인자는 명명된 인자나 명시적 레지스터 인자 뒤에 올 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 또한 위치 기반 피연산자 앞에 명시적 레지스터를 둘 수 없습니다.
unsafe { core::arch::asm!("/* {} */", in("eax") 0, in(reg) 5); }
// 오류: 위치 기반 인자는 명명된 인자나 명시적 레지스터 인자 뒤에 올 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.register-operands"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.register-operands" title="asm.ts-args.register-operands"><span>[asm<wbr>.ts-args<wbr>.register-operands]<span/></a></div>
<p>명시적 레지스터 피연산자는 템플릿 문자열의 플레이스홀더에서 사용될 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 명시적 레지스터 피연산자는 치환되지 않으므로, 문자열에서 `eax`를 명시적으로 사용하십시오.
unsafe { core::arch::asm!("/* {} */", in("eax") 5); }
// 오류: 인덱스 0의 인자에 대한 잘못된 참조
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.at-least-once"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.at-least-once" title="asm.ts-args.at-least-once"><span>[asm<wbr>.ts-args<wbr>.at-least-once]<span/></a></div>
<p>다른 모든 명명된 및 위치 기반 피연산자는 템플릿 문자열에 최소 한 번 이상 나타나야 하며, 그렇지 않으면 컴파일러 오류가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 포맷 문자열에서 모든 피연산자의 이름을 지정해야 합니다.
unsafe { core::arch::asm!("", in(reg) 5, x = const 5); }
// 오류: 사용되지 않은 여러 개의 asm 인자가 있습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.ts-args.opaque"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.opaque" title="asm.ts-args.opaque"><span>[asm<wbr>.ts-args<wbr>.opaque]<span/></a></div>
<p>정확한 어셈블리 코드 구문은 타겟에 따라 다르며, 피연산자가 템플릿 문자열에 치환되어 어셈블러에 전달될 코드를 형성하는 방식을 제외하고는 컴파일러에게 불투명(opaque)합니다.</p>
<div class="rule" id="r-asm.ts-args.llvm-syntax"><a class="rule-link" href="inline-assembly.html#r-asm.ts-args.llvm-syntax" title="asm.ts-args.llvm-syntax"><span>[asm<wbr>.ts-args<wbr>.llvm-syntax]<span/></a></div>
<p>현재 모든 지원되는 타겟은 LLVM 내부 어셈블러에서 사용하는 어셈블리 코드 구문을 따르며, 이는 대개 GNU 어셈블러(GAS)의 구문과 일치합니다. x86에서는 기본적으로 GAS의 <code>.intel_syntax noprefix</code> 모드가 사용됩니다. ARM에서는 <code>.syntax unified</code> 모드가 사용됩니다. 이러한 타겟들은 어셈블리 코드에 추가적인 제약을 가합니다. 즉, 모든 어셈블러 상태(예: <code>.section</code>으로 변경될 수 있는 현재 섹션)는 asm 문자열의 끝에서 원래 값으로 복구되어야 합니다. GAS 구문을 따르지 않는 어셈블리 코드는 어셈블러에 따라 다른 동작을 유발할 수 있습니다. 인라인 어셈블리에서 사용되는 지시어(directives)에 대한 추가적인 제약 조건은 <a href="inline-assembly.html#directives-support">지시어 지원</a> 섹션에 명시되어 있습니다.</p>
<div class="rule" id="r-asm.operand-type"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type" title="asm.operand-type"><span>[asm<wbr>.operand-type]<span/></a></div>
<h2 id="피연산자-타입"><a class="header" href="#피연산자-타입">피연산자 타입</a></h2>
<div class="rule" id="r-asm.operand-type.supported-operands"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands" title="asm.operand-type.supported-operands"><span>[asm<wbr>.operand-type<wbr>.supported-operands]<span/></a></div>
<p>여러 종류의 피연산자가 지원됩니다:</p>
<div class="rule" id="r-asm.operand-type.supported-operands.in"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.in" title="asm.operand-type.supported-operands.in"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.in]<span/></a></div>
<ul>
<li><code>in(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>할당된 레지스터는 asm 코드의 시작 시점에 <code>&lt;expr&gt;</code>의 값을 갖게 됩니다.</li>
<li>할당된 레지스터는 asm 코드의 끝에서도 동일한 값을 유지해야 합니다(동일한 레지스터에 <code>lateout</code>이 할당된 경우는 제외).</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// `in`은 인라인 어셈블리에 값을 전달하는 데 사용될 수 있습니다...
unsafe { core::arch::asm!("/* {} */", in(reg) 5); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.out"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.out" title="asm.operand-type.supported-operands.out"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.out]<span/></a></div>
<ul>
<li><code>out(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>할당된 레지스터는 asm 코드 시작 시점에 정의되지 않은(undefined) 값을 갖게 됩니다.</li>
<li><code>&lt;expr&gt;</code>은 (초기화되지 않았을 수도 있는) 장소 표현식(place expression)이어야 하며, asm 코드의 끝에서 할당된 레지스터의 내용이 여기에 기록됩니다.</li>
<li>표현식 대신 밑줄(<code>_</code>)을 지정할 수 있으며, 이 경우 asm 코드 끝에서 레지스터의 내용이 버려집니다(실질적으로 클로버(clobber)로 작동함).</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// 그리고 `out`은 값을 다시 러스트로 전달하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("/* {} */", out(reg) x); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.lateout"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.lateout" title="asm.operand-type.supported-operands.lateout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.lateout]<span/></a></div>
<ul>
<li><code>lateout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>out</code>과 동일하지만, 레지스터 할당기가 <code>in</code>에 할당된 레지스터를 재사용할 수 있습니다.</li>
<li>모든 입력이 읽힌 후에만 레지스터에 기록해야 합니다. 그렇지 않으면 입력을 덮어쓸(clobber) 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// `lateout`은 `out`과 동일하지만,
// 우리가 값을 덮어쓸 시점에 입력값들에 대해 더 이상 신경 쓰지 않는다는 것을
// 컴파일러가 알고 있습니다.
unsafe { core::arch::asm!("mov {}, 5", lateout(reg) x); }
assert_eq!(x, 5)
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.inout"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.inout" title="asm.operand-type.supported-operands.inout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inout]<span/></a></div>
<ul>
<li><code>inout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>할당된 레지스터는 asm 코드의 시작 시점에 <code>&lt;expr&gt;</code>의 값을 갖게 됩니다.</li>
<li><code>&lt;expr&gt;</code>은 가변적이고 초기화된 장소 표현식이어야 하며, asm 코드의 끝에서 할당된 레지스터의 내용이 여기에 기록됩니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64 = 4;
// `inout`은 레지스터 내에서 값을 수정하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.inout-arrow"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.inout-arrow" title="asm.operand-type.supported-operands.inout-arrow"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inout-arrow]<span/></a></div>
<ul>
<li><code>inout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li><code>inout</code>과 동일하지만, 레지스터의 초기값이 <code>&lt;in expr&gt;</code>의 값에서 취해집니다.</li>
<li><code>&lt;out expr&gt;</code>은 (초기화되지 않았을 수도 있는) 장소 표현식이어야 하며, asm 코드의 끝에서 할당된 레지스터의 내용이 여기에 기록됩니다.</li>
<li><code>&lt;out expr&gt;</code> 대신 밑줄(<code>_</code>)을 지정할 수 있으며, 이 경우 asm 코드 끝에서 레지스터의 내용이 버려집니다(실질적으로 클로버로 작동함).</li>
<li><code>&lt;in expr&gt;</code>과 <code>&lt;out expr&gt;</code>은 서로 다른 타입을 가질 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// `inout`은 또한 값을 다른 장소로 이동시킬 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) 4u64=&gt;x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.inlateout"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.inlateout" title="asm.operand-type.supported-operands.inlateout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inlateout]<span/></a></div>
<ul>
<li><code>inlateout(&lt;reg&gt;) &lt;expr&gt;</code> / <code>inlateout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li><code>inout</code>과 동일하지만, 레지스터 할당기가 <code>in</code>에 할당된 레지스터를 재사용할 수 있습니다(이는 컴파일러가 <code>in</code>이 <code>inlateout</code>과 동일한 초기값을 갖는다는 것을 아는 경우 발생할 수 있습니다).</li>
<li>모든 입력이 읽힌 후에만 레지스터에 기록해야 합니다. 그렇지 않으면 입력을 덮어쓸(clobber) 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64 = 4;
// `inlateout`은 `lateout`을 사용하는 `inout`입니다.
unsafe { core::arch::asm!("inc {}", inlateout(reg) x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.supported-operands.sym"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.supported-operands.sym" title="asm.operand-type.supported-operands.sym"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.sym]<span/></a></div>
<ul>
<li><code>sym &lt;path&gt;</code>
<ul>
<li><code>&lt;path&gt;</code>는 <code>fn</code> 또는 <code>static</code>을 참조해야 합니다.</li>
<li>해당 아이템을 참조하는 맹글링된(mangled) 심볼 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>치환된 문자열에는 어떠한 수식어(예: GOT, PLT, 재배치(relocations) 등)도 포함되지 않습니다.</li>
<li><code>&lt;path&gt;</code>는 <code>#[thread_local]</code> 정적 변수를 가리킬 수 있으며, 이 경우 asm 코드는 심볼을 재배치(relocations, 예: <code>@plt</code>, <code>@TPOFF</code>)와 결합하여 스레드 로컬 데이터를 읽을 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() {
    println!("Hello from inline assembly")
}
// `sym`은 (직접 쓸 수 있는 외부 이름이 없는 경우에도) 함수를 참조하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("call {}", sym foo, clobber_abi("C")); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<ul>
<li><code>const &lt;expr&gt;</code>
<ul>
<li><code>&lt;expr&gt;</code>은 정수 상수 표현식이어야 합니다. 이 표현식은 인라인 <code>const</code> 블록과 동일한 규칙을 따릅니다.</li>
<li>표현식의 타입은 모든 정수 타입이 될 수 있지만, 정수 리터럴과 마찬가지로 기본값은 <code>i32</code>입니다.</li>
<li>표현식의 값은 문자열로 포맷되어 asm 템플릿 문자열에 직접 치환됩니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// swizzle [0, 1, 2, 3] =&gt; [3, 2, 0, 1]
const SHUFFLE: u8 = 0b01_00_10_11;
let x: core::arch::x86_64::__m128 = unsafe { core::mem::transmute([0u32, 1u32, 2u32, 3u32]) };
let y: core::arch::x86_64::__m128;
// `pshufd`와 같이 즉시값(immediate)을 기대하는 명령어에 상수 값을 전달합니다.
unsafe {
    core::arch::asm!("pshufd {xmm}, {xmm}, {shuffle}",
        xmm = inlateout(xmm_reg) x=&gt;y,
        shuffle = const SHUFFLE
    );
}
let y: [u32; 4] = unsafe { core::mem::transmute(y) };
assert_eq!(y, [3, 2, 0, 1]);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.left-to-right"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.left-to-right" title="asm.operand-type.left-to-right"><span>[asm<wbr>.operand-type<wbr>.left-to-right]<span/></a></div>
<p>피연산자 표현식은 함수 호출 인자와 마찬가지로 왼쪽에서 오른쪽으로 평가됩니다. <code>asm!</code>이 실행된 후, 출력값들은 왼쪽에서 오른쪽 순서로 기록됩니다. 이는 두 개의 출력이 동일한 장소를 가리킬 때 중요합니다. 해당 장소는 가장 오른쪽에 있는 출력값을 갖게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut y: i64;
// y는 첫 번째 출력이 아니라 두 번째 출력에서 값을 가져옵니다.
unsafe { core::arch::asm!("mov {}, 0", "mov {}, 1", out(reg) y, out(reg) y); }
assert_eq!(y, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.operand-type.global_asm-restriction"><a class="rule-link" href="inline-assembly.html#r-asm.operand-type.global_asm-restriction" title="asm.operand-type.global_asm-restriction"><span>[asm<wbr>.operand-type<wbr>.global_asm-restriction]<span/></a></div>
<p><code>global_asm!</code>은 함수 외부에 존재하므로, <code>sym</code> 및 <code>const</code> 피연산자만 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">fn main() {}
</span>let x = 5;
// 함수 내부에 있지 않으므로 레지스터 피연산자는 허용되지 않습니다.
<span class="boring">#[cfg(target_arch = "x86_64")]
</span>core::arch::global_asm!("", in(reg) 5);
// 오류: `in` 피연산자는 `global_asm!`과 함께 사용될 수 없습니다.
<span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>fn foo() {}

<span class="boring">#[cfg(target_arch = "x86_64")]
</span>// 하지만 `const`와 `sym`은 모두 허용됩니다.
core::arch::global_asm!("/* {} {} */", const 0, sym foo);</code></pre></pre>
<div class="rule" id="r-asm.register-operands"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands" title="asm.register-operands"><span>[asm<wbr>.register-operands]<span/></a></div>
<h2 id="레지스터-피연산자"><a class="header" href="#레지스터-피연산자">레지스터 피연산자</a></h2>
<div class="rule" id="r-asm.register-operands.register-or-class"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.register-or-class" title="asm.register-operands.register-or-class"><span>[asm<wbr>.register-operands<wbr>.register-or-class]<span/></a></div>
<p>입력 및 출력 피연산자는 명시적 레지스터로 지정하거나, 레지스터 할당기가 레지스터를 선택할 수 있는 레지스터 클래스로 지정할 수 있습니다. 명시적 레지스터는 문자열 리터럴(예: <code>"eax"</code>)로 지정되며, 레지스터 클래스는 식별자(예: <code>reg</code>)로 지정됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut y: i64;
// `reg` 또는 `eax`와 같은 명시적 레지스터를 지정하여 정수 레지스터를 얻을 수 있습니다.
unsafe { core::arch::asm!("mov eax, {:e}", in(reg) 5, lateout("eax") y); }
assert_eq!(y, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.equivalence-to-base-register"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.equivalence-to-base-register" title="asm.register-operands.equivalence-to-base-register"><span>[asm<wbr>.register-operands<wbr>.equivalence-to-base-register]<span/></a></div>
<p>명시적 레지스터는 레지스터 별칭(예: ARM의 <code>r14</code> 대 <code>lr</code>) 및 레지스터의 더 작은 뷰(예: <code>eax</code> 대 <code>rax</code>)를 베이스 레지스터와 동일하게 취급함에 유의하십시오.</p>
<div class="rule" id="r-asm.register-operands.error-two-operands"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.error-two-operands" title="asm.register-operands.error-two-operands"><span>[asm<wbr>.register-operands<wbr>.error-two-operands]<span/></a></div>
<p>두 개의 입력 피연산자 또는 두 개의 출력 피연산자에 동일한 명시적 레지스터를 사용하는 것은 컴파일 타임 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// eax를 두 번 지정할 수 없습니다.
unsafe { core::arch::asm!("", in("eax") 5, in("eax") 4); }
// 오류: `eax` 레지스터가 `eax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// ... 서로 다른 별칭을 사용하더라도 마찬가지입니다.
unsafe { core::arch::asm!("", in("ax") 5, in("rax") 4); }
// 오류: `rax` 레지스터가 `ax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.error-overlapping"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.error-overlapping" title="asm.register-operands.error-overlapping"><span>[asm<wbr>.register-operands<wbr>.error-overlapping]<span/></a></div>
<p>또한, 입력 피연산자 또는 출력 피연산자에서 겹치는 레지스터(예: ARM VFP)를 사용하는 것도 컴파일 타임 오류입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// al은 ax와 겹치므로 둘 다 지정할 수 없습니다.
unsafe { core::arch::asm!("", in("ax") 5, in("al") 4i8); }
// 오류: `al` 레지스터가 `ax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.allowed-types"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.allowed-types" title="asm.register-operands.allowed-types"><span>[asm<wbr>.register-operands<wbr>.allowed-types]<span/></a></div>
<p>인라인 어셈블리의 피연산자로는 다음 타입들만 허용됩니다:</p>
<ul>
<li>정수 (부호 있는 것과 부호 없는 것)</li>
<li>부동 소수점 숫자</li>
<li>포인터 (thin 포인터만)</li>
<li>함수 포인터</li>
<li>SIMD 벡터 (<code>#[repr(simd)]</code>로 정의되고 <code>Copy</code>를 구현하는 구조체). 이는 <code>std::arch</code>에 정의된 아키텍처별 벡터 타입(예: x86의 <code>__m128</code> 또는 ARM의 <code>int8x16_t</code>)을 포함합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() {}

// 정수는 허용됩니다...
let y: i64 = 5;
unsafe { core::arch::asm!("/* {} */", in(reg) y); }

// 포인터도 허용되며...
let py = &amp;raw const y;
unsafe { core::arch::asm!("/* {} */", in(reg) py); }

// 부동 소수점 역시 허용됩니다...
let f = 1.0f32;
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) f); }

// 함수 포인터와 simd 벡터까지도 허용됩니다.
let func: extern "C" fn() = foo;
unsafe { core::arch::asm!("/* {} */", in(reg) func); }

let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) z); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>struct Foo;
let x: Foo = Foo;
// 구조체와 같은 복합 타입은 허용되지 않습니다.
unsafe { core::arch::asm!("/* {} */", in(reg) x); }
// 오류: 인라인 어셈블리에 `Foo` 타입의 값을 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.supported-register-classes"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.supported-register-classes" title="asm.register-operands.supported-register-classes"><span>[asm<wbr>.register-operands<wbr>.supported-register-classes]<span/></a></div>
<p>현재 지원되는 레지스터 클래스 목록입니다:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>레지스터</th><th>LLVM 제약 코드</th></tr></thead><tbody>
<tr><td>x86</td><td><code>reg</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>bp</code>, <code>r[8-15]</code> (x86-64 전용)</td><td><code>r</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code></td><td><code>Q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_byte</code></td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>ah</code>, <code>bh</code>, <code>ch</code>, <code>dh</code></td><td><code>q</code></td></tr>
<tr><td>x86-64</td><td><code>reg_byte</code>*</td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>sil</code>, <code>dil</code>, <code>bpl</code>, <code>r[8-15]b</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>xmm[0-7]</code> (x86) <code>xmm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>ymm[0-7]</code> (x86) <code>ymm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>zmm[0-7]</code> (x86) <code>zmm[0-31]</code> (x86-64)</td><td><code>v</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>k[1-7]</code></td><td><code>Yk</code></td></tr>
<tr><td>x86</td><td><code>kreg0</code></td><td><code>k0</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td><code>st([0-7])</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td><code>mm[0-7]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86-64</td><td><code>tmm_reg</code></td><td><code>tmm[0-7]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td><code>x[0-30]</code></td><td><code>r</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>AArch64</td><td><code>vreg_low16</code></td><td><code>v[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td><code>p[0-15]</code>, <code>ffr</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>Arm64EC</td><td><code>reg</code></td><td><code>x[0-12]</code>, <code>x[15-22]</code>, <code>x[25-27]</code>, <code>x30</code></td><td><code>r</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg</code></td><td><code>v[0-15]</code></td><td><code>w</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg_low16</code></td><td><code>v[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>ARM (ARM/Thumb2)</td><td><code>reg</code></td><td><code>r[0-12]</code>, <code>r14</code></td><td><code>r</code></td></tr>
<tr><td>ARM (Thumb1)</td><td><code>reg</code></td><td><code>r[0-7]</code></td><td><code>r</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>s[0-31]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>sreg_low16</code></td><td><code>s[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>d[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low16</code></td><td><code>d[0-15]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low8</code></td><td><code>d[0-8]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>q[0-15]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low8</code></td><td><code>q[0-7]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low4</code></td><td><code>q[0-3]</code></td><td><code>x</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[9-15]</code>, <code>x[16-31]</code> (non-RV32E)</td><td><code>r</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>LoongArch</td><td><code>reg</code></td><td><code>$r1</code>, <code>$r[4-20]</code>, <code>$r[23,30]</code></td><td><code>r</code></td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td><code>$f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>s390x</td><td><code>reg</code></td><td><code>r[0-10]</code>, <code>r[12-14]</code></td><td><code>r</code></td></tr>
<tr><td>s390x</td><td><code>reg_addr</code></td><td><code>r[1-10]</code>, <code>r[12-14]</code></td><td><code>a</code></td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td><code>f[0-15]</code></td><td><code>f</code></td></tr>
<tr><td>s390x</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>s390x</td><td><code>areg</code></td><td><code>a[2-15]</code></td><td>클로버(clobbers) 전용</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>:</p>
<ul>
<li>x86에서 <code>reg_byte</code>는 <code>reg</code>와 다르게 취급됩니다. 그 이유는 컴파일러가 <code>al</code>과 <code>ah</code>를 별도로 할당할 수 있는 반면, <code>reg</code>는 레지스터 전체를 예약하기 때문입니다.</li>
<li>x86-64에서 고위 바이트 레지스터(예: <code>ah</code>)는 <code>reg_byte</code> 레지스터 클래스에서 사용할 수 없습니다.</li>
<li>일부 레지스터 클래스는 “클로버 전용(Only clobbers)“으로 표시되어 있습니다. 이는 해당 클래스의 레지스터를 입력이나 출력에 사용할 수 없으며, 오직 <code>out(&lt;explicit register&gt;) _</code> 또는 <code>lateout(&lt;explicit register&gt;) _</code> 형식의 클로버로만 사용할 수 있음을 의미합니다.</li>
</ul>
</blockquote>
<div class="rule" id="r-asm.register-operands.value-type-constraints"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.value-type-constraints" title="asm.register-operands.value-type-constraints"><span>[asm<wbr>.register-operands<wbr>.value-type-constraints]<span/></a></div>
<p>각 레지스터 클래스는 사용할 수 있는 값의 타입에 대한 제약 조건을 가집니다. 이는 값이 레지스터에 로드되는 방식이 타입에 따라 다르기 때문에 필요합니다. 예를 들어, 빅 엔디안(big-endian) 시스템에서 <code>i32x4</code>와 <code>i8x16</code>을 SIMD 레지스터에 로드하면, 두 값의 바이트 단위 메모리 표현이 동일하더라도 레지스터의 내용은 서로 다를 수 있습니다. 특정 레지스터 클래스에서 지원되는 타입의 가용 여부는 현재 활성화된 타겟 기능(target features)에 따라 달라질 수 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>타겟 기능</th><th>허용되는 타입</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>없음</td><td><code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>없음</td><td><code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>없음</td><td><code>i8</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>sse</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>avx</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>avx512f</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code> <br> <code>i8x64</code>, <code>i16x32</code>, <code>i32x16</code>, <code>i64x8</code>, <code>f32x16</code>, <code>f64x8</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512f</code></td><td><code>i8</code>, <code>i16</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512bw</code></td><td><code>i32</code>, <code>i64</code></td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>tmm_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>neon</code></td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>Arm64EC</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg</code></td><td><code>neon</code></td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>vfp2</code></td><td><code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>vfp2</code></td><td><code>i64</code>, <code>f64</code>, <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>neon</code></td><td><code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code></td></tr>
<tr><td>RISC-V32</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>RISC-V64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f</code></td><td><code>f32</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>d</code></td><td><code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>LoongArch64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code></td></tr>
<tr><td>LoongArch64</td><td><code>freg</code></td><td><code>f</code></td><td><code>f32</code></td></tr>
<tr><td>LoongArch64</td><td><code>freg</code></td><td><code>d</code></td><td><code>f64</code></td></tr>
<tr><td>s390x</td><td><code>reg</code>, <code>reg_addr</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code></td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td>없음</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td>s390x</td><td><code>vreg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>s390x</td><td><code>areg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>: 위 표의 목적상 포인터, 함수 포인터 및 <code>isize</code>/<code>usize</code>는 타겟에 따라 해당하는 정수 타입(<code>i16</code>/<code>i32</code>/<code>i64</code>)과 동일하게 취급됩니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5i32;
let y = -1i8;
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };

// `reg`는 `i32`에 유효하고, `reg_byte`는 `i8`에 유효하며, `xmm_reg`는 `__m128i`에 유효합니다.
// `tmm0`는 입력이나 출력으로 사용할 수 없지만, 클로버(clobber)할 수는 있습니다.
unsafe { core::arch::asm!("/* {} {} {} */", in(reg) x, in(reg_byte) y, in(xmm_reg) z, out("tmm0") _); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
// `__m128i`를 `reg` 입력으로 전달할 수 없습니다.
unsafe { core::arch::asm!("/* {} */", in(reg) z); }
// 오류: `__m128i` 타입은 이 레지스터 클래스에 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.smaller-value"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.smaller-value" title="asm.register-operands.smaller-value"><span>[asm<wbr>.register-operands<wbr>.smaller-value]<span/></a></div>
<p>만약 할당된 레지스터보다 값의 크기가 작다면, 해당 레지스터의 상위 비트들은 입력 시 정의되지 않은(undefined) 값을 갖게 되며 출력 시에는 무시됩니다. 유일한 예외는 RISC-V의 <code>freg</code> 레지스터 클래스로, RISC-V 아키텍처의 요구 사항에 따라 <code>f32</code> 값은 <code>f64</code> 내에 NaN-boxed 됩니다.</p>
<!--no_run, this test has a non-deterministic runtime behavior-->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64;
// 32비트 값을 64비트 값으로 옮기기, 이런.
#[allow(asm_sub_register)] // rustc는 이 동작에 대해 경고합니다.
unsafe { core::arch::asm!("mov {}, {}", lateout(reg) x, in(reg) 4i32); }
// 상위 32비트는 불확정적입니다.
assert_eq!(x, 4); // 이 단언(assertion)은 성공이 보장되지 않습니다.
assert_eq!(x &amp; 0xFFFFFFFF, 4); // 하지만 이것은 성공할 것입니다.
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-operands.separate-input-output"><a class="rule-link" href="inline-assembly.html#r-asm.register-operands.separate-input-output" title="asm.register-operands.separate-input-output"><span>[asm<wbr>.register-operands<wbr>.separate-input-output]<span/></a></div>
<p><code>inout</code> 피연산자에 대해 별도의 입력 및 출력 표현식이 지정된 경우, 두 표현식은 반드시 동일한 타입을 가져야 합니다. 유일한 예외는 두 피연산자가 모두 포인터이거나 정수인 경우로, 이 경우에는 크기만 같으면 됩니다. 이 제한은 LLVM 및 GCC의 레지스터 할당기가 서로 다른 타입을 가진 묶인(tied) 피연산자를 처리하지 못하는 경우가 있기 때문에 존재합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 포인터와 정수는 (크기가 같다면) 혼용될 수 있습니다.
let x: isize = 0;
let y: *mut ();
// 인라인 어셈블리의 마법을 사용하여 `isize`를 `*mut ()`로 변환(transmute)합니다.
unsafe { core::arch::asm!("/*{}*/", inout(reg) x=&gt;y); }
assert!(y.is_null()); // 널 포인터를 만드는 지극히 우회적인 방법
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let y: f32;
// 하지만 이런 식으로 `i32`를 `f32`로 재해석할 수는 없습니다.
unsafe { core::arch::asm!("/* {} */", inout(reg) x=&gt;y); }
// 오류: asm inout 인자의 타입이 호환되지 않습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-names"><a class="rule-link" href="inline-assembly.html#r-asm.register-names" title="asm.register-names"><span>[asm<wbr>.register-names]<span/></a></div>
<h2 id="레지스터-이름"><a class="header" href="#레지스터-이름">레지스터 이름</a></h2>
<div class="rule" id="r-asm.register-names.supported-register-aliases"><a class="rule-link" href="inline-assembly.html#r-asm.register-names.supported-register-aliases" title="asm.register-names.supported-register-aliases"><span>[asm<wbr>.register-names<wbr>.supported-register-aliases]<span/></a></div>
<p>일부 레지스터는 여러 개의 이름을 가집니다. 이들은 모두 컴파일러에 의해 기본 레지스터 이름과 동일하게 취급됩니다. 다음은 지원되는 모든 레지스터 별칭 목록입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>기본 레지스터</th><th>별칭</th></tr></thead><tbody>
<tr><td>x86</td><td><code>ax</code></td><td><code>eax</code>, <code>rax</code></td></tr>
<tr><td>x86</td><td><code>bx</code></td><td><code>ebx</code>, <code>rbx</code></td></tr>
<tr><td>x86</td><td><code>cx</code></td><td><code>ecx</code>, <code>rcx</code></td></tr>
<tr><td>x86</td><td><code>dx</code></td><td><code>edx</code>, <code>rdx</code></td></tr>
<tr><td>x86</td><td><code>si</code></td><td><code>esi</code>, <code>rsi</code></td></tr>
<tr><td>x86</td><td><code>di</code></td><td><code>edi</code>, <code>rdi</code></td></tr>
<tr><td>x86</td><td><code>bp</code></td><td><code>bpl</code>, <code>ebp</code>, <code>rbp</code></td></tr>
<tr><td>x86</td><td><code>sp</code></td><td><code>spl</code>, <code>esp</code>, <code>rsp</code></td></tr>
<tr><td>x86</td><td><code>ip</code></td><td><code>eip</code>, <code>rip</code></td></tr>
<tr><td>x86</td><td><code>st(0)</code></td><td><code>st</code></td></tr>
<tr><td>x86</td><td><code>r[8-15]</code></td><td><code>r[8-15]b</code>, <code>r[8-15]w</code>, <code>r[8-15]d</code></td></tr>
<tr><td>x86</td><td><code>xmm[0-31]</code></td><td><code>ymm[0-31]</code>, <code>zmm[0-31]</code></td></tr>
<tr><td>AArch64</td><td><code>x[0-30]</code></td><td><code>w[0-30]</code></td></tr>
<tr><td>AArch64</td><td><code>x29</code></td><td><code>fp</code></td></tr>
<tr><td>AArch64</td><td><code>x30</code></td><td><code>lr</code></td></tr>
<tr><td>AArch64</td><td><code>sp</code></td><td><code>wsp</code></td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td><code>wzr</code></td></tr>
<tr><td>AArch64</td><td><code>v[0-31]</code></td><td><code>b[0-31]</code>, <code>h[0-31]</code>, <code>s[0-31]</code>, <code>d[0-31]</code>, <code>q[0-31]</code></td></tr>
<tr><td>Arm64EC</td><td><code>x[0-30]</code></td><td><code>w[0-30]</code></td></tr>
<tr><td>Arm64EC</td><td><code>x29</code></td><td><code>fp</code></td></tr>
<tr><td>Arm64EC</td><td><code>x30</code></td><td><code>lr</code></td></tr>
<tr><td>Arm64EC</td><td><code>sp</code></td><td><code>wsp</code></td></tr>
<tr><td>Arm64EC</td><td><code>xzr</code></td><td><code>wzr</code></td></tr>
<tr><td>Arm64EC</td><td><code>v[0-15]</code></td><td><code>b[0-15]</code>, <code>h[0-15]</code>, <code>s[0-15]</code>, <code>d[0-15]</code>, <code>q[0-15]</code></td></tr>
<tr><td>ARM</td><td><code>r[0-3]</code></td><td><code>a[1-4]</code></td></tr>
<tr><td>ARM</td><td><code>r[4-9]</code></td><td><code>v[1-6]</code></td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td><code>rfp</code></td></tr>
<tr><td>ARM</td><td><code>r10</code></td><td><code>sl</code></td></tr>
<tr><td>ARM</td><td><code>r11</code></td><td><code>fp</code></td></tr>
<tr><td>ARM</td><td><code>r12</code></td><td><code>ip</code></td></tr>
<tr><td>ARM</td><td><code>r13</code></td><td><code>sp</code></td></tr>
<tr><td>ARM</td><td><code>r14</code></td><td><code>lr</code></td></tr>
<tr><td>ARM</td><td><code>r15</code></td><td><code>pc</code></td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td><code>zero</code></td></tr>
<tr><td>RISC-V</td><td><code>x1</code></td><td><code>ra</code></td></tr>
<tr><td>RISC-V</td><td><code>x2</code></td><td><code>sp</code></td></tr>
<tr><td>RISC-V</td><td><code>x3</code></td><td><code>gp</code></td></tr>
<tr><td>RISC-V</td><td><code>x4</code></td><td><code>tp</code></td></tr>
<tr><td>RISC-V</td><td><code>x[5-7]</code></td><td><code>t[0-2]</code></td></tr>
<tr><td>RISC-V</td><td><code>x8</code></td><td><code>fp</code>, <code>s0</code></td></tr>
<tr><td>RISC-V</td><td><code>x9</code></td><td><code>s1</code></td></tr>
<tr><td>RISC-V</td><td><code>x[10-17]</code></td><td><code>a[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[18-27]</code></td><td><code>s[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[28-31]</code></td><td><code>t[3-6]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[0-7]</code></td><td><code>ft[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[8-9]</code></td><td><code>fs[0-1]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[10-17]</code></td><td><code>fa[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[18-27]</code></td><td><code>fs[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[28-31]</code></td><td><code>ft[8-11]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r0</code></td><td><code>$zero</code></td></tr>
<tr><td>LoongArch</td><td><code>$r1</code></td><td><code>$ra</code></td></tr>
<tr><td>LoongArch</td><td><code>$r2</code></td><td><code>$tp</code></td></tr>
<tr><td>LoongArch</td><td><code>$r3</code></td><td><code>$sp</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[4-11]</code></td><td><code>$a[0-7]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[12-20]</code></td><td><code>$t[0-8]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r21</code></td><td></td></tr>
<tr><td>LoongArch</td><td><code>$r22</code></td><td><code>$fp</code>, <code>$s9</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[23-31]</code></td><td><code>$s[0-8]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[0-7]</code></td><td><code>$fa[0-7]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[8-23]</code></td><td><code>$ft[0-15]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[24-31]</code></td><td><code>$fs[0-7]</code></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z = 0i64;
// rax는 eax 및 ax의 별칭입니다.
unsafe { core::arch::asm!("", in("rax") z); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-names.not-for-io"><a class="rule-link" href="inline-assembly.html#r-asm.register-names.not-for-io" title="asm.register-names.not-for-io"><span>[asm<wbr>.register-names<wbr>.not-for-io]<span/></a></div>
<p>일부 레지스터는 입력 또는 출력 피연산자로 사용할 수 없습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>지원되지 않는 레지스터</th><th>이유</th></tr></thead><tbody>
<tr><td>모두</td><td><code>sp</code>, <code>r15</code> (s390x)</td><td>스택 포인터(sp)는 asm 코드 블록의 끝에서 원래 값으로 복구되어야 합니다.</td></tr>
<tr><td>모두</td><td><code>bp</code> (x86), <code>x29</code> (AArch64 및 Arm64EC), <code>x8</code> (RISC-V), <code>$fp</code> (LoongArch), <code>r11</code> (s390x)</td><td>프레임 포인터(fp)는 입력 또는 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>ARM</td><td><code>r7</code> 또는 <code>r11</code></td><td>ARM에서 프레임 포인터는 타겟에 따라 <code>r7</code> 또는 <code>r11</code>이 될 수 있습니다. 프레임 포인터는 입력 또는 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>모두</td><td><code>si</code> (x86-32), <code>bx</code> (x86-64), <code>r6</code> (ARM), <code>x19</code> (AArch64 및 Arm64EC), <code>x9</code> (RISC-V), <code>$s8</code> (LoongArch)</td><td>이는 복잡한 스택 프레임을 가진 함수를 위해 LLVM에서 내부적으로 “베이스 포인터“로 사용됩니다.</td></tr>
<tr><td>x86</td><td><code>ip</code></td><td>이것은 프로그램 카운터(pc)이며, 실제 레지스터가 아닙니다.</td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>AArch64</td><td><code>x18</code></td><td>이는 일부 AArch64 타겟에서 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>xzr</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>x18</code></td><td>이것은 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>x13</code>, <code>x14</code>, <code>x23</code>, <code>x24</code>, <code>x28</code>, <code>v[16-31]</code>, <code>p[0-15]</code>, <code>ffr</code></td><td>이들은 Arm64EC에서 지원되지 않는 AArch64 레지스터들입니다.</td></tr>
<tr><td>ARM</td><td><code>pc</code></td><td>이것은 프로그램 카운터(pc)이며, 실제 레지스터가 아닙니다.</td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td>이는 일부 ARM 타겟에서 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>RISC-V</td><td><code>gp</code>, <code>tp</code></td><td>이 레지스터들은 예약되어 있으며 입력이나 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r0</code> 또는 <code>$zero</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r2</code> 또는 <code>$tp</code></td><td>이는 TLS를 위해 예약되어 있습니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r21</code></td><td>이는 ABI에 의해 예약되어 있습니다.</td></tr>
<tr><td>s390x</td><td><code>c[0-15]</code></td><td>커널에 의해 예약되어 있습니다.</td></tr>
<tr><td>s390x</td><td><code>a[0-1]</code></td><td>시스템 사용을 위해 예약되어 있습니다.</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// bp는 예약되어 있습니다.
unsafe { core::arch::asm!("", in("bp") 5i32); }
// 오류: 잘못된 레지스터 `bp`: 프레임 포인터는 인라인 asm의 피연산자로 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.register-names.fp-bp-reserved"><a class="rule-link" href="inline-assembly.html#r-asm.register-names.fp-bp-reserved" title="asm.register-names.fp-bp-reserved"><span>[asm<wbr>.register-names<wbr>.fp-bp-reserved]<span/></a></div>
<p>프레임 포인터와 베이스 포인터 레지스터는 LLVM 내부 사용을 위해 예약되어 있습니다. <code>asm!</code> 구문에서 예약된 레지스터 사용을 명시적으로 지정할 수는 없지만, 일부 경우 LLVM이 <code>reg</code> 피연산자를 위해 이러한 예약된 레지스터 중 하나를 할당할 수 있습니다. 예약된 레지스터를 사용하는 어셈블리 코드는 <code>reg</code> 피연산자가 동일한 레지스터를 사용할 수 있으므로 주의해야 합니다.</p>
<div class="rule" id="r-asm.template-modifiers"><a class="rule-link" href="inline-assembly.html#r-asm.template-modifiers" title="asm.template-modifiers"><span>[asm<wbr>.template-modifiers]<span/></a></div>
<h2 id="템플릿-수식어"><a class="header" href="#템플릿-수식어">템플릿 수식어</a></h2>
<div class="rule" id="r-asm.template-modifiers.intro"><a class="rule-link" href="inline-assembly.html#r-asm.template-modifiers.intro" title="asm.template-modifiers.intro"><span>[asm<wbr>.template-modifiers<wbr>.intro]<span/></a></div>
<p>플레이스홀더는 중괄호 안의 <code>:</code> 뒤에 수식어를 지정하여 기능을 확장할 수 있습니다. 이러한 수식어는 레지스터 할당에는 영향을 주지 않지만, 피연산자가 템플릿 문자열에 삽입될 때 포맷팅되는 방식을 변경합니다.</p>
<div class="rule" id="r-asm.template-modifiers.only-one"><a class="rule-link" href="inline-assembly.html#r-asm.template-modifiers.only-one" title="asm.template-modifiers.only-one"><span>[asm<wbr>.template-modifiers<wbr>.only-one]<span/></a></div>
<p>템플릿 플레이스홀더당 하나의 수식어만 허용됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// `r`과 `e`를 동시에 지정할 수는 없습니다.
unsafe { core::arch::asm!("/* {:er}", in(reg) 5i32); }
// 오류: asm 템플릿 수식어는 단일 문자여야 합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.template-modifiers.supported-modifiers"><a class="rule-link" href="inline-assembly.html#r-asm.template-modifiers.supported-modifiers" title="asm.template-modifiers.supported-modifiers"><span>[asm<wbr>.template-modifiers<wbr>.supported-modifiers]<span/></a></div>
<p>지원되는 수식어는 LLVM(및 GCC)의 <a href="http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers">asm 템플릿 인자 수식어</a>의 하위 집합이지만, 동일한 문자 코드를 사용하지는 않습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>수식어</th><th>출력 예시</th><th>LLVM 수식어</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>없음</td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>없음</td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_abcd</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>h</code></td><td><code>ah</code></td><td><code>h</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>x</code></td><td><code>ax</code></td><td><code>w</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>e</code></td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>r</code></td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>없음</td><td><code>al</code> / <code>ah</code></td><td>없음</td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td>없음</td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td>없음</td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td>없음</td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>x</code></td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>y</code></td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>z</code></td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td>없음</td><td><code>k1</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td>없음</td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td><code>w</code></td><td><code>w0</code></td><td><code>w</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td><code>x</code></td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td>없음</td><td><code>v0</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>v</code></td><td><code>v0</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>b</code></td><td><code>b0</code></td><td><code>b</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>h</code></td><td><code>h0</code></td><td><code>h</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>s</code></td><td><code>s0</code></td><td><code>s</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>d</code></td><td><code>d0</code></td><td><code>d</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>q</code></td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>없음</td><td><code>r0</code></td><td>없음</td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td>없음</td><td><code>s0</code></td><td>없음</td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td>없음</td><td><code>d0</code></td><td><code>P</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td>없음</td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>e</code> / <code>f</code></td><td><code>d0</code> / <code>d1</code></td><td><code>e</code> / <code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td>없음</td><td><code>x1</code></td><td>없음</td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td>없음</td><td><code>f0</code></td><td>없음</td></tr>
<tr><td>LoongArch</td><td><code>reg</code></td><td>없음</td><td><code>$r1</code></td><td>없음</td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td>없음</td><td><code>$f0</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>reg</code></td><td>없음</td><td><code>%r0</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>reg_addr</code></td><td>없음</td><td><code>%r1</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td>없음</td><td><code>%f0</code></td><td>없음</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>:</p>
<ul>
<li>ARM의 <code>e</code> / <code>f</code>: 이는 NEON 쿼드(128비트) 레지스터의 하위 또는 상위 더블워드(doubleword) 레지스터 이름을 출력합니다.</li>
<li>x86: 수식어가 없는 <code>reg</code>에 대한 우리의 동작은 GCC와 다릅니다. GCC는 피연산자 값 타입을 기반으로 수식어를 추론하지만, 우리는 기본적으로 전체 레지스터 크기를 사용합니다.</li>
<li>x86 <code>xmm_reg</code>: <code>x</code>, <code>t</code> 및 <code>g</code> LLVM 수식어는 아직 LLVM에 구현되지 않았지만(이들은 GCC에서만 지원됨), 이는 간단한 변경사항일 것입니다.</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0x10u16;

// `xchg`를 사용한 u16::swap_bytes
// `{x}`의 하위 절반은 `{x:l}`로, 상위 절반은 `{x:h}`로 참조됩니다.
unsafe { core::arch::asm!("xchg {x:l}, {x:h}", x = inout(reg_abcd) x); }
assert_eq!(x, 0x1000u16);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.template-modifiers.smaller-value"><a class="rule-link" href="inline-assembly.html#r-asm.template-modifiers.smaller-value" title="asm.template-modifiers.smaller-value"><span>[asm<wbr>.template-modifiers<wbr>.smaller-value]<span/></a></div>
<p>이전 섹션에서 언급했듯이, 레지스터 너비보다 작은 입력값을 전달하면 레지스터의 상위 비트들이 정의되지 않은 값을 갖게 됩니다. 인라인 asm이 레지스터의 하위 비트들만 접근한다면 이는 문제가 되지 않으며, 이는 asm 코드에서 서브레지스터 이름을 사용하기 위해 템플릿 수식어를 사용함으로써 가능합니다(예: <code>rax</code> 대신 <code>ax</code>). 이는 빠지기 쉬운 함정이므로, 컴파일러는 입력 타입에 따라 적절한 템플릿 수식어 사용을 제안할 것입니다. 피연산자에 대한 모든 참조에 이미 수식어가 있다면 해당 피연산자에 대한 경고는 억제됩니다.</p>
<div class="rule" id="r-asm.abi-clobbers"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers" title="asm.abi-clobbers"><span>[asm<wbr>.abi-clobbers]<span/></a></div>
<h2 id="abi-클로버clobbers"><a class="header" href="#abi-클로버clobbers">ABI 클로버(Clobbers)</a></h2>
<div class="rule" id="r-asm.abi-clobbers.intro"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers.intro" title="asm.abi-clobbers.intro"><span>[asm<wbr>.abi-clobbers<wbr>.intro]<span/></a></div>
<p><code>clobber_abi</code> 키워드는 <code>asm!</code> 블록에 기본 클로버 세트를 적용하는 데 사용될 수 있습니다. 이는 특정 호출 규약(calling convention)으로 함수를 호출할 때 필요한 클로버 제약 조건을 자동으로 삽입합니다. 만약 호출 규약이 호출 간에 레지스터의 값을 완전히 보존하지 않는 경우, <code>lateout("...") _</code>가 피연산자 목록에 암시적으로 추가됩니다(여기서 <code>...</code>은 해당 레지스터의 이름으로 대체됩니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() -&gt; i32 { 0 }

let z: i32;
// 함수를 호출하려면, 피호출자 저장(callee saved) 레지스터를 클로버하고 있음을 컴파일러에 알려야 합니다.
unsafe { core::arch::asm!("call {}", sym foo, out("rax") z, clobber_abi("C")); }
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.abi-clobbers.many"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers.many" title="asm.abi-clobbers.many"><span>[asm<wbr>.abi-clobbers<wbr>.many]<span/></a></div>
<p><code>clobber_abi</code>는 횟수 제한 없이 지정될 수 있습니다. 지정된 모든 호출 규약의 합집합에 속하는 모든 고유 레지스터에 대해 클로버를 삽입합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "sysv64" fn foo() -&gt; i32 { 0 }
extern "win64" fn bar(x: i32) -&gt; i32 { x + 1}

let z: i32;
// 심지어 서로 다른 규약과 서로 다른 저장된 레지스터를 가진 여러 함수를 호출할 수도 있습니다.
unsafe {
    core::arch::asm!(
        "call {}",
        "mov ecx, eax",
        "call {}",
        sym foo,
        sym bar,
        out("rax") z,
        clobber_abi("C")
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.abi-clobbers.must-specify"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers.must-specify" title="asm.abi-clobbers.must-specify"><span>[asm<wbr>.abi-clobbers<wbr>.must-specify]<span/></a></div>
<p><code>clobber_abi</code>가 사용될 때 컴파일러는 제네릭 레지스터 클래스 출력을 허용하지 않습니다. 모든 출력은 명시적 레지스터를 지정해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo(x: i32) -&gt; i32 { 0 }

let z: i32;
// 실수로 겹치지 않도록 명시적 레지스터를 사용해야 합니다.
unsafe {
    core::arch::asm!(
        "mov eax, {:e}",
        "call {}",
        out(reg) z,
        sym foo,
        clobber_abi("C")
    );
    // 오류: `clobber_abi`를 사용하는 asm은 출력에 대해 명시적 레지스터를 지정해야 합니다.
}
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.abi-clobbers.explicit-have-precedence"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers.explicit-have-precedence" title="asm.abi-clobbers.explicit-have-precedence"><span>[asm<wbr>.abi-clobbers<wbr>.explicit-have-precedence]<span/></a></div>
<p>명시적 레지스터 출력은 <code>clobber_abi</code>에 의해 삽입된 암시적 클로버보다 우선순위를 갖습니다. 레지스터가 출력으로 사용되지 않는 경우에만 해당 레지스터에 대한 클로버가 삽입됩니다.</p>
<div class="rule" id="r-asm.abi-clobbers.supported-abis"><a class="rule-link" href="inline-assembly.html#r-asm.abi-clobbers.supported-abis" title="asm.abi-clobbers.supported-abis"><span>[asm<wbr>.abi-clobbers<wbr>.supported-abis]<span/></a></div>
<p>다음 ABI들은 <code>clobber_abi</code>와 함께 사용될 수 있습니다:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>ABI 이름</th><th>클로버된 레지스터</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"cdecl"</code>, <code>"stdcall"</code>, <code>"fastcall"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>xmm[0-7]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code></td></tr>
<tr><td>x86-64</td><td><code>"C"</code>, <code>"system"</code> (윈도우 전용), <code>"efiapi"</code>, <code>"win64"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>x86-64</td><td><code>"C"</code>, <code>"system"</code> (윈도우 제외), <code>"sysv64"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>AArch64</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code></td><td><code>x[0-17]</code>, <code>x18</code>*, <code>x30</code>, <code>v[0-31]</code>, <code>p[0-15]</code>, <code>ffr</code></td></tr>
<tr><td>Arm64EC</td><td><code>"C"</code>, <code>"system"</code></td><td><code>x[0-12]</code>, <code>x[15-17]</code>, <code>x30</code>, <code>v[0-15]</code></td></tr>
<tr><td>ARM</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"aapcs"</code></td><td><code>r[0-3]</code>, <code>r12</code>, <code>r14</code>, <code>s[0-15]</code>, <code>d[0-7]</code>, <code>d[16-31]</code></td></tr>
<tr><td>RISC-V</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[10-17]</code><em>, <code>x[28-31]</code></em>, <code>f[0-7]</code>, <code>f[10-17]</code>, <code>f[28-31]</code>, <code>v[0-31]</code></td></tr>
<tr><td>LoongArch</td><td><code>"C"</code>, <code>"system"</code></td><td><code>$r1</code>, <code>$r[4-20]</code>, <code>$f[0-23]</code></td></tr>
<tr><td>s390x</td><td><code>"C"</code>, <code>"system"</code></td><td><code>r[0-5]</code>, <code>r14</code>, <code>f[0-7]</code>, <code>v[0-31]</code>, <code>a[2-15]</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>참고:</p>
<ul>
<li>AArch64에서 <code>x18</code>은 타겟에서 예약된 레지스터로 간주되지 않는 경우에만 클로버 목록에 포함됩니다.</li>
<li>RISC-V에서 <code>x[16-17]</code> 및 <code>x[28-31]</code>은 타겟에서 예약된 레지스터로 간주되지 않는 경우에만 클로버 목록에 포함됩니다.</li>
</ul>
</blockquote>
<p>각 ABI에 대한 클로버된 레지스터 목록은 아키텍처에 새로운 레지스터가 추가됨에 따라 rustc에서 업데이트됩니다. 이는 LLVM이 생성된 코드에서 이러한 새로운 레지스터를 사용하기 시작할 때 <code>asm!</code> 클로버가 계속해서 올바르게 작동하도록 보장합니다.</p>
<div class="rule" id="r-asm.options"><a class="rule-link" href="inline-assembly.html#r-asm.options" title="asm.options"><span>[asm<wbr>.options]<span/></a></div>
<h2 id="옵션"><a class="header" href="#옵션">옵션</a></h2>
<div class="rule" id="r-asm.options.supported-options"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options" title="asm.options.supported-options"><span>[asm<wbr>.options<wbr>.supported-options]<span/></a></div>
<p>플래그는 인라인 어셈블리 블록의 동작에 더 많은 영향을 주는 데 사용됩니다. 현재 정의된 옵션은 다음과 같습니다.</p>
<div class="rule" id="r-asm.options.supported-options.pure"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.pure" title="asm.options.supported-options.pure"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.pure]<span/></a></div>
<ul>
<li><code>pure</code>: <code>asm!</code> 블록은 부작용(side effects)이 없어야 하며, 반드시 반환되어야 하고, 출력은 오직 직접적인 입력(즉, 포인터가 가리키는 대상이 아닌 값 자체) 또는 메모리에서 읽은 값(<code>nomem</code> 옵션이 설정되지 않은 경우)에만 의존해야 합니다. 이를 통해 컴파일러는 프로그램에 명시된 것보다 더 적은 횟수로 <code>asm!</code> 블록을 실행하거나(예: 루프 외부로 이동), 출력이 사용되지 않는 경우 완전히 제거할 수 있습니다. <code>pure</code> 옵션은 <code>nomem</code> 또는 <code>readonly</code> 옵션 중 하나와 반드시 결합되어야 하며, 그렇지 않으면 컴파일 타임 오류가 발생합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// `pure`는 어셈블리에 부작용이 없다고 가정하여 최적화하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure, nomem)); }
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// 메모리 읽기 허용 여부를 나타내기 위해 nomem 또는 readonly 중 하나를 만족해야 합니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure)); }
// 오류: `pure` 옵션은 `nomem` 또는 `readonly` 중 하나와 결합되어야 합니다.
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.nomem"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.nomem" title="asm.options.supported-options.nomem"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.nomem]<span/></a></div>
<ul>
<li><code>nomem</code>: <code>asm!</code> 블록이 <code>asm!</code> 블록 외부에서 접근 가능한 어떠한 메모리도 읽거나 쓰지 않습니다. 이를 통해 컴파일러는 <code>asm!</code>에 의해 메모리가 읽히거나 쓰이지 않는다는 것을 알기 때문에, 수정된 전역 변수의 값을 <code>asm!</code> 블록 너머까지 레지스터에 캐싱할 수 있습니다. 또한 컴파일러는 이 <code>asm!</code> 블록이 펜스(fences) 등을 통한 다른 스레드와의 어떠한 동기화도 수행하지 않는다고 가정합니다.</li>
</ul>
<!-- no_run: This test has unpredictable or undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0i32;
let z: i32;
// nomem asm 블록에서 메모리에 접근하는 것은 허용되지 않습니다.
unsafe {
    core::arch::asm!("mov {val:e}, dword ptr [{ptr}]",
        ptr = in(reg) &amp;mut x,
        val = lateout(reg) z,
        options(nomem)
    )
}

// 메모리에 쓰는 것 또한 정의되지 않은 동작입니다.
unsafe {
    core::arch::asm!("mov  dword ptr [{ptr}], {val:e}",
        ptr = in(reg) &amp;mut x,
        val = in(reg) z,
        options(nomem)
    )
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// 하지만 `push` 등을 통해 우리만의 메모리를 할당한다면
// 여전히 그것을 사용할 수 있습니다.
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(nomem)
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.readonly"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.readonly" title="asm.options.supported-options.readonly"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.readonly]<span/></a></div>
<ul>
<li><code>readonly</code>: <code>asm!</code> 블록이 <code>asm!</code> 블록 외부에서 접근 가능한 어떠한 메모리에도 쓰지 않습니다. 이를 통해 컴파일러는 변하지 않은 전역 변수의 값이 <code>asm!</code>에 의해 쓰이지 않는다는 것을 알기 때문에, 그 값을 <code>asm!</code> 블록 너머까지 레지스터에 캐싱할 수 있습니다. 또한 컴파일러는 이 <code>asm!</code> 블록이 펜스 등을 통한 다른 스레드와의 어떠한 동기화도 수행하지 않는다고 가정합니다.</li>
</ul>
<!-- no_run: This test has undefined behaviour at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0;
// readonly에서 메모리를 수정할 수 없습니다.
unsafe {
    core::arch::asm!("mov dword ptr[{}], 1", in(reg) &amp;mut x, options(readonly))
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64 = 0;
let z: i64;
// 하지만 여전히 읽을 수는 있습니다.
unsafe {
    core::arch::asm!("mov {x}, qword ptr [{x}]",
        x = inout(reg) &amp;x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64 = 0;
let z: i64;
// nomem과 동일한 예외가 적용됩니다.
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.preserves_flags"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.preserves_flags" title="asm.options.supported-options.preserves_flags"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.preserves_flags]<span/></a></div>
<ul>
<li><code>preserves_flags</code>: <code>asm!</code> 블록이 플래그 레지스터(아래 규칙에 정의됨)를 수정하지 않습니다. 이를 통해 컴파일러는 <code>asm!</code> 블록 이후에 조건 플래그를 다시 계산하는 것을 피할 수 있습니다.</li>
</ul>
<div class="rule" id="r-asm.options.supported-options.noreturn"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.noreturn" title="asm.options.supported-options.noreturn"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.noreturn]<span/></a></div>
<ul>
<li><code>noreturn</code>: <code>asm!</code> 블록이 절대 반환되지 않으며, 반환 타입은 <code>!</code> (never)로 정의됩니다. 어셈블리 코드의 끝을 지나 실행이 계속되면 동작은 정의되지 않습니다. <code>noreturn</code> asm 블록은 반환하지 않는 함수와 똑같이 동작합니다. 특히, 스코프 내의 지역 변수들은 블록이 호출되기 전에 드롭(drop)되지 않습니다.</li>
</ul>
<!-- no_run: This test aborts at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024">fn main() -&gt; ! {
<span class="boring">#[cfg(target_arch = "x86_64")] {
</span>    // noreturn 블록 내부에서 실행을 트랩(trap)하기 위해 명령어를 사용할 수 있습니다.
    unsafe { core::arch::asm!("ud2", options(noreturn)); }
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] panic!("no return");
</span>}</code></pre></pre>
<!-- no_run: Test has undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// noreturn asm 블록의 끝을 지나치지 않도록 할 책임은 사용자에게 있습니다.
unsafe { core::arch::asm!("", options(noreturn)); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.nostack"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.nostack" title="asm.options.supported-options.nostack"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.nostack]<span/></a></div>
<ul>
<li><code>nostack</code>: <code>asm!</code> 블록이 스택에 데이터를 푸시하거나 스택 레드존(red-zone, 타겟에서 지원하는 경우)에 쓰지 않습니다. 이 옵션을 사용하지 <em>않으면</em> 스택 포인터는 함수 호출을 위해 (타겟 ABI에 따라) 적절하게 정렬됨이 보장됩니다.</li>
</ul>
<!-- no_run: Test has undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// nostack과 함께 `push` 및 `pop`을 사용하는 것은 정의되지 않은 동작(UB)입니다.
unsafe { core::arch::asm!("push rax", "pop rax", options(nostack)); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.att_syntax"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.att_syntax" title="asm.options.supported-options.att_syntax"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.att_syntax]<span/></a></div>
<ul>
<li><code>att_syntax</code>: 이 옵션은 x86에서만 유효하며, 어셈블러가 GNU 어셈블러의 <code>.att_syntax prefix</code> 모드를 사용하도록 합니다. 레지스터 피연산자는 앞에 <code>%</code>가 붙은 상태로 치환됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32;
let y = 1i32;
// 여기서는 AT&amp;T 구문을 사용해야 합니다. 피연산자 순서는 src, dest입니다.
unsafe {
    core::arch::asm!("mov {y:e}, {x:e}",
        x = lateout(reg) x,
        y = in(reg) y,
        options(att_syntax)
    );
}
assert_eq!(x, y);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.supported-options.raw"><a class="rule-link" href="inline-assembly.html#r-asm.options.supported-options.raw" title="asm.options.supported-options.raw"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.raw]<span/></a></div>
<ul>
<li><code>raw</code>: 템플릿 문자열을 원시 어셈블리 문자열로 파싱하게 하며, <code>{</code> 및 <code>}</code>에 대한 특별한 처리를 하지 않습니다. 이는 주로 <code>include_str!</code>을 사용하여 외부 파일에서 원시 어셈블리 코드를 포함할 때 유용합니다.</li>
</ul>
<div class="rule" id="r-asm.options.checks"><a class="rule-link" href="inline-assembly.html#r-asm.options.checks" title="asm.options.checks"><span>[asm<wbr>.options<wbr>.checks]<span/></a></div>
<p>컴파일러는 옵션에 대해 몇 가지 추가 검사를 수행합니다.</p>
<div class="rule" id="r-asm.options.checks.mutually-exclusive"><a class="rule-link" href="inline-assembly.html#r-asm.options.checks.mutually-exclusive" title="asm.options.checks.mutually-exclusive"><span>[asm<wbr>.options<wbr>.checks<wbr>.mutually-exclusive]<span/></a></div>
<ul>
<li><code>nomem</code>과 <code>readonly</code> 옵션은 상호 배타적입니다. 두 옵션을 모두 지정하는 것은 컴파일 타임 오류입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// nomem은 readonly보다 엄격하게 강력하므로 함께 지정할 수 없습니다.
unsafe { core::arch::asm!("", options(nomem, readonly)); }
// 오류: `nomem`과 `readonly` 옵션은 상호 배타적입니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.checks.pure"><a class="rule-link" href="inline-assembly.html#r-asm.options.checks.pure" title="asm.options.checks.pure"><span>[asm<wbr>.options<wbr>.checks<wbr>.pure]<span/></a></div>
<ul>
<li><code>pure</code>를 출력이 없거나 버려지는 출력(<code>_</code>)만 있는 asm 블록에 지정하는 것은 컴파일 타임 오류입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// pure 블록은 최소 하나 이상의 출력이 필요합니다.
unsafe { core::arch::asm!("", options(pure)); }
// 오류: `pure` 옵션을 사용하는 asm은 최소 하나 이상의 출력이 있어야 합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.checks.noreturn"><a class="rule-link" href="inline-assembly.html#r-asm.options.checks.noreturn" title="asm.options.checks.noreturn"><span>[asm<wbr>.options<wbr>.checks<wbr>.noreturn]<span/></a></div>
<ul>
<li><code>noreturn</code>을 출력이 있는 asm 블록에 지정하는 것은 컴파일 타임 오류입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z: i32;
// noreturn은 출력을 가질 수 없습니다.
unsafe { core::arch::asm!("mov {:e}, 1", out(reg) z, options(noreturn)); }
// 오류: `noreturn` 옵션에서는 asm 출력이 허용되지 않습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.options.global_asm-restriction"><a class="rule-link" href="inline-assembly.html#r-asm.options.global_asm-restriction" title="asm.options.global_asm-restriction"><span>[asm<wbr>.options<wbr>.global_asm-restriction]<span/></a></div>
<p><code>global_asm!</code>은 오직 <code>att_syntax</code>와 <code>raw</code> 옵션만 지원합니다. 나머지 옵션들은 전역 스코프 인라인 어셈블리에서는 의미가 없습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">fn main() {}
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>// global_asm!에서 nomem은 무의미합니다.
core::arch::global_asm!("", options(nomem));
<span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");</span></code></pre></pre>
<div class="rule" id="r-asm.rules"><a class="rule-link" href="inline-assembly.html#r-asm.rules" title="asm.rules"><span>[asm<wbr>.rules]<span/></a></div>
<h2 id="인라인-어셈블리-규칙"><a class="header" href="#인라인-어셈블리-규칙">인라인 어셈블리 규칙</a></h2>
<div class="rule" id="r-asm.rules.intro"><a class="rule-link" href="inline-assembly.html#r-asm.rules.intro" title="asm.rules.intro"><span>[asm<wbr>.rules<wbr>.intro]<span/></a></div>
<p>정의되지 않은 동작을 피하기 위해, 함수 스코프 인라인 어셈블리(<code>asm!</code>)를 사용할 때는 다음 규칙들을 따라야 합니다.</p>
<div class="rule" id="r-asm.rules.reg-not-input"><a class="rule-link" href="inline-assembly.html#r-asm.rules.reg-not-input" title="asm.rules.reg-not-input"><span>[asm<wbr>.rules<wbr>.reg-not-input]<span/></a></div>
<ul>
<li>입력으로 지정되지 않은 모든 레지스터는 asm 블록 진입 시 정의되지 않은 값을 갖게 됩니다.
<ul>
<li>인라인 어셈블리 문맥에서 “정의되지 않은 값“이란, 해당 레지스터가 아키텍처에서 허용하는 가능한 값들 중 하나를 (비결정적으로) 가질 수 있음을 의미합니다. 특히 이는 읽을 때마다 값이 달라질 수 있는 LLVM의 <code>undef</code>와는 다릅니다(어셈블리 코드에는 그러한 개념이 존재하지 않기 때문입니다).</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.reg-not-output"><a class="rule-link" href="inline-assembly.html#r-asm.rules.reg-not-output" title="asm.rules.reg-not-output"><span>[asm<wbr>.rules<wbr>.reg-not-output]<span/></a></div>
<ul>
<li>출력으로 지정되지 않은 모든 레지스터는 asm 블록을 나갈 때 진입 시와 동일한 값을 유지해야 합니다. 그렇지 않으면 동작은 정의되지 않습니다.
<ul>
<li>이는 입력 또는 출력으로 지정될 수 있는 레지스터에만 적용됩니다. 다른 레지스터들은 타겟별 규칙을 따릅니다.</li>
<li><code>lateout</code>이 <code>in</code>과 동일한 레지스터에 할당될 수 있으며, 이 경우 이 규칙은 적용되지 않음에 유의하십시오. 하지만 이는 레지스터 할당 결과에 의존하므로 코드가 이에 의존해서는 안 됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.unwind"><a class="rule-link" href="inline-assembly.html#r-asm.rules.unwind" title="asm.rules.unwind"><span>[asm<wbr>.rules<wbr>.unwind]<span/></a></div>
<ul>
<li>실행이 asm 블록 밖으로 언와인드(unwind)되는 경우 동작은 정의되지 않습니다.
<ul>
<li>어셈블리 코드가 호출한 함수가 언와인드되는 경우에도 마찬가지로 적용됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.mem-same-as-ffi"><a class="rule-link" href="inline-assembly.html#r-asm.rules.mem-same-as-ffi" title="asm.rules.mem-same-as-ffi"><span>[asm<wbr>.rules<wbr>.mem-same-as-ffi]<span/></a></div>
<ul>
<li>어셈블리 코드가 읽고 쓸 수 있도록 허용된 메모리 위치의 집합은 FFI 함수에 허용된 것과 동일합니다.
<ul>
<li>정확한 규칙은 안전하지 않은 코드 지침(unsafe code guidelines)을 참조하십시오.</li>
<li>만약 <code>readonly</code> 옵션이 설정되어 있다면, 메모리 읽기만 허용됩니다.</li>
<li>만약 <code>nomem</code> 옵션이 설정되어 있다면, 메모리에 대한 어떠한 읽기나 쓰기도 허용되지 않습니다.</li>
<li>이 규칙들은 asm 블록 내에서 할당된 스택 공간과 같이 어셈블리 코드에 비공개인 메모리에는 적용되지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.black-box"><a class="rule-link" href="inline-assembly.html#r-asm.rules.black-box" title="asm.rules.black-box"><span>[asm<wbr>.rules<wbr>.black-box]<span/></a></div>
<ul>
<li>컴파일러는 asm 내의 명령어가 실제로 실행될 명령어라고 가정할 수 없습니다.
<ul>
<li>이는 실질적으로 컴파일러가 <code>asm!</code>을 블랙박스로 취급해야 하며, 명령어 자체가 아닌 인터페이스 명세만을 고려해야 함을 의미합니다.</li>
<li>런타임 코드 패칭(patching)은 타겟별 메커니즘을 통해 허용됩니다.</li>
<li>하지만 각 <code>asm!</code>이 목적 파일(object file)의 단일 명령어 인스턴스에 직접 대응한다는 보장은 없습니다. 컴파일러는 <code>asm!</code> 블록을 자유롭게 복제하거나 중복 제거할 수 있습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.stack-below-sp"><a class="rule-link" href="inline-assembly.html#r-asm.rules.stack-below-sp" title="asm.rules.stack-below-sp"><span>[asm<wbr>.rules<wbr>.stack-below-sp]<span/></a></div>
<ul>
<li><code>nostack</code> 옵션이 설정되지 않은 한, asm 코드는 스택 포인터 아래의 스택 공간을 사용할 수 있습니다.
<ul>
<li>asm 블록 진입 시 스택 포인터는 함수 호출을 위해 (타겟 ABI에 따라) 적절하게 정렬됨이 보장됩니다.</li>
<li>스택 오버플로가 발생하지 않도록 할 책임은 사용자에게 있습니다(예: 가드 페이지에 도달하도록 스택 프로빙(stack probing) 사용).</li>
<li>타겟 ABI의 요구에 따라 스택 메모리를 할당할 때는 스택 포인터를 조정해야 합니다.</li>
<li>asm 블록을 나가기 전에 스택 포인터는 원래 값으로 복구되어야 합니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.noreturn"><a class="rule-link" href="inline-assembly.html#r-asm.rules.noreturn" title="asm.rules.noreturn"><span>[asm<wbr>.rules<wbr>.noreturn]<span/></a></div>
<ul>
<li><code>noreturn</code> 옵션이 설정된 경우, 실행이 asm 블록의 끝에 도달하면 동작은 정의되지 않습니다.</li>
</ul>
<div class="rule" id="r-asm.rules.pure"><a class="rule-link" href="inline-assembly.html#r-asm.rules.pure" title="asm.rules.pure"><span>[asm<wbr>.rules<wbr>.pure]<span/></a></div>
<ul>
<li><code>pure</code> 옵션이 설정된 경우, <code>asm!</code>이 직접적인 출력 이외의 부작용을 가지면 동작은 정의되지 않습니다. 또한 동일한 입력에 대해 두 번의 <code>asm!</code> 실행이 서로 다른 출력을 내는 경우에도 동작은 정의되지 않습니다.
<ul>
<li><code>nomem</code> 옵션과 함께 사용될 때, “입력“은 오직 <code>asm!</code>의 직접적인 입력만을 의미합니다.</li>
<li><code>readonly</code> 옵션과 함께 사용될 때, “입력“은 <code>asm!</code>의 직접적인 입력과 <code>asm!</code> 블록이 읽을 수 있도록 허용된 모든 메모리를 포함합니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.preserved-registers"><a class="rule-link" href="inline-assembly.html#r-asm.rules.preserved-registers" title="asm.rules.preserved-registers"><span>[asm<wbr>.rules<wbr>.preserved-registers]<span/></a></div>
<ul>
<li><code>preserves_flags</code> 옵션이 설정된 경우, 다음 플래그 레지스터들은 asm 블록을 나갈 때 반드시 복구되어야 합니다.
<ul>
<li>x86
<ul>
<li><code>EFLAGS</code>의 상태 플래그 (CF, PF, AF, ZF, SF, OF).</li>
<li>부동 소수점 상태 워드 (전체).</li>
<li><code>MXCSR</code>의 부동 소수점 예외 플래그 (PE, UE, OE, ZE, DE, IE).</li>
</ul>
</li>
<li>ARM
<ul>
<li><code>CPSR</code>의 조건 플래그 (N, Z, C, V)</li>
<li><code>CPSR</code>의 포화(Saturation) 플래그 (Q)</li>
<li><code>CPSR</code>의 크거나 같음(Greater than or equal) 플래그 (GE).</li>
<li><code>FPSCR</code>의 조건 플래그 (N, Z, C, V)</li>
<li><code>FPSCR</code>의 포화(Saturation) 플래그 (QC)</li>
<li><code>FPSCR</code>의 부동 소수점 예외 플래그 (IDC, IXC, UFC, OFC, DZC, IOC).</li>
</ul>
</li>
<li>AArch64 및 Arm64EC
<ul>
<li>조건 플래그 (<code>NZCV</code> 레지스터).</li>
<li>부동 소수점 상태 (<code>FPSR</code> 레지스터).</li>
</ul>
</li>
<li>RISC-V
<ul>
<li><code>fcsr</code>의 부동 소수점 예외 플래그 (<code>fflags</code>).</li>
<li>벡터 확장 상태 (<code>vtype</code>, <code>vl</code>, <code>vcsr</code>).</li>
</ul>
</li>
<li>LoongArch
<ul>
<li><code>$fcc[0-7]</code>의 부동 소수점 조건 플래그.</li>
</ul>
</li>
<li>s390x
<ul>
<li>조건 코드 레지스터 <code>cc</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.x86-df"><a class="rule-link" href="inline-assembly.html#r-asm.rules.x86-df" title="asm.rules.x86-df"><span>[asm<wbr>.rules<wbr>.x86-df]<span/></a></div>
<ul>
<li>x86에서, 방향 플래그(<code>EFLAGS</code>의 DF)는 asm 블록 진입 시 해제(clear)되어 있으며, 나갈 때도 반드시 해제되어야 합니다.
<ul>
<li>asm 블록을 나갈 때 방향 플래그가 설정되어 있으면 동작은 정의되지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.x86-x87"><a class="rule-link" href="inline-assembly.html#r-asm.rules.x86-x87" title="asm.rules.x86-x87"><span>[asm<wbr>.rules<wbr>.x86-x87]<span/></a></div>
<ul>
<li>x86에서, 모든 <code>st([0-7])</code> 레지스터들이 <code>out("st(0)") _, out("st(1)") _, ...</code>와 같이 클로버된 것으로 표시되지 않는 한, x87 부동 소수점 레지스터 스택은 변경되지 않은 상태로 유지되어야 합니다.
<ul>
<li>모든 x87 레지스터가 클로버(clobber)된 경우, <code>asm</code> 블록에 진입할 때 x87 레지스터 스택이 비어 있음이 보장됩니다. 어셈블리 코드는 asm 블록을 나갈 때도 x87 레지스터 스택이 비어 있도록 보장해야 합니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[cfg(target_arch = "x86_64")]
</span>pub fn fadd(x: f64, y: f64) -&gt; f64 {
  let mut out = 0f64;
  let mut top = 0u16;
  // 전체 x87 스택을 클로버하면 x87로 복잡한 작업을 수행할 수 있습니다.
  unsafe { core::arch::asm!(
    "fld qword ptr [{x}]",
    "fld qword ptr [{y}])",
    "faddp",
    "fstp qword ptr [{out}]",
    "xor eax, eax",
    "fstsw ax",
    "shl eax, 11",
    x = in(reg) &amp;x,
    y = in(reg) &amp;y,
    out = in(reg) &amp;mut out,
    out("st(0)") _, out("st(1)") _, out("st(2)") _, out("st(3)") _,
    out("st(4)") _, out("st(5)") _, out("st(6)") _, out("st(7)") _,
    out("eax") top
  );}

  assert_eq!(top &amp; 0x7, 0);
  out
}

pub fn main() {
<span class="boring">#[cfg(target_arch = "x86_64")]{
</span>  assert_eq!(fadd(1.0, 1.0), 2.0);
<span class="boring">}
</span>}</code></pre></pre>
<div class="rule" id="r-asm.rules.arm64ec"><a class="rule-link" href="inline-assembly.html#r-asm.rules.arm64ec" title="asm.rules.arm64ec"><span>[asm<wbr>.rules<wbr>.arm64ec]<span/></a></div>
<ul>
<li>arm64ec에서는 함수를 호출할 때 <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec-abi#authoring-arm64ec-in-assembly">적절한 펑크(thunks)가 있는 호출 검사기(call checkers)</a>가 필수입니다.</li>
</ul>
<div class="rule" id="r-asm.rules.only-on-exit"><a class="rule-link" href="inline-assembly.html#r-asm.rules.only-on-exit" title="asm.rules.only-on-exit"><span>[asm<wbr>.rules<wbr>.only-on-exit]<span/></a></div>
<ul>
<li>스택 포인터와 출력이 아닌 레지스터를 원래 값으로 복구해야 한다는 요구 사항은 <code>asm!</code> 블록을 나갈 때만 적용됩니다.
<ul>
<li>즉, 절대 반환되지 않는 <code>asm!</code> 블록은(<code>noreturn</code>으로 표시되지 않았더라도) 이러한 레지스터를 보존할 필요가 없습니다.</li>
<li>(예를 들어 문맥 전환을 위해) 진입했을 때와 다른 <code>asm!</code> 블록으로 반환할 때, 해당 레지스터들은 현재 <em>나가고 있는</em> <code>asm!</code> 블록에 진입했을 때 가졌던 값을 포함해야 합니다.
<ul>
<li>진입하지 않은 <code>asm!</code> 블록을 나갈 수는 없습니다. 또한 이미 나간 <code>asm!</code> 블록을 (다시 진입하지 않고) 또 나갈 수도 없습니다.</li>
<li>모든 타겟별 상태(예: 스레드 로컬 저장소, 스택 바운드)를 전환할 책임은 사용자에게 있습니다.</li>
<li>동일한 함수나 블록 내일지라도, 서로 다른 두 <code>asm!</code> 블록 사이를 점프할 때는 그 문맥(context)이 잠재적으로 다를 수 있음을 고려하고 문맥 전환(context switching)을 수행해야 합니다. 두 <code>asm!</code> 블록 사이에서 특정 문맥 값(예: 현재 스택 포인터 또는 스택 포인터 아래의 임시 값)이 변하지 않은 상태로 유지될 것이라고 가정할 수 없습니다.</li>
<li>접근할 수 있는 메모리 위치의 집합은 진입한 <code>asm!</code> 블록과 나가는 <code>asm!</code> 블록에서 허용된 위치들의 교집합입니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.not-successive"><a class="rule-link" href="inline-assembly.html#r-asm.rules.not-successive" title="asm.rules.not-successive"><span>[asm<wbr>.rules<wbr>.not-successive]<span/></a></div>
<ul>
<li>소스 코드상에서 인접한 두 <code>asm!</code> 블록이 사이에 다른 코드가 없더라도, 바이너리 상에서 사이에 다른 명령어 없이 연속된 주소에 위치할 것이라고 가정할 수 없습니다.</li>
</ul>
<div class="rule" id="r-asm.rules.not-exactly-once"><a class="rule-link" href="inline-assembly.html#r-asm.rules.not-exactly-once" title="asm.rules.not-exactly-once"><span>[asm<wbr>.rules<wbr>.not-exactly-once]<span/></a></div>
<ul>
<li><code>asm!</code> 블록이 출력 바이너리에 정확히 한 번 나타날 것이라고 가정할 수 없습니다. 컴파일러는 <code>asm!</code> 블록을 포함하는 함수가 여러 곳에 인라인되는 경우와 같이 <code>asm!</code> 블록의 여러 복사본을 인스턴스화할 수 있습니다.</li>
</ul>
<div class="rule" id="r-asm.rules.x86-prefix-restriction"><a class="rule-link" href="inline-assembly.html#r-asm.rules.x86-prefix-restriction" title="asm.rules.x86-prefix-restriction"><span>[asm<wbr>.rules<wbr>.x86-prefix-restriction]<span/></a></div>
<ul>
<li>x86에서, 인라인 어셈블리는 컴파일러가 생성한 명령어에 적용될 수 있는 명령어 접두사(예: <code>LOCK</code>)로 끝나서는 안 됩니다.
<ul>
<li>현재 컴파일러는 인라인 어셈블리가 컴파일되는 방식 때문에 이를 감지할 수 없지만, 향후에는 이를 포착하여 거부할 수 있습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-asm.rules.preserves_flags"><a class="rule-link" href="inline-assembly.html#r-asm.rules.preserves_flags" title="asm.rules.preserves_flags"><span>[asm<wbr>.rules<wbr>.preserves_flags]<span/></a></div>
<blockquote>
<p><strong>참고</strong>: 일반적으로 <code>preserves_flags</code>에 포함되는 플래그들은 함수 호출 시 보존되지 <em>않는</em> 플래그들입니다.</p>
</blockquote>
<div class="rule" id="r-asm.validity"><a class="rule-link" href="inline-assembly.html#r-asm.validity" title="asm.validity"><span>[asm<wbr>.validity]<span/></a></div>
<h3 id="정확성-및-유효성"><a class="header" href="#정확성-및-유효성">정확성 및 유효성</a></h3>
<div class="rule" id="r-asm.validity.necessary-but-not-sufficient"><a class="rule-link" href="inline-assembly.html#r-asm.validity.necessary-but-not-sufficient" title="asm.validity.necessary-but-not-sufficient"><span>[asm<wbr>.validity<wbr>.necessary-but-not-sufficient]<span/></a></div>
<p>앞서 언급한 모든 규칙과 더불어, <code>asm!</code>의 문자열 인자는 모든 다른 인자가 평가되고 포맷팅이 수행되며 피연산자가 번역된 후 최종적으로 타겟 아키텍처에 대해 구문적으로 올바르고 의미론적으로 유효한 어셈블리가 되어야 합니다. 포맷팅 규칙을 통해 컴파일러는 올바른 구문을 가진 어셈블리를 생성할 수 있습니다. 피연산자에 관한 규칙은 러스트 피연산자를 <code>asm!</code> 내부 및 외부로 유효하게 번역할 수 있게 합니다. 이러한 규칙들을 준수하는 것은 최종적으로 확장된 어셈블리가 정확하고 유효하기 위해 필요하지만 충분하지는 않습니다. 예를 들면 다음과 같습니다.</p>
<ul>
<li>인자들이 포맷팅된 후 구문적으로 잘못된 위치에 배치될 수 있습니다.</li>
<li>명령어는 올바르게 작성되었으나 아키텍처적으로 유효하지 않은 피연산자가 제공될 수 있습니다.</li>
<li>아키텍처적으로 명시되지 않은 명령어가 명시되지 않은 코드로 어셈블될 수 있습니다.</li>
<li>각각은 정확하고 유효한 명령어 집합일지라도, 연달아 배치될 경우 정의되지 않은 동작을 초래할 수 있습니다.</li>
</ul>
<div class="rule" id="r-asm.validity.non-exhaustive"><a class="rule-link" href="inline-assembly.html#r-asm.validity.non-exhaustive" title="asm.validity.non-exhaustive"><span>[asm<wbr>.validity<wbr>.non-exhaustive]<span/></a></div>
<p>결과적으로, 이러한 규칙들은 _비포괄적(non-exhaustive)_입니다. 컴파일러는 초기 문자열이나 최종적으로 생성된 어셈블리의 정확성과 유효성을 검사할 의무가 없습니다. 어셈블러는 정확성과 유효성을 검사할 수도 있지만 반드시 그래야 하는 것은 아닙니다. <code>asm!</code>을 사용할 때, 오타 하나만으로도 프로그램이 불안정해질 수 있으며, 어셈블리 규칙에는 수천 페이지 분량의 아키텍처 참조 매뉴얼이 포함될 수 있습니다. 프로그래머는 이 <code>unsafe</code> 기능을 호출하는 것이 컴파일러와 아키텍처 양쪽의 규칙을 위반하지 않을 책임을 지는 것임을 인지하고 적절한 주의를 기울여야 합니다.</p>
<div class="rule" id="r-asm.directives"><a class="rule-link" href="inline-assembly.html#r-asm.directives" title="asm.directives"><span>[asm<wbr>.directives]<span/></a></div>
<h3 id="지시어-지원"><a class="header" href="#지시어-지원">지시어 지원</a></h3>
<div class="rule" id="r-asm.directives.subset-supported"><a class="rule-link" href="inline-assembly.html#r-asm.directives.subset-supported" title="asm.directives.subset-supported"><span>[asm<wbr>.directives<wbr>.subset-supported]<span/></a></div>
<p>인라인 어셈블리는 다음과 같이 GNU AS와 LLVM 내부 어셈블러 양쪽에서 지원하는 지시어의 하위 집합을 지원합니다. 다른 지시어를 사용한 결과는 어셈블러에 따라 다르며(오류를 발생시키거나 그대로 수용될 수 있음).</p>
<div class="rule" id="r-asm.directives.stateful"><a class="rule-link" href="inline-assembly.html#r-asm.directives.stateful" title="asm.directives.stateful"><span>[asm<wbr>.directives<wbr>.stateful]<span/></a></div>
<p>만약 인라인 어셈블리에 후속 어셈블리 처리 방식을 변경하는 “상태 유지(stateful)” 지시어가 포함된 경우, 해당 블록은 인라인 어셈블리가 끝나기 전에 그러한 지시어의 효과를 되돌려야(undo) 합니다.</p>
<div class="rule" id="r-asm.directives.supported-directives"><a class="rule-link" href="inline-assembly.html#r-asm.directives.supported-directives" title="asm.directives.supported-directives"><span>[asm<wbr>.directives<wbr>.supported-directives]<span/></a></div>
<p>다음 지시어들은 어셈블러에 의해 지원됨이 보장됩니다:</p>
<ul>
<li><code>.2byte</code></li>
<li><code>.4byte</code></li>
<li><code>.8byte</code></li>
<li><code>.align</code></li>
<li><code>.alt_entry</code></li>
<li><code>.ascii</code></li>
<li><code>.asciz</code></li>
<li><code>.balign</code></li>
<li><code>.balignl</code></li>
<li><code>.balignw</code></li>
<li><code>.bss</code></li>
<li><code>.byte</code></li>
<li><code>.comm</code></li>
<li><code>.data</code></li>
<li><code>.def</code></li>
<li><code>.double</code></li>
<li><code>.endef</code></li>
<li><code>.equ</code></li>
<li><code>.equiv</code></li>
<li><code>.eqv</code></li>
<li><code>.fill</code></li>
<li><code>.float</code></li>
<li><code>.global</code></li>
<li><code>.globl</code></li>
<li><code>.inst</code></li>
<li><code>.insn</code></li>
<li><code>.lcomm</code></li>
<li><code>.long</code></li>
<li><code>.octa</code></li>
<li><code>.option</code></li>
<li><code>.p2align</code></li>
<li><code>.popsection</code></li>
<li><code>.private_extern</code></li>
<li><code>.pushsection</code></li>
<li><code>.quad</code></li>
<li><code>.scl</code></li>
<li><code>.section</code></li>
<li><code>.set</code></li>
<li><code>.short</code></li>
<li><code>.size</code></li>
<li><code>.skip</code></li>
<li><code>.sleb128</code></li>
<li><code>.space</code></li>
<li><code>.string</code></li>
<li><code>.text</code></li>
<li><code>.type</code></li>
<li><code>.uleb128</code></li>
<li><code>.word</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let bytes: *const u8;
let len: usize;
unsafe {
    core::arch::asm!(
        "jmp 3f", "2: .ascii \"Hello World!\"",
        "3: lea {bytes}, [2b+rip]",
        "mov {len}, 12",
        bytes = out(reg) bytes,
        len = out(reg) len
    );
}

let s = unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(bytes, len)) };

assert_eq!(s, "Hello World!");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-asm.target-specific-directives"><a class="rule-link" href="inline-assembly.html#r-asm.target-specific-directives" title="asm.target-specific-directives"><span>[asm<wbr>.target-specific-directives]<span/></a></div>
<h4 id="타겟별-지시어-지원"><a class="header" href="#타겟별-지시어-지원">타겟별 지시어 지원</a></h4>
<div class="rule" id="r-asm.target-specific-directives.dwarf-unwinding"><a class="rule-link" href="inline-assembly.html#r-asm.target-specific-directives.dwarf-unwinding" title="asm.target-specific-directives.dwarf-unwinding"><span>[asm<wbr>.target-specific-directives<wbr>.dwarf-unwinding]<span/></a></div>
<h5 id="dwarf-언와인딩unwinding"><a class="header" href="#dwarf-언와인딩unwinding">Dwarf 언와인딩(Unwinding)</a></h5>
<p>DWARF 언와인딩 정보를 지원하는 ELF 타겟에서 다음 지시어들이 지원됩니다:</p>
<ul>
<li><code>.cfi_adjust_cfa_offset</code></li>
<li><code>.cfi_def_cfa</code></li>
<li><code>.cfi_def_cfa_offset</code></li>
<li><code>.cfi_def_cfa_register</code></li>
<li><code>.cfi_endproc</code></li>
<li><code>.cfi_escape</code></li>
<li><code>.cfi_lsda</code></li>
<li><code>.cfi_offset</code></li>
<li><code>.cfi_personality</code></li>
<li><code>.cfi_register</code></li>
<li><code>.cfi_rel_offset</code></li>
<li><code>.cfi_remember_state</code></li>
<li><code>.cfi_restore</code></li>
<li><code>.cfi_restore_state</code></li>
<li><code>.cfi_return_column</code></li>
<li><code>.cfi_same_value</code></li>
<li><code>.cfi_sections</code></li>
<li><code>.cfi_signal_frame</code></li>
<li><code>.cfi_startproc</code></li>
<li><code>.cfi_undefined</code></li>
<li><code>.cfi_window_save</code></li>
</ul>
<div class="rule" id="r-asm.target-specific-directives.structured-exception-handling"><a class="rule-link" href="inline-assembly.html#r-asm.target-specific-directives.structured-exception-handling" title="asm.target-specific-directives.structured-exception-handling"><span>[asm<wbr>.target-specific-directives<wbr>.structured-exception-handling]<span/></a></div>
<h5 id="구조화된-예외-처리-structured-exception-handling"><a class="header" href="#구조화된-예외-처리-structured-exception-handling">구조화된 예외 처리 (Structured Exception Handling)</a></h5>
<p>구조화된 예외 처리를 사용하는 타겟에서는 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.seh_endproc</code></li>
<li><code>.seh_endprologue</code></li>
<li><code>.seh_proc</code></li>
<li><code>.seh_pushreg</code></li>
<li><code>.seh_savereg</code></li>
<li><code>.seh_setframe</code></li>
<li><code>.seh_stackalloc</code></li>
</ul>
<div class="rule" id="r-asm.target-specific-directives.x86"><a class="rule-link" href="inline-assembly.html#r-asm.target-specific-directives.x86" title="asm.target-specific-directives.x86"><span>[asm<wbr>.target-specific-directives<wbr>.x86]<span/></a></div>
<h5 id="x86-32비트-및-64비트"><a class="header" href="#x86-32비트-및-64비트">x86 (32비트 및 64비트)</a></h5>
<p>32비트 및 64비트 x86 타겟 모두에서 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.nops</code></li>
<li><code>.code16</code></li>
<li><code>.code32</code></li>
<li><code>.code64</code></li>
</ul>
<p><code>.code16</code>, <code>.code32</code>, <code>.code64</code> 지시어의 사용은 어셈블리 블록을 나가기 전에 상태가 기본값으로 복구되는 경우에만 지원됩니다. 32비트 x86은 기본적으로 <code>.code32</code>를 사용하고, x86_64는 기본적으로 <code>.code64</code>를 사용합니다.</p>
<div class="rule" id="r-asm.target-specific-directives.arm-32-bit"><a class="rule-link" href="inline-assembly.html#r-asm.target-specific-directives.arm-32-bit" title="asm.target-specific-directives.arm-32-bit"><span>[asm<wbr>.target-specific-directives<wbr>.arm-32-bit]<span/></a></div>
<h5 id="arm-32비트"><a class="header" href="#arm-32비트">ARM (32비트)</a></h5>
<p>ARM에서 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.even</code></li>
<li><code>.fnstart</code></li>
<li><code>.fnend</code></li>
<li><code>.save</code></li>
<li><code>.movsp</code></li>
<li><code>.code</code></li>
<li><code>.thumb</code></li>
<li><code>.thumb_func</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-safety"><a class="rule-link" href="unsafety.html#r-safety" title="safety"><span>[safety]<span/></a></div>
<h1 id="안전하지-않음"><a class="header" href="#안전하지-않음">안전하지 않음</a></h1>
<div class="rule" id="r-safety.intro"><a class="rule-link" href="unsafety.html#r-safety.intro" title="safety.intro"><span>[safety<wbr>.intro]<span/></a></div>
<p>안전하지 않은(unsafe) 연산은 러스트의 정적 세만틱(static semantics)이 보장하는 메모리 안전성을 잠재적으로 위반할 수 있는 연산들입니다.</p>
<div class="rule" id="r-safety.unsafe-ops"><a class="rule-link" href="unsafety.html#r-safety.unsafe-ops" title="safety.unsafe-ops"><span>[safety<wbr>.unsafe-ops]<span/></a></div>
<p>다음의 언어 레벨 기능들은 러스트의 안전한 하위 집합(safe subset)에서 사용될 수 없습니다:</p>
<div class="rule" id="r-safety.unsafe-deref"><a class="rule-link" href="unsafety.html#r-safety.unsafe-deref" title="safety.unsafe-deref"><span>[safety<wbr>.unsafe-deref]<span/></a></div>
<ul>
<li><a href="types/pointer.html">원시 포인터(raw pointer)</a>를 역참조하는 것.</li>
</ul>
<div class="rule" id="r-safety.unsafe-static"><a class="rule-link" href="unsafety.html#r-safety.unsafe-static" title="safety.unsafe-static"><span>[safety<wbr>.unsafe-static]<span/></a></div>
<ul>
<li><a href="items/static-items.html#mutable-statics">가변(mutable)</a> 또는 <a href="items/external-blocks.html">외부(external)</a> 정적 변수를 읽거나 쓰는 것.</li>
</ul>
<div class="rule" id="r-safety.unsafe-union-access"><a class="rule-link" href="unsafety.html#r-safety.unsafe-union-access" title="safety.unsafe-union-access"><span>[safety<wbr>.unsafe-union-access]<span/></a></div>
<ul>
<li>값을 할당하는 경우를 제외하고 <a href="items/unions.html"><code>유니온(union)</code></a>의 필드에 접근하는 것.</li>
</ul>
<div class="rule" id="r-safety.unsafe-call"><a class="rule-link" href="unsafety.html#r-safety.unsafe-call" title="safety.unsafe-call"><span>[safety<wbr>.unsafe-call]<span/></a></div>
<ul>
<li>안전하지 않은 함수(내장 함수(intrinsic)나 외래 함수(foreign function) 포함)를 호출하는 것.</li>
</ul>
<div class="rule" id="r-safety.unsafe-target-feature-call"><a class="rule-link" href="unsafety.html#r-safety.unsafe-target-feature-call" title="safety.unsafe-target-feature-call"><span>[safety<wbr>.unsafe-target-feature-call]<span/></a></div>
<ul>
<li>동일한 기능을 활성화하는 <code>target_feature</code> 속성이 없는 함수에서 <a href="attributes/codegen.html#r-attributes.codegen.target_feature"><code>target_feature</code></a>가 지정된 안전한 함수를 호출하는 것(<a href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions">attributes.codegen.target_feature.safety-restrictions</a> 참조).</li>
</ul>
<div class="rule" id="r-safety.unsafe-impl"><a class="rule-link" href="unsafety.html#r-safety.unsafe-impl" title="safety.unsafe-impl"><span>[safety<wbr>.unsafe-impl]<span/></a></div>
<ul>
<li><a href="items/traits.html#unsafe-traits">안전하지 않은 트레잇(unsafe trait)</a>을 구현하는 것.</li>
</ul>
<div class="rule" id="r-safety.unsafe-extern"><a class="rule-link" href="unsafety.html#r-safety.unsafe-extern" title="safety.unsafe-extern"><span>[safety<wbr>.unsafe-extern]<span/></a></div>
<ul>
<li><a href="items/external-blocks.html"><code>extern</code></a> 블록을 선언하는 것<sup class="footnote-reference"><a href="#extern-2024">1</a></sup>.</li>
</ul>
<div class="rule" id="r-safety.unsafe-attribute"><a class="rule-link" href="unsafety.html#r-safety.unsafe-attribute" title="safety.unsafe-attribute"><span>[safety<wbr>.unsafe-attribute]<span/></a></div>
<ul>
<li>아이템에 <a href="attributes.html">안전하지 않은 속성(unsafe attribute)</a>을 적용하는 것.</li>
</ul>
<div class="footnote-definition" id="extern-2024"><sup class="footnote-definition-label">1</sup>
<p>2024 에디션 이전에는 extern 블록을 <code>unsafe</code> 없이 선언할 수 있었습니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-unsafe"><a class="rule-link" href="unsafe-keyword.html#r-unsafe" title="unsafe"><span>[unsafe]<span/></a></div>
<h1 id="unsafe-키워드"><a class="header" href="#unsafe-키워드"><code>unsafe</code> 키워드</a></h1>
<div class="rule" id="r-unsafe.intro"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.intro" title="unsafe.intro"><span>[unsafe<wbr>.intro]<span/></a></div>
<p><code>unsafe</code> 키워드는 안전하지 않은 함수(<code>unsafe fn</code>), 안전하지 않은 블록(<code>unsafe {}</code>), 안전하지 않은 트레잇(<code>unsafe trait</code>), 안전하지 않은 트레잇 구현(<code>unsafe impl</code>), 안전하지 않은 외부 블록(<code>unsafe extern</code>), 그리고 안전하지 않은 속성(<code>#[unsafe(attr)]</code>)과 같이 여러 다른 문맥에서 나타날 수 있습니다. 이는 사용되는 위치와 <code>unsafe_op_in_unsafe_fn</code> 린트(lint)의 활성화 여부에 따라 여러 다른 역할을 수행합니다.</p>
<ul>
<li>추가적인 안전 조건을 _정의_하는 코드를 표시하는 데 사용됩니다(<code>unsafe fn</code>, <code>unsafe trait</code>).</li>
<li>추가적인 안전 조건을 _만족_시켜야 하는 코드를 표시하는 데 사용됩니다(<code>unsafe {}</code>, <code>unsafe impl</code>, <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a>이 설정되지 않은 <code>unsafe fn</code>, <code>unsafe extern</code>, <code>#[unsafe(attr)]</code>).</li>
</ul>
<p>다음은 각 경우에 대해 설명합니다. 몇 가지 예시는 <a href="../std/keyword.unsafe.html">키워드 문서</a>를 참조하십시오.</p>
<div class="rule" id="r-unsafe.fn"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.fn" title="unsafe.fn"><span>[unsafe<wbr>.fn]<span/></a></div>
<h2 id="안전하지-않은-함수-unsafe-fn"><a class="header" href="#안전하지-않은-함수-unsafe-fn">안전하지 않은 함수 (<code>unsafe fn</code>)</a></h2>
<div class="rule" id="r-unsafe.fn.intro"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.fn.intro" title="unsafe.fn.intro"><span>[unsafe<wbr>.fn<wbr>.intro]<span/></a></div>
<p>안전하지 않은 함수는 모든 문맥에서 그리고/또는 모든 가능한 입력에 대해 안전하지 않은 함수입니다. 이러한 함수들은 모든 호출자가 준수해야 하지만 컴파일러가 확인하지 않는 요구 사항인 _추가 안전 조건_을 갖는다고 말합니다. 예를 들어, <a href="../std/primitive.slice.html#method.get_unchecked"><code>get_unchecked</code></a>는 인덱스가 범위를 벗어나지 않아야 한다는 추가 안전 조건을 가집니다. 안전하지 않은 함수는 그러한 추가 안전 조건이 무엇인지 설명하는 문서를 동반해야 합니다.</p>
<div class="rule" id="r-unsafe.fn.safety"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.fn.safety" title="unsafe.fn.safety"><span>[unsafe<wbr>.fn<wbr>.safety]<span/></a></div>
<p>이러한 함수는 <code>unsafe</code> 키워드를 앞에 붙여야 하며, <code>unsafe</code> 블록 내부 또는 <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> 린트가 없는 <code>unsafe fn</code> 내부에서만 호출될 수 있습니다.</p>
<div class="rule" id="r-unsafe.block"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.block" title="unsafe.block"><span>[unsafe<wbr>.block]<span/></a></div>
<h2 id="안전하지-않은-블록-unsafe-"><a class="header" href="#안전하지-않은-블록-unsafe-">안전하지 않은 블록 (<code>unsafe {}</code>)</a></h2>
<div class="rule" id="r-unsafe.block.intro"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.block.intro" title="unsafe.block.intro"><span>[unsafe<wbr>.block<wbr>.intro]<span/></a></div>
<p>코드 블록 앞에 <code>unsafe</code> 키워드를 붙여 <a href="unsafety.html">안전하지 않음(Unsafety)</a> 장에 정의된 안전하지 않은 동작들(예: 다른 안전하지 않은 함수 호출 또는 원시 포인터 역참조)의 사용을 허용할 수 있습니다.</p>
<div class="rule" id="r-unsafe.block.fn-body"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.block.fn-body" title="unsafe.block.fn-body"><span>[unsafe<wbr>.block<wbr>.fn-body]<span/></a></div>
<p>기본적으로 안전하지 않은 함수의 본문은 안전하지 않은 블록으로 간주됩니다. 이는 <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> 린트를 활성화하여 변경할 수 있습니다.</p>
<p>연산들을 <code>unsafe</code> 블록 안에 넣음으로써, 프로그래머는 해당 블록 내부의 모든 연산에 대한 추가 안전 조건을 충족하도록 조치를 취했음을 선언합니다.</p>
<p>안전하지 않은 블록은 안전하지 않은 함수와 논리적으로 대칭을 이룹니다. 안전하지 않은 함수가 호출자가 준수해야 하는 증명 책임(proof obligation)을 정의한다면, 안전하지 않은 블록은 블록 내부에서 호출된 함수나 연산의 모든 관련 증명 책임이 완료되었음을 나타냅니다. 증명 책임을 완료하는 방법은 많습니다. 예를 들어, 특정 속성이 확실히 참임을 보장하는 런타임 검사나 데이터 구조의 불변성(invariants)이 있을 수 있습니다. 또는 안전하지 않은 블록이 <code>unsafe fn</code> 내부에 있는 경우, 해당 블록은 그 함수의 증명 책임을 사용하여 블록 내부에서 발생하는 증명 책임을 완료할 수 있습니다.</p>
<p>안전하지 않은 블록은 외부 라이브러리를 래핑하거나, 하드웨어를 직접 사용하거나, 언어에 직접 존재하지 않는 기능을 구현할 때 사용됩니다. 예를 들어, 러스트는 메모리 안전한 동시성을 구현하는 데 필요한 언어적 기능을 제공하지만, 표준 라이브러리의 스레드 및 메시지 패싱 구현은 안전하지 않은 블록을 사용합니다.</p>
<p>러스트의 타입 시스템은 동적 안전성 요구 사항에 대한 보수적인 근사치이므로, 어떤 경우에는 안전한 코드를 사용하는 데 성능 비용이 발생합니다. 예를 들어, 이중 연결 리스트는 트리 구조가 아니며 안전한 코드에서는 참조 횟수 계산(RC) 포인터로만 표현될 수 있습니다. <code>unsafe</code> 블록을 사용하여 역방향 링크를 원시 포인터로 표현하면 참조 횟수 계산 없이 구현할 수 있습니다. (이 예제에 대한 더 심도 있는 탐구는 <a href="https://rust-unofficial.github.io/too-many-lists/">“Learn Rust With Entirely Too Many Linked Lists”</a>를 참조하십시오.)</p>
<div class="rule" id="r-unsafe.trait"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.trait" title="unsafe.trait"><span>[unsafe<wbr>.trait]<span/></a></div>
<h2 id="안전하지-않은-트레잇-unsafe-trait"><a class="header" href="#안전하지-않은-트레잇-unsafe-trait">안전하지 않은 트레잇 (<code>unsafe trait</code>)</a></h2>
<div class="rule" id="r-unsafe.trait.intro"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.trait.intro" title="unsafe.trait.intro"><span>[unsafe<wbr>.trait<wbr>.intro]<span/></a></div>
<p>안전하지 않은 트레잇은 트레잇의 _구현체_가 준수해야 하는 추가 안전 조건이 함께 제공되는 트레잇입니다. 안전하지 않은 트레잇은 그러한 추가 안전 조건이 무엇인지 설명하는 문서를 동반해야 합니다.</p>
<div class="rule" id="r-unsafe.trait.safety"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.trait.safety" title="unsafe.trait.safety"><span>[unsafe<wbr>.trait<wbr>.safety]<span/></a></div>
<p>그러한 트레잇은 <code>unsafe</code> 키워드를 앞에 붙여야 하며, 오직 <code>unsafe impl</code> 블록을 통해서만 구현될 수 있습니다.</p>
<div class="rule" id="r-unsafe.impl"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.impl" title="unsafe.impl"><span>[unsafe<wbr>.impl]<span/></a></div>
<h2 id="안전하지-않은-트레잇-구현-unsafe-impl"><a class="header" href="#안전하지-않은-트레잇-구현-unsafe-impl">안전하지 않은 트레잇 구현 (<code>unsafe impl</code>)</a></h2>
<p>안전하지 않은 트레잇을 구현할 때, 구현체 앞에 <code>unsafe</code> 키워드를 붙여야 합니다. <code>unsafe impl</code>을 작성함으로써, 프로그래머는 트레잇에서 요구하는 추가 안전 조건을 충족하도록 조치를 취했음을 선언합니다.</p>
<p>안전하지 않은 트레잇 구현은 안전하지 않은 트레잇과 논리적으로 대칭을 이룹니다. 안전하지 않은 트레잇이 구현체가 준수해야 하는 증명 책임을 정의한다면, 안전하지 않은 구현은 모든 관련 증명 책임이 완료되었음을 나타냅니다.</p>
<div class="rule" id="r-unsafe.extern"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.extern" title="unsafe.extern"><span>[unsafe<wbr>.extern]<span/></a></div>
<h2 id="안전하지-않은-외부-블록-unsafe-extern"><a class="header" href="#안전하지-않은-외부-블록-unsafe-extern">안전하지 않은 외부 블록 (<code>unsafe extern</code>)</a></h2>
<p><a href="items/external-blocks.html">외부 블록</a>을 선언하는 프로그래머는 내부에 포함된 아이템의 시그니처가 정확함을 보장해야 합니다. 그렇지 않으면 정의되지 않은 동작으로 이어질 수 있습니다. 이러한 의무가 충족되었음을 <code>unsafe extern</code>을 작성하여 나타냅니다.</p>
<div class="rule" id="r-unsafe.extern.edition2024"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.extern.edition2024" title="unsafe.extern.edition2024"><span>[unsafe<wbr>.extern<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>extern</code> 블록에 <code>unsafe</code>를 붙이지 않아도 되었습니다.</p>
</blockquote>
<div class="rule" id="r-unsafe.attribute"><a class="rule-link" href="unsafe-keyword.html#r-unsafe.attribute" title="unsafe.attribute"><span>[unsafe<wbr>.attribute]<span/></a></div>
<h2 id="안전하지-않은-속성-unsafeattr"><a class="header" href="#안전하지-않은-속성-unsafeattr">안전하지 않은 속성 (<code>#[unsafe(attr)]</code>)</a></h2>
<p><a href="attributes.html">안전하지 않은 속성</a>은 속성을 사용할 때 준수해야 하는 추가 안전 조건이 있는 속성입니다. 컴파일러는 이러한 조건이 준수되었는지 확인할 수 없습니다. 조건이 충족되었음을 단언하기 위해, 이러한 속성들은 <code>unsafe(..)</code>로 감싸야 합니다. 예를 들어, <code>#[unsafe(no_mangle)]</code>과 같습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-undefined"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined" title="undefined"><span>[undefined]<span/></a></div>
<h2 id="정의되지-않은-동작으로-간주되는-경우"><a class="header" href="#정의되지-않은-동작으로-간주되는-경우">정의되지 않은 동작으로 간주되는 경우</a></h2>
<div class="rule" id="r-undefined.general"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.general" title="undefined.general"><span>[undefined<wbr>.general]<span/></a></div>
<p>러스트 코드가 다음 목록의 동작 중 어느 하나라도 보인다면 잘못된 것입니다. 이는 <code>unsafe</code> 블록과 <code>unsafe</code> 함수 내부의 코드를 포함합니다. <code>unsafe</code>는 단지 정의되지 않은 동작을 피하는 책임이 프로그래머에게 있음을 의미할 뿐이며, 러스트 프로그램이 정의되지 않은 동작을 결코 일으켜서는 안 된다는 사실을 바꾸지는 않습니다.</p>
<div class="rule" id="r-undefined.soundness"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.soundness" title="undefined.soundness"><span>[undefined<wbr>.soundness]<span/></a></div>
<p>안전하지 않은 코드를 작성할 때, 그 코드와 상호 작용하는 모든 안전한 코드가 이러한 동작들을 유발할 수 없도록 보장하는 것은 프로그래머의 책임입니다. 모든 안전한 클라이언트에 대해 이 속성을 만족하는 안전하지 않은 코드를 _건전하다(sound)_고 하며, 안전한 코드에 의해 오용되어 정의되지 않은 동작을 보일 수 있는 안전하지 않은 코드는 _불건전하다(unsound)_고 합니다.</p>
<div class="warning">
<p><em><strong>경고:</strong></em> 다음 목록은 포괄적이지 않으며, 늘어나거나 줄어들 수 있습니다. 안전하지 않은 코드에서 무엇이 허용되고 허용되지 않는지에 대한 러스트 세만틱의 공식적인 모델은 아직 없으므로, 안전하지 않다고 간주되는 동작이 더 있을 수 있습니다. 또한 우리는 목록의 일부 동작을 미래에 정의된(defined) 동작으로 만들 권리를 가집니다. 즉, 이 목록은 어떤 것이 모든 미래 러스트 버전에서 <em>반드시</em> 항상 정의되지 않은 상태로 남을 것임을 말하는 것은 아닙니다(하지만 미래에 일부 항목에 대해 그러한 약속을 할 수도 있습니다).</p>
<p>안전하지 않은 코드를 작성하기 전에 <a href="../nomicon/index.html">러스트노미콘(Rustonomicon)</a>을 읽어보시기 바랍니다.</p>
</div>
<div class="rule" id="r-undefined.race"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.race" title="undefined.race"><span>[undefined<wbr>.race]<span/></a></div>
<ul>
<li>데이터 경합 (Data races).</li>
</ul>
<div class="rule" id="r-undefined.pointer-access"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.pointer-access" title="undefined.pointer-access"><span>[undefined<wbr>.pointer-access]<span/></a></div>
<ul>
<li><a href="behavior-considered-undefined.html#dangling-pointers">매달린 포인터(dangling pointer)</a>이거나 <a href="behavior-considered-undefined.html#places-based-on-misaligned-pointers">정렬되지 않은 포인터에 기반한</a> 위치에 접근(로드 또는 스토어)하는 것.</li>
</ul>
<div class="rule" id="r-undefined.place-projection"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.place-projection" title="undefined.place-projection"><span>[undefined<wbr>.place-projection]<span/></a></div>
<ul>
<li><a href="../std/primitive.pointer.html#method.offset">범위 내 포인터 산술 연산(in-bounds pointer arithmetic)</a>의 요구 사항을 위반하는 위치 투영(place projection)을 수행하는 것. 위치 투영이란 <a href="expressions/field-expr.html">필드 표현식</a>, <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스 표현식</a>, 또는 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열/슬라이스 인덱스 표현식</a>을 의미합니다.</li>
</ul>
<div class="rule" id="r-undefined.alias"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.alias" title="undefined.alias"><span>[undefined<wbr>.alias]<span/></a></div>
<ul>
<li>
<p><a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">포인터 별칭 규칙(pointer aliasing rules)</a>을 위반하는 것. <code>Box&lt;T&gt;</code>, <code>&amp;mut T</code>, <code>&amp;T</code>는 LLVM의 스코프 기반 <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> 모델을 따릅니다. 단, <code>&amp;T</code>가 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>를 포함하는 경우는 예외입니다. 참조와 박스는 살아있는(live) 동안 <a href="behavior-considered-undefined.html#dangling-pointers">매달린 포인터</a>가 되어서는 안 됩니다. 정확한 생존 기간은 명시되지 않았으나, 몇 가지 한계가 존재합니다:</p>
<ul>
<li>참조의 경우, 생존 기간의 상한선은 대여 검사기(borrow checker)가 할당한 구문상 라이프타임입니다. 즉, 그 라이프타임보다 <em>더 길게</em> 살아있을 수 없습니다.</li>
<li>참조나 박스가 함수로 전달되거나 함수에서 반환될 때마다, 그것은 살아있는 것으로 간주됩니다.</li>
<li>참조가(<code>Box</code>가 아닌!) 함수로 전달될 때, 그것은 최소한 해당 함수 호출 동안은 살아있습니다. 이 역시 <code>&amp;T</code>가 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>를 포함하는 경우는 예외입니다.
이 모든 사항은 이러한 타입의 값들이 복합 타입의 (중첩된) 필드로 전달될 때도 적용되지만, 포인터 간접 참조(indirections) 뒤에 있는 경우는 제외됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-undefined.immutable"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.immutable" title="undefined.immutable"><span>[undefined<wbr>.immutable]<span/></a></div>
<ul>
<li>
<p>불변(immutable) 바이트를 수정하는 것. <a href="destructors.html#constant-promotion">상수 승격(const-promoted)</a> 표현식을 통해 도달 가능한 모든 바이트는 불변이며, <code>'static</code>으로 <a href="destructors.html#temporary-lifetime-extension">수명 연장(lifetime-extended)</a>된 <code>static</code> 및 <code>const</code> 초기화 식의 대여를 통해 도달 가능한 바이트들도 불변입니다. 불변 바인딩이나 불변 <code>static</code>에 의해 소유된 바이트들은, 해당 바이트들이 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>의 일부가 아닌 한 불변입니다.</p>
<p>게다가, 공유 참조가 <a href="behavior-considered-undefined.html#pointed-to-bytes">가리키는</a> 바이트들은 다른 참조(공유 및 가변 모두)와 <code>Box</code>를 통한 전이적 참조를 포함하여 모두 불변입니다. 전이성에는 복합 타입의 필드에 저장된 참조들도 포함됩니다.</p>
<p>수정이란 관련 바이트 중 어느 하나라도 겹치는 0바이트 이상의 모든 쓰기 연산을 의미합니다(해당 쓰기가 메모리 내용을 변경하지 않더라도 마찬가지입니다).</p>
</li>
</ul>
<div class="rule" id="r-undefined.intrinsic"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.intrinsic" title="undefined.intrinsic"><span>[undefined<wbr>.intrinsic]<span/></a></div>
<ul>
<li>컴파일러 내장 함수(intrinsics)를 통해 정의되지 않은 동작을 유발하는 것.</li>
</ul>
<div class="rule" id="r-undefined.target-feature"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.target-feature" title="undefined.target-feature"><span>[undefined<wbr>.target-feature]<span/></a></div>
<ul>
<li>현재 플랫폼이 지원하지 않는 플랫폼 기능을 사용하여 컴파일된 코드를 실행하는 것(<a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> 참조). 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 제외합니다.</li>
</ul>
<div class="rule" id="r-undefined.call"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.call" title="undefined.call"><span>[undefined<wbr>.call]<span/></a></div>
<ul>
<li>잘못된 호출 ABI로 함수를 호출하거나, 잘못된 언와인드(unwind) ABI를 가진 함수에서 언와인딩을 수행하는 것.</li>
</ul>
<div class="rule" id="r-undefined.invalid"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.invalid" title="undefined.invalid"><span>[undefined<wbr>.invalid]<span/></a></div>
<ul>
<li><a href="behavior-considered-undefined.html#invalid-values">유효하지 않은 값</a>을 생성하는 것. 값을 “생성“한다는 것은 값이 장소(place)에 할당되거나 장소로부터 읽힐 때, 함수/기본 연산으로 전달되거나 함수/기본 연산으로부터 반환될 때마다 발생합니다.</li>
</ul>
<div class="rule" id="r-undefined.asm"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.asm" title="undefined.asm"><span>[undefined<wbr>.asm]<span/></a></div>
<ul>
<li>인라인 어셈블리의 잘못된 사용. 자세한 내용은 인라인 어셈블리를 사용하는 코드를 작성할 때 따라야 할 <a href="inline-assembly.html#rules-for-inline-assembly">규칙</a>을 참조하십시오.</li>
</ul>
<div class="rule" id="r-undefined.const-transmute-ptr2int"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.const-transmute-ptr2int" title="undefined.const-transmute-ptr2int"><span>[undefined<wbr>.const-transmute-ptr2int]<span/></a></div>
<ul>
<li><strong><a href="const_eval.html#const-context">상수 컨텍스트(const context)</a>에서</strong>: 할당된 객체에 대한 포인터(참조, 원시 포인터, 또는 함수 포인터)를 정수와 같은 비포인터 타입으로 변환(transmute)하거나 재해석하는 것. ’재해석’이란 캐스트 없이 포인터 값을 정수 타입으로 로드하는 것을 말하며, 예를 들어 원시 포인터 캐스트를 수행하거나 유니온을 사용하는 경우가 해당됩니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 정의되지 않은 동작은 프로그램 전체에 영향을 미칩니다. 예를 들어, C의 정의되지 않은 동작을 보이는 C 함수를 호출하면 프로그램 전체에 정의되지 않은 동작이 포함되어 러스트 코드에도 영향을 줄 수 있습니다. 반대의 경우도 마찬가지로, 러스트에서의 정의되지 않은 동작은 다른 언어로의 모든 FFI 호출에 의해 실행되는 코드에 악영향을 줄 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-undefined.pointed-to"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.pointed-to" title="undefined.pointed-to"><span>[undefined<wbr>.pointed-to]<span/></a></div>
<h3 id="가리키는-바이트-pointed-to-bytes"><a class="header" href="#가리키는-바이트-pointed-to-bytes">가리키는 바이트 (Pointed-to bytes)</a></h3>
<p>포인터나 참조가 “가리키는” 바이트 범위는 포인터 값과 피지시체(pointee) 타입의 크기(<code>size_of_val</code> 사용)에 의해 결정됩니다.</p>
<h3 id="잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers"><a class="header" href="#잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers">잘못 정렬된 포인터에 기반한 장소 (Places based on misaligned pointers)</a></h3>
<div class="rule" id="r-undefined.misaligned"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned" title="undefined.misaligned"><span>[undefined<wbr>.misaligned]<span/></a></div>
<div class="rule" id="r-undefined.misaligned.general"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned.general" title="undefined.misaligned.general"><span>[undefined<wbr>.misaligned<wbr>.general]<span/></a></div>
<p>장소 계산 중 마지막 <code>*</code> 투영(projection)이 해당 타입에 맞게 정렬되지 않은 포인터에 대해 수행된 경우, 해당 장소는 “잘못 정렬된 포인터에 기반한다“고 합니다. (장소 표현식에 <code>*</code> 투영이 없다면 이는 지역 변수나 <code>static</code>의 필드에 접근하는 것이며, rustc가 적절한 정렬을 보장합니다. <code>*</code> 투영이 여러 개인 경우, 각각의 투영은 메모리로부터 역참조될 포인터 자체를 로드하며, 이러한 각 로드는 정렬 제약 조건을 따릅니다. 러스트의 겉보기 구문에서는 자동 역참조로 인해 일부 <code>*</code> 투영이 생략될 수 있음에 유의하십시오. 여기서는 완전히 확장된 장소 표현식을 고려합니다.)</p>
<p>예를 들어, <code>ptr</code>의 타입이 <code>*const S</code>이고 <code>S</code>의 정렬(alignment)이 8이라면, <code>ptr</code>은 반드시 8로 정렬되어야 합니다. 그렇지 않으면 <code>(*ptr).f</code>는 “잘못 정렬된 포인터에 기반한” 것이 됩니다. 이는 필드 <code>f</code>의 타입이 <code>u8</code>(즉, 정렬이 1인 타입)인 경우에도 마찬가지입니다. 다시 말해, 정렬 요구 사항은 접근하려는 필드의 타입이 아니라 역참조된 포인터의 타입에서 비롯됩니다.</p>
<div class="rule" id="r-undefined.misaligned.load-store"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned.load-store" title="undefined.misaligned.load-store"><span>[undefined<wbr>.misaligned<wbr>.load-store]<span/></a></div>
<p>잘못 정렬된 포인터에 기반한 장소는 해당 장소로부터 로드하거나 해당 장소에 스토어할 때만 정의되지 않은 동작을 유발함에 유의하십시오.</p>
<div class="rule" id="r-undefined.misaligned.raw"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned.raw" title="undefined.misaligned.raw"><span>[undefined<wbr>.misaligned<wbr>.raw]<span/></a></div>
<p>그러한 장소에 대한 <code>&amp;raw const</code>/<code>&amp;raw mut</code>는 허용됩니다.</p>
<div class="rule" id="r-undefined.misaligned.reference"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned.reference" title="undefined.misaligned.reference"><span>[undefined<wbr>.misaligned<wbr>.reference]<span/></a></div>
<p>장소에 대한 <code>&amp;</code>/<code>&amp;mut</code>는 필드 타입의 정렬을 요구하며(그렇지 않으면 프로그램이 “유효하지 않은 값을 생성“하게 됨), 이는 일반적으로 정렬된 포인터에 기반해야 한다는 요구 사항보다 덜 제한적입니다.</p>
<div class="rule" id="r-undefined.misaligned.packed"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.misaligned.packed" title="undefined.misaligned.packed"><span>[undefined<wbr>.misaligned<wbr>.packed]<span/></a></div>
<p>필드 타입이 자신을 포함하는 타입보다 더 엄격하게 정렬되어 있을 수 있는 경우(예: <code>repr(packed)</code>), 참조를 취하면 컴파일러 오류가 발생합니다. 이는 정렬된 포인터에 기반하는 것이 새로운 참조가 정렬되도록 보장하는 데 항상 충분하지만, 항상 필수적인 것은 아님을 의미합니다.</p>
<h3 id="매달린-포인터-dangling-pointers"><a class="header" href="#매달린-포인터-dangling-pointers">매달린 포인터 (Dangling pointers)</a></h3>
<div class="rule" id="r-undefined.dangling"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.dangling" title="undefined.dangling"><span>[undefined<wbr>.dangling]<span/></a></div>
<div class="rule" id="r-undefined.dangling.general"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.dangling.general" title="undefined.dangling.general"><span>[undefined<wbr>.dangling<wbr>.general]<span/></a></div>
<p>참조/포인터가 <a href="behavior-considered-undefined.html#pointed-to-bytes">가리키는</a> 모든 바이트가 동일한 살아있는(live) 할당의 일부가 아닌 경우(특히 모든 바이트는 <em>어떤</em> 할당의 일부여야 함), 해당 참조/포인터는 “매달려(dangling)” 있다고 합니다.</p>
<div class="rule" id="r-undefined.dangling.zero-size"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.dangling.zero-size" title="undefined.dangling.zero-size"><span>[undefined<wbr>.dangling<wbr>.zero-size]<span/></a></div>
<p>크기가 0인 경우, 포인터는 (비록 널 포인터일지라도) 결코 “매달려” 있지 않은 것으로 간주됩니다.</p>
<div class="rule" id="r-undefined.dangling.dynamic-size"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.dangling.dynamic-size" title="undefined.dangling.dynamic-size"><span>[undefined<wbr>.dangling<wbr>.dynamic-size]<span/></a></div>
<p>동적 크기 타입(슬라이스 및 문자열 등)은 전체 범위를 가리키므로, 길이 메타데이터가 결코 너무 크지 않도록 하는 것이 중요합니다.</p>
<div class="rule" id="r-undefined.dangling.alloc-limit"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.dangling.alloc-limit" title="undefined.dangling.alloc-limit"><span>[undefined<wbr>.dangling<wbr>.alloc-limit]<span/></a></div>
<p>특히, 러스트 값의 동적 크기(<code>size_of_val</code>에 의해 결정됨)는 결코 <code>isize::MAX</code>를 초과해서는 안 됩니다. 단일 할당이 <code>isize::MAX</code>보다 큰 것은 불가능하기 때문입니다.</p>
<h3 id="유효하지-않은-값-invalid-values"><a class="header" href="#유효하지-않은-값-invalid-values">유효하지 않은 값 (Invalid values)</a></h3>
<div class="rule" id="r-undefined.validity"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity" title="undefined.validity"><span>[undefined<wbr>.validity]<span/></a></div>
<div class="rule" id="r-undefined.validity.general"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.general" title="undefined.validity.general"><span>[undefined<wbr>.validity<wbr>.general]<span/></a></div>
<p>러스트 컴파일러는 프로그램 실행 중에 생성된 모든 값이 “유효하다“고 가정합니다. 따라서 유효하지 않은 값을 생성하는 것은 즉시 정의되지 않은 동작(UB)으로 이어집니다.</p>
<p>값이 유효한지 여부는 타입에 따라 다릅니다:</p>
<div class="rule" id="r-undefined.validity.bool"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.bool" title="undefined.validity.bool"><span>[undefined<wbr>.validity<wbr>.bool]<span/></a></div>
<ul>
<li><a href="types/boolean.html"><code>bool</code></a> 값은 <code>false</code> (<code>0</code>) 또는 <code>true</code> (<code>1</code>)여야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.fn-pointer"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.fn-pointer" title="undefined.validity.fn-pointer"><span>[undefined<wbr>.validity<wbr>.fn-pointer]<span/></a></div>
<ul>
<li><code>fn</code> 포인터 값은 널(null)이 아니어야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.char"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.char" title="undefined.validity.char"><span>[undefined<wbr>.validity<wbr>.char]<span/></a></div>
<ul>
<li><code>char</code> 값은 써로게이트(surrogate, 즉 <code>0xD800..=0xDFFF</code> 범위 내의 값)가 아니어야 하며, <code>char::MAX</code>보다 작거나 같아야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.never"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.never" title="undefined.validity.never"><span>[undefined<wbr>.validity<wbr>.never]<span/></a></div>
<ul>
<li><code>!</code> 값은 결코 존재해서는 안 됩니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.scalar"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.scalar" title="undefined.validity.scalar"><span>[undefined<wbr>.validity<wbr>.scalar]<span/></a></div>
<ul>
<li>정수(<code>i*</code>/<code>u*</code>), 부동 소수점 값(<code>f*</code>), 또는 원시 포인터는 반드시 초기화되어야 합니다. 즉, <a href="http://llvm.org/docs/LangRef.html#undefined-values">초기화되지 않은 메모리</a>로부터 얻어서는 안 됩니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.str"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.str" title="undefined.validity.str"><span>[undefined<wbr>.validity<wbr>.str]<span/></a></div>
<ul>
<li><code>str</code> 값은 <code>[u8]</code>과 같이 취급됩니다. 즉, 반드시 초기화되어야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.enum"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.enum" title="undefined.validity.enum"><span>[undefined<wbr>.validity<wbr>.enum]<span/></a></div>
<ul>
<li>열거형(<code>enum</code>)은 유효한 판별자(discriminant)를 가져야 하며, 해당 판별자가 나타내는 변형(variant)의 모든 필드는 각각의 타입에 대해 유효해야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.struct"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.struct" title="undefined.validity.struct"><span>[undefined<wbr>.validity<wbr>.struct]<span/></a></div>
<ul>
<li>구조체(<code>struct</code>), 튜플, 배열은 모든 필드/요소가 각각의 타입에 대해 유효할 것을 요구합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.union"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.union" title="undefined.validity.union"><span>[undefined<wbr>.validity<wbr>.union]<span/></a></div>
<ul>
<li>유니온(<code>union</code>)의 경우, 정확한 유효성 요구 사항은 아직 결정되지 않았습니다. 분명히, 안전한 코드만으로 생성할 수 있는 모든 값은 유효합니다. 만약 유니온이 크기가 0인 필드를 가지고 있다면, 가능한 모든 값이 유효합니다. 더 자세한 내용은 <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/438">여전히 논의 중</a>입니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.reference-box"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.reference-box" title="undefined.validity.reference-box"><span>[undefined<wbr>.validity<wbr>.reference-box]<span/></a></div>
<ul>
<li>참조 또는 <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>는 정렬되어 있어야 하고 널이 아니어야 하며, <a href="behavior-considered-undefined.html#dangling-pointers">매달려</a> 있어서도 안 됩니다. 또한 유효한 값을 가리켜야 합니다(동적 크기 타입의 경우, 메타데이터에 의해 결정된 피지시체의 실제 동적 타입을 사용). 마지막 지점(유효한 값을 가리켜야 한다는 것)은 여전히 논의의 여지가 있음에 유의하십시오.</li>
</ul>
<div class="rule" id="r-undefined.validity.wide"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.wide" title="undefined.validity.wide"><span>[undefined<wbr>.validity<wbr>.wide]<span/></a></div>
<ul>
<li>와이드 참조(wide reference), <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, 또는 원시 포인터의 메타데이터는 크기가 정해지지 않은 꼬리(unsized tail)의 타입과 일치해야 합니다:
<ul>
<li><code>dyn Trait</code> 메타데이터는 컴파일러가 생성한 <code>Trait</code>용 vtable에 대한 포인터여야 합니다. (원시 포인터의 경우, 이 요구 사항은 여전히 논의 중입니다.)</li>
<li>슬라이스(<code>[T]</code>) 메타데이터는 유효한 <code>usize</code>여야 합니다. 더 나아가, 와이드 참조 및 <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>의 경우, 슬라이스 메타데이터가 가리키는 값의 전체 크기를 <code>isize::MAX</code>보다 크게 만든다면 유효하지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-undefined.validity.valid-range"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.valid-range" title="undefined.validity.valid-range"><span>[undefined<wbr>.validity<wbr>.valid-range]<span/></a></div>
<ul>
<li>
<p>만약 타입이 유효한 값의 커스텀 범위를 가지고 있다면, 유효한 값은 반드시 그 범위 내에 있어야 합니다. 표준 라이브러리에서는 <a href="../core/ptr/non_null/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a>와 <a href="../core/num/nonzero/struct.NonZero.html"><code>NonZero&lt;T&gt;</code></a>가 이에 해당합니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code>는 불안정한 <code>rustc_layout_scalar_valid_range_*</code> 속성들을 사용하여 이를 수행합니다.</p>
</blockquote>
</li>
</ul>
<div class="rule" id="r-undefined.validity.undef"><a class="rule-link" href="behavior-considered-undefined.html#r-undefined.validity.undef" title="undefined.validity.undef"><span>[undefined<wbr>.validity<wbr>.undef]<span/></a></div>
<p><strong>참고:</strong> 초기화되지 않은 메모리는 제한된 유효 값 집합을 가진 모든 타입에 대해 암시적으로 유효하지 않습니다. 다시 말해, 초기화되지 않은 메모리를 읽는 것이 허용되는 유일한 경우는 <code>union</code> 내부와 “패딩(padding)”(타입의 필드 사이의 간격)뿐입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe로-간주되지-않는-동작"><a class="header" href="#unsafe로-간주되지-않는-동작"><code>unsafe</code>로 간주되지 않는 동작</a></h2>
<p>러스트 컴파일러는 다음의 동작들을 _안전하지 않다(unsafe)_고 간주하지 않습니다. 비록 프로그래머가 이를 바람직하지 않거나, 예상치 못했거나, 잘못된 것으로 생각할지라도 말입니다.</p>
<h5 id="데드락-deadlocks"><a class="header" href="#데드락-deadlocks">데드락 (Deadlocks)</a></h5>
<h5 id="메모리-및-기타-리소스-누수-leaks"><a class="header" href="#메모리-및-기타-리소스-누수-leaks">메모리 및 기타 리소스 누수 (Leaks)</a></h5>
<h5 id="소멸자destructor를-호출하지-않고-종료하는-것"><a class="header" href="#소멸자destructor를-호출하지-않고-종료하는-것">소멸자(destructor)를 호출하지 않고 종료하는 것</a></h5>
<h5 id="포인터-누수를-통해-무작위화된-베이스-주소를-노출하는-것"><a class="header" href="#포인터-누수를-통해-무작위화된-베이스-주소를-노출하는-것">포인터 누수를 통해 무작위화된 베이스 주소를 노출하는 것</a></h5>
<h5 id="정수-오버플로-integer-overflow"><a class="header" href="#정수-오버플로-integer-overflow">정수 오버플로 (Integer overflow)</a></h5>
<p>프로그램에 산술 오버플로가 포함되어 있다면, 이는 프로그래머의 실수입니다. 이어지는 논의에서, 우리는 산술 오버플로와 래핑(wrapping) 산술 연산을 구분합니다. 전자는 잘못된 것이고, 후자는 의도된 것입니다.</p>
<p>프로그래머가 <code>debug_assert!</code> 단언을 활성화한 경우(예: 최적화되지 않은 빌드), 구현체는 오버플로 시 <code>panic</code>을 일으키는 동적 검사를 삽입해야 합니다. 다른 종류의 빌드에서는 구현체의 재량에 따라 오버플로 시 <code>panic</code>이 발생하거나 조용히 값이 래핑될 수 있습니다.</p>
<p>암시적으로 래핑되는 오버플로의 경우, 구현체는 2의 보수 오버플로 관례를 사용하여 잘 정의된(여전히 오류로 간주될지라도) 결과를 제공해야 합니다.</p>
<p>정수 타입들은 프로그래머가 명시적으로 래핑 산술 연산을 수행할 수 있도록 내재적 메서드들을 제공합니다. 예를 들어, <code>i32::wrapping_add</code>는 2의 보수 래핑 덧셈을 제공합니다.</p>
<p>표준 라이브러리는 또한 <code>T</code>에 대한 모든 표준 산술 연산이 래핑 세만틱을 갖도록 보장하는 <code>Wrapping&lt;T&gt;</code> 뉴타입(newtype)을 제공합니다.</p>
<p>오류 조건, 근거, 그리고 정수 오버플로에 대한 더 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a>을 참조하십시오.</p>
<h5 id="논리-오류-logic-errors"><a class="header" href="#논리-오류-logic-errors">논리 오류 (Logic errors)</a></h5>
<p>안전한 코드는 컴파일 타임이나 런타임에 확인할 수 없는 추가적인 논리적 제약을 부과할 수 있습니다. 프로그램이 이러한 제약을 위반할 경우, 동작은 명시되지 않을 수 있으나 정의되지 않은 동작으로 이어지지는 않습니다. 여기에는 패닉, 잘못된 결과, 중단(abort), 그리고 종료되지 않음(non-termination) 등이 포함될 수 있습니다. 동작은 실행, 빌드, 또는 빌드 종류에 따라 달라질 수도 있습니다.</p>
<p>예를 들어, <code>Hash</code>와 <code>Eq</code>를 모두 구현할 때는 동일하다고 간주되는 값들이 동일한 해시 값을 가져야 한다는 요구 사항이 있습니다. 또 다른 예로 <code>BinaryHeap</code>, <code>BTreeMap</code>, <code>BTreeSet</code>, <code>HashMap</code>, <code>HashSet</code>과 같은 데이터 구조들은 데이터 구조에 포함된 동안 키(key)의 수정에 대한 제약 조건을 기술합니다. 이러한 제약 조건을 위반하는 것은 안전하지 않은(unsafe) 것으로 간주되지는 않지만, 프로그램은 오류가 있는 것으로 간주되며 그 동작은 예측할 수 없게 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-const-eval"><a class="rule-link" href="const_eval.html#r-const-eval" title="const-eval"><span>[const-eval]<span/></a></div>
<h1 id="상수-평가-constant-evaluation"><a class="header" href="#상수-평가-constant-evaluation">상수 평가 (Constant evaluation)</a></h1>
<div class="rule" id="r-const-eval.general"><a class="rule-link" href="const_eval.html#r-const-eval.general" title="const-eval.general"><span>[const-eval<wbr>.general]<span/></a></div>
<p>상수 평가는 컴파일 중에 <a href="expressions.html">표현식</a>의 결과를 계산하는 과정입니다. 모든 표현식 중 일부 하위 집합만이 컴파일 타임에 평가될 수 있습니다.</p>
<div class="rule" id="r-const-eval.const-expr"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr" title="const-eval.const-expr"><span>[const-eval<wbr>.const-expr]<span/></a></div>
<h2 id="상수-표현식"><a class="header" href="#상수-표현식">상수 표현식</a></h2>
<div class="rule" id="r-const-eval.const-expr.general"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.general" title="const-eval.const-expr.general"><span>[const-eval<wbr>.const-expr<wbr>.general]<span/></a></div>
<p>상수 표현식이라고 불리는 특정 형태의 표현식들은 컴파일 타임에 평가될 수 있습니다.</p>
<div class="rule" id="r-const-eval.const-expr.const-context"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.const-context" title="const-eval.const-expr.const-context"><span>[const-eval<wbr>.const-expr<wbr>.const-context]<span/></a></div>
<p><a href="const_eval.html#const-context">상수 컨텍스트(const context)</a>에서는 이러한 표현식들만이 허용되며, 항상 컴파일 타임에 평가됩니다.</p>
<div class="rule" id="r-const-eval.const-expr.runtime-context"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.runtime-context" title="const-eval.const-expr.runtime-context"><span>[const-eval<wbr>.const-expr<wbr>.runtime-context]<span/></a></div>
<p><a href="statements.html#let-statements">let 문</a>과 같은 다른 곳에서는, 상수 표현식이 컴파일 타임에 평가될 <em>수도</em> 있지만, 그것이 보장되지는 않습니다.</p>
<div class="rule" id="r-const-eval.const-expr.error"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.error" title="const-eval.const-expr.error"><span>[const-eval<wbr>.const-expr<wbr>.error]<span/></a></div>
<p>범위를 벗어난 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a>이나 <a href="expressions/operator-expr.html#overflow">오버플로</a>와 같은 동작들은, 값이 컴파일 타임에 평가되어야 하는 경우(즉, 상수 컨텍스트인 경우) 컴파일러 오류가 됩니다. 그렇지 않으면 이러한 동작들은 경고로 처리되지만, 런타임에 패닉이 발생할 가능성이 높습니다.</p>
<div class="rule" id="r-const-eval.const-expr.list"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.list" title="const-eval.const-expr.list"><span>[const-eval<wbr>.const-expr<wbr>.list]<span/></a></div>
<p>다음 표현식들은 피연산자 또한 상수 표현식이고 어떠한 <a href="destructors.html"><code>Drop::drop</code></a> 호출도 일으키지 않는 한 상수 표현식입니다.</p>
<div class="rule" id="r-const-eval.const-expr.literal"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.literal" title="const-eval.const-expr.literal"><span>[const-eval<wbr>.const-expr<wbr>.literal]<span/></a></div>
<ul>
<li><a href="expressions/literal-expr.html">리터럴</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.parameter"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.parameter" title="const-eval.const-expr.parameter"><span>[const-eval<wbr>.const-expr<wbr>.parameter]<span/></a></div>
<ul>
<li><a href="items/generics.html">상수 파라미터</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.path-item"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.path-item" title="const-eval.const-expr.path-item"><span>[const-eval<wbr>.const-expr<wbr>.path-item]<span/></a></div>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="items/constant-items.html">상수</a>에 대한 <a href="expressions/path-expr.html">경로</a>. 상수를 재귀적으로 정의하는 것은 허용되지 않습니다.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.path-static"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.path-static" title="const-eval.const-expr.path-static"><span>[const-eval<wbr>.const-expr<wbr>.path-static]<span/></a></div>
<ul>
<li>다음 제약 사항이 있는 <a href="items/static-items.html">정적 변수(statics)</a>에 대한 경로:
<ul>
<li><code>static</code> 아이템에 쓰는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li><code>extern</code> 정적 변수로부터 읽는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li>평가가 <code>static</code> 아이템의 초기화 식 내에서 수행되는 것이 <em>아니라면</em>, 가변 <code>static</code>으로부터 읽는 것은 허용되지 않습니다. 가변 <code>static</code>은 <code>static mut</code> 아이템이거나, 내부 가변성(interior-mutable) 타입을 가진 <code>static</code> 아이템을 의미합니다.</li>
</ul>
</li>
</ul>
<p>이러한 요구 사항들은 상수가 평가될 때만 확인됩니다. 다시 말해, 이러한 접근이 상수 컨텍스트에서 구문상으로 나타나는 것은 실제로 실행되지 않는 한 허용됩니다.</p>
<div class="rule" id="r-const-eval.const-expr.tuple"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.tuple" title="const-eval.const-expr.tuple"><span>[const-eval<wbr>.const-expr<wbr>.tuple]<span/></a></div>
<ul>
<li><a href="expressions/tuple-expr.html">튜플 표현식</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.array"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.array" title="const-eval.const-expr.array"><span>[const-eval<wbr>.const-expr<wbr>.array]<span/></a></div>
<ul>
<li><a href="expressions/array-expr.html">배열 표현식</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.constructor"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.constructor" title="const-eval.const-expr.constructor"><span>[const-eval<wbr>.const-expr<wbr>.constructor]<span/></a></div>
<ul>
<li><a href="expressions/struct-expr.html">구조체</a> 표현식.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.block"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.block" title="const-eval.const-expr.block"><span>[const-eval<wbr>.const-expr<wbr>.block]<span/></a></div>
<ul>
<li><code>unsafe</code> 및 <code>const</code> 블록을 포함한 <a href="expressions/block-expr.html">블록 표현식</a>.
<ul>
<li><a href="statements.html#let-statements">let 문</a> 및 그에 따른 가변 바인딩을 포함한 반박 불가능한(irrefutable) <a href="patterns.html">패턴</a></li>
<li><a href="expressions/operator-expr.html#assignment-expressions">대입 표현식</a></li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 대입 표현식</a></li>
<li><a href="statements.html#expression-statements">표현식 구문</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.field"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.field" title="const-eval.const-expr.field"><span>[const-eval<wbr>.const-expr<wbr>.field]<span/></a></div>
<ul>
<li><a href="expressions/field-expr.html">필드</a> 표현식.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.index"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.index" title="const-eval.const-expr.index"><span>[const-eval<wbr>.const-expr<wbr>.index]<span/></a></div>
<ul>
<li>인덱스 표현식, <code>usize</code>를 사용한 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a> 또는 <a href="types/slice.html">슬라이스</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.range"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.range" title="const-eval.const-expr.range"><span>[const-eval<wbr>.const-expr<wbr>.range]<span/></a></div>
<ul>
<li><a href="expressions/range-expr.html">범위 표현식</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.closure"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.closure" title="const-eval.const-expr.closure"><span>[const-eval<wbr>.const-expr<wbr>.closure]<span/></a></div>
<ul>
<li>환경으로부터 변수를 캡처하지 않는 <a href="expressions/closure-expr.html">클로저 표현식</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.builtin-arith-logic"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.builtin-arith-logic" title="const-eval.const-expr.builtin-arith-logic"><span>[const-eval<wbr>.const-expr<wbr>.builtin-arith-logic]<span/></a></div>
<ul>
<li>정수 및 부동 소수점 타입, <code>bool</code>, <code>char</code>에 사용되는 내장 <a href="expressions/operator-expr.html#negation-operators">부정</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">산술</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">논리</a>, <a href="expressions/operator-expr.html#comparison-operators">비교</a> 또는 <a href="expressions/operator-expr.html#lazy-boolean-operators">지연 평가 불리언(lazy boolean)</a> 연산자.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.borrows"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.borrows" title="const-eval.const-expr.borrows"><span>[const-eval<wbr>.const-expr<wbr>.borrows]<span/></a></div>
<ul>
<li>원시 대여를 포함한 모든 형태의 <a href="expressions/operator-expr.html#borrow-operators">대여(borrow)</a>. 단, 한 가지 제한 사항이 있습니다: 가변 대여 및 내부 가변성을 가진 값에 대한 공유 대여는 오직 <em>일시적인(transient)</em> 장소만을 참조할 수 있습니다. 장소의 수명이 현재의 <a href="const_eval.html#const-context">상수 컨텍스트</a> 내부에 엄격하게 포함되는 경우, 그 장소를 _일시적_이라고 합니다.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.deref"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.deref" title="const-eval.const-expr.deref"><span>[const-eval<wbr>.const-expr<wbr>.deref]<span/></a></div>
<ul>
<li>원시 포인터를 제외한 <a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자</a>.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.group"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.group" title="const-eval.const-expr.group"><span>[const-eval<wbr>.const-expr<wbr>.group]<span/></a></div>
<ul>
<li><a href="expressions/grouped-expr.html">그룹화된(Grouped)</a> 표현식.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.cast"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.cast" title="const-eval.const-expr.cast"><span>[const-eval<wbr>.const-expr<wbr>.cast]<span/></a></div>
<ul>
<li>다음 경우를 제외한 <a href="expressions/operator-expr.html#type-cast-expressions">캐스트</a> 표현식:
<ul>
<li>포인터를 주소로 변환하는 캐스트 및</li>
<li>함수 포인터를 주소로 변환하는 캐스트.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.const-fn"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.const-fn" title="const-eval.const-expr.const-fn"><span>[const-eval<wbr>.const-expr<wbr>.const-fn]<span/></a></div>
<ul>
<li><a href="items/functions.html#const-functions">상수 함수(const functions)</a> 및 상수 메서드 호출.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.loop"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.loop" title="const-eval.const-expr.loop"><span>[const-eval<wbr>.const-expr<wbr>.loop]<span/></a></div>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops">loop</a>, <a href="expressions/loop-expr.html#predicate-loops">while</a> 및 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 표현식.</li>
</ul>
<div class="rule" id="r-const-eval.const-expr.if-match"><a class="rule-link" href="const_eval.html#r-const-eval.const-expr.if-match" title="const-eval.const-expr.if-match"><span>[const-eval<wbr>.const-expr<wbr>.if-match]<span/></a></div>
<ul>
<li><a href="expressions/if-expr.html#if-expressions">if</a>, <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 및 <a href="expressions/match-expr.html">match</a> 표현식.</li>
</ul>
<h2 id="상수-컨텍스트-const-context"><a class="header" href="#상수-컨텍스트-const-context">상수 컨텍스트 (Const context)</a></h2>
<div class="rule" id="r-const-eval.const-context"><a class="rule-link" href="const_eval.html#r-const-eval.const-context" title="const-eval.const-context"><span>[const-eval<wbr>.const-context]<span/></a></div>
<div class="rule" id="r-const-eval.const-context.general"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.general" title="const-eval.const-context.general"><span>[const-eval<wbr>.const-context<wbr>.general]<span/></a></div>
<p>_상수 컨텍스트_는 다음 중 하나를 의미합니다:</p>
<div class="rule" id="r-const-eval.const-context.array-length"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.array-length" title="const-eval.const-context.array-length"><span>[const-eval<wbr>.const-context<wbr>.array-length]<span/></a></div>
<ul>
<li><a href="types/array.html">배열 타입 길이 표현식</a></li>
</ul>
<div class="rule" id="r-const-eval.const-context.repeat-length"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.repeat-length" title="const-eval.const-context.repeat-length"><span>[const-eval<wbr>.const-context<wbr>.repeat-length]<span/></a></div>
<ul>
<li><a href="expressions/array-expr.html">배열 반복 길이 표현식</a></li>
</ul>
<div class="rule" id="r-const-eval.const-context.init"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.init" title="const-eval.const-context.init"><span>[const-eval<wbr>.const-context<wbr>.init]<span/></a></div>
<ul>
<li>다음의 초기화 식:
<ul>
<li><a href="items/constant-items.html">상수(constants)</a></li>
<li><a href="items/static-items.html">정적 변수(statics)</a></li>
<li><a href="items/enumerations.html#discriminants">열거형 판별자(enum discriminants)</a></li>
</ul>
</li>
</ul>
<div class="rule" id="r-const-eval.const-context.generic"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.generic" title="const-eval.const-context.generic"><span>[const-eval<wbr>.const-context<wbr>.generic]<span/></a></div>
<ul>
<li><a href="items/generics.html#const-generics">상수 제네릭 인자(const generic argument)</a></li>
</ul>
<div class="rule" id="r-const-eval.const-context.block"><a class="rule-link" href="const_eval.html#r-const-eval.const-context.block" title="const-eval.const-context.block"><span>[const-eval<wbr>.const-context<wbr>.block]<span/></a></div>
<ul>
<li><a href="expressions/block-expr.html#const-blocks">상수 블록(const block)</a></li>
</ul>
<p>타입의 일부로 사용되는 상수 컨텍스트(배열 타입 및 반복 길이 표현식, 그리고 상수 제네릭 인자)는 주변의 제네릭 파라미터를 제한적으로만 사용할 수 있습니다. 그러한 표현식은 단일의 순수한 상수 제네릭 파라미터이거나, 어떠한 제네릭도 사용하지 않는 임의의 표현식이어야 합니다.</p>
<div class="rule" id="r-const-eval.const-fn"><a class="rule-link" href="const_eval.html#r-const-eval.const-fn" title="const-eval.const-fn"><span>[const-eval<wbr>.const-fn]<span/></a></div>
<h2 id="상수-함수-const-functions"><a class="header" href="#상수-함수-const-functions">상수 함수 (Const Functions)</a></h2>
<div class="rule" id="r-const-eval.const-fn.general"><a class="rule-link" href="const_eval.html#r-const-eval.const-fn.general" title="const-eval.const-fn.general"><span>[const-eval<wbr>.const-fn<wbr>.general]<span/></a></div>
<p>_상수 함수(const fn)_는 상수 컨텍스트에서 호출이 허용되는 함수입니다.</p>
<div class="rule" id="r-const-eval.const-fn.usage"><a class="rule-link" href="const_eval.html#r-const-eval.const-fn.usage" title="const-eval.const-fn.usage"><span>[const-eval<wbr>.const-fn<wbr>.usage]<span/></a></div>
<p>함수를 <code>const</code>로 선언하는 것은 기존의 사용처에는 아무런 영향을 주지 않으며, 단지 인자와 반환 타입이 사용할 수 있는 타입을 제한하고, 함수의 본문을 상수 표현식으로 제한할 뿐입니다.</p>
<div class="rule" id="r-const-eval.const-fn.const-context"><a class="rule-link" href="const_eval.html#r-const-eval.const-fn.const-context" title="const-eval.const-fn.const-context"><span>[const-eval<wbr>.const-fn<wbr>.const-context]<span/></a></div>
<p>상수 컨텍스트에서 호출될 때, 함수는 컴파일 타임에 컴파일러에 의해 해석됩니다. 이 해석은 호스트가 아닌 컴파일 타겟의 환경에서 이루어집니다. 따라서 만약 32비트 시스템을 대상으로 컴파일하고 있다면, 빌드하는 시스템이 64비트인지 32비트인지와 관계없이 <code>usize</code>는 32비트가 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="애플리케이션-바이너리-인터페이스-abi"><a class="header" href="#애플리케이션-바이너리-인터페이스-abi">애플리케이션 바이너리 인터페이스 (ABI)</a></h1>
<p>이 섹션은 크레이트의 컴파일된 출력물의 ABI에 영향을 주는 기능들을 설명합니다.</p>
<p>함수를 내보내기 위해 ABI를 지정하는 방법에 대한 정보는 _<a href="items/functions.html#extern-function-qualifier">외부 함수(extern functions)</a>_를 참조하십시오. 외부 라이브러리를 링크하기 위해 ABI를 지정하는 방법에 대한 정보는 _<a href="items/external-blocks.html">외부 블록(external blocks)</a>_을 참조하십시오.</p>
<h2 id="used-속성"><a class="header" href="#used-속성"><code>used</code> 속성</a></h2>
<p>_<code>used</code> 속성_은 오직 <a href="items/static-items.html"><code>static</code> 아이템</a>에만 적용될 수 있습니다. 이 <a href="attributes.html">속성</a>은 해당 변수가 크레이트의 다른 아이템에 의해 사용되거나 참조되지 않더라도, 출력 목적 파일(.o, .rlib 등, 최종 바이너리 제외)에 변수를 강제로 유지하도록 컴파일러에 명령합니다. 하지만 링커는 여전히 이러한 아이템을 제거할 수 있습니다.</p>
<p>아래는 컴파일러가 어떤 조건 하에서 <code>static</code> 아이템을 출력 목적 파일에 유지하는지 보여주는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo.rs

// 이는 `#[used]` 때문에 유지됩니다:
#[used]
static FOO: u32 = 0;

// 이는 사용되지 않으므로 제거 가능합니다:
#[allow(dead_code)]
static BAR: u32 = 0;

// 이는 공개적으로 도달 가능하므로 유지됩니다:
pub static BAZ: u32 = 0;

// 이는 공개적으로 도달 가능한 함수에 의해 참조되므로 유지됩니다:
static QUUX: u32 = 0;

pub fn quux() -&gt; &amp;'static u32 {
    &amp;QUUX
}

// 이는 비공개이며 사용되지 않는(dead) 함수에 의해 참조되므로 제거 가능합니다:
static CORGE: u32 = 0;

#[allow(dead_code)]
fn corge() -&gt; &amp;'static u32 {
    &amp;CORGE
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-console">$ rustc -O --emit=obj --crate-type=rlib foo.rs

$ nm -C foo.o
0000000000000000 R foo::BAZ
0000000000000000 r foo::FOO
0000000000000000 R foo::QUUX
0000000000000000 T foo::quux
</code></pre>
<h2 id="no_mangle-속성"><a class="header" href="#no_mangle-속성"><code>no_mangle</code> 속성</a></h2>
<p>_<code>no_mangle</code> 속성_은 표준 심볼 이름 맹글링(mangling)을 비활성화하기 위해 모든 <a href="items.html">아이템</a>에 사용될 수 있습니다. 해당 아이템의 심볼은 아이템의 이름과 동일한 식별자가 됩니다.</p>
<p>또한, <a href="abi.html#the-used-attribute"><code>used</code> 속성</a>과 유사하게, 해당 아이템은 생성된 라이브러리나 목적 파일로부터 공개적으로 내보내집니다.</p>
<p>맹글링되지 않은 심볼은 동일한 이름을 가진 다른 심볼(또는 잘 알려진 심볼)과 충돌하여 정의되지 않은 동작을 초래할 수 있으므로, 이 속성은 안전하지 않습니다(unsafe).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
extern "C" fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>unsafe</code> 수식 없이 <code>no_mangle</code> 속성을 사용할 수 있었습니다.</p>
</blockquote>
<h2 id="link_section-속성"><a class="header" href="#link_section-속성"><code>link_section</code> 속성</a></h2>
<p>_<code>link_section</code> 속성_은 <a href="items/functions.html">함수</a> 또는 <a href="items/static-items.html">정적 변수</a>의 내용이 배치될 목적 파일의 섹션을 지정합니다. 섹션 이름을 지정하기 위해 <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용합니다.</p>
<p>이 속성은 가변 데이터를 읽기 전용 영역에 배치하는 것과 같이, 데이터와 코드를 의도하지 않은 메모리 섹션에 배치할 수 있게 하므로 안전하지 않습니다(unsafe).</p>
<!-- no_run: don't link. The format of the section name is platform-specific. -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
#[unsafe(link_section = ".example_section")]
pub static VAR1: u32 = 1;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>unsafe</code> 수식 없이 <code>link_section</code> 속성을 사용할 수 있었습니다.</p>
</blockquote>
<h2 id="export_name-속성"><a class="header" href="#export_name-속성"><code>export_name</code> 속성</a></h2>
<p>_<code>export_name</code> 속성_은 <a href="items/functions.html">함수</a> 또는 <a href="items/static-items.html">정적 변수</a>에서 내보내질 심볼의 이름을 지정합니다. 심볼 이름을 지정하기 위해 <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용합니다.</p>
<p>커스텀 이름을 가진 심볼은 동일한 이름을 가진 다른 심볼(또는 잘 알려진 심볼)과 충돌하여 정의되지 않은 동작을 초래할 수 있으므로, 이 속성은 안전하지 않습니다(unsafe).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(export_name = "exported_symbol_name")]
pub fn name_in_rust() { }
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>unsafe</code> 수식 없이 <code>export_name</code> 속성을 사용할 수 있었습니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-runtime"><a class="rule-link" href="runtime.html#r-runtime" title="runtime"><span>[runtime]<span/></a></div>
<h1 id="러스트-런타임"><a class="header" href="#러스트-런타임">러스트 런타임</a></h1>
<p>이 섹션은 러스트 런타임의 일부 측면을 정의하는 기능들을 설명합니다.</p>
<div class="rule" id="r-runtime.panic_handler"><a class="rule-link" href="runtime.html#r-runtime.panic_handler" title="runtime.panic_handler"><span>[runtime<wbr>.panic_handler]<span/></a></div>
<h2 id="panic_handler-속성"><a class="header" href="#panic_handler-속성"><code>panic_handler</code> 속성</a></h2>
<div class="rule" id="r-runtime.panic_handler.allowed-positions"><a class="rule-link" href="runtime.html#r-runtime.panic_handler.allowed-positions" title="runtime.panic_handler.allowed-positions"><span>[runtime<wbr>.panic_handler<wbr>.allowed-positions]<span/></a></div>
<p>_<code>panic_handler</code> 속성_은 오직 시그니처가 <code>fn(&amp;PanicInfo) -&gt; !</code>인 함수에만 적용될 수 있습니다.</p>
<div class="rule" id="r-runtime.panic_handler.intro"><a class="rule-link" href="runtime.html#r-runtime.panic_handler.intro" title="runtime.panic_handler.intro"><span>[runtime<wbr>.panic_handler<wbr>.intro]<span/></a></div>
<p>이 <a href="attributes.html">속성</a>이 표시된 함수는 패닉(panic) 시의 동작을 정의합니다.</p>
<div class="rule" id="r-runtime.panic_handler.panic-info"><a class="rule-link" href="runtime.html#r-runtime.panic_handler.panic-info" title="runtime.panic_handler.panic-info"><span>[runtime<wbr>.panic_handler<wbr>.panic-info]<span/></a></div>
<p><a href="../core/panic/panic_info/struct.PanicInfo.html"><code>PanicInfo</code></a> 구조체는 패닉이 발생한 위치에 대한 정보를 포함합니다.</p>
<div class="rule" id="r-runtime.panic_handler.unique"><a class="rule-link" href="runtime.html#r-runtime.panic_handler.unique" title="runtime.panic_handler.unique"><span>[runtime<wbr>.panic_handler<wbr>.unique]<span/></a></div>
<p>binary, dylib, 또는 cdylib 크레이트의 의존성 그래프에는 단 하나의 <code>panic_handler</code> 함수가 존재해야 합니다.</p>
<p>아래는 패닉 메시지를 기록한 다음 스레드를 중단시키는 <code>panic_handler</code> 함수의 예시입니다.</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
<span class="boring">   _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl Sink {
</span><span class="boring">    fn new() -&gt; Sink { Sink { _0: () }}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for Sink {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // "panicked at '$reason', src/main.rs:27:4"를 어떤 `sink`에 기록함
    let _ = writeln!(sink, "{}", info);

    loop {}
}</code></pre>
<div class="rule" id="r-runtime.panic_handler.std"><a class="rule-link" href="runtime.html#r-runtime.panic_handler.std" title="runtime.panic_handler.std"><span>[runtime<wbr>.panic_handler<wbr>.std]<span/></a></div>
<h3 id="표준-동작"><a class="header" href="#표준-동작">표준 동작</a></h3>
<p>표준 라이브러리는 기본적으로 스택을 언와인딩(unwinding)하는 <code>panic_handler</code> 구현을 제공하지만, 이를 <a href="../book/ch09-01-unrecoverable-errors-with-panic.html">프로세스를 중단(abort)하도록 변경</a>할 수 있습니다. 표준 라이브러리의 패닉 동작은 런타임에 <a href="../std/panicking/fn.set_hook.html">set_hook</a> 함수를 사용하여 수정될 수 있습니다.</p>
<div class="rule" id="r-runtime.global_allocator"><a class="rule-link" href="runtime.html#r-runtime.global_allocator" title="runtime.global_allocator"><span>[runtime<wbr>.global_allocator]<span/></a></div>
<h2 id="global_allocator-속성"><a class="header" href="#global_allocator-속성"><code>global_allocator</code> 속성</a></h2>
<p>_<code>global_allocator</code> 속성_은 <a href="../core/alloc/global/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> 트레잇을 구현하는 <a href="items/static-items.html">정적 아이템(static item)</a>에 사용되어 전역 할당자(global allocator)를 설정합니다.</p>
<div class="rule" id="r-runtime.windows_subsystem"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem" title="runtime.windows_subsystem"><span>[runtime<wbr>.windows_subsystem]<span/></a></div>
<h2 id="windows_subsystem-속성"><a class="header" href="#windows_subsystem-속성"><code>windows_subsystem</code> 속성</a></h2>
<div class="rule" id="r-runtime.windows_subsystem.intro"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem.intro" title="runtime.windows_subsystem.intro"><span>[runtime<wbr>.windows_subsystem<wbr>.intro]<span/></a></div>
<p>_<code>windows_subsystem</code> 속성_은 윈도우 타겟에서 링크할 때 <a href="https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx">서브시스템(subsystem)</a>을 설정하기 위해 크레이트 레벨에서 적용될 수 있습니다.</p>
<div class="rule" id="r-runtime.windows_subsystem.syntax"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem.syntax" title="runtime.windows_subsystem.syntax"><span>[runtime<wbr>.windows_subsystem<wbr>.syntax]<span/></a></div>
<p>이 속성은 <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용하여 <code>console</code> 또는 <code>windows</code> 중 하나의 값으로 서브시스템을 지정합니다.</p>
<div class="rule" id="r-runtime.windows_subsystem.ignored"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem.ignored" title="runtime.windows_subsystem.ignored"><span>[runtime<wbr>.windows_subsystem<wbr>.ignored]<span/></a></div>
<p>이 속성은 윈도우가 아닌 타겟이나 <code>bin</code>이 아닌 <a href="linkage.html">크레이트 타입</a>에서는 무시됩니다.</p>
<div class="rule" id="r-runtime.windows_subsystem.console"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem.console" title="runtime.windows_subsystem.console"><span>[runtime<wbr>.windows_subsystem<wbr>.console]<span/></a></div>
<p>“console” 서브시스템이 기본값입니다. 만약 콘솔 프로세스가 기존 콘솔에서 실행된다면 해당 콘솔에 부착되고, 그렇지 않으면 새로운 콘솔 창이 생성됩니다.</p>
<div class="rule" id="r-runtime.windows_subsystem.windows"><a class="rule-link" href="runtime.html#r-runtime.windows_subsystem.windows" title="runtime.windows_subsystem.windows"><span>[runtime<wbr>.windows_subsystem<wbr>.windows]<span/></a></div>
<p>“windows” 서브시스템은 시작 시 콘솔 창을 표시하고 싶지 않은 GUI 애플리케이션에서 주로 사용됩니다. 이는 기존의 어떤 콘솔과도 분리되어 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![windows_subsystem = "windows"]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="부록"><a class="header" href="#부록">부록</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div class="rule" id="r-macro.ambiguity"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity" title="macro.ambiguity"><span>[macro<wbr>.ambiguity]<span/></a></div>
<h1 id="부록-매크로-follow-set-모호성-공식-명세"><a class="header" href="#부록-매크로-follow-set-모호성-공식-명세">부록: 매크로 Follow-Set 모호성 공식 명세</a></h1>
<p>이 페이지는 <a href="macros-by-example.html">예제를 통한 매크로</a>를 위한 follow 규칙의 공식 명세를 문서화합니다. 이 규칙들은 원래 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a>에서 명시되었으며, 이 텍스트의 대부분은 해당 RFC에서 복사되고 이후의 RFC들에서 확장된 것입니다.</p>
<div class="rule" id="r-macro.ambiguity.convention"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention" title="macro.ambiguity.convention"><span>[macro<wbr>.ambiguity<wbr>.convention]<span/></a></div>
<h2 id="정의-및-규약"><a class="header" href="#정의-및-규약">정의 및 규약</a></h2>
<div class="rule" id="r-macro.ambiguity.convention.defs"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.defs" title="macro.ambiguity.convention.defs"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.defs]<span/></a></div>
<ul>
<li><code>macro</code>: 소스 코드에서 <code>foo!(...)</code>와 같이 호출 가능한 모든 것.</li>
<li><code>MBE</code>: 예제를 통한 매크로(macro-by-example), <code>macro_rules</code>에 의해 정의된 매크로.</li>
<li><code>matcher</code>: <code>macro_rules</code> 호출 내 규칙의 왼쪽 부분(LHS), 또는 그 일부분.</li>
<li><code>macro parser</code>: 모든 매처(matchers)로부터 파생된 문법을 사용하여 입력을 파싱하는 러스트 파서 내의 코드 조각.</li>
<li><code>fragment</code>: 주어진 매처가 수용할(또는 “일치시킬”) 러스트 구문 클래스.</li>
<li><code>repetition</code>: 규칙적인 반복 패턴을 따르는 프래그먼트.</li>
<li><code>NT</code>: 비단말(non-terminal), 매처에 나타날 수 있는 다양한 “메타 변수” 또는 반복 매처. MBE 구문에서 시작 부분의 <code>$</code> 문자로 지정됩니다.</li>
<li><code>simple NT</code>: “메타 변수” 비단말 (아래에서 더 자세히 논의됨).</li>
<li><code>complex NT</code>: 반복 연산자(<code>*</code>, <code>+</code>, <code>?</code>)를 통해 지정된, 반복 일치 비단말.</li>
<li><code>token</code>: 매처의 원자적 요소. 즉, 식별자, 연산자, 여는/닫는 구분자, <em>그리고</em> 단순 NT(simple NT).</li>
<li><code>token tree</code>: 토큰(리프), 복합 NT(complex NT), 그리고 토큰 트리의 유한 시퀀스로 형성된 트리 구조.</li>
<li><code>delimiter token</code>: 한 프래그먼트의 끝과 다음 프래그먼트의 시작을 나누기 위한 토큰.</li>
<li><code>separator token</code>: 복합 NT에서 일치된 반복의 각 요소 쌍을 구분하는 선택적인 구분자 토큰.</li>
<li><code>separated complex NT</code>: 자체 구분자 토큰을 가진 복합 NT.</li>
<li><code>delimited sequence</code>: 시퀀스의 시작과 끝에 적절한 여는 구분자와 닫는 구분자가 있는 토큰 트리 시퀀스.</li>
<li><code>empty fragment</code>: 토큰을 구분하는 보이지 않는 러스트 구문 클래스. 즉, 공백(whitespace) 또는 (일부 어휘 문맥에서) 빈 토큰 시퀀스.</li>
<li><code>fragment specifier</code>: 단순 NT(simple NT)에서 해당 NT가 수용하는 프래그먼트를 지정하는 식별자.</li>
<li><code>language</code>: 문맥 자유 언어(context-free language).</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.ambiguity.convention.matcher"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.matcher" title="macro.ambiguity.convention.matcher"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.matcher]<span/></a></div>
<p><code>(start $foo:expr $($i:ident),* end)</code>는 매처(matcher)입니다. 전체 매처는 구분된 시퀀스(여는 구분자 <code>(</code>와 닫는 구분자 <code>)</code>가 있는)이며, <code>$foo</code>와 <code>$i</code>는 각각 <code>expr</code>과 <code>ident</code>를 프래그먼트 지정자로 가진 단순 NT입니다.</p>
<div class="rule" id="r-macro.ambiguity.convention.complex-nt"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.complex-nt" title="macro.ambiguity.convention.complex-nt"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.complex-nt]<span/></a></div>
<p><code>$(i:ident),*</code> 또한 하나의 NT입니다. 이는 쉼표로 구분된 식별자들의 반복과 일치하는 복합 NT(complex NT)입니다. <code>,</code>는 이 복합 NT의 구분자 토큰(separator token)입니다. 이는 일치된 프래그먼트의 각 요소 쌍(있는 경우) 사이에 나타납니다.</p>
<p>형태의 프래그먼트 중 <code>hi &lt;expr&gt;;</code>가 최소 한 번 이상 나타나는 것과 일치합니다. 이 복합 NT는 전용 구분자 토큰을 가지고 있지 않음에 유의하십시오.</p>
<p>(러스트의 파서는 구분된 시퀀스가 항상 토큰 트리 구조의 적절한 중첩과 여는/닫는 구분자의 올바른 일치와 함께 발생하도록 보장함에 유의하십시오.)</p>
<div class="rule" id="r-macro.ambiguity.convention.vars"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.vars" title="macro.ambiguity.convention.vars"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.vars]<span/></a></div>
<p>우리는 매처를 나타내기 위해 변수 “M“을, 임의의 개별 토큰을 위해 변수 “t“와 “u“를, 임의의 토큰 트리를 위해 변수 “tt“와 “uu“를 사용하는 경향이 있습니다. (“tt“의 사용은 프래그먼트 지정자로서의 추가적인 역할 때문에 잠재적인 모호성을 제시하지만, 문맥상 어떤 해석을 의미하는지 명확할 것입니다.)</p>
<div class="rule" id="r-macro.ambiguity.convention.set"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.set" title="macro.ambiguity.convention.set"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.set]<span/></a></div>
<p>“SEP“는 구분자 토큰을, “OP“는 반복 연산자 <code>*</code>, <code>+</code>, <code>?</code>를, “OPEN”/“CLOSE“는 구분된 시퀀스를 둘러싼 일치하는 토큰 쌍(예: <code>[</code> 및 <code>]</code>)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.convention.sequence-vars"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.convention.sequence-vars" title="macro.ambiguity.convention.sequence-vars"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.sequence-vars]<span/></a></div>
<p>그리스 문자 “α”, “β”, “γ”, “δ“는 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스를 나타냅니다. (단, 그리스 문자 “ε”(입실론)은 이 설명에서 특별한 역할을 수행하며 토큰 트리 시퀀스를 나타내지 않습니다.)</p>
<ul>
<li>이 그리스 문자 관례는 대개 시퀀스의 존재가 기술적인 세부 사항일 때만 채택됩니다. 특히, 우리가 토큰 트리 시퀀스에 대해 작업하고 있음을 _강조_하고자 할 때는 그리스 문자가 아닌 “tt …“라는 표기법을 사용합니다.</li>
</ul>
<p>매처는 단지 하나의 토큰 트리라는 점에 유의하십시오. 위에서 언급했듯이 “단순 NT“는 메타 변수 NT이며, 따라서 반복이 아닙니다. 예를 들어 <code>$foo:ty</code>는 단순 NT이지만 <code>$($foo:ty)+</code>는 복합 NT입니다.</p>
<p>또한 이 형식화된 체계(formalism)의 문맥에서 “토큰“이라는 용어는 일반적으로 단순 NT를 _포함_함에 유의하십시오.</p>
<p>마지막으로, 독자 여러분은 이 형식화된 체계의 정의에 따라 어떤 단순 NT도 빈 프래그먼트와 일치하지 않으며, 마찬가지로 어떤 토큰도 러스트 구문의 빈 프래그먼트와 일치하지 않는다는 점을 기억하는 것이 유용합니다. (따라서 빈 프래그먼트와 일치할 수 있는 <em>유일한</em> NT는 복합 NT뿐입니다.) 이는 실제로 사실이 아닌데, 왜냐하면 <code>vis</code> 매처는 빈 프래그먼트와 일치할 수 있기 때문입니다. 따라서 이 체계의 목적을 위해 우리는 <code>$v:vis</code>를 실제로는 <code>$($v:vis)?</code>인 것처럼 취급할 것이며, 매처가 빈 프래그먼트와 일치해야 한다는 요구 사항을 둘 것입니다.</p>
<div class="rule" id="r-macro.ambiguity.invariant"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.invariant" title="macro.ambiguity.invariant"><span>[macro<wbr>.ambiguity<wbr>.invariant]<span/></a></div>
<h3 id="매처-불변성-the-matcher-invariants"><a class="header" href="#매처-불변성-the-matcher-invariants">매처 불변성 (The Matcher Invariants)</a></h3>
<div class="rule" id="r-macro.ambiguity.invariant.list"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.invariant.list" title="macro.ambiguity.invariant.list"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.list]<span/></a></div>
<p>유효한 매처가 되려면 다음 세 가지 불변성을 충족해야 합니다. FIRST 및 FOLLOW의 정의는 나중에 설명됩니다.</p>
<ol>
<li>매처 <code>M</code> 내의 임의의 두 연속된 토큰 트리 시퀀스(<code>M = ... tt uu ...</code>)에 대해 <code>uu ...</code>가 비어 있지 않다면, FOLLOW(<code>... tt</code>) ∪ {ε} ⊇ FIRST(<code>uu ...</code>)를 만족해야 합니다.</li>
<li>매처 내의 임의의 구분된 복합 NT <code>M = ... $(tt ...) SEP OP ...</code>에 대해, <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>)여야 합니다.</li>
<li>매처 내의 구분되지 않은 복합 NT <code>M = ... $(tt ...) OP ...</code>에 대해, OP = <code>*</code> 또는 <code>+</code>인 경우, FOLLOW(<code>tt ...</code>) ⊇ FIRST(<code>tt ...</code>)여야 합니다.</li>
</ol>
<div class="rule" id="r-macro.ambiguity.invariant.follow-matcher"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.invariant.follow-matcher" title="macro.ambiguity.invariant.follow-matcher"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.follow-matcher]<span/></a></div>
<p>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set.  This ensures that a legal macro definition will continue to assign the same determination as to where <code>... tt</code> ends and <code>uu ...</code> begins, even as new syntactic forms are added to the language.</p>
<div class="rule" id="r-macro.ambiguity.invariant.separated-complex-nt"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.invariant.separated-complex-nt" title="macro.ambiguity.invariant.separated-complex-nt"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.separated-complex-nt]<span/></a></div>
<p>두 번째 불변성은 구분된 복합 NT가 해당 NT 내부 콘텐츠에 대해 미리 결정된 follow 집합의 일부인 구분자 토큰을 사용해야 함을 의미합니다. 이는 새로운 구문 형태가 언어에 추가되더라도, 적법한 매크로 정의가 입력 프래그먼트를 동일한 <code>tt ...</code>들의 구분된 시퀀스로 계속 파싱하도록 보장합니다.</p>
<div class="rule" id="r-macro.ambiguity.invariant.unseparated-complex-nt"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.invariant.unseparated-complex-nt" title="macro.ambiguity.invariant.unseparated-complex-nt"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.unseparated-complex-nt]<span/></a></div>
<p>세 번째 불변성은 사이에 구분이 없이 동일한 것의 두 개 이상의 사본과 일치할 수 있는 복합 NT가 있을 때, 첫 번째 불변성에 따라 이들이 서로 옆에 놓이는 것이 허용되어야 함을 의미합니다. 이 불변성은 또한 이들이 비어 있지 않을 것을 요구하며, 이는 발생 가능한 모호성을 제거합니다.</p>
<p><strong>참고: 세 번째 불변성은 과거의 실수와 해당 동작에 대한 상당한 의존성 때문에 현재 강제되지 않고 있습니다. 앞으로 이에 대해 어떻게 할지는 현재 결정되지 않았습니다. 이 동작을 준수하지 않는 매크로는 미래의 러스트 에디션에서 유효하지 않게 될 수 있습니다. <a href="https://github.com/rust-lang/rust/issues/56575">트래킹 이슈</a>를 참조하십시오.</strong></p>
<div class="rule" id="r-macro.ambiguity.sets"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets" title="macro.ambiguity.sets"><span>[macro<wbr>.ambiguity<wbr>.sets]<span/></a></div>
<h3 id="비공식적인-first-및-follow"><a class="header" href="#비공식적인-first-및-follow">비공식적인 FIRST 및 FOLLOW</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.intro"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.intro" title="macro.ambiguity.sets.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.intro]<span/></a></div>
<p>주어진 매처 M은 세 가지 집합 FIRST(M), LAST(M), FOLLOW(M)에 매핑됩니다.</p>
<p>이 세 가지 집합은 각각 토큰들로 구성됩니다. FIRST(M)과 LAST(M)은 또한 M이 빈 프래그먼트와 일치할 수 있음을 나타내는 구별된 비토큰 요소 ε(“입실론”)을 포함할 수 있습니다. (단, FOLLOW(M)은 항상 토큰들의 집합입니다.)</p>
<p>비공식적으로는 다음과 같습니다:</p>
<div class="rule" id="r-macro.ambiguity.sets.first"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.first" title="macro.ambiguity.sets.first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.first]<span/></a></div>
<ul>
<li>FIRST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 먼저 사용되는 토큰들을 수집합니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.last"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.last" title="macro.ambiguity.sets.last"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.last]<span/></a></div>
<ul>
<li>LAST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 마지막에 사용되는 토큰들을 수집합니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.follow"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.follow" title="macro.ambiguity.sets.follow"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.follow]<span/></a></div>
<ul>
<li>
<p>FOLLOW(M): M과 일치하는 어떤 프래그먼트 직후에 올 수 있도록 허용된 토큰들의 집합입니다.</p>
<p>다시 말해, t ∈ FOLLOW(M)일 필요충분조건은 다음을 만족하는 (잠재적으로 비어 있을 수 있는) 토큰 시퀀스 α, β, γ, δ가 존재하는 것입니다.</p>
<ul>
<li>
<p>M이 β와 일치하고,</p>
</li>
<li>
<p>t가 γ와 일치하며,</p>
</li>
<li>
<p>α β γ δ를 연결한 결과가 파싱 가능한 러스트 프로그램인 경우.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.universe"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.universe" title="macro.ambiguity.sets.universe"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.universe]<span/></a></div>
<p>우리는 모든 토큰(단순 NT 포함)의 집합을 나타내기 위해 ANYTOKEN이라는 약어를 사용합니다. 예를 들어, 매처 M 뒤에 어떤 토큰이 와도 적법하다면, FOLLOW(M) = ANYTOKEN입니다.</p>
<p>(위의 비공식적인 설명에 대한 이해를 점검하기 위해, 독자 여러분은 공식 정의를 읽기 전에 <a href="macro-ambiguity.html#examples-of-first-and-last">FIRST/LAST의 예시</a>로 건너뛰어 확인해 볼 수 있습니다.)</p>
<div class="rule" id="r-macro.ambiguity.sets.def"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def" title="macro.ambiguity.sets.def"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def]<span/></a></div>
<h3 id="first-last"><a class="header" href="#first-last">FIRST, LAST</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.def.intro"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.intro" title="macro.ambiguity.sets.def.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.intro]<span/></a></div>
<p>다음은 FIRST와 LAST에 대한 공식적인 귀납적 정의입니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.notation"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.notation" title="macro.ambiguity.sets.def.notation"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.notation]<span/></a></div>
<p>“A ∪ B“는 합집합을, “A ∩ B“는 교집합을, “A \ B“는 차집합(즉, A에는 존재하지만 B에는 존재하지 않는 모든 요소)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.first"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first" title="macro.ambiguity.sets.def.first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first]<span/></a></div>
<h4 id="first"><a class="header" href="#first">FIRST</a></h4>
<div class="rule" id="r-macro.ambiguity.sets.def.first.intro"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.intro" title="macro.ambiguity.sets.def.first.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.intro]<span/></a></div>
<p>FIRST(M)은 시퀀스 M과 그 첫 번째 토큰 트리(있는 경우)의 구조에 따른 케이스 분석을 통해 정의됩니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.first.epsilon"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.epsilon" title="macro.ambiguity.sets.def.first.epsilon"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.epsilon]<span/></a></div>
<ul>
<li>M이 빈 시퀀스라면, FIRST(M) = { ε }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.first.token"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.token" title="macro.ambiguity.sets.def.first.token"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.token]<span/></a></div>
<ul>
<li>
<p>M이 토큰 t로 시작한다면, FIRST(M) = { t }입니다.</p>
<p>(참고: 이는 M이 구분된 토큰 트리 시퀀스로 시작하는 경우 <code>M = OPEN tt ... CLOSE ...</code>를 포함하며, 이 경우 <code>t = OPEN</code>이므로 FIRST(M) = { <code>OPEN</code> }이 됩니다.)</p>
<p>(참고: 이는 어떤 단순 NT도 빈 프래그먼트와 일치하지 않는다는 속성에 결정적으로 의존합니다.)</p>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.first.complex"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.complex" title="macro.ambiguity.sets.def.first.complex"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.complex]<span/></a></div>
<ul>
<li>
<p>그 외의 경우, M은 복합 NT로 시작하는 토큰 트리 시퀀스입니다: <code>M = $( tt ... ) OP α</code>, 또는 <code>M = $( tt ... ) SEP OP α</code> (여기서 <code>α</code>는 매처의 나머지 부분인, 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스입니다).</p>
<ul>
<li>SEP가 존재하고 ε ∈ FIRST(<code>tt ...</code>)라면 SEP_SET(M) = { SEP }이고, 그렇지 않으면 SEP_SET(M) = {}라고 합시다.</li>
</ul>
</li>
<li>
<p>OP가 <code>*</code> 또는 <code>?</code>라면 ALPHA_SET(M) = FIRST(<code>α</code>)이고, OP가 <code>+</code>라면 ALPHA_SET(M) = {}라고 합시다.</p>
</li>
<li>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M)입니다.</p>
</li>
</ul>
<p>복합 NT에 대한 정의는 정당화될 필요가 있습니다. SEP_SET(M)은 구분자가 정의되어 있고 반복되는 프래그먼트가 비어 있을 수 있는 경우, 구분자가 M의 유효한 첫 번째 토큰이 될 수 있는 가능성을 정의합니다. ALPHA_SET(M)은 복합 NT가 비어 있을 수 있는 가능성을 정의하며, 이는 M의 유효한 첫 번째 토큰들이 뒤따르는 토큰 트리 시퀀스 <code>α</code>의 토큰들임을 의미합니다. 이는 <code>*</code> 또는 <code>?</code>가 사용되어 반복 횟수가 0일 수 있는 경우에 발생합니다. 이론적으로는 잠재적으로 비어 있을 수 있는 반복 프래그먼트와 함께 <code>+</code>가 사용된 경우에도 발생할 수 있으나, 이는 세 번째 불변성에 의해 금지됩니다.</p>
<p>그 지점으로부터, FIRST(M)은 SEP_SET(M) 또는 ALPHA_SET(M)의 모든 토큰을 포함할 수 있으며, 복합 NT 일치가 비어 있지 않다면 FIRST(<code>tt ...</code>)로 시작하는 모든 토큰 또한 가능합니다. 마지막으로 고려할 부분은 ε입니다. SEP_SET(M)과 FIRST(<code>tt ...</code>) \ {ε}은 ε을 포함할 수 없지만, ALPHA_SET(M)은 포함할 수 있습니다. 따라서 이 정의는 ε ∈ ALPHA_SET(M)인 경우에만 M이 ε을 수용하도록 허용합니다. 이는 복합 NT 사례에서 M이 ε을 수용하려면 복합 NT와 α가 모두 이를 수용해야 하기 때문에 정확합니다. 만약 OP = <code>+</code>라면, 복합 NT가 비어 있을 수 없음을 의미하므로 정의에 따라 ε ∉ ALPHA_SET(M)입니다. 그 외의 경우 복합 NT는 0번의 반복을 수용할 수 있으며, 이때 ALPHA_SET(M) = FOLLOW(<code>α</code>)가 됩니다. 따라서 이 정의는 ε에 대해서도 정확합니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.last"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last" title="macro.ambiguity.sets.def.last"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last]<span/></a></div>
<h4 id="last"><a class="header" href="#last">LAST</a></h4>
<div class="rule" id="r-macro.ambiguity.sets.def.last.intro"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.intro" title="macro.ambiguity.sets.def.last.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.intro]<span/></a></div>
<p>LAST(M)은 M 자체(토큰 트리 시퀀스)에 대한 케이스 분석을 통해 정의됩니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.last.empty"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.empty" title="macro.ambiguity.sets.def.last.empty"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.empty]<span/></a></div>
<ul>
<li>M이 빈 시퀀스라면, LAST(M) = { ε }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.token"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.token" title="macro.ambiguity.sets.def.last.token"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.token]<span/></a></div>
<ul>
<li>M이 단일 토큰 t라면, LAST(M) = { t }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-star"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-star" title="macro.ambiguity.sets.def.last.rep-star"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-star]<span/></a></div>
<ul>
<li>
<p>M이 0번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) *</code> 또는 <code>M = $( tt ... ) SEP *</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-plus"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-plus" title="macro.ambiguity.sets.def.last.rep-plus"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-plus]<span/></a></div>
<ul>
<li>
<p>M이 1번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) +</code> 또는 <code>M = $( tt ... ) SEP +</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-question"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-question" title="macro.ambiguity.sets.def.last.rep-question"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-question]<span/></a></div>
<ul>
<li>M이 0번 또는 1번 반복되는 단일 복합 NT인 경우(<code>M = $( tt ...) ?</code>), LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.delim"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.delim" title="macro.ambiguity.sets.def.last.delim"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.delim]<span/></a></div>
<ul>
<li>M이 구분된 토큰 트리 시퀀스 <code>OPEN tt ... CLOSE</code>인 경우, LAST(M) = { <code>CLOSE</code> }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.sequence"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.sequence" title="macro.ambiguity.sets.def.last.sequence"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.sequence]<span/></a></div>
<ul>
<li>
<p>M이 비어 있지 않은 토큰 트리 시퀀스 <code>tt uu ...</code>인 경우,</p>
<ul>
<li>
<p>ε ∈ LAST(<code>uu ...</code>)라면, LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε })입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>uu ...</code>는 반드시 비어 있지 않아야 하며, LAST(M) = LAST(<code>uu ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="first-및-last의-예시"><a class="header" href="#first-및-last의-예시">FIRST 및 LAST의 예시</a></h3>
<p>다음은 FIRST와 LAST의 몇 가지 예시입니다. (특히 입력 조각들 사이의 상호 작용에 따라 특별한 ε 요소가 어떻게 도입되고 제거되는지 유의하십시오.)</p>
<p>첫 번째 예시는 매처 분석이 어떻게 구성되는지 상세히 설명하기 위해 트리 구조로 제시됩니다. (일부 단순한 서브트리들은 생략되었습니다.)</p>
<pre><code class="language-text">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                        |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                        |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>따라서:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>하지만 다음 사항에 유의하십시오:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>다음은 LAST에 대한 유사한 예시들입니다.</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow" title="macro.ambiguity.sets.def.follow"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow]<span/></a></div>
<h3 id="followm"><a class="header" href="#followm">FOLLOW(M)</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.intro"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.intro" title="macro.ambiguity.sets.def.follow.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.intro]<span/></a></div>
<p>마지막으로, FOLLOW(M)의 정의는 다음과 같이 구성됩니다. pat, expr 등은 주어진 프래그먼트 지정자를 가진 단순 비단말(nonterminals)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.pat"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.pat" title="macro.ambiguity.sets.def.follow.pat"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.pat]<span/></a></div>
<ul>
<li>FOLLOW(pat) = {<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code>}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.expr-stmt"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.expr-stmt" title="macro.ambiguity.sets.def.follow.expr-stmt"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.expr-stmt]<span/></a></div>
<ul>
<li>FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {<code>=&gt;</code>, <code>,</code>, <code>;</code>}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.ty-path"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.ty-path" title="macro.ambiguity.sets.def.follow.ty-path"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.ty-path]<span/></a></div>
<ul>
<li>FOLLOW(ty) = FOLLOW(path) = {<code>{</code>, <code>[</code>, <code>,</code>, <code>=&gt;</code>, <code>:</code>, <code>=</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>;</code>, <code>|</code>, <code>as</code>, <code>where</code>, block 비단말}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.vis"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.vis" title="macro.ambiguity.sets.def.follow.vis"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.vis]<span/></a></div>
<ul>
<li>FOLLOW(vis) = {<code>,</code>l 원시(raw)가 아닌 <code>priv</code>를 제외한 모든 키워드 또는 식별자; 타입을 시작할 수 있는 모든 토큰; ident, ty, 그리고 path 비단말}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.simple"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.simple" title="macro.ambiguity.sets.def.follow.simple"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.simple]<span/></a></div>
<ul>
<li>FOLLOW(t) = ANYTOKEN (block, ident, tt, item, lifetime, literal, meta 단순 비단말 및 모든 단말(terminals)을 포함한 다른 모든 단순 토큰의 경우).</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.other-matcher"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.other-matcher" title="macro.ambiguity.sets.def.follow.other-matcher"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.other-matcher]<span/></a></div>
<ul>
<li>다른 모든 M에 대해 FOLLOW(M)은, t가 (LAST(M) \ {ε})의 범위에 있을 때 FOLLOW(t)의 교집합으로 정의됩니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.type-first"><a class="rule-link" href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.type-first" title="macro.ambiguity.sets.def.follow.type-first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.type-first]<span/></a></div>
<p>타입을 시작할 수 있는 토큰은 이 글을 쓰는 시점을 기준으로 {<code>(</code>, <code>[</code>, <code>!</code>, <code>*</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>?</code>, 라이프타임, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>::</code>, 키워드가 아닌 모든 식별자, <code>super</code>, <code>self</code>, <code>Self</code>, <code>extern</code>, <code>crate</code>, <code>$crate</code>, <code>_</code>, <code>for</code>, <code>impl</code>, <code>fn</code>, <code>unsafe</code>, <code>typeof</code>, <code>dyn</code>}입니다. 새로운 토큰이 추가될 때 부록을 업데이트하는 것을 잊을 수 있으므로 이 목록이 완전하지 않을 수 있습니다.</p>
<p>복합 M에 대한 FOLLOW의 예시:</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3 id="유효하거나-유효하지-않은-매처의-예시"><a class="header" href="#유효하거나-유효하지-않은-매처의-예시">유효하거나 유효하지 않은 매처의 예시</a></h3>
<p>위의 명세를 바탕으로, 특정 매처가 왜 적법하고 다른 것들은 그렇지 않은지에 대한 논거를 제시할 수 있습니다.</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : 부적법. FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> : 적법. FIRST(<code>, foo &lt;</code>) = { <code>,</code> } ⊆ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : 부적법. FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>)이고, 또한 FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : 적법. FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN이고, FIRST(<code>;</code>) = { <code>;</code> } 또한 ⊆ ANYTOKEN이기 때문입니다.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : 적법. (단, 실제로 이 매크로를 사용하려고 시도하면 확장 과정에서 지역적 모호성 오류가 발생합니다.)</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : 부적법. FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> }가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code> : 부적법. 구분자 <code>-</code>가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($e:expr)*)</code> : 부적법. expr NT들이 FOLLOW(expr NT)에 없기 때문입니다.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="영향"><a class="header" href="#영향">영향</a></h1>
<p>러스트는 특별히 독창적인 언어는 아니며, 광범위한 소스에서 유래한 설계 요소들을 가지고 있습니다. 그중 일부는 다음과 같습니다(이후에 제거된 요소 포함):</p>
<ul>
<li>SML, OCaml: 대수적 데이터 타입, 패턴 매칭, 타입 추론, 세미콜론을 이용한 구문 분리</li>
<li>C++: 참조, RAII, 스마트 포인터, 이동 세만틱, 단일화(monomorphization), 메모리 모델</li>
<li>ML Kit, Cyclone: 리전(region) 기반 메모리 관리</li>
<li>Haskell (GHC): 타입 클래스, 타입 패밀리</li>
<li>Newsqueak, Alef, Limbo: 채널, 동시성</li>
<li>Erlang: 메시지 패싱, 스레드 실패, <strike>연결된 스레드 실패</strike>, <strike>경량 동시성</strike></li>
<li>Swift: 옵셔널 바인딩</li>
<li>Scheme: 위생적(hygienic) 매크로</li>
<li>C#: 속성 (attributes)</li>
<li>Ruby: 클로저 구문, <strike>블록 구문</strike></li>
<li>NIL, Hermes: <strike>타입 상태 (typestate)</strike></li>
<li><a href="http://www.unicode.org/reports/tr31/">Unicode Annex #31</a>: 식별자 및 패턴 구문</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="테스트-요약"><a class="header" href="#테스트-요약">테스트 요약</a></h1>
<p>다음은 레퍼런스 내의 개별 규칙 식별자에 연결된 총 테스트 요약입니다.</p>
<table>
<tr>
  <th></th>
  <th>Rules</th>
  <th>Tests</th>
  <th>Uncovered Rules</th>
  <th>Coverage</th>
</tr>
<tr>
<td><a href="introduction.html"> Introduction</a></td>
<td>1</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(0);">1</a>
<div id="uncovered-0" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="introduction.html#r-example.rule.label">example.rule.label</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="notation.html">1. Notation</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="lexical-structure.html">2. Lexical structure</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="input-format.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1. Input format</a></td>
<td>11</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(3);">11</a>
<div id="uncovered-3" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="input-format.html#r-input">input</a></li>
<li><a href="input-format.html#r-input.byte-order-mark">input.byte-order-mark</a></li>
<li><a href="input-format.html#r-input.crlf">input.crlf</a></li>
<li><a href="input-format.html#r-input.encoding">input.encoding</a></li>
<li><a href="input-format.html#r-input.encoding.invalid">input.encoding.invalid</a></li>
<li><a href="input-format.html#r-input.encoding.utf8">input.encoding.utf8</a></li>
<li><a href="input-format.html#r-input.intro">input.intro</a></li>
<li><a href="input-format.html#r-input.shebang">input.shebang</a></li>
<li><a href="input-format.html#r-input.shebang.inner-attribute">input.shebang.inner-attribute</a></li>
<li><a href="input-format.html#r-input.shebang.intro">input.shebang.intro</a></li>
<li><a href="input-format.html#r-input.tokenization">input.tokenization</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="keywords.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2. Keywords</a></td>
<td>17</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(4);">17</a>
<div id="uncovered-4" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="keywords.html#r-lex.keywords">lex.keywords</a></li>
<li><a href="keywords.html#r-lex.keywords.reserved">lex.keywords.reserved</a></li>
<li><a href="keywords.html#r-lex.keywords.reserved.edition2018">lex.keywords.reserved.edition2018</a></li>
<li><a href="keywords.html#r-lex.keywords.reserved.intro">lex.keywords.reserved.intro</a></li>
<li><a href="keywords.html#r-lex.keywords.reserved.list">lex.keywords.reserved.list</a></li>
<li><a href="keywords.html#r-lex.keywords.strict">lex.keywords.strict</a></li>
<li><a href="keywords.html#r-lex.keywords.strict.edition2018">lex.keywords.strict.edition2018</a></li>
<li><a href="keywords.html#r-lex.keywords.strict.intro">lex.keywords.strict.intro</a></li>
<li><a href="keywords.html#r-lex.keywords.strict.list">lex.keywords.strict.list</a></li>
<li><a href="keywords.html#r-lex.keywords.weak">lex.keywords.weak</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.dyn">lex.keywords.weak.dyn</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.intro">lex.keywords.weak.intro</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.lifetime-static">lex.keywords.weak.lifetime-static</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.macro_rules">lex.keywords.weak.macro_rules</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.raw">lex.keywords.weak.raw</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.safe">lex.keywords.weak.safe</a></li>
<li><a href="keywords.html#r-lex.keywords.weak.union">lex.keywords.weak.union</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="identifiers.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3. Identifiers</a></td>
<td>12</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(5);">12</a>
<div id="uncovered-5" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="identifiers.html#r-ident">ident</a></li>
<li><a href="identifiers.html#r-ident.ascii-limitations">ident.ascii-limitations</a></li>
<li><a href="identifiers.html#r-ident.keyword">ident.keyword</a></li>
<li><a href="identifiers.html#r-ident.normalization">ident.normalization</a></li>
<li><a href="identifiers.html#r-ident.profile">ident.profile</a></li>
<li><a href="identifiers.html#r-ident.raw">ident.raw</a></li>
<li><a href="identifiers.html#r-ident.raw.allowed">ident.raw.allowed</a></li>
<li><a href="identifiers.html#r-ident.raw.intro">ident.raw.intro</a></li>
<li><a href="identifiers.html#r-ident.raw.reserved">ident.raw.reserved</a></li>
<li><a href="identifiers.html#r-ident.syntax">ident.syntax</a></li>
<li><a href="identifiers.html#r-ident.unicode">ident.unicode</a></li>
<li><a href="identifiers.html#r-ident.zero-width-chars">ident.zero-width-chars</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="comments.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4. Comments</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(6);">9</a>
<div id="uncovered-6" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="comments.html#r-comments.doc">comments.doc</a></li>
<li><a href="comments.html#r-comments.doc.attributes">comments.doc.attributes</a></li>
<li><a href="comments.html#r-comments.doc.bare-crs">comments.doc.bare-crs</a></li>
<li><a href="comments.html#r-comments.doc.inner-attributes">comments.doc.inner-attributes</a></li>
<li><a href="comments.html#r-comments.doc.inner-syntax">comments.doc.inner-syntax</a></li>
<li><a href="comments.html#r-comments.doc.syntax">comments.doc.syntax</a></li>
<li><a href="comments.html#r-comments.normal">comments.normal</a></li>
<li><a href="comments.html#r-comments.normal.tokenization">comments.normal.tokenization</a></li>
<li><a href="comments.html#r-comments.syntax">comments.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="whitespace.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5. Whitespace</a></td>
<td>4</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(7);">4</a>
<div id="uncovered-7" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="whitespace.html#r-lex.whitespace">lex.whitespace</a></li>
<li><a href="whitespace.html#r-lex.whitespace.intro">lex.whitespace.intro</a></li>
<li><a href="whitespace.html#r-lex.whitespace.replacement">lex.whitespace.replacement</a></li>
<li><a href="whitespace.html#r-lex.whitespace.token-sep">lex.whitespace.token-sep</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="tokens.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6. Tokens</a></td>
<td>110</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(8);">110</a>
<div id="uncovered-8" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="tokens.html#r-lex.token">lex.token</a></li>
<li><a href="tokens.html#r-lex.token.byte">lex.token.byte</a></li>
<li><a href="tokens.html#r-lex.token.byte.intro">lex.token.byte.intro</a></li>
<li><a href="tokens.html#r-lex.token.byte.syntax">lex.token.byte.syntax</a></li>
<li><a href="tokens.html#r-lex.token.delim">lex.token.delim</a></li>
<li><a href="tokens.html#r-lex.token.intro">lex.token.intro</a></li>
<li><a href="tokens.html#r-lex.token.life">lex.token.life</a></li>
<li><a href="tokens.html#r-lex.token.life.intro">lex.token.life.intro</a></li>
<li><a href="tokens.html#r-lex.token.life.raw.allowed">lex.token.life.raw.allowed</a></li>
<li><a href="tokens.html#r-lex.token.life.raw.edition2021">lex.token.life.raw.edition2021</a></li>
<li><a href="tokens.html#r-lex.token.life.raw.intro">lex.token.life.raw.intro</a></li>
<li><a href="tokens.html#r-lex.token.life.raw.reserved">lex.token.life.raw.reserved</a></li>
<li><a href="tokens.html#r-lex.token.life.syntax">lex.token.life.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal">lex.token.literal</a></li>
<li><a href="tokens.html#r-lex.token.literal.char">lex.token.literal.char</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape">lex.token.literal.char-escape</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.ascii">lex.token.literal.char-escape.ascii</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.intro">lex.token.literal.char-escape.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.null">lex.token.literal.char-escape.null</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.slash">lex.token.literal.char-escape.slash</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.unicode">lex.token.literal.char-escape.unicode</a></li>
<li><a href="tokens.html#r-lex.token.literal.char-escape.whitespace">lex.token.literal.char-escape.whitespace</a></li>
<li><a href="tokens.html#r-lex.token.literal.char.intro">lex.token.literal.char.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.char.syntax">lex.token.literal.char.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.float">lex.token.literal.float</a></li>
<li><a href="tokens.html#r-lex.token.literal.float.form">lex.token.literal.float.form</a></li>
<li><a href="tokens.html#r-lex.token.literal.float.suffix">lex.token.literal.float.suffix</a></li>
<li><a href="tokens.html#r-lex.token.literal.float.syntax">lex.token.literal.float.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.int">lex.token.literal.int</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.kind">lex.token.literal.int.kind</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.kind-bin">lex.token.literal.int.kind-bin</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.kind-dec">lex.token.literal.int.kind-dec</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.kind-hex">lex.token.literal.int.kind-hex</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.kind-oct">lex.token.literal.int.kind-oct</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.restriction">lex.token.literal.int.restriction</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.syntax">lex.token.literal.int.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.tuple-field">lex.token.literal.int.tuple-field</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.tuple-field.eq">lex.token.literal.int.tuple-field.eq</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.tuple-field.intro">lex.token.literal.int.tuple-field.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.int.tuple-field.syntax">lex.token.literal.int.tuple-field.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.literal.suffix.intro">lex.token.literal.literal.suffix.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.num">lex.token.literal.num</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved">lex.token.literal.reserved</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.empty-exp">lex.token.literal.reserved.empty-exp</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.empty-with-radix">lex.token.literal.reserved.empty-with-radix</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.exp">lex.token.literal.reserved.exp</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.intro">lex.token.literal.reserved.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.out-of-range">lex.token.literal.reserved.out-of-range</a></li>
<li><a href="tokens.html#r-lex.token.literal.reserved.period">lex.token.literal.reserved.period</a></li>
<li><a href="tokens.html#r-lex.token.literal.str">lex.token.literal.str</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-byte-raw.content">lex.token.literal.str-byte-raw.content</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-raw">lex.token.literal.str-raw</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-raw.body">lex.token.literal.str-raw.body</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-raw.content">lex.token.literal.str-raw.content</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-raw.intro">lex.token.literal.str-raw.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.str-raw.syntax">lex.token.literal.str-raw.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.str.intro">lex.token.literal.str.intro</a></li>
<li><a href="tokens.html#r-lex.token.literal.str.linefeed">lex.token.literal.str.linefeed</a></li>
<li><a href="tokens.html#r-lex.token.literal.str.syntax">lex.token.literal.str.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.suffix">lex.token.literal.suffix</a></li>
<li><a href="tokens.html#r-lex.token.literal.suffix.parse">lex.token.literal.suffix.parse</a></li>
<li><a href="tokens.html#r-lex.token.literal.suffix.syntax">lex.token.literal.suffix.syntax</a></li>
<li><a href="tokens.html#r-lex.token.literal.suffix.validity">lex.token.literal.suffix.validity</a></li>
<li><a href="tokens.html#r-lex.token.punct">lex.token.punct</a></li>
<li><a href="tokens.html#r-lex.token.punct.intro">lex.token.punct.intro</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards">lex.token.reserved-guards</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards.edition2024">lex.token.reserved-guards.edition2024</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards.intro">lex.token.reserved-guards.intro</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards.pounds">lex.token.reserved-guards.pounds</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards.string-literal">lex.token.reserved-guards.string-literal</a></li>
<li><a href="tokens.html#r-lex.token.reserved-guards.syntax">lex.token.reserved-guards.syntax</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix">lex.token.reserved-prefix</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.edition2021">lex.token.reserved-prefix.edition2021</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.id">lex.token.reserved-prefix.id</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.intro">lex.token.reserved-prefix.intro</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.life">lex.token.reserved-prefix.life</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.raw-token">lex.token.reserved-prefix.raw-token</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.strings">lex.token.reserved-prefix.strings</a></li>
<li><a href="tokens.html#r-lex.token.reserved-prefix.syntax">lex.token.reserved-prefix.syntax</a></li>
<li><a href="tokens.html#r-lex.token.str-byte">lex.token.str-byte</a></li>
<li><a href="tokens.html#r-lex.token.str-byte-raw">lex.token.str-byte-raw</a></li>
<li><a href="tokens.html#r-lex.token.str-byte-raw.body">lex.token.str-byte-raw.body</a></li>
<li><a href="tokens.html#r-lex.token.str-byte-raw.intro">lex.token.str-byte-raw.intro</a></li>
<li><a href="tokens.html#r-lex.token.str-byte-raw.syntax">lex.token.str-byte-raw.syntax</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.escape">lex.token.str-byte.escape</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.escape-byte">lex.token.str-byte.escape-byte</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.escape-null">lex.token.str-byte.escape-null</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.escape-slash">lex.token.str-byte.escape-slash</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.escape-whitespace">lex.token.str-byte.escape-whitespace</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.intro">lex.token.str-byte.intro</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.linefeed">lex.token.str-byte.linefeed</a></li>
<li><a href="tokens.html#r-lex.token.str-byte.syntax">lex.token.str-byte.syntax</a></li>
<li><a href="tokens.html#r-lex.token.str-c">lex.token.str-c</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw">lex.token.str-c-raw</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw.body">lex.token.str-c-raw.body</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw.content">lex.token.str-c-raw.content</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw.edition2021">lex.token.str-c-raw.edition2021</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw.intro">lex.token.str-c-raw.intro</a></li>
<li><a href="tokens.html#r-lex.token.str-c-raw.syntax">lex.token.str-c-raw.syntax</a></li>
<li><a href="tokens.html#r-lex.token.str-c.char-unicode">lex.token.str-c.char-unicode</a></li>
<li><a href="tokens.html#r-lex.token.str-c.edition2021">lex.token.str-c.edition2021</a></li>
<li><a href="tokens.html#r-lex.token.str-c.escape">lex.token.str-c.escape</a></li>
<li><a href="tokens.html#r-lex.token.str-c.escape-byte">lex.token.str-c.escape-byte</a></li>
<li><a href="tokens.html#r-lex.token.str-c.escape-slash">lex.token.str-c.escape-slash</a></li>
<li><a href="tokens.html#r-lex.token.str-c.escape-unicode">lex.token.str-c.escape-unicode</a></li>
<li><a href="tokens.html#r-lex.token.str-c.escape-whitespace">lex.token.str-c.escape-whitespace</a></li>
<li><a href="tokens.html#r-lex.token.str-c.intro">lex.token.str-c.intro</a></li>
<li><a href="tokens.html#r-lex.token.str-c.linefeed">lex.token.str-c.linefeed</a></li>
<li><a href="tokens.html#r-lex.token.str-c.null">lex.token.str-c.null</a></li>
<li><a href="tokens.html#r-lex.token.str-c.syntax">lex.token.str-c.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="macros.html">3. Macros</a></td>
<td>12</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(9);">12</a>
<div id="uncovered-9" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="macros.html#r-macro">macro</a></li>
<li><a href="macros.html#r-macro.intro">macro.intro</a></li>
<li><a href="macros.html#r-macro.invocation">macro.invocation</a></li>
<li><a href="macros.html#r-macro.invocation.expr">macro.invocation.expr</a></li>
<li><a href="macros.html#r-macro.invocation.extern">macro.invocation.extern</a></li>
<li><a href="macros.html#r-macro.invocation.intro">macro.invocation.intro</a></li>
<li><a href="macros.html#r-macro.invocation.item">macro.invocation.item</a></li>
<li><a href="macros.html#r-macro.invocation.item-statement">macro.invocation.item-statement</a></li>
<li><a href="macros.html#r-macro.invocation.nested">macro.invocation.nested</a></li>
<li><a href="macros.html#r-macro.invocation.pattern">macro.invocation.pattern</a></li>
<li><a href="macros.html#r-macro.invocation.syntax">macro.invocation.syntax</a></li>
<li><a href="macros.html#r-macro.invocation.type">macro.invocation.type</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="macros-by-example.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1. Macros By Example</a></td>
<td>50</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(10);">50</a>
<div id="uncovered-10" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="macros-by-example.html#r-macro.decl">macro.decl</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set">macro.decl.follow-set</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.edition2021">macro.decl.follow-set.edition2021</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.intro">macro.decl.follow-set.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.repetition">macro.decl.follow-set.repetition</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-expr-stmt">macro.decl.follow-set.token-expr-stmt</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-other">macro.decl.follow-set.token-other</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-pat">macro.decl.follow-set.token-pat</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-pat_param">macro.decl.follow-set.token-pat_param</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-path-ty">macro.decl.follow-set.token-path-ty</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-restriction">macro.decl.follow-set.token-restriction</a></li>
<li><a href="macros-by-example.html#r-macro.decl.follow-set.token-vis">macro.decl.follow-set.token-vis</a></li>
<li><a href="macros-by-example.html#r-macro.decl.hygiene">macro.decl.hygiene</a></li>
<li><a href="macros-by-example.html#r-macro.decl.hygiene.crate">macro.decl.hygiene.crate</a></li>
<li><a href="macros-by-example.html#r-macro.decl.hygiene.intro">macro.decl.hygiene.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.hygiene.local_inner_macros">macro.decl.hygiene.local_inner_macros</a></li>
<li><a href="macros-by-example.html#r-macro.decl.hygiene.vis">macro.decl.hygiene.vis</a></li>
<li><a href="macros-by-example.html#r-macro.decl.intro">macro.decl.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta">macro.decl.meta</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.dollar-crate">macro.decl.meta.dollar-crate</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.edition2021">macro.decl.meta.edition2021</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.edition2024">macro.decl.meta.edition2024</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.intro">macro.decl.meta.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.specifier">macro.decl.meta.specifier</a></li>
<li><a href="macros-by-example.html#r-macro.decl.meta.transcription">macro.decl.meta.transcription</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition">macro.decl.repetition</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition.fragment">macro.decl.repetition.fragment</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition.intro">macro.decl.repetition.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition.operators">macro.decl.repetition.operators</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition.optional-restriction">macro.decl.repetition.optional-restriction</a></li>
<li><a href="macros-by-example.html#r-macro.decl.repetition.separator">macro.decl.repetition.separator</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope">macro.decl.scope</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.intro">macro.decl.scope.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.macro_use">macro.decl.scope.macro_use</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.macro_use.export">macro.decl.scope.macro_use.export</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.macro_use.mod-decl">macro.decl.scope.macro_use.mod-decl</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.macro_use.prelude">macro.decl.scope.macro_use.prelude</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.path">macro.decl.scope.path</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.path.export">macro.decl.scope.path.export</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.path.intro">macro.decl.scope.path.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.textual">macro.decl.scope.textual</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.textual.intro">macro.decl.scope.textual.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.textual.shadow">macro.decl.scope.textual.shadow</a></li>
<li><a href="macros-by-example.html#r-macro.decl.scope.unqualified">macro.decl.scope.unqualified</a></li>
<li><a href="macros-by-example.html#r-macro.decl.syntax">macro.decl.syntax</a></li>
<li><a href="macros-by-example.html#r-macro.decl.transcription">macro.decl.transcription</a></li>
<li><a href="macros-by-example.html#r-macro.decl.transcription.fragment">macro.decl.transcription.fragment</a></li>
<li><a href="macros-by-example.html#r-macro.decl.transcription.intro">macro.decl.transcription.intro</a></li>
<li><a href="macros-by-example.html#r-macro.decl.transcription.lookahead">macro.decl.transcription.lookahead</a></li>
<li><a href="macros-by-example.html#r-macro.decl.transcription.syntax">macro.decl.transcription.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="procedural-macros.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2. Procedural Macros</a></td>
<td>35</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(11);">35</a>
<div id="uncovered-11" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="procedural-macros.html#r-macro.proc">macro.proc</a></li>
<li><a href="procedural-macros.html#r-macro.proc.attribute">macro.proc.attribute</a></li>
<li><a href="procedural-macros.html#r-macro.proc.attribute.def">macro.proc.attribute.def</a></li>
<li><a href="procedural-macros.html#r-macro.proc.attribute.intro">macro.proc.attribute.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.attribute.namespace">macro.proc.attribute.namespace</a></li>
<li><a href="procedural-macros.html#r-macro.proc.def">macro.proc.def</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive">macro.proc.derive</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.attributes">macro.proc.derive.attributes</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.attributes.def">macro.proc.derive.attributes.def</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.attributes.intro">macro.proc.derive.attributes.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.def">macro.proc.derive.def</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.intro">macro.proc.derive.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.namespace">macro.proc.derive.namespace</a></li>
<li><a href="procedural-macros.html#r-macro.proc.derive.output">macro.proc.derive.output</a></li>
<li><a href="procedural-macros.html#r-macro.proc.error">macro.proc.error</a></li>
<li><a href="procedural-macros.html#r-macro.proc.function">macro.proc.function</a></li>
<li><a href="procedural-macros.html#r-macro.proc.function.def">macro.proc.function.def</a></li>
<li><a href="procedural-macros.html#r-macro.proc.function.intro">macro.proc.function.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.function.invocation">macro.proc.function.invocation</a></li>
<li><a href="procedural-macros.html#r-macro.proc.function.namespace">macro.proc.function.namespace</a></li>
<li><a href="procedural-macros.html#r-macro.proc.hygiene">macro.proc.hygiene</a></li>
<li><a href="procedural-macros.html#r-macro.proc.intro">macro.proc.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.proc_macro">macro.proc.proc_macro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.proc_macro.intro">macro.proc.proc_macro.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.proc_macro.span">macro.proc.proc_macro.span</a></li>
<li><a href="procedural-macros.html#r-macro.proc.proc_macro.token-stream">macro.proc.proc_macro.token-stream</a></li>
<li><a href="procedural-macros.html#r-macro.proc.result">macro.proc.result</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token">macro.proc.token</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.conversion.from-proc_macro">macro.proc.token.conversion.from-proc_macro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.conversion.intro">macro.proc.token.conversion.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.conversion.to-proc_macro">macro.proc.token.conversion.to-proc_macro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.doc-comment">macro.proc.token.doc-comment</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.intro">macro.proc.token.intro</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.macro_rules">macro.proc.token.macro_rules</a></li>
<li><a href="procedural-macros.html#r-macro.proc.token.tree">macro.proc.token.tree</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="crates-and-source-files.html">4. Crates and source files</a></td>
<td>18</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(12);">18</a>
<div id="uncovered-12" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="crates-and-source-files.html#r-crate">crate</a></li>
<li><a href="crates-and-source-files.html#r-crate.attributes">crate.attributes</a></li>
<li><a href="crates-and-source-files.html#r-crate.compile-time">crate.compile-time</a></li>
<li><a href="crates-and-source-files.html#r-crate.crate_name">crate.crate_name</a></li>
<li><a href="crates-and-source-files.html#r-crate.crate_name.general">crate.crate_name.general</a></li>
<li><a href="crates-and-source-files.html#r-crate.crate_name.restriction">crate.crate_name.restriction</a></li>
<li><a href="crates-and-source-files.html#r-crate.inline-module">crate.inline-module</a></li>
<li><a href="crates-and-source-files.html#r-crate.input-source">crate.input-source</a></li>
<li><a href="crates-and-source-files.html#r-crate.items">crate.items</a></li>
<li><a href="crates-and-source-files.html#r-crate.main">crate.main</a></li>
<li><a href="crates-and-source-files.html#r-crate.main.general">crate.main.general</a></li>
<li><a href="crates-and-source-files.html#r-crate.main.import">crate.main.import</a></li>
<li><a href="crates-and-source-files.html#r-crate.main.restriction">crate.main.restriction</a></li>
<li><a href="crates-and-source-files.html#r-crate.module">crate.module</a></li>
<li><a href="crates-and-source-files.html#r-crate.module-def">crate.module-def</a></li>
<li><a href="crates-and-source-files.html#r-crate.no_main">crate.no_main</a></li>
<li><a href="crates-and-source-files.html#r-crate.syntax">crate.syntax</a></li>
<li><a href="crates-and-source-files.html#r-crate.unit">crate.unit</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="conditional-compilation.html">5. Conditional compilation</a></td>
<td>72</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(13);">72</a>
<div id="uncovered-13" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="conditional-compilation.html#r-cfg">cfg</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr">cfg.attr</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.crate-level-attrs">cfg.attr.crate-level-attrs</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.effect">cfg.attr.effect</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.general">cfg.attr.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.restriction">cfg.attr.restriction</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.syntax">cfg.attr.syntax</a></li>
<li><a href="conditional-compilation.html#r-cfg.attr.syntax-explanation">cfg.attr.syntax-explanation</a></li>
<li><a href="conditional-compilation.html#r-cfg.attributes-macro">cfg.attributes-macro</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr">cfg.cfg_attr</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr.attribute-list">cfg.cfg_attr.attribute-list</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr.behaviour">cfg.cfg_attr.behaviour</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr.general">cfg.cfg_attr.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr.restriction">cfg.cfg_attr.restriction</a></li>
<li><a href="conditional-compilation.html#r-cfg.cfg_attr.syntax">cfg.cfg_attr.syntax</a></li>
<li><a href="conditional-compilation.html#r-cfg.conditional">cfg.conditional</a></li>
<li><a href="conditional-compilation.html#r-cfg.debug_assertions">cfg.debug_assertions</a></li>
<li><a href="conditional-compilation.html#r-cfg.general">cfg.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.macro">cfg.macro</a></li>
<li><a href="conditional-compilation.html#r-cfg.option-key-uniqueness">cfg.option-key-uniqueness</a></li>
<li><a href="conditional-compilation.html#r-cfg.option-key-value">cfg.option-key-value</a></li>
<li><a href="conditional-compilation.html#r-cfg.option-name">cfg.option-name</a></li>
<li><a href="conditional-compilation.html#r-cfg.option-spec">cfg.option-spec</a></li>
<li><a href="conditional-compilation.html#r-cfg.options.crate">cfg.options.crate</a></li>
<li><a href="conditional-compilation.html#r-cfg.options.general">cfg.options.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.options.other">cfg.options.other</a></li>
<li><a href="conditional-compilation.html#r-cfg.options.set">cfg.options.set</a></li>
<li><a href="conditional-compilation.html#r-cfg.options.target">cfg.options.target</a></li>
<li><a href="conditional-compilation.html#r-cfg.panic">cfg.panic</a></li>
<li><a href="conditional-compilation.html#r-cfg.panic.general">cfg.panic.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.panic.values">cfg.panic.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.predicate">cfg.predicate</a></li>
<li><a href="conditional-compilation.html#r-cfg.predicate.all">cfg.predicate.all</a></li>
<li><a href="conditional-compilation.html#r-cfg.predicate.any">cfg.predicate.any</a></li>
<li><a href="conditional-compilation.html#r-cfg.predicate.not">cfg.predicate.not</a></li>
<li><a href="conditional-compilation.html#r-cfg.predicate.option">cfg.predicate.option</a></li>
<li><a href="conditional-compilation.html#r-cfg.proc_macro">cfg.proc_macro</a></li>
<li><a href="conditional-compilation.html#r-cfg.syntax">cfg.syntax</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_abi">cfg.target_abi</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_abi.disambiguation">cfg.target_abi.disambiguation</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_abi.general">cfg.target_abi.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_abi.values">cfg.target_abi.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_arch">cfg.target_arch</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_arch.gen">cfg.target_arch.gen</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_arch.values">cfg.target_arch.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_endian">cfg.target_endian</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_env">cfg.target_env</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_env.general">cfg.target_env.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_env.values">cfg.target_env.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_family">cfg.target_family</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_family.general">cfg.target_family.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_family.unix">cfg.target_family.unix</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_family.values">cfg.target_family.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_family.windows">cfg.target_family.windows</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_feature">cfg.target_feature</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_feature.crt_static">cfg.target_feature.crt_static</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_feature.general">cfg.target_feature.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_feature.values">cfg.target_feature.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_has_atomic">cfg.target_has_atomic</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_has_atomic.general">cfg.target_has_atomic.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_has_atomic.stdlib">cfg.target_has_atomic.stdlib</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_has_atomic.values">cfg.target_has_atomic.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_os">cfg.target_os</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_os.general">cfg.target_os.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_os.values">cfg.target_os.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_pointer_width">cfg.target_pointer_width</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_pointer_width.general">cfg.target_pointer_width.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_pointer_width.values">cfg.target_pointer_width.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_vendor">cfg.target_vendor</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_vendor.general">cfg.target_vendor.general</a></li>
<li><a href="conditional-compilation.html#r-cfg.target_vendor.values">cfg.target_vendor.values</a></li>
<li><a href="conditional-compilation.html#r-cfg.test">cfg.test</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items.html">6. Items</a></td>
<td>10</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(14);">10</a>
<div id="uncovered-14" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items.html#r-items">items</a></li>
<li><a href="items.html#r-items.associated-locations">items.associated-locations</a></li>
<li><a href="items.html#r-items.decl-order">items.decl-order</a></li>
<li><a href="items.html#r-items.extern-locations">items.extern-locations</a></li>
<li><a href="items.html#r-items.intro">items.intro</a></li>
<li><a href="items.html#r-items.kinds">items.kinds</a></li>
<li><a href="items.html#r-items.locations">items.locations</a></li>
<li><a href="items.html#r-items.name-resolution">items.name-resolution</a></li>
<li><a href="items.html#r-items.static-def">items.static-def</a></li>
<li><a href="items.html#r-items.syntax">items.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/modules.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1. Modules</a></td>
<td>19</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(15);">19</a>
<div id="uncovered-15" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/modules.html#r-items.mod">items.mod</a></li>
<li><a href="items/modules.html#r-items.mod.attributes">items.mod.attributes</a></li>
<li><a href="items/modules.html#r-items.mod.attributes.intro">items.mod.attributes.intro</a></li>
<li><a href="items/modules.html#r-items.mod.attributes.supported">items.mod.attributes.supported</a></li>
<li><a href="items/modules.html#r-items.mod.def">items.mod.def</a></li>
<li><a href="items/modules.html#r-items.mod.intro">items.mod.intro</a></li>
<li><a href="items/modules.html#r-items.mod.multiple-items">items.mod.multiple-items</a></li>
<li><a href="items/modules.html#r-items.mod.namespace">items.mod.namespace</a></li>
<li><a href="items/modules.html#r-items.mod.nesting">items.mod.nesting</a></li>
<li><a href="items/modules.html#r-items.mod.outlined">items.mod.outlined</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.intro">items.mod.outlined.intro</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.path">items.mod.outlined.path</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.path.intro">items.mod.outlined.path.intro</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.path.search">items.mod.outlined.path.search</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.path.search-nested">items.mod.outlined.path.search-nested</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.search">items.mod.outlined.search</a></li>
<li><a href="items/modules.html#r-items.mod.outlined.search-mod">items.mod.outlined.search-mod</a></li>
<li><a href="items/modules.html#r-items.mod.syntax">items.mod.syntax</a></li>
<li><a href="items/modules.html#r-items.mod.unsafe">items.mod.unsafe</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/extern-crates.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2. Extern crates</a></td>
<td>13</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(16);">13</a>
<div id="uncovered-16" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/extern-crates.html#r-items.extern-crate">items.extern-crate</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.as">items.extern-crate.as</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.extern-prelude">items.extern-crate.extern-prelude</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.intro">items.extern-crate.intro</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.lookup">items.extern-crate.lookup</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.name-restrictions">items.extern-crate.name-restrictions</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.namespace">items.extern-crate.namespace</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.no_link">items.extern-crate.no_link</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.self">items.extern-crate.self</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.syntax">items.extern-crate.syntax</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.underscore">items.extern-crate.underscore</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.underscore.intro">items.extern-crate.underscore.intro</a></li>
<li><a href="items/extern-crates.html#r-items.extern-crate.underscore.macro_use">items.extern-crate.underscore.macro_use</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/use-declarations.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3. Use declarations</a></td>
<td>44</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(17);">44</a>
<div id="uncovered-17" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/use-declarations.html#r-items.use">items.use</a></li>
<li><a href="items/use-declarations.html#r-items.use.ambiguities">items.use.ambiguities</a></li>
<li><a href="items/use-declarations.html#r-items.use.ambiguities.glob">items.use.ambiguities.glob</a></li>
<li><a href="items/use-declarations.html#r-items.use.ambiguities.intro">items.use.ambiguities.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.as">items.use.as</a></li>
<li><a href="items/use-declarations.html#r-items.use.as-underscore">items.use.as-underscore</a></li>
<li><a href="items/use-declarations.html#r-items.use.as-underscore.glob">items.use.as-underscore.glob</a></li>
<li><a href="items/use-declarations.html#r-items.use.as-underscore.intro">items.use.as-underscore.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.as-underscore.macro">items.use.as-underscore.macro</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms">items.use.forms</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms.as">items.use.forms.as</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms.glob">items.use.forms.glob</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms.multiple">items.use.forms.multiple</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms.nesting">items.use.forms.nesting</a></li>
<li><a href="items/use-declarations.html#r-items.use.forms.self">items.use.forms.self</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob">items.use.glob</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob.edition2015">items.use.glob.edition2015</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob.intro">items.use.glob.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob.last-segment-only">items.use.glob.last-segment-only</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob.self-import">items.use.glob.self-import</a></li>
<li><a href="items/use-declarations.html#r-items.use.glob.shadowing">items.use.glob.shadowing</a></li>
<li><a href="items/use-declarations.html#r-items.use.intro">items.use.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.multiple-syntax">items.use.multiple-syntax</a></li>
<li><a href="items/use-declarations.html#r-items.use.multiple-syntax.edition2015">items.use.multiple-syntax.edition2015</a></li>
<li><a href="items/use-declarations.html#r-items.use.multiple-syntax.empty">items.use.multiple-syntax.empty</a></li>
<li><a href="items/use-declarations.html#r-items.use.multiple-syntax.intro">items.use.multiple-syntax.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.path">items.use.path</a></li>
<li><a href="items/use-declarations.html#r-items.use.path.disallowed">items.use.path.disallowed</a></li>
<li><a href="items/use-declarations.html#r-items.use.path.edition2015">items.use.path.edition2015</a></li>
<li><a href="items/use-declarations.html#r-items.use.path.intro">items.use.path.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.path.namespace">items.use.path.namespace</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions">items.use.restrictions</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions.crate">items.use.restrictions.crate</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions.duplicate-name">items.use.restrictions.duplicate-name</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions.macro-crate">items.use.restrictions.macro-crate</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions.self">items.use.restrictions.self</a></li>
<li><a href="items/use-declarations.html#r-items.use.restrictions.variant">items.use.restrictions.variant</a></li>
<li><a href="items/use-declarations.html#r-items.use.self">items.use.self</a></li>
<li><a href="items/use-declarations.html#r-items.use.self.intro">items.use.self.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.self.namespace">items.use.self.namespace</a></li>
<li><a href="items/use-declarations.html#r-items.use.syntax">items.use.syntax</a></li>
<li><a href="items/use-declarations.html#r-items.use.visibility">items.use.visibility</a></li>
<li><a href="items/use-declarations.html#r-items.use.visibility.intro">items.use.visibility.intro</a></li>
<li><a href="items/use-declarations.html#r-items.use.visibility.unambiguous">items.use.visibility.unambiguous</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/functions.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4. Functions</a></td>
<td>49</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(18);">49</a>
<div id="uncovered-18" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/functions.html#r-items.fn">items.fn</a></li>
<li><a href="items/functions.html#r-items.fn.async">items.fn.async</a></li>
<li><a href="items/functions.html#r-items.fn.async.desugar">items.fn.async.desugar</a></li>
<li><a href="items/functions.html#r-items.fn.async.desugar-brief">items.fn.async.desugar-brief</a></li>
<li><a href="items/functions.html#r-items.fn.async.edition2018">items.fn.async.edition2018</a></li>
<li><a href="items/functions.html#r-items.fn.async.future">items.fn.async.future</a></li>
<li><a href="items/functions.html#r-items.fn.async.intro">items.fn.async.intro</a></li>
<li><a href="items/functions.html#r-items.fn.async.lifetime-capture">items.fn.async.lifetime-capture</a></li>
<li><a href="items/functions.html#r-items.fn.async.param-capture">items.fn.async.param-capture</a></li>
<li><a href="items/functions.html#r-items.fn.async.safety">items.fn.async.safety</a></li>
<li><a href="items/functions.html#r-items.fn.async.safety.intro">items.fn.async.safety.intro</a></li>
<li><a href="items/functions.html#r-items.fn.attributes">items.fn.attributes</a></li>
<li><a href="items/functions.html#r-items.fn.attributes.builtin-attributes">items.fn.attributes.builtin-attributes</a></li>
<li><a href="items/functions.html#r-items.fn.attributes.intro">items.fn.attributes.intro</a></li>
<li><a href="items/functions.html#r-items.fn.body">items.fn.body</a></li>
<li><a href="items/functions.html#r-items.fn.body.bodyless">items.fn.body.bodyless</a></li>
<li><a href="items/functions.html#r-items.fn.body.intro">items.fn.body.intro</a></li>
<li><a href="items/functions.html#r-items.fn.const">items.fn.const</a></li>
<li><a href="items/functions.html#r-items.fn.const.exclusivity">items.fn.const.exclusivity</a></li>
<li><a href="items/functions.html#r-items.fn.const.extern">items.fn.const.extern</a></li>
<li><a href="items/functions.html#r-items.fn.const.intro">items.fn.const.intro</a></li>
<li><a href="items/functions.html#r-items.fn.extern">items.fn.extern</a></li>
<li><a href="items/functions.html#r-items.fn.extern.def">items.fn.extern.def</a></li>
<li><a href="items/functions.html#r-items.fn.extern.default-abi">items.fn.extern.default-abi</a></li>
<li><a href="items/functions.html#r-items.fn.extern.default-extern">items.fn.extern.default-extern</a></li>
<li><a href="items/functions.html#r-items.fn.extern.foreign-call">items.fn.extern.foreign-call</a></li>
<li><a href="items/functions.html#r-items.fn.extern.intro">items.fn.extern.intro</a></li>
<li><a href="items/functions.html#r-items.fn.extern.unwind">items.fn.extern.unwind</a></li>
<li><a href="items/functions.html#r-items.fn.fn-item-type">items.fn.fn-item-type</a></li>
<li><a href="items/functions.html#r-items.fn.generics">items.fn.generics</a></li>
<li><a href="items/functions.html#r-items.fn.generics.explicit-arguments">items.fn.generics.explicit-arguments</a></li>
<li><a href="items/functions.html#r-items.fn.generics.intro">items.fn.generics.intro</a></li>
<li><a href="items/functions.html#r-items.fn.generics.mono">items.fn.generics.mono</a></li>
<li><a href="items/functions.html#r-items.fn.generics.param-bounds">items.fn.generics.param-bounds</a></li>
<li><a href="items/functions.html#r-items.fn.generics.param-names">items.fn.generics.param-names</a></li>
<li><a href="items/functions.html#r-items.fn.implicit-return">items.fn.implicit-return</a></li>
<li><a href="items/functions.html#r-items.fn.intro">items.fn.intro</a></li>
<li><a href="items/functions.html#r-items.fn.namespace">items.fn.namespace</a></li>
<li><a href="items/functions.html#r-items.fn.param-attributes">items.fn.param-attributes</a></li>
<li><a href="items/functions.html#r-items.fn.param-attributes.intro">items.fn.param-attributes.intro</a></li>
<li><a href="items/functions.html#r-items.fn.param-attributes.parsed-attributes">items.fn.param-attributes.parsed-attributes</a></li>
<li><a href="items/functions.html#r-items.fn.params">items.fn.params</a></li>
<li><a href="items/functions.html#r-items.fn.params.intro">items.fn.params.intro</a></li>
<li><a href="items/functions.html#r-items.fn.params.self-pat">items.fn.params.self-pat</a></li>
<li><a href="items/functions.html#r-items.fn.params.self-restriction">items.fn.params.self-restriction</a></li>
<li><a href="items/functions.html#r-items.fn.params.varargs">items.fn.params.varargs</a></li>
<li><a href="items/functions.html#r-items.fn.safety-qualifiers">items.fn.safety-qualifiers</a></li>
<li><a href="items/functions.html#r-items.fn.signature">items.fn.signature</a></li>
<li><a href="items/functions.html#r-items.fn.syntax">items.fn.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/type-aliases.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5. Type aliases</a></td>
<td>8</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(19);">8</a>
<div id="uncovered-19" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/type-aliases.html#r-items.type">items.type</a></li>
<li><a href="items/type-aliases.html#r-items.type.associated-impl">items.type.associated-impl</a></li>
<li><a href="items/type-aliases.html#r-items.type.associated-trait">items.type.associated-trait</a></li>
<li><a href="items/type-aliases.html#r-items.type.associated-type">items.type.associated-type</a></li>
<li><a href="items/type-aliases.html#r-items.type.constructor-alias">items.type.constructor-alias</a></li>
<li><a href="items/type-aliases.html#r-items.type.deprecated">items.type.deprecated</a></li>
<li><a href="items/type-aliases.html#r-items.type.intro">items.type.intro</a></li>
<li><a href="items/type-aliases.html#r-items.type.syntax">items.type.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/structs.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6. Structs</a></td>
<td>7</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(20);">7</a>
<div id="uncovered-20" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/structs.html#r-items.struct">items.struct</a></li>
<li><a href="items/structs.html#r-items.struct.intro">items.struct.intro</a></li>
<li><a href="items/structs.html#r-items.struct.layout">items.struct.layout</a></li>
<li><a href="items/structs.html#r-items.struct.namespace">items.struct.namespace</a></li>
<li><a href="items/structs.html#r-items.struct.syntax">items.struct.syntax</a></li>
<li><a href="items/structs.html#r-items.struct.tuple">items.struct.tuple</a></li>
<li><a href="items/structs.html#r-items.struct.unit">items.struct.unit</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/enumerations.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.7. Enumerations</a></td>
<td>33</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(21);">33</a>
<div id="uncovered-21" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/enumerations.html#r-items.enum">items.enum</a></li>
<li><a href="items/enumerations.html#r-items.enum.constructor">items.enum.constructor</a></li>
<li><a href="items/enumerations.html#r-items.enum.constructor-names">items.enum.constructor-names</a></li>
<li><a href="items/enumerations.html#r-items.enum.constructor-namespace">items.enum.constructor-namespace</a></li>
<li><a href="items/enumerations.html#r-items.enum.decl">items.enum.decl</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant">items.enum.discriminant</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.access-memory">items.enum.discriminant.access-memory</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.access-opaque">items.enum.discriminant.access-opaque</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.coercion">items.enum.discriminant.coercion</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.coercion.fieldless">items.enum.discriminant.coercion.fieldless</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.coercion.intro">items.enum.discriminant.coercion.intro</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.explicit">items.enum.discriminant.explicit</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.explicit.intro">items.enum.discriminant.explicit.intro</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.explicit.primitive-repr">items.enum.discriminant.explicit.primitive-repr</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.explicit.unit-only">items.enum.discriminant.explicit.unit-only</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.implicit">items.enum.discriminant.implicit</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.intro">items.enum.discriminant.intro</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.repr-rust">items.enum.discriminant.repr-rust</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.restrictions">items.enum.discriminant.restrictions</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.restrictions.above-max-discriminant">items.enum.discriminant.restrictions.above-max-discriminant</a></li>
<li><a href="items/enumerations.html#r-items.enum.discriminant.restrictions.same-discriminant">items.enum.discriminant.restrictions.same-discriminant</a></li>
<li><a href="items/enumerations.html#r-items.enum.empty">items.enum.empty</a></li>
<li><a href="items/enumerations.html#r-items.enum.empty.intro">items.enum.empty.intro</a></li>
<li><a href="items/enumerations.html#r-items.enum.empty.uninhabited">items.enum.empty.uninhabited</a></li>
<li><a href="items/enumerations.html#r-items.enum.fieldless">items.enum.fieldless</a></li>
<li><a href="items/enumerations.html#r-items.enum.intro">items.enum.intro</a></li>
<li><a href="items/enumerations.html#r-items.enum.namespace">items.enum.namespace</a></li>
<li><a href="items/enumerations.html#r-items.enum.path-expr">items.enum.path-expr</a></li>
<li><a href="items/enumerations.html#r-items.enum.struct-expr">items.enum.struct-expr</a></li>
<li><a href="items/enumerations.html#r-items.enum.syntax">items.enum.syntax</a></li>
<li><a href="items/enumerations.html#r-items.enum.tuple-expr">items.enum.tuple-expr</a></li>
<li><a href="items/enumerations.html#r-items.enum.unit-only">items.enum.unit-only</a></li>
<li><a href="items/enumerations.html#r-items.enum.variant-visibility">items.enum.variant-visibility</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/unions.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.8. Unions</a></td>
<td>31</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(22);">31</a>
<div id="uncovered-22" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/unions.html#r-items.union">items.union</a></li>
<li><a href="items/unions.html#r-items.union.common-storage">items.union.common-storage</a></li>
<li><a href="items/unions.html#r-items.union.drop">items.union.drop</a></li>
<li><a href="items/unions.html#r-items.union.field-copy">items.union.field-copy</a></li>
<li><a href="items/unions.html#r-items.union.field-manually-drop">items.union.field-manually-drop</a></li>
<li><a href="items/unions.html#r-items.union.field-references">items.union.field-references</a></li>
<li><a href="items/unions.html#r-items.union.field-restrictions">items.union.field-restrictions</a></li>
<li><a href="items/unions.html#r-items.union.field-tuple">items.union.field-tuple</a></li>
<li><a href="items/unions.html#r-items.union.fieldless">items.union.fieldless</a></li>
<li><a href="items/unions.html#r-items.union.fields">items.union.fields</a></li>
<li><a href="items/unions.html#r-items.union.fields.intro">items.union.fields.intro</a></li>
<li><a href="items/unions.html#r-items.union.fields.offset">items.union.fields.offset</a></li>
<li><a href="items/unions.html#r-items.union.fields.read">items.union.fields.read</a></li>
<li><a href="items/unions.html#r-items.union.fields.read-safety">items.union.fields.read-safety</a></li>
<li><a href="items/unions.html#r-items.union.fields.validity">items.union.fields.validity</a></li>
<li><a href="items/unions.html#r-items.union.fields.write-safety">items.union.fields.write-safety</a></li>
<li><a href="items/unions.html#r-items.union.init">items.union.init</a></li>
<li><a href="items/unions.html#r-items.union.init.intro">items.union.init.intro</a></li>
<li><a href="items/unions.html#r-items.union.init.result">items.union.init.result</a></li>
<li><a href="items/unions.html#r-items.union.intro">items.union.intro</a></li>
<li><a href="items/unions.html#r-items.union.namespace">items.union.namespace</a></li>
<li><a href="items/unions.html#r-items.union.pattern">items.union.pattern</a></li>
<li><a href="items/unions.html#r-items.union.pattern.intro">items.union.pattern.intro</a></li>
<li><a href="items/unions.html#r-items.union.pattern.one-field">items.union.pattern.one-field</a></li>
<li><a href="items/unions.html#r-items.union.pattern.safety">items.union.pattern.safety</a></li>
<li><a href="items/unions.html#r-items.union.pattern.subpattern">items.union.pattern.subpattern</a></li>
<li><a href="items/unions.html#r-items.union.ref">items.union.ref</a></li>
<li><a href="items/unions.html#r-items.union.ref.borrow">items.union.ref.borrow</a></li>
<li><a href="items/unions.html#r-items.union.ref.intro">items.union.ref.intro</a></li>
<li><a href="items/unions.html#r-items.union.ref.usage">items.union.ref.usage</a></li>
<li><a href="items/unions.html#r-items.union.syntax">items.union.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/constant-items.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.9. Constant items</a></td>
<td>14</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(23);">14</a>
<div id="uncovered-23" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/constant-items.html#r-items.const">items.const</a></li>
<li><a href="items/constant-items.html#r-items.const.behavior">items.const.behavior</a></li>
<li><a href="items/constant-items.html#r-items.const.destructor">items.const.destructor</a></li>
<li><a href="items/constant-items.html#r-items.const.eval">items.const.eval</a></li>
<li><a href="items/constant-items.html#r-items.const.expr-omission">items.const.expr-omission</a></li>
<li><a href="items/constant-items.html#r-items.const.final-value-immutable">items.const.final-value-immutable</a></li>
<li><a href="items/constant-items.html#r-items.const.intro">items.const.intro</a></li>
<li><a href="items/constant-items.html#r-items.const.namespace">items.const.namespace</a></li>
<li><a href="items/constant-items.html#r-items.const.static">items.const.static</a></li>
<li><a href="items/constant-items.html#r-items.const.static-temporary">items.const.static-temporary</a></li>
<li><a href="items/constant-items.html#r-items.const.syntax">items.const.syntax</a></li>
<li><a href="items/constant-items.html#r-items.const.unnamed">items.const.unnamed</a></li>
<li><a href="items/constant-items.html#r-items.const.unnamed.intro">items.const.unnamed.intro</a></li>
<li><a href="items/constant-items.html#r-items.const.unnamed.repetition">items.const.unnamed.repetition</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/static-items.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.10. Static items</a></td>
<td>19</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(24);">19</a>
<div id="uncovered-24" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/static-items.html#r-items.static">items.static</a></li>
<li><a href="items/static-items.html#r-items.static.alternate">items.static.alternate</a></li>
<li><a href="items/static-items.html#r-items.static.generics">items.static.generics</a></li>
<li><a href="items/static-items.html#r-items.static.init">items.static.init</a></li>
<li><a href="items/static-items.html#r-items.static.init.omission">items.static.init.omission</a></li>
<li><a href="items/static-items.html#r-items.static.intro">items.static.intro</a></li>
<li><a href="items/static-items.html#r-items.static.lifetime">items.static.lifetime</a></li>
<li><a href="items/static-items.html#r-items.static.mut">items.static.mut</a></li>
<li><a href="items/static-items.html#r-items.static.mut.extern">items.static.mut.extern</a></li>
<li><a href="items/static-items.html#r-items.static.mut.intro">items.static.mut.intro</a></li>
<li><a href="items/static-items.html#r-items.static.mut.safety">items.static.mut.safety</a></li>
<li><a href="items/static-items.html#r-items.static.mut.sync">items.static.mut.sync</a></li>
<li><a href="items/static-items.html#r-items.static.namespace">items.static.namespace</a></li>
<li><a href="items/static-items.html#r-items.static.read-only">items.static.read-only</a></li>
<li><a href="items/static-items.html#r-items.static.safety">items.static.safety</a></li>
<li><a href="items/static-items.html#r-items.static.safety-qualifiers">items.static.safety-qualifiers</a></li>
<li><a href="items/static-items.html#r-items.static.storage-disjointness">items.static.storage-disjointness</a></li>
<li><a href="items/static-items.html#r-items.static.sync">items.static.sync</a></li>
<li><a href="items/static-items.html#r-items.static.syntax">items.static.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/traits.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.11. Traits</a></td>
<td>32</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(25);">32</a>
<div id="uncovered-25" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/traits.html#r-items.traits">items.traits</a></li>
<li><a href="items/traits.html#r-items.traits.associated-item-decls">items.traits.associated-item-decls</a></li>
<li><a href="items/traits.html#r-items.traits.associated-item-namespaces">items.traits.associated-item-namespaces</a></li>
<li><a href="items/traits.html#r-items.traits.associated-visibility">items.traits.associated-visibility</a></li>
<li><a href="items/traits.html#r-items.traits.associated-visibility.intro">items.traits.associated-visibility.intro</a></li>
<li><a href="items/traits.html#r-items.traits.bounds">items.traits.bounds</a></li>
<li><a href="items/traits.html#r-items.traits.const-fn">items.traits.const-fn</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible">items.traits.dyn-compatible</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.associated-consts">items.traits.dyn-compatible.associated-consts</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.associated-functions">items.traits.dyn-compatible.associated-functions</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.associated-types">items.traits.dyn-compatible.associated-types</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.async-traits">items.traits.dyn-compatible.async-traits</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.intro">items.traits.dyn-compatible.intro</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.sized">items.traits.dyn-compatible.sized</a></li>
<li><a href="items/traits.html#r-items.traits.dyn-compatible.supertraits">items.traits.dyn-compatible.supertraits</a></li>
<li><a href="items/traits.html#r-items.traits.generic">items.traits.generic</a></li>
<li><a href="items/traits.html#r-items.traits.impls">items.traits.impls</a></li>
<li><a href="items/traits.html#r-items.traits.intro">items.traits.intro</a></li>
<li><a href="items/traits.html#r-items.traits.namespace">items.traits.namespace</a></li>
<li><a href="items/traits.html#r-items.traits.params">items.traits.params</a></li>
<li><a href="items/traits.html#r-items.traits.params.allowed-patterns">items.traits.params.allowed-patterns</a></li>
<li><a href="items/traits.html#r-items.traits.params.edition2015">items.traits.params.edition2015</a></li>
<li><a href="items/traits.html#r-items.traits.params.restriction">items.traits.params.restriction</a></li>
<li><a href="items/traits.html#r-items.traits.params.restriction.edition2018">items.traits.params.restriction.edition2018</a></li>
<li><a href="items/traits.html#r-items.traits.safety">items.traits.safety</a></li>
<li><a href="items/traits.html#r-items.traits.safety.intro">items.traits.safety.intro</a></li>
<li><a href="items/traits.html#r-items.traits.self-param">items.traits.self-param</a></li>
<li><a href="items/traits.html#r-items.traits.supertraits">items.traits.supertraits</a></li>
<li><a href="items/traits.html#r-items.traits.supertraits.decl">items.traits.supertraits.decl</a></li>
<li><a href="items/traits.html#r-items.traits.supertraits.intro">items.traits.supertraits.intro</a></li>
<li><a href="items/traits.html#r-items.traits.supertraits.subtrait">items.traits.supertraits.subtrait</a></li>
<li><a href="items/traits.html#r-items.traits.syntax">items.traits.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/implementations.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.12. Implementations</a></td>
<td>30</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(26);">30</a>
<div id="uncovered-26" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/implementations.html#r-items.impl">items.impl</a></li>
<li><a href="items/implementations.html#r-items.impl.attributes">items.impl.attributes</a></li>
<li><a href="items/implementations.html#r-items.impl.generics">items.impl.generics</a></li>
<li><a href="items/implementations.html#r-items.impl.generics.constrain">items.impl.generics.constrain</a></li>
<li><a href="items/implementations.html#r-items.impl.generics.intro">items.impl.generics.intro</a></li>
<li><a href="items/implementations.html#r-items.impl.generics.usage">items.impl.generics.usage</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent">items.impl.inherent</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.associated-item-path">items.impl.inherent.associated-item-path</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.associated-items">items.impl.inherent.associated-items</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.associated-items.allowed-items">items.impl.inherent.associated-items.allowed-items</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.coherence">items.impl.inherent.coherence</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.implementing-type">items.impl.inherent.implementing-type</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.intro">items.impl.inherent.intro</a></li>
<li><a href="items/implementations.html#r-items.impl.inherent.type-alias">items.impl.inherent.type-alias</a></li>
<li><a href="items/implementations.html#r-items.impl.intro">items.impl.intro</a></li>
<li><a href="items/implementations.html#r-items.impl.kinds">items.impl.kinds</a></li>
<li><a href="items/implementations.html#r-items.impl.syntax">items.impl.syntax</a></li>
<li><a href="items/implementations.html#r-items.impl.trait">items.impl.trait</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.associated-item-path">items.impl.trait.associated-item-path</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.coherence">items.impl.trait.coherence</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.coherence.intro">items.impl.trait.coherence.intro</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.coherence.overlapping">items.impl.trait.coherence.overlapping</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.def-requirement">items.impl.trait.def-requirement</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.fundamental">items.impl.trait.fundamental</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.implemented-trait">items.impl.trait.implemented-trait</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.intro">items.impl.trait.intro</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.orphan-rule">items.impl.trait.orphan-rule</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.orphan-rule.general">items.impl.trait.orphan-rule.general</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.safety">items.impl.trait.safety</a></li>
<li><a href="items/implementations.html#r-items.impl.trait.uncovered-param">items.impl.trait.uncovered-param</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/external-blocks.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.13. External blocks</a></td>
<td>85</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(27);">85</a>
<div id="uncovered-27" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/external-blocks.html#r-items.extern">items.extern</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi">items.extern.abi</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.aapcs">items.extern.abi.aapcs</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.c">items.extern.abi.c</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.cdecl">items.extern.abi.cdecl</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.efiapi">items.extern.abi.efiapi</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.fastcall">items.extern.abi.fastcall</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.intro">items.extern.abi.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.platform">items.extern.abi.platform</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.rust">items.extern.abi.rust</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.standard">items.extern.abi.standard</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.stdcall">items.extern.abi.stdcall</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.system">items.extern.abi.system</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.sysv64">items.extern.abi.sysv64</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.thiscall">items.extern.abi.thiscall</a></li>
<li><a href="items/external-blocks.html#r-items.extern.abi.win64">items.extern.abi.win64</a></li>
<li><a href="items/external-blocks.html#r-items.extern.allowed-kinds">items.extern.allowed-kinds</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes">items.extern.attributes</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.fn-parameters">items.extern.attributes.fn-parameters</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.intro">items.extern.attributes.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link">items.extern.attributes.link</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.dylib">items.extern.attributes.link.dylib</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.empty-block">items.extern.attributes.link.empty-block</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.framework">items.extern.attributes.link.framework</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type">items.extern.attributes.link.import_name_type</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.default">items.extern.attributes.link.import_name_type.default</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.intro">items.extern.attributes.link.import_name_type.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.platform-specific">items.extern.attributes.link.import_name_type.platform-specific</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.values">items.extern.attributes.link.import_name_type.values</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.import_name_type.variables">items.extern.attributes.link.import_name_type.variables</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.intro">items.extern.attributes.link.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib">items.extern.attributes.link.kind-raw-dylib</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.import">items.extern.attributes.link.kind-raw-dylib.import</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.intro">items.extern.attributes.link.kind-raw-dylib.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.kind-raw-dylib.platform-specific">items.extern.attributes.link.kind-raw-dylib.platform-specific</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers">items.extern.attributes.link.modifiers</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle">items.extern.attributes.link.modifiers.bundle</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.allowed-kinds">items.extern.attributes.link.modifiers.bundle.allowed-kinds</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.behavior">items.extern.attributes.link.modifiers.bundle.behavior</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.behavior-negative">items.extern.attributes.link.modifiers.bundle.behavior-negative</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.default">items.extern.attributes.link.modifiers.bundle.default</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.bundle.no-effect">items.extern.attributes.link.modifiers.bundle.no-effect</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.multiple">items.extern.attributes.link.modifiers.multiple</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.syntax">items.extern.attributes.link.modifiers.syntax</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim">items.extern.attributes.link.modifiers.verbatim</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.allowed-kinds">items.extern.attributes.link.modifiers.verbatim.allowed-kinds</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.behavior">items.extern.attributes.link.modifiers.verbatim.behavior</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.behavior-negative">items.extern.attributes.link.modifiers.verbatim.behavior-negative</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.verbatim.default">items.extern.attributes.link.modifiers.verbatim.default</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive">items.extern.attributes.link.modifiers.whole-archive</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.allowed-kinds">items.extern.attributes.link.modifiers.whole-archive.allowed-kinds</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.behavior">items.extern.attributes.link.modifiers.whole-archive.behavior</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.modifiers.whole-archive.default">items.extern.attributes.link.modifiers.whole-archive.default</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.name-requirement">items.extern.attributes.link.name-requirement</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.raw-dylib">items.extern.attributes.link.raw-dylib</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.static">items.extern.attributes.link.static</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.syntax">items.extern.attributes.link.syntax</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link.wasm_import_module">items.extern.attributes.link.wasm_import_module</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_name">items.extern.attributes.link_name</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_name.exclusive">items.extern.attributes.link_name.exclusive</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_name.intro">items.extern.attributes.link_name.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_name.syntax">items.extern.attributes.link_name.syntax</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_ordinal">items.extern.attributes.link_ordinal</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.allowed-kinds">items.extern.attributes.link_ordinal.allowed-kinds</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.exclusive">items.extern.attributes.link_ordinal.exclusive</a></li>
<li><a href="items/external-blocks.html#r-items.extern.attributes.link_ordinal.intro">items.extern.attributes.link_ordinal.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.edition2024">items.extern.edition2024</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn">items.extern.fn</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn-safety">items.extern.fn-safety</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.body">items.extern.fn.body</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.fn-ptr">items.extern.fn.fn-ptr</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.foreign-abi">items.extern.fn.foreign-abi</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.param-patterns">items.extern.fn.param-patterns</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.qualifiers">items.extern.fn.qualifiers</a></li>
<li><a href="items/external-blocks.html#r-items.extern.fn.safety">items.extern.fn.safety</a></li>
<li><a href="items/external-blocks.html#r-items.extern.intro">items.extern.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.namespace">items.extern.namespace</a></li>
<li><a href="items/external-blocks.html#r-items.extern.static">items.extern.static</a></li>
<li><a href="items/external-blocks.html#r-items.extern.static.intro">items.extern.static.intro</a></li>
<li><a href="items/external-blocks.html#r-items.extern.static.mut">items.extern.static.mut</a></li>
<li><a href="items/external-blocks.html#r-items.extern.static.read-only">items.extern.static.read-only</a></li>
<li><a href="items/external-blocks.html#r-items.extern.static.safety">items.extern.static.safety</a></li>
<li><a href="items/external-blocks.html#r-items.extern.syntax">items.extern.syntax</a></li>
<li><a href="items/external-blocks.html#r-items.extern.unsafe-required">items.extern.unsafe-required</a></li>
<li><a href="items/external-blocks.html#r-items.extern.variadic">items.extern.variadic</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/generics.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.14. Generic parameters</a></td>
<td>24</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(28);">24</a>
<div id="uncovered-28" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/generics.html#r-items.generics">items.generics</a></li>
<li><a href="items/generics.html#r-items.generics.attributes">items.generics.attributes</a></li>
<li><a href="items/generics.html#r-items.generics.builtin-generic-types">items.generics.builtin-generic-types</a></li>
<li><a href="items/generics.html#r-items.generics.const">items.generics.const</a></li>
<li><a href="items/generics.html#r-items.generics.const.allowed-types">items.generics.const.allowed-types</a></li>
<li><a href="items/generics.html#r-items.generics.const.argument">items.generics.const.argument</a></li>
<li><a href="items/generics.html#r-items.generics.const.argument.const-expr">items.generics.const.argument.const-expr</a></li>
<li><a href="items/generics.html#r-items.generics.const.exhaustiveness">items.generics.const.exhaustiveness</a></li>
<li><a href="items/generics.html#r-items.generics.const.intro">items.generics.const.intro</a></li>
<li><a href="items/generics.html#r-items.generics.const.namespace">items.generics.const.namespace</a></li>
<li><a href="items/generics.html#r-items.generics.const.standalone">items.generics.const.standalone</a></li>
<li><a href="items/generics.html#r-items.generics.const.type-ambiguity">items.generics.const.type-ambiguity</a></li>
<li><a href="items/generics.html#r-items.generics.const.usage">items.generics.const.usage</a></li>
<li><a href="items/generics.html#r-items.generics.const.variance">items.generics.const.variance</a></li>
<li><a href="items/generics.html#r-items.generics.invalid-lifetimes">items.generics.invalid-lifetimes</a></li>
<li><a href="items/generics.html#r-items.generics.syntax">items.generics.syntax</a></li>
<li><a href="items/generics.html#r-items.generics.syntax.decl-order">items.generics.syntax.decl-order</a></li>
<li><a href="items/generics.html#r-items.generics.syntax.duplicate-params">items.generics.syntax.duplicate-params</a></li>
<li><a href="items/generics.html#r-items.generics.syntax.intro">items.generics.syntax.intro</a></li>
<li><a href="items/generics.html#r-items.generics.syntax.scope">items.generics.syntax.scope</a></li>
<li><a href="items/generics.html#r-items.generics.where">items.generics.where</a></li>
<li><a href="items/generics.html#r-items.generics.where.higher-ranked-lifetimes">items.generics.where.higher-ranked-lifetimes</a></li>
<li><a href="items/generics.html#r-items.generics.where.intro">items.generics.where.intro</a></li>
<li><a href="items/generics.html#r-items.generics.where.syntax">items.generics.where.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="items/associated-items.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.15. Associated Items</a></td>
<td>45</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(29);">45</a>
<div id="uncovered-29" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="items/associated-items.html#r-associated.fn.method.self-pat-mut">associated.fn.method.self-pat-mut</a></li>
<li><a href="items/associated-items.html#r-associated.fn.method.self-pat-shorthands">associated.fn.method.self-pat-shorthands</a></li>
<li><a href="items/associated-items.html#r-items.associated">items.associated</a></li>
<li><a href="items/associated-items.html#r-items.associated.const">items.associated.const</a></li>
<li><a href="items/associated-items.html#r-items.associated.const.decl">items.associated.const.decl</a></li>
<li><a href="items/associated-items.html#r-items.associated.const.def">items.associated.const.def</a></li>
<li><a href="items/associated-items.html#r-items.associated.const.eval">items.associated.const.eval</a></li>
<li><a href="items/associated-items.html#r-items.associated.const.intro">items.associated.const.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.const.name">items.associated.const.name</a></li>
<li><a href="items/associated-items.html#r-items.associated.decl-def">items.associated.decl-def</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn">items.associated.fn</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.decl">items.associated.fn.decl</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.def">items.associated.fn.def</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.intro">items.associated.fn.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.method">items.associated.fn.method</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.method.intro">items.associated.fn.method.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.method.self-ty">items.associated.fn.method.self-ty</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.param-attributes">items.associated.fn.param-attributes</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.params.edition2015">items.associated.fn.params.edition2015</a></li>
<li><a href="items/associated-items.html#r-items.associated.fn.qualified-self">items.associated.fn.qualified-self</a></li>
<li><a href="items/associated-items.html#r-items.associated.intro">items.associated.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.kinds">items.associated.kinds</a></li>
<li><a href="items/associated-items.html#r-items.associated.name">items.associated.name</a></li>
<li><a href="items/associated-items.html#r-items.associated.related">items.associated.related</a></li>
<li><a href="items/associated-items.html#r-items.associated.same-signature">items.associated.same-signature</a></li>
<li><a href="items/associated-items.html#r-items.associated.syntax">items.associated.syntax</a></li>
<li><a href="items/associated-items.html#r-items.associated.trait-items">items.associated.trait-items</a></li>
<li><a href="items/associated-items.html#r-items.associated.type">items.associated.type</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.alias">items.associated.type.alias</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.decl">items.associated.type.decl</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.def">items.associated.type.def</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.def.restriction">items.associated.type.def.restriction</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic">items.associated.type.generic</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause">items.associated.type.generic-where-clause</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause.forward">items.associated.type.generic-where-clause.forward</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause.intersection">items.associated.type.generic-where-clause.intersection</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause.intro">items.associated.type.generic-where-clause.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause.static">items.associated.type.generic-where-clause.static</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.generic-where-clause.valid-fn">items.associated.type.generic-where-clause.valid-fn</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.impl-fulfillment">items.associated.type.impl-fulfillment</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.intro">items.associated.type.intro</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.name">items.associated.type.name</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.param">items.associated.type.param</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.restrictions">items.associated.type.restrictions</a></li>
<li><a href="items/associated-items.html#r-items.associated.type.sized">items.associated.type.sized</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes.html">7. Attributes</a></td>
<td>21</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(30);">21</a>
<div id="uncovered-30" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes.html#r-attributes.activity">attributes.activity</a></li>
<li><a href="attributes.html#r-attributes.activity.intro">attributes.activity.intro</a></li>
<li><a href="attributes.html#r-attributes.allowed-position">attributes.allowed-position</a></li>
<li><a href="attributes.html#r-attributes.builtin">attributes.builtin</a></li>
<li><a href="attributes.html#r-attributes.inner">attributes.inner</a></li>
<li><a href="attributes.html#r-attributes.input">attributes.input</a></li>
<li><a href="attributes.html#r-attributes.intro">attributes.intro</a></li>
<li><a href="attributes.html#r-attributes.kind">attributes.kind</a></li>
<li><a href="attributes.html#r-attributes.meta">attributes.meta</a></li>
<li><a href="attributes.html#r-attributes.meta.builtin">attributes.meta.builtin</a></li>
<li><a href="attributes.html#r-attributes.meta.intro">attributes.meta.intro</a></li>
<li><a href="attributes.html#r-attributes.meta.literal-expr">attributes.meta.literal-expr</a></li>
<li><a href="attributes.html#r-attributes.meta.order">attributes.meta.order</a></li>
<li><a href="attributes.html#r-attributes.meta.order-macro">attributes.meta.order-macro</a></li>
<li><a href="attributes.html#r-attributes.meta.syntax">attributes.meta.syntax</a></li>
<li><a href="attributes.html#r-attributes.safety">attributes.safety</a></li>
<li><a href="attributes.html#r-attributes.syntax">attributes.syntax</a></li>
<li><a href="attributes.html#r-attributes.tool">attributes.tool</a></li>
<li><a href="attributes.html#r-attributes.tool.ignored">attributes.tool.ignored</a></li>
<li><a href="attributes.html#r-attributes.tool.intro">attributes.tool.intro</a></li>
<li><a href="attributes.html#r-attributes.tool.prelude">attributes.tool.prelude</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/testing.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1. Testing</a></td>
<td>13</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(31);">13</a>
<div id="uncovered-31" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/testing.html#r-attributes.testing">attributes.testing</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.ignore">attributes.testing.ignore</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.ignore.intro">attributes.testing.ignore.intro</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.ignore.syntax">attributes.testing.ignore.syntax</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.should_panic">attributes.testing.should_panic</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.should_panic.behavior">attributes.testing.should_panic.behavior</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.should_panic.intro">attributes.testing.should_panic.intro</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.should_panic.syntax">attributes.testing.should_panic.syntax</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.test">attributes.testing.test</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.test.allowed-positions">attributes.testing.test.allowed-positions</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.test.enabled">attributes.testing.test.enabled</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.test.intro">attributes.testing.test.intro</a></li>
<li><a href="attributes/testing.html#r-attributes.testing.test.success">attributes.testing.test.success</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/derive.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2. Derive</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(32);">5</a>
<div id="uncovered-32" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/derive.html#r-attributes.derive">attributes.derive</a></li>
<li><a href="attributes/derive.html#r-attributes.derive.automatically_derived">attributes.derive.automatically_derived</a></li>
<li><a href="attributes/derive.html#r-attributes.derive.intro">attributes.derive.intro</a></li>
<li><a href="attributes/derive.html#r-attributes.derive.proc-macro">attributes.derive.proc-macro</a></li>
<li><a href="attributes/derive.html#r-attributes.derive.syntax">attributes.derive.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/diagnostics.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.3. Diagnostics</a></td>
<td>51</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(33);">51</a>
<div id="uncovered-33" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/diagnostics.html#r-attributes.diagnostic.deprecated.allowed-positions">attributes.diagnostic.deprecated.allowed-positions</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend">attributes.diagnostic.do_not_recommend</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.allowed-positions">attributes.diagnostic.do_not_recommend.allowed-positions</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.intro">attributes.diagnostic.do_not_recommend.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.do_not_recommend.syntax">attributes.diagnostic.do_not_recommend.syntax</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.namespace">attributes.diagnostic.namespace</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.namespace.intro">attributes.diagnostic.namespace.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.namespace.unknown-invalid-syntax">attributes.diagnostic.namespace.unknown-invalid-syntax</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented">attributes.diagnostic.on_unimplemented</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.allowed-positions">attributes.diagnostic.on_unimplemented.allowed-positions</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.format-parameters">attributes.diagnostic.on_unimplemented.format-parameters</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.format-string">attributes.diagnostic.on_unimplemented.format-string</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.intro">attributes.diagnostic.on_unimplemented.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.invalid-formats">attributes.diagnostic.on_unimplemented.invalid-formats</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.invalid-string">attributes.diagnostic.on_unimplemented.invalid-string</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.keys">attributes.diagnostic.on_unimplemented.keys</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.note-repetition">attributes.diagnostic.on_unimplemented.note-repetition</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.repetition">attributes.diagnostic.on_unimplemented.repetition</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.syntax">attributes.diagnostic.on_unimplemented.syntax</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostic.on_unimplemented.unknown-keys">attributes.diagnostic.on_unimplemented.unknown-keys</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics">attributes.diagnostics</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated">attributes.diagnostics.deprecated</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated.intro">attributes.diagnostics.deprecated.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.deprecated.syntax">attributes.diagnostics.deprecated.syntax</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.expect">attributes.diagnostics.expect</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.expect.fulfillment">attributes.diagnostics.expect.fulfillment</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.expect.independent">attributes.diagnostics.expect.independent</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.expect.intro">attributes.diagnostics.expect.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint">attributes.diagnostics.lint</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.allow">attributes.diagnostics.lint.allow</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.deny">attributes.diagnostics.lint.deny</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.expect">attributes.diagnostics.lint.expect</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.forbid">attributes.diagnostics.lint.forbid</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.group">attributes.diagnostics.lint.group</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.group.warnings">attributes.diagnostics.lint.group.warnings</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.level">attributes.diagnostics.lint.level</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.override">attributes.diagnostics.lint.override</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.reason">attributes.diagnostics.lint.reason</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool">attributes.diagnostics.lint.tool</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool.activation">attributes.diagnostics.lint.tool.activation</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.tool.intro">attributes.diagnostics.lint.tool.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.lint.warn">attributes.diagnostics.lint.warn</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use">attributes.diagnostics.must_use</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.allowed-positions">attributes.diagnostics.must_use.allowed-positions</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.fn">attributes.diagnostics.must_use.fn</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.intro">attributes.diagnostics.must_use.intro</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.message">attributes.diagnostics.must_use.message</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait">attributes.diagnostics.must_use.trait</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait-function">attributes.diagnostics.must_use.trait-function</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.trait-impl-function">attributes.diagnostics.must_use.trait-impl-function</a></li>
<li><a href="attributes/diagnostics.html#r-attributes.diagnostics.must_use.type">attributes.diagnostics.must_use.type</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/codegen.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.4. Code generation</a></td>
<td>40</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(34);">40</a>
<div id="uncovered-34" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/codegen.html#r-attributes.codegen">attributes.codegen</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.cold">attributes.codegen.cold</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.hint">attributes.codegen.hint</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.hint.cold-inline">attributes.codegen.hint.cold-inline</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.hint.usage">attributes.codegen.hint.usage</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.inline">attributes.codegen.inline</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.inline.intro">attributes.codegen.inline.intro</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.inline.modes">attributes.codegen.inline.modes</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set">attributes.codegen.instruction_set</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set.allowed-positions">attributes.codegen.instruction_set.allowed-positions</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set.arm">attributes.codegen.instruction_set.arm</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set.behavior">attributes.codegen.instruction_set.behavior</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set.syntax">attributes.codegen.instruction_set.syntax</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.instruction_set.target-limits">attributes.codegen.instruction_set.target-limits</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.no_builtins">attributes.codegen.no_builtins</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature">attributes.codegen.target_feature</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.aarch64">attributes.codegen.target_feature.aarch64</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.allowed-positions">attributes.codegen.target_feature.allowed-positions</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.arch">attributes.codegen.target_feature.arch</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.availability">attributes.codegen.target_feature.availability</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.closures">attributes.codegen.target_feature.closures</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.fn-traits">attributes.codegen.target_feature.fn-traits</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.info">attributes.codegen.target_feature.info</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.inline">attributes.codegen.target_feature.inline</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.intro">attributes.codegen.target_feature.intro</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.remark-cfg">attributes.codegen.target_feature.remark-cfg</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.remark-rt">attributes.codegen.target_feature.remark-rt</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.riscv">attributes.codegen.target_feature.riscv</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.safety-restrictions">attributes.codegen.target_feature.safety-restrictions</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.target-ub">attributes.codegen.target_feature.target-ub</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.wasm">attributes.codegen.target_feature.wasm</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.target_feature.x86">attributes.codegen.target_feature.x86</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller">attributes.codegen.track_caller</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.allowed-positions">attributes.codegen.track_caller.allowed-positions</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.behavior">attributes.codegen.track_caller.behavior</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.decay">attributes.codegen.track_caller.decay</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.extern">attributes.codegen.track_caller.extern</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.hint">attributes.codegen.track_caller.hint</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.limits">attributes.codegen.track_caller.limits</a></li>
<li><a href="attributes/codegen.html#r-attributes.codegen.track_caller.traits">attributes.codegen.track_caller.traits</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/limits.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.5. Limits</a></td>
<td>7</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(35);">7</a>
<div id="uncovered-35" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/limits.html#r-attributes.limits">attributes.limits</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.recursion_limit">attributes.limits.recursion_limit</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.recursion_limit.intro">attributes.limits.recursion_limit.intro</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.recursion_limit.syntax">attributes.limits.recursion_limit.syntax</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.type_length_limit">attributes.limits.type_length_limit</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.type_length_limit.intro">attributes.limits.type_length_limit.intro</a></li>
<li><a href="attributes/limits.html#r-attributes.limits.type_length_limit.syntax">attributes.limits.type_length_limit.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/type_system.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.6. Type System</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(36);">9</a>
<div id="uncovered-36" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/type_system.html#r-attributes.type-system">attributes.type-system</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive">attributes.type-system.non_exhaustive</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.allowed-positions">attributes.type-system.non_exhaustive.allowed-positions</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.construction">attributes.type-system.non_exhaustive.construction</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.external-crate">attributes.type-system.non_exhaustive.external-crate</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.intro">attributes.type-system.non_exhaustive.intro</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.match">attributes.type-system.non_exhaustive.match</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.same-crate">attributes.type-system.non_exhaustive.same-crate</a></li>
<li><a href="attributes/type_system.html#r-attributes.type-system.non_exhaustive.syntax">attributes.type-system.non_exhaustive.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="attributes/debugger.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.7. Debugger</a></td>
<td>16</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(37);">16</a>
<div id="uncovered-37" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="attributes/debugger.html#r-attributes.debugger">attributes.debugger</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo">attributes.debugger.collapse_debuginfo</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.default">attributes.debugger.collapse_debuginfo.default</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.intro">attributes.debugger.collapse_debuginfo.intro</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.options">attributes.debugger.collapse_debuginfo.options</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.collapse_debuginfo.syntax">attributes.debugger.collapse_debuginfo.syntax</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer">attributes.debugger.debugger_visualizer</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb">attributes.debugger.debugger_visualizer.gdb</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb.path">attributes.debugger.debugger_visualizer.gdb.path</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.gdb.pretty">attributes.debugger.debugger_visualizer.gdb.pretty</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.intro">attributes.debugger.debugger_visualizer.intro</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis">attributes.debugger.debugger_visualizer.natvis</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.intro">attributes.debugger.debugger_visualizer.natvis.intro</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.msvc">attributes.debugger.debugger_visualizer.natvis.msvc</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.natvis.path">attributes.debugger.debugger_visualizer.natvis.path</a></li>
<li><a href="attributes/debugger.html#r-attributes.debugger.debugger_visualizer.syntax">attributes.debugger.debugger_visualizer.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="statements-and-expressions.html">8. Statements and expressions</a></td>
<td>1</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(38);">1</a>
<div id="uncovered-38" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="statements-and-expressions.html#r-stmt-expr">stmt-expr</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="statements.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1. Statements</a></td>
<td>23</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(39);">23</a>
<div id="uncovered-39" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="statements.html#r-statement">statement</a></li>
<li><a href="statements.html#r-statement.attribute">statement.attribute</a></li>
<li><a href="statements.html#r-statement.decl">statement.decl</a></li>
<li><a href="statements.html#r-statement.expr">statement.expr</a></li>
<li><a href="statements.html#r-statement.expr.constraint-block">statement.expr.constraint-block</a></li>
<li><a href="statements.html#r-statement.expr.intro">statement.expr.intro</a></li>
<li><a href="statements.html#r-statement.expr.restriction-semicolon">statement.expr.restriction-semicolon</a></li>
<li><a href="statements.html#r-statement.expr.syntax">statement.expr.syntax</a></li>
<li><a href="statements.html#r-statement.intro">statement.intro</a></li>
<li><a href="statements.html#r-statement.item">statement.item</a></li>
<li><a href="statements.html#r-statement.item.associated-scope">statement.item.associated-scope</a></li>
<li><a href="statements.html#r-statement.item.intro">statement.item.intro</a></li>
<li><a href="statements.html#r-statement.item.outer-generics">statement.item.outer-generics</a></li>
<li><a href="statements.html#r-statement.item.scope">statement.item.scope</a></li>
<li><a href="statements.html#r-statement.kind">statement.kind</a></li>
<li><a href="statements.html#r-statement.let">statement.let</a></li>
<li><a href="statements.html#r-statement.let.behavior">statement.let.behavior</a></li>
<li><a href="statements.html#r-statement.let.constraint">statement.let.constraint</a></li>
<li><a href="statements.html#r-statement.let.inference">statement.let.inference</a></li>
<li><a href="statements.html#r-statement.let.intro">statement.let.intro</a></li>
<li><a href="statements.html#r-statement.let.scope">statement.let.scope</a></li>
<li><a href="statements.html#r-statement.let.syntax">statement.let.syntax</a></li>
<li><a href="statements.html#r-statement.syntax">statement.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2. Expressions</a></td>
<td>38</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(40);">38</a>
<div id="uncovered-40" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions.html#r-expr">expr</a></li>
<li><a href="expressions.html#r-expr.attr">expr.attr</a></li>
<li><a href="expressions.html#r-expr.attr.never-before">expr.attr.never-before</a></li>
<li><a href="expressions.html#r-expr.attr.restriction">expr.attr.restriction</a></li>
<li><a href="expressions.html#r-expr.behavior">expr.behavior</a></li>
<li><a href="expressions.html#r-expr.evaluation">expr.evaluation</a></li>
<li><a href="expressions.html#r-expr.implicit-borrow">expr.implicit-borrow</a></li>
<li><a href="expressions.html#r-expr.implicit-borrow-intro">expr.implicit-borrow-intro</a></li>
<li><a href="expressions.html#r-expr.implicit-borrow.application">expr.implicit-borrow.application</a></li>
<li><a href="expressions.html#r-expr.intro">expr.intro</a></li>
<li><a href="expressions.html#r-expr.move">expr.move</a></li>
<li><a href="expressions.html#r-expr.move.copy">expr.move.copy</a></li>
<li><a href="expressions.html#r-expr.move.deinitialization">expr.move.deinitialization</a></li>
<li><a href="expressions.html#r-expr.move.intro">expr.move.intro</a></li>
<li><a href="expressions.html#r-expr.move.movable-place">expr.move.movable-place</a></li>
<li><a href="expressions.html#r-expr.move.place-invalid">expr.move.place-invalid</a></li>
<li><a href="expressions.html#r-expr.move.requires-sized">expr.move.requires-sized</a></li>
<li><a href="expressions.html#r-expr.mut">expr.mut</a></li>
<li><a href="expressions.html#r-expr.mut.intro">expr.mut.intro</a></li>
<li><a href="expressions.html#r-expr.mut.valid-places">expr.mut.valid-places</a></li>
<li><a href="expressions.html#r-expr.operand-order">expr.operand-order</a></li>
<li><a href="expressions.html#r-expr.operand-order.default">expr.operand-order.default</a></li>
<li><a href="expressions.html#r-expr.operand-order.operands-before-primary">expr.operand-order.operands-before-primary</a></li>
<li><a href="expressions.html#r-expr.operands">expr.operands</a></li>
<li><a href="expressions.html#r-expr.overload">expr.overload</a></li>
<li><a href="expressions.html#r-expr.place-value">expr.place-value</a></li>
<li><a href="expressions.html#r-expr.place-value.assignee">expr.place-value.assignee</a></li>
<li><a href="expressions.html#r-expr.place-value.intro">expr.place-value.intro</a></li>
<li><a href="expressions.html#r-expr.place-value.parenthesis">expr.place-value.parenthesis</a></li>
<li><a href="expressions.html#r-expr.place-value.place-context">expr.place-value.place-context</a></li>
<li><a href="expressions.html#r-expr.place-value.place-expr-kinds">expr.place-value.place-expr-kinds</a></li>
<li><a href="expressions.html#r-expr.place-value.place-memory-location">expr.place-value.place-memory-location</a></li>
<li><a href="expressions.html#r-expr.place-value.value-expr-kinds">expr.place-value.value-expr-kinds</a></li>
<li><a href="expressions.html#r-expr.place-value.value-result">expr.place-value.value-result</a></li>
<li><a href="expressions.html#r-expr.precedence">expr.precedence</a></li>
<li><a href="expressions.html#r-expr.structure">expr.structure</a></li>
<li><a href="expressions.html#r-expr.syntax">expr.syntax</a></li>
<li><a href="expressions.html#r-expr.temporary">expr.temporary</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/literal-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.1. Literal expressions</a></td>
<td>87</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(41);">87</a>
<div id="uncovered-41" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/literal-expr.html#r-expr.literal">expr.literal</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.bool">expr.literal.bool</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.bool.intro">expr.literal.bool.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.bool.result">expr.literal.bool.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char">expr.literal.byte-char</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.escape">expr.literal.byte-char.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.intro">expr.literal.byte-char.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.literal">expr.literal.byte-char.literal</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.literal-content">expr.literal.byte-char.literal-content</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.no-suffix">expr.literal.byte-char.no-suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.represented">expr.literal.byte-char.represented</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.result">expr.literal.byte-char.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-char.single">expr.literal.byte-char.single</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string">expr.literal.byte-string</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.escape">expr.literal.byte-string.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.intro">expr.literal.byte-string.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.literal-content">expr.literal.byte-string.literal-content</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.no-suffix">expr.literal.byte-string.no-suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.raw">expr.literal.byte-string.raw</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.represented">expr.literal.byte-string.represented</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.result">expr.literal.byte-string.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.byte-string.type">expr.literal.byte-string.type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string">expr.literal.c-string</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.escape">expr.literal.c-string.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.intro">expr.literal.c-string.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.literal-content">expr.literal.c-string.literal-content</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.no-suffix">expr.literal.c-string.no-suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.raw">expr.literal.c-string.raw</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.represented">expr.literal.c-string.represented</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.result">expr.literal.c-string.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.c-string.type">expr.literal.c-string.type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char">expr.literal.char</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.escape">expr.literal.char.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.intro">expr.literal.char.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.literal-content">expr.literal.char.literal-content</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.no-suffix">expr.literal.char.no-suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.represented">expr.literal.char.represented</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.result">expr.literal.char.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.single">expr.literal.char.single</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.char.type">expr.literal.char.type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.const-expr">expr.literal.const-expr</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.continuation">expr.literal.continuation</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape">expr.literal.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.hex-ascii">expr.literal.escape.hex-ascii</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.hex-octet">expr.literal.escape.hex-octet</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.intro">expr.literal.escape.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.sequence">expr.literal.escape.sequence</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.simple">expr.literal.escape.simple</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.escape.unicode">expr.literal.escape.unicode</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float">expr.literal.float</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.infer">expr.literal.float.infer</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.inference-default">expr.literal.float.inference-default</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.inference-error">expr.literal.float.inference-error</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.inference-unique-type">expr.literal.float.inference-unique-type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.intro">expr.literal.float.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.result">expr.literal.float.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.separators-stripped">expr.literal.float.separators-stripped</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.suffix">expr.literal.float.suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.type-suffix-stripped">expr.literal.float.type-suffix-stripped</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.float.value">expr.literal.float.value</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int">expr.literal.int</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.cast">expr.literal.int.cast</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.infer">expr.literal.int.infer</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.inference-default">expr.literal.int.inference-default</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.inference-error">expr.literal.int.inference-error</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.inference-unique-type">expr.literal.int.inference-unique-type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.intro">expr.literal.int.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.radix">expr.literal.int.radix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.radix-prefix-stripped">expr.literal.int.radix-prefix-stripped</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.representation">expr.literal.int.representation</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.separators-stripped">expr.literal.int.separators-stripped</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.suffix">expr.literal.int.suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.type-suffix-stripped">expr.literal.int.type-suffix-stripped</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.int.u128-value">expr.literal.int.u128-value</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.intro">expr.literal.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.literal-token">expr.literal.literal-token</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string">expr.literal.string</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string-representation">expr.literal.string-representation</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.escape">expr.literal.string.escape</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.intro">expr.literal.string.intro</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.literal-content">expr.literal.string.literal-content</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.no-suffix">expr.literal.string.no-suffix</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.raw">expr.literal.string.raw</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.represented">expr.literal.string.represented</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.result">expr.literal.string.result</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.string.type">expr.literal.string.type</a></li>
<li><a href="expressions/literal-expr.html#r-expr.literal.syntax">expr.literal.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/path-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.2. Path expressions</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(42);">6</a>
<div id="uncovered-42" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/path-expr.html#r-expr.path">expr.path</a></li>
<li><a href="expressions/path-expr.html#r-expr.path.const">expr.path.const</a></li>
<li><a href="expressions/path-expr.html#r-expr.path.intro">expr.path.intro</a></li>
<li><a href="expressions/path-expr.html#r-expr.path.place">expr.path.place</a></li>
<li><a href="expressions/path-expr.html#r-expr.path.safety">expr.path.safety</a></li>
<li><a href="expressions/path-expr.html#r-expr.path.syntax">expr.path.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/block-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.3. Block expressions</a></td>
<td>37</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(43);">37</a>
<div id="uncovered-43" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/block-expr.html#r-expr.block">expr.block</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async">expr.block.async</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.anonymous-type">expr.block.async.anonymous-type</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.capture">expr.block.async.capture</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.context">expr.block.async.context</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.function">expr.block.async.function</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.function.control-flow">expr.block.async.function.control-flow</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.function.intro">expr.block.async.function.intro</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.function.return-try">expr.block.async.function.return-try</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.future">expr.block.async.future</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.future-result">expr.block.async.future-result</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.intro">expr.block.async.intro</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.layout-unspecified">expr.block.async.layout-unspecified</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.async.syntax">expr.block.async.syntax</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.attributes">expr.block.attributes</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.attributes.inner-attributes">expr.block.attributes.inner-attributes</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.attributes.valid">expr.block.attributes.valid</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const">expr.block.const</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.context">expr.block.const.context</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.evaluation">expr.block.const.evaluation</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.generic-params">expr.block.const.generic-params</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.intro">expr.block.const.intro</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.not-executed">expr.block.const.not-executed</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.const.syntax">expr.block.const.syntax</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.evaluation">expr.block.evaluation</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.inner-attributes">expr.block.inner-attributes</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.intro">expr.block.intro</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.label">expr.block.label</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.namepsace">expr.block.namepsace</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.null-statement">expr.block.null-statement</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.result">expr.block.result</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.sequential-evaluation">expr.block.sequential-evaluation</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.statements">expr.block.statements</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.syntax">expr.block.syntax</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.type">expr.block.type</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.unsafe">expr.block.unsafe</a></li>
<li><a href="expressions/block-expr.html#r-expr.block.value">expr.block.value</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/operator-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.4. Operator expressions</a></td>
<td>112</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(44);">112</a>
<div id="uncovered-44" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/operator-expr.html#r-expr.arith-logic">expr.arith-logic</a></li>
<li><a href="expressions/operator-expr.html#r-expr.arith-logic.behavior">expr.arith-logic.behavior</a></li>
<li><a href="expressions/operator-expr.html#r-expr.arith-logic.intro">expr.arith-logic.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.arith-logic.syntax">expr.arith-logic.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as">expr.as</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.bool-char-as-int">expr.as.bool-char-as-int</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.coercions">expr.as.coercions</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.enum">expr.as.enum</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.enum.discriminant">expr.as.enum.discriminant</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.enum.no-drop">expr.as.enum.no-drop</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.int-as-pointer">expr.as.int-as-pointer</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.intro">expr.as.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric">expr.as.numeric</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.float-as-int">expr.as.numeric.float-as-int</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.float-narrowing">expr.as.numeric.float-narrowing</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.float-widening">expr.as.numeric.float-widening</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.int-as-float">expr.as.numeric.int-as-float</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.int-extension">expr.as.numeric.int-extension</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.int-same-size">expr.as.numeric.int-same-size</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.numeric.int-truncation">expr.as.numeric.int-truncation</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer">expr.as.pointer</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer-as-int">expr.as.pointer-as-int</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer.behavior">expr.as.pointer.behavior</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer.discard-metadata">expr.as.pointer.discard-metadata</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer.sized">expr.as.pointer.sized</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.pointer.unsized">expr.as.pointer.unsized</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.result">expr.as.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.syntax">expr.as.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.as.u8-as-char">expr.as.u8-as-char</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign">expr.assign</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.assignee">expr.assign.assignee</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.basic">expr.assign.basic</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.behavior">expr.assign.behavior</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.behavior-basic">expr.assign.behavior-basic</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.behavior-destructring">expr.assign.behavior-destructring</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructring-order">expr.assign.destructring-order</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure">expr.assign.destructure</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.assignee">expr.assign.destructure.assignee</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.default-binding">expr.assign.destructure.default-binding</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.discard-value">expr.assign.destructure.discard-value</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.intro">expr.assign.destructure.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.irrefutable">expr.assign.destructure.irrefutable</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.destructure.repeat-ident">expr.assign.destructure.repeat-ident</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.drop-target">expr.assign.drop-target</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.evaluation-order">expr.assign.evaluation-order</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.intro">expr.assign.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.result">expr.assign.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.assign.syntax">expr.assign.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.bool-logic">expr.bool-logic</a></li>
<li><a href="expressions/operator-expr.html#r-expr.bool-logic.conditional-evaluation">expr.bool-logic.conditional-evaluation</a></li>
<li><a href="expressions/operator-expr.html#r-expr.bool-logic.intro">expr.bool-logic.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.bool-logic.syntax">expr.bool-logic.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.and-and-syntax">expr.borrow.and-and-syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.raw">expr.borrow.raw</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.raw.intro">expr.borrow.raw.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.raw.invalid-ref">expr.borrow.raw.invalid-ref</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.raw.place">expr.borrow.raw.place</a></li>
<li><a href="expressions/operator-expr.html#r-expr.borrow.raw.result">expr.borrow.raw.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp">expr.cmp</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.behavior">expr.cmp.behavior</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.intro">expr.cmp.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.paren-chaining">expr.cmp.paren-chaining</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.place">expr.cmp.place</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.syntax">expr.cmp.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.cmp.trait">expr.cmp.trait</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign">expr.compound-assign</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.intro">expr.compound-assign.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.no-value">expr.compound-assign.no-value</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.operand-order">expr.compound-assign.operand-order</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.place">expr.compound-assign.place</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.primitive-order">expr.compound-assign.primitive-order</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.result">expr.compound-assign.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.syntax">expr.compound-assign.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.compound-assign.trait">expr.compound-assign.trait</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref">expr.deref</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.intro">expr.deref.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.mut">expr.deref.mut</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.result">expr.deref.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.safety">expr.deref.safety</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.syntax">expr.deref.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.deref.traits">expr.deref.traits</a></li>
<li><a href="expressions/operator-expr.html#r-expr.negate">expr.negate</a></li>
<li><a href="expressions/operator-expr.html#r-expr.negate.intro">expr.negate.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.negate.results">expr.negate.results</a></li>
<li><a href="expressions/operator-expr.html#r-expr.negate.syntax">expr.negate.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator">expr.operator</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow">expr.operator.borrow</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow.intro">expr.operator.borrow.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow.lifetime">expr.operator.borrow.lifetime</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow.mut">expr.operator.borrow.mut</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow.result">expr.operator.borrow.result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.borrow.temporary">expr.operator.borrow.temporary</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow">expr.operator.int-overflow</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow.binary-arith">expr.operator.int-overflow.binary-arith</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow.div">expr.operator.int-overflow.div</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow.intro">expr.operator.int-overflow.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow.shift">expr.operator.int-overflow.shift</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.int-overflow.unary-neg">expr.operator.int-overflow.unary-neg</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.intro">expr.operator.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.syntax">expr.operator.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.operator.trait">expr.operator.trait</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try">expr.try</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.behavior-std-option">expr.try.behavior-std-option</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.behavior-std-result">expr.try.behavior-std-result</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.effects-err">expr.try.effects-err</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.effects-none">expr.try.effects-none</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.intro">expr.try.intro</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.restricted-types">expr.try.restricted-types</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.result-ok">expr.try.result-ok</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.result-some">expr.try.result-some</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.syntax">expr.try.syntax</a></li>
<li><a href="expressions/operator-expr.html#r-expr.try.trait">expr.try.trait</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/grouped-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.5. Grouped expressions</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(45);">6</a>
<div id="uncovered-45" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/grouped-expr.html#r-expr.paren">expr.paren</a></li>
<li><a href="expressions/grouped-expr.html#r-expr.paren.evaluation">expr.paren.evaluation</a></li>
<li><a href="expressions/grouped-expr.html#r-expr.paren.intro">expr.paren.intro</a></li>
<li><a href="expressions/grouped-expr.html#r-expr.paren.override-precedence">expr.paren.override-precedence</a></li>
<li><a href="expressions/grouped-expr.html#r-expr.paren.place-or-value">expr.paren.place-or-value</a></li>
<li><a href="expressions/grouped-expr.html#r-expr.paren.syntax">expr.paren.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/array-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.6. Array and index expressions</a></td>
<td>21</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(46);">21</a>
<div id="uncovered-46" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/array-expr.html#r-expr.array">expr.array</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.array">expr.array.array</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.array-behavior">expr.array.array-behavior</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.array-syntax">expr.array.array-syntax</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.constructor">expr.array.constructor</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index">expr.array.index</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index.array">expr.array.index.array</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index.const">expr.array.index.const</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index.trait">expr.array.index.trait</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index.trait-impl">expr.array.index.trait-impl</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.index.zero-index">expr.array.index.zero-index</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.length-operand">expr.array.length-operand</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.length-restriction">expr.array.length-restriction</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat">expr.array.repeat</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-behavior">expr.array.repeat-behavior</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-const-item">expr.array.repeat-const-item</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-copy">expr.array.repeat-copy</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-evaluation-zero">expr.array.repeat-evaluation-zero</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-non-const">expr.array.repeat-non-const</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.repeat-operand">expr.array.repeat-operand</a></li>
<li><a href="expressions/array-expr.html#r-expr.array.syntax">expr.array.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/tuple-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.7. Tuple and index expressions</a></td>
<td>16</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(47);">16</a>
<div id="uncovered-47" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/tuple-expr.html#r-expr.tuple">expr.tuple</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index">expr.tuple-index</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.index-name-operand">expr.tuple-index.index-name-operand</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.index-syntax">expr.tuple-index.index-syntax</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.intro">expr.tuple-index.intro</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.required-type">expr.tuple-index.required-type</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.result">expr.tuple-index.result</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple-index.syntax">expr.tuple-index.syntax</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.fields">expr.tuple.fields</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.intro">expr.tuple.intro</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.result">expr.tuple.result</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.syntax">expr.tuple.syntax</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.type">expr.tuple.type</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.unary-tuple-restriction">expr.tuple.unary-tuple-restriction</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.unit">expr.tuple.unit</a></li>
<li><a href="expressions/tuple-expr.html#r-expr.tuple.value">expr.tuple.value</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/struct-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.8. Struct expressions</a></td>
<td>16</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(48);">16</a>
<div id="uncovered-48" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/struct-expr.html#r-expr.struct">expr.struct</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.brace-restricted-positions">expr.struct.brace-restricted-positions</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.field">expr.struct.field</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.field.intro">expr.struct.field.intro</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.field.named">expr.struct.field.named</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.field.union-constraint">expr.struct.field.union-constraint</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.intro">expr.struct.intro</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.syntax">expr.struct.syntax</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.tuple">expr.struct.tuple</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.tuple-field">expr.struct.tuple-field</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.unit">expr.struct.unit</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.update">expr.struct.update</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.update.base-same-type">expr.struct.update.base-same-type</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.update.fields">expr.struct.update.fields</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.update.intro">expr.struct.update.intro</a></li>
<li><a href="expressions/struct-expr.html#r-expr.struct.update.visibility-constraint">expr.struct.update.visibility-constraint</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/call-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.9. Call expressions</a></td>
<td>11</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(49);">11</a>
<div id="uncovered-49" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/call-expr.html#r-expr.call">expr.call</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.autoref-deref">expr.call.autoref-deref</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.convergence">expr.call.convergence</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.desugar">expr.call.desugar</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.desugar.ambiguity">expr.call.desugar.ambiguity</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.desugar.explicit-path">expr.call.desugar.explicit-path</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.desugar.fully-qualified">expr.call.desugar.fully-qualified</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.desugar.limits">expr.call.desugar.limits</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.intro">expr.call.intro</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.syntax">expr.call.syntax</a></li>
<li><a href="expressions/call-expr.html#r-expr.call.trait">expr.call.trait</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/method-call-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.10. Method call expressions</a></td>
<td>11</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(50);">11</a>
<div id="uncovered-50" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/method-call-expr.html#r-expr.method">expr.method</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.ambiguous-search">expr.method.ambiguous-search</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.ambiguous-target">expr.method.ambiguous-target</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.autoref-deref">expr.method.autoref-deref</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.candidate-receivers">expr.method.candidate-receivers</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.candidate-receivers-refs">expr.method.candidate-receivers-refs</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.candidate-search">expr.method.candidate-search</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.intro">expr.method.intro</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.receiver-constraints">expr.method.receiver-constraints</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.syntax">expr.method.syntax</a></li>
<li><a href="expressions/method-call-expr.html#r-expr.method.target">expr.method.target</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/field-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.11. Field access expressions</a></td>
<td>8</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(51);">8</a>
<div id="uncovered-51" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/field-expr.html#r-expr.field">expr.field</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.autoref-deref">expr.field.autoref-deref</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.borrow">expr.field.borrow</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.form">expr.field.form</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.intro">expr.field.intro</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.mut">expr.field.mut</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.not-method-call">expr.field.not-method-call</a></li>
<li><a href="expressions/field-expr.html#r-expr.field.syntax">expr.field.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/closure-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.12. Closure expressions</a></td>
<td>17</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(52);">17</a>
<div id="uncovered-52" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/closure-expr.html#r-expr.closure">expr.closure</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.async">expr.closure.async</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.async.edition2018">expr.closure.async.edition2018</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.async.future">expr.closure.async.future</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.async.intro">expr.closure.async.intro</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.capture-inference">expr.closure.capture-inference</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.capture-move">expr.closure.capture-move</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.capture-mut-ref">expr.closure.capture-mut-ref</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.captures">expr.closure.captures</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.explicit-type-body">expr.closure.explicit-type-body</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.intro">expr.closure.intro</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.param-attributes">expr.closure.param-attributes</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.param-type">expr.closure.param-type</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.parameter-restriction">expr.closure.parameter-restriction</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.syntax">expr.closure.syntax</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.trait-impl">expr.closure.trait-impl</a></li>
<li><a href="expressions/closure-expr.html#r-expr.closure.unique-type">expr.closure.unique-type</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/loop-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.13. Loop expressions</a></td>
<td>52</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(53);">52</a>
<div id="uncovered-53" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/loop-expr.html#r-expr.loop">expr.loop</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.block-labels">expr.loop.block-labels</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.block-labels.break">expr.loop.block-labels.break</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.block-labels.intro">expr.loop.block-labels.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.block-labels.label-required">expr.loop.block-labels.label-required</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break">expr.loop.break</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break-label">expr.loop.break-label</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break-value">expr.loop.break-value</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break-value.intro">expr.loop.break-value.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break-value.loop">expr.loop.break-value.loop</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break.intro">expr.loop.break.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break.label">expr.loop.break.label</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break.syntax">expr.loop.break.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.break.value">expr.loop.break.value</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue">expr.loop.continue</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue-label">expr.loop.continue-label</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.for">expr.loop.continue.for</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.in-loop-only">expr.loop.continue.in-loop-only</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.intro">expr.loop.continue.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.label">expr.loop.continue.label</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.syntax">expr.loop.continue.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.continue.while">expr.loop.continue.while</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.explicit-result">expr.loop.explicit-result</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for">expr.loop.for</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for.condition">expr.loop.for.condition</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for.desugar">expr.loop.for.desugar</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for.intro">expr.loop.for.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for.lang-items">expr.loop.for.lang-items</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.for.syntax">expr.loop.for.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.infinite">expr.loop.infinite</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.infinite.break">expr.loop.infinite.break</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.infinite.diverging">expr.loop.infinite.diverging</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.infinite.intro">expr.loop.infinite.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.infinite.syntax">expr.loop.infinite.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.intro">expr.loop.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.label">expr.loop.label</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.label.control-flow">expr.loop.label.control-flow</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.label.intro">expr.loop.label.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.label.ref">expr.loop.label.ref</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.label.syntax">expr.loop.label.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.syntax">expr.loop.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while">expr.loop.while</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.condition">expr.loop.while.condition</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.intro">expr.loop.while.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let">expr.loop.while.let</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.condition">expr.loop.while.let.condition</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.desugar">expr.loop.while.let.desugar</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.intro">expr.loop.while.let.intro</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.lazy-bool">expr.loop.while.let.lazy-bool</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.or-pattern">expr.loop.while.let.or-pattern</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.let.syntax">expr.loop.while.let.syntax</a></li>
<li><a href="expressions/loop-expr.html#r-expr.loop.while.syntax">expr.loop.while.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/range-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.14. Range expressions</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(54);">5</a>
<div id="uncovered-54" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/range-expr.html#r-expr.range">expr.range</a></li>
<li><a href="expressions/range-expr.html#r-expr.range.behavior">expr.range.behavior</a></li>
<li><a href="expressions/range-expr.html#r-expr.range.equivalence">expr.range.equivalence</a></li>
<li><a href="expressions/range-expr.html#r-expr.range.for">expr.range.for</a></li>
<li><a href="expressions/range-expr.html#r-expr.range.syntax">expr.range.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/if-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.15. If and if let expressions</a></td>
<td>19</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(55);">19</a>
<div id="uncovered-55" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/if-expr.html#r-expr.if">expr.if</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.condition-bool">expr.if.condition-bool</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.condition-true">expr.if.condition-true</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.else">expr.if.else</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.else-if">expr.if.else-if</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.intro">expr.if.intro</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let">expr.if.let</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.desugaring">expr.if.let.desugaring</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.else">expr.if.let.else</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.else-if">expr.if.let.else-if</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.intro">expr.if.let.intro</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.lazy-bool">expr.if.let.lazy-bool</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.or-pattern">expr.if.let.or-pattern</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.pattern">expr.if.let.pattern</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.result">expr.if.let.result</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.let.syntax">expr.if.let.syntax</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.result">expr.if.result</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.syntax">expr.if.syntax</a></li>
<li><a href="expressions/if-expr.html#r-expr.if.type">expr.if.type</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/match-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.16. Match expressions</a></td>
<td>25</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(56);">25</a>
<div id="uncovered-56" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/match-expr.html#r-expr.match">expr.match</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.attributes">expr.match.attributes</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.attributes.inner">expr.match.attributes.inner</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.attributes.outer">expr.match.attributes.outer</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.binding-restriction">expr.match.binding-restriction</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard">expr.match.guard</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.behavior">expr.match.guard.behavior</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.bound-variables">expr.match.guard.bound-variables</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.intro">expr.match.guard.intro</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.next">expr.match.guard.next</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.no-mutation">expr.match.guard.no-mutation</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.shared-ref">expr.match.guard.shared-ref</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.type">expr.match.guard.type</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.guard.value">expr.match.guard.value</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.intro">expr.match.intro</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.or-pattern">expr.match.or-pattern</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.or-patterns-restriction">expr.match.or-patterns-restriction</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.pattern-var-binding">expr.match.pattern-var-binding</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.pattern-vars">expr.match.pattern-vars</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.scrutinee">expr.match.scrutinee</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.scrutinee-behavior">expr.match.scrutinee-behavior</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.scrutinee-constraint">expr.match.scrutinee-constraint</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.scrutinee-place">expr.match.scrutinee-place</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.scrutinee-value">expr.match.scrutinee-value</a></li>
<li><a href="expressions/match-expr.html#r-expr.match.syntax">expr.match.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/return-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.17. Return expressions</a></td>
<td>4</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(57);">4</a>
<div id="uncovered-57" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/return-expr.html#r-expr.return">expr.return</a></li>
<li><a href="expressions/return-expr.html#r-expr.return.behavior">expr.return.behavior</a></li>
<li><a href="expressions/return-expr.html#r-expr.return.intro">expr.return.intro</a></li>
<li><a href="expressions/return-expr.html#r-expr.return.syntax">expr.return.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/await-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.18. Await expressions</a></td>
<td>8</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(58);">8</a>
<div id="uncovered-58" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/await-expr.html#r-expr.await">expr.await</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.allowed-positions">expr.await.allowed-positions</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.construct">expr.await.construct</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.desugar">expr.await.desugar</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.effects">expr.await.effects</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.intro">expr.await.intro</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.syntax">expr.await.syntax</a></li>
<li><a href="expressions/await-expr.html#r-expr.await.task">expr.await.task</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="expressions/underscore-expr.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2.19. Underscore expressions</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(59);">5</a>
<div id="uncovered-59" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="expressions/underscore-expr.html#r-expr.placeholder">expr.placeholder</a></li>
<li><a href="expressions/underscore-expr.html#r-expr.placeholder.intro">expr.placeholder.intro</a></li>
<li><a href="expressions/underscore-expr.html#r-expr.placeholder.lhs-assignment-only">expr.placeholder.lhs-assignment-only</a></li>
<li><a href="expressions/underscore-expr.html#r-expr.placeholder.pattern">expr.placeholder.pattern</a></li>
<li><a href="expressions/underscore-expr.html#r-expr.placeholder.syntax">expr.placeholder.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="patterns.html">9. Patterns</a></td>
<td>137</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(60);">137</a>
<div id="uncovered-60" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="patterns.html#r-patterns">patterns</a></li>
<li><a href="patterns.html#r-patterns.behavior">patterns.behavior</a></li>
<li><a href="patterns.html#r-patterns.behavior.nested-or-patterns">patterns.behavior.nested-or-patterns</a></li>
<li><a href="patterns.html#r-patterns.const">patterns.const</a></li>
<li><a href="patterns.html#r-patterns.const.aggregate">patterns.const.aggregate</a></li>
<li><a href="patterns.html#r-patterns.const.builtin-aggregate">patterns.const.builtin-aggregate</a></li>
<li><a href="patterns.html#r-patterns.const.exhaustive">patterns.const.exhaustive</a></li>
<li><a href="patterns.html#r-patterns.const.float">patterns.const.float</a></li>
<li><a href="patterns.html#r-patterns.const.generic">patterns.const.generic</a></li>
<li><a href="patterns.html#r-patterns.const.partial-eq">patterns.const.partial-eq</a></li>
<li><a href="patterns.html#r-patterns.const.pointer">patterns.const.pointer</a></li>
<li><a href="patterns.html#r-patterns.const.primitive">patterns.const.primitive</a></li>
<li><a href="patterns.html#r-patterns.const.ref">patterns.const.ref</a></li>
<li><a href="patterns.html#r-patterns.const.structural-equality">patterns.const.structural-equality</a></li>
<li><a href="patterns.html#r-patterns.const.translation">patterns.const.translation</a></li>
<li><a href="patterns.html#r-patterns.constraints">patterns.constraints</a></li>
<li><a href="patterns.html#r-patterns.constraints.exhaustiveness-or-pattern">patterns.constraints.exhaustiveness-or-pattern</a></li>
<li><a href="patterns.html#r-patterns.constraints.match-type-check">patterns.constraints.match-type-check</a></li>
<li><a href="patterns.html#r-patterns.constraints.pattern">patterns.constraints.pattern</a></li>
<li><a href="patterns.html#r-patterns.destructure">patterns.destructure</a></li>
<li><a href="patterns.html#r-patterns.destructure.intro">patterns.destructure.intro</a></li>
<li><a href="patterns.html#r-patterns.destructure.named-field-shorthand">patterns.destructure.named-field-shorthand</a></li>
<li><a href="patterns.html#r-patterns.destructure.placeholder">patterns.destructure.placeholder</a></li>
<li><a href="patterns.html#r-patterns.for">patterns.for</a></li>
<li><a href="patterns.html#r-patterns.ident">patterns.ident</a></li>
<li><a href="patterns.html#r-patterns.ident.bare">patterns.ident.bare</a></li>
<li><a href="patterns.html#r-patterns.ident.binding">patterns.ident.binding</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.auto-deref">patterns.ident.binding.auto-deref</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.default-mode">patterns.ident.binding.default-mode</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.intro">patterns.ident.binding.intro</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.mixed">patterns.ident.binding.mixed</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.mode-limitations-binding">patterns.ident.binding.mode-limitations-binding</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.mode-limitations-reference">patterns.ident.binding.mode-limitations-reference</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.mode-limitations-reference.edition2024">patterns.ident.binding.mode-limitations-reference.edition2024</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.mode-limitations.edition2024">patterns.ident.binding.mode-limitations.edition2024</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.move">patterns.ident.binding.move</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.nested-references">patterns.ident.binding.nested-references</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.non-reference">patterns.ident.binding.non-reference</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.ref">patterns.ident.binding.ref</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.ref-mut">patterns.ident.binding.ref-mut</a></li>
<li><a href="patterns.html#r-patterns.ident.binding.top-down">patterns.ident.binding.top-down</a></li>
<li><a href="patterns.html#r-patterns.ident.constraint">patterns.ident.constraint</a></li>
<li><a href="patterns.html#r-patterns.ident.intro">patterns.ident.intro</a></li>
<li><a href="patterns.html#r-patterns.ident.move">patterns.ident.move</a></li>
<li><a href="patterns.html#r-patterns.ident.precedent">patterns.ident.precedent</a></li>
<li><a href="patterns.html#r-patterns.ident.ref">patterns.ident.ref</a></li>
<li><a href="patterns.html#r-patterns.ident.ref-ignored">patterns.ident.ref-ignored</a></li>
<li><a href="patterns.html#r-patterns.ident.refutable">patterns.ident.refutable</a></li>
<li><a href="patterns.html#r-patterns.ident.scope">patterns.ident.scope</a></li>
<li><a href="patterns.html#r-patterns.ident.scrutinized">patterns.ident.scrutinized</a></li>
<li><a href="patterns.html#r-patterns.ident.syntax">patterns.ident.syntax</a></li>
<li><a href="patterns.html#r-patterns.ident.unique">patterns.ident.unique</a></li>
<li><a href="patterns.html#r-patterns.if-let">patterns.if-let</a></li>
<li><a href="patterns.html#r-patterns.intro">patterns.intro</a></li>
<li><a href="patterns.html#r-patterns.let">patterns.let</a></li>
<li><a href="patterns.html#r-patterns.literal">patterns.literal</a></li>
<li><a href="patterns.html#r-patterns.literal.intro">patterns.literal.intro</a></li>
<li><a href="patterns.html#r-patterns.literal.refutable">patterns.literal.refutable</a></li>
<li><a href="patterns.html#r-patterns.literal.syntax">patterns.literal.syntax</a></li>
<li><a href="patterns.html#r-patterns.match">patterns.match</a></li>
<li><a href="patterns.html#r-patterns.or">patterns.or</a></li>
<li><a href="patterns.html#r-patterns.param">patterns.param</a></li>
<li><a href="patterns.html#r-patterns.paren">patterns.paren</a></li>
<li><a href="patterns.html#r-patterns.paren.intro">patterns.paren.intro</a></li>
<li><a href="patterns.html#r-patterns.paren.syntax">patterns.paren.syntax</a></li>
<li><a href="patterns.html#r-patterns.path">patterns.path</a></li>
<li><a href="patterns.html#r-patterns.path.intro">patterns.path.intro</a></li>
<li><a href="patterns.html#r-patterns.path.qualified">patterns.path.qualified</a></li>
<li><a href="patterns.html#r-patterns.path.refutable">patterns.path.refutable</a></li>
<li><a href="patterns.html#r-patterns.path.syntax">patterns.path.syntax</a></li>
<li><a href="patterns.html#r-patterns.path.unqualified">patterns.path.unqualified</a></li>
<li><a href="patterns.html#r-patterns.precedence">patterns.precedence</a></li>
<li><a href="patterns.html#r-patterns.range">patterns.range</a></li>
<li><a href="patterns.html#r-patterns.range.bound">patterns.range.bound</a></li>
<li><a href="patterns.html#r-patterns.range.closed">patterns.range.closed</a></li>
<li><a href="patterns.html#r-patterns.range.constraint-bound-path">patterns.range.constraint-bound-path</a></li>
<li><a href="patterns.html#r-patterns.range.constraint-less-than">patterns.range.constraint-less-than</a></li>
<li><a href="patterns.html#r-patterns.range.constraint-slice">patterns.range.constraint-slice</a></li>
<li><a href="patterns.html#r-patterns.range.edition2021">patterns.range.edition2021</a></li>
<li><a href="patterns.html#r-patterns.range.float-restriction">patterns.range.float-restriction</a></li>
<li><a href="patterns.html#r-patterns.range.intro">patterns.range.intro</a></li>
<li><a href="patterns.html#r-patterns.range.literal-value">patterns.range.literal-value</a></li>
<li><a href="patterns.html#r-patterns.range.lower-bound">patterns.range.lower-bound</a></li>
<li><a href="patterns.html#r-patterns.range.negation">patterns.range.negation</a></li>
<li><a href="patterns.html#r-patterns.range.open-above">patterns.range.open-above</a></li>
<li><a href="patterns.html#r-patterns.range.open-below">patterns.range.open-below</a></li>
<li><a href="patterns.html#r-patterns.range.path-value">patterns.range.path-value</a></li>
<li><a href="patterns.html#r-patterns.range.refutable">patterns.range.refutable</a></li>
<li><a href="patterns.html#r-patterns.range.refutable-char">patterns.range.refutable-char</a></li>
<li><a href="patterns.html#r-patterns.range.refutable-integer">patterns.range.refutable-integer</a></li>
<li><a href="patterns.html#r-patterns.range.syntax">patterns.range.syntax</a></li>
<li><a href="patterns.html#r-patterns.range.type">patterns.range.type</a></li>
<li><a href="patterns.html#r-patterns.range.upper-bound">patterns.range.upper-bound</a></li>
<li><a href="patterns.html#r-patterns.range.value">patterns.range.value</a></li>
<li><a href="patterns.html#r-patterns.ref">patterns.ref</a></li>
<li><a href="patterns.html#r-patterns.ref.intro">patterns.ref.intro</a></li>
<li><a href="patterns.html#r-patterns.ref.mut">patterns.ref.mut</a></li>
<li><a href="patterns.html#r-patterns.ref.ref-ref">patterns.ref.ref-ref</a></li>
<li><a href="patterns.html#r-patterns.ref.refutable">patterns.ref.refutable</a></li>
<li><a href="patterns.html#r-patterns.ref.syntax">patterns.ref.syntax</a></li>
<li><a href="patterns.html#r-patterns.refutable">patterns.refutable</a></li>
<li><a href="patterns.html#r-patterns.rest">patterns.rest</a></li>
<li><a href="patterns.html#r-patterns.rest.allowed-patterns">patterns.rest.allowed-patterns</a></li>
<li><a href="patterns.html#r-patterns.rest.intro">patterns.rest.intro</a></li>
<li><a href="patterns.html#r-patterns.rest.refutable">patterns.rest.refutable</a></li>
<li><a href="patterns.html#r-patterns.slice">patterns.slice</a></li>
<li><a href="patterns.html#r-patterns.slice.intro">patterns.slice.intro</a></li>
<li><a href="patterns.html#r-patterns.slice.refutable-array">patterns.slice.refutable-array</a></li>
<li><a href="patterns.html#r-patterns.slice.refutable-slice">patterns.slice.refutable-slice</a></li>
<li><a href="patterns.html#r-patterns.slice.restriction">patterns.slice.restriction</a></li>
<li><a href="patterns.html#r-patterns.slice.syntax">patterns.slice.syntax</a></li>
<li><a href="patterns.html#r-patterns.struct">patterns.struct</a></li>
<li><a href="patterns.html#r-patterns.struct.binding-shorthand">patterns.struct.binding-shorthand</a></li>
<li><a href="patterns.html#r-patterns.struct.constraint-struct">patterns.struct.constraint-struct</a></li>
<li><a href="patterns.html#r-patterns.struct.constraint-union">patterns.struct.constraint-union</a></li>
<li><a href="patterns.html#r-patterns.struct.ignore-rest">patterns.struct.ignore-rest</a></li>
<li><a href="patterns.html#r-patterns.struct.intro">patterns.struct.intro</a></li>
<li><a href="patterns.html#r-patterns.struct.refutable">patterns.struct.refutable</a></li>
<li><a href="patterns.html#r-patterns.struct.syntax">patterns.struct.syntax</a></li>
<li><a href="patterns.html#r-patterns.syntax">patterns.syntax</a></li>
<li><a href="patterns.html#r-patterns.tuple">patterns.tuple</a></li>
<li><a href="patterns.html#r-patterns.tuple-struct">patterns.tuple-struct</a></li>
<li><a href="patterns.html#r-patterns.tuple-struct.intro">patterns.tuple-struct.intro</a></li>
<li><a href="patterns.html#r-patterns.tuple-struct.refutable">patterns.tuple-struct.refutable</a></li>
<li><a href="patterns.html#r-patterns.tuple-struct.syntax">patterns.tuple-struct.syntax</a></li>
<li><a href="patterns.html#r-patterns.tuple.intro">patterns.tuple.intro</a></li>
<li><a href="patterns.html#r-patterns.tuple.refutable">patterns.tuple.refutable</a></li>
<li><a href="patterns.html#r-patterns.tuple.rest-syntax">patterns.tuple.rest-syntax</a></li>
<li><a href="patterns.html#r-patterns.tuple.syntax">patterns.tuple.syntax</a></li>
<li><a href="patterns.html#r-patterns.usage">patterns.usage</a></li>
<li><a href="patterns.html#r-patterns.while-let">patterns.while-let</a></li>
<li><a href="patterns.html#r-patterns.wildcard">patterns.wildcard</a></li>
<li><a href="patterns.html#r-patterns.wildcard.intro">patterns.wildcard.intro</a></li>
<li><a href="patterns.html#r-patterns.wildcard.no-binding">patterns.wildcard.no-binding</a></li>
<li><a href="patterns.html#r-patterns.wildcard.refutable">patterns.wildcard.refutable</a></li>
<li><a href="patterns.html#r-patterns.wildcard.struct-matcher">patterns.wildcard.struct-matcher</a></li>
<li><a href="patterns.html#r-patterns.wildcard.syntax">patterns.wildcard.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="type-system.html">10. Type system</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="types.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1. Types</a></td>
<td>22</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(62);">22</a>
<div id="uncovered-62" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types.html#r-type">type</a></li>
<li><a href="types.html#r-type.builtin">type.builtin</a></li>
<li><a href="types.html#r-type.intro">type.intro</a></li>
<li><a href="types.html#r-type.kinds">type.kinds</a></li>
<li><a href="types.html#r-type.name">type.name</a></li>
<li><a href="types.html#r-type.name.grouped">type.name.grouped</a></li>
<li><a href="types.html#r-type.name.inference">type.name.inference</a></li>
<li><a href="types.html#r-type.name.intro">type.name.intro</a></li>
<li><a href="types.html#r-type.name.macro-expansion">type.name.macro-expansion</a></li>
<li><a href="types.html#r-type.name.never">type.name.never</a></li>
<li><a href="types.html#r-type.name.parenthesized">type.name.parenthesized</a></li>
<li><a href="types.html#r-type.name.parenthesized.intro">type.name.parenthesized.intro</a></li>
<li><a href="types.html#r-type.name.parenthesized.syntax">type.name.parenthesized.syntax</a></li>
<li><a href="types.html#r-type.name.path">type.name.path</a></li>
<li><a href="types.html#r-type.name.pointer">type.name.pointer</a></li>
<li><a href="types.html#r-type.name.sequence">type.name.sequence</a></li>
<li><a href="types.html#r-type.name.syntax">type.name.syntax</a></li>
<li><a href="types.html#r-type.name.trait">type.name.trait</a></li>
<li><a href="types.html#r-type.recursive">type.recursive</a></li>
<li><a href="types.html#r-type.recursive.constraint">type.recursive.constraint</a></li>
<li><a href="types.html#r-type.recursive.intro">type.recursive.intro</a></li>
<li><a href="types.html#r-type.user-defined">type.user-defined</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/boolean.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.1. Boolean type</a></td>
<td>23</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(63);">23</a>
<div id="uncovered-63" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/boolean.html#r-type.bool">type.bool</a></li>
<li><a href="types/boolean.html#r-type.bool.expr">type.bool.expr</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.and">type.bool.expr.and</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp">type.bool.expr.cmp</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.eq">type.bool.expr.cmp.eq</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.greater">type.bool.expr.cmp.greater</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.greater-eq">type.bool.expr.cmp.greater-eq</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.less">type.bool.expr.cmp.less</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.less-eq">type.bool.expr.cmp.less-eq</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.cmp.not-eq">type.bool.expr.cmp.not-eq</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.not">type.bool.expr.not</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.or">type.bool.expr.or</a></li>
<li><a href="types/boolean.html#r-type.bool.expr.xor">type.bool.expr.xor</a></li>
<li><a href="types/boolean.html#r-type.bool.intro">type.bool.intro</a></li>
<li><a href="types/boolean.html#r-type.bool.layout">type.bool.layout</a></li>
<li><a href="types/boolean.html#r-type.bool.literal">type.bool.literal</a></li>
<li><a href="types/boolean.html#r-type.bool.namespace">type.bool.namespace</a></li>
<li><a href="types/boolean.html#r-type.bool.repr">type.bool.repr</a></li>
<li><a href="types/boolean.html#r-type.bool.traits">type.bool.traits</a></li>
<li><a href="types/boolean.html#r-type.bool.usage">type.bool.usage</a></li>
<li><a href="types/boolean.html#r-type.bool.usage-condition">type.bool.usage-condition</a></li>
<li><a href="types/boolean.html#r-type.bool.usage-lazy-operator">type.bool.usage-lazy-operator</a></li>
<li><a href="types/boolean.html#r-type.bool.validity">type.bool.validity</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/numeric.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.2. Numeric types</a></td>
<td>10</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(64);">10</a>
<div id="uncovered-64" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/numeric.html#r-type.numeric">type.numeric</a></li>
<li><a href="types/numeric.html#r-type.numeric.float">type.numeric.float</a></li>
<li><a href="types/numeric.html#r-type.numeric.int">type.numeric.int</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.signed">type.numeric.int.signed</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.size">type.numeric.int.size</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.size.isize">type.numeric.int.size.isize</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.size.minimum">type.numeric.int.size.minimum</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.size.usize">type.numeric.int.size.usize</a></li>
<li><a href="types/numeric.html#r-type.numeric.int.unsigned">type.numeric.int.unsigned</a></li>
<li><a href="types/numeric.html#r-type.numeric.validity">type.numeric.validity</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/textual.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.3. Textual types</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(65);">9</a>
<div id="uncovered-65" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/textual.html#r-type.layout.char-layout">type.layout.char-layout</a></li>
<li><a href="types/textual.html#r-type.layout.char-validity">type.layout.char-validity</a></li>
<li><a href="types/textual.html#r-type.text">type.text</a></li>
<li><a href="types/textual.html#r-type.text.char-precondition">type.text.char-precondition</a></li>
<li><a href="types/textual.html#r-type.text.char-value">type.text.char-value</a></li>
<li><a href="types/textual.html#r-type.text.intro">type.text.intro</a></li>
<li><a href="types/textual.html#r-type.text.layout">type.text.layout</a></li>
<li><a href="types/textual.html#r-type.text.str-unsized">type.text.str-unsized</a></li>
<li><a href="types/textual.html#r-type.text.str-value">type.text.str-value</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/never.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.4. Never type</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(66);">5</a>
<div id="uncovered-66" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/never.html#r-type.never">type.never</a></li>
<li><a href="types/never.html#r-type.never.coercion">type.never.coercion</a></li>
<li><a href="types/never.html#r-type.never.constraint">type.never.constraint</a></li>
<li><a href="types/never.html#r-type.never.intro">type.never.intro</a></li>
<li><a href="types/never.html#r-type.never.syntax">type.never.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/tuple.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.5. Tuple types</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(67);">9</a>
<div id="uncovered-67" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/tuple.html#r-type.tuple">type.tuple</a></li>
<li><a href="types/tuple.html#r-type.tuple.access">type.tuple.access</a></li>
<li><a href="types/tuple.html#r-type.tuple.constructor">type.tuple.constructor</a></li>
<li><a href="types/tuple.html#r-type.tuple.field-name">type.tuple.field-name</a></li>
<li><a href="types/tuple.html#r-type.tuple.field-number">type.tuple.field-number</a></li>
<li><a href="types/tuple.html#r-type.tuple.intro">type.tuple.intro</a></li>
<li><a href="types/tuple.html#r-type.tuple.restriction">type.tuple.restriction</a></li>
<li><a href="types/tuple.html#r-type.tuple.syntax">type.tuple.syntax</a></li>
<li><a href="types/tuple.html#r-type.tuple.unit">type.tuple.unit</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/array.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.6. Array types</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(68);">5</a>
<div id="uncovered-68" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/array.html#r-type.array">type.array</a></li>
<li><a href="types/array.html#r-type.array.constraint">type.array.constraint</a></li>
<li><a href="types/array.html#r-type.array.index">type.array.index</a></li>
<li><a href="types/array.html#r-type.array.intro">type.array.intro</a></li>
<li><a href="types/array.html#r-type.array.syntax">type.array.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/slice.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.7. Slice types</a></td>
<td>5</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(69);">5</a>
<div id="uncovered-69" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/slice.html#r-type.slice">type.slice</a></li>
<li><a href="types/slice.html#r-type.slice.intro">type.slice.intro</a></li>
<li><a href="types/slice.html#r-type.slice.safe">type.slice.safe</a></li>
<li><a href="types/slice.html#r-type.slice.syntax">type.slice.syntax</a></li>
<li><a href="types/slice.html#r-type.slice.unsized">type.slice.unsized</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/struct.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.8. Struct types</a></td>
<td>7</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(70);">7</a>
<div id="uncovered-70" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/struct.html#r-type.struct">type.struct</a></li>
<li><a href="types/struct.html#r-type.struct.constructor">type.struct.constructor</a></li>
<li><a href="types/struct.html#r-type.struct.field-visibility">type.struct.field-visibility</a></li>
<li><a href="types/struct.html#r-type.struct.intro">type.struct.intro</a></li>
<li><a href="types/struct.html#r-type.struct.layout">type.struct.layout</a></li>
<li><a href="types/struct.html#r-type.struct.tuple">type.struct.tuple</a></li>
<li><a href="types/struct.html#r-type.struct.unit">type.struct.unit</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/enum.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.9. Enumerated types</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(71);">6</a>
<div id="uncovered-71" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/enum.html#r-type.enum">type.enum</a></li>
<li><a href="types/enum.html#r-type.enum.constructor">type.enum.constructor</a></li>
<li><a href="types/enum.html#r-type.enum.declaration">type.enum.declaration</a></li>
<li><a href="types/enum.html#r-type.enum.intro">type.enum.intro</a></li>
<li><a href="types/enum.html#r-type.enum.name">type.enum.name</a></li>
<li><a href="types/enum.html#r-type.enum.value">type.enum.value</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/union.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.10. Union types</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(72);">6</a>
<div id="uncovered-72" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/union.html#r-type.union">type.union</a></li>
<li><a href="types/union.html#r-type.union.access">type.union.access</a></li>
<li><a href="types/union.html#r-type.union.constraint">type.union.constraint</a></li>
<li><a href="types/union.html#r-type.union.intro">type.union.intro</a></li>
<li><a href="types/union.html#r-type.union.layout">type.union.layout</a></li>
<li><a href="types/union.html#r-type.union.safety">type.union.safety</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/function-item.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.11. Function item types</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(73);">6</a>
<div id="uncovered-73" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/function-item.html#r-type.fn-item">type.fn-item</a></li>
<li><a href="types/function-item.html#r-type.fn-item.coercion">type.fn-item.coercion</a></li>
<li><a href="types/function-item.html#r-type.fn-item.intro">type.fn-item.intro</a></li>
<li><a href="types/function-item.html#r-type.fn-item.name">type.fn-item.name</a></li>
<li><a href="types/function-item.html#r-type.fn-item.traits">type.fn-item.traits</a></li>
<li><a href="types/function-item.html#r-type.fn-item.unique">type.fn-item.unique</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/closure.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.12. Closure types</a></td>
<td>41</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(74);">41</a>
<div id="uncovered-74" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/closure.html#r-type.closure">type.closure</a></li>
<li><a href="types/closure.html#r-type.closure.async.input">type.closure.async.input</a></li>
<li><a href="types/closure.html#r-type.closure.async.traits">type.closure.async.traits</a></li>
<li><a href="types/closure.html#r-type.closure.async.traits.async-family">type.closure.async.traits.async-family</a></li>
<li><a href="types/closure.html#r-type.closure.async.traits.fn-family">type.closure.async.traits.fn-family</a></li>
<li><a href="types/closure.html#r-type.closure.call">type.closure.call</a></li>
<li><a href="types/closure.html#r-type.closure.call.fn">type.closure.call.fn</a></li>
<li><a href="types/closure.html#r-type.closure.call.fn-mut">type.closure.call.fn-mut</a></li>
<li><a href="types/closure.html#r-type.closure.call.intro">type.closure.call.intro</a></li>
<li><a href="types/closure.html#r-type.closure.capture">type.closure.capture</a></li>
<li><a href="types/closure.html#r-type.closure.capture.copy">type.closure.capture.copy</a></li>
<li><a href="types/closure.html#r-type.closure.capture.intro">type.closure.capture.intro</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precedence">type.closure.capture.precedence</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.box-deref">type.closure.capture.precision.box-deref</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.box-move.read">type.closure.capture.precision.box-move.read</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.box-non-move.moved">type.closure.capture.precision.box-non-move.moved</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.box-non-move.not-moved">type.closure.capture.precision.box-non-move.not-moved</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.capture-path">type.closure.capture.precision.capture-path</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.dereference-shared">type.closure.capture.precision.dereference-shared</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.edition2018.composite">type.closure.capture.precision.edition2018.composite</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.edition2018.drop-order">type.closure.capture.precision.edition2018.drop-order</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.edition2018.entirety">type.closure.capture.precision.edition2018.entirety</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.edition2018.move">type.closure.capture.precision.edition2018.move</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.edition2018.wildcard">type.closure.capture.precision.edition2018.wildcard</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.intro">type.closure.capture.precision.intro</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.move-dereference">type.closure.capture.precision.move-dereference</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.place-projection">type.closure.capture.precision.place-projection</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.raw-pointer-dereference">type.closure.capture.precision.raw-pointer-dereference</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.shared-prefix">type.closure.capture.precision.shared-prefix</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.unaligned">type.closure.capture.precision.unaligned</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.union">type.closure.capture.precision.union</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.wildcard">type.closure.capture.precision.wildcard</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.wildcard.array-slice">type.closure.capture.precision.wildcard.array-slice</a></li>
<li><a href="types/closure.html#r-type.closure.capture.precision.wildcard.initialized">type.closure.capture.precision.wildcard.initialized</a></li>
<li><a href="types/closure.html#r-type.closure.drop-order">type.closure.drop-order</a></li>
<li><a href="types/closure.html#r-type.closure.intro">type.closure.intro</a></li>
<li><a href="types/closure.html#r-type.closure.non-capturing">type.closure.non-capturing</a></li>
<li><a href="types/closure.html#r-type.closure.traits">type.closure.traits</a></li>
<li><a href="types/closure.html#r-type.closure.traits.behavior">type.closure.traits.behavior</a></li>
<li><a href="types/closure.html#r-type.closure.traits.intro">type.closure.traits.intro</a></li>
<li><a href="types/closure.html#r-type.closure.unique-immutable">type.closure.unique-immutable</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/pointer.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.13. Pointer types</a></td>
<td>22</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(75);">22</a>
<div id="uncovered-75" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/pointer.html#r-type.pointer">type.pointer</a></li>
<li><a href="types/pointer.html#r-type.pointer.intro">type.pointer.intro</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw">type.pointer.raw</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.cmp">type.pointer.raw.cmp</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.constructor">type.pointer.raw.constructor</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.copy">type.pointer.raw.copy</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.intro">type.pointer.raw.intro</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.safety">type.pointer.raw.safety</a></li>
<li><a href="types/pointer.html#r-type.pointer.raw.syntax">type.pointer.raw.syntax</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference">type.pointer.reference</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.mut">type.pointer.reference.mut</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.mut.copy">type.pointer.reference.mut.copy</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.mut.intro">type.pointer.reference.mut.intro</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.shared">type.pointer.reference.shared</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.shared.constraint-mutation">type.pointer.reference.shared.constraint-mutation</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.shared.copy">type.pointer.reference.shared.copy</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.shared.intro">type.pointer.reference.shared.intro</a></li>
<li><a href="types/pointer.html#r-type.pointer.reference.syntax">type.pointer.reference.syntax</a></li>
<li><a href="types/pointer.html#r-type.pointer.smart">type.pointer.smart</a></li>
<li><a href="types/pointer.html#r-type.pointer.validity">type.pointer.validity</a></li>
<li><a href="types/pointer.html#r-type.pointer.validity.pointer-fragment">type.pointer.validity.pointer-fragment</a></li>
<li><a href="types/pointer.html#r-type.pointer.validity.raw">type.pointer.validity.raw</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/function-pointer.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.14. Function pointer types</a></td>
<td>7</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(76);">7</a>
<div id="uncovered-76" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/function-pointer.html#r-type.fn-pointer">type.fn-pointer</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.attributes">type.fn-pointer.attributes</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.coercion">type.fn-pointer.coercion</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.constraint-variadic">type.fn-pointer.constraint-variadic</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.intro">type.fn-pointer.intro</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.qualifiers">type.fn-pointer.qualifiers</a></li>
<li><a href="types/function-pointer.html#r-type.fn-pointer.syntax">type.fn-pointer.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/trait-object.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.15. Trait object types</a></td>
<td>11</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(77);">11</a>
<div id="uncovered-77" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/trait-object.html#r-type.trait-object">type.trait-object</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.alias">type.trait-object.alias</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.constraint">type.trait-object.constraint</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.impls">type.trait-object.impls</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.intro">type.trait-object.intro</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.lifetime-bounds">type.trait-object.lifetime-bounds</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.name">type.trait-object.name</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.syntax">type.trait-object.syntax</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.syntax-edition2015">type.trait-object.syntax-edition2015</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.syntax-edition2021">type.trait-object.syntax-edition2021</a></li>
<li><a href="types/trait-object.html#r-type.trait-object.unsized">type.trait-object.unsized</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/impl-trait.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.16. Impl trait type</a></td>
<td>22</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(78);">22</a>
<div id="uncovered-78" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/impl-trait.html#r-type.impl-trait">type.impl-trait</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.constraint">type.impl-trait.constraint</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.auto">type.impl-trait.generic-capture.auto</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.auto.intro">type.impl-trait.generic-capture.auto.intro</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.edition2024">type.impl-trait.generic-capture.edition2024</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise">type.impl-trait.generic-capture.precise</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-lifetime">type.impl-trait.generic-capture.precise.constraint-lifetime</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-param-impl-trait">type.impl-trait.generic-capture.precise.constraint-param-impl-trait</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.constraint-single">type.impl-trait.generic-capture.precise.constraint-single</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-capture.precise.use">type.impl-trait.generic-capture.precise.use</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.generic-captures">type.impl-trait.generic-captures</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.intro">type.impl-trait.intro</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.param">type.impl-trait.param</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.param.generic">type.impl-trait.param.generic</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.param.intro">type.impl-trait.param.intro</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return">type.impl-trait.return</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return-in-trait">type.impl-trait.return-in-trait</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return-in-trait.desugaring">type.impl-trait.return-in-trait.desugaring</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return-in-trait.intro">type.impl-trait.return-in-trait.intro</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return.constraint-body">type.impl-trait.return.constraint-body</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.return.intro">type.impl-trait.return.intro</a></li>
<li><a href="types/impl-trait.html#r-type.impl-trait.syntax">type.impl-trait.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/parameters.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.17. Type parameters</a></td>
<td>1</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(79);">1</a>
<div id="uncovered-79" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/parameters.html#r-type.generic">type.generic</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="types/inferred.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.18. Inferred type</a></td>
<td>4</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(80);">4</a>
<div id="uncovered-80" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="types/inferred.html#r-type.inferred">type.inferred</a></li>
<li><a href="types/inferred.html#r-type.inferred.constraint">type.inferred.constraint</a></li>
<li><a href="types/inferred.html#r-type.inferred.intro">type.inferred.intro</a></li>
<li><a href="types/inferred.html#r-type.inferred.syntax">type.inferred.syntax</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="dynamically-sized-types.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.2. Dynamically Sized Types</a></td>
<td>7</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(81);">7</a>
<div id="uncovered-81" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="dynamically-sized-types.html#r-dynamic-sized">dynamic-sized</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.intro">dynamic-sized.intro</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.pointer-types">dynamic-sized.pointer-types</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.question-sized">dynamic-sized.question-sized</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.restriction">dynamic-sized.restriction</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.struct-field">dynamic-sized.struct-field</a></li>
<li><a href="dynamically-sized-types.html#r-dynamic-sized.trait-impl">dynamic-sized.trait-impl</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="type-layout.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.3. Type layout</a></td>
<td>68</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(82);">68</a>
<div id="uncovered-82" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="type-layout.html#r-layout">layout</a></li>
<li><a href="type-layout.html#r-layout.array">layout.array</a></li>
<li><a href="type-layout.html#r-layout.closure">layout.closure</a></li>
<li><a href="type-layout.html#r-layout.guarantees">layout.guarantees</a></li>
<li><a href="type-layout.html#r-layout.intro">layout.intro</a></li>
<li><a href="type-layout.html#r-layout.pointer">layout.pointer</a></li>
<li><a href="type-layout.html#r-layout.pointer.intro">layout.pointer.intro</a></li>
<li><a href="type-layout.html#r-layout.pointer.thin">layout.pointer.thin</a></li>
<li><a href="type-layout.html#r-layout.pointer.unsized">layout.pointer.unsized</a></li>
<li><a href="type-layout.html#r-layout.primitive">layout.primitive</a></li>
<li><a href="type-layout.html#r-layout.primitive.align">layout.primitive.align</a></li>
<li><a href="type-layout.html#r-layout.primitive.size">layout.primitive.size</a></li>
<li><a href="type-layout.html#r-layout.primitive.size-int">layout.primitive.size-int</a></li>
<li><a href="type-layout.html#r-layout.properties">layout.properties</a></li>
<li><a href="type-layout.html#r-layout.properties.align">layout.properties.align</a></li>
<li><a href="type-layout.html#r-layout.properties.size">layout.properties.size</a></li>
<li><a href="type-layout.html#r-layout.properties.sized">layout.properties.sized</a></li>
<li><a href="type-layout.html#r-layout.repr">layout.repr</a></li>
<li><a href="type-layout.html#r-layout.repr.align-packed">layout.repr.align-packed</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment">layout.repr.alignment</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.align">layout.repr.alignment.align</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.constraint-alignment">layout.repr.alignment.constraint-alignment</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.constraint-exclusive">layout.repr.alignment.constraint-exclusive</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.enum">layout.repr.alignment.enum</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.intro">layout.repr.alignment.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.packed">layout.repr.alignment.packed</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.packed-fields">layout.repr.alignment.packed-fields</a></li>
<li><a href="type-layout.html#r-layout.repr.alignment.packed-padding">layout.repr.alignment.packed-padding</a></li>
<li><a href="type-layout.html#r-layout.repr.attribute">layout.repr.attribute</a></li>
<li><a href="type-layout.html#r-layout.repr.c">layout.repr.c</a></li>
<li><a href="type-layout.html#r-layout.repr.c.adt">layout.repr.c.adt</a></li>
<li><a href="type-layout.html#r-layout.repr.c.adt.fields">layout.repr.c.adt.fields</a></li>
<li><a href="type-layout.html#r-layout.repr.c.adt.intro">layout.repr.c.adt.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.c.adt.tag">layout.repr.c.adt.tag</a></li>
<li><a href="type-layout.html#r-layout.repr.c.constraint">layout.repr.c.constraint</a></li>
<li><a href="type-layout.html#r-layout.repr.c.enum">layout.repr.c.enum</a></li>
<li><a href="type-layout.html#r-layout.repr.c.intro">layout.repr.c.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.c.struct">layout.repr.c.struct</a></li>
<li><a href="type-layout.html#r-layout.repr.c.struct.align">layout.repr.c.struct.align</a></li>
<li><a href="type-layout.html#r-layout.repr.c.struct.size-field-offset">layout.repr.c.struct.size-field-offset</a></li>
<li><a href="type-layout.html#r-layout.repr.c.union">layout.repr.c.union</a></li>
<li><a href="type-layout.html#r-layout.repr.c.union.intro">layout.repr.c.union.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.c.union.size-align">layout.repr.c.union.size-align</a></li>
<li><a href="type-layout.html#r-layout.repr.inter-field">layout.repr.inter-field</a></li>
<li><a href="type-layout.html#r-layout.repr.intro">layout.repr.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.kinds">layout.repr.kinds</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive">layout.repr.primitive</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive-c">layout.repr.primitive-c</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive.adt">layout.repr.primitive.adt</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive.constraint">layout.repr.primitive.constraint</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive.enum">layout.repr.primitive.enum</a></li>
<li><a href="type-layout.html#r-layout.repr.primitive.intro">layout.repr.primitive.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.rust">layout.repr.rust</a></li>
<li><a href="type-layout.html#r-layout.repr.rust.alignment">layout.repr.rust.alignment</a></li>
<li><a href="type-layout.html#r-layout.repr.rust.field-storage">layout.repr.rust.field-storage</a></li>
<li><a href="type-layout.html#r-layout.repr.rust.intro">layout.repr.rust.intro</a></li>
<li><a href="type-layout.html#r-layout.repr.rust.layout">layout.repr.rust.layout</a></li>
<li><a href="type-layout.html#r-layout.repr.rust.unspecified">layout.repr.rust.unspecified</a></li>
<li><a href="type-layout.html#r-layout.repr.transparent">layout.repr.transparent</a></li>
<li><a href="type-layout.html#r-layout.repr.transparent.constraint-exclusive">layout.repr.transparent.constraint-exclusive</a></li>
<li><a href="type-layout.html#r-layout.repr.transparent.constraint-field">layout.repr.transparent.constraint-field</a></li>
<li><a href="type-layout.html#r-layout.repr.transparent.layout-abi">layout.repr.transparent.layout-abi</a></li>
<li><a href="type-layout.html#r-layout.slice">layout.slice</a></li>
<li><a href="type-layout.html#r-layout.str">layout.str</a></li>
<li><a href="type-layout.html#r-layout.trait-object">layout.trait-object</a></li>
<li><a href="type-layout.html#r-layout.tuple">layout.tuple</a></li>
<li><a href="type-layout.html#r-layout.tuple.general">layout.tuple.general</a></li>
<li><a href="type-layout.html#r-layout.tuple.unit">layout.tuple.unit</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="interior-mutability.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.4. Interior mutability</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(83);">9</a>
<div id="uncovered-83" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="interior-mutability.html#r-interior-mut">interior-mut</a></li>
<li><a href="interior-mutability.html#r-interior-mut.abstraction">interior-mut.abstraction</a></li>
<li><a href="interior-mutability.html#r-interior-mut.atomic">interior-mut.atomic</a></li>
<li><a href="interior-mutability.html#r-interior-mut.intro">interior-mut.intro</a></li>
<li><a href="interior-mutability.html#r-interior-mut.mut-unsafe-cell">interior-mut.mut-unsafe-cell</a></li>
<li><a href="interior-mutability.html#r-interior-mut.no-constraint">interior-mut.no-constraint</a></li>
<li><a href="interior-mutability.html#r-interior-mut.ref-cell">interior-mut.ref-cell</a></li>
<li><a href="interior-mutability.html#r-interior-mut.shared-ref">interior-mut.shared-ref</a></li>
<li><a href="interior-mutability.html#r-interior-mut.unsafe-cell">interior-mut.unsafe-cell</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="subtyping.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.5. Subtyping and Variance</a></td>
<td>12</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(84);">12</a>
<div id="uncovered-84" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="subtyping.html#r-subtype">subtype</a></li>
<li><a href="subtyping.html#r-subtype.higher-ranked">subtype.higher-ranked</a></li>
<li><a href="subtyping.html#r-subtype.intro">subtype.intro</a></li>
<li><a href="subtyping.html#r-subtype.kinds">subtype.kinds</a></li>
<li><a href="subtyping.html#r-subtyping.variance">subtyping.variance</a></li>
<li><a href="subtyping.html#r-subtyping.variance.builtin-composite-types">subtyping.variance.builtin-composite-types</a></li>
<li><a href="subtyping.html#r-subtyping.variance.builtin-types">subtyping.variance.builtin-types</a></li>
<li><a href="subtyping.html#r-subtyping.variance.contravariant">subtyping.variance.contravariant</a></li>
<li><a href="subtyping.html#r-subtyping.variance.covariant">subtyping.variance.covariant</a></li>
<li><a href="subtyping.html#r-subtyping.variance.intro">subtyping.variance.intro</a></li>
<li><a href="subtyping.html#r-subtyping.variance.invariant">subtyping.variance.invariant</a></li>
<li><a href="subtyping.html#r-subtyping.variance.user-composite-types">subtyping.variance.user-composite-types</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="trait-bounds.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.6. Trait and lifetime bounds</a></td>
<td>22</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(85);">22</a>
<div id="uncovered-85" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="trait-bounds.html#r-bound">bound</a></li>
<li><a href="trait-bounds.html#r-bound.higher-ranked">bound.higher-ranked</a></li>
<li><a href="trait-bounds.html#r-bound.higher-ranked.intro">bound.higher-ranked.intro</a></li>
<li><a href="trait-bounds.html#r-bound.higher-ranked.syntax">bound.higher-ranked.syntax</a></li>
<li><a href="trait-bounds.html#r-bound.higher-ranked.trait">bound.higher-ranked.trait</a></li>
<li><a href="trait-bounds.html#r-bound.implied">bound.implied</a></li>
<li><a href="trait-bounds.html#r-bound.implied.context">bound.implied.context</a></li>
<li><a href="trait-bounds.html#r-bound.implied.def">bound.implied.def</a></li>
<li><a href="trait-bounds.html#r-bound.implied.intro">bound.implied.intro</a></li>
<li><a href="trait-bounds.html#r-bound.implied.trait">bound.implied.trait</a></li>
<li><a href="trait-bounds.html#r-bound.intro">bound.intro</a></li>
<li><a href="trait-bounds.html#r-bound.lifetime">bound.lifetime</a></li>
<li><a href="trait-bounds.html#r-bound.lifetime.intro">bound.lifetime.intro</a></li>
<li><a href="trait-bounds.html#r-bound.lifetime.outlive-lifetime">bound.lifetime.outlive-lifetime</a></li>
<li><a href="trait-bounds.html#r-bound.lifetime.outlive-type">bound.lifetime.outlive-type</a></li>
<li><a href="trait-bounds.html#r-bound.satisfaction">bound.satisfaction</a></li>
<li><a href="trait-bounds.html#r-bound.sized">bound.sized</a></li>
<li><a href="trait-bounds.html#r-bound.special">bound.special</a></li>
<li><a href="trait-bounds.html#r-bound.syntax">bound.syntax</a></li>
<li><a href="trait-bounds.html#r-bound.trait-object">bound.trait-object</a></li>
<li><a href="trait-bounds.html#r-bound.trivial">bound.trivial</a></li>
<li><a href="trait-bounds.html#r-bound.use">bound.use</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="type-coercions.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.7. Type coercions</a></td>
<td>45</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(86);">45</a>
<div id="uncovered-86" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="type-coercions.html#r-coerce">coerce</a></li>
<li><a href="type-coercions.html#r-coerce.as">coerce.as</a></li>
<li><a href="type-coercions.html#r-coerce.intro">coerce.intro</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound">coerce.least-upper-bound</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.computation">coerce.least-upper-bound.computation</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.computation-identity">coerce.least-upper-bound.computation-identity</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.computation-replace">coerce.least-upper-bound.computation-replace</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.computation-unify">coerce.least-upper-bound.computation-unify</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.intro">coerce.least-upper-bound.intro</a></li>
<li><a href="type-coercions.html#r-coerce.least-upper-bound.target">coerce.least-upper-bound.target</a></li>
<li><a href="type-coercions.html#r-coerce.site">coerce.site</a></li>
<li><a href="type-coercions.html#r-coerce.site.argument">coerce.site.argument</a></li>
<li><a href="type-coercions.html#r-coerce.site.array">coerce.site.array</a></li>
<li><a href="type-coercions.html#r-coerce.site.block">coerce.site.block</a></li>
<li><a href="type-coercions.html#r-coerce.site.constructor">coerce.site.constructor</a></li>
<li><a href="type-coercions.html#r-coerce.site.intro">coerce.site.intro</a></li>
<li><a href="type-coercions.html#r-coerce.site.let">coerce.site.let</a></li>
<li><a href="type-coercions.html#r-coerce.site.parenthesis">coerce.site.parenthesis</a></li>
<li><a href="type-coercions.html#r-coerce.site.repeat">coerce.site.repeat</a></li>
<li><a href="type-coercions.html#r-coerce.site.return">coerce.site.return</a></li>
<li><a href="type-coercions.html#r-coerce.site.subexpr">coerce.site.subexpr</a></li>
<li><a href="type-coercions.html#r-coerce.site.tuple">coerce.site.tuple</a></li>
<li><a href="type-coercions.html#r-coerce.site.value">coerce.site.value</a></li>
<li><a href="type-coercions.html#r-coerce.types">coerce.types</a></li>
<li><a href="type-coercions.html#r-coerce.types.closure">coerce.types.closure</a></li>
<li><a href="type-coercions.html#r-coerce.types.deref">coerce.types.deref</a></li>
<li><a href="type-coercions.html#r-coerce.types.deref-mut">coerce.types.deref-mut</a></li>
<li><a href="type-coercions.html#r-coerce.types.fn">coerce.types.fn</a></li>
<li><a href="type-coercions.html#r-coerce.types.intro">coerce.types.intro</a></li>
<li><a href="type-coercions.html#r-coerce.types.mut-pointer">coerce.types.mut-pointer</a></li>
<li><a href="type-coercions.html#r-coerce.types.mut-reborrow">coerce.types.mut-reborrow</a></li>
<li><a href="type-coercions.html#r-coerce.types.mut-to-pointer">coerce.types.mut-to-pointer</a></li>
<li><a href="type-coercions.html#r-coerce.types.never">coerce.types.never</a></li>
<li><a href="type-coercions.html#r-coerce.types.ref-to-pointer">coerce.types.ref-to-pointer</a></li>
<li><a href="type-coercions.html#r-coerce.types.reflexive">coerce.types.reflexive</a></li>
<li><a href="type-coercions.html#r-coerce.types.transitive">coerce.types.transitive</a></li>
<li><a href="type-coercions.html#r-coerce.types.unsize">coerce.types.unsize</a></li>
<li><a href="type-coercions.html#r-coerce.unsize">coerce.unsize</a></li>
<li><a href="type-coercions.html#r-coerce.unsize.intro">coerce.unsize.intro</a></li>
<li><a href="type-coercions.html#r-coerce.unsize.slice">coerce.unsize.slice</a></li>
<li><a href="type-coercions.html#r-coerce.unsize.trait">coerce.unsize.trait</a></li>
<li><a href="type-coercions.html#r-coerce.unsize.trait-object">coerce.unsize.trait-object</a></li>
<li><a href="type-coercions.html#r-coerce.unsize.trait-upcast">coerce.unsize.trait-upcast</a></li>
<li><a href="type-coercions.html#r-coerce.unsized.composite">coerce.unsized.composite</a></li>
<li><a href="type-coercions.html#r-coerce.unsized.pointer">coerce.unsized.pointer</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="destructors.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.8. Destructors</a></td>
<td>42</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(87);">42</a>
<div id="uncovered-87" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="destructors.html#r-destructors.drop_in_place">destructors.drop_in_place</a></li>
<li><a href="destructors.html#r-destructors.forget">destructors.forget</a></li>
<li><a href="destructors.html#r-destructors.intro">destructors.intro</a></li>
<li><a href="destructors.html#r-destructors.operation">destructors.operation</a></li>
<li><a href="destructors.html#r-destructors.scope">destructors.scope</a></li>
<li><a href="destructors.html#r-destructors.scope.bindings">destructors.scope.bindings</a></li>
<li><a href="destructors.html#r-destructors.scope.bindings.intro">destructors.scope.bindings.intro</a></li>
<li><a href="destructors.html#r-destructors.scope.bindings.match-pattern-order">destructors.scope.bindings.match-pattern-order</a></li>
<li><a href="destructors.html#r-destructors.scope.block">destructors.scope.block</a></li>
<li><a href="destructors.html#r-destructors.scope.const-promotion">destructors.scope.const-promotion</a></li>
<li><a href="destructors.html#r-destructors.scope.desugaring">destructors.scope.desugaring</a></li>
<li><a href="destructors.html#r-destructors.scope.expression">destructors.scope.expression</a></li>
<li><a href="destructors.html#r-destructors.scope.function">destructors.scope.function</a></li>
<li><a href="destructors.html#r-destructors.scope.intro">destructors.scope.intro</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension">destructors.scope.lifetime-extension</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.exprs">destructors.scope.lifetime-extension.exprs</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.let">destructors.scope.lifetime-extension.let</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.patterns">destructors.scope.lifetime-extension.patterns</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.patterns.extending">destructors.scope.lifetime-extension.patterns.extending</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.patterns.let">destructors.scope.lifetime-extension.patterns.let</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.static">destructors.scope.lifetime-extension.static</a></li>
<li><a href="destructors.html#r-destructors.scope.lifetime-extension.sub-expressions">destructors.scope.lifetime-extension.sub-expressions</a></li>
<li><a href="destructors.html#r-destructors.scope.list">destructors.scope.list</a></li>
<li><a href="destructors.html#r-destructors.scope.match-arm">destructors.scope.match-arm</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting">destructors.scope.nesting</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.expr-statement">destructors.scope.nesting.expr-statement</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.function">destructors.scope.nesting.function</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.function-body">destructors.scope.nesting.function-body</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.let-initializer">destructors.scope.nesting.let-initializer</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.match">destructors.scope.nesting.match</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.match-arm">destructors.scope.nesting.match-arm</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.match-guard">destructors.scope.nesting.match-guard</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.other">destructors.scope.nesting.other</a></li>
<li><a href="destructors.html#r-destructors.scope.nesting.statement">destructors.scope.nesting.statement</a></li>
<li><a href="destructors.html#r-destructors.scope.operands">destructors.scope.operands</a></li>
<li><a href="destructors.html#r-destructors.scope.operators">destructors.scope.operators</a></li>
<li><a href="destructors.html#r-destructors.scope.params">destructors.scope.params</a></li>
<li><a href="destructors.html#r-destructors.scope.statement">destructors.scope.statement</a></li>
<li><a href="destructors.html#r-destructors.scope.temporary">destructors.scope.temporary</a></li>
<li><a href="destructors.html#r-destructors.scope.temporary.edition2024">destructors.scope.temporary.edition2024</a></li>
<li><a href="destructors.html#r-destructors.scope.temporary.enclosing">destructors.scope.temporary.enclosing</a></li>
<li><a href="destructors.html#r-destructors.scope.temporary.intro">destructors.scope.temporary.intro</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="lifetime-elision.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.9. Lifetime elision</a></td>
<td>24</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(88);">24</a>
<div id="uncovered-88" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="lifetime-elision.html#r-lifetime-elision">lifetime-elision</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.const-static">lifetime-elision.const-static</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.const-static.fn-references">lifetime-elision.const-static.fn-references</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.const-static.implicit-static">lifetime-elision.const-static.implicit-static</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function">lifetime-elision.function</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.explicit-placeholder">lifetime-elision.function.explicit-placeholder</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.implicit-lifetime-parameters">lifetime-elision.function.implicit-lifetime-parameters</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.intro">lifetime-elision.function.intro</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.lifetimes-not-inferred">lifetime-elision.function.lifetimes-not-inferred</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.only-functions">lifetime-elision.function.only-functions</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.output-lifetime">lifetime-elision.function.output-lifetime</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.function.receiver-lifetime">lifetime-elision.function.receiver-lifetime</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object">lifetime-elision.trait-object</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type">lifetime-elision.trait-object.containing-type</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type-explicit">lifetime-elision.trait-object.containing-type-explicit</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.containing-type-unique">lifetime-elision.trait-object.containing-type-unique</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.default">lifetime-elision.trait-object.default</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.explicit-bound">lifetime-elision.trait-object.explicit-bound</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.explicit-placeholder">lifetime-elision.trait-object.explicit-placeholder</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.innermost-type">lifetime-elision.trait-object.innermost-type</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.intro">lifetime-elision.trait-object.intro</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.static-lifetime">lifetime-elision.trait-object.static-lifetime</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.trait-bounds">lifetime-elision.trait-object.trait-bounds</a></li>
<li><a href="lifetime-elision.html#r-lifetime-elision.trait-object.trait-unique">lifetime-elision.trait-object.trait-unique</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="special-types-and-traits.html">11. Special types and traits</a></td>
<td>54</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(89);">54</a>
<div id="uncovered-89" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="special-types-and-traits.html#r-lang-types">lang-types</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.arc">lang-types.arc</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.arc.receiver">lang-types.arc.receiver</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits">lang-types.auto-traits</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.aggregate">lang-types.auto-traits.aggregate</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.auto-impl">lang-types.auto-traits.auto-impl</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.builtin-composite">lang-types.auto-traits.builtin-composite</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.closure">lang-types.auto-traits.closure</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.fn-item-pointer">lang-types.auto-traits.fn-item-pointer</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.generic-impl">lang-types.auto-traits.generic-impl</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.negative">lang-types.auto-traits.negative</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.auto-traits.trait-object-marker">lang-types.auto-traits.trait-object-marker</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.box">lang-types.box</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.box.deref">lang-types.box.deref</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.box.fundamental">lang-types.box.fundamental</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.box.intro">lang-types.box.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.box.receiver">lang-types.box.receiver</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone">lang-types.clone</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone.builtin-copy">lang-types.clone.builtin-copy</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone.builtin-types">lang-types.clone.builtin-types</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone.closure">lang-types.clone.closure</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone.intro">lang-types.clone.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.clone.tuple">lang-types.clone.tuple</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy">lang-types.copy</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.behavior">lang-types.copy.behavior</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.builtin-types">lang-types.copy.builtin-types</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.closure">lang-types.copy.closure</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.constraint">lang-types.copy.constraint</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.fn-item">lang-types.copy.fn-item</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.fn-pointer">lang-types.copy.fn-pointer</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.intro">lang-types.copy.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.copy.tuple">lang-types.copy.tuple</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.deref">lang-types.deref</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.drop">lang-types.drop</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.intro">lang-types.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.ops">lang-types.ops</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.phantom-data">lang-types.phantom-data</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.pin">lang-types.pin</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.pin.receiver">lang-types.pin.receiver</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.rc">lang-types.rc</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.rc.receiver">lang-types.rc.receiver</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.send">lang-types.send</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sized">lang-types.sized</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sized.implicit-impl">lang-types.sized.implicit-impl</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sized.implicit-sized">lang-types.sized.implicit-sized</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sized.intro">lang-types.sized.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sized.relaxation">lang-types.sized.relaxation</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sync">lang-types.sync</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sync.intro">lang-types.sync.intro</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.sync.static-constraint">lang-types.sync.static-constraint</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.termination">lang-types.termination</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.unsafe-cell">lang-types.unsafe-cell</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.unsafe-cell.interior-mut">lang-types.unsafe-cell.interior-mut</a></li>
<li><a href="special-types-and-traits.html#r-lang-types.unsafe-cell.read-only-alloc">lang-types.unsafe-cell.read-only-alloc</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="names.html">12. Names</a></td>
<td>31</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(90);">31</a>
<div id="uncovered-90" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="names.html#r-names">names</a></li>
<li><a href="names.html#r-names.decl">names.decl</a></li>
<li><a href="names.html#r-names.explicit">names.explicit</a></li>
<li><a href="names.html#r-names.explicit-decl">names.explicit-decl</a></li>
<li><a href="names.html#r-names.explicit.binding">names.explicit.binding</a></li>
<li><a href="names.html#r-names.explicit.expr">names.explicit.expr</a></li>
<li><a href="names.html#r-names.explicit.generics">names.explicit.generics</a></li>
<li><a href="names.html#r-names.explicit.higher-ranked-bounds">names.explicit.higher-ranked-bounds</a></li>
<li><a href="names.html#r-names.explicit.item-decl">names.explicit.item-decl</a></li>
<li><a href="names.html#r-names.explicit.list">names.explicit.list</a></li>
<li><a href="names.html#r-names.explicit.macro-invocation">names.explicit.macro-invocation</a></li>
<li><a href="names.html#r-names.explicit.macro_export">names.explicit.macro_export</a></li>
<li><a href="names.html#r-names.explicit.macro_use">names.explicit.macro_use</a></li>
<li><a href="names.html#r-names.implicit">names.implicit</a></li>
<li><a href="names.html#r-names.implicit.builtin-attributes">names.implicit.builtin-attributes</a></li>
<li><a href="names.html#r-names.implicit.derive-helpers">names.implicit.derive-helpers</a></li>
<li><a href="names.html#r-names.implicit.extern-prelude">names.implicit.extern-prelude</a></li>
<li><a href="names.html#r-names.implicit.lifetime-static">names.implicit.lifetime-static</a></li>
<li><a href="names.html#r-names.implicit.lints">names.implicit.lints</a></li>
<li><a href="names.html#r-names.implicit.list">names.implicit.list</a></li>
<li><a href="names.html#r-names.implicit.prelude">names.implicit.prelude</a></li>
<li><a href="names.html#r-names.implicit.primitive-types">names.implicit.primitive-types</a></li>
<li><a href="names.html#r-names.implicit.root">names.implicit.root</a></li>
<li><a href="names.html#r-names.implicit.stdlib">names.implicit.stdlib</a></li>
<li><a href="names.html#r-names.implicit.tool-attributes">names.implicit.tool-attributes</a></li>
<li><a href="names.html#r-names.intro">names.intro</a></li>
<li><a href="names.html#r-names.lifetime">names.lifetime</a></li>
<li><a href="names.html#r-names.namespace">names.namespace</a></li>
<li><a href="names.html#r-names.path">names.path</a></li>
<li><a href="names.html#r-names.resolution">names.resolution</a></li>
<li><a href="names.html#r-names.visibility">names.visibility</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="names/namespaces.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.1. Namespaces</a></td>
<td>9</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(91);">9</a>
<div id="uncovered-91" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="names/namespaces.html#r-names.namespaces">names.namespaces</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.intro">names.namespaces.intro</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.kinds">names.namespaces.kinds</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.sub-namespaces">names.namespaces.sub-namespaces</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.sub-namespaces.intro">names.namespaces.sub-namespaces.intro</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.sub-namespaces.use-shadow">names.namespaces.sub-namespaces.use-shadow</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.without">names.namespaces.without</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.without.fields">names.namespaces.without.fields</a></li>
<li><a href="names/namespaces.html#r-names.namespaces.without.use">names.namespaces.without.use</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="names/scopes.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.2. Scopes</a></td>
<td>46</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(92);">46</a>
<div id="uncovered-92" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="names/scopes.html#r-names.scopes">names.scopes</a></li>
<li><a href="names/scopes.html#r-names.scopes.associated-items">names.scopes.associated-items</a></li>
<li><a href="names/scopes.html#r-names.scopes.associated-items.duplicate">names.scopes.associated-items.duplicate</a></li>
<li><a href="names/scopes.html#r-names.scopes.associated-items.scope">names.scopes.associated-items.scope</a></li>
<li><a href="names/scopes.html#r-names.scopes.derive">names.scopes.derive</a></li>
<li><a href="names/scopes.html#r-names.scopes.derive.scope">names.scopes.derive.scope</a></li>
<li><a href="names/scopes.html#r-names.scopes.derive.shadow">names.scopes.derive.shadow</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters">names.scopes.generic-parameters</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters.bounds">names.scopes.generic-parameters.bounds</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters.inner-items">names.scopes.generic-parameters.inner-items</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters.order-independent">names.scopes.generic-parameters.order-independent</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters.param-list">names.scopes.generic-parameters.param-list</a></li>
<li><a href="names/scopes.html#r-names.scopes.generic-parameters.shadow">names.scopes.generic-parameters.shadow</a></li>
<li><a href="names/scopes.html#r-names.scopes.intro">names.scopes.intro</a></li>
<li><a href="names/scopes.html#r-names.scopes.items">names.scopes.items</a></li>
<li><a href="names/scopes.html#r-names.scopes.items.duplicate">names.scopes.items.duplicate</a></li>
<li><a href="names/scopes.html#r-names.scopes.items.module">names.scopes.items.module</a></li>
<li><a href="names/scopes.html#r-names.scopes.items.nested-modules">names.scopes.items.nested-modules</a></li>
<li><a href="names/scopes.html#r-names.scopes.items.shadow-prelude">names.scopes.items.shadow-prelude</a></li>
<li><a href="names/scopes.html#r-names.scopes.items.statement">names.scopes.items.statement</a></li>
<li><a href="names/scopes.html#r-names.scopes.lifetimes">names.scopes.lifetimes</a></li>
<li><a href="names/scopes.html#r-names.scopes.lifetimes.generic">names.scopes.lifetimes.generic</a></li>
<li><a href="names/scopes.html#r-names.scopes.lifetimes.higher-ranked">names.scopes.lifetimes.higher-ranked</a></li>
<li><a href="names/scopes.html#r-names.scopes.lifetimes.impl-trait">names.scopes.lifetimes.impl-trait</a></li>
<li><a href="names/scopes.html#r-names.scopes.lifetimes.special">names.scopes.lifetimes.special</a></li>
<li><a href="names/scopes.html#r-names.scopes.loop-label">names.scopes.loop-label</a></li>
<li><a href="names/scopes.html#r-names.scopes.loop-label.scope">names.scopes.loop-label.scope</a></li>
<li><a href="names/scopes.html#r-names.scopes.loop-label.shadow">names.scopes.loop-label.shadow</a></li>
<li><a href="names/scopes.html#r-names.scopes.macro_rules">names.scopes.macro_rules</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings">names.scopes.pattern-bindings</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.closure">names.scopes.pattern-bindings.closure</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.if-let">names.scopes.pattern-bindings.if-let</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.items">names.scopes.pattern-bindings.items</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.let">names.scopes.pattern-bindings.let</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.loop">names.scopes.pattern-bindings.loop</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.match-arm">names.scopes.pattern-bindings.match-arm</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.parameter">names.scopes.pattern-bindings.parameter</a></li>
<li><a href="names/scopes.html#r-names.scopes.pattern-bindings.shadow">names.scopes.pattern-bindings.shadow</a></li>
<li><a href="names/scopes.html#r-names.scopes.prelude">names.scopes.prelude</a></li>
<li><a href="names/scopes.html#r-names.scopes.prelude.intro">names.scopes.prelude.intro</a></li>
<li><a href="names/scopes.html#r-names.scopes.prelude.layers">names.scopes.prelude.layers</a></li>
<li><a href="names/scopes.html#r-names.scopes.prelude.shadow">names.scopes.prelude.shadow</a></li>
<li><a href="names/scopes.html#r-names.scopes.self">names.scopes.self</a></li>
<li><a href="names/scopes.html#r-names.scopes.self.def-scope">names.scopes.self.def-scope</a></li>
<li><a href="names/scopes.html#r-names.scopes.self.impl-scope">names.scopes.self.impl-scope</a></li>
<li><a href="names/scopes.html#r-names.scopes.self.intro">names.scopes.self.intro</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="names/preludes.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.3. Preludes</a></td>
<td>28</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(93);">28</a>
<div id="uncovered-93" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="names/preludes.html#r-names.preludes">names.preludes</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern">names.preludes.extern</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.core">names.preludes.extern.core</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.edition2018">names.preludes.extern.edition2018</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.intro">names.preludes.extern.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std">names.preludes.extern.no_std</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std.allowed-positions">names.preludes.extern.no_std.allowed-positions</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std.core">names.preludes.extern.no_std.core</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std.extern">names.preludes.extern.no_std.extern</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std.intro">names.preludes.extern.no_std.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.no_std.module">names.preludes.extern.no_std.module</a></li>
<li><a href="names/preludes.html#r-names.preludes.extern.std">names.preludes.extern.std</a></li>
<li><a href="names/preludes.html#r-names.preludes.intro">names.preludes.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.kinds">names.preludes.kinds</a></li>
<li><a href="names/preludes.html#r-names.preludes.lang">names.preludes.lang</a></li>
<li><a href="names/preludes.html#r-names.preludes.lang.entities">names.preludes.lang.entities</a></li>
<li><a href="names/preludes.html#r-names.preludes.lang.intro">names.preludes.lang.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.macro_use">names.preludes.macro_use</a></li>
<li><a href="names/preludes.html#r-names.preludes.macro_use.intro">names.preludes.macro_use.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.no_implicit_prelude">names.preludes.no_implicit_prelude</a></li>
<li><a href="names/preludes.html#r-names.preludes.no_implicit_prelude.edition2018">names.preludes.no_implicit_prelude.edition2018</a></li>
<li><a href="names/preludes.html#r-names.preludes.no_implicit_prelude.intro">names.preludes.no_implicit_prelude.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.no_implicit_prelude.lang">names.preludes.no_implicit_prelude.lang</a></li>
<li><a href="names/preludes.html#r-names.preludes.std">names.preludes.std</a></li>
<li><a href="names/preludes.html#r-names.preludes.std.intro">names.preludes.std.intro</a></li>
<li><a href="names/preludes.html#r-names.preludes.std.module">names.preludes.std.module</a></li>
<li><a href="names/preludes.html#r-names.preludes.tool">names.preludes.tool</a></li>
<li><a href="names/preludes.html#r-names.preludes.tool.intro">names.preludes.tool.intro</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="paths.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.4. Paths</a></td>
<td>54</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(94);">54</a>
<div id="uncovered-94" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="paths.html#r-paths">paths</a></li>
<li><a href="paths.html#r-paths.canonical">paths.canonical</a></li>
<li><a href="paths.html#r-paths.canonical.alias">paths.canonical.alias</a></li>
<li><a href="paths.html#r-paths.canonical.bare-impl-prefix">paths.canonical.bare-impl-prefix</a></li>
<li><a href="paths.html#r-paths.canonical.def">paths.canonical.def</a></li>
<li><a href="paths.html#r-paths.canonical.intro">paths.canonical.intro</a></li>
<li><a href="paths.html#r-paths.canonical.local-canonical-path">paths.canonical.local-canonical-path</a></li>
<li><a href="paths.html#r-paths.canonical.module-prefix">paths.canonical.module-prefix</a></li>
<li><a href="paths.html#r-paths.canonical.non-canonical">paths.canonical.non-canonical</a></li>
<li><a href="paths.html#r-paths.canonical.trait-impl-prefix">paths.canonical.trait-impl-prefix</a></li>
<li><a href="paths.html#r-paths.expr">paths.expr</a></li>
<li><a href="paths.html#r-paths.expr.argument-order">paths.expr.argument-order</a></li>
<li><a href="paths.html#r-paths.expr.complex-const-params">paths.expr.complex-const-params</a></li>
<li><a href="paths.html#r-paths.expr.impl-trait-params">paths.expr.impl-trait-params</a></li>
<li><a href="paths.html#r-paths.expr.intro">paths.expr.intro</a></li>
<li><a href="paths.html#r-paths.expr.syntax">paths.expr.syntax</a></li>
<li><a href="paths.html#r-paths.expr.turbofish">paths.expr.turbofish</a></li>
<li><a href="paths.html#r-paths.intro">paths.intro</a></li>
<li><a href="paths.html#r-paths.qualified">paths.qualified</a></li>
<li><a href="paths.html#r-paths.qualified.intro">paths.qualified.intro</a></li>
<li><a href="paths.html#r-paths.qualified.syntax">paths.qualified.syntax</a></li>
<li><a href="paths.html#r-paths.qualifiers">paths.qualifiers</a></li>
<li><a href="paths.html#r-paths.qualifiers.crate">paths.qualifiers.crate</a></li>
<li><a href="paths.html#r-paths.qualifiers.crate.allowed-positions">paths.qualifiers.crate.allowed-positions</a></li>
<li><a href="paths.html#r-paths.qualifiers.crate.intro">paths.qualifiers.crate.intro</a></li>
<li><a href="paths.html#r-paths.qualifiers.global-root">paths.qualifiers.global-root</a></li>
<li><a href="paths.html#r-paths.qualifiers.global-root.edition2015">paths.qualifiers.global-root.edition2015</a></li>
<li><a href="paths.html#r-paths.qualifiers.global-root.intro">paths.qualifiers.global-root.intro</a></li>
<li><a href="paths.html#r-paths.qualifiers.macro-crate">paths.qualifiers.macro-crate</a></li>
<li><a href="paths.html#r-paths.qualifiers.macro-crate.allowed-positions">paths.qualifiers.macro-crate.allowed-positions</a></li>
<li><a href="paths.html#r-paths.qualifiers.macro-crate.hygiene">paths.qualifiers.macro-crate.hygiene</a></li>
<li><a href="paths.html#r-paths.qualifiers.mod-self">paths.qualifiers.mod-self</a></li>
<li><a href="paths.html#r-paths.qualifiers.mod-self.intro">paths.qualifiers.mod-self.intro</a></li>
<li><a href="paths.html#r-paths.qualifiers.mod-self.restriction">paths.qualifiers.mod-self.restriction</a></li>
<li><a href="paths.html#r-paths.qualifiers.self-pat">paths.qualifiers.self-pat</a></li>
<li><a href="paths.html#r-paths.qualifiers.super">paths.qualifiers.super</a></li>
<li><a href="paths.html#r-paths.qualifiers.super.allowed-positions">paths.qualifiers.super.allowed-positions</a></li>
<li><a href="paths.html#r-paths.qualifiers.super.intro">paths.qualifiers.super.intro</a></li>
<li><a href="paths.html#r-paths.qualifiers.super.repetition">paths.qualifiers.super.repetition</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self">paths.qualifiers.type-self</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.allowed-positions">paths.qualifiers.type-self.allowed-positions</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.impl">paths.qualifiers.type-self.impl</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.intro">paths.qualifiers.type-self.intro</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.no-generics">paths.qualifiers.type-self.no-generics</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.scope">paths.qualifiers.type-self.scope</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.trait">paths.qualifiers.type-self.trait</a></li>
<li><a href="paths.html#r-paths.qualifiers.type-self.type">paths.qualifiers.type-self.type</a></li>
<li><a href="paths.html#r-paths.simple">paths.simple</a></li>
<li><a href="paths.html#r-paths.simple.intro">paths.simple.intro</a></li>
<li><a href="paths.html#r-paths.simple.syntax">paths.simple.syntax</a></li>
<li><a href="paths.html#r-paths.type">paths.type</a></li>
<li><a href="paths.html#r-paths.type.intro">paths.type.intro</a></li>
<li><a href="paths.html#r-paths.type.syntax">paths.type.syntax</a></li>
<li><a href="paths.html#r-paths.type.turbofish">paths.type.turbofish</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="names/name-resolution.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.5. Name resolution</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="visibility-and-privacy.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.6. Visibility and privacy</a></td>
<td>18</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(96);">18</a>
<div id="uncovered-96" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="visibility-and-privacy.html#r-vis">vis</a></li>
<li><a href="visibility-and-privacy.html#r-vis.access">vis.access</a></li>
<li><a href="visibility-and-privacy.html#r-vis.default">vis.default</a></li>
<li><a href="visibility-and-privacy.html#r-vis.intro">vis.intro</a></li>
<li><a href="visibility-and-privacy.html#r-vis.name-hierarchy">vis.name-hierarchy</a></li>
<li><a href="visibility-and-privacy.html#r-vis.privacy">vis.privacy</a></li>
<li><a href="visibility-and-privacy.html#r-vis.reexports">vis.reexports</a></li>
<li><a href="visibility-and-privacy.html#r-vis.reexports.intro">vis.reexports.intro</a></li>
<li><a href="visibility-and-privacy.html#r-vis.reexports.private-item">vis.reexports.private-item</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped">vis.scoped</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.crate">vis.scoped.crate</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.edition2018">vis.scoped.edition2018</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.in">vis.scoped.in</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.intro">vis.scoped.intro</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.self">vis.scoped.self</a></li>
<li><a href="visibility-and-privacy.html#r-vis.scoped.super">vis.scoped.super</a></li>
<li><a href="visibility-and-privacy.html#r-vis.syntax">vis.syntax</a></li>
<li><a href="visibility-and-privacy.html#r-vis.usage">vis.usage</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="memory-model.html">13. Memory model</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="memory-allocation-and-lifetime.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.1. Memory allocation and lifetime</a></td>
<td>3</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(98);">3</a>
<div id="uncovered-98" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="memory-allocation-and-lifetime.html#r-alloc">alloc</a></li>
<li><a href="memory-allocation-and-lifetime.html#r-alloc.dynamic">alloc.dynamic</a></li>
<li><a href="memory-allocation-and-lifetime.html#r-alloc.static">alloc.static</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="variables.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2. Variables</a></td>
<td>6</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(99);">6</a>
<div id="uncovered-99" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="variables.html#r-variable">variable</a></li>
<li><a href="variables.html#r-variable.init">variable.init</a></li>
<li><a href="variables.html#r-variable.intro">variable.intro</a></li>
<li><a href="variables.html#r-variable.local">variable.local</a></li>
<li><a href="variables.html#r-variable.local-mut">variable.local-mut</a></li>
<li><a href="variables.html#r-variable.param-mut">variable.param-mut</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="linkage.html">14. Linkage</a></td>
<td>21</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(100);">21</a>
<div id="uncovered-100" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="linkage.html#r-link">link</a></li>
<li><a href="linkage.html#r-link.bin">link.bin</a></li>
<li><a href="linkage.html#r-link.cdylib">link.cdylib</a></li>
<li><a href="linkage.html#r-link.crt">link.crt</a></li>
<li><a href="linkage.html#r-link.crt.crt-static">link.crt.crt-static</a></li>
<li><a href="linkage.html#r-link.crt.ineffective">link.crt.ineffective</a></li>
<li><a href="linkage.html#r-link.crt.intro">link.crt.intro</a></li>
<li><a href="linkage.html#r-link.crt.target_feature">link.crt.target_feature</a></li>
<li><a href="linkage.html#r-link.dependency">link.dependency</a></li>
<li><a href="linkage.html#r-link.dependency-dynamic">link.dependency-dynamic</a></li>
<li><a href="linkage.html#r-link.dependency-prefer-dynamic">link.dependency-prefer-dynamic</a></li>
<li><a href="linkage.html#r-link.dependency-rlib">link.dependency-rlib</a></li>
<li><a href="linkage.html#r-link.dependency-staticlib">link.dependency-staticlib</a></li>
<li><a href="linkage.html#r-link.dylib">link.dylib</a></li>
<li><a href="linkage.html#r-link.intro">link.intro</a></li>
<li><a href="linkage.html#r-link.lib">link.lib</a></li>
<li><a href="linkage.html#r-link.proc-macro">link.proc-macro</a></li>
<li><a href="linkage.html#r-link.repetition">link.repetition</a></li>
<li><a href="linkage.html#r-link.rlib">link.rlib</a></li>
<li><a href="linkage.html#r-link.staticlib">link.staticlib</a></li>
<li><a href="linkage.html#r-link.type">link.type</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="inline-assembly.html">15. Inline assembly</a></td>
<td>102</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(101);">102</a>
<div id="uncovered-101" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="inline-assembly.html#r-asm">asm</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers">asm.abi-clobbers</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers.explicit-have-precedence">asm.abi-clobbers.explicit-have-precedence</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers.intro">asm.abi-clobbers.intro</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers.many">asm.abi-clobbers.many</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers.must-specify">asm.abi-clobbers.must-specify</a></li>
<li><a href="inline-assembly.html#r-asm.abi-clobbers.supported-abis">asm.abi-clobbers.supported-abis</a></li>
<li><a href="inline-assembly.html#r-asm.directives">asm.directives</a></li>
<li><a href="inline-assembly.html#r-asm.directives.stateful">asm.directives.stateful</a></li>
<li><a href="inline-assembly.html#r-asm.directives.subset-supported">asm.directives.subset-supported</a></li>
<li><a href="inline-assembly.html#r-asm.directives.supported-directives">asm.directives.supported-directives</a></li>
<li><a href="inline-assembly.html#r-asm.example">asm.example</a></li>
<li><a href="inline-assembly.html#r-asm.intro">asm.intro</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type">asm.operand-type</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.global_asm-restriction">asm.operand-type.global_asm-restriction</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.left-to-right">asm.operand-type.left-to-right</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands">asm.operand-type.supported-operands</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.in">asm.operand-type.supported-operands.in</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.inlateout">asm.operand-type.supported-operands.inlateout</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.inout">asm.operand-type.supported-operands.inout</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.inout-arrow">asm.operand-type.supported-operands.inout-arrow</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.lateout">asm.operand-type.supported-operands.lateout</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.out">asm.operand-type.supported-operands.out</a></li>
<li><a href="inline-assembly.html#r-asm.operand-type.supported-operands.sym">asm.operand-type.supported-operands.sym</a></li>
<li><a href="inline-assembly.html#r-asm.options">asm.options</a></li>
<li><a href="inline-assembly.html#r-asm.options.checks">asm.options.checks</a></li>
<li><a href="inline-assembly.html#r-asm.options.checks.mutually-exclusive">asm.options.checks.mutually-exclusive</a></li>
<li><a href="inline-assembly.html#r-asm.options.checks.noreturn">asm.options.checks.noreturn</a></li>
<li><a href="inline-assembly.html#r-asm.options.checks.pure">asm.options.checks.pure</a></li>
<li><a href="inline-assembly.html#r-asm.options.global_asm-restriction">asm.options.global_asm-restriction</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options">asm.options.supported-options</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.att_syntax">asm.options.supported-options.att_syntax</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.nomem">asm.options.supported-options.nomem</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.noreturn">asm.options.supported-options.noreturn</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.nostack">asm.options.supported-options.nostack</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.preserves_flags">asm.options.supported-options.preserves_flags</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.pure">asm.options.supported-options.pure</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.raw">asm.options.supported-options.raw</a></li>
<li><a href="inline-assembly.html#r-asm.options.supported-options.readonly">asm.options.supported-options.readonly</a></li>
<li><a href="inline-assembly.html#r-asm.register-names">asm.register-names</a></li>
<li><a href="inline-assembly.html#r-asm.register-names.fp-bp-reserved">asm.register-names.fp-bp-reserved</a></li>
<li><a href="inline-assembly.html#r-asm.register-names.not-for-io">asm.register-names.not-for-io</a></li>
<li><a href="inline-assembly.html#r-asm.register-names.supported-register-aliases">asm.register-names.supported-register-aliases</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands">asm.register-operands</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.allowed-types">asm.register-operands.allowed-types</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.equivalence-to-base-register">asm.register-operands.equivalence-to-base-register</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.error-overlapping">asm.register-operands.error-overlapping</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.error-two-operands">asm.register-operands.error-two-operands</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.register-or-class">asm.register-operands.register-or-class</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.separate-input-output">asm.register-operands.separate-input-output</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.smaller-value">asm.register-operands.smaller-value</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.supported-register-classes">asm.register-operands.supported-register-classes</a></li>
<li><a href="inline-assembly.html#r-asm.register-operands.value-type-constraints">asm.register-operands.value-type-constraints</a></li>
<li><a href="inline-assembly.html#r-asm.rules">asm.rules</a></li>
<li><a href="inline-assembly.html#r-asm.rules.arm64ec">asm.rules.arm64ec</a></li>
<li><a href="inline-assembly.html#r-asm.rules.black-box">asm.rules.black-box</a></li>
<li><a href="inline-assembly.html#r-asm.rules.intro">asm.rules.intro</a></li>
<li><a href="inline-assembly.html#r-asm.rules.mem-same-as-ffi">asm.rules.mem-same-as-ffi</a></li>
<li><a href="inline-assembly.html#r-asm.rules.noreturn">asm.rules.noreturn</a></li>
<li><a href="inline-assembly.html#r-asm.rules.not-exactly-once">asm.rules.not-exactly-once</a></li>
<li><a href="inline-assembly.html#r-asm.rules.not-successive">asm.rules.not-successive</a></li>
<li><a href="inline-assembly.html#r-asm.rules.only-on-exit">asm.rules.only-on-exit</a></li>
<li><a href="inline-assembly.html#r-asm.rules.preserved-registers">asm.rules.preserved-registers</a></li>
<li><a href="inline-assembly.html#r-asm.rules.preserves_flags">asm.rules.preserves_flags</a></li>
<li><a href="inline-assembly.html#r-asm.rules.pure">asm.rules.pure</a></li>
<li><a href="inline-assembly.html#r-asm.rules.reg-not-input">asm.rules.reg-not-input</a></li>
<li><a href="inline-assembly.html#r-asm.rules.reg-not-output">asm.rules.reg-not-output</a></li>
<li><a href="inline-assembly.html#r-asm.rules.stack-below-sp">asm.rules.stack-below-sp</a></li>
<li><a href="inline-assembly.html#r-asm.rules.unwind">asm.rules.unwind</a></li>
<li><a href="inline-assembly.html#r-asm.rules.x86-df">asm.rules.x86-df</a></li>
<li><a href="inline-assembly.html#r-asm.rules.x86-prefix-restriction">asm.rules.x86-prefix-restriction</a></li>
<li><a href="inline-assembly.html#r-asm.rules.x86-x87">asm.rules.x86-x87</a></li>
<li><a href="inline-assembly.html#r-asm.scope">asm.scope</a></li>
<li><a href="inline-assembly.html#r-asm.scope.asm">asm.scope.asm</a></li>
<li><a href="inline-assembly.html#r-asm.scope.global_asm">asm.scope.global_asm</a></li>
<li><a href="inline-assembly.html#r-asm.scope.intro">asm.scope.intro</a></li>
<li><a href="inline-assembly.html#r-asm.stable-targets">asm.stable-targets</a></li>
<li><a href="inline-assembly.html#r-asm.syntax">asm.syntax</a></li>
<li><a href="inline-assembly.html#r-asm.target-specific-directives">asm.target-specific-directives</a></li>
<li><a href="inline-assembly.html#r-asm.target-specific-directives.arm-32-bit">asm.target-specific-directives.arm-32-bit</a></li>
<li><a href="inline-assembly.html#r-asm.target-specific-directives.dwarf-unwinding">asm.target-specific-directives.dwarf-unwinding</a></li>
<li><a href="inline-assembly.html#r-asm.target-specific-directives.structured-exception-handling">asm.target-specific-directives.structured-exception-handling</a></li>
<li><a href="inline-assembly.html#r-asm.target-specific-directives.x86">asm.target-specific-directives.x86</a></li>
<li><a href="inline-assembly.html#r-asm.template-modifiers">asm.template-modifiers</a></li>
<li><a href="inline-assembly.html#r-asm.template-modifiers.intro">asm.template-modifiers.intro</a></li>
<li><a href="inline-assembly.html#r-asm.template-modifiers.only-one">asm.template-modifiers.only-one</a></li>
<li><a href="inline-assembly.html#r-asm.template-modifiers.smaller-value">asm.template-modifiers.smaller-value</a></li>
<li><a href="inline-assembly.html#r-asm.template-modifiers.supported-modifiers">asm.template-modifiers.supported-modifiers</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args">asm.ts-args</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.at-least-once">asm.ts-args.at-least-once</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.before-other-args">asm.ts-args.before-other-args</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.llvm-syntax">asm.ts-args.llvm-syntax</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.no-implicit">asm.ts-args.no-implicit</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.one-or-more">asm.ts-args.one-or-more</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.opaque">asm.ts-args.opaque</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.order">asm.ts-args.order</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.positional-first">asm.ts-args.positional-first</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.register-operands">asm.ts-args.register-operands</a></li>
<li><a href="inline-assembly.html#r-asm.ts-args.syntax">asm.ts-args.syntax</a></li>
<li><a href="inline-assembly.html#r-asm.validity">asm.validity</a></li>
<li><a href="inline-assembly.html#r-asm.validity.necessary-but-not-sufficient">asm.validity.necessary-but-not-sufficient</a></li>
<li><a href="inline-assembly.html#r-asm.validity.non-exhaustive">asm.validity.non-exhaustive</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="unsafety.html">16. Unsafety</a></td>
<td>11</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(102);">11</a>
<div id="uncovered-102" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="unsafety.html#r-safety">safety</a></li>
<li><a href="unsafety.html#r-safety.intro">safety.intro</a></li>
<li><a href="unsafety.html#r-safety.unsafe-attribute">safety.unsafe-attribute</a></li>
<li><a href="unsafety.html#r-safety.unsafe-call">safety.unsafe-call</a></li>
<li><a href="unsafety.html#r-safety.unsafe-deref">safety.unsafe-deref</a></li>
<li><a href="unsafety.html#r-safety.unsafe-extern">safety.unsafe-extern</a></li>
<li><a href="unsafety.html#r-safety.unsafe-impl">safety.unsafe-impl</a></li>
<li><a href="unsafety.html#r-safety.unsafe-ops">safety.unsafe-ops</a></li>
<li><a href="unsafety.html#r-safety.unsafe-static">safety.unsafe-static</a></li>
<li><a href="unsafety.html#r-safety.unsafe-target-feature-call">safety.unsafe-target-feature-call</a></li>
<li><a href="unsafety.html#r-safety.unsafe-union-access">safety.unsafe-union-access</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="unsafe-keyword.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.1. The unsafe keyword</a></td>
<td>15</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(103);">15</a>
<div id="uncovered-103" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="unsafe-keyword.html#r-unsafe">unsafe</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.attribute">unsafe.attribute</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.block">unsafe.block</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.block.fn-body">unsafe.block.fn-body</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.block.intro">unsafe.block.intro</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.extern">unsafe.extern</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.extern.edition2024">unsafe.extern.edition2024</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.fn">unsafe.fn</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.fn.intro">unsafe.fn.intro</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.fn.safety">unsafe.fn.safety</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.impl">unsafe.impl</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.intro">unsafe.intro</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.trait">unsafe.trait</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.trait.intro">unsafe.trait.intro</a></li>
<li><a href="unsafe-keyword.html#r-unsafe.trait.safety">unsafe.trait.safety</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="behavior-considered-undefined.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2. Behavior considered undefined</a></td>
<td>41</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(104);">41</a>
<div id="uncovered-104" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="behavior-considered-undefined.html#r-undefined">undefined</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.alias">undefined.alias</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.asm">undefined.asm</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.call">undefined.call</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.const-transmute-ptr2int">undefined.const-transmute-ptr2int</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.dangling">undefined.dangling</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.dangling.alloc-limit">undefined.dangling.alloc-limit</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.dangling.dynamic-size">undefined.dangling.dynamic-size</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.dangling.general">undefined.dangling.general</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.dangling.zero-size">undefined.dangling.zero-size</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.general">undefined.general</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.immutable">undefined.immutable</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.intrinsic">undefined.intrinsic</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.invalid">undefined.invalid</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned">undefined.misaligned</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned.general">undefined.misaligned.general</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned.load-store">undefined.misaligned.load-store</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned.packed">undefined.misaligned.packed</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned.raw">undefined.misaligned.raw</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.misaligned.reference">undefined.misaligned.reference</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.place-projection">undefined.place-projection</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.pointed-to">undefined.pointed-to</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.pointer-access">undefined.pointer-access</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.race">undefined.race</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.soundness">undefined.soundness</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.target-feature">undefined.target-feature</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity">undefined.validity</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.bool">undefined.validity.bool</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.char">undefined.validity.char</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.enum">undefined.validity.enum</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.fn-pointer">undefined.validity.fn-pointer</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.general">undefined.validity.general</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.never">undefined.validity.never</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.reference-box">undefined.validity.reference-box</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.scalar">undefined.validity.scalar</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.str">undefined.validity.str</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.struct">undefined.validity.struct</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.undef">undefined.validity.undef</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.union">undefined.validity.union</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.valid-range">undefined.validity.valid-range</a></li>
<li><a href="behavior-considered-undefined.html#r-undefined.validity.wide">undefined.validity.wide</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="behavior-not-considered-unsafe.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3. Behavior not considered unsafe</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="const_eval.html">17. Constant Evaluation</a></td>
<td>39</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(106);">39</a>
<div id="uncovered-106" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="const_eval.html#r-const-eval">const-eval</a></li>
<li><a href="const_eval.html#r-const-eval.const-context">const-eval.const-context</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.array-length">const-eval.const-context.array-length</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.block">const-eval.const-context.block</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.general">const-eval.const-context.general</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.generic">const-eval.const-context.generic</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.init">const-eval.const-context.init</a></li>
<li><a href="const_eval.html#r-const-eval.const-context.repeat-length">const-eval.const-context.repeat-length</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr">const-eval.const-expr</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.array">const-eval.const-expr.array</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.block">const-eval.const-expr.block</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.borrows">const-eval.const-expr.borrows</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.builtin-arith-logic">const-eval.const-expr.builtin-arith-logic</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.cast">const-eval.const-expr.cast</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.closure">const-eval.const-expr.closure</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.const-context">const-eval.const-expr.const-context</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.const-fn">const-eval.const-expr.const-fn</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.constructor">const-eval.const-expr.constructor</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.deref">const-eval.const-expr.deref</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.error">const-eval.const-expr.error</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.field">const-eval.const-expr.field</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.general">const-eval.const-expr.general</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.group">const-eval.const-expr.group</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.if-match">const-eval.const-expr.if-match</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.index">const-eval.const-expr.index</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.list">const-eval.const-expr.list</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.literal">const-eval.const-expr.literal</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.loop">const-eval.const-expr.loop</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.parameter">const-eval.const-expr.parameter</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.path-item">const-eval.const-expr.path-item</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.path-static">const-eval.const-expr.path-static</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.range">const-eval.const-expr.range</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.runtime-context">const-eval.const-expr.runtime-context</a></li>
<li><a href="const_eval.html#r-const-eval.const-expr.tuple">const-eval.const-expr.tuple</a></li>
<li><a href="const_eval.html#r-const-eval.const-fn">const-eval.const-fn</a></li>
<li><a href="const_eval.html#r-const-eval.const-fn.const-context">const-eval.const-fn.const-context</a></li>
<li><a href="const_eval.html#r-const-eval.const-fn.general">const-eval.const-fn.general</a></li>
<li><a href="const_eval.html#r-const-eval.const-fn.usage">const-eval.const-fn.usage</a></li>
<li><a href="const_eval.html#r-const-eval.general">const-eval.general</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="abi.html">18. Application Binary Interface</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="runtime.html">19. The Rust runtime</a></td>
<td>14</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(108);">14</a>
<div id="uncovered-108" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="runtime.html#r-runtime">runtime</a></li>
<li><a href="runtime.html#r-runtime.global_allocator">runtime.global_allocator</a></li>
<li><a href="runtime.html#r-runtime.panic_handler">runtime.panic_handler</a></li>
<li><a href="runtime.html#r-runtime.panic_handler.allowed-positions">runtime.panic_handler.allowed-positions</a></li>
<li><a href="runtime.html#r-runtime.panic_handler.intro">runtime.panic_handler.intro</a></li>
<li><a href="runtime.html#r-runtime.panic_handler.panic-info">runtime.panic_handler.panic-info</a></li>
<li><a href="runtime.html#r-runtime.panic_handler.std">runtime.panic_handler.std</a></li>
<li><a href="runtime.html#r-runtime.panic_handler.unique">runtime.panic_handler.unique</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem">runtime.windows_subsystem</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem.console">runtime.windows_subsystem.console</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem.ignored">runtime.windows_subsystem.ignored</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem.intro">runtime.windows_subsystem.intro</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem.syntax">runtime.windows_subsystem.syntax</a></li>
<li><a href="runtime.html#r-runtime.windows_subsystem.windows">runtime.windows_subsystem.windows</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="appendices.html">20. Appendices</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="macro-ambiguity.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20.1. Macro Follow-Set Ambiguity Formal Specification</a></td>
<td>45</td>
<td>0</td>
<td><div class="popup-container">
<a href="javascript:void(0)" onclick="spec_toggle_uncovered(110);">45</a>
<div id="uncovered-110" class="uncovered-rules-popup popup-hidden">
Uncovered rules
                        <ul><li><a href="macro-ambiguity.html#r-macro.ambiguity">macro.ambiguity</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention">macro.ambiguity.convention</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.complex-nt">macro.ambiguity.convention.complex-nt</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.defs">macro.ambiguity.convention.defs</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.matcher">macro.ambiguity.convention.matcher</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.sequence-vars">macro.ambiguity.convention.sequence-vars</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.set">macro.ambiguity.convention.set</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.convention.vars">macro.ambiguity.convention.vars</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.invariant">macro.ambiguity.invariant</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.invariant.follow-matcher">macro.ambiguity.invariant.follow-matcher</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.invariant.list">macro.ambiguity.invariant.list</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.invariant.separated-complex-nt">macro.ambiguity.invariant.separated-complex-nt</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.invariant.unseparated-complex-nt">macro.ambiguity.invariant.unseparated-complex-nt</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets">macro.ambiguity.sets</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def">macro.ambiguity.sets.def</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first">macro.ambiguity.sets.def.first</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.complex">macro.ambiguity.sets.def.first.complex</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.epsilon">macro.ambiguity.sets.def.first.epsilon</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.intro">macro.ambiguity.sets.def.first.intro</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.first.token">macro.ambiguity.sets.def.first.token</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow">macro.ambiguity.sets.def.follow</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.expr-stmt">macro.ambiguity.sets.def.follow.expr-stmt</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.intro">macro.ambiguity.sets.def.follow.intro</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.other-matcher">macro.ambiguity.sets.def.follow.other-matcher</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.pat">macro.ambiguity.sets.def.follow.pat</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.simple">macro.ambiguity.sets.def.follow.simple</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.ty-path">macro.ambiguity.sets.def.follow.ty-path</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.type-first">macro.ambiguity.sets.def.follow.type-first</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.follow.vis">macro.ambiguity.sets.def.follow.vis</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.intro">macro.ambiguity.sets.def.intro</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last">macro.ambiguity.sets.def.last</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.delim">macro.ambiguity.sets.def.last.delim</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.empty">macro.ambiguity.sets.def.last.empty</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.intro">macro.ambiguity.sets.def.last.intro</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-plus">macro.ambiguity.sets.def.last.rep-plus</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-question">macro.ambiguity.sets.def.last.rep-question</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.rep-star">macro.ambiguity.sets.def.last.rep-star</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.sequence">macro.ambiguity.sets.def.last.sequence</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.last.token">macro.ambiguity.sets.def.last.token</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.def.notation">macro.ambiguity.sets.def.notation</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.first">macro.ambiguity.sets.first</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.follow">macro.ambiguity.sets.follow</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.intro">macro.ambiguity.sets.intro</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.last">macro.ambiguity.sets.last</a></li>
<li><a href="macro-ambiguity.html#r-macro.ambiguity.sets.universe">macro.ambiguity.sets.universe</a></li>
</ul></div></div></td>
<td>0.0%</td>
</tr>
<tr>
<td><a href="influences.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20.2. Influences</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="test-summary.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20.3. Test summary</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="glossary.html">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20.4. Glossary</a></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><b>Total:</b></td>
<td>2628</td>
<td>0</td>
<td>2628</td>
<td>0.0%</td>
</tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="용어집"><a class="header" href="#용어집">용어집</a></h1>
<h3 id="추상-구문-트리-abstract-syntax-tree"><a class="header" href="#추상-구문-트리-abstract-syntax-tree">추상 구문 트리 (Abstract syntax tree)</a></h3>
<p>‘추상 구문 트리’ 또는 ‘AST’는 컴파일러가 프로그램을 컴파일할 때 사용하는 프로그램 구조의 중간 표현입니다.</p>
<h3 id="정렬-alignment"><a class="header" href="#정렬-alignment">정렬 (Alignment)</a></h3>
<p>값의 정렬은 값이 시작되는 선호되는 주소를 지정합니다. 항상 2의 거듭제곱입니다. 값에 대한 참조는 반드시 정렬되어야 합니다. <a href="type-layout.html#size-and-alignment">자세히</a>.</p>
<h3 id="항수-arity"><a class="header" href="#항수-arity">항수 (Arity)</a></h3>
<p>항수는 함수나 연산자가 취하는 인자의 개수를 의미합니다. 예를 들어, <code>f(2, 3)</code>와 <code>g(4, 6)</code>는 항수가 2이고, <code>h(8, 2, 6)</code>는 항수가 3입니다. <code>!</code> 연산자는 항수가 1입니다.</p>
<h3 id="배열-array"><a class="header" href="#배열-array">배열 (Array)</a></h3>
<p>배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. 메모리의 연속적인 영역을 차지합니다.배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. 메모리의 연속적인 영역을 차지합니다.</p>
<h3 id="연관-아이템-1"><a class="header" href="#연관-아이템-1">연관 아이템</a></h3>
<p>연관 아이템은 다른 아이템과 연관된 아이템입니다. 연관 아이템은 <a href="items/implementations.html">구현</a>에 정의되고 <a href="items/traits.html">트레잇</a>에 선언됩니다. 함수, 상수, 타입 별칭만 연관될 수 있습니다. <a href="glossary.html#free-item">자유 아이템</a>과 대조됩니다.</p>
<h3 id="블랭킷-구현"><a class="header" href="#블랭킷-구현">블랭킷 구현</a></h3>
<p>타입이 <a href="glossary.html#uncovered-type">커버되지 않은</a> 상태로 나타나는 모든 구현. <code>impl&lt;T&gt; Foo for T</code>, <code>impl&lt;T&gt; Bar&lt;T&gt; for T</code>, <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for T</code>, 그리고 <code>impl&lt;T&gt; Bar&lt;T&gt; for Vec&lt;T&gt;</code>는 블랭킷 구현으로 간주됩니다. 하지만 <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code>는 이 <code>impl</code>에 나타나는 모든 <code>T</code> 인스턴스가 <code>Vec</code>에 의해 커버되므로 블랭킷 구현이 아닙니다.</p>
<h3 id="바운드"><a class="header" href="#바운드">바운드</a></h3>
<p>바운드는 타입이나 트레잇에 대한 제약 조건입니다. 예를 들어, 함수가 받는 인자에 바운드가 지정되면 해당 함수에 전달되는 타입은 해당 제약 조건을 준수해야 합니다.</p>
<h3 id="컴비네이터"><a class="header" href="#컴비네이터">컴비네이터</a></h3>
<p>컴비네이터는 함수와 이전에 정의된 컴비네이터만을 적용하여 인자로부터 결과를 제공하는 고차 함수입니다. 모듈식으로 제어 흐름을 관리하는 데 사용할 수 있습니다.</p>
<h3 id="크레이트"><a class="header" href="#크레이트">크레이트</a></h3>
<p>크레이트는 컴파일 및 링크의 단위입니다. 라이브러리나 실행 파일과 같은 다양한 <a href="linkage.html">크레이트 종류</a>가 있습니다. 크레이트는 외부 크레이트라고 하는 다른 라이브러리 크레이트를 링크하고 참조할 수 있습니다. 크레이트는 크레이트 루트라고 하는 이름 없는 루트 모듈에서 시작하는 자체 포함된 <a href="items/modules.html">모듈</a> 트리를 가집니다. <a href="items.html">아이템</a>은 공개 모듈의 <a href="paths.html">경로</a>를 포함하여 크레이트 루트에서 공개로 표시하여 다른 크레이트에서 볼 수 있도록 할 수 있습니다. <a href="crates-and-source-files.html">더 보기</a>.</p>
<h3 id="디스패치"><a class="header" href="#디스패치">디스패치</a></h3>
<p>디스패치는 다형성과 관련될 때 실제로 실행되는 코드의 특정 버전을 결정하는 메커니즘입니다. 디스패치의 두 가지 주요 형태는 정적 디스패치와 동적 디스패치입니다. Rust는 정적 디스패치를 선호하지만 ’트레잇 객체’라는 메커니즘을 통해 동적 디스패치도 지원합니다.</p>
<h3 id="동적-크기-타입-1"><a class="header" href="#동적-크기-타입-1">동적 크기 타입</a></h3>
<p>동적 크기 타입(DST)은 정적으로 알려진 크기나 정렬이 없는 타입입니다.</p>
<h3 id="엔티티"><a class="header" href="#엔티티">엔티티</a></h3>
<p><a href="names.html"><em>엔티티</em></a>는 소스 프로그램 내에서 어떤 방식으로든, 보통 <a href="paths.html">경로</a>를 통해 참조될 수 있는 언어 구성 요소입니다. 엔티티에는 <a href="types.html">타입</a>, <a href="items.html">아이템</a>, <a href="items/generics.html">제네릭 파라미터</a>, <a href="patterns.html">변수 바인딩</a>, <a href="tokens.html#lifetimes-and-loop-labels">루프 레이블</a>, <a href="tokens.html#lifetimes-and-loop-labels">라이프타임</a>, <a href="expressions/field-expr.html">필드</a>, <a href="attributes.html">속성</a>, <a href="attributes/diagnostics.html#lint-check-attributes">린트</a>가 포함됩니다.</p>
<h3 id="표현식-1"><a class="header" href="#표현식-1">표현식</a></h3>
<p>표현식은 값, 상수, 변수, 연산자 및 함수의 조합으로, 부수 효과가 있거나 없을 수 있으며 단일 값으로 평가됩니다.</p>
<p>예를 들어, <code>2 + (3 * 4)</code>는 값 14를 반환하는 표현식입니다.</p>
<h3 id="자유-아이템"><a class="header" href="#자유-아이템">자유 아이템</a></h3>
<p><a href="items/implementations.html">구현</a>의 멤버가 아닌 <a href="items.html">아이템</a>으로, <em>자유 함수</em> 또는 _자유 상수_와 같은 것입니다. <a href="glossary.html#associated-item">연관 아이템</a>과 대조됩니다.</p>
<h3 id="기본-트레잇"><a class="header" href="#기본-트레잇">기본 트레잇</a></h3>
<p>기본 트레잇은 기존 타입에 대해 구현을 추가하는 것이 파괴적인 변경이 되는 트레잇입니다. <code>Fn</code> 트레잇과 <code>Sized</code>가 기본 트레잇입니다.</p>
<h3 id="기본-타입-생성자"><a class="header" href="#기본-타입-생성자">기본 타입 생성자</a></h3>
<p>기본 타입 생성자는 그 위에 <a href="glossary.html#blanket-implementation">블랭킷 구현</a>을 구현하는 것이 파괴적인 변경이 되는 타입입니다. <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Pin</code>이 기본 타입 생성자입니다.</p>
<p>타입 <code>T</code>가 <a href="glossary.html#local-type">로컬</a>로 간주될 때마다 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, <code>Pin&lt;T&gt;</code>도 로컬로 간주됩니다. 기본 타입 생성자는 다른 타입을 <a href="glossary.html#uncovered-type">커버</a>할 수 없습니다. “커버된 타입“이라는 용어가 사용될 때마다 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, <code>Pin&lt;T&gt;</code>의 <code>T</code>는 커버된 것으로 간주되지 않습니다.</p>
<h3 id="인해비티드"><a class="header" href="#인해비티드">인해비티드</a></h3>
<p>타입은 생성자가 있어 인스턴스화할 수 있는 경우 인해비티드(inhabited)됩니다. 인해비티드 타입은 해당 타입의 값이 있을 수 있다는 의미에서 “비어 있지” 않습니다. <a href="glossary.html#uninhabited">언인해비티드</a>의 반대입니다.</p>
<h3 id="고유-구현-1"><a class="header" href="#고유-구현-1">고유 구현</a></h3>
<p>트레잇-타입 쌍이 아닌 명목 타입에 적용되는 <a href="items/implementations.html">구현</a>입니다. <a href="items/implementations.html#inherent-implementations">더 보기</a>.</p>
<h3 id="고유-메서드"><a class="header" href="#고유-메서드">고유 메서드</a></h3>
<p>트레잇 구현이 아닌 <a href="items/implementations.html#inherent-implementations">고유 구현</a>에 정의된 <a href="items/associated-items.html#methods">메서드</a>입니다.</p>
<h3 id="초기화됨"><a class="header" href="#초기화됨">초기화됨</a></h3>
<p>변수는 값이 할당되고 그 이후로 이동되지 않은 경우 초기화됩니다. 다른 모든 메모리 위치는 초기화되지 않은 것으로 간주됩니다. 안전하지 않은 Rust만이 초기화하지 않고 메모리 위치를 생성할 수 있습니다.</p>
<h3 id="로컬-트레잇"><a class="header" href="#로컬-트레잇">로컬 트레잇</a></h3>
<p>현재 크레이트에서 정의된 <code>trait</code>입니다. 트레잇 정의는 적용된 타입 인자와 독립적으로 로컬이거나 로컬이 아닐 수 있습니다. <code>trait Foo&lt;T, U&gt;</code>가 주어졌을 때, <code>T</code>와 <code>U</code>에 대해 대체된 타입에 관계없이 <code>Foo</code>는 항상 로컬입니다.</p>
<h3 id="로컬-타입"><a class="header" href="#로컬-타입">로컬 타입</a></h3>
<p>현재 크레이트에서 정의된 <code>struct</code>, <code>enum</code> 또는 <code>union</code>입니다. 이것은 적용된 타입 인자에 영향을 받지 않습니다. <code>struct Foo</code>는 로컬로 간주되지만 <code>Vec&lt;Foo&gt;</code>는 그렇지 않습니다. <code>LocalType&lt;ForeignType&gt;</code>은 로컬입니다. 타입 별칭은 지역성에 영향을 주지 않습니다.</p>
<h3 id="모듈-1"><a class="header" href="#모듈-1">모듈</a></h3>
<p>모듈은 0개 이상의 <a href="items.html">아이템</a>을 담는 컨테이너입니다. 모듈은 크레이트 루트 또는 루트 모듈이라고 하는 루트의 이름 없는 모듈에서 시작하는 트리로 구성됩니다. <a href="paths.html">경로</a>는 다른 모듈의 아이템을 참조하는 데 사용될 수 있으며, 이는 <a href="visibility-and-privacy.html">가시성 규칙</a>에 의해 제한될 수 있습니다. <a href="items/modules.html">더 보기</a></p>
<h3 id="이름-1"><a class="header" href="#이름-1">이름</a></h3>
<p><a href="names.html"><em>이름</em></a>은 <a href="glossary.html#entity">엔티티</a>를 참조하는 <a href="identifiers.html">식별자</a> 또는 <a href="tokens.html#lifetimes-and-loop-labels">라이프타임 또는 루프 레이블</a>입니다. _이름 바인딩_은 엔티티 선언이 해당 엔티티와 연관된 식별자 또는 레이블을 도입할 때입니다. <a href="paths.html">경로</a>, 식별자 및 레이블은 엔티티를 참조하는 데 사용됩니다.</p>
<h3 id="이름-확인-1"><a class="header" href="#이름-확인-1">이름 확인</a></h3>
<p><a href="names/name-resolution.html"><em>이름 확인(Name resolution)</em></a>은 컴파일 타임에 <a href="paths.html">경로</a>, <a href="identifiers.html">식별자</a>, <a href="tokens.html#lifetimes-and-loop-labels">레이블</a>을 <a href="glossary.html#entity">엔티티</a> 선언에 연결하는 프로세스입니다.</p>
<h3 id="네임스페이스-namespace"><a class="header" href="#네임스페이스-namespace">네임스페이스 (Namespace)</a></h3>
<p>_네임스페이스_는 이름이 참조하는 <a href="glossary.html#entity">엔티티</a>의 종류에 따른 선언된 <a href="glossary.html#name">이름</a>들의 논리적 그룹화입니다. 네임스페이스를 통해 한 네임스페이스에 있는 이름이 다른 네임스페이스에 있는 동일한 이름과 충돌하지 않도록 할 수 있습니다.</p>
<p>네임스페이스 내에서 이름은 계층 구조로 조직되며, 계층 구조의 각 레벨은 자신만의 명명된 엔티티 컬렉션을 가집니다.</p>
<h3 id="공칭-타입-nominal-types"><a class="header" href="#공칭-타입-nominal-types">공칭 타입 (Nominal types)</a></h3>
<p>경로를 통해 직접 참조할 수 있는 타입입니다. 구체적으로는 <a href="items/enumerations.html">열거형</a>, <a href="items/structs.html">구조체</a>, <a href="items/unions.html">유니온</a>, 그리고 <a href="types/trait-object.html">트레잇 객체 타입</a>을 의미합니다.</p>
<h3 id="dyn-호환-트레잇-dyn-compatible-traits"><a class="header" href="#dyn-호환-트레잇-dyn-compatible-traits">Dyn 호환 트레잇 (Dyn-compatible traits)</a></h3>
<p><a href="types/trait-object.html">트레잇 객체 타입</a> (<code>dyn Trait</code>)에서 사용될 수 있는 <a href="items/traits.html">트레잇</a>입니다. 특정한 <a href="items/traits.html#dyn-compatibility">규칙</a>을 따르는 트레잇만이 _dyn 호환_됩니다.</p>
<p>이들은 이전에 <em>객체 안전한(object safe)</em> 트레잇으로 알려져 있었습니다.</p>
<h3 id="경로-path"><a class="header" href="#경로-path">경로 (Path)</a></h3>
<p><a href="paths.html"><em>경로</em></a>는 현재 스코프나 다른 레벨의 <a href="glossary.html#namespace">네임스페이스</a> 계층 구조에 있는 <a href="glossary.html#entity">엔티티</a>를 참조하기 위해 사용되는 하나 이상의 경로 세그먼트 시퀀스입니다.</p>
<h3 id="프렐류드-prelude"><a class="header" href="#프렐류드-prelude">프렐류드 (Prelude)</a></h3>
<p>프렐류드(또는 러스트 프렐류드)는 모든 크레이트의 모든 모듈로 임포트되는 아이템들(주로 트레잇)의 작은 모음입니다. 프렐류드에 포함된 트레잇들은 어디에서나 사용됩니다.</p>
<h3 id="스코프-2"><a class="header" href="#스코프-2">스코프</a></h3>
<p><a href="names/scopes.html"><em>스코프</em></a>는 명명된 <a href="glossary.html#entity">엔티티</a>가 해당 이름으로 참조될 수 있는 소스 텍스트의 영역입니다.</p>
<h3 id="검사-대상-scrutinee"><a class="header" href="#검사-대상-scrutinee">검사 대상 (Scrutinee)</a></h3>
<p>검사 대상(scrutinee)은 <code>match</code> 표현식이나 유사한 패턴 매칭 구문에서 매칭의 대상이 되는 표현식입니다. 예를 들어, <code>match x { A =&gt; 1, B =&gt; 2 }</code>에서 표현식 <code>x</code>가 검사 대상입니다.</p>
<h3 id="크기-size"><a class="header" href="#크기-size">크기 (Size)</a></h3>
<p>값의 크기에는 두 가지 정의가 있습니다.</p>
<p>첫 번째는 해당 값을 저장하기 위해 얼마나 많은 메모리가 할당되어야 하는가입니다.</p>
<p>두 번째는 해당 아이템 타입을 가진 배열에서 연속된 요소들 사이의 바이트 단위 오프셋입니다.</p>
<p>이는 0을 포함하여 정렬의 배수입니다. 크기는 컴파일러 버전(새로운 최적화가 도입됨에 따라)이나 타겟 플랫폼(<code>usize</code>가 플랫폼마다 다른 것과 마찬가지)에 따라 달라질 수 있습니다.</p>
<p><a href="type-layout.html#size-and-alignment">자세히</a>.</p>
<h3 id="슬라이스-slice"><a class="header" href="#슬라이스-slice">슬라이스 (Slice)</a></h3>
<p>슬라이스는 연속된 시퀀스에 대한 동적 크기 뷰(view)이며, <code>[T]</code>로 작성됩니다.</p>
<p>주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 슬라이스 타입은 <code>&amp;[T]</code>이며, 가변 슬라이스 타입은 <code>&amp;mut [T]</code>입니다. 여기서 <code>T</code>는 요소의 타입을 나타냅니다.</p>
<h3 id="구문-statement"><a class="header" href="#구문-statement">구문 (Statement)</a></h3>
<p>구문은 컴퓨터에 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립 요소입니다.</p>
<h3 id="문자열-리터럴-string-literal"><a class="header" href="#문자열-리터럴-string-literal">문자열 리터럴 (String literal)</a></h3>
<p>문자열 리터럴은 최종 바이너리에 직접 저장되는 문자열이며, 따라서 <code>'static</code> 기간 동안 유효합니다.</p>
<p>그 타입은 <code>'static</code> 기간의 차용된 문자열 슬라이스인 <code>&amp;'static str</code>입니다.</p>
<h3 id="문자열-슬라이스-string-slice"><a class="header" href="#문자열-슬라이스-string-slice">문자열 슬라이스 (String slice)</a></h3>
<p>문자열 슬라이스는 러스트에서 가장 기본적인 문자열 타입으로, <code>str</code>로 작성됩니다. 주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 문자열 슬라이스 타입은 <code>&amp;str</code>이며, 가변 문자열 슬라이스 타입은 <code>&amp;mut str</code>입니다.</p>
<p>문자열 슬라이스는 항상 유효한 UTF-8입니다.</p>
<h3 id="트레잇-trait"><a class="header" href="#트레잇-trait">트레잇 (Trait)</a></h3>
<p>트레잇은 타입이 제공해야 하는 기능을 설명하는 데 사용되는 언어 아이템입니다. 이를 통해 타입은 자신의 동작에 대해 특정한 약속을 할 수 있습니다.</p>
<p>제네릭 함수와 제네릭 구조체는 트레잇을 사용하여 받아들이는 타입을 제한하거나 바인딩(bound)할 수 있습니다.</p>
<h3 id="터보피쉬-turbofish"><a class="header" href="#터보피쉬-turbofish">터보피쉬 (Turbofish)</a></h3>
<p>표현식에서 제네릭 파라미터를 포함하는 경로는 여는 괄호 앞에 <code>::</code>를 붙여야 합니다. 제네릭을 위한 화살괄호와 결합하면 <code>::&lt;&gt;</code>와 같이 물고기처럼 보입니다. 이 때문에 이 구문은 구어체로 터보피쉬 구문이라고 불립니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ok_num = Ok::&lt;_, ()&gt;(5);
let vec = [1, 2, 3].iter().map(|n| n * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>이 <code>::</code> 접두사는 쉼표로 구분된 목록에서 여러 비교 연산이 포함된 제네릭 경로의 모호성을 해결하기 위해 필요합니다. 접두사가 없을 때 모호해질 수 있는 예시는 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs">the bastion of the turbofish</a>를 참조하십시오.</p>
<h3 id="비피복-타입-uncovered-type"><a class="header" href="#비피복-타입-uncovered-type">비피복 타입 (Uncovered type)</a></h3>
<p>다른 타입의 인자로 나타나지 않는 타입입니다. 예를 들어, <code>T</code>는 피복되지 않았지만(uncovered), <code>Vec&lt;T&gt;</code>에서의 <code>T</code>는 피복되었습니다(covered). 이는 타입 인자에서만 의미가 있습니다.</p>
<h3 id="정의되지-않은-동작-undefined-behavior"><a class="header" href="#정의되지-않은-동작-undefined-behavior">정의되지 않은 동작 (Undefined behavior)</a></h3>
<p>명시되지 않은 컴파일 타임 또는 런타임 동작입니다. 이는 프로세스 종료나 손상, 부적절하거나 부정확하거나 의도하지 않은 계산, 또는 플랫폼별 결과 등을 초래할 수 있으나 이에 국한되지 않습니다. <a href="behavior-considered-undefined.html">자세히</a>.</p>
<h3 id="비거주-uninhabited"><a class="header" href="#비거주-uninhabited">비거주 (Uninhabited)</a></h3>
<p>생성자가 없어서 인스턴스화할 수 없는 타입입니다. 비거주 타입은 해당 타입의 값이 없다는 의미에서 “비어 있음“을 뜻합니다. 비거주 타입의 대표적인 예로는 <a href="types/never.html">never 타입</a> <code>!</code> 또는 변형이 없는 열거형인 <code>enum Never { }</code>가 있습니다. <a href="glossary.html#inhabited">거주(Inhabited)</a>의 반대말입니다.</p>
<script>
(function() {
    var fragments = {
        "#object-safe-traits": "glossary.html#dyn-compatible-traits",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
