<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Procedural macros - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/procedural-macros.md`;
                    } else {
                        canonical_href = `${base}/${lang}/procedural-macros.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/procedural-macros.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[macro.proc]</p>
<h1 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural macros</a></h1>
<p>r[macro.proc.intro] <em>Procedural macros</em> allow creating syntax extensions as execution of a function. Procedural macros come in one of three flavors:</p>
<ul>
<li><a href="#the-proc_macro-attribute">Function-like macros</a> - <code>custom!(...)</code></li>
<li><a href="macro.proc.derive">Derive macros</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="#the-proc_macro_attribute-attribute">Attribute macros</a> - <code>#[CustomAttribute]</code></li>
</ul>
<p>절차적 매크로를 사용하면 컴파일 타임에 Rust 구문을 사용하고 생성하는 코드를 실행할 수 있습니다. 절차적 매크로를 AST에서 다른 AST로의 함수로 생각할 수 있습니다.</p>
<p>r[macro.proc.def] Procedural macros must be defined in the root of a crate with the <a href="linkage.html">crate type</a> of <code>proc-macro</code>. The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.</p>
<blockquote>
<p>[!NOTE] When using Cargo, Procedural macro crates are defined with the <code>proc-macro</code> key in your manifest:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>r[macro.proc.result] As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</p>
<p>절차적 매크로는 컴파일 중에 실행되므로 컴파일러와 동일한 리소스를 갖습니다. 예를 들어, 표준 입력, 오류 및 출력은 컴파일러가 액세스할 수 있는 것과 동일합니다. 마찬가지로 파일 액세스도 동일합니다. 이 때문에 절차적 매크로는 <a href="../cargo/reference/build-scripts.html">Cargo의 빌드 스크립트</a>와 동일한 보안 문제를 가지고 있습니다.</p>
<p>r[macro.proc.error] Procedural macros have two ways of reporting errors. The first is to panic. The second is to emit a [<code>compile_error</code>] macro invocation.</p>
<p>r[macro.proc.proc_macro-crate]</p>
<h2 id="proc_macro-크레이트"><a class="header" href="#proc_macro-크레이트">proc_macro 크레이트</a></h2>
<p>r[macro.proc.proc_macro-crate.intro] Procedural macro crates almost always will link to the compiler-provided <a href="proc_macro"><code>proc_macro</code> crate</a>. The <code>proc_macro</code> crate provides types required for writing procedural macros and facilities to make it easier.</p>
<p>r[macro.proc.proc_macro-crate.token-stream] This crate primarily contains a <a href="proc_macro::TokenStream"><code>TokenStream</code></a> type. Procedural macros operate over <em>token streams</em> instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A <em>token stream</em> is roughly equivalent to <code>Vec&lt;TokenTree&gt;</code> where a <code>TokenTree</code> can roughly be thought of as lexical token. For example <code>foo</code> is an <code>Ident</code> token, <code>.</code> is a <code>Punct</code> token, and <code>1.2</code> is a <code>Literal</code> token. The <code>TokenStream</code> type, unlike <code>Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>
<p>r[macro.proc.proc_macro-crate.span] All tokens have an associated <code>Span</code>. A <code>Span</code> is an opaque value that cannot be modified but can be manufactured. <code>Span</code>s represent an extent of source code within a program and are primarily used for error reporting. While you cannot modify a <code>Span</code> itself, you can always change the <code>Span</code> <em>associated</em> with any token, such as through getting a <code>Span</code> from another token.</p>
<p>r[macro.proc.hygiene]</p>
<h2 id="절차적-매크로-위생"><a class="header" href="#절차적-매크로-위생">절차적 매크로 위생</a></h2>
<p>절차적 매크로는 _비위생적_입니다. 이는 출력 토큰 스트림이 바로 옆 코드에 인라인으로 작성된 것처럼 동작함을 의미합니다. 이는 외부 항목의 영향을 받고 외부 임포트에도 영향을 미친다는 것을 의미합니다.</p>
<p>매크로 작성자는 이 제한 사항을 감안할 때 가능한 한 많은 컨텍스트에서 매크로가 작동하도록 주의해야 합니다. 여기에는 종종 라이브러리의 아이템에 대한 절대 경로를 사용하거나(예: <code>Option</code> 대신 <code>::std::option::Option</code>) 생성된 함수가 다른 함수와 충돌할 가능성이 없는 이름을 갖도록 하는 것(예: <code>foo</code> 대신 <code>__internal_foo</code>)이 포함됩니다.</p>
<!-- TODO: rule name needs improvement -->
<!-- template:attributes -->
<p>r[macro.proc.proc_macro]</p>
<h2 id="the-proc_macro-attribute"><a class="header" href="#the-proc_macro-attribute">The <code>proc_macro</code> attribute</a></h2>
<p>r[macro.proc.proc_macro.intro] The <em><code>proc_macro</code> <a href="attributes.html">attribute</a></em> defines a [function-like][macro.invocation] procedural macro.</p>
<blockquote>
<p>[!EXAMPLE] This macro definition ignores its input and emits a function <code>answer</code> into its scope.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>We can use it in a binary crate to print “42” to standard output.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}</code></pre>
</blockquote>
<p>r[macro.proc.proc_macro.syntax] The <code>proc_macro</code> attribute uses the [MetaWord] syntax.</p>
<p>r[macro.proc.proc_macro.allowed-positions] The <code>proc_macro</code> attribute may only be applied to a <code>pub</code> function of type <code>fn(TokenStream) -&gt; TokenStream</code> where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. It must have the [“Rust” ABI][items.fn.extern]. No other function qualifiers are allowed. It must be located in the root of the crate.</p>
<p>r[macro.proc.proc_macro.duplicates] The <code>proc_macro</code> attribute may only be specified once on a function.</p>
<p>r[macro.proc.proc_macro.namespace] The <code>proc_macro</code> attribute publicly defines the macro in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate with the same name as the function.</p>
<p>r[macro.proc.proc_macro.behavior] A function-like macro invocation of a function-like procedural macro will pass what is inside the delimiters of the macro invocation as the input <a href="proc_macro::TokenStream"><code>TokenStream</code></a> argument and replace the entire macro invocation with the output <a href="proc_macro::TokenStream"><code>TokenStream</code></a> of the function.</p>
<p>r[macro.proc.proc_macro.invocation] Function-like procedural macros may be invoked in any macro invocation position, which includes:</p>
<ul>
<li><a href="statements.html">Statements</a></li>
<li><a href="expressions.html">Expressions</a></li>
<li><a href="patterns.html">패턴</a></li>
<li><a href="types.html#type-expressions">Type expressions</a></li>
<li><a href="items.html">Item</a> positions, including items in <a href="items/external-blocks.html"><code>extern</code> blocks</a></li>
<li>Inherent and trait <a href="items/implementations.html">implementations</a></li>
<li><a href="items/traits.html">Trait definitions</a></li>
</ul>
<!-- template:attributes -->
<p>r[macro.proc.derive]</p>
<h2 id="the-proc_macro_derive-attribute"><a class="header" href="#the-proc_macro_derive-attribute">The <code>proc_macro_derive</code> attribute</a></h2>
<p>r[macro.proc.derive.intro] Applying the <em><code>proc_macro_derive</code> <a href="attributes.html">attribute</a></em> to a function defines a <em>derive macro</em> that can be invoked by the <a href="attributes/derive.html"><code>derive</code> attribute</a>. These macros are given the token stream of a <a href="items/structs.html">struct</a>, <a href="items/enumerations.html">enum</a>, or <a href="items/unions.html">union</a> definition and can emit new <a href="items.html">items</a> after it. They can also declare and use <a href="#derive-macro-helper-attributes">derive macro helper attributes</a>.</p>
<blockquote>
<p>[!EXAMPLE] This derive macro ignores its input and appends tokens that define a function.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>To use it, we might write:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</code></pre>
</blockquote>
<p>r[macro.proc.derive.syntax] The syntax for the <code>proc_macro_derive</code> attribute is:</p>
<pre><code class="language-grammar attributes">@root ProcMacroDeriveAttribute -&gt;
    `proc_macro_derive` `(` DeriveMacroName ( `,` DeriveMacroAttributes )? `,`? `)`

DeriveMacroName -&gt; IDENTIFIER

DeriveMacroAttributes -&gt;
    `attributes` `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`?)? `)`
</code></pre>
<p>The name of the derive macro is given by [DeriveMacroName]. The optional <code>attributes</code> argument is described in [macro.proc.derive.attributes].</p>
<p>r[macro.proc.derive.allowed-positions] The <code>proc_macro_derive</code> attribute may only be applied to a <code>pub</code> function with the [Rust ABI][items.fn.extern] defined in the root of the crate with a type of <code>fn(TokenStream) -&gt; TokenStream</code>  where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. The function may be <code>const</code> and may use <code>extern</code> to explicitly specify the Rust ABI, but it may not use any other [qualifiers][FunctionQualifiers] (e.g. it may not be <code>async</code> or <code>unsafe</code>).</p>
<p>r[macro.proc.derive.duplicates] The <code>proc_macro_derive</code> attribute may be used only once on a function.</p>
<p>r[macro.proc.derive.namespace] The <code>proc_macro_derive</code> attribute publicly defines the derive macro in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate.</p>
<p>r[macro.proc.derive.output] The input <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is the token stream of the item to which the <code>derive</code> attribute is applied. The output <a href="proc_macro::TokenStream"><code>TokenStream</code></a> must be a (possibly empty) set of items. These items are appended following the input item within the same <a href="items/modules.html">module</a> or <a href="expressions/block-expr.html">block</a>.</p>
<p>r[macro.proc.derive.attributes]</p>
<h3 id="파생-매크로-헬퍼-속성"><a class="header" href="#파생-매크로-헬퍼-속성">파생 매크로 헬퍼 속성</a></h3>
<p>r[macro.proc.derive.attributes.intro] Derive macros can declare <em>derive macro helper attributes</em> to be used within the scope of the <a href="items.html">item</a> to which the derive macro is applied. These <a href="attributes.html">attributes</a> are <a href="attributes.html#active-and-inert-attributes">inert</a>. While their purpose is to be used by the macro that declared them, they can be seen by any macro.</p>
<p>r[macro.proc.derive.attributes.decl] A helper attribute for a derive macro is declared by adding its identifier to the <code>attributes</code> list in the <code>proc_macro_derive</code> attribute.</p>
<blockquote>
<p>[!EXAMPLE] This declares a helper attribute and then ignores it.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type="proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">
</span>#[proc_macro_derive(WithHelperAttr, attributes(helper))]
pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</code></pre>
<p>To use it, we might write:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(WithHelperAttr)]
struct Struct {
    #[helper] field: (),
}</code></pre>
</blockquote>
<p>r[macro.proc.derive.attributes.scope] When a derive macro invocation is applied to an item, the helper attributes introduced by that derive macro become in scope 1) for attributes that are applied to that item and are applied lexically after the derive macro invocation and 2) for attributes that are applied to fields and variants inside of the item.</p>
<blockquote>
<p>[!NOTE] rustc currently allows derive helpers to be used before the macro that introduces them. Such derive helpers used out of order may not shadow other attribute macros. This behavior is deprecated and slated for removal.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[helper] // Deprecated, hard error in the future.
#[derive(WithHelperAttr)]
struct Struct {
    field: (),
}</code></pre>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/79202">Rust issue #79202</a>.</p>
</blockquote>
<!-- template:attributes -->
<p>r[macro.proc.attribute]</p>
<h2 id="the-proc_macro_attribute-attribute"><a class="header" href="#the-proc_macro_attribute-attribute">The <code>proc_macro_attribute</code> attribute</a></h2>
<p>r[macro.proc.attribute.intro] The <em><code>proc_macro_attribute</code> <a href="attributes.html">attribute</a></em> defines an <em>attribute macro</em> which can be used as an <a href="attributes.html">outer attribute</a>.</p>
<blockquote>
<p>[!EXAMPLE] This attribute macro takes the input stream and emits it as-is, effectively being a no-op attribute.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</code></pre>
</blockquote>
<blockquote>
<p>[!EXAMPLE] This shows, in the output of the compiler, the stringified <a href="proc_macro::TokenStream"><code>TokenStream</code>s</a> that attribute macros see.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("attr: \"{attr}\"");
    println!("item: \"{item}\"");
    item
}</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function.
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() {}"

// Example: Attribute with input.
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// Example: Multiple tokens in the input.
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: "multiple =&gt; tokens"
// out: item: "fn invoke3() {}"

// Example: Delimiters in the input.
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"</code></pre>
</blockquote>
<p>r[macro.proc.attribute.syntax] The <code>proc_macro_attribute</code> attribute uses the [MetaWord] syntax.</p>
<p>r[macro.proc.attribute.allowed-positions] The <code>proc_macro_attribute</code> attribute may only be applied to a <code>pub</code> function of type <code>fn(TokenStream, TokenStream) -&gt; TokenStream</code> where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. It must have the [“Rust” ABI][items.fn.extern]. No other function qualifiers are allowed. It must be located in the root of the crate.</p>
<p>r[macro.proc.attribute.duplicates] The <code>proc_macro_attribute</code> attribute may only be specified once on a function.</p>
<p>r[macro.proc.attribute.namespace] The <code>proc_macro_attribute</code> attribute defines the attribute in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate with the same name as the function.</p>
<p>r[macro.proc.attribute.use-positions] Attribute macros can only be used on:</p>
<ul>
<li><a href="items.html">아이템</a></li>
<li>Items in <a href="items/external-blocks.html"><code>extern</code> blocks</a></li>
<li>Inherent and trait <a href="items/implementations.html">implementations</a></li>
<li><a href="items/traits.html">Trait definitions</a></li>
</ul>
<p>r[macro.proc.attribute.behavior] The first <a href="proc_macro::TokenStream"><code>TokenStream</code></a> parameter is the delimited token tree following the attribute’s name but not including the outer delimiters. If the applied attribute contains only the attribute name or the attribute name followed by empty delimiters, the <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is empty.</p>
<p>The second <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is the rest of the <a href="items.html">item</a>, including other <a href="attributes.html">attributes</a> on the <a href="items.html">item</a>.</p>
<p>The item to which the attribute is applied is replaced by the zero or more items in the returned <a href="proc_macro::TokenStream"><code>TokenStream</code></a>.</p>
<p>r[macro.proc.token]</p>
<h2 id="선언적-매크로-토큰과-절차적-매크로-토큰"><a class="header" href="#선언적-매크로-토큰과-절차적-매크로-토큰">선언적 매크로 토큰과 절차적 매크로 토큰</a></h2>
<p>r[macro.proc.token.intro] Declarative <code>macro_rules</code> macros and procedural macros use similar, but different definitions for tokens (or rather <a href="proc_macro::TokenTree"><code>TokenTree</code>s</a>.)</p>
<p>r[macro.proc.token.macro_rules] Token trees in <code>macro_rules</code> (corresponding to <code>tt</code> matchers) are defined as</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 모든 연산자, 단일 문자 및 다중 문자 연산자 모두 포함(<code>+</code>, <code>+=</code>).
<ul>
<li>이 집합에는 작은따옴표 <code>'</code>가 포함되지 않음에 유의하세요.</li>
</ul>
</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 절대 리터럴 토큰의 일부가 아니며, 별도의 연산자 토큰임에 유의하세요.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>라이프타임 (<code>'ident</code>)</li>
<li><code>macro_rules</code>의 메타변수 치환 (예: <code>mac</code>의 확장 후 <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code>에서의 <code>$my_expr</code>. 전달된 표현식과 관계없이 단일 토큰 트리로 간주됨)</li>
</ul>
<p>r[macro.proc.token.tree] Token trees in procedural macros are defined as</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 연산자에 사용되는 모든 구두점 문자(<code>+</code>, 단 <code>+=</code>는 아님) 및 작은따옴표 <code>'</code> 문자(주로 라이프타임에 사용됨. 라이프타임 분리 및 결합 동작은 아래 참조)</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 정수 및 부동 소수점 리터럴의 일부로 지원됩니다.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
</ul>
<p>r[macro.proc.token.conversion.intro] Mismatches between these two definitions are accounted for when token streams are passed to and from procedural macros.<br />
Note that the conversions below may happen lazily, so they might not happen if the tokens are not actually inspected.</p>
<p>r[macro.proc.token.conversion.to-proc_macro] When passed to a proc-macro</p>
<ul>
<li>모든 다중 문자 연산자는 단일 문자로 분리됩니다.</li>
<li>라이프타임은 <code>'</code> 문자와 식별자로 분리됩니다.</li>
<li>The keyword metavariable <a href="macro.decl.hygiene.crate"><code>$crate</code></a> is passed as a single identifier.</li>
<li>All other metavariable substitutions are represented as their underlying token streams.
<ul>
<li>Such token streams may be wrapped into delimited groups (<a href="proc_macro::Group"><code>Group</code></a>) with implicit delimiters (<a href="proc_macro::Delimiter::None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li>
<li><code>tt</code> 및 <code>ident</code> 치환은 절대 이러한 그룹으로 래핑되지 않으며 항상 기본 토큰 트리로 표현됩니다.</li>
</ul>
</li>
</ul>
<p>r[macro.proc.token.conversion.from-proc_macro] When emitted from a proc macro</p>
<ul>
<li>구두점 문자는 가능한 경우 다중 문자 연산자로 결합됩니다.</li>
<li>식별자와 결합된 작은따옴표 <code>'</code>는 라이프타임으로 결합됩니다.</li>
<li>Negative literals are converted into two tokens (the <code>-</code> and the literal) possibly wrapped into a delimited group (<a href="proc_macro::Group"><code>Group</code></a>) with implicit delimiters (<a href="proc_macro::Delimiter::None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li>
</ul>
<p>r[macro.proc.token.doc-comment] Note that neither declarative nor procedural macros support doc comment tokens (e.g. <code>/// Doc</code>), so they are always converted to token streams representing their equivalent <code>#[doc = r"str"]</code> attributes when passed to macros.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros-by-example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="crates-and-source-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros-by-example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="crates-and-source-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
