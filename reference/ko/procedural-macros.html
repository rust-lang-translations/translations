<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>절차적 매크로 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/procedural-macros.md`;
                    } else {
                        canonical_href = `${base}/${lang}/procedural-macros.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/procedural-macros.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-macro.proc"><a class="rule-link" href="#r-macro.proc" title="macro.proc"><span>[macro<wbr>.proc]<span/></a></div>
<h2 id="절차적-매크로"><a class="header" href="#절차적-매크로">절차적 매크로</a></h2>
<div class="rule" id="r-macro.proc.intro"><a class="rule-link" href="#r-macro.proc.intro" title="macro.proc.intro"><span>[macro<wbr>.proc<wbr>.intro]<span/></a></div>
<p>_절차적 매크로_는 함수의 실행으로 구문 확장을 생성할 수 있습니다. 절차적 매크로는 세 가지 종류 중 하나입니다:</p>
<ul>
<li><a href="#function-like-procedural-macros">함수형 매크로</a> - <code>custom!(...)</code></li>
<li><a href="#derive-macros">파생 매크로</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="#attribute-macros">속성 매크로</a> - <code>#[CustomAttribute]</code></li>
</ul>
<p>절차적 매크로를 사용하면 컴파일 타임에 Rust 구문을 사용하고 생성하는 코드를 실행할 수 있습니다. 절차적 매크로를 AST에서 다른 AST로의 함수로 생각할 수 있습니다.</p>
<div class="rule" id="r-macro.proc.def"><a class="rule-link" href="#r-macro.proc.def" title="macro.proc.def"><span>[macro<wbr>.proc<wbr>.def]<span/></a></div>
<p>절차적 매크로는 <code>proc-macro</code>의 <a href="linkage.html">크레이트 타입</a>을 가진 크레이트의 루트에 정의되어야 합니다. 매크로는 정의된 크레이트에서 사용할 수 없으며, 다른 크레이트에서 임포트될 때만 사용할 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: Cargo를 사용할 때, 절차적 매크로 크레이트는 매니페스트에서 <code>proc-macro</code> 키로 정의됩니다:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<div class="rule" id="r-macro.proc.result"><a class="rule-link" href="#r-macro.proc.result" title="macro.proc.result"><span>[macro<wbr>.proc<wbr>.result]<span/></a></div>
<p>함수로서, 그들은 구문을 반환하거나, 패닉하거나, 또는 무한정 반복해야 합니다. 반환된 구문은 절차적 매크로의 종류에 따라 구문을 대체하거나 추가합니다. 패닉은 컴파일러에 의해 잡혀 컴파일러 오류로 바뀝니다. 무한 루프는 컴파일러에 의해 잡히지 않아 컴파일러를 멈추게 합니다.</p>
<p>절차적 매크로는 컴파일 중에 실행되므로 컴파일러와 동일한 리소스를 갖습니다. 예를 들어, 표준 입력, 오류 및 출력은 컴파일러가 액세스할 수 있는 것과 동일합니다. 마찬가지로 파일 액세스도 동일합니다. 이 때문에 절차적 매크로는 <a href="../cargo/reference/build-scripts.html">Cargo의 빌드 스크립트</a>와 동일한 보안 문제를 가지고 있습니다.</p>
<div class="rule" id="r-macro.proc.error"><a class="rule-link" href="#r-macro.proc.error" title="macro.proc.error"><span>[macro<wbr>.proc<wbr>.error]<span/></a></div>
<p>절차적 매크로는 오류를 보고하는 두 가지 방법이 있습니다. 첫 번째는 패닉하는 것입니다. 두 번째는 <a href="../core/macro.compile_error.html"><code>compile_error</code></a> 매크로 호출을 내보내는 것입니다.</p>
<div class="rule" id="r-macro.proc.proc_macro"><a class="rule-link" href="#r-macro.proc.proc_macro" title="macro.proc.proc_macro"><span>[macro<wbr>.proc<wbr>.proc_macro]<span/></a></div>
<h3 id="proc_macro-크레이트"><a class="header" href="#proc_macro-크레이트">proc_macro 크레이트</a></h3>
<div class="rule" id="r-macro.proc.proc_macro.intro"><a class="rule-link" href="#r-macro.proc.proc_macro.intro" title="macro.proc.proc_macro.intro"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.intro]<span/></a></div>
<p>절차적 매크로 크레이트는 거의 항상 컴파일러에서 제공하는 <a href="../proc_macro/index.html"><code>proc_macro</code> 크레이트</a>에 링크됩니다. <code>proc_macro</code> 크레이트는 절차적 매크로를 작성하는 데 필요한 유형과 이를 더 쉽게 만드는 기능을 제공합니다.</p>
<div class="rule" id="r-macro.proc.proc_macro.token-stream"><a class="rule-link" href="#r-macro.proc.proc_macro.token-stream" title="macro.proc.proc_macro.token-stream"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.token-stream]<span/></a></div>
<p>이 크레이트는 주로 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 타입을 포함합니다. 절차적 매크로는 AST 노드 대신 _토큰 스트림_을 통해 작동하며, 이는 컴파일러와 절차적 매크로 모두에게 시간이 지나도 훨씬 더 안정적인 인터페이스입니다. _토큰 스트림_은 대략 <code>Vec&lt;TokenTree&gt;</code>와 동일하며, 여기서 <code>TokenTree</code>는 어휘 토큰으로 생각할 수 있습니다. 예를 들어 <code>foo</code>는 <code>Ident</code> 토큰이고, <code>.</code>는 <code>Punct</code> 토큰이며, <code>1.2</code>는 <code>Literal</code> 토큰입니다. <code>TokenStream</code> 타입은 <code>Vec&lt;TokenTree&gt;</code>와 달리 복제 비용이 저렴합니다.</p>
<div class="rule" id="r-macro.proc.proc_macro.span"><a class="rule-link" href="#r-macro.proc.proc_macro.span" title="macro.proc.proc_macro.span"><span>[macro<wbr>.proc<wbr>.proc_macro<wbr>.span]<span/></a></div>
<p>모든 토큰에는 연관된 <code>Span</code>이 있습니다. <code>Span</code>은 수정할 수 없지만 제조할 수 있는 불투명한 값입니다. <code>Span</code>은 프로그램 내 소스 코드의 범위를 나타내며 주로 오류 보고에 사용됩니다. <code>Span</code> 자체를 수정할 수는 없지만, 다른 토큰에서 <code>Span</code>을 가져오는 것과 같이 모든 토큰과 <em>연관된</em> <code>Span</code>은 언제든지 변경할 수 있습니다.</p>
<div class="rule" id="r-macro.proc.hygiene"><a class="rule-link" href="#r-macro.proc.hygiene" title="macro.proc.hygiene"><span>[macro<wbr>.proc<wbr>.hygiene]<span/></a></div>
<h3 id="절차적-매크로-위생"><a class="header" href="#절차적-매크로-위생">절차적 매크로 위생</a></h3>
<p>절차적 매크로는 _비위생적_입니다. 이는 출력 토큰 스트림이 바로 옆 코드에 인라인으로 작성된 것처럼 동작함을 의미합니다. 이는 외부 항목의 영향을 받고 외부 임포트에도 영향을 미친다는 것을 의미합니다.</p>
<p>매크로 작성자는 이 제한 사항을 감안할 때 가능한 한 많은 컨텍스트에서 매크로가 작동하도록 주의해야 합니다. 여기에는 종종 라이브러리의 아이템에 대한 절대 경로를 사용하거나(예: <code>Option</code> 대신 <code>::std::option::Option</code>) 생성된 함수가 다른 함수와 충돌할 가능성이 없는 이름을 갖도록 하는 것(예: <code>foo</code> 대신 <code>__internal_foo</code>)이 포함됩니다.</p>
<div class="rule" id="r-macro.proc.function"><a class="rule-link" href="#r-macro.proc.function" title="macro.proc.function"><span>[macro<wbr>.proc<wbr>.function]<span/></a></div>
<h3 id="함수형-절차적-매크로"><a class="header" href="#함수형-절차적-매크로">함수형 절차적 매크로</a></h3>
<div class="rule" id="r-macro.proc.function.intro"><a class="rule-link" href="#r-macro.proc.function.intro" title="macro.proc.function.intro"><span>[macro<wbr>.proc<wbr>.function<wbr>.intro]<span/></a></div>
<p>_함수형 절차적 매크로_는 매크로 호출 연산자(<code>!</code>)를 사용하여 호출되는 절차적 매크로입니다.</p>
<div class="rule" id="r-macro.proc.function.def"><a class="rule-link" href="#r-macro.proc.function.def" title="macro.proc.function.def"><span>[macro<wbr>.proc<wbr>.function<wbr>.def]<span/></a></div>
<p>이 매크로는 <code>proc_macro</code> <a href="attributes.html">속성</a>과 <code>(TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다. 입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 매크로 호출의 구분 기호 안에 있는 것이고 출력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 전체 매크로 호출을 대체합니다.</p>
<div class="rule" id="r-macro.proc.function.namespace"><a class="rule-link" href="#r-macro.proc.function.namespace" title="macro.proc.function.namespace"><span>[macro<wbr>.proc<wbr>.function<wbr>.namespace]<span/></a></div>
<p><code>proc_macro</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 매크로를 정의합니다.</p>
<p>예를 들어, 다음 매크로 정의는 입력을 무시하고 <code>answer</code> 함수를 해당 범위로 출력합니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>그런 다음 바이너리 크레이트에서 이를 사용하여 표준 출력으로 “42“를 출력합니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}</code></pre>
<div class="rule" id="r-macro.proc.function.invocation"><a class="rule-link" href="#r-macro.proc.function.invocation" title="macro.proc.function.invocation"><span>[macro<wbr>.proc<wbr>.function<wbr>.invocation]<span/></a></div>
<p>함수형 절차적 매크로는 <a href="statements.html">문</a>, <a href="expressions.html">표현식</a>, <a href="patterns.html">패턴</a>, <a href="types.html#type-expressions">타입 표현식</a>, <a href="items/external-blocks.html"><code>extern</code> 블록</a>의 아이템, 고유 및 트레잇 <a href="items/implementations.html">구현</a>, 그리고 <a href="items/traits.html">트레잇 정의</a>를 포함한 <a href="items.html">아이템</a> 위치 등 모든 매크로 호출 위치에서 호출될 수 있습니다.</p>
<div class="rule" id="r-macro.proc.derive"><a class="rule-link" href="#r-macro.proc.derive" title="macro.proc.derive"><span>[macro<wbr>.proc<wbr>.derive]<span/></a></div>
<h3 id="파생-매크로"><a class="header" href="#파생-매크로">파생 매크로</a></h3>
<div class="rule" id="r-macro.proc.derive.intro"><a class="rule-link" href="#r-macro.proc.derive.intro" title="macro.proc.derive.intro"><span>[macro<wbr>.proc<wbr>.derive<wbr>.intro]<span/></a></div>
<p>_파생 매크로_는 <a href="attributes/derive.html"><code>derive</code> 속성</a>에 대한 새로운 입력을 정의합니다. 이 매크로는 <a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형</a>, 또는 <a href="items/unions.html">공용체</a>의 토큰 스트림이 주어지면 새로운 <a href="items.html">아이템</a>을 생성할 수 있습니다. 또한 <a href="#derive-macro-helper-attributes">파생 매크로 헬퍼 속성</a>을 정의할 수도 있습니다.</p>
<div class="rule" id="r-macro.proc.derive.def"><a class="rule-link" href="#r-macro.proc.derive.def" title="macro.proc.derive.def"><span>[macro<wbr>.proc<wbr>.derive<wbr>.def]<span/></a></div>
<p>사용자 정의 파생 매크로는 <code>proc_macro_derive</code> 속성과 <code>(TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다.</p>
<div class="rule" id="r-macro.proc.derive.namespace"><a class="rule-link" href="#r-macro.proc.derive.namespace" title="macro.proc.derive.namespace"><span>[macro<wbr>.proc<wbr>.derive<wbr>.namespace]<span/></a></div>
<p><code>proc_macro_derive</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 사용자 정의 파생을 정의합니다.</p>
<div class="rule" id="r-macro.proc.derive.output"><a class="rule-link" href="#r-macro.proc.derive.output" title="macro.proc.derive.output"><span>[macro<wbr>.proc<wbr>.derive<wbr>.output]<span/></a></div>
<p>입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <code>derive</code> 속성을 가진 아이템의 토큰 스트림입니다. 출력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 입력 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>의 아이템이 있는 <a href="items/modules.html">모듈</a> 또는 <a href="expressions/block-expr.html">블록</a>에 추가되는 아이템 집합이어야 합니다.</p>
<p>다음은 파생 매크로의 예입니다. 입력으로 유용한 작업을 수행하는 대신 <code>answer</code> 함수를 추가하기만 합니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>그리고 나서 해당 파생 매크로를 사용합니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</code></pre>
<div class="rule" id="r-macro.proc.derive.attributes"><a class="rule-link" href="#r-macro.proc.derive.attributes" title="macro.proc.derive.attributes"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes]<span/></a></div>
<h4 id="파생-매크로-헬퍼-속성"><a class="header" href="#파생-매크로-헬퍼-속성">파생 매크로 헬퍼 속성</a></h4>
<div class="rule" id="r-macro.proc.derive.attributes.intro"><a class="rule-link" href="#r-macro.proc.derive.attributes.intro" title="macro.proc.derive.attributes.intro"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes<wbr>.intro]<span/></a></div>
<p>파생 매크로는 자신이 있는 <a href="items.html">아이템</a>의 범위에 추가적인 <a href="attributes.html">속성</a>을 추가할 수 있습니다. 해당 속성은 _파생 매크로 헬퍼 속성_이라고 합니다. 이러한 속성은 <a href="attributes.html#active-and-inert-attributes">비활성</a>이며, 유일한 목적은 자신을 정의한 파생 매크로에 제공되는 것입니다. 즉, 모든 매크로에서 볼 수 있습니다.</p>
<div class="rule" id="r-macro.proc.derive.attributes.def"><a class="rule-link" href="#r-macro.proc.derive.attributes.def" title="macro.proc.derive.attributes.def"><span>[macro<wbr>.proc<wbr>.derive<wbr>.attributes<wbr>.def]<span/></a></div>
<p>헬퍼 속성을 정의하는 방법은 <code>proc_macro_derive</code> 매크로에 <code>attributes</code> 키를 넣고 헬퍼 속성의 이름인 식별자의 쉼표로 구분된 목록을 사용하는 것입니다.</p>
<p>예를 들어, 다음 파생 매크로는 헬퍼 속성 <code>helper</code>를 정의하지만, 궁극적으로는 아무것도 하지 않습니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type="proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</code></pre>
<p>그리고 나서 구조체에서 파생 매크로를 사용합니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}</code></pre>
<div class="rule" id="r-macro.proc.attribute"><a class="rule-link" href="#r-macro.proc.attribute" title="macro.proc.attribute"><span>[macro<wbr>.proc<wbr>.attribute]<span/></a></div>
<h3 id="속성-매크로"><a class="header" href="#속성-매크로">속성 매크로</a></h3>
<div class="rule" id="r-macro.proc.attribute.intro"><a class="rule-link" href="#r-macro.proc.attribute.intro" title="macro.proc.attribute.intro"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.intro]<span/></a></div>
<p>_속성 매크로_는 <a href="items/external-blocks.html"><code>extern</code> 블록</a>의 아이템, 고유 및 트레잇 <a href="items/implementations.html">구현</a>, 그리고 <a href="items/traits.html">트레잇 정의</a>를 포함한 <a href="items.html">아이템</a>에 첨부될 수 있는 새로운 <a href="attributes.html">외부 속성</a>을 정의합니다.</p>
<div class="rule" id="r-macro.proc.attribute.def"><a class="rule-link" href="#r-macro.proc.attribute.def" title="macro.proc.attribute.def"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.def]<span/></a></div>
<p>속성 매크로는 <code>(TokenStream, TokenStream) -&gt; TokenStream</code> 시그니처를 가진 <code>proc_macro_attribute</code> <a href="attributes.html">속성</a>을 가진 <a href="visibility-and-privacy.html">공개</a> <a href="items/functions.html">함수</a>에 의해 정의됩니다. 첫 번째 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 속성 이름을 따르는 구분된 토큰 트리이며, 외부 구분 기호는 포함하지 않습니다. 속성이 단순한 속성 이름으로 작성된 경우, 속성 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 비어 있습니다. 두 번째 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <a href="items.html">아이템</a>의 다른 <a href="attributes.html">속성</a>을 포함한 <a href="items.html">아이템</a>의 나머지 부분입니다. 반환된 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>은 <a href="items.html">아이템</a>을 임의의 수의 <a href="items.html">아이템</a>으로 대체합니다.</p>
<div class="rule" id="r-macro.proc.attribute.namespace"><a class="rule-link" href="#r-macro.proc.attribute.namespace" title="macro.proc.attribute.namespace"><span>[macro<wbr>.proc<wbr>.attribute<wbr>.namespace]<span/></a></div>
<p><code>proc_macro_attribute</code> 속성은 크레이트의 루트에 있는 <a href="names/namespaces.html">매크로 네임스페이스</a>에 속성을 정의합니다.</p>
<p>예를 들어, 이 속성 매크로는 입력 스트림을 받아서 그대로 반환하므로, 사실상 속성의 no-op입니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</code></pre>
<p>다음 예제는 속성 매크로가 보는 문자열화된 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code>s</a>을 보여줍니다. 출력은 컴파일러의 출력에 표시됩니다. 출력은 “out:” 접두사가 붙은 함수 뒤의 주석에 표시됩니다.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("attr: \"{attr}\"");
    println!("item: \"{item}\"");
    item
}</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// 예: 기본 함수
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() {}"

// 예: 입력이 있는 속성
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// 예: 입력에 여러 토큰이 있는 경우
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: "multiple =&gt; tokens"
// out: item: "fn invoke3() {}"

// 예:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"</code></pre>
<div class="rule" id="r-macro.proc.token"><a class="rule-link" href="#r-macro.proc.token" title="macro.proc.token"><span>[macro<wbr>.proc<wbr>.token]<span/></a></div>
<h3 id="선언적-매크로-토큰과-절차적-매크로-토큰"><a class="header" href="#선언적-매크로-토큰과-절차적-매크로-토큰">선언적 매크로 토큰과 절차적 매크로 토큰</a></h3>
<div class="rule" id="r-macro.proc.token.intro"><a class="rule-link" href="#r-macro.proc.token.intro" title="macro.proc.token.intro"><span>[macro<wbr>.proc<wbr>.token<wbr>.intro]<span/></a></div>
<p>선언적 <code>macro_rules</code> 매크로와 절차적 매크로는 토큰(또는 <a href="../proc_macro/enum.TokenTree.html"><code>TokenTree</code>s</a>)에 대해 비슷하지만 다른 정의를 사용합니다.</p>
<div class="rule" id="r-macro.proc.token.macro_rules"><a class="rule-link" href="#r-macro.proc.token.macro_rules" title="macro.proc.token.macro_rules"><span>[macro<wbr>.proc<wbr>.token<wbr>.macro_rules]<span/></a></div>
<p><code>macro_rules</code>의 토큰 트리(<code>tt</code> 매처에 해당)는 다음과 같이 정의됩니다.</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 모든 연산자, 단일 문자 및 다중 문자 연산자 모두 포함(<code>+</code>, <code>+=</code>).
<ul>
<li>이 집합에는 작은따옴표 <code>'</code>가 포함되지 않음에 유의하세요.</li>
</ul>
</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 절대 리터럴 토큰의 일부가 아니며, 별도의 연산자 토큰임에 유의하세요.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>라이프타임 (<code>'ident</code>)</li>
<li><code>macro_rules</code>의 메타변수 치환 (예: <code>mac</code>의 확장 후 <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code>에서의 <code>$my_expr</code>. 전달된 표현식과 관계없이 단일 토큰 트리로 간주됨)</li>
</ul>
<div class="rule" id="r-macro.proc.token.tree"><a class="rule-link" href="#r-macro.proc.token.tree" title="macro.proc.token.tree"><span>[macro<wbr>.proc<wbr>.token<wbr>.tree]<span/></a></div>
<p>절차적 매크로에서 토큰 트리는 다음과 같이 정의됩니다</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 연산자에 사용되는 모든 구두점 문자(<code>+</code>, 단 <code>+=</code>는 아님) 및 작은따옴표 <code>'</code> 문자(주로 라이프타임에 사용됨. 라이프타임 분리 및 결합 동작은 아래 참조)</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 정수 및 부동 소수점 리터럴의 일부로 지원됩니다.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
</ul>
<div class="rule" id="r-macro.proc.token.conversion.intro"><a class="rule-link" href="#r-macro.proc.token.conversion.intro" title="macro.proc.token.conversion.intro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.intro]<span/></a></div>
<p>이 두 정의 간의 불일치는 토큰 스트림이 절차적 매크로로 전달되거나 반환될 때 고려됩니다.<br />
아래의 변환은 지연되어 발생할 수 있으므로, 토큰이 실제로 검사되지 않으면 발생하지 않을 수 있음에 유의하세요.</p>
<div class="rule" id="r-macro.proc.token.conversion.to-proc_macro"><a class="rule-link" href="#r-macro.proc.token.conversion.to-proc_macro" title="macro.proc.token.conversion.to-proc_macro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.to-proc_macro]<span/></a></div>
<p>절차적 매크로로 전달될 때</p>
<ul>
<li>모든 다중 문자 연산자는 단일 문자로 분리됩니다.</li>
<li>라이프타임은 <code>'</code> 문자와 식별자로 분리됩니다.</li>
<li>모든 메타변수 치환은 기본 토큰 스트림으로 표현됩니다.
<ul>
<li>이러한 토큰 스트림은 파싱 우선순위를 보존하기 위해 필요한 경우 암시적 구분자(<a href="../proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>)를 가진 구분된 그룹(<a href="../proc_macro/struct.Group.html"><code>Group</code></a>)으로 래핑될 수 있습니다.</li>
<li><code>tt</code> 및 <code>ident</code> 치환은 절대 이러한 그룹으로 래핑되지 않으며 항상 기본 토큰 트리로 표현됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.proc.token.conversion.from-proc_macro"><a class="rule-link" href="#r-macro.proc.token.conversion.from-proc_macro" title="macro.proc.token.conversion.from-proc_macro"><span>[macro<wbr>.proc<wbr>.token<wbr>.conversion<wbr>.from-proc_macro]<span/></a></div>
<p>절차적 매크로에서 방출될 때</p>
<ul>
<li>구두점 문자는 가능한 경우 다중 문자 연산자로 결합됩니다.</li>
<li>식별자와 결합된 작은따옴표 <code>'</code>는 라이프타임으로 결합됩니다.</li>
<li>음수 리터럴은 두 개의 토큰(<code>-</code>와 리터럴)으로 변환되며, 파싱 우선순위를 보존하기 위해 필요한 경우 암시적 구분자(<a href="../proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>)를 가진 구분된 그룹(<a href="../proc_macro/struct.Group.html"><code>Group</code></a>)으로 래핑될 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.proc.token.doc-comment"><a class="rule-link" href="#r-macro.proc.token.doc-comment" title="macro.proc.token.doc-comment"><span>[macro<wbr>.proc<wbr>.token<wbr>.doc-comment]<span/></a></div>
<p>선언적 매크로와 절차적 매크로 모두 문서 주석 토큰(예: <code>/// Doc</code>)을 지원하지 않으므로, 매크로로 전달될 때는 항상 이에 상응하는 <code>#[doc = r"str"]</code> 속성을 나타내는 토큰 스트림으로 변환된다는 점에 유의하세요.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros-by-example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="crates-and-source-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros-by-example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="crates-and-source-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
