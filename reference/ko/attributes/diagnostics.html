<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>진단 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/attributes/diagnostics.md`;
                    } else {
                        canonical_href = `${base}/${lang}/attributes/diagnostics.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/attributes/diagnostics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-attributes.diagnostics"><a class="rule-link" href="#r-attributes.diagnostics" title="attributes.diagnostics"><span>[attributes<wbr>.diagnostics]<span/></a></div>
<h1 id="진단-속성"><a class="header" href="#진단-속성">진단 속성</a></h1>
<p>다음 <a href="../attributes.html">속성들</a>은 컴파일 중에 진단 메시지를 제어하거나 생성하는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint"><a class="rule-link" href="#r-attributes.diagnostics.lint" title="attributes.diagnostics.lint"><span>[attributes<wbr>.diagnostics<wbr>.lint]<span/></a></div>
<h2 id="린트lint-체크-속성"><a class="header" href="#린트lint-체크-속성">린트(Lint) 체크 속성</a></h2>
<p>린트 체크는 도달할 수 없는 코드나 누락된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴을 지적합니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint.level"><a class="rule-link" href="#r-attributes.diagnostics.lint.level" title="attributes.diagnostics.lint.level"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.level]<span/></a></div>
<p>린트 속성 <code>allow</code>, <code>expect</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>는 속성이 적용되는 엔티티의 린트 레벨을 변경하기 위한 린트 이름 목록을 지정하기 위해 <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> 구문을 사용합니다.</p>
<p>임의의 린트 체크 <code>C</code>에 대해:</p>
<div class="rule" id="r-attributes.diagnostics.lint.allow"><a class="rule-link" href="#r-attributes.diagnostics.lint.allow" title="attributes.diagnostics.lint.allow"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.allow]<span/></a></div>
<ul>
<li><code>#[allow(C)]</code>는 <code>C</code>에 대한 체크를 무시하여 위반 사항이 보고되지 않도록 합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.expect"><a class="rule-link" href="#r-attributes.diagnostics.lint.expect" title="attributes.diagnostics.lint.expect"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.expect]<span/></a></div>
<ul>
<li><code>#[expect(C)]</code>는 린트 <code>C</code>가 발생할 것으로 예상됨을 나타냅니다. 이 속성은 <code>C</code>의 발생을 억제하거나, 예상이 충족되지 않은 경우 경고를 발생시킵니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.warn"><a class="rule-link" href="#r-attributes.diagnostics.lint.warn" title="attributes.diagnostics.lint.warn"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.warn]<span/></a></div>
<ul>
<li><code>#[warn(C)]</code>는 <code>C</code> 위반에 대해 경고하지만 컴파일을 계속합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.deny"><a class="rule-link" href="#r-attributes.diagnostics.lint.deny" title="attributes.diagnostics.lint.deny"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.deny]<span/></a></div>
<ul>
<li><code>#[deny(C)]</code>는 <code>C</code> 위반을 발견하면 에러를 발생시킵니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostics.lint.forbid"><a class="rule-link" href="#r-attributes.diagnostics.lint.forbid" title="attributes.diagnostics.lint.forbid"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.forbid]<span/></a></div>
<ul>
<li><code>#[forbid(C)]</code>는 <code>deny(C)</code>와 동일하지만, 이후에 린트 레벨을 변경하는 것도 금지합니다.</li>
</ul>
<blockquote>
<p>참고: <code>rustc</code>에서 지원하는 린트 체크 목록과 기본 설정은 <code>rustc -W help</code>를 통해 확인할 수 있으며, <a href="../../rustc/lints/index.html">rustc 책</a>에도 문서화되어 있습니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // 여기서 누락된 문서는 무시됩니다.
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // 여기서 누락된 문서는 에러를 발생시킵니다.
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.override"><a class="rule-link" href="#r-attributes.diagnostics.lint.override" title="attributes.diagnostics.lint.override"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.override]<span/></a></div>
<p>린트 속성은 이전 속성에서 지정된 레벨을 오버라이드할 수 있습니다. 단, 금지된(forbidden) 린트 레벨을 변경하려고 시도해서는 안 됩니다 (단, <code>deny</code>는 <code>forbid</code> 컨텍스트 내부에서 허용되지만 무시됩니다). 이전 속성이란 구문 트리에서 상위 레벨에 있는 속성이나, 소스 코드 순서상 왼쪽에서 오른쪽으로 나열된 동일한 엔티티의 이전 속성을 의미합니다.</p>
<p>이 예시는 <code>allow</code>와 <code>warn</code>을 사용하여 특정 체크를 켜고 끄는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // 여기서 누락된 문서는 무시됩니다.
        pub fn undocumented_one() -&gt; i32 { 1 }

        // 위의 allow에도 불구하고,
        // 여기서 누락된 문서는 경고를 발생시킵니다.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시는 특정 린트 체크에 대해 <code>allow</code>나 <code>expect</code>를 사용하는 것을 금지하기 위해 <code>forbid</code>를 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // 경고를 토글하려고 시도하면 여기서 에러가 발생합니다.
    #[allow(missing_docs)]
    /// 2를 반환합니다.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>rustc</code>는 <a href="../../rustc/lints/levels.html#via-compiler-flag">커맨드 라인</a>에서 린트 레벨을 설정하는 것을 허용하며, 보고되는 린트에 대해 <a href="../../rustc/lints/levels.html#capping-lints">상한(caps) 설정</a>도 지원합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.lint.reason"><a class="rule-link" href="#r-attributes.diagnostics.lint.reason" title="attributes.diagnostics.lint.reason"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.reason]<span/></a></div>
<h3 id="린트-사유lint-reasons"><a class="header" href="#린트-사유lint-reasons">린트 사유(Lint Reasons)</a></h3>
<p>모든 린트 속성은 특정 속성이 추가된 이유에 대한 문맥을 제공하기 위해 추가적인 <code>reason</code> 매개변수를 지원합니다. 이 사유는 린트가 정의된 레벨에서 내보내질 때 린트 메시지의 일부로 표시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `keyword_idents`는 기본적으로 허용됩니다. 여기서는 에디션을 업데이트할 때
// 식별자 마이그레이션을 피하기 위해 이를 거부(deny)합니다.
#![deny(
    keyword_idents,
    reason = "미래 호환성을 위해 이러한 식별자들을 피하고 싶습니다"
)]

// 이 이름은 Rust 2015 에디션에서 허용되었습니다. 우리는 여전히 피하고자 합니다
// 미래 호환성을 확보하고 최종 사용자에게 혼란을 주지 않기 위함입니다.
fn dyn() {}
<span class="boring">}</span></code></pre></pre>
<p>사유와 함께 린트를 허용한 또 다른 예시입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

pub fn get_path() -&gt; PathBuf {
    // `allow` 속성의 `reason` 매개변수는 독자를 위한 문서 역할을 합니다.
    #[allow(unused_mut, reason = "이것은 일부 플랫폼에서만 수정됩니다")]
    let mut file_name = PathBuf::from("git");

    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");

    file_name
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect"><a class="rule-link" href="#r-attributes.diagnostics.expect" title="attributes.diagnostics.expect"><span>[attributes<wbr>.diagnostics<wbr>.expect]<span/></a></div>
<h3 id="expect-속성"><a class="header" href="#expect-속성"><code>#[expect]</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostics.expect.intro"><a class="rule-link" href="#r-attributes.diagnostics.expect.intro" title="attributes.diagnostics.expect.intro"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.intro]<span/></a></div>
<p><code>#[expect(C)]</code> 속성은 린트 <code>C</code>에 대한 린트 기대를 생성합니다. 동일한 위치의 <code>#[warn(C)]</code> 속성이 린트를 발생시키는 경우 기대가 충족됩니다. 린트 <code>C</code>가 발생하지 않아 기대가 충족되지 않으면, 해당 속성 위치에서 <code>unfulfilled_lint_expectations</code> 린트가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // 이 `#[expect]` 속성은 `unused_variables` 린트가 다음 문장에서 발생할 것이라는
    // 린트 기대를 생성합니다. `question` 변수가 `println!` 매크로에 의해
    // 사용되므로 이 기대는 충족되지 않습니다. 따라서 해당 속성 위치에서
    // `unfulfilled_lint_expectations` 린트가 발생합니다.
    #[expect(unused_variables)]
    let question = "누가 바다 저 깊은 곳 파인애플에 살까요?";
    println!("{question}");

    // 이 `#[expect]` 속성은 `answer` 변수가 전혀 사용되지 않으므로 충족될
    // 린트 기대를 생성합니다. 평소라면 발생했을 `unused_variables` 린트는
    // 억제됩니다. 해당 문장이나 속성에 대해 어떤 경고도 발생하지 않습니다.
    #[expect(unused_variables)]
    let answer = "네모네모 스폰지밥!";
}</code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect.fulfillment"><a class="rule-link" href="#r-attributes.diagnostics.expect.fulfillment" title="attributes.diagnostics.expect.fulfillment"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.fulfillment]<span/></a></div>
<p>린트 기대는 <code>expect</code> 속성에 의해 억제된 린트 발생에 의해서만 충족됩니다. 만약 <code>allow</code>나 <code>warn</code> 같은 다른 레벨 속성에 의해 해당 스코프에서 린트 레벨이 수정되면, 린트 발생은 그에 맞춰 처리되며 기대는 충족되지 않은 상태로 남습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[expect(unused_variables)]
fn select_song() {
    // 이것은 `warn` 속성에 정의된 대로 `unused_variables` 린트를 warn 레벨로
    // 내보낼 것입니다. 이는 함수 위에 있는 기대를 충족시키지 못합니다.
    #[warn(unused_variables)]
    let song_name = "Crab Rave";

    // `allow` 속성은 린트 발생을 억제합니다. 이는 `expect` 속성이 아닌
    // `allow` 속성에 의해 억제되었으므로 함수 위의 기대를
    // 충족시키지 못합니다.
    #[allow(unused_variables)]
    let song_creator = "Noisestorm";

    // 이 `expect` 속성은 변수 위치에서 `unused_variables` 린트 발생을
    // 억제할 것입니다. 이 린트 발생은 지역적인 expect 속성에 의해
    // 억제되었으므로 함수 위의 `expect` 속성은 여전히 충족되지 않습니다.
    #[expect(unused_variables)]
    let song_version = "Monstercat Release";
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.expect.independent"><a class="rule-link" href="#r-attributes.diagnostics.expect.independent" title="attributes.diagnostics.expect.independent"><span>[attributes<wbr>.diagnostics<wbr>.expect<wbr>.independent]<span/></a></div>
<p><code>expect</code> 속성이 여러 린트를 포함하는 경우, 각각은 개별적으로 기대됩니다. 린트 그룹의 경우 그룹 내의 한 린트라도 발생했다면 충분합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 기대는 함수 내부의 사용되지 않은 값에 의해 충족될 것입니다.
// 발생한 `unused_variables` 린트가 `unused` 린트 그룹에 속하기 때문입니다.
#[expect(unused)]
pub fn thoughts() {
    let unused = "예시가 떨어져 가고 있어요";
}

pub fn another_example() {
    // 이 속성은 두 개의 린트 기대를 생성합니다. `unused_mut` 린트는
    // 억제되며 첫 번째 기대를 충족시킬 것입니다. `unused_variables` 린트는
    // 변수가 사용되므로 발생하지 않을 것입니다. 따라서 그 기대는 충족되지
    // 않은 상태로 남게 되며, 경고가 발생할 것입니다.
    #[expect(unused_mut, unused_variables)]
    let mut link = "https://www.rust-lang.org/";

    println!("우리 커뮤니티에 오신 것을 환영합니다: {link}");
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: <code>#[expect(unfulfilled_lint_expectations)]</code>의 동작은 현재 항상 <code>unfulfilled_lint_expectations</code> 린트를 생성하도록 정의되어 있습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.lint.group"><a class="rule-link" href="#r-attributes.diagnostics.lint.group" title="attributes.diagnostics.lint.group"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.group]<span/></a></div>
<h3 id="린트-그룹"><a class="header" href="#린트-그룹">린트 그룹</a></h3>
<p>린트들은 관련된 린트들의 레벨을 함께 조정할 수 있도록 명명된 그룹으로 조직될 수 있습니다. 명명된 그룹을 사용하는 것은 해당 그룹 내의 린트들을 나열하는 것과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 "unused" 그룹의 모든 린트를 허용합니다.
#[allow(unused)]
// 이는 "unused" 그룹의 "unused_must_use" 린트를
// deny 레벨로 오버라이드합니다.
#[deny(unused_must_use)]
fn example() {
    // "unused_variables" 린트가 "unused" 그룹에 속해 있으므로
    // 경고를 생성하지 않습니다.
    let x = 1;
    // 결과가 사용되지 않았고 "unused_must_use"가 "deny"로 설정되었으므로
    // 에러를 생성합니다.
    std::fs::remove_file("some_file"); // 에러: 반드시 사용되어야 할 `Result`가 사용되지 않음
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.group.warnings"><a class="rule-link" href="#r-attributes.diagnostics.lint.group.warnings" title="attributes.diagnostics.lint.group.warnings"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.group<wbr>.warnings]<span/></a></div>
<p>“warnings“라는 이름의 특별한 그룹이 있는데, 이는 “warn” 레벨의 모든 린트를 포함합니다. “warnings” 그룹은 속성 순서를 무시하며, 해당 엔티티 내에서 경고를 발생시킬 모든 린트에 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">unsafe fn an_unsafe_fn() {}
</span>// 이 두 속성의 순서는 중요하지 않습니다.
#[deny(warnings)]
// unsafe_code 린트는 보통 기본적으로 "allow"입니다.
#[warn(unsafe_code)]
fn example_err() {
    // `unsafe_code` 경고가 "deny"로 격상되었으므로 이것은 에러입니다.
    unsafe { an_unsafe_fn() } // 에러: `unsafe` 블록 사용
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.lint.tool"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool" title="attributes.diagnostics.lint.tool"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool]<span/></a></div>
<h3 id="도구-린트-속성"><a class="header" href="#도구-린트-속성">도구 린트 속성</a></h3>
<div class="rule" id="r-attributes.diagnostics.lint.tool.intro"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool.intro" title="attributes.diagnostics.lint.tool.intro"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool<wbr>.intro]<span/></a></div>
<p>도구 린트를 사용하면 범위가 지정된(scoped) 린트를 사용하여 특정 도구의 린트를 <code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code> 할 수 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.lint.tool.activation"><a class="rule-link" href="#r-attributes.diagnostics.lint.tool.activation" title="attributes.diagnostics.lint.tool.activation"><span>[attributes<wbr>.diagnostics<wbr>.lint<wbr>.tool<wbr>.activation]<span/></a></div>
<p>도구 린트는 관련 도구가 활성화된 경우에만 체크됩니다. 만약 <code>allow</code>와 같은 린트 속성이 존재하지 않는 도구 린트를 참조하더라도, 컴파일러는 해당 도구를 사용하기 전까지는 존재하지 않는 린트에 대해 경고하지 않습니다.</p>
<p>그 외에는 일반 린트 속성과 동일하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// clippy의 `pedantic` 린트 그룹 전체를 warn으로 설정합니다.
#![warn(clippy::pedantic)]
// clippy의 `filter_map` 린트 경고를 억제합니다.
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// 이 함수에서만 clippy의 `cmp_nan` 린트를 억제합니다.
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}</code></pre></pre>
<blockquote>
<p>참고: <code>rustc</code>는 현재 “<a href="https://github.com/rust-lang/rust-clippy">clippy</a>“와 “<a href="../../rustdoc/lints.html">rustdoc</a>” 도구 린트를 인식합니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostics.deprecated"><a class="rule-link" href="#r-attributes.diagnostics.deprecated" title="attributes.diagnostics.deprecated"><span>[attributes<wbr>.diagnostics<wbr>.deprecated]<span/></a></div>
<h2 id="deprecated-속성"><a class="header" href="#deprecated-속성"><code>deprecated</code> 속성</a></h2>
<div class="rule" id="r-attributes.diagnostics.deprecated.intro"><a class="rule-link" href="#r-attributes.diagnostics.deprecated.intro" title="attributes.diagnostics.deprecated.intro"><span>[attributes<wbr>.diagnostics<wbr>.deprecated<wbr>.intro]<span/></a></div>
<p>_<code>deprecated</code> 속성_은 아이템을 사용 중단된 것(deprecated)으로 표시합니다. <code>rustc</code>는 <code>#[deprecated]</code> 아이템 사용 시 경고를 발생시킵니다. <code>rustdoc</code>은 사용 가능한 경우 <code>since</code> 버전과 <code>note</code>를 포함하여 아이템의 사용 중단 여부를 표시합니다.</p>
<div class="rule" id="r-attributes.diagnostics.deprecated.syntax"><a class="rule-link" href="#r-attributes.diagnostics.deprecated.syntax" title="attributes.diagnostics.deprecated.syntax"><span>[attributes<wbr>.diagnostics<wbr>.deprecated<wbr>.syntax]<span/></a></div>
<p><code>deprecated</code> 속성은 여러 형식을 가집니다:</p>
<ul>
<li><code>deprecated</code> — 일반적인 메시지를 발생시킵니다.</li>
<li><code>deprecated = "message"</code> — 사용 중단 메시지에 주어진 문자열을 포함합니다.</li>
<li>두 개의 선택적 필드가 있는 <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문:
<ul>
<li><code>since</code> — 아이템이 사용 중단된 버전 번호를 지정합니다. <code>rustc</code>는 현재 이 문자열을 해석하지 않지만, <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>와 같은 외부 도구가 이 값의 유효성을 검사할 수 있습니다.</li>
<li><code>note</code> — 사용 중단 메시지에 포함되어야 할 문자열을 지정합니다. 이는 일반적으로 사용 중단에 대한 설명과 권장되는 대안을 제공하는 데 사용됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.deprecated.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.deprecated.allowed-positions" title="attributes.diagnostic.deprecated.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.deprecated<wbr>.allowed-positions]<span/></a></div>
<p><code>deprecated</code> 속성은 모든 <a href="../items.html">아이템</a>, <a href="../items/traits.html">트레잇 아이템</a>, <a href="../items/enumerations.html">열거형 변형</a>, <a href="../items/structs.html">구조체 필드</a>, <a href="../items/external-blocks.html">외부 블록 아이템</a> 또는 <a href="../macros-by-example.html">매크로 정의</a>에 적용될 수 있습니다. <a href="../items/implementations.html#trait-implementations">트레잇 구현 아이템</a>에는 적용할 수 없습니다. <a href="../items/modules.html">모듈</a>이나 <a href="../items/implementations.html">구현</a>과 같이 다른 아이템을 포함하는 아이템에 적용되면 모든 자식 아이템이 사용 중단 속성을 상속받습니다.</p>
<!-- NOTE: It is only rejected for trait impl items
(AnnotationKind::Prohibited). In all other locations, it is silently ignored.
Tuple struct fields are ignored.
-->
<p>예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = "5.2.0", note = "foo는 거의 사용되지 않았습니다. 사용자들은 대신 bar를 사용해야 합니다")]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a>에 동기와 자세한 내용이 포함되어 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use"><a class="rule-link" href="#r-attributes.diagnostics.must_use" title="attributes.diagnostics.must_use"><span>[attributes<wbr>.diagnostics<wbr>.must_use]<span/></a></div>
<h2 id="must_use-속성"><a class="header" href="#must_use-속성"><code>must_use</code> 속성</a></h2>
<div class="rule" id="r-attributes.diagnostics.must_use.intro"><a class="rule-link" href="#r-attributes.diagnostics.must_use.intro" title="attributes.diagnostics.must_use.intro"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.intro]<span/></a></div>
<p>_<code>must_use</code> 속성_은 값이 “사용“되지 않았을 때 진단 경고를 발생시키는 데 사용됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostics.must_use.allowed-positions" title="attributes.diagnostics.must_use.allowed-positions"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.allowed-positions]<span/></a></div>
<p><code>must_use</code> 속성은 사용자 정의 복합 타입(<a href="../items/structs.html">구조체</a>, <a href="../items/enumerations.html">열거형</a>, <a href="../items/unions.html">공용체</a>), <a href="../items/functions.html">함수</a>, 그리고 <a href="../items/traits.html">트레잇</a>에 적용될 수 있습니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.message"><a class="rule-link" href="#r-attributes.diagnostics.must_use.message" title="attributes.diagnostics.must_use.message"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.message]<span/></a></div>
<p><code>must_use</code> 속성은 <code>#[must_use = "예시 메시지"]</code>와 같이 <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> 구문을 사용하여 메시지를 포함할 수 있습니다. 메시지는 경고와 함께 표시됩니다.</p>
<div class="rule" id="r-attributes.diagnostics.must_use.type"><a class="rule-link" href="#r-attributes.diagnostics.must_use.type" title="attributes.diagnostics.must_use.type"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.type]<span/></a></div>
<p>사용자 정의 복합 타입에 사용된 경우, <a href="../statements.html#expression-statements">표현식 구문</a>의 <a href="../expressions.html">표현식</a>이 해당 타입을 가지면 <code>unused_must_use</code> 린트를 위반하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // 몇몇 필드들
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// `unused_must_use` 린트를 위반합니다.
MustUse::new();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.fn"><a class="rule-link" href="#r-attributes.diagnostics.must_use.fn" title="attributes.diagnostics.must_use.fn"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.fn]<span/></a></div>
<p>함수에 사용된 경우, <a href="../statements.html#expression-statements">표현식 구문</a>의 <a href="../expressions.html">표현식</a>이 해당 함수에 대한 <a href="../expressions/call-expr.html">호출 표현식</a>이면 <code>unused_must_use</code> 린트를 위반하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반합니다.
five();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait" title="attributes.diagnostics.must_use.trait"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait]<span/></a></div>
<p><a href="../items/traits.html">트레잇 선언</a>에 사용된 경우, 해당 트레잇의 <a href="../types/impl-trait.html">impl 트레잇</a> 또는 <a href="../types/trait-object.html">dyn 트레잇</a>을 반환하는 함수에 대한 <a href="../statements.html#expression-statements">표현식 구문</a>의 <a href="../expressions/call-expr.html">호출 표현식</a>은 <code>unused_must_use</code> 린트를 위반합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// `unused_must_use` 린트를 위반합니다.
get_critical();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait-function"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait-function" title="attributes.diagnostics.must_use.trait-function"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait-function]<span/></a></div>
<p>트레잇 선언 내의 함수에 사용된 경우, 호출 표현식이 해당 트레잇 구현체의 함수인 경우에도 동일하게 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// `unused_must_use` 린트를 위반합니다.
5i32.use_me();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-attributes.diagnostics.must_use.trait-impl-function"><a class="rule-link" href="#r-attributes.diagnostics.must_use.trait-impl-function" title="attributes.diagnostics.must_use.trait-impl-function"><span>[attributes<wbr>.diagnostics<wbr>.must_use<wbr>.trait-impl-function]<span/></a></div>
<p>트레잇 구현 내의 함수에 사용된 경우, 이 속성은 아무런 동작도 하지 않습니다.</p>
<blockquote>
<p>참고: 값을 포함하는 사소한 무부하(no-op) 표현식은 린트를 위반하지 않습니다. 예시로는 <a href="../special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않는 타입으로 값을 감싼 후 해당 타입을 사용하지 않거나, 사용되지 않는 <a href="../expressions/block-expr.html">블록 표현식</a>의 마지막 표현식이 되는 경우가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 이들 중 어느 것도 `unused_must_use` 린트를 위반하지 않습니다.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>참고: <code>must_use</code> 값이 의도적으로 버려질 때는 패턴이 <code>_</code>인 <a href="../statements.html#let-statements">let 문</a>을 사용하는 것이 관용적입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반하지 않습니다.
let _ = five();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-attributes.diagnostic.namespace"><a class="rule-link" href="#r-attributes.diagnostic.namespace" title="attributes.diagnostic.namespace"><span>[attributes<wbr>.diagnostic<wbr>.namespace]<span/></a></div>
<h2 id="diagnostic-도구-속성-네임스페이스"><a class="header" href="#diagnostic-도구-속성-네임스페이스"><code>diagnostic</code> 도구 속성 네임스페이스</a></h2>
<div class="rule" id="r-attributes.diagnostic.namespace.intro"><a class="rule-link" href="#r-attributes.diagnostic.namespace.intro" title="attributes.diagnostic.namespace.intro"><span>[attributes<wbr>.diagnostic<wbr>.namespace<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic]</code> 속성 네임스페이스는 컴파일 타임 에러 메시지에 영향을 주는 속성들을 위한 공간입니다. 이러한 속성들이 제공하는 힌트가 반드시 사용된다는 보장은 없습니다.</p>
<div class="rule" id="r-attributes.diagnostic.namespace.unknown-invalid-syntax"><a class="rule-link" href="#r-attributes.diagnostic.namespace.unknown-invalid-syntax" title="attributes.diagnostic.namespace.unknown-invalid-syntax"><span>[attributes<wbr>.diagnostic<wbr>.namespace<wbr>.unknown-invalid-syntax]<span/></a></div>
<p>이 네임스페이스 내의 알 수 없는 속성들은 수용되지만, 사용되지 않는 속성에 대해 경고를 내보낼 수 있습니다. 추가적으로, 알려진 속성에 대한 유효하지 않은 입력은 보통 경고가 됩니다 (자세한 내용은 속성 정의를 참조하세요). 이는 의미 없는 속성이나 옵션들을 계속 유지할 필요 없이 미래에 속성을 추가하거나 제거하고 입력을 변경할 수 있도록 하기 위함입니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented" title="attributes.diagnostic.on_unimplemented"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented]<span/></a></div>
<h3 id="diagnosticon_unimplemented-속성"><a class="header" href="#diagnosticon_unimplemented-속성"><code>diagnostic::on_unimplemented</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.intro"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.intro" title="attributes.diagnostic.on_unimplemented.intro"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic::on_unimplemented]</code> 속성은 트레잇이 요구되지만 특정 타입에 구현되지 않은 상황에서 보통 생성되는 에러 메시지를 보완하도록 컴파일러에 주는 힌트입니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.allowed-positions" title="attributes.diagnostic.on_unimplemented.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.allowed-positions]<span/></a></div>
<p>이 속성은 <a href="../items/traits.html">트레잇 선언</a>에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.syntax"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.syntax" title="attributes.diagnostic.on_unimplemented.syntax"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.syntax]<span/></a></div>
<p>이 속성은 입력을 지정하기 위해 <a href="../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 구문을 사용하지만, 전방 및 후방 호환성을 제공하기 위해 속성에 대한 잘못된 형식의 입력은 에러로 간주되지 않습니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.keys"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.keys" title="attributes.diagnostic.on_unimplemented.keys"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.keys]<span/></a></div>
<p>다음 키들은 주어진 의미를 갖습니다:</p>
<ul>
<li><code>message</code> — 최상위 레벨 에러 메시지를 위한 텍스트입니다.</li>
<li><code>label</code> — 에러 메시지에서 잘못된 코드 내에 표시될 라벨을 위한 텍스트입니다.</li>
<li><code>note</code> — 추가적인 노트를 제공합니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.note-repetition"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.note-repetition" title="attributes.diagnostic.on_unimplemented.note-repetition"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.note-repetition]<span/></a></div>
<p><code>note</code> 옵션은 여러 번 나타날 수 있으며, 그 결과 여러 개의 노트 메시지가 내보내집니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.repetition"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.repetition" title="attributes.diagnostic.on_unimplemented.repetition"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.repetition]<span/></a></div>
<p>다른 옵션들이 여러 번 나타나는 경우, 해당 옵션의 첫 번째 출현이 실제로 사용되는 값을 지정합니다. 이후의 출현은 경고를 발생시킵니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.unknown-keys"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.unknown-keys" title="attributes.diagnostic.on_unimplemented.unknown-keys"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.unknown-keys]<span/></a></div>
<p>알 수 없는 키에 대해서는 경고가 발생합니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-string"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.format-string" title="attributes.diagnostic.on_unimplemented.format-string"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.format-string]<span/></a></div>
<p>세 가지 옵션 모두 문자열을 인수로 받으며, <a href="../../alloc/fmt/index.html"><code>std::fmt</code></a> 문자열과 동일한 포맷팅 방식을 사용하여 해석됩니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.format-parameters"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.format-parameters" title="attributes.diagnostic.on_unimplemented.format-parameters"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.format-parameters]<span/></a></div>
<p>주어진 이름을 가진 포맷 매개변수들은 다음 텍스트로 대체됩니다:</p>
<ul>
<li><code>{Self}</code> — 트레잇을 구현하는 타입의 이름입니다.</li>
<li><code>{</code> <em>제네릭매개변수이름</em> <code>}</code> — 주어진 제네릭 매개변수에 대한 제네릭 인수의 타입 이름입니다.</li>
</ul>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-formats"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.invalid-formats" title="attributes.diagnostic.on_unimplemented.invalid-formats"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.invalid-formats]<span/></a></div>
<p>그 외의 포맷 매개변수는 경고를 발생시키지만, 문자열에는 그대로 포함됩니다.</p>
<div class="rule" id="r-attributes.diagnostic.on_unimplemented.invalid-string"><a class="rule-link" href="#r-attributes.diagnostic.on_unimplemented.invalid-string" title="attributes.diagnostic.on_unimplemented.invalid-string"><span>[attributes<wbr>.diagnostic<wbr>.on_unimplemented<wbr>.invalid-string]<span/></a></div>
<p>유효하지 않은 포맷 문자열은 경고를 발생시킬 수 있지만, 허용은 됩니다. 다만 의도한 대로 표시되지 않을 수 있습니다. 포맷 지정자(Format specifiers)는 경고를 발생시킬 수 있지만, 무시됩니다.</p>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024">#[diagnostic::on_unimplemented(
    message = "`{Self}`에 구현된 `ImportantTrait&lt;{A}&gt;`에 대한 메시지",
    label = "나의 라벨",
    note = "노트 1",
    note = "노트 2"
)]
trait ImportantTrait&lt;A&gt; {}

fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {}

fn main() {
    use_my_trait(String::new());
}</code></pre></pre>
<p>컴파일러는 다음과 같은 에러 메시지를 생성할 수 있습니다:</p>
<pre><code class="language-text">error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` implemented for `String`
  --&gt; src/main.rs:14:18
   |
14 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String`
   = note: Note 1
   = note: Note 2
</code></pre>
<h3 id="diagnosticdo_not_recommend-속성"><a class="header" href="#diagnosticdo_not_recommend-속성"><code>diagnostic::do_not_recommend</code> 속성</a></h3>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend" title="attributes.diagnostic.do_not_recommend"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend]<span/></a></div>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.intro"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.intro" title="attributes.diagnostic.do_not_recommend.intro"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.intro]<span/></a></div>
<p><code>#[diagnostic::do_not_recommend]</code> 속성은 진단 메시지의 일부로 해당 트레잇 구현을 표시하지 않도록 컴파일러에 주는 힌트입니다.</p>
<blockquote>
<p><strong>참고</strong>: 권장 사항을 억제하는 것은 해당 권장 사항이 프로그래머에게 보통 유용하지 않을 것임을 알고 있는 경우에 유용할 수 있습니다. 이는 광범위한 blanket 구현에서 종종 발생합니다. 권장 사항이 프로그래머를 잘못된 길로 안내할 수 있거나, 트레잇 구현이 노출하고 싶지 않은 내부 상세 정보일 수 있거나, 프로그래머가 바운드를 충족시킬 수 없는 경우 등이 해당됩니다.</p>
<p>예를 들어, 요구되는 트레잇을 구현하지 않은 타입에 대한 에러 메시지에서, 컴파일러는 트레잇 구현 내의 특정 바운드만 아니었다면 요구 사항을 충족했을 트레잇 구현을 찾을 수도 있습니다. 컴파일러는 사용자에게 구현이 존재하지만 트레잇 구현 내의 바운드가 문제라고 말할 수 있습니다. <code>#[diagnostic::do_not_recommend]</code> 속성은 컴파일러에게 해당 트레잇 구현에 대해 사용자에게 알리지 <em>말고</em>, 대신 단순히 해당 타입이 요구되는 트레잇을 구현하지 않는다고 알리도록 하는 데 사용될 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.allowed-positions"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.allowed-positions" title="attributes.diagnostic.do_not_recommend.allowed-positions"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.allowed-positions]<span/></a></div>
<p>이 속성은 <a href="../items/implementations.html#trait-implementations">트레잇 구현 아이템</a>에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다.</p>
<div class="rule" id="r-attributes.diagnostic.do_not_recommend.syntax"><a class="rule-link" href="#r-attributes.diagnostic.do_not_recommend.syntax" title="attributes.diagnostic.do_not_recommend.syntax"><span>[attributes<wbr>.diagnostic<wbr>.do_not_recommend<wbr>.syntax]<span/></a></div>
<p>이 속성은 어떤 인수도 받지 않지만, 예상치 못한 인수가 있어도 에러로 간주되지 않습니다.</p>
<p>다음 예시에는 SQL 라이브러리에서 사용되는 <code>Expression</code> 타입으로 임의의 타입을 캐스팅하는 데 사용되는 <code>AsExpression</code>이라는 트레잇이 있습니다. 여기에는 <code>AsExpression</code>을 인수로 받는 <code>check</code>라는 메서드가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">pub trait Expression {
</span><span class="boring">    type SqlType;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait AsExpression&lt;ST&gt; {
</span><span class="boring">    type Expression: Expression&lt;SqlType = ST&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Text;
</span><span class="boring">pub struct Integer;
</span><span class="boring">
</span><span class="boring">pub struct Bound&lt;T&gt;(T);
</span><span class="boring">pub struct SelectInt;
</span><span class="boring">
</span><span class="boring">impl Expression for SelectInt {
</span><span class="boring">    type SqlType = Integer;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Expression for Bound&lt;T&gt; {
</span><span class="boring">    type SqlType = T;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Integer&gt; for i32 {
</span><span class="boring">    type Expression = Bound&lt;Integer&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Text&gt; for &amp;'_ str {
</span><span class="boring">    type Expression = Bound&lt;Text&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Foo for T where T: Expression {}
</span>
// 권장 사항을 변경하려면 이 라인의 주석을 해제하세요.
// #[diagnostic::do_not_recommend]
impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
where
    T: Expression&lt;SqlType = ST&gt;,
{
    type Expression = T;
}

trait Foo: Expression + Sized {
    fn check&lt;T&gt;(&amp;self, _: T) -&gt; &lt;T as AsExpression&lt;&lt;Self as Expression&gt;::SqlType&gt;&gt;::Expression
    where
        T: AsExpression&lt;Self::SqlType&gt;,
    {
        todo!()
    }
}

fn main() {
    SelectInt.check("bar");
}</code></pre></pre>
<p><code>SelectInt</code> 타입의 <code>check</code> 메서드는 <code>Integer</code> 타입을 기대합니다. <code>AsExpression</code> 트레잇에 의해 <code>i32</code> 타입이 <code>Integer</code>로 변환되므로 <code>i32</code> 타입으로 호출하는 것은 작동합니다. 하지만 문자열로 호출하는 것은 작동하지 않으며, 다음과 같은 에러를 발생시킬 수 있습니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: Expression` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `Expression` is not implemented for `&amp;str`
   |
   = help: the following other types implement trait `Expression`:
             Bound&lt;T&gt;
             SelectInt
note: required for `&amp;str` to implement `AsExpression&lt;Integer&gt;`
  --&gt; src/main.rs:45:13
   |
45 | impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
   |             ^^^^^^^^^^^^^^^^     ^
46 | where
47 |     T: Expression&lt;SqlType = ST&gt;,
   |        ------------------------ unsatisfied trait bound introduced here
</code></pre>
<p><code>AsExpression</code>에 대한 blanket <code>impl</code>에 <code>#[diagnostic::do_no_recommend]</code> 속성을 추가하면 메시지가 다음과 같이 변경됩니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: AsExpression&lt;Integer&gt;` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
   |
   = help: the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
           but trait `AsExpression&lt;Text&gt;` is implemented for it
   = help: for that trait implementation, expected `Text`, found `Integer`
</code></pre>
<p>첫 번째 에러 메시지는 <code>&amp;str</code>과 <code>Expression</code> 사이의 관계에 대한 다소 혼란스러운 에러 메시지와, blanket 구현에서의 충족되지 않은 트레잇 바운드를 포함합니다. <code>#[diagnostic::do_no_recommend]</code>를 추가한 후에는 권장 사항을 위해 blanket 구현을 더 이상 고려하지 않습니다. 메시지는 문자열을 <code>Integer</code>로 변환할 수 없음을 나타내며 조금 더 명확해질 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../attributes/derive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../attributes/codegen.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../attributes/derive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../attributes/codegen.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
