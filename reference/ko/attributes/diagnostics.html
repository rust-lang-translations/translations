<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>진단 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/attributes/diagnostics.md`;
                    } else {
                        canonical_href = `${base}/${lang}/attributes/diagnostics.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/attributes/diagnostics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[attributes.diagnostics]</p>
<h1 id="진단-속성"><a class="header" href="#진단-속성">진단 속성</a></h1>
<p>다음 <a href="../attributes.html">속성들</a>은 컴파일 중에 진단 메시지를 제어하거나 생성하는 데 사용됩니다.</p>
<p>r[attributes.diagnostics.lint]</p>
<h2 id="린트lint-체크-속성"><a class="header" href="#린트lint-체크-속성">린트(Lint) 체크 속성</a></h2>
<p>린트 체크는 도달할 수 없는 코드나 누락된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴을 지적합니다.</p>
<p>r[attributes.diagnostics.lint.level] The lint attributes <code>allow</code>, <code>expect</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code> use the [MetaListPaths] syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</p>
<p>임의의 린트 체크 <code>C</code>에 대해:</p>
<p>r[attributes.diagnostics.lint.allow]</p>
<ul>
<li><code>#[allow(C)]</code>는 <code>C</code>에 대한 체크를 무시하여 위반 사항이 보고되지 않도록 합니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.expect]</p>
<ul>
<li><code>#[expect(C)]</code>는 린트 <code>C</code>가 발생할 것으로 예상됨을 나타냅니다. 이 속성은 <code>C</code>의 발생을 억제하거나, 예상이 충족되지 않은 경우 경고를 발생시킵니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.warn]</p>
<ul>
<li><code>#[warn(C)]</code>는 <code>C</code> 위반에 대해 경고하지만 컴파일을 계속합니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.deny]</p>
<ul>
<li><code>#[deny(C)]</code>는 <code>C</code> 위반을 발견하면 에러를 발생시킵니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.forbid]</p>
<ul>
<li><code>#[forbid(C)]</code>는 <code>deny(C)</code>와 동일하지만, 이후에 린트 레벨을 변경하는 것도 금지합니다.</li>
</ul>
<blockquote>
<p>[!NOTE] The lint checks supported by <code>rustc</code> can be found via <code>rustc -W help</code>, along with their default settings and are documented in the <a href="../../rustc/lints/index.html">rustc book</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // 여기서 누락된 문서는 무시됩니다.
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // 여기서 누락된 문서는 에러를 발생시킵니다.
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.override] Lint attributes can override the level specified from a previous attribute, as long as the level does not attempt to change a forbidden lint (except for <code>deny</code>, which is allowed inside a <code>forbid</code> context, but ignored). Previous attributes are those from a higher level in the syntax tree, or from a previous attribute on the same entity as listed in left-to-right source order.</p>
<p>이 예시는 <code>allow</code>와 <code>warn</code>을 사용하여 특정 체크를 켜고 끄는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // 여기서 누락된 문서는 무시됩니다.
        pub fn undocumented_one() -&gt; i32 { 1 }

        // 위의 allow에도 불구하고,
        // 여기서 누락된 문서는 경고를 발생시킵니다.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시는 특정 린트 체크에 대해 <code>allow</code>나 <code>expect</code>를 사용하는 것을 금지하기 위해 <code>forbid</code>를 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // 경고를 토글하려고 시도하면 여기서 에러가 발생합니다.
    #[allow(missing_docs)]
    /// 2를 반환합니다.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] <code>rustc</code> allows setting lint levels on the <a href="../../rustc/lints/levels.html#via-compiler-flag">command-line</a>, and also supports <a href="../../rustc/lints/levels.html#capping-lints">setting caps</a> on the lints that are reported.</p>
</blockquote>
<p>r[attributes.diagnostics.lint.reason]</p>
<h3 id="lint-reasons"><a class="header" href="#lint-reasons">Lint reasons</a></h3>
<p>모든 린트 속성은 특정 속성이 추가된 이유에 대한 문맥을 제공하기 위해 추가적인 <code>reason</code> 매개변수를 지원합니다. 이 사유는 린트가 정의된 레벨에서 내보내질 때 린트 메시지의 일부로 표시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `keyword_idents`는 기본적으로 허용됩니다. 여기서는 에디션을 업데이트할 때
// 식별자 마이그레이션을 피하기 위해 이를 거부(deny)합니다.
#![deny(
    keyword_idents,
    reason = "미래 호환성을 위해 이러한 식별자들을 피하고 싶습니다"
)]

// 이 이름은 Rust 2015 에디션에서 허용되었습니다. 우리는 여전히 피하고자 합니다
// 미래 호환성을 확보하고 최종 사용자에게 혼란을 주지 않기 위함입니다.
fn dyn() {}
<span class="boring">}</span></code></pre></pre>
<p>사유와 함께 린트를 허용한 또 다른 예시입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

pub fn get_path() -&gt; PathBuf {
    // `allow` 속성의 `reason` 매개변수는 독자를 위한 문서 역할을 합니다.
    #[allow(unused_mut, reason = "이것은 일부 플랫폼에서만 수정됩니다")]
    let mut file_name = PathBuf::from("git");

    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");

    file_name
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.expect]</p>
<h3 id="expect-속성"><a class="header" href="#expect-속성"><code>#[expect]</code> 속성</a></h3>
<p>r[attributes.diagnostics.expect.intro] The <code>#[expect(C)]</code> attribute creates a lint expectation for lint <code>C</code>. The expectation will be fulfilled, if a <code>#[warn(C)]</code> attribute at the same location would result in a lint emission. If the expectation is unfulfilled, because lint <code>C</code> would not be emitted, the <code>unfulfilled_lint_expectations</code> lint will be emitted at the attribute.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // 이 `#[expect]` 속성은 `unused_variables` 린트가 다음 문장에서 발생할 것이라는
    // 린트 기대를 생성합니다. `question` 변수가 `println!` 매크로에 의해
    // 사용되므로 이 기대는 충족되지 않습니다. 따라서 해당 속성 위치에서
    // `unfulfilled_lint_expectations` 린트가 발생합니다.
    #[expect(unused_variables)]
    let question = "누가 바다 저 깊은 곳 파인애플에 살까요?";
    println!("{question}");

    // 이 `#[expect]` 속성은 `answer` 변수가 전혀 사용되지 않으므로 충족될
    // 린트 기대를 생성합니다. 평소라면 발생했을 `unused_variables` 린트는
    // 억제됩니다. 해당 문장이나 속성에 대해 어떤 경고도 발생하지 않습니다.
    #[expect(unused_variables)]
    let answer = "네모네모 스폰지밥!";
}</code></pre></pre>
<p>r[attributes.diagnostics.expect.fulfillment] The lint expectation is only fulfilled by lint emissions which have been suppressed by the <code>expect</code> attribute. If the lint level is modified in the scope with other level attributes like <code>allow</code> or <code>warn</code>, the lint emission will be handled accordingly and the expectation will remain unfulfilled.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[expect(unused_variables)]
fn select_song() {
    // 이것은 `warn` 속성에 정의된 대로 `unused_variables` 린트를 warn 레벨로
    // 내보낼 것입니다. 이는 함수 위에 있는 기대를 충족시키지 못합니다.
    #[warn(unused_variables)]
    let song_name = "Crab Rave";

    // `allow` 속성은 린트 발생을 억제합니다. 이는 `expect` 속성이 아닌
    // `allow` 속성에 의해 억제되었으므로 함수 위의 기대를
    // 충족시키지 못합니다.
    #[allow(unused_variables)]
    let song_creator = "Noisestorm";

    // 이 `expect` 속성은 변수 위치에서 `unused_variables` 린트 발생을
    // 억제할 것입니다. 이 린트 발생은 지역적인 expect 속성에 의해
    // 억제되었으므로 함수 위의 `expect` 속성은 여전히 충족되지 않습니다.
    #[expect(unused_variables)]
    let song_version = "Monstercat Release";
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.expect.independent] If the <code>expect</code> attribute contains several lints, each one is expected separately. For a lint group it’s enough if one lint inside the group has been emitted:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 기대는 함수 내부의 사용되지 않은 값에 의해 충족될 것입니다.
// 발생한 `unused_variables` 린트가 `unused` 린트 그룹에 속하기 때문입니다.
#[expect(unused)]
pub fn thoughts() {
    let unused = "예시가 떨어져 가고 있어요";
}

pub fn another_example() {
    // 이 속성은 두 개의 린트 기대를 생성합니다. `unused_mut` 린트는
    // 억제되며 첫 번째 기대를 충족시킬 것입니다. `unused_variables` 린트는
    // 변수가 사용되므로 발생하지 않을 것입니다. 따라서 그 기대는 충족되지
    // 않은 상태로 남게 되며, 경고가 발생할 것입니다.
    #[expect(unused_mut, unused_variables)]
    let mut link = "https://www.rust-lang.org/";

    println!("우리 커뮤니티에 오신 것을 환영합니다: {link}");
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] The behavior of <code>#[expect(unfulfilled_lint_expectations)]</code> is currently defined to always generate the <code>unfulfilled_lint_expectations</code> lint.</p>
</blockquote>
<p>r[attributes.diagnostics.lint.group]</p>
<h3 id="린트-그룹"><a class="header" href="#린트-그룹">린트 그룹</a></h3>
<p>린트들은 관련된 린트들의 레벨을 함께 조정할 수 있도록 명명된 그룹으로 조직될 수 있습니다. 명명된 그룹을 사용하는 것은 해당 그룹 내의 린트들을 나열하는 것과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 "unused" 그룹의 모든 린트를 허용합니다.
#[allow(unused)]
// 이는 "unused" 그룹의 "unused_must_use" 린트를
// deny 레벨로 오버라이드합니다.
#[deny(unused_must_use)]
fn example() {
    // "unused_variables" 린트가 "unused" 그룹에 속해 있으므로
    // 경고를 생성하지 않습니다.
    let x = 1;
    // 결과가 사용되지 않았고 "unused_must_use"가 "deny"로 설정되었으므로
    // 에러를 생성합니다.
    std::fs::remove_file("some_file"); // 에러: 반드시 사용되어야 할 `Result`가 사용되지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.group.warnings] There is a special group named “warnings” which includes all lints at the “warn” level. The “warnings” group ignores attribute order and applies to all lints that would otherwise warn within the entity.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">unsafe fn an_unsafe_fn() {}
</span>// 이 두 속성의 순서는 중요하지 않습니다.
#[deny(warnings)]
// unsafe_code 린트는 보통 기본적으로 "allow"입니다.
#[warn(unsafe_code)]
fn example_err() {
    // `unsafe_code` 경고가 "deny"로 격상되었으므로 이것은 에러입니다.
    unsafe { an_unsafe_fn() } // 에러: `unsafe` 블록 사용
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.tool]</p>
<h3 id="도구-린트-속성"><a class="header" href="#도구-린트-속성">도구 린트 속성</a></h3>
<p>r[attributes.diagnostics.lint.tool.intro] Tool lints allows using scoped lints, to <code>allow</code>, <code>warn</code>, <code>deny</code> or <code>forbid</code> lints of certain tools.</p>
<p>r[attributes.diagnostics.lint.tool.activation] Tool lints only get checked when the associated tool is active. If a lint attribute, such as <code>allow</code>, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</p>
<p>그 외에는 일반 린트 속성과 동일하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// clippy의 `pedantic` 린트 그룹 전체를 warn으로 설정합니다.
#![warn(clippy::pedantic)]
// clippy의 `filter_map` 린트 경고를 억제합니다.
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// 이 함수에서만 clippy의 `cmp_nan` 린트를 억제합니다.
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}</code></pre></pre>
<blockquote>
<p>[!NOTE] <code>rustc</code> currently recognizes the tool lints for “<a href="https://github.com/rust-lang/rust-clippy">clippy</a>” and “<a href="../../rustdoc/lints.html">rustdoc</a>”.</p>
</blockquote>
<p>r[attributes.diagnostics.deprecated]</p>
<h2 id="deprecated-속성"><a class="header" href="#deprecated-속성"><code>deprecated</code> 속성</a></h2>
<p>r[attributes.diagnostics.deprecated.intro] The <em><code>deprecated</code> attribute</em> marks an item as deprecated. <code>rustc</code> will issue warnings on usage of <code>#[deprecated]</code> items. <code>rustdoc</code> will show item deprecation, including the <code>since</code> version and <code>note</code>, if available.</p>
<p>r[attributes.diagnostics.deprecated.syntax] The <code>deprecated</code> attribute has several forms:</p>
<ul>
<li><code>deprecated</code> — 일반적인 메시지를 발생시킵니다.</li>
<li><code>deprecated = "message"</code> — 사용 중단 메시지에 주어진 문자열을 포함합니다.</li>
<li>[MetaListNameValueStr] syntax with two optional fields:
<ul>
<li><code>since</code> — 아이템이 사용 중단된 버전 번호를 지정합니다. <code>rustc</code>는 현재 이 문자열을 해석하지 않지만, <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>와 같은 외부 도구가 이 값의 유효성을 검사할 수 있습니다.</li>
<li><code>note</code> — 사용 중단 메시지에 포함되어야 할 문자열을 지정합니다. 이는 일반적으로 사용 중단에 대한 설명과 권장되는 대안을 제공하는 데 사용됩니다.</li>
</ul>
</li>
</ul>
<p>r[attributes.diagnostic.deprecated.allowed-positions] The <code>deprecated</code> attribute may be applied to any <a href="../items.html">item</a>, <a href="../items/traits.html">trait item</a>, <a href="../items/enumerations.html">enum variant</a>, <a href="../items/structs.html">struct field</a>, <a href="../items/external-blocks.html">external block item</a>, or <a href="../macros-by-example.html">macro definition</a>. It cannot be applied to <a href="../items/implementations.html#trait-implementations">trait implementation items</a>. When applied to an item containing other items, such as a <a href="../items/modules.html">module</a> or <a href="../items/implementations.html">implementation</a>, all child items inherit the deprecation attribute.</p>
<!-- NOTE: It is only rejected for trait impl items
(AnnotationKind::Prohibited). In all other locations, it is silently ignored.
Tuple struct fields are ignored.
-->
<p>예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = "5.2.0", note = "foo는 거의 사용되지 않았습니다. 사용자들은 대신 bar를 사용해야 합니다")]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a>에 동기와 자세한 내용이 포함되어 있습니다.</p>
<p>r[attributes.diagnostics.must_use]</p>
<h2 id="must_use-속성"><a class="header" href="#must_use-속성"><code>must_use</code> 속성</a></h2>
<p>r[attributes.diagnostics.must_use.intro] The <em><code>must_use</code> attribute</em> is used to issue a diagnostic warning when a value is not “used”.</p>
<p>r[attributes.diagnostics.must_use.allowed-positions] The <code>must_use</code> attribute can be applied to user-defined composite types (<a href="../items/structs.html"><code>struct</code>s</a>, <a href="../items/enumerations.html"><code>enum</code>s</a>, and <a href="../items/unions.html"><code>union</code>s</a>), <a href="../items/functions.html">functions</a>, and <a href="../items/traits.html">traits</a>.</p>
<p>r[attributes.diagnostics.must_use.message] The <code>must_use</code> attribute may include a message by using the [MetaNameValueStr] syntax such as <code>#[must_use = "example message"]</code>. The message will be given alongside the warning.</p>
<p>r[attributes.diagnostics.must_use.type] When used on user-defined composite types, if the <a href="../expressions.html">expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> has that type, then the <code>unused_must_use</code> lint is violated.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // 몇몇 필드들
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// `unused_must_use` 린트를 위반합니다.
MustUse::new();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.fn] When used on a function, if the <a href="../expressions.html">expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> is a <a href="../expressions/call-expr.html">call expression</a> to that function, then the <code>unused_must_use</code> lint is violated.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반합니다.
five();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait] When used on a <a href="../items/traits.html">trait declaration</a>, a <a href="../expressions/call-expr.html">call expression</a> of an <a href="../statements.html#expression-statements">expression statement</a> to a function that returns an <a href="../types/impl-trait.html">impl trait</a> or a <a href="../types/trait-object.html">dyn trait</a> of that trait violates the <code>unused_must_use</code> lint.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// `unused_must_use` 린트를 위반합니다.
get_critical();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait-function] When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// `unused_must_use` 린트를 위반합니다.
5i32.use_me();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait-impl-function] When used on a function in a trait implementation, the attribute does nothing.</p>
<blockquote>
<p>[!NOTE] Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement <a href="../special-types-and-traits.html#drop"><code>Drop</code></a> and then not using that type and being the final expression of a <a href="../expressions/block-expr.html">block expression</a> that is not used.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 이들 중 어느 것도 `unused_must_use` 린트를 위반하지 않습니다.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] It is idiomatic to use a <a href="../statements.html#let-statements">let statement</a> with a pattern of <code>_</code> when a must-used value is purposely discarded.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반하지 않습니다.
let _ = five();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.diagnostic.namespace]</p>
<h2 id="diagnostic-도구-속성-네임스페이스"><a class="header" href="#diagnostic-도구-속성-네임스페이스"><code>diagnostic</code> 도구 속성 네임스페이스</a></h2>
<p>r[attributes.diagnostic.namespace.intro] The <code>#[diagnostic]</code> attribute namespace is a home for attributes to influence compile-time error messages. The hints provided by these attributes are not guaranteed to be used.</p>
<p>r[attributes.diagnostic.namespace.unknown-invalid-syntax] Unknown attributes in this namespace are accepted, though they may emit warnings for unused attributes. Additionally, invalid inputs to known attributes will typically be a warning (see the attribute definitions for details). This is meant to allow adding or discarding attributes and changing inputs in the future to allow changes without the need to keep the non-meaningful attributes or options working.</p>
<p>r[attributes.diagnostic.on_unimplemented]</p>
<h3 id="diagnosticon_unimplemented-속성"><a class="header" href="#diagnosticon_unimplemented-속성"><code>diagnostic::on_unimplemented</code> 속성</a></h3>
<p>r[attributes.diagnostic.on_unimplemented.intro] The <code>#[diagnostic::on_unimplemented]</code> attribute is a hint to the compiler to supplement the error message that would normally be generated in scenarios where a trait is required but not implemented on a type.</p>
<p>r[attributes.diagnostic.on_unimplemented.allowed-positions] The attribute should be placed on a <a href="../items/traits.html">trait declaration</a>, though it is not an error to be located in other positions.</p>
<p>r[attributes.diagnostic.on_unimplemented.syntax] The attribute uses the [MetaListNameValueStr] syntax to specify its inputs, though any malformed input to the attribute is not considered as an error to provide both forwards and backwards compatibility.</p>
<p>r[attributes.diagnostic.on_unimplemented.keys] The following keys have the given meaning:</p>
<ul>
<li><code>message</code> — 최상위 레벨 에러 메시지를 위한 텍스트입니다.</li>
<li><code>label</code> — 에러 메시지에서 잘못된 코드 내에 표시될 라벨을 위한 텍스트입니다.</li>
<li><code>note</code> — 추가적인 노트를 제공합니다.</li>
</ul>
<p>r[attributes.diagnostic.on_unimplemented.note-repetition] The <code>note</code> option can appear several times, which results in several note messages being emitted.</p>
<p>r[attributes.diagnostic.on_unimplemented.repetition] If any of the other options appears several times the first occurrence of the relevant option specifies the actually used value. Subsequent occurrences generates a warning.</p>
<p>r[attributes.diagnostic.on_unimplemented.unknown-keys] A warning is generated for any unknown keys.</p>
<p>r[attributes.diagnostic.on_unimplemented.format-string] All three options accept a string as an argument, interpreted using the same formatting as a [<code>std::fmt</code>] string.</p>
<p>r[attributes.diagnostic.on_unimplemented.format-parameters] Format parameters with the given named parameter will be replaced with the following text:</p>
<ul>
<li><code>{Self}</code> — 트레잇을 구현하는 타입의 이름입니다.</li>
<li><code>{</code> <em>제네릭매개변수이름</em> <code>}</code> — 주어진 제네릭 매개변수에 대한 제네릭 인수의 타입 이름입니다.</li>
</ul>
<p>r[attributes.diagnostic.on_unimplemented.invalid-formats] Any other format parameter will generate a warning, but will otherwise be included in the string as-is.</p>
<p>r[attributes.diagnostic.on_unimplemented.invalid-string] Invalid format strings may generate a warning, but are otherwise allowed, but may not display as intended. Format specifiers may generate a warning, but are otherwise ignored.</p>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024">#[diagnostic::on_unimplemented(
    message = "`{Self}`에 구현된 `ImportantTrait&lt;{A}&gt;`에 대한 메시지",
    label = "나의 라벨",
    note = "노트 1",
    note = "노트 2"
)]
trait ImportantTrait&lt;A&gt; {}

fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {}

fn main() {
    use_my_trait(String::new());
}</code></pre></pre>
<p>컴파일러는 다음과 같은 에러 메시지를 생성할 수 있습니다:</p>
<pre><code class="language-text">error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` implemented for `String`
  --&gt; src/main.rs:14:18
   |
14 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String`
   = note: Note 1
   = note: Note 2
</code></pre>
<p>r[attributes.diagnostic.do_not_recommend]</p>
<h3 id="diagnosticdo_not_recommend-속성"><a class="header" href="#diagnosticdo_not_recommend-속성"><code>diagnostic::do_not_recommend</code> 속성</a></h3>
<p>r[attributes.diagnostic.do_not_recommend.intro] The <code>#[diagnostic::do_not_recommend]</code> attribute is a hint to the compiler to not show the annotated trait implementation as part of a diagnostic message.</p>
<blockquote>
<p>[!NOTE] Suppressing the recommendation can be useful if you know that the recommendation would normally not be useful to the programmer. This often occurs with broad, blanket impls. The recommendation may send the programmer down the wrong path, or the trait implementation may be an internal detail that you don’t want to expose, or the bounds may not be able to be satisfied by the programmer.</p>
<p>예를 들어, 요구되는 트레잇을 구현하지 않은 타입에 대한 에러 메시지에서, 컴파일러는 트레잇 구현 내의 특정 바운드만 아니었다면 요구 사항을 충족했을 트레잇 구현을 찾을 수도 있습니다. 컴파일러는 사용자에게 구현이 존재하지만 트레잇 구현 내의 바운드가 문제라고 말할 수 있습니다. <code>#[diagnostic::do_not_recommend]</code> 속성은 컴파일러에게 해당 트레잇 구현에 대해 사용자에게 알리지 <em>말고</em>, 대신 단순히 해당 타입이 요구되는 트레잇을 구현하지 않는다고 알리도록 하는 데 사용될 수 있습니다.</p>
</blockquote>
<p>r[attributes.diagnostic.do_not_recommend.allowed-positions] The attribute should be placed on a <a href="../items/implementations.html#trait-implementations">trait implementation item</a>, though it is not an error to be located in other positions.</p>
<p>r[attributes.diagnostic.do_not_recommend.syntax] The attribute does not accept any arguments, though unexpected arguments are not considered as an error.</p>
<p>다음 예시에는 SQL 라이브러리에서 사용되는 <code>Expression</code> 타입으로 임의의 타입을 캐스팅하는 데 사용되는 <code>AsExpression</code>이라는 트레잇이 있습니다. 여기에는 <code>AsExpression</code>을 인수로 받는 <code>check</code>라는 메서드가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">pub trait Expression {
</span><span class="boring">    type SqlType;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait AsExpression&lt;ST&gt; {
</span><span class="boring">    type Expression: Expression&lt;SqlType = ST&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Text;
</span><span class="boring">pub struct Integer;
</span><span class="boring">
</span><span class="boring">pub struct Bound&lt;T&gt;(T);
</span><span class="boring">pub struct SelectInt;
</span><span class="boring">
</span><span class="boring">impl Expression for SelectInt {
</span><span class="boring">    type SqlType = Integer;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Expression for Bound&lt;T&gt; {
</span><span class="boring">    type SqlType = T;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Integer&gt; for i32 {
</span><span class="boring">    type Expression = Bound&lt;Integer&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Text&gt; for &amp;'_ str {
</span><span class="boring">    type Expression = Bound&lt;Text&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Foo for T where T: Expression {}
</span>
// 권장 사항을 변경하려면 이 라인의 주석을 해제하세요.
// #[diagnostic::do_not_recommend]
impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
where
    T: Expression&lt;SqlType = ST&gt;,
{
    type Expression = T;
}

trait Foo: Expression + Sized {
    fn check&lt;T&gt;(&amp;self, _: T) -&gt; &lt;T as AsExpression&lt;&lt;Self as Expression&gt;::SqlType&gt;&gt;::Expression
    where
        T: AsExpression&lt;Self::SqlType&gt;,
    {
        todo!()
    }
}

fn main() {
    SelectInt.check("bar");
}</code></pre></pre>
<p><code>SelectInt</code> 타입의 <code>check</code> 메서드는 <code>Integer</code> 타입을 기대합니다. <code>AsExpression</code> 트레잇에 의해 <code>i32</code> 타입이 <code>Integer</code>로 변환되므로 <code>i32</code> 타입으로 호출하는 것은 작동합니다. 하지만 문자열로 호출하는 것은 작동하지 않으며, 다음과 같은 에러를 발생시킬 수 있습니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: Expression` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `Expression` is not implemented for `&amp;str`
   |
   = help: the following other types implement trait `Expression`:
             Bound&lt;T&gt;
             SelectInt
note: required for `&amp;str` to implement `AsExpression&lt;Integer&gt;`
  --&gt; src/main.rs:45:13
   |
45 | impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
   |             ^^^^^^^^^^^^^^^^     ^
46 | where
47 |     T: Expression&lt;SqlType = ST&gt;,
   |        ------------------------ unsatisfied trait bound introduced here
</code></pre>
<p>By adding the <code>#[diagnostic::do_not_recommend]</code> attribute to the blanket <code>impl</code> for <code>AsExpression</code>, the message changes to:</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: AsExpression&lt;Integer&gt;` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
   |
   = help: the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
           but trait `AsExpression&lt;Text&gt;` is implemented for it
   = help: for that trait implementation, expected `Text`, found `Integer`
</code></pre>
<p>The first error message includes a somewhat confusing error message about the relationship of <code>&amp;str</code> and <code>Expression</code>, as well as the unsatisfied trait bound in the blanket impl. After adding <code>#[diagnostic::do_not_recommend]</code>, it no longer considers the blanket impl for the recommendation. The message should be a little clearer, with an indication that a string cannot be converted to an <code>Integer</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../attributes/derive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../attributes/codegen.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../attributes/derive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../attributes/codegen.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
