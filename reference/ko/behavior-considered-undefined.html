<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>정의되지 않은 동작으로 간주되는 경우 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/behavior-considered-undefined.md`;
                    } else {
                        canonical_href = `${base}/${lang}/behavior-considered-undefined.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/behavior-considered-undefined.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-undefined"><a class="rule-link" href="#r-undefined" title="undefined"><span>[undefined]<span/></a></div>
<h2 id="정의되지-않은-동작으로-간주되는-경우"><a class="header" href="#정의되지-않은-동작으로-간주되는-경우">정의되지 않은 동작으로 간주되는 경우</a></h2>
<div class="rule" id="r-undefined.general"><a class="rule-link" href="#r-undefined.general" title="undefined.general"><span>[undefined<wbr>.general]<span/></a></div>
<p>러스트 코드가 다음 목록의 동작 중 어느 하나라도 보인다면 잘못된 것입니다. 이는 <code>unsafe</code> 블록과 <code>unsafe</code> 함수 내부의 코드를 포함합니다. <code>unsafe</code>는 단지 정의되지 않은 동작을 피하는 책임이 프로그래머에게 있음을 의미할 뿐이며, 러스트 프로그램이 정의되지 않은 동작을 결코 일으켜서는 안 된다는 사실을 바꾸지는 않습니다.</p>
<div class="rule" id="r-undefined.soundness"><a class="rule-link" href="#r-undefined.soundness" title="undefined.soundness"><span>[undefined<wbr>.soundness]<span/></a></div>
<p>안전하지 않은 코드를 작성할 때, 그 코드와 상호 작용하는 모든 안전한 코드가 이러한 동작들을 유발할 수 없도록 보장하는 것은 프로그래머의 책임입니다. 모든 안전한 클라이언트에 대해 이 속성을 만족하는 안전하지 않은 코드를 _건전하다(sound)_고 하며, 안전한 코드에 의해 오용되어 정의되지 않은 동작을 보일 수 있는 안전하지 않은 코드는 _불건전하다(unsound)_고 합니다.</p>
<div class="warning">
<p><em><strong>경고:</strong></em> 다음 목록은 포괄적이지 않으며, 늘어나거나 줄어들 수 있습니다. 안전하지 않은 코드에서 무엇이 허용되고 허용되지 않는지에 대한 러스트 세만틱의 공식적인 모델은 아직 없으므로, 안전하지 않다고 간주되는 동작이 더 있을 수 있습니다. 또한 우리는 목록의 일부 동작을 미래에 정의된(defined) 동작으로 만들 권리를 가집니다. 즉, 이 목록은 어떤 것이 모든 미래 러스트 버전에서 <em>반드시</em> 항상 정의되지 않은 상태로 남을 것임을 말하는 것은 아닙니다(하지만 미래에 일부 항목에 대해 그러한 약속을 할 수도 있습니다).</p>
<p>안전하지 않은 코드를 작성하기 전에 <a href="../nomicon/index.html">러스트노미콘(Rustonomicon)</a>을 읽어보시기 바랍니다.</p>
</div>
<div class="rule" id="r-undefined.race"><a class="rule-link" href="#r-undefined.race" title="undefined.race"><span>[undefined<wbr>.race]<span/></a></div>
<ul>
<li>데이터 경합 (Data races).</li>
</ul>
<div class="rule" id="r-undefined.pointer-access"><a class="rule-link" href="#r-undefined.pointer-access" title="undefined.pointer-access"><span>[undefined<wbr>.pointer-access]<span/></a></div>
<ul>
<li><a href="#dangling-pointers">매달린 포인터(dangling pointer)</a>이거나 <a href="#places-based-on-misaligned-pointers">정렬되지 않은 포인터에 기반한</a> 위치에 접근(로드 또는 스토어)하는 것.</li>
</ul>
<div class="rule" id="r-undefined.place-projection"><a class="rule-link" href="#r-undefined.place-projection" title="undefined.place-projection"><span>[undefined<wbr>.place-projection]<span/></a></div>
<ul>
<li><a href="../std/primitive.pointer.html#method.offset">범위 내 포인터 산술 연산(in-bounds pointer arithmetic)</a>의 요구 사항을 위반하는 위치 투영(place projection)을 수행하는 것. 위치 투영이란 <a href="expressions/field-expr.html">필드 표현식</a>, <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스 표현식</a>, 또는 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열/슬라이스 인덱스 표현식</a>을 의미합니다.</li>
</ul>
<div class="rule" id="r-undefined.alias"><a class="rule-link" href="#r-undefined.alias" title="undefined.alias"><span>[undefined<wbr>.alias]<span/></a></div>
<ul>
<li>
<p><a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">포인터 별칭 규칙(pointer aliasing rules)</a>을 위반하는 것. <code>Box&lt;T&gt;</code>, <code>&amp;mut T</code>, <code>&amp;T</code>는 LLVM의 스코프 기반 <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> 모델을 따릅니다. 단, <code>&amp;T</code>가 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>를 포함하는 경우는 예외입니다. 참조와 박스는 살아있는(live) 동안 <a href="#dangling-pointers">매달린 포인터</a>가 되어서는 안 됩니다. 정확한 생존 기간은 명시되지 않았으나, 몇 가지 한계가 존재합니다:</p>
<ul>
<li>참조의 경우, 생존 기간의 상한선은 대여 검사기(borrow checker)가 할당한 구문상 라이프타임입니다. 즉, 그 라이프타임보다 <em>더 길게</em> 살아있을 수 없습니다.</li>
<li>참조나 박스가 함수로 전달되거나 함수에서 반환될 때마다, 그것은 살아있는 것으로 간주됩니다.</li>
<li>참조가(<code>Box</code>가 아닌!) 함수로 전달될 때, 그것은 최소한 해당 함수 호출 동안은 살아있습니다. 이 역시 <code>&amp;T</code>가 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>를 포함하는 경우는 예외입니다.
이 모든 사항은 이러한 타입의 값들이 복합 타입의 (중첩된) 필드로 전달될 때도 적용되지만, 포인터 간접 참조(indirections) 뒤에 있는 경우는 제외됩니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-undefined.immutable"><a class="rule-link" href="#r-undefined.immutable" title="undefined.immutable"><span>[undefined<wbr>.immutable]<span/></a></div>
<ul>
<li>
<p>불변(immutable) 바이트를 수정하는 것. <a href="destructors.html#constant-promotion">상수 승격(const-promoted)</a> 표현식을 통해 도달 가능한 모든 바이트는 불변이며, <code>'static</code>으로 <a href="destructors.html#temporary-lifetime-extension">수명 연장(lifetime-extended)</a>된 <code>static</code> 및 <code>const</code> 초기화 식의 대여를 통해 도달 가능한 바이트들도 불변입니다. 불변 바인딩이나 불변 <code>static</code>에 의해 소유된 바이트들은, 해당 바이트들이 <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>의 일부가 아닌 한 불변입니다.</p>
<p>게다가, 공유 참조가 <a href="#pointed-to-bytes">가리키는</a> 바이트들은 다른 참조(공유 및 가변 모두)와 <code>Box</code>를 통한 전이적 참조를 포함하여 모두 불변입니다. 전이성에는 복합 타입의 필드에 저장된 참조들도 포함됩니다.</p>
<p>수정이란 관련 바이트 중 어느 하나라도 겹치는 0바이트 이상의 모든 쓰기 연산을 의미합니다(해당 쓰기가 메모리 내용을 변경하지 않더라도 마찬가지입니다).</p>
</li>
</ul>
<div class="rule" id="r-undefined.intrinsic"><a class="rule-link" href="#r-undefined.intrinsic" title="undefined.intrinsic"><span>[undefined<wbr>.intrinsic]<span/></a></div>
<ul>
<li>컴파일러 내장 함수(intrinsics)를 통해 정의되지 않은 동작을 유발하는 것.</li>
</ul>
<div class="rule" id="r-undefined.target-feature"><a class="rule-link" href="#r-undefined.target-feature" title="undefined.target-feature"><span>[undefined<wbr>.target-feature]<span/></a></div>
<ul>
<li>현재 플랫폼이 지원하지 않는 플랫폼 기능을 사용하여 컴파일된 코드를 실행하는 것(<a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> 참조). 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 제외합니다.</li>
</ul>
<div class="rule" id="r-undefined.call"><a class="rule-link" href="#r-undefined.call" title="undefined.call"><span>[undefined<wbr>.call]<span/></a></div>
<ul>
<li>잘못된 호출 ABI로 함수를 호출하거나, 잘못된 언와인드(unwind) ABI를 가진 함수에서 언와인딩을 수행하는 것.</li>
</ul>
<div class="rule" id="r-undefined.invalid"><a class="rule-link" href="#r-undefined.invalid" title="undefined.invalid"><span>[undefined<wbr>.invalid]<span/></a></div>
<ul>
<li><a href="#invalid-values">유효하지 않은 값</a>을 생성하는 것. 값을 “생성“한다는 것은 값이 장소(place)에 할당되거나 장소로부터 읽힐 때, 함수/기본 연산으로 전달되거나 함수/기본 연산으로부터 반환될 때마다 발생합니다.</li>
</ul>
<div class="rule" id="r-undefined.asm"><a class="rule-link" href="#r-undefined.asm" title="undefined.asm"><span>[undefined<wbr>.asm]<span/></a></div>
<ul>
<li>인라인 어셈블리의 잘못된 사용. 자세한 내용은 인라인 어셈블리를 사용하는 코드를 작성할 때 따라야 할 <a href="inline-assembly.html#rules-for-inline-assembly">규칙</a>을 참조하십시오.</li>
</ul>
<div class="rule" id="r-undefined.const-transmute-ptr2int"><a class="rule-link" href="#r-undefined.const-transmute-ptr2int" title="undefined.const-transmute-ptr2int"><span>[undefined<wbr>.const-transmute-ptr2int]<span/></a></div>
<ul>
<li><strong><a href="const_eval.html#const-context">상수 컨텍스트(const context)</a>에서</strong>: 할당된 객체에 대한 포인터(참조, 원시 포인터, 또는 함수 포인터)를 정수와 같은 비포인터 타입으로 변환(transmute)하거나 재해석하는 것. ’재해석’이란 캐스트 없이 포인터 값을 정수 타입으로 로드하는 것을 말하며, 예를 들어 원시 포인터 캐스트를 수행하거나 유니온을 사용하는 경우가 해당됩니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 정의되지 않은 동작은 프로그램 전체에 영향을 미칩니다. 예를 들어, C의 정의되지 않은 동작을 보이는 C 함수를 호출하면 프로그램 전체에 정의되지 않은 동작이 포함되어 러스트 코드에도 영향을 줄 수 있습니다. 반대의 경우도 마찬가지로, 러스트에서의 정의되지 않은 동작은 다른 언어로의 모든 FFI 호출에 의해 실행되는 코드에 악영향을 줄 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-undefined.pointed-to"><a class="rule-link" href="#r-undefined.pointed-to" title="undefined.pointed-to"><span>[undefined<wbr>.pointed-to]<span/></a></div>
<h3 id="가리키는-바이트-pointed-to-bytes"><a class="header" href="#가리키는-바이트-pointed-to-bytes">가리키는 바이트 (Pointed-to bytes)</a></h3>
<p>포인터나 참조가 “가리키는” 바이트 범위는 포인터 값과 피지시체(pointee) 타입의 크기(<code>size_of_val</code> 사용)에 의해 결정됩니다.</p>
<h3 id="잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers"><a class="header" href="#잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers">잘못 정렬된 포인터에 기반한 장소 (Places based on misaligned pointers)</a></h3>
<div class="rule" id="r-undefined.misaligned"><a class="rule-link" href="#r-undefined.misaligned" title="undefined.misaligned"><span>[undefined<wbr>.misaligned]<span/></a></div>
<div class="rule" id="r-undefined.misaligned.general"><a class="rule-link" href="#r-undefined.misaligned.general" title="undefined.misaligned.general"><span>[undefined<wbr>.misaligned<wbr>.general]<span/></a></div>
<p>장소 계산 중 마지막 <code>*</code> 투영(projection)이 해당 타입에 맞게 정렬되지 않은 포인터에 대해 수행된 경우, 해당 장소는 “잘못 정렬된 포인터에 기반한다“고 합니다. (장소 표현식에 <code>*</code> 투영이 없다면 이는 지역 변수나 <code>static</code>의 필드에 접근하는 것이며, rustc가 적절한 정렬을 보장합니다. <code>*</code> 투영이 여러 개인 경우, 각각의 투영은 메모리로부터 역참조될 포인터 자체를 로드하며, 이러한 각 로드는 정렬 제약 조건을 따릅니다. 러스트의 겉보기 구문에서는 자동 역참조로 인해 일부 <code>*</code> 투영이 생략될 수 있음에 유의하십시오. 여기서는 완전히 확장된 장소 표현식을 고려합니다.)</p>
<p>예를 들어, <code>ptr</code>의 타입이 <code>*const S</code>이고 <code>S</code>의 정렬(alignment)이 8이라면, <code>ptr</code>은 반드시 8로 정렬되어야 합니다. 그렇지 않으면 <code>(*ptr).f</code>는 “잘못 정렬된 포인터에 기반한” 것이 됩니다. 이는 필드 <code>f</code>의 타입이 <code>u8</code>(즉, 정렬이 1인 타입)인 경우에도 마찬가지입니다. 다시 말해, 정렬 요구 사항은 접근하려는 필드의 타입이 아니라 역참조된 포인터의 타입에서 비롯됩니다.</p>
<div class="rule" id="r-undefined.misaligned.load-store"><a class="rule-link" href="#r-undefined.misaligned.load-store" title="undefined.misaligned.load-store"><span>[undefined<wbr>.misaligned<wbr>.load-store]<span/></a></div>
<p>잘못 정렬된 포인터에 기반한 장소는 해당 장소로부터 로드하거나 해당 장소에 스토어할 때만 정의되지 않은 동작을 유발함에 유의하십시오.</p>
<div class="rule" id="r-undefined.misaligned.raw"><a class="rule-link" href="#r-undefined.misaligned.raw" title="undefined.misaligned.raw"><span>[undefined<wbr>.misaligned<wbr>.raw]<span/></a></div>
<p>그러한 장소에 대한 <code>&amp;raw const</code>/<code>&amp;raw mut</code>는 허용됩니다.</p>
<div class="rule" id="r-undefined.misaligned.reference"><a class="rule-link" href="#r-undefined.misaligned.reference" title="undefined.misaligned.reference"><span>[undefined<wbr>.misaligned<wbr>.reference]<span/></a></div>
<p>장소에 대한 <code>&amp;</code>/<code>&amp;mut</code>는 필드 타입의 정렬을 요구하며(그렇지 않으면 프로그램이 “유효하지 않은 값을 생성“하게 됨), 이는 일반적으로 정렬된 포인터에 기반해야 한다는 요구 사항보다 덜 제한적입니다.</p>
<div class="rule" id="r-undefined.misaligned.packed"><a class="rule-link" href="#r-undefined.misaligned.packed" title="undefined.misaligned.packed"><span>[undefined<wbr>.misaligned<wbr>.packed]<span/></a></div>
<p>필드 타입이 자신을 포함하는 타입보다 더 엄격하게 정렬되어 있을 수 있는 경우(예: <code>repr(packed)</code>), 참조를 취하면 컴파일러 오류가 발생합니다. 이는 정렬된 포인터에 기반하는 것이 새로운 참조가 정렬되도록 보장하는 데 항상 충분하지만, 항상 필수적인 것은 아님을 의미합니다.</p>
<h3 id="매달린-포인터-dangling-pointers"><a class="header" href="#매달린-포인터-dangling-pointers">매달린 포인터 (Dangling pointers)</a></h3>
<div class="rule" id="r-undefined.dangling"><a class="rule-link" href="#r-undefined.dangling" title="undefined.dangling"><span>[undefined<wbr>.dangling]<span/></a></div>
<div class="rule" id="r-undefined.dangling.general"><a class="rule-link" href="#r-undefined.dangling.general" title="undefined.dangling.general"><span>[undefined<wbr>.dangling<wbr>.general]<span/></a></div>
<p>참조/포인터가 <a href="#pointed-to-bytes">가리키는</a> 모든 바이트가 동일한 살아있는(live) 할당의 일부가 아닌 경우(특히 모든 바이트는 <em>어떤</em> 할당의 일부여야 함), 해당 참조/포인터는 “매달려(dangling)” 있다고 합니다.</p>
<div class="rule" id="r-undefined.dangling.zero-size"><a class="rule-link" href="#r-undefined.dangling.zero-size" title="undefined.dangling.zero-size"><span>[undefined<wbr>.dangling<wbr>.zero-size]<span/></a></div>
<p>크기가 0인 경우, 포인터는 (비록 널 포인터일지라도) 결코 “매달려” 있지 않은 것으로 간주됩니다.</p>
<div class="rule" id="r-undefined.dangling.dynamic-size"><a class="rule-link" href="#r-undefined.dangling.dynamic-size" title="undefined.dangling.dynamic-size"><span>[undefined<wbr>.dangling<wbr>.dynamic-size]<span/></a></div>
<p>동적 크기 타입(슬라이스 및 문자열 등)은 전체 범위를 가리키므로, 길이 메타데이터가 결코 너무 크지 않도록 하는 것이 중요합니다.</p>
<div class="rule" id="r-undefined.dangling.alloc-limit"><a class="rule-link" href="#r-undefined.dangling.alloc-limit" title="undefined.dangling.alloc-limit"><span>[undefined<wbr>.dangling<wbr>.alloc-limit]<span/></a></div>
<p>특히, 러스트 값의 동적 크기(<code>size_of_val</code>에 의해 결정됨)는 결코 <code>isize::MAX</code>를 초과해서는 안 됩니다. 단일 할당이 <code>isize::MAX</code>보다 큰 것은 불가능하기 때문입니다.</p>
<h3 id="유효하지-않은-값-invalid-values"><a class="header" href="#유효하지-않은-값-invalid-values">유효하지 않은 값 (Invalid values)</a></h3>
<div class="rule" id="r-undefined.validity"><a class="rule-link" href="#r-undefined.validity" title="undefined.validity"><span>[undefined<wbr>.validity]<span/></a></div>
<div class="rule" id="r-undefined.validity.general"><a class="rule-link" href="#r-undefined.validity.general" title="undefined.validity.general"><span>[undefined<wbr>.validity<wbr>.general]<span/></a></div>
<p>러스트 컴파일러는 프로그램 실행 중에 생성된 모든 값이 “유효하다“고 가정합니다. 따라서 유효하지 않은 값을 생성하는 것은 즉시 정의되지 않은 동작(UB)으로 이어집니다.</p>
<p>값이 유효한지 여부는 타입에 따라 다릅니다:</p>
<div class="rule" id="r-undefined.validity.bool"><a class="rule-link" href="#r-undefined.validity.bool" title="undefined.validity.bool"><span>[undefined<wbr>.validity<wbr>.bool]<span/></a></div>
<ul>
<li><a href="types/boolean.html"><code>bool</code></a> 값은 <code>false</code> (<code>0</code>) 또는 <code>true</code> (<code>1</code>)여야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.fn-pointer"><a class="rule-link" href="#r-undefined.validity.fn-pointer" title="undefined.validity.fn-pointer"><span>[undefined<wbr>.validity<wbr>.fn-pointer]<span/></a></div>
<ul>
<li><code>fn</code> 포인터 값은 널(null)이 아니어야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.char"><a class="rule-link" href="#r-undefined.validity.char" title="undefined.validity.char"><span>[undefined<wbr>.validity<wbr>.char]<span/></a></div>
<ul>
<li><code>char</code> 값은 써로게이트(surrogate, 즉 <code>0xD800..=0xDFFF</code> 범위 내의 값)가 아니어야 하며, <code>char::MAX</code>보다 작거나 같아야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.never"><a class="rule-link" href="#r-undefined.validity.never" title="undefined.validity.never"><span>[undefined<wbr>.validity<wbr>.never]<span/></a></div>
<ul>
<li><code>!</code> 값은 결코 존재해서는 안 됩니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.scalar"><a class="rule-link" href="#r-undefined.validity.scalar" title="undefined.validity.scalar"><span>[undefined<wbr>.validity<wbr>.scalar]<span/></a></div>
<ul>
<li>정수(<code>i*</code>/<code>u*</code>), 부동 소수점 값(<code>f*</code>), 또는 원시 포인터는 반드시 초기화되어야 합니다. 즉, <a href="http://llvm.org/docs/LangRef.html#undefined-values">초기화되지 않은 메모리</a>로부터 얻어서는 안 됩니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.str"><a class="rule-link" href="#r-undefined.validity.str" title="undefined.validity.str"><span>[undefined<wbr>.validity<wbr>.str]<span/></a></div>
<ul>
<li><code>str</code> 값은 <code>[u8]</code>과 같이 취급됩니다. 즉, 반드시 초기화되어야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.enum"><a class="rule-link" href="#r-undefined.validity.enum" title="undefined.validity.enum"><span>[undefined<wbr>.validity<wbr>.enum]<span/></a></div>
<ul>
<li>열거형(<code>enum</code>)은 유효한 판별자(discriminant)를 가져야 하며, 해당 판별자가 나타내는 변형(variant)의 모든 필드는 각각의 타입에 대해 유효해야 합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.struct"><a class="rule-link" href="#r-undefined.validity.struct" title="undefined.validity.struct"><span>[undefined<wbr>.validity<wbr>.struct]<span/></a></div>
<ul>
<li>구조체(<code>struct</code>), 튜플, 배열은 모든 필드/요소가 각각의 타입에 대해 유효할 것을 요구합니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.union"><a class="rule-link" href="#r-undefined.validity.union" title="undefined.validity.union"><span>[undefined<wbr>.validity<wbr>.union]<span/></a></div>
<ul>
<li>유니온(<code>union</code>)의 경우, 정확한 유효성 요구 사항은 아직 결정되지 않았습니다. 분명히, 안전한 코드만으로 생성할 수 있는 모든 값은 유효합니다. 만약 유니온이 크기가 0인 필드를 가지고 있다면, 가능한 모든 값이 유효합니다. 더 자세한 내용은 <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/438">여전히 논의 중</a>입니다.</li>
</ul>
<div class="rule" id="r-undefined.validity.reference-box"><a class="rule-link" href="#r-undefined.validity.reference-box" title="undefined.validity.reference-box"><span>[undefined<wbr>.validity<wbr>.reference-box]<span/></a></div>
<ul>
<li>참조 또는 <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>는 정렬되어 있어야 하고 널이 아니어야 하며, <a href="#dangling-pointers">매달려</a> 있어서도 안 됩니다. 또한 유효한 값을 가리켜야 합니다(동적 크기 타입의 경우, 메타데이터에 의해 결정된 피지시체의 실제 동적 타입을 사용). 마지막 지점(유효한 값을 가리켜야 한다는 것)은 여전히 논의의 여지가 있음에 유의하십시오.</li>
</ul>
<div class="rule" id="r-undefined.validity.wide"><a class="rule-link" href="#r-undefined.validity.wide" title="undefined.validity.wide"><span>[undefined<wbr>.validity<wbr>.wide]<span/></a></div>
<ul>
<li>와이드 참조(wide reference), <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, 또는 원시 포인터의 메타데이터는 크기가 정해지지 않은 꼬리(unsized tail)의 타입과 일치해야 합니다:
<ul>
<li><code>dyn Trait</code> 메타데이터는 컴파일러가 생성한 <code>Trait</code>용 vtable에 대한 포인터여야 합니다. (원시 포인터의 경우, 이 요구 사항은 여전히 논의 중입니다.)</li>
<li>슬라이스(<code>[T]</code>) 메타데이터는 유효한 <code>usize</code>여야 합니다. 더 나아가, 와이드 참조 및 <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>의 경우, 슬라이스 메타데이터가 가리키는 값의 전체 크기를 <code>isize::MAX</code>보다 크게 만든다면 유효하지 않습니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-undefined.validity.valid-range"><a class="rule-link" href="#r-undefined.validity.valid-range" title="undefined.validity.valid-range"><span>[undefined<wbr>.validity<wbr>.valid-range]<span/></a></div>
<ul>
<li>
<p>만약 타입이 유효한 값의 커스텀 범위를 가지고 있다면, 유효한 값은 반드시 그 범위 내에 있어야 합니다. 표준 라이브러리에서는 <a href="../core/ptr/non_null/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a>와 <a href="../core/num/nonzero/struct.NonZero.html"><code>NonZero&lt;T&gt;</code></a>가 이에 해당합니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>rustc</code>는 불안정한 <code>rustc_layout_scalar_valid_range_*</code> 속성들을 사용하여 이를 수행합니다.</p>
</blockquote>
</li>
</ul>
<div class="rule" id="r-undefined.validity.undef"><a class="rule-link" href="#r-undefined.validity.undef" title="undefined.validity.undef"><span>[undefined<wbr>.validity<wbr>.undef]<span/></a></div>
<p><strong>참고:</strong> 초기화되지 않은 메모리는 제한된 유효 값 집합을 가진 모든 타입에 대해 암시적으로 유효하지 않습니다. 다시 말해, 초기화되지 않은 메모리를 읽는 것이 허용되는 유일한 경우는 <code>union</code> 내부와 “패딩(padding)”(타입의 필드 사이의 간격)뿐입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unsafe-keyword.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unsafe-keyword.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
