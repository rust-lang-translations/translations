<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>정의되지 않은 동작으로 간주되는 경우 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/behavior-considered-undefined.md`;
                    } else {
                        canonical_href = `${base}/${lang}/behavior-considered-undefined.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/behavior-considered-undefined.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[undefined]</p>
<h1 id="정의되지-않은-동작으로-간주되는-경우"><a class="header" href="#정의되지-않은-동작으로-간주되는-경우">정의되지 않은 동작으로 간주되는 경우</a></h1>
<p>r[undefined.general] Rust code is incorrect if it exhibits any of the behaviors in the following list. This includes code within <code>unsafe</code> blocks and <code>unsafe</code> functions. <code>unsafe</code> only means that avoiding undefined behavior is on the programmer; it does not change anything about the fact that Rust programs must never cause undefined behavior.</p>
<p>r[undefined.soundness] It is the programmer’s responsibility when writing <code>unsafe</code> code to ensure that any safe code interacting with the <code>unsafe</code> code cannot trigger these behaviors. <code>unsafe</code> code that satisfies this property for any safe client is called <em>sound</em>; if <code>unsafe</code> code can be misused by safe code to exhibit undefined behavior, it is <em>unsound</em>.</p>
<blockquote>
<p>[!WARNING] The following list is not exhaustive; it may grow or shrink. There is no formal model of Rust’s semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. We also reserve the right to make some of the behavior in that list defined in the future. In other words, this list does not say that anything will <em>definitely</em> always be undefined in all future Rust version (but we might make such commitments for some list items in the future).</p>
<p>안전하지 않은 코드를 작성하기 전에 <a href="../nomicon/index.html">러스트노미콘(Rustonomicon)</a>을 읽어보시기 바랍니다.</p>
</blockquote>
<p>r[undefined.race]</p>
<ul>
<li>데이터 경합 (Data races).</li>
</ul>
<p>r[undefined.pointer-access]</p>
<ul>
<li><a href="#dangling-pointers">매달린 포인터(dangling pointer)</a>이거나 <a href="#places-based-on-misaligned-pointers">정렬되지 않은 포인터에 기반한</a> 위치에 접근(로드 또는 스토어)하는 것.</li>
</ul>
<p>r[undefined.place-projection]</p>
<ul>
<li>Performing a place projection that violates the requirements of <a href="pointer#method.offset">in-bounds pointer arithmetic</a>. A place projection is a <a href="expressions/field-expr.html">field expression</a>, a <a href="expressions/tuple-expr.html#tuple-indexing-expressions">tuple index expression</a>, or an <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array/slice index expression</a>.</li>
</ul>
<p>r[undefined.alias]</p>
<ul>
<li>
<p>Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles: <code>&amp;T</code> must point to memory that is not mutated while they are live (except for data inside an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>), and <code>&amp;mut T</code> must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live. <code>Box&lt;T&gt;</code> is treated similar to <code>&amp;'static mut T</code> for the purpose of these rules. The exact liveness duration is not specified, but some bounds exist:</p>
<ul>
<li>참조의 경우, 생존 기간의 상한선은 대여 검사기(borrow checker)가 할당한 구문상 라이프타임입니다. 즉, 그 라이프타임보다 <em>더 길게</em> 살아있을 수 없습니다.</li>
<li>Each time a reference or box is dereferenced or reborrowed, it is considered live.</li>
<li>참조나 박스가 함수로 전달되거나 함수에서 반환될 때마다, 그것은 살아있는 것으로 간주됩니다.</li>
<li>When a reference (but not a <code>Box</code>!) is passed to a function, it is live at least as long as that function call, again except if the <code>&amp;T</code> contains an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>.
이 모든 사항은 이러한 타입의 값들이 복합 타입의 (중첩된) 필드로 전달될 때도 적용되지만, 포인터 간접 참조(indirections) 뒤에 있는 경우는 제외됩니다.</li>
</ul>
</li>
</ul>
<p>r[undefined.immutable]</p>
<ul>
<li>
<p>Mutating immutable bytes. All bytes reachable through a <a href="destructors.html#constant-promotion">const-promoted</a> expression are immutable, as well as bytes reachable through borrows in <code>static</code> and <code>const</code> initializers that have been <a href="destructors.html#temporary-lifetime-extension">lifetime-extended</a> to <code>'static</code>. The bytes owned by an immutable binding or immutable <code>static</code> are immutable, unless those bytes are part of an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>.</p>
<p>게다가, 공유 참조가 <a href="#pointed-to-bytes">가리키는</a> 바이트들은 다른 참조(공유 및 가변 모두)와 <code>Box</code>를 통한 전이적 참조를 포함하여 모두 불변입니다. 전이성에는 복합 타입의 필드에 저장된 참조들도 포함됩니다.</p>
<p>수정이란 관련 바이트 중 어느 하나라도 겹치는 0바이트 이상의 모든 쓰기 연산을 의미합니다(해당 쓰기가 메모리 내용을 변경하지 않더라도 마찬가지입니다).</p>
</li>
</ul>
<p>r[undefined.intrinsic]</p>
<ul>
<li>컴파일러 내장 함수(intrinsics)를 통해 정의되지 않은 동작을 유발하는 것.</li>
</ul>
<p>r[undefined.target-feature]</p>
<ul>
<li>현재 플랫폼이 지원하지 않는 플랫폼 기능을 사용하여 컴파일된 코드를 실행하는 것(<a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> 참조). 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 제외합니다.</li>
</ul>
<p>r[undefined.call]</p>
<ul>
<li>Calling a function with the wrong <a href="items/external-blocks.html#abi">call ABI</a>, or unwinding past a stack frame that does not allow unwinding (e.g. by calling a <code>"C-unwind"</code> function imported or transmuted as a <code>"C"</code> function or function pointer).</li>
</ul>
<p>r[undefined.invalid]</p>
<ul>
<li><a href="#invalid-values">유효하지 않은 값</a>을 생성하는 것. 값을 “생성“한다는 것은 값이 장소(place)에 할당되거나 장소로부터 읽힐 때, 함수/기본 연산으로 전달되거나 함수/기본 연산으로부터 반환될 때마다 발생합니다.</li>
</ul>
<p>r[undefined.asm]</p>
<ul>
<li>인라인 어셈블리의 잘못된 사용. 자세한 내용은 인라인 어셈블리를 사용하는 코드를 작성할 때 따라야 할 <a href="inline-assembly.html#rules-for-inline-assembly">규칙</a>을 참조하십시오.</li>
</ul>
<p>r[undefined.runtime]</p>
<ul>
<li>Violating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented.
<ul>
<li>For assumptions specifically related to unwinding, see the <a href="panic.html#unwinding-across-ffi-boundaries">panic documentation</a>.</li>
<li>The runtime assumes that a Rust stack frame is not deallocated without executing destructors for local variables owned by the stack frame. This assumption can be violated by C functions like <code>longjmp</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!NOTE] Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
<p>r[undefined.pointed-to]</p>
<h2 id="가리키는-바이트-pointed-to-bytes"><a class="header" href="#가리키는-바이트-pointed-to-bytes">가리키는 바이트 (Pointed-to bytes)</a></h2>
<p>포인터나 참조가 “가리키는” 바이트 범위는 포인터 값과 피지시체(pointee) 타입의 크기(<code>size_of_val</code> 사용)에 의해 결정됩니다.</p>
<p>r[undefined.misaligned]</p>
<h2 id="잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers"><a class="header" href="#잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers">잘못 정렬된 포인터에 기반한 장소 (Places based on misaligned pointers)</a></h2>
<p>r[undefined.misaligned.general] A place is said to be “based on a misaligned pointer” if the last <code>*</code> projection during place computation was performed on a pointer that was not aligned for its type. (If there is no <code>*</code> projection in the place expression, then this is accessing the field of a local or <code>static</code> and rustc will guarantee proper alignment. If there are multiple <code>*</code> projection, then each of them incurs a load of the pointer-to-be-dereferenced itself from memory, and each of these loads is subject to the alignment constraint. Note that some <code>*</code> projections can be omitted in surface Rust syntax due to automatic dereferencing; we are considering the fully expanded place expression here.)</p>
<p>예를 들어, <code>ptr</code>의 타입이 <code>*const S</code>이고 <code>S</code>의 정렬(alignment)이 8이라면, <code>ptr</code>은 반드시 8로 정렬되어야 합니다. 그렇지 않으면 <code>(*ptr).f</code>는 “잘못 정렬된 포인터에 기반한” 것이 됩니다. 이는 필드 <code>f</code>의 타입이 <code>u8</code>(즉, 정렬이 1인 타입)인 경우에도 마찬가지입니다. 다시 말해, 정렬 요구 사항은 접근하려는 필드의 타입이 아니라 역참조된 포인터의 타입에서 비롯됩니다.</p>
<p>r[undefined.misaligned.load-store] Note that a place based on a misaligned pointer only leads to undefined behavior when it is loaded from or stored to.</p>
<p>r[undefined.misaligned.raw] <code>&amp;raw const</code>/<code>&amp;raw mut</code> on such a place is allowed.</p>
<p>r[undefined.misaligned.reference] <code>&amp;</code>/<code>&amp;mut</code> on a place requires the alignment of the field type (or else the program would be “producing an invalid value”), which generally is a less restrictive requirement than being based on an aligned pointer.</p>
<p>r[undefined.misaligned.packed] Taking a reference will lead to a compiler error in cases where the field type might be more aligned than the type that contains it, i.e., <code>repr(packed)</code>. This means that being based on an aligned pointer is always sufficient to ensure that the new reference is aligned, but it is not always necessary.</p>
<p>r[undefined.dangling]</p>
<h2 id="매달린-포인터-dangling-pointers"><a class="header" href="#매달린-포인터-dangling-pointers">매달린 포인터 (Dangling pointers)</a></h2>
<p>r[undefined.dangling.general] A reference/pointer is “dangling” if not all of the bytes it <a href="#pointed-to-bytes">points to</a> are part of the same live allocation (so in particular they all have to be part of <em>some</em> allocation).</p>
<p>r[undefined.dangling.zero-size] If the size is 0, then the pointer is trivially never “dangling” (even if it is a null pointer).</p>
<p>r[undefined.dangling.dynamic-size] Note that dynamically sized types (such as slices and strings) point to their entire range, so it is important that the length metadata is never too large.</p>
<p>r[undefined.dangling.alloc-limit] In particular, the dynamic size of a Rust value (as determined by <code>size_of_val</code>) must never exceed <code>isize::MAX</code>, since it is impossible for a single allocation to be larger than <code>isize::MAX</code>.</p>
<p>r[undefined.validity]</p>
<h2 id="유효하지-않은-값-invalid-values"><a class="header" href="#유효하지-않은-값-invalid-values">유효하지 않은 값 (Invalid values)</a></h2>
<p>r[undefined.validity.general] The Rust compiler assumes that all values produced during program execution are “valid”, and producing an invalid value is hence immediate UB.</p>
<p>값이 유효한지 여부는 타입에 따라 다릅니다:</p>
<p>r[undefined.validity.bool]</p>
<ul>
<li><a href="types/boolean.html"><code>bool</code></a> 값은 <code>false</code> (<code>0</code>) 또는 <code>true</code> (<code>1</code>)여야 합니다.</li>
</ul>
<p>r[undefined.validity.fn-pointer]</p>
<ul>
<li><code>fn</code> 포인터 값은 널(null)이 아니어야 합니다.</li>
</ul>
<p>r[undefined.validity.char]</p>
<ul>
<li><code>char</code> 값은 써로게이트(surrogate, 즉 <code>0xD800..=0xDFFF</code> 범위 내의 값)가 아니어야 하며, <code>char::MAX</code>보다 작거나 같아야 합니다.</li>
</ul>
<p>r[undefined.validity.never]</p>
<ul>
<li><code>!</code> 값은 결코 존재해서는 안 됩니다.</li>
</ul>
<p>r[undefined.validity.scalar]</p>
<ul>
<li>An integer (<code>i*</code>/<code>u*</code>), floating point value (<code>f*</code>), or raw pointer must be initialized, i.e., must not be obtained from uninitialized memory.</li>
</ul>
<p>r[undefined.validity.str]</p>
<ul>
<li><code>str</code> 값은 <code>[u8]</code>과 같이 취급됩니다. 즉, 반드시 초기화되어야 합니다.</li>
</ul>
<p>r[undefined.validity.enum]</p>
<ul>
<li>열거형(<code>enum</code>)은 유효한 판별자(discriminant)를 가져야 하며, 해당 판별자가 나타내는 변형(variant)의 모든 필드는 각각의 타입에 대해 유효해야 합니다.</li>
</ul>
<p>r[undefined.validity.struct]</p>
<ul>
<li>구조체(<code>struct</code>), 튜플, 배열은 모든 필드/요소가 각각의 타입에 대해 유효할 것을 요구합니다.</li>
</ul>
<p>r[undefined.validity.union]</p>
<ul>
<li>유니온(<code>union</code>)의 경우, 정확한 유효성 요구 사항은 아직 결정되지 않았습니다. 분명히, 안전한 코드만으로 생성할 수 있는 모든 값은 유효합니다. 만약 유니온이 크기가 0인 필드를 가지고 있다면, 가능한 모든 값이 유효합니다. 더 자세한 내용은 <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/438">여전히 논의 중</a>입니다.</li>
</ul>
<p>r[undefined.validity.reference-box]</p>
<ul>
<li>A reference or [<code>Box&lt;T&gt;</code>] must be aligned and non-null, it cannot be <a href="#dangling-pointers">dangling</a>, and it must point to a valid value (in case of dynamically sized types, using the actual dynamic type of the pointee as determined by the metadata). Note that the last point (about pointing to a valid value) remains a subject of some debate.</li>
</ul>
<p>r[undefined.validity.wide]</p>
<ul>
<li>The metadata of a wide reference, [<code>Box&lt;T&gt;</code>], or raw pointer must match the type of the unsized tail:
<ul>
<li><code>dyn Trait</code> 메타데이터는 컴파일러가 생성한 <code>Trait</code>용 vtable에 대한 포인터여야 합니다. (원시 포인터의 경우, 이 요구 사항은 여전히 논의 중입니다.)</li>
<li>Slice (<code>[T]</code>) metadata must be a valid <code>usize</code>. Furthermore, for wide references and [<code>Box&lt;T&gt;</code>], slice metadata is invalid if it makes the total size of the pointed-to value bigger than <code>isize::MAX</code>.</li>
</ul>
</li>
</ul>
<p>r[undefined.validity.valid-range]</p>
<ul>
<li>
<p>If a type has a custom range of a valid values, then a valid value must be in that range. In the standard library, this affects <a href="core::ptr::NonNull"><code>NonNull&lt;T&gt;</code></a> and <a href="core::num::NonZero"><code>NonZero&lt;T&gt;</code></a>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> achieves this with the unstable <code>rustc_layout_scalar_valid_range_*</code> attributes.</p>
</blockquote>
</li>
</ul>
<p>r[undefined.validity.const-provenance]</p>
<ul>
<li>
<p><strong>In <a href="const-eval.const-context">const contexts</a></strong>: In addition to what is described above, further provenance-related requirements apply during const evaluation. Any value that holds pure integer data (the <code>i*</code>/<code>u*</code>/<code>f*</code> types as well as <code>bool</code> and <code>char</code>, enum discriminants, and slice metadata) must not carry any provenance. Any value that holds pointer data (references, raw pointers, function pointers, and <code>dyn Trait</code> metadata) must either carry no provenance, or all bytes must be fragments of the same original pointer value in the correct order.</p>
<p>This implies that transmuting or otherwise reinterpreting a pointer (reference, raw pointer, or function pointer) into a non-pointer type (such as integers) is undefined behavior if the pointer had provenance.</p>
<blockquote>
<p>[!EXAMPLE] All of the following are UB:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::mem::MaybeUninit;
</span><span class="boring">use core::ptr;
</span>// We cannot reinterpret a pointer with provenance as an integer,
// as then the bytes of the integer will have provenance.
const _: usize = {
    let ptr = &amp;0;
    unsafe { (&amp;raw const ptr as *const usize).read() }
};

// We cannot rearrange the bytes of a pointer with provenance and
// then interpret them as a reference, as then a value holding
// pointer data will have pointer fragments in the wrong order.
const _: &amp;i32 = {
    let mut ptr = &amp;0;
    let ptr_bytes = &amp;raw mut ptr as *mut MaybeUninit::&lt;u8&gt;;
    unsafe { ptr::swap(ptr_bytes.add(1), ptr_bytes.add(2)) };
    ptr
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
</ul>
<p>r[undefined.validity.undef] <strong>Note:</strong> Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside <code>union</code>s and in “padding” (the gaps between the fields of a type).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unsafe-keyword.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unsafe-keyword.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
