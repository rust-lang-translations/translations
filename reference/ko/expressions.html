<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>표현식 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/expressions.md`;
                    } else {
                        canonical_href = `${base}/${lang}/expressions.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/expressions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[expr]</p>
<h1 id="표현식"><a class="header" href="#표현식">표현식</a></h1>
<p>r[expr.syntax]</p>
<pre><code class="language-grammar expressions">Expression -&gt;
      ExpressionWithoutBlock
    | ExpressionWithBlock

ExpressionWithoutBlock -&gt;
    OuterAttribute*
    (
        LiteralExpression
      | PathExpression
      | OperatorExpression
      | GroupedExpression
      | ArrayExpression
      | AwaitExpression
      | IndexExpression
      | TupleExpression
      | TupleIndexingExpression
      | StructExpression
      | CallExpression
      | MethodCallExpression
      | FieldExpression
      | ClosureExpression
      | AsyncBlockExpression
      | ContinueExpression
      | BreakExpression
      | RangeExpression
      | ReturnExpression
      | UnderscoreExpression
      | MacroInvocation
    )

ExpressionWithBlock -&gt;
    OuterAttribute*
    (
        BlockExpression
      | ConstBlockExpression
      | UnsafeBlockExpression
      | LoopExpression
      | IfExpression
      | MatchExpression
    )
</code></pre>
<p>r[expr.intro] An expression may have two roles: it always produces a <em>value</em>, and it may have <em>effects</em> (otherwise known as “side effects”).</p>
<p>r[expr.evaluation] An expression <em>evaluates to</em> a value, and has effects during <em>evaluation</em>.</p>
<p>r[expr.operands] Many expressions contain sub-expressions, called the <em>operands</em> of the expression.</p>
<p>r[expr.behavior] The meaning of each kind of expression dictates several things:</p>
<ul>
<li>표현식을 평가할 때 피연산자를 평가할지 여부</li>
<li>피연산자를 평가하는 순서</li>
<li>표현식의 값을 얻기 위해 피연산자들의 값을 결합하는 방법</li>
</ul>
<p>r[expr.structure] In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<blockquote>
<p>[!NOTE] We give names to the operands of expressions so that we may discuss them, but these names are not stable and may be changed.</p>
</blockquote>
<p>r[expr.precedence]</p>
<h2 id="표현식-우선순위"><a class="header" href="#표현식-우선순위">표현식 우선순위</a></h2>
<p>Rust 연산자와 표현식의 우선순위는 다음과 같으며, 강한 것부터 약한 것 순으로 나열되어 있습니다. 동일한 우선순위 수준의 이항 연산자들은 그들의 결합성(associativity)에 따라 그룹화됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>연산자/표현식</th><th>결합성</th></tr></thead><tbody>
<tr><td>[Paths][expr.path]</td><td></td></tr>
<tr><td>[Method calls][expr.method]</td><td></td></tr>
<tr><td>[Field expressions][expr.field]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[Function calls][expr.call], [array indexing][expr.array.index]</td><td></td></tr>
<tr><td>[<code>?</code>][expr.try]</td><td></td></tr>
<tr><td>Unary [<code>-</code>][expr.negate] [<code>!</code>][expr.negate] [<code>*</code>][expr.deref] [borrow][expr.operator.borrow]</td><td></td></tr>
<tr><td>[<code>as</code>][expr.as]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>*</code>][expr.arith-logic] [<code>/</code>][expr.arith-logic] [<code>%</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>+</code>][expr.arith-logic] [<code>-</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>&lt;&lt;</code>][expr.arith-logic] [<code>&gt;&gt;</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>&amp;</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>^</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>|</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>==</code>][expr.cmp] [<code>!=</code>][expr.cmp] [<code>&lt;</code>][expr.cmp] [<code>&gt;</code>][expr.cmp] [<code>&lt;=</code>][expr.cmp] [<code>&gt;=</code>][expr.cmp]</td><td>괄호 필요</td></tr>
<tr><td>[<code>&amp;&amp;</code>][expr.bool-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>||</code>][expr.bool-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>..</code>][expr.range] [<code>..=</code>][expr.range]</td><td>괄호 필요</td></tr>
<tr><td>[<code>=</code>][expr.assign] [<code>+=</code>][expr.compound-assign] [<code>-=</code>][expr.compound-assign] [<code>*=</code>][expr.compound-assign] [<code>/=</code>][expr.compound-assign] [<code>%=</code>][expr.compound-assign] <br> [<code>&amp;=</code>][expr.compound-assign] [<code>|=</code>][expr.compound-assign] [<code>^=</code>][expr.compound-assign] [<code>&lt;&lt;=</code>][expr.compound-assign] [<code>&gt;&gt;=</code>][expr.compound-assign]</td><td>오른쪽에서 왼쪽으로</td></tr>
<tr><td>[<code>return</code>][expr.return] [<code>break</code>][expr.loop.break] [closures][expr.closure]</td><td></td></tr>
</tbody></table>
</div>
<p>r[expr.operand-order]</p>
<h2 id="피연산자의-평가-순서"><a class="header" href="#피연산자의-평가-순서">피연산자의 평가 순서</a></h2>
<p>r[expr.operand-order.default] The following list of expressions all evaluate their operands the same way, as described after the list. Other expressions either don’t take operands or evaluate them conditionally as described on their respective pages.</p>
<ul>
<li>역참조 표현식</li>
<li>에러 전파 표현식</li>
<li>부정 표현식</li>
<li>산술 및 논리 이항 연산자</li>
<li>비교 연산자</li>
<li>타입 캐스트 표현식</li>
<li>그룹화된 표현식</li>
<li>배열 표현식</li>
<li>Await 표현식</li>
<li>인덱스 표현식</li>
<li>튜플 표현식</li>
<li>튜플 인덱스 표현식</li>
<li>구조체 표현식</li>
<li>호출 표현식</li>
<li>메서드 호출 표현식</li>
<li>필드 표현식</li>
<li>Break 표현식</li>
<li>범위 표현식</li>
<li>Return 표현식</li>
</ul>
<p>r[expr.operand-order.operands-before-primary] The operands of these expressions are evaluated prior to applying the effects of the expression. Expressions taking multiple operands are evaluated left to right as written in the source code.</p>
<blockquote>
<p>[!NOTE] Which subexpressions are the operands of an expression is determined by expression precedence as per the previous section.</p>
</blockquote>
<p>예를 들어, 두 개의 <code>next</code> 메서드 호출은 항상 동일한 순서로 호출됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// 참조를 피하기 위해 배열 대신 vec를 사용합니다.
</span><span class="boring">// 이 예제가 작성된 시점에는 안정적인 소유권 있는(owned) 배열 반복자가
</span><span class="boring">// 없었기 때문입니다.
</span>let mut one_two = vec![1, 2].into_iter();
assert_eq!(
    (1, 2),
    (one_two.next().unwrap(), one_two.next().unwrap())
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Since this is applied recursively, these expressions are also evaluated from innermost to outermost, ignoring siblings until there are no inner subexpressions.</p>
</blockquote>
<p>r[expr.place-value]</p>
<h2 id="place-expressions-and-value-expressions"><a class="header" href="#place-expressions-and-value-expressions">Place expressions and value expressions</a></h2>
<p>r[expr.place-value.intro] Expressions are divided into two main categories: place expressions and value expressions; there is also a third, minor category of expressions called assignee expressions. Within each expression, operands may likewise occur in either place context or value context. The evaluation of an expression depends both on its own category and the context it occurs within.</p>
<p>r[expr.place-value.place-memory-location] A <em>place expression</em> is an expression that represents a memory location.</p>
<p>r[expr.place-value.place-expr-kinds] These expressions are <a href="expressions/path-expr.html">paths</a> which refer to local variables, <a href="items/static-items.html">static variables</a>, <a href="expressions/operator-expr.html#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions (<code>expr[expr]</code>), <a href="expressions/field-expr.html">field</a> references (<code>expr.f</code>) and parenthesized place expressions.</p>
<p>r[expr.place-value.value-expr-kinds] All other expressions are value expressions.</p>
<p>r[expr.place-value.value-result] A <em>value expression</em> is an expression that represents an actual value.</p>
<p>r[expr.place-value.place-context] The following contexts are <em>place expression</em> contexts:</p>
<ul>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a> 표현식의 왼쪽 피연산자.</li>
<li>단항 <a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용(raw borrow)</a> 또는 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a> 연산자의 피연산자.</li>
<li>필드 표현식의 피연산자.</li>
<li>배열 인덱싱 표현식의 인덱스된 피연산자.</li>
<li>임의의 <a href="#implicit-borrows">암시적 차용(implicit borrow)</a>의 피연산자.</li>
<li><a href="statements.html#let-statements">let 문</a>의 초기화 식(initializer).</li>
<li>The <a href="glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-patterns"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a>, or <a href="expressions/loop-expr.html#while-let-patterns"><code>while let</code></a> expression.</li>
<li><a href="expressions/struct-expr.html#functional-update-syntax">함수형 업데이트(functional update)</a> 구조체 표현식의 베이스(base).</li>
</ul>
<blockquote>
<p>[!NOTE] Historically, place expressions were called <em>lvalues</em> and value expressions were called <em>rvalues</em>.</p>
</blockquote>
<p>r[expr.place-value.assignee] An <em>assignee expression</em> is an expression that appears in the left operand of an <a href="expressions/operator-expr.html#assignment-expressions">assignment</a> expression. Explicitly, the assignee expressions are:</p>
<ul>
<li>장소 표현식.</li>
<li><a href="expressions/underscore-expr.html">밑줄(Underscores)</a>.</li>
<li>피할당자 표현식의 <a href="expressions/tuple-expr.html">튜플</a>.</li>
<li>[Slices][expr.array.index] of assignee expressions.</li>
<li><a href="items.struct.tuple">Tuple structs</a> of assignee expressions.</li>
<li><a href="expr.struct">Structs</a> of assignee expressions (with optionally named fields).</li>
<li><a href="items.struct.unit">Unit structs</a></li>
</ul>
<p>r[expr.place-value.parenthesis] Arbitrary parenthesisation is permitted inside assignee expressions.</p>
<p>r[expr.move]</p>
<h3 id="이동-및-복사-타입"><a class="header" href="#이동-및-복사-타입">이동 및 복사 타입</a></h3>
<p>r[expr.move.intro] When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held <em>in</em> that memory location.</p>
<p>r[expr.move.copy] If the type of that value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>, then the value will be copied.</p>
<p>r[expr.move.requires-sized] In the remaining situations, if that type is <a href="special-types-and-traits.html#sized"><code>Sized</code></a>, then it may be possible to move the value.</p>
<p>r[expr.move.movable-place] Only the following place expressions may be moved out of:</p>
<ul>
<li>현재 차용(borrow)되지 않은 <a href="variables.html">변수</a>.</li>
<li><a href="#temporaries">임시 값</a>.</li>
<li>값을 이동시킬 수 있는 장소 표현식의 <a href="expressions/field-expr.html">필드</a>들 중 <a href="special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않은 것.</li>
<li>The result of <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> an expression with type [<code>Box&lt;T&gt;</code>] and that can also be moved out of.</li>
</ul>
<p>r[expr.move.deinitialization] After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized.</p>
<p>r[expr.move.place-invalid] In all other cases, trying to use a place expression in a value expression context is an error.</p>
<p>r[expr.mut]</p>
<h3 id="가변성mutability"><a class="header" href="#가변성mutability">가변성(Mutability)</a></h3>
<p>r[expr.mut.intro] For a place expression to be <a href="expressions/operator-expr.html#assignment-expressions">assigned</a> to, mutably <a href="expressions/operator-expr.html#borrow-operators">borrowed</a>, <a href="#implicit-borrows">implicitly mutably borrowed</a>, or bound to a pattern containing <code>ref mut</code>, it must be <em>mutable</em>. We call these <em>mutable place expressions</em>. In contrast, other place expressions are called <em>immutable place expressions</em>.</p>
<p>r[expr.mut.valid-places] The following expressions can be mutable place expression contexts:</p>
<ul>
<li>현재 차용되지 않은 가변 <a href="variables.html">변수(variables)</a>.</li>
<li><a href="items/static-items.html#mutable-statics">가변 <code>static</code> 아이템</a>.</li>
<li><a href="#temporaries">임시 값</a>.</li>
<li><a href="expressions/field-expr.html">필드(Fields)</a>: 이는 하위 표현식을 가변 장소 표현식 컨텍스트에서 평가합니다.</li>
<li><code>*mut T</code> 포인터의 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(Dereferences)</a>.</li>
<li><code>&amp;mut T</code> 타입을 가진 변수 또는 변수 필드의 역참조. 참고: 이는 다음 규칙의 요구 사항에 대한 예외입니다.</li>
<li><code>DerefMut</code>를 구현하는 타입의 역참조: 이는 역참조되는 값이 가변 장소 표현식 컨텍스트에서 평가될 것을 요구합니다.</li>
<li><code>IndexMut</code>를 구현하는 타입의 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(Array indexing)</a>: 이는 인덱싱되는 값을 가변 장소 표현식 컨텍스트에서 평가하지만, 인덱스는 그렇지 않습니다.</li>
</ul>
<p>r[expr.temporary]</p>
<h3 id="임시-값temporaries"><a class="header" href="#임시-값temporaries">임시 값(Temporaries)</a></h3>
<p>대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용할 때, 이름 없는 임시 메모리 위치가 생성되고 해당 값으로 초기화됩니다. 표현식은 <code>static</code>으로 <a href="destructors.html#constant-promotion">승격(promoted)</a>되지 않는 한 해당 위치로 평가됩니다. 임시 값의 <a href="destructors.html#drop-scopes">드롭 스코프(drop scope)</a>는 보통 이를 둘러싼 구문의 끝입니다.</p>
<p>r[expr.super-macros]</p>
<h3 id="super-macros"><a class="header" href="#super-macros">Super macros</a></h3>
<p>r[expr.super-macros.intro] Certain built-in macros may create <a href="expr.temporary">temporaries</a> whose <a href="destructors.scope.temporary">scopes</a> may be <a href="destructors.scope.lifetime-extension">extended</a>. These temporaries are <em>super temporaries</em> and these macros are <em>super macros</em>. <a href="macro.invocation">Invocations</a> of these macros are <em>super macro call expressions</em>. Arguments to these macros may be <em>super operands</em>.</p>
<blockquote>
<p>[!NOTE] When a super macro call expression is an <a href="destructors.scope.lifetime-extension.exprs">extending expression</a>, its super operands are <a href="destructors.scope.lifetime-extension.exprs">extending expressions</a> and the <a href="destructors.scope.temporary">scopes</a> of the super temporaries are <a href="destructors.scope.lifetime-extension">extended</a>. See [destructors.scope.lifetime-extension.exprs].</p>
</blockquote>
<p>r[expr.super-macros.format_args]</p>
<h4 id="format_args"><a class="header" href="#format_args"><code>format_args!</code></a></h4>
<p>r[expr.super-macros.format_args.super-operands] Except for the format string argument, all arguments passed to <a href="core::format_args"><code>format_args!</code></a> are <em>super operands</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() -&gt; String { String::from("") }
</span>// Due to the call being an extending expression and the argument
// being a super operand, the inner block is an extending expression,
// so the scope of the temporary created in its trailing expression
// is extended.
let _ = format_args!("{}", { &amp;temp() }); // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.super-macros.format_args.super-temporaries] The super operands of <a href="core::format_args"><code>format_args!</code></a> are <a href="expr.implicit-borrow">implicitly borrowed</a> and are therefore <a href="expr.place-value">place expression contexts</a>. When a <a href="expr.place-value">value expression</a> is passed as an argument, it creates a <em>super temporary</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() -&gt; String { String::from("") }
</span>let x = format_args!("{}", temp());
x; // &lt;-- The temporary is extended, allowing use here.
<span class="boring">}</span></code></pre></pre>
<p>The expansion of a call to <a href="core::format_args"><code>format_args!</code></a> sometimes creates other internal <em>super temporaries</em>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    // This call creates an internal temporary.
    let x = format_args!("{:?}", 0);
    x // &lt;-- The temporary is extended, allowing its use here.
}; // &lt;-- The temporary is dropped here.
x; // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This call doesn't create an internal temporary.
let x = { let x = format_args!("{}", 0); x };
x; // OK
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] The details of when <a href="core::format_args"><code>format_args!</code></a> does or does not create internal temporaries are currently unspecified.</p>
</blockquote>
<p>r[expr.super-macros.pin]</p>
<h4 id="pin"><a class="header" href="#pin"><code>pin!</code></a></h4>
<p>r[expr.super-macros.pin.super-operands] The argument to <a href="core::pin::pin"><code>pin!</code></a> is a <em>super operand</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">fn temp() {}
</span>// As above for `format_args!`.
let _ = pin!({ &amp;temp() }); // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.super-macros.pin.super-temporaries] The argument to <a href="core::pin::pin"><code>pin!</code></a> is a <a href="expr.place-value">value expression context</a> and creates a <em>super temporary</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">fn temp() {}
</span>// The argument is evaluated into a super temporary.
let x = pin!(temp());
// The temporary is extended, allowing its use here.
x; // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.implicit-borrow]</p>
<h3 id="implicit-borrows"><a class="header" href="#implicit-borrows">Implicit borrows</a></h3>
<p>r[expr.implicit-borrow-intro] Certain expressions will treat an expression as a place expression by implicitly borrowing it. For example, it is possible to compare two unsized <a href="types/slice.html">slices</a> for equality directly, because the <code>==</code> operator implicitly borrows its operands:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// 동등한 형태:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.implicit-borrow.application] Implicit borrows may be taken in the following expressions:</p>
<ul>
<li><a href="expressions/method-call-expr.html">메서드 호출(method-call)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/field-expr.html">필드(field)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/call-expr.html">호출 표현식(call expressions)</a>의 왼쪽 피연산자.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(array indexing)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a> (<code>*</code>)의 피연산자.</li>
<li><a href="expressions/operator-expr.html#comparison-operators">비교(comparison)</a>의 피연산자들.</li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a>의 왼쪽 피연산자들.</li>
<li>Arguments to <a href="core::format_args"><code>format_args!</code></a> except the format string.</li>
</ul>
<p>r[expr.overload]</p>
<h2 id="overloading-traits"><a class="header" href="#overloading-traits">Overloading traits</a></h2>
<p>다음 중 많은 연산자와 표현식들은 <code>std::ops</code>나 <code>std::cmp</code>에 있는 트레잇들을 사용하여 다른 타입에 대해 오버로드될 수 있습니다. 이러한 트레잇들은 <code>core::ops</code> 및 <code>core::cmp</code>에도 동일한 이름으로 존재합니다.</p>
<p>r[expr.attr]</p>
<h2 id="expression-attributes"><a class="header" href="#expression-attributes">Expression attributes</a></h2>
<p>r[expr.attr.restriction] <a href="attributes.html">Outer attributes</a> before an expression are allowed only in a few specific cases:</p>
<ul>
<li><a href="statements.html">구문(statement)</a>으로 사용된 표현식 앞에 올 때.</li>
<li><a href="expressions/array-expr.html">배열 표현식(array expressions)</a>, <a href="expressions/tuple-expr.html">튜플 표현식(tuple expressions)</a>, <a href="expressions/call-expr.html">호출 표현식(call expressions)</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체(struct)</a> 표현식의 요소들에 올 때.</li>
<li><a href="expressions/block-expr.html">블록 표현식(block expressions)</a>의 마지막 표현식(tail expression)에 올 때.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<p>r[expr.attr.never-before] They are never allowed before:</p>
<ul>
<li><a href="expressions/range-expr.html">범위(Range)</a> 표현식 앞.</li>
<li>Binary operator expressions ([ArithmeticOrLogicalExpression], [ComparisonExpression], [LazyBooleanExpression], [TypeCastExpression], [AssignmentExpression], [CompoundAssignmentExpression]).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="statements.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="expressions/literal-expr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="statements.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="expressions/literal-expr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
