<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>표현식 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/expressions.md`;
                    } else {
                        canonical_href = `${base}/${lang}/expressions.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/expressions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-expr"><a class="rule-link" href="#r-expr" title="expr"><span>[expr]<span/></a></div>
<h1 id="표현식"><a class="header" href="#표현식">표현식</a></h1>
<div class="rule" id="r-expr.syntax"><a class="rule-link" href="#r-expr.syntax" title="expr.syntax"><span>[expr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>표현식</em> :<br />
      <em>블록없는표현식</em><br />
   | <em>블록있는표현식</em></p>
<p><em>ExpressionWithoutBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
      | <a href="expressions/path-expr.html"><em>PathExpression</em></a><br />
      | <a href="expressions/operator-expr.html"><em>OperatorExpression</em></a><br />
      | <a href="expressions/grouped-expr.html"><em>GroupedExpression</em></a><br />
      | <a href="expressions/array-expr.html"><em>ArrayExpression</em></a><br />
      | <a href="expressions/await-expr.html"><em>AwaitExpression</em></a><br />
      | <a href="expressions/array-expr.html#array-and-slice-indexing-expressions"><em>IndexExpression</em></a><br />
      | <a href="expressions/tuple-expr.html"><em>TupleExpression</em></a><br />
      | <a href="expressions/tuple-expr.html#tuple-indexing-expressions"><em>TupleIndexingExpression</em></a><br />
      | <a href="expressions/struct-expr.html"><em>StructExpression</em></a><br />
      | <a href="expressions/call-expr.html"><em>CallExpression</em></a><br />
      | <a href="expressions/method-call-expr.html"><em>MethodCallExpression</em></a><br />
      | <a href="expressions/field-expr.html"><em>FieldExpression</em></a><br />
      | <a href="expressions/closure-expr.html"><em>ClosureExpression</em></a><br />
      | <a href="expressions/block-expr.html#async-blocks"><em>AsyncBlockExpression</em></a><br />
      | <a href="expressions/loop-expr.html#continue-expressions"><em>ContinueExpression</em></a><br />
      | <a href="expressions/loop-expr.html#break-expressions"><em>BreakExpression</em></a><br />
      | <a href="expressions/range-expr.html"><em>RangeExpression</em></a><br />
      | <a href="expressions/return-expr.html"><em>ReturnExpression</em></a><br />
      | <a href="expressions/underscore-expr.html"><em>UnderscoreExpression</em></a><br />
      | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a><br />
   )</p>
<p><em>블록있는표현식</em> :<br />
   <a href="attributes.html"><em>외부속성</em></a><sup>*</sup><a href="#expression-attributes">†</a><br />
   (<br />
          <a href="expressions/block-expr.html"><em>블록표현식</em></a><br />
      | <a href="expressions/block-expr.html#const-blocks"><em>Const블록표현식</em></a><br />
      | <a href="expressions/block-expr.html#unsafe-blocks"><em>Unsafe블록표현식</em></a><br />
      | <a href="expressions/loop-expr.html"><em>루프표현식</em></a><br />
      | <a href="expressions/if-expr.html#if-expressions"><em>If표현식</em></a><br />
      | <a href="expressions/if-expr.html#if-let-expressions"><em>IfLet표현식</em></a><br />
      | <a href="expressions/match-expr.html"><em>매치표현식</em></a><br />
   )</p>
</blockquote>
<div class="rule" id="r-expr.intro"><a class="rule-link" href="#r-expr.intro" title="expr.intro"><span>[expr<wbr>.intro]<span/></a></div>
<p>표현식은 두 가지 역할을 가질 수 있습니다: 항상 _값(value)_을 생성하며, <em>효과(effects)</em> (또는 “부수 효과”)를 가질 수 있습니다.</p>
<div class="rule" id="r-expr.evaluation"><a class="rule-link" href="#r-expr.evaluation" title="expr.evaluation"><span>[expr<wbr>.evaluation]<span/></a></div>
<p>표현식은 값으로 _평가(evaluates to)_되며, <em>평가</em> 중에 효과를 가집니다.</p>
<div class="rule" id="r-expr.operands"><a class="rule-link" href="#r-expr.operands" title="expr.operands"><span>[expr<wbr>.operands]<span/></a></div>
<p>많은 표현식은 하위 표현식을 포함하며, 이를 표현식의 _피연산자(operands)_라고 부릅니다.</p>
<div class="rule" id="r-expr.behavior"><a class="rule-link" href="#r-expr.behavior" title="expr.behavior"><span>[expr<wbr>.behavior]<span/></a></div>
<p>각 종류의 표현식의 의미는 몇 가지 사항을 결정합니다:</p>
<ul>
<li>표현식을 평가할 때 피연산자를 평가할지 여부</li>
<li>피연산자를 평가하는 순서</li>
<li>표현식의 값을 얻기 위해 피연산자들의 값을 결합하는 방법</li>
</ul>
<div class="rule" id="r-expr.structure"><a class="rule-link" href="#r-expr.structure" title="expr.structure"><span>[expr<wbr>.structure]<span/></a></div>
<p>이러한 방식으로 표현식의 구조는 실행 구조를 결정합니다. 블록은 단지 또 다른 종류의 표현식일 뿐이므로, 블록, 구문, 표현식 그리고 다시 블록이 임의의 깊이로 서로 재귀적으로 중첩될 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 논의를 위해 표현식의 피연산자에 이름을 붙였지만, 이러한 이름은 고정된 것이 아니며 변경될 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-expr.precedence"><a class="rule-link" href="#r-expr.precedence" title="expr.precedence"><span>[expr<wbr>.precedence]<span/></a></div>
<h2 id="표현식-우선순위"><a class="header" href="#표현식-우선순위">표현식 우선순위</a></h2>
<p>Rust 연산자와 표현식의 우선순위는 다음과 같으며, 강한 것부터 약한 것 순으로 나열되어 있습니다. 동일한 우선순위 수준의 이항 연산자들은 그들의 결합성(associativity)에 따라 그룹화됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>연산자/표현식</th><th>결합성</th></tr></thead><tbody>
<tr><td>경로</td><td></td></tr>
<tr><td>메서드 호출</td><td></td></tr>
<tr><td>필드 표현식</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>함수 호출, 배열 인덱싱</td><td></td></tr>
<tr><td><code>?</code></td><td></td></tr>
<tr><td>단항 <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code></td><td></td></tr>
<tr><td><code>as</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>&amp;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>^</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>|</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>괄호 필요</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>||</code></td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td><code>..</code> <code>..=</code></td><td>괄호 필요</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>오른쪽에서 왼쪽으로</td></tr>
<tr><td><code>return</code> <code>break</code> 클로저</td><td></td></tr>
</tbody></table>
</div><div class="rule" id="r-expr.operand-order"><a class="rule-link" href="#r-expr.operand-order" title="expr.operand-order"><span>[expr<wbr>.operand-order]<span/></a></div>
<h2 id="피연산자의-평가-순서"><a class="header" href="#피연산자의-평가-순서">피연산자의 평가 순서</a></h2>
<div class="rule" id="r-expr.operand-order.default"><a class="rule-link" href="#r-expr.operand-order.default" title="expr.operand-order.default"><span>[expr<wbr>.operand-order<wbr>.default]<span/></a></div>
<p>다음 목록의 표현식들은 모두 목록 뒤에 설명된 것과 동일한 방식으로 피연산자를 평가합니다. 다른 표현식들은 피연산자를 취하지 않거나, 각각의 페이지에 설명된 대로 조건부로 평가합니다.</p>
<ul>
<li>역참조 표현식</li>
<li>에러 전파 표현식</li>
<li>부정 표현식</li>
<li>산술 및 논리 이항 연산자</li>
<li>비교 연산자</li>
<li>타입 캐스트 표현식</li>
<li>그룹화된 표현식</li>
<li>배열 표현식</li>
<li>Await 표현식</li>
<li>인덱스 표현식</li>
<li>튜플 표현식</li>
<li>튜플 인덱스 표현식</li>
<li>구조체 표현식</li>
<li>호출 표현식</li>
<li>메서드 호출 표현식</li>
<li>필드 표현식</li>
<li>Break 표현식</li>
<li>범위 표현식</li>
<li>Return 표현식</li>
</ul>
<div class="rule" id="r-expr.operand-order.operands-before-primary"><a class="rule-link" href="#r-expr.operand-order.operands-before-primary" title="expr.operand-order.operands-before-primary"><span>[expr<wbr>.operand-order<wbr>.operands-before-primary]<span/></a></div>
<p>이러한 표현식의 피연산자들은 표현식의 효과가 적용되기 전에 평가됩니다. 여러 피연산자를 취하는 표현식은 소스 코드에 작성된 대로 왼쪽에서 오른쪽으로 평가됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 어떤 하위 표현식이 표현식의 피연산자인지는 이전 섹션에서 설명한 표현식 우선순위에 의해 결정됩니다.</p>
</blockquote>
<p>예를 들어, 두 개의 <code>next</code> 메서드 호출은 항상 동일한 순서로 호출됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// 참조를 피하기 위해 배열 대신 vec를 사용합니다.
</span><span class="boring">// 이 예제가 작성된 시점에는 안정적인 소유권 있는(owned) 배열 반복자가
</span><span class="boring">// 없었기 때문입니다.
</span>let mut one_two = vec![1, 2].into_iter();
assert_eq!(
    (1, 2),
    (one_two.next().unwrap(), one_two.next().unwrap())
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 이는 재귀적으로 적용되므로, 이러한 표현식들은 또한 가장 안쪽에서 바깥쪽 순서로 평가되며, 내부에 더 이상의 하위 표현식이 없을 때까지 형제 노드들을 무시합니다.</p>
</blockquote>
<div class="rule" id="r-expr.place-value"><a class="rule-link" href="#r-expr.place-value" title="expr.place-value"><span>[expr<wbr>.place-value]<span/></a></div>
<h2 id="장소-표현식과-값-표현식"><a class="header" href="#장소-표현식과-값-표현식">장소 표현식과 값 표현식</a></h2>
<div class="rule" id="r-expr.place-value.intro"><a class="rule-link" href="#r-expr.place-value.intro" title="expr.place-value.intro"><span>[expr<wbr>.place-value<wbr>.intro]<span/></a></div>
<p>표현식은 두 가지 주요 범주로 나뉩니다: 장소 표현식(place expressions)과 값 표현식(value expressions). 또한 피할당자 표현식(assignee expressions)이라고 불리는 세 번째 보조 범주도 있습니다. 각 표현식 내에서 피연산자들은 마찬가지로 장소 컨텍스트나 값 컨텍스트 중 하나에서 나타날 수 있습니다. 표현식의 평가는 표현식 자체의 범주와 표현식이 나타나는 컨텍스트 모두에 달려 있습니다.</p>
<div class="rule" id="r-expr.place-value.place-memory-location"><a class="rule-link" href="#r-expr.place-value.place-memory-location" title="expr.place-value.place-memory-location"><span>[expr<wbr>.place-value<wbr>.place-memory-location]<span/></a></div>
<p>_장소 표현식(place expression)_은 메모리 위치를 나타내는 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.place-expr-kinds"><a class="rule-link" href="#r-expr.place-value.place-expr-kinds" title="expr.place-value.place-expr-kinds"><span>[expr<wbr>.place-value<wbr>.place-expr-kinds]<span/></a></div>
<p>이러한 표현식들은 지역 변수, <a href="items/static-items.html">정적 변수</a>를 참조하는 <a href="expressions/path-expr.html">경로</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a> 표현식 (<code>expr[expr]</code>), <a href="expressions/field-expr.html">필드</a> 참조 (<code>expr.f</code>) 및 괄호로 둘러싸인 장소 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.value-expr-kinds"><a class="rule-link" href="#r-expr.place-value.value-expr-kinds" title="expr.place-value.value-expr-kinds"><span>[expr<wbr>.place-value<wbr>.value-expr-kinds]<span/></a></div>
<p>다른 모든 표현식은 값 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.value-result"><a class="rule-link" href="#r-expr.place-value.value-result" title="expr.place-value.value-result"><span>[expr<wbr>.place-value<wbr>.value-result]<span/></a></div>
<p>_값 표현식(value expression)_은 실제 값을 나타내는 표현식입니다.</p>
<div class="rule" id="r-expr.place-value.place-context"><a class="rule-link" href="#r-expr.place-value.place-context" title="expr.place-value.place-context"><span>[expr<wbr>.place-value<wbr>.place-context]<span/></a></div>
<p>다음 컨텍스트들은 <em>장소 표현식</em> 컨텍스트입니다:</p>
<ul>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a> 표현식의 왼쪽 피연산자.</li>
<li>단항 <a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용(raw borrow)</a> 또는 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a> 연산자의 피연산자.</li>
<li>필드 표현식의 피연산자.</li>
<li>배열 인덱싱 표현식의 인덱스된 피연산자.</li>
<li>임의의 <a href="#implicit-borrows">암시적 차용(implicit borrow)</a>의 피연산자.</li>
<li><a href="statements.html#let-statements">let 문</a>의 초기화 식(initializer).</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a> 또는 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 표현식의 <a href="glossary.html#scrutinee">피검사대상(scrutinee)</a>.</li>
<li><a href="expressions/struct-expr.html#functional-update-syntax">함수형 업데이트(functional update)</a> 구조체 표현식의 베이스(base).</li>
</ul>
<blockquote>
<p>참고: 역사적으로 장소 표현식은 _lvalues_로, 값 표현식은 _rvalues_로 불렸습니다.</p>
</blockquote>
<div class="rule" id="r-expr.place-value.assignee"><a class="rule-link" href="#r-expr.place-value.assignee" title="expr.place-value.assignee"><span>[expr<wbr>.place-value<wbr>.assignee]<span/></a></div>
<p>_피할당자 표현식(assignee expression)_은 <a href="expressions/operator-expr.html#assignment-expressions">할당(assignment)</a> 표현식의 왼쪽 피연산자로 나타나는 표현식입니다. 명시적으로, 피할당자 표현식은 다음과 같습니다:</p>
<ul>
<li>장소 표현식.</li>
<li><a href="expressions/underscore-expr.html">밑줄(Underscores)</a>.</li>
<li>피할당자 표현식의 <a href="expressions/tuple-expr.html">튜플</a>.</li>
<li>피할당자 표현식의 <a href="expressions/array-expr.html">슬라이스</a>.</li>
<li>피할당자 표현식의 <a href="expressions/struct-expr.html">튜플 구조체</a>.</li>
<li>피할당자 표현식의 <a href="expressions/struct-expr.html">구조체</a> (선택적으로 이름이 붙은 필드 포함).</li>
<li><a href="expressions/struct-expr.html">유닛 구조체</a>.</li>
</ul>
<div class="rule" id="r-expr.place-value.parenthesis"><a class="rule-link" href="#r-expr.place-value.parenthesis" title="expr.place-value.parenthesis"><span>[expr<wbr>.place-value<wbr>.parenthesis]<span/></a></div>
<p>피할당자 표현식 내에서는 임의의 괄호 사용이 허용됩니다.</p>
<div class="rule" id="r-expr.move"><a class="rule-link" href="#r-expr.move" title="expr.move"><span>[expr<wbr>.move]<span/></a></div>
<h3 id="이동-및-복사-타입"><a class="header" href="#이동-및-복사-타입">이동 및 복사 타입</a></h3>
<div class="rule" id="r-expr.move.intro"><a class="rule-link" href="#r-expr.move.intro" title="expr.move.intro"><span>[expr<wbr>.move<wbr>.intro]<span/></a></div>
<p>장소 표현식이 값 표현식 컨텍스트에서 평가되거나 패턴에서 값으로 바인딩될 때, 이는 해당 메모리 위치_에_ 저장된 값을 나타냅니다.</p>
<div class="rule" id="r-expr.move.copy"><a class="rule-link" href="#r-expr.move.copy" title="expr.move.copy"><span>[expr<wbr>.move<wbr>.copy]<span/></a></div>
<p>해당 값의 타입이 <a href="special-types-and-traits.html#copy"><code>Copy</code></a>를 구현한다면, 값이 복사됩니다.</p>
<div class="rule" id="r-expr.move.requires-sized"><a class="rule-link" href="#r-expr.move.requires-sized" title="expr.move.requires-sized"><span>[expr<wbr>.move<wbr>.requires-sized]<span/></a></div>
<p>그 외의 상황에서 해당 타입이 <a href="special-types-and-traits.html#sized"><code>Sized</code></a>라면, 값을 이동(move)시키는 것이 가능할 수 있습니다.</p>
<div class="rule" id="r-expr.move.movable-place"><a class="rule-link" href="#r-expr.move.movable-place" title="expr.move.movable-place"><span>[expr<wbr>.move<wbr>.movable-place]<span/></a></div>
<p>오직 다음 장소 표현식들로부터만 값을 이동시킬 수 있습니다:</p>
<ul>
<li>현재 차용(borrow)되지 않은 <a href="variables.html">변수</a>.</li>
<li><a href="#temporaries">임시 값</a>.</li>
<li>값을 이동시킬 수 있는 장소 표현식의 <a href="expressions/field-expr.html">필드</a>들 중 <a href="special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않은 것.</li>
<li><a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 타입을 가진 표현식을 <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a>한 결과로서, 마찬가지로 값을 이동시킬 수 있는 경우.</li>
</ul>
<div class="rule" id="r-expr.move.deinitialization"><a class="rule-link" href="#r-expr.move.deinitialization" title="expr.move.deinitialization"><span>[expr<wbr>.move<wbr>.deinitialization]<span/></a></div>
<p>지역 변수로 평가되는 장소 표현식에서 값을 이동시킨 후에는 해당 위치가 초기화 해제(deinitialized)되며, 다시 초기화될 때까지 다시 읽을 수 없습니다.</p>
<div class="rule" id="r-expr.move.place-invalid"><a class="rule-link" href="#r-expr.move.place-invalid" title="expr.move.place-invalid"><span>[expr<wbr>.move<wbr>.place-invalid]<span/></a></div>
<p>그 외의 모든 경우, 값 표현식 컨텍스트에서 장소 표현식을 사용하려고 시도하는 것은 에러입니다.</p>
<div class="rule" id="r-expr.mut"><a class="rule-link" href="#r-expr.mut" title="expr.mut"><span>[expr<wbr>.mut]<span/></a></div>
<h3 id="가변성mutability"><a class="header" href="#가변성mutability">가변성(Mutability)</a></h3>
<div class="rule" id="r-expr.mut.intro"><a class="rule-link" href="#r-expr.mut.intro" title="expr.mut.intro"><span>[expr<wbr>.mut<wbr>.intro]<span/></a></div>
<p>장소 표현식에 <a href="expressions/operator-expr.html#assignment-expressions">할당(assigned)</a>하거나, 가변적으로 <a href="expressions/operator-expr.html#borrow-operators">차용(borrowed)</a>하거나, <a href="#implicit-borrows">암시적으로 가변 차용</a>하거나, <code>ref mut</code>를 포함하는 패턴에 바인딩하려면 해당 표현식은 반드시 _가변(mutable)_이어야 합니다. 이를 _가변 장소 표현식(mutable place expressions)_이라고 부릅니다. 반면에 다른 장소 표현식들은 _불변 장소 표현식(immutable place expressions)_이라고 부릅니다.</p>
<div class="rule" id="r-expr.mut.valid-places"><a class="rule-link" href="#r-expr.mut.valid-places" title="expr.mut.valid-places"><span>[expr<wbr>.mut<wbr>.valid-places]<span/></a></div>
<p>다음 표현식들은 가변 장소 표현식 컨텍스트가 될 수 있습니다:</p>
<ul>
<li>현재 차용되지 않은 가변 <a href="variables.html">변수(variables)</a>.</li>
<li><a href="items/static-items.html#mutable-statics">가변 <code>static</code> 아이템</a>.</li>
<li><a href="#temporaries">임시 값</a>.</li>
<li><a href="expressions/field-expr.html">필드(Fields)</a>: 이는 하위 표현식을 가변 장소 표현식 컨텍스트에서 평가합니다.</li>
<li><code>*mut T</code> 포인터의 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(Dereferences)</a>.</li>
<li><code>&amp;mut T</code> 타입을 가진 변수 또는 변수 필드의 역참조. 참고: 이는 다음 규칙의 요구 사항에 대한 예외입니다.</li>
<li><code>DerefMut</code>를 구현하는 타입의 역참조: 이는 역참조되는 값이 가변 장소 표현식 컨텍스트에서 평가될 것을 요구합니다.</li>
<li><code>IndexMut</code>를 구현하는 타입의 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(Array indexing)</a>: 이는 인덱싱되는 값을 가변 장소 표현식 컨텍스트에서 평가하지만, 인덱스는 그렇지 않습니다.</li>
</ul>
<div class="rule" id="r-expr.temporary"><a class="rule-link" href="#r-expr.temporary" title="expr.temporary"><span>[expr<wbr>.temporary]<span/></a></div>
<h3 id="임시-값temporaries"><a class="header" href="#임시-값temporaries">임시 값(Temporaries)</a></h3>
<p>대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용할 때, 이름 없는 임시 메모리 위치가 생성되고 해당 값으로 초기화됩니다. 표현식은 <code>static</code>으로 <a href="destructors.html#constant-promotion">승격(promoted)</a>되지 않는 한 해당 위치로 평가됩니다. 임시 값의 <a href="destructors.html#drop-scopes">드롭 스코프(drop scope)</a>는 보통 이를 둘러싼 구문의 끝입니다.</p>
<div class="rule" id="r-expr.implicit-borrow"><a class="rule-link" href="#r-expr.implicit-borrow" title="expr.implicit-borrow"><span>[expr<wbr>.implicit-borrow]<span/></a></div>
<h3 id="암시적-차용implicit-borrows"><a class="header" href="#암시적-차용implicit-borrows">암시적 차용(Implicit Borrows)</a></h3>
<div class="rule" id="r-expr.implicit-borrow-intro"><a class="rule-link" href="#r-expr.implicit-borrow-intro" title="expr.implicit-borrow-intro"><span>[expr<wbr>.implicit-borrow-intro]<span/></a></div>
<p>특정 표현식들은 표현식을 암시적으로 차용함으로써 장소 표현식으로 취급합니다. 예를 들어, <code>==</code> 연산자는 피연산자를 암시적으로 차용하기 때문에 두 개의 크기 미지정 <a href="types/slice.html">슬라이스(slices)</a>의 동등성을 직접 비교하는 것이 가능합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// 동등한 형태:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.implicit-borrow.application"><a class="rule-link" href="#r-expr.implicit-borrow.application" title="expr.implicit-borrow.application"><span>[expr<wbr>.implicit-borrow<wbr>.application]<span/></a></div>
<p>암시적 차용은 다음 표현식들에서 발생할 수 있습니다:</p>
<ul>
<li><a href="expressions/method-call-expr.html">메서드 호출(method-call)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/field-expr.html">필드(field)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/call-expr.html">호출 표현식(call expressions)</a>의 왼쪽 피연산자.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(array indexing)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a> (<code>*</code>)의 피연산자.</li>
<li><a href="expressions/operator-expr.html#comparison-operators">비교(comparison)</a>의 피연산자들.</li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a>의 왼쪽 피연산자들.</li>
</ul>
<div class="rule" id="r-expr.overload"><a class="rule-link" href="#r-expr.overload" title="expr.overload"><span>[expr<wbr>.overload]<span/></a></div>
<h2 id="오버로딩-트레잇"><a class="header" href="#오버로딩-트레잇">오버로딩 트레잇</a></h2>
<p>다음 중 많은 연산자와 표현식들은 <code>std::ops</code>나 <code>std::cmp</code>에 있는 트레잇들을 사용하여 다른 타입에 대해 오버로드될 수 있습니다. 이러한 트레잇들은 <code>core::ops</code> 및 <code>core::cmp</code>에도 동일한 이름으로 존재합니다.</p>
<div class="rule" id="r-expr.attr"><a class="rule-link" href="#r-expr.attr" title="expr.attr"><span>[expr<wbr>.attr]<span/></a></div>
<h2 id="표현식-속성"><a class="header" href="#표현식-속성">표현식 속성</a></h2>
<div class="rule" id="r-expr.attr.restriction"><a class="rule-link" href="#r-expr.attr.restriction" title="expr.attr.restriction"><span>[expr<wbr>.attr<wbr>.restriction]<span/></a></div>
<p>표현식 앞의 <a href="attributes.html">외부 속성(Outer attributes)</a>은 오직 다음 몇 가지 구체적인 경우에만 허용됩니다:</p>
<ul>
<li><a href="statements.html">구문(statement)</a>으로 사용된 표현식 앞에 올 때.</li>
<li><a href="expressions/array-expr.html">배열 표현식(array expressions)</a>, <a href="expressions/tuple-expr.html">튜플 표현식(tuple expressions)</a>, <a href="expressions/call-expr.html">호출 표현식(call expressions)</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체(struct)</a> 표현식의 요소들에 올 때.</li>
<li><a href="expressions/block-expr.html">블록 표현식(block expressions)</a>의 마지막 표현식(tail expression)에 올 때.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<div class="rule" id="r-expr.attr.never-before"><a class="rule-link" href="#r-expr.attr.never-before" title="expr.attr.never-before"><span>[expr<wbr>.attr<wbr>.never-before]<span/></a></div>
<p>다음의 경우에는 절대 허용되지 않습니다:</p>
<ul>
<li><a href="expressions/range-expr.html">범위(Range)</a> 표현식 앞.</li>
<li>이항 연산자 표현식 (<a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>산술또는논리표현식</em></a>, <a href="expressions/operator-expr.html#comparison-operators"><em>비교표현식</em></a>, <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>지연불리언표현식</em></a>, <a href="expressions/operator-expr.html#type-cast-expressions"><em>타입캐스트표현식</em></a>, <a href="expressions/operator-expr.html#assignment-expressions"><em>할당표현식</em></a>, <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>복합할당표현식</em></a>) 앞.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="statements.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="expressions/literal-expr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="statements.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="expressions/literal-expr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
