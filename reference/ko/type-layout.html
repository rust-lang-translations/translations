<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>타입 레이아웃 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/type-layout.md`;
                    } else {
                        canonical_href = `${base}/${lang}/type-layout.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/type-layout.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[layout]</p>
<h1 id="타입-레이아웃"><a class="header" href="#타입-레이아웃">타입 레이아웃</a></h1>
<p>r[layout.intro] The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</p>
<p>r[layout.guarantees] Type layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.</p>
<p>동일한 레이아웃을 가진 타입이라도 함수 경계를 넘어 전달되는 방식은 다를 수 있다는 점에 유의하십시오. 타입의 함수 호출 ABI 호환성에 대해서는 <a href="../core/primitive.fn.html#abi-compatibility">여기</a>를 참조하십시오.</p>
<p>r[layout.properties]</p>
<h2 id="size-and-alignment"><a class="header" href="#size-and-alignment">Size and alignment</a></h2>
<p>모든 값은 정렬과 크기를 가집니다.</p>
<p>r[layout.properties.align] The <em>alignment</em> of a value specifies what addresses are valid to store the value at. A value of alignment <code>n</code> must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the <a href="std::mem::align_of_val"><code>align_of_val</code></a> function.</p>
<p>r[layout.properties.size] The <em>size</em> of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. Note that some types are zero-sized; 0 is considered a multiple of any alignment (for example, on some platforms, the type <code>[u16; 0]</code> has size 0 and alignment 2). The size of a value can be checked with the <a href="std::mem::size_of_val"><code>size_of_val</code></a> function.</p>
<p>r[layout.properties.sized] Types where all values have the same size and alignment, and both are known at compile time, implement the <a href="std::marker::Sized"><code>Sized</code></a> trait and can be checked with the <a href="std::mem::size_of"><code>size_of</code></a> and <a href="std::mem::align_of"><code>align_of</code></a> functions. Types that are not <a href="std::marker::Sized"><code>Sized</code></a> are known as <a href="dynamically-sized-types.html">dynamically sized types</a>. Since all values of a <code>Sized</code> type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</p>
<p>r[layout.primitive]</p>
<h2 id="primitive-data-layout"><a class="header" href="#primitive-data-layout">Primitive data layout</a></h2>
<p>r[layout.primitive.size] The size of most primitives is given in this table.</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>usize</code> / <code>isize</code></td><td>아래 참조</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
</div>
<p>r[layout.primitive.size-int] <code>usize</code> and <code>isize</code> have a size big enough to contain every address on the target platform. For example, on a 32 bit target, this is 4 bytes, and on a 64 bit target, this is 8 bytes.</p>
<p>r[layout.primitive.align] The alignment of primitives is platform-specific. In most cases, their alignment is equal to their size, but it may be less. In particular, <code>i128</code> and <code>u128</code> are often aligned to 4 or 8 bytes even though their size is 16, and on many 32-bit platforms, <code>i64</code>, <code>u64</code>, and <code>f64</code> are only aligned to 4 bytes, not 8.</p>
<p>r[layout.pointer]</p>
<h2 id="pointers-and-references-layout"><a class="header" href="#pointers-and-references-layout">Pointers and references layout</a></h2>
<p>r[layout.pointer.intro] Pointers and references have the same layout. Mutability of the pointer or reference does not change the layout.</p>
<p>r[layout.pointer.thin] Pointers to sized types have the same size and alignment as <code>usize</code>.</p>
<p>r[layout.pointer.unsized] Pointers to unsized types are sized. The size and alignment is guaranteed to be at least equal to the size and alignment of a pointer.</p>
<blockquote>
<p>[!NOTE] Though you should not rely on this, all pointers to <abbr title="Dynamically Sized Types">DSTs</abbr> are currently twice the size of the size of <code>usize</code> and have the same alignment.</p>
</blockquote>
<p>r[layout.array]</p>
<h2 id="array-layout"><a class="header" href="#array-layout">Array layout</a></h2>
<p><code>[T; N]</code> 배열은 <code>size_of::&lt;T&gt;() * N</code>의 크기를 가지며 <code>T</code>와 동일한 정렬을 가집니다. 배열은 0부터 시작하는 <code>nth</code> 요소가 배열 시작점으로부터 <code>n * size_of::&lt;T&gt;()</code> 바이트만큼 오프셋되도록 배치됩니다.</p>
<p>r[layout.slice]</p>
<h2 id="slice-layout"><a class="header" href="#slice-layout">Slice layout</a></h2>
<p>슬라이스는 자신이 슬라이싱하는 배열 섹션과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>[!NOTE] This is about the raw <code>[T]</code> type, not pointers (<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code>, etc.) to slices.</p>
</blockquote>
<p>r[layout.str]</p>
<h2 id="str-레이아웃"><a class="header" href="#str-레이아웃"><code>str</code> 레이아웃</a></h2>
<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code>[u8]</code>. A reference <code>&amp;str</code> has the same layout as a reference <code>&amp;[u8]</code>.</p>
<p>r[layout.tuple]</p>
<h2 id="tuple-layout"><a class="header" href="#tuple-layout">Tuple layout</a></h2>
<p>r[layout.tuple.general] Tuples are laid out according to the <a href="#the-rust-representation"><code>Rust</code> representation</a>.</p>
<p>r[layout.tuple.unit] The exception to this is the unit tuple (<code>()</code>), which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</p>
<p>r[layout.trait-object]</p>
<h2 id="trait-object-layout"><a class="header" href="#trait-object-layout">Trait object layout</a></h2>
<p>트레잇 객체는 해당 트레잇 객체가 나타내는 값과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>[!NOTE] This is about the raw trait object types, not pointers (<code>&amp;dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code>, etc.) to trait objects.</p>
</blockquote>
<p>r[layout.closure]</p>
<h2 id="closure-layout"><a class="header" href="#closure-layout">Closure layout</a></h2>
<p>클로저는 레이아웃 보장이 없습니다.</p>
<p>r[layout.repr]</p>
<h2 id="표현-representations"><a class="header" href="#표현-representations">표현 (Representations)</a></h2>
<p>r[layout.repr.intro] All user-defined composite types (<code>struct</code>s, <code>enum</code>s, and <code>union</code>s) have a <em>representation</em> that specifies what the layout is for the type.</p>
<p>r[layout.repr.kinds] The possible representations for a type are:</p>
<ul>
<li><a href="#the-rust-representation"><code>Rust</code></a> (기본값)</li>
<li><a href="#the-c-representation"><code>C</code></a></li>
<li><a href="#primitive-representations">기본 표현(primitive representations)</a></li>
<li><a href="#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>r[layout.repr.attribute] The representation of a type can be changed by applying the <code>repr</code> attribute to it. The following example shows a struct with a <code>C</code> representation.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.align-packed] The alignment may be raised or lowered with the <code>align</code> and <code>packed</code> modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 기본 표현, 정렬이 2로 낮아짐.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 표현, 정렬이 8로 높아짐
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, <code>Foo&lt;Bar&gt;</code> and <code>Foo&lt;Baz&gt;</code> both have the same representation.</p>
</blockquote>
<p>r[layout.repr.inter-field] The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a <code>C</code> representation that contains a struct <code>Inner</code> with the <code>Rust</code> representation will not change the layout of <code>Inner</code>.</p>
<p><a id="the-default-representation"></a> r[layout.repr.rust]</p>
<h3 id="the-rust-representation"><a class="header" href="#the-rust-representation">The <code>Rust</code> representation</a></h3>
<p>r[layout.repr.rust.intro] The <code>Rust</code> representation is the default representation for nominal types without a <code>repr</code> attribute. Using this representation explicitly through a <code>repr</code> attribute is guaranteed to be the same as omitting the attribute entirely.</p>
<p>r[layout.repr.rust.layout] The only data layout guarantees made by this representation are those required for soundness. They are:</p>
<ol>
<li>필드들이 올바르게 정렬됩니다.</li>
<li>필드들이 겹치지 않습니다.</li>
<li>타입의 정렬은 최소한 그 필드들의 최대 정렬 이상입니다.</li>
</ol>
<p>r[layout.repr.rust.alignment] Formally, the first guarantee means that the offset of any field is divisible by that field’s alignment.</p>
<p>r[layout.repr.rust.field-storage] The second guarantee means that the fields can be ordered such that the offset plus the size of any field is less than or equal to the offset of the next field in the ordering. The ordering does not have to be the same as the order in which the fields are specified in the declaration of the type.</p>
<p>두 번째 보장이 필드들이 서로 다른 주소를 갖는다는 것을 의미하지는 않음에 유의하십시오. 크기가 0인 타입은 동일한 구조체 내의 다른 필드와 같은 주소를 가질 수 있습니다.</p>
<p>r[layout.repr.rust.unspecified] There are no other guarantees of data layout made by this representation.</p>
<p>r[layout.repr.c]</p>
<h3 id="the-c-representation"><a class="header" href="#the-c-representation">The <code>C</code> representation</a></h3>
<p>r[layout.repr.c.intro] The <code>C</code> representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</p>
<p>이러한 이중 목적 때문에, C 프로그래밍 언어와의 인터페이스에는 유용하지 않은 타입을 생성하는 것도 가능합니다.</p>
<p>r[layout.repr.c.constraint] This representation can be applied to structs, unions, and enums. The exception is <a href="items/enumerations.html#zero-variant-enums">zero-variant enums</a> for which the <code>C</code> representation is an error.</p>
<p>r[layout.repr.c.struct]</p>
<h4 id="reprc-구조체"><a class="header" href="#reprc-구조체"><code>#[repr(C)]</code> 구조체</a></h4>
<p>r[layout.repr.c.struct.align] The alignment of the struct is the alignment of the most-aligned field in it.</p>
<p>r[layout.repr.c.struct.size-field-offset] The size and offset of fields is determined by the following algorithm.</p>
<p>현재 오프셋 0바이트로 시작합니다.</p>
<p>구조체의 선언 순서대로 각 필드에 대해, 먼저 필드의 크기와 정렬을 결정합니다. 현재 오프셋이 필드의 정렬의 배수가 아니라면, 필드 정렬의 배수가 될 때까지 현재 오프셋에 패딩 바이트를 추가합니다. 해당 필드의 오프셋은 현재 오프셋 값이 됩니다. 그런 다음 현재 오프셋을 필드의 크기만큼 증가시킵니다.</p>
<p>마지막으로, 구조체의 크기는 현재 오프셋을 구조체의 정렬의 가장 가까운 배수로 올림한 값입니다.</p>
<p>다음은 의사코드로 설명된 이 알고리즘입니다.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 다음 주소가 `alignment`에 맞춰 정렬되도록 하기 위해
/// `offset` 뒤에 필요한 패딩의 양을 반환합니다.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // `alignment`의 다음 배수로 올림
        alignment - misalignment
    } else {
        // 이미 `alignment`의 배수임
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 현재 오프셋을 증가시켜 이 필드의 정렬의 배수가 되도록 합니다.
    // 첫 번째 필드의 경우, 이는 항상 0이 됩니다.
    // 건너뛴 바이트를 패딩 바이트라고 합니다.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<blockquote>
<p>[!WARNING] This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use <a href="std::alloc::Layout"><code>Layout</code></a>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] This algorithm can produce zero-sized structs. In C, an empty struct declaration like <code>struct Foo { }</code> is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the <code>[[no_unique_address]]</code> attribute, in which case they do not increase the overall size of the struct.</p>
</blockquote>
<p>r[layout.repr.c.union]</p>
<h4 id="reprc-공용체"><a class="header" href="#reprc-공용체"><code>#[repr(C)]</code> 공용체</a></h4>
<p>r[layout.repr.c.union.intro] A union declared with <code>#[repr(C)]</code> will have the same size and alignment as an equivalent C union declaration in the C language for the target platform.</p>
<p>r[layout.repr.c.union.size-align] The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // f2에서 옴
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // f1에서 옴

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // b에서 크기 6,
                                                      // a의 정렬에 따라
                                                      // 8로 올림.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // a에서 옴
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.c.enum]</p>
<h4 id="reprc-필드-없는-열거형"><a class="header" href="#reprc-필드-없는-열거형"><code>#[repr(C)]</code> 필드 없는 열거형</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, <code>C</code> 표현은 대상 플랫폼의 C ABI에 대한 기본 <code>enum</code> 크기 및 정렬과 동일한 크기 및 정렬을 가집니다.</p>
<blockquote>
<p>[!NOTE] The enum representation in C is implementation defined, so this is really a “best guess”. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</p>
</blockquote>
<blockquote>
<p>[!WARNING] There are crucial differences between an <code>enum</code> in the C language and Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> with this representation. An <code>enum</code> in C is mostly a <code>typedef</code> plus some named constants; in other words, an object of an <code>enum</code> type can hold any integer value. For example, this is often used for bitflags in <code>C</code>. In contrast, Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> can only legally hold the discriminant values, everything else is <a href="behavior-considered-undefined.html">undefined behavior</a>. Therefore, using a field-less enum in FFI to model a C <code>enum</code> is often wrong.</p>
</blockquote>
<p>r[layout.repr.c.adt]</p>
<h4 id="reprc-필드-있는-열거형"><a class="header" href="#reprc-필드-있는-열거형"><code>#[repr(C)]</code> 필드 있는 열거형</a></h4>
<p>r[layout.repr.c.adt.intro] The representation of a <code>repr(C)</code> enum with fields is a <code>repr(C)</code> struct with two fields, also called a “tagged union” in C:</p>
<p>r[layout.repr.c.adt.tag]</p>
<ul>
<li>모든 필드가 제거된 열거형의 <code>repr(C)</code> 버전 (“태그”)</li>
</ul>
<p>r[layout.repr.c.adt.fields]</p>
<ul>
<li>필드를 가진 각 변형의 필드들을 위한 <code>repr(C)</code> 구조체들의 <code>repr(C)</code> 공용체 (“페이로드”)</li>
</ul>
<blockquote>
<p>[!NOTE] Due to the representation of <code>repr(C)</code> structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an <code>enum</code>’s representation may therefore use whichever form is more convenient or consistent for them.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 Enum은 다음 구조체와 동일한 표현을 가집니다 ...
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 구조체와.
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant,
    payload: MyEnumFields,
}

// 이것은 판별자 열거형입니다.
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 이것은 변형 공용체입니다.
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 이 구조체는 생략될 수 있으며(0크기 타입임), C/C++ 헤더에 있어야 합니다.
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.primitive]</p>
<h3 id="기본-표현-primitive-representations"><a class="header" href="#기본-표현-primitive-representations">기본 표현 (Primitive representations)</a></h3>
<p>r[layout.repr.primitive.intro] The <em>primitive representations</em> are the representations with the same names as the primitive integer types. That is: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
<p>r[layout.repr.primitive.constraint] Primitive representations can only be applied to enumerations and have different behavior whether the enum has fields or no fields. It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enums</a> to have a primitive representation. Combining two primitive representations together is an error.</p>
<p>r[layout.repr.primitive.enum]</p>
<h4 id="primitive-representation-of-field-less-enums"><a class="header" href="#primitive-representation-of-field-less-enums">Primitive representation of field-less enums</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, 기본 표현은 크기와 정렬을 동일한 이름의 기본 타입과 같게 설정합니다. 예를 들어, <code>u8</code> 표현을 가진 필드 없는 열거형은 0에서 255(포함) 사이의 판별자만 가질 수 있습니다.</p>
<p>r[layout.repr.primitive.adt]</p>
<h4 id="primitive-representation-of-enums-with-fields"><a class="header" href="#primitive-representation-of-enums-with-fields">Primitive representation of enums with fields</a></h4>
<p>기본 표현 열거형의 표현은 <code>repr(C)</code> 공용체입니다</p>
<blockquote>
<p>[!NOTE] This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a <code>struct</code>).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 열거형은 다음 공용체와 동일한 표현을 가집니다 ...
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 공용체와.
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 이것은 판별자 열거형입니다.
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.primitive-c]</p>
<h4 id="필드가-있는-열거형의-기본-표현과-reprc-결합하기"><a class="header" href="#필드가-있는-열거형의-기본-표현과-reprc-결합하기">필드가 있는 열거형의 기본 표현과 <code>#[repr(C)]</code> 결합하기</a></h4>
<p>필드가 있는 열거형의 경우, <code>repr(C)</code>와 기본 표현을 결합하는 것도 가능합니다(예: <code>repr(C, u8)</code>). 이는 판별자 열거형의 표현을 선택된 기본 타입으로 변경함으로써 <a href="#reprc-enums-with-fields"><code>repr(C)</code></a>를 수정합니다. 따라서 <code>u8</code> 표현을 선택했다면, 판별자 열거형은 1바이트의 크기와 정렬을 갖게 됩니다.</p>
<p><a href="#reprc-enums-with-fields">앞서</a> 나온 예시의 판별자 열거형은 다음과 같이 됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // `u8`이 추가됨
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 따라서 여기서 `C` 대신 `u8`이 사용됨
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre></pre>
<p>예를 들어, <code>repr(C, u8)</code> 열거형은 257개의 고유한 판별자(“태그”)를 가질 수 없는 반면, <code>repr(C)</code> 속성만 있는 동일한 열거형은 문제없이 컴파일됩니다.</p>
<p><code>repr(C)</code>에 더해 기본 표현을 사용하면 <code>repr(C)</code> 형태로부터 열거형의 크기가 변경될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// The size of the C representation is platform dependent
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// 판별자를 위한 1바이트와 Enum8::Variant0의 값을 위한 1바이트
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// 판별자를 위한 2바이트와 Enum16::Variant0의 값을 위한 1바이트
// 더하기 1바이트의 패딩.
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.alignment]</p>
<h3 id="정렬-수정자"><a class="header" href="#정렬-수정자">정렬 수정자</a></h3>
<p>r[layout.repr.alignment.intro] The <code>align</code> and <code>packed</code> modifiers can be used to respectively raise or lower the alignment of <code>struct</code>s and <code>union</code>s. <code>packed</code> may also alter the padding between fields (although it will not alter the padding inside of any field). On their own, <code>align</code> and <code>packed</code> do not provide guarantees about the order of fields in the layout of a struct or the layout of an enum variant, although they may be combined with representations (such as <code>C</code>) which do provide such guarantees.</p>
<p>r[layout.repr.alignment.constraint-alignment] The alignment is specified as an integer parameter in the form of <code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given, as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<p>r[layout.repr.alignment.align] For <code>align</code>, if the specified alignment is less than the alignment of the type without the <code>align</code> modifier, then the alignment is unaffected.</p>
<p>r[layout.repr.alignment.packed] For <code>packed</code>, if the specified alignment is greater than the type’s alignment without the <code>packed</code> modifier, then the alignment and layout is unaffected.</p>
<p>r[layout.repr.alignment.packed-fields] The alignments of each field, for the purpose of positioning fields, is the smaller of the specified alignment and the alignment of the field’s type.</p>
<p>r[layout.repr.alignment.packed-padding] Inter-field padding is guaranteed to be the minimum required in order to satisfy each field’s (possibly altered) alignment (although note that, on its own, <code>packed</code> does not provide any guarantee about field ordering). An important consequence of these rules is that a type with <code>#[repr(packed(1))]</code> (or <code>#[repr(packed)]</code>) will have no inter-field padding.</p>
<p>r[layout.repr.alignment.constraint-exclusive] The <code>align</code> and <code>packed</code> modifiers cannot be applied on the same type and a <code>packed</code> type cannot transitively contain another <code>align</code>ed type. <code>align</code> and <code>packed</code> may only be applied to the <a href="#the-rust-representation"><code>Rust</code></a> and <a href="#the-c-representation"><code>C</code></a> representations.</p>
<p>r[layout.repr.alignment.enum] The <code>align</code> modifier can also be applied on an <code>enum</code>. When it is, the effect on the <code>enum</code>’s alignment is the same as if the <code>enum</code> was wrapped in a newtype <code>struct</code> with the same <code>align</code> modifier.</p>
<blockquote>
<p>[!NOTE] References to unaligned fields are not allowed because it is <a href="behavior-considered-undefined.html">undefined behavior</a>. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}
let mut e = Packed { f1: 1, f2: 2 };
// 필드에 대한 참조를 생성하는 대신, 값을 로컬 변수로 복사하십시오.
let x = e.f2;
// 또는 참조를 생성하는 `println!`과 같은 상황에서는 중괄호를 사용하여
// 값의 복사본으로 변경하십시오.
println!("{}", {e.f2});
// 포인터가 필요한 경우, 포인터를 직접 역참조하는 대신
// 읽기 및 쓰기에 정렬되지 않은 메서드를 사용하십시오.
let ptr: *const u16 = &amp;raw const e.f2;
let value = unsafe { ptr.read_unaligned() };
let mut_ptr: *mut u16 = &amp;raw mut e.f2;
unsafe { mut_ptr.write_unaligned(3) }
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[layout.repr.transparent]</p>
<h3 id="the-transparent-representation"><a class="header" href="#the-transparent-representation">The <code>transparent</code> representation</a></h3>
<p>r[layout.repr.transparent.constraint-field] The <code>transparent</code> representation can only be used on a <a href="items/structs.html"><code>struct</code></a> or an <a href="items/enumerations.html"><code>enum</code></a> with a single variant that has:</p>
<ul>
<li>크기가 0이고 정렬이 1인 임의 개수의 필드 (예: <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>), 그리고</li>
<li>최대 하나의 다른 필드.</li>
</ul>
<p>r[layout.repr.transparent.layout-abi] Structs and enums with this representation have the same layout and ABI as the only non-size 0 non-alignment 1 field, if present, or unit otherwise.</p>
<p>이는 <code>C</code> 표현과는 다릅니다. <code>C</code> 표현을 가진 구조체는 항상 <code>C</code> <code>struct</code>의 ABI를 갖는 반면, 예를 들어 기본(primitive) 필드를 가진 <code>transparent</code> 표현의 구조체는 해당 기본 필드의 ABI를 갖기 때문입니다.</p>
<p>r[layout.repr.transparent.constraint-exclusive] Because this representation delegates type layout to another type, it cannot be used with any other representation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dynamically-sized-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dynamically-sized-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
