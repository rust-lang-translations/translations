<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>연산자 표현식 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/expressions/operator-expr.md`;
                    } else {
                        canonical_href = `${base}/${lang}/expressions/operator-expr.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/expressions/operator-expr.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[expr.operator]</p>
<h1 id="연산자-표현식"><a class="header" href="#연산자-표현식">연산자 표현식</a></h1>
<p>r[expr.operator.syntax]</p>
<pre><code class="language-grammar expressions">OperatorExpression -&gt;
      BorrowExpression
    | DereferenceExpression
    | TryPropagationExpression
    | NegationExpression
    | ArithmeticOrLogicalExpression
    | ComparisonExpression
    | LazyBooleanExpression
    | TypeCastExpression
    | AssignmentExpression
    | CompoundAssignmentExpression
</code></pre>
<p>r[expr.operator.intro] Operators are defined for built in types by the Rust language.</p>
<p>r[expr.operator.trait] Many of the following operators can also be overloaded using traits in <code>std::ops</code> or <code>std::cmp</code>.</p>
<p>r[expr.operator.int-overflow]</p>
<h2 id="오버플로"><a class="header" href="#오버플로">오버플로</a></h2>
<p>r[expr.operator.int-overflow.intro] Integer operators will panic when they overflow when compiled in debug mode. The <code>-C debug-assertions</code> and <code>-C overflow-checks</code> compiler flags can be used to control this more directly. The following things are considered to be overflow:</p>
<p>r[expr.operator.int-overflow.binary-arith]</p>
<ul>
<li><code>+</code>, <code>*</code> 또는 이항 <code>-</code>가 저장할 수 있는 최대값보다 크거나 최소값보다 작은 값을 생성할 때.</li>
</ul>
<p>r[expr.operator.int-overflow.unary-neg]</p>
<ul>
<li>피연산자가 <a href="literal-expr.html#integer-literal-expressions">리터럴 표현식</a> (또는 하나 이상의 <a href="grouped-expr.html">그룹화된 표현식</a> 내에 단독으로 있는 리터럴 표현식)이 아닌 경우, 부호 있는 정수 타입의 가장 작은 음수 값에 단항 <code>-</code>를 적용할 때.</li>
</ul>
<p>r[expr.operator.int-overflow.div]</p>
<ul>
<li>왼쪽 인수가 부호 있는 정수 타입의 가장 작은 정수이고 오른쪽 인수가 <code>-1</code>인 경우 <code>/</code> 또는 <code>%</code> 사용. 이러한 검사는 레거시 이유로 <code>-C overflow-checks</code>가 비활성화된 경우에도 발생합니다.</li>
</ul>
<p>r[expr.operator.int-overflow.shift]</p>
<ul>
<li>오른쪽 인수가 왼쪽 인수 타입의 비트 수보다 크거나 같거나 음수인 경우 <code>&lt;&lt;</code> 또는 <code>&gt;&gt;</code> 사용.</li>
</ul>
<blockquote>
<p>[!NOTE] The exception for literal expressions behind unary <code>-</code> means that forms such as <code>-128_i8</code> or <code>let j: i8 = -(128)</code> never cause a panic and have the expected value of -128.</p>
<p>이러한 경우, <a href="literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>의 설명에 따라 정수 리터럴이 해당 타입으로 잘리기 때문에 리터럴 표현식은 이미 해당 타입에 대해 가장 작은 음수 값을 가집니다(예: <code>128_i8</code>은 값 -128을 가짐).</p>
<p>이러한 가장 작은 음수 값의 부정은 2의 보수 오버플로 규칙으로 인해 값이 변경되지 않고 그대로 유지됩니다.</p>
<p><code>rustc</code>에서 이러한 가장 작은 음수 표현식은 <code>overflowing_literals</code> 린트 검사에서도 무시됩니다.</p>
</blockquote>
<p>r[expr.operator.borrow]</p>
<h2 id="차용-연산자"><a class="header" href="#차용-연산자">차용 연산자</a></h2>
<p>r[expr.operator.borrow.syntax]</p>
<pre><code class="language-grammar expressions">BorrowExpression -&gt;
      (`&amp;`|`&amp;&amp;`) Expression
    | (`&amp;`|`&amp;&amp;`) `mut` Expression
    | (`&amp;`|`&amp;&amp;`) `raw` `const` Expression
    | (`&amp;`|`&amp;&amp;`) `raw` `mut` Expression
</code></pre>
<p>r[expr.operator.borrow.intro] The <code>&amp;</code> (shared borrow) and <code>&amp;mut</code> (mutable borrow) operators are unary prefix operators.</p>
<p>r[expr.operator.borrow.result] When applied to a <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a>, this expressions produces a reference (pointer) to the location that the value refers to.</p>
<p>r[expr.operator.borrow.lifetime] The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (<code>&amp;</code>), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the place may not be accessed in any way until the borrow expires.</p>
<p>r[expr.operator.borrow.mut] <code>&amp;mut</code> evaluates its operand in a mutable place expression context.</p>
<p>r[expr.operator.borrow.temporary] If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to a <a href="../expressions.html#place-expressions-and-value-expressions">value expression</a>, then a <a href="../expressions.html#temporaries">temporary value</a> is created.</p>
<p>이 연산자들은 오버로딩할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 이 스코프 동안 지속되는 값 7을 가진 임시 값이 생성됩니다.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // 이 스코프 동안 `array`를 가변적으로 차용합니다.
    // `array`는 `mutable_reference`를 통해서만 사용할 수 있습니다.
    let mutable_reference = &amp;mut array;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.borrow.and-and-syntax] Even though <code>&amp;&amp;</code> is a single token (<a href="#lazy-boolean-operators">the lazy ‘and’ operator</a>), when used in the context of borrow expressions it works as two borrows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 같은 의미:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// 같은 의미:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}</span></code></pre></pre>
<p>r[expr.borrow.raw]</p>
<h3 id="원시-차용-연산자"><a class="header" href="#원시-차용-연산자">원시 차용 연산자</a></h3>
<p>r[expr.borrow.raw.intro] <code>&amp;raw const</code> and <code>&amp;raw mut</code> are the <em>raw borrow operators</em>.</p>
<p>r[expr.borrow.raw.place] The operand expression of these operators is evaluated in place expression context.</p>
<p>r[expr.borrow.raw.result] <code>&amp;raw const expr</code> then creates a const raw pointer of type <code>*const T</code> to the given place, and <code>&amp;raw mut expr</code> creates a mutable raw pointer of type <code>*mut T</code>.</p>
<p>r[expr.borrow.raw.invalid-ref] The raw borrow operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions. In those situations, using a borrow operator would cause <a href="../behavior-considered-undefined.html">undefined behavior</a> by creating an invalid reference, but a raw pointer may still be constructed.</p>
<p>다음은 <code>packed</code> 구조체를 통해 정렬되지 않은 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2`는 정렬되지 않은 참조를 생성하므로 정의되지 않은 동작이 됩니다!
let raw_f2 = &amp;raw const packed.f2;
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
<span class="boring">}</span></code></pre></pre>
<p>다음은 유효한 값을 포함하지 않는 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하므로,
// 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<p>r[expr.deref]</p>
<h2 id="역참조-연산자"><a class="header" href="#역참조-연산자">역참조 연산자</a></h2>
<p>r[expr.deref.syntax]</p>
<pre><code class="language-grammar expressions">DereferenceExpression -&gt; `*` Expression
</code></pre>
<p>r[expr.deref.intro] The <code>*</code> (dereference) operator is also a unary prefix operator.</p>
<p>r[expr.deref.result] When applied to a <a href="../types/pointer.html">pointer</a> it denotes the pointed-to location.</p>
<p>r[expr.deref.mut] If the expression is of type <code>&amp;mut T</code> or <code>*mut T</code>, and is either a local variable, a (nested) field of a local variable or is a mutable <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a>, then the resulting memory location can be assigned to.</p>
<p>r[expr.deref.safety] Dereferencing a raw pointer requires <code>unsafe</code>.</p>
<p>r[expr.deref.traits] On non-pointer types <code>*x</code> is equivalent to <code>*std::ops::Deref::deref(&amp;x)</code> in an <a href="../expressions.html#mutability">immutable place expression context</a> and <code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code> in a mutable place expression context.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.try]</p>
<h2 id="the-try-propagation-expression"><a class="header" href="#the-try-propagation-expression">The try propagation expression</a></h2>
<p>r[expr.try.syntax]</p>
<pre><code class="language-grammar expressions">TryPropagationExpression -&gt; Expression `?`
</code></pre>
<p>r[expr.try.intro] The try propagation expression uses the value of the inner expression and the <a href="core::ops::Try"><code>Try</code></a> trait to decide whether to produce a value, and if so, what value to produce, or whether to return a value to the caller, and if so, what value to return.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = "123".parse()?; // `x` is `123`.
    let y: i32 = "24a".parse()?; // Returns an `Err()` immediately.
    Ok(x + y)                    // 실행되지 않습니다.
}

let res = try_to_parse();
println!("{res:?}");
<span class="boring">assert!(res.is_err())
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::ControlFlow;

pub struct TreeNode&lt;T&gt; {
    value: T,
    left: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
    right: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
}

impl&lt;T&gt; TreeNode&lt;T&gt; {
    pub fn traverse_inorder&lt;B&gt;(&amp;self, f: &amp;mut impl FnMut(&amp;T) -&gt; ControlFlow&lt;B&gt;) -&gt; ControlFlow&lt;B&gt; {
        if let Some(left) = &amp;self.left {
            left.traverse_inorder(f)?;
        }
        f(&amp;self.value)?;
        if let Some(right) = &amp;self.right {
            right.traverse_inorder(f)?;
        }
        ControlFlow::Continue(())
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = TreeNode {
</span><span class="boring">        value: 1,
</span><span class="boring">        left: Some(Box::new(TreeNode{value: 2, left: None, right: None})),
</span><span class="boring">        right: None,
</span><span class="boring">    };
</span><span class="boring">    let v = n.traverse_inorder(&amp;mut |t| {
</span><span class="boring">        if *t == 2 {
</span><span class="boring">            ControlFlow::Break("found")
</span><span class="boring">        } else {
</span><span class="boring">            ControlFlow::Continue(())
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">    assert_eq!(v, ControlFlow::Break("found"));
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The <a href="core::ops::Try"><code>Try</code></a> trait is currently unstable, and thus cannot be implemented for user types.</p>
<p>The try propagation expression is currently roughly equivalent to:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![ feature(try_trait_v2) ]
</span><span class="boring">fn example() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let expr = Ok(());
</span>match core::ops::Try::branch(expr) {
    core::ops::ControlFlow::Continue(val) =&gt; val,
    core::ops::ControlFlow::Break(residual) =&gt;
        return core::ops::FromResidual::from_residual(residual),
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The try propagation operator is sometimes called <em>the question mark operator</em>, <em>the <code>?</code> operator</em>, or <em>the try operator</em>.</p>
</blockquote>
<p>r[expr.try.restricted-types] The try propagation operator can be applied to expressions with the type of:</p>
<ul>
<li>[<code>Result&lt;T, E&gt;</code>]
<ul>
<li><code>Result::Ok(val)</code> evaluates to <code>val</code>.</li>
<li><code>Result::Err(e)</code> returns <code>Result::Err(From::from(e))</code>.</li>
</ul>
</li>
<li>[<code>Option&lt;T&gt;</code>]
<ul>
<li><code>Option::Some(val)</code> evaluates to <code>val</code>.</li>
<li><code>Option::None</code> returns <code>Option::None</code>.</li>
</ul>
</li>
<li>[<code>ControlFlow&lt;B, C&gt;</code>][core::ops::ControlFlow]
<ul>
<li><code>ControlFlow::Continue(c)</code> evaluates to <code>c</code>.</li>
<li><code>ControlFlow::Break(b)</code> returns <code>ControlFlow::Break(b)</code>.</li>
</ul>
</li>
<li>[<code>Poll&lt;Result&lt;T, E&gt;&gt;</code>][core::task::Poll]
<ul>
<li><code>Poll::Ready(Ok(val))</code> evaluates to <code>Poll::Ready(val)</code>.</li>
<li><code>Poll::Ready(Err(e))</code> returns <code>Poll::Ready(Err(From::from(e)))</code>.</li>
<li><code>Poll::Pending</code> evaluates to <code>Poll::Pending</code>.</li>
</ul>
</li>
<li>[<code>Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt;</code>][<code>core::task::Poll</code>]
<ul>
<li><code>Poll::Ready(Some(Ok(val)))</code> evaluates to <code>Poll::Ready(Some(val))</code>.</li>
<li><code>Poll::Ready(Some(Err(e)))</code> returns <code>Poll::Ready(Some(Err(From::from(e))))</code>.</li>
<li><code>Poll::Ready(None)</code> evaluates to <code>Poll::Ready(None)</code>.</li>
<li><code>Poll::Pending</code> evaluates to <code>Poll::Pending</code>.</li>
</ul>
</li>
</ul>
<p>r[expr.negate]</p>
<h2 id="부정-연산자"><a class="header" href="#부정-연산자">부정 연산자</a></h2>
<p>r[expr.negate.syntax]</p>
<pre><code class="language-grammar expressions">NegationExpression -&gt;
      `-` Expression
    | `!` Expression
</code></pre>
<p>r[expr.negate.intro] These are the last two unary operators.</p>
<p>r[expr.negate.results] This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two’s complement. The operands of all of these operators are evaluated in <a href="../expressions.html#place-expressions-and-value-expressions">value expression context</a> so are moved or copied.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>부정*</td><td></td><td>부정</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>비트 NOT</td><td><a href="../types/boolean.html#logical-not">논리적 NOT</a></td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
</div>
<ul>
<li>부호 있는 정수 타입에만 해당.</li>
</ul>
<p>다음은 이러한 연산자의 몇 가지 예입니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.arith-logic]</p>
<h2 id="산술-및-논리-이항-연산자"><a class="header" href="#산술-및-논리-이항-연산자">산술 및 논리 이항 연산자</a></h2>
<p>r[expr.arith-logic.syntax]</p>
<pre><code class="language-grammar expressions">ArithmeticOrLogicalExpression -&gt;
      Expression `+` Expression
    | Expression `-` Expression
    | Expression `*` Expression
    | Expression `/` Expression
    | Expression `%` Expression
    | Expression `&amp;` Expression
    | Expression `|` Expression
    | Expression `^` Expression
    | Expression `&lt;&lt;` Expression
    | Expression `&gt;&gt;` Expression
</code></pre>
<p>r[expr.arith-logic.intro] Binary operators expressions are all written with infix notation.</p>
<p>r[expr.arith-logic.behavior] This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two’s complement. The operands of all of these operators are evaluated in <a href="../expressions.html#place-expressions-and-value-expressions">value expression context</a> so are moved or copied.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th><th>복합 할당 트레잇 오버로딩</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>덧셈</td><td></td><td>덧셈</td><td><code>std::ops::Add</code></td><td><code>std::ops::AddAssign</code></td></tr>
<tr><td><code>-</code></td><td>뺄셈</td><td></td><td>뺄셈</td><td><code>std::ops::Sub</code></td><td><code>std::ops::SubAssign</code></td></tr>
<tr><td><code>*</code></td><td>곱셈</td><td></td><td>곱셈</td><td><code>std::ops::Mul</code></td><td><code>std::ops::MulAssign</code></td></tr>
<tr><td><code>/</code></td><td>나눗셈*†</td><td></td><td>나눗셈</td><td><code>std::ops::Div</code></td><td><code>std::ops::DivAssign</code></td></tr>
<tr><td><code>%</code></td><td>나머지**†</td><td></td><td>나머지</td><td><code>std::ops::Rem</code></td><td><code>std::ops::RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td>비트 AND</td><td><a href="../types/boolean.html#logical-and">논리적 AND</a></td><td></td><td><code>std::ops::BitAnd</code></td><td><code>std::ops::BitAndAssign</code></td></tr>
<tr><td><code>|</code></td><td>비트 OR</td><td><a href="../types/boolean.html#logical-or">논리적 OR</a></td><td></td><td><code>std::ops::BitOr</code></td><td><code>std::ops::BitOrAssign</code></td></tr>
<tr><td><code>^</code></td><td>비트 XOR</td><td><a href="../types/boolean.html#logical-xor">논리적 XOR</a></td><td></td><td><code>std::ops::BitXor</code></td><td><code>std::ops::BitXorAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>왼쪽 시프트</td><td></td><td></td><td><code>std::ops::Shl</code></td><td><code>std::ops::ShlAssign</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>오른쪽 시프트***</td><td></td><td></td><td><code>std::ops::Shr</code></td><td><code>std::ops::ShrAssign</code></td></tr>
</tbody></table>
</div>
<ul>
<li>정수 나눗셈은 0을 향해 반올림합니다.</li>
</ul>
<p>** Rust는 <a href="https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition">절단 나눗셈</a>으로 정의된 나머지를 사용합니다. <code>remainder = dividend % divisor</code>라고 할 때, 나머지는 피제수(dividend)와 같은 부호를 가집니다.</p>
<p>*** 부호 있는 정수 타입에서는 산술 오른쪽 시프트, 부호 없는 정수 타입에서는 논리 오른쪽 시프트입니다.</p>
<p>† 정수 타입의 경우, 0으로 나누면 패닉이 발생합니다.</p>
<p>다음은 이러한 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.cmp]</p>
<h2 id="비교-연산자"><a class="header" href="#비교-연산자">비교 연산자</a></h2>
<p>r[expr.cmp.syntax]</p>
<pre><code class="language-grammar expressions">ComparisonExpression -&gt;
      Expression `==` Expression
    | Expression `!=` Expression
    | Expression `&gt;` Expression
    | Expression `&lt;` Expression
    | Expression `&gt;=` Expression
    | Expression `&lt;=` Expression
</code></pre>
<p>r[expr.cmp.intro] Comparison operators are also defined both for primitive types and many types in the standard library.</p>
<p>r[expr.cmp.paren-chaining] Parentheses are required when chaining comparison operators. For example, the expression <code>a == b == c</code> is invalid and may be written as <code>(a == b) == c</code>.</p>
<p>r[expr.cmp.trait] Unlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety).</p>
<p>r[expr.cmp.place] Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in <a href="../expressions.html#place-expressions-and-value-expressions">place expression context</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// 다음과 동일합니다
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}</span></code></pre></pre>
<p>이는 피연산자를 밖으로 이동시킬 필요가 없음을 의미합니다.</p>
<p>r[expr.cmp.behavior]</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>의미</th><th>오버로딩 메서드</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>같음</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>같지 않음</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>보다 큼</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>보다 작음</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>보다 크거나 같음</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>보다 작거나 같음</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
</div>
<p>다음은 비교 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!("World" &gt;= "Hello");
<span class="boring">}</span></code></pre></pre>
<p>r[expr.bool-logic]</p>
<h2 id="지연-불리언-연산자"><a class="header" href="#지연-불리언-연산자">지연 불리언 연산자</a></h2>
<p>r[expr.bool-logic.syntax]</p>
<pre><code class="language-grammar expressions">LazyBooleanExpression -&gt;
      Expression `||` Expression
    | Expression `&amp;&amp;` Expression
</code></pre>
<p>r[expr.bool-logic.intro] The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The <code>||</code> operator denotes logical ‘or’, and the <code>&amp;&amp;</code> operator denotes logical ‘and’.</p>
<p>r[expr.bool-logic.conditional-evaluation] They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, <code>||</code> only evaluates its right-hand operand when the left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = false || true; // 참(true)
let y = false &amp;&amp; panic!(); // 거짓(false), `panic!()`을 평가하지 않음
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as]</p>
<h2 id="타입-캐스트-표현식"><a class="header" href="#타입-캐스트-표현식">타입 캐스트 표현식</a></h2>
<p>r[expr.as.syntax]</p>
<pre><code class="language-grammar expressions">TypeCastExpression -&gt; Expression `as` TypeNoBounds
</code></pre>
<p>r[expr.as.intro] A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>r[expr.as.result] Executing an <code>as</code> expression casts the value on the left-hand side to the type on the right-hand side.</p>
<p><code>as</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.coercions] <code>as</code> can be used to explicitly perform <a href="../type-coercions.html">coercions</a>, as well as the following additional casts. Any cast that does not fit either a coercion rule or an entry in the table is a compiler error. Here <code>*T</code> means either <code>*const T</code> or <code>*mut T</code>. <code>m</code> stands for optional <code>mut</code> in reference types and <code>mut</code> or <code>const</code> in pointer types.</p>
<div class="table-wrapper"><table><thead><tr><th><code>e</code>의 타입</th><th><code>U</code></th><th><code>e as U</code>에 의해 수행되는 캐스트</th></tr></thead><tbody>
<tr><td>정수 또는 부동 소수점 타입</td><td>정수 또는 부동 소수점 타입</td><td>[Numeric cast][expr.as.numeric]</td></tr>
<tr><td>열거형</td><td>정수 타입</td><td>[Enum cast][expr.as.enum]</td></tr>
<tr><td><code>bool</code> 또는 <code>char</code></td><td>정수 타입</td><td>[Primitive to integer cast][expr.as.bool-char-as-int]</td></tr>
<tr><td><code>u8</code></td><td><code>char</code></td><td>[<code>u8</code> to <code>char</code> cast][expr.as.u8-as-char]</td></tr>
<tr><td><code>*T</code></td><td><code>*V</code> <sup class="footnote-reference"><a href="#meta-compat">1</a></sup></td><td>[Pointer to pointer cast][expr.as.pointer]</td></tr>
<tr><td><code>*T</code> (여기서 <code>T: Sized</code>)</td><td>정수 타입</td><td>[Pointer to address cast][expr.as.pointer-as-int]</td></tr>
<tr><td>정수 타입</td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>[Address to pointer cast][expr.as.int-as-pointer]</td></tr>
<tr><td><code>&amp;m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><code>*m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td><a href="../types/function-pointer.html">함수 포인터</a></td><td>함수 아이템에서 함수 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 아이템에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td>정수</td><td>함수 아이템에서 주소로의 캐스트</td></tr>
<tr><td><a href="../types/function-pointer.html">함수 포인터</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 포인터에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-pointer.html">함수 포인터</a></td><td>정수</td><td>함수 포인터에서 주소로의 캐스트</td></tr>
<tr><td>클로저 <sup class="footnote-reference"><a href="#no-capture">3</a></sup></td><td>함수 포인터</td><td>클로저에서 함수 포인터로의 캐스트</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="meta-compat"><sup class="footnote-definition-label">1</sup>
<p>Where <code>T</code> and <code>V</code> have compatible metadata: * <code>V: Sized</code>, or * Both slice metadata (<code>*[u16]</code> -&gt; <code>*[u8]</code>, <code>*str</code> -&gt; <code>*(u8, [u32])</code>), or * Both the same trait object metadata, modulo dropping auto traits (<code>*dyn Debug</code> -&gt; <code>*(u16, dyn Debug)</code>, <code>*dyn Debug + Send</code> -&gt; <code>*dyn Debug</code>) * <strong>Note</strong>: <em>adding</em> auto traits is only allowed if the principal trait has the auto trait as a super trait (given <code>trait T: Send {}</code>, <code>*dyn T</code> -&gt; <code>*dyn T + Send</code> is valid, but <code>*dyn Debug</code> -&gt; <code>*dyn Debug + Send</code> is not) * <strong>Note</strong>: Generics (including lifetimes) must match (<code>*dyn T&lt;'a, A&gt;</code> -&gt; <code>*dyn T&lt;'b, B&gt;</code> requires <code>'a = 'b</code> and <code>A = B</code>)</p>
</div>
<div class="footnote-definition" id="lessmut"><sup class="footnote-definition-label">2</sup>
<p>Only when <code>m₁</code> is <code>mut</code> or <code>m₂</code> is <code>const</code>. Casting <code>mut</code> reference/pointer to <code>const</code> pointer is allowed.</p>
</div>
<div class="footnote-definition" id="no-capture"><sup class="footnote-definition-label">3</sup>
<p>Only closures that do not capture (close over) any local variables can be cast to function pointers.</p>
</div>
<h3 id="의미론"><a class="header" href="#의미론">의미론</a></h3>
<p>r[expr.as.numeric]</p>
<h4 id="숫자-캐스트"><a class="header" href="#숫자-캐스트">숫자 캐스트</a></h4>
<p>r[expr.as.numeric.int-same-size]</p>
<ul>
<li>
<p>같은 크기의 두 정수 간 캐스팅(예: i32 -&gt; u32)은 무연산(no-op)입니다(러스트는 고정 정수의 음수 값에 2의 보수를 사용합니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as u8, 42u8);
assert_eq!(-1i8 as u8, 255u8);
assert_eq!(255u8 as i8, -1i8);
assert_eq!(-1i16 as u16, 65535u16);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-truncation]</p>
<ul>
<li>
<p>더 큰 정수에서 더 작은 정수로의 캐스팅(예: u32 -&gt; u8)은 잘라냅니다(truncate).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42u16 as u8, 42u8);
assert_eq!(1234u16 as u8, 210u8);
assert_eq!(0xabcdu16 as u8, 0xcdu8);

assert_eq!(-42i16 as i8, -42i8);
assert_eq!(1234u16 as i8, -46i8);
assert_eq!(0xabcdi32 as i8, -51i8);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-extension]</p>
<ul>
<li>
<p>더 작은 정수에서 더 큰 정수로의 캐스팅(예: u8 -&gt; u32)은 다음과 같습니다.</p>
<ul>
<li>소스가 부호 없으면 0으로 확장(zero-extend)</li>
<li>소스가 부호 있으면 부호 확장(sign-extend)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as i16, 42i16);
assert_eq!(-17i8 as i16, -17i16);
assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, "0으로 확장");
assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, "부호 확장 0");
assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, "부호 확장 1");
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-as-int]</p>
<ul>
<li>
<p>부동 소수점에서 정수로의 캐스팅은 부동 소수점을 0을 향해 반올림합니다.</p>
<ul>
<li><code>NaN</code>은 <code>0</code>을 반환합니다.</li>
<li><code>INFINITY</code>를 포함하여 최대 정수 값보다 큰 값은 정수 타입의 최대 값으로 포화(saturate)됩니다.</li>
<li><code>NEG_INFINITY</code>를 포함하여 최소 정수 값보다 작은 값은 정수 타입의 최소 값으로 포화(saturate)됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42.9f32 as i32, 42);
assert_eq!(-42.9f32 as i32, -42);
assert_eq!(42_000_000f32 as i32, 42_000_000);
assert_eq!(std::f32::NAN as i32, 0);
assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);
assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-as-float]</p>
<ul>
<li>
<p>정수에서 부동 소수점으로의 캐스팅은 가능한 가장 가까운 부동 소수점을 생성합니다 *</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
<li>참고: 현재 숫자 타입 세트에서는 <code>f32::MAX + (0.5 ULP)</code>보다 크거나 같은 값에 대해 <code>u128 as f32</code>에서만 오버플로가 발생할 수 있습니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1337i32 as f32, 1337f32);
assert_eq!(123_456_789i32 as f32, 123_456_790f32, "반올림됨");
assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-widening]</p>
<ul>
<li>
<p>f32에서 f64로의 캐스팅은 완벽하며 손실이 없습니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f32 as f64, 1_234.5f64);
assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);
assert!((std::f32::NAN as f64).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-narrowing]</p>
<ul>
<li>
<p>f64에서 f32로의 캐스팅은 가능한 가장 가까운 f32를 생성합니다 **</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f64 as f32, 1_234.5f32);
assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, "반올림됨");
assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);
assert!((std::f64::NAN as f32).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>* 이 반올림 모드와 오버플로 동작을 사용하는 정수-부동 소수점 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>** 이 반올림 모드와 오버플로 동작을 사용하는 f64-f32 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>*** IEEE 754-2008 §4.3.1에 정의된 대로: 가장 가까운 부동 소수점 숫자를 선택하고, 두 부동 소수점 숫자 사이의 정확히 중간인 경우 최하위 자릿수가 짝수인 것을 선호합니다.</p>
<p>r[expr.as.enum]</p>
<h4 id="열거형-캐스트"><a class="header" href="#열거형-캐스트">열거형 캐스트</a></h4>
<p>r[expr.as.enum.discriminant] Casts an enum to its discriminant, then uses a numeric cast if needed. Casting is limited to the following kinds of enumerations:</p>
<ul>
<li><a href="../items/enumerations.html#unit-only-enum">유닛 전용 열거형</a></li>
<li><a href="../items/enumerations.html#explicit-discriminants">명시적 판별자</a>가 없는 <a href="../items/enumerations.html#field-less-enum">필드 없는 열거형</a>, 또는 유닛 변형만 명시적 판별자를 갖는 경우</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum { A, B, C }
assert_eq!(Enum::A as i32, 0);
assert_eq!(Enum::B as i32, 1);
assert_eq!(Enum::C as i32, 2);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.enum.no-drop] Casting is not allowed if the enum implements [<code>Drop</code>].</p>
<p>r[expr.as.bool-char-as-int]</p>
<h4 id="기본-타입에서-정수로의-캐스트"><a class="header" href="#기본-타입에서-정수로의-캐스트">기본 타입에서 정수로의 캐스트</a></h4>
<ul>
<li><code>false</code>는 <code>0</code>으로, <code>true</code>는 <code>1</code>로 캐스팅됩니다</li>
<li><code>char</code>는 코드 포인트 값으로 캐스팅된 다음 필요한 경우 숫자 캐스트를 사용합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
assert_eq!('A' as i32, 65);
assert_eq!('Ö' as i32, 214);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.u8-as-char]</p>
<h4 id="u8에서-char로의-캐스트"><a class="header" href="#u8에서-char로의-캐스트"><code>u8</code>에서 <code>char</code>로의 캐스트</a></h4>
<p>해당 코드 포인트를 가진 <code>char</code>로 캐스팅합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(65u8 as char, 'A');
assert_eq!(214u8 as char, 'Ö');
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.pointer-as-int]</p>
<h4 id="포인터에서-주소로의-캐스트"><a class="header" href="#포인터에서-주소로의-캐스트">포인터에서 주소로의 캐스트</a></h4>
<p>원시 포인터에서 정수로의 캐스팅은 참조된 메모리의 기계 주소를 생성합니다. 정수 타입이 포인터 타입보다 작은 경우 주소가 잘릴 수 있습니다. <code>usize</code>를 사용하면 이를 방지할 수 있습니다.</p>
<p>r[expr.as.int-as-pointer]</p>
<h4 id="주소에서-포인터로의-캐스트"><a class="header" href="#주소에서-포인터로의-캐스트">주소에서 포인터로의 캐스트</a></h4>
<p>정수에서 원시 포인터로의 캐스팅은 정수를 메모리 주소로 해석하고 해당 메모리를 참조하는 포인터를 생성합니다.</p>
<blockquote>
<p>[!WARNING] This interacts with the Rust memory model, which is still under development. A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer. Dereferencing such a pointer may be <a href="../behavior-considered-undefined.html">undefined behavior</a> if aliasing rules are not followed.</p>
</blockquote>
<p>건전한 주소 연산의 간단한 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize;
let second_address = first_address + 4; // 4 == size_of::&lt;i32&gt;()
let p2 = second_address as *mut i32;
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.pointer]</p>
<h4 id="포인터에서-포인터로의-캐스트"><a class="header" href="#포인터에서-포인터로의-캐스트">포인터에서 포인터로의 캐스트</a></h4>
<p>r[expr.as.pointer.behavior] <code>*const T</code> / <code>*mut T</code> can be cast to <code>*const U</code> / <code>*mut U</code> with the following behavior:</p>
<p>r[expr.as.pointer.sized]</p>
<ul>
<li><code>T</code>와 <code>U</code>가 모두 크기가 있는(sized) 경우, 포인터는 변경되지 않고 반환됩니다.</li>
</ul>
<p>r[expr.as.pointer.unsized]</p>
<ul>
<li>
<p><code>T</code>와 <code>U</code>가 모두 크기가 없는(unsized) 경우, 포인터도 변경되지 않고 반환됩니다. 특히 메타데이터는 정확하게 보존됩니다.</p>
<p>예를 들어, <code>*const [T]</code>에서 <code>*const [U]</code>로의 캐스트는 요소 수를 보존합니다. 결과적으로 이러한 캐스트는 포인터가 참조하는 대상의 크기를 반드시 보존하지는 않는다는 점에 유의하십시오(예: <code>*const [u16]</code>을 <code>*const [u8]</code>로 캐스팅하면 원본 크기의 절반인 객체를 참조하는 원시 포인터가 됩니다). <code>str</code> 및 <code>struct Foo(i32, [u8])</code> 또는 <code>(u64, Foo)</code>와 같이 크기가 없는 꼬리가 슬라이스 타입인 복합 타입에도 동일하게 적용됩니다.</p>
</li>
</ul>
<p>r[expr.as.pointer.discard-metadata]</p>
<ul>
<li><code>T</code>는 크기가 없고 <code>U</code>는 크기가 있는 경우, 캐스트는 넓은 포인터(wide pointer) <code>T</code>를 완성하는 모든 메타데이터를 버리고 크기가 없는 포인터의 데이터 부분으로 구성된 얇은 포인터(thin pointer) <code>U</code>를 생성합니다.</li>
</ul>
<p>r[expr.assign]</p>
<h2 id="할당-표현식"><a class="header" href="#할당-표현식">할당 표현식</a></h2>
<p>r[expr.assign.syntax]</p>
<pre><code class="language-grammar expressions">AssignmentExpression -&gt; Expression `=` Expression
</code></pre>
<p>r[expr.assign.intro] An <em>assignment expression</em> moves a value into a specified place.</p>
<p>r[expr.assign.assignee] An assignment expression consists of a <a href="../expressions.html#mutability">mutable</a> <a href="../expressions.html#place-expressions-and-value-expressions">assignee expression</a>, the <em>assignee operand</em>, followed by an equals sign (<code>=</code>) and a <a href="../expressions.html#place-expressions-and-value-expressions">value expression</a>, the <em>assigned value operand</em>.</p>
<p>r[expr.assign.behavior-basic] In its most basic form, an assignee expression is a <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a>, and we discuss this case first.</p>
<p>r[expr.assign.behavior-destructuring] The more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case.</p>
<p>r[expr.assign.basic]</p>
<h3 id="기본-할당"><a class="header" href="#기본-할당">기본 할당</a></h3>
<p>r[expr.assign.evaluation-order] Evaluating assignment expressions begins by evaluating its operands. The assigned value operand is evaluated first, followed by the assignee expression.</p>
<p>r[expr.assign.destructuring-order] For destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.</p>
<blockquote>
<p>[!NOTE] This is different than other expressions in that the right operand is evaluated before the left one.</p>
</blockquote>
<p>r[expr.assign.drop-target] It then has the effect of first <a href="../destructors.html">dropping</a> the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable.</p>
<p>r[expr.assign.behavior] Next it either <a href="../expressions.html#moved-and-copied-types">copies or moves</a> the assigned value to the assigned place.</p>
<p>r[expr.assign.result] An assignment expression always produces <a href="../types/tuple.html">the unit value</a>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
let y = 0;
x = y;
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure]</p>
<h3 id="구조-분해-할당"><a class="header" href="#구조-분해-할당">구조 분해 할당</a></h3>
<p>r[expr.assign.destructure.intro] Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs. For instance, we may swap two mutable variables:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (0, 1);
// 구조 분해 할당을 사용하여 `a`와 `b`를 교환합니다.
(b, a) = (a, b);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure.assignee] In contrast to destructuring declarations using <code>let</code>, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities. Instead, a group of expressions that correspond to patterns are designated to be <a href="../expressions.html#place-expressions-and-value-expressions">assignee expressions</a>, and permitted on the left-hand side of an assignment. Assignee expressions are then desugared to pattern matches followed by sequential assignment.</p>
<p>r[expr.assign.destructure.irrefutable] The desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice <code>[..]</code>, are permitted for destructuring assignment.</p>
<p>탈설탕 방법은 간단하며, 예제로 설명하는 것이 가장 좋습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct { x: u32, y: u32 }
</span><span class="boring">let (mut a, mut b) = (0, 0);
</span>(a, b) = (3, 4);

[a, b] = [3, 4];

Struct { x: a, y: b } = Struct { x: 3, y: 4};

// 다음과 같이 탈설탕됩니다:

{
    let (_a, _b) = (3, 4);
    a = _a;
    b = _b;
}

{
    let [_a, _b] = [3, 4];
    a = _a;
    b = _b;
}

{
    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};
    a = _a;
    b = _b;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure.repeat-ident] Identifiers are not forbidden from being used multiple times in a single assignee expression.</p>
<p>r[expr.assign.destructure.discard-value] <a href="./underscore-expr.html">Underscore expressions</a> and empty <a href="./range-expr.html">range expressions</a> may be used to ignore certain values, without binding them.</p>
<p>r[expr.assign.destructure.default-binding] Note that default binding modes do not apply for the desugared expression.</p>
<p>r[expr.assign.destructure.tmp-scopes]</p>
<blockquote>
<p>[!NOTE] The desugaring restricts the <a href="destructors.scope.temporary">temporary scope</a> of the assigned value operand (the RHS) of a destructuring assignment.</p>
<p>In a basic assignment, the <a href="expr.temporary">temporary</a> is dropped at the end of the enclosing temporary scope. Below, that’s the statement. Therefore, the assignment and use is allowed.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>fn f&lt;T&gt;(x: T) -&gt; T { x }
let x;
(x = f(&amp;temp()), x); // OK
<span class="boring">}</span></code></pre></pre>
<p>Conversely, in a destructuring assignment, the temporary is dropped at the end of the <code>let</code> statement in the desugaring. As that happens before we try to assign to <code>x</code>, below, it fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">fn f&lt;T&gt;(x: T) -&gt; T { x }
</span><span class="boring">let x;
</span>[x] = [f(&amp;temp())]; // 오류
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">fn f&lt;T&gt;(x: T) -&gt; T { x }
</span><span class="boring">let x;
</span>{
    let [_x] = [f(&amp;temp())];
    //                     ^
    //      The temporary is dropped here.
    x = _x; // 오류
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.assign.destructure.tmp-ext]</p>
<blockquote>
<p>[!NOTE] Due to the desugaring, the assigned value operand (the RHS) of a destructuring assignment is an <a href="destructors.scope.lifetime-extension.exprs">extending expression</a> within a newly-introduced block.</p>
<p>Below, because the <a href="destructors.scope.temporary">temporary scope</a> is extended to the end of this introduced block, the assignment is allowed.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>[x] = [&amp;temp()]; // OK
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>{ let [_x] = [&amp;temp()]; x = _x; } // OK
<span class="boring">}</span></code></pre></pre>
<p>However, if we try to use <code>x</code>, even within the same statement, we’ll get an error because the <a href="expr.temporary">temporary</a> is dropped at the end of this introduced block.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>([x] = [&amp;temp()], x); // 오류
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>(
    {
        let [_x] = [&amp;temp()];
        x = _x;
    }, // &lt;-- The temporary is dropped here.
    x, // 오류
);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.compound-assign]</p>
<h2 id="복합-할당-표현식"><a class="header" href="#복합-할당-표현식">복합 할당 표현식</a></h2>
<p>r[expr.compound-assign.syntax]</p>
<pre><code class="language-grammar expressions">CompoundAssignmentExpression -&gt;
      Expression `+=` Expression
    | Expression `-=` Expression
    | Expression `*=` Expression
    | Expression `/=` Expression
    | Expression `%=` Expression
    | Expression `&amp;=` Expression
    | Expression `|=` Expression
    | Expression `^=` Expression
    | Expression `&lt;&lt;=` Expression
    | Expression `&gt;&gt;=` Expression
</code></pre>
<p>r[expr.compound-assign.intro] <em>Compound assignment expressions</em> combine arithmetic and logical binary operators with assignment expressions.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 1;
assert!(x == 6);
<span class="boring">}</span></code></pre></pre>
<p>복합 할당의 구문은 <a href="../expressions.html#mutability">가변</a> <a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>(<em>할당된 피연산자</em>), 그 다음에 단일 토큰(공백 없음)으로 <code>=</code>이 뒤따르는 연산자 중 하나, 그리고 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>수정하는 피연산자</em>)입니다.</p>
<p>r[expr.compound-assign.place] Unlike other place operands, the assigned place operand must be a place expression.</p>
<p>r[expr.compound-assign.no-value] Attempting to use a value expression is a compiler error rather than promoting it to a temporary.</p>
<p>r[expr.compound-assign.operand-order] Evaluation of compound assignment expressions depends on the types of the operands.</p>
<p>r[expr.compound-assign.primitives] If the types of both operands are known, prior to monomorphization, to be primitive, the right hand side is evaluated first, the left hand side is evaluated next, and the place given by the evaluation of the left hand side is mutated by applying the operator to the values of both sides.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use core::{num::Wrapping, ops::AddAssign};
</span><span class="boring">
</span>trait Equate {}
impl&lt;T&gt; Equate for (T, T) {}

fn f1(x: (u8,)) {
    let mut order = vec![];
    // The RHS is evaluated first as both operands are of primitive
    // type.
    { order.push(2); x }.0 += { order.push(1); x }.0;
    assert!(order.is_sorted());
}

fn f2(x: (Wrapping&lt;u8&gt;,)) {
    let mut order = vec![];
    // The LHS is evaluated first as `Wrapping&lt;_&gt;` is not a primitive
    // type.
    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;
    assert!(order.is_sorted());
}

fn f3&lt;T: AddAssign&lt;u8&gt; + Copy&gt;(x: (T,)) where (T, u8): Equate {
    let mut order = vec![];
    // The LHS is evaluated first as one of the operands is a generic
    // parameter, even though that generic parameter can be unified
    // with a primitive type due to the where clause bound.
    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;
    assert!(order.is_sorted());
}

fn main() {
    f1((0u8,));
    f2((Wrapping(0u8),));
    // We supply a primitive type as the generic argument, but this
    // does not affect the evaluation order in `f3` when
    // monomorphized.
    f3::&lt;u8&gt;((0u8,));
}</code></pre></pre>
<blockquote>
<p>[!NOTE] This is unusual. Elsewhere left to right evaluation is the norm.</p>
<p>See the <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs">eval order test</a> for more examples.</p>
</blockquote>
<p>r[expr.compound-assign.trait] Otherwise, this expression is syntactic sugar for using the corresponding trait for the operator (see [expr.arith-logic.behavior]) and calling its method with the left hand side as the <a href="expr.method.intro">receiver</a> and the right hand side as the next argument.</p>
<p>For example, the following two statements are equivalent:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T, y: T) {
    x += y; // Statement 1.
    x.add_assign(y); // Statement 2.
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Surprisingly, desugaring this further to a fully qualified method call is not equivalent, as there is special borrow checker behavior when the mutable reference to the first operand is taken via <a href="expr.method.candidate-receivers-refs">autoref</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // Here we used `x` as both the LHS and the RHS. Because the
    // mutable borrow of the LHS needed to call the trait method
    // is taken implicitly by autoref, this is OK.
    x += x; //~ OK
    x.add_assign(x); //~ OK
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0503 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // We can't desugar the above to the below, as once we take the
    // mutable borrow of `x` to pass the first argument, we can't
    // pass `x` by value in the second argument because the mutable
    // reference is still live.
    &lt;T as AddAssign&gt;::add_assign(&amp;mut x, x);
    //~^ ERROR cannot use `x` because it was mutably borrowed
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0503 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // As above.
    (&amp;mut x).add_assign(x);
    //~^ ERROR cannot use `x` because it was mutably borrowed
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.compound-assign.result] As with normal assignment expressions, compound assignment expressions always produce <a href="../types/tuple.html">the unit value</a>.</p>
<blockquote>
<p>[!WARNING] Avoid writing code that depends on the evaluation order of operands in compound assignments as it can be unusual and surprising.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../expressions/block-expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../expressions/grouped-expr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../expressions/block-expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../expressions/grouped-expr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
