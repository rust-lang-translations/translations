<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>연산자 표현식 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/expressions/operator-expr.md`;
                    } else {
                        canonical_href = `${base}/${lang}/expressions/operator-expr.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/expressions/operator-expr.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-expr.operator"><a class="rule-link" href="#r-expr.operator" title="expr.operator"><span>[expr<wbr>.operator]<span/></a></div>
<h1 id="연산자-표현식"><a class="header" href="#연산자-표현식">연산자 표현식</a></h1>
<div class="rule" id="r-expr.operator.syntax"><a class="rule-link" href="#r-expr.operator.syntax" title="expr.operator.syntax"><span>[expr<wbr>.operator<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>연산자표현식</em> :<br />
      <a href="#borrow-operators"><em>차용표현식</em></a><br />
   | <a href="#the-dereference-operator"><em>역참조표현식</em></a><br />
   | <a href="#the-question-mark-operator"><em>오류전파표현식</em></a><br />
   | <a href="#negation-operators"><em>부정표현식</em></a><br />
   | <a href="#arithmetic-and-logical-binary-operators"><em>산술또는논리표현식</em></a><br />
   | <a href="#comparison-operators"><em>비교표현식</em></a><br />
   | <a href="#lazy-boolean-operators"><em>지연불리언표현식</em></a><br />
   | <a href="#type-cast-expressions"><em>타입캐스트표현식</em></a><br />
   | <a href="#assignment-expressions"><em>할당표현식</em></a><br />
   | <a href="#compound-assignment-expressions"><em>복합할당표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.operator.intro"><a class="rule-link" href="#r-expr.operator.intro" title="expr.operator.intro"><span>[expr<wbr>.operator<wbr>.intro]<span/></a></div>
<p>연산자는 러스트 언어에 의해 내장 타입에 대해 정의됩니다.</p>
<div class="rule" id="r-expr.operator.trait"><a class="rule-link" href="#r-expr.operator.trait" title="expr.operator.trait"><span>[expr<wbr>.operator<wbr>.trait]<span/></a></div>
<p>다음 연산자 중 다수는 <code>std::ops</code> 또는 <code>std::cmp</code>의 트레잇을 사용하여 오버로딩할 수도 있습니다.</p>
<div class="rule" id="r-expr.operator.int-overflow"><a class="rule-link" href="#r-expr.operator.int-overflow" title="expr.operator.int-overflow"><span>[expr<wbr>.operator<wbr>.int-overflow]<span/></a></div>
<h2 id="오버플로"><a class="header" href="#오버플로">오버플로</a></h2>
<div class="rule" id="r-expr.operator.int-overflow.intro"><a class="rule-link" href="#r-expr.operator.int-overflow.intro" title="expr.operator.int-overflow.intro"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.intro]<span/></a></div>
<p>정수 연산자는 디버그 모드에서 컴파일될 때 오버플로가 발생하면 패닉을 일으킵니다. <code>-C debug-assertions</code> 및 <code>-C overflow-checks</code> 컴파일러 플래그를 사용하여 이를 더 직접적으로 제어할 수 있습니다. 다음 사항들은 오버플로로 간주됩니다:</p>
<div class="rule" id="r-expr.operator.int-overflow.binary-arith"><a class="rule-link" href="#r-expr.operator.int-overflow.binary-arith" title="expr.operator.int-overflow.binary-arith"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.binary-arith]<span/></a></div>
<ul>
<li><code>+</code>, <code>*</code> 또는 이항 <code>-</code>가 저장할 수 있는 최대값보다 크거나 최소값보다 작은 값을 생성할 때.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.unary-neg"><a class="rule-link" href="#r-expr.operator.int-overflow.unary-neg" title="expr.operator.int-overflow.unary-neg"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.unary-neg]<span/></a></div>
<ul>
<li>피연산자가 <a href="literal-expr.html#integer-literal-expressions">리터럴 표현식</a> (또는 하나 이상의 <a href="grouped-expr.html">그룹화된 표현식</a> 내에 단독으로 있는 리터럴 표현식)이 아닌 경우, 부호 있는 정수 타입의 가장 작은 음수 값에 단항 <code>-</code>를 적용할 때.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.div"><a class="rule-link" href="#r-expr.operator.int-overflow.div" title="expr.operator.int-overflow.div"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.div]<span/></a></div>
<ul>
<li>왼쪽 인수가 부호 있는 정수 타입의 가장 작은 정수이고 오른쪽 인수가 <code>-1</code>인 경우 <code>/</code> 또는 <code>%</code> 사용. 이러한 검사는 레거시 이유로 <code>-C overflow-checks</code>가 비활성화된 경우에도 발생합니다.</li>
</ul>
<div class="rule" id="r-expr.operator.int-overflow.shift"><a class="rule-link" href="#r-expr.operator.int-overflow.shift" title="expr.operator.int-overflow.shift"><span>[expr<wbr>.operator<wbr>.int-overflow<wbr>.shift]<span/></a></div>
<ul>
<li>오른쪽 인수가 왼쪽 인수 타입의 비트 수보다 크거나 같거나 음수인 경우 <code>&lt;&lt;</code> 또는 <code>&gt;&gt;</code> 사용.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 단항 <code>-</code> 뒤의 리터럴 표현식에 대한 예외는 <code>-128_i8</code> 또는 <code>let j: i8 = -(128)</code>과 같은 형식은 절대 패닉을 일으키지 않으며 예상 값 -128을 갖는다는 것을 의미합니다.</p>
<p>이러한 경우, <a href="literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>의 설명에 따라 정수 리터럴이 해당 타입으로 잘리기 때문에 리터럴 표현식은 이미 해당 타입에 대해 가장 작은 음수 값을 가집니다(예: <code>128_i8</code>은 값 -128을 가짐).</p>
<p>이러한 가장 작은 음수 값의 부정은 2의 보수 오버플로 규칙으로 인해 값이 변경되지 않고 그대로 유지됩니다.</p>
<p><code>rustc</code>에서 이러한 가장 작은 음수 표현식은 <code>overflowing_literals</code> 린트 검사에서도 무시됩니다.</p>
</blockquote>
<div class="rule" id="r-expr.operator.borrow"><a class="rule-link" href="#r-expr.operator.borrow" title="expr.operator.borrow"><span>[expr<wbr>.operator<wbr>.borrow]<span/></a></div>
<h2 id="차용-연산자"><a class="header" href="#차용-연산자">차용 연산자</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>차용표현식</em> :<br />
      (<code>&amp;</code>|<code>&amp;&amp;</code>) <a href="../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>raw</code> <code>const</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>raw</code> <code>mut</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.operator.borrow.intro"><a class="rule-link" href="#r-expr.operator.borrow.intro" title="expr.operator.borrow.intro"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.intro]<span/></a></div>
<p><code>&amp;</code> (공유 차용) 및 <code>&amp;mut</code> (가변 차용) 연산자는 단항 접두사 연산자입니다.</p>
<div class="rule" id="r-expr.operator.borrow.result"><a class="rule-link" href="#r-expr.operator.borrow.result" title="expr.operator.borrow.result"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.result]<span/></a></div>
<p><a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>에 적용될 때, 이 표현식은 값이 참조하는 위치에 대한 참조(포인터)를 생성합니다.</p>
<div class="rule" id="r-expr.operator.borrow.lifetime"><a class="rule-link" href="#r-expr.operator.borrow.lifetime" title="expr.operator.borrow.lifetime"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.lifetime]<span/></a></div>
<p>메모리 위치는 또한 참조 기간 동안 차용 상태로 놓입니다. 공유 차용(<code>&amp;</code>)의 경우, 이는 장소를 변경할 수 없지만 읽거나 다시 공유할 수 있음을 의미합니다. 가변 차용(<code>&amp;mut</code>)의 경우, 차용이 만료될 때까지 어떤 방식으로도 장소에 접근할 수 없습니다.</p>
<div class="rule" id="r-expr.operator.borrow.mut"><a class="rule-link" href="#r-expr.operator.borrow.mut" title="expr.operator.borrow.mut"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.mut]<span/></a></div>
<p><code>&amp;mut</code>은 피연산자를 가변 장소 표현식 컨텍스트에서 평가합니다.</p>
<div class="rule" id="r-expr.operator.borrow.temporary"><a class="rule-link" href="#r-expr.operator.borrow.temporary" title="expr.operator.borrow.temporary"><span>[expr<wbr>.operator<wbr>.borrow<wbr>.temporary]<span/></a></div>
<p><code>&amp;</code> 또는 <code>&amp;mut</code> 연산자가 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식</a>에 적용되면 <a href="../expressions.html#temporaries">임시 값</a>이 생성됩니다.</p>
<p>이 연산자들은 오버로딩할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 이 스코프 동안 지속되는 값 7을 가진 임시 값이 생성됩니다.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // 이 스코프 동안 `array`를 가변적으로 차용합니다.
    // `array`는 `mutable_reference`를 통해서만 사용할 수 있습니다.
    let mutable_reference = &amp;mut array;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.borrow.and-and-syntax"><a class="rule-link" href="#r-expr.borrow.and-and-syntax" title="expr.borrow.and-and-syntax"><span>[expr<wbr>.borrow<wbr>.and-and-syntax]<span/></a></div>
<p><code>&amp;&amp;</code>가 단일 토큰(<a href="#lazy-boolean-operators">지연 ‘and’ 연산자</a>)임에도 불구하고, 차용 표현식의 컨텍스트에서 사용될 때는 두 번의 차용으로 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 같은 의미:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// 같은 의미:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.borrow.raw"><a class="rule-link" href="#r-expr.borrow.raw" title="expr.borrow.raw"><span>[expr<wbr>.borrow<wbr>.raw]<span/></a></div>
<h3 id="원시-차용-연산자"><a class="header" href="#원시-차용-연산자">원시 차용 연산자</a></h3>
<div class="rule" id="r-expr.borrow.raw.intro"><a class="rule-link" href="#r-expr.borrow.raw.intro" title="expr.borrow.raw.intro"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.intro]<span/></a></div>
<p><code>&amp;raw const</code>와 <code>&amp;raw mut</code>는 _원시 차용 연산자_입니다.</p>
<div class="rule" id="r-expr.borrow.raw.place"><a class="rule-link" href="#r-expr.borrow.raw.place" title="expr.borrow.raw.place"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.place]<span/></a></div>
<p>이 연산자들의 피연산자 표현식은 장소 표현식 컨텍스트에서 평가됩니다.</p>
<div class="rule" id="r-expr.borrow.raw.result"><a class="rule-link" href="#r-expr.borrow.raw.result" title="expr.borrow.raw.result"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.result]<span/></a></div>
<p><code>&amp;raw const expr</code>은 주어진 장소에 대한 <code>*const T</code> 타입의 상수 원시 포인터를 생성하고, <code>&amp;raw mut expr</code>은 <code>*mut T</code> 타입의 가변 원시 포인터를 생성합니다.</p>
<div class="rule" id="r-expr.borrow.raw.invalid-ref"><a class="rule-link" href="#r-expr.borrow.raw.invalid-ref" title="expr.borrow.raw.invalid-ref"><span>[expr<wbr>.borrow<wbr>.raw<wbr>.invalid-ref]<span/></a></div>
<p>장소 표현식이 적절하게 정렬되지 않은 장소로 평가되거나 해당 타입에 의해 결정된 유효한 값을 저장하지 않을 수 있는 경우, 또는 참조를 생성하면 잘못된 앨리어싱 가정이 도입되는 경우 항상 차용 연산자 대신 원시 차용 연산자를 사용해야 합니다. 이러한 상황에서 차용 연산자를 사용하면 잘못된 참조가 생성되어 <a href="../behavior-considered-undefined.html">정의되지 않은 동작</a>을 유발할 수 있지만, 원시 포인터는 여전히 생성될 수 있습니다.</p>
<p>다음은 <code>packed</code> 구조체를 통해 정렬되지 않은 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2`는 정렬되지 않은 참조를 생성하므로 정의되지 않은 동작이 됩니다!
let raw_f2 = &amp;raw const packed.f2;
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
<span class="boring">}</span></code></pre></pre>
<p>다음은 유효한 값을 포함하지 않는 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하므로,
// 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.deref"><a class="rule-link" href="#r-expr.deref" title="expr.deref"><span>[expr<wbr>.deref]<span/></a></div>
<h2 id="역참조-연산자"><a class="header" href="#역참조-연산자">역참조 연산자</a></h2>
<div class="rule" id="r-expr.deref.syntax"><a class="rule-link" href="#r-expr.deref.syntax" title="expr.deref.syntax"><span>[expr<wbr>.deref<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>역참조표현식</em> :<br />
   <code>*</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.deref.intro"><a class="rule-link" href="#r-expr.deref.intro" title="expr.deref.intro"><span>[expr<wbr>.deref<wbr>.intro]<span/></a></div>
<p><code>*</code> (역참조) 연산자는 또한 단항 접두사 연산자입니다.</p>
<div class="rule" id="r-expr.deref.result"><a class="rule-link" href="#r-expr.deref.result" title="expr.deref.result"><span>[expr<wbr>.deref<wbr>.result]<span/></a></div>
<p><a href="../types/pointer.html">포인터</a>에 적용될 때, 이는 가리키는 위치를 나타냅니다.</p>
<div class="rule" id="r-expr.deref.mut"><a class="rule-link" href="#r-expr.deref.mut" title="expr.deref.mut"><span>[expr<wbr>.deref<wbr>.mut]<span/></a></div>
<p>표현식이 <code>&amp;mut T</code> 또는 <code>*mut T</code> 타입이고, 지역 변수, 지역 변수의 (중첩된) 필드 또는 가변 <a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>인 경우, 결과 메모리 위치에 할당할 수 있습니다.</p>
<div class="rule" id="r-expr.deref.safety"><a class="rule-link" href="#r-expr.deref.safety" title="expr.deref.safety"><span>[expr<wbr>.deref<wbr>.safety]<span/></a></div>
<p>원시 포인터를 역참조하려면 <code>unsafe</code>가 필요합니다.</p>
<div class="rule" id="r-expr.deref.traits"><a class="rule-link" href="#r-expr.deref.traits" title="expr.deref.traits"><span>[expr<wbr>.deref<wbr>.traits]<span/></a></div>
<p>비 포인터 타입에서 <code>*x</code>는 <a href="../expressions.html#mutability">불변 장소 표현식 컨텍스트</a>에서는 <code>*std::ops::Deref::deref(&amp;x)</code>와 동일하고, 가변 장소 표현식 컨텍스트에서는 <code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code>와 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try"><a class="rule-link" href="#r-expr.try" title="expr.try"><span>[expr<wbr>.try]<span/></a></div>
<h2 id="물음표-연산자"><a class="header" href="#물음표-연산자">물음표 연산자</a></h2>
<div class="rule" id="r-expr.try.syntax"><a class="rule-link" href="#r-expr.try.syntax" title="expr.try.syntax"><span>[expr<wbr>.try<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>오류전파표현식</em> :<br />
   <a href="../expressions.html"><em>표현식</em></a> <code>?</code></p>
</blockquote>
<div class="rule" id="r-expr.try.intro"><a class="rule-link" href="#r-expr.try.intro" title="expr.try.intro"><span>[expr<wbr>.try<wbr>.intro]<span/></a></div>
<p>물음표 연산자 (<code>?</code>)는 유효한 값을 풀거나(unwrap) 오류 값을 반환하여 호출 함수로 전파합니다.</p>
<div class="rule" id="r-expr.try.restricted-types"><a class="rule-link" href="#r-expr.try.restricted-types" title="expr.try.restricted-types"><span>[expr<wbr>.try<wbr>.restricted-types]<span/></a></div>
<p>이것은 <code>Result&lt;T, E&gt;</code> 및 <code>Option&lt;T&gt;</code> 타입에만 적용할 수 있는 단항 후위 연산자입니다.</p>
<div class="rule" id="r-expr.try.behavior-std-result"><a class="rule-link" href="#r-expr.try.behavior-std-result" title="expr.try.behavior-std-result"><span>[expr<wbr>.try<wbr>.behavior-std-result]<span/></a></div>
<p><code>Result&lt;T, E&gt;</code> 타입의 값에 적용되면 오류를 전파합니다.</p>
<div class="rule" id="r-expr.try.effects-err"><a class="rule-link" href="#r-expr.try.effects-err" title="expr.try.effects-err"><span>[expr<wbr>.try<wbr>.effects-err]<span/></a></div>
<p>값이 <code>Err(e)</code>이면, 둘러싼 함수나 클로저에서 <code>Err(From::from(e))</code>를 반환합니다.</p>
<div class="rule" id="r-expr.try.result-ok"><a class="rule-link" href="#r-expr.try.result-ok" title="expr.try.result-ok"><span>[expr<wbr>.try<wbr>.result-ok]<span/></a></div>
<p><code>Ok(x)</code>에 적용되면 값을 풀어 <code>x</code>로 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = "123".parse()?; // x = 123
    let y: i32 = "24a".parse()?; // 즉시 Err()를 반환합니다
    Ok(x + y)                    // 실행되지 않습니다.
}

let res = try_to_parse();
println!("{:?}", res);
<span class="boring">assert!(res.is_err())
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try.behavior-std-option"><a class="rule-link" href="#r-expr.try.behavior-std-option" title="expr.try.behavior-std-option"><span>[expr<wbr>.try<wbr>.behavior-std-option]<span/></a></div>
<p><code>Option&lt;T&gt;</code> 타입의 값에 적용되면 <code>None</code>을 전파합니다.</p>
<div class="rule" id="r-expr.try.effects-none"><a class="rule-link" href="#r-expr.try.effects-none" title="expr.try.effects-none"><span>[expr<wbr>.try<wbr>.effects-none]<span/></a></div>
<p>값이 <code>None</code>이면 <code>None</code>을 반환합니다.</p>
<div class="rule" id="r-expr.try.result-some"><a class="rule-link" href="#r-expr.try.result-some" title="expr.try.result-some"><span>[expr<wbr>.try<wbr>.result-some]<span/></a></div>
<p><code>Some(x)</code>에 적용되면 값을 풀어 <code>x</code>로 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.try.trait"><a class="rule-link" href="#r-expr.try.trait" title="expr.try.trait"><span>[expr<wbr>.try<wbr>.trait]<span/></a></div>
<p><code>?</code>는 오버로딩할 수 없습니다.</p>
<div class="rule" id="r-expr.negate"><a class="rule-link" href="#r-expr.negate" title="expr.negate"><span>[expr<wbr>.negate]<span/></a></div>
<h2 id="부정-연산자"><a class="header" href="#부정-연산자">부정 연산자</a></h2>
<div class="rule" id="r-expr.negate.syntax"><a class="rule-link" href="#r-expr.negate.syntax" title="expr.negate.syntax"><span>[expr<wbr>.negate<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>부정표현식</em> :<br />
      <code>-</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <code>!</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.negate.intro"><a class="rule-link" href="#r-expr.negate.intro" title="expr.negate.intro"><span>[expr<wbr>.negate<wbr>.intro]<span/></a></div>
<p>이것들은 마지막 두 단항 연산자입니다.</p>
<div class="rule" id="r-expr.negate.results"><a class="rule-link" href="#r-expr.negate.results" title="expr.negate.results"><span>[expr<wbr>.negate<wbr>.results]<span/></a></div>
<p>이 표는 기본 타입에 대한 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식 컨텍스트</a>에서 평가되므로 이동하거나 복사됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>부정*</td><td></td><td>부정</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>비트 NOT</td><td><a href="../types/boolean.html#logical-not">논리적 NOT</a></td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
</div>
<ul>
<li>부호 있는 정수 타입에만 해당.</li>
</ul>
<p>다음은 이러한 연산자의 몇 가지 예입니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.arith-logic"><a class="rule-link" href="#r-expr.arith-logic" title="expr.arith-logic"><span>[expr<wbr>.arith-logic]<span/></a></div>
<h2 id="산술-및-논리-이항-연산자"><a class="header" href="#산술-및-논리-이항-연산자">산술 및 논리 이항 연산자</a></h2>
<div class="rule" id="r-expr.arith-logic.syntax"><a class="rule-link" href="#r-expr.arith-logic.syntax" title="expr.arith-logic.syntax"><span>[expr<wbr>.arith-logic<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>산술또는논리표현식</em> :<br />
      <a href="../expressions.html"><em>표현식</em></a> <code>+</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>-</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>*</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>/</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>%</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&amp;</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>|</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>^</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&lt;&lt;</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&gt;&gt;</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.arith-logic.intro"><a class="rule-link" href="#r-expr.arith-logic.intro" title="expr.arith-logic.intro"><span>[expr<wbr>.arith-logic<wbr>.intro]<span/></a></div>
<p>이항 연산자 표현식은 모두 중위 표기법으로 작성됩니다.</p>
<div class="rule" id="r-expr.arith-logic.behavior"><a class="rule-link" href="#r-expr.arith-logic.behavior" title="expr.arith-logic.behavior"><span>[expr<wbr>.arith-logic<wbr>.behavior]<span/></a></div>
<p>이 표는 기본 타입에 대한 산술 및 논리 이항 연산자의 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식 컨텍스트</a>에서 평가되므로 이동하거나 복사됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th><th>복합 할당 트레잇 오버로딩</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>덧셈</td><td></td><td>덧셈</td><td><code>std::ops::Add</code></td><td><code>std::ops::AddAssign</code></td></tr>
<tr><td><code>-</code></td><td>뺄셈</td><td></td><td>뺄셈</td><td><code>std::ops::Sub</code></td><td><code>std::ops::SubAssign</code></td></tr>
<tr><td><code>*</code></td><td>곱셈</td><td></td><td>곱셈</td><td><code>std::ops::Mul</code></td><td><code>std::ops::MulAssign</code></td></tr>
<tr><td><code>/</code></td><td>나눗셈*†</td><td></td><td>나눗셈</td><td><code>std::ops::Div</code></td><td><code>std::ops::DivAssign</code></td></tr>
<tr><td><code>%</code></td><td>나머지**†</td><td></td><td>나머지</td><td><code>std::ops::Rem</code></td><td><code>std::ops::RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td>비트 AND</td><td><a href="../types/boolean.html#logical-and">논리적 AND</a></td><td></td><td><code>std::ops::BitAnd</code></td><td><code>std::ops::BitAndAssign</code></td></tr>
<tr><td><code>|</code></td><td>비트 OR</td><td><a href="../types/boolean.html#logical-or">논리적 OR</a></td><td></td><td><code>std::ops::BitOr</code></td><td><code>std::ops::BitOrAssign</code></td></tr>
<tr><td><code>^</code></td><td>비트 XOR</td><td><a href="../types/boolean.html#logical-xor">논리적 XOR</a></td><td></td><td><code>std::ops::BitXor</code></td><td><code>std::ops::BitXorAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>왼쪽 시프트</td><td></td><td></td><td><code>std::ops::Shl</code></td><td><code>std::ops::ShlAssign</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>오른쪽 시프트***</td><td></td><td></td><td><code>std::ops::Shr</code></td><td><code>std::ops::ShrAssign</code></td></tr>
</tbody></table>
</div>
<ul>
<li>정수 나눗셈은 0을 향해 반올림합니다.</li>
</ul>
<p>** Rust는 <a href="https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition">절단 나눗셈</a>으로 정의된 나머지를 사용합니다. <code>remainder = dividend % divisor</code>라고 할 때, 나머지는 피제수(dividend)와 같은 부호를 가집니다.</p>
<p>*** 부호 있는 정수 타입에서는 산술 오른쪽 시프트, 부호 없는 정수 타입에서는 논리 오른쪽 시프트입니다.</p>
<p>† 정수 타입의 경우, 0으로 나누면 패닉이 발생합니다.</p>
<p>다음은 이러한 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.cmp"><a class="rule-link" href="#r-expr.cmp" title="expr.cmp"><span>[expr<wbr>.cmp]<span/></a></div>
<h2 id="비교-연산자"><a class="header" href="#비교-연산자">비교 연산자</a></h2>
<div class="rule" id="r-expr.cmp.syntax"><a class="rule-link" href="#r-expr.cmp.syntax" title="expr.cmp.syntax"><span>[expr<wbr>.cmp<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>비교표현식</em> :<br />
      <a href="../expressions.html"><em>표현식</em></a> <code>==</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>!=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&gt;</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&lt;</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&gt;=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&lt;=</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.cmp.intro"><a class="rule-link" href="#r-expr.cmp.intro" title="expr.cmp.intro"><span>[expr<wbr>.cmp<wbr>.intro]<span/></a></div>
<p>비교 연산자는 기본 타입과 표준 라이브러리의 많은 타입에 대해 정의되어 있습니다.</p>
<div class="rule" id="r-expr.cmp.paren-chaining"><a class="rule-link" href="#r-expr.cmp.paren-chaining" title="expr.cmp.paren-chaining"><span>[expr<wbr>.cmp<wbr>.paren-chaining]<span/></a></div>
<p>비교 연산자를 연결할 때는 괄호가 필요합니다. 예를 들어, 표현식 <code>a == b == c</code>는 유효하지 않으며 <code>(a == b) == c</code>로 작성해야 합니다.</p>
<div class="rule" id="r-expr.cmp.trait"><a class="rule-link" href="#r-expr.cmp.trait" title="expr.cmp.trait"><span>[expr<wbr>.cmp<wbr>.trait]<span/></a></div>
<p>산술 및 논리 연산자와 달리, 이 연산자를 오버로딩하는 트레잇은 타입이 비교되는 방식을 보여주는 데 더 일반적으로 사용되며, 이러한 트레잇을 바운드로 사용하는 함수에 의해 실제 비교를 정의한다고 가정될 가능성이 높습니다. 표준 라이브러리의 많은 함수와 매크로는 이러한 가정을 사용할 수 있습니다(안전성을 보장하기 위한 것은 아니지만).</p>
<div class="rule" id="r-expr.cmp.place"><a class="rule-link" href="#r-expr.cmp.place" title="expr.cmp.place"><span>[expr<wbr>.cmp<wbr>.place]<span/></a></div>
<p>위의 산술 및 논리 연산자와 달리, 이 연산자들은 암시적으로 피연산자의 공유 차용을 취하여 <a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식 컨텍스트</a>에서 평가합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// 다음과 동일합니다
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}</span></code></pre></pre>
<p>이는 피연산자를 밖으로 이동시킬 필요가 없음을 의미합니다.</p>
<div class="rule" id="r-expr.cmp.behavior"><a class="rule-link" href="#r-expr.cmp.behavior" title="expr.cmp.behavior"><span>[expr<wbr>.cmp<wbr>.behavior]<span/></a></div>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>의미</th><th>오버로딩 메서드</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>같음</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>같지 않음</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>보다 큼</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>보다 작음</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>보다 크거나 같음</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>보다 작거나 같음</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
</div>
<p>다음은 비교 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!("World" &gt;= "Hello");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.bool-logic"><a class="rule-link" href="#r-expr.bool-logic" title="expr.bool-logic"><span>[expr<wbr>.bool-logic]<span/></a></div>
<h2 id="지연-불리언-연산자"><a class="header" href="#지연-불리언-연산자">지연 불리언 연산자</a></h2>
<div class="rule" id="r-expr.bool-logic.syntax"><a class="rule-link" href="#r-expr.bool-logic.syntax" title="expr.bool-logic.syntax"><span>[expr<wbr>.bool-logic<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>지연불리언표현식</em> :<br />
      <a href="../expressions.html"><em>표현식</em></a> <code>||</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&amp;&amp;</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.bool-logic.intro"><a class="rule-link" href="#r-expr.bool-logic.intro" title="expr.bool-logic.intro"><span>[expr<wbr>.bool-logic<wbr>.intro]<span/></a></div>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The <code>||</code> operator denotes logical ‘or’, and the <code>&amp;&amp;</code> operator denotes logical ‘and’.</p>
<div class="rule" id="r-expr.bool-logic.conditional-evaluation"><a class="rule-link" href="#r-expr.bool-logic.conditional-evaluation" title="expr.bool-logic.conditional-evaluation"><span>[expr<wbr>.bool-logic<wbr>.conditional-evaluation]<span/></a></div>
<p>이들은 <code>|</code> 및 <code>&amp;</code>와 달리, 왼쪽 피연산자가 표현식의 결과를 이미 결정하지 않은 경우에만 오른쪽 피연산자가 평가된다는 점에서 다릅니다. 즉, <code>||</code>는 왼쪽 피연산자가 <code>false</code>로 평가될 때만 오른쪽 피연산자를 평가하고, <code>&amp;&amp;</code>는 <code>true</code>로 평가될 때만 평가합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = false || true; // 참(true)
let y = false &amp;&amp; panic!(); // 거짓(false), `panic!()`을 평가하지 않음
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as"><a class="rule-link" href="#r-expr.as" title="expr.as"><span>[expr<wbr>.as]<span/></a></div>
<h2 id="타입-캐스트-표현식"><a class="header" href="#타입-캐스트-표현식">타입 캐스트 표현식</a></h2>
<div class="rule" id="r-expr.as.syntax"><a class="rule-link" href="#r-expr.as.syntax" title="expr.as.syntax"><span>[expr<wbr>.as<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>타입캐스트표현식</em> :<br />
   <a href="../expressions.html"><em>표현식</em></a> <code>as</code> <a href="../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
</blockquote>
<div class="rule" id="r-expr.as.intro"><a class="rule-link" href="#r-expr.as.intro" title="expr.as.intro"><span>[expr<wbr>.as<wbr>.intro]<span/></a></div>
<p>타입 캐스트 표현식은 이항 연산자 <code>as</code>로 표시됩니다.</p>
<div class="rule" id="r-expr.as.result"><a class="rule-link" href="#r-expr.as.result" title="expr.as.result"><span>[expr<wbr>.as<wbr>.result]<span/></a></div>
<p><code>as</code> 표현식을 실행하면 왼쪽의 값이 오른쪽의 타입으로 캐스팅됩니다.</p>
<p><code>as</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.coercions"><a class="rule-link" href="#r-expr.as.coercions" title="expr.as.coercions"><span>[expr<wbr>.as<wbr>.coercions]<span/></a></div>
<p><code>as</code>는 <a href="../type-coercions.html">강제 변환</a>을 명시적으로 수행하는 데 사용될 수 있으며, 다음의 추가 캐스트에도 사용됩니다. 강제 변환 규칙이나 표의 항목에 맞지 않는 캐스트는 컴파일러 오류입니다. 여기서 <code>*T</code>는 <code>*const T</code> 또는 <code>*mut T</code>를 의미합니다. <code>m</code>은 참조 타입에서 선택적 <code>mut</code>를 나타내고, 포인터 타입에서는 <code>mut</code> 또는 <code>const</code>를 나타냅니다.</p>
<div class="table-wrapper"><table><thead><tr><th><code>e</code>의 타입</th><th><code>U</code></th><th><code>e as U</code>에 의해 수행되는 캐스트</th></tr></thead><tbody>
<tr><td>정수 또는 부동 소수점 타입</td><td>정수 또는 부동 소수점 타입</td><td><a href="operator-expr.html#r-expr.as.numeric">숫자 캐스트</a></td></tr>
<tr><td>열거형</td><td>정수 타입</td><td><a href="operator-expr.html#r-expr.as.enum">열거형 캐스트</a></td></tr>
<tr><td><code>bool</code> 또는 <code>char</code></td><td>정수 타입</td><td><a href="operator-expr.html#r-expr.as.bool-char-as-int">기본 타입에서 정수로의 캐스트</a></td></tr>
<tr><td><code>u8</code></td><td><code>char</code></td><td><a href="operator-expr.html#r-expr.as.u8-as-char"><code>u8</code>에서 <code>char</code>로의 캐스트</a></td></tr>
<tr><td><code>*T</code></td><td><code>*V</code> <sup class="footnote-reference"><a href="#meta-compat">1</a></sup></td><td><a href="operator-expr.html#r-expr.as.pointer">포인터에서 포인터로의 캐스트</a></td></tr>
<tr><td><code>*T</code> (여기서 <code>T: Sized</code>)</td><td>정수 타입</td><td><a href="operator-expr.html#r-expr.as.pointer-as-int">포인터에서 주소로의 캐스트</a></td></tr>
<tr><td>정수 타입</td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td><a href="operator-expr.html#r-expr.as.int-as-pointer">주소에서 포인터로의 캐스트</a></td></tr>
<tr><td><code>&amp;m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><code>*m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td><a href="../types/function-pointer.html">함수 포인터</a></td><td>함수 아이템에서 함수 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 아이템에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-item.html">함수 아이템</a></td><td>정수</td><td>함수 아이템에서 주소로의 캐스트</td></tr>
<tr><td><a href="../types/function-pointer.html">함수 포인터</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 포인터에서 포인터로의 캐스트</td></tr>
<tr><td><a href="../types/function-pointer.html">함수 포인터</a></td><td>정수</td><td>함수 포인터에서 주소로의 캐스트</td></tr>
<tr><td>클로저 <sup class="footnote-reference"><a href="#no-capture">3</a></sup></td><td>함수 포인터</td><td>클로저에서 함수 포인터로의 캐스트</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="meta-compat"><sup class="footnote-definition-label">1</sup>
<p><code>T</code>와 <code>V</code>가 호환되는 메타데이터를 갖는 경우: * <code>V: Sized</code>이거나, * 둘 다 슬라이스 메타데이터(<code>*[u16]</code> -&gt; <code>*[u8]</code>, <code>*str</code> -&gt; <code>*(u8, [u32])</code>)이거나, * 둘 다 동일한 트레잇 객체 메타데이터(자동 트레잇 제거 제외) (<code>*dyn Debug</code> -&gt; <code>*(u16, dyn Debug)</code>, <code>*dyn Debug + Send</code> -&gt; <code>*dyn Debug</code>) * <strong>참고</strong>: 자동 트레잇 _추가_는 주 트레잇이 해당 자동 트레잇을 슈퍼 트레잇으로 갖는 경우에만 허용됩니다(<code>trait T: Send {}</code>가 주어졌을 때, <code>*dyn T</code> -&gt; <code>*dyn T + Send</code>는 유효하지만 <code>*dyn Debug</code> -&gt; <code>*dyn Debug + Send</code>는 유효하지 않음) * <strong>참고</strong>: 제네릭(라이프타임 포함)은 일치해야 합니다(<code>*dyn T&lt;'a, A&gt;</code> -&gt; <code>*dyn T&lt;'b, B&gt;</code>는 <code>'a = 'b</code> 및 <code>A = B</code>를 요구함)</p>
</div>
<div class="footnote-definition" id="lessmut"><sup class="footnote-definition-label">2</sup>
<p><code>m₁</code>이 <code>mut</code>이거나 <code>m₂</code>가 <code>const</code>인 경우에만 해당합니다. <code>mut</code> 참조/포인터를 <code>const</code> 포인터로 캐스팅하는 것은 허용됩니다.</p>
</div>
<div class="footnote-definition" id="no-capture"><sup class="footnote-definition-label">3</sup>
<p>지역 변수를 캡처(close over)하지 않는 클로저만 함수 포인터로 캐스팅될 수 있습니다.</p>
</div>
<h3 id="의미론"><a class="header" href="#의미론">의미론</a></h3>
<div class="rule" id="r-expr.as.numeric"><a class="rule-link" href="#r-expr.as.numeric" title="expr.as.numeric"><span>[expr<wbr>.as<wbr>.numeric]<span/></a></div>
<h4 id="숫자-캐스트"><a class="header" href="#숫자-캐스트">숫자 캐스트</a></h4>
<div class="rule" id="r-expr.as.numeric.int-same-size"><a class="rule-link" href="#r-expr.as.numeric.int-same-size" title="expr.as.numeric.int-same-size"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-same-size]<span/></a></div>
<ul>
<li>
<p>같은 크기의 두 정수 간 캐스팅(예: i32 -&gt; u32)은 무연산(no-op)입니다(러스트는 고정 정수의 음수 값에 2의 보수를 사용합니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as u8, 42u8);
assert_eq!(-1i8 as u8, 255u8);
assert_eq!(255u8 as i8, -1i8);
assert_eq!(-1i16 as u16, 65535u16);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-truncation"><a class="rule-link" href="#r-expr.as.numeric.int-truncation" title="expr.as.numeric.int-truncation"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-truncation]<span/></a></div>
<ul>
<li>
<p>더 큰 정수에서 더 작은 정수로의 캐스팅(예: u32 -&gt; u8)은 잘라냅니다(truncate).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42u16 as u8, 42u8);
assert_eq!(1234u16 as u8, 210u8);
assert_eq!(0xabcdu16 as u8, 0xcdu8);

assert_eq!(-42i16 as i8, -42i8);
assert_eq!(1234u16 as i8, -46i8);
assert_eq!(0xabcdi32 as i8, -51i8);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-extension"><a class="rule-link" href="#r-expr.as.numeric.int-extension" title="expr.as.numeric.int-extension"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-extension]<span/></a></div>
<ul>
<li>
<p>더 작은 정수에서 더 큰 정수로의 캐스팅(예: u8 -&gt; u32)은 다음과 같습니다.</p>
<ul>
<li>소스가 부호 없으면 0으로 확장(zero-extend)</li>
<li>소스가 부호 있으면 부호 확장(sign-extend)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as i16, 42i16);
assert_eq!(-17i8 as i16, -17i16);
assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, "0으로 확장");
assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, "부호 확장 0");
assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, "부호 확장 1");
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-as-int"><a class="rule-link" href="#r-expr.as.numeric.float-as-int" title="expr.as.numeric.float-as-int"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-as-int]<span/></a></div>
<ul>
<li>
<p>부동 소수점에서 정수로의 캐스팅은 부동 소수점을 0을 향해 반올림합니다.</p>
<ul>
<li><code>NaN</code>은 <code>0</code>을 반환합니다.</li>
<li><code>INFINITY</code>를 포함하여 최대 정수 값보다 큰 값은 정수 타입의 최대 값으로 포화(saturate)됩니다.</li>
<li><code>NEG_INFINITY</code>를 포함하여 최소 정수 값보다 작은 값은 정수 타입의 최소 값으로 포화(saturate)됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42.9f32 as i32, 42);
assert_eq!(-42.9f32 as i32, -42);
assert_eq!(42_000_000f32 as i32, 42_000_000);
assert_eq!(std::f32::NAN as i32, 0);
assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);
assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.int-as-float"><a class="rule-link" href="#r-expr.as.numeric.int-as-float" title="expr.as.numeric.int-as-float"><span>[expr<wbr>.as<wbr>.numeric<wbr>.int-as-float]<span/></a></div>
<ul>
<li>
<p>정수에서 부동 소수점으로의 캐스팅은 가능한 가장 가까운 부동 소수점을 생성합니다 *</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
<li>참고: 현재 숫자 타입 세트에서는 <code>f32::MAX + (0.5 ULP)</code>보다 크거나 같은 값에 대해 <code>u128 as f32</code>에서만 오버플로가 발생할 수 있습니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1337i32 as f32, 1337f32);
assert_eq!(123_456_789i32 as f32, 123_456_790f32, "반올림됨");
assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-widening"><a class="rule-link" href="#r-expr.as.numeric.float-widening" title="expr.as.numeric.float-widening"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-widening]<span/></a></div>
<ul>
<li>
<p>f32에서 f64로의 캐스팅은 완벽하며 손실이 없습니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f32 as f64, 1_234.5f64);
assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);
assert!((std::f32::NAN as f64).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-expr.as.numeric.float-narrowing"><a class="rule-link" href="#r-expr.as.numeric.float-narrowing" title="expr.as.numeric.float-narrowing"><span>[expr<wbr>.as<wbr>.numeric<wbr>.float-narrowing]<span/></a></div>
<ul>
<li>
<p>f64에서 f32로의 캐스팅은 가능한 가장 가까운 f32를 생성합니다 **</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f64 as f32, 1_234.5f32);
assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, "반올림됨");
assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);
assert!((std::f64::NAN as f32).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>* 이 반올림 모드와 오버플로 동작을 사용하는 정수-부동 소수점 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>** 이 반올림 모드와 오버플로 동작을 사용하는 f64-f32 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>*** IEEE 754-2008 §4.3.1에 정의된 대로: 가장 가까운 부동 소수점 숫자를 선택하고, 두 부동 소수점 숫자 사이의 정확히 중간인 경우 최하위 자릿수가 짝수인 것을 선호합니다.</p>
<div class="rule" id="r-expr.as.enum"><a class="rule-link" href="#r-expr.as.enum" title="expr.as.enum"><span>[expr<wbr>.as<wbr>.enum]<span/></a></div>
<h4 id="열거형-캐스트"><a class="header" href="#열거형-캐스트">열거형 캐스트</a></h4>
<div class="rule" id="r-expr.as.enum.discriminant"><a class="rule-link" href="#r-expr.as.enum.discriminant" title="expr.as.enum.discriminant"><span>[expr<wbr>.as<wbr>.enum<wbr>.discriminant]<span/></a></div>
<p>열거형을 판별자(discriminant)로 캐스팅한 다음 필요한 경우 숫자 캐스트를 사용합니다. 캐스팅은 다음 종류의 열거형으로 제한됩니다:</p>
<ul>
<li><a href="../items/enumerations.html#unit-only-enum">유닛 전용 열거형</a></li>
<li><a href="../items/enumerations.html#explicit-discriminants">명시적 판별자</a>가 없는 <a href="../items/enumerations.html#field-less-enum">필드 없는 열거형</a>, 또는 유닛 변형만 명시적 판별자를 갖는 경우</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum { A, B, C }
assert_eq!(Enum::A as i32, 0);
assert_eq!(Enum::B as i32, 1);
assert_eq!(Enum::C as i32, 2);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.enum.no-drop"><a class="rule-link" href="#r-expr.as.enum.no-drop" title="expr.as.enum.no-drop"><span>[expr<wbr>.as<wbr>.enum<wbr>.no-drop]<span/></a></div>
<p>열거형이 <a href="../../core/ops/drop/trait.Drop.html"><code>Drop</code></a>을 구현하는 경우 캐스팅이 허용되지 않습니다.</p>
<div class="rule" id="r-expr.as.bool-char-as-int"><a class="rule-link" href="#r-expr.as.bool-char-as-int" title="expr.as.bool-char-as-int"><span>[expr<wbr>.as<wbr>.bool-char-as-int]<span/></a></div>
<h4 id="기본-타입에서-정수로의-캐스트"><a class="header" href="#기본-타입에서-정수로의-캐스트">기본 타입에서 정수로의 캐스트</a></h4>
<ul>
<li><code>false</code>는 <code>0</code>으로, <code>true</code>는 <code>1</code>로 캐스팅됩니다</li>
<li><code>char</code>는 코드 포인트 값으로 캐스팅된 다음 필요한 경우 숫자 캐스트를 사용합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
assert_eq!('A' as i32, 65);
assert_eq!('Ö' as i32, 214);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.u8-as-char"><a class="rule-link" href="#r-expr.as.u8-as-char" title="expr.as.u8-as-char"><span>[expr<wbr>.as<wbr>.u8-as-char]<span/></a></div>
<h4 id="u8에서-char로의-캐스트"><a class="header" href="#u8에서-char로의-캐스트"><code>u8</code>에서 <code>char</code>로의 캐스트</a></h4>
<p>해당 코드 포인트를 가진 <code>char</code>로 캐스팅합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(65u8 as char, 'A');
assert_eq!(214u8 as char, 'Ö');
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.pointer-as-int"><a class="rule-link" href="#r-expr.as.pointer-as-int" title="expr.as.pointer-as-int"><span>[expr<wbr>.as<wbr>.pointer-as-int]<span/></a></div>
<h4 id="포인터에서-주소로의-캐스트"><a class="header" href="#포인터에서-주소로의-캐스트">포인터에서 주소로의 캐스트</a></h4>
<p>원시 포인터에서 정수로의 캐스팅은 참조된 메모리의 기계 주소를 생성합니다. 정수 타입이 포인터 타입보다 작은 경우 주소가 잘릴 수 있습니다. <code>usize</code>를 사용하면 이를 방지할 수 있습니다.</p>
<div class="rule" id="r-expr.as.int-as-pointer"><a class="rule-link" href="#r-expr.as.int-as-pointer" title="expr.as.int-as-pointer"><span>[expr<wbr>.as<wbr>.int-as-pointer]<span/></a></div>
<h4 id="주소에서-포인터로의-캐스트"><a class="header" href="#주소에서-포인터로의-캐스트">주소에서 포인터로의 캐스트</a></h4>
<p>정수에서 원시 포인터로의 캐스팅은 정수를 메모리 주소로 해석하고 해당 메모리를 참조하는 포인터를 생성합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 이것은 아직 개발 중인 러스트 메모리 모델과 상호 작용합니다. 이 캐스트에서 얻은 포인터는 유효한 포인터와 비트 단위로 동일하더라도 추가적인 제한을 받을 수 있습니다. 이러한 포인터를 역참조하는 것은 앨리어싱 규칙을 따르지 않을 경우 <a href="../behavior-considered-undefined.html">정의되지 않은 동작</a>이 될 수 있습니다.</p>
</blockquote>
</div>
<p>건전한 주소 연산의 간단한 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize;
let second_address = first_address + 4; // 4 == size_of::&lt;i32&gt;()
let p2 = second_address as *mut i32;
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.as.pointer"><a class="rule-link" href="#r-expr.as.pointer" title="expr.as.pointer"><span>[expr<wbr>.as<wbr>.pointer]<span/></a></div>
<h4 id="포인터에서-포인터로의-캐스트"><a class="header" href="#포인터에서-포인터로의-캐스트">포인터에서 포인터로의 캐스트</a></h4>
<div class="rule" id="r-expr.as.pointer.behavior"><a class="rule-link" href="#r-expr.as.pointer.behavior" title="expr.as.pointer.behavior"><span>[expr<wbr>.as<wbr>.pointer<wbr>.behavior]<span/></a></div>
<p><code>*const T</code> / <code>*mut T</code>는 다음과 같은 동작으로 <code>*const U</code> / <code>*mut U</code>로 캐스팅될 수 있습니다:</p>
<div class="rule" id="r-expr.as.pointer.sized"><a class="rule-link" href="#r-expr.as.pointer.sized" title="expr.as.pointer.sized"><span>[expr<wbr>.as<wbr>.pointer<wbr>.sized]<span/></a></div>
<ul>
<li><code>T</code>와 <code>U</code>가 모두 크기가 있는(sized) 경우, 포인터는 변경되지 않고 반환됩니다.</li>
</ul>
<div class="rule" id="r-expr.as.pointer.unsized"><a class="rule-link" href="#r-expr.as.pointer.unsized" title="expr.as.pointer.unsized"><span>[expr<wbr>.as<wbr>.pointer<wbr>.unsized]<span/></a></div>
<ul>
<li>
<p><code>T</code>와 <code>U</code>가 모두 크기가 없는(unsized) 경우, 포인터도 변경되지 않고 반환됩니다. 특히 메타데이터는 정확하게 보존됩니다.</p>
<p>예를 들어, <code>*const [T]</code>에서 <code>*const [U]</code>로의 캐스트는 요소 수를 보존합니다. 결과적으로 이러한 캐스트는 포인터가 참조하는 대상의 크기를 반드시 보존하지는 않는다는 점에 유의하십시오(예: <code>*const [u16]</code>을 <code>*const [u8]</code>로 캐스팅하면 원본 크기의 절반인 객체를 참조하는 원시 포인터가 됩니다). <code>str</code> 및 <code>struct Foo(i32, [u8])</code> 또는 <code>(u64, Foo)</code>와 같이 크기가 없는 꼬리가 슬라이스 타입인 복합 타입에도 동일하게 적용됩니다.</p>
</li>
</ul>
<div class="rule" id="r-expr.as.pointer.discard-metadata"><a class="rule-link" href="#r-expr.as.pointer.discard-metadata" title="expr.as.pointer.discard-metadata"><span>[expr<wbr>.as<wbr>.pointer<wbr>.discard-metadata]<span/></a></div>
<ul>
<li><code>T</code>는 크기가 없고 <code>U</code>는 크기가 있는 경우, 캐스트는 넓은 포인터(wide pointer) <code>T</code>를 완성하는 모든 메타데이터를 버리고 크기가 없는 포인터의 데이터 부분으로 구성된 얇은 포인터(thin pointer) <code>U</code>를 생성합니다.</li>
</ul>
<div class="rule" id="r-expr.assign"><a class="rule-link" href="#r-expr.assign" title="expr.assign"><span>[expr<wbr>.assign]<span/></a></div>
<h2 id="할당-표현식"><a class="header" href="#할당-표현식">할당 표현식</a></h2>
<div class="rule" id="r-expr.assign.syntax"><a class="rule-link" href="#r-expr.assign.syntax" title="expr.assign.syntax"><span>[expr<wbr>.assign<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>할당표현식</em> :<br />
   <a href="../expressions.html"><em>표현식</em></a> <code>=</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.assign.intro"><a class="rule-link" href="#r-expr.assign.intro" title="expr.assign.intro"><span>[expr<wbr>.assign<wbr>.intro]<span/></a></div>
<p>_할당 표현식_은 값을 지정된 장소로 이동합니다.</p>
<div class="rule" id="r-expr.assign.assignee"><a class="rule-link" href="#r-expr.assign.assignee" title="expr.assign.assignee"><span>[expr<wbr>.assign<wbr>.assignee]<span/></a></div>
<p>할당 표현식은 <a href="../expressions.html#mutability">가변</a> <a href="../expressions.html#place-expressions-and-value-expressions">피할당자 표현식</a>(<em>피할당자 피연산자</em>)과 그 뒤에 오는 등호(<code>=</code>), 그리고 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>할당된 값 피연산자</em>)으로 구성됩니다.</p>
<div class="rule" id="r-expr.assign.behavior-basic"><a class="rule-link" href="#r-expr.assign.behavior-basic" title="expr.assign.behavior-basic"><span>[expr<wbr>.assign<wbr>.behavior-basic]<span/></a></div>
<p>가장 기본적인 형태에서, 피할당자 표현식은 <a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>이며, 이 경우를 먼저 논의합니다.</p>
<div class="rule" id="r-expr.assign.behavior-destructring"><a class="rule-link" href="#r-expr.assign.behavior-destructring" title="expr.assign.behavior-destructring"><span>[expr<wbr>.assign<wbr>.behavior-destructring]<span/></a></div>
<p>더 일반적인 구조 분해 할당의 경우는 아래에서 논의되지만, 이 경우는 항상 장소 표현식에 대한 순차적인 할당으로 분해되므로, 장소 표현식 할당이 더 근본적인 경우로 간주될 수 있습니다.</p>
<div class="rule" id="r-expr.assign.basic"><a class="rule-link" href="#r-expr.assign.basic" title="expr.assign.basic"><span>[expr<wbr>.assign<wbr>.basic]<span/></a></div>
<h3 id="기본-할당"><a class="header" href="#기본-할당">기본 할당</a></h3>
<div class="rule" id="r-expr.assign.evaluation-order"><a class="rule-link" href="#r-expr.assign.evaluation-order" title="expr.assign.evaluation-order"><span>[expr<wbr>.assign<wbr>.evaluation-order]<span/></a></div>
<p>할당 표현식의 평가는 피연산자의 평가로 시작됩니다. 할당된 값 피연산자가 먼저 평가되고, 그 다음에 피할당자 표현식이 평가됩니다.</p>
<div class="rule" id="r-expr.assign.destructring-order"><a class="rule-link" href="#r-expr.assign.destructring-order" title="expr.assign.destructring-order"><span>[expr<wbr>.assign<wbr>.destructring-order]<span/></a></div>
<p>구조 분해 할당의 경우, 피할당자 표현식의 하위 표현식은 왼쪽에서 오른쪽으로 평가됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 이것은 오른쪽 피연산자가 왼쪽 피연산자보다 먼저 평가된다는 점에서 다른 표현식과 다릅니다.</p>
</blockquote>
<div class="rule" id="r-expr.assign.drop-target"><a class="rule-link" href="#r-expr.assign.drop-target" title="expr.assign.drop-target"><span>[expr<wbr>.assign<wbr>.drop-target]<span/></a></div>
<p>그런 다음 할당된 장소의 값이 초기화되지 않은 지역 변수나 초기화되지 않은 지역 변수의 필드가 아닌 경우, 할당된 장소의 값을 먼저 <a href="../destructors.html">드랍</a>하는 효과를 가집니다.</p>
<div class="rule" id="r-expr.assign.behavior"><a class="rule-link" href="#r-expr.assign.behavior" title="expr.assign.behavior"><span>[expr<wbr>.assign<wbr>.behavior]<span/></a></div>
<p>그 다음 할당된 값을 할당된 장소로 <a href="../expressions.html#moved-and-copied-types">복사하거나 이동</a>합니다.</p>
<div class="rule" id="r-expr.assign.result"><a class="rule-link" href="#r-expr.assign.result" title="expr.assign.result"><span>[expr<wbr>.assign<wbr>.result]<span/></a></div>
<p>할당 표현식은 항상 <a href="../types/tuple.html">유닛 값</a>을 생성합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
let y = 0;
x = y;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure"><a class="rule-link" href="#r-expr.assign.destructure" title="expr.assign.destructure"><span>[expr<wbr>.assign<wbr>.destructure]<span/></a></div>
<h3 id="구조-분해-할당"><a class="header" href="#구조-분해-할당">구조 분해 할당</a></h3>
<div class="rule" id="r-expr.assign.destructure.intro"><a class="rule-link" href="#r-expr.assign.destructure.intro" title="expr.assign.destructure.intro"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.intro]<span/></a></div>
<p>구조 분해 할당은 변수 선언을 위한 구조 분해 패턴 매칭의 대응으로, 튜플이나 구조체와 같은 복합 값에 대한 할당을 허용합니다. 예를 들어, 두 개의 가변 변수를 교환할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (0, 1);
// 구조 분해 할당을 사용하여 `a`와 `b`를 교환합니다.
(b, a) = (a, b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure.assignee"><a class="rule-link" href="#r-expr.assign.destructure.assignee" title="expr.assign.destructure.assignee"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.assignee]<span/></a></div>
<p><code>let</code>을 사용한 구조 분해 선언과 달리, 구문상의 모호성 때문에 패턴은 할당의 왼쪽에 나타날 수 없습니다. 대신 패턴에 해당하는 표현식 그룹이 <a href="../expressions.html#place-expressions-and-value-expressions">피할당자 표현식</a>으로 지정되어 할당의 왼쪽에 허용됩니다. 피할당자 표현식은 그런 다음 패턴 매칭과 순차적 할당으로 탈설탕(desugared)됩니다.</p>
<div class="rule" id="r-expr.assign.destructure.irrefutable"><a class="rule-link" href="#r-expr.assign.destructure.irrefutable" title="expr.assign.destructure.irrefutable"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.irrefutable]<span/></a></div>
<p>탈설탕된 패턴은 반박할 수 없어야 합니다(irrefutable). 특히 이는 컴파일 타임에 길이가 알려진 슬라이스 패턴과 사소한 슬라이스 <code>[..]</code>만이 구조 분해 할당에 허용됨을 의미합니다.</p>
<p>탈설탕 방법은 간단하며, 예제로 설명하는 것이 가장 좋습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct { x: u32, y: u32 }
</span><span class="boring">let (mut a, mut b) = (0, 0);
</span>(a, b) = (3, 4);

[a, b] = [3, 4];

Struct { x: a, y: b } = Struct { x: 3, y: 4};

// 다음과 같이 탈설탕됩니다:

{
    let (_a, _b) = (3, 4);
    a = _a;
    b = _b;
}

{
    let [_a, _b] = [3, 4];
    a = _a;
    b = _b;
}

{
    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};
    a = _a;
    b = _b;
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.assign.destructure.repeat-ident"><a class="rule-link" href="#r-expr.assign.destructure.repeat-ident" title="expr.assign.destructure.repeat-ident"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.repeat-ident]<span/></a></div>
<p>단일 피할당자 표현식에서 식별자를 여러 번 사용하는 것은 금지되지 않습니다.</p>
<div class="rule" id="r-expr.assign.destructure.discard-value"><a class="rule-link" href="#r-expr.assign.destructure.discard-value" title="expr.assign.destructure.discard-value"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.discard-value]<span/></a></div>
<p><a href="./underscore-expr.html">밑줄 표현식</a>과 빈 <a href="./range-expr.html">범위 표현식</a>을 사용하여 특정 값을 바인딩하지 않고 무시할 수 있습니다.</p>
<div class="rule" id="r-expr.assign.destructure.default-binding"><a class="rule-link" href="#r-expr.assign.destructure.default-binding" title="expr.assign.destructure.default-binding"><span>[expr<wbr>.assign<wbr>.destructure<wbr>.default-binding]<span/></a></div>
<p>탈설탕된 표현식에는 기본 바인딩 모드가 적용되지 않는다는 점에 유의하십시오.</p>
<div class="rule" id="r-expr.compound-assign"><a class="rule-link" href="#r-expr.compound-assign" title="expr.compound-assign"><span>[expr<wbr>.compound-assign]<span/></a></div>
<h2 id="복합-할당-표현식"><a class="header" href="#복합-할당-표현식">복합 할당 표현식</a></h2>
<div class="rule" id="r-expr.compound-assign.syntax"><a class="rule-link" href="#r-expr.compound-assign.syntax" title="expr.compound-assign.syntax"><span>[expr<wbr>.compound-assign<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>복합할당표현식</em> :<br />
      <a href="../expressions.html"><em>표현식</em></a> <code>+=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>-=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>*=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>/=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>%=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&amp;=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>|=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>^=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&lt;&lt;=</code> <a href="../expressions.html"><em>표현식</em></a><br />
   | <a href="../expressions.html"><em>표현식</em></a> <code>&gt;&gt;=</code> <a href="../expressions.html"><em>표현식</em></a></p>
</blockquote>
<div class="rule" id="r-expr.compound-assign.intro"><a class="rule-link" href="#r-expr.compound-assign.intro" title="expr.compound-assign.intro"><span>[expr<wbr>.compound-assign<wbr>.intro]<span/></a></div>
<p>_복합 할당 표현식_은 산술 및 논리 이항 연산자와 할당 표현식을 결합한 것입니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 1;
assert!(x == 6);
<span class="boring">}</span></code></pre></pre>
<p>복합 할당의 구문은 <a href="../expressions.html#mutability">가변</a> <a href="../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>(<em>할당된 피연산자</em>), 그 다음에 단일 토큰(공백 없음)으로 <code>=</code>이 뒤따르는 연산자 중 하나, 그리고 <a href="../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>수정하는 피연산자</em>)입니다.</p>
<div class="rule" id="r-expr.compound-assign.place"><a class="rule-link" href="#r-expr.compound-assign.place" title="expr.compound-assign.place"><span>[expr<wbr>.compound-assign<wbr>.place]<span/></a></div>
<p>다른 장소 피연산자와 달리, 할당된 장소 피연산자는 반드시 장소 표현식이어야 합니다.</p>
<div class="rule" id="r-expr.compound-assign.no-value"><a class="rule-link" href="#r-expr.compound-assign.no-value" title="expr.compound-assign.no-value"><span>[expr<wbr>.compound-assign<wbr>.no-value]<span/></a></div>
<p>값 표현식을 사용하려고 시도하면 이를 임시 값으로 승격시키는 대신 컴파일러 오류가 발생합니다.</p>
<div class="rule" id="r-expr.compound-assign.operand-order"><a class="rule-link" href="#r-expr.compound-assign.operand-order" title="expr.compound-assign.operand-order"><span>[expr<wbr>.compound-assign<wbr>.operand-order]<span/></a></div>
<p>복합 할당 표현식의 평가는 연산자의 타입에 따라 다릅니다.</p>
<div class="rule" id="r-expr.compound-assign.primitive-order"><a class="rule-link" href="#r-expr.compound-assign.primitive-order" title="expr.compound-assign.primitive-order"><span>[expr<wbr>.compound-assign<wbr>.primitive-order]<span/></a></div>
<p>두 타입이 모두 기본 타입인 경우, 수정하는 피연산자가 먼저 평가된 다음 할당된 피연산자가 평가됩니다. 그런 다음 할당된 피연산자와 수정하는 피연산자의 값으로 연산자의 연산을 수행한 값으로 할당된 피연산자 장소의 값을 설정합니다.</p>
<blockquote>
<p><strong>참고</strong>: 이것은 오른쪽 피연산자가 왼쪽 피연산자보다 먼저 평가된다는 점에서 다른 표현식과 다릅니다.</p>
</blockquote>
<div class="rule" id="r-expr.compound-assign.trait"><a class="rule-link" href="#r-expr.compound-assign.trait" title="expr.compound-assign.trait"><span>[expr<wbr>.compound-assign<wbr>.trait]<span/></a></div>
<p>그렇지 않으면, 이 표현식은 연산자의 오버로딩 복합 할당 트레잇의 함수를 호출하기 위한 구문 설탕입니다(이 장의 앞부분에 있는 표 참조). 할당된 피연산자의 가변 차용이 자동으로 취해집니다.</p>
<p>예를 들어, <code>example</code>의 다음 표현식 문은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Addable;
</span><span class="boring">use std::ops::AddAssign;
</span>
impl AddAssign&lt;Addable&gt; for Addable {
    /* */
<span class="boring">fn add_assign(&amp;mut self, other: Addable) {}
</span>}

fn example() {
<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  a1 += a2;

<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  AddAssign::add_assign(&amp;mut a1, a2);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-expr.compound-assign.result"><a class="rule-link" href="#r-expr.compound-assign.result" title="expr.compound-assign.result"><span>[expr<wbr>.compound-assign<wbr>.result]<span/></a></div>
<p>할당 표현식과 마찬가지로, 복합 할당 표현식은 항상 <a href="../types/tuple.html">유닛 값</a>을 생성합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> 피연산자의 평가 순서는 피연산자의 타입에 따라 바뀝니다. 기본 타입의 경우 오른쪽이 먼저 평가되고, 비기본 타입의 경우 왼쪽이 먼저 평가됩니다. 복합 할당 표현식에서 피연산자의 평가 순서에 의존하는 코드를 작성하지 않도록 하십시오. 이 의존성을 사용하는 예는 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs">이 테스트</a>를 참조하십시오.</p>
</blockquote>
</div>
<script>
(function() {
    var fragments = {
        "#slice-dst-pointer-to-pointer-cast": "operator-expr.html#pointer-to-pointer-cast",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../expressions/block-expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../expressions/grouped-expr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../expressions/block-expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../expressions/grouped-expr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
