<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>상수 평가 (Constant evaluation) - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/const_eval.md`;
                    } else {
                        canonical_href = `${base}/${lang}/const_eval.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/const_eval.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[const-eval]</p>
<h1 id="상수-평가-constant-evaluation"><a class="header" href="#상수-평가-constant-evaluation">상수 평가 (Constant evaluation)</a></h1>
<p>r[const-eval.general] Constant evaluation is the process of computing the result of <a href="expressions.html">expressions</a> during compilation. Only a subset of all expressions can be evaluated at compile-time.</p>
<p>r[const-eval.const-expr]</p>
<h2 id="상수-표현식"><a class="header" href="#상수-표현식">상수 표현식</a></h2>
<p>r[const-eval.const-expr.general] Certain forms of expressions, called constant expressions, can be evaluated at compile time.</p>
<p>r[const-eval.const-expr.const-context] Expressions in a <a href="#const-context">const context</a> must be constant expressions.</p>
<p>r[const-eval.const-expr.evaluation] Expressions in const contexts are always evaluated at compile time.</p>
<p>r[const-eval.const-expr.runtime-context] Outside of const contexts, constant expressions <em>may</em> be, but are not guaranteed to be, evaluated at compile time.</p>
<p>r[const-eval.const-expr.error] Behaviors such as out of bounds <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="expressions/operator-expr.html#overflow">overflow</a> are compiler errors if the value must be evaluated at compile time (i.e. in const contexts). Otherwise, these behaviors are warnings, but will likely panic at run-time.</p>
<p>r[const-eval.const-expr.list] The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any <a href="destructors.html"><code>Drop::drop</code></a> calls to be run.</p>
<p>r[const-eval.const-expr.literal]</p>
<ul>
<li><a href="expressions/literal-expr.html">리터럴</a>.</li>
</ul>
<p>r[const-eval.const-expr.parameter]</p>
<ul>
<li><a href="items/generics.html">상수 파라미터</a>.</li>
</ul>
<p>r[const-eval.const-expr.path-item]</p>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="items/constant-items.html">상수</a>에 대한 <a href="expressions/path-expr.html">경로</a>. 상수를 재귀적으로 정의하는 것은 허용되지 않습니다.</li>
</ul>
<p>r[const-eval.const-expr.path-static]</p>
<ul>
<li>
<p>다음 제약 사항이 있는 <a href="items/static-items.html">정적 변수(statics)</a>에 대한 경로:</p>
<ul>
<li><code>static</code> 아이템에 쓰는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li><code>extern</code> 정적 변수로부터 읽는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li>평가가 <code>static</code> 아이템의 초기화 식 내에서 수행되는 것이 <em>아니라면</em>, 가변 <code>static</code>으로부터 읽는 것은 허용되지 않습니다. 가변 <code>static</code>은 <code>static mut</code> 아이템이거나, 내부 가변성(interior-mutable) 타입을 가진 <code>static</code> 아이템을 의미합니다.
이러한 요구 사항들은 상수가 평가될 때만 확인됩니다. 다시 말해, 이러한 접근이 상수 컨텍스트에서 구문상으로 나타나는 것은 실제로 실행되지 않는 한 허용됩니다.</li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.tuple]</p>
<ul>
<li><a href="expressions/tuple-expr.html">튜플 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.array]</p>
<ul>
<li><a href="expressions/array-expr.html">배열 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.constructor]</p>
<ul>
<li><a href="expressions/struct-expr.html">Struct expressions</a>.</li>
</ul>
<p>r[const-eval.const-expr.block]</p>
<ul>
<li><code>unsafe</code> 및 <code>const</code> 블록을 포함한 <a href="expressions/block-expr.html">블록 표현식</a>.
<ul>
<li><a href="statements.html#let-statements">let 문</a> 및 그에 따른 가변 바인딩을 포함한 반박 불가능한(irrefutable) <a href="patterns.html">패턴</a></li>
<li><a href="expressions/operator-expr.html#assignment-expressions">대입 표현식</a></li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 대입 표현식</a></li>
<li><a href="statements.html#expression-statements">표현식 구문</a></li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.field]</p>
<ul>
<li><a href="expressions/field-expr.html">필드</a> 표현식.</li>
</ul>
<p>r[const-eval.const-expr.index]</p>
<ul>
<li>인덱스 표현식, <code>usize</code>를 사용한 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a> 또는 <a href="types/slice.html">슬라이스</a>.</li>
</ul>
<p>r[const-eval.const-expr.range]</p>
<ul>
<li><a href="expressions/range-expr.html">범위 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.closure]</p>
<ul>
<li>환경으로부터 변수를 캡처하지 않는 <a href="expressions/closure-expr.html">클로저 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.builtin-arith-logic]</p>
<ul>
<li>정수 및 부동 소수점 타입, <code>bool</code>, <code>char</code>에 사용되는 내장 <a href="expressions/operator-expr.html#negation-operators">부정</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">산술</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">논리</a>, <a href="expressions/operator-expr.html#comparison-operators">비교</a> 또는 <a href="expressions/operator-expr.html#lazy-boolean-operators">지연 평가 불리언(lazy boolean)</a> 연산자.</li>
</ul>
<p>r[const-eval.const-expr.borrows]</p>
<ul>
<li>
<p>All forms of <a href="expressions/operator-expr.html#borrow-operators">borrow</a>s, including raw borrows, except borrows of expressions whose temporary scopes would be extended (see <a href="destructors.scope.lifetime-extension">temporary lifetime extension</a>) to the end of the program and which are either:</p>
<ul>
<li>Mutable borrows.</li>
<li>Shared borrows of expressions that result in values with <a href="interior-mutability.html">interior mutability</a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Due to being in tail position, this borrow extends the scope of the
// temporary to the end of the program. Since the borrow is mutable,
// this is not allowed in a const expression.
const C: &amp;u8 = &amp;mut 0; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Const blocks are similar to initializers of `const` items.
let _: &amp;u8 = const { &amp;mut 0 }; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0492 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// This is not allowed as 1) the temporary scope is extended to the
// end of the program and 2) the temporary has interior mutability.
const C: &amp;AtomicU8 = &amp;AtomicU8::new(0); // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0492 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// As above.
let _: &amp;_ = const { &amp;AtomicU8::new(0) }; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(static_mut_refs)]
</span>// Even though this borrow is mutable, it's not of a temporary, so
// this is allowed.
const C: &amp;u8 = unsafe { static mut S: u8 = 0; &amp;mut S }; // OK
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// Even though this borrow is of a value with interior mutability,
// it's not of a temporary, so this is allowed.
const C: &amp;AtomicU8 = {
    static S: AtomicU8 = AtomicU8::new(0); &amp;S // OK
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// This shared borrow of an interior mutable temporary is allowed
// because its scope is not extended.
const C: () = { _ = &amp;AtomicU8::new(0); }; // OK
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Even though the borrow is mutable and the temporary lives to the
// end of the program due to promotion, this is allowed because the
// borrow is not in tail position and so the scope of the temporary
// is not extended via temporary lifetime extension.
const C: () = { let _: &amp;'static mut [u8] = &amp;mut []; }; // OK
//                                              ~~
//                                     Promoted temporary.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In other words — to focus on what’s allowed rather than what’s not allowed — shared borrows of interior mutable data and mutable borrows are only allowed in a <a href="#const-context">const context</a> when the borrowed <a href="expr.place-value.place-memory-location">place expression</a> is <em>transient</em>, <em>indirect</em>, or <em>static</em>.</p>
<p>A place expression is <em>transient</em> if it is a variable local to the current const context or an expression whose temporary scope is contained inside the current const context.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The borrow is of a variable local to the initializer, therefore
// this place expression is transient.
const C: () = { let mut x = 0; _ = &amp;mut x; };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The borrow is of a temporary whose scope has not been extended,
// therefore this place expression is transient.
const C: () = { _ = &amp;mut 0u8; };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When a temporary is promoted but not lifetime extended, its
// place expression is still treated as transient.
const C: () = { let _: &amp;'static mut [u8] = &amp;mut []; };
<span class="boring">}</span></code></pre></pre>
<p>A place expression is <em>indirect</em> if it is a <a href="expr.deref">dereference expression</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: () = { _ = &amp;mut *(&amp;mut 0); };
<span class="boring">}</span></code></pre></pre>
<p>A place expression is <em>static</em> if it is a <code>static</code> item.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(static_mut_refs)]
</span>const C: &amp;u8 = unsafe { static mut S: u8 = 0; &amp;mut S };
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] One surprising consequence of these rules is that we allow this,</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;[u8] = { let x: &amp;mut [u8] = &amp;mut []; x }; // OK
//                                    ~~~~~~~
// Empty arrays are promoted even behind mutable borrows.
<span class="boring">}</span></code></pre></pre>
<p>but we disallow this similar code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;[u8] = &amp;mut []; // 오류
//               ~~~~~~~
//           Tail expression.
<span class="boring">}</span></code></pre></pre>
<p>The difference between these is that, in the first, the empty array is <a href="destructors.html#constant-promotion">promoted</a> but its scope does not undergo <a href="destructors.scope.lifetime-extension">temporary lifetime extension</a>, so we consider the <a href="expr.place-value.place-memory-location">place expression</a> to be transient (even though after promotion the place indeed lives to the end of the program). In the second, the scope of the empty array temporary does undergo lifetime extension, and so it is rejected due to being a mutable borrow of a lifetime-extended temporary (and therefore borrowing a non-transient place expression).</p>
<p>The effect is surprising because temporary lifetime extension, in this case, causes less code to compile than would without it.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/143129">issue #143129</a> for more details.</p>
</blockquote>
</li>
</ul>
<p>r[const-eval.const-expr.deref]</p>
<ul>
<li>
<p><a href="expr.deref">Dereference expressions</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::cell::UnsafeCell;
</span>const _: u8 = unsafe {
    let x: *mut u8 = &amp;raw mut *&amp;mut 0;
    //                        ^^^^^^^
    //             Dereference of mutable reference.
    *x = 1; // Dereference of mutable pointer.
    *(x as *const u8) // Dereference of constant pointer.
};
const _: u8 = unsafe {
    let x = &amp;UnsafeCell::new(0);
    *x.get() = 1; // Mutation of interior mutable value.
    *x.get()
};
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[const-eval.const-expr.group]</p>
<ul>
<li><a href="expressions/grouped-expr.html">그룹화된(Grouped)</a> 표현식.</li>
</ul>
<p>r[const-eval.const-expr.cast]</p>
<ul>
<li>다음 경우를 제외한 <a href="expressions/operator-expr.html#type-cast-expressions">캐스트</a> 표현식:
<ul>
<li>포인터를 주소로 변환하는 캐스트 및</li>
<li>함수 포인터를 주소로 변환하는 캐스트.</li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.const-fn]</p>
<ul>
<li><a href="items/functions.html#const-functions">상수 함수(const functions)</a> 및 상수 메서드 호출.</li>
</ul>
<p>r[const-eval.const-expr.loop]</p>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops">loop</a> and <a href="expressions/loop-expr.html#predicate-loops">while</a> expressions.</li>
</ul>
<p>r[const-eval.const-expr.if-match]</p>
<ul>
<li><a href="expressions/if-expr.html#if-expressions">if</a> and <a href="expressions/match-expr.html">match</a> expressions.</li>
</ul>
<p>r[const-eval.const-context]</p>
<h2 id="상수-컨텍스트-const-context"><a class="header" href="#상수-컨텍스트-const-context">상수 컨텍스트 (Const context)</a></h2>
<p>r[const-eval.const-context.general] A <em>const context</em> is one of the following:</p>
<p>r[const-eval.const-context.array-length]</p>
<ul>
<li><a href="types/array.html">배열 타입 길이 표현식</a></li>
</ul>
<p>r[const-eval.const-context.repeat-length]</p>
<ul>
<li><a href="expressions/array-expr.html">배열 반복 길이 표현식</a></li>
</ul>
<p>r[const-eval.const-context.init]</p>
<ul>
<li>다음의 초기화 식:
<ul>
<li><a href="items/constant-items.html">상수(constants)</a></li>
<li><a href="items/static-items.html">정적 변수(statics)</a></li>
<li><a href="items/enumerations.html#discriminants">열거형 판별자(enum discriminants)</a></li>
</ul>
</li>
</ul>
<p>r[const-eval.const-context.generic]</p>
<ul>
<li><a href="items/generics.html#const-generics">상수 제네릭 인자(const generic argument)</a></li>
</ul>
<p>r[const-eval.const-context.block]</p>
<ul>
<li><a href="expressions/block-expr.html#const-blocks">상수 블록(const block)</a></li>
</ul>
<p>r[const-eval.const-context.outer-generics] Const contexts that are used as parts of types (array type and repeat length expressions as well as const generic arguments) can only make restricted use of surrounding generic parameters: such an expression must either be a single bare const generic parameter, or an arbitrary expression not making use of any generics.</p>
<p>r[const-eval.const-fn]</p>
<h2 id="const-함수"><a class="header" href="#const-함수">const 함수</a></h2>
<p>r[const-eval.const-fn.intro] A <em>const function</em> is a function that can be called from a const context. It is defined with the <code>const</code> qualifier, and also includes <a href="items/structs.html">tuple struct</a> and <a href="items/enumerations.html">tuple enum variant</a> constructors.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn square(x: i32) -&gt; i32 { x * x }

const VALUE: i32 = square(12);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[const-eval.const-fn.const-context] When called from a const context, a const function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So <code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p>
<p>r[const-eval.const-fn.outside-context] When a const function is called from outside a const context, it behaves the same as if it did not have the <code>const</code> qualifier.</p>
<p>r[const-eval.const-fn.body-restriction] The body of a const function may only use <a href="#constant-expressions">constant expressions</a>.</p>
<p>r[const-eval.const-fn.async] Const functions are not allowed to be <a href="items/functions.html#async-functions">async</a>.</p>
<p>r[const-eval.const-fn.type-restrictions] The types of a const function’s parameters and return type are restricted to those that are compatible with a const context.</p>
<!-- TODO: Define the type restrictions. -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="behavior-not-considered-unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="abi.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="behavior-not-considered-unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="abi.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
