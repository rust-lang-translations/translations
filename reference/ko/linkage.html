<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>연결 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/linkage.md`;
                    } else {
                        canonical_href = `${base}/${lang}/linkage.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/linkage.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[link]</p>
<h1 id="연결"><a class="header" href="#연결">연결</a></h1>
<blockquote>
<p>[!NOTE] This section is described more in terms of the compiler than of the language.</p>
</blockquote>
<p>r[link.intro] The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the <a href="../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">FFI section of the book</a>.</p>
<p>r[link.type] In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the <code>crate_type</code> attribute. If one or more command line flags are specified, all <code>crate_type</code> attributes will be ignored in favor of only building the artifacts specified by command line.</p>
<p>r[link.bin]</p>
<ul>
<li><code>--crate-type=bin</code>, <code>#![crate_type = "bin"]</code> - 실행 가능한 프로그램이 생성됩니다. 이 경우 프로그램이 실행될 때 호출될 <code>main</code> 함수가 크레이트 내에 반드시 있어야 합니다. 모든 러스트 및 네이티브 의존성을 링크하여 배포 가능한 단일 바이너리를 생성합니다. 이것이 기본 크레이트 타입입니다.</li>
</ul>
<p>r[link.lib]</p>
<ul>
<li><code>--crate-type=lib</code>, <code>#![crate_type = "lib"]</code> - 러스트 라이브러리가 생성됩니다. 라이브러리는 여러 형태로 나타날 수 있기 때문에 무엇이 정확히 생성되는지는 모호할 수 있습니다. 이 일반적인 <code>lib</code> 옵션의 목적은 “컴파일러가 권장하는” 스타일의 라이브러리를 생성하는 것입니다. 생성된 라이브러리는 항상 rustc에서 사용할 수 있지만, 실제 라이브러리 타입은 수시로 바뀔 수 있습니다. 나머지 출력 타입들은 모두 서로 다른 종류의 라이브러리들이며, <code>lib</code> 타입은 그 중 하나에 대한 별칭으로 볼 수 있습니다(실제 타입은 컴파일러가 정의합니다).</li>
</ul>
<p>r[link.dylib]</p>
<ul>
<li><code>--crate-type=dylib</code>, <code>#![crate_type = "dylib"]</code> - 동적 러스트 라이브러리가 생성됩니다. 이는 <code>lib</code> 출력 타입과 달리 동적 라이브러리 생성을 강제합니다. 생성된 동적 라이브러리는 다른 라이브러리나 실행 파일의 의존성으로 사용될 수 있습니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<p>r[link.staticlib]</p>
<ul>
<li>
<p><code>--crate-type=staticlib</code>, <code>#![crate_type = "staticlib"]</code> - 정적 시스템 라이브러리가 생성됩니다. 이는 다른 라이브러리 출력과 달리, 컴파일러가 <code>staticlib</code> 출력에 링크하려고 시도하지 않습니다. 이 출력 타입의 목적은 로컬 크레이트의 모든 코드와 모든 업스트림 의존성을 포함하는 정적 라이브러리를 만드는 것입니다. 이 출력 타입은 리눅스, macOS 및 윈도우(MinGW)에서는 <code>*.a</code> 파일을, 윈도우(MSVC)에서는 <code>*.lib</code> 파일을 생성합니다. 이 형식은 다른 러스트 코드에 대한 동적 의존성이 없기 때문에, 기존의 비-러스트 애플리케이션에 러스트 코드를 링크하는 것과 같은 상황에서 사용하는 것을 권장합니다.</p>
<p>정적 라이브러리가 가질 수 있는 모든 동적 의존성(예: 시스템 라이브러리에 대한 의존성, 또는 동적 라이브러리로 컴파일된 러스트 라이브러리에 대한 의존성)은 해당 정적 라이브러리를 어딘가에서 링크할 때 수동으로 지정해야 함에 유의하십시오. <code>--print=native-static-libs</code> 플래그가 이 작업에 도움이 될 수 있습니다.</p>
<p>생성된 정적 라이브러리는 표준 라이브러리를 포함한 모든 의존성의 코드를 포함하고 이들의 모든 공개 심볼을 내보내기 때문에, 정적 라이브러리를 실행 파일이나 공유 라이브러리에 링크할 때는 특별한 주의가 필요할 수 있음에 유의하십시오. 공유 라이브러리의 경우, 내보낼 심볼 목록을 링커나 심볼 버전 스크립트, 내보낸 심볼 목록(macOS) 또는 모듈 정의 파일(윈도우) 등을 통해 제한해야 합니다. 또한, 실제로 사용되지 않는 의존성 코드를 모두 제거하기 위해 사용되지 않는 섹션을 제거할 수 있습니다 (예: <code>--gc-sections</code> 또는 macOS의 <code>-dead_strip</code>).</p>
</li>
</ul>
<p>r[link.cdylib]</p>
<ul>
<li><code>--crate-type=cdylib</code>, <code>#![crate_type = "cdylib"]</code> - 동적 시스템 라이브러리가 생성됩니다. 이는 다른 언어에서 로드할 동적 라이브러리를 컴파일할 때 사용됩니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<p>r[link.rlib]</p>
<ul>
<li><code>--crate-type=rlib</code>, <code>#![crate_type = "rlib"]</code> - “러스트 라이브러리” 파일이 생성됩니다. 이는 중간 생성물로 사용되며 “정적 러스트 라이브러리“라고 생각할 수 있습니다. 이러한 <code>rlib</code> 파일은 <code>staticlib</code> 파일과 달리 향후 링크 시 컴파일러에 의해 해석됩니다. 이는 본질적으로 <code>rustc</code>가 동적 라이브러리에서 메타데이터를 찾는 것처럼 <code>rlib</code> 파일에서도 메타데이터를 찾는다는 것을 의미합니다. 이 출력 형식은 정적으로 링크된 실행 파일과 <code>staticlib</code> 출력을 생성하는 데 사용됩니다.</li>
</ul>
<p>r[link.proc-macro]</p>
<ul>
<li><code>--crate-type=proc-macro</code>, <code>#![crate_type = "proc-macro"]</code> - 생성되는 출력은 명시되지 않았지만, <code>-L</code> 경로가 제공되면 컴파일러는 출력 결과물을 매크로로 인식하고 프로그램에 로드할 수 있습니다. 이 크레이트 타입으로 컴파일된 크레이트는 반드시 <a href="procedural-macros.html">절차적 매크로</a>만 내보내야 합니다. 컴파일러는 자동으로 <code>proc_macro</code> <a href="conditional-compilation.html">설정 옵션</a>을 설정합니다. 크레이트는 항상 컴파일러 자체가 빌드된 것과 동일한 타겟으로 컴파일됩니다. 예를 들어, 리눅스 <code>x86_64</code> CPU에서 컴파일러를 실행 중이라면, 다른 타겟을 위해 빌드 중인 다른 크레이트의 의존성일지라도 타겟은 <code>x86_64-unknown-linux-gnu</code>가 됩니다.</li>
</ul>
<p>r[link.repetition] Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output without having to recompile. However, this only applies for outputs specified by the same method. If only <code>crate_type</code> attributes are specified, then they will all be built, but if one or more <code>--crate-type</code> command line flags are specified, then only those outputs will be built.</p>
<p>r[link.dependency] With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the <code>rlib</code> format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</p>
<p>r[link.dependency-staticlib]</p>
<ol>
<li>
<p>정적 라이브러리가 생성되는 경우, 모든 업스트림 의존성은 <code>rlib</code> 형식으로 사용 가능해야 합니다. 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환할 수 없다는 이유에서 비롯됩니다.</p>
<p>정적 라이브러리에 네이티브 동적 의존성을 링크하는 것은 불가능하며, 이 경우 링크되지 않은 모든 네이티브 동적 의존성에 대한 경고가 출력됨에 유의하십시오.</p>
</li>
</ol>
<p>r[link.dependency-rlib]</p>
<ol start="2">
<li>
<p><code>rlib</code> 파일이 생성되는 경우, 업스트림 의존성이 어떤 형식으로 제공되는지에 대한 제한은 없습니다. 단지 메타데이터를 읽기 위해 모든 업스트림 의존성이 사용 가능해야 합니다.</p>
<p><code>rlib</code> 파일이 <code>libstd.rlib</code> 사본을 포함한다면 그다지 효율적이지 않을 것입니다!</p>
</li>
</ol>
<p>r[link.dependency-prefer-dynamic]</p>
<ol start="3">
<li>실행 파일이 생성되고 <code>-C prefer-dynamic</code> 플래그가 지정되지 않은 경우, 먼저 <code>rlib</code> 형식의 의존성을 찾으려고 시도합니다. 일부 의존성을 rlib 형식으로 사용할 수 없는 경우, 동적 링크가 시도됩니다(아래 참조).</li>
</ol>
<p>r[link.dependency-dynamic]</p>
<ol start="4">
<li>
<p>동적 라이브러리나 동적으로 링크되는 실행 파일이 생성되는 경우, 컴파일러는 최종 결과물을 만들기 위해 사용 가능한 의존성들을 rlib 또는 dylib 형식 중에서 조정하려고 시도합니다.</p>
<p>컴파일러의 주요 목표는 라이브러리가 어떤 결과물에서도 두 번 이상 나타나지 않도록 보장하는 것입니다. 예를 들어, 만약 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크되어 있다면, A의 사본이 두 개가 되기 때문에 어떤 크레이트도 B와 C를 동시에 링크할 수 없습니다. 컴파일러는 rlib와 dylib 형식의 혼합을 허용하지만, 이 제한 사항은 반드시 준수되어야 합니다.</p>
<p>컴파일러는 현재 라이브러리를 어떤 형식으로 링크해야 하는지에 대한 힌트를 제공하는 방법을 구현하고 있지 않습니다. 동적 링크 시 컴파일러는 일부 의존성을 rlib를 통해 링크하는 것을 허용하면서도 동적 의존성을 최대화하려고 시도합니다.</p>
<p>대부분의 상황에서, 동적 링크를 하는 경우 모든 라이브러리를 dylib로 사용할 수 있도록 하는 것이 권장됩니다. 다른 상황에서 컴파일러는 각 라이브러리를 어떤 형식으로 링크해야 할지 결정할 수 없는 경우 경고를 출력합니다.</p>
</li>
</ol>
<p>일반적으로 모든 컴파일 요구 사항에 대해 <code>--crate-type=bin</code> 또는 <code>--crate-type=lib</code>로 충분하며, 다른 옵션들은 크레이트의 출력 형식에 대해 더 세밀한 제어가 필요한 경우에만 사용 가능합니다.</p>
<p>r[link.crt]</p>
<h2 id="정적-및-동적-c-런타임"><a class="header" href="#정적-및-동적-c-런타임">정적 및 동적 C 런타임</a></h2>
<p>r[link.crt.intro] The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the <code>x86_64-pc-windows-msvc</code> and <code>x86_64-unknown-linux-musl</code> targets typically come with both runtimes and the user selects which one they’d like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</p>
<ul>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>i686-unknown-linux-musl</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
</ul>
<p>r[link.crt.crt-static] The linkage of the C runtime is configured to respect the <code>crt-static</code> target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</p>
<pre><code class="language-sh">rustc -C target-feature=+crt-static foo.rs
</code></pre>
<p>반면 C 런타임에 동적으로 링크하려면 다음과 같이 실행합니다.</p>
<pre><code class="language-sh">rustc -C target-feature=-crt-static foo.rs
</code></pre>
<p>r[link.crt.ineffective] Targets which do not support switching between linkage of the C runtime will ignore this flag. It’s recommended to inspect the resulting binary to ensure that it’s linked as you would expect after the compiler succeeds.</p>
<p>r[link.crt.target_feature] Crates may also learn about how the C runtime is being linked. Code on MSVC, for example, needs to be compiled differently (e.g. with <code>/MT</code> or <code>/MD</code>) depending on the runtime being linked. This is exported currently through the <a href="conditional-compilation.html#target_feature"><code>cfg</code> attribute <code>target_feature</code> option</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_feature = "crt-static")]
fn foo() {
    println!("C 런타임은 정적으로 링크되어야 함");
}

#[cfg(not(target_feature = "crt-static"))]
fn foo() {
    println!("C 런타임은 동적으로 링크되어야 함");
}
<span class="boring">}</span></code></pre></pre>
<p>또한 Cargo 빌드 스크립트는 <a href="../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">환경 변수</a>를 통해 이 기능에 대해 알 수 있습니다. 빌드 스크립트에서는 다음과 같이 링크 여부를 감지할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::env;

fn main() {
    let linkage = env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or(String::new());

    if linkage.contains("crt-static") {
        println!("C 런타임은 정적으로 링크될 것임");
    } else {
        println!("C 런타임은 동적으로 링크될 것임");
    }
}</code></pre></pre>
<p>로컬에서 이 기능을 사용하려면 일반적으로 <code>RUSTFLAGS</code> 환경 변수를 사용하여 Cargo를 통해 컴파일러 플래그를 지정합니다. 예를 들어 MSVC에서 정적으로 링크된 바이너리를 컴파일하려면 다음과 같이 실행합니다:</p>
<pre><code class="language-sh">RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc
</code></pre>
<p>r[link.foreign-code]</p>
<h2 id="러스트와-외부-코드베이스의-혼합"><a class="header" href="#러스트와-외부-코드베이스의-혼합">러스트와 외부 코드베이스의 혼합</a></h2>
<p>r[link.foreign-code.foreign-linkers] If you are mixing Rust with foreign code (e.g. C, C++) and wish to make a single binary containing both types of code, you have two approaches for the final binary link:</p>
<ul>
<li><code>rustc</code>를 사용합니다. 비-러스트 라이브러리는 <code>rustc</code> 인자인 <code>-L &lt;directory&gt;</code> 및 <code>-l&lt;library&gt;</code>를 사용하거나 러스트 코드의 <code>#[link]</code> 지시어를 통해 전달합니다. <code>.o</code> 파일에 링크해야 한다면 <code>-Clink-arg=file.o</code>를 사용할 수 있습니다.</li>
<li>외부 링커를 사용합니다. 이 경우, 먼저 러스트 <code>staticlib</code> 타겟을 생성하고 이를 외부 링커 호출 시 전달해야 합니다. 여러 개의 러스트 서브시스템을 링크해야 한다면, 여러 개의 <code>extern crate</code> 문을 사용하여 여러 러스트 <code>rlib</code>를 포함하는 단일 <code>staticlib</code>를 생성해야 할 수도 있습니다. 여러 개의 러스트 <code>staticlib</code> 파일은 충돌할 가능성이 높습니다.</li>
</ul>
<p>러스트 <code>rlib</code>를 외부 링커에 직접 전달하는 것은 현재 지원되지 않습니다.</p>
<blockquote>
<p>[!NOTE] Rust code compiled or linked with a different instance of the Rust runtime counts as “foreign code” for the purpose of this section.</p>
</blockquote>
<p>r[link.unwinding]</p>
<h3 id="prohibited-linkage-and-unwinding"><a class="header" href="#prohibited-linkage-and-unwinding">Prohibited linkage and unwinding</a></h3>
<p>r[link.unwinding.intro] Panic unwinding can only be used if the binary is built consistently according to the following rules.</p>
<p>r[link.unwinding.potential] A Rust artifact is called <em>potentially unwinding</em> if any of the following conditions is met:</p>
<ul>
<li>The artifact uses the [<code>unwind</code> panic handler][panic.panic_handler].</li>
<li>The artifact contains a crate built with the <code>unwind</code> <a href="panic.html#panic-strategy">panic strategy</a> that makes a call to a function using a <code>-unwind</code> ABI.</li>
<li>The artifact makes a <code>"Rust"</code> ABI call to code running in another Rust artifact that has a separate copy of the Rust runtime, and that other artifact is potentially unwinding.</li>
</ul>
<blockquote>
<p>[!NOTE] This definition captures whether a <code>"Rust"</code> ABI call inside a Rust artifact can ever unwind.</p>
</blockquote>
<p>r[link.unwinding.prohibited] If a Rust artifact is potentially unwinding, then all its crates must be built with the <code>unwind</code> <a href="panic.html#panic-strategy">panic strategy</a>. Otherwise, unwinding can cause undefined behavior.</p>
<blockquote>
<p>[!NOTE] If you are using <code>rustc</code> to link, these rules are enforced automatically. If you are <em>not</em> using <code>rustc</code> to link, you must take care to ensure that unwinding is handled consistently across the entire binary. Linking without <code>rustc</code> includes using <code>dlopen</code> or similar facilities where linking is done by the system runtime without <code>rustc</code> being involved. This can only happen when mixing code with different <a href="../rustc/codegen-options/index.html#panic"><code>-C panic</code></a> flags, so most users do not have to be concerned about this.</p>
</blockquote>
<blockquote>
<p>[!NOTE] To guarantee that a library will be sound (and linkable with <code>rustc</code>) regardless of the panic runtime used at link-time, the <a href="../rustc/lints/listing/allowed-by-default.html#ffi-unwind-calls"><code>ffi_unwind_calls</code> lint</a> may be used. The lint flags any calls to <code>-unwind</code> foreign functions or function pointers.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="inline-assembly.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="inline-assembly.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
