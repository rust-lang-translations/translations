<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>토큰 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/tokens.md`;
                    } else {
                        canonical_href = `${base}/${lang}/tokens.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/tokens.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-lex.token"><a class="rule-link" href="#r-lex.token" title="lex.token"><span>[lex<wbr>.token]<span/></a></div>
<h1 id="토큰"><a class="header" href="#토큰">토큰</a></h1>
<div class="rule" id="r-lex.token.intro"><a class="rule-link" href="#r-lex.token.intro" title="lex.token.intro"><span>[lex<wbr>.token<wbr>.intro]<span/></a></div>
<p>토큰은 정규 (비재귀) 언어로 정의된 문법의 기본 생성물입니다. Rust 소스 입력은 다음 종류의 토큰으로 나눌 수 있습니다:</p>
<ul>
<li><a href="keywords.html">키워드</a></li>
<li><a href="identifiers.html">식별자</a></li>
<li><a href="#literals">리터럴</a></li>
<li><a href="#lifetimes-and-loop-labels">라이프타임</a></li>
<li><a href="#punctuation">구두점</a></li>
<li><a href="#delimiters">구분자</a></li>
</ul>
<p>이 문서의 문법에서 “단순” 토큰은 <a href="notation.html#string-table-productions">문자열 테이블 생성</a> 형식으로 주어지며, <code>monospace</code> 글꼴로 나타납니다.</p>
<div class="rule" id="r-lex.token.literal"><a class="rule-link" href="#r-lex.token.literal" title="lex.token.literal"><span>[lex<wbr>.token<wbr>.literal]<span/></a></div>
<h2 id="리터럴"><a class="header" href="#리터럴">리터럴</a></h2>
<p>리터럴은 <a href="expressions/literal-expr.html">리터럴 표현식</a>에 사용되는 토큰입니다.</p>
<h3 id="예시"><a class="header" href="#예시">예시</a></h3>
<h4 id="문자와-문자열"><a class="header" href="#문자와-문자열">문자와 문자열</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>예시</th><th><code>#</code> 세트<sup class="footnote-reference"><a href="#nsets">1</a></sup></th><th>문자</th><th>이스케이프</th></tr></thead><tbody>
<tr><td><a href="#character-literals">문자</a></td><td><code>'H'</code></td><td>0</td><td>모든 유니코드</td><td><a href="#quote-escapes">인용</a> &amp; <a href="#ascii-escapes">ASCII</a> &amp; <a href="#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="#string-literals">문자열</a></td><td><code>"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="#quote-escapes">인용</a> &amp; <a href="#ascii-escapes">ASCII</a> &amp; <a href="#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="#raw-string-literals">원시 문자열</a></td><td><code>r#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
<tr><td><a href="#byte-literals">바이트</a></td><td><code>b'H'</code></td><td>0</td><td>모든 ASCII</td><td><a href="#quote-escapes">인용</a> &amp; <a href="#byte-escapes">바이트</a></td></tr>
<tr><td><a href="#byte-string-literals">바이트 문자열</a></td><td><code>b"hello"</code></td><td>0</td><td>모든 ASCII</td><td><a href="#quote-escapes">인용</a> &amp; <a href="#byte-escapes">바이트</a></td></tr>
<tr><td><a href="#raw-byte-string-literals">원시 바이트 문자열</a></td><td><code>br#"hello"#</code></td><td>&lt;256</td><td>모든 ASCII</td><td><code>N/A</code></td></tr>
<tr><td><a href="#c-string-literals">C 문자열</a></td><td><code>c"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="#quote-escapes">인용</a> &amp; <a href="#byte-escapes">바이트</a> &amp; <a href="#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="#raw-c-string-literals">원시 C 문자열</a></td><td><code>cr#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nsets"><sup class="footnote-definition-label">1</sup>
<p>동일한 리터럴의 각 면에 있는 <code>#</code>의 수는 동일해야 합니다.</p>
</div>
<blockquote>
<p><strong>참고</strong>: 문자 및 문자열 리터럴 토큰은 <code>U+000D</code> (CR) 뒤에 <code>U+000A</code> (LF)가 즉시 오는 시퀀스를 포함하지 않습니다. 이 쌍은 이전에 단일 <code>U+000A</code> (LF)로 변환되었을 것입니다.</p>
</blockquote>
<h4 id="ascii-이스케이프"><a class="header" href="#ascii-이스케이프">ASCII 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x41</code></td><td>7비트 문자 코드 (정확히 2자리, 최대 0x7F)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="바이트-이스케이프"><a class="header" href="#바이트-이스케이프">바이트 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x7F</code></td><td>8비트 문자 코드 (정확히 2자리)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="유니코드-이스케이프"><a class="header" href="#유니코드-이스케이프">유니코드 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\u{7FFF}</code></td><td>24비트 유니코드 문자 코드 (최대 6자리)</td></tr>
</tbody></table>
</div>
<h4 id="인용-이스케이프"><a class="header" href="#인용-이스케이프">인용 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\'</code></td><td>작은따옴표</td></tr>
<tr><td><code>\"</code></td><td>큰따옴표</td></tr>
</tbody></table>
</div>
<h4 id="숫자"><a class="header" href="#숫자">숫자</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="#number-literals">숫자 리터럴</a><sup class="footnote-reference"><a href="#nl">2</a></sup></th><th>예시</th><th>지수</th></tr></thead><tbody>
<tr><td>10진수 정수</td><td><code>98_222</code></td><td><code>N/A</code></td></tr>
<tr><td>16진수 정수</td><td><code>0xff</code></td><td><code>N/A</code></td></tr>
<tr><td>8진수 정수</td><td><code>0o77</code></td><td><code>N/A</code></td></tr>
<tr><td>2진수 정수</td><td><code>0b1111_0000</code></td><td><code>N/A</code></td></tr>
<tr><td>부동 소수점</td><td><code>123.0E+77</code></td><td><code>선택 사항</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nl"><sup class="footnote-definition-label">2</sup>
<p>모든 숫자 리터럴은 <code>_</code>를 시각적 구분자로 허용합니다: <code>1_234.0E+18f64</code></p>
</div>
<div class="rule" id="r-lex.token.literal.suffix"><a class="rule-link" href="#r-lex.token.literal.suffix" title="lex.token.literal.suffix"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix]<span/></a></div>
<h4 id="접미사"><a class="header" href="#접미사">접미사</a></h4>
<div class="rule" id="r-lex.token.literal.literal.suffix.intro"><a class="rule-link" href="#r-lex.token.literal.literal.suffix.intro" title="lex.token.literal.literal.suffix.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.literal<wbr>.suffix<wbr>.intro]<span/></a></div>
<p>접미사는 리터럴의 주요 부분 뒤에 오는 문자 시퀀스(중간 공백 없이)로, 비원시 식별자 또는 키워드와 동일한 형태입니다.</p>
<div class="rule" id="r-lex.token.literal.suffix.syntax"><a class="rule-link" href="#r-lex.token.literal.suffix.syntax" title="lex.token.literal.suffix.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
SUFFIX : 식별자_또는_키워드<br />
SUFFIX_NO_E : SUFFIX <sub><em><code>e</code> 또는 <code>E</code>로 시작하지 않음</em></sub><strong><sup>렉서</sup></strong><br />
SUFFIX : 식별자_또는_키워드<br />
SUFFIX_NO_E : SUFFIX <sub><em><code>e</code> 또는 <code>E</code>로 시작하지 않음</em></sub></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.suffix.validity"><a class="rule-link" href="#r-lex.token.literal.suffix.validity" title="lex.token.literal.suffix.validity"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.validity]<span/></a></div>
<p>어떤 종류의 리터럴(문자열, 정수 등)이든 어떤 접미사와 함께 사용되어도 유효한 토큰입니다.</p>
<p>어떤 접미사가 붙은 리터럴 토큰도 오류 없이 매크로에 전달될 수 있습니다. 매크로 자체는 그러한 토큰을 해석하는 방법과 오류를 발생시킬지 여부를 결정합니다. 특히, 예제 매크로의 <code>literal</code> 프래그먼트 지정자는 임의의 접미사가 붙은 리터럴 토큰과 일치합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! blackhole { ($tt:tt) =&gt; () }
macro_rules! blackhole_lit { ($l:literal) =&gt; () }

blackhole!("string"suffix); // OK
blackhole_lit!(1suffix); // OK
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.suffix.parse"><a class="rule-link" href="#r-lex.token.literal.suffix.parse" title="lex.token.literal.suffix.parse"><span>[lex<wbr>.token<wbr>.literal<wbr>.suffix<wbr>.parse]<span/></a></div>
<p>그러나 리터럴 표현식 또는 패턴으로 해석되는 리터럴 토큰의 접미사는 제한됩니다. 비숫자 리터럴 토큰의 모든 접미사는 거부되며, 숫자 리터럴 토큰은 아래 목록의 접미사만 허용됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>정수</th><th>부동 소수점</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, <code>isize</code></td><td><code>f32</code>, <code>f64</code></td></tr>
</tbody></table>
</div>
<h3 id="문자-및-문자열-리터럴"><a class="header" href="#문자-및-문자열-리터럴">문자 및 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.literal.char"><a class="rule-link" href="#r-lex.token.literal.char" title="lex.token.literal.char"><span>[lex<wbr>.token<wbr>.literal<wbr>.char]<span/></a></div>
<h4 id="문자-리터럴"><a class="header" href="#문자-리터럴">문자 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.char.syntax"><a class="rule-link" href="#r-lex.token.literal.char.syntax" title="lex.token.literal.char.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.char<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
CHAR_LITERAL :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) <code>'</code> SUFFIX<sup>?</sup><strong><sup>렉서</sup></strong><br />
CHAR_LITERAL :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) <code>'</code> SUFFIX<sup>?</sup></p>
<p>QUOTE_ESCAPE :<br />
   <code>\'</code> | <code>\"</code></p>
<p>ASCII_ESCAPE :<br />
      <code>\x</code> 8진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code>ASCII_ESCAPE :<br />
      <code>\x</code> 8진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code></p>
<p>UNICODE_ESCAPE :<br />
   <code>\u{</code> ( 16진수_숫자 <code>_</code><sup><em></sup> )<sup>1..6</sup> <code>}</code>UNICODE_ESCAPE :<br />
   <code>\u{</code> ( 16진수_숫자 <code>_</code><sup></em></sup> )<sup>1..6</sup> <code>}</code></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.char.intro"><a class="rule-link" href="#r-lex.token.literal.char.intro" title="lex.token.literal.char.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.char<wbr>.intro]<span/></a></div>
<p>_문자 리터럴_은 두 개의 <code>U+0027</code>(작은따옴표) 문자 안에 묶인 단일 유니코드 문자입니다. 단, <code>U+0027</code> 자체는 선행하는 <code>U+005C</code> 문자(<code>\</code>)로 _이스케이프_되어야 합니다.</p>
<div class="rule" id="r-lex.token.literal.str"><a class="rule-link" href="#r-lex.token.literal.str" title="lex.token.literal.str"><span>[lex<wbr>.token<wbr>.literal<wbr>.str]<span/></a></div>
<h4 id="문자열-리터럴"><a class="header" href="#문자열-리터럴">문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.str.syntax"><a class="rule-link" href="#r-lex.token.literal.str.syntax" title="lex.token.literal.str.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
STRING_LITERAL :<br />
   <code>"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em>]<br />
      | QUOTE_ESCAPE<br />
      | ASCII_ESCAPE<br />
      | UNICODE_ESCAPE<br />
      | STRING_CONTINUE<br />
   )<sup><em></sup> <code>"</code> SUFFIX<sup>?</sup><strong><sup>렉서</sup></strong><br />
STRING_LITERAL :<br />
   <code>"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em>]<br />
      | QUOTE_ESCAPE<br />
      | ASCII_ESCAPE<br />
      | UNICODE_ESCAPE<br />
      | STRING_CONTINUE<br />
   )<sup></em></sup> <code>"</code> SUFFIX<sup>?</sup></p>
<p>STRING_CONTINUE :<br />
   <code>\</code> <em>뒤에</em> \nSTRING_CONTINUE :<br />
   <code>\</code> <em>뒤에</em> \n</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.str.intro"><a class="rule-link" href="#r-lex.token.literal.str.intro" title="lex.token.literal.str.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.intro]<span/></a></div>
<p>_문자열 리터럴_은 두 개의 <code>U+0022</code>(큰따옴표) 문자 안에 묶인 모든 유니코드 문자 시퀀스입니다. 단, <code>U+0022</code> 자체는 선행하는 <code>U+005C</code> 문자(<code>\</code>)로 _이스케이프_되어야 합니다.</p>
<div class="rule" id="r-lex.token.literal.str.linefeed"><a class="rule-link" href="#r-lex.token.literal.str.linefeed" title="lex.token.literal.str.linefeed"><span>[lex<wbr>.token<wbr>.literal<wbr>.str<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.literal.char-escape"><a class="rule-link" href="#r-lex.token.literal.char-escape" title="lex.token.literal.char-escape"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape]<span/></a></div>
<h4 id="문자-이스케이프"><a class="header" href="#문자-이스케이프">문자 이스케이프</a></h4>
<div class="rule" id="r-lex.token.literal.char-escape.intro"><a class="rule-link" href="#r-lex.token.literal.char-escape.intro" title="lex.token.literal.char-escape.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.intro]<span/></a></div>
<p>문자 또는 비원시 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.literal.char-escape.ascii"><a class="rule-link" href="#r-lex.token.literal.char-escape.ascii" title="lex.token.literal.char-escape.ascii"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.ascii]<span/></a></div>
<ul>
<li>_7비트 코드 포인트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, <code>0x7F</code>까지의 값을 가진 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 값을 가진 ASCII 문자를 나타냅니다. 더 높은 값은 유니코드 코드 포인트를 의미하는지 바이트 값을 의미하는지 모호하기 때문에 허용되지 않습니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.unicode"><a class="rule-link" href="#r-lex.token.literal.char-escape.unicode" title="lex.token.literal.char-escape.unicode"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.unicode]<span/></a></div>
<ul>
<li>_24비트 코드 포인트 이스케이프_는 <code>U+0075</code>(<code>u</code>)로 시작하며, <code>U+007B</code>(<code>{</code>)와 <code>U+007D</code>(<code>}</code>) 중괄호로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.whitespace"><a class="rule-link" href="#r-lex.token.literal.char-escape.whitespace" title="lex.token.literal.char-escape.whitespace"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 유니코드 값 <code>U+000A</code>(LF), <code>U+000D</code>(CR) 또는 <code>U+0009</code>(HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.null"><a class="rule-link" href="#r-lex.token.literal.char-escape.null" title="lex.token.literal.char-escape.null"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.null]<span/></a></div>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 유니코드 값 <code>U+0000</code>(NUL)을 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.char-escape.slash"><a class="rule-link" href="#r-lex.token.literal.char-escape.slash" title="lex.token.literal.char-escape.slash"><span>[lex<wbr>.token<wbr>.literal<wbr>.char-escape<wbr>.slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote itself.</li>
</ul>
<div class="rule" id="r-lex.token.literal.str-raw"><a class="rule-link" href="#r-lex.token.literal.str-raw" title="lex.token.literal.str-raw"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw]<span/></a></div>
<h4 id="원시-문자열-리터럴"><a class="header" href="#원시-문자열-리터럴">원시 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.str-raw.syntax"><a class="rule-link" href="#r-lex.token.literal.str-raw.syntax" title="lex.token.literal.str-raw.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_STRING_LITERAL :<br />
   <code>r</code> 원시_문자열_내용 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
RAW_STRING_LITERAL :<br />
   <code>r</code> 원시_문자열_내용 접미사<sup>?</sup></p>
<p>RAW_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_문자열_내용 <code>#</code>RAW_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_문자열_내용 <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.str-raw.intro"><a class="rule-link" href="#r-lex.token.literal.str-raw.intro" title="lex.token.literal.str-raw.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.intro]<span/></a></div>
<p>원시 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 <code>U+0072</code>(<code>r</code>) 문자로 시작하며, 256개 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.literal.str-raw.body"><a class="rule-link" href="#r-lex.token.literal.str-raw.body" title="lex.token.literal.str-raw.body"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.body]<span/></a></div>
<p>_원시 문자열 본문_은 <code>U+000D</code>(CR)를 제외한 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.literal.str-raw.content"><a class="rule-link" href="#r-lex.token.literal.str-raw.content" title="lex.token.literal.str-raw.content"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-raw<wbr>.content]<span/></a></div>
<p>원시 문자열 본문에 포함된 모든 유니코드 문자는 그 자체를 나타내며, <code>U+0022</code>(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<p>문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="바이트-및-바이트-문자열-리터럴"><a class="header" href="#바이트-및-바이트-문자열-리터럴">바이트 및 바이트 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.byte"><a class="rule-link" href="#r-lex.token.byte" title="lex.token.byte"><span>[lex<wbr>.token<wbr>.byte]<span/></a></div>
<h4 id="바이트-리터럴"><a class="header" href="#바이트-리터럴">바이트 리터럴</a></h4>
<div class="rule" id="r-lex.token.byte.syntax"><a class="rule-link" href="#r-lex.token.byte.syntax" title="lex.token.byte.syntax"><span>[lex<wbr>.token<wbr>.byte<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
BYTE_LITERAL :<br />
   <code>b'</code> ( ASCII_FOR_CHAR | BYTE_ESCAPE )  <code>'</code> 접미사<sup>?</sup></p>
<p>ASCII_FOR_CHAR :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>'</code>, <code>\</code>, \n, \r 또는 \t 제외_</p>
<p>BYTE_ESCAPE :<br />
      <code>\x</code> 16진수_숫자 16진수_숫자<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code> | <code>\'</code> | <code>\"</code></p>
</blockquote>
<div class="rule" id="r-lex.token.byte.intro"><a class="rule-link" href="#r-lex.token.byte.intro" title="lex.token.byte.intro"><span>[lex<wbr>.token<wbr>.byte<wbr>.intro]<span/></a></div>
<p>_바이트 리터럴_은 <code>U+0062</code>(<code>b</code>)와 <code>U+0027</code>(작은따옴표) 문자로 시작하고 <code>U+0027</code> 문자로 끝나는 단일 ASCII 문자(<code>U+0000</code>에서 <code>U+007F</code> 범위) 또는 단일 _이스케이프_입니다. <code>U+0027</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 이는 <code>u8</code> 부호 없는 8비트 정수 _숫자 리터럴_과 동일합니다.</p>
<div class="rule" id="r-lex.token.str-byte"><a class="rule-link" href="#r-lex.token.str-byte" title="lex.token.str-byte"><span>[lex<wbr>.token<wbr>.str-byte]<span/></a></div>
<h4 id="바이트-문자열-리터럴"><a class="header" href="#바이트-문자열-리터럴">바이트 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-byte.syntax"><a class="rule-link" href="#r-lex.token.str-byte.syntax" title="lex.token.str-byte.syntax"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
BYTE_STRING_LITERAL :<br />
   <code>b"</code> ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup><em></sup> <code>"</code> 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
BYTE_STRING_LITERAL :<br />
   <code>b"</code> ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup></em></sup> <code>"</code> 접미사<sup>?</sup></p>
<p>ASCII_FOR_STRING :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>"</code>, <code>\</code> _및 IsolatedCR 제외_ASCII_FOR_STRING :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지), 단</em> <code>"</code>, <code>\</code> <em>및 IsolatedCR 제외</em></p>
</blockquote>
<div class="rule" id="r-lex.token.str-byte.intro"><a class="rule-link" href="#r-lex.token.str-byte.intro" title="lex.token.str-byte.intro"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.intro]<span/></a></div>
<p>비원시 _바이트 문자열 리터럴_은 <code>U+0062</code>(<code>b</code>)와 <code>U+0022</code>(큰따옴표) 문자로 시작하고 <code>U+0022</code> 문자로 끝나는 ASCII 문자와 <em>이스케이프</em> 시퀀스입니다. <code>U+0022</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 또는 바이트 문자열 리터럴은 아래에 정의된 _원시 바이트 문자열 리터럴_일 수 있습니다.</p>
<div class="rule" id="r-lex.token.str-byte.linefeed"><a class="rule-link" href="#r-lex.token.str-byte.linefeed" title="lex.token.str-byte.linefeed"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 바이트 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 바이트 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.str-byte.escape"><a class="rule-link" href="#r-lex.token.str-byte.escape" title="lex.token.str-byte.escape"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape]<span/></a></div>
<p>바이트 또는 비원시 바이트 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.str-byte.escape-byte"><a class="rule-link" href="#r-lex.token.str-byte.escape-byte" title="lex.token.str-byte.escape-byte"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-byte]<span/></a></div>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-whitespace"><a class="rule-link" href="#r-lex.token.str-byte.escape-whitespace" title="lex.token.str-byte.escape-whitespace"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-null"><a class="rule-link" href="#r-lex.token.str-byte.escape-null" title="lex.token.str-byte.escape-null"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-null]<span/></a></div>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 바이트 값 <code>0x00</code>(ASCII NUL)을 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte.escape-slash"><a class="rule-link" href="#r-lex.token.str-byte.escape-slash" title="lex.token.str-byte.escape-slash"><span>[lex<wbr>.token<wbr>.str-byte<wbr>.escape-slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<div class="rule" id="r-lex.token.str-byte-raw"><a class="rule-link" href="#r-lex.token.str-byte-raw" title="lex.token.str-byte-raw"><span>[lex<wbr>.token<wbr>.str-byte-raw]<span/></a></div>
<h4 id="원시-바이트-문자열-리터럴"><a class="header" href="#원시-바이트-문자열-리터럴">원시 바이트 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-byte-raw.syntax"><a class="rule-link" href="#r-lex.token.str-byte-raw.syntax" title="lex.token.str-byte-raw.syntax"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_BYTE_STRING_LITERAL :<br />
   <code>br</code> 원시_바이트_문자열_내용 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
RAW_BYTE_STRING_LITERAL :<br />
   <code>br</code> 원시_바이트_문자열_내용 접미사<sup>?</sup></p>
<p>RAW_BYTE_STRING_CONTENT :<br />
      <code>"</code> ASCII_FOR_RAW<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_바이트_문자열_내용 <code>#</code>RAW_BYTE_STRING_CONTENT :<br />
      <code>"</code> ASCII_FOR_RAW<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> 원시_바이트_문자열_내용 <code>#</code></p>
<p>ASCII_FOR_RAW :<br />
   _모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외_ASCII_FOR_RAW :<br />
   <em>모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외</em></p>
</blockquote>
<div class="rule" id="r-lex.token.str-byte-raw.intro"><a class="rule-link" href="#r-lex.token.str-byte-raw.intro" title="lex.token.str-byte-raw.intro"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.intro]<span/></a></div>
<p>원시 바이트 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 <code>U+0062</code>(<code>b</code>) 문자로 시작하고 <code>U+0072</code>(<code>r</code>) 문자가 뒤따르며, 256개 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-byte-raw.body"><a class="rule-link" href="#r-lex.token.str-byte-raw.body" title="lex.token.str-byte-raw.body"><span>[lex<wbr>.token<wbr>.str-byte-raw<wbr>.body]<span/></a></div>
<p>_원시 문자열 본문_은 <code>U+000D</code>(CR)를 제외한 모든 ASCII 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다. 원시 바이트 문자열 리터럴은 비 ASCII 바이트를 포함할 수 없습니다.</p>
<div class="rule" id="r-lex.token.literal.str-byte-raw.content"><a class="rule-link" href="#r-lex.token.literal.str-byte-raw.content" title="lex.token.literal.str-byte-raw.content"><span>[lex<wbr>.token<wbr>.literal<wbr>.str-byte-raw<wbr>.content]<span/></a></div>
<p>원시 문자열 본문에 포함된 모든 문자는 ASCII 인코딩을 나타내며, <code>U+0022</code>(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<p>바이트 문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="c-문자열-및-원시-c-문자열-리터럴"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴">C 문자열 및 원시 C 문자열 리터럴</a></h3>
<div class="rule" id="r-lex.token.str-c"><a class="rule-link" href="#r-lex.token.str-c" title="lex.token.str-c"><span>[lex<wbr>.token<wbr>.str-c]<span/></a></div>
<h4 id="c-문자열-리터럴"><a class="header" href="#c-문자열-리터럴">C 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-c.syntax"><a class="rule-link" href="#r-lex.token.str-c.syntax" title="lex.token.str-c.syntax"><span>[lex<wbr>.token<wbr>.str-c<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
C_STRING_LITERAL :<br />
   <code>c"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em> <em>NUL</em>]<br />
      | BYTE_ESCAPE <em>단, <code>\0</code> 또는 <code>\x00</code> 제외</em><br />
      | UNICODE_ESCAPE <em>단, <code>\u{0}</code>, <code>\u{00}</code>, …, <code>\u{000000}</code> 제외</em><br />
      | STRING_CONTINUE<br />
   )<sup><em></sup> <code>"</code> 접미사<sup>?</sup><strong><sup>렉서</sup></strong><br />
C_STRING_LITERAL :<br />
   <code>c"</code> (<br />
      ~[<code>"</code> <code>\</code> <em>IsolatedCR</em> <em>NUL</em>]<br />
      | BYTE_ESCAPE <em>단, <code>\0</code> 또는 <code>\x00</code> 제외</em><br />
      | UNICODE_ESCAPE <em>단, <code>\u{0}</code>, <code>\u{00}</code>, …, <code>\u{000000}</code> 제외</em><br />
      | STRING_CONTINUE<br />
   )<sup></em></sup> <code>"</code> 접미사<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.str-c.intro"><a class="rule-link" href="#r-lex.token.str-c.intro" title="lex.token.str-c.intro"><span>[lex<wbr>.token<wbr>.str-c<wbr>.intro]<span/></a></div>
<p>_C 문자열 리터럴_은 <code>U+0063</code>(<code>c</code>)과 <code>U+0022</code>(큰따옴표) 문자로 시작하고 <code>U+0022</code> 문자로 끝나는 유니코드 문자와 <em>이스케이프</em> 시퀀스입니다. <code>U+0022</code> 문자가 리터럴 내에 있으면 선행하는 <code>U+005C</code>(<code>\</code>) 문자로 _이스케이프_되어야 합니다. 또는 C 문자열 리터럴은 아래에 정의된 _원시 C 문자열 리터럴_일 수 있습니다.</p>
<div class="rule" id="r-lex.token.str-c.null"><a class="rule-link" href="#r-lex.token.str-c.null" title="lex.token.str-c.null"><span>[lex<wbr>.token<wbr>.str-c<wbr>.null]<span/></a></div>
<p>C 문자열은 바이트 <code>0x00</code>으로 암시적으로 종료되므로, C 문자열 리터럴 <code>c""</code>는 바이트 문자열 리터럴 <code>b"\x00"</code>에서 <code>&amp;CStr</code>를 수동으로 구성하는 것과 동일합니다. 암시적 종료자를 제외하고, 바이트 <code>0x00</code>은 C 문자열 내에서 허용되지 않습니다.</p>
<div class="rule" id="r-lex.token.str-c.linefeed"><a class="rule-link" href="#r-lex.token.str-c.linefeed" title="lex.token.str-c.linefeed"><span>[lex<wbr>.token<wbr>.str-c<wbr>.linefeed]<span/></a></div>
<p><code>U+000A</code>(LF) 문자로 표현되는 줄 바꿈은 C 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 <code>U+005C</code> 문자(<code>\</code>)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>를 참조하십시오. <code>U+000D</code>(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 C 문자열 리터럴에 나타날 수 없습니다.</p>
<div class="rule" id="r-lex.token.str-c.escape"><a class="rule-link" href="#r-lex.token.str-c.escape" title="lex.token.str-c.escape"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape]<span/></a></div>
<p>비원시 C 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 <code>U+005C</code>(<code>\</code>)로 시작하며 다음 형식 중 하나로 이어집니다:</p>
<div class="rule" id="r-lex.token.str-c.escape-byte"><a class="rule-link" href="#r-lex.token.str-c.escape-byte" title="lex.token.str-c.escape-byte"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-byte]<span/></a></div>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-unicode"><a class="rule-link" href="#r-lex.token.str-c.escape-unicode" title="lex.token.str-c.escape-unicode"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-unicode]<span/></a></div>
<ul>
<li>_24비트 코드 포인트 이스케이프_는 <code>U+0075</code>(<code>u</code>)로 시작하고 중괄호 <code>U+007B</code>(<code>{</code>) 및 <code>U+007D</code>(<code>}</code>)로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타내며 UTF-8로 인코딩됩니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-whitespace"><a class="rule-link" href="#r-lex.token.str-c.escape-whitespace" title="lex.token.str-c.escape-whitespace"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-whitespace]<span/></a></div>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.escape-slash"><a class="rule-link" href="#r-lex.token.str-c.escape-slash" title="lex.token.str-c.escape-slash"><span>[lex<wbr>.token<wbr>.str-c<wbr>.escape-slash]<span/></a></div>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<div class="rule" id="r-lex.token.str-c.char-unicode"><a class="rule-link" href="#r-lex.token.str-c.char-unicode" title="lex.token.str-c.char-unicode"><span>[lex<wbr>.token<wbr>.str-c<wbr>.char-unicode]<span/></a></div>
<p>C 문자열은 정의된 인코딩이 없는 바이트를 나타내지만 C 문자열 리터럴에는 <code>U+007F</code> 이상의 유니코드 문자가 포함될 수 있습니다. 이러한 문자는 해당 문자의 UTF-8 표현 바이트로 대체됩니다.</p>
<p>다음 C 문자열 리터럴은 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"æ";        // 라틴어 소문자 AE (U+00E6)
c"\u{00E6}";
c"\xC3\xA6";
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.str-c.edition2021"><a class="rule-link" href="#r-lex.token.str-c.edition2021" title="lex.token.str-c.edition2021"><span>[lex<wbr>.token<wbr>.str-c<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>c""</code> 토큰이 <code>c ""</code>로 분석됩니다.</p>
</blockquote>
<div class="rule" id="r-lex.token.str-c-raw"><a class="rule-link" href="#r-lex.token.str-c-raw" title="lex.token.str-c-raw"><span>[lex<wbr>.token<wbr>.str-c-raw]<span/></a></div>
<h4 id="원시-c-문자열-리터럴"><a class="header" href="#원시-c-문자열-리터럴">원시 C 문자열 리터럴</a></h4>
<div class="rule" id="r-lex.token.str-c-raw.syntax"><a class="rule-link" href="#r-lex.token.str-c-raw.syntax" title="lex.token.str-c-raw.syntax"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
RAW_C_STRING_LITERAL :<br />
   <code>cr</code> RAW_C_STRING_CONTENT 접미사<sup>?</sup></p>
<p>RAW_C_STRING_CONTENT :<br />
      <code>"</code> ( ~ <em>IsolatedCR</em> <em>NUL</em> )<sup>* (non-greedy)</sup> <code>"</code><br />
   | <code>#</code> RAW_C_STRING_CONTENT <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.str-c-raw.intro"><a class="rule-link" href="#r-lex.token.str-c-raw.intro" title="lex.token.str-c-raw.intro"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.intro]<span/></a></div>
<p>원시 C 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. <code>U+0063</code>(<code>c</code>) 문자로 시작하고 <code>U+0072</code>(<code>r</code>) 문자가 뒤따르며, 256자 미만의 <code>U+0023</code>(<code>#</code>) 문자와 <code>U+0022</code>(큰따옴표) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.body"><a class="rule-link" href="#r-lex.token.str-c-raw.body" title="lex.token.str-c-raw.body"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.body]<span/></a></div>
<p>_원시 C 문자열 본문_은 <code>U+0000</code>(NUL) 및 <code>U+000D</code>(CR) 이외의 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 다른 <code>U+0022</code>(큰따옴표) 문자로만 종료되며, 여는 <code>U+0022</code>(큰따옴표) 문자 앞에 있던 것과 동일한 수의 <code>U+0023</code>(<code>#</code>) 문자가 뒤따릅니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.content"><a class="rule-link" href="#r-lex.token.str-c-raw.content" title="lex.token.str-c-raw.content"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.content]<span/></a></div>
<p>원시 C 문자열 본문에 포함된 모든 문자는 UTF-8 인코딩으로 자신을 나타냅니다. <code>U+0022</code>(큰따옴표) 문자(원시 C 문자열 리터럴을 시작하는 데 사용된 <code>U+0023</code>(<code>#</code>) 문자 수만큼 이상 뒤따르지 않는 경우) 또는 <code>U+005C</code>(<code>\</code>)는 특별한 의미를 갖지 않습니다.</p>
<div class="rule" id="r-lex.token.str-c-raw.edition2021"><a class="rule-link" href="#r-lex.token.str-c-raw.edition2021" title="lex.token.str-c-raw.edition2021"><span>[lex<wbr>.token<wbr>.str-c-raw<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 원시 C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>cr""</code> 토큰이 <code>cr ""</code>로, <code>cr#""#</code>는 <code>cr #""#</code>(문법에 맞지 않음)로 어휘 분석됩니다.</p>
</blockquote>
<h4 id="c-문자열-및-원시-c-문자열-리터럴의-예"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴의-예">C 문자열 및 원시 C 문자열 리터럴의 예</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"foo"; cr"foo";                     // foo
c"\"foo\""; cr#""foo""#;             // "foo"

c"foo #\"# bar";
cr##"foo #"# bar"##;                 // foo #"# bar

c"\x52"; c"R"; cr"R";                // R
c"\\x52"; cr"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.num"><a class="rule-link" href="#r-lex.token.literal.num" title="lex.token.literal.num"><span>[lex<wbr>.token<wbr>.literal<wbr>.num]<span/></a></div>
<h3 id="숫자-리터럴"><a class="header" href="#숫자-리터럴">숫자 리터럴</a></h3>
<p>_숫자 리터럴_은 <em>정수 리터럴</em> 또는 _부동 소수점 리터럴_입니다. 두 종류의 리터럴을 인식하는 문법은 혼합되어 있습니다.</p>
<div class="rule" id="r-lex.token.literal.int"><a class="rule-link" href="#r-lex.token.literal.int" title="lex.token.literal.int"><span>[lex<wbr>.token<wbr>.literal<wbr>.int]<span/></a></div>
<h4 id="정수-리터럴"><a class="header" href="#정수-리터럴">정수 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.int.syntax"><a class="rule-link" href="#r-lex.token.literal.int.syntax" title="lex.token.literal.int.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
INTEGER_LITERAL :<br />
   ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) SUFFIX_NO_E<sup>?</sup></p>
<p>DEC_LITERAL :<br />
   DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>BIN_LITERAL :<br />
   <code>0b</code> (BIN_DIGIT|<code>_</code>)<sup><em></sup> BIN_DIGIT (BIN_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>OCT_LITERAL :<br />
   <code>0o</code> (OCT_DIGIT|<code>_</code>)<sup><em></sup> OCT_DIGIT (OCT_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>HEX_LITERAL :<br />
   <code>0x</code> (HEX_DIGIT|<code>_</code>)<sup><em></sup> HEX_DIGIT (HEX_DIGIT|<code>_</code>)<sup></em></sup></p>
<p>BIN_DIGIT : [<code>0</code>-<code>1</code>]</p>
<p>OCT_DIGIT : [<code>0</code>-<code>7</code>]</p>
<p>DEC_DIGIT : [<code>0</code>-<code>9</code>]</p>
<p>HEX_DIGIT : [<code>0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F</code>]</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.int.kind"><a class="rule-link" href="#r-lex.token.literal.int.kind" title="lex.token.literal.int.kind"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind]<span/></a></div>
<p>_정수 리터럴_은 네 가지 형태 중 하나를 갖습니다.</p>
<div class="rule" id="r-lex.token.literal.int.kind-dec"><a class="rule-link" href="#r-lex.token.literal.int.kind-dec" title="lex.token.literal.int.kind-dec"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-dec]<span/></a></div>
<ul>
<li>_십진수 리터럴_은 _십진수 숫자_로 시작하고 _십진수 숫자_와 _밑줄_의 혼합으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-hex"><a class="rule-link" href="#r-lex.token.literal.int.kind-hex" title="lex.token.literal.int.kind-hex"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-hex]<span/></a></div>
<ul>
<li>_16진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0078</code>(<code>0x</code>)로 시작하고 16진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-oct"><a class="rule-link" href="#r-lex.token.literal.int.kind-oct" title="lex.token.literal.int.kind-oct"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-oct]<span/></a></div>
<ul>
<li>_8진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+006F</code>(<code>0o</code>)로 시작하고 8진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.kind-bin"><a class="rule-link" href="#r-lex.token.literal.int.kind-bin" title="lex.token.literal.int.kind-bin"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.kind-bin]<span/></a></div>
<ul>
<li>_2진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0062</code>(<code>0b</code>)로 시작하고 2진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.int.restriction"><a class="rule-link" href="#r-lex.token.literal.int.restriction" title="lex.token.literal.int.restriction"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.restriction]<span/></a></div>
<p>모든 리터럴과 마찬가지로 정수 리터럴 뒤에는 위에서 설명한 대로 접미사가 (공백 없이) 바로 올 수 있습니다. 접미사는 <code>e</code> 또는 <code>E</code>로 시작할 수 없습니다. 이는 부동 소수점 리터럴의 지수로 해석되기 때문입니다. 이러한 접미사의 효과에 대해서는 <a href="expressions/literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>을 참조하십시오.</p>
<p>리터럴 표현식으로 허용되는 정수 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(overflowing_literals)]
</span>123;
123i32;
123u32;
123_u32;

0xff;
0xff_u8;
0x01_f32; // 정수 7986, 부동 소수점 1.0 아님
0x01_e3;  // 정수 483, 부동 소수점 1000.0 아님

0o70;
0o70_i16;

0b1111_1111_1001_0000;
0b1111_1111_1001_0000i64;
0b________1;

0usize;

// These are too big for their type, but are accepted as literal expressions.
128_i8;
256_u8;

// This is an integer literal, accepted as a floating-point literal expression.
5f32;
<span class="boring">}</span></code></pre></pre>
<p>예를 들어 <code>-1i8</code>은 <code>-</code>와 <code>1i8</code>의 두 토큰으로 분석됩니다.</p>
<p>Examples of integer literals which are not accepted as literal expressions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>0invalidSuffix;
123AFB43;
0b010a;
0xAB_CD_EF_GH;
0b1111_f32;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.int.tuple-field"><a class="rule-link" href="#r-lex.token.literal.int.tuple-field" title="lex.token.literal.int.tuple-field"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field]<span/></a></div>
<h4 id="튜플-인덱스"><a class="header" href="#튜플-인덱스">튜플 인덱스</a></h4>
<div class="rule" id="r-lex.token.literal.int.tuple-field.syntax"><a class="rule-link" href="#r-lex.token.literal.int.tuple-field.syntax" title="lex.token.literal.int.tuple-field.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
TUPLE_INDEX:<br />
   INTEGER_LITERAL</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.int.tuple-field.intro"><a class="rule-link" href="#r-lex.token.literal.int.tuple-field.intro" title="lex.token.literal.int.tuple-field.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.intro]<span/></a></div>
<p>튜플 인덱스는 <a href="types/tuple.html">튜플</a>, <a href="items/structs.html">튜플 구조체</a> 및 <a href="items/enumerations.html">튜플 변형</a>의 필드를 참조하는 데 사용됩니다.</p>
<div class="rule" id="r-lex.token.literal.int.tuple-field.eq"><a class="rule-link" href="#r-lex.token.literal.int.tuple-field.eq" title="lex.token.literal.int.tuple-field.eq"><span>[lex<wbr>.token<wbr>.literal<wbr>.int<wbr>.tuple-field<wbr>.eq]<span/></a></div>
<p>튜플 인덱스는 리터럴 토큰과 직접 비교됩니다. 튜플 인덱스는 <code>0</code>으로 시작하고 각 연속 인덱스는 값을 1씩 10진수 값으로 증가시킵니다. 따라서 10진수 값만 일치하며 값에 추가 <code>0</code> 접두사 문자가 없어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example = ("dog", "cat", 말);
let dog = example.0;
let cat = example.1;
// 다음 예제는 유효하지 않습니다.
let cat = example.01;  // 오류: `01`이라는 필드가 없습니다
let horse = example.0b10;  // 오류: `0b10`이라는 필드가 없습니다
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>참고</strong>: 튜플 인덱스에는 특정 접미사가 포함될 수 있지만 이는 유효하도록 의도된 것이 아니며 향후 버전에서 제거될 수 있습니다. 자세한 내용은 <a href="https://github.com/rust-lang/rust/issues/60210">https://github.com/rust-lang/rust/issues/60210</a>을 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-lex.token.literal.float"><a class="rule-link" href="#r-lex.token.literal.float" title="lex.token.literal.float"><span>[lex<wbr>.token<wbr>.literal<wbr>.float]<span/></a></div>
<h4 id="부동-소수점-리터럴"><a class="header" href="#부동-소수점-리터럴">부동 소수점 리터럴</a></h4>
<div class="rule" id="r-lex.token.literal.float.syntax"><a class="rule-link" href="#r-lex.token.literal.float.syntax" title="lex.token.literal.float.syntax"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
FLOAT_LITERAL :<br />
      DEC_LITERAL <code>.</code> <em>(not immediately followed by <code>.</code>, <code>_</code> or an XID_Start character)</em><br />
   | DEC_LITERAL <code>.</code> DEC_LITERAL SUFFIX_NO_E<sup>?</sup><br />
   | DEC_LITERAL (<code>.</code> DEC_LITERAL)<sup>?</sup> FLOAT_EXPONENT SUFFIX<sup>?</sup></p>
<p>FLOAT_EXPONENT :<br />
   (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup> (DEC_DIGIT|<code>_</code>)<sup>*</sup> DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.float.form"><a class="rule-link" href="#r-lex.token.literal.float.form" title="lex.token.literal.float.form"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.form]<span/></a></div>
<p>_부동 소수점 리터럴_은 두 가지 형태 중 하나를 갖습니다.</p>
<ul>
<li><em>십진수 리터럴</em> 뒤에 마침표 문자 <code>U+002E</code>(<code>.</code>)가 옵니다. 선택적으로 다른 십진수 리터럴과 선택적 _지수_가 뒤따를 수 있습니다.</li>
<li>단일 <em>십진수 리터럴</em> 뒤에 _지수_가 옵니다.</li>
</ul>
<div class="rule" id="r-lex.token.literal.float.suffix"><a class="rule-link" href="#r-lex.token.literal.float.suffix" title="lex.token.literal.float.suffix"><span>[lex<wbr>.token<wbr>.literal<wbr>.float<wbr>.suffix]<span/></a></div>
<p>정수 리터럴과 마찬가지로 부동 소수점 리터럴 뒤에는 접미사가 올 수 있습니다. 단, 접미사 앞부분이 <code>U+002E</code>(<code>.</code>)로 끝나지 않아야 합니다. 리터럴에 지수가 포함되지 않은 경우 접미사는 <code>e</code> 또는 <code>E</code>로 시작할 수 없습니다. 이러한 접미사의 효과에 대해서는 <a href="expressions/literal-expr.html#floating-point-literal-expressions">부동 소수점 리터럴 표현식</a>을 참조하십시오.</p>
<p>리터럴 표현식으로 허용되는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;
0.1f64;
0.1f32;
12E+99_f64;
let x: f64 = 2.;
<span class="boring">}</span></code></pre></pre>
<p>마지막 예는 마침표로 끝나는 부동 소수점 리터럴에 접미사 구문을 사용할 수 없기 때문에 다릅니다. <code>2.f64</code>는 <code>2</code>에서 <code>f64</code>라는 이름의 메서드를 호출하려고 시도합니다.</p>
<p>예를 들어 <code>-1.0</code>은 <code>-</code>와 <code>1.0</code>의 두 토큰으로 분석됩니다.</p>
<p>리터럴 표현식으로 허용되지 않는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>2.0f80;
2e5f80;
2e5e6;
2.0e5e6;
1.3e10u64;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.literal.reserved"><a class="rule-link" href="#r-lex.token.literal.reserved" title="lex.token.literal.reserved"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved]<span/></a></div>
<h4 id="숫자-리터럴과-유사한-예약된-형식"><a class="header" href="#숫자-리터럴과-유사한-예약된-형식">숫자 리터럴과 유사한 예약된 형식</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
RESERVED_NUMBER :<br />
      BIN_LITERAL [<code>2</code>-<code>9</code>​]<br />
   | OCT_LITERAL [<code>8</code>-<code>9</code>​]<br />
   | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) <code>.</code><br />
         <em>(not immediately followed by <code>.</code>, <code>_</code> or an XID_Start character)</em><br />
   | ( BIN_LITERAL | OCT_LITERAL ) (<code>e</code>|<code>E</code>)<br />
   | <code>0b</code> <code>_</code><sup>*</sup> <em>end of input or not BIN_DIGIT</em><br />
   | <code>0o</code> <code>_</code><sup>*</sup> <em>end of input or not OCT_DIGIT</em><br />
   | <code>0x</code> <code>_</code><sup>*</sup> <em>end of input or not HEX_DIGIT</em><br />
   | DEC_LITERAL ( . DEC_LITERAL)<sup>?</sup> (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup> <em>end of input or not DEC_DIGIT</em></p>
</blockquote>
<div class="rule" id="r-lex.token.literal.reserved.intro"><a class="rule-link" href="#r-lex.token.literal.reserved.intro" title="lex.token.literal.reserved.intro"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.intro]<span/></a></div>
<p>숫자 리터럴과 유사한 다음 어휘 형식은 _예약된 형식_입니다. 이들이 제기하는 모호성 때문에 토크나이저는 이를 별도의 토큰으로 해석하는 대신 거부합니다.</p>
<div class="rule" id="r-lex.token.literal.reserved.out-of-range"><a class="rule-link" href="#r-lex.token.literal.reserved.out-of-range" title="lex.token.literal.reserved.out-of-range"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.out-of-range]<span/></a></div>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 해당 기수 범위를 벗어나는 10진수 숫자가 오는 경우.</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.period"><a class="rule-link" href="#r-lex.token.literal.reserved.period" title="lex.token.literal.reserved.period"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.period]<span/></a></div>
<ul>
<li>접미사가 없는 2진수, 8진수 또는 16진수 리터럴 뒤에 공백 없이 마침표 문자가 오는 경우(마침표 뒤에 오는 내용에 대한 제한은 부동 소수점 리터럴과 동일).</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.exp"><a class="rule-link" href="#r-lex.token.literal.reserved.exp" title="lex.token.literal.reserved.exp"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.exp]<span/></a></div>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 <code>e</code> 또는 <code>E</code> 문자가 오는 경우.</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.empty-with-radix"><a class="rule-link" href="#r-lex.token.literal.reserved.empty-with-radix" title="lex.token.literal.reserved.empty-with-radix"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.empty-with-radix]<span/></a></div>
<ul>
<li>기수 접두사 중 하나로 시작하지만 유효한 2진수, 8진수 또는 16진수 리터럴이 아닌 입력 (숫자를 포함하지 않기 때문에).</li>
</ul>
<div class="rule" id="r-lex.token.literal.reserved.empty-exp"><a class="rule-link" href="#r-lex.token.literal.reserved.empty-exp" title="lex.token.literal.reserved.empty-exp"><span>[lex<wbr>.token<wbr>.literal<wbr>.reserved<wbr>.empty-exp]<span/></a></div>
<ul>
<li>지수에 숫자가 없는 부동 소수점 리터럴 형식을 갖는 입력.</li>
</ul>
<p>예약된 형식의 예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0b0102;  // 이것은 `0b010` 뒤에 `2`가 오는 것이 아닙니다
0o1279;  // 이것은 `0o127` 뒤에 `9`가 오는 것이 아닙니다
0x80.0;  // 이것은 `0x80` 뒤에 `.`와 `0`이 오는 것이 아닙니다
0b101e;  // 이것은 접미사가 붙은 리터럴이 아니거나, `0b101` 뒤에 `e`가 오는 것이 아닙니다
0b;      // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b`가 오는 것이 아닙니다
0b_;     // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b_`가 오는 것이 아닙니다
2e;      // this is not a floating-point literal, or `2` followed by `e`
2.0e;    // 이것은 부동 소수점 리터럴이 아니거나, `2.0` 뒤에 `e`가 오는 것이 아닙니다
2em;     // 이것은 접미사가 붙은 리터럴이 아니거나, `2` 뒤에 `em`이 오는 것이 아닙니다
2.0em;   // 이것은 접미사가 붙은 리터럴이 아니거나, `2.0` 뒤에 `em`이 오는 것이 아닙니다
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-lex.token.life"><a class="rule-link" href="#r-lex.token.life" title="lex.token.life"><span>[lex<wbr>.token<wbr>.life]<span/></a></div>
<h2 id="라이프타임과-루프-레이블"><a class="header" href="#라이프타임과-루프-레이블">라이프타임과 루프 레이블</a></h2>
<div class="rule" id="r-lex.token.life.syntax"><a class="rule-link" href="#r-lex.token.life.syntax" title="lex.token.life.syntax"><span>[lex<wbr>.token<wbr>.life<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>렉서</sup></strong><br />
LIFETIME_TOKEN :<br />
      <code>'</code> <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | <code>'_</code> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | RAW_LIFETIME</p>
<p>LIFETIME_OR_LABEL :<br />
      <code>'</code> <a href="identifiers.html">NON_KEYWORD_IDENTIFIER</a> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em><br />
   | RAW_LIFETIME</p>
<p>RAW_LIFETIME :<br />
   <code>'r#</code> <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <sub><em><code>crate</code>, <code>self</code>, <code>super</code>, <code>Self</code> 제외</em></sub> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em></p>
<p>RESERVED_RAW_LIFETIME : <code>'r#_</code> <em>(<code>'</code>가 바로 뒤에 오지 않음)</em></p>
</blockquote>
<div class="rule" id="r-lex.token.life.intro"><a class="rule-link" href="#r-lex.token.life.intro" title="lex.token.life.intro"><span>[lex<wbr>.token<wbr>.life<wbr>.intro]<span/></a></div>
<p>라이프타임 매개변수와 <a href="expressions/loop-expr.html">루프 레이블</a>은 LIFETIME_OR_LABEL 토큰을 사용합니다. 모든 LIFETIME_TOKEN은 렉서에 의해 허용되며, 예를 들어 매크로에서 사용될 수 있습니다.</p>
<div class="rule" id="r-lex.token.life.raw.intro"><a class="rule-link" href="#r-lex.token.life.raw.intro" title="lex.token.life.raw.intro"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.intro]<span/></a></div>
<p>원시 라이프타임은 일반 라이프타임과 같지만 식별자 앞에 <code>r#</code> 접두사가 붙습니다. (<code>r#</code> 접두사는 실제 라이프타임의 일부로 포함되지 않습니다.)</p>
<div class="rule" id="r-lex.token.life.raw.allowed"><a class="rule-link" href="#r-lex.token.life.raw.allowed" title="lex.token.life.raw.allowed"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.allowed]<span/></a></div>
<p>일반 라이프타임과 달리 원시 라이프타임은 <code>RAW_LIFETIME</code>에 대해 위에 나열된 키워드를 제외한 모든 엄격하거나 예약된 키워드일 수 있습니다.</p>
<div class="rule" id="r-lex.token.life.raw.reserved"><a class="rule-link" href="#r-lex.token.life.raw.reserved" title="lex.token.life.raw.reserved"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.reserved]<span/></a></div>
<p><a href="lifetime-elision.html">자리표시자 라이프타임</a>과의 혼동을 피하기 위해 RESERVED_RAW_LIFETIME 토큰 <code>'r#_</code>를 사용하는 것은 오류입니다.</p>
<div class="rule" id="r-lex.token.life.raw.edition2021"><a class="rule-link" href="#r-lex.token.life.raw.edition2021" title="lex.token.life.raw.edition2021"><span>[lex<wbr>.token<wbr>.life<wbr>.raw<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 원시 라이프타임은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 <code>'r#lt</code> 토큰이 <code>'r # lt</code>로 어휘 분석됩니다.</p>
</blockquote>
<div class="rule" id="r-lex.token.punct"><a class="rule-link" href="#r-lex.token.punct" title="lex.token.punct"><span>[lex<wbr>.token<wbr>.punct]<span/></a></div>
<h2 id="구두점"><a class="header" href="#구두점">구두점</a></h2>
<div class="rule" id="r-lex.token.punct.intro"><a class="rule-link" href="#r-lex.token.punct.intro" title="lex.token.punct.intro"><span>[lex<wbr>.token<wbr>.punct<wbr>.intro]<span/></a></div>
<p>구두점 기호 토큰은 완전성을 위해 여기에 나열됩니다. 개별적인 사용법과 의미는 링크된 페이지에 정의되어 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>이름</th><th>용법</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>더하기</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">더하기</a>, <a href="trait-bounds.html">트레이트 바운드</a>, <a href="macros-by-example.html">매크로 클리니 매처</a></td></tr>
<tr><td><code>-</code></td><td>빼기</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">빼기</a>, <a href="expressions/operator-expr.html#negation-operators">부정</a></td></tr>
<tr><td><code>*</code></td><td>별</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">곱하기</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a>, <a href="macros-by-example.html">매크로 클리니 매처</a>, <a href="items/use-declarations.html">와일드카드 사용</a></td></tr>
<tr><td><code>/</code></td><td>슬래시</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">나누기</a></td></tr>
<tr><td><code>%</code></td><td>백분율</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">나머지</a></td></tr>
<tr><td><code>^</code></td><td>캐럿</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 XOR</a></td></tr>
<tr><td><code>!</code></td><td>아님</td><td><a href="expressions/operator-expr.html#negation-operators">비트 및 논리 NOT</a>, <a href="macros-by-example.html">매크로 호출</a>, <a href="attributes.html">내부 속성</a>, <a href="types/never.html">Never 유형</a>, <a href="items/implementations.html">음수 impls</a></td></tr>
<tr><td><code>&amp;</code></td><td>그리고</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 AND</a>, <a href="expressions/operator-expr.html#borrow-operators">차용</a>, <a href="types/pointer.html">참조</a>, <a href="patterns.html#reference-patterns">참조 패턴</a></td></tr>
<tr><td><code>|</code></td><td>또는</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">비트 및 논리 OR</a>, <a href="expressions/closure-expr.html">클로저</a>, <a href="expressions/match-expr.html">match</a>, <a href="expressions/if-expr.html#if-let-expressions">if let</a> 및 <a href="expressions/loop-expr.html#predicate-pattern-loops">while let</a>의 패턴</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>그리고 그리고</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 AND</a>, <a href="expressions/operator-expr.html#borrow-operators">차용</a>, <a href="types/pointer.html">참조</a>, <a href="patterns.html#reference-patterns">참조 패턴</a></td></tr>
<tr><td><code>||</code></td><td>또는 또는</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 OR</a>, <a href="expressions/closure-expr.html">클로저</a></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Shl</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">왼쪽 시프트</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Shr</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">오른쪽 시프트</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>+=</code></td><td>PlusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">덧셈 할당</a></td></tr>
<tr><td><code>-=</code></td><td>MinusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">뺄셈 할당</a></td></tr>
<tr><td><code>*=</code></td><td>StarEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">곱셈 할당</a></td></tr>
<tr><td><code>/=</code></td><td>SlashEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">나눗셈 할당</a></td></tr>
<tr><td><code>%=</code></td><td>PercentEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">나머지 할당</a></td></tr>
<tr><td><code>^=</code></td><td>CaretEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 XOR 할당</a></td></tr>
<tr><td><code>&amp;=</code></td><td>AndEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 And 할당</a></td></tr>
<tr><td><code>|=</code></td><td>OrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">비트 Or 할당</a></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>ShlEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">왼쪽 시프트 할당</a></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>ShrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">오른쪽 시프트 할당</a>, <a href="items/generics.html">중첩 제네릭</a></td></tr>
<tr><td><code>=</code></td><td>Eq</td><td><a href="expressions/operator-expr.html#assignment-expressions">할당</a>, <a href="attributes.html">속성</a>, 다양한 유형 정의</td></tr>
<tr><td><code>==</code></td><td>EqEq</td><td><a href="expressions/operator-expr.html#comparison-operators">같음</a></td></tr>
<tr><td><code>!=</code></td><td>Ne</td><td><a href="expressions/operator-expr.html#comparison-operators">같지 않음</a></td></tr>
<tr><td><code>&gt;</code></td><td>Gt</td><td><a href="expressions/operator-expr.html#comparison-operators">보다 큼</a>, <a href="items/generics.html">제네릭</a>, <a href="paths.html">경로</a></td></tr>
<tr><td><code>&lt;</code></td><td>Lt</td><td><a href="expressions/operator-expr.html#comparison-operators">보다 작음</a>, <a href="items/generics.html">제네릭</a>, <a href="paths.html">경로</a></td></tr>
<tr><td><code>&gt;=</code></td><td>Ge</td><td><a href="expressions/operator-expr.html#comparison-operators">크거나 같음</a>, <a href="items/generics.html">제네릭</a></td></tr>
<tr><td><code>&lt;=</code></td><td>Le</td><td><a href="expressions/operator-expr.html#comparison-operators">작거나 같음</a></td></tr>
<tr><td><code>@</code></td><td>At</td><td><a href="patterns.html#identifier-patterns">하위 패턴 바인딩</a></td></tr>
<tr><td><code>_</code></td><td>밑줄</td><td><a href="patterns.html#wildcard-pattern">와일드카드 패턴</a>, <a href="types/inferred.html">추론된 유형</a>, <a href="items/constant-items.html">상수</a>의 명명되지 않은 항목, <a href="items/extern-crates.html">외부 상자</a>, <a href="items/use-declarations.html">사용 선언</a> 및 <a href="expressions/underscore-expr.html">구조 해체 할당</a></td></tr>
<tr><td><code>.</code></td><td>점</td><td><a href="expressions/field-expr.html">필드 접근</a>, <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱스</a></td></tr>
<tr><td><code>..</code></td><td>점점</td><td><a href="expressions/range-expr.html">범위</a>, <a href="expressions/struct-expr.html">구조체 표현식</a>, <a href="patterns.html">패턴</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>...</code></td><td>점점점</td><td><a href="items/external-blocks.html">가변 함수</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>..=</code></td><td>DotDotEq</td><td><a href="expressions/range-expr.html">포함 범위</a>, <a href="patterns.html#range-patterns">범위 패턴</a></td></tr>
<tr><td><code>,</code></td><td>쉼표</td><td>다양한 구분자</td></tr>
<tr><td><code>;</code></td><td>세미콜론</td><td>다양한 항목 및 문의 종결자, <a href="types/array.html">배열 유형</a></td></tr>
<tr><td><code>:</code></td><td>콜론</td><td>다양한 구분자</td></tr>
<tr><td><code>::</code></td><td>PathSep</td><td><a href="paths.html">경로 구분자</a></td></tr>
<tr><td><code>-&gt;</code></td><td>RArrow</td><td><a href="items/functions.html">함수 반환 유형</a>, <a href="expressions/closure-expr.html">클로저 반환 유형</a>, <a href="types/function-pointer.html">함수 포인터 유형</a></td></tr>
<tr><td><code>=&gt;</code></td><td>FatArrow</td><td><a href="expressions/match-expr.html">일치 암</a>, <a href="macros-by-example.html">매크로</a></td></tr>
<tr><td><code>&lt;-</code></td><td>LArrow</td><td>왼쪽 화살표 기호는 Rust 1.0 이전부터 사용되지 않았지만 여전히 단일 토큰으로 처리됩니다.</td></tr>
<tr><td><code>#</code></td><td>파운드</td><td><a href="attributes.html">속성</a></td></tr>
<tr><td><code>$</code></td><td>달러</td><td><a href="macros-by-example.html">매크로</a></td></tr>
<tr><td><code>?</code></td><td>물음표</td><td><a href="expressions/operator-expr.html#the-question-mark-operator">물음표 연산자</a>, <a href="trait-bounds.html#sized">크기가 의심스러운</a>, <a href="macros-by-example.html">매크로 클리니 매처</a></td></tr>
<tr><td><code>~</code></td><td>물결표</td><td>물결 연산자는 Rust 1.0 이전부터 사용되지 않았지만 토큰은 여전히 사용될 수 있습니다.</td></tr>
</tbody></table>
</div><div class="rule" id="r-lex.token.delim"><a class="rule-link" href="#r-lex.token.delim" title="lex.token.delim"><span>[lex<wbr>.token<wbr>.delim]<span/></a></div>
<h2 id="구분자"><a class="header" href="#구분자">구분자</a></h2>
<p>대괄호 구두점은 문법의 다양한 부분에서 사용됩니다. 여는 대괄호는 항상 닫는 대괄호와 짝을 이루어야 합니다. 대괄호와 그 안의 토큰은 <a href="macros-by-example.html">매크로</a>에서 “토큰 트리“라고 합니다. 세 가지 유형의 대괄호는 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>대괄호</th><th>유형</th></tr></thead><tbody>
<tr><td><code>{</code> <code>}</code></td><td>중괄호</td></tr>
<tr><td><code>[</code> <code>]</code></td><td>대괄호</td></tr>
<tr><td><code>(</code> <code>)</code></td><td>괄호</td></tr>
</tbody></table>
</div><div class="rule" id="r-lex.token.reserved-prefix"><a class="rule-link" href="#r-lex.token.reserved-prefix" title="lex.token.reserved-prefix"><span>[lex<wbr>.token<wbr>.reserved-prefix]<span/></a></div>
<h2 id="예약된-접두사"><a class="header" href="#예약된-접두사">예약된 접두사</a></h2>
<div class="rule" id="r-lex.token.reserved-prefix.syntax"><a class="rule-link" href="#r-lex.token.reserved-prefix.syntax" title="lex.token.reserved-prefix.syntax"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer 2021+</sup></strong><br />
RESERVED_TOKEN_DOUBLE_QUOTE : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>b</code> or <code>c</code> or <code>r</code> or <code>br</code> or <code>cr</code></em></sub> | <code>_</code> ) <code>"</code><br />
RESERVED_TOKEN_SINGLE_QUOTE : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>b</code></em></sub> | <code>_</code> ) <code>'</code><br />
RESERVED_TOKEN_POUND : ( IDENTIFIER_OR_KEYWORD <sub><em>Except <code>r</code> or <code>br</code> or <code>cr</code></em></sub> | <code>_</code> ) <code>#</code><br />
RESERVED_TOKEN_LIFETIME : <code>'</code> (IDENTIFIER_OR_KEYWORD <sub><em>Except <code>r</code></em></sub> | _) <code>#</code></p>
</blockquote>
<div class="rule" id="r-lex.token.reserved-prefix.intro"><a class="rule-link" href="#r-lex.token.reserved-prefix.intro" title="lex.token.reserved-prefix.intro"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.intro]<span/></a></div>
<p>Some lexical forms known as <em>reserved prefixes</em> are reserved for future use.</p>
<div class="rule" id="r-lex.token.reserved-prefix.id"><a class="rule-link" href="#r-lex.token.reserved-prefix.id" title="lex.token.reserved-prefix.id"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.id]<span/></a></div>
<p>Source input which would otherwise be lexically interpreted as a non-raw identifier (or a keyword or <code>_</code>) which is immediately followed by a <code>#</code>, <code>'</code>, or <code>"</code> character (without intervening whitespace) is identified as a reserved prefix.</p>
<div class="rule" id="r-lex.token.reserved-prefix.raw-token"><a class="rule-link" href="#r-lex.token.reserved-prefix.raw-token" title="lex.token.reserved-prefix.raw-token"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.raw-token]<span/></a></div>
<p>원시 식별자, 원시 문자열 리터럴 및 원시 바이트 문자열 리터럴에는 <code>#</code> 문자가 포함될 수 있지만 예약된 접두사를 포함하는 것으로 해석되지 않습니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.strings"><a class="rule-link" href="#r-lex.token.reserved-prefix.strings" title="lex.token.reserved-prefix.strings"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.strings]<span/></a></div>
<p>마찬가지로 원시 문자열 리터럴, 바이트 리터럴, 바이트 문자열 리터럴, 원시 바이트 문자열 리터럴, C 문자열 리터럴 및 원시 C 문자열 리터럴에 사용되는 <code>r</code>, <code>b</code>, <code>br</code>, <code>c</code> 및 <code>cr</code> 접두사는 예약된 접두사로 해석되지 않습니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.life"><a class="rule-link" href="#r-lex.token.reserved-prefix.life" title="lex.token.reserved-prefix.life"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.life]<span/></a></div>
<p>그렇지 않으면 어휘적으로 비원시 라이프타임(또는 키워드 또는 <code>_</code>)으로 해석될 소스 입력은 <code>#</code> 문자가 바로 뒤에 오는(중간 공백 없이) 경우 예약된 라이프타임 접두사로 식별됩니다.</p>
<div class="rule" id="r-lex.token.reserved-prefix.edition2021"><a class="rule-link" href="#r-lex.token.reserved-prefix.edition2021" title="lex.token.reserved-prefix.edition2021"><span>[lex<wbr>.token<wbr>.reserved-prefix<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션부터 예약된 접두사는 렉서에 의해 오류로 보고됩니다(특히 매크로에 전달할 수 없음).</p>
<p>2021 에디션 이전에는 예약된 접두사가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다(예: 식별자 또는 키워드에 대한 하나의 토큰 뒤에 <code>#</code> 토큰이 옴).</p>
<p>모든 에디션에서 허용되는 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a #foo}
lexes!{continue 'foo}
lexes!{match "..." {}}
lexes!{r#let#foo}         // 세 개의 토큰: r#let # foo
lexes!{'prefix #lt}
<span class="boring">}</span></code></pre></pre>
<p>2021 에디션 이전에는 허용되었지만 이후에는 거부된 예:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a#foo}
lexes!{continue'foo}
lexes!{match"..." {}}
lexes!{'prefix#lt}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-lex.token.reserved-guards"><a class="rule-link" href="#r-lex.token.reserved-guards" title="lex.token.reserved-guards"><span>[lex<wbr>.token<wbr>.reserved-guards]<span/></a></div>
<h2 id="예약된-가드"><a class="header" href="#예약된-가드">예약된 가드</a></h2>
<div class="rule" id="r-lex.token.reserved-guards.syntax"><a class="rule-link" href="#r-lex.token.reserved-guards.syntax" title="lex.token.reserved-guards.syntax"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>Lexer 2024+</sup></strong><br />
RESERVED_GUARDED_STRING_LITERAL : <code>#</code><sup>+</sup> <a href="tokens.html#string-literals">STRING_LITERAL</a><br />
RESERVED_POUNDS : <code>#</code><sup>2..</sup></p>
</blockquote>
<div class="rule" id="r-lex.token.reserved-guards.intro"><a class="rule-link" href="#r-lex.token.reserved-guards.intro" title="lex.token.reserved-guards.intro"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.intro]<span/></a></div>
<p>예약된 가드는 향후 사용을 위해 예약된 구문이며 사용하면 컴파일 오류가 발생합니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.string-literal"><a class="rule-link" href="#r-lex.token.reserved-guards.string-literal" title="lex.token.reserved-guards.string-literal"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.string-literal]<span/></a></div>
<p>_예약된 보호된 문자열 리터럴_은 하나 이상의 <code>U+0023</code>(<code>#</code>) 토큰 바로 뒤에 <a href="tokens.html#string-literals">STRING_LITERAL</a>이 오는 토큰입니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.pounds"><a class="rule-link" href="#r-lex.token.reserved-guards.pounds" title="lex.token.reserved-guards.pounds"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.pounds]<span/></a></div>
<p>_예약된 파운드_는 두 개 이상의 <code>U+0023</code>(<code>#</code>) 토큰입니다.</p>
<div class="rule" id="r-lex.token.reserved-guards.edition2024"><a class="rule-link" href="#r-lex.token.reserved-guards.edition2024" title="lex.token.reserved-guards.edition2024"><span>[lex<wbr>.token<wbr>.reserved-guards<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 예약된 가드가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다. 예를 들어, <code>#"foo"#</code> 형식은 세 개의 토큰으로 해석됩니다. <code>##</code>은 두 개의 토큰으로 해석됩니다.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="whitespace.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="whitespace.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
