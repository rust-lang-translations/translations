<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Use 선언 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/use-declarations.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/use-declarations.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/use-declarations.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[items.use]</p>
<h1 id="use-선언"><a class="header" href="#use-선언">Use 선언</a></h1>
<p>r[items.use.syntax]</p>
<pre><code class="language-grammar items">UseDeclaration -&gt; `use` UseTree `;`

UseTree -&gt;
      (SimplePath? `::`)? `*`
    | (SimplePath? `::`)? `{` (UseTree ( `,`  UseTree )* `,`?)? `}`
    | SimplePath ( `as` ( IDENTIFIER | `_` ) )?
</code></pre>
<p>r[items.use.intro] A <em>use declaration</em> creates one or more local name bindings synonymous with some other <a href="../paths.html">path</a>. Usually a <code>use</code> declaration is used to shorten the path required to refer to a module item. These declarations may appear in <a href="modules.html">modules</a> and <a href="../expressions/block-expr.html">blocks</a>, usually at the top. A <code>use</code> declaration is also sometimes called an <em>import</em>, or, if it is public, a <em>re-export</em>.</p>
<p>r[items.use.forms] Use declarations support a number of convenient shortcuts:</p>
<p>r[items.use.forms.multiple]</p>
<ul>
<li><code>use a::b::{c, d, e::f, g::h::i};</code>와 같이 중괄호 구문을 사용하여 공통 접두사를 가진 경로 목록을 동시에 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.self]</p>
<ul>
<li><code>use a::b::{self, c, d::e};</code>와 같이 <code>self</code> 키워드를 사용하여 공통 접두사를 가진 경로 목록과 그들의 공통 부모 모듈을 동시에 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.as]</p>
<ul>
<li><code>use p::q::r as x;</code> 구문을 사용하여 대상 이름을 새로운 로컬 이름으로 다시 바인딩합니다. 이는 앞의 두 기능과 함께 사용될 수도 있습니다: <code>use a::b::{self as ab, c as abc}</code>.</li>
</ul>
<p>r[items.use.forms.glob]</p>
<ul>
<li>별표 와일드카드 구문인 <code>use a::b::*;</code>를 사용하여 주어진 접두사와 일치하는 모든 경로를 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.nesting]</p>
<ul>
<li><code>use a::b::{self as ab, c, d::{*, e::f}};</code>와 같이 이전 기능들의 그룹을 여러 번 중첩하여 사용합니다.</li>
</ul>
<p><code>use</code> 선언의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // use 선언은 함수 내부에도 존재할 수 있습니다
    use std::option::Option::{Some, None};

    // 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'와 동일합니다.
    foo(vec![Some(1.0f64), None]);

    // `hash_map`과 `HashMap` 모두 스코프에 있습니다.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</code></pre></pre>
<p>r[items.use.visibility]</p>
<h2 id="use-가시성"><a class="header" href="#use-가시성"><code>use</code> 가시성</a></h2>
<p>r[items.use.visibility.intro] Like items, <code>use</code> declarations are private to the containing module, by default. Also like items, a <code>use</code> declaration can be public, if qualified by the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A public <code>use</code> declaration can therefore <em>redirect</em> some public name to a different target definition: even a definition with a private canonical path, inside a different module.</p>
<p>r[items.use.visibility.unambiguous] If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</p>
<p>다시 내보내기(re-exporting)의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod quux {
    pub use self::foo::{bar, baz};
    pub mod foo {
        pub fn bar() {}
        pub fn baz() {}
    }
}

fn main() {
    quux::bar();
    quux::baz();
}</code></pre></pre>
<p>이 예제에서 <code>quux</code> 모듈은 <code>foo</code>에 정의된 두 개의 공개 이름을 다시 내보냅니다.</p>
<p>r[items.use.path]</p>
<h2 id="use-경로"><a class="header" href="#use-경로"><code>use</code> 경로</a></h2>
<p>r[items.use.path.intro] The <a href="../paths.html">paths</a> that are allowed in a <code>use</code> item follow the [SimplePath] grammar and are similar to the paths that may be used in an expression. They may create bindings for:</p>
<ul>
<li>이름을 지을 수 있는 <a href="../items.html">아이템</a></li>
<li><a href="enumerations.html">열거형 변형</a></li>
<li><a href="../types.html">내장 타입</a></li>
<li><a href="../attributes.html">속성</a></li>
<li><a href="macro.proc.derive">Derive macros</a></li>
<li><a href="../macros-by-example.html"><code>macro_rules</code></a></li>
</ul>
<p>r[items.use.path.disallowed] They cannot import <a href="associated-items.html">associated items</a>, <a href="generics.html">generic parameters</a>, <a href="../variables.html">local variables</a>, paths with <a href="../paths.html#self"><code>Self</code></a>, or <a href="../attributes.html#tool-attributes">tool attributes</a>. More restrictions are described below.</p>
<p>r[items.use.path.namespace] <code>use</code> will create bindings for all <a href="../names/namespaces.html">namespaces</a> from the imported entities, with the exception that a <code>self</code> import will only import from the type namespace (as described below). For example, the following illustrates creating bindings for the same name in two namespaces:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod stuff {
    pub struct Foo(pub i32);
}

// `Foo` 타입과 `Foo` 생성자를 임포트합니다.
use stuff::Foo;

fn example() {
    let ctor = Foo; // 값 네임스페이스에서 `Foo`를 사용합니다.
    let x: Foo = ctor(123); // 타입 네임스페이스에서 `Foo`를 사용합니다.
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.path.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, <code>use</code> paths are relative to the crate root. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2015">mod foo {
    pub mod example { pub mod iter {} }
    pub mod baz { pub fn foobaz() {} }
}
mod bar {
    // 크레이트 루트에서 `foo`를 확인합니다.
    use foo::example::iter;
    // `::` 접두사는 명시적으로 `foo`를 확인합니다.
    // 크레이트 루트로부터.
    use ::foo::baz::foobaz;
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>2015 에디션은 use 선언이 <a href="../names/preludes.html#extern-prelude">extern 프렐류드</a>를 참조하는 것을 허용하지 않습니다. 따라서 2015 에디션에서 use 선언으로 외부 크레이트를 참조하려면 여전히 <a href="extern-crates.html"><code>extern crate</code></a> 선언이 필요합니다. 2018 에디션부터는 <code>use</code> 선언에서 <code>extern crate</code>와 동일한 방식으로 외부 크레이트 의존성을 지정할 수 있습니다.</p>
</blockquote>
<p>r[items.use.as]</p>
<h2 id="as를-이용한-이름-변경"><a class="header" href="#as를-이용한-이름-변경"><code>as</code>를 이용한 이름 변경</a></h2>
<p><code>as</code> 키워드는 임포트된 엔티티의 이름을 변경하는 데 사용될 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 함수 `foo`에 대한 비공개 별칭 `bar`를 생성합니다.
use inner::foo as bar;

mod inner {
    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.multiple-syntax]</p>
<h2 id="중괄호-구문"><a class="header" href="#중괄호-구문">중괄호 구문</a></h2>
<p>r[items.use.multiple-syntax.intro] Braces can be used in the last segment of the path to import multiple entities from the previous segment, or, if there are no previous segments, from the current scope. Braces can be nested, creating a tree of paths, where each grouping of segments is logically combined with its parent to create a full path.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
use std::collections::{BTreeSet, hash_map::{self, HashMap}};
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.multiple-syntax.empty] An empty brace does not import anything, though the leading path is validated that it is accessible.</p>
<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->
<p>r[items.use.multiple-syntax.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, paths are relative to the crate root, so an import such as <code>use {foo, bar};</code> will import the names <code>foo</code> and <code>bar</code> from the crate root, whereas starting in 2018, those names are relative to the current scope.</p>
</blockquote>
<p>r[items.use.self]</p>
<h2 id="self-임포트"><a class="header" href="#self-임포트"><code>self</code> 임포트</a></h2>
<p>r[items.use.self.intro] The keyword <code>self</code> may be used within <a href="#brace-syntax">brace syntax</a> to create a binding of the parent entity under its own name.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod stuff {
    pub fn foo() {}
    pub fn bar() {}
}
mod example {
    // `stuff`와 `foo`에 대한 바인딩을 생성합니다.
    use crate::stuff::{self, foo};
    pub fn baz() {
        foo();
        stuff::bar();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[items.use.self.namespace] <code>self</code> only creates a binding from the <a href="../names/namespaces.html">type namespace</a> of the parent entity. For example, in the following, only the <code>foo</code> mod is imported:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">mod bar {
    pub mod foo {}
    pub fn foo() {}
}

// 이는 `foo` 모듈만 임포트합니다. `foo` 함수는 값 네임스페이스에 존재하므로 임포트되지 않습니다.
use bar::foo::{self};

fn main() {
    foo(); //~ 오류: `foo`는 모듈입니다.
}</code></pre></pre>
<blockquote>
<p>[!NOTE] <code>self</code> may also be used as the first segment of a path. The usage of <code>self</code> as the first segment and inside a <code>use</code> brace is logically the same; it means the current module of the parent segment, or the current module if there is no parent segment. See <a href="../paths.html#self"><code>self</code></a> in the paths chapter for more information on the meaning of a leading <code>self</code>.</p>
</blockquote>
<p>r[items.use.glob]</p>
<h2 id="글로브-임포트"><a class="header" href="#글로브-임포트">글로브 임포트</a></h2>
<p>r[items.use.glob.intro] The <code>*</code> character may be used as the last segment of a <code>use</code> path to import all importable entities from the entity of the preceding segment. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `bar`에 대한 비공개 별칭을 생성합니다.
use foo::*;

mod foo {
    fn i_am_private() {}
    enum Example {
        V1,
        V2,
    }
    pub fn bar() {
        // `Example` 열거형의 `V1`과 `V2`에 대한
        // 지역 별칭을 생성합니다.
        use Example::*;
        let x = V1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.glob.shadowing] Items and named imports are allowed to shadow names from glob imports in the same <a href="../names/namespaces.html">namespace</a>. That is, if there is a name already defined by another item in the same namespace, the glob import will be shadowed. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이것은 `clashing::Foo` 튜플 구조체 생성자에 대한 바인딩을 생성하지만,
// 여기에 정의된 `Foo` 구조체와 충돌하기 때문에 그 타입은 임포트하지
// 않습니다.
//
// 여기서 정의 순서는 중요하지 않음에 유의하세요.
use clashing::*;
struct Foo {
    field: f32,
}

fn do_stuff() {
    // `clashing::Foo`의 생성자를 사용합니다.
    let f1 = Foo(123);
    // 구조체 표현식은 위에서 정의된
    // `Foo` 구조체의 타입을 사용합니다.
    let f2 = Foo { field: 1.0 };
    // 글로브 임포트로 인해 `Bar`도 스코프에 있습니다.
    let z = Bar {};
}

mod clashing {
    pub struct Foo(pub i32);
    pub struct Bar {}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] For areas where shadowing is not allowed, see <a href="names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
</blockquote>
<p>r[items.use.glob.last-segment-only] <code>*</code> cannot be used as the first or intermediate segments.</p>
<p>r[items.use.glob.self-import] <code>*</code> cannot be used to import a module’s contents into itself (such as <code>use self::*;</code>).</p>
<p>r[items.use.glob.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, paths are relative to the crate root, so an import such as <code>use *;</code> is valid, and it means to import everything from the crate root. This cannot be used in the crate root itself.</p>
</blockquote>
<p>r[items.use.as-underscore]</p>
<h2 id="underscore-imports"><a class="header" href="#underscore-imports">Underscore imports</a></h2>
<p>r[items.use.as-underscore.intro] Items can be imported without binding to a name by using an underscore with the form <code>use path as _</code>. This is particularly useful to import a trait so that its methods may be used without importing the trait’s symbol, for example if the trait’s symbol may conflict with another symbol. Another example is to link an external crate without importing its name.</p>
<p>r[items.use.as-underscore.glob] Asterisk glob imports will import items imported with <code>_</code> in their unnameable form.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // 밑줄 임포트는 이 아이템과의 이름 충돌을 방지합니다.

fn main() {
    let z = Zoo;
    z.zoo();
}</code></pre></pre>
<p>r[items.use.as-underscore.macro] The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to <code>_</code> imports. For example, the following should not produce an error:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// 다음과 같이 확장됩니다:
// use std as _;
// use std as _;
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.restrictions]</p>
<h2 id="제약-사항"><a class="header" href="#제약-사항">제약 사항</a></h2>
<p>다음은 유효한 <code>use</code> 선언에 대한 제약 사항입니다:</p>
<p>r[items.use.restrictions.crate]</p>
<ul>
<li><code>use crate;</code>는 크레이트 루트를 바인딩할 이름을 정의하기 위해 반드시 <code>as</code>를 사용해야 합니다.</li>
</ul>
<p>r[items.use.restrictions.self]</p>
<ul>
<li><code>use {self};</code>는 오류입니다. <code>self</code>를 사용할 때는 반드시 선행 세그먼트가 있어야 합니다.</li>
</ul>
<p>r[items.use.restrictions.duplicate-name]</p>
<ul>
<li>다른 아이템 정의와 마찬가지로, <code>use</code> 임포트는 모듈이나 블록 내의 동일한 네임스페이스에서 같은 이름으로 중복 바인딩을 생성할 수 없습니다.</li>
</ul>
<p>r[items.use.restrictions.macro-crate]</p>
<ul>
<li><code>$crate</code>를 포함한 <code>use</code> 경로는 <a href="../macros-by-example.html"><code>macro_rules</code></a> 확장 내에서 허용되지 않습니다.</li>
</ul>
<p>r[items.use.restrictions.variant]</p>
<ul>
<li><code>use</code> 경로는 <a href="type-aliases.html">타입 별칭</a>을 통해 열거형 변형을 참조할 수 없습니다. 예를 들어:
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    MyVariant
}
type TypeAlias = MyEnum;

use MyEnum::MyVariant; //~ OK
use TypeAlias::MyVariant; //~ 오류
<span class="boring">}</span></code></pre></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/extern-crates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../items/functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/extern-crates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../items/functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
