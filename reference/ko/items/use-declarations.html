<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Use 선언 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/use-declarations.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/use-declarations.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/use-declarations.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-items.use"><a class="rule-link" href="#r-items.use" title="items.use"><span>[items<wbr>.use]<span/></a></div>
<h1 id="use-선언"><a class="header" href="#use-선언">Use 선언</a></h1>
<div class="rule" id="r-items.use.syntax"><a class="rule-link" href="#r-items.use.syntax" title="items.use.syntax"><span>[items<wbr>.use<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문:</sup></strong><br />
<em>Use선언</em> :<br />
   <code>use</code> <em>Use트리</em> <code>;</code></p>
<p><em>Use트리</em> :<br />
      (<a href="../paths.html#simple-paths"><em>단순경로</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>*</code><br />
   | (<a href="../paths.html#simple-paths"><em>단순경로</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>{</code> (<em>Use트리</em> ( <code>,</code>  <em>Use트리</em> )<sup>*</sup> <code>,</code><sup>?</sup>)<sup>?</sup> <code>}</code><br />
   | <a href="../paths.html#simple-paths"><em>단순경로</em></a> ( <code>as</code> ( <a href="../identifiers.html">식별자</a> | <code>_</code> ) )<sup>?</sup></p>
</blockquote>
<div class="rule" id="r-items.use.intro"><a class="rule-link" href="#r-items.use.intro" title="items.use.intro"><span>[items<wbr>.use<wbr>.intro]<span/></a></div>
<p>_use 선언_은 다른 <a href="../paths.html">경로</a>와 동의어인 하나 이상의 로컬 이름 바인딩을 생성합니다. 일반적으로 <code>use</code> 선언은 모듈 아이템을 참조하는 데 필요한 경로를 단축하기 위해 사용됩니다. 이러한 선언은 <a href="modules.html">모듈</a>과 <a href="../expressions/block-expr.html">블록</a>에 나타날 수 있으며, 보통 최상단에 위치합니다. <code>use</code> 선언은 때때로 _임포트(import)_라고도 불리며, 공개된 경우에는 _재내보내기(re-export)_라고도 합니다.</p>
<div class="rule" id="r-items.use.forms"><a class="rule-link" href="#r-items.use.forms" title="items.use.forms"><span>[items<wbr>.use<wbr>.forms]<span/></a></div>
<p><code>use</code> 선언은 여러 편리한 단축 표기법을 지원합니다:</p>
<div class="rule" id="r-items.use.forms.multiple"><a class="rule-link" href="#r-items.use.forms.multiple" title="items.use.forms.multiple"><span>[items<wbr>.use<wbr>.forms<wbr>.multiple]<span/></a></div>
<ul>
<li><code>use a::b::{c, d, e::f, g::h::i};</code>와 같이 중괄호 구문을 사용하여 공통 접두사를 가진 경로 목록을 동시에 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.self"><a class="rule-link" href="#r-items.use.forms.self" title="items.use.forms.self"><span>[items<wbr>.use<wbr>.forms<wbr>.self]<span/></a></div>
<ul>
<li><code>use a::b::{self, c, d::e};</code>와 같이 <code>self</code> 키워드를 사용하여 공통 접두사를 가진 경로 목록과 그들의 공통 부모 모듈을 동시에 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.as"><a class="rule-link" href="#r-items.use.forms.as" title="items.use.forms.as"><span>[items<wbr>.use<wbr>.forms<wbr>.as]<span/></a></div>
<ul>
<li><code>use p::q::r as x;</code> 구문을 사용하여 대상 이름을 새로운 로컬 이름으로 다시 바인딩합니다. 이는 앞의 두 기능과 함께 사용될 수도 있습니다: <code>use a::b::{self as ab, c as abc}</code>.</li>
</ul>
<div class="rule" id="r-items.use.forms.glob"><a class="rule-link" href="#r-items.use.forms.glob" title="items.use.forms.glob"><span>[items<wbr>.use<wbr>.forms<wbr>.glob]<span/></a></div>
<ul>
<li>별표 와일드카드 구문인 <code>use a::b::*;</code>를 사용하여 주어진 접두사와 일치하는 모든 경로를 바인딩합니다.</li>
</ul>
<div class="rule" id="r-items.use.forms.nesting"><a class="rule-link" href="#r-items.use.forms.nesting" title="items.use.forms.nesting"><span>[items<wbr>.use<wbr>.forms<wbr>.nesting]<span/></a></div>
<ul>
<li><code>use a::b::{self as ab, c, d::{*, e::f}};</code>와 같이 이전 기능들의 그룹을 여러 번 중첩하여 사용합니다.</li>
</ul>
<p><code>use</code> 선언의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // use 선언은 함수 내부에도 존재할 수 있습니다
    use std::option::Option::{Some, None};

    // 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'와 동일합니다.
    foo(vec![Some(1.0f64), None]);

    // `hash_map`과 `HashMap` 모두 스코프에 있습니다.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</code></pre></pre>
<div class="rule" id="r-items.use.visibility"><a class="rule-link" href="#r-items.use.visibility" title="items.use.visibility"><span>[items<wbr>.use<wbr>.visibility]<span/></a></div>
<h2 id="use-가시성"><a class="header" href="#use-가시성"><code>use</code> 가시성</a></h2>
<div class="rule" id="r-items.use.visibility.intro"><a class="rule-link" href="#r-items.use.visibility.intro" title="items.use.visibility.intro"><span>[items<wbr>.use<wbr>.visibility<wbr>.intro]<span/></a></div>
<p>아이템과 마찬가지로, <code>use</code> 선언은 기본적으로 포함하는 모듈에 비공개(private)입니다. 또한 아이템과 마찬가지로 <code>use</code> 선언은 <code>pub</code> 키워드로 한정되면 공개(public)가 될 수 있습니다. 이러한 <code>use</code> 선언은 이름을 _다시 내보내기(re-export)_하는 역할을 합니다. 따라서 공개 <code>use</code> 선언은 일부 공개 이름을 다른 대상 정의로, 심지어 다른 모듈 내부의 비공개 정규 경로를 가진 정의로 _리디렉션_할 수 있습니다.</p>
<div class="rule" id="r-items.use.visibility.unambiguous"><a class="rule-link" href="#r-items.use.visibility.unambiguous" title="items.use.visibility.unambiguous"><span>[items<wbr>.use<wbr>.visibility<wbr>.unambiguous]<span/></a></div>
<p>이러한 리디렉션의 시퀀스가 순환을 형성하거나 모호하지 않게 해석될 수 없는 경우, 컴파일 타임 오류를 나타냅니다.</p>
<p>다시 내보내기(re-exporting)의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod quux {
    pub use self::foo::{bar, baz};
    pub mod foo {
        pub fn bar() {}
        pub fn baz() {}
    }
}

fn main() {
    quux::bar();
    quux::baz();
}</code></pre></pre>
<p>이 예제에서 <code>quux</code> 모듈은 <code>foo</code>에 정의된 두 개의 공개 이름을 다시 내보냅니다.</p>
<div class="rule" id="r-items.use.path"><a class="rule-link" href="#r-items.use.path" title="items.use.path"><span>[items<wbr>.use<wbr>.path]<span/></a></div>
<h2 id="use-경로"><a class="header" href="#use-경로"><code>use</code> 경로</a></h2>
<div class="rule" id="r-items.use.path.intro"><a class="rule-link" href="#r-items.use.path.intro" title="items.use.path.intro"><span>[items<wbr>.use<wbr>.path<wbr>.intro]<span/></a></div>
<p><code>use</code> 아이템에서 허용되는 <a href="../paths.html">경로</a>는 <a href="../paths.html#simple-paths"><em>단순경로</em></a> 문법을 따르며 표현식에서 사용될 수 있는 경로와 유사합니다. 이들은 다음에 대한 바인딩을 생성할 수 있습니다:</p>
<ul>
<li>이름을 지을 수 있는 <a href="../items.html">아이템</a></li>
<li><a href="enumerations.html">열거형 변형</a></li>
<li><a href="../types.html">내장 타입</a></li>
<li><a href="../attributes.html">속성</a></li>
<li><a href="../procedural-macros.html#derive-macros">Derive 매크로</a></li>
</ul>
<div class="rule" id="r-items.use.path.disallowed"><a class="rule-link" href="#r-items.use.path.disallowed" title="items.use.path.disallowed"><span>[items<wbr>.use<wbr>.path<wbr>.disallowed]<span/></a></div>
<p><a href="associated-items.html">연관 아이템</a>, <a href="generics.html">제네릭 매개변수</a>, <a href="../variables.html">지역 변수</a>, <a href="../paths.html#self"><code>Self</code></a>가 포함된 경로, 또는 <a href="../attributes.html#tool-attributes">도구 속성</a>은 임포트할 수 없습니다. 더 많은 제약 사항은 아래에 설명되어 있습니다.</p>
<div class="rule" id="r-items.use.path.namespace"><a class="rule-link" href="#r-items.use.path.namespace" title="items.use.path.namespace"><span>[items<wbr>.use<wbr>.path<wbr>.namespace]<span/></a></div>
<p><code>use</code>는 임포트된 엔티티의 모든 <a href="../names/namespaces.html">네임스페이스</a>에 대한 바인딩을 생성합니다. 단, <code>self</code> 임포트는 타입 네임스페이스에서만 임포트합니다(아래 설명 참조). 예를 들어, 다음은 두 네임스페이스에서 동일한 이름에 대한 바인딩을 생성하는 것을 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod stuff {
    pub struct Foo(pub i32);
}

// `Foo` 타입과 `Foo` 생성자를 임포트합니다.
use stuff::Foo;

fn example() {
    let ctor = Foo; // 값 네임스페이스에서 `Foo`를 사용합니다.
    let x: Foo = ctor(123); // 타입 네임스페이스에서 `Foo`를 사용합니다.
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.path.edition2015"><a class="rule-link" href="#r-items.use.path.edition2015" title="items.use.path.edition2015"><span>[items<wbr>.use<wbr>.path<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 <code>use</code> 경로는 크레이트 루트에 상대적입니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2015">mod foo {
    pub mod example { pub mod iter {} }
    pub mod baz { pub fn foobaz() {} }
}
mod bar {
    // 크레이트 루트에서 `foo`를 확인합니다.
    use foo::example::iter;
    // `::` 접두사는 명시적으로 `foo`를 확인합니다.
    // 크레이트 루트로부터.
    use ::foo::baz::foobaz;
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>2015 에디션은 use 선언이 <a href="../names/preludes.html#extern-prelude">extern 프렐류드</a>를 참조하는 것을 허용하지 않습니다. 따라서 2015 에디션에서 use 선언으로 외부 크레이트를 참조하려면 여전히 <a href="extern-crates.html"><code>extern crate</code></a> 선언이 필요합니다. 2018 에디션부터는 <code>use</code> 선언에서 <code>extern crate</code>와 동일한 방식으로 외부 크레이트 의존성을 지정할 수 있습니다.</p>
</blockquote>
<div class="rule" id="r-items.use.as"><a class="rule-link" href="#r-items.use.as" title="items.use.as"><span>[items<wbr>.use<wbr>.as]<span/></a></div>
<h2 id="as를-이용한-이름-변경"><a class="header" href="#as를-이용한-이름-변경"><code>as</code>를 이용한 이름 변경</a></h2>
<p><code>as</code> 키워드는 임포트된 엔티티의 이름을 변경하는 데 사용될 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 함수 `foo`에 대한 비공개 별칭 `bar`를 생성합니다.
use inner::foo as bar;

mod inner {
    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.multiple-syntax"><a class="rule-link" href="#r-items.use.multiple-syntax" title="items.use.multiple-syntax"><span>[items<wbr>.use<wbr>.multiple-syntax]<span/></a></div>
<h2 id="중괄호-구문"><a class="header" href="#중괄호-구문">중괄호 구문</a></h2>
<div class="rule" id="r-items.use.multiple-syntax.intro"><a class="rule-link" href="#r-items.use.multiple-syntax.intro" title="items.use.multiple-syntax.intro"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.intro]<span/></a></div>
<p>중괄호는 경로의 마지막 세그먼트에서 이전 세그먼트로부터 여러 엔티티를 임포트하거나, 이전 세그먼트가 없는 경우 현재 스코프에서 임포트하는 데 사용될 수 있습니다. 중괄호는 중첩될 수 있으며, 각 세그먼트 그룹이 부모와 논리적으로 결합되어 전체 경로를 형성하는 경로 트리를 생성합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
use std::collections::{BTreeSet, hash_map::{self, HashMap}};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.multiple-syntax.empty"><a class="rule-link" href="#r-items.use.multiple-syntax.empty" title="items.use.multiple-syntax.empty"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.empty]<span/></a></div>
<p>빈 중괄호는 아무것도 임포트하지 않지만, 선행 경로가 접근 가능한지는 확인됩니다.</p>
<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->
<div class="rule" id="r-items.use.multiple-syntax.edition2015"><a class="rule-link" href="#r-items.use.multiple-syntax.edition2015" title="items.use.multiple-syntax.edition2015"><span>[items<wbr>.use<wbr>.multiple-syntax<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, <code>use {foo, bar};</code>와 같은 임포트는 크레이트 루트에서 <code>foo</code>와 <code>bar</code>라는 이름을 임포트합니다. 반면 2018 에디션부터는 해당 이름들이 현재 스코프에 상대적입니다.</p>
</blockquote>
<div class="rule" id="r-items.use.self"><a class="rule-link" href="#r-items.use.self" title="items.use.self"><span>[items<wbr>.use<wbr>.self]<span/></a></div>
<h2 id="self-임포트"><a class="header" href="#self-임포트"><code>self</code> 임포트</a></h2>
<div class="rule" id="r-items.use.self.intro"><a class="rule-link" href="#r-items.use.self.intro" title="items.use.self.intro"><span>[items<wbr>.use<wbr>.self<wbr>.intro]<span/></a></div>
<p><code>self</code> 키워드는 <a href="#brace-syntax">중괄호 구문</a> 내에서 부모 엔티티를 자신의 이름으로 바인딩하는 데 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod stuff {
    pub fn foo() {}
    pub fn bar() {}
}
mod example {
    // `stuff`와 `foo`에 대한 바인딩을 생성합니다.
    use crate::stuff::{self, foo};
    pub fn baz() {
        foo();
        stuff::bar();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-items.use.self.namespace"><a class="rule-link" href="#r-items.use.self.namespace" title="items.use.self.namespace"><span>[items<wbr>.use<wbr>.self<wbr>.namespace]<span/></a></div>
<p><code>self</code>는 부모 엔티티의 <a href="../names/namespaces.html">타입 네임스페이스</a>에서만 바인딩을 생성합니다. 예를 들어, 다음 예시에서는 <code>foo</code> 모듈만 임포트됩니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">mod bar {
    pub mod foo {}
    pub fn foo() {}
}

// 이는 `foo` 모듈만 임포트합니다. `foo` 함수는 값 네임스페이스에 존재하므로 임포트되지 않습니다.
use bar::foo::{self};

fn main() {
    foo(); //~ 오류: `foo`는 모듈입니다.
}</code></pre></pre>
<blockquote>
<p><strong>참고</strong>: <code>self</code>는 경로의 첫 번째 세그먼트로도 사용될 수 있습니다. <code>self</code>를 첫 번째 세그먼트로 사용하는 것과 <code>use</code> 중괄호 내부에서 사용하는 것은 논리적으로 동일합니다. 이는 부모 세그먼트의 현재 모듈을 의미하거나, 부모 세그먼트가 없는 경우 현재 모듈을 의미합니다. 선행 <code>self</code>의 의미에 대한 자세한 내용은 경로 챕터의 <a href="../paths.html#self"><code>self</code></a>를 참조하십시오.</p>
</blockquote>
<div class="rule" id="r-items.use.glob"><a class="rule-link" href="#r-items.use.glob" title="items.use.glob"><span>[items<wbr>.use<wbr>.glob]<span/></a></div>
<h2 id="글로브-임포트"><a class="header" href="#글로브-임포트">글로브 임포트</a></h2>
<div class="rule" id="r-items.use.glob.intro"><a class="rule-link" href="#r-items.use.glob.intro" title="items.use.glob.intro"><span>[items<wbr>.use<wbr>.glob<wbr>.intro]<span/></a></div>
<p><code>*</code> 문자는 <code>use</code> 경로의 마지막 세그먼트로 사용하여 이전 세그먼트의 엔티티에서 임포트 가능한 모든 엔티티를 임포트하는 데 사용할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `bar`에 대한 비공개 별칭을 생성합니다.
use foo::*;

mod foo {
    fn i_am_private() {}
    enum Example {
        V1,
        V2,
    }
    pub fn bar() {
        // `Example` 열거형의 `V1`과 `V2`에 대한
        // 지역 별칭을 생성합니다.
        use Example::*;
        let x = V1;
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.glob.shadowing"><a class="rule-link" href="#r-items.use.glob.shadowing" title="items.use.glob.shadowing"><span>[items<wbr>.use<wbr>.glob<wbr>.shadowing]<span/></a></div>
<p>아이템과 명명된 임포트는 같은 <a href="../names/namespaces.html">네임스페이스</a>에서 글로브 임포트로 가져온 이름을 가리는(shadow) 것이 허용됩니다. 즉, 같은 네임스페이스에 다른 아이템에 의해 이미 정의된 이름이 있다면, 글로브 임포트는 가려집니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이것은 `clashing::Foo` 튜플 구조체 생성자에 대한 바인딩을 생성하지만,
// 여기에 정의된 `Foo` 구조체와 충돌하기 때문에 그 타입은 임포트하지
// 않습니다.
//
// 여기서 정의 순서는 중요하지 않음에 유의하세요.
use clashing::*;
struct Foo {
    field: f32,
}

fn do_stuff() {
    // `clashing::Foo`의 생성자를 사용합니다.
    let f1 = Foo(123);
    // 구조체 표현식은 위에서 정의된
    // `Foo` 구조체의 타입을 사용합니다.
    let f2 = Foo { field: 1.0 };
    // 글로브 임포트로 인해 `Bar`도 스코프에 있습니다.
    let z = Bar {};
}

mod clashing {
    pub struct Foo(pub i32);
    pub struct Bar {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.glob.last-segment-only"><a class="rule-link" href="#r-items.use.glob.last-segment-only" title="items.use.glob.last-segment-only"><span>[items<wbr>.use<wbr>.glob<wbr>.last-segment-only]<span/></a></div>
<p><code>*</code>는 첫 번째 또는 중간 세그먼트로 사용할 수 없습니다.</p>
<div class="rule" id="r-items.use.glob.self-import"><a class="rule-link" href="#r-items.use.glob.self-import" title="items.use.glob.self-import"><span>[items<wbr>.use<wbr>.glob<wbr>.self-import]<span/></a></div>
<p><code>*</code>는 모듈의 내용을 자기 자신에게 임포트하는 데 사용할 수 없습니다(예: <code>use self::*;</code>).</p>
<div class="rule" id="r-items.use.glob.edition2015"><a class="rule-link" href="#r-items.use.glob.edition2015" title="items.use.glob.edition2015"><span>[items<wbr>.use<wbr>.glob<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, <code>use *;</code>와 같은 임포트는 유효하며 크레이트 루트의 모든 것을 임포트한다는 의미입니다. 이는 크레이트 루트 자체에서는 사용할 수 없습니다.</p>
</blockquote>
<div class="rule" id="r-items.use.as-underscore"><a class="rule-link" href="#r-items.use.as-underscore" title="items.use.as-underscore"><span>[items<wbr>.use<wbr>.as-underscore]<span/></a></div>
<h2 id="밑줄-임포트"><a class="header" href="#밑줄-임포트">밑줄 임포트</a></h2>
<div class="rule" id="r-items.use.as-underscore.intro"><a class="rule-link" href="#r-items.use.as-underscore.intro" title="items.use.as-underscore.intro"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.intro]<span/></a></div>
<p>아이템은 <code>use path as _</code> 형식을 사용하여 이름에 바인딩하지 않고 임포트할 수 있습니다. 이는 트레잇의 심볼을 임포트하지 않고 메서드를 사용하려 할 때(예: 트레잇 심볼이 다른 심볼과 충돌할 수 있는 경우) 특히 유용합니다. 다른 예로는 이름을 임포트하지 않고 외부 크레이트를 링크하는 경우가 있습니다.</p>
<div class="rule" id="r-items.use.as-underscore.glob"><a class="rule-link" href="#r-items.use.as-underscore.glob" title="items.use.as-underscore.glob"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.glob]<span/></a></div>
<p>별표 글로브 임포트는 <code>_</code>로 임포트된 아이템을 이름 지을 수 없는 형태로 임포트합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // 밑줄 임포트는 이 아이템과의 이름 충돌을 방지합니다.

fn main() {
    let z = Zoo;
    z.zoo();
}</code></pre></pre>
<div class="rule" id="r-items.use.as-underscore.macro"><a class="rule-link" href="#r-items.use.as-underscore.macro" title="items.use.as-underscore.macro"><span>[items<wbr>.use<wbr>.as-underscore<wbr>.macro]<span/></a></div>
<p>고유하고 이름 지을 수 없는 심볼은 매크로 확장 후에 생성되므로, 매크로는 안전하게 <code>_</code> 임포트에 대한 다중 참조를 내보낼 수 있습니다. 예를 들어, 다음 코드는 오류를 생성하지 않아야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// 다음과 같이 확장됩니다:
// use std as _;
// use std as _;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-items.use.restrictions"><a class="rule-link" href="#r-items.use.restrictions" title="items.use.restrictions"><span>[items<wbr>.use<wbr>.restrictions]<span/></a></div>
<h2 id="제약-사항"><a class="header" href="#제약-사항">제약 사항</a></h2>
<p>다음은 유효한 <code>use</code> 선언에 대한 제약 사항입니다:</p>
<div class="rule" id="r-items.use.restrictions.crate"><a class="rule-link" href="#r-items.use.restrictions.crate" title="items.use.restrictions.crate"><span>[items<wbr>.use<wbr>.restrictions<wbr>.crate]<span/></a></div>
<ul>
<li><code>use crate;</code>는 크레이트 루트를 바인딩할 이름을 정의하기 위해 반드시 <code>as</code>를 사용해야 합니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.self"><a class="rule-link" href="#r-items.use.restrictions.self" title="items.use.restrictions.self"><span>[items<wbr>.use<wbr>.restrictions<wbr>.self]<span/></a></div>
<ul>
<li><code>use {self};</code>는 오류입니다. <code>self</code>를 사용할 때는 반드시 선행 세그먼트가 있어야 합니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.duplicate-name"><a class="rule-link" href="#r-items.use.restrictions.duplicate-name" title="items.use.restrictions.duplicate-name"><span>[items<wbr>.use<wbr>.restrictions<wbr>.duplicate-name]<span/></a></div>
<ul>
<li>다른 아이템 정의와 마찬가지로, <code>use</code> 임포트는 모듈이나 블록 내의 동일한 네임스페이스에서 같은 이름으로 중복 바인딩을 생성할 수 없습니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.macro-crate"><a class="rule-link" href="#r-items.use.restrictions.macro-crate" title="items.use.restrictions.macro-crate"><span>[items<wbr>.use<wbr>.restrictions<wbr>.macro-crate]<span/></a></div>
<ul>
<li><code>$crate</code>를 포함한 <code>use</code> 경로는 <a href="../macros-by-example.html"><code>macro_rules</code></a> 확장 내에서 허용되지 않습니다.</li>
</ul>
<div class="rule" id="r-items.use.restrictions.variant"><a class="rule-link" href="#r-items.use.restrictions.variant" title="items.use.restrictions.variant"><span>[items<wbr>.use<wbr>.restrictions<wbr>.variant]<span/></a></div>
<ul>
<li><code>use</code> 경로는 <a href="type-aliases.html">타입 별칭</a>을 통해 열거형 변형을 참조할 수 없습니다. 예를 들어:
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    MyVariant
}
type TypeAlias = MyEnum;

use MyEnum::MyVariant; //~ OK
use TypeAlias::MyVariant; //~ 오류
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div class="rule" id="r-items.use.ambiguities"><a class="rule-link" href="#r-items.use.ambiguities" title="items.use.ambiguities"><span>[items<wbr>.use<wbr>.ambiguities]<span/></a></div>
<h2 id="모호성"><a class="header" href="#모호성">모호성</a></h2>
<blockquote>
<p><strong>참고</strong>: 이 섹션은 미완성입니다.</p>
</blockquote>
<div class="rule" id="r-items.use.ambiguities.intro"><a class="rule-link" href="#r-items.use.ambiguities.intro" title="items.use.ambiguities.intro"><span>[items<wbr>.use<wbr>.ambiguities<wbr>.intro]<span/></a></div>
<p><code>use</code> 선언이 어떤 이름을 참조하는지 모호한 경우 오류가 발생하는 상황이 있습니다. 이는 동일한 엔티티로 해석되지 않는 두 개의 이름 후보가 있을 때 발생합니다.</p>
<div class="rule" id="r-items.use.ambiguities.glob"><a class="rule-link" href="#r-items.use.ambiguities.glob" title="items.use.ambiguities.glob"><span>[items<wbr>.use<wbr>.ambiguities<wbr>.glob]<span/></a></div>
<p>글로브(Glob) 임포트는 해당 이름이 사용되지 않는 한 동일한 네임스페이스에서 충돌하는 이름들을 임포트하는 것이 허용됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub struct Qux;
}

mod bar {
    pub struct Qux;
}

use foo::*;
use bar::*; //~ OK, 이름 충돌 없음.

fn main() {
    // 이는 모호성으로 인해 오류가 됩니다.
    //let x = Qux;
}</code></pre></pre>
<p>여러 글로브 임포트가 동일한 이름을 임포트할 수 있으며, 임포트된 항목들이 (재내보내기를 거쳐) 동일한 아이템인 경우 해당 이름을 사용할 수 있습니다. 이름의 가시성은 임포트된 것들 중 최대 가시성을 가집니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub struct Qux;
}

mod bar {
    pub use super::foo::Qux;
}

// 이 둘은 모두 동일한 `Qux`를 임포트합니다. `Qux`의 가시성은 이 두 `use` 선언 사이의 최대 가시성인 `pub`이 됩니다.
pub use bar::*;
use foo::*;

fn main() {
    let _: Qux = Qux;
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/extern-crates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../items/functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/extern-crates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../items/functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
