<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>제네릭 파라미터 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/generics.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/generics.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/generics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[items.generics]</p>
<h1 id="제네릭-파라미터"><a class="header" href="#제네릭-파라미터">제네릭 파라미터</a></h1>
<p>r[items.generics.syntax]</p>
<pre><code class="language-grammar items">GenericParams -&gt; `&lt;` ( GenericParam (`,` GenericParam)* `,`? )? `&gt;`

GenericParam -&gt; OuterAttribute* ( LifetimeParam | TypeParam | ConstParam )

LifetimeParam -&gt; Lifetime ( `:` LifetimeBounds )?

TypeParam -&gt; IDENTIFIER ( `:` TypeParamBounds? )? ( `=` Type )?

ConstParam -&gt;
    `const` IDENTIFIER `:` Type
    ( `=` ( BlockExpression | IDENTIFIER | `-`?LiteralExpression ) )?
</code></pre>
<p>r[items.generics.syntax.intro] <a href="functions.html">Functions</a>, <a href="type-aliases.html">type aliases</a>, <a href="structs.html">structs</a>, <a href="enumerations.html">enumerations</a>, <a href="unions.html">unions</a>, <a href="traits.html">traits</a>, and <a href="implementations.html">implementations</a> may be <em>parameterized</em> by types, constants, and lifetimes. These parameters are listed in angle <span class="parenthetical">brackets (<code>&lt;...&gt;</code>)</span>, usually immediately after the name of the item and before its definition. For implementations, which don’t have a name, they come directly after <code>impl</code>.</p>
<p>r[items.generics.syntax.decl-order] The order of generic parameters is restricted to lifetime parameters and then type and const parameters intermixed.</p>
<p>r[items.generics.syntax.duplicate-params] The same parameter name may not be declared more than once in a [GenericParams] list.</p>
<p>타입, 상수, 라이프타임 매개변수를 가진 아이템의 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, T&gt;() {}
trait A&lt;U&gt; {}
struct Ref&lt;'a, T&gt; where T: 'a { r: &amp;'a T }
struct InnerArray&lt;T, const N: usize&gt;([T; N]);
struct EitherOrderWorks&lt;const N: bool, U&gt;(U);
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.syntax.scope] Generic parameters are in scope within the item definition where they are declared. They are not in scope for items declared within the body of a function as described in <a href="../statements.html#item-declarations">item declarations</a>. See <a href="../names/scopes.html#generic-parameter-scopes">generic parameter scopes</a> for more details.</p>
<p>r[items.generics.builtin-generic-types] <a href="../types/pointer.html#shared-references-">References</a>, <a href="../types/pointer.html#raw-pointers-const-and-mut">raw pointers</a>, <a href="../types/array.html">arrays</a>, <a href="../types/slice.html">slices</a>, <a href="../types/tuple.html">tuples</a>, and <a href="../types/function-pointer.html">function pointers</a> have lifetime or type parameters as well, but are not referred to with path syntax.</p>
<p>r[items.generics.invalid-lifetimes] <code>'_</code> and <code>'static</code> are not valid lifetime parameter names.</p>
<p>r[items.generics.const]</p>
<h3 id="상수-제네릭"><a class="header" href="#상수-제네릭">상수 제네릭</a></h3>
<p>r[items.generics.const.intro] <em>Const generic parameters</em> allow items to be generic over constant values.</p>
<p>r[items.generics.const.namespace] The const identifier introduces a name in the <a href="../names/namespaces.html">value namespace</a> for the constant parameter, and all instances of the item must be instantiated with a value of the given type.</p>
<p>r[items.generics.const.allowed-types] The only allowed types of const parameters are <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>, <code>char</code> and <code>bool</code>.</p>
<p>r[items.generics.const.usage] Const parameters can be used anywhere a <a href="constant-items.html">const item</a> can be used, with the exception that when used in a <a href="../types.html">type</a> or <a href="../expressions/array-expr.html">array repeat expression</a>, it must be standalone (as described below). That is, they are allowed in the following places:</p>
<ol>
<li>해당 아이템 시그니처의 일부를 형성하는 모든 타입에 적용된 상수로 사용될 때.</li>
<li><a href="associated-items.html#associated-constants">연관 상수</a>를 정의하는 데 사용되는 상수 표현식의 일부로 사용되거나, <a href="associated-items.html#associated-types">연관 타입</a>의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에 있는 모든 런타임 표현식의 값으로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에서 사용되는 모든 타입의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 필드의 타입의 일부로 사용될 때.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 있는 예시.

// 아이템 자체의 시그니처에서 사용됨.
fn foo&lt;const N: usize&gt;(arr: [i32; N]) {
    // 함수 본문 내에서 타입으로 사용됨.
    let x: [i32; N];
    // 표현식으로 사용됩니다.
    println!("{}", N * 2);
}

// 구조체의 필드로 사용됨.
struct Foo&lt;const N: usize&gt;([i32; N]);

impl&lt;const N: usize&gt; Foo&lt;N&gt; {
    // 연관 상수로 사용됨.
    const CONST: usize = N * 4;
}

trait Trait {
    type Output;
}

impl&lt;const N: usize&gt; Trait for Foo&lt;N&gt; {
    // 연관 타입으로 사용됨.
    type Output = [i32; N];
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 없는 예시.
fn foo&lt;const N: usize&gt;() {
    // 함수 본문 내의 아이템 정의에서는 사용할 수 없음.
    const BAD_CONST: [usize; N] = [1; N];
    static BAD_STATIC: [usize; N] = [1; N];
    fn inner(bad_arg: [usize; N]) {
        let bad_value = N * 2;
    }
    type BadAlias = [usize; N];
    struct BadStruct([usize; N]);
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.standalone] As a further restriction, const parameters may only appear as a standalone argument inside of a <a href="../types.html">type</a> or <a href="../expressions/array-expr.html">array repeat expression</a>. In those contexts, they may only be used as a single segment <a href="../expressions/path-expr.html">path expression</a>, possibly inside a <a href="../expressions/block-expr.html">block</a> (such as <code>N</code> or <code>{N}</code>). That is, they cannot be combined with other expressions.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 매개변수를 사용할 수 없는 예시.

// 타입 내에서 다른 표현식과 결합하는 것은 허용되지 않습니다. 예를 들어
// 여기 반환 타입에 있는 산술 표현식과 같은 경우입니다.
fn bad_function&lt;const N: usize&gt;() -&gt; [u8; {N + 1}] {
    // 배열 반복 표현식에서도 마찬가지로 허용되지 않습니다.
    [1; {N + 1}]
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.argument] A const argument in a <a href="../paths.html">path</a> specifies the const value to use for that item.</p>
<p>r[items.generics.const.argument.const-expr] The argument must either be an <a href="items.generics.const.inferred">inferred const</a> or be a <a href="../const_eval.html#constant-expressions">const expression</a> of the type ascribed to the const parameter. The const expression must be a <a href="../expressions/block-expr.html">block expression</a> (surrounded with braces) unless it is a single path segment (an [IDENTIFIER]) or a <a href="../expressions/literal-expr.html">literal</a> (with a possibly leading <code>-</code> token).</p>
<blockquote>
<p>[!NOTE] This syntactic restriction is necessary to avoid requiring infinite lookahead when parsing an expression inside of a type.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;const N: i64&gt;;
const C: i64 = 1;
fn f&lt;const N: i64&gt;() -&gt; S&lt;N&gt; { S }

let _ = f::&lt;1&gt;(); // Literal.
let _ = f::&lt;-1&gt;(); // Negative literal.
let _ = f::&lt;{ 1 + 2 }&gt;(); // Constant expression.
let _ = f::&lt;C&gt;(); // Single segment path.
let _ = f::&lt;{ C + 1 }&gt;(); // Constant expression.
let _: S&lt;1&gt; = f::&lt;_&gt;(); // Inferred const.
let _: S&lt;1&gt; = f::&lt;(((_)))&gt;(); // Inferred const.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In a generic argument list, an <a href="items.generics.const.inferred">inferred const</a> is parsed as an [inferred type][InferredType] but then semantically treated as a separate kind of <a href="items.generics.const.argument">const generic argument</a>.</p>
</blockquote>
<p>r[items.generics.const.inferred] Where a const argument is expected, an <code>_</code> (optionally surrounded by any number of matching parentheses), called the <em>inferred const</em> ([path rules][paths.expr.complex-const-params], [array expression rules][expr.array.length-restriction]), can be used instead. This asks the compiler to infer the const argument if possible based on surrounding information.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_buf&lt;const N: usize&gt;() -&gt; [u8; N] {
    [0; _]
    //  ^ Infers `N`.
}
let _: [u8; 1024] = make_buf::&lt;_&gt;();
//                             ^ Infers `1024`.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] An <a href="items.generics.const.inferred">inferred const</a> is not semantically an [expression][Expression] and so is not accepted within braces.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;const N: usize&gt;() -&gt; [u8; N] { [0; _] }
let _: [_; 1] = f::&lt;{ _ }&gt;();
//                    ^ ERROR `_` not allowed here
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.generics.const.inferred.constraint] The inferred const cannot be used in item signatures.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;const N: usize&gt;(x: [u8; N]) -&gt; [u8; _] { x }
//                                       ^ ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.type-ambiguity] When there is ambiguity if a generic argument could be resolved as either a type or const argument, it is always resolved as a type. Placing the argument in a block expression can force it to be interpreted as a const argument.</p>
<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once
    namespaces are introduced, and it is clear which namespace each parameter
    lives in. -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type N = u32;
struct Foo&lt;const N: usize&gt;;
// 다음은 오류입니다. `N`이 타입 별칭 `N`으로 해석되기 때문입니다.
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // 오류
// 중괄호로 감싸서 강제로 상수 매개변수 `N`으로 해석되게 함으로써
// 해결할 수 있습니다.
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.variance] Unlike type and lifetime parameters, const parameters can be declared without being used inside of a parameterized item, with the exception of implementations as described in <a href="implementations.html#generic-implementations">generic implementations</a>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ok
struct Foo&lt;const N: usize&gt;;
enum Bar&lt;const M: usize&gt; { A, B }

// 오류: 사용되지 않은 매개변수
struct Baz&lt;T&gt;;
struct Biz&lt;'a&gt;;
struct Unconstrained;
impl&lt;const N: usize&gt; Unconstrained {}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.exhaustiveness] When resolving a trait bound obligation, the exhaustiveness of all implementations of const parameters is not considered when determining if the bound is satisfied. For example, in the following, even though all possible const values for the <code>bool</code> type are implemented, it is still an error that the trait bound is not satisfied:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;const B: bool&gt;;
trait Bar {}
impl Bar for Foo&lt;true&gt; {}
impl Bar for Foo&lt;false&gt; {}

fn needs_bar(_: impl Bar) {}
fn generic&lt;const B: bool&gt;() {
    let v = Foo::&lt;B&gt;;
    needs_bar(v); // 오류: 트레잇 바운드 `Foo&lt;B&gt;: Bar`가 충족되지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.where]</p>
<h2 id="where-절"><a class="header" href="#where-절">Where 절</a></h2>
<p>r[items.generics.where.syntax]</p>
<pre><code class="language-grammar items">WhereClause -&gt; `where` ( WhereClauseItem `,` )* WhereClauseItem?

WhereClauseItem -&gt;
      LifetimeWhereClauseItem
    | TypeBoundWhereClauseItem

LifetimeWhereClauseItem -&gt; Lifetime `:` LifetimeBounds

TypeBoundWhereClauseItem -&gt; ForLifetimes? Type `:` TypeParamBounds?
</code></pre>
<p>r[items.generics.where.intro] <em>Where clauses</em> provide another way to specify bounds on type and lifetime parameters as well as a way to specify bounds on types that aren’t type parameters.</p>
<p>r[items.generics.where.higher-ranked-lifetimes] The <code>for</code> keyword can be used to introduce <a href="../trait-bounds.html#higher-ranked-trait-bounds">higher-ranked lifetimes</a>. It only allows [LifetimeParam] parameters.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt;
where
    T: Iterator,            // 대신 A&lt;T: Iterator&gt;를 사용할 수 있습니다.
    T::Item: Copy,          // 연관 타입에 대한 바운드
    String: PartialEq&lt;T&gt;,   // 타입 매개변수를 사용하여 `String`에 대한 바운드 지정
    i32: Default,           // 허용되지만 유용하지는 않음
{
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.attributes]</p>
<h2 id="속성"><a class="header" href="#속성">속성</a></h2>
<p>제네릭 라이프타임 및 타입 매개변수에는 <a href="../attributes.html">속성</a>을 붙일 수 있습니다. 이 위치에서 무언가를 수행하는 내장 속성은 없지만, 커스텀 derive 속성이 여기에 의미를 부여할 수 있습니다.</p>
<p>이 예시는 커스텀 derive 속성을 사용하여 제네릭 매개변수의 의미를 수정하는 방법을 보여줍니다.</p>
<!-- ignore: requires proc macro derive -->
<pre><code class="language-rust ignore">// MyFlexibleClone에 대한 derive가 `my_flexible_clone`을 이해할 수 있는
// 속성으로 선언했다고 가정합니다.
#[derive(MyFlexibleClone)]
struct Foo&lt;#[my_flexible_clone(unbounded)] H&gt; {
    a: *const H
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/external-blocks.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../items/associated-items.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/external-blocks.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../items/associated-items.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
