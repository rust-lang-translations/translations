<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>함수 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/functions.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/functions.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/functions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[items.fn]</p>
<h1 id="함수"><a class="header" href="#함수">함수</a></h1>
<p>r[items.fn.syntax]</p>
<pre><code class="language-grammar items">Function -&gt;
    FunctionQualifiers `fn` IDENTIFIER GenericParams?
        `(` FunctionParameters? `)`
        FunctionReturnType? WhereClause?
        ( BlockExpression | `;` )

FunctionQualifiers -&gt; `const`? `async`?[^async-edition] ItemSafety?[^extern-qualifiers] (`extern` Abi?)?

ItemSafety -&gt; `safe`[^extern-safe] | `unsafe`

Abi -&gt; STRING_LITERAL | RAW_STRING_LITERAL

FunctionParameters -&gt;
      SelfParam `,`?
    | (SelfParam `,`)? FunctionParam (`,` FunctionParam)* `,`?

SelfParam -&gt; OuterAttribute* ( ShorthandSelf | TypedSelf )

ShorthandSelf -&gt; (`&amp;` | `&amp;` Lifetime)? `mut`? `self`

TypedSelf -&gt; `mut`? `self` `:` Type

FunctionParam -&gt; OuterAttribute* ( FunctionParamPattern | `...` | Type[^fn-param-2015] )

FunctionParamPattern -&gt; PatternNoTopAlt `:` ( Type | `...` )

FunctionReturnType -&gt; `-&gt;` Type
</code></pre>
<div class="footnote-definition" id="async-edition"><sup class="footnote-definition-label">1</sup>
<p><code>async</code> 한정자는 2015 에디션에서 허용되지 않습니다.</p>
</div>
<div class="footnote-definition" id="extern-safe"><sup class="footnote-definition-label">2</sup>
<p><code>safe</code> 함수 한정자는 시맨틱적으로 <code>extern</code> 블록 내에서만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="extern-qualifiers"><sup class="footnote-definition-label">3</sup>
<p><em>Rust 2024 이전 에디션 관련</em>: <code>extern</code> 블록 내에서, <code>safe</code> 또는 <code>unsafe</code> 함수 한정자는 <code>extern</code>이 <code>unsafe</code>로 한정될 때만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="fn-param-2015"><sup class="footnote-definition-label">4</sup>
<p>타입만 있는 함수 매개변수는 2015 에디션에서 <a href="traits.html">트레잇 아이템</a>의 연관 함수에서만 허용됩니다.</p>
</div>
<p>r[items.fn.intro] A <em>function</em> consists of a <a href="../expressions/block-expr.html">block</a> (that’s the <em>body</em> of the function), along with a name, a set of parameters, and an output type. Other than a name, all these are optional.</p>
<p>r[items.fn.namespace] Functions are declared with the keyword <code>fn</code> which defines the given name in the <a href="../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.fn.signature] Functions may declare a set of <em>input</em> <a href="../variables.html"><em>variables</em></a> as parameters, through which the caller passes arguments into the function, and the <em>output</em> <a href="../types.html#type-expressions"><em>type</em></a> of the value the function will return to its caller on completion.</p>
<p>r[items.fn.implicit-return] If the output type is not explicitly stated, it is the <a href="../types/tuple.html">unit type</a>.</p>
<p>r[items.fn.fn-item-type] When referred to, a <em>function</em> yields a first-class <em>value</em> of the corresponding zero-sized <a href="../types/function-item.html"><em>function item type</em></a>, which when called evaluates to a direct call to the function.</p>
<p>예를 들어, 이것은 간단한 함수입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.safety-qualifiers] The <code>safe</code> function is semantically only allowed when used in an <a href="external-blocks.html"><code>extern</code> block</a>.</p>
<p>r[items.fn.params]</p>
<h2 id="함수-매개변수"><a class="header" href="#함수-매개변수">함수 매개변수</a></h2>
<p>r[items.fn.params.intro] Function parameters are irrefutable <a href="../patterns.html">patterns</a>, so any pattern that is valid in an else-less <code>let</code> binding is also valid as a parameter:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first((value, _): (i32, i32)) -&gt; i32 { value }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.params.self-pat] If the first parameter is a [SelfParam], this indicates that the function is a <a href="associated-items.html#methods">method</a>.</p>
<p>r[items.fn.params.self-restriction] Functions with a self parameter may only appear as an <a href="associated-items.html#associated-functions-and-methods">associated function</a> in a <a href="traits.html">trait</a> or <a href="implementations.html">implementation</a>.</p>
<p>r[items.fn.params.varargs] A parameter with the <code>...</code> token indicates a <a href="external-blocks.html#variadic-functions">variadic function</a>, and may only be used as the last parameter of an <a href="external-blocks.html">external block</a> function. The variadic parameter may have an optional identifier, such as <code>args: ...</code>.</p>
<p>r[items.fn.body]</p>
<h2 id="함수-본문"><a class="header" href="#함수-본문">함수 본문</a></h2>
<p>r[items.fn.body.intro] The body block of a function is conceptually wrapped in another block that first binds the argument patterns and then <code>return</code>s the value of the function’s body. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</p>
<p>예를 들어, 위의 함수는 마치 다음과 같이 작성된 것처럼 동작합니다:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">// argument_0은 호출자로부터 전달된 실제 첫 번째 인자입니다.
let (value, _) = argument_0;
return {
    value
};</code></pre>
<p>r[items.fn.body.bodyless] Functions without a body block are terminated with a semicolon. This form may only appear in a <a href="traits.html">trait</a> or <a href="external-blocks.html">external block</a>.</p>
<p>r[items.fn.generics]</p>
<h2 id="제네릭-함수"><a class="header" href="#제네릭-함수">제네릭 함수</a></h2>
<p>r[items.fn.generics.intro] A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo는 A와 B에 대해 제네릭합니다.

fn foo&lt;A, B&gt;(x: A, y: B) {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[items.fn.generics.param-names] Inside the function signature and body, the name of the type parameter can be used as a type name.</p>
<p>r[items.fn.generics.param-bounds] <a href="traits.html">Trait</a> bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the <code>where</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;T&gt;(x: T) where T: Debug {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[items.fn.generics.mono] When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the <code>foo</code> function here:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // 세부 사항 생략
}

foo(&amp;[1, 2]);
<span class="boring">}</span></code></pre></pre>
<p>타입 매개변수 <code>T</code>를 <code>i32</code>로 인스턴스화할 것입니다.</p>
<p>r[items.fn.generics.explicit-arguments] The type parameters can also be explicitly supplied in a trailing <a href="../paths.html">path</a> component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, <code>mem::size_of::&lt;u32&gt;() == 4</code>.</p>
<p>r[items.fn.extern]</p>
<h2 id="외부-함수-한정자"><a class="header" href="#외부-함수-한정자">외부 함수 한정자</a></h2>
<p>r[items.fn.extern.intro] The <code>extern</code> function qualifier allows providing function <em>definitions</em> that can be called with a particular ABI:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">extern "ABI" fn foo() { /* ... */ }</code></pre>
<p>r[items.fn.extern.def] These are often used in combination with <a href="external-blocks.html">external block</a> items which provide function <em>declarations</em> that can be used to call functions without providing their <em>definition</em>:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">unsafe extern "ABI" {
  unsafe fn foo(); /* 본문 없음 */
  safe fn bar(); /* 본문 없음 */
}
unsafe { foo() };
bar();</code></pre>
<p>r[items.fn.extern.default-abi] When <code>"extern" Abi?*</code> is omitted from <code>FunctionQualifiers</code> in function items, the ABI <code>"Rust"</code> is assigned. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "Rust" fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.foreign-call] Functions can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// "C" ABI를 가진 함수를 선언합니다.
extern "C" fn new_i32() -&gt; i32 { 0 }

// "stdcall" ABI를 가진 함수를 선언합니다.
<span class="boring">#[cfg(any(windows, target_arch = "x86"))]
</span>extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.default-extern] Just as with <a href="external-blocks.html">external block</a>, when the <code>extern</code> keyword is used and the <code>"ABI"</code> is omitted, the ABI used defaults to <code>"C"</code>. That is, this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" fn new_i32() -&gt; i32 { 0 }
let fptr: extern "C" fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.unwind]</p>
<h3 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h3>
<p>r[items.fn.extern.unwind.intro] Most ABI strings come in two variants, one with an <code>-unwind</code> suffix and one without. The <code>Rust</code> ABI always permits unwinding, so there is no <code>Rust-unwind</code> ABI. The choice of ABI, together with the runtime <a href="../panic.html#the-panic_handler-attribute">panic handler</a>, determines the behavior when unwinding out of a function.</p>
<p>r[items.fn.extern.unwind.behavior] The table below indicates the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition using the corresponding ABI string). Note that the Rust runtime is not affected by, and cannot have an effect on, any unwinding that occurs entirely within another language’s runtime, that is, unwinds that are thrown and caught without reaching a Rust ABI boundary.</p>
<p>The <code>panic</code>-unwind column refers to <a href="../panic.html">panicking</a> via the <code>panic!</code> macro and similar standard library mechanisms, as well as to any other Rust operations that cause a panic, such as out-of-bounds array indexing or integer overflow.</p>
<p>The “unwinding” ABI category refers to <code>"Rust"</code> (the implicit ABI of Rust functions not marked <code>extern</code>), <code>"C-unwind"</code>, and any other ABI with <code>-unwind</code> in its name. The “non-unwinding” ABI category refers to all other ABI strings, including <code>"C"</code> and <code>"stdcall"</code>.</p>
<p>Native unwinding is defined per-target. On targets that support throwing and catching C++ exceptions, it refers to the mechanism used to implement this feature. Some platforms implement a form of unwinding referred to as <a href="https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html#forced-unwinding">“forced unwinding”</a>; <code>longjmp</code> on Windows and <code>pthread_exit</code> in <code>glibc</code> are implemented this way. Forced unwinding is explicitly excluded from the “Native unwind” column in the table.</p>
<div class="table-wrapper"><table><thead><tr><th>panic runtime</th><th>ABI</th><th><code>panic</code>-unwind</th><th>Native unwind (unforced)</th></tr></thead><tbody>
<tr><td><code>panic=unwind</code></td><td>unwinding</td><td>unwind</td><td>unwind</td></tr>
<tr><td><code>panic=unwind</code></td><td>non-unwinding</td><td>abort (see notes below)</td><td><a href="../behavior-considered-undefined.html">undefined behavior</a></td></tr>
<tr><td><code>panic=abort</code></td><td>unwinding</td><td><code>panic</code> aborts without unwinding</td><td>abort</td></tr>
<tr><td><code>panic=abort</code></td><td>non-unwinding</td><td><code>panic</code> aborts without unwinding</td><td><a href="../behavior-considered-undefined.html">undefined behavior</a></td></tr>
</tbody></table>
</div>
<p>r[items.fn.extern.abort] With <code>panic=unwind</code>, when a <code>panic</code> is turned into an abort by a non-unwinding ABI boundary, either no destructors (<code>Drop</code> calls) will run, or all destructors up until the ABI boundary will run. It is unspecified which of those two behaviors will happen.</p>
<p>For other considerations and limitations regarding unwinding across FFI boundaries, see the <a href="../panic.html#unwinding-across-ffi-boundaries">relevant section in the Panic documentation</a>.</p>
<p>r[items.fn.const]</p>
<h2 id="const-함수"><a class="header" href="#const-함수">const 함수</a></h2>
<p>See <a href="../const_eval.html#const-functions">const functions</a> for the definition of const functions.</p>
<p>r[items.fn.async]</p>
<h2 id="비동기-함수"><a class="header" href="#비동기-함수">비동기 함수</a></h2>
<p>r[items.fn.async.intro] Functions may be qualified as async, and this can also be combined with the <code>unsafe</code> qualifier:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn regular_example() { }
async unsafe fn unsafe_example() { }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.async.future] Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function’s body.</p>
<p>r[items.fn.async.desugar-brief] An async function is roughly equivalent to a function that returns <a href="../types/impl-trait.html"><code>impl Future</code></a> and with an <a href="../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> as its body:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 소스
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::future::Future;
</span>// 디슈거링(Desugared)
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.async.desugar] The actual desugaring is more complex:</p>
<p>r[items.fn.async.lifetime-capture]</p>
<ul>
<li>디슈거링에서의 반환 타입은 <code>async fn</code> 선언의 모든 라이프타임 매개변수를 캡처한다고 가정합니다. 이는 위의 디슈거링 예시에서 <code>'a</code>보다 명시적으로 오래 살며, 따라서 이를 캡처하는 것에서 확인할 수 있습니다.</li>
</ul>
<p>r[items.fn.async.param-capture]</p>
<ul>
<li>본문의 <a href="../expressions/block-expr.html#async-blocks"><code>async move</code> 블록</a>은 사용되지 않거나 <code>_</code> 패턴에 바인딩된 매개변수를 포함하여 모든 함수 매개변수를 캡처합니다. 이는 함수가 비동기가 아닐 때와 동일한 순서로 함수 매개변수가 드롭되도록 보장하지만, 드롭은 반환된 퓨처가 완전히 어웨이트(awaited)되었을 때 발생한다는 점이 다릅니다.</li>
</ul>
<p>비동기의 효과에 대한 자세한 내용은 <a href="../expressions/block-expr.html#async-blocks"><code>async</code> 블록</a>을 참조하십시오.</p>
<p>r[items.fn.async.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Async functions are only available beginning with Rust 2018.</p>
</blockquote>
<p>r[items.fn.async.safety]</p>
<h3 id="async와-unsafe-결합하기"><a class="header" href="#async와-unsafe-결합하기"><code>async</code>와 <code>unsafe</code> 결합하기</a></h3>
<p>r[items.fn.async.safety.intro] It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an <code>unsafe</code> context is not required to “await” it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 어웨이트되었을 때 `x`를 역참조하는 퓨처를 반환합니다.
//
// 건전성 조건: 결과 퓨처가 완료될 때까지 `x`를 안전하게 역참조할 수 있어야 합니다.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // 함수를 처음 호출하려면 `unsafe` 블록이 필요합니다.
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // 하지만 여기서는 `unsafe` 블록이 필요하지 않습니다. 이는 `p`의 값을 읽을 것입니다.
    let q = future.await;
}
<span class="boring">}</span></code></pre></pre>
<p>이 동작은 <code>impl Future</code>를 반환하는 함수로의 디슈거링 결과입니다. 이 경우 디슈거링된 함수는 <code>unsafe</code> 함수이지만, 반환 값은 동일하게 유지됩니다.</p>
<p>Unsafe는 다른 함수에서 사용되는 것과 정확히 동일한 방식으로 비동기 함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 몇 가지 추가적인 의무를 부과함을 나타냅니다. 다른 모든 unsafe 함수와 마찬가지로, 이러한 조건은 초기 호출 자체를 넘어 확장될 수 있습니다. 예를 들어, 위의 스니펫에서 <code>unsafe_example</code> 함수는 포인터 <code>x</code>를 인자로 받았고, (어웨이트되었을 때) 해당 포인터를 역참조했습니다. 이는 퓨처가 실행을 마칠 때까지 <code>x</code>가 유효해야 함을 의미하며, 이를 보장하는 것은 호출자의 책임입니다.</p>
<p>r[items.fn.attributes]</p>
<h2 id="함수의-속성"><a class="header" href="#함수의-속성">함수의 속성</a></h2>
<p>r[items.fn.attributes.intro] <a href="../attributes.html">Outer attributes</a> are allowed on functions. <a href="../attributes.html">Inner attributes</a> are allowed directly after the <code>{</code> inside its body <a href="../expressions/block-expr.html">block</a>.</p>
<p>이 예시는 함수의 내부 속성을 보여줍니다. 이 함수는 단지 “Example“이라는 단어로 문서화됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn documented() {
    #![doc = "예시"]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Except for lints, it is idiomatic to only use outer attributes on function items.</p>
</blockquote>
<p>r[items.fn.attributes.builtin-attributes] The attributes that have meaning on a function are:</p>
<ul>
<li><a href="../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a></li>
<li><a href="../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a></li>
<li><a href="../attributes/codegen.html#the-cold-attribute"><code>cold</code></a></li>
<li><a href="../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a></li>
<li><a href="../../rustdoc/the-doc-attribute.html"><code>doc</code></a></li>
<li><a href="../abi.html#the-export_name-attribute"><code>export_name</code></a></li>
<li><a href="../attributes/codegen.html#the-inline-attribute"><code>inline</code></a></li>
<li><a href="../abi.html#the-link_section-attribute"><code>link_section</code></a></li>
<li><a href="../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a></li>
<li><a href="../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a></li>
<li><a href="../attributes/diagnostics.html#lint-check-attributes">Lint check attributes</a></li>
<li><a href="macro.proc.attribute">Procedural macro attributes</a></li>
<li><a href="../attributes/testing.html">Testing attributes</a></li>
</ul>
<p>r[items.fn.param-attributes]</p>
<h2 id="함수-매개변수의-속성"><a class="header" href="#함수-매개변수의-속성">함수 매개변수의 속성</a></h2>
<p>r[items.fn.param-attributes.intro] <a href="../attributes.html">Outer attributes</a> are allowed on function parameters and the permitted <a href="../attributes.html#built-in-attributes-index">built-in attributes</a> are restricted to <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.param-attributes.parsed-attributes] Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final <code>TokenStream</code>.</p>
<p>예를 들어, 다음 코드는 어디에도 공식적으로 정의되지 않은 비활성 <code>some_inert_attribute</code> 속성을 정의하고, <code>some_proc_macro_attribute</code> 절차적 매크로가 그 존재를 감지하여 출력 토큰 스트림에서 제거하는 역할을 담당합니다.</p>
<!-- ignore: requires proc macro -->
<pre><code class="language-rust ignore">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/use-declarations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../items/type-aliases.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/use-declarations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../items/type-aliases.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
