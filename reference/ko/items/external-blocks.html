<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>외부 블록 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/external-blocks.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/external-blocks.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/external-blocks.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[items.extern]</p>
<h1 id="외부-블록"><a class="header" href="#외부-블록">외부 블록</a></h1>
<p>r[items.extern.syntax]</p>
<pre><code class="language-grammar items">ExternBlock -&gt;
    `unsafe`?[^unsafe-2024] `extern` Abi? `{`
        InnerAttribute*
        ExternalItem*
    `}`

ExternalItem -&gt;
    OuterAttribute* (
        MacroInvocationSemi
      | Visibility? StaticItem
      | Visibility? Function
    )
</code></pre>
<div class="footnote-definition" id="unsafe-2024"><sup class="footnote-definition-label">1</sup>
<p>2024 에디션부터는 <code>unsafe</code> 키워드가 시맨틱적으로 요구됩니다.</p>
</div>
<p>r[items.extern.intro] External blocks provide <em>declarations</em> of items that are not <em>defined</em> in the current crate and are the basis of Rust’s foreign function interface. These are akin to unchecked imports.</p>
<p>r[items.extern.allowed-kinds] Two kinds of item <em>declarations</em> are allowed in external blocks: <a href="functions.html">functions</a> and <a href="static-items.html">statics</a>.</p>
<p>r[items.extern.safety] Calling unsafe functions or accessing unsafe statics that are declared in external blocks is only allowed in an <a href="../unsafe-keyword.html"><code>unsafe</code> context</a>.</p>
<p>r[items.extern.namespace] The external block defines its functions and statics in the <a href="../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.extern.unsafe-required] The <code>unsafe</code> keyword is semantically required to appear before the <code>extern</code> keyword on external blocks.</p>
<p>r[items.extern.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Prior to the 2024 edition, the <code>unsafe</code> keyword is optional. The <code>safe</code> and <code>unsafe</code> item qualifiers are only allowed if the external block itself is marked as <code>unsafe</code>.</p>
</blockquote>
<p>r[items.extern.fn]</p>
<h2 id="함수"><a class="header" href="#함수">함수</a></h2>
<p>r[items.extern.fn.body] Functions within external blocks are declared in the same way as other Rust functions, with the exception that they must not have a body and are instead terminated by a semicolon.</p>
<p>r[items.extern.fn.param-patterns] Patterns are not allowed in parameters, only [IDENTIFIER] or <code>_</code> may be used.</p>
<p>r[items.extern.fn.qualifiers] The <code>safe</code> and <code>unsafe</code> function qualifiers are allowed, but other function qualifiers (e.g. <code>const</code>, <code>async</code>, <code>extern</code>) are not.</p>
<p>r[items.extern.fn.foreign-abi] Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</p>
<p>r[items.extern.fn.safety] A function declared in an extern block is implicitly <code>unsafe</code> unless the <code>safe</code> function qualifier is present.</p>
<p>r[items.extern.fn.fn-ptr] When coerced to a function pointer, a function declared in an extern block has type <code>extern "abi" for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code>, where <code>'l1</code>, … <code>'lm</code> are its lifetime parameters, <code>A1</code>, …, <code>An</code> are the declared types of its parameters, and <code>R</code> is the declared return type.</p>
<p>r[items.extern.static]</p>
<h2 id="정적-아이템"><a class="header" href="#정적-아이템">정적 아이템</a></h2>
<p>r[items.extern.static.intro] Statics within external blocks are declared in the same way as <a href="static-items.html">statics</a> outside of external blocks, except that they do not have an expression initializing their value.</p>
<p>r[items.extern.static.safety] Unless a static item declared in an extern block is qualified as <code>safe</code>, it is <code>unsafe</code> to access that item, whether or not it’s mutable, because there is nothing guaranteeing that the bit pattern at the static’s memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge of initializing the static.</p>
<p>r[items.extern.static.mut] Extern statics can be either immutable or mutable just like <a href="static-items.html">statics</a> outside of external blocks.</p>
<p>r[items.extern.static.read-only] An immutable static <em>must</em> be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it. Once Rust code runs, mutating an immutable static (from inside or outside Rust) is UB, except if the mutation happens to bytes inside of an <code>UnsafeCell</code>.</p>
<p>r[items.extern.abi]</p>
<h2 id="abi"><a class="header" href="#abi">ABI</a></h2>
<p>r[items.extern.abi.intro] The <code>extern</code> keyword can be followed by an optional <a href="glossary.abi">ABI</a> string. The ABI specifies the calling convention of the functions in the block. The calling convention defines a low-level interface for functions, such as how arguments are placed in registers or on the stack, how return values are passed, and who is responsible for cleaning up the stack.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Interface to the Windows API.
unsafe extern "system" { /* ... */ }
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.extern.abi.default] If the ABI string is not specified, it defaults to <code>"C"</code>.</p>
<blockquote>
<p>[!NOTE] The <code>extern</code> syntax without an explicit ABI is being phased out, so it’s better to always write the ABI explicitly.</p>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/134986">Rust issue #134986</a>.</p>
</blockquote>
<p>r[items.extern.abi.standard] The following ABI strings are supported on all platforms:</p>
<p>r[items.extern.abi.rust]</p>
<ul>
<li><code>unsafe extern "Rust"</code> — The native calling convention for Rust functions and closures. This is the default when a function is declared without using <a href="items.fn.extern"><code>extern fn</code></a>. The Rust ABI offers no stability guarantees.</li>
</ul>
<p>r[items.extern.abi.c]</p>
<ul>
<li><code>unsafe extern "C"</code> — The “C” ABI matches the default ABI chosen by the dominant C compiler for the target.</li>
</ul>
<p>r[items.extern.abi.system]</p>
<ul>
<li>
<p><code>unsafe extern "system"</code> — This is equivalent to <code>extern "C"</code> except on Windows x86_32 where it is equivalent to <code>"stdcall"</code> for non-variadic functions, and equivalent to <code>"C"</code> for variadic functions.</p>
<blockquote>
<p>[!NOTE] As the correct underlying ABI on Windows is target-specific, it’s best to use <code>extern "system"</code> when attempting to link Windows API functions that don’t use an explicitly defined ABI.</p>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.unwind]</p>
<ul>
<li><code>extern "C-unwind"</code> and <code>extern "system-unwind"</code> — Identical to <code>"C"</code> and <code>"system"</code>, respectively, but with <a href="functions.html#unwinding">different behavior</a> when the callee unwinds (by panicking or throwing a C++ style exception).</li>
</ul>
<p>r[items.extern.abi.platform] There are also some platform-specific ABI strings:</p>
<p>r[items.extern.abi.cdecl]</p>
<ul>
<li>
<p><code>unsafe extern "cdecl"</code> — The calling convention typically used with x86_32 C code.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__cdecl</code> and GCC and clang’s <code>__attribute__((cdecl))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl">https://learn.microsoft.com/en-us/cpp/cpp/cdecl</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.stdcall]</p>
<ul>
<li>
<p><code>unsafe extern "stdcall"</code> — The calling convention typically used by the <a href="https://learn.microsoft.com/en-us/windows/win32/api/">Win32 API</a> on x86_32.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__stdcall</code> and GCC and clang’s <code>__attribute__((stdcall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall">https://learn.microsoft.com/en-us/cpp/cpp/stdcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall">https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.win64]</p>
<ul>
<li>
<p><code>unsafe extern "win64"</code> — The Windows x64 ABI.</p>
<ul>
<li>Only available on x86_64 targets.</li>
<li>“win64” is the same as the “C” ABI on Windows x86_64 targets.</li>
<li>Corresponds to GCC and clang’s <code>__attribute__((ms_abi))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions">https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.sysv64]</p>
<ul>
<li>
<p><code>unsafe extern "sysv64"</code> — The System V ABI.</p>
<ul>
<li>Only available on x86_64 targets.</li>
<li>“sysv64” is the same as the “C” ABI on non-Windows x86_64 targets.</li>
<li>Corresponds to GCC and clang’s <code>__attribute__((sysv_abi))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://wiki.osdev.org/System_V_ABI">https://wiki.osdev.org/System_V_ABI</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.aapcs]</p>
<ul>
<li>
<p><code>unsafe extern "aapcs"</code> — The soft-float ABI for ARM.</p>
<ul>
<li>Only available on ARM32 targets.</li>
<li>“aapcs” is the same as the “C” ABI on soft-float ARM32.</li>
<li>Corresponds to clang’s <code>__attribute__((pcs("aapcs")))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://developer.arm.com/documentation/107656/0101/Getting-started-with-Armv8-M-based-systems/Procedure-Call-Standard-for-Arm-Architecture--AAPCS-">Arm Procedure Call Standard</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.fastcall]</p>
<ul>
<li>
<p><code>unsafe extern "fastcall"</code> — A “fast” variant of stdcall that passes some arguments in registers.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__fastcall</code> and GCC and clang’s <code>__attribute__((fastcall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall">https://learn.microsoft.com/en-us/cpp/cpp/fastcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall">https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.thiscall]</p>
<ul>
<li>
<p><code>unsafe extern "thiscall"</code> — The calling convention typically used on C++ class member functions on x86_32 MSVC.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__thiscall</code> and GCC and clang’s <code>__attribute__((thiscall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall">https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall</a></li>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall">https://learn.microsoft.com/en-us/cpp/cpp/thiscall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.efiapi]</p>
<ul>
<li><code>unsafe extern "efiapi"</code> — The ABI used for <a href="https://uefi.org/specifications">UEFI</a> functions.
<ul>
<li>Only available on x86 and ARM targets (32bit and 64bit).</li>
</ul>
</li>
</ul>
<p>r[items.extern.abi.platform-unwind-variants] Like <code>"C"</code> and <code>"system"</code>, most platform-specific ABI strings also have a <a href="functions.html#unwinding">corresponding <code>-unwind</code> variant</a>; specifically, these are:</p>
<ul>
<li><code>"aapcs-unwind"</code></li>
<li><code>"cdecl-unwind"</code></li>
<li><code>"fastcall-unwind"</code></li>
<li><code>"stdcall-unwind"</code></li>
<li><code>"sysv64-unwind"</code></li>
<li><code>"thiscall-unwind"</code></li>
<li><code>"win64-unwind"</code></li>
</ul>
<p>r[items.extern.variadic]</p>
<h2 id="가변-인자-함수"><a class="header" href="#가변-인자-함수">가변 인자 함수</a></h2>
<p>외부 블록 내의 함수는 마지막 인수로 <code>...</code>을 지정하여 가변 인자 함수가 될 수 있습니다. 가변 인자 매개변수는 선택적으로 식별자를 가질 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    unsafe fn foo(...);
    unsafe fn bar(x: i32, ...);
    unsafe fn with_name(format: *const u8, args: ...);
    // SAFETY: This function guarantees it will not access
    // variadic arguments.
    safe fn ignores_variadic_arguments(x: i32, ...);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!WARNING] The <code>safe</code> qualifier should not be used on a function in an <code>extern</code> block unless that function guarantees that it will not access the variadic arguments at all. Passing an unexpected number of arguments or arguments of unexpected type to a variadic function may lead to [undefined behavior][undefined].</p>
</blockquote>
<p>r[items.extern.variadic.conventions] Variadic parameters can only be specified within <code>extern</code> blocks with the following ABI strings or their corresponding [<code>-unwind</code> variants][items.fn.extern.unwind]:</p>
<ul>
<li><code>"aapcs"</code></li>
<li><code>"C"</code></li>
<li><code>"cdecl"</code></li>
<li><code>"efiapi"</code></li>
<li><code>"system"</code></li>
<li><code>"sysv64"</code></li>
<li><code>"win64"</code></li>
</ul>
<p>r[items.extern.attributes]</p>
<h2 id="외부-블록의-속성"><a class="header" href="#외부-블록의-속성">외부 블록의 속성</a></h2>
<p>r[items.extern.attributes.intro] The following <a href="../attributes.html">attributes</a> control the behavior of external blocks.</p>
<p>r[items.extern.attributes.link]</p>
<h3 id="link-속성"><a class="header" href="#link-속성"><code>link</code> 속성</a></h3>
<p>r[items.extern.attributes.link.intro] The <em><code>link</code> attribute</em> specifies the name of a native library that the compiler should link with for the items within an <code>extern</code> block.</p>
<p>r[items.extern.attributes.link.syntax] It uses the [MetaListNameValueStr] syntax to specify its inputs. The <code>name</code> key is the name of the native library to link. The <code>kind</code> key is an optional value which specifies the kind of library with the following possible values:</p>
<p>r[items.extern.attributes.link.dylib]</p>
<ul>
<li><code>dylib</code> — 동적 라이브러리임을 나타냅니다. <code>kind</code>가 지정되지 않은 경우의 기본값입니다.</li>
</ul>
<p>r[items.extern.attributes.link.static]</p>
<ul>
<li><code>static</code> — 정적 라이브러리임을 나타냅니다.</li>
</ul>
<p>r[items.extern.attributes.link.framework]</p>
<ul>
<li><code>framework</code> — macOS 프레임워크임을 나타냅니다. macOS 타겟인 경우에만 유효합니다.</li>
</ul>
<p>r[items.extern.attributes.link.raw-dylib]</p>
<ul>
<li><code>raw-dylib</code> — 컴파일러가 링크를 위해 임포트 라이브러리를 생성할 동적 라이브러리임을 나타냅니다(자세한 내용은 아래의 <a href="#dylib-versus-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a> 섹션을 참조하세요). Windows 타겟인 경우에만 유효합니다.</li>
</ul>
<p>r[items.extern.attributes.link.name-requirement] The <code>name</code> key must be included if <code>kind</code> is specified.</p>
<p>r[items.extern.attributes.link.modifiers] The optional <code>modifiers</code> argument is a way to specify linking modifiers for the library to link.</p>
<p>r[items.extern.attributes.link.modifiers.syntax] Modifiers are specified as a comma-delimited string with each modifier prefixed with either a <code>+</code> or <code>-</code> to indicate that the modifier is enabled or disabled, respectively.</p>
<p>r[items.extern.attributes.link.modifiers.multiple] Specifying multiple <code>modifiers</code> arguments in a single <code>link</code> attribute, or multiple identical modifiers in the same <code>modifiers</code> argument is not currently supported.<br />
Example: <code>#[link(name = "mylib", kind = "static", modifiers = "+whole-archive")]</code>.</p>
<p>r[items.extern.attributes.link.wasm_import_module] The <code>wasm_import_module</code> key may be used to specify the <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly module</a> name for the items within an <code>extern</code> block when importing symbols from the host environment. The default module name is <code>env</code> if <code>wasm_import_module</code> is not specified.</p>
<!-- ignore: requires extern linking -->
<pre><code class="language-rust ignore">#[link(name = "crypto")]
unsafe extern {
    // …
}

#[link(name = "CoreFoundation", kind = "framework")]
unsafe extern {
    // …
}

#[link(wasm_import_module = "foo")]
unsafe extern {
    // …
}</code></pre>
<p>r[items.extern.attributes.link.empty-block] It is valid to add the <code>link</code> attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</p>
<p>r[items.extern.attributes.link.modifiers.bundle]</p>
<h4 id="링크-수정자-bundle"><a class="header" href="#링크-수정자-bundle">링크 수정자: <code>bundle</code></a></h4>
<p>r[items.extern.attributes.link.modifiers.bundle.allowed-kinds] This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.behavior] When building a rlib or staticlib <code>+bundle</code> means that the native static library will be packed into the rlib or staticlib archive, and then retrieved from there during linking of the final binary.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.behavior-negative] When building a rlib <code>-bundle</code> means that the native static library is registered as a dependency of that rlib “by name”, and object files from it are included only during linking of the final binary, the file search by that name is also performed during final linking.<br />
When building a staticlib <code>-bundle</code> means that the native static library is simply not included into the archive and some higher level build system will need to add it later during linking of the final binary.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.no-effect] This modifier has no effect when building other targets like executables or dynamic libraries.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.default] The default for this modifier is <code>+bundle</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="../../rustc/command-line-arguments.html#linking-modifiers-bundle">rustc의 <code>bundle</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive]</p>
<h4 id="링크-수정자-whole-archive"><a class="header" href="#링크-수정자-whole-archive">링크 수정자: <code>whole-archive</code></a></h4>
<p>r[items.extern.attributes.link.modifiers.whole-archive.allowed-kinds] This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive.behavior] <code>+whole-archive</code> means that the static library is linked as a whole archive without throwing any object files away.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive.default] The default for this modifier is <code>-whole-archive</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="../../rustc/command-line-arguments.html#linking-modifiers-whole-archive">rustc의 <code>whole-archive</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim]</p>
<h3 id="링크-수정자-verbatim"><a class="header" href="#링크-수정자-verbatim">링크 수정자: <code>verbatim</code></a></h3>
<p>r[items.extern.attributes.link.modifiers.verbatim.allowed-kinds] This modifier is compatible with all linking kinds.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.behavior] <code>+verbatim</code> means that rustc itself won’t add any target-specified library prefixes or suffixes (like <code>lib</code> or <code>.a</code>) to the library name, and will try its best to ask for the same thing from the linker.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.behavior-negative] <code>-verbatim</code> means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won’t prevent linker from implicitly adding it.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.default] The default for this modifier is <code>-verbatim</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="../../rustc/command-line-arguments.html#linking-modifiers-verbatim">rustc의 <code>verbatim</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib]</p>
<h4 id="dylib-대-raw-dylib"><a class="header" href="#dylib-대-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a></h4>
<p>r[items.extern.attributes.link.kind-raw-dylib.intro] On Windows, linking against a dynamic library requires that an import library is provided to the linker: this is a special static library that declares all of the symbols exported by the dynamic library in such a way that the linker knows that they have to be dynamically loaded at runtime.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib.import] Specifying <code>kind = "dylib"</code> instructs the Rust compiler to link an import library based on the <code>name</code> key. The linker will then use its normal library resolution logic to find that import library. Alternatively, specifying <code>kind = "raw-dylib"</code> instructs the compiler to generate an import library during compilation and provide that to the linker instead.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib.platform-specific] <code>raw-dylib</code> is only supported on Windows. Using it when targeting other platforms will result in a compiler error.</p>
<p>r[items.extern.attributes.link.import_name_type]</p>
<h4 id="import_name_type-키"><a class="header" href="#import_name_type-키"><code>import_name_type</code> 키</a></h4>
<p>r[items.extern.attributes.link.import_name_type.intro] On x86 Windows, names of functions are “decorated” (i.e., have a specific prefix and/or suffix added) to indicate their calling convention. For example, a <code>stdcall</code> calling convention function with the name <code>fn1</code> that has no arguments would be decorated as <code>_fn1@0</code>. However, the <a href="https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type">PE Format</a> does also permit names to have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains use different decorations for the same calling conventions which means, by default, some Win32 functions cannot be called using the <code>raw-dylib</code> link kind via the GNU toolchain.</p>
<p>r[items.extern.attributes.link.import_name_type.values] To allow for these differences, when using the <code>raw-dylib</code> link kind you may also specify the <code>import_name_type</code> key with one of the following values to change how functions are named in the generated import library:</p>
<ul>
<li><code>decorated</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 완전히 장식됩니다.</li>
<li><code>noprefix</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 장식되지만, 앞의 <code>?</code>, <code>@</code> 또는 선택적으로 <code>_</code>를 생략합니다.</li>
<li><code>undecorated</code>: 함수 이름이 장식되지 않습니다.</li>
</ul>
<p>r[items.extern.attributes.link.import_name_type.default] If the <code>import_name_type</code> key is not specified, then the function name will be fully-decorated using the target toolchain’s format.</p>
<p>r[items.extern.attributes.link.import_name_type.variables] Variables are never decorated and so the <code>import_name_type</code> key has no effect on how they are named in the generated import library.</p>
<p>r[items.extern.attributes.link.import_name_type.platform-specific] The <code>import_name_type</code> key is only supported on x86 Windows. Using it when targeting other platforms will result in a compiler error.</p>
<!-- template:attributes -->
<p>r[items.extern.attributes.link_name]</p>
<h3 id="link_name-속성"><a class="header" href="#link_name-속성"><code>link_name</code> 속성</a></h3>
<p>r[items.extern.attributes.link_name.intro] The <em><code>link_name</code> <a href="../attributes.html">attribute</a></em> may be applied to declarations inside an <code>extern</code> block to specify the symbol to import for the given function or static.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    #[link_name = "actual_symbol_name"]
    safe fn name_in_rust();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.extern.attributes.link_name.syntax] The <code>link_name</code> attribute uses the [MetaNameValueStr] syntax.</p>
<p>r[items.extern.attributes.link_name.allowed-positions] The <code>link_name</code> attribute may only be applied to a function or static item in an <code>extern</code> block.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[items.extern.attributes.link_name.duplicates] Only the last use of <code>link_name</code> on an item has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use preceding the last. This may become an error in the future.</p>
</blockquote>
<p>r[items.extern.attributes.link_name.link_ordinal] The <code>link_name</code> attribute may not be used with the <a href="items.extern.attributes.link_ordinal"><code>link_ordinal</code></a> attribute.</p>
<p>r[items.extern.attributes.link_ordinal]</p>
<h3 id="link_ordinal-속성"><a class="header" href="#link_ordinal-속성"><code>link_ordinal</code> 속성</a></h3>
<p>r[items.extern.attributes.link_ordinal.intro] The <em><code>link_ordinal</code> attribute</em> can be applied on declarations inside an <code>extern</code> block to indicate the numeric ordinal to use when generating the import library to link against. An ordinal is a unique number per symbol exported by a dynamic library on Windows and can be used when the library is being loaded to find that symbol rather than having to look it up by name.</p>
<blockquote>
<p>[!WARNING] <code>link_ordinal</code> should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(all(windows, target_arch = "x86"))]
</span>#[link(name = "exporter", kind = "raw-dylib")]
unsafe extern "stdcall" {
    #[link_ordinal(15)]
    safe fn imported_function_stdcall(i: i32);
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.extern.attributes.link_ordinal.allowed-kinds] This attribute is only used with the <code>raw-dylib</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link_ordinal.exclusive] Using this attribute with the <code>link_name</code> attribute will result in a compiler error.</p>
<p>r[items.extern.attributes.fn-parameters]</p>
<h3 id="함수-매개변수의-속성"><a class="header" href="#함수-매개변수의-속성">함수 매개변수의 속성</a></h3>
<p>외부 함수의 매개변수에 붙는 속성들은 <a href="functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/implementations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../items/generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/implementations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../items/generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
