<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Associated items - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/items/associated-items.md`;
                    } else {
                        canonical_href = `${base}/${lang}/items/associated-items.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/items/associated-items.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[items.associated]</p>
<h1 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h1>
<p>r[items.associated.syntax]</p>
<pre><code class="language-grammar items">AssociatedItem -&gt;
    OuterAttribute* (
        MacroInvocationSemi
      | ( Visibility? ( TypeAlias | ConstantItem | Function ) )
    )
</code></pre>
<p>r[items.associated.intro] <em>Associated Items</em> are the items declared in <a href="traits.html">traits</a> or defined in <a href="implementations.html">implementations</a>. They are called this because they are defined on an associate type — the type in the implementation.</p>
<p>r[items.associated.kinds] They are a subset of the kinds of items you can declare in a module. Specifically, there are <a href="#associated-functions-and-methods">associated functions</a> (including methods), <a href="#associated-types">associated types</a>, and <a href="#associated-constants">associated constants</a>.</p>
<p>r[items.associated.related] Associated items are useful when the associated item is logically related to the associating item. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically related to Options, so should be associated.</p>
<p>r[items.associated.decl-def] Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.</p>
<p>r[items.associated.trait-items] It is the declarations that make up the contract of traits and what is available on generic types.</p>
<p>r[items.associated.fn]</p>
<h2 id="연관-함수와-메서드"><a class="header" href="#연관-함수와-메서드">연관 함수와 메서드</a></h2>
<p>r[items.associated.fn.intro] <em>Associated functions</em> are <a href="functions.html">functions</a> associated with a type.</p>
<p>r[items.associated.fn.decl] An <em>associated function declaration</em> declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a <code>;</code>.</p>
<p>r[items.associated.name] The identifier is the name of the function.</p>
<p>r[items.associated.same-signature] The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations’s.</p>
<p>r[items.associated.fn.def] An <em>associated function definition</em> defines a function associated with another type. It is written the same as a <a href="../types/function-item.html">function item</a>.</p>
<blockquote>
<p>[!NOTE] A common example is an associated function named <code>new</code> that returns a value of the type with which it is associated.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}</code></pre></pre>
<p>r[items.associated.fn.qualified-self] When the associated function is declared on a trait, the function can also be called with a <a href="../paths.html">path</a> that is a path to the trait appended by the name of the trait. When this happens, it is substituted for <code>&lt;_ as Trait&gt;::function_name</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// 이 경우 이 4가지는 모두 동일합니다.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.fn.method]</p>
<h3 id="메서드"><a class="header" href="#메서드">메서드</a></h3>
<p>r[items.associated.fn.method.intro] Associated functions whose first parameter is named <code>self</code> are called <em>methods</em> and may be invoked using the <a href="../expressions/method-call-expr.html">method call operator</a>, for example, <code>x.foo()</code>, as well as the usual function call notation.</p>
<p>r[items.associated.fn.method.self-ty] If the type of the <code>self</code> parameter is specified, it is limited to types resolving to one generated by the following grammar (where <code>'lt</code> denotes some arbitrary lifetime):</p>
<pre><code class="language-text">P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</code></pre>
<p>이 문법에서 <code>Self</code> 터미널(terminal)은 구현 타입으로 해석되는 타입을 나타냅니다. 여기에는 문맥적 타입 별칭 <code>Self</code>, 다른 타입 별칭, 또는 구현 타입으로 해석되는 연관 타입 투영(associated type projections)이 포함될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// `Example` 구조체에 구현된 메서드의 예시.
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[associated.fn.method.self-pat-shorthands] Shorthand syntax can be used without specifying a type, which have the following equivalents:</p>
<div class="table-wrapper"><table><thead><tr><th>단축 구문</th><th>동등한 표현</th></tr></thead><tbody>
<tr><td><code>self</code></td><td><code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code></td><td><code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code></td><td><code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE] Lifetimes can be, and usually are, elided with this shorthand.</p>
</blockquote>
<p>r[associated.fn.method.self-pat-mut] If the <code>self</code> parameter is prefixed with <code>mut</code>, it becomes a mutable variable, similar to regular parameters using a <code>mut</code> <a href="../patterns.html#identifier-patterns">identifier pattern</a>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
<span class="boring">}</span></code></pre></pre>
<p>트레잇의 메서드 예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
<span class="boring">}</span></code></pre></pre>
<p>이것은 두 개의 메서드를 가진 트레잇을 정의합니다. 트레잇이 스코프 내에 있는 동안 이 트레잇의 <a href="implementations.html">구현</a>을 가진 모든 값은 <code>draw</code> 및 <code>bounding_box</code> 메서드를 호출할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span><span class="boring">trait Shape {
</span><span class="boring">    fn draw(&amp;self, surface: Surface);
</span><span class="boring">    fn bounding_box(&amp;self) -&gt; BoundingBox;
</span><span class="boring">}
</span><span class="boring">
</span>struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
<span class="boring">  fn draw(&amp;self, _: Surface) {}
</span><span class="boring">  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
</span>}

<span class="boring">impl Circle {
</span><span class="boring">    fn new() -&gt; Circle { Circle{} }
</span><span class="boring">}
</span><span class="boring">
</span>let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.fn.params.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. <code>fn foo(u8)</code>). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</p>
</blockquote>
<p>r[items.associated.fn.param-attributes]</p>
<h4 id="메서드-매개변수의-속성"><a class="header" href="#메서드-매개변수의-속성">메서드 매개변수의 속성</a></h4>
<p>메서드 매개변수의 속성은 <a href="functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>
<p>r[items.associated.type]</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>r[items.associated.type.intro] <em>Associated types</em> are <a href="type-aliases.html">type aliases</a> associated with another type.</p>
<p>r[items.associated.type.restrictions] Associated types cannot be defined in <a href="implementations.html#inherent-implementations">inherent implementations</a> nor can they be given a default implementation in traits.</p>
<p>r[items.associated.type.decl] An <em>associated type declaration</em> declares a signature for associated type definitions. It is written in one of the following forms, where <code>Assoc</code> is the name of the associated type, <code>Params</code> is a comma-separated list of type, lifetime or const parameters, <code>Bounds</code> is a plus-separated list of trait bounds that the associated type must meet, and <code>WhereBounds</code> is a comma-separated list of bounds that the parameters must meet:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc;
type Assoc: Bounds;
type Assoc&lt;Params&gt;;
type Assoc&lt;Params&gt;: Bounds;
type Assoc&lt;Params&gt; where WhereBounds;
type Assoc&lt;Params&gt;: Bounds where WhereBounds;</code></pre>
<p>r[items.associated.type.name] The identifier is the name of the declared type alias.</p>
<p>r[items.associated.type.impl-fulfillment] The optional trait bounds must be fulfilled by the implementations of the type alias.</p>
<p>r[items.associated.type.sized] There is an implicit <a href="../special-types-and-traits.html#sized"><code>Sized</code></a> bound on associated types that can be relaxed using the special <code>?Sized</code> bound.</p>
<p>r[items.associated.type.def] An <em>associated type definition</em> defines a type alias for the implementation of a trait on a type.</p>
<p>r[items.associated.type.def.restriction] They are written similarly to an <em>associated type declaration</em>, but cannot contain <code>Bounds</code>, but instead must contain a <code>Type</code>:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc = Type;
type Assoc&lt;Params&gt; = Type; // 여기서 `Type` 타입은 `Params`를 참조할 수 있습니다
type Assoc&lt;Params&gt; = Type where WhereBounds;
type Assoc&lt;Params&gt; where WhereBounds = Type; // 사용 중단됨(deprecated), 위의 형식을 선호하세요</code></pre>
<p>r[items.associated.type.alias] If a type <code>Item</code> has an associated type <code>Assoc</code> from a trait <code>Trait</code>, then <code>&lt;Item as Trait&gt;::Assoc</code> is a type that is an alias of the type specified in the associated type definition.</p>
<p>r[items.associated.type.param] Furthermore, if <code>Item</code> is a type parameter, then <code>Item::Assoc</code> can be used in type parameters.</p>
<p>r[items.associated.type.generic] Associated types may include <a href="generics.html">generic parameters</a> and <a href="generics.html#where-clauses">where clauses</a>; these are often referred to as <em>generic associated types</em>, or <em>GATs</em>. If the type <code>Thing</code> has an associated type <code>Item</code> from a trait <code>Trait</code> with the generics <code>&lt;'a&gt;</code> , the type can be named like <code>&lt;Thing as Trait&gt;::Item&lt;'x&gt;</code>, where <code>'x</code> is some lifetime in scope. In this case, <code>'x</code> will be used wherever <code>'a</code> appears in the associated type definitions on impls.</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait AssociatedType {
    // 연관 타입 선언
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // 연관 타입 정의
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // &lt;Struct as AssociatedType&gt;::Assoc와 같이 OtherStruct를 참조하기 위해 연관 타입을 사용함
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}</code></pre></pre>
<p>제네릭과 where 절을 사용한 연관 타입의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct ArrayLender&lt;'a, T&gt;(&amp;'a mut [T; 16]);

trait Lend {
    // 제네릭 연관 타입 선언
    type Lender&lt;'a&gt; where Self: 'a;
    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt;;
}

impl&lt;T&gt; Lend for [T; 16] {
    // 제네릭 연관 타입 정의
    type Lender&lt;'a&gt; = ArrayLender&lt;'a, T&gt; where Self: 'a;

    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt; {
        ArrayLender(self)
    }
}

fn borrow&lt;'a, T: Lend&gt;(array: &amp;'a mut T) -&gt; &lt;T as Lend&gt;::Lender&lt;'a&gt; {
    array.lend()
}

fn main() {
    let mut array = [0usize; 16];
    let lender = borrow(&amp;mut array);
}</code></pre></pre>
<h3 id="associated-types-container-example"><a class="header" href="#associated-types-container-example">Associated types container example</a></h3>
<p>다음 <code>Container</code> 트레잇 예시를 고려해 보세요. 해당 타입이 메서드 시그니처에서 사용 가능하다는 점에 주목하세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}</span></code></pre></pre>
<p>어떤 타입이 이 트레잇을 구현하기 위해서는, 모든 메서드에 대한 구현을 제공해야 할 뿐만 아니라 타입 <code>E</code>를 명시해야 합니다. 다음은 표준 라이브러리 타입 <code>Vec</code>에 대한 <code>Container</code> 구현입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Container {
</span><span class="boring">    type E;
</span><span class="boring">    fn empty() -&gt; Self;
</span><span class="boring">    fn insert(&amp;mut self, elem: Self::E);
</span><span class="boring">}
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounds와-wherebounds-사이의-관계"><a class="header" href="#bounds와-wherebounds-사이의-관계"><code>Bounds</code>와 <code>WhereBounds</code> 사이의 관계</a></h3>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;X as Example&gt;::Output&lt;Y&gt;</code>와 같은 연관 타입에 대한 참조가 주어지면, 연관 타입 자체는 반드시 <code>Ord</code>여야 하고, 타입 <code>Y</code>는 반드시 <code>Debug</code>여야 합니다.</p>
<p>r[items.associated.type.generic-where-clause]</p>
<h3 id="제네릭-연관-타입에-요구되는-where-절"><a class="header" href="#제네릭-연관-타입에-요구되는-where-절">제네릭 연관 타입에 요구되는 where 절</a></h3>
<p>r[items.associated.type.generic-where-clause.intro] Generic associated type declarations on traits currently may require a list of where clauses, dependent on functions in the trait and how the GAT is used. These rules may be loosened in the future; updates can be found <a href="https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html">on the generic associated types initiative repository</a>.</p>
<p>r[items.associated.type.generic-where-clause.valid-fn] In a few words, these where clauses are required in order to maximize the allowed definitions of the associated type in impls. To do this, any clauses that <em>can be proven to hold</em> on functions (using the parameters of the function or trait) where a GAT appears as an input or output must also be written on the GAT itself.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'x&gt; where Self: 'x;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>위의 <code>next</code> 함수에서, <code>&amp;'a mut self</code>로부터 암시된 바운드 덕분에 <code>Self: 'a</code>임을 증명할 수 있습니다. 따라서 GAT 자체에 동일한 바운드인 <code>where Self: 'x</code>를 작성해야 합니다.</p>
<p>r[items.associated.type.generic-where-clause.intersection] When there are multiple functions in a trait that use the GAT, then the <em>intersection</em> of the bounds from the different functions are used, rather than the union.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Check&lt;T&gt; {
    type Checker&lt;'x&gt;;
    fn create_checker&lt;'a&gt;(item: &amp;'a T) -&gt; Self::Checker&lt;'a&gt;;
    fn do_check(checker: Self::Checker&lt;'_&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시에서는 <code>type Checker&lt;'a&gt;;</code>에 아무런 바운드가 요구되지 않습니다. <code>create_checker</code>에서는 <code>T: 'a</code>임을 알 수 있지만, <code>do_check</code>에서는 이를 알 수 없기 때문입니다. 하지만 만약 <code>do_check</code>가 주석 처리된다면, <code>Checker</code>에 <code>where T: 'x</code> 바운드가 요구될 것입니다.</p>
<p>r[items.associated.type.generic-where-clause.forward] The bounds on associated types also propagate required where clauses.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt; where Self: 'a;
    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt; where Self: 'a;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>iter</code> 때문에 <code>Item</code>에 <code>where Self: 'a</code>가 요구됩니다. 그런데 <code>Item</code>이 <code>Iterator</code>의 바운드에서 사용되므로, <code>where Self: 'a</code> 절이 거기서도 요구됩니다.</p>
<p>r[items.associated.type.generic-where-clause.static] Finally, any explicit uses of <code>'static</code> on GATs in the trait do not count towards the required bounds.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StaticReturn {
    type Y&lt;'a&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.const]</p>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated constants</a></h2>
<p>r[items.associated.const.intro] <em>Associated constants</em> are <a href="constant-items.html">constants</a> associated with a type.</p>
<p>r[items.associated.const.decl] An <em>associated constant declaration</em> declares a signature for associated constant definitions. It is written as <code>const</code>, then an identifier, then <code>:</code>, then a type, finished by a <code>;</code>.</p>
<p>r[items.associated.const.name] The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</p>
<p>r[items.associated.const.def] An <em>associated constant definition</em> defines a constant associated with a type. It is written the same as a <a href="constant-items.html">constant item</a>.</p>
<p>r[items.associated.const.eval] Associated constant definitions undergo <a href="../const_eval.html">constant evaluation</a> only when referenced. Further, definitions that include <a href="generics.html">generic parameters</a> are evaluated after monomorphization.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Struct;
struct GenericStruct&lt;const ID: i32&gt;;

impl Struct {
    // 정의가 즉시 평가되지 않음
    const PANIC: () = panic!("컴파일 타임 패닉");
}

impl&lt;const ID: i32&gt; GenericStruct&lt;ID&gt; {
    // 정의가 즉시 평가되지 않음
    const NON_ZERO: () = if ID == 0 {
        panic!("모순")
    };
}

fn main() {
    // Struct::PANIC을 참조하면 컴파일 오류가 발생함
    let _ = Struct::PANIC;

    // 괜찮음, ID가 0이 아님
    let _ = GenericStruct::&lt;1&gt;::NON_ZERO;

    // ID=0으로 NON_ZERO를 평가할 때 발생하는 컴파일 오류
    let _ = GenericStruct::&lt;0&gt;::NON_ZERO;
}</code></pre></pre>
<h3 id="associated-constants-examples"><a class="header" href="#associated-constants-examples">Associated constants examples</a></h3>
<p>기본 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}</code></pre></pre>
<p>기본값 사용하기:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../items/generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../attributes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../items/generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../attributes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
