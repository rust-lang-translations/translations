<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>패턴 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/patterns.md`;
                    } else {
                        canonical_href = `${base}/${lang}/patterns.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-patterns"><a class="rule-link" href="#r-patterns" title="patterns"><span>[patterns]<span/></a></div>
<h1 id="패턴"><a class="header" href="#패턴">패턴</a></h1>
<div class="rule" id="r-patterns.syntax"><a class="rule-link" href="#r-patterns.syntax" title="patterns.syntax"><span>[patterns<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>패턴</em> :<br />
      <code>|</code><sup>?</sup> <em>최상위대안없는패턴</em>  ( <code>|</code> <em>최상위대안없는패턴</em> )<sup>*</sup></p>
<p><em>최상위대안없는패턴</em> :<br />
      <em>범위없는패턴</em><br />
   | <a href="#range-patterns"><em>범위패턴</em></a></p>
<p><em>범위없는패턴</em> :<br />
      <a href="#literal-patterns"><em>리터럴패턴</em></a><br />
   | <a href="#identifier-patterns"><em>식별자패턴</em></a><br />
   | <a href="#wildcard-pattern"><em>와일드카드패턴</em></a><br />
   | <a href="#rest-patterns"><em>나머지패턴</em></a><br />
   | <a href="#reference-patterns"><em>참조패턴</em></a><br />
   | <a href="#struct-patterns"><em>구조체패턴</em></a><br />
   | <a href="#tuple-struct-patterns"><em>튜플구조체패턴</em></a><br />
   | <a href="#tuple-patterns"><em>튜플패턴</em></a><br />
   | <a href="#grouped-patterns"><em>그룹화된패턴</em></a><br />
   | <a href="#slice-patterns"><em>슬라이스패턴</em></a><br />
   | <a href="#path-patterns"><em>경로패턴</em></a><br />
   | <a href="macros.html#macro-invocation"><em>매크로호출</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.intro"><a class="rule-link" href="#r-patterns.intro" title="patterns.intro"><span>[patterns<wbr>.intro]<span/></a></div>
<p>패턴은 값을 구조에 대해 매칭하고, 선택적으로 구조 내부의 값에 변수를 바인딩하는 데 사용됩니다. 또한 변수 선언과 함수 및 클로저의 매개변수에도 사용됩니다.</p>
<p>다음 예제의 패턴은 네 가지 작업을 수행합니다:</p>
<ul>
<li><code>person</code>의 <code>car</code> 필드가 무언가로 채워져 있는지 테스트합니다.</li>
<li>사람의 <code>age</code> 필드가 13에서 19 사이인지 테스트하고, 그 값을 <code>person_age</code> 변수에 바인딩합니다.</li>
<li><code>name</code> 필드에 대한 참조를 <code>person_name</code> 변수에 바인딩합니다.</li>
<li><code>person</code>의 나머지 필드를 무시합니다. 나머지 필드는 어떤 값이든 가질 수 있으며 어떤 변수에도 바인딩되지 않습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from("John"),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!("{}는 차가 있고 {}살입니다.", person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.usage"><a class="rule-link" href="#r-patterns.usage" title="patterns.usage"><span>[patterns<wbr>.usage]<span/></a></div>
<p>패턴은 다음에서 사용됩니다:</p>
<div class="rule" id="r-patterns.let"><a class="rule-link" href="#r-patterns.let" title="patterns.let"><span>[patterns<wbr>.let]<span/></a></div>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 선언</a></li>
</ul>
<div class="rule" id="r-patterns.param"><a class="rule-link" href="#r-patterns.param" title="patterns.param"><span>[patterns<wbr>.param]<span/></a></div>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
</ul>
<div class="rule" id="r-patterns.match"><a class="rule-link" href="#r-patterns.match" title="patterns.match"><span>[patterns<wbr>.match]<span/></a></div>
<ul>
<li><a href="expressions/match-expr.html"><code>match</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.if-let"><a class="rule-link" href="#r-patterns.if-let" title="patterns.if-let"><span>[patterns<wbr>.if-let]<span/></a></div>
<ul>
<li><a href="expressions/if-expr.html"><code>if let</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.while-let"><a class="rule-link" href="#r-patterns.while-let" title="patterns.while-let"><span>[patterns<wbr>.while-let]<span/></a></div>
<ul>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.for"><a class="rule-link" href="#r-patterns.for" title="patterns.for"><span>[patterns<wbr>.for]<span/></a></div>
<ul>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a></li>
</ul>
<div class="rule" id="r-patterns.destructure"><a class="rule-link" href="#r-patterns.destructure" title="patterns.destructure"><span>[patterns<wbr>.destructure]<span/></a></div>
<h2 id="구조-분해"><a class="header" href="#구조-분해">구조 분해</a></h2>
<div class="rule" id="r-patterns.destructure.intro"><a class="rule-link" href="#r-patterns.destructure.intro" title="patterns.destructure.intro"><span>[patterns<wbr>.destructure<wbr>.intro]<span/></a></div>
<p>패턴은 <a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형</a>, <a href="types/tuple.html">튜플</a>을 _구조 분해_하는 데 사용될 수 있습니다. 구조 분해는 값을 구성 요소로 나눕니다. 사용되는 구문은 해당 값을 생성할 때와 거의 동일합니다.</p>
<div class="rule" id="r-patterns.destructure.placeholder"><a class="rule-link" href="#r-patterns.destructure.placeholder" title="patterns.destructure.placeholder"><span>[patterns<wbr>.destructure<wbr>.placeholder]<span/></a></div>
<p><a href="glossary.html#scrutinee">조사 대상</a> 표현식이 <code>struct</code>, <code>enum</code> 또는 <code>tuple</code> 타입인 패턴에서, 플레이스홀더(<code>_</code>)는 <em>단일</em> 데이터 필드를 나타내며, 와일드카드 <code>..</code>는 특정 변형의 <em>모든</em> 나머지 필드를 나타냅니다.</p>
<div class="rule" id="r-patterns.destructure.named-field-shorthand"><a class="rule-link" href="#r-patterns.destructure.named-field-shorthand" title="patterns.destructure.named-field-shorthand"><span>[patterns<wbr>.destructure<wbr>.named-field-shorthand]<span/></a></div>
<p>이름이 있는(번호가 아닌) 필드를 가진 데이터 구조를 구조 분해할 때, <code>fieldname: fieldname</code>의 단축형으로 <code>fieldname</code>을 작성할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!("Quit"),
    Message::WriteString(write) =&gt; println!("{}", &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!("가로로 {}만큼 이동", x),
    Message::Move{ .. } =&gt; println!("다른 이동"),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!("색상 변경, 빨강: {}, 초록: {}", red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.refutable"><a class="rule-link" href="#r-patterns.refutable" title="patterns.refutable"><span>[patterns<wbr>.refutable]<span/></a></div>
<h2 id="반박-가능성"><a class="header" href="#반박-가능성">반박 가능성</a></h2>
<p>패턴이 비교 대상 값과 일치하지 않을 가능성이 있는 경우를 _반박 가능(refutable)_하다고 합니다. 반면에 _반박 불가능(irrefutable)_한 패턴은 비교 대상 값과 항상 일치합니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // "(x, y)"는 반박 불가능한 패턴입니다

if let (a, 3) = (1, 2) {           // "(a, 3)"은 반박 가능하며, 일치하지 않을 수 있습니다
    panic!("여기에 도달해서는 안 됩니다");
} else if let (a, 4) = (3, 4) {    // "(a, 4)"는 반박 가능하며, 일치하게 됩니다
    println!("({}, 4)와 일치함", a);
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.literal"><a class="rule-link" href="#r-patterns.literal" title="patterns.literal"><span>[patterns<wbr>.literal]<span/></a></div>
<h2 id="리터럴-패턴"><a class="header" href="#리터럴-패턴">리터럴 패턴</a></h2>
<div class="rule" id="r-patterns.literal.syntax"><a class="rule-link" href="#r-patterns.literal.syntax" title="patterns.literal.syntax"><span>[patterns<wbr>.literal<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>리터럴패턴</em> :<br />
      <code>true</code> | <code>false</code><br />
   | <a href="tokens.html#character-literals">문자리터럴</a><br />
   | <a href="tokens.html#byte-literals">바이트리터럴</a><br />
   | <a href="tokens.html#string-literals">문자열리터럴</a><br />
   | <a href="tokens.html#raw-string-literals">원시문자열리터럴</a><br />
   | <a href="tokens.html#byte-string-literals">바이트문자열리터럴</a><br />
   | <a href="tokens.html#raw-byte-string-literals">원시바이트문자열리터럴</a><br />
   | <a href="tokens.html#c-string-literals">C문자열리터럴</a><br />
   | <a href="tokens.html#raw-c-string-literals">원시C문자열리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">정수리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">부동소수점리터럴</a></p>
</blockquote>
<div class="rule" id="r-patterns.literal.intro"><a class="rule-link" href="#r-patterns.literal.intro" title="patterns.literal.intro"><span>[patterns<wbr>.literal<wbr>.intro]<span/></a></div>
<p>_리터럴 패턴_은 리터럴에 의해 생성된 값과 정확히 동일한 값에 매치됩니다. 음수는 <a href="expressions/literal-expr.html">리터럴</a>이 아니므로, 리터럴 패턴은 리터럴 앞에 선택적으로 마이너스 기호를 허용하며, 이는 부정 연산자처럼 작동합니다.</p>
<div class="warning">
<blockquote>
<p><em><strong>경고:</strong></em> C 문자열 및 원시 C 문자열 리터럴은 리터럴 패턴에서 허용되지만, <code>&amp;CStr</code>은 구조적 동등성(<code>#[derive(Eq, PartialEq)]</code>)을 구현하지 않으므로 <code>&amp;CStr</code>에 대한 어떠한 <code>match</code>도 타입 오류로 인해 거부됩니다.</p>
</blockquote>
</div>
<div class="rule" id="r-patterns.literal.refutable"><a class="rule-link" href="#r-patterns.literal.refutable" title="patterns.literal.refutable"><span>[patterns<wbr>.literal<wbr>.refutable]<span/></a></div>
<p>리터럴 패턴은 항상 반박 가능합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!("마이너스 1입니다"),
        1 =&gt; println!("1입니다"),
        2|4 =&gt; println!("2 또는 4입니다"),
        _ =&gt; println!("어떠한 매치 암(arm)과도 일치하지 않았습니다"),
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident"><a class="rule-link" href="#r-patterns.ident" title="patterns.ident"><span>[patterns<wbr>.ident]<span/></a></div>
<h2 id="식별자-패턴"><a class="header" href="#식별자-패턴">식별자 패턴</a></h2>
<div class="rule" id="r-patterns.ident.syntax"><a class="rule-link" href="#r-patterns.ident.syntax" title="patterns.ident.syntax"><span>[patterns<wbr>.ident<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>식별자패턴</em> :<br />
      <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">식별자</a> (<code>@</code> <a href="#patterns"><em>최상위대안없는패턴</em></a> ) <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.ident.intro"><a class="rule-link" href="#r-patterns.ident.intro" title="patterns.ident.intro"><span>[patterns<wbr>.ident<wbr>.intro]<span/></a></div>
<p>식별자 패턴은 매치된 값을 <a href="names/namespaces.html">값 네임스페이스</a>의 변수에 바인딩합니다.</p>
<div class="rule" id="r-patterns.ident.unique"><a class="rule-link" href="#r-patterns.ident.unique" title="patterns.ident.unique"><span>[patterns<wbr>.ident<wbr>.unique]<span/></a></div>
<p>식별자는 패턴 내에서 유일해야 합니다.</p>
<div class="rule" id="r-patterns.ident.scope"><a class="rule-link" href="#r-patterns.ident.scope" title="patterns.ident.scope"><span>[patterns<wbr>.ident<wbr>.scope]<span/></a></div>
<p>변수는 스코프 내의 동일한 이름을 가진 다른 변수를 섀도잉(shadowing)합니다. 새 바인딩의 <a href="names/scopes.html">스코프</a>는 패턴이 사용되는 컨텍스트(<code>let</code> 바인딩 또는 <code>match</code> 암 등)에 따라 달라집니다.</p>
<div class="rule" id="r-patterns.ident.bare"><a class="rule-link" href="#r-patterns.ident.bare" title="patterns.ident.bare"><span>[patterns<wbr>.ident<wbr>.bare]<span/></a></div>
<p>식별자만으로 구성된(선택적으로 <code>mut</code>가 붙은) 패턴은 모든 값과 매치되며 그 값을 해당 식별자에 바인딩합니다. 이는 변수 선언과 함수 및 클로저의 매개변수에서 가장 흔히 사용되는 패턴입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.scrutinized"><a class="rule-link" href="#r-patterns.ident.scrutinized" title="patterns.ident.scrutinized"><span>[patterns<wbr>.ident<wbr>.scrutinized]<span/></a></div>
<p>패턴의 매치된 값을 변수에 바인딩하려면 <code>variable @ 서브패턴</code> 구문을 사용합니다. 예를 들어, 다음은 값 2를 <code>e</code>에 바인딩합니다(전체 범위가 아니라, 여기서 범위는 범위 서브패턴입니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!("범위 요소 {}를 얻음", e),
    _ =&gt; println!("아무거나"),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.move"><a class="rule-link" href="#r-patterns.ident.move" title="patterns.ident.move"><span>[patterns<wbr>.ident<wbr>.move]<span/></a></div>
<p>기본적으로 식별자 패턴은 매치된 값이 <a href="special-types-and-traits.html#copy"><code>Copy</code></a>를 구현하는지 여부에 따라 매치된 값을 복사하거나 이동하여 변수에 바인딩합니다.</p>
<div class="rule" id="r-patterns.ident.ref"><a class="rule-link" href="#r-patterns.ident.ref" title="patterns.ident.ref"><span>[patterns<wbr>.ident<wbr>.ref]<span/></a></div>
<p><code>ref</code> 키워드를 사용하여 참조로 바인딩하거나, <code>ref mut</code>를 사용하여 가변 참조로 바인딩하도록 변경할 수 있습니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 match 표현식에서 값은 복사(또는 이동)됩니다. 두 번째 match에서 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 구조 분해 서브패턴에서는 <code>&amp;</code> 연산자를 값의 필드에 적용할 수 없기 때문에 이 구문이 필요합니다. 예를 들어, 다음은 유효하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>이를 유효하게 만들려면 다음과 같이 작성하십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.ref-ignored"><a class="rule-link" href="#r-patterns.ident.ref-ignored" title="patterns.ident.ref-ignored"><span>[patterns<wbr>.ident<wbr>.ref-ignored]<span/></a></div>
<p>따라서 <code>ref</code>는 매치 대상이 아닙니다. 이것의 목적은 오로지 매치된 바인딩을 복사하거나 이동하는 대신 참조로 만드는 것입니다.</p>
<div class="rule" id="r-patterns.ident.precedent"><a class="rule-link" href="#r-patterns.ident.precedent" title="patterns.ident.precedent"><span>[patterns<wbr>.ident<wbr>.precedent]<span/></a></div>
<p><a href="#path-patterns">경로 패턴</a>은 식별자 패턴보다 우선순위가 높습니다.</p>
<div class="rule" id="r-patterns.ident.constraint"><a class="rule-link" href="#r-patterns.ident.constraint" title="patterns.ident.constraint"><span>[patterns<wbr>.ident<wbr>.constraint]<span/></a></div>
<p><code>ref</code> 또는 <code>ref mut</code>가 지정되고 식별자가 상수를 섀도잉하면 오류입니다.</p>
<div class="rule" id="r-patterns.ident.refutable"><a class="rule-link" href="#r-patterns.ident.refutable" title="patterns.ident.refutable"><span>[patterns<wbr>.ident<wbr>.refutable]<span/></a></div>
<p><code>@</code> 서브패턴이 반박 불가능하거나 서브패턴이 지정되지 않은 경우 식별자 패턴은 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.ident.binding"><a class="rule-link" href="#r-patterns.ident.binding" title="patterns.ident.binding"><span>[patterns<wbr>.ident<wbr>.binding]<span/></a></div>
<h3 id="바인딩-모드"><a class="header" href="#바인딩-모드">바인딩 모드</a></h3>
<div class="rule" id="r-patterns.ident.binding.intro"><a class="rule-link" href="#r-patterns.ident.binding.intro" title="patterns.ident.binding.intro"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.intro]<span/></a></div>
<p>더 나은 편의성을 제공하기 위해, 패턴은 값에 참조를 더 쉽게 바인딩할 수 있도록 서로 다른 _바인딩 모드_에서 작동합니다. 참조 값이 비참조 패턴에 의해 매치될 때, 자동으로 <code>ref</code> 또는 <code>ref mut</code> 바인딩으로 취급됩니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);
if let Some(y) = x {
    // y는 `ref y`로 변환되었으며 타입은 &amp;i32입니다
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.non-reference"><a class="rule-link" href="#r-patterns.ident.binding.non-reference" title="patterns.ident.binding.non-reference"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.non-reference]<span/></a></div>
<p>_비참조 패턴_에는 바인딩, <a href="#wildcard-pattern">와일드카드 패턴</a> (<code>_</code>), 참조 타입의 <a href="#path-patterns"><code>const</code> 패턴</a>, <a href="#reference-patterns">참조 패턴</a>을 제외한 모든 패턴이 포함됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.default-mode"><a class="rule-link" href="#r-patterns.ident.binding.default-mode" title="patterns.ident.binding.default-mode"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.default-mode]<span/></a></div>
<p>바인딩 패턴에 <code>ref</code>, <code>ref mut</code>, 또는 <code>mut</code>가 명시적으로 없는 경우, 변수가 바인딩되는 방식을 결정하기 위해 _기본 바인딩 모드_를 사용합니다.</p>
<div class="rule" id="r-patterns.ident.binding.move"><a class="rule-link" href="#r-patterns.ident.binding.move" title="patterns.ident.binding.move"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.move]<span/></a></div>
<p>기본 바인딩 모드는 이동 시맨틱을 사용하는 “move” 모드에서 시작합니다.</p>
<div class="rule" id="r-patterns.ident.binding.top-down"><a class="rule-link" href="#r-patterns.ident.binding.top-down" title="patterns.ident.binding.top-down"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.top-down]<span/></a></div>
<p>패턴을 매치할 때, 컴파일러는 패턴의 바깥쪽에서 시작하여 안쪽으로 진행합니다.</p>
<div class="rule" id="r-patterns.ident.binding.auto-deref"><a class="rule-link" href="#r-patterns.ident.binding.auto-deref" title="patterns.ident.binding.auto-deref"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.auto-deref]<span/></a></div>
<p>비참조 패턴을 사용하여 참조를 매치할 때마다, 자동으로 값을 역참조하고 기본 바인딩 모드를 업데이트합니다.</p>
<div class="rule" id="r-patterns.ident.binding.ref"><a class="rule-link" href="#r-patterns.ident.binding.ref" title="patterns.ident.binding.ref"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.ref]<span/></a></div>
<p>참조는 기본 바인딩 모드를 <code>ref</code>로 설정합니다.</p>
<div class="rule" id="r-patterns.ident.binding.ref-mut"><a class="rule-link" href="#r-patterns.ident.binding.ref-mut" title="patterns.ident.binding.ref-mut"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.ref-mut]<span/></a></div>
<p>가변 참조는 모드가 이미 <code>ref</code>가 아닌 한 <code>ref mut</code>로 설정하며, 이미 <code>ref</code>인 경우에는 <code>ref</code>로 유지됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.nested-references"><a class="rule-link" href="#r-patterns.ident.binding.nested-references" title="patterns.ident.binding.nested-references"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.nested-references]<span/></a></div>
<p>자동으로 역참조된 값이 여전히 참조인 경우, 다시 역참조되며 이 과정이 반복됩니다.</p>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-binding"><a class="rule-link" href="#r-patterns.ident.binding.mode-limitations-binding" title="patterns.ident.binding.mode-limitations-binding"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-binding]<span/></a></div>
<p>바인딩 패턴은 기본 바인딩 모드가 “move“일 때만 <code>ref</code> 또는 <code>ref mut</code> 바인딩 모드를 명시적으로 지정하거나 <code>mut</code>로 가변성을 지정할 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [mut x] = &amp;[()]; //~ 오류
let [ref x] = &amp;[()]; //~ 오류
let [ref mut x] = &amp;mut [()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.mode-limitations.edition2024"><a class="rule-link" href="#r-patterns.ident.binding.mode-limitations.edition2024" title="patterns.ident.binding.mode-limitations.edition2024"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 기본 바인딩 모드가 “move“가 아닐 때도 바인딩에 <code>ref</code> 또는 <code>ref mut</code> 바인딩 모드를 명시적으로 지정할 수 있었고, 이러한 바인딩에 <code>mut</code>로 가변성을 지정할 수 있었습니다. 이 에디션들에서는 바인딩에 <code>mut</code>를 지정하면 현재 기본 바인딩 모드에 상관없이 바인딩 모드가 “move“로 설정되었습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-reference"><a class="rule-link" href="#r-patterns.ident.binding.mode-limitations-reference" title="patterns.ident.binding.mode-limitations-reference"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-reference]<span/></a></div>
<p>마찬가지로, 참조 패턴은 기본 바인딩 모드가 “move“일 때만 나타날 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [&amp;x] = &amp;[&amp;()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ident.binding.mode-limitations-reference.edition2024"><a class="rule-link" href="#r-patterns.ident.binding.mode-limitations-reference.edition2024" title="patterns.ident.binding.mode-limitations-reference.edition2024"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mode-limitations-reference<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 기본 바인딩 모드가 “move“가 아닐 때도 참조 패턴이 나타날 수 있었으며, 이는 조사 대상(scrutinee)과 매치되는 효과와 기본 바인딩 모드를 “move“로 재설정하는 효과를 모두 가졌습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ident.binding.mixed"><a class="rule-link" href="#r-patterns.ident.binding.mixed" title="patterns.ident.binding.mixed"><span>[patterns<wbr>.ident<wbr>.binding<wbr>.mixed]<span/></a></div>
<p>이동 바인딩과 참조 바인딩은 동일한 패턴에서 혼합될 수 있습니다. 이렇게 하면 바인딩된 객체의 부분 이동(partial move)이 발생하며, 해당 객체는 이후에 사용할 수 없습니다. 이는 타입이 복사 가능하지 않은 경우에만 적용됩니다.</p>
<p>아래 예시에서 <code>name</code>은 <code>person</code>에서 이동됩니다. <code>person</code> 전체를 사용하거나 <code>person.name</code>을 사용하려고 하면 _부분 이동_으로 인해 오류가 발생합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from("John"), age: 23 };
</span>// `name`은 person에서 이동되고 `age`는 참조됩니다
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.wildcard"><a class="rule-link" href="#r-patterns.wildcard" title="patterns.wildcard"><span>[patterns<wbr>.wildcard]<span/></a></div>
<h2 id="와일드카드-패턴"><a class="header" href="#와일드카드-패턴">와일드카드 패턴</a></h2>
<div class="rule" id="r-patterns.wildcard.syntax"><a class="rule-link" href="#r-patterns.wildcard.syntax" title="patterns.wildcard.syntax"><span>[patterns<wbr>.wildcard<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>와일드카드패턴</em> :<br />
   <code>_</code></p>
</blockquote>
<div class="rule" id="r-patterns.wildcard.intro"><a class="rule-link" href="#r-patterns.wildcard.intro" title="patterns.wildcard.intro"><span>[patterns<wbr>.wildcard<wbr>.intro]<span/></a></div>
<p><em>와일드카드 패턴</em>(밑줄 기호)은 모든 값과 매치됩니다. 이는 값이 중요하지 않을 때 값을 무시하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.wildcard.struct-matcher"><a class="rule-link" href="#r-patterns.wildcard.struct-matcher" title="patterns.wildcard.struct-matcher"><span>[patterns<wbr>.wildcard<wbr>.struct-matcher]<span/></a></div>
<p>다른 패턴 내부에서 이는 단일 데이터 필드와 매치됩니다(나머지 필드들과 매치되는 <code>..</code>와 대조적임).</p>
<div class="rule" id="r-patterns.wildcard.no-binding"><a class="rule-link" href="#r-patterns.wildcard.no-binding" title="patterns.wildcard.no-binding"><span>[patterns<wbr>.wildcard<wbr>.no-binding]<span/></a></div>
<p>식별자 패턴과 달리, 매치되는 값을 복사, 이동 또는 차용하지 않습니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x는 항상 _와 매치됩니다
<span class="boring">assert_eq!(a, 10);
</span>
// 함수/클로저 매개변수를 무시합니다
let real_part = |a: f64, _: f64| { a };

// 구조체의 필드를 무시합니다
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 어떤 값이든 Some이면 허용합니다
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.wildcard.refutable"><a class="rule-link" href="#r-patterns.wildcard.refutable" title="patterns.wildcard.refutable"><span>[patterns<wbr>.wildcard<wbr>.refutable]<span/></a></div>
<p>와일드카드 패턴은 항상 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.rest"><a class="rule-link" href="#r-patterns.rest" title="patterns.rest"><span>[patterns<wbr>.rest]<span/></a></div>
<h2 id="나머지-패턴"><a class="header" href="#나머지-패턴">나머지 패턴</a></h2>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>나머지패턴</em> :<br />
   <code>..</code></p>
</blockquote>
<div class="rule" id="r-patterns.rest.intro"><a class="rule-link" href="#r-patterns.rest.intro" title="patterns.rest.intro"><span>[patterns<wbr>.rest<wbr>.intro]<span/></a></div>
<p><em>나머지 패턴</em>(<code>..</code> 토큰)은 가변 길이 패턴으로 작동하며, 앞뒤에서 이미 매치되지 않은 0개 이상의 요소와 매치됩니다.</p>
<div class="rule" id="r-patterns.rest.allowed-patterns"><a class="rule-link" href="#r-patterns.rest.allowed-patterns" title="patterns.rest.allowed-patterns"><span>[patterns<wbr>.rest<wbr>.allowed-patterns]<span/></a></div>
<p>이는 <a href="#tuple-patterns">튜플</a>, <a href="#tuple-struct-patterns">튜플 구조체</a>, <a href="#slice-patterns">슬라이스</a> 패턴에서만 사용될 수 있으며, 해당 패턴의 요소 중 하나로 단 한 번만 나타날 수 있습니다. 또한 <a href="#slice-patterns">슬라이스 패턴</a>에 한해서만 <a href="#identifier-patterns">식별자 패턴</a>에서도 허용됩니다.</p>
<div class="rule" id="r-patterns.rest.refutable"><a class="rule-link" href="#r-patterns.rest.refutable" title="patterns.rest.refutable"><span>[patterns<wbr>.rest<wbr>.refutable]<span/></a></div>
<p>나머지 패턴은 항상 반박 불가능합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec!["a", "b", "c"];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!("슬라이스가 비어 있음"),
    [one] =&gt; println!("단일 요소 {}", one),
    [head, tail @ ..] =&gt; println!("head={} tail={:?}", head, tail),
}

match slice {
    // "!"여야 하는 마지막 요소를 제외한 모든 것을 무시합니다.
    [.., "!"] =&gt; println!("!!!"),

    // `start`는 "z"여야 하는 마지막 요소를 제외한 모든 것의 슬라이스입니다.
    [start @ .., "z"] =&gt; println!("다음으로 시작함: {:?}", start),

    // `end`는 "a"여야 하는 첫 번째 요소를 제외한 모든 것의 슬라이스입니다.
    ["a", end @ ..] =&gt; println!("다음으로 끝남: {:?}", end),

    // 'whole'은 전체 슬라이스이고 `last`는 마지막 요소입니다
    whole @ [.., last] =&gt; println!("{:?}의 마지막 요소는 {}입니다", whole, last),

    rest =&gt; println!("{:?}", rest),
}

if let [.., penultimate, _] = slice {
    println!("마지막에서 두 번째는 {}입니다", penultimate);
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// 나머지 패턴은 튜플 및 튜플 구조체 패턴에서도 사용될 수 있습니다.
match tuple {
    (1, .., y, z) =&gt; println!("y={} z={}", y, z),
    (.., 5) =&gt; println!("꼬리(tail)는 5여야 함"),
    (..) =&gt; println!("그 외 모든 것과 일치함"),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.range"><a class="rule-link" href="#r-patterns.range" title="patterns.range"><span>[patterns<wbr>.range]<span/></a></div>
<h2 id="범위-패턴"><a class="header" href="#범위-패턴">범위 패턴</a></h2>
<div class="rule" id="r-patterns.range.syntax"><a class="rule-link" href="#r-patterns.range.syntax" title="patterns.range.syntax"><span>[patterns<wbr>.range<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>범위패턴</em> :<br />
      <em>포함범위패턴</em><br />
   | <em>시작범위패턴</em><br />
   | <em>끝포함범위패턴</em><br />
   | <em>오래된범위패턴</em></p>
<p><em>배타범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..</code> <em>범위패턴경계</em></p>
<p><em>포함범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..=</code> <em>범위패턴경계</em></p>
<p><em>시작범위패턴</em> :<br />
      <em>범위패턴경계</em> <code>..</code></p>
<p><em>끝포함범위패턴</em> :<br />
      <code>..=</code> <em>범위패턴경계</em></p>
<p><em>오래된범위패턴</em> :<br />
   <em>범위패턴경계</em> <code>...</code> <em>범위패턴경계</em></p>
<p><em>범위패턴경계</em> :<br />
      <a href="tokens.html#character-literals">문자리터럴</a><br />
   | <a href="tokens.html#byte-literals">바이트리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">정수리터럴</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">부동소수점리터럴</a><br />
   | <a href="expressions/path-expr.html"><em>경로표현식</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.range.intro"><a class="rule-link" href="#r-patterns.range.intro" title="patterns.range.intro"><span>[patterns<wbr>.range<wbr>.intro]<span/></a></div>
<p>_범위 패턴_은 경계로 정의된 범위 내의 스칼라 값과 매치됩니다. 이들은 <em>기호(sigil)</em>(<code>..</code>, <code>..=</code>, <code>...</code> 중 하나)와 한쪽 또는 양쪽의 경계로 구성됩니다.</p>
<div class="rule" id="r-patterns.range.lower-bound"><a class="rule-link" href="#r-patterns.range.lower-bound" title="patterns.range.lower-bound"><span>[patterns<wbr>.range<wbr>.lower-bound]<span/></a></div>
<p>기호 왼쪽의 경계는 _하한(lower bound)_입니다.</p>
<div class="rule" id="r-patterns.range.upper-bound"><a class="rule-link" href="#r-patterns.range.upper-bound" title="patterns.range.upper-bound"><span>[patterns<wbr>.range<wbr>.upper-bound]<span/></a></div>
<p>오른쪽의 경계는 _상한(upper bound)_입니다.</p>
<div class="rule" id="r-patterns.range.closed"><a class="rule-link" href="#r-patterns.range.closed" title="patterns.range.closed"><span>[patterns<wbr>.range<wbr>.closed]<span/></a></div>
<p>하한과 상한을 모두 가진 범위 패턴은 두 경계 사이의 모든 값(경계 포함)과 매치됩니다. 이는 하한 뒤에 끝을 제외하는 <code>..</code> 또는 끝을 포함하는 <code>..=</code>가 오고, 그 뒤에 상한이 오는 방식으로 작성됩니다.</p>
<div class="rule" id="r-patterns.range.type"><a class="rule-link" href="#r-patterns.range.type" title="patterns.range.type"><span>[patterns<wbr>.range<wbr>.type]<span/></a></div>
<p>범위 패턴의 타입은 상한과 하한 타입의 통합된 타입입니다.</p>
<p>예를 들어, <code>'m'..='p'</code> 패턴은 <code>'m'</code>, <code>'n'</code>, <code>'o'</code>, <code>'p'</code> 값과만 매치됩니다. 마찬가지로 <code>'m'..'p'</code>는 <code>'m'</code>, <code>'n'</code>, <code>'o'</code>와만 매치되며, 특히 <code>'p'</code>는 포함되지 <strong>않습니다</strong>.</p>
<div class="rule" id="r-patterns.range.constraint-less-than"><a class="rule-link" href="#r-patterns.range.constraint-less-than" title="patterns.range.constraint-less-than"><span>[patterns<wbr>.range<wbr>.constraint-less-than]<span/></a></div>
<p>하한은 상한보다 클 수 없습니다. 즉, <code>a..=b</code>에서 a ≤ b여야 합니다. 예를 들어, <code>10..=0</code>과 같은 범위 패턴은 오류입니다.</p>
<div class="rule" id="r-patterns.range.open-below"><a class="rule-link" href="#r-patterns.range.open-below" title="patterns.range.open-below"><span>[patterns<wbr>.range<wbr>.open-below]<span/></a></div>
<p>하한만 있는 범위 패턴은 하한보다 크거나 같은 모든 값과 매치됩니다. 이는 하한 뒤에 <code>..</code>가 오는 방식으로 작성되며, 하한과 동일한 타입을 갖습니다. 예를 들어, <code>1..</code>은 1, 9, 9001, 또는 (적절한 크기인 경우) 9007199254740991과 매치되지만, 0이나 부호 있는 정수의 경우 음수와는 매치되지 않습니다.</p>
<div class="rule" id="r-patterns.range.open-above"><a class="rule-link" href="#r-patterns.range.open-above" title="patterns.range.open-above"><span>[patterns<wbr>.range<wbr>.open-above]<span/></a></div>
<p>상한만 있는 범위 패턴은 상한보다 작거나 같은 모든 값과 매치됩니다. 이는 <code>..=</code> 뒤에 상한이 오는 방식으로 작성되며, 상한과 동일한 타입을 갖습니다. 예를 들어, <code>..=10</code>은 10, 1, 0, 그리고 부호 있는 정수 타입의 경우 모든 음수 값과 매치됩니다.</p>
<div class="rule" id="r-patterns.range.constraint-slice"><a class="rule-link" href="#r-patterns.range.constraint-slice" title="patterns.range.constraint-slice"><span>[patterns<wbr>.range<wbr>.constraint-slice]<span/></a></div>
<p>하나의 경계만 있는 범위 패턴은 <a href="#slice-patterns">슬라이스 패턴</a>의 서브패턴에서 최상위 패턴으로 사용될 수 없습니다.</p>
<div class="rule" id="r-patterns.range.bound"><a class="rule-link" href="#r-patterns.range.bound" title="patterns.range.bound"><span>[patterns<wbr>.range<wbr>.bound]<span/></a></div>
<p>경계는 다음 중 하나로 작성됩니다:</p>
<ul>
<li>문자, 바이트, 정수 또는 부동 소수점 리터럴.</li>
<li>정수 또는 부동 소수점 리터럴 앞에 <code>-</code>가 붙은 형태.</li>
<li><a href="expressions/path-expr.html">경로</a></li>
</ul>
<div class="rule" id="r-patterns.range.constraint-bound-path"><a class="rule-link" href="#r-patterns.range.constraint-bound-path" title="patterns.range.constraint-bound-path"><span>[patterns<wbr>.range<wbr>.constraint-bound-path]<span/></a></div>
<p>경계가 경로로 작성된 경우, 매크로 확인 후에 해당 경로는 <code>char</code>, 정수 타입 또는 부동 소수점 타입의 상수 아이템으로 해석되어야 합니다.</p>
<div class="rule" id="r-patterns.range.value"><a class="rule-link" href="#r-patterns.range.value" title="patterns.range.value"><span>[patterns<wbr>.range<wbr>.value]<span/></a></div>
<p>경계의 타입과 값은 그것이 어떻게 작성되었느냐에 따라 달라집니다.</p>
<div class="rule" id="r-patterns.range.path-value"><a class="rule-link" href="#r-patterns.range.path-value" title="patterns.range.path-value"><span>[patterns<wbr>.range<wbr>.path-value]<span/></a></div>
<p>경계가 <a href="expressions/path-expr.html">경로</a>인 경우, 패턴은 해당 경로가 해석되는 <a href="items/constant-items.html">상수</a>의 타입과 값을 갖습니다.</p>
<div class="rule" id="r-patterns.range.float-restriction"><a class="rule-link" href="#r-patterns.range.float-restriction" title="patterns.range.float-restriction"><span>[patterns<wbr>.range<wbr>.float-restriction]<span/></a></div>
<p>부동 소수점 범위 패턴의 경우, 상수는 <code>NaN</code>일 수 없습니다.</p>
<div class="rule" id="r-patterns.range.literal-value"><a class="rule-link" href="#r-patterns.range.literal-value" title="patterns.range.literal-value"><span>[patterns<wbr>.range<wbr>.literal-value]<span/></a></div>
<p>리터럴인 경우, 해당 <a href="expressions/literal-expr.html">리터럴 표현식</a>의 타입과 값을 갖습니다.</p>
<div class="rule" id="r-patterns.range.negation"><a class="rule-link" href="#r-patterns.range.negation" title="patterns.range.negation"><span>[patterns<wbr>.range<wbr>.negation]<span/></a></div>
<p>리터럴 앞에 <code>-</code>가 붙은 경우, 해당 <a href="expressions/literal-expr.html">리터럴 표현식</a>과 동일한 타입을 가지며, 해당 리터럴 표현식의 값을 <a href="expressions/operator-expr.html#negation-operators">부정한(negating)</a> 값을 갖습니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!("{}", match ph {
    0..7 =&gt; "산성",
    7 =&gt; "중성",
    8..=14 =&gt; "염기성",
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; "0입니다!",
    1.. =&gt; "양수입니다!",
};

// 상수에 대한 경로 사용:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!("{}", match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; "대류권",
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; "성층권",
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; "중간권",
    _ =&gt; "아마도 외계 공간",
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!("크기가 적절하며 {}바이트를 차지함", size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// 정규화된 경로 사용:
println!("{}", match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; "u8에 맞음",
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; "u16에 맞음",
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; "u32에 맞음",
    _ =&gt; "너무 큼",
});
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.range.refutable"><a class="rule-link" href="#r-patterns.range.refutable" title="patterns.range.refutable"><span>[patterns<wbr>.range<wbr>.refutable]<span/></a></div>
<p>고정 너비 정수 및 <code>char</code> 타입에 대한 범위 패턴이 타입의 가능한 모든 값 세트를 포괄하는 경우 반박 불가능(irrefutable)합니다. 예를 들어, <code>0u8..=255u8</code>은 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.range.refutable-integer"><a class="rule-link" href="#r-patterns.range.refutable-integer" title="patterns.range.refutable-integer"><span>[patterns<wbr>.range<wbr>.refutable-integer]<span/></a></div>
<p>정수 타입의 값 범위는 최소값부터 최대값까지의 닫힌 범위입니다.</p>
<div class="rule" id="r-patterns.range.refutable-char"><a class="rule-link" href="#r-patterns.range.refutable-char" title="patterns.range.refutable-char"><span>[patterns<wbr>.range<wbr>.refutable-char]<span/></a></div>
<p><code>char</code> 타입의 값 범위는 정확히 모든 유니코드 스칼라 값을 포함하는 범위인 <code>'\u{0000}'..='\u{D7FF}'</code>와 <code>'\u{E000}'..='\u{10FFFF}'</code>입니다.</p>
<div class="rule" id="r-patterns.range.edition2021"><a class="rule-link" href="#r-patterns.range.edition2021" title="patterns.range.edition2021"><span>[patterns<wbr>.range<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션 이전에는 하한과 상한을 모두 가진 범위 패턴을 <code>..=</code> 대신 <code>...</code>를 사용하여 동일한 의미로 작성할 수도 있었습니다.</p>
</blockquote>
<div class="rule" id="r-patterns.ref"><a class="rule-link" href="#r-patterns.ref" title="patterns.ref"><span>[patterns<wbr>.ref]<span/></a></div>
<h2 id="참조-패턴"><a class="header" href="#참조-패턴">참조 패턴</a></h2>
<div class="rule" id="r-patterns.ref.syntax"><a class="rule-link" href="#r-patterns.ref.syntax" title="patterns.ref.syntax"><span>[patterns<wbr>.ref<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>참조패턴</em> :<br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <a href="#patterns"><em>범위없는패턴</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.ref.intro"><a class="rule-link" href="#r-patterns.ref.intro" title="patterns.ref.intro"><span>[patterns<wbr>.ref<wbr>.intro]<span/></a></div>
<p>참조 패턴은 매치되는 포인터를 역참조하며, 따라서 이를 차용합니다.</p>
<p>예를 들어, <code>x: &amp;i32</code>에 대한 다음 두 매치는 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; "0", _ =&gt; "some" };
let b = match int_reference { &amp;0 =&gt; "0", _ =&gt; "some" };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.ref.ref-ref"><a class="rule-link" href="#r-patterns.ref.ref-ref" title="patterns.ref.ref-ref"><span>[patterns<wbr>.ref<wbr>.ref-ref]<span/></a></div>
<p>참조 패턴에 대한 문법 생성물은 참조의 참조를 매치하기 위해 <code>&amp;&amp;</code> 토큰과 매치되어야 합니다. 이는 그 자체로 하나의 토큰이며, 두 개의 <code>&amp;</code> 토큰이 아니기 때문입니다.</p>
<div class="rule" id="r-patterns.ref.mut"><a class="rule-link" href="#r-patterns.ref.mut" title="patterns.ref.mut"><span>[patterns<wbr>.ref<wbr>.mut]<span/></a></div>
<p><code>mut</code> 키워드를 추가하면 가변 참조를 역참조합니다. 가변성은 참조의 가변성과 일치해야 합니다.</p>
<div class="rule" id="r-patterns.ref.refutable"><a class="rule-link" href="#r-patterns.ref.refutable" title="patterns.ref.refutable"><span>[patterns<wbr>.ref<wbr>.refutable]<span/></a></div>
<p>참조 패턴은 항상 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.struct"><a class="rule-link" href="#r-patterns.struct" title="patterns.struct"><span>[patterns<wbr>.struct]<span/></a></div>
<h2 id="구조체-패턴"><a class="header" href="#구조체-패턴">구조체 패턴</a></h2>
<div class="rule" id="r-patterns.struct.syntax"><a class="rule-link" href="#r-patterns.struct.syntax" title="patterns.struct.syntax"><span>[patterns<wbr>.struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>구조체패턴</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>{</code><br />
      <em>구조체패턴요소</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>구조체패턴요소</em> :<br />
      <em>구조체패턴필드</em> (<code>,</code> | <code>,</code> <em>구조체패턴기타</em>)<sup>?</sup><br />
   | <em>구조체패턴기타</em></p>
<p><em>구조체패턴필드</em> :<br />
   <em>구조체패턴필드</em> (<code>,</code> <em>구조체패턴필드</em>) <sup>*</sup></p>
<p><em>구조체패턴필드</em> :<br />
   <a href="attributes.html"><em>외부속성</em></a> <sup>*</sup><br />
   (<br />
         <a href="tokens.html#tuple-index">튜플인덱스</a> <code>:</code> <a href="#patterns"><em>패턴</em></a><br />
      | <a href="identifiers.html">식별자</a> <code>:</code> <a href="#patterns"><em>패턴</em></a><br />
      | <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">식별자</a><br />
   )</p>
<p><em>구조체패턴기타</em> :<br />
   <code>..</code></p>
</blockquote>
<div class="rule" id="r-patterns.struct.intro"><a class="rule-link" href="#r-patterns.struct.intro" title="patterns.struct.intro"><span>[patterns<wbr>.struct<wbr>.intro]<span/></a></div>
<p>구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 구조체, 열거형 및 공용체 값과 매치됩니다. 또한 구조체, 열거형 또는 공용체 값을 <a href="#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.struct.ignore-rest"><a class="rule-link" href="#r-patterns.struct.ignore-rest" title="patterns.struct.ignore-rest"><span>[patterns<wbr>.struct<wbr>.ignore-rest]<span/></a></div>
<p>구조체 패턴에서 필드는 이름이나 인덱스(튜플 구조체의 경우)로 참조되거나 <code>..</code>을 사용하여 무시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // 순서는 중요하지 않음
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // 순서는 중요하지 않음
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}

<span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">}
</span><span class="boring">let m = Message::Quit;
</span><span class="boring">
</span>match m {
    Message::Quit =&gt; (),
    Message::Move {x: 10, y: 20} =&gt; (),
    Message::Move {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.constraint-struct"><a class="rule-link" href="#r-patterns.struct.constraint-struct" title="patterns.struct.constraint-struct"><span>[patterns<wbr>.struct<wbr>.constraint-struct]<span/></a></div>
<p><code>..</code>이 사용되지 않으면, 구조체를 매치하는 데 사용되는 구조체 패턴은 모든 필드를 명시해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.constraint-union"><a class="rule-link" href="#r-patterns.struct.constraint-union" title="patterns.struct.constraint-union"><span>[patterns<wbr>.struct<wbr>.constraint-union]<span/></a></div>
<p>공용체(union)를 매치하는 데 사용되는 구조체 패턴은 정확히 하나의 필드만 지정해야 합니다 (<a href="items/unions.html#pattern-matching-on-unions">공용체에서의 패턴 매칭</a> 참조)。</p>
<div class="rule" id="r-patterns.struct.binding-shorthand"><a class="rule-link" href="#r-patterns.struct.binding-shorthand" title="patterns.struct.binding-shorthand"><span>[patterns<wbr>.struct<wbr>.binding-shorthand]<span/></a></div>
<p><code>ref</code> 및/또는 <code>mut</code> <em>식별자</em> 구문은 모든 값과 매치되며, 주어진 필드와 동일한 이름을 가진 변수에 바인딩합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct{a: x, b: y, c: z} = struct_value;          // 모든 필드 구조 분해
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.struct.refutable"><a class="rule-link" href="#r-patterns.struct.refutable" title="patterns.struct.refutable"><span>[patterns<wbr>.struct<wbr>.refutable]<span/></a></div>
<p>_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다.</p>
<div class="rule" id="r-patterns.tuple-struct"><a class="rule-link" href="#r-patterns.tuple-struct" title="patterns.tuple-struct"><span>[patterns<wbr>.tuple-struct]<span/></a></div>
<h2 id="튜플-구조체-패턴"><a class="header" href="#튜플-구조체-패턴">튜플 구조체 패턴</a></h2>
<div class="rule" id="r-patterns.tuple-struct.syntax"><a class="rule-link" href="#r-patterns.tuple-struct.syntax" title="patterns.tuple-struct.syntax"><span>[patterns<wbr>.tuple-struct<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플구조체패턴</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>표현식내경로</em></a> <code>(</code> <em>튜플구조체항목</em> <sup>?</sup> <code>)</code></p>
<p><em>튜플구조체항목</em> :<br />
   <a href="#patterns"><em>패턴</em></a> ( <code>,</code> <a href="#patterns"><em>패턴</em></a> ) <sup>*</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.tuple-struct.intro"><a class="rule-link" href="#r-patterns.tuple-struct.intro" title="patterns.tuple-struct.intro"><span>[patterns<wbr>.tuple-struct<wbr>.intro]<span/></a></div>
<p>튜플 구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 구조체 및 열거형 값과 매치됩니다. 또한 튜플 구조체 또는 열거형 값을 <a href="#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.tuple-struct.refutable"><a class="rule-link" href="#r-patterns.tuple-struct.refutable" title="patterns.tuple-struct.refutable"><span>[patterns<wbr>.tuple-struct<wbr>.refutable]<span/></a></div>
<p>_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 튜플 구조체 패턴은 반박 가능합니다.</p>
<div class="rule" id="r-patterns.tuple"><a class="rule-link" href="#r-patterns.tuple" title="patterns.tuple"><span>[patterns<wbr>.tuple]<span/></a></div>
<h2 id="튜플-패턴"><a class="header" href="#튜플-패턴">튜플 패턴</a></h2>
<div class="rule" id="r-patterns.tuple.syntax"><a class="rule-link" href="#r-patterns.tuple.syntax" title="patterns.tuple.syntax"><span>[patterns<wbr>.tuple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>튜플패턴</em> :<br />
   <code>(</code> <em>튜플패턴항목</em> <sup>?</sup> <code>)</code></p>
<p><em>튜플패턴항목</em> :<br />
      <a href="#patterns"><em>패턴</em></a> <code>,</code><br />
   | <a href="#rest-patterns"><em>나머지패턴</em></a><br />
   | <a href="#patterns"><em>패턴</em></a> ( <code>,</code> <a href="#patterns"><em>패턴</em></a> ) <sup>+</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.tuple.intro"><a class="rule-link" href="#r-patterns.tuple.intro" title="patterns.tuple.intro"><span>[patterns<wbr>.tuple<wbr>.intro]<span/></a></div>
<p>튜플 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 값과 매치됩니다. 또한 튜플을 <a href="#destructuring">구조 분해</a>하는 데 사용됩니다.</p>
<div class="rule" id="r-patterns.tuple.rest-syntax"><a class="rule-link" href="#r-patterns.tuple.rest-syntax" title="patterns.tuple.rest-syntax"><span>[patterns<wbr>.tuple<wbr>.rest-syntax]<span/></a></div>
<p>단일 <a href="#rest-patterns"><em>나머지 패턴</em></a>을 포함하는 <code>(..)</code> 형식은 쉼표가 필요하지 않은 특별한 형식으로, 모든 크기의 튜플과 매치됩니다.</p>
<div class="rule" id="r-patterns.tuple.refutable"><a class="rule-link" href="#r-patterns.tuple.refutable" title="patterns.tuple.refutable"><span>[patterns<wbr>.tuple<wbr>.refutable]<span/></a></div>
<p>튜플 패턴은 서브패턴 중 하나가 반박 가능한 경우 반박 가능합니다.</p>
<p>튜플 패턴 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, "ten");
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, "ten");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.paren"><a class="rule-link" href="#r-patterns.paren" title="patterns.paren"><span>[patterns<wbr>.paren]<span/></a></div>
<h2 id="그룹화된-패턴"><a class="header" href="#그룹화된-패턴">그룹화된 패턴</a></h2>
<div class="rule" id="r-patterns.paren.syntax"><a class="rule-link" href="#r-patterns.paren.syntax" title="patterns.paren.syntax"><span>[patterns<wbr>.paren<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>그룹화된패턴</em> :<br />
   <code>(</code> <a href="#patterns"><em>패턴</em></a> <code>)</code></p>
</blockquote>
<div class="rule" id="r-patterns.paren.intro"><a class="rule-link" href="#r-patterns.paren.intro" title="patterns.paren.intro"><span>[patterns<wbr>.paren<wbr>.intro]<span/></a></div>
<p>패턴을 괄호로 묶으면 복합 패턴의 우선순위를 명시적으로 제어할 수 있습니다. 예를 들어, <code>&amp;0..=5</code>와 같이 참조 패턴이 범위 패턴 옆에 오는 것은 모호하여 허용되지 않지만, 괄호를 사용하여 표현할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.slice"><a class="rule-link" href="#r-patterns.slice" title="patterns.slice"><span>[patterns<wbr>.slice]<span/></a></div>
<h2 id="슬라이스-패턴"><a class="header" href="#슬라이스-패턴">슬라이스 패턴</a></h2>
<div class="rule" id="r-patterns.slice.syntax"><a class="rule-link" href="#r-patterns.slice.syntax" title="patterns.slice.syntax"><span>[patterns<wbr>.slice<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>슬라이스패턴</em> :<br />
   <code>[</code> <em>슬라이스패턴항목</em> <sup>?</sup> <code>]</code></p>
<p><em>슬라이스패턴항목</em> :<br />
   <a href="#patterns"><em>패턴</em></a> ( <code>,</code> <a href="#patterns"><em>패턴</em></a> ) <sup>*</sup> <code>,</code> <sup>?</sup></p>
</blockquote>
<div class="rule" id="r-patterns.slice.intro"><a class="rule-link" href="#r-patterns.slice.intro" title="patterns.slice.intro"><span>[patterns<wbr>.slice<wbr>.intro]<span/></a></div>
<p>슬라이스 패턴은 고정 크기 배열과 동적 크기 슬라이스 모두와 매치될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 고정 크기
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; "1로 시작함",
    [a, b, c] =&gt; "다른 것으로 시작함",
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 동적 크기
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 이 암(arm)은 길이가 일치하지 않으므로 적용되지 않습니다 */ }
    [a, b, c] =&gt; { /* 이 암(arm)이 적용됩니다 */ }
    _ =&gt; { /* 길이를 정적으로 알 수 없으므로 이 와일드카드가 필요합니다 */ }
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-patterns.slice.refutable-array"><a class="rule-link" href="#r-patterns.slice.refutable-array" title="patterns.slice.refutable-array"><span>[patterns<wbr>.slice<wbr>.refutable-array]<span/></a></div>
<p>슬라이스 패턴은 배열을 매치할 때 각 요소가 반박 불가능하다면 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.slice.refutable-slice"><a class="rule-link" href="#r-patterns.slice.refutable-slice" title="patterns.slice.refutable-slice"><span>[patterns<wbr>.slice<wbr>.refutable-slice]<span/></a></div>
<p>슬라이스를 매치할 때, 단일 <code>..</code> <a href="#rest-patterns">나머지 패턴</a>이거나 <code>..</code> 나머지 패턴을 서브패턴으로 가진 <a href="#identifier-patterns">식별자 패턴</a> 형식인 경우에만 반박 불가능합니다.</p>
<div class="rule" id="r-patterns.slice.restriction"><a class="rule-link" href="#r-patterns.slice.restriction" title="patterns.slice.restriction"><span>[patterns<wbr>.slice<wbr>.restriction]<span/></a></div>
<p>슬라이스 내에서 하한과 상한이 모두 있지 않은 범위 패턴은 단일 슬라이스 요소와 매치하려는 의도임을 명확히 하기 위해 <code>(a..)</code>와 같이 괄호로 묶어야 합니다. <code>a..=b</code>와 같이 하한과 상한이 모두 있는 범위 패턴은 괄호로 묶을 필요가 없습니다.</p>
<div class="rule" id="r-patterns.path"><a class="rule-link" href="#r-patterns.path" title="patterns.path"><span>[patterns<wbr>.path]<span/></a></div>
<h2 id="경로-패턴"><a class="header" href="#경로-패턴">경로 패턴</a></h2>
<div class="rule" id="r-patterns.path.syntax"><a class="rule-link" href="#r-patterns.path.syntax" title="patterns.path.syntax"><span>[patterns<wbr>.path<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>경로패턴</em> :<br />
      <a href="expressions/path-expr.html"><em>경로표현식</em></a></p>
</blockquote>
<div class="rule" id="r-patterns.path.intro"><a class="rule-link" href="#r-patterns.path.intro" title="patterns.path.intro"><span>[patterns<wbr>.path<wbr>.intro]<span/></a></div>
<p>_경로 패턴_은 상수 값이나 필드가 없는 구조체 또는 열거형 변형을 참조하는 패턴입니다.</p>
<div class="rule" id="r-patterns.path.unqualified"><a class="rule-link" href="#r-patterns.path.unqualified" title="patterns.path.unqualified"><span>[patterns<wbr>.path<wbr>.unqualified]<span/></a></div>
<p>수식되지 않은(unqualified) 경로 패턴은 다음을 참조할 수 있습니다:</p>
<ul>
<li>열거형 변형</li>
<li>구조체</li>
<li>상수</li>
<li>연관 상수</li>
</ul>
<div class="rule" id="r-patterns.path.qualified"><a class="rule-link" href="#r-patterns.path.qualified" title="patterns.path.qualified"><span>[patterns<wbr>.path<wbr>.qualified]<span/></a></div>
<p>수식된(qualified) 경로 패턴은 연관 상수만 참조할 수 있습니다.</p>
<div class="rule" id="r-patterns.path.refutable"><a class="rule-link" href="#r-patterns.path.refutable" title="patterns.path.refutable"><span>[patterns<wbr>.path<wbr>.refutable]<span/></a></div>
<p>경로 패턴은 구조체를 참조하거나, 열거형이 단 하나의 변형만 가질 때 해당 열거형 변형을 참조하거나, 타입이 반박 불가능한 상수를 참조할 때 반박 불가능합니다. 여러 변형을 가진 열거형의 변형이나 반박 가능한 상수를 참조할 때는 반박 가능합니다.</p>
<div class="rule" id="r-patterns.const"><a class="rule-link" href="#r-patterns.const" title="patterns.const"><span>[patterns<wbr>.const]<span/></a></div>
<h3 id="상수-패턴"><a class="header" href="#상수-패턴">상수 패턴</a></h3>
<div class="rule" id="r-patterns.const.partial-eq"><a class="rule-link" href="#r-patterns.const.partial-eq" title="patterns.const.partial-eq"><span>[patterns<wbr>.const<wbr>.partial-eq]<span/></a></div>
<p><code>T</code> 타입의 상수 <code>C</code>가 패턴으로 사용될 때, 먼저 <code>T: PartialEq</code>인지 확인합니다.</p>
<div class="rule" id="r-patterns.const.structural-equality"><a class="rule-link" href="#r-patterns.const.structural-equality" title="patterns.const.structural-equality"><span>[patterns<wbr>.const<wbr>.structural-equality]<span/></a></div>
<p>나아가 상수 <code>C</code>의 값이 _(재귀적) 구조적 동등성_을 가져야 하며, 이는 다음과 같이 재귀적으로 정의됩니다:</p>
<div class="rule" id="r-patterns.const.primitive"><a class="rule-link" href="#r-patterns.const.primitive" title="patterns.const.primitive"><span>[patterns<wbr>.const<wbr>.primitive]<span/></a></div>
<ul>
<li>정수뿐만 아니라 <code>str</code>, <code>bool</code>, <code>char</code> 값은 항상 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.builtin-aggregate"><a class="rule-link" href="#r-patterns.const.builtin-aggregate" title="patterns.const.builtin-aggregate"><span>[patterns<wbr>.const<wbr>.builtin-aggregate]<span/></a></div>
<ul>
<li>튜플, 배열, 슬라이스는 모든 필드/요소가 구조적 동등성을 가지면 구조적 동등성을 갖습니다. (특히, <code>()</code>와 <code>[]</code>는 항상 구조적 동등성을 갖습니다.)</li>
</ul>
<div class="rule" id="r-patterns.const.ref"><a class="rule-link" href="#r-patterns.const.ref" title="patterns.const.ref"><span>[patterns<wbr>.const<wbr>.ref]<span/></a></div>
<ul>
<li>참조는 가리키는 값이 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.aggregate"><a class="rule-link" href="#r-patterns.const.aggregate" title="patterns.const.aggregate"><span>[patterns<wbr>.const<wbr>.aggregate]<span/></a></div>
<ul>
<li><code>struct</code> 또는 <code>enum</code> 타입의 값은 <code>PartialEq</code> 인스턴스가 <code>#[derive(PartialEq)]</code>를 통해 파생되었고, 모든 필드(열거형의 경우 현재 활성화된 변형의 필드)가 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.pointer"><a class="rule-link" href="#r-patterns.const.pointer" title="patterns.const.pointer"><span>[patterns<wbr>.const<wbr>.pointer]<span/></a></div>
<ul>
<li>원시 포인터는 상수 정수로 정의된 경우(그 후 캐스팅되거나 transmute된 경우) 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.float"><a class="rule-link" href="#r-patterns.const.float" title="patterns.const.float"><span>[patterns<wbr>.const<wbr>.float]<span/></a></div>
<ul>
<li>부동 소수점 값은 <code>NaN</code>이 아니면 구조적 동등성을 갖습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.exhaustive"><a class="rule-link" href="#r-patterns.const.exhaustive" title="patterns.const.exhaustive"><span>[patterns<wbr>.const<wbr>.exhaustive]<span/></a></div>
<ul>
<li>그 외에는 구조적 동등성을 갖지 않습니다.</li>
</ul>
<div class="rule" id="r-patterns.const.generic"><a class="rule-link" href="#r-patterns.const.generic" title="patterns.const.generic"><span>[patterns<wbr>.const<wbr>.generic]<span/></a></div>
<p>특히, 상수 <code>C</code>의 값은 패턴 구축 시점(단형성화(monomorphization) 이전)에 알려져야 합니다. 이는 제네릭 파라미터가 포함된 연관 상수는 패턴으로 사용될 수 없음을 의미합니다.</p>
<div class="rule" id="r-patterns.const.translation"><a class="rule-link" href="#r-patterns.const.translation" title="patterns.const.translation"><span>[patterns<wbr>.const<wbr>.translation]<span/></a></div>
<p>모든 조건이 충족되면, 상수 값은 패턴으로 번역되며 이제 해당 패턴을 직접 작성한 것과 정확히 동일하게 동작합니다. 특히, 이는 망라성 검사(exhaustiveness checking)에 완전히 참여합니다. (원시 포인터의 경우, 상수가 이러한 패턴을 작성하는 유일한 방법입니다. 이러한 타입들에 대해서는 오직 <code>_</code>만이 망라적인 것으로 간주됩니다.)</p>
<div class="rule" id="r-patterns.or"><a class="rule-link" href="#r-patterns.or" title="patterns.or"><span>[patterns<wbr>.or]<span/></a></div>
<h2 id="or-패턴"><a class="header" href="#or-패턴">Or 패턴</a></h2>
<p>_Or 패턴_은 둘 이상의 서브패턴 중 하나와 매치되는 패턴입니다(예: <code>A | B | C</code>). 이들은 임의로 중첩될 수 있습니다. 구문상으로 Or 패턴은 다른 패턴이 허용되는 모든 위치(<em>패턴</em> 생성물로 표현됨)에서 허용되지만, <code>let</code> 바인딩과 함수 및 클로저의 인자(<em>최상위대안없는패턴</em> 생성물로 표현됨)는 제외됩니다.</p>
<div class="rule" id="r-patterns.constraints"><a class="rule-link" href="#r-patterns.constraints" title="patterns.constraints"><span>[patterns<wbr>.constraints]<span/></a></div>
<h3 id="정적-시맨틱"><a class="header" href="#정적-시맨틱">정적 시맨틱</a></h3>
<div class="rule" id="r-patterns.constraints.pattern"><a class="rule-link" href="#r-patterns.constraints.pattern" title="patterns.constraints.pattern"><span>[patterns<wbr>.constraints<wbr>.pattern]<span/></a></div>
<ol>
<li>
<p>임의의 패턴 <code>p</code>와 <code>q</code>에 대해 어떤 깊이에서든 <code>p | q</code> 패턴이 주어졌을 때, 다음의 경우 해당 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다:</p>
<ul>
<li><code>p</code>에 대해 추론된 타입이 <code>q</code>에 대해 추론된 타입과 통합(unify)되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에서 동일한 바인딩 집합이 도입되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에 있는 동일한 이름의 두 바인딩 타입이 타입 또는 바인딩 모드 관점에서 통합되지 않는 경우.
타입 통합은 모든 인스턴스에서 앞서 언급한 대로 정확해야 하며, 암시적인 <a href="type-coercions.html">타입 강제 변환</a>은 적용되지 않습니다.</li>
</ul>
</li>
</ol>
<div class="rule" id="r-patterns.constraints.match-type-check"><a class="rule-link" href="#r-patterns.constraints.match-type-check" title="patterns.constraints.match-type-check"><span>[patterns<wbr>.constraints<wbr>.match-type-check]<span/></a></div>
<ol start="2">
<li><code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code> 표현식을 타입 검사할 때, <code>p_i | q_i</code> 형식의 패턴을 포함하는 각 매치 암 <code>a_i</code>에 대해, 해당 패턴이 존재하는 깊이 <code>d</code>에서 <code>e_s</code>의 깊이 <code>d</code> 조각의 타입이 <code>p_i | q_i</code>와 통합(unify)되지 않으면 <code>p_i | q_i</code> 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다.</li>
</ol>
<div class="rule" id="r-patterns.constraints.exhaustiveness-or-pattern"><a class="rule-link" href="#r-patterns.constraints.exhaustiveness-or-pattern" title="patterns.constraints.exhaustiveness-or-pattern"><span>[patterns<wbr>.constraints<wbr>.exhaustiveness-or-pattern]<span/></a></div>
<ol start="3">
<li>
<p>망라성 검사와 관련하여, <code>p | q</code> 패턴은 <code>p</code>와 <code>q</code>를 모두 포괄하는 것으로 간주됩니다. 어떤 생성자 <code>c(x, ..)</code>에 대해 분배 법칙이 적용되어, <code>c(p | q, ..rest)</code>는 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 값 집합을 포괄합니다. 이는 최상위 레벨에 존재하는 패턴을 제외하고 <code>p | q</code> 형식의 중첩된 패턴이 더 이상 없을 때까지 재귀적으로 적용될 수 있습니다.</p>
<p>여기서 _“생성자”_는 튜플 구조체 패턴만을 가리키는 것이 아니라, 모든 곱 타입(product type)에 대한 패턴을 의미합니다. 여기에는 열거형 변형, 튜플 구조체, 이름 있는 필드가 있는 구조체, 배열, 튜플, 슬라이스가 포함됩니다.</p>
</li>
</ol>
<div class="rule" id="r-patterns.behavior"><a class="rule-link" href="#r-patterns.behavior" title="patterns.behavior"><span>[patterns<wbr>.behavior]<span/></a></div>
<h3 id="동적-시맨틱"><a class="header" href="#동적-시맨틱">동적 시맨틱</a></h3>
<div class="rule" id="r-patterns.behavior.nested-or-patterns"><a class="rule-link" href="#r-patterns.behavior.nested-or-patterns" title="patterns.behavior.nested-or-patterns"><span>[patterns<wbr>.behavior<wbr>.nested-or-patterns]<span/></a></div>
<ol>
<li>조사 대상 표현식 <code>e_s</code>를 깊이 <code>d</code>에서 <code>c(p | q, ..rest)</code> 패턴(여기서 <code>c</code>는 어떤 생성자, <code>p</code>와 <code>q</code>는 임의의 패턴, <code>rest</code>는 <code>c</code>의 나머지 선택적 요소)과 매치하는 동적 시맨틱은 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 것으로 정의됩니다.</li>
</ol>
<div class="rule" id="r-patterns.precedence"><a class="rule-link" href="#r-patterns.precedence" title="patterns.precedence"><span>[patterns<wbr>.precedence]<span/></a></div>
<h3 id="구분-기호가-없는-다른-패턴과의-우선순위"><a class="header" href="#구분-기호가-없는-다른-패턴과의-우선순위">구분 기호가 없는 다른 패턴과의 우선순위</a></h3>
<p>이 장의 다른 곳에서 보여준 것처럼, 식별자 패턴, 참조 패턴, Or 패턴을 포함하여 구문상으로 구분 기호가 없는(undelimited) 여러 유형의 패턴이 있습니다. Or 패턴은 항상 가장 낮은 우선순위를 갖습니다. 이를 통해 향후 타입 어스크립션(type ascription) 기능을 위한 구문적 공간을 확보하고 모호성을 줄일 수 있습니다. 예를 들어, <code>x @ A(..) | B(..)</code>는 <code>x</code>가 모든 패턴에 바인딩되지 않았다는 오류를 발생시킵니다. <code>&amp;A(x) | B(x)</code>는 서로 다른 서브패턴에 있는 <code>x</code> 사이의 타입 불일치를 발생시킵니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="expressions/underscore-expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="type-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="expressions/underscore-expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="type-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
