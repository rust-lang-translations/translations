<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>패턴 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/patterns.md`;
                    } else {
                        canonical_href = `${base}/${lang}/patterns.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[patterns]</p>
<h1 id="패턴"><a class="header" href="#패턴">패턴</a></h1>
<p>r[patterns.syntax]</p>
<pre><code class="language-grammar patterns">Pattern -&gt; `|`? PatternNoTopAlt  ( `|` PatternNoTopAlt )*

PatternNoTopAlt -&gt;
      PatternWithoutRange
    | RangePattern

PatternWithoutRange -&gt;
      LiteralPattern
    | IdentifierPattern
    | WildcardPattern
    | RestPattern
    | ReferencePattern
    | StructPattern
    | TupleStructPattern
    | TuplePattern
    | GroupedPattern
    | SlicePattern
    | PathPattern
    | MacroInvocation
</code></pre>
<p>r[patterns.intro] Patterns are used to match values against structures and to, optionally, bind variables to values inside these structures. They are also used in variable declarations and parameters for functions and closures.</p>
<p>다음 예제의 패턴은 네 가지 작업을 수행합니다:</p>
<ul>
<li><code>person</code>의 <code>car</code> 필드가 무언가로 채워져 있는지 테스트합니다.</li>
<li>사람의 <code>age</code> 필드가 13에서 19 사이인지 테스트하고, 그 값을 <code>person_age</code> 변수에 바인딩합니다.</li>
<li><code>name</code> 필드에 대한 참조를 <code>person_name</code> 변수에 바인딩합니다.</li>
<li><code>person</code>의 나머지 필드를 무시합니다. 나머지 필드는 어떤 값이든 가질 수 있으며 어떤 변수에도 바인딩되지 않습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from("John"),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!("{}는 차가 있고 {}살입니다.", person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.usage] Patterns are used in:</p>
<p>r[patterns.let]</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 선언</a></li>
</ul>
<p>r[patterns.param]</p>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
</ul>
<p>r[patterns.match]</p>
<ul>
<li><a href="expressions/match-expr.html"><code>match</code> 표현식</a></li>
</ul>
<p>r[patterns.if-let]</p>
<ul>
<li><a href="expressions/if-expr.html"><code>if let</code> 표현식</a></li>
</ul>
<p>r[patterns.while-let]</p>
<ul>
<li><a href="expressions/loop-expr.html#while-let-patterns"><code>while let</code> expressions</a></li>
</ul>
<p>r[patterns.for]</p>
<ul>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a></li>
</ul>
<p>r[patterns.destructure]</p>
<h2 id="구조-분해"><a class="header" href="#구조-분해">구조 분해</a></h2>
<p>r[patterns.destructure.intro] Patterns can be used to <em>destructure</em> <a href="items/structs.html">structs</a>, <a href="items/enumerations.html">enums</a>, and <a href="types/tuple.html">tuples</a>. Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.</p>
<p>r[patterns.destructure.wildcard] In a pattern whose <a href="glossary.html#scrutinee">scrutinee</a> expression has a <code>struct</code>, <code>enum</code> or <code>tuple</code> type, a <a href="#wildcard-pattern">wildcard pattern</a> (<code>_</code>) stands in for a <em>single</em> data field, whereas an <a href="#grammar-StructPatternEtCetera">et cetera</a> or [rest pattern][patterns.rest] (<code>..</code>) stands in for <em>all</em> the remaining fields of a particular variant.</p>
<p>r[patterns.destructure.named-field-shorthand] When destructuring a data structure with named (but not numbered) fields, it is allowed to write <code>fieldname</code> as a shorthand for <code>fieldname: fieldname</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!("Quit"),
    Message::WriteString(write) =&gt; println!("{}", &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!("가로로 {}만큼 이동", x),
    Message::Move{ .. } =&gt; println!("다른 이동"),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!("색상 변경, 빨강: {}, 초록: {}", red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.refutable]</p>
<h2 id="반박-가능성"><a class="header" href="#반박-가능성">반박 가능성</a></h2>
<p>패턴이 비교 대상 값과 일치하지 않을 가능성이 있는 경우를 _반박 가능(refutable)_하다고 합니다. 반면에 _반박 불가능(irrefutable)_한 패턴은 비교 대상 값과 항상 일치합니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // "(x, y)"는 반박 불가능한 패턴입니다

if let (a, 3) = (1, 2) {           // "(a, 3)"은 반박 가능하며, 일치하지 않을 수 있습니다
    panic!("여기에 도달해서는 안 됩니다");
} else if let (a, 4) = (3, 4) {    // "(a, 4)"는 반박 가능하며, 일치하게 됩니다
    println!("({}, 4)와 일치함", a);
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.literal]</p>
<h2 id="리터럴-패턴"><a class="header" href="#리터럴-패턴">리터럴 패턴</a></h2>
<p>r[patterns.literal.syntax]</p>
<pre><code class="language-grammar patterns">LiteralPattern -&gt; `-`? LiteralExpression
</code></pre>
<p>r[patterns.literal.intro] <em>Literal patterns</em> match exactly the same value as what is created by the literal. Since negative numbers are not <a href="expressions/literal-expr.html">literals</a>, literals in patterns may be prefixed by an optional minus sign, which acts like the negation operator.</p>
<blockquote>
<p>[!WARNING] C string and raw C string literals are accepted in literal patterns, but <code>&amp;CStr</code> doesn’t implement structural equality (<code>#[derive(Eq, PartialEq)]</code>) and therefore any such <code>match</code> on a <code>&amp;CStr</code> will be rejected with a type error.</p>
</blockquote>
<p>r[patterns.literal.refutable] Literal patterns are always refutable.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!("마이너스 1입니다"),
        1 =&gt; println!("1입니다"),
        2|4 =&gt; println!("2 또는 4입니다"),
        _ =&gt; println!("어떠한 매치 암(arm)과도 일치하지 않았습니다"),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident]</p>
<h2 id="식별자-패턴"><a class="header" href="#식별자-패턴">식별자 패턴</a></h2>
<p>r[patterns.ident.syntax]</p>
<pre><code class="language-grammar patterns">IdentifierPattern -&gt; `ref`? `mut`? IDENTIFIER ( `@` PatternNoTopAlt )?
</code></pre>
<p>r[patterns.ident.intro] Identifier patterns bind the value they match to a variable in the <a href="names.namespaces.kinds">value namespace</a>.</p>
<p>r[patterns.ident.unique] The identifier must be unique within the pattern.</p>
<p>r[patterns.ident.scope] The variable will shadow any variables of the same name in scope. The <a href="names/scopes.html">scope</a> of the new binding depends on the context of where the pattern is used (such as a <code>let</code> binding or a <code>match</code> arm).</p>
<p>r[patterns.ident.bare] Patterns that consist of only an identifier, possibly with a <code>mut</code>, match any value and bind it to that identifier. This is the most commonly used pattern in variable declarations and parameters for functions and closures.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.scrutinized] To bind the matched value of a pattern to a variable, use the syntax <code>variable @ subpattern</code>. For example, the following binds the value 2 to <code>e</code> (not the entire range: the range here is a range subpattern).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!("범위 요소 {}를 얻음", e),
    _ =&gt; println!("아무거나"),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.move] By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>.</p>
<p>r[patterns.ident.ref] This can be changed to bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using <code>ref mut</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 match 표현식에서 값은 복사(또는 이동)됩니다. 두 번째 match에서 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 구조 분해 서브패턴에서는 <code>&amp;</code> 연산자를 값의 필드에 적용할 수 없기 때문에 이 구문이 필요합니다. 예를 들어, 다음은 유효하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>이를 유효하게 만들려면 다음과 같이 작성하십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.ref-ignored] Thus, <code>ref</code> is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</p>
<p>r[patterns.ident.precedent] <a href="#path-patterns">Path patterns</a> take precedence over identifier patterns.</p>
<blockquote>
<p>[!NOTE] When a pattern is a single-segment identifier, the grammar is ambiguous whether it means an [IdentifierPattern] or a [PathPattern]. This ambiguity can only be resolved after <a href="names/name-resolution.html">name resolution</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const EXPECTED_VALUE: u8 = 42;
//    ^^^^^^^^^^^^^^ That this constant is in scope affects how the
//                   patterns below are treated.

fn check_value(x: u8) -&gt; Result&lt;u8, u8&gt; {
    match x {
        EXPECTED_VALUE =&gt; Ok(x),
    //  ^^^^^^^^^^^^^^ Parsed as a `PathPattern` that resolves to
    //                 the constant `42`.
        other_value =&gt; Err(x),
    //  ^^^^^^^^^^^ Parsed as an `IdentifierPattern`.
    }
}

// If `EXPECTED_VALUE` were treated as an `IdentifierPattern` above,
// that pattern would always match, making the function always return
// `Ok(_) regardless of the input.
assert_eq!(check_value(42), Ok(42));
assert_eq!(check_value(43), Err(43));
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[patterns.ident.constraint] It is an error if <code>ref</code> or <code>ref mut</code> is specified and the identifier shadows a constant.</p>
<p>r[patterns.ident.refutable] Identifier patterns are irrefutable if the <code>@</code> subpattern is irrefutable or the subpattern is not specified.</p>
<p>r[patterns.ident.binding]</p>
<h3 id="바인딩-모드"><a class="header" href="#바인딩-모드">바인딩 모드</a></h3>
<p>r[patterns.ident.binding.intro] To service better ergonomics, patterns operate in different <em>binding modes</em> in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a <code>ref</code> or <code>ref mut</code> binding. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);
if let Some(y) = x {
    // y는 `ref y`로 변환되었으며 타입은 &amp;i32입니다
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.non-reference] <em>Non-reference patterns</em> include all patterns except bindings, <a href="#wildcard-pattern">wildcard patterns</a> (<code>_</code>), <a href="#path-patterns"><code>const</code> patterns</a> of reference types, and <a href="#reference-patterns">reference patterns</a>.</p>
<p>r[patterns.ident.binding.default-mode] If a binding pattern does not explicitly have <code>ref</code>, <code>ref mut</code>, or <code>mut</code>, then it uses the <em>default binding mode</em> to determine how the variable is bound.</p>
<p>r[patterns.ident.binding.move] The default binding mode starts in “move” mode which uses move semantics.</p>
<p>r[patterns.ident.binding.top-down] When matching a pattern, the compiler starts from the outside of the pattern and works inwards.</p>
<p>r[patterns.ident.binding.auto-deref] Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode.</p>
<p>r[patterns.ident.binding.ref] References will set the default binding mode to <code>ref</code>.</p>
<p>r[patterns.ident.binding.ref-mut] Mutable references will set the mode to <code>ref mut</code> unless the mode is already <code>ref</code> in which case it remains <code>ref</code>.</p>
<p>r[patterns.ident.binding.nested-references] If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</p>
<p>r[patterns.ident.binding.mode-limitations-binding] The binding pattern may only explicitly specify a <code>ref</code> or <code>ref mut</code> binding mode, or specify mutability with <code>mut</code>, when the default binding mode is “move”. For example, these are not accepted:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [mut x] = &amp;[()]; //~ 오류
let [ref x] = &amp;[()]; //~ 오류
let [ref mut x] = &amp;mut [()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.mode-limitations.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, bindings could explicitly specify a <code>ref</code> or <code>ref mut</code> binding mode even when the default binding mode was not “move”, and they could specify mutability on such bindings with <code>mut</code>. In these editions, specifying <code>mut</code> on a binding set the binding mode to “move” regardless of the current default binding mode.</p>
</blockquote>
<p>r[patterns.ident.binding.mode-limitations-reference] Similarly, a reference pattern may only appear when the default binding mode is “move”. For example, this is not accepted:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [&amp;x] = &amp;[&amp;()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.mode-limitations-reference.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, reference patterns could appear even when the default binding mode was not “move”, and had both the effect of matching against the scrutinee and of causing the default binding mode to be reset to “move”.</p>
</blockquote>
<p>r[patterns.ident.binding.mixed] Move bindings and reference bindings can be mixed together in the same pattern. Doing so will result in partial move of the object bound to and the object cannot be used afterwards. This applies only if the type cannot be copied.</p>
<p>아래 예시에서 <code>name</code>은 <code>person</code>에서 이동됩니다. <code>person</code> 전체를 사용하거나 <code>person.name</code>을 사용하려고 하면 _부분 이동_으로 인해 오류가 발생합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from("John"), age: 23 };
</span>// `name`은 person에서 이동되고 `age`는 참조됩니다
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.wildcard]</p>
<h2 id="와일드카드-패턴"><a class="header" href="#와일드카드-패턴">와일드카드 패턴</a></h2>
<p>r[patterns.wildcard.syntax]</p>
<pre><code class="language-grammar patterns">WildcardPattern -&gt; `_`
</code></pre>
<p>r[patterns.wildcard.intro] The <em>wildcard pattern</em> (an underscore symbol) matches any value. It is used to ignore values when they don’t matter.</p>
<p>r[patterns.wildcard.struct-matcher] Inside other patterns it matches a single data field (as opposed to the <code>..</code> which matches the remaining fields).</p>
<p>r[patterns.wildcard.no-binding] Unlike identifier patterns, it does not copy, move or borrow the value it matches.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x는 항상 _와 매치됩니다
<span class="boring">assert_eq!(a, 10);
</span>
// 함수/클로저 매개변수를 무시합니다
let real_part = |a: f64, _: f64| { a };

// 구조체의 필드를 무시합니다
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 어떤 값이든 Some이면 허용합니다
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.wildcard.refutable] The wildcard pattern is always irrefutable.</p>
<p>r[patterns.rest]</p>
<h2 id="rest-pattern"><a class="header" href="#rest-pattern">Rest pattern</a></h2>
<p>r[patterns.rest.syntax]</p>
<pre><code class="language-grammar patterns">RestPattern -&gt; `..`
</code></pre>
<p>r[patterns.rest.intro] The <em>rest pattern</em> (the <code>..</code> token) acts as a variable-length pattern which matches zero or more elements that haven’t been matched already before and after.</p>
<p>r[patterns.rest.allowed-patterns] It may only be used in <a href="#tuple-patterns">tuple</a>, <a href="#tuple-struct-patterns">tuple struct</a>, and <a href="#slice-patterns">slice</a> patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an <a href="#identifier-patterns">identifier pattern</a> for <a href="#slice-patterns">slice patterns</a> only.</p>
<p>r[patterns.rest.refutable] The rest pattern is always irrefutable.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec!["a", "b", "c"];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!("슬라이스가 비어 있음"),
    [one] =&gt; println!("단일 요소 {}", one),
    [head, tail @ ..] =&gt; println!("head={} tail={:?}", head, tail),
}

match slice {
    // "!"여야 하는 마지막 요소를 제외한 모든 것을 무시합니다.
    [.., "!"] =&gt; println!("!!!"),

    // `start`는 "z"여야 하는 마지막 요소를 제외한 모든 것의 슬라이스입니다.
    [start @ .., "z"] =&gt; println!("다음으로 시작함: {:?}", start),

    // `end`는 "a"여야 하는 첫 번째 요소를 제외한 모든 것의 슬라이스입니다.
    ["a", end @ ..] =&gt; println!("다음으로 끝남: {:?}", end),

    // 'whole'은 전체 슬라이스이고 `last`는 마지막 요소입니다
    whole @ [.., last] =&gt; println!("{:?}의 마지막 요소는 {}입니다", whole, last),

    rest =&gt; println!("{:?}", rest),
}

if let [.., penultimate, _] = slice {
    println!("마지막에서 두 번째는 {}입니다", penultimate);
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// The rest pattern may also be used in tuple and tuple
// struct patterns.
match tuple {
    (1, .., y, z) =&gt; println!("y={} z={}", y, z),
    (.., 5) =&gt; println!("꼬리(tail)는 5여야 함"),
    (..) =&gt; println!("그 외 모든 것과 일치함"),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.range]</p>
<h2 id="범위-패턴"><a class="header" href="#범위-패턴">범위 패턴</a></h2>
<p>r[patterns.range.syntax]</p>
<pre><code class="language-grammar patterns">RangePattern -&gt;
      RangeExclusivePattern
    | RangeInclusivePattern
    | RangeFromPattern
    | RangeToExclusivePattern
    | RangeToInclusivePattern
    | ObsoleteRangePattern[^obsolete-range-edition]

RangeExclusivePattern -&gt;
      RangePatternBound `..` RangePatternBound

RangeInclusivePattern -&gt;
      RangePatternBound `..=` RangePatternBound

RangeFromPattern -&gt;
      RangePatternBound `..`

RangeToExclusivePattern -&gt;
      `..` RangePatternBound

RangeToInclusivePattern -&gt;
      `..=` RangePatternBound

ObsoleteRangePattern -&gt;
    RangePatternBound `...` RangePatternBound

RangePatternBound -&gt;
      LiteralPattern
    | PathExpression
</code></pre>
<div class="footnote-definition" id="obsolete-range-edition"><sup class="footnote-definition-label">1</sup>
<p>The [ObsoleteRangePattern] syntax has been removed in the 2021 edition.</p>
</div>
<p>r[patterns.range.intro] <em>Range patterns</em> match scalar values within the range defined by their bounds. They comprise a <em>sigil</em> (<code>..</code> or <code>..=</code>) and a bound on one or both sides.</p>
<p>A bound on the left of the sigil is called a <em>lower bound</em>. A bound on the right is called an <em>upper bound</em>.</p>
<p>r[patterns.range.exclusive] The <em>exclusive range pattern</em> matches all values from the lower bound up to, but not including the upper bound. It is written as its lower bound, followed by <code>..</code>, followed by the upper bound.</p>
<p>For example, a pattern <code>'m'..'p'</code> will match only <code>'m'</code>, <code>'n'</code> and <code>'o'</code>, specifically <strong>not</strong> including <code>'p'</code>.</p>
<p>r[patterns.range.inclusive] The <em>inclusive range pattern</em> matches all values from the lower bound up to and including the upper bound. It is written as its lower bound, followed by <code>..=</code>, followed by the upper bound.</p>
<p>For example, a pattern <code>'m'..='p'</code> will match only the values <code>'m'</code>, <code>'n'</code>, <code>'o'</code>, and <code>'p'</code>.</p>
<p>r[patterns.range.from] The <em>from range pattern</em> matches all values greater than or equal to the lower bound. It is written as its lower bound followed by <code>..</code>.</p>
<p>For example, <code>1..</code> will match any integer greater than or equal to 1, such as 1, 9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not 0, and not negative numbers for signed integers.</p>
<p>r[patterns.range.to-exclusive] The <em>to exclusive range pattern</em> matches all values less than the upper bound. It is written as <code>..</code> followed by the upper bound.</p>
<p>For example, <code>..10</code> will match any integer less than 10, such as 9, 1, 0, and for signed integer types, all negative values.</p>
<p>r[patterns.range.to-inclusive] The <em>to inclusive range pattern</em> matches all values less than or equal to the upper bound. It is written as <code>..=</code> followed by the upper bound.</p>
<p>For example, <code>..=10</code> will match any integer less than or equal to 10, such as 10, 1, 0, and for signed integer types, all negative values.</p>
<p>r[patterns.range.constraint-nonempty] A range pattern must be nonempty; it must span at least one value in the set of possible values for its type. In other words:</p>
<ul>
<li>In <code>a..=b</code>, a ≤ b must be the case. For example, it is an error to have a range pattern <code>10..=0</code>, but <code>10..=10</code> is allowed.</li>
<li>In <code>a..b</code>, a &lt; b must be the case. For example, it is an error to have a range pattern <code>10..0</code> or <code>10..10</code>.</li>
<li>In <code>..b</code>, b must not be the smallest value of its type. For example, it is an error to have a range pattern <code>..-128i8</code> or <code>..f64::NEG_INFINITY</code>.</li>
</ul>
<p>r[patterns.range.bound] A bound is written as one of:</p>
<ul>
<li>문자, 바이트, 정수 또는 부동 소수점 리터럴.</li>
<li>정수 또는 부동 소수점 리터럴 앞에 <code>-</code>가 붙은 형태.</li>
<li>A <a href="expressions/path-expr.html">path</a>.</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>We syntactically accept more than this for a <em>[RangePatternBound]</em>. We later reject the other things semantically.</p>
</blockquote>
<p>r[patterns.range.constraint-bound-path] If a bound is written as a path, after macro resolution, the path must resolve to a constant item of the type <code>char</code>, an integer type, or a float type.</p>
<p>r[patterns.range.type] The range pattern matches the type of its upper and lower bounds, which must be the same type.</p>
<p>r[patterns.range.path-value] If a bound is a <a href="expressions/path-expr.html">path</a>, the bound matches the type and has the value of the <a href="items/constant-items.html">constant</a> the path resolves to.</p>
<p>r[patterns.range.literal-value] If a bound is a literal, the bound matches the type and has the value of the corresponding <a href="expressions/literal-expr.html">literal expression</a>.</p>
<p>r[patterns.range.negation] If a bound is a literal preceded by a <code>-</code>, the bound matches the same type as the corresponding <a href="expressions/literal-expr.html">literal expression</a> and has the value of <a href="expressions/operator-expr.html#negation-operators">negating</a> the value of the corresponding literal expression.</p>
<p>r[patterns.range.float-restriction] For float range patterns, the constant may not be a <code>NaN</code>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!("{}", match ph {
    0..7 =&gt; "산성",
    7 =&gt; "중성",
    8..=14 =&gt; "염기성",
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; "0입니다!",
    1.. =&gt; "양수입니다!",
};

// 상수에 대한 경로 사용:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!("{}", match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; "대류권",
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; "성층권",
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; "중간권",
    _ =&gt; "아마도 외계 공간",
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!("크기가 적절하며 {}바이트를 차지함", size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// 정규화된 경로 사용:
println!("{}", match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; "u8에 맞음",
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; "u16에 맞음",
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; "u32에 맞음",
    _ =&gt; "너무 큼",
});
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.range.refutable] Range patterns for fix-width integer and <code>char</code> types are irrefutable when they span the entire set of possible values of a type. For example, <code>0u8..=255u8</code> is irrefutable.</p>
<p>r[patterns.range.refutable-integer] The range of values for an integer type is the closed range from its minimum to maximum value.</p>
<p>r[patterns.range.refutable-char] The range of values for a <code>char</code> type are precisely those ranges containing all Unicode Scalar Values: <code>'\u{0000}'..='\u{D7FF}'</code> and <code>'\u{E000}'..='\u{10FFFF}'</code>.</p>
<p>r[patterns.range.constraint-slice] [RangeFromPattern] cannot be used as a top-level pattern for subpatterns in <a href="#slice-patterns">slice patterns</a>. For example, the pattern <code>[1.., _]</code> is not a valid pattern.</p>
<p>r[patterns.range.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, range patterns with both a lower and upper bound may also be written using <code>...</code> in place of <code>..=</code>, with the same meaning.</p>
</blockquote>
<p>r[patterns.ref]</p>
<h2 id="참조-패턴"><a class="header" href="#참조-패턴">참조 패턴</a></h2>
<p>r[patterns.ref.syntax]</p>
<pre><code class="language-grammar patterns">ReferencePattern -&gt; (`&amp;`|`&amp;&amp;`) `mut`? PatternWithoutRange
</code></pre>
<p>r[patterns.ref.intro] Reference patterns dereference the pointers that are being matched and, thus, borrow them.</p>
<p>예를 들어, <code>x: &amp;i32</code>에 대한 다음 두 매치는 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; "0", _ =&gt; "some" };
let b = match int_reference { &amp;0 =&gt; "0", _ =&gt; "some" };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ref.ref-ref] The grammar production for reference patterns has to match the token <code>&amp;&amp;</code> to match a reference to a reference because it is a token by itself, not two <code>&amp;</code> tokens.</p>
<p>r[patterns.ref.mut] Adding the <code>mut</code> keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</p>
<p>r[patterns.ref.refutable] Reference patterns are always irrefutable.</p>
<p>r[patterns.struct]</p>
<h2 id="구조체-패턴"><a class="header" href="#구조체-패턴">구조체 패턴</a></h2>
<p>r[patterns.struct.syntax]</p>
<pre><code class="language-grammar patterns">StructPattern -&gt;
    PathInExpression `{`
        StructPatternElements?
    `}`

StructPatternElements -&gt;
      StructPatternFields (`,` | `,` StructPatternEtCetera)?
    | StructPatternEtCetera

StructPatternFields -&gt;
    StructPatternField (`,` StructPatternField)*

StructPatternField -&gt;
    OuterAttribute*
    (
        TUPLE_INDEX `:` Pattern
      | IDENTIFIER `:` Pattern
      | `ref`? `mut`? IDENTIFIER
    )

StructPatternEtCetera -&gt; `..`
</code></pre>
<p>r[patterns.struct.intro] Struct patterns match struct, enum, and union values that match all criteria defined by its subpatterns. They are also used to <a href="#destructuring">destructure</a> a struct, enum, or union value.</p>
<p>r[patterns.struct.ignore-rest] On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // 순서는 중요하지 않음
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // 순서는 중요하지 않음
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}

<span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">}
</span><span class="boring">let m = Message::Quit;
</span><span class="boring">
</span>match m {
    Message::Quit =&gt; (),
    Message::Move {x: 10, y: 20} =&gt; (),
    Message::Move {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.constraint-struct] If <code>..</code> is not used, a struct pattern used to match a struct is required to specify all fields:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.constraint-union] A struct pattern used to match a union must specify exactly one field (see <a href="items/unions.html#pattern-matching-on-unions">Pattern matching on unions</a>).</p>
<p>r[patterns.struct.binding-shorthand] The [IDENTIFIER] syntax matches any value and binds it to a variable with the same name as the given field. It is a shorthand for <code>fieldname: fieldname</code>. The <code>ref</code> and <code>mut</code> qualifiers can be included with the behavior as described in [patterns.ident.ref].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct { a, b, c } = struct_value;
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.refutable] A struct pattern is refutable if the [PathInExpression] resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>
<p>r[patterns.struct.namespace] A struct pattern matches against the struct, union, or enum variant whose constructor is resolved from [PathInExpression] in the <a href="names.namespaces.kinds">type namespace</a>. See [patterns.tuple-struct.namespace] for more details.</p>
<p>r[patterns.tuple-struct]</p>
<h2 id="튜플-구조체-패턴"><a class="header" href="#튜플-구조체-패턴">튜플 구조체 패턴</a></h2>
<p>r[patterns.tuple-struct.syntax]</p>
<pre><code class="language-grammar patterns">TupleStructPattern -&gt; PathInExpression `(` TupleStructItems? `)`

TupleStructItems -&gt; Pattern ( `,` Pattern )* `,`?
</code></pre>
<p>r[patterns.tuple-struct.intro] Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to <a href="#destructuring">destructure</a> a tuple struct or enum value.</p>
<p>r[patterns.tuple-struct.refutable] A tuple struct pattern is refutable if the [PathInExpression] resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>
<p>r[patterns.tuple-struct.namespace] A tuple struct pattern matches against the tuple struct or <a href="items.enum.tuple-expr">tuple-like enum variant</a> whose constructor is resolved from [PathInExpression] in the <a href="names.namespaces.kinds">value namespace</a>.</p>
<blockquote>
<p>[!NOTE] Conversely, a struct pattern for a tuple struct or <a href="items.enum.tuple-expr">tuple-like enum variant</a>, e.g. <code>S { 0: _ }</code>, matches against the tuple struct or variant whose constructor is resolved in the <a href="names.namespaces.kinds">type namespace</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">enum E1 { V(u16) }
enum E2 { V(u32) }

// Import `E1::V` from the type namespace only.
mod _0 {
    const V: () = (); // For namespace masking.
    pub(super) use super::E1::*;
}
use _0::*;

// Import `E2::V` from the value namespace only.
mod _1 {
    struct V {} // For namespace masking.
    pub(super) use super::E2::*;
}
use _1::*;

fn f() {
    // This struct pattern matches against the tuple-like
    // enum variant whose constructor was found in the type
    // namespace.
    let V { 0: ..=u16::MAX } = (loop {}) else { loop {} };
    // This tuple struct pattern matches against the tuple-like
    // enum variant whose constructor was found in the value
    // namespace.
    let V(..=u32::MAX) = (loop {}) else { loop {} };
}
<span class="boring">// Required due to the odd behavior of `super` within functions.
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>The Lang team has made certain decisions, such as in <a href="https://github.com/rust-lang/rust/pull/138458">PR #138458</a>, that raise questions about the desirability of using the value namespace in this way for patterns, as described in <a href="https://github.com/rust-lang/rust/pull/140593#issuecomment-2972338457">PR #140593</a>. It might be prudent to not intentionally rely on this nuance in your code.</p>
</blockquote>
<p>r[patterns.tuple]</p>
<h2 id="튜플-패턴"><a class="header" href="#튜플-패턴">튜플 패턴</a></h2>
<p>r[patterns.tuple.syntax]</p>
<pre><code class="language-grammar patterns">TuplePattern -&gt; `(` TuplePatternItems? `)`

TuplePatternItems -&gt;
      Pattern `,`
    | RestPattern
    | Pattern (`,` Pattern)+ `,`?
</code></pre>
<p>r[patterns.tuple.intro] Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to <a href="#destructuring">destructure</a> a tuple.</p>
<p>r[patterns.tuple.rest-syntax] The form <code>(..)</code> with a single [RestPattern] is a special form that does not require a comma, and matches a tuple of any size.</p>
<p>r[patterns.tuple.refutable] The tuple pattern is refutable when one of its subpatterns is refutable.</p>
<p>튜플 패턴 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, "ten");
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, "ten");
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.paren]</p>
<h2 id="그룹화된-패턴"><a class="header" href="#그룹화된-패턴">그룹화된 패턴</a></h2>
<p>r[patterns.paren.syntax]</p>
<pre><code class="language-grammar patterns">GroupedPattern -&gt; `(` Pattern `)`
</code></pre>
<p>r[patterns.paren.intro] Enclosing a pattern in parentheses can be used to explicitly control the precedence of compound patterns. For example, a reference pattern next to a range pattern such as <code>&amp;0..=5</code> is ambiguous and is not allowed, but can be expressed with parentheses.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.slice]</p>
<h2 id="슬라이스-패턴"><a class="header" href="#슬라이스-패턴">슬라이스 패턴</a></h2>
<p>r[patterns.slice.syntax]</p>
<pre><code class="language-grammar patterns">SlicePattern -&gt; `[` SlicePatternItems? `]`

SlicePatternItems -&gt; Pattern (`,` Pattern)* `,`?
</code></pre>
<p>r[patterns.slice.intro] Slice patterns can match both arrays of fixed size and slices of dynamic size.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 고정 크기
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; "1로 시작함",
    [a, b, c] =&gt; "다른 것으로 시작함",
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 동적 크기
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 이 암(arm)은 길이가 일치하지 않으므로 적용되지 않습니다 */ }
    [a, b, c] =&gt; { /* 이 암(arm)이 적용됩니다 */ }
    _ =&gt; { /* 길이를 정적으로 알 수 없으므로 이 와일드카드가 필요합니다 */ }
};
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.slice.refutable-array] Slice patterns are irrefutable when matching an array as long as each element is irrefutable.</p>
<p>r[patterns.slice.refutable-slice] When matching a slice, it is irrefutable only in the form with a single <code>..</code> [rest pattern][patterns.rest] or <a href="#identifier-patterns">identifier pattern</a> with the <code>..</code> rest pattern as a subpattern.</p>
<p>r[patterns.slice.restriction] Within a slice, a range pattern without both lower and upper bound must be enclosed in parentheses, as in <code>(a..)</code>, to clarify it is intended to match against a single slice element. A range pattern with both lower and upper bound, like <code>a..=b</code>, is not required to be enclosed in parentheses.</p>
<p>r[patterns.path]</p>
<h2 id="경로-패턴"><a class="header" href="#경로-패턴">경로 패턴</a></h2>
<p>r[patterns.path.syntax]</p>
<pre><code class="language-grammar patterns">PathPattern -&gt; PathExpression
</code></pre>
<p>r[patterns.path.intro] <em>Path patterns</em> are patterns that refer either to constant values or to structs or enum variants that have no fields.</p>
<p>r[patterns.path.unqualified] Unqualified path patterns can refer to:</p>
<ul>
<li>열거형 변형</li>
<li>구조체</li>
<li>상수</li>
<li>연관 상수</li>
</ul>
<p>r[patterns.path.qualified] Qualified path patterns can only refer to associated constants.</p>
<p>r[patterns.path.refutable] Path patterns are irrefutable when they refer to structs or an enum variant when the enum has only one variant or a constant whose type is irrefutable. They are refutable when they refer to refutable constants or enum variants for enums with multiple variants.</p>
<p>r[patterns.const]</p>
<h3 id="상수-패턴"><a class="header" href="#상수-패턴">상수 패턴</a></h3>
<p>r[patterns.const.partial-eq] When a constant <code>C</code> of type <code>T</code> is used as a pattern, we first check that <code>T: PartialEq</code>.</p>
<p>r[patterns.const.structural-equality] Furthermore we require that the value of <code>C</code> <em>has (recursive) structural equality</em>, which is defined recursively as follows:</p>
<p>r[patterns.const.primitive]</p>
<ul>
<li>정수뿐만 아니라 <code>str</code>, <code>bool</code>, <code>char</code> 값은 항상 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.builtin-aggregate]</p>
<ul>
<li>튜플, 배열, 슬라이스는 모든 필드/요소가 구조적 동등성을 가지면 구조적 동등성을 갖습니다. (특히, <code>()</code>와 <code>[]</code>는 항상 구조적 동등성을 갖습니다.)</li>
</ul>
<p>r[patterns.const.ref]</p>
<ul>
<li>참조는 가리키는 값이 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.aggregate]</p>
<ul>
<li><code>struct</code> 또는 <code>enum</code> 타입의 값은 <code>PartialEq</code> 인스턴스가 <code>#[derive(PartialEq)]</code>를 통해 파생되었고, 모든 필드(열거형의 경우 현재 활성화된 변형의 필드)가 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.pointer]</p>
<ul>
<li>원시 포인터는 상수 정수로 정의된 경우(그 후 캐스팅되거나 transmute된 경우) 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.float]</p>
<ul>
<li>부동 소수점 값은 <code>NaN</code>이 아니면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.exhaustive]</p>
<ul>
<li>그 외에는 구조적 동등성을 갖지 않습니다.</li>
</ul>
<p>r[patterns.const.generic] In particular, the value of <code>C</code> must be known at pattern-building time (which is pre-monomorphization). This means that associated consts that involve generic parameters cannot be used as patterns.</p>
<p>r[patterns.const.immutable] The value of <code>C</code> must not contain any references to mutable statics (<code>static mut</code> items or interior mutable <code>static</code> items) or <code>extern</code> statics.</p>
<p>r[patterns.const.translation] After ensuring all conditions are met, the constant value is translated into a pattern, and now behaves exactly as-if that pattern had been written directly. In particular, it fully participates in exhaustiveness checking. (For raw pointers, constants are the only way to write such patterns. Only <code>_</code> is ever considered exhaustive for these types.)</p>
<p>r[patterns.or]</p>
<h2 id="or-패턴"><a class="header" href="#or-패턴">Or 패턴</a></h2>
<p><em>Or-patterns</em> are patterns that match on one of two or more sub-patterns (for example <code>A | B | C</code>). They can nest arbitrarily. Syntactically, or-patterns are allowed in any of the places where other patterns are allowed (represented by the [Pattern] production), with the exceptions of <code>let</code>-bindings and function and closure parameters (represented by the [PatternNoTopAlt] production).</p>
<p>r[patterns.constraints]</p>
<h3 id="정적-시맨틱"><a class="header" href="#정적-시맨틱">정적 시맨틱</a></h3>
<p>r[patterns.constraints.pattern]</p>
<ol>
<li>
<p>임의의 패턴 <code>p</code>와 <code>q</code>에 대해 어떤 깊이에서든 <code>p | q</code> 패턴이 주어졌을 때, 다음의 경우 해당 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다:</p>
<ul>
<li><code>p</code>에 대해 추론된 타입이 <code>q</code>에 대해 추론된 타입과 통합(unify)되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에서 동일한 바인딩 집합이 도입되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에 있는 동일한 이름의 두 바인딩 타입이 타입 또는 바인딩 모드 관점에서 통합되지 않는 경우.
타입 통합은 모든 인스턴스에서 앞서 언급한 대로 정확해야 하며, 암시적인 <a href="type-coercions.html">타입 강제 변환</a>은 적용되지 않습니다.</li>
</ul>
</li>
</ol>
<p>r[patterns.constraints.match-type-check] 2. When type checking an expression <code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code>, for each match arm <code>a_i</code> which contains a pattern of form <code>p_i | q_i</code>, the pattern <code>p_i | q_i</code> is considered ill formed if, at the depth <code>d</code> where it exists the fragment of <code>e_s</code> at depth <code>d</code>, the type of the expression fragment does not unify with <code>p_i | q_i</code>.</p>
<p>r[patterns.constraints.exhaustiveness-or-pattern] 3. With respect to exhaustiveness checking, a pattern <code>p | q</code> is considered to cover <code>p</code> as well as <code>q</code>. For some constructor <code>c(x, ..)</code> the distributive law applies such that <code>c(p | q, ..rest)</code> covers the same set of value as <code>c(p, ..rest) | c(q, ..rest)</code> does. This can be applied recursively until there are no more nested patterns of form <code>p | q</code> other than those that exist at the top level.</p>
<p>여기서 _“생성자”_는 튜플 구조체 패턴만을 가리키는 것이 아니라, 모든 곱 타입(product type)에 대한 패턴을 의미합니다. 여기에는 열거형 변형, 튜플 구조체, 이름 있는 필드가 있는 구조체, 배열, 튜플, 슬라이스가 포함됩니다.</p>
<p>r[patterns.behavior]</p>
<h3 id="동적-시맨틱"><a class="header" href="#동적-시맨틱">동적 시맨틱</a></h3>
<p>r[patterns.behavior.nested-or-patterns]</p>
<ol>
<li>조사 대상 표현식 <code>e_s</code>를 깊이 <code>d</code>에서 <code>c(p | q, ..rest)</code> 패턴(여기서 <code>c</code>는 어떤 생성자, <code>p</code>와 <code>q</code>는 임의의 패턴, <code>rest</code>는 <code>c</code>의 나머지 선택적 요소)과 매치하는 동적 시맨틱은 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 것으로 정의됩니다.</li>
</ol>
<p>r[patterns.precedence]</p>
<h3 id="구분-기호가-없는-다른-패턴과의-우선순위"><a class="header" href="#구분-기호가-없는-다른-패턴과의-우선순위">구분 기호가 없는 다른 패턴과의 우선순위</a></h3>
<p>이 장의 다른 곳에서 보여준 것처럼, 식별자 패턴, 참조 패턴, Or 패턴을 포함하여 구문상으로 구분 기호가 없는(undelimited) 여러 유형의 패턴이 있습니다. Or 패턴은 항상 가장 낮은 우선순위를 갖습니다. 이를 통해 향후 타입 어스크립션(type ascription) 기능을 위한 구문적 공간을 확보하고 모호성을 줄일 수 있습니다. 예를 들어, <code>x @ A(..) | B(..)</code>는 <code>x</code>가 모든 패턴에 바인딩되지 않았다는 오류를 발생시킵니다. <code>&amp;A(x) | B(x)</code>는 서로 다른 서브패턴에 있는 <code>x</code> 사이의 타입 불일치를 발생시킵니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="expressions/underscore-expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="type-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="expressions/underscore-expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="type-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
