<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>매크로 Follow-Set 모호성 공식 명세 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/macro-ambiguity.md`;
                    } else {
                        canonical_href = `${base}/${lang}/macro-ambiguity.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/macro-ambiguity.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-macro.ambiguity"><a class="rule-link" href="#r-macro.ambiguity" title="macro.ambiguity"><span>[macro<wbr>.ambiguity]<span/></a></div>
<h1 id="부록-매크로-follow-set-모호성-공식-명세"><a class="header" href="#부록-매크로-follow-set-모호성-공식-명세">부록: 매크로 Follow-Set 모호성 공식 명세</a></h1>
<p>이 페이지는 <a href="macros-by-example.html">예제를 통한 매크로</a>를 위한 follow 규칙의 공식 명세를 문서화합니다. 이 규칙들은 원래 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a>에서 명시되었으며, 이 텍스트의 대부분은 해당 RFC에서 복사되고 이후의 RFC들에서 확장된 것입니다.</p>
<div class="rule" id="r-macro.ambiguity.convention"><a class="rule-link" href="#r-macro.ambiguity.convention" title="macro.ambiguity.convention"><span>[macro<wbr>.ambiguity<wbr>.convention]<span/></a></div>
<h2 id="정의-및-규약"><a class="header" href="#정의-및-규약">정의 및 규약</a></h2>
<div class="rule" id="r-macro.ambiguity.convention.defs"><a class="rule-link" href="#r-macro.ambiguity.convention.defs" title="macro.ambiguity.convention.defs"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.defs]<span/></a></div>
<ul>
<li><code>macro</code>: 소스 코드에서 <code>foo!(...)</code>와 같이 호출 가능한 모든 것.</li>
<li><code>MBE</code>: 예제를 통한 매크로(macro-by-example), <code>macro_rules</code>에 의해 정의된 매크로.</li>
<li><code>matcher</code>: <code>macro_rules</code> 호출 내 규칙의 왼쪽 부분(LHS), 또는 그 일부분.</li>
<li><code>macro parser</code>: 모든 매처(matchers)로부터 파생된 문법을 사용하여 입력을 파싱하는 러스트 파서 내의 코드 조각.</li>
<li><code>fragment</code>: 주어진 매처가 수용할(또는 “일치시킬”) 러스트 구문 클래스.</li>
<li><code>repetition</code>: 규칙적인 반복 패턴을 따르는 프래그먼트.</li>
<li><code>NT</code>: 비단말(non-terminal), 매처에 나타날 수 있는 다양한 “메타 변수” 또는 반복 매처. MBE 구문에서 시작 부분의 <code>$</code> 문자로 지정됩니다.</li>
<li><code>simple NT</code>: “메타 변수” 비단말 (아래에서 더 자세히 논의됨).</li>
<li><code>complex NT</code>: 반복 연산자(<code>*</code>, <code>+</code>, <code>?</code>)를 통해 지정된, 반복 일치 비단말.</li>
<li><code>token</code>: 매처의 원자적 요소. 즉, 식별자, 연산자, 여는/닫는 구분자, <em>그리고</em> 단순 NT(simple NT).</li>
<li><code>token tree</code>: 토큰(리프), 복합 NT(complex NT), 그리고 토큰 트리의 유한 시퀀스로 형성된 트리 구조.</li>
<li><code>delimiter token</code>: 한 프래그먼트의 끝과 다음 프래그먼트의 시작을 나누기 위한 토큰.</li>
<li><code>separator token</code>: 복합 NT에서 일치된 반복의 각 요소 쌍을 구분하는 선택적인 구분자 토큰.</li>
<li><code>separated complex NT</code>: 자체 구분자 토큰을 가진 복합 NT.</li>
<li><code>delimited sequence</code>: 시퀀스의 시작과 끝에 적절한 여는 구분자와 닫는 구분자가 있는 토큰 트리 시퀀스.</li>
<li><code>empty fragment</code>: 토큰을 구분하는 보이지 않는 러스트 구문 클래스. 즉, 공백(whitespace) 또는 (일부 어휘 문맥에서) 빈 토큰 시퀀스.</li>
<li><code>fragment specifier</code>: 단순 NT(simple NT)에서 해당 NT가 수용하는 프래그먼트를 지정하는 식별자.</li>
<li><code>language</code>: 문맥 자유 언어(context-free language).</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.ambiguity.convention.matcher"><a class="rule-link" href="#r-macro.ambiguity.convention.matcher" title="macro.ambiguity.convention.matcher"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.matcher]<span/></a></div>
<p><code>(start $foo:expr $($i:ident),* end)</code>는 매처(matcher)입니다. 전체 매처는 구분된 시퀀스(여는 구분자 <code>(</code>와 닫는 구분자 <code>)</code>가 있는)이며, <code>$foo</code>와 <code>$i</code>는 각각 <code>expr</code>과 <code>ident</code>를 프래그먼트 지정자로 가진 단순 NT입니다.</p>
<div class="rule" id="r-macro.ambiguity.convention.complex-nt"><a class="rule-link" href="#r-macro.ambiguity.convention.complex-nt" title="macro.ambiguity.convention.complex-nt"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.complex-nt]<span/></a></div>
<p><code>$(i:ident),*</code> 또한 하나의 NT입니다. 이는 쉼표로 구분된 식별자들의 반복과 일치하는 복합 NT(complex NT)입니다. <code>,</code>는 이 복합 NT의 구분자 토큰(separator token)입니다. 이는 일치된 프래그먼트의 각 요소 쌍(있는 경우) 사이에 나타납니다.</p>
<p>형태의 프래그먼트 중 <code>hi &lt;expr&gt;;</code>가 최소 한 번 이상 나타나는 것과 일치합니다. 이 복합 NT는 전용 구분자 토큰을 가지고 있지 않음에 유의하십시오.</p>
<p>(러스트의 파서는 구분된 시퀀스가 항상 토큰 트리 구조의 적절한 중첩과 여는/닫는 구분자의 올바른 일치와 함께 발생하도록 보장함에 유의하십시오.)</p>
<div class="rule" id="r-macro.ambiguity.convention.vars"><a class="rule-link" href="#r-macro.ambiguity.convention.vars" title="macro.ambiguity.convention.vars"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.vars]<span/></a></div>
<p>우리는 매처를 나타내기 위해 변수 “M“을, 임의의 개별 토큰을 위해 변수 “t“와 “u“를, 임의의 토큰 트리를 위해 변수 “tt“와 “uu“를 사용하는 경향이 있습니다. (“tt“의 사용은 프래그먼트 지정자로서의 추가적인 역할 때문에 잠재적인 모호성을 제시하지만, 문맥상 어떤 해석을 의미하는지 명확할 것입니다.)</p>
<div class="rule" id="r-macro.ambiguity.convention.set"><a class="rule-link" href="#r-macro.ambiguity.convention.set" title="macro.ambiguity.convention.set"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.set]<span/></a></div>
<p>“SEP“는 구분자 토큰을, “OP“는 반복 연산자 <code>*</code>, <code>+</code>, <code>?</code>를, “OPEN”/“CLOSE“는 구분된 시퀀스를 둘러싼 일치하는 토큰 쌍(예: <code>[</code> 및 <code>]</code>)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.convention.sequence-vars"><a class="rule-link" href="#r-macro.ambiguity.convention.sequence-vars" title="macro.ambiguity.convention.sequence-vars"><span>[macro<wbr>.ambiguity<wbr>.convention<wbr>.sequence-vars]<span/></a></div>
<p>그리스 문자 “α”, “β”, “γ”, “δ“는 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스를 나타냅니다. (단, 그리스 문자 “ε”(입실론)은 이 설명에서 특별한 역할을 수행하며 토큰 트리 시퀀스를 나타내지 않습니다.)</p>
<ul>
<li>이 그리스 문자 관례는 대개 시퀀스의 존재가 기술적인 세부 사항일 때만 채택됩니다. 특히, 우리가 토큰 트리 시퀀스에 대해 작업하고 있음을 _강조_하고자 할 때는 그리스 문자가 아닌 “tt …“라는 표기법을 사용합니다.</li>
</ul>
<p>매처는 단지 하나의 토큰 트리라는 점에 유의하십시오. 위에서 언급했듯이 “단순 NT“는 메타 변수 NT이며, 따라서 반복이 아닙니다. 예를 들어 <code>$foo:ty</code>는 단순 NT이지만 <code>$($foo:ty)+</code>는 복합 NT입니다.</p>
<p>또한 이 형식화된 체계(formalism)의 문맥에서 “토큰“이라는 용어는 일반적으로 단순 NT를 _포함_함에 유의하십시오.</p>
<p>마지막으로, 독자 여러분은 이 형식화된 체계의 정의에 따라 어떤 단순 NT도 빈 프래그먼트와 일치하지 않으며, 마찬가지로 어떤 토큰도 러스트 구문의 빈 프래그먼트와 일치하지 않는다는 점을 기억하는 것이 유용합니다. (따라서 빈 프래그먼트와 일치할 수 있는 <em>유일한</em> NT는 복합 NT뿐입니다.) 이는 실제로 사실이 아닌데, 왜냐하면 <code>vis</code> 매처는 빈 프래그먼트와 일치할 수 있기 때문입니다. 따라서 이 체계의 목적을 위해 우리는 <code>$v:vis</code>를 실제로는 <code>$($v:vis)?</code>인 것처럼 취급할 것이며, 매처가 빈 프래그먼트와 일치해야 한다는 요구 사항을 둘 것입니다.</p>
<div class="rule" id="r-macro.ambiguity.invariant"><a class="rule-link" href="#r-macro.ambiguity.invariant" title="macro.ambiguity.invariant"><span>[macro<wbr>.ambiguity<wbr>.invariant]<span/></a></div>
<h3 id="매처-불변성-the-matcher-invariants"><a class="header" href="#매처-불변성-the-matcher-invariants">매처 불변성 (The Matcher Invariants)</a></h3>
<div class="rule" id="r-macro.ambiguity.invariant.list"><a class="rule-link" href="#r-macro.ambiguity.invariant.list" title="macro.ambiguity.invariant.list"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.list]<span/></a></div>
<p>유효한 매처가 되려면 다음 세 가지 불변성을 충족해야 합니다. FIRST 및 FOLLOW의 정의는 나중에 설명됩니다.</p>
<ol>
<li>매처 <code>M</code> 내의 임의의 두 연속된 토큰 트리 시퀀스(<code>M = ... tt uu ...</code>)에 대해 <code>uu ...</code>가 비어 있지 않다면, FOLLOW(<code>... tt</code>) ∪ {ε} ⊇ FIRST(<code>uu ...</code>)를 만족해야 합니다.</li>
<li>매처 내의 임의의 구분된 복합 NT <code>M = ... $(tt ...) SEP OP ...</code>에 대해, <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>)여야 합니다.</li>
<li>매처 내의 구분되지 않은 복합 NT <code>M = ... $(tt ...) OP ...</code>에 대해, OP = <code>*</code> 또는 <code>+</code>인 경우, FOLLOW(<code>tt ...</code>) ⊇ FIRST(<code>tt ...</code>)여야 합니다.</li>
</ol>
<div class="rule" id="r-macro.ambiguity.invariant.follow-matcher"><a class="rule-link" href="#r-macro.ambiguity.invariant.follow-matcher" title="macro.ambiguity.invariant.follow-matcher"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.follow-matcher]<span/></a></div>
<p>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set.  This ensures that a legal macro definition will continue to assign the same determination as to where <code>... tt</code> ends and <code>uu ...</code> begins, even as new syntactic forms are added to the language.</p>
<div class="rule" id="r-macro.ambiguity.invariant.separated-complex-nt"><a class="rule-link" href="#r-macro.ambiguity.invariant.separated-complex-nt" title="macro.ambiguity.invariant.separated-complex-nt"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.separated-complex-nt]<span/></a></div>
<p>두 번째 불변성은 구분된 복합 NT가 해당 NT 내부 콘텐츠에 대해 미리 결정된 follow 집합의 일부인 구분자 토큰을 사용해야 함을 의미합니다. 이는 새로운 구문 형태가 언어에 추가되더라도, 적법한 매크로 정의가 입력 프래그먼트를 동일한 <code>tt ...</code>들의 구분된 시퀀스로 계속 파싱하도록 보장합니다.</p>
<div class="rule" id="r-macro.ambiguity.invariant.unseparated-complex-nt"><a class="rule-link" href="#r-macro.ambiguity.invariant.unseparated-complex-nt" title="macro.ambiguity.invariant.unseparated-complex-nt"><span>[macro<wbr>.ambiguity<wbr>.invariant<wbr>.unseparated-complex-nt]<span/></a></div>
<p>세 번째 불변성은 사이에 구분이 없이 동일한 것의 두 개 이상의 사본과 일치할 수 있는 복합 NT가 있을 때, 첫 번째 불변성에 따라 이들이 서로 옆에 놓이는 것이 허용되어야 함을 의미합니다. 이 불변성은 또한 이들이 비어 있지 않을 것을 요구하며, 이는 발생 가능한 모호성을 제거합니다.</p>
<p><strong>참고: 세 번째 불변성은 과거의 실수와 해당 동작에 대한 상당한 의존성 때문에 현재 강제되지 않고 있습니다. 앞으로 이에 대해 어떻게 할지는 현재 결정되지 않았습니다. 이 동작을 준수하지 않는 매크로는 미래의 러스트 에디션에서 유효하지 않게 될 수 있습니다. <a href="https://github.com/rust-lang/rust/issues/56575">트래킹 이슈</a>를 참조하십시오.</strong></p>
<div class="rule" id="r-macro.ambiguity.sets"><a class="rule-link" href="#r-macro.ambiguity.sets" title="macro.ambiguity.sets"><span>[macro<wbr>.ambiguity<wbr>.sets]<span/></a></div>
<h3 id="비공식적인-first-및-follow"><a class="header" href="#비공식적인-first-및-follow">비공식적인 FIRST 및 FOLLOW</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.intro"><a class="rule-link" href="#r-macro.ambiguity.sets.intro" title="macro.ambiguity.sets.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.intro]<span/></a></div>
<p>주어진 매처 M은 세 가지 집합 FIRST(M), LAST(M), FOLLOW(M)에 매핑됩니다.</p>
<p>이 세 가지 집합은 각각 토큰들로 구성됩니다. FIRST(M)과 LAST(M)은 또한 M이 빈 프래그먼트와 일치할 수 있음을 나타내는 구별된 비토큰 요소 ε(“입실론”)을 포함할 수 있습니다. (단, FOLLOW(M)은 항상 토큰들의 집합입니다.)</p>
<p>비공식적으로는 다음과 같습니다:</p>
<div class="rule" id="r-macro.ambiguity.sets.first"><a class="rule-link" href="#r-macro.ambiguity.sets.first" title="macro.ambiguity.sets.first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.first]<span/></a></div>
<ul>
<li>FIRST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 먼저 사용되는 토큰들을 수집합니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.last"><a class="rule-link" href="#r-macro.ambiguity.sets.last" title="macro.ambiguity.sets.last"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.last]<span/></a></div>
<ul>
<li>LAST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 마지막에 사용되는 토큰들을 수집합니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.follow"><a class="rule-link" href="#r-macro.ambiguity.sets.follow" title="macro.ambiguity.sets.follow"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.follow]<span/></a></div>
<ul>
<li>
<p>FOLLOW(M): M과 일치하는 어떤 프래그먼트 직후에 올 수 있도록 허용된 토큰들의 집합입니다.</p>
<p>다시 말해, t ∈ FOLLOW(M)일 필요충분조건은 다음을 만족하는 (잠재적으로 비어 있을 수 있는) 토큰 시퀀스 α, β, γ, δ가 존재하는 것입니다.</p>
<ul>
<li>
<p>M이 β와 일치하고,</p>
</li>
<li>
<p>t가 γ와 일치하며,</p>
</li>
<li>
<p>α β γ δ를 연결한 결과가 파싱 가능한 러스트 프로그램인 경우.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.universe"><a class="rule-link" href="#r-macro.ambiguity.sets.universe" title="macro.ambiguity.sets.universe"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.universe]<span/></a></div>
<p>우리는 모든 토큰(단순 NT 포함)의 집합을 나타내기 위해 ANYTOKEN이라는 약어를 사용합니다. 예를 들어, 매처 M 뒤에 어떤 토큰이 와도 적법하다면, FOLLOW(M) = ANYTOKEN입니다.</p>
<p>(위의 비공식적인 설명에 대한 이해를 점검하기 위해, 독자 여러분은 공식 정의를 읽기 전에 <a href="#examples-of-first-and-last">FIRST/LAST의 예시</a>로 건너뛰어 확인해 볼 수 있습니다.)</p>
<div class="rule" id="r-macro.ambiguity.sets.def"><a class="rule-link" href="#r-macro.ambiguity.sets.def" title="macro.ambiguity.sets.def"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def]<span/></a></div>
<h3 id="first-last"><a class="header" href="#first-last">FIRST, LAST</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.def.intro"><a class="rule-link" href="#r-macro.ambiguity.sets.def.intro" title="macro.ambiguity.sets.def.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.intro]<span/></a></div>
<p>다음은 FIRST와 LAST에 대한 공식적인 귀납적 정의입니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.notation"><a class="rule-link" href="#r-macro.ambiguity.sets.def.notation" title="macro.ambiguity.sets.def.notation"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.notation]<span/></a></div>
<p>“A ∪ B“는 합집합을, “A ∩ B“는 교집합을, “A \ B“는 차집합(즉, A에는 존재하지만 B에는 존재하지 않는 모든 요소)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.first"><a class="rule-link" href="#r-macro.ambiguity.sets.def.first" title="macro.ambiguity.sets.def.first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first]<span/></a></div>
<h4 id="first"><a class="header" href="#first">FIRST</a></h4>
<div class="rule" id="r-macro.ambiguity.sets.def.first.intro"><a class="rule-link" href="#r-macro.ambiguity.sets.def.first.intro" title="macro.ambiguity.sets.def.first.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.intro]<span/></a></div>
<p>FIRST(M)은 시퀀스 M과 그 첫 번째 토큰 트리(있는 경우)의 구조에 따른 케이스 분석을 통해 정의됩니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.first.epsilon"><a class="rule-link" href="#r-macro.ambiguity.sets.def.first.epsilon" title="macro.ambiguity.sets.def.first.epsilon"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.epsilon]<span/></a></div>
<ul>
<li>M이 빈 시퀀스라면, FIRST(M) = { ε }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.first.token"><a class="rule-link" href="#r-macro.ambiguity.sets.def.first.token" title="macro.ambiguity.sets.def.first.token"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.token]<span/></a></div>
<ul>
<li>
<p>M이 토큰 t로 시작한다면, FIRST(M) = { t }입니다.</p>
<p>(참고: 이는 M이 구분된 토큰 트리 시퀀스로 시작하는 경우 <code>M = OPEN tt ... CLOSE ...</code>를 포함하며, 이 경우 <code>t = OPEN</code>이므로 FIRST(M) = { <code>OPEN</code> }이 됩니다.)</p>
<p>(참고: 이는 어떤 단순 NT도 빈 프래그먼트와 일치하지 않는다는 속성에 결정적으로 의존합니다.)</p>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.first.complex"><a class="rule-link" href="#r-macro.ambiguity.sets.def.first.complex" title="macro.ambiguity.sets.def.first.complex"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.first<wbr>.complex]<span/></a></div>
<ul>
<li>
<p>그 외의 경우, M은 복합 NT로 시작하는 토큰 트리 시퀀스입니다: <code>M = $( tt ... ) OP α</code>, 또는 <code>M = $( tt ... ) SEP OP α</code> (여기서 <code>α</code>는 매처의 나머지 부분인, 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스입니다).</p>
<ul>
<li>SEP가 존재하고 ε ∈ FIRST(<code>tt ...</code>)라면 SEP_SET(M) = { SEP }이고, 그렇지 않으면 SEP_SET(M) = {}라고 합시다.</li>
</ul>
</li>
<li>
<p>OP가 <code>*</code> 또는 <code>?</code>라면 ALPHA_SET(M) = FIRST(<code>α</code>)이고, OP가 <code>+</code>라면 ALPHA_SET(M) = {}라고 합시다.</p>
</li>
<li>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M)입니다.</p>
</li>
</ul>
<p>복합 NT에 대한 정의는 정당화될 필요가 있습니다. SEP_SET(M)은 구분자가 정의되어 있고 반복되는 프래그먼트가 비어 있을 수 있는 경우, 구분자가 M의 유효한 첫 번째 토큰이 될 수 있는 가능성을 정의합니다. ALPHA_SET(M)은 복합 NT가 비어 있을 수 있는 가능성을 정의하며, 이는 M의 유효한 첫 번째 토큰들이 뒤따르는 토큰 트리 시퀀스 <code>α</code>의 토큰들임을 의미합니다. 이는 <code>*</code> 또는 <code>?</code>가 사용되어 반복 횟수가 0일 수 있는 경우에 발생합니다. 이론적으로는 잠재적으로 비어 있을 수 있는 반복 프래그먼트와 함께 <code>+</code>가 사용된 경우에도 발생할 수 있으나, 이는 세 번째 불변성에 의해 금지됩니다.</p>
<p>그 지점으로부터, FIRST(M)은 SEP_SET(M) 또는 ALPHA_SET(M)의 모든 토큰을 포함할 수 있으며, 복합 NT 일치가 비어 있지 않다면 FIRST(<code>tt ...</code>)로 시작하는 모든 토큰 또한 가능합니다. 마지막으로 고려할 부분은 ε입니다. SEP_SET(M)과 FIRST(<code>tt ...</code>) \ {ε}은 ε을 포함할 수 없지만, ALPHA_SET(M)은 포함할 수 있습니다. 따라서 이 정의는 ε ∈ ALPHA_SET(M)인 경우에만 M이 ε을 수용하도록 허용합니다. 이는 복합 NT 사례에서 M이 ε을 수용하려면 복합 NT와 α가 모두 이를 수용해야 하기 때문에 정확합니다. 만약 OP = <code>+</code>라면, 복합 NT가 비어 있을 수 없음을 의미하므로 정의에 따라 ε ∉ ALPHA_SET(M)입니다. 그 외의 경우 복합 NT는 0번의 반복을 수용할 수 있으며, 이때 ALPHA_SET(M) = FOLLOW(<code>α</code>)가 됩니다. 따라서 이 정의는 ε에 대해서도 정확합니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.last"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last" title="macro.ambiguity.sets.def.last"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last]<span/></a></div>
<h4 id="last"><a class="header" href="#last">LAST</a></h4>
<div class="rule" id="r-macro.ambiguity.sets.def.last.intro"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.intro" title="macro.ambiguity.sets.def.last.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.intro]<span/></a></div>
<p>LAST(M)은 M 자체(토큰 트리 시퀀스)에 대한 케이스 분석을 통해 정의됩니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.last.empty"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.empty" title="macro.ambiguity.sets.def.last.empty"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.empty]<span/></a></div>
<ul>
<li>M이 빈 시퀀스라면, LAST(M) = { ε }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.token"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.token" title="macro.ambiguity.sets.def.last.token"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.token]<span/></a></div>
<ul>
<li>M이 단일 토큰 t라면, LAST(M) = { t }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-star"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.rep-star" title="macro.ambiguity.sets.def.last.rep-star"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-star]<span/></a></div>
<ul>
<li>
<p>M이 0번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) *</code> 또는 <code>M = $( tt ... ) SEP *</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-plus"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.rep-plus" title="macro.ambiguity.sets.def.last.rep-plus"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-plus]<span/></a></div>
<ul>
<li>
<p>M이 1번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) +</code> 또는 <code>M = $( tt ... ) SEP +</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.rep-question"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.rep-question" title="macro.ambiguity.sets.def.last.rep-question"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.rep-question]<span/></a></div>
<ul>
<li>M이 0번 또는 1번 반복되는 단일 복합 NT인 경우(<code>M = $( tt ...) ?</code>), LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.delim"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.delim" title="macro.ambiguity.sets.def.last.delim"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.delim]<span/></a></div>
<ul>
<li>M이 구분된 토큰 트리 시퀀스 <code>OPEN tt ... CLOSE</code>인 경우, LAST(M) = { <code>CLOSE</code> }입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.last.sequence"><a class="rule-link" href="#r-macro.ambiguity.sets.def.last.sequence" title="macro.ambiguity.sets.def.last.sequence"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.last<wbr>.sequence]<span/></a></div>
<ul>
<li>
<p>M이 비어 있지 않은 토큰 트리 시퀀스 <code>tt uu ...</code>인 경우,</p>
<ul>
<li>
<p>ε ∈ LAST(<code>uu ...</code>)라면, LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε })입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>uu ...</code>는 반드시 비어 있지 않아야 하며, LAST(M) = LAST(<code>uu ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="first-및-last의-예시"><a class="header" href="#first-및-last의-예시">FIRST 및 LAST의 예시</a></h3>
<p>다음은 FIRST와 LAST의 몇 가지 예시입니다. (특히 입력 조각들 사이의 상호 작용에 따라 특별한 ε 요소가 어떻게 도입되고 제거되는지 유의하십시오.)</p>
<p>첫 번째 예시는 매처 분석이 어떻게 구성되는지 상세히 설명하기 위해 트리 구조로 제시됩니다. (일부 단순한 서브트리들은 생략되었습니다.)</p>
<pre><code class="language-text">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                        |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                        |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>따라서:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>하지만 다음 사항에 유의하십시오:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>다음은 LAST에 대한 유사한 예시들입니다.</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow" title="macro.ambiguity.sets.def.follow"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow]<span/></a></div>
<h3 id="followm"><a class="header" href="#followm">FOLLOW(M)</a></h3>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.intro"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.intro" title="macro.ambiguity.sets.def.follow.intro"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.intro]<span/></a></div>
<p>마지막으로, FOLLOW(M)의 정의는 다음과 같이 구성됩니다. pat, expr 등은 주어진 프래그먼트 지정자를 가진 단순 비단말(nonterminals)을 나타냅니다.</p>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.pat"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.pat" title="macro.ambiguity.sets.def.follow.pat"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.pat]<span/></a></div>
<ul>
<li>FOLLOW(pat) = {<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code>}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.expr-stmt"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.expr-stmt" title="macro.ambiguity.sets.def.follow.expr-stmt"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.expr-stmt]<span/></a></div>
<ul>
<li>FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {<code>=&gt;</code>, <code>,</code>, <code>;</code>}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.ty-path"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.ty-path" title="macro.ambiguity.sets.def.follow.ty-path"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.ty-path]<span/></a></div>
<ul>
<li>FOLLOW(ty) = FOLLOW(path) = {<code>{</code>, <code>[</code>, <code>,</code>, <code>=&gt;</code>, <code>:</code>, <code>=</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>;</code>, <code>|</code>, <code>as</code>, <code>where</code>, block 비단말}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.vis"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.vis" title="macro.ambiguity.sets.def.follow.vis"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.vis]<span/></a></div>
<ul>
<li>FOLLOW(vis) = {<code>,</code>l 원시(raw)가 아닌 <code>priv</code>를 제외한 모든 키워드 또는 식별자; 타입을 시작할 수 있는 모든 토큰; ident, ty, 그리고 path 비단말}입니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.simple"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.simple" title="macro.ambiguity.sets.def.follow.simple"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.simple]<span/></a></div>
<ul>
<li>FOLLOW(t) = ANYTOKEN (block, ident, tt, item, lifetime, literal, meta 단순 비단말 및 모든 단말(terminals)을 포함한 다른 모든 단순 토큰의 경우).</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.other-matcher"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.other-matcher" title="macro.ambiguity.sets.def.follow.other-matcher"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.other-matcher]<span/></a></div>
<ul>
<li>다른 모든 M에 대해 FOLLOW(M)은, t가 (LAST(M) \ {ε})의 범위에 있을 때 FOLLOW(t)의 교집합으로 정의됩니다.</li>
</ul>
<div class="rule" id="r-macro.ambiguity.sets.def.follow.type-first"><a class="rule-link" href="#r-macro.ambiguity.sets.def.follow.type-first" title="macro.ambiguity.sets.def.follow.type-first"><span>[macro<wbr>.ambiguity<wbr>.sets<wbr>.def<wbr>.follow<wbr>.type-first]<span/></a></div>
<p>타입을 시작할 수 있는 토큰은 이 글을 쓰는 시점을 기준으로 {<code>(</code>, <code>[</code>, <code>!</code>, <code>*</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>?</code>, 라이프타임, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>::</code>, 키워드가 아닌 모든 식별자, <code>super</code>, <code>self</code>, <code>Self</code>, <code>extern</code>, <code>crate</code>, <code>$crate</code>, <code>_</code>, <code>for</code>, <code>impl</code>, <code>fn</code>, <code>unsafe</code>, <code>typeof</code>, <code>dyn</code>}입니다. 새로운 토큰이 추가될 때 부록을 업데이트하는 것을 잊을 수 있으므로 이 목록이 완전하지 않을 수 있습니다.</p>
<p>복합 M에 대한 FOLLOW의 예시:</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3 id="유효하거나-유효하지-않은-매처의-예시"><a class="header" href="#유효하거나-유효하지-않은-매처의-예시">유효하거나 유효하지 않은 매처의 예시</a></h3>
<p>위의 명세를 바탕으로, 특정 매처가 왜 적법하고 다른 것들은 그렇지 않은지에 대한 논거를 제시할 수 있습니다.</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : 부적법. FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> : 적법. FIRST(<code>, foo &lt;</code>) = { <code>,</code> } ⊆ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : 부적법. FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>)이고, 또한 FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : 적법. FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN이고, FIRST(<code>;</code>) = { <code>;</code> } 또한 ⊆ ANYTOKEN이기 때문입니다.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : 적법. (단, 실제로 이 매크로를 사용하려고 시도하면 확장 과정에서 지역적 모호성 오류가 발생합니다.)</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : 부적법. FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> }가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code> : 부적법. 구분자 <code>-</code>가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($e:expr)*)</code> : 부적법. expr NT들이 FOLLOW(expr NT)에 없기 때문입니다.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="appendices.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="influences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="appendices.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="influences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
