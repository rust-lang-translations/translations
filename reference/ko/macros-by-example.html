<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros by example - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/macros-by-example.md`;
                    } else {
                        canonical_href = `${base}/${lang}/macros-by-example.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/macros-by-example.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[macro.decl]</p>
<h1 id="macros-by-example"><a class="header" href="#macros-by-example">Macros by example</a></h1>
<p>r[macro.decl.syntax]</p>
<pre><code class="language-grammar macros">MacroRulesDefinition -&gt;
    `macro_rules` `!` IDENTIFIER MacroRulesDef

MacroRulesDef -&gt;
      `(` MacroRules `)` `;`
    | `[` MacroRules `]` `;`
    | `{` MacroRules `}`

MacroRules -&gt;
    MacroRule ( `;` MacroRule )* `;`?

MacroRule -&gt;
    MacroMatcher `=&gt;` MacroTranscriber

MacroMatcher -&gt;
      `(` MacroMatch* `)`
    | `[` MacroMatch* `]`
    | `{` MacroMatch* `}`

MacroMatch -&gt;
      Token _except `$` and [delimiters][lex.token.delim]_
    | MacroMatcher
    | `$` ( IDENTIFIER_OR_KEYWORD _except `crate`_ | RAW_IDENTIFIER ) `:` MacroFragSpec
    | `$` `(` MacroMatch+ `)` MacroRepSep? MacroRepOp

MacroFragSpec -&gt;
      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | `literal`
    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`

MacroRepSep -&gt; Token _except [delimiters][lex.token.delim] and [MacroRepOp]_

MacroRepOp -&gt; `*` | `+` | `?`

MacroTranscriber -&gt; DelimTokenTree
</code></pre>
<p>r[macro.decl.intro] <code>macro_rules</code> allows users to define syntax extension in a declarative way.  We call such extensions “macros by example” or simply “macros”.</p>
<p>각 예제별 매크로에는 이름과 하나 이상의 _규칙_이 있습니다. 각 규칙에는 두 부분이 있습니다. 일치하는 구문을 설명하는 _매처_와 성공적으로 일치한 호출을 대체할 구문을 설명하는 _트랜스크라이버_입니다. 매처와 트랜스크라이버는 모두 구분 기호로 둘러싸여 있어야 합니다. 매크로는 표현식, 문, 항목(트레이트, impl 및 외부 항목 포함), 유형 또는 패턴으로 확장될 수 있습니다.</p>
<p>r[macro.decl.transcription]</p>
<h2 id="트랜스크라이빙"><a class="header" href="#트랜스크라이빙">트랜스크라이빙</a></h2>
<p>r[macro.decl.transcription.intro] When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried.</p>
<p>r[macro.decl.transcription.lookahead] When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a <code>)</code>, even though that would allow it to parse the invocation unambiguously:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // 오류: 지역적 모호성
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.transcription.syntax] In both the matcher and the transcriber, the <code>$</code> token is used to invoke special behaviours from the macro engine (described below in <a href="#metavariables">Metavariables</a> and <a href="#repetitions">Repetitions</a>). Tokens that aren’t part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher <code>(())</code> will match <code>{()}</code> but not <code>{{}}</code>. The character <code>$</code> cannot be matched or transcribed literally.</p>
<p>r[macro.decl.transcription.fragment]</p>
<h3 id="일치된-조각-전달"><a class="header" href="#일치된-조각-전달">일치된 조각 전달</a></h3>
<p>일치된 조각을 다른 예제별 매크로로 전달할 때 두 번째 매크로의 매처는 조각 유형의 불투명한 AST를 보게 됩니다. 두 번째 매크로는 매처의 조각을 일치시키기 위해 리터럴 토큰을 사용할 수 없으며 동일한 유형의 조각 지정자만 사용할 수 있습니다. <code>ident</code>, <code>lifetime</code> 및 <code>tt</code> 조각 유형은 예외이며 리터럴 토큰으로 일치시킬 수 있습니다. 다음은 이 제한 사항을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// 오류:               ^^ 매크로 호출에서 이 토큰을 예상한 규칙이 없습니다
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>다음은 ‘tt’ 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.meta]</p>
<h2 id="메타변수"><a class="header" href="#메타변수">메타변수</a></h2>
<p>r[macro.decl.meta.intro] In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>fragment-specifier</em> matches a Rust syntax fragment of the kind specified and binds it to the metavariable <code>$</code><em>name</em>.</p>
<p>r[macro.decl.meta.specifier] Valid fragment specifiers are:</p>
<ul>
<li><code>block</code>: a [BlockExpression]</li>
<li><code>expr</code>: an [Expression]</li>
<li><code>expr_2021</code>: an [Expression] except [UnderscoreExpression] and [ConstBlockExpression] (see [macro.decl.meta.edition2024])</li>
<li><code>ident</code>: an [IDENTIFIER_OR_KEYWORD] except <code>_</code>, [RAW_IDENTIFIER], or <a href="macro.decl.hygiene.crate"><code>$crate</code></a></li>
<li><code>item</code>: an [Item]</li>
<li><code>lifetime</code>: a [LIFETIME_TOKEN]</li>
<li><code>literal</code>: matches <code>-</code><sup>?</sup>[LiteralExpression]</li>
<li><code>meta</code>: an [Attr], the contents of an attribute</li>
<li><code>pat</code>: a [Pattern] (see [macro.decl.meta.edition2021])</li>
<li><code>pat_param</code>: a [PatternNoTopAlt]</li>
<li><code>path</code>: a [TypePath] style path</li>
<li><code>stmt</code>: a [Statement][grammar-Statement] without the trailing semicolon (except for item statements that require semicolons)</li>
<li><code>tt</code>: a [TokenTree] (a single <a href="tokens.html">token</a> or tokens in matching delimiters <code>()</code>, <code>[]</code>, or <code>{}</code>)</li>
<li><code>ty</code>: a [Type][grammar-Type]</li>
<li><code>vis</code>: a possibly empty [Visibility] qualifier</li>
</ul>
<p>r[macro.decl.meta.transcription] In the transcriber, metavariables are referred to simply by <code>$</code><em>name</em>, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. Metavariables can be transcribed more than once or not at all.</p>
<p>r[macro.decl.meta.dollar-crate] The keyword metavariable <a href="macro.decl.hygiene.crate"><code>$crate</code></a> can be used to refer to the current crate.</p>
<p>r[macro.decl.meta.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Starting with the 2021 edition, <code>pat</code> fragment-specifiers match top-level or-patterns (that is, they accept [Pattern]).</p>
<p>Before the 2021 edition, they match exactly the same fragments as <code>pat_param</code> (that is, they accept [PatternNoTopAlt]).</p>
<p>관련 에디션은 <code>macro_rules!</code> 정의에 적용되는 에디션입니다.</p>
</blockquote>
<p>r[macro.decl.meta.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, <code>expr</code> fragment specifiers do not match [UnderscoreExpression] or [ConstBlockExpression] at the top level. They are allowed within subexpressions.</p>
<p>The <code>expr_2021</code> 조각 지정자는 2024 이전 에디션과의 하위 호환성을 유지하기 위해 존재합니다.</p>
</blockquote>
<p>r[macro.decl.repetition]</p>
<h2 id="반복"><a class="header" href="#반복">반복</a></h2>
<p>r[macro.decl.repetition.intro] In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside <code>$(</code>…<code>)</code>, followed by a repetition operator, optionally with a separator token between.</p>
<p>r[macro.decl.repetition.separator] The separator token can be any token other than a delimiter or one of the repetition operators, but <code>;</code> and <code>,</code> are the most common. For instance, <code>$( $i:ident ),*</code> represents any number of identifiers separated by commas. Nested repetitions are permitted.</p>
<p>r[macro.decl.repetition.operators] The repetition operators are:</p>
<ul>
<li><code>*</code> — 임의의 횟수 반복을 나타냅니다.</li>
<li><code>+</code> — 임의의 횟수이지만 최소 한 번 이상을 나타냅니다.</li>
<li><code>?</code> — 0 또는 1회 발생하는 선택적 조각을 나타냅니다.</li>
</ul>
<p>r[macro.decl.repetition.optional-restriction] Since <code>?</code> represents at most one occurrence, it cannot be used with a separator.</p>
<p>r[macro.decl.repetition.fragment] The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the <code>$( $i:ident ),*</code> example above matches <code>$i</code> to all of the identifiers in the list.</p>
<p>트랜스크립션 중에는 컴파일러가 반복을 올바르게 확장하는 방법을 알 수 있도록 반복에 추가 제한 사항이 적용됩니다.</p>
<ol>
<li>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher <code>$( $i:ident ),*</code>, the transcribers <code>=&gt; { $i }</code>, <code>=&gt; { $( $( $i )* )* }</code>, and <code>=&gt; { $( $i )+ }</code> are all illegal, but <code>=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</li>
<li>트랜스크라이버의 각 반복에는 확장 횟수를 결정하기 위해 최소한 하나의 메타변수가 포함되어야 합니다. 동일한 반복에 여러 메타변수가 나타나면 동일한 수의 조각에 바인딩되어야 합니다. 예를 들어, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code>는 <code>$j</code> 조각과 동일한 수의 <code>$i</code> 조각을 바인딩해야 합니다. 즉, <code>(a, b, c; d, e, f)</code>로 매크로를 호출하는 것은 합법이며 <code>((a,d), (b,e), (c,f))</code>로 확장되지만, <code>(a, b, c; d, e)</code>는 동일한 수가 아니므로 불법입니다. 이 요구 사항은 중첩된 반복의 모든 계층에 적용됩니다.</li>
</ol>
<p>r[macro.decl.scope]</p>
<h2 id="scoping-exporting-and-importing"><a class="header" href="#scoping-exporting-and-importing">Scoping, exporting, and importing</a></h2>
<p>r[macro.decl.scope.intro] For historical reasons, the scoping of macros by example does not work entirely like items. Macros have two forms of scope: textual scope, and path-based scope. Textual scope is based on the order that things appear in source files, or even across multiple files, and is the default scoping. It is explained further below. Path-based scope works exactly the same way that item scoping does. The scoping, exporting, and importing of macros is controlled largely by attributes.</p>
<p>r[macro.decl.scope.unqualified] When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro’s name is qualified with a path, then it is only looked up in path-based scoping.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // 경로 기반 가져오기.

macro_rules! lazy_static { // 텍스트 정의.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // 텍스트 조회는 먼저 우리 매크로를 찾습니다.
self::lazy_static!{} // 경로 기반 조회는 우리 매크로를 무시하고 가져온 매크로를 찾습니다.</code></pre>
<p>r[macro.decl.scope.textual]</p>
<h3 id="textual-scope"><a class="header" href="#textual-scope">Textual scope</a></h3>
<p>r[macro.decl.scope.textual.intro] Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with <code>let</code> except it also applies at the module level. When <code>macro_rules!</code> is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // 오류: m이 범위에 없습니다.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: m 선언 후에 나타납니다.

    mod uses_macro;
}

// m!{} // 오류: m이 범위에 없습니다.

//// src/has_macro/uses_macro.rs

m!{} // OK: src/lib.rs에서 m 선언 후에 나타납니다</code></pre>
<p>r[macro.decl.scope.textual.shadow] It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // 오류: '1'과 일치하는 규칙이 없습니다
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}</span></code></pre></pre>
<p>매크로는 함수 내부에서도 로컬로 선언하고 사용할 수 있으며 유사하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // 오류: m이 범위에 없습니다.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}

// m!(); // 오류: m이 범위에 없습니다.
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.scope.textual.shadow.path-based] Textual scope name bindings for macros shadow path-based scope bindings to macros.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m2 {
    () =&gt; {
        println!("m2");
    };
}

// Resolves to path-based candidate from use declaration below.
m!(); // prints "m2\n"

// Introduce second candidate for `m` with textual scope.
//
// This shadows path-based candidate from below for the rest of this
// example.
macro_rules! m {
    () =&gt; {
        println!("m");
    };
}

// Introduce `m2` macro as path-based candidate.
//
// This item is in scope for this entire example, not just below the
// use declaration.
use m2 as m;

// Resolves to the textual macro candidate from above the use
// declaration.
m!(); // prints "m\n"
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] For areas where shadowing is not allowed, see <a href="names/name-resolution.html#r-names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
</blockquote>
<p>r[macro.decl.scope.path-based]</p>
<h3 id="path-based-scope"><a class="header" href="#path-based-scope">Path-based scope</a></h3>
<p>r[macro.decl.scope.path-based.intro] By default, a macro has no path-based scope. Macros can gain path-based scope in two ways:</p>
<ul>
<li><a href="items/use-declarations.html#use-visibility">Use declaration re-export</a></li>
<li><a href="#the-macro_export-attribute"><code>macro_export</code></a></li>
</ul>
<p>r[macro.decl.scope.path.reexport] Macros can be re-exported to give them path-based scope from a module other than the crate root.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mac::m!(); // OK: Path-based lookup finds `m` in the mac module.

mod mac {
    // Introduce macro `m` with textual scope.
    macro_rules! m {
        () =&gt; {};
    }

    // Reexport with path-based scope from within `m`'s textual scope.
    pub(crate) use m;
}
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.scope.path-based.visibility] Macros have an implicit visibility of <code>pub(crate)</code>. <code>#[macro_export]</code> changes the implicit visibility to <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implicit visibility is `pub(crate)`.
macro_rules! private_m {
    () =&gt; {};
}

// Implicit visibility is `pub`.
#[macro_export]
macro_rules! pub_m {
    () =&gt; {};
}

pub(crate) use private_m as private_macro; // OK.
pub use pub_m as pub_macro; // OK.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0364 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Implicit visibility is `pub(crate)`.
</span><span class="boring">macro_rules! private_m {
</span><span class="boring">    () =&gt; {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Implicit visibility is `pub`.
</span><span class="boring">#[macro_export]
</span><span class="boring">macro_rules! pub_m {
</span><span class="boring">    () =&gt; {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub(crate) use private_m as private_macro; // OK.
</span><span class="boring">pub use pub_m as pub_macro; // OK.
</span><span class="boring">
</span>pub use private_m; // ERROR: `private_m` is only public within
                   // the crate and cannot be re-exported outside.
<span class="boring">}</span></code></pre></pre>
<!-- template:attributes -->
<p>r[macro.decl.scope.macro_use]</p>
<h3 id="macro_use-속성"><a class="header" href="#macro_use-속성"><code>macro_use</code> 속성</a></h3>
<p>r[macro.decl.scope.macro_use.intro] The <em><code>macro_use</code> [attribute][attributes]</em> has two purposes: it may be used on modules to extend the scope of macros defined within them, and it may be used on [<code>extern crate</code>][items.extern-crate] to import macros from another crate into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}
m!();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore">#[macro_use]
extern crate log;</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.syntax] When used on modules, the <code>macro_use</code> attribute uses the [MetaWord] syntax.</p>
<p>When used on <code>extern crate</code>, it uses the [MetaWord] and [MetaListIdents] syntaxes. For more on how these syntaxes may be used, see [macro.decl.scope.macro_use.prelude].</p>
<p>r[macro.decl.scope.macro_use.allowed-positions] The <code>macro_use</code> attribute may be applied to modules or <code>extern crate</code>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[macro.decl.scope.macro_use.extern-crate-self] The <code>macro_use</code> attribute may not be used on <a href="items.extern-crate.self"><code>extern crate self</code></a>.</p>
<p>r[macro.decl.scope.macro_use.duplicates] The <code>macro_use</code> attribute may be used any number of times on a form.</p>
<p>Multiple instances of <code>macro_use</code> in the [MetaListIdents] syntax may be specified. The union of all specified macros will be imported.</p>
<blockquote>
<p>[!NOTE] On modules, <code>rustc</code> lints against any [MetaWord] <code>macro_use</code> attributes following the first.</p>
<p>On <code>extern crate</code>, <code>rustc</code> lints against any <code>macro_use</code> attributes that have no effect due to not importing any macros not already imported by another <code>macro_use</code> attribute. If two or more [MetaListIdents] <code>macro_use</code> attributes import the same macro, the first is linted against. If any [MetaWord] <code>macro_use</code> attributes are present, all [MetaListIdents] <code>macro_use</code> attributes are linted against. If two or more [MetaWord] <code>macro_use</code> attributes are present, the ones following the first are linted against.</p>
</blockquote>
<p>r[macro.decl.scope.macro_use.mod-decl] When <code>macro_use</code> is used on a module, the module’s macro scope extends beyond the module’s lexical scope.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}
m!(); // OK
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.prelude] Specifying <code>macro_use</code> on an <code>extern crate</code> declaration in the crate root imports exported macros from that crate.</p>
<p>Macros imported this way are imported into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>, not textually, which means that they can be shadowed by any other name. Macros imported by <code>macro_use</code> can be used before the import statement.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> currently prefers the last macro imported in case of conflict. Don’t rely on this. This behavior is unusual, as imports in Rust are generally order-independent. This behavior of <code>macro_use</code> may change in the future.</p>
<p>For details, see <a href="https://github.com/rust-lang/rust/issues/148025">Rust issue #148025</a>.</p>
</blockquote>
<p>When using the [MetaWord] syntax, all exported macros are imported. When using the [MetaListIdents] syntax, only the specified macros are imported.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // Or `#[macro_use]` to import all macros.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // ERROR: lazy_static is not defined in `self`.</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.export] Macros to be imported with <code>macro_use</code> must be exported with [<code>macro_export</code>][macro.decl.scope.macro_export].</p>
<!-- template:attributes -->
<p>r[macro.decl.scope.macro_export]</p>
<h3 id="the-macro_export-attribute"><a class="header" href="#the-macro_export-attribute">The <code>macro_export</code> attribute</a></h3>
<p>r[macro.decl.scope.macro_export.intro] The <em><code>macro_export</code> [attribute][attributes]</em> exports the macro from the crate and makes it available in the root of the crate for path-based resolution.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self::m!();
//  ^^^^ OK: Path-based lookup finds `m` in the current module.
m!(); // As above.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.syntax] The <code>macro_export</code> attribute uses the [MetaWord] and [MetaListIdents] syntaxes. With the [MetaListIdents] syntax, it accepts a single [<code>local_inner_macros</code>][macro.decl.scope.macro_export.local_inner_macros] value.</p>
<p>r[macro.decl.scope.macro_export.allowed-positions] The <code>macro_export</code> attribute may be applied to <code>macro_rules</code> definitions.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[macro.decl.scope.macro_export.duplicates] Only the first use of <code>macro_export</code> on a macro has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[macro.decl.scope.macro_export.path-based] By default, macros only have [textual scope][macro.decl.scope.textual] and cannot be resolved by path. When the <code>macro_export</code> attribute is used, the macro is made available in the crate root and can be referred to by its path.</p>
<blockquote>
<p>[!EXAMPLE] Without <code>macro_export</code>, macros only have textual scope, so path-based resolution of the macro fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0433 edition2024">macro_rules! m {
    () =&gt; {};
}
self::m!(); // 오류
crate::m!(); // 오류
<span class="boring">fn main() {}</span></code></pre></pre>
<p>With <code>macro_export</code>, path-based resolution works.</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[macro_export]
macro_rules! m {
    () =&gt; {};
}
self::m!(); // OK
crate::m!(); // OK
<span class="boring">fn main() {}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.export] The <code>macro_export</code> attribute causes a macro to be exported from the crate root so that it can be referred to in other crates by path.</p>
<blockquote>
<p>[!EXAMPLE] Given the following in a <code>log</code> crate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! warn {
    ($message:expr) =&gt; { eprintln!("WARN: {}", $message) };
}
<span class="boring">}</span></code></pre></pre>
<p>From another crate, you can refer to the macro by path:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">fn main() {
    log::warn!("example warning");
}</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.macro_use] <code>macro_export</code> allows the use of [<code>macro_use</code>][macro.decl.scope.macro_use] on an <code>extern crate</code> to import the macro into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>.</p>
<blockquote>
<p>[!EXAMPLE] Given the following in a <code>log</code> crate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! warn {
    ($message:expr) =&gt; { eprintln!("WARN: {}", $message) };
}
<span class="boring">}</span></code></pre></pre>
<p>Using <code>macro_use</code> in a dependent crate allows you to use the macro from the prelude:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use]
extern crate log;

pub mod util {
    pub fn do_thing() {
        // Resolved via macro prelude.
        warn!("example warning");
    }
}</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.local_inner_macros] Adding <code>local_inner_macros</code> to the <code>macro_export</code> attribute causes all single-segment macro invocations in the macro definition to have an implicit <code>$crate::</code> prefix.</p>
<blockquote>
<p>[!NOTE] This is intended primarily as a tool to migrate code written before <a href="macro.decl.hygiene.crate"><code>$crate</code></a> was added to the language to work with Rust 2018’s path-based imports of macros. Its use is discouraged in new code.</p>
</blockquote>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // 자동으로 $crate::helper!()로 변환됩니다.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.hygiene]</p>
<h2 id="위생"><a class="header" href="#위생">위생</a></h2>
<p>r[macro.decl.hygiene.intro] Macros by example have <em>mixed-site hygiene</em>. This means that <a href="expressions/loop-expr.html#loop-labels">loop labels</a>, <a href="expr.loop.block-labels">block labels</a>, and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
fn func() {
    unreachable!("이것은 절대 호출되지 않습니다")
}

macro_rules! check {
    () =&gt; {
        assert_eq!(x, 1); // 정의 사이트의 `x`를 사용합니다.
        func();           // 호출 사이트의 `func`를 사용합니다.
    };
}

{
    let x = 2;
    fn func() { /* 패닉하지 않습니다 */ }
    check!();
}
<span class="boring">}</span></code></pre></pre>
<p>매크로 확장에서 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다.매크로 확장 시 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (define) =&gt; {
        let x = 1;
    };
    (refer) =&gt; {
        dbg!(x);
    };
}

m!(define);
m!(refer);
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.hygiene.crate] A special case is the <code>$crate</code> metavariable. It refers to the crate defining the macro, and can be used at the start of the path to look up items or macros which are not in scope at the invocation site.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// `helper_macro` 크레이트의 정의.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
// () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 가져오지 않았습니다!
//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 임포트되지 않았습니다!
use helper_macro::helped;

fn unit() {
    helped!();
}</code></pre>
<p>참고: <code>$crate</code>는 현재 크레이트를 참조하므로 매크로가 아닌 항목을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다.참고로, <code>$crate</code>는 현재 크레이트를 참조하므로, 매크로가 아닌 아이템을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.hygiene.vis] Additionally, even though <code>$crate</code> allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke <code>call_foo!()</code> from outside its crate will fail because <code>foo()</code> is not public.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Prior to Rust 1.30, <code>$crate</code> and [<code>local_inner_macros</code>][macro.decl.scope.macro_export.local_inner_macros] were unsupported. They were added alongside [path-based imports of macros][macro.decl.scope.macro_export], to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use <code>$crate</code> or <code>local_inner_macros</code> to work well with path-based imports.</p>
</blockquote>
<p>r[macro.decl.follow-set]</p>
<h2 id="follow-set-ambiguity-restrictions"><a class="header" href="#follow-set-ambiguity-restrictions">Follow-set ambiguity restrictions</a></h2>
<p>r[macro.decl.follow-set.intro] The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language.</p>
<p>r[macro.decl.follow-set.token-restriction] In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</p>
<p>예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 <code>[,]</code>가 합법적인 표현식의 일부가 될 수 없으므로 구문 분석이 항상 명확하기 때문에 오늘날 Rust에서 이론적으로 허용될 수 있습니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있으므로 <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 나중에 Rust 버전에서 <code>[,]</code>가 허용되면 이 매처는 모호해지거나 잘못 구문 분석되어 작동하는 코드를 손상시킬 수 있습니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분 기호이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적입니다. 구체적인 규칙은 다음과 같습니다.예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 오늘날 Rust에서 이론적으로 받아들여질 수 있습니다. 왜냐하면 <code>[,]</code>는 합법적인 표현식의 일부가 될 수 없으므로 파싱이 항상 명확하기 때문입니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있기 때문에, <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 만약 <code>[,]</code>가 이후 버전의 Rust에서 허용된다면, 이 매처는 모호해지거나 잘못 파싱되어 작동하는 코드를 깨뜨릴 것입니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분자이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적일 것입니다. 구체적인 규칙은 다음과 같습니다:</p>
<p>r[macro.decl.follow-set.token-expr-stmt]</p>
<ul>
<li><code>expr</code>과 <code>stmt</code>는 <code>=&gt;</code>, <code>,</code>, 또는 <code>;</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-pat_param]</p>
<ul>
<li><code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code> 또는 <code>in</code> 중 하나만 뒤따를 수 있습니다.<code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-pat]</p>
<ul>
<li><code>pat</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-path-ty]</p>
<ul>
<li><code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 조각 지정자의 매크로 변수 중 하나만 뒤따를 수 있습니다.<code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 프래그먼트 지정자의 매크로 변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-vis]</p>
<ul>
<li><code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 유형을 시작할 수 있는 모든 토큰 또는 <code>ident</code>, <code>ty</code> 또는 <code>path</code> 조각 지정자가 있는 메타변수 중 하나만 뒤따를 수 있습니다.<code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 타입을 시작할 수 있는 모든 토큰, 또는 <code>ident</code>, <code>ty</code>, 또는 <code>path</code> 프래그먼트 지정자를 가진 메타변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-other]</p>
<ul>
<li>다른 모든 조각 지정자에는 제한이 없습니다.</li>
</ul>
<p>r[macro.decl.follow-set.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, <code>pat</code> may also be followed by <code>|</code>.</p>
</blockquote>
<p>r[macro.decl.follow-set.repetition] When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</p>
<ul>
<li>반복에 구분 기호가 포함된 경우, 해당 구분 기호는 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 여러 번 반복될 수 있는 경우(<code>*</code> 또는 <code>+</code>), 내용은 스스로를 따를 수 있어야 합니다.</li>
<li>반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.</li>
</ul>
<p>자세한 내용은 <a href="macro-ambiguity.html">공식 사양</a>을 참조하십시오.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="procedural-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="procedural-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
