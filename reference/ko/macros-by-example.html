<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>예제를 통한 매크로 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/macros-by-example.md`;
                    } else {
                        canonical_href = `${base}/${lang}/macros-by-example.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/macros-by-example.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-macro.decl"><a class="rule-link" href="#r-macro.decl" title="macro.decl"><span>[macro<wbr>.decl]<span/></a></div>
<h1 id="예제를-통한-매크로"><a class="header" href="#예제를-통한-매크로">예제를 통한 매크로</a></h1>
<div class="rule" id="r-macro.decl.syntax"><a class="rule-link" href="#r-macro.decl.syntax" title="macro.decl.syntax"><span>[macro<wbr>.decl<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>MacroRulesDefinition</em> :<br />
   <code>macro_rules</code> <code>!</code> <a href="identifiers.html">IDENTIFIER</a> <em>MacroRulesDef</em></p>
<p><em>MacroRulesDef</em> :<br />
      <code>(</code> <em>MacroRules</em> <code>)</code> <code>;</code><br />
   | <code>[</code> <em>MacroRules</em> <code>]</code> <code>;</code><br />
   | <code>{</code> <em>MacroRules</em> <code>}</code></p>
<p><em>MacroRules</em> :<br />
   <em>MacroRule</em> ( <code>;</code> <em>MacroRule</em> )<sup>*</sup> <code>;</code><sup>?</sup></p>
<p><em>MacroRule</em> :<br />
   <em>MacroMatcher</em> <code>=&gt;</code> <em>MacroTranscriber</em></p>
<p><em>MacroMatcher</em> :<br />
      <code>(</code> <em>MacroMatch</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>MacroMatch</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>MacroMatch</em><sup>*</sup> <code>}</code></p>
<p><em>MacroMatch</em> :<br />
      <a href="tokens.html"><em>Token</em></a><sub><em>except <code>$</code> and <a href="tokens.html#delimiters">delimiters</a></em></sub><br />
   | <em>MacroMatcher</em><br />
   | <code>$</code> ( <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <sub><em>except <code>crate</code></em></sub> | <a href="identifiers.html">RAW_IDENTIFIER</a> | <code>_</code> ) <code>:</code> <em>MacroFragSpec</em><br />
   | <code>$</code> <code>(</code> <em>MacroMatch</em><sup>+</sup> <code>)</code> <em>MacroRepSep</em><sup>?</sup> <em>MacroRepOp</em></p>
<p><em>MacroFragSpec</em> :<br />
      <code>block</code> | <code>expr</code> | <code>expr_2021</code> | <code>ident</code> | <code>item</code> | <code>lifetime</code> | <code>literal</code><br />
   | <code>meta</code> | <code>pat</code> | <code>pat_param</code> | <code>path</code> | <code>stmt</code> | <code>tt</code> | <code>ty</code> | <code>vis</code></p>
<p><em>MacroRepSep</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>except <a href="tokens.html#delimiters">delimiters</a> and MacroRepOp</em></sub></p>
<p><em>MacroRepOp</em> :<br />
   <code>*</code> | <code>+</code> | <code>?</code></p>
<p><em>MacroTranscriber</em> :<br />
   <a href="macros.html"><em>DelimTokenTree</em></a></p>
</blockquote>
<div class="rule" id="r-macro.decl.intro"><a class="rule-link" href="#r-macro.decl.intro" title="macro.decl.intro"><span>[macro<wbr>.decl<wbr>.intro]<span/></a></div>
<p><code>macro_rules</code>는 사용자가 선언적인 방식으로 구문 확장을 정의할 수 있도록 합니다.  이러한 확장을 “예제를 통한 매크로” 또는 간단히 “매크로“라고 합니다.</p>
<p>각 예제별 매크로에는 이름과 하나 이상의 _규칙_이 있습니다. 각 규칙에는 두 부분이 있습니다. 일치하는 구문을 설명하는 _매처_와 성공적으로 일치한 호출을 대체할 구문을 설명하는 _트랜스크라이버_입니다. 매처와 트랜스크라이버는 모두 구분 기호로 둘러싸여 있어야 합니다. 매크로는 표현식, 문, 항목(트레이트, impl 및 외부 항목 포함), 유형 또는 패턴으로 확장될 수 있습니다.</p>
<div class="rule" id="r-macro.decl.transcription"><a class="rule-link" href="#r-macro.decl.transcription" title="macro.decl.transcription"><span>[macro<wbr>.decl<wbr>.transcription]<span/></a></div>
<h2 id="트랜스크라이빙"><a class="header" href="#트랜스크라이빙">트랜스크라이빙</a></h2>
<div class="rule" id="r-macro.decl.transcription.intro"><a class="rule-link" href="#r-macro.decl.transcription.intro" title="macro.decl.transcription.intro"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.intro]<span/></a></div>
<p>매크로가 호출되면 매크로 확장기는 이름으로 매크로 호출을 조회하고 각 매크로 규칙을 차례로 시도합니다. 첫 번째 성공적인 일치를 트랜스크라이브합니다. 이로 인해 오류가 발생하면 이후 일치는 시도되지 않습니다.</p>
<div class="rule" id="r-macro.decl.transcription.lookahead"><a class="rule-link" href="#r-macro.decl.transcription.lookahead" title="macro.decl.transcription.lookahead"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.lookahead]<span/></a></div>
<p>일치시킬 때 미리 보기를 수행하지 않습니다. 컴파일러가 한 번에 하나의 토큰으로 매크로 호출을 구문 분석하는 방법을 명확하게 결정할 수 없으면 오류입니다. 다음 예에서 컴파일러는 다음 토큰이 ’)’인지 확인하기 위해 식별자를 지나 미리 보지 않습니다. 그렇게 하면 호출을 명확하게 구문 분석할 수 있음에도 불구하고 말입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // 오류: 지역적 모호성
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.transcription.syntax"><a class="rule-link" href="#r-macro.decl.transcription.syntax" title="macro.decl.transcription.syntax"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.syntax]<span/></a></div>
<p>매처와 트랜스크라이버 모두에서 ‘$’ 토큰은 매크로 엔진에서 특수 동작을 호출하는 데 사용됩니다(<a href="#metavariables">메타변수</a> 및 <a href="#repetitions">반복</a>에서 아래에 설명됨). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치되고 트랜스크라이브됩니다. 예외는 매처의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 ’(())’는 ’{()}’와 일치하지만 ’{{}}’와는 일치하지 않습니다. ‘$’ 문자는 문자 그대로 일치시키거나 트랜스크라이브할 수 없습니다.</p>
<div class="rule" id="r-macro.decl.transcription.fragment"><a class="rule-link" href="#r-macro.decl.transcription.fragment" title="macro.decl.transcription.fragment"><span>[macro<wbr>.decl<wbr>.transcription<wbr>.fragment]<span/></a></div>
<h3 id="일치된-조각-전달"><a class="header" href="#일치된-조각-전달">일치된 조각 전달</a></h3>
<p>일치된 조각을 다른 예제별 매크로로 전달할 때 두 번째 매크로의 매처는 조각 유형의 불투명한 AST를 보게 됩니다. 두 번째 매크로는 매처의 조각을 일치시키기 위해 리터럴 토큰을 사용할 수 없으며 동일한 유형의 조각 지정자만 사용할 수 있습니다. <code>ident</code>, <code>lifetime</code> 및 <code>tt</code> 조각 유형은 예외이며 리터럴 토큰으로 일치시킬 수 있습니다. 다음은 이 제한 사항을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// 오류:               ^^ 매크로 호출에서 이 토큰을 예상한 규칙이 없습니다
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>다음은 ‘tt’ 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.meta"><a class="rule-link" href="#r-macro.decl.meta" title="macro.decl.meta"><span>[macro<wbr>.decl<wbr>.meta]<span/></a></div>
<h2 id="메타변수"><a class="header" href="#메타변수">메타변수</a></h2>
<div class="rule" id="r-macro.decl.meta.intro"><a class="rule-link" href="#r-macro.decl.meta.intro" title="macro.decl.meta.intro"><span>[macro<wbr>.decl<wbr>.meta<wbr>.intro]<span/></a></div>
<p>매처에서 <code>$</code> <em>이름</em> <code>:</code> _조각-지정자_는 지정된 종류의 Rust 구문 조각과 일치하고 메타변수 <code>$</code>_이름_에 바인딩합니다.</p>
<div class="rule" id="r-macro.decl.meta.specifier"><a class="rule-link" href="#r-macro.decl.meta.specifier" title="macro.decl.meta.specifier"><span>[macro<wbr>.decl<wbr>.meta<wbr>.specifier]<span/></a></div>
<p>유효한 조각 지정자는 다음과 같습니다.</p>
<ul>
<li><code>block</code>: <a href="expressions/block-expr.html"><em>블록표현식</em></a></li>
<li><code>expr</code>: <a href="expressions.html"><em>표현식</em></a></li>
<li><code>expr_2021</code>: <a href="expressions/underscore-expr.html"><em>밑줄표현식</em></a> 및 <a href="expressions/block-expr.html#const-blocks"><em>상수블록표현식</em></a>을 제외한 <a href="expressions.html"><em>표현식</em></a> (<a href="macros-by-example.html#r-macro.decl.meta.edition2024">macro.decl.meta.edition2024</a> 참조)</li>
<li><code>ident</code>: <a href="identifiers.html">식별자_또는_키워드</a> 또는 <a href="identifiers.html">원시_식별자</a></li>
<li><code>item</code>: <a href="items.html"><em>아이템</em></a></li>
<li><code>lifetime</code>: <a href="tokens.html#lifetimes-and-loop-labels">라이프타임_토큰</a></li>
<li><code>literal</code>: <code>-</code><sup>?</sup><a href="expressions/literal-expr.html"><em>리터럴표현식</em></a>과 일치합니다</li>
<li><code>meta</code>: <a href="attributes.html"><em>속성</em></a>, 속성의 내용</li>
<li><code>pat</code>: <a href="patterns.html"><em>패턴</em></a> (<a href="macros-by-example.html#r-macro.decl.meta.edition2021">macro.decl.meta.edition2021</a> 참조)</li>
<li><code>pat_param</code>: <a href="patterns.html"><em>패턴상단대체없음</em></a></li>
<li><code>path</code>: <a href="paths.html#paths-in-types"><em>타입경로</em></a> 스타일 경로</li>
<li><code>stmt</code>: 후행 세미콜론이 없는 <a href="statements.html"><em>문</em></a> (세미콜론이 필요한 항목 문 제외)</li>
<li><code>tt</code>: <a href="macros.html#macro-invocation"><em>토큰트리</em></a> (단일 <a href="tokens.html">토큰</a> 또는 일치하는 구분 기호 <code>()</code>, <code>[]</code> 또는 <code>{}</code>의 토큰)</li>
<li><code>ty</code>: <a href="types.html#type-expressions"><em>타입</em></a></li>
<li><code>vis</code>: 비어 있을 수 있는 <a href="visibility-and-privacy.html"><em>가시성</em></a> 한정자</li>
</ul>
<div class="rule" id="r-macro.decl.meta.transcription"><a class="rule-link" href="#r-macro.decl.meta.transcription" title="macro.decl.meta.transcription"><span>[macro<wbr>.decl<wbr>.meta<wbr>.transcription]<span/></a></div>
<p>트랜스크라이버에서 메타변수는 조각 종류가 매처에 지정되어 있으므로 간단히 <code>$</code>_이름_으로 참조됩니다. 메타변수는 일치하는 구문 요소로 대체됩니다.</p>
<div class="rule" id="r-macro.decl.meta.dollar-crate"><a class="rule-link" href="#r-macro.decl.meta.dollar-crate" title="macro.decl.meta.dollar-crate"><span>[macro<wbr>.decl<wbr>.meta<wbr>.dollar-crate]<span/></a></div>
<p>키워드 메타변수 <code>$crate</code>는 현재 크레이트를 참조하는 데 사용할 수 있습니다. 아래 <a href="#hygiene">위생</a>을 참조하십시오. 메타변수는 두 번 이상 또는 전혀 트랜스크라이브되지 않을 수 있습니다.</p>
<div class="rule" id="r-macro.decl.meta.edition2021"><a class="rule-link" href="#r-macro.decl.meta.edition2021" title="macro.decl.meta.edition2021"><span>[macro<wbr>.decl<wbr>.meta<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션부터 <code>pat</code> 조각 지정자는 최상위 또는 패턴과 일치합니다(즉, <a href="patterns.html"><em>패턴</em></a>을 허용합니다).</p>
<p>2021 에디션 이전에는 <code>pat_param</code>과 정확히 동일한 조각과 일치합니다(즉, <a href="patterns.html"><em>패턴상단대체없음</em></a>을 허용합니다).</p>
<p>관련 에디션은 <code>macro_rules!</code> 정의에 적용되는 에디션입니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.meta.edition2024"><a class="rule-link" href="#r-macro.decl.meta.edition2024" title="macro.decl.meta.edition2024"><span>[macro<wbr>.decl<wbr>.meta<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션 이전에는 <code>expr</code> 조각 지정자가 최상위 수준에서 <a href="expressions/underscore-expr.html"><em>밑줄표현식</em></a> 또는 <a href="expressions/block-expr.html#const-blocks"><em>상수블록표현식</em></a>과 일치하지 않습니다. 하위 표현식 내에서는 허용됩니다.</p>
<p>The <code>expr_2021</code> 조각 지정자는 2024 이전 에디션과의 하위 호환성을 유지하기 위해 존재합니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.repetition"><a class="rule-link" href="#r-macro.decl.repetition" title="macro.decl.repetition"><span>[macro<wbr>.decl<wbr>.repetition]<span/></a></div>
<h2 id="반복"><a class="header" href="#반복">반복</a></h2>
<div class="rule" id="r-macro.decl.repetition.intro"><a class="rule-link" href="#r-macro.decl.repetition.intro" title="macro.decl.repetition.intro"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.intro]<span/></a></div>
<p>매처와 트랜스크라이버 모두에서 반복은 반복할 토큰을 <code>$(</code>…<code>)</code> 안에 넣고 반복 연산자를 뒤에 붙여 표시하며, 선택적으로 사이에 구분 기호 토큰을 넣을 수 있습니다.</p>
<div class="rule" id="r-macro.decl.repetition.separator"><a class="rule-link" href="#r-macro.decl.repetition.separator" title="macro.decl.repetition.separator"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.separator]<span/></a></div>
<p>구분 기호 토큰은 구분 기호나 반복 연산자 중 하나가 아닌 모든 토큰이 될 수 있지만 <code>;</code>와 <code>,</code>가 가장 일반적입니다. 예를 들어, <code>$( $i:ident ),*</code>는 쉼표로 구분된 임의의 수의 식별자를 나타냅니다. 중첩된 반복은 허용됩니다.</p>
<div class="rule" id="r-macro.decl.repetition.operators"><a class="rule-link" href="#r-macro.decl.repetition.operators" title="macro.decl.repetition.operators"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.operators]<span/></a></div>
<p>반복 연산자는 다음과 같습니다.</p>
<ul>
<li><code>*</code> — 임의의 횟수 반복을 나타냅니다.</li>
<li><code>+</code> — 임의의 횟수이지만 최소 한 번 이상을 나타냅니다.</li>
<li><code>?</code> — 0 또는 1회 발생하는 선택적 조각을 나타냅니다.</li>
</ul>
<div class="rule" id="r-macro.decl.repetition.optional-restriction"><a class="rule-link" href="#r-macro.decl.repetition.optional-restriction" title="macro.decl.repetition.optional-restriction"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.optional-restriction]<span/></a></div>
<p>Since <code>?</code>는 최대 한 번 발생함을 나타내므로 구분 기호와 함께 사용할 수 없습니다.</p>
<div class="rule" id="r-macro.decl.repetition.fragment"><a class="rule-link" href="#r-macro.decl.repetition.fragment" title="macro.decl.repetition.fragment"><span>[macro<wbr>.decl<wbr>.repetition<wbr>.fragment]<span/></a></div>
<p>반복되는 조각은 구분 기호 토큰으로 구분된 지정된 수의 조각과 일치하고 트랜스크라이브됩니다. 메타변수는 해당 조각의 모든 반복과 일치합니다. 예를 들어, 위의 <code>$( $i:ident ),*</code> 예제는 목록의 모든 식별자에 <code>$i</code>를 일치시킵니다.</p>
<p>트랜스크립션 중에는 컴파일러가 반복을 올바르게 확장하는 방법을 알 수 있도록 반복에 추가 제한 사항이 적용됩니다.</p>
<ol>
<li>메타변수는 매처에서와 동일한 수, 종류 및 중첩 순서로 트랜스크라이버에 나타나야 합니다. 따라서 매처 <code>$( $i:ident ),*</code>의 경우 트랜스크라이버 <code>=&gt; { $i }</code>, <code>=&gt; { $( $( $i)* )* }</code> 및 <code>=&gt; { $( $i )+ }</code>는 모두 불법이지만 <code>=&gt; { $( $i );* }</code>는 올바르며 쉼표로 구분된 식별자 목록을 세미콜론으로 구분된 목록으로 바꿉니다.</li>
<li>트랜스크라이버의 각 반복에는 확장 횟수를 결정하기 위해 최소한 하나의 메타변수가 포함되어야 합니다. 동일한 반복에 여러 메타변수가 나타나면 동일한 수의 조각에 바인딩되어야 합니다. 예를 들어, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code>는 <code>$j</code> 조각과 동일한 수의 <code>$i</code> 조각을 바인딩해야 합니다. 즉, <code>(a, b, c; d, e, f)</code>로 매크로를 호출하는 것은 합법이며 <code>((a,d), (b,e), (c,f))</code>로 확장되지만, <code>(a, b, c; d, e)</code>는 동일한 수가 아니므로 불법입니다. 이 요구 사항은 중첩된 반복의 모든 계층에 적용됩니다.</li>
</ol>
<div class="rule" id="r-macro.decl.scope"><a class="rule-link" href="#r-macro.decl.scope" title="macro.decl.scope"><span>[macro<wbr>.decl<wbr>.scope]<span/></a></div>
<h2 id="스코핑-내보내기-및-가져오기"><a class="header" href="#스코핑-내보내기-및-가져오기">스코핑, 내보내기 및 가져오기</a></h2>
<div class="rule" id="r-macro.decl.scope.intro"><a class="rule-link" href="#r-macro.decl.scope.intro" title="macro.decl.scope.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.intro]<span/></a></div>
<p>역사적인 이유로 예제별 매크로의 범위 지정은 항목처럼 완전히 작동하지 않습니다. 매크로에는 텍스트 범위와 경로 기반 범위의 두 가지 범위 형식이 있습니다. 텍스트 범위는 소스 파일에 항목이 나타나는 순서 또는 여러 파일에 걸쳐 나타나는 순서를 기반으로 하며 기본 범위 지정입니다. 아래에서 자세히 설명합니다. 경로 기반 범위는 항목 범위 지정과 정확히 동일하게 작동합니다. 매크로의 범위 지정, 내보내기 및 가져오기는 주로 속성에 의해 제어됩니다.</p>
<div class="rule" id="r-macro.decl.scope.unqualified"><a class="rule-link" href="#r-macro.decl.scope.unqualified" title="macro.decl.scope.unqualified"><span>[macro<wbr>.decl<wbr>.scope<wbr>.unqualified]<span/></a></div>
<p>매크로가 정규화되지 않은 식별자(다중 부분 경로의 일부가 아님)에 의해 호출되면 먼저 텍스트 범위에서 조회됩니다. 결과가 없으면 경로 기반 범위에서 조회됩니다. 매크로 이름이 경로로 정규화되면 경로 기반 범위에서만 조회됩니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // 경로 기반 가져오기.

macro_rules! lazy_static { // 텍스트 정의.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // 텍스트 조회는 먼저 우리 매크로를 찾습니다.
self::lazy_static!{} // 경로 기반 조회는 우리 매크로를 무시하고 가져온 매크로를 찾습니다.</code></pre>
<div class="rule" id="r-macro.decl.scope.textual"><a class="rule-link" href="#r-macro.decl.scope.textual" title="macro.decl.scope.textual"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual]<span/></a></div>
<h3 id="텍스트-범위"><a class="header" href="#텍스트-범위">텍스트 범위</a></h3>
<div class="rule" id="r-macro.decl.scope.textual.intro"><a class="rule-link" href="#r-macro.decl.scope.textual.intro" title="macro.decl.scope.textual.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual<wbr>.intro]<span/></a></div>
<p>텍스트 범위는 주로 소스 파일에 항목이 나타나는 순서를 기반으로 하며 <code>let</code>으로 선언된 지역 변수의 범위와 유사하게 작동하지만 모듈 수준에서도 적용됩니다. <code>macro_rules!</code>를 사용하여 매크로를 정의하면 매크로는 정의 후 범위에 들어갑니다(이름은 호출 사이트에서 조회되므로 여전히 재귀적으로 사용할 수 있음). 일반적으로 모듈인 주변 범위가 닫힐 때까지입니다. 이것은 자식 모듈에 들어가거나 여러 파일에 걸쳐 있을 수도 있습니다.</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // 오류: m이 범위에 없습니다.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: m 선언 후에 나타납니다.

    mod uses_macro;
}

// m!{} // 오류: m이 범위에 없습니다.

//// src/has_macro/uses_macro.rs

m!{} // OK: src/lib.rs에서 m 선언 후에 나타납니다</code></pre>
<div class="rule" id="r-macro.decl.scope.textual.shadow"><a class="rule-link" href="#r-macro.decl.scope.textual.shadow" title="macro.decl.scope.textual.shadow"><span>[macro<wbr>.decl<wbr>.scope<wbr>.textual<wbr>.shadow]<span/></a></div>
<p>매크로를 여러 번 정의하는 것은 오류가 아닙니다. 가장 최근 선언은 범위를 벗어나지 않는 한 이전 선언을 가립니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // 오류: '1'과 일치하는 규칙이 없습니다
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}</span></code></pre></pre>
<p>매크로는 함수 내부에서도 로컬로 선언하고 사용할 수 있으며 유사하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // 오류: m이 범위에 없습니다.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}

// m!(); // 오류: m이 범위에 없습니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.macro_use"><a class="rule-link" href="#r-macro.decl.scope.macro_use" title="macro.decl.scope.macro_use"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use]<span/></a></div>
<h3 id="macro_use-속성"><a class="header" href="#macro_use-속성"><code>macro_use</code> 속성</a></h3>
<div class="rule" id="r-macro.decl.scope.macro_use.mod-decl"><a class="rule-link" href="#r-macro.decl.scope.macro_use.mod-decl" title="macro.decl.scope.macro_use.mod-decl"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.mod-decl]<span/></a></div>
<p>The _<code>macro_use</code> 속성_은 두 가지 목적이 있습니다. 첫째, 모듈에 적용하여 모듈이 닫힐 때 모듈의 매크로 범위가 끝나지 않도록 하는 데 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}

m!();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.macro_use.prelude"><a class="rule-link" href="#r-macro.decl.scope.macro_use.prelude" title="macro.decl.scope.macro_use.prelude"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.prelude]<span/></a></div>
<p>둘째, 크레이트의 루트 모듈에 나타나는 <code>extern crate</code> 선언에 첨부하여 다른 크레이트에서 매크로를 가져오는 데 사용할 수 있습니다. 이런 식으로 가져온 매크로는 텍스트가 아닌 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 전주곡</a>으로 가져오므로 다른 이름으로 가려질 수 있습니다. <code>#[macro_use]</code>로 가져온 매크로는 가져오기 문 앞에 사용할 수 있지만 충돌이 발생하면 마지막으로 가져온 매크로가 우선합니다. 선택적으로, <a href="attributes.html#meta-item-attribute-syntax"><em>MetaListIdents</em></a> 구문을 사용하여 가져올 매크로 목록을 지정할 수 있습니다. 이것은 <code>#[macro_use]</code>가 모듈에 적용될 때 지원되지 않습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // 또는 #[macro_use]를 사용하여 모든 매크로를 가져옵니다.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // 오류: `self`에 lazy_static이 정의되어 있지 않습니다</code></pre>
<div class="rule" id="r-macro.decl.scope.macro_use.export"><a class="rule-link" href="#r-macro.decl.scope.macro_use.export" title="macro.decl.scope.macro_use.export"><span>[macro<wbr>.decl<wbr>.scope<wbr>.macro_use<wbr>.export]<span/></a></div>
<p><code>#[macro_use]</code>로 가져올 매크로는 아래에 설명된 <code>#[macro_export]</code>로 내보내야 합니다.</p>
<div class="rule" id="r-macro.decl.scope.path"><a class="rule-link" href="#r-macro.decl.scope.path" title="macro.decl.scope.path"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path]<span/></a></div>
<h3 id="경로-기반-범위"><a class="header" href="#경로-기반-범위">경로 기반 범위</a></h3>
<div class="rule" id="r-macro.decl.scope.path.intro"><a class="rule-link" href="#r-macro.decl.scope.path.intro" title="macro.decl.scope.path.intro"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path<wbr>.intro]<span/></a></div>
<p>기본적으로 매크로에는 경로 기반 범위가 없습니다. 그러나 <code>#[macro_export]</code> 속성이 있으면 크레이트 루트 범위에 선언되고 다음과 같이 정상적으로 참조할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self::m!();
m!(); // OK: 경로 기반 조회는 현재 모듈에서 m을 찾습니다.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.scope.path.export"><a class="rule-link" href="#r-macro.decl.scope.path.export" title="macro.decl.scope.path.export"><span>[macro<wbr>.decl<wbr>.scope<wbr>.path<wbr>.export]<span/></a></div>
<p><code>#[macro_export]</code>로 레이블이 지정된 매크로는 항상 <code>pub</code>이며 위에서 설명한 대로 경로 또는 <code>#[macro_use]</code>를 통해 다른 크레이트에서 참조할 수 있습니다.</p>
<div class="rule" id="r-macro.decl.hygiene"><a class="rule-link" href="#r-macro.decl.hygiene" title="macro.decl.hygiene"><span>[macro<wbr>.decl<wbr>.hygiene]<span/></a></div>
<h2 id="위생"><a class="header" href="#위생">위생</a></h2>
<div class="rule" id="r-macro.decl.hygiene.intro"><a class="rule-link" href="#r-macro.decl.hygiene.intro" title="macro.decl.hygiene.intro"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.intro]<span/></a></div>
<p>매크로 바이 이그젬플은 _혼합-사이트 위생_을 가집니다. 이는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a>, <a href="expressions/loop-expr.html#labelled-block-expressions">블록 레이블</a> 및 지역 변수는 매크로 정의 사이트에서 조회되는 반면 다른 심볼은 매크로 호출 사이트에서 조회됨을 의미합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
fn func() {
    unreachable!("이것은 절대 호출되지 않습니다")
}

macro_rules! check {
    () =&gt; {
        assert_eq!(x, 1); // 정의 사이트의 `x`를 사용합니다.
        func();           // 호출 사이트의 `func`를 사용합니다.
    };
}

{
    let x = 2;
    fn func() { /* 패닉하지 않습니다 */ }
    check!();
}
<span class="boring">}</span></code></pre></pre>
<p>매크로 확장에서 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다.매크로 확장 시 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (define) =&gt; {
        let x = 1;
    };
    (refer) =&gt; {
        dbg!(x);
    };
}

m!(define);
m!(refer);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.hygiene.crate"><a class="rule-link" href="#r-macro.decl.hygiene.crate" title="macro.decl.hygiene.crate"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.crate]<span/></a></div>
<p>특별한 경우는 <code>$crate</code> 메타변수입니다. 이것은 매크로를 정의하는 크레이트를 참조하며, 호출 사이트에서 범위에 없는 아이템이나 매크로를 조회하기 위해 경로의 시작 부분에서 사용될 수 있습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// `helper_macro` 크레이트의 정의.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
// () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 가져오지 않았습니다!
//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 임포트되지 않았습니다!
use helper_macro::helped;

fn unit() {
    helped!();
}</code></pre>
<p>참고: <code>$crate</code>는 현재 크레이트를 참조하므로 매크로가 아닌 항목을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다.참고로, <code>$crate</code>는 현재 크레이트를 참조하므로, 매크로가 아닌 아이템을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.hygiene.vis"><a class="rule-link" href="#r-macro.decl.hygiene.vis" title="macro.decl.hygiene.vis"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.vis]<span/></a></div>
<p>또한 <code>$crate</code>를 사용하면 매크로가 확장될 때 자체 크레이트 내의 항목을 참조할 수 있지만 가시성에는 영향을 미치지 않습니다. 참조된 항목이나 매크로는 호출 사이트에서 계속 볼 수 있어야 합니다. 다음 예에서 <code>foo()</code>가 공개되지 않았기 때문에 크레이트 외부에서 <code>call_foo!()</code>를 호출하려는 모든 시도는 실패합니다.또한, <code>$crate</code>를 사용하면 매크로가 확장될 때 자신의 크레이트 내의 아이템을 참조할 수 있지만, 가시성에는 영향을 미치지 않습니다. 참조된 아이템이나 매크로는 호출 사이트에서 여전히 보여야 합니다. 다음 예제에서, <code>foo()</code>가 공개되지 않았기 때문에 크레이트 외부에서 <code>call_foo!()</code>를 호출하려는 모든 시도는 실패합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>버전 및 에디션 차이</strong>: Rust 1.30 이전에는 <code>$crate</code> 및 <code>local_inner_macros</code>(아래)가 지원되지 않았습니다. 매크로 내보내기 크레이트 사용자가 도우미 매크로를 수동으로 가져올 필요가 없도록 경로 기반 매크로 가져오기(위에 설명됨)와 함께 추가되었습니다. 도우미 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 가져오기와 잘 작동하도록 <code>$crate</code> 또는 <code>local_inner_macros</code>를 사용하도록 수정해야 합니다.<strong>버전 및 에디션 차이</strong>: Rust 1.30 이전에는 <code>$crate</code> 및 <code>local_inner_macros</code>(아래)가 지원되지 않았습니다. 이것들은 매크로를 내보내는 크레이트의 사용자가 헬퍼 매크로를 수동으로 임포트할 필요가 없도록 하기 위해 (위에서 설명한) 경로 기반 매크로 임포트와 함께 추가되었습니다. 헬퍼 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 임포트와 잘 작동하도록 <code>$crate</code> 또는 <code>local_inner_macros</code>를 사용하도록 수정해야 합니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.hygiene.local_inner_macros"><a class="rule-link" href="#r-macro.decl.hygiene.local_inner_macros" title="macro.decl.hygiene.local_inner_macros"><span>[macro<wbr>.decl<wbr>.hygiene<wbr>.local_inner_macros]<span/></a></div>
<p>매크로를 내보낼 때 <code>#[macro_export]</code> 속성에 <code>local_inner_macros</code> 키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 <code>$crate::</code> 접두사를 붙일 수 있습니다. 이것은 주로 <code>$crate</code>가 언어에 추가되기 전에 작성된 코드를 Rust 2018의 경로 기반 매크로 가져오기와 함께 작동하도록 마이그레이션하는 도구로 사용됩니다. 새 코드에서는 사용을 권장하지 않습니다.매크로가 내보내질 때, <code>#[macro_export]</code> 속성에 <code>local_inner_macros</code> 키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 <code>$crate::</code> 접두사를 붙일 수 있습니다. 이것은 주로 <code>$crate</code>가 언어에 추가되기 전에 작성된 코드를 Rust 2018의 경로 기반 매크로 임포트와 함께 작동하도록 마이그레이션하기 위한 도구로 의도되었습니다. 새 코드에서는 사용을 권장하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // 자동으로 $crate::helper!()로 변환됩니다.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-macro.decl.follow-set"><a class="rule-link" href="#r-macro.decl.follow-set" title="macro.decl.follow-set"><span>[macro<wbr>.decl<wbr>.follow-set]<span/></a></div>
<h2 id="후속-집합-모호성-제한"><a class="header" href="#후속-집합-모호성-제한">후속 집합 모호성 제한</a></h2>
<div class="rule" id="r-macro.decl.follow-set.intro"><a class="rule-link" href="#r-macro.decl.follow-set.intro" title="macro.decl.follow-set.intro"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.intro]<span/></a></div>
<p>매크로 시스템에서 사용하는 파서는 상당히 강력하지만 현재 또는 미래 버전의 언어에서 모호성을 방지하기 위해 제한됩니다.매크로 시스템에서 사용하는 파서는 상당히 강력하지만, 현재 또는 미래 버전의 언어에서 모호성을 방지하기 위해 제한됩니다.</p>
<div class="rule" id="r-macro.decl.follow-set.token-restriction"><a class="rule-link" href="#r-macro.decl.follow-set.token-restriction" title="macro.decl.follow-set.token-restriction"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-restriction]<span/></a></div>
<p>특히, 모호한 확장에 대한 규칙 외에도 메타변수와 일치하는 비단말은 해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 합니다.특히, 모호한 확장에 대한 규칙 외에도, 메타변수에 의해 일치된 비단말은 해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 합니다.</p>
<p>예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 <code>[,]</code>가 합법적인 표현식의 일부가 될 수 없으므로 구문 분석이 항상 명확하기 때문에 오늘날 Rust에서 이론적으로 허용될 수 있습니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있으므로 <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 나중에 Rust 버전에서 <code>[,]</code>가 허용되면 이 매처는 모호해지거나 잘못 구문 분석되어 작동하는 코드를 손상시킬 수 있습니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분 기호이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적입니다. 구체적인 규칙은 다음과 같습니다.예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 오늘날 Rust에서 이론적으로 받아들여질 수 있습니다. 왜냐하면 <code>[,]</code>는 합법적인 표현식의 일부가 될 수 없으므로 파싱이 항상 명확하기 때문입니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있기 때문에, <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 만약 <code>[,]</code>가 이후 버전의 Rust에서 허용된다면, 이 매처는 모호해지거나 잘못 파싱되어 작동하는 코드를 깨뜨릴 것입니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분자이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적일 것입니다. 구체적인 규칙은 다음과 같습니다:</p>
<div class="rule" id="r-macro.decl.follow-set.token-expr-stmt"><a class="rule-link" href="#r-macro.decl.follow-set.token-expr-stmt" title="macro.decl.follow-set.token-expr-stmt"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-expr-stmt]<span/></a></div>
<ul>
<li><code>expr</code>과 <code>stmt</code>는 <code>=&gt;</code>, <code>,</code>, 또는 <code>;</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-pat_param"><a class="rule-link" href="#r-macro.decl.follow-set.token-pat_param" title="macro.decl.follow-set.token-pat_param"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-pat_param]<span/></a></div>
<ul>
<li><code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code> 또는 <code>in</code> 중 하나만 뒤따를 수 있습니다.<code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-pat"><a class="rule-link" href="#r-macro.decl.follow-set.token-pat" title="macro.decl.follow-set.token-pat"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-pat]<span/></a></div>
<ul>
<li><code>pat</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-path-ty"><a class="rule-link" href="#r-macro.decl.follow-set.token-path-ty" title="macro.decl.follow-set.token-path-ty"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-path-ty]<span/></a></div>
<ul>
<li><code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 조각 지정자의 매크로 변수 중 하나만 뒤따를 수 있습니다.<code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 프래그먼트 지정자의 매크로 변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-vis"><a class="rule-link" href="#r-macro.decl.follow-set.token-vis" title="macro.decl.follow-set.token-vis"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-vis]<span/></a></div>
<ul>
<li><code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 유형을 시작할 수 있는 모든 토큰 또는 <code>ident</code>, <code>ty</code> 또는 <code>path</code> 조각 지정자가 있는 메타변수 중 하나만 뒤따를 수 있습니다.<code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 타입을 시작할 수 있는 모든 토큰, 또는 <code>ident</code>, <code>ty</code>, 또는 <code>path</code> 프래그먼트 지정자를 가진 메타변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.token-other"><a class="rule-link" href="#r-macro.decl.follow-set.token-other" title="macro.decl.follow-set.token-other"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.token-other]<span/></a></div>
<ul>
<li>다른 모든 조각 지정자에는 제한이 없습니다.</li>
</ul>
<div class="rule" id="r-macro.decl.follow-set.edition2021"><a class="rule-link" href="#r-macro.decl.follow-set.edition2021" title="macro.decl.follow-set.edition2021"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.edition2021]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2021 에디션 이전에는 <code>pat</code> 뒤에 <code>|</code>가 올 수도 있습니다.<strong>에디션 차이</strong>: 2021 에디션 이전에는 <code>pat</code> 뒤에 <code>|</code>가 올 수도 있습니다.</p>
</blockquote>
<div class="rule" id="r-macro.decl.follow-set.repetition"><a class="rule-link" href="#r-macro.decl.follow-set.repetition" title="macro.decl.follow-set.repetition"><span>[macro<wbr>.decl<wbr>.follow-set<wbr>.repetition]<span/></a></div>
<p>반복이 포함된 경우 규칙은 구분 기호를 고려하여 가능한 모든 확장 수에 적용됩니다. 이는 다음을 의미합니다.반복이 포함된 경우, 구분 기호를 고려하여 가능한 모든 확장 수에 규칙이 적용됩니다. 이는 다음을 의미합니다:</p>
<ul>
<li>반복에 구분 기호가 포함된 경우, 해당 구분 기호는 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 여러 번 반복될 수 있는 경우(<code>*</code> 또는 <code>+</code>), 내용은 스스로를 따를 수 있어야 합니다.</li>
<li>반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.</li>
</ul>
<p>자세한 내용은 <a href="macro-ambiguity.html">공식 사양</a>을 참조하십시오.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="procedural-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="procedural-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
