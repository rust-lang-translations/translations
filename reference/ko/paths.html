<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>경로 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/paths.md`;
                    } else {
                        canonical_href = `${base}/${lang}/paths.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/paths.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-paths"><a class="rule-link" href="#r-paths" title="paths"><span>[paths]<span/></a></div>
<h1 id="경로"><a class="header" href="#경로">경로</a></h1>
<div class="rule" id="r-paths.intro"><a class="rule-link" href="#r-paths.intro" title="paths.intro"><span>[paths<wbr>.intro]<span/></a></div>
<p>_경로(path)_는 <code>::</code> 토큰으로 구분된 하나 이상의 경로 세그먼트 시퀀스입니다. 경로는 <a href="items.html">아이템</a>, 값, <a href="types.html">타입</a>, <a href="macros.html">매크로</a> 및 <a href="attributes.html">속성</a>을 참조하는 데 사용됩니다.</p>
<p>식별자 세그먼트로만 구성된 단순 경로의 두 가지 예:</p>
<!-- ignore: syntax fragment -->
<pre><code class="language-rust ignore">x;
x::y::z;</code></pre>
<h2 id="경로의-종류"><a class="header" href="#경로의-종류">경로의 종류</a></h2>
<div class="rule" id="r-paths.simple"><a class="rule-link" href="#r-paths.simple" title="paths.simple"><span>[paths<wbr>.simple]<span/></a></div>
<h3 id="단순-경로"><a class="header" href="#단순-경로">단순 경로</a></h3>
<div class="rule" id="r-paths.simple.syntax"><a class="rule-link" href="#r-paths.simple.syntax" title="paths.simple.syntax"><span>[paths<wbr>.simple<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>SimplePath</em> :<br />
   <code>::</code><sup>?</sup> <em>SimplePathSegment</em> (<code>::</code> <em>SimplePathSegment</em>)<sup>*</sup></p>
<p><em>SimplePathSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>crate</code> | <code>$crate</code></p>
</blockquote>
<div class="rule" id="r-paths.simple.intro"><a class="rule-link" href="#r-paths.simple.intro" title="paths.simple.intro"><span>[paths<wbr>.simple<wbr>.intro]<span/></a></div>
<p>단순 경로는 <a href="visibility-and-privacy.html">가시성</a> 표시어, <a href="attributes.html">속성</a>, <a href="macros-by-example.html">매크로</a> 및 <a href="items/use-declarations.html"><code>use</code></a> 아이템에서 사용됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = "0"]
    pub (in super) fn f1() {}
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.expr"><a class="rule-link" href="#r-paths.expr" title="paths.expr"><span>[paths<wbr>.expr]<span/></a></div>
<h3 id="표현식에서의-경로"><a class="header" href="#표현식에서의-경로">표현식에서의 경로</a></h3>
<div class="rule" id="r-paths.expr.syntax"><a class="rule-link" href="#r-paths.expr.syntax" title="paths.expr.syntax"><span>[paths<wbr>.expr<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>PathInExpression</em> :<br />
   <code>::</code><sup>?</sup> <em>PathExprSegment</em> (<code>::</code> <em>PathExprSegment</em>)<sup>*</sup></p>
<p><em>PathExprSegment</em> :<br />
   <em>PathIdentSegment</em> (<code>::</code> <em>GenericArgs</em>)<sup>?</sup></p>
<p><em>PathIdentSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>Self</code> | <code>crate</code> | <code>$crate</code></p>
<p><em>GenericArgs</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
   | <code>&lt;</code> ( <em>GenericArg</em> <code>,</code> )<sup>*</sup> <em>GenericArg</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>GenericArg</em> :<br />
   <a href="trait-bounds.html"><em>Lifetime</em></a> | <a href="types.html#type-expressions"><em>Type</em></a> | <em>GenericArgsConst</em> | <em>GenericArgsBinding</em> | <em>GenericArgsBounds</em></p>
<p><em>GenericArgsConst</em> :<br />
      <a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
   | <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
   | <code>-</code> <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
   | <a href="#simple-paths"><em>SimplePathSegment</em></a></p>
<p><em>GenericArgsBinding</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> <em>GenericArgs</em><sup>?</sup> <code>=</code> <a href="types.html#type-expressions"><em>Type</em></a></p>
<p><em>GenericArgsBounds</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> <em>GenericArgs</em><sup>?</sup> <code>:</code> <a href="trait-bounds.html"><em>TypeParamBounds</em></a></p>
</blockquote>
<div class="rule" id="r-paths.expr.intro"><a class="rule-link" href="#r-paths.expr.intro" title="paths.expr.intro"><span>[paths<wbr>.expr<wbr>.intro]<span/></a></div>
<p>표현식에서의 경로는 제네릭 인자가 포함된 경로를 지정할 수 있게 해줍니다. 이들은 <a href="expressions.html">표현식</a>과 <a href="patterns.html">패턴</a>의 다양한 곳에서 사용됩니다.</p>
<div class="rule" id="r-paths.expr.turbofish"><a class="rule-link" href="#r-paths.expr.turbofish" title="paths.expr.turbofish"><span>[paths<wbr>.expr<wbr>.turbofish]<span/></a></div>
<p>제네릭 인자를 위한 여는 <code>&lt;</code> 앞에는 작음(less-than) 연산자와의 모호성을 피하기 위해 <code>::</code> 토큰이 필요합니다. 이것은 구어체로 “터보피쉬(turbofish)” 구문이라고 알려져 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.expr.argument-order"><a class="rule-link" href="#r-paths.expr.argument-order" title="paths.expr.argument-order"><span>[paths<wbr>.expr<wbr>.argument-order]<span/></a></div>
<p>제네릭 인자의 순서는 라이프타임 인자, 그 다음 타입 인자, 그 다음 상수 인자, 그 다음 등치 제약 조건(equality constraints) 순으로 제한됩니다.</p>
<div class="rule" id="r-paths.expr.complex-const-params"><a class="rule-link" href="#r-paths.expr.complex-const-params" title="paths.expr.complex-const-params"><span>[paths<wbr>.expr<wbr>.complex-const-params]<span/></a></div>
<p>상수 인자가 <a href="expressions/literal-expr.html">리터럴</a>이거나 단일 세그먼트 경로가 아닌 경우에는 중괄호로 둘러싸야 합니다.</p>
<div class="rule" id="r-paths.expr.impl-trait-params"><a class="rule-link" href="#r-paths.expr.impl-trait-params" title="paths.expr.impl-trait-params"><span>[paths<wbr>.expr<wbr>.impl-trait-params]<span/></a></div>
<p><code>impl Trait</code> 타입에 대응하는 합성 타입 파라미터(synthetic type parameters)는 암시적이며, 이를 명시적으로 지정할 수 없습니다.</p>
<div class="rule" id="r-paths.qualified"><a class="rule-link" href="#r-paths.qualified" title="paths.qualified"><span>[paths<wbr>.qualified]<span/></a></div>
<h2 id="정규화된-경로qualified-paths"><a class="header" href="#정규화된-경로qualified-paths">정규화된 경로(Qualified paths)</a></h2>
<div class="rule" id="r-paths.qualified.syntax"><a class="rule-link" href="#r-paths.qualified.syntax" title="paths.qualified.syntax"><span>[paths<wbr>.qualified<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>QualifiedPathInExpression</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>PathExprSegment</em>)<sup>+</sup></p>
<p><em>QualifiedPathType</em> :<br />
   <code>&lt;</code> <a href="types.html#type-expressions"><em>Type</em></a> (<code>as</code> <em>TypePath</em>)<sup>?</sup> <code>&gt;</code></p>
<p><em>QualifiedPathInType</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>TypePathSegment</em>)<sup>+</sup></p>
</blockquote>
<div class="rule" id="r-paths.qualified.intro"><a class="rule-link" href="#r-paths.qualified.intro" title="paths.qualified.intro"><span>[paths<wbr>.qualified<wbr>.intro]<span/></a></div>
<p>완전하게 정규화된 경로(Fully qualified paths)는 <a href="items/implementations.html#trait-implementations">트레잇 구현</a>에 대한 경로의 모호성을 제거하고 <a href="#canonical-paths">표준 경로(canonical paths)</a>를 지정할 수 있게 해줍니다. 타입 명세에서 사용될 때는 아래에 명시된 타입 구문을 사용하는 것을 지원합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S;
impl S {
    fn f() { println!("S"); }
}
trait T1 {
    fn f() { println!("T1 f"); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!("T2 f"); }
}
impl T2 for S {}
S::f();  // 내재적 구현(inherent impl)을 호출합니다.
&lt;S as T1&gt;::f();  // T1 트레잇 함수를 호출합니다.
&lt;S as T2&gt;::f();  // T2 트레잇 함수를 호출합니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.type"><a class="rule-link" href="#r-paths.type" title="paths.type"><span>[paths<wbr>.type]<span/></a></div>
<h3 id="타입에서의-경로"><a class="header" href="#타입에서의-경로">타입에서의 경로</a></h3>
<div class="rule" id="r-paths.type.syntax"><a class="rule-link" href="#r-paths.type.syntax" title="paths.type.syntax"><span>[paths<wbr>.type<wbr>.syntax]<span/></a></div>
<blockquote>
<p><strong><sup>구문</sup></strong><br />
<em>TypePath</em> :<br />
   <code>::</code><sup>?</sup> <em>TypePathSegment</em> (<code>::</code> <em>TypePathSegment</em>)<sup>*</sup></p>
<p><em>TypePathSegment</em> :<br />
   <em>PathIdentSegment</em> (<code>::</code><sup>?</sup> (<a href="#paths-in-expressions"><em>GenericArgs</em></a> | <em>TypePathFn</em>))<sup>?</sup></p>
<p><em>TypePathFn</em> :<br />
<code>(</code> <em>TypePathFnInputs</em><sup>?</sup> <code>)</code> (<code>-&gt;</code> <a href="types.html#type-expressions"><em>TypeNoBounds</em></a>)<sup>?</sup></p>
<p><em>TypePathFnInputs</em> :<br />
<a href="types.html#type-expressions"><em>Type</em></a> (<code>,</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<div class="rule" id="r-paths.type.intro"><a class="rule-link" href="#r-paths.type.intro" title="paths.type.intro"><span>[paths<wbr>.type<wbr>.intro]<span/></a></div>
<p>타입 경로는 타입 정의, 트레잇 바운드, 타입 파라미터 바운드 및 정규화된 경로 내에서 사용됩니다.</p>
<div class="rule" id="r-paths.type.turbofish"><a class="rule-link" href="#r-paths.type.turbofish" title="paths.type.turbofish"><span>[paths<wbr>.type<wbr>.turbofish]<span/></a></div>
<p>제네릭 인자 앞에 <code>::</code> 토큰을 사용할 수 있지만, _PathInExpression_에서와 같은 모호성이 없기 때문에 필수사항은 아닙니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ops {
</span><span class="boring">    pub struct Range&lt;T&gt; {f1: T}
</span><span class="boring">    pub trait Index&lt;T&gt; {}
</span><span class="boring">    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
</span><span class="boring">}
</span><span class="boring">struct S;
</span>impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
<span class="boring">   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
</span><span class="boring">   EXAMPLE.into_iter()
</span>}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers"><a class="rule-link" href="#r-paths.qualifiers" title="paths.qualifiers"><span>[paths<wbr>.qualifiers]<span/></a></div>
<h2 id="경로-한정자path-qualifiers"><a class="header" href="#경로-한정자path-qualifiers">경로 한정자(Path qualifiers)</a></h2>
<p>경로는 해석 방식의 의미를 변경하기 위해 앞에 다양한 한정자를 붙여 표시할 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.global-root"><a class="rule-link" href="#r-paths.qualifiers.global-root" title="paths.qualifiers.global-root"><span>[paths<wbr>.qualifiers<wbr>.global-root]<span/></a></div>
<h3 id=""><a class="header" href="#"><code>::</code></a></h3>
<div class="rule" id="r-paths.qualifiers.global-root.intro"><a class="rule-link" href="#r-paths.qualifiers.global-root.intro" title="paths.qualifiers.global-root.intro"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.intro]<span/></a></div>
<p><code>::</code>로 시작하는 경로는 _전역 경로(global paths)_로 간주되며, 경로의 세그먼트가 해석되기 시작하는 위치는 에디션에 따라 다릅니다. 경로의 각 식별자는 아이템으로 해석되어야 합니다.</p>
<div class="rule" id="r-paths.qualifiers.global-root.edition2015"><a class="rule-link" href="#r-paths.qualifiers.global-root.edition2015" title="paths.qualifiers.global-root.edition2015"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.edition2015]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2015 에디션에서 식별자는 “크레이트 루트(crate root)”(2018 에디션의 <code>crate::</code>)에서 해석됩니다. 여기에는 외부 크레이트, <code>std</code> 또는 <code>core</code>와 같은 기본 크레이트, 그리고 크레이트 최상위 레벨의 아이템들(<code>use</code> 임포트 포함)을 포함한 다양한 아이템들이 들어 있습니다.</p>
<p>2018 에디션부터 <code>::</code>로 시작하는 경로는 <a href="names/preludes.html#extern-prelude">외부 프렐류드(extern prelude)</a>에 있는 크레이트에서 해석됩니다. 즉, 그 뒤에는 반드시 크레이트 이름이 와야 합니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {
    // 2018 에디션에서는 외부 프렐류드를 통해 `std`에 접근합니다.
    // 2015 에디션에서는 크레이트 루트를 통해 `std`에 접근합니다.
    let now = ::std::time::Instant::now();
    println!("{:?}", now);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2015">// 2015 에디션
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // `a`의 foo 함수를 호출합니다.
        // Rust 2018에서 `::a`는 크레이트 `a`로 해석됩니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.mod-self"><a class="rule-link" href="#r-paths.qualifiers.mod-self" title="paths.qualifiers.mod-self"><span>[paths<wbr>.qualifiers<wbr>.mod-self]<span/></a></div>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<div class="rule" id="r-paths.qualifiers.mod-self.intro"><a class="rule-link" href="#r-paths.qualifiers.mod-self.intro" title="paths.qualifiers.mod-self.intro"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.intro]<span/></a></div>
<p><code>self</code>는 현재 모듈을 기준으로 상대적인 경로를 해석합니다.</p>
<div class="rule" id="r-paths.qualifiers.mod-self.restriction"><a class="rule-link" href="#r-paths.qualifiers.mod-self.restriction" title="paths.qualifiers.mod-self.restriction"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.restriction]<span/></a></div>
<p><code>self</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.self-pat"><a class="rule-link" href="#r-paths.qualifiers.self-pat" title="paths.qualifiers.self-pat"><span>[paths<wbr>.qualifiers<wbr>.self-pat]<span/></a></div>
<p>메서드 본문에서 단일 <code>self</code> 세그먼트로 구성된 경로는 해당 메서드의 self 파라미터로 해석됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
fn bar() {
    self::foo();
}
struct S(bool);
impl S {
  fn baz(self) {
        self.0;
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.type-self"><a class="rule-link" href="#r-paths.qualifiers.type-self" title="paths.qualifiers.type-self"><span>[paths<wbr>.qualifiers<wbr>.type-self]<span/></a></div>
<h3 id="self-1"><a class="header" href="#self-1"><code>Self</code></a></h3>
<div class="rule" id="r-paths.qualifiers.type-self.intro"><a class="rule-link" href="#r-paths.qualifiers.type-self.intro" title="paths.qualifiers.type-self.intro"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.intro]<span/></a></div>
<p>대문자 “S“로 시작하는 <code>Self</code>는 현재 구현되거나 정의되고 있는 타입을 참조하는 데 사용됩니다. 다음과 같은 상황에서 사용될 수 있습니다:</p>
<div class="rule" id="r-paths.qualifiers.type-self.trait"><a class="rule-link" href="#r-paths.qualifiers.type-self.trait" title="paths.qualifiers.type-self.trait"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.trait]<span/></a></div>
<ul>
<li><a href="items/traits.html">트레잇(trait)</a> 정의에서, 이는 해당 트레잇을 구현하는 타입을 참조합니다.</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.impl"><a class="rule-link" href="#r-paths.qualifiers.type-self.impl" title="paths.qualifiers.type-self.impl"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.impl]<span/></a></div>
<ul>
<li><a href="items/implementations.html">구현(implementation)</a>에서, 이는 구현되고 있는 타입을 참조합니다. 튜플 또는 유닛 <a href="items/structs.html">구조체(struct)</a>를 구현할 때는 <a href="names/namespaces.html">값 네임스페이스</a>의 생성자도 참조합니다.</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.type"><a class="rule-link" href="#r-paths.qualifiers.type-self.type" title="paths.qualifiers.type-self.type"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.type]<span/></a></div>
<ul>
<li><a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형(enumeration)</a> 또는 <a href="items/unions.html">공용체(union)</a>의 정의에서, 이는 정의되고 있는 타입을 참조합니다. 정의가 무한히 재귀적일 수는 없습니다(반드시 간접 참조(indirection)가 있어야 합니다).</li>
</ul>
<div class="rule" id="r-paths.qualifiers.type-self.scope"><a class="rule-link" href="#r-paths.qualifiers.type-self.scope" title="paths.qualifiers.type-self.scope"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.scope]<span/></a></div>
<p><code>Self</code>의 스코프는 제네릭 파라미터와 유사하게 동작합니다. 자세한 내용은 <a href="names/scopes.html#self-scope"><code>Self</code> 스코프</a> 섹션을 참조하십시오.</p>
<div class="rule" id="r-paths.qualifiers.type-self.allowed-positions"><a class="rule-link" href="#r-paths.qualifiers.type-self.allowed-positions" title="paths.qualifiers.type-self.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.allowed-positions]<span/></a></div>
<p><code>Self</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.type-self.no-generics"><a class="rule-link" href="#r-paths.qualifiers.type-self.no-generics" title="paths.qualifiers.type-self.no-generics"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.no-generics]<span/></a></div>
<p><code>Self</code> 경로는 (<code>Self::&lt;i32&gt;</code>와 같이) 제네릭 인자를 포함할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    type Item;
    const C: i32;
    // `Self`는 `T`를 구현하는 어떤 타입이든 될 수 있습니다.
    fn new() -&gt; Self;
    // `Self::Item`은 구현체에서의 타입 별칭(type alias)이 됩니다.
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self`는 `S` 타입입니다.
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item`은 `i32` 타입입니다.
        Self::C                  // `Self::C`는 상수 값 `9`입니다.
    }
}

// `Self`는 트레잇 정의의 제네릭 내에서 스코프에 있으며,
// 정의되고 있는 타입을 참조합니다.
trait Add&lt;Rhs = Self&gt; {
    type Output;
    // `Self`는 또한 구현되고 있는 타입의
    // 연관 아이템을 참조할 수 있습니다.
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct NonEmptyList&lt;T&gt; {
    head: T,
    // 구조체는 자기 자신을 참조할 수 있습니다(무한히
    // 재귀적이지 않은 한).
    tail: Option&lt;Box&lt;Self&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.super"><a class="rule-link" href="#r-paths.qualifiers.super" title="paths.qualifiers.super"><span>[paths<wbr>.qualifiers<wbr>.super]<span/></a></div>
<h3 id="super"><a class="header" href="#super"><code>super</code></a></h3>
<div class="rule" id="r-paths.qualifiers.super.intro"><a class="rule-link" href="#r-paths.qualifiers.super.intro" title="paths.qualifiers.super.intro"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.intro]<span/></a></div>
<p>경로에서의 <code>super</code>는 부모 모듈로 해석됩니다.</p>
<div class="rule" id="r-paths.qualifiers.super.allowed-positions"><a class="rule-link" href="#r-paths.qualifiers.super.allowed-positions" title="paths.qualifiers.super.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.allowed-positions]<span/></a></div>
<p>이는 경로의 앞부분 세그먼트에서만 사용될 수 있으며, 초기 <code>self</code> 세그먼트 뒤에 올 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // a의 foo 함수를 호출합니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.super.repetition"><a class="rule-link" href="#r-paths.qualifiers.super.repetition" title="paths.qualifiers.super.repetition"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.repetition]<span/></a></div>
<p><code>super</code>는 조상 모듈을 참조하기 위해 첫 번째 <code>super</code> 또는 <code>self</code> 뒤에 여러 번 반복될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // a의 foo 함수를 호출합니다.
                self::super::super::foo(); // a의 foo 함수를 호출합니다.
            }
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.crate"><a class="rule-link" href="#r-paths.qualifiers.crate" title="paths.qualifiers.crate"><span>[paths<wbr>.qualifiers<wbr>.crate]<span/></a></div>
<h3 id="crate"><a class="header" href="#crate"><code>crate</code></a></h3>
<div class="rule" id="r-paths.qualifiers.crate.intro"><a class="rule-link" href="#r-paths.qualifiers.crate.intro" title="paths.qualifiers.crate.intro"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.intro]<span/></a></div>
<p><code>crate</code>는 현재 크레이트를 기준으로 상대적인 경로를 해석합니다.</p>
<div class="rule" id="r-paths.qualifiers.crate.allowed-positions"><a class="rule-link" href="#r-paths.qualifiers.crate.allowed-positions" title="paths.qualifiers.crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.allowed-positions]<span/></a></div>
<p><code>crate</code>는 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="rule" id="r-paths.qualifiers.macro-crate"><a class="rule-link" href="#r-paths.qualifiers.macro-crate" title="paths.qualifiers.macro-crate"><span>[paths<wbr>.qualifiers<wbr>.macro-crate]<span/></a></div>
<h3 id="crate-1"><a class="header" href="#crate-1"><code>$crate</code></a></h3>
<div class="rule" id="r-paths.qualifiers.macro-crate.allowed-positions"><a class="rule-link" href="#r-paths.qualifiers.macro-crate.allowed-positions" title="paths.qualifiers.macro-crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.allowed-positions]<span/></a></div>
<p><code>$crate</code>는 <a href="macros-by-example.html">매크로 전사기(macro transcribers)</a> 내에서만 사용되며, 앞에 <code>::</code> 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다.</p>
<div class="rule" id="r-paths.qualifiers.macro-crate.hygiene"><a class="rule-link" href="#r-paths.qualifiers.macro-crate.hygiene" title="paths.qualifiers.macro-crate.hygiene"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.hygiene]<span/></a></div>
<p><code>$crate</code>는 매크로가 호출된 크레이트에 관계없이, 매크로가 정의된 크레이트의 최상위 레벨에 있는 아이템에 접근하기 위한 경로로 확장됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">fn main() { }</span></code></pre></pre>
<div class="rule" id="r-paths.canonical"><a class="rule-link" href="#r-paths.canonical" title="paths.canonical"><span>[paths<wbr>.canonical]<span/></a></div>
<h2 id="표준-경로canonical-paths"><a class="header" href="#표준-경로canonical-paths">표준 경로(Canonical paths)</a></h2>
<div class="rule" id="r-paths.canonical.intro"><a class="rule-link" href="#r-paths.canonical.intro" title="paths.canonical.intro"><span>[paths<wbr>.canonical<wbr>.intro]<span/></a></div>
<p>모듈이나 구현체에 정의된 아이템은 해당 크레이트 내의 정의된 위치에 대응하는 _표준 경로(canonical path)_를 갖습니다.</p>
<div class="rule" id="r-paths.canonical.alias"><a class="rule-link" href="#r-paths.canonical.alias" title="paths.canonical.alias"><span>[paths<wbr>.canonical<wbr>.alias]<span/></a></div>
<p>이러한 아이템들에 대한 다른 모든 경로들은 별칭(aliases)입니다.</p>
<div class="rule" id="r-paths.canonical.def"><a class="rule-link" href="#r-paths.canonical.def" title="paths.canonical.def"><span>[paths<wbr>.canonical<wbr>.def]<span/></a></div>
<p>표준 경로는 아이템 자체가 정의하는 경로 세그먼트가 추가된 _경로 접두사(path prefix)_로 정의됩니다.</p>
<div class="rule" id="r-paths.canonical.non-canonical"><a class="rule-link" href="#r-paths.canonical.non-canonical" title="paths.canonical.non-canonical"><span>[paths<wbr>.canonical<wbr>.non-canonical]<span/></a></div>
<p><a href="items/implementations.html">구현체(Implementations)</a>와 <a href="items/use-declarations.html">use 선언(use declarations)</a>은 표준 경로를 갖지 않지만, 구현체가 정의하는 아이템들은 표준 경로를 갖습니다. 블록 표현식에 정의된 아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 모듈에 정의된 아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 아이템(예: 구현하는 타입, 구현되는 트레잇, 타입 파라미터 또는 타입 파라미터의 바운드)을 참조하는 구현체에 정의된 연관 아이템들은 표준 경로를 갖지 않습니다.</p>
<div class="rule" id="r-paths.canonical.module-prefix"><a class="rule-link" href="#r-paths.canonical.module-prefix" title="paths.canonical.module-prefix"><span>[paths<wbr>.canonical<wbr>.module-prefix]<span/></a></div>
<p>모듈의 경로 접두사는 해당 모듈에 대한 표준 경로입니다.</p>
<div class="rule" id="r-paths.canonical.bare-impl-prefix"><a class="rule-link" href="#r-paths.canonical.bare-impl-prefix" title="paths.canonical.bare-impl-prefix"><span>[paths<wbr>.canonical<wbr>.bare-impl-prefix]<span/></a></div>
<p>단순 구현체(bare implementations)의 경우, 구현되고 있는 아이템의 표준 경로를 <span class="parenthetical">화살괄호(<code>&lt;&gt;</code>)</span>로 둘러싼 형태가 접두사가 됩니다.</p>
<div class="rule" id="r-paths.canonical.trait-impl-prefix"><a class="rule-link" href="#r-paths.canonical.trait-impl-prefix" title="paths.canonical.trait-impl-prefix"><span>[paths<wbr>.canonical<wbr>.trait-impl-prefix]<span/></a></div>
<p><a href="items/implementations.html#trait-implementations">트레잇 구현체(trait implementations)</a>의 경우, 구현되고 있는 아이템의 표준 경로 뒤에 <code>as</code>와 트레잇의 표준 경로를 붙인 후 전체를 <span class="parenthetical">화살괄호(<code>&lt;&gt;</code>)</span>로 둘러싼 형태가 접두사가 됩니다.</p>
<div class="rule" id="r-paths.canonical.local-canonical-path"><a class="rule-link" href="#r-paths.canonical.local-canonical-path" title="paths.canonical.local-canonical-path"><span>[paths<wbr>.canonical<wbr>.local-canonical-path]<span/></a></div>
<p>표준 경로는 오직 주어진 크레이트 내에서만 의미가 있습니다. 크레이트들 사이에 공통된 전역 네임스페이스는 존재하지 않습니다. 아이템의 표준 경로는 단지 크레이트 내에서 아이템을 식별할 뿐입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 주석은 아이템의 표준 경로를 나타냅니다.

mod a { // crate::a
    pub struct Struct; // crate::a::Struct

    pub trait Trait { // crate::a::Trait
        fn f(&amp;self); // crate::a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;crate::a::Struct as crate::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;crate::a::Struct&gt;::g
    }
}

mod without { // crate::without
    fn canonicals() { // crate::without::canonicals
        struct OtherStruct; // 없음(None)

        trait OtherTrait { // 없음(None)
            fn g(&amp;self); // 없음(None)
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl OtherTrait for crate::a::Struct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl crate::a::Trait for OtherStruct {
            fn f(&amp;self) {} // 없음(None)
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="names/preludes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="names/name-resolution.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="names/preludes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="names/name-resolution.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
