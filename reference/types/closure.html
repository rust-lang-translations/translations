<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closure types - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/types/closure.md`;
                    } else {
                        canonical_href = `${base}/${lang}/types/closure.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/types/closure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-type.closure"><a class="rule-link" href="#r-type.closure" title="type.closure"><span>[type<wbr>.closure]<span/></a></div>
<h1 id="closure-types"><a class="header" href="#closure-types">Closure types</a></h1>
<div class="rule" id="r-type.closure.intro"><a class="rule-link" href="#r-type.closure.intro" title="type.closure.intro"><span>[type<wbr>.closure<wbr>.intro]<span/></a></div>
<p>A <a href="../expressions/closure-expr.html">closure expression</a> produces a closure value with a unique, anonymous type that cannot be written out.
A closure type is approximately equivalent to a struct which contains the captured values.
For instance, the following closure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // Prints "Point { x: 2, y: 1 }".
<span class="boring">}</span></code></pre></pre>
<p>generates a closure type roughly like the following:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// Note: This is not exactly how it is translated, this is only for
// illustration.

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>so that the call to <code>f</code> works as if it were:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">// Note: This is not valid Rust due to the duplicate mutable borrows.
// This is only provided as an illustration.
f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.left_top.x });</code></pre>
<div class="rule" id="r-type.closure.capture"><a class="rule-link" href="#r-type.closure.capture" title="type.closure.capture"><span>[type<wbr>.closure<wbr>.capture]<span/></a></div>
<h2 id="capture-modes"><a class="header" href="#capture-modes">Capture modes</a></h2>
<div class="rule" id="r-type.closure.capture.intro"><a class="rule-link" href="#r-type.closure.capture.intro" title="type.closure.capture.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.intro]<span/></a></div>
<p>A <em>capture mode</em> determines how a <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a> from the environment is borrowed or moved into the closure.
The capture modes are:</p>
<ol>
<li>Immutable borrow (<code>ImmBorrow</code>) — The place expression is captured as a <a href="pointer.html#references--and-mut">shared reference</a>.</li>
<li>Unique immutable borrow (<code>UniqueImmBorrow</code>) — This is similar to an immutable borrow, but must be unique as described <a href="#unique-immutable-borrows-in-captures">below</a>.</li>
<li>Mutable borrow (<code>MutBorrow</code>) — The place expression is captured as a <a href="pointer.html#mutable-references-mut">mutable reference</a>.</li>
<li>Move (<code>ByValue</code>) — The place expression is captured by <a href="../expressions.html#moved-and-copied-types">moving the value</a> into the closure.</li>
</ol>
<div class="rule" id="r-type.closure.capture.precedence"><a class="rule-link" href="#r-type.closure.capture.precedence" title="type.closure.capture.precedence"><span>[type<wbr>.closure<wbr>.capture<wbr>.precedence]<span/></a></div>
<p>Place expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body.
The mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.</p>
<div class="rule" id="r-type.closure.capture.copy"><a class="rule-link" href="#r-type.closure.capture.copy" title="type.closure.capture.copy"><span>[type<wbr>.closure<wbr>.capture<wbr>.copy]<span/></a></div>
<h3 id="copy-values"><a class="header" href="#copy-values"><code>Copy</code> values</a></h3>
<p>Values that implement <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> that are moved into the closure are captured with the <code>ImmBorrow</code> mode.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x captured by ImmBorrow
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.async.input"><a class="rule-link" href="#r-type.closure.async.input" title="type.closure.async.input"><span>[type<wbr>.closure<wbr>.async<wbr>.input]<span/></a></div>
<h3 id="async-input-capture"><a class="header" href="#async-input-capture">Async input capture</a></h3>
<p>Async closures always capture all input arguments, regardless of whether or not they are used within the body.</p>
<h2 id="capture-precision"><a class="header" href="#capture-precision">Capture Precision</a></h2>
<div class="rule" id="r-type.closure.capture.precision.capture-path"><a class="rule-link" href="#r-type.closure.capture.precision.capture-path" title="type.closure.capture.precision.capture-path"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.capture-path]<span/></a></div>
<p>A <em>capture path</em> is a sequence starting with a variable from the environment followed by zero or more place projections that were applied to that variable.</p>
<div class="rule" id="r-type.closure.capture.precision.place-projection"><a class="rule-link" href="#r-type.closure.capture.precision.place-projection" title="type.closure.capture.precision.place-projection"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.place-projection]<span/></a></div>
<p>A <em>place projection</em> is a <a href="../expressions/field-expr.html">field access</a>, <a href="../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index</a>, <a href="../expressions/operator-expr.html#the-dereference-operator">dereference</a> (and automatic dereferences), or <a href="../expressions/array-expr.html#array-and-slice-indexing-expressions">array or slice index</a> expression applied to a variable.</p>
<div class="rule" id="r-type.closure.capture.precision.intro"><a class="rule-link" href="#r-type.closure.capture.precision.intro" title="type.closure.capture.precision.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.intro]<span/></a></div>
<p>The closure borrows or moves the capture path, which may be truncated based on the rules described below.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1 captured by ImmBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<p>Here the capture path is the local variable <code>s</code>, followed by a field access <code>.f1</code>, and then a tuple index <code>.1</code>.
This closure captures an immutable borrow of <code>s.f1.1</code>.</p>
<div class="rule" id="r-type.closure.capture.precision.shared-prefix"><a class="rule-link" href="#r-type.closure.capture.precision.shared-prefix" title="type.closure.capture.precision.shared-prefix"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.shared-prefix]<span/></a></div>
<h3 id="shared-prefix"><a class="header" href="#shared-prefix">Shared prefix</a></h3>
<p>In the case where a capture path and one of the ancestor’s of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, <code>CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)</code>, using the strict weak ordering:</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>Note that this might need to be applied recursively.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In this example, there are three different capture paths with a shared ancestor:
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u captured by ImmBorrow
    u.1.truncate(0); // u.0 captured by MutBorrow
    move_value(u.0.0); // u.0.0 captured by ByValue
};
c();
<span class="boring">}</span></code></pre></pre>
<p>Overall this closure will capture <code>u</code> by <code>ByValue</code>.</p>
<div class="rule" id="r-type.closure.capture.precision.dereference-shared"><a class="rule-link" href="#r-type.closure.capture.precision.dereference-shared" title="type.closure.capture.precision.dereference-shared"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.dereference-shared]<span/></a></div>
<h3 id="rightmost-shared-reference-truncation"><a class="header" href="#rightmost-shared-reference-truncation">Rightmost shared reference truncation</a></h3>
<p>The capture path is truncated at the rightmost dereference in the capture path if the dereference is applied to a shared reference.</p>
<p>This truncation is allowed because fields that are read through a shared reference will always be read via a shared reference or a copy.
This helps reduce the size of the capture when the extra precision does not yield any benefit from a borrow checking perspective.</p>
<p>The reason it is the <em>rightmost</em> dereference is to help avoid a shorter lifetime than is necessary.
Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre></pre>
<p>If this were to capture <code>m</code>, then the closure would no longer outlive <code>'static</code>, since <code>m</code> is constrained to <code>'a</code>. Instead, it captures <code>(*(*m).a)</code> by <code>ImmBorrow</code>.</p>
<div class="rule" id="r-type.closure.capture.precision.wildcard"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard" title="type.closure.capture.precision.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard]<span/></a></div>
<h3 id="wildcard-pattern-bindings"><a class="header" href="#wildcard-pattern-bindings">Wildcard pattern bindings</a></h3>
<p>Closures only capture data that needs to be read.
Binding a value with a <a href="../patterns.html#wildcard-pattern">wildcard pattern</a> does not count as a read, and thus won’t be captured.
For example, the following closures will not capture <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = String::from("hello");
let c = || {
    let _ = x;  // x is not captured
};
c();

let c = || match x {  // x is not captured
    _ =&gt; println!("Hello World!")
};
c();
<span class="boring">}</span></code></pre></pre>
<p>This also includes destructuring of tuples, structs, and enums.
Fields matched with the <a href="../patterns.html#rest-patterns"><em>RestPattern</em></a> or <a href="../patterns.html#struct-patterns"><em>StructPatternEtCetera</em></a> are also not considered as read, and thus those fields will not be captured.
The following illustrates some of these:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (String::from("a"), String::from("b"));
let c = || {
    let (first, ..) = x;  // captures `x.0` ByValue
};
// The first tuple field has been moved into the closure.
// The second tuple field is still accessible.
println!("{:?}", x.1);
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example {
    f1: String,
    f2: String,
}

let e = Example {
    f1: String::from("first"),
    f2: String::from("second"),
};
let c = || {
    let Example { f2, .. } = e; // captures `e.f2` ByValue
};
// Field f2 cannot be accessed since it is moved into the closure.
// Field f1 is still accessible.
println!("{:?}", e.f1);
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.array-slice"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.array-slice" title="type.closure.capture.precision.wildcard.array-slice"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.array-slice]<span/></a></div>
<p>Partial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.
For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Example;
let x = [Example, Example];

let c = || {
    let [first, _] = x; // captures all of `x` ByValue
};
c();
println!("{:?}", x[1]); // ERROR: borrow of moved value: `x`
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.initialized"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.initialized" title="type.closure.capture.precision.wildcard.initialized"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.initialized]<span/></a></div>
<p>Values that are matched with wildcards must still be initialized.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;
let c = || {
    let _ = x; // ERROR: used binding `x` isn't initialized
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.move-dereference"><a class="rule-link" href="#r-type.closure.capture.precision.move-dereference" title="type.closure.capture.precision.move-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.move-dereference]<span/></a></div>
<h3 id="capturing-references-in-move-contexts"><a class="header" href="#capturing-references-in-move-contexts">Capturing references in move contexts</a></h3>
<p>Because it is not allowed to move fields out of a reference, <code>move</code> closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a reference.
The reference itself will be moved into the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // captures `t_mut_ref` ByValue
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.raw-pointer-dereference"><a class="rule-link" href="#r-type.closure.capture.precision.raw-pointer-dereference" title="type.closure.capture.precision.raw-pointer-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.raw-pointer-dereference]<span/></a></div>
<h3 id="raw-pointer-dereference"><a class="header" href="#raw-pointer-dereference">Raw pointer dereference</a></h3>
<p>Because it is <code>unsafe</code> to dereference a raw pointer, closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a raw pointer.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // captures `t_ptr` by ImmBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.union"><a class="rule-link" href="#r-type.closure.capture.precision.union" title="type.closure.capture.precision.union"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.union]<span/></a></div>
<h3 id="union-fields"><a class="header" href="#union-fields">Union fields</a></h3>
<p>Because it is <code>unsafe</code> to access a union field, closures will only capture the prefix of a capture path that runs up to the union itself.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // captures `u` ByValue
};
c();

// This also includes writing to fields.
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // captures `u` with MutBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.unaligned"><a class="rule-link" href="#r-type.closure.capture.precision.unaligned" title="type.closure.capture.precision.unaligned"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.unaligned]<span/></a></div>
<h3 id="reference-into-unaligned-structs"><a class="header" href="#reference-into-unaligned-structs">Reference into unaligned <code>struct</code>s</a></h3>
<p>Because it is <a href="../behavior-considered-undefined.html">undefined behavior</a> to create references to unaligned fields in a structure,
closures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses <a href="../type-layout.html#the-alignment-modifiers">the <code>packed</code> representation</a>.
This includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // captures `t` with ImmBorrow
};
// Copies out of `t` are ok.
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre></pre>
<p>Similarly, taking the address of an unaligned field also captures the entire struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // captures `t` with ImmBorrow
};
let a = t.0; // ERROR: cannot move out of `t.0` because it is borrowed
c();
<span class="boring">}</span></code></pre></pre>
<p>but the above works if it is not packed since it captures the field precisely:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // captures `t.1` with ImmBorrow
};
// The move here is allowed.
let a = t.0;
c();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-deref"><a class="rule-link" href="#r-type.closure.capture.precision.box-deref" title="type.closure.capture.precision.box-deref"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-deref]<span/></a></div>
<h3 id="box-vs-other-deref-implementations"><a class="header" href="#box-vs-other-deref-implementations"><code>Box</code> vs other <code>Deref</code> implementations</a></h3>
<p>The implementation of the <a href="../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> trait for <a href="../special-types-and-traits.html#boxt"><code>Box</code></a> is treated differently from other <code>Deref</code> implementations, as it is considered a special entity.</p>
<p>For example, let us look at examples involving <code>Rc</code> and <code>Box</code>. The <code>*rc</code> is desugared to a call to the trait method <code>deref</code> defined on <code>Rc</code>, but since <code>*box</code> is treated differently, it is possible to do a precise capture of the contents of the <code>Box</code>.</p>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.not-moved"><a class="rule-link" href="#r-type.closure.capture.precision.box-non-move.not-moved" title="type.closure.capture.precision.box-non-move.not-moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.not-moved]<span/></a></div>
<h4 id="box-with-non-move-closure"><a class="header" href="#box-with-non-move-closure"><code>Box</code> with non-<code>move</code> closure</a></h4>
<p>In a non-<code>move</code> closure, if the contents of the <code>Box</code> are not moved into the closure body, the contents of the <code>Box</code> are precisely captured.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // captures `(*b).0` by ImmBorrow
};
c_box();

// Contrast `Box` with another type that implements Deref:
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // captures `r` by ImmBorrow
};
c_rc();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.moved"><a class="rule-link" href="#r-type.closure.capture.precision.box-non-move.moved" title="type.closure.capture.precision.box-non-move.moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.moved]<span/></a></div>
<p>However, if the contents of the <code>Box</code> are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is the same as the example above except the closure
// moves the value instead of taking a reference to it.

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // captures `b` with ByValue
};
c_box();
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.box-move.read"><a class="rule-link" href="#r-type.closure.capture.precision.box-move.read" title="type.closure.capture.precision.box-move.read"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-move<wbr>.read]<span/></a></div>
<h4 id="box-with-move-closure"><a class="header" href="#box-with-move-closure"><code>Box</code> with move closure</a></h4>
<p>Similarly to moving contents of a <code>Box</code> in a non-<code>move</code> closure, reading the contents of a <code>Box</code> in a <code>move</code> closure will capture the <code>Box</code> entirely.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // captures `b` with ByValue
};
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.unique-immutable"><a class="rule-link" href="#r-type.closure.unique-immutable" title="type.closure.unique-immutable"><span>[type<wbr>.closure<wbr>.unique-immutable]<span/></a></div>
<h2 id="unique-immutable-borrows-in-captures"><a class="header" href="#unique-immutable-borrows-in-captures">Unique immutable borrows in captures</a></h2>
<p>Captures can occur by a special kind of borrow called a <em>unique immutable borrow</em>,
which cannot be used anywhere else in the language and cannot be written out explicitly.
It occurs when modifying the referent of a mutable reference, as in the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // An ImmBorrow and a MutBorrow of `x`.
    let a = &amp;x;
    *x = true; // `x` captured by UniqueImmBorrow
};
// The following line is an error:
// let y = &amp;x;
c();
// However, the following is OK.
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>.
But at the same time, borrowing <code>x</code> immutably would make the assignment illegal,
because a <code>&amp; &amp;mut</code> reference might not be unique, so it cannot safely be used to modify a value.
So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</p>
<p>In the above example, uncommenting the declaration of <code>y</code> will produce an error because it would violate the uniqueness of the closure’s borrow of <code>x</code>; the declaration of z is valid because the closure’s lifetime has expired at the end of the block, releasing the borrow.</p>
<div class="rule" id="r-type.closure.call"><a class="rule-link" href="#r-type.closure.call" title="type.closure.call"><span>[type<wbr>.closure<wbr>.call]<span/></a></div>
<h2 id="call-traits-and-coercions"><a class="header" href="#call-traits-and-coercions">Call traits and coercions</a></h2>
<div class="rule" id="r-type.closure.call.intro"><a class="rule-link" href="#r-type.closure.call.intro" title="type.closure.call.intro"><span>[type<wbr>.closure<wbr>.call<wbr>.intro]<span/></a></div>
<p>Closure types all implement <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>, indicating that they can be called once
by consuming ownership of the closure. Additionally, some closures implement
more specific call traits:</p>
<div class="rule" id="r-type.closure.call.fn-mut"><a class="rule-link" href="#r-type.closure.call.fn-mut" title="type.closure.call.fn-mut"><span>[type<wbr>.closure<wbr>.call<wbr>.fn-mut]<span/></a></div>
<ul>
<li>A closure which does not move out of any captured variables implements
<a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>, indicating that it can be called by mutable reference.</li>
</ul>
<div class="rule" id="r-type.closure.call.fn"><a class="rule-link" href="#r-type.closure.call.fn" title="type.closure.call.fn"><span>[type<wbr>.closure<wbr>.call<wbr>.fn]<span/></a></div>
<ul>
<li>A closure which does not mutate or move out of any captured variables
implements <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a>, indicating that it can be called by shared reference.</li>
</ul>
<blockquote>
<p>Note: <code>move</code> closures may still implement <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> or <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>, even though
they capture variables by move. This is because the traits implemented by a
closure type are determined by what the closure does with captured values,
not how it captures them.</p>
</blockquote>
<div class="rule" id="r-type.closure.non-capturing"><a class="rule-link" href="#r-type.closure.non-capturing" title="type.closure.non-capturing"><span>[type<wbr>.closure<wbr>.non-capturing]<span/></a></div>
<p><em>Non-capturing closures</em> are closures that don’t capture anything from their
environment. Non-async, non-capturing closures can be coerced to function pointers (e.g., <code>fn()</code>)
with the matching signature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.async.traits"><a class="rule-link" href="#r-type.closure.async.traits" title="type.closure.async.traits"><span>[type<wbr>.closure<wbr>.async<wbr>.traits]<span/></a></div>
<h3 id="async-closure-traits"><a class="header" href="#async-closure-traits">Async closure traits</a></h3>
<div class="rule" id="r-type.closure.async.traits.fn-family"><a class="rule-link" href="#r-type.closure.async.traits.fn-family" title="type.closure.async.traits.fn-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.fn-family]<span/></a></div>
<p>Async closures have a further restriction of whether or not they implement <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> or <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a>.</p>
<p>The <a href="../../core/future/future/trait.Future.html"><code>Future</code></a> returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be <em>lending</em> to its <a href="../../core/future/future/trait.Future.html"><code>Future</code></a> if it has either of the following properties:</p>
<ul>
<li>The <code>Future</code> includes a mutable capture.</li>
<li>The async closure captures by value, except when the value is accessed with a dereference projection.</li>
</ul>
<p>If the async closure is lending to its <code>Future</code>, then <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> and <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> are <em>not</em> implemented. <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> is always implemented.</p>
<blockquote>
<p><strong>Example</strong>: The first clause for a mutable capture can be illustrated with the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x captured with MutBorrow
    };
    takes_callback(c);  // ERROR: async closure does not implement `FnMut`
}
<span class="boring">}</span></code></pre></pre>
<p>The second clause for a regular value capture can be illustrated with the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x captured ByValue
    };
    takes_callback(c);  // ERROR: async closure does not implement `Fn`
}
<span class="boring">}</span></code></pre></pre>
<p>The exception of the the second clause can be illustrated by using a dereference, which does allow <code>Fn</code> and <code>FnMut</code> to be implemented:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK: implements `Fn`
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div class="rule" id="r-type.closure.async.traits.async-family"><a class="rule-link" href="#r-type.closure.async.traits.async-family" title="type.closure.async.traits.async-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.async-family]<span/></a></div>
<p>Async closures implement <a href="../../core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a>, <a href="../../core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a>, and <a href="../../core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a> in an analogous way as regular closures implement <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a>, <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a>, and <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a>; that is, depending on the use of the captured variables in its body.</p>
<div class="rule" id="r-type.closure.traits"><a class="rule-link" href="#r-type.closure.traits" title="type.closure.traits"><span>[type<wbr>.closure<wbr>.traits]<span/></a></div>
<h3 id="other-traits"><a class="header" href="#other-traits">Other traits</a></h3>
<div class="rule" id="r-type.closure.traits.intro"><a class="rule-link" href="#r-type.closure.traits.intro" title="type.closure.traits.intro"><span>[type<wbr>.closure<wbr>.traits<wbr>.intro]<span/></a></div>
<p>All closure types implement <a href="../special-types-and-traits.html#sized"><code>Sized</code></a>. Additionally, closure types implement the
following traits if allowed to do so by the types of the captures it stores:</p>
<ul>
<li><a href="../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<div class="rule" id="r-type.closure.traits.behavior"><a class="rule-link" href="#r-type.closure.traits.behavior" title="type.closure.traits.behavior"><span>[type<wbr>.closure<wbr>.traits<wbr>.behavior]<span/></a></div>
<p>The rules for <a href="../special-types-and-traits.html#send"><code>Send</code></a> and <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> match those for normal struct types, while
<a href="../special-types-and-traits.html#clone"><code>Clone</code></a> and <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> behave as if <a href="../attributes/derive.html">derived</a>. For <a href="../special-types-and-traits.html#clone"><code>Clone</code></a>, the order of
cloning of the captured values is left unspecified.</p>
<p>Because captures are often by reference, the following general rules arise:</p>
<ul>
<li>A closure is <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> if all captured values are <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>.</li>
<li>A closure is <a href="../special-types-and-traits.html#send"><code>Send</code></a> if all values captured by non-unique immutable
reference are <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>, and all values captured by unique immutable or mutable
reference, copy, or move are <a href="../special-types-and-traits.html#send"><code>Send</code></a>.</li>
<li>A closure is <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> if it does not capture any values by
unique immutable or mutable reference, and if all values it captures by copy
or move are <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>, respectively.</li>
</ul>
<div class="rule" id="r-type.closure.drop-order"><a class="rule-link" href="#r-type.closure.drop-order" title="type.closure.drop-order"><span>[type<wbr>.closure<wbr>.drop-order]<span/></a></div>
<h2 id="drop-order"><a class="header" href="#drop-order">Drop Order</a></h2>
<p>If a closure captures a field of a composite types such as structs, tuples, and enums by value, the field’s lifetime would now be tied to the closure. As a result, it is possible for disjoint fields of a composite types to be dropped at different times.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0 is captured into the closure |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c' and 'tuple.0' dropped here ------------+  |
} // tuple.1 dropped here -----------------------------+
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.entirety"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.entirety" title="type.closure.capture.precision.edition2018.entirety"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.entirety]<span/></a></div>
<h2 id="edition-2018-and-before"><a class="header" href="#edition-2018-and-before">Edition 2018 and before</a></h2>
<h3 id="closure-types-difference"><a class="header" href="#closure-types-difference">Closure types difference</a></h3>
<p>In Edition 2018 and before, closures always capture a variable in its entirety, without its precise capture path. This means that for the example used in the <a href="#closure-types">Closure types</a> section, the generated closure type would instead look something like this:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>and the call to <code>f</code> would work as follows:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.composite"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.composite" title="type.closure.capture.precision.edition2018.composite"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.composite]<span/></a></div>
<h3 id="capture-precision-difference"><a class="header" href="#capture-precision-difference">Capture precision difference</a></h3>
<p>Composite types such as structs, tuples, and enums are always captured in its entirety,
not by individual fields. As a result, it may be necessary to borrow into a local variable in order to capture a single field:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If, instead, the closure were to use <code>self.vec</code> directly, then it would attempt to capture <code>self</code> by mutable reference. But since <code>self.set</code> is already borrowed to iterate over, the code would not compile.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.move"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.move" title="type.closure.capture.precision.edition2018.move"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.move]<span/></a></div>
<p>If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code> types, by copy, regardless of whether a borrow would work. The <code>move</code> keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.wildcard"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.wildcard" title="type.closure.capture.precision.edition2018.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.wildcard]<span/></a></div>
<p>Regardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety.</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.drop-order"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.drop-order" title="type.closure.capture.precision.edition2018.drop-order"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.drop-order]<span/></a></div>
<h3 id="drop-order-difference"><a class="header" href="#drop-order-difference">Drop order difference</a></h3>
<p>As composite types are captured in their entirety, a closure which captures one of those composite types by value would drop the entire captured variable at the same time as the closure gets dropped.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple is captured into the closure |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c' and 'tuple' dropped here ------------+
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../types/function-item.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../types/pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../types/function-item.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../types/pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
