<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closure types - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/types/closure.md`;
                    } else {
                        canonical_href = `${base}/${lang}/types/closure.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/types/closure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[type.closure]</p>
<h1 id="closure-types"><a class="header" href="#closure-types">Closure types</a></h1>
<p>r[type.closure.intro]
A <a href="../expressions/closure-expr.html">closure expression</a> produces a closure value with a unique, anonymous type that cannot be written out.
A closure type is approximately equivalent to a struct which contains the captured values.
For instance, the following closure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // Prints "Point { x: 2, y: 1 }".
<span class="boring">}</span></code></pre></pre>
<p>generates a closure type roughly like the following:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// Note: This is not exactly how it is translated, this is only for
// illustration.

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>so that the call to <code>f</code> works as if it were:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.right_bottom.x });</code></pre>
<p>r[type.closure.capture]</p>
<h2 id="capture-modes"><a class="header" href="#capture-modes">Capture modes</a></h2>
<p>r[type.closure.capture.intro]
A <em>capture mode</em> determines how a <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a> from the environment is borrowed or moved into the closure.
The capture modes are:</p>
<ol>
<li>Immutable borrow (<code>ImmBorrow</code>) — The place expression is captured as a <a href="pointer.html#references--and-mut">shared reference</a>.</li>
<li>Unique immutable borrow (<code>UniqueImmBorrow</code>) — This is similar to an immutable borrow, but must be unique as described <a href="#unique-immutable-borrows-in-captures">below</a>.</li>
<li>Mutable borrow (<code>MutBorrow</code>) — The place expression is captured as a <a href="pointer.html#mutable-references-mut">mutable reference</a>.</li>
<li>Move (<code>ByValue</code>) — The place expression is captured by <a href="../expressions.html#moved-and-copied-types">moving the value</a> into the closure.</li>
</ol>
<p>r[type.closure.capture.precedence]
Place expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body.
The mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.</p>
<p>r[type.closure.capture.copy]</p>
<h3 id="copy-values"><a class="header" href="#copy-values"><code>Copy</code> values</a></h3>
<p>Values that implement <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> that are moved into the closure are captured with the <code>ImmBorrow</code> mode.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x captured by ImmBorrow
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.input]</p>
<h3 id="async-input-capture"><a class="header" href="#async-input-capture">Async input capture</a></h3>
<p>Async closures always capture all input arguments, regardless of whether or not they are used within the body.</p>
<h2 id="capture-precision"><a class="header" href="#capture-precision">Capture precision</a></h2>
<p>r[type.closure.capture.precision.capture-path]
A <em>capture path</em> is a sequence starting with a variable from the environment followed by zero or more place projections from that variable.</p>
<p>r[type.closure.capture.precision.place-projection]
A <em>place projection</em> is a <a href="../expressions/field-expr.html">field access</a>, <a href="../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index</a>, <a href="../expressions/operator-expr.html#the-dereference-operator">dereference</a> (and automatic dereferences), <a href="../expressions/array-expr.html#array-and-slice-indexing-expressions">array or slice index</a> expression, or <a href="patterns.destructure">pattern destructuring</a> applied to a variable.</p>
<blockquote>
<p>[!NOTE]
In <code>rustc</code>, pattern destructuring desugars into a series of dereferences and field or element accesses.</p>
</blockquote>
<p>r[type.closure.capture.precision.intro]
The closure borrows or moves the capture path, which may be truncated based on the rules described below.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1 captured by ImmBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<p>Here the capture path is the local variable <code>s</code>, followed by a field access <code>.f1</code>, and then a tuple index <code>.1</code>.
This closure captures an immutable borrow of <code>s.f1.1</code>.</p>
<p>r[type.closure.capture.precision.shared-prefix]</p>
<h3 id="shared-prefix"><a class="header" href="#shared-prefix">Shared prefix</a></h3>
<p>In the case where a capture path and one of the ancestors of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, <code>CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)</code>, using the strict weak ordering:</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>Note that this might need to be applied recursively.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In this example, there are three different capture paths with a shared ancestor:
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u captured by ImmBorrow
    u.1.truncate(0); // u.0 captured by MutBorrow
    move_value(u.0.0); // u.0.0 captured by ByValue
};
c();
<span class="boring">}</span></code></pre></pre>
<p>Overall this closure will capture <code>u</code> by <code>ByValue</code>.</p>
<p>r[type.closure.capture.precision.dereference-shared]</p>
<h3 id="rightmost-shared-reference-truncation"><a class="header" href="#rightmost-shared-reference-truncation">Rightmost shared reference truncation</a></h3>
<p>The capture path is truncated at the rightmost dereference in the capture path if the dereference is applied to a shared reference.</p>
<p>This truncation is allowed because fields that are read through a shared reference will always be read via a shared reference or a copy.
This helps reduce the size of the capture when the extra precision does not yield any benefit from a borrow checking perspective.</p>
<p>The reason it is the <em>rightmost</em> dereference is to help avoid a shorter lifetime than is necessary.
Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre></pre>
<p>If this were to capture <code>m</code>, then the closure would no longer outlive <code>'static</code>, since <code>m</code> is constrained to <code>'a</code>. Instead, it captures <code>(*(*m).a)</code> by <code>ImmBorrow</code>.</p>
<p>r[type.closure.capture.precision.wildcard]</p>
<h3 id="wildcard-pattern-bindings"><a class="header" href="#wildcard-pattern-bindings">Wildcard pattern bindings</a></h3>
<p>r[type.closure.capture.precision.wildcard.reads]
Closures only capture data that needs to be read. Binding a value with a <a href="../patterns.html#wildcard-pattern">wildcard pattern</a> does not read the value, so the place is not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = S;
let c = || {
    let _ = x;  // Does not capture `x`.
};
let c = || match x {
    _ =&gt; (), // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.destructuring]
Destructuring tuples, structs, and single-variant enums does not, by itself, cause a read or the place to be captured.</p>
<blockquote>
<p>[!NOTE]
Enums marked with [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] from other crates are always treated as having multiple variants. See <em>[type.closure.capture.precision.discriminants.non_exhaustive]</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.

// Destructuring tuples does not cause a read or capture.
let x = (S,);
let c = || {
    let (..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring unit structs does not cause a read or capture.
let x = S;
let c = || {
    let S = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring structs does not cause a read or capture.
struct W&lt;T&gt;(T);
let x = W(S);
let c = || {
    let W(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring single-variant enums does not cause a read
// or capture.
enum E&lt;T&gt; { V(T) }
let x = E::V(S);
let c = || {
    let E::V(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.fields]
Fields matched against [RestPattern] (<code>..</code>) or [StructPatternEtCetera] (also <code>..</code>) are not read, and those fields are not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = (S, S);
let c = || {
    let (x0, ..) = x;  // Captures `x.0` by `ByValue`.
};
// Only the first tuple field was captured by the closure.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.array-slice]
Partial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = [S, S];
let c = || {
    let [x0, _] = x; // Captures all of `x` by `ByValue`.
};
let _ = &amp;mut x[1]; // ERROR: Borrow of moved value.
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.initialized]
Values that are matched with wildcards must still be initialized.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;
let c = || {
    let _ = x; // ERROR: Binding `x` isn't initialized.
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants]</p>
<h3 id="capturing-for-discriminant-reads"><a class="header" href="#capturing-for-discriminant-reads">Capturing for discriminant reads</a></h3>
<p>r[type.closure.capture.precision.discriminants.reads]
If pattern matching reads a discriminant, the place containing that discriminant is captured by <code>ImmBorrow</code>.</p>
<p>r[type.closure.capture.precision.discriminants.multiple-variant]
Matching against a variant of an enum that has more than one variant reads the discriminant, capturing the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = (Some(S), S);
let c = || match x {
    (None, _) =&gt; (),
//   ^^^^
// This pattern requires reading the discriminant, which
// causes `x.0` to be captured by `ImmBorrow`.
    _ =&gt; (),
};
let _ = &amp;mut x.0; // ERROR: Cannot borrow `x.0` as mutable.
//           ^^^
// The closure is still live, so `x.0` is still immutably
// borrowed here.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; // A non-`Copy` type.
</span><span class="boring">let x = (Some(S), S);
</span>let c = || match x { // Captures `x.0` by `ImmBorrow`.
    (None, _) =&gt; (),
    _ =&gt; (),
};
// Though `x.0` is captured due to the discriminant read,
// `x.1` is not captured.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.single-variant]
Matching against the only variant of a single-variant enum does not read the discriminant and does not capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E&lt;T&gt; { V(T) } // A single-variant enum.
let x = E::V(());
let c = || {
    let E::V(_) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.non_exhaustive]
If [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] is applied to an enum defined in an external crate, the enum is treated as having multiple variants for the purpose of deciding whether a read occurs, even if it actually has only one variant.</p>
<p>r[type.closure.capture.precision.discriminants.uninhabited-variants]
Even if all variants but the one being matched against are uninhabited, making the pattern [irrefutable][patterns.refutable], the discriminant is still read if it otherwise would be.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}
let mut x = Ok::&lt;_, Empty&gt;(42);
let c = || {
    let Ok(_) = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.range-patterns]</p>
<h3 id="capturing-and-range-patterns"><a class="header" href="#capturing-and-range-patterns">Capturing and range patterns</a></h3>
<p>r[type.closure.capture.precision.range-patterns.reads]
Matching against a [range pattern][patterns.range] reads the place being matched, even if the range includes all possible values of the type, and captures the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0u8;
let c = || {
    let 0..=u8::MAX = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.slice-patterns]</p>
<h3 id="capturing-and-slice-patterns"><a class="header" href="#capturing-and-slice-patterns">Capturing and slice patterns</a></h3>
<p>r[type.closure.capture.precision.slice-patterns.slices]
Matching a slice against a [slice pattern][patterns.slice] other than one with only a single [rest pattern][patterns.rest] (i.e. <code>[..]</code>) is treated as a read of the length from the slice and captures the slice by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Captures `*x` by `ImmBorrow`.
    &amp;mut [] =&gt; (),
//       ^^
// This matches a slice of exactly zero elements. To know whether the
// scrutinee matches, the length must be read, causing the slice to
// be captured.
    _ =&gt; (),
};
let _ = &amp;mut *x; // ERROR: Cannot borrow `*x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Does not capture `*x`.
    [..] =&gt; (),
//   ^^ Rest pattern.
};
let _ = &amp;mut *x; // OK: `*x` can be borrow here.
c();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE]
Perhaps surprisingly, even though the length is contained in the (wide) <em>pointer</em> to the slice, it is the place of the <em>pointee</em> (the slice) that is treated as read and is captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    // The closure outlives `'l` because it captures `**x`. If
    // instead it captured `*x`, it would not live long enough
    // to satisfy the `impl Fn() + 'l` bound.
    || match *x { // Captures `**x` by `ImmBorrow`.
        &amp;[] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this way, the behavior is consistent with dereferencing to the slice in the scrutinee.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    || match **x { // Captures `**x` by `ImmBorrow`.
        [] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For details, see <a href="https://github.com/rust-lang/rust/pull/138961">Rust PR #138961</a>.</p>
</blockquote>
<p>r[type.closure.capture.precision.slice-patterns.arrays]
As the length of an array is fixed by its type, matching an array against a slice pattern does not by itself capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [u8; 1] = [0];
let c = || match x { // Does not capture `x`.
    [_] =&gt; (), // Length is fixed.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.move-dereference]</p>
<h3 id="capturing-references-in-move-contexts"><a class="header" href="#capturing-references-in-move-contexts">Capturing references in move contexts</a></h3>
<p>Because it is not allowed to move fields out of a reference, <code>move</code> closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a reference.
The reference itself will be moved into the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // captures `t_mut_ref` ByValue
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.raw-pointer-dereference]</p>
<h3 id="raw-pointer-dereference"><a class="header" href="#raw-pointer-dereference">Raw pointer dereference</a></h3>
<p>Because it is <code>unsafe</code> to dereference a raw pointer, closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a raw pointer.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // captures `t_ptr` by ImmBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.union]</p>
<h3 id="union-fields"><a class="header" href="#union-fields">Union fields</a></h3>
<p>Because it is <code>unsafe</code> to access a union field, closures will only capture the prefix of a capture path that runs up to the union itself.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // captures `u` ByValue
};
c();

// This also includes writing to fields.
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // captures `u` with MutBorrow
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.unaligned]</p>
<h3 id="reference-into-unaligned-structs"><a class="header" href="#reference-into-unaligned-structs">Reference into unaligned <code>struct</code>s</a></h3>
<p>Because it is <a href="../behavior-considered-undefined.html">undefined behavior</a> to create references to unaligned fields in a structure,
closures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses <a href="../type-layout.html#the-alignment-modifiers">the <code>packed</code> representation</a>.
This includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // captures `t` with ImmBorrow
};
// Copies out of `t` are ok.
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre></pre>
<p>Similarly, taking the address of an unaligned field also captures the entire struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // captures `t` with ImmBorrow
};
let a = t.0; // ERROR: cannot move out of `t.0` because it is borrowed
c();
<span class="boring">}</span></code></pre></pre>
<p>but the above works if it is not packed since it captures the field precisely:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // captures `t.1` with ImmBorrow
};
// The move here is allowed.
let a = t.0;
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-deref]</p>
<h3 id="box-vs-other-deref-implementations"><a class="header" href="#box-vs-other-deref-implementations"><code>Box</code> vs other <code>Deref</code> implementations</a></h3>
<p>The implementation of the <a href="../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> trait for <a href="../special-types-and-traits.html#boxt"><code>Box</code></a> is treated differently from other <code>Deref</code> implementations, as it is considered a special entity.</p>
<p>For example, let us look at examples involving <code>Rc</code> and <code>Box</code>. The <code>*rc</code> is desugared to a call to the trait method <code>deref</code> defined on <code>Rc</code>, but since <code>*box</code> is treated differently, it is possible to do a precise capture of the contents of the <code>Box</code>.</p>
<p>r[type.closure.capture.precision.box-non-move.not-moved]</p>
<h4 id="box-with-non-move-closure"><a class="header" href="#box-with-non-move-closure"><code>Box</code> with non-<code>move</code> closure</a></h4>
<p>In a non-<code>move</code> closure, if the contents of the <code>Box</code> are not moved into the closure body, the contents of the <code>Box</code> are precisely captured.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // captures `(*b).0` by ImmBorrow
};
c_box();

// Contrast `Box` with another type that implements Deref:
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // captures `r` by ImmBorrow
};
c_rc();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-non-move.moved]
However, if the contents of the <code>Box</code> are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is the same as the example above except the closure
// moves the value instead of taking a reference to it.

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // captures `b` with ByValue
};
c_box();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-move.read]</p>
<h4 id="box-with-move-closure"><a class="header" href="#box-with-move-closure"><code>Box</code> with move closure</a></h4>
<p>Similarly to moving contents of a <code>Box</code> in a non-<code>move</code> closure, reading the contents of a <code>Box</code> in a <code>move</code> closure will capture the <code>Box</code> entirely.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // captures `b` with ByValue
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.unique-immutable]</p>
<h2 id="unique-immutable-borrows-in-captures"><a class="header" href="#unique-immutable-borrows-in-captures">Unique immutable borrows in captures</a></h2>
<p>Captures can occur by a special kind of borrow called a <em>unique immutable borrow</em>,
which cannot be used anywhere else in the language and cannot be written out explicitly.
It occurs when modifying the referent of a mutable reference, as in the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // An ImmBorrow and a MutBorrow of `x`.
    let a = &amp;x;
    *x = true; // `x` captured by UniqueImmBorrow
};
// The following line is an error:
// let y = &amp;x;
c();
// However, the following is OK.
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>.
But at the same time, borrowing <code>x</code> immutably would make the assignment illegal,
because a <code>&amp; &amp;mut</code> reference might not be unique, so it cannot safely be used to modify a value.
So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</p>
<p>In the above example, uncommenting the declaration of <code>y</code> will produce an error because it would violate the uniqueness of the closure’s borrow of <code>x</code>; the declaration of z is valid because the closure’s lifetime has expired at the end of the block, releasing the borrow.</p>
<p>r[type.closure.call]</p>
<h2 id="call-traits-and-coercions"><a class="header" href="#call-traits-and-coercions">Call traits and coercions</a></h2>
<p>r[type.closure.call.intro]
Closure types all implement [<code>FnOnce</code>], indicating that they can be called once
by consuming ownership of the closure. Additionally, some closures implement
more specific call traits:</p>
<p>r[type.closure.call.fn-mut]</p>
<ul>
<li>A closure which does not move out of any captured variables implements
[<code>FnMut</code>], indicating that it can be called by mutable reference.</li>
</ul>
<p>r[type.closure.call.fn]</p>
<ul>
<li>A closure which does not mutate or move out of any captured variables
implements [<code>Fn</code>], indicating that it can be called by shared reference.</li>
</ul>
<blockquote>
<p>[!NOTE]
<code>move</code> closures may still implement [<code>Fn</code>] or [<code>FnMut</code>], even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</p>
</blockquote>
<p>r[type.closure.non-capturing]
<em>Non-capturing closures</em> are closures that don’t capture anything from their
environment. Non-async, non-capturing closures can be coerced to function pointers (e.g., <code>fn()</code>)
with the matching signature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.traits]</p>
<h3 id="async-closure-traits"><a class="header" href="#async-closure-traits">Async closure traits</a></h3>
<p>r[type.closure.async.traits.fn-family]
Async closures have a further restriction of whether or not they implement [<code>FnMut</code>] or [<code>Fn</code>].</p>
<p>The [<code>Future</code>] returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be <em>lending</em> to its [<code>Future</code>] if it has either of the following properties:</p>
<ul>
<li>The <code>Future</code> includes a mutable capture.</li>
<li>The async closure captures by value, except when the value is accessed with a dereference projection.</li>
</ul>
<p>If the async closure is lending to its <code>Future</code>, then [<code>FnMut</code>] and [<code>Fn</code>] are <em>not</em> implemented. [<code>FnOnce</code>] is always implemented.</p>
<blockquote>
<p><strong>Example</strong>: The first clause for a mutable capture can be illustrated with the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x captured with MutBorrow
    };
    takes_callback(c);  // ERROR: async closure does not implement `FnMut`
}
<span class="boring">}</span></code></pre></pre>
<p>The second clause for a regular value capture can be illustrated with the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x captured ByValue
    };
    takes_callback(c);  // ERROR: async closure does not implement `Fn`
}
<span class="boring">}</span></code></pre></pre>
<p>The exception of the the second clause can be illustrated by using a dereference, which does allow <code>Fn</code> and <code>FnMut</code> to be implemented:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK: implements `Fn`
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[type.closure.async.traits.async-family]
Async closures implement [<code>AsyncFn</code>], [<code>AsyncFnMut</code>], and [<code>AsyncFnOnce</code>] in an analogous way as regular closures implement [<code>Fn</code>], [<code>FnMut</code>], and [<code>FnOnce</code>]; that is, depending on the use of the captured variables in its body.</p>
<p>r[type.closure.traits]</p>
<h3 id="other-traits"><a class="header" href="#other-traits">Other traits</a></h3>
<p>r[type.closure.traits.intro]
All closure types implement <a href="../special-types-and-traits.html#sized"><code>Sized</code></a>. Additionally, closure types implement the
following traits if allowed to do so by the types of the captures it stores:</p>
<ul>
<li><a href="../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<p>r[type.closure.traits.behavior]
The rules for <a href="../special-types-and-traits.html#send"><code>Send</code></a> and <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> match those for normal struct types, while
<a href="../special-types-and-traits.html#clone"><code>Clone</code></a> and <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> behave as if <a href="../attributes/derive.html">derived</a>. For <a href="../special-types-and-traits.html#clone"><code>Clone</code></a>, the order of
cloning of the captured values is left unspecified.</p>
<p>Because captures are often by reference, the following general rules arise:</p>
<ul>
<li>A closure is <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> if all captured values are <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>.</li>
<li>A closure is <a href="../special-types-and-traits.html#send"><code>Send</code></a> if all values captured by non-unique immutable
reference are <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>, and all values captured by unique immutable or mutable
reference, copy, or move are <a href="../special-types-and-traits.html#send"><code>Send</code></a>.</li>
<li>A closure is <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> if it does not capture any values by
unique immutable or mutable reference, and if all values it captures by copy
or move are <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>, respectively.</li>
</ul>
<p>r[type.closure.drop-order]</p>
<h2 id="drop-order"><a class="header" href="#drop-order">Drop order</a></h2>
<p>If a closure captures a field of a composite types such as structs, tuples, and enums by value, the field’s lifetime would now be tied to the closure. As a result, it is possible for disjoint fields of a composite types to be dropped at different times.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0 is captured into the closure |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c' and 'tuple.0' dropped here ------------+  |
} // tuple.1 dropped here -----------------------------+
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.edition2018.entirety]</p>
<h2 id="edition-2018-and-before"><a class="header" href="#edition-2018-and-before">Edition 2018 and before</a></h2>
<h3 id="closure-types-difference"><a class="header" href="#closure-types-difference">Closure types difference</a></h3>
<p>In Edition 2018 and before, closures always capture a variable in its entirety, without its precise capture path. This means that for the example used in the <a href="#closure-types">Closure types</a> section, the generated closure type would instead look something like this:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>and the call to <code>f</code> would work as follows:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<p>r[type.closure.capture.precision.edition2018.composite]</p>
<h3 id="capture-precision-difference"><a class="header" href="#capture-precision-difference">Capture precision difference</a></h3>
<p>Composite types such as structs, tuples, and enums are always captured in its entirety,
not by individual fields. As a result, it may be necessary to borrow into a local variable in order to capture a single field:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If, instead, the closure were to use <code>self.vec</code> directly, then it would attempt to capture <code>self</code> by mutable reference. But since <code>self.set</code> is already borrowed to iterate over, the code would not compile.</p>
<p>r[type.closure.capture.precision.edition2018.move]
If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code> types, by copy, regardless of whether a borrow would work. The <code>move</code> keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</p>
<p>r[type.closure.capture.precision.edition2018.wildcard]
Regardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety.</p>
<p>r[type.closure.capture.precision.edition2018.drop-order]</p>
<h3 id="drop-order-difference"><a class="header" href="#drop-order-difference">Drop order difference</a></h3>
<p>As composite types are captured in their entirety, a closure which captures one of those composite types by value would drop the entire captured variable at the same time as the closure gets dropped.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple is captured into the closure |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c' and 'tuple' dropped here ------------+
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../types/function-item.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../types/pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../types/function-item.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../types/pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
