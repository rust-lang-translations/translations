msgstr "_백슬래시 이스케이프_는 `U+005C`(`\\`) 문자이며, ASCII 인코딩 `0x5C`를 나타내기 위해 _이스케이프_되어야 합니다."
"Project-Id-Version: The Rust Reference\n"
"POT-Creation-Date: 2025-10-15T16:19:04+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:19:04+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "The Rust Reference"
msgstr "러스트 레퍼런스"

#: src/SUMMARY.md:3 src/introduction.md:1
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:5 src/notation.md:1 src/notation.md:7
msgid "Notation"
msgstr "표기법"

#: src/SUMMARY.md:7 src/lexical-structure.md:1
msgid "Lexical structure"
msgstr "어휘 구조"

#: src/SUMMARY.md:8 src/input-format.md:3
msgid "Input format"
msgstr "입력 형식"

#: src/SUMMARY.md:9 src/keywords.md:3
msgid "Keywords"
msgstr "키워드"

#: src/SUMMARY.md:10 src/identifiers.md:3
msgid "Identifiers"
msgstr "식별자"

#: src/SUMMARY.md:11 src/comments.md:3
msgid "Comments"
msgstr "주석"

#: src/SUMMARY.md:12 src/whitespace.md:3
msgid "Whitespace"
msgstr "공백"

#: src/SUMMARY.md:13 src/tokens.md:3
msgid "Tokens"
msgstr "토큰"

#: src/SUMMARY.md:15 src/macros.md:3 src/attributes.md:301
msgid "Macros"
msgstr "매크로"

#: src/SUMMARY.md:16 src/macros-by-example.md:3
msgid "Macros By Example"
msgstr "예제를 통한 매크로"

#: src/SUMMARY.md:17 src/procedural-macros.md:3
msgid "Procedural Macros"
msgstr "절차적 매크로"

#: src/SUMMARY.md:19 src/crates-and-source-files.md:3
msgid "Crates and source files"
msgstr "크레이트와 소스 파일"

#: src/SUMMARY.md:21 src/conditional-compilation.md:3 src/attributes.md:287
msgid "Conditional compilation"
msgstr "조건부 컴파일"

#: src/SUMMARY.md:23 src/items.md:3
msgid "Items"
msgstr "아이템"

#: src/SUMMARY.md:24 src/items/modules.md:3 src/attributes.md:352
msgid "Modules"
msgstr "모듈"

#: src/SUMMARY.md:25
msgid "Extern crates"
msgstr "외부 크레이트"

#: src/SUMMARY.md:26 src/items/use-declarations.md:3
#: src/names/namespaces.md:106
msgid "Use declarations"
msgstr "Use 선언"

#: src/SUMMARY.md:27 src/items/functions.md:3 src/items/external-blocks.md:51
msgid "Functions"
msgstr "함수"

#: src/SUMMARY.md:28 src/items/type-aliases.md:3
msgid "Type aliases"
msgstr "타입 별칭"

#: src/SUMMARY.md:29 src/items/structs.md:3
msgid "Structs"
msgstr "구조체"

#: src/SUMMARY.md:30 src/items/enumerations.md:3
msgid "Enumerations"
msgstr "열거형"

#: src/SUMMARY.md:31 src/items/unions.md:3
msgid "Unions"
msgstr "공용체"

#: src/SUMMARY.md:32 src/items/constant-items.md:3
msgid "Constant items"
msgstr "상수 아이템"

#: src/SUMMARY.md:33 src/items/static-items.md:3
msgid "Static items"
msgstr "정적 아이템"

#: src/SUMMARY.md:34 src/items/traits.md:3
msgid "Traits"
msgstr "트레잇"

#: src/SUMMARY.md:35 src/items/implementations.md:3
msgid "Implementations"
msgstr "구현"

#: src/SUMMARY.md:36 src/items/external-blocks.md:3
msgid "External blocks"
msgstr "외부 블록"

#: src/SUMMARY.md:37 src/items/generics.md:3
msgid "Generic parameters"
msgstr "제네릭 파라미터"

#: src/SUMMARY.md:38 src/items/associated-items.md:3
msgid "Associated Items"
msgstr "연관 아이템"

#: src/SUMMARY.md:40 src/items/generics.md:297 src/attributes.md:30
msgid "Attributes"
msgstr "속성"

#: src/SUMMARY.md:41 src/attributes.md:291
msgid "Testing"
msgstr "테스팅"

#: src/SUMMARY.md:42 src/attributes.md:296 src/attributes/derive.md:3
msgid "Derive"
msgstr "파생"

#: src/SUMMARY.md:43 src/attributes.md:309
msgid "Diagnostics"
msgstr "진단"

#: src/SUMMARY.md:44 src/attributes.md:336
msgid "Code generation"
msgstr "코드 생성"

#: src/SUMMARY.md:45 src/attributes.md:355 src/attributes/limits.md:3
msgid "Limits"
msgstr "제한"

#: src/SUMMARY.md:46 src/attributes.md:369
msgid "Type System"
msgstr "타입 시스템"

#: src/SUMMARY.md:47 src/attributes.md:373
msgid "Debugger"
msgstr "디버거"

#: src/SUMMARY.md:49 src/statements-and-expressions.md:3
msgid "Statements and expressions"
msgstr "구문과 표현식"

#: src/SUMMARY.md:50 src/statements.md:3
msgid "Statements"
msgstr "구문"

#: src/SUMMARY.md:51 src/expressions.md:3
msgid "Expressions"
msgstr "표현식"

#: src/SUMMARY.md:52 src/expressions/literal-expr.md:3
msgid "Literal expressions"
msgstr "리터럴 표현식"

#: src/SUMMARY.md:53 src/expressions/path-expr.md:3
msgid "Path expressions"
msgstr "경로 표현식"

#: src/SUMMARY.md:54 src/expressions/block-expr.md:3
msgid "Block expressions"
msgstr "블록 표현식"

#: src/SUMMARY.md:55 src/expressions/operator-expr.md:3
msgid "Operator expressions"
msgstr "연산자 표현식"

#: src/SUMMARY.md:56 src/expressions/grouped-expr.md:3
msgid "Grouped expressions"
msgstr "그룹화된 표현식"

#: src/SUMMARY.md:57
msgid "Array and index expressions"
msgstr "배열 및 인덱스 표현식"

#: src/SUMMARY.md:58
msgid "Tuple and index expressions"
msgstr "튜플 및 인덱스 표현식"

#: src/SUMMARY.md:59 src/expressions/struct-expr.md:3
msgid "Struct expressions"
msgstr "구조체 표현식"

#: src/SUMMARY.md:60 src/expressions/call-expr.md:3
msgid "Call expressions"
msgstr "호출 표현식"

#: src/SUMMARY.md:61
msgid "Method call expressions"
msgstr "메서드 호출 표현식"

#: src/SUMMARY.md:62 src/expressions/field-expr.md:3
msgid "Field access expressions"
msgstr "필드 접근 표현식"

#: src/SUMMARY.md:63 src/expressions/closure-expr.md:3
msgid "Closure expressions"
msgstr "클로저 표현식"

#: src/SUMMARY.md:64
msgid "Loop expressions"
msgstr "루프 표현식"

#: src/SUMMARY.md:65 src/expressions/range-expr.md:3
msgid "Range expressions"
msgstr "범위 표현식"

#: src/SUMMARY.md:66
msgid "If and if let expressions"
msgstr "if 및 if let 표현식"

#: src/SUMMARY.md:67
msgid "Match expressions"
msgstr "match 표현식"

#: src/SUMMARY.md:68
msgid "Return expressions"
msgstr "return 표현식"

#: src/SUMMARY.md:69 src/expressions/await-expr.md:3
msgid "Await expressions"
msgstr "await 표현식"

#: src/SUMMARY.md:70
msgid "Underscore expressions"
msgstr "밑줄 표현식"

#: src/SUMMARY.md:72 src/patterns.md:3
msgid "Patterns"
msgstr "패턴"

#: src/SUMMARY.md:74 src/type-system.md:1
msgid "Type system"
msgstr "타입 시스템"

#: src/SUMMARY.md:75 src/types.md:46
msgid "Types"
msgstr "타입"

#: src/SUMMARY.md:76 src/types/boolean.md:3
msgid "Boolean type"
msgstr "불리언 타입"

#: src/SUMMARY.md:77 src/types/numeric.md:3
msgid "Numeric types"
msgstr "숫자 타입"

#: src/SUMMARY.md:78 src/types/textual.md:3
msgid "Textual types"
msgstr "텍스트 타입"

#: src/SUMMARY.md:79 src/types/never.md:3
msgid "Never type"
msgstr "결코 리턴하지 않는 타입"

#: src/SUMMARY.md:80 src/types/tuple.md:3
msgid "Tuple types"
msgstr "튜플 타입"

#: src/SUMMARY.md:81 src/types/array.md:3
msgid "Array types"
msgstr "배열 타입"

#: src/SUMMARY.md:82 src/types/slice.md:3
msgid "Slice types"
msgstr "슬라이스 타입"

#: src/SUMMARY.md:83 src/types/struct.md:3
msgid "Struct types"
msgstr "구조체 타입"

#: src/SUMMARY.md:84 src/types/enum.md:3
msgid "Enumerated types"
msgstr "열거 타입"

#: src/SUMMARY.md:85 src/types/union.md:3
msgid "Union types"
msgstr "공용체 타입"

#: src/SUMMARY.md:86 src/types/function-item.md:3
msgid "Function item types"
msgstr "함수 아이템 타입"

#: src/SUMMARY.md:87 src/types/closure.md:3
msgid "Closure types"
msgstr "클로저 타입"

#: src/SUMMARY.md:88 src/types/pointer.md:3
msgid "Pointer types"
msgstr "포인터 타입"

#: src/SUMMARY.md:89 src/types/function-pointer.md:3
msgid "Function pointer types"
msgstr "함수 포인터 타입"

#: src/SUMMARY.md:90
msgid "Trait object types"
msgstr "트레잇 객체 타입"

#: src/SUMMARY.md:91
msgid "Impl trait type"
msgstr "impl 트레잇 타입"

#: src/SUMMARY.md:92 src/types/parameters.md:3
msgid "Type parameters"
msgstr "타입 파라미터"

#: src/SUMMARY.md:93 src/types/inferred.md:3
msgid "Inferred type"
msgstr "추론된 타입"

#: src/SUMMARY.md:94 src/dynamically-sized-types.md:1
msgid "Dynamically Sized Types"
msgstr "동적 크기 타입"

#: src/SUMMARY.md:95
msgid "Type layout"
msgstr "타입 레이아웃"

#: src/SUMMARY.md:96
msgid "Interior mutability"
msgstr "내부 가변성"

#: src/SUMMARY.md:97 src/subtyping.md:3
msgid "Subtyping and Variance"
msgstr "서브타이핑과 가변성"

#: src/SUMMARY.md:98 src/trait-bounds.md:3
msgid "Trait and lifetime bounds"
msgstr "트레잇과 라이프타임 바운드"

#: src/SUMMARY.md:99 src/type-coercions.md:3
msgid "Type coercions"
msgstr "타입 강제 변환"

#: src/SUMMARY.md:100 src/destructors.md:1
msgid "Destructors"
msgstr "소멸자"

#: src/SUMMARY.md:101 src/lifetime-elision.md:3
msgid "Lifetime elision"
msgstr "라이프타임 생략"

#: src/SUMMARY.md:103 src/special-types-and-traits.md:3
msgid "Special types and traits"
msgstr "특수 타입과 트레잇"

#: src/SUMMARY.md:105 src/names.md:3
msgid "Names"
msgstr "이름"

#: src/SUMMARY.md:106 src/names/namespaces.md:3
msgid "Namespaces"
msgstr "네임스페이스"

#: src/SUMMARY.md:107 src/names/scopes.md:3
msgid "Scopes"
msgstr "스코프"

#: src/SUMMARY.md:108 src/attributes.md:348 src/names/preludes.md:3
msgid "Preludes"
msgstr "프렐류드"

#: src/SUMMARY.md:109 src/expressions.md:86 src/paths.md:3
msgid "Paths"
msgstr "경로"

#: src/SUMMARY.md:110 src/names/name-resolution.md:1 src/glossary.md:158
msgid "Name resolution"
msgstr "이름 확인"

#: src/SUMMARY.md:111
msgid "Visibility and privacy"
msgstr "가시성과 프라이버시"

#: src/SUMMARY.md:113 src/memory-model.md:1
msgid "Memory model"
msgstr "메모리 모델"

#: src/SUMMARY.md:114 src/memory-allocation-and-lifetime.md:3
msgid "Memory allocation and lifetime"
msgstr "메모리 할당과 라이프타임"

#: src/SUMMARY.md:115 src/variables.md:3
msgid "Variables"
msgstr "변수"

#: src/SUMMARY.md:117 src/linkage.md:3
msgid "Linkage"
msgstr "연결"

#: src/SUMMARY.md:119 src/inline-assembly.md:3
msgid "Inline assembly"
msgstr "인라인 어셈블리"

#: src/SUMMARY.md:121 src/unsafety.md:3
msgid "Unsafety"
msgstr "안전하지 않음"

#: src/SUMMARY.md:122 src/unsafe-keyword.md:3
msgid "The `unsafe` keyword"
msgstr "`unsafe` 키워드"

#: src/SUMMARY.md:123 src/behavior-considered-undefined.md:3
msgid "Behavior considered undefined"
msgstr "정의되지 않은 동작으로 간주되는 경우"

#: src/SUMMARY.md:124
msgid "Behavior not considered unsafe"
msgstr "안전하지 않은 것으로 간주되지 않는 동작"

#: src/SUMMARY.md:126
msgid "Constant Evaluation"
msgstr "상수 평가"

#: src/SUMMARY.md:128
msgid "Application Binary Interface"
msgstr "애플리케이션 바이너리 인터페이스"

#: src/SUMMARY.md:130 src/runtime.md:3
msgid "The Rust runtime"
msgstr "러스트 런타임"

#: src/SUMMARY.md:132 src/appendices.md:1
msgid "Appendices"
msgstr "부록"

#: src/SUMMARY.md:133
msgid "Macro Follow-Set Ambiguity Formal Specification"
msgstr "매크로 Follow-Set 모호성 공식 명세"

#: src/SUMMARY.md:134 src/influences.md:1
msgid "Influences"
msgstr "영향"

#: src/SUMMARY.md:135 src/test-summary.md:1
msgid "Test summary"
msgstr "테스트 요약"

#: src/SUMMARY.md:136 src/glossary.md:1
msgid "Glossary"
msgstr "용어집"

#: src/introduction.md:3
msgid "This book is the primary reference for the Rust programming language. It provides three kinds of material:"
msgstr "이 책은 러스트 프로그래밍 언어의 주요 참고 자료입니다. 이 책은 세 가지 종류의 자료를 제공합니다:"

#: src/introduction.md:6
msgid "Chapters that informally describe each language construct and their use."
msgstr "각 언어 구성 요소와 그 사용법을 비공식적으로 설명하는 장."

#: src/introduction.md:7
msgid "Chapters that informally describe the memory model, concurrency model, runtime services, linkage model, and debugging facilities."
msgstr "메모리 모델, 동시성 모델, 런타임 서비스, 연결 모델 및 디버깅 기능을 비공식적으로 설명하는 장."

#: src/introduction.md:8
msgid ""
"Appendix chapters providing rationale and references to languages that "
"influenced the design."
msgstr "설계에 영향을 미친 언어에 대한 근거와 참조를 제공하는 부록 장."

#: src/introduction.md:12
msgid ""
"_**Warning:**_ This book is incomplete. Documenting everything takes a "
"while. See the [GitHub issues](https://github.com/rust-lang/reference/"
"issues) for what is not documented in this book."
msgstr "_**경고:**_ 이 책은 미완성입니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 문서화되지 않은 내용은 [GitHub 이슈](https://github.com/rust-lang/reference/issues)를 참조하십시오."

#: src/introduction.md:19
msgid "Rust releases"
msgstr "러스트 릴리스"

#: src/introduction.md:21
msgid "Rust has a new language release every six weeks. The first stable release of the language was Rust 1.0.0, followed by Rust 1.1.0 and so on. Tools (`rustc`, `cargo`, etc.) and documentation ([Standard library](../std/index.html), this book, etc.) are released with the language release."
msgstr "러스트는 6주마다 새로운 언어 릴리스를 발표합니다. 언어의 첫 번째 안정 릴리스는 Rust 1.0.0이었고, 이어서 Rust 1.1.0 등이 출시되었습니다. 도구(`rustc`, `cargo` 등) 및 문서([표준 라이브러리](../std/index.html), 이 책 등)는 언어 릴리스와 함께 출시됩니다."

#: src/introduction.md:25
msgid "The latest release of this book, matching the latest Rust version, can always be found at <https://doc.rust-lang.org/reference/>. Prior versions can be found by adding the Rust version before the \"reference\" directory. For example, the Reference for Rust 1.49.0 is located at <https://doc.rust-lang.org/1.49.0/reference/>."
msgstr "최신 Rust 버전에 해당하는 이 책의 최신 릴리스는 항상 <https://doc.rust-lang.org/reference/>에서 찾을 수 있습니다. 이전 버전은 \"reference\" 디렉토리 앞에 Rust 버전을 추가하여 찾을 수 있습니다. 예를 들어, Rust 1.49.0에 대한 참조는 <https://doc.rust-lang.org/1.49.0/reference/>에 있습니다."

#: src/introduction.md:29
msgid "What _The Reference_ is not"
msgstr "_참조_가 아닌 것"

#: src/introduction.md:31
msgid "This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate [book](../book/index.html) is available to help acquire such background familiarity."
msgstr "이 책은 언어 입문서가 아닙니다. 언어에 대한 기본적인 지식이 있다고 가정합니다. 이러한 배경 지식을 습득하는 데 도움이 되는 별도의 [책](../book/index.html)이 있습니다."

#: src/introduction.md:35
msgid "This book also does not serve as a reference to the [standard library](../std/index.html) included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here."
msgstr "이 책은 또한 언어 배포판에 포함된 [표준 라이브러리](../std/index.html)에 대한 참조 역할을 하지 않습니다. 해당 라이브러리는 소스 코드에서 문서 속성을 추출하여 별도로 문서화됩니다. 언어 기능이라고 예상할 수 있는 많은 기능이 Rust에서는 라이브러리 기능이므로, 찾고 있는 것이 여기에 없을 수도 있습니다."

#: src/introduction.md:39
msgid "Similarly, this book does not usually document the specifics of `rustc` as a tool or of Cargo. `rustc` has its own [book](../rustc/index.html). Cargo has a [book](../cargo/index.html) that contains a [reference](../cargo/reference/index.html). There are a few pages such as [linkage](linkage.html) that still describe how `rustc` works."
msgstr "마찬가지로, 이 책은 일반적으로 `rustc` 도구 또는 Cargo의 세부 사항을 문서화하지 않습니다. `rustc`에는 자체 [책](../rustc/index.html)이 있습니다. Cargo에는 [참조](../cargo/reference/index.html)가 포함된 [책](../cargo/index.html)이 있습니다. [연결](linkage.html)과 같은 몇몇 페이지는 여전히 `rustc`의 작동 방식을 설명합니다."

#: src/introduction.md:44
msgid ""
"This book also only serves as a reference to what is available in stable "
"Rust. For unstable features being worked on, see the [Unstable Book](https://"
"doc.rust-lang.org/nightly/unstable-book/)."
msgstr "이 책은 또한 안정적인 Rust에서 사용할 수 있는 기능에 대한 참조 역할만 합니다. 개발 중인 불안정한 기능에 대해서는 [불안정 책](https://doc.rust-lang.org/nightly/unstable-book/)을 참조하십시오."

#: src/introduction.md:47
msgid "Rust compilers, including `rustc`, will perform optimizations. The reference does not specify what optimizations are allowed or disallowed. Instead, think of the compiled program as a black box. You can only probe by running it, feeding it input and observing its output. Everything that happens that way must conform to what the reference says."
msgstr "`rustc`를 포함한 Rust 컴파일러는 최적화를 수행합니다. 참조는 어떤 최적화가 허용되거나 허용되지 않는지 명시하지 않습니다. 대신, 컴파일된 프로그램을 블랙박스로 생각하십시오. 프로그램을 실행하고 입력을 제공하며 출력을 관찰함으로써만 탐색할 수 있습니다. 그렇게 발생하는 모든 것은 참조가 말하는 바를 따라야 합니다."

#: src/introduction.md:53
msgid ""
"Finally, this book is not normative. It may include details that are "
"specific to `rustc` itself, and should not be taken as a specification for "
"the Rust language. We intend to produce such a book someday, and until then, "
"the reference is the closest thing we have to one."
msgstr "마지막으로, 이 책은 규범적이지 않습니다. `rustc` 자체에 특정한 세부 사항을 포함할 수 있으며, Rust 언어에 대한 사양으로 간주되어서는 안 됩니다. 우리는 언젠가 그러한 책을 만들 계획이며, 그때까지는 이 참조가 가장 가까운 것입니다."

#: src/introduction.md:57
msgid "How to use this book"
msgstr "이 책을 사용하는 방법"

#: src/introduction.md:59
msgid "This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss."
msgstr "이 책은 순차적으로 읽는다고 가정하지 않습니다. 각 장은 일반적으로 독립적으로 읽을 수 있지만, 언급하지만 논의하지 않는 언어의 측면에 대해서는 다른 장으로 상호 연결됩니다."

#: src/introduction.md:62
msgid "There are two main ways to read this document."
msgstr "이 문서를 읽는 두 가지 주요 방법이 있습니다."

#: src/introduction.md:64
msgid "The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press `s` or click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the [lifetime of temporaries](expressions.html#temporaries) is defined in the [expressions chapter](expressions.html), you could search \"temporary let\" and the first search result will take you to that section."
msgstr "첫 번째는 특정 질문에 답하는 것입니다. 해당 질문에 답하는 장을 알고 있다면 목차에서 해당 장으로 이동할 수 있습니다. 그렇지 않으면 `s`를 누르거나 상단 바의 돋보기를 클릭하여 질문과 관련된 키워드를 검색할 수 있습니다. 예를 들어, let 문에서 생성된 임시 값이 언제 삭제되는지 알고 싶다고 가정해 봅시다. [임시 값의 수명](expressions.html#temporaries)이 [표현식 장](expressions.html)에 정의되어 있다는 것을 이미 알고 있지 못했다면, \"temporary let\"을 검색하면 첫 번째 검색 결과가 해당 섹션으로 안내할 것입니다."

#: src/introduction.md:70
msgid "The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section."
msgstr "두 번째는 언어의 한 측면에 대한 지식을 일반적으로 향상시키는 것입니다. 이 경우, 더 알고 싶은 것을 볼 때까지 목차를 탐색하고 읽기 시작하십시오. 링크가 흥미로워 보이면 클릭하여 해당 섹션을 읽으십시오."

#: src/introduction.md:74
msgid ""
"That said, there is no wrong way to read this book. Read it however you feel "
"helps you best."
msgstr "그렇다고 해서 이 책을 읽는 데 잘못된 방법은 없습니다. 가장 도움이 된다고 생각하는 방식으로 읽으십시오."

#: src/introduction.md:76
msgid "Conventions"
msgstr "규약"

#: src/introduction.md:78
msgid ""
"Like all technical books, this book has certain conventions in how it "
"displays information. These conventions are documented here."
msgstr "모든 기술 서적과 마찬가지로 이 책은 정보를 표시하는 방식에 있어 특정 규칙을 따릅니다. 이러한 규칙은 여기에 문서화되어 있습니다."

#: src/introduction.md:81
msgid ""
"Statements that define a term contain that term in _italics_. Whenever that "
"term is used outside of that chapter, it is usually a link to the section "
"that has this definition."
msgstr "용어를 정의하는 문장은 해당 용어를 _이탤릭체_로 포함합니다. 해당 용어가 해당 장 외부에서 사용될 때마다 일반적으로 이 정의가 있는 섹션에 대한 링크입니다."

#: src/introduction.md:84
msgid "An _example term_ is an example of a term being defined."
msgstr "_예시 용어_는 정의되는 용어의 예시입니다."

#: src/introduction.md:86
msgid ""
"Differences in the language by which edition the crate is compiled under are "
"in a blockquote that start with the words \"Edition differences:\" in "
"**bold**."
msgstr "크레이트가 컴파일되는 에디션에 따른 언어의 차이점은 \"에디션 차이:\"라는 단어로 시작하는 **굵은 글씨**의 인용 블록에 있습니다."

#: src/introduction.md:88
msgid ""
"**Edition differences**: In the 2015 edition, this syntax is valid that is "
"disallowed as of the 2018 edition."
msgstr "**에디션 차이**: 2015년 에디션에서는 이 구문이 유효했지만, 2018년 에디션부터는 허용되지 않습니다."

#: src/introduction.md:90
msgid ""
"Notes that contain useful information about the state of the book or point "
"out useful, but mostly out of scope, information are in blockquotes that "
"start with the word \"Note:\" in **bold**."
msgstr "책의 상태에 대한 유용한 정보나 유용하지만 대부분 범위 외의 정보를 포함하는 노트는 **굵은 글씨**로 \"참고:\"라는 단어로 시작하는 인용 블록에 있습니다."

#: src/introduction.md:92
msgid "**Note**: This is an example note."
msgstr "**참고**: 이것은 예시 노트입니다."

#: src/introduction.md:94
msgid ""
"Warnings that show unsound behavior in the language or possibly confusing "
"interactions of language features are in a special warning box."
msgstr "언어의 불안정한 동작 또는 언어 기능의 혼란스러운 상호 작용을 보여주는 경고는 특별 경고 상자에 있습니다."

#: src/introduction.md:98
msgid "_**Warning:**_ This is an example warning."
msgstr "_**경고:**_ 이것은 예시 경고입니다."

#: src/introduction.md:104
msgid "Code snippets inline in the text are inside `<code>` tags."
msgstr "텍스트 내의 코드 스니펫은 `<code>` 태그 안에 있습니다."

#: src/introduction.md:106
msgid ""
"Longer code examples are in a syntax highlighted box that has controls for "
"copying, executing, and showing hidden lines in the top right corner."
msgstr "더 긴 코드 예제는 구문 강조 표시된 상자에 있으며, 오른쪽 상단 모서리에 복사, 실행 및 숨겨진 줄 표시를 위한 컨트롤이 있습니다."

#: src/introduction.md:109
msgid "// This is a hidden line.\n"
msgstr "// 이것은 숨겨진 줄입니다.\n"

#: src/introduction.md:111
msgid "\"This is a code example\""
msgstr "\"이것은 코드 예시입니다\""

#: src/introduction.md:115
msgid ""
"All examples are written for the latest edition unless otherwise stated."
msgstr "모든 예제는 별도로 명시되지 않는 한 최신 에디션을 기준으로 작성되었습니다."

#: src/introduction.md:117
msgid ""
"The grammar and lexical structure is in blockquotes with either \"Lexer\" or "
"\"Syntax\" in <sup>**bold superscript**</sup> as the first line."
msgstr "문법 및 어휘 구조는 첫 줄에 <sup>**굵은 위첨자**</sup>로 \"Lexer\" 또는 \"Syntax\"가 있는 인용 블록에 있습니다."

#: src/introduction.md:119
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ExampleGrammar_:  \n"
"      `~` [_Expression_](expressions.md)  \n"
"   | `box` [_Expression_](expressions.md)"
msgstr "**<sup>구문</sup>**  \n_예시문법_:  \n      `~` [_표현식_](expressions.md)  \n   | `box` [_표현식_](expressions.md)"

#: src/introduction.md:124
msgid "See [Notation](notation.md) for more detail."
msgstr "자세한 내용은 [표기법](notation.md)을 참조하십시오."

#: src/introduction.md:126
msgid ""
"Rule identifiers appear before each language rule enclosed in square "
"brackets. These identifiers provide a way to refer to a specific rule in the "
"language. The rule identifier uses periods to separate sections from most "
"general to most specific ([destructors.scope.nesting.function-body]"
"(destructors.md#r-destructors.scope.nesting.function-body) for example)."
msgstr "규칙 식별자는 각 언어 규칙 앞에 대괄호로 묶여 나타납니다. 이러한 식별자는 언어의 특정 규칙을 참조하는 방법을 제공합니다. 규칙 식별자는 가장 일반적인 것부터 가장 구체적인 것까지 섹션을 구분하기 위해 마침표를 사용합니다(예: [destructors.scope.nesting.function-body](destructors.md#r-destructors.scope.nesting.function-body))."

#: src/introduction.md:128
msgid "The rule name can be clicked to link to that rule."
msgstr "규칙 이름을 클릭하면 해당 규칙으로 연결됩니다."

#: src/introduction.md:135
msgid ""
"_**Warning:**_ The organization of the rules is currently in flux. For the "
"time being, these identifier names are not stable between releases, and "
"links to these rules may fail if they are changed. We intend to stabilize "
"these once the organization has settled so that links to the rule names will "
"not break between releases."
msgstr "_**경고:**_ 규칙의 구성은 현재 유동적입니다. 당분간 이러한 식별자 이름은 릴리스 간에 안정적이지 않으며, 변경될 경우 이러한 규칙에 대한 링크가 실패할 수 있습니다. 우리는 구성이 안정화되면 규칙 이름에 대한 링크가 릴리스 간에 깨지지 않도록 이를 안정화할 계획입니다."

#: src/introduction.md:141
msgid "Contributing"
msgstr "기여하기"

#: src/introduction.md:143
msgid "We welcome contributions of all kinds."
msgstr "모든 종류의 기여를 환영합니다."

#: src/introduction.md:145
msgid ""
"You can contribute to this book by opening an issue or sending a pull "
"request to [the Rust Reference repository](https://github.com/rust-lang/"
"reference/). If this book does not answer your question, and you think its "
"answer is in scope of it, please do not hesitate to [file an issue](https://"
"github.com/rust-lang/reference/issues) or ask about it in the `t-lang/doc` "
"stream on [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/237824-t-"
"lang.2Fdoc). Knowing what people use this book for the most helps direct our "
"attention to making those sections the best that they can be. We also want "
"the reference to be as normative as possible, so if you see anything that is "
"wrong or is non-normative but not specifically called out, please also [file "
"an issue](https://github.com/rust-lang/reference/issues)."
msgstr "이 책에 기여하려면 [Rust 참조 저장소](https://github.com/rust-lang/reference/)에 이슈를 열거나 풀 리퀘스트를 보내십시오. 이 책이 질문에 답하지 못하고 그 답이 이 책의 범위 내에 있다고 생각되면 주저하지 말고 [이슈를 제출](https://github.com/rust-lang/reference/issues)하거나 [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/237824-t-lang.2Fdoc)의 `t-lang/doc` 스트림에서 문의하십시오. 사람들이 이 책을 가장 많이 사용하는 용도를 알면 해당 섹션을 최상으로 만드는 데 집중하는 데 도움이 됩니다. 또한 참조가 가능한 한 규범적이기를 원하므로, 잘못되었거나 비규범적이지만 특별히 언급되지 않은 부분이 있으면 [이슈를 제출](https://github.com/rust-lang/reference/issues)해 주십시오."

#: src/notation.md:3
msgid "Grammar"
msgstr "문법"

#: src/notation.md:5
msgid ""
"The following notations are used by the _Lexer_ and _Syntax_ grammar "
"snippets:"
msgstr "다음 표기법은 _렉서_ 및 _구문_ 문법 스니펫에서 사용됩니다."

#: src/notation.md:7 src/comments.md:91 src/tokens.md:29
#: src/attributes/codegen.md:467 src/destructors.md:433
msgid "Examples"
msgstr "예시"

#: src/notation.md:7 src/expressions/operator-expr.md:438
msgid "Meaning"
msgstr "의미"

#: src/notation.md:9
msgid "CAPITAL"
msgstr "대문자"

#: src/notation.md:9
msgid "KW_IF, INTEGER_LITERAL"
msgstr "KW_IF, 정수_리터럴"

#: src/notation.md:9
msgid "A token produced by the lexer"
msgstr "렉서가 생성한 토큰"

#: src/notation.md:10
msgid "_ItalicCamelCase_"
msgstr "_이탤릭카멜케이스_"

#: src/notation.md:10
msgid "_LetStatement_, _Item_"
msgstr "_Let문_, _아이템_"

#: src/notation.md:10
msgid "A syntactical production"
msgstr "구문 생성"

#: src/notation.md:11
msgid "`string`"
msgstr "`문자열`"

#: src/notation.md:11
msgid "`x`, `while`, `*`"
msgstr "`x`, `while`, `*`"

#: src/notation.md:11
msgid "The exact character(s)"
msgstr "정확한 문자(들)"

#: src/notation.md:12
msgid "\\\\x"
msgstr "\\x"

#: src/notation.md:12
msgid "\\\\n, \\\\r, \\\\t, \\\\0"
msgstr "\\n, \\r, \\t, \\0"

#: src/notation.md:12
msgid "The character represented by this escape"
msgstr "이 이스케이프가 나타내는 문자"

#: src/notation.md:13
msgid "x<sup>?</sup>"
msgstr "x<sup>?</sup>"

#: src/notation.md:13
msgid "`pub`<sup>?</sup>"
msgstr "`pub`<sup>?</sup>"

#: src/notation.md:13
msgid "An optional item"
msgstr "선택적 항목"

#: src/notation.md:14
msgid "x<sup>\\*</sup>"
msgstr "x<sup>*</sup>"

#: src/notation.md:14
msgid "_OuterAttribute_<sup>\\*</sup>"
msgstr "_외부속성_<sup>*</sup>"

#: src/notation.md:14
msgid "0 or more of x"
msgstr "x가 0개 이상"

#: src/notation.md:15
msgid "x<sup>+</sup>"
msgstr "x<sup>+</sup>"

#: src/notation.md:15
msgid "_MacroMatch_<sup>+</sup>"
msgstr "_매크로매치_<sup>+</sup>"

#: src/notation.md:15
msgid "1 or more of x"
msgstr "x가 1개 이상"

#: src/notation.md:16
msgid "x<sup>a..b</sup>"
msgstr "x<sup>a..b</sup>"

#: src/notation.md:16
msgid "HEX_DIGIT<sup>1..6</sup>"
msgstr "16진수_숫자<sup>1..6</sup>"

#: src/notation.md:16
msgid "a to b repetitions of x"
msgstr "x의 a부터 b까지 반복"

#: src/notation.md:17
msgid "\\|"
msgstr "|"

#: src/notation.md:17
msgid "`u8` \\| `u16`, Block \\| Item"
msgstr "`u8` | `u16`, 블록 | 아이템"

#: src/notation.md:17
msgid "Either one or another"
msgstr "둘 중 하나"

#: src/notation.md:18
msgid "\\[ \\]"
msgstr "[ ]"

#: src/notation.md:18
msgid "\\[`b` `B`\\]"
msgstr "[`b` `B`]"

#: src/notation.md:18
msgid "Any of the characters listed"
msgstr "나열된 문자 중 하나"

#: src/notation.md:19
msgid "\\[ - \\]"
msgstr "[ - ]"

#: src/notation.md:19
msgid "\\[`a`\\-`z`\\]"
msgstr "[`a`\\-`z`]"

#: src/notation.md:19
msgid "Any of the characters in the range"
msgstr "범위 내의 문자 중 하나"

#: src/notation.md:20
msgid "~\\[ \\]"
msgstr "~[ ]"

#: src/notation.md:20
msgid "~\\[`b` `B`\\]"
msgstr "~[`b` `B`]"

#: src/notation.md:20
msgid "Any characters, except those listed"
msgstr "나열된 문자를 제외한 모든 문자"

#: src/notation.md:21
msgid "~`string`"
msgstr "~`문자열`"

#: src/notation.md:21
msgid "~`\\n`, ~`*/`"
msgstr "~`\n`, ~`*/`"

#: src/notation.md:21
msgid "Any characters, except this sequence"
msgstr "이 시퀀스를 제외한 모든 문자"

#: src/notation.md:22
msgid "( )"
msgstr "( )"

#: src/notation.md:22
msgid "(`,` _Parameter_)<sup>?</sup>"
msgstr "(`,` _매개변수_)<sup>?</sup>"

#: src/notation.md:22
msgid "Groups items"
msgstr "항목 그룹화"

#: src/notation.md:24
msgid "String table productions"
msgstr "문자열 테이블 생성"

#: src/notation.md:26
msgid ""
"Some rules in the grammar — notably [unary operators](expressions/operator-"
"expr.md#borrow-operators), [binary operators](expressions/operator-"
"expr.md#arithmetic-and-logical-binary-operators), and [keywords]"
"(keywords.md) — are given in a simplified form: as a listing of printable "
"strings. These cases form a subset of the rules regarding the [token]"
"(tokens.md) rule, and are assumed to be the result of a lexical-analysis "
"phase feeding the parser, driven by a <abbr title=\"Deterministic Finite\n"
"Automaton\">DFA</abbr>, operating over the disjunction of all such string "
"table entries."
msgstr "문법의 일부 규칙(특히 [단항 연산자](expressions/operator-expr.md#borrow-operators), [이항 연산자](expressions/operator-expr.md#arithmetic-and-logical-binary-operators) 및 [키워드](keywords.md))은 인쇄 가능한 문자열 목록으로 단순화된 형태로 제공됩니다. 이러한 경우는 [토큰](tokens.md) 규칙에 관한 규칙의 하위 집합을 형성하며, <abbr title=\"결정론적 유한 오토마톤\">DFA</abbr>에 의해 구동되는 어휘 분석 단계가 파서에 공급하는 결과로 간주되며, 이러한 모든 문자열 테이블 항목의 논리합에 대해 작동합니다."

#: src/notation.md:34
msgid ""
"When such a string in `monospace` font occurs inside the grammar, it is an "
"implicit reference to a single member of such a string table production. See "
"[tokens](tokens.md) for more information."
msgstr "문법 내에서 `monospace` 글꼴의 문자열이 나타나면, 이는 해당 문자열 테이블 생성의 단일 멤버에 대한 암시적 참조입니다. 자세한 내용은 [토큰](tokens.md)을 참조하십시오."

#: src/input-format.md:7
msgid ""
"This chapter describes how a source file is interpreted as a sequence of "
"tokens."
msgstr "이 장에서는 소스 파일이 토큰 시퀀스로 해석되는 방법을 설명합니다."

#: src/input-format.md:9
msgid ""
"See [Crates and source files](crates-and-source-files.md) for a description "
"of how programs are organised into files."
msgstr "프로그램이 파일로 구성되는 방법에 대한 설명은 [크레이트 및 소스 파일](crates-and-source-files.md)을 참조하십시오."

#: src/input-format.md:13
msgid "Source encoding"
msgstr "소스 인코딩"

#: src/input-format.md:17
msgid ""
"Each source file is interpreted as a sequence of Unicode characters encoded "
"in UTF-8."
msgstr "각 소스 파일은 UTF-8로 인코딩된 유니코드 문자 시퀀스로 해석됩니다."

#: src/input-format.md:21
msgid "It is an error if the file is not valid UTF-8."
msgstr "파일이 유효한 UTF-8이 아니면 오류입니다."

#: src/input-format.md:25
msgid "Byte order mark removal"
msgstr "바이트 순서 마크 제거"

#: src/input-format.md:28
msgid ""
"If the first character in the sequence is `U+FEFF` ([BYTE ORDER MARK]"
"(https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8)), it is removed."
msgstr "시퀀스의 첫 번째 문자가 `U+FEFF`([바이트 순서 마크](https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8))이면 제거됩니다."

#: src/input-format.md:32
msgid "CRLF normalization"
msgstr "CRLF 정규화"

#: src/input-format.md:35
msgid ""
"Each pair of characters `U+000D` (CR) immediately followed by `U+000A` (LF) "
"is replaced by a single `U+000A` (LF)."
msgstr "`U+000D` (CR) 문자와 그 뒤에 바로 오는 `U+000A` (LF) 문자의 각 쌍은 단일 `U+000A` (LF)로 대체됩니다."

#: src/input-format.md:37
msgid ""
"Other occurrences of the character `U+000D` (CR) are left in place (they are "
"treated as [whitespace](whitespace.md))."
msgstr "`U+000D` (CR) 문자의 다른 발생은 그대로 유지됩니다(이들은 [공백](whitespace.md)으로 처리됩니다)."

#: src/input-format.md:41
msgid "Shebang removal"
msgstr "쉬뱅 제거"

#: src/input-format.md:45
msgid ""
"If the remaining sequence begins with the characters `#!`, the characters up "
"to and including the first `U+000A` (LF) are removed from the sequence."
msgstr "남은 시퀀스가 `#!` 문자로 시작하면, 첫 번째 `U+000A` (LF)까지의 문자가 시퀀스에서 제거됩니다."

#: src/input-format.md:47
msgid "For example, the first line of the following file would be ignored:"
msgstr "예를 들어, 다음 파일의 첫 번째 줄은 무시됩니다:"

#: src/input-format.md:54 src/macros.md:82
msgid "\"Hello!\""
msgstr "\"안녕하세요!\""

#: src/input-format.md:60
msgid ""
"As an exception, if the `#!` characters are followed (ignoring intervening "
"[comments](comments.md) or [whitespace](whitespace.md)) by a `[` token, "
"nothing is removed. This prevents an [inner attribute](attributes.md) at the "
"start of a source file being removed."
msgstr "예외적으로, `#!` 문자 뒤에 (중간에 있는 [주석](comments.md)이나 [공백](whitespace.md)을 무시하고) `[` 토큰이 오면 아무것도 제거되지 않습니다. 이는 소스 파일 시작 부분에 있는 [내부 속성](attributes.md)이 제거되는 것을 방지합니다."

#: src/input-format.md:63
msgid ""
"**Note**: The standard library [`include!`](../core/macro.include.html) "
"macro applies byte order mark removal, CRLF normalization, and shebang "
"removal to the file it reads. The [`include_str!`](../core/"
"macro.include_str.html) and [`include_bytes!`](../core/"
"macro.include_bytes.html) macros do not."
msgstr "**참고**: 표준 라이브러리 [`include!`](../core/macro.include.html) 매크로는 읽는 파일에 바이트 순서 마크 제거, CRLF 정규화 및 쉬뱅 제거를 적용합니다. [`include_str!`](../core/macro.include_str.html) 및 [`include_bytes!`](../core/macro.include_bytes.html) 매크로는 그렇지 않습니다."

#: src/input-format.md:67
msgid "Tokenization"
msgstr "토큰화"

#: src/input-format.md:70
msgid ""
"The resulting sequence of characters is then converted into tokens as "
"described in the remainder of this chapter."
msgstr "결과 문자 시퀀스는 이 장의 나머지 부분에 설명된 대로 토큰으로 변환됩니다."

#: src/keywords.md:5
msgid "Rust divides keywords into three categories:"
msgstr "러스트는 키워드를 세 가지 범주로 나눕니다:"

#: src/keywords.md:7
msgid "[strict](#strict-keywords)"
msgstr "[엄격](#strict-keywords)"

#: src/keywords.md:8
msgid "[reserved](#reserved-keywords)"
msgstr "[예약됨](#reserved-keywords)"

#: src/keywords.md:9
msgid "[weak](#weak-keywords)"
msgstr "[약함](#weak-keywords)"

#: src/keywords.md:13
msgid "Strict keywords"
msgstr "엄격한 키워드"

#: src/keywords.md:17
msgid ""
"These keywords can only be used in their correct contexts. They cannot be "
"used as the names of:"
msgstr "이 키워드는 올바른 컨텍스트에서만 사용할 수 있습니다. 다음 이름으로는 사용할 수 없습니다:"

#: src/keywords.md:20
msgid "[Items](items.md)"
msgstr "[아이템](items.md)"

#: src/keywords.md:21
msgid "[Variables](variables.md) and function parameters"
msgstr "[변수](variables.md) 및 함수 매개변수"

#: src/keywords.md:22
msgid "Fields and [variants](items/enumerations.md)"
msgstr "필드 및 [변형](items/enumerations.md)"

#: src/keywords.md:23
msgid "[Type parameters](types/parameters.md)"
msgstr "[타입 매개변수](types/parameters.md)"

#: src/keywords.md:24
msgid ""
"Lifetime parameters or [loop labels](expressions/loop-expr.md#loop-labels)"
msgstr "라이프타임 매개변수 또는 [루프 레이블](expressions/loop-expr.md#loop-labels)"

#: src/keywords.md:25
msgid "[Macros](macros.md) or [attributes](attributes.md)"
msgstr "[매크로](macros.md) 또는 [속성](attributes.md)"

#: src/keywords.md:26
msgid "[Macro placeholders](macros-by-example.md)"
msgstr "[매크로 플레이스홀더](macros-by-example.md)"

#: src/keywords.md:27
msgid "[Crates](crates-and-source-files.md)"
msgstr "[크레이트](crates-and-source-files.md)"

#: src/keywords.md:31
msgid ""
"**<sup>Lexer:<sup>**  \n"
"KW_AS             : `as`  \n"
"KW_BREAK          : `break`  \n"
"KW_CONST          : `const`  \n"
"KW_CONTINUE       : `continue`  \n"
"KW_CRATE          : `crate`  \n"
"KW_ELSE           : `else`  \n"
"KW_ENUM           : `enum`  \n"
"KW_EXTERN         : `extern`  \n"
"KW_FALSE          : `false`  \n"
"KW_FN             : `fn`  \n"
"KW_FOR            : `for`  \n"
"KW_IF             : `if`  \n"
"KW_IMPL           : `impl`  \n"
"KW_IN             : `in`  \n"
"KW_LET            : `let`  \n"
"KW_LOOP           : `loop`  \n"
"KW_MATCH          : `match`  \n"
"KW_MOD            : `mod`  \n"
"KW_MOVE           : `move`  \n"
"KW_MUT            : `mut`  \n"
"KW_PUB            : `pub`  \n"
"KW_REF            : `ref`  \n"
"KW_RETURN         : `return`  \n"
"KW_SELFVALUE      : `self`  \n"
"KW_SELFTYPE       : `Self`  \n"
"KW_STATIC         : `static`  \n"
"KW_STRUCT         : `struct`  \n"
"KW_SUPER          : `super`  \n"
"KW_TRAIT          : `trait`  \n"
"KW_TRUE           : `true`  \n"
"KW_TYPE           : `type`  \n"
"KW_UNSAFE         : `unsafe`  \n"
"KW_USE            : `use`  \n"
"KW_WHERE          : `where`  \n"
"KW_WHILE          : `while`"
msgstr ""
"**<sup>렉서:<sup>**  \n"
"KW_AS             : `as`  \n"
"KW_BREAK          : `break`  \n"
"KW_CONST          : `const`  \n"
"KW_CONTINUE       : `continue`  \n"
"KW_CRATE          : `crate`  \n"
"KW_ELSE           : `else`  \n"
"KW_ENUM           : `enum`  \n"
"KW_EXTERN         : `extern`  \n"
"KW_FALSE          : `false`  \n"
"KW_FN             : `fn`  \n"
"KW_FOR            : `for`  \n"
"KW_IF             : `if`  \n"
"KW_IMPL           : `impl`  \n"
"KW_IN             : `in`  \n"
"KW_LET            : `let`  \n"
"KW_LOOP           : `loop`  \n"
"KW_MATCH          : `match`  \n"
"KW_MOD            : `mod`  \n"
"KW_MOVE           : `move`  \n"
"KW_MUT            : `mut`  \n"
"KW_PUB            : `pub`  \n"
"KW_REF            : `ref`  \n"
"KW_RETURN         : `return`  \n"
"KW_SELFVALUE      : `self`  \n"
"KW_SELFTYPE       : `Self`  \n"
"KW_STATIC         : `static`  \n"
"KW_STRUCT         : `struct`  \n"
"KW_SUPER          : `super`  \n"
"KW_TRAIT          : `trait`  \n"
"KW_TRUE           : `true`  \n"
"KW_TYPE           : `type`  \n"
"KW_UNSAFE         : `unsafe`  \n"
"KW_USE            : `use`  \n"
"KW_WHERE          : `where`  \n"
"KW_WHILE          : `while`"

#: src/keywords.md:70
msgid "The following keywords were added beginning in the 2018 edition."
msgstr "다음 키워드는 2018년 에디션부터 추가되었습니다."

#: src/keywords.md:72
msgid ""
"**<sup>Lexer 2018+</sup>**  \n"
"KW_ASYNC          : `async`  \n"
"KW_AWAIT          : `await`  \n"
"KW_DYN            : `dyn`"
msgstr ""
"**<sup>렉서 2018+</sup>**  \n"
"KW_ASYNC          : `async`  \n"
"KW_AWAIT          : `await`  \n"
"KW_DYN            : `dyn`"

#: src/keywords.md:79
msgid "Reserved keywords"
msgstr "예약된 키워드"

#: src/keywords.md:83
msgid ""
"These keywords aren't used yet, but they are reserved for future use. They "
"have the same restrictions as strict keywords. The reasoning behind this is "
"to make current programs forward compatible with future versions of Rust by "
"forbidding them to use these keywords."
msgstr "이 키워드들은 아직 사용되지 않지만, 미래를 위해 예약되어 있습니다. 이 키워드들은 엄격한 키워드와 동일한 제약 조건을 가집니다. 이 키워드들을 사용하지 못하게 함으로써 현재 프로그램이 미래 버전의 Rust와 호환되도록 하기 위함입니다."

#: src/keywords.md:90
msgid ""
"**<sup>Lexer</sup>**  \n"
"KW_ABSTRACT       : `abstract`  \n"
"KW_BECOME         : `become`  \n"
"KW_BOX            : `box`  \n"
"KW_DO             : `do`  \n"
"KW_FINAL          : `final`  \n"
"KW_MACRO          : `macro`  \n"
"KW_OVERRIDE       : `override`  \n"
"KW_PRIV           : `priv`  \n"
"KW_TYPEOF         : `typeof`  \n"
"KW_UNSIZED        : `unsized`  \n"
"KW_VIRTUAL        : `virtual`  \n"
"KW_YIELD          : `yield`"
msgstr ""
"**<sup>렉서</sup>**  \n"
"KW_ABSTRACT       : `abstract`  \n"
"KW_BECOME         : `become`  \n"
"KW_BOX            : `box`  \n"
"KW_DO             : `do`  \n"
"KW_FINAL          : `final`  \n"
"KW_MACRO          : `macro`  \n"
"KW_OVERRIDE       : `override`  \n"
"KW_PRIV           : `priv`  \n"
"KW_TYPEOF         : `typeof`  \n"
"KW_UNSIZED        : `unsized`  \n"
"KW_VIRTUAL        : `virtual`  \n"
"KW_YIELD          : `yield`"

#: src/keywords.md:106
msgid "The following keywords are reserved beginning in the 2018 edition."
msgstr "다음 키워드는 2018년 에디션부터 예약되었습니다."

#: src/keywords.md:108
msgid ""
"**<sup>Lexer 2018+</sup>**  \n"
"KW_TRY   : `try`"
msgstr "**<sup>렉서 2018+</sup>**  \nKW_TRY   : `try`"

#: src/keywords.md:111
msgid "The following keywords are reserved beginning in the 2024 edition."
msgstr "다음 키워드는 2024년 에디션부터 예약되었습니다."

#: src/keywords.md:113
msgid ""
"**<sup>Lexer 2024+</sup>**  \n"
"KW_GEN   : `gen`"
msgstr "**<sup>렉서 2024+</sup>**  \nKW_GEN   : `gen`"

#: src/keywords.md:118
msgid "Weak keywords"
msgstr "약한 키워드"

#: src/keywords.md:122
msgid ""
"These keywords have special meaning only in certain contexts. For example, "
"it is possible to declare a variable or method with the name `union`."
msgstr "이 키워드는 특정 컨텍스트에서만 특별한 의미를 가집니다. 예를 들어, `union`이라는 이름으로 변수나 메서드를 선언할 수 있습니다."

#: src/keywords.md:125
msgid ""
"**<sup>Lexer</sup>**  \n"
"KW_MACRO_RULES    : `macro_rules`  \n"
"KW_UNION          : `union`  \n"
"KW_STATICLIFETIME : `'static`  \n"
"KW_SAFE           : `safe`  \n"
"KW_RAW            : `raw`"
msgstr ""
"**<sup>렉서</sup>**  \n"
"KW_MACRO_RULES    : `macro_rules`  \n"
"KW_UNION          : `union`  \n"
"KW_STATICLIFETIME : `'static`  \n"
"KW_SAFE           : `safe`  \n"
"KW_RAW            : `raw`"

#: src/keywords.md:132
msgid ""
"**<sup>Lexer 2015</sup>**  \n"
"KW_DYN            : `dyn`"
msgstr "**<sup>렉서 2015</sup>**  \nKW_DYN            : `dyn`"

#: src/keywords.md:137
msgid "`macro_rules` is used to create custom [macros](macros.md)."
msgstr "`macro_rules`는 사용자 정의 [매크로](macros.md)를 생성하는 데 사용됩니다."

#: src/keywords.md:141
msgid ""
"`union` is used to declare a [union](items/unions.md) and is only a keyword "
"when used in a union declaration."
msgstr "`union`은 [유니온](items/unions.md)을 선언하는 데 사용되며, 유니온 선언에서 사용될 때만 키워드입니다."

#: src/keywords.md:146
msgid ""
"`'static` is used for the static lifetime and cannot be used as a [generic "
"lifetime parameter](items/generics.md) or [loop label](expressions/loop-"
"expr.md#loop-labels)"
msgstr "`'static`은 정적 라이프타임에 사용되며, [제네릭 라이프타임 매개변수](items/generics.md) 또는 [루프 레이블](expressions/loop-expr.md#loop-labels)로 사용될 수 없습니다."

#: src/keywords.md:149
msgid ""
"```compile_fail\n"
"// error[E0262]: invalid lifetime parameter name: `'static`\n"
"fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str "
"{ s }\n"
"```"
msgstr "```compile_fail\n// error[E0262]: 잘못된 라이프타임 매개변수 이름: `'static`\nfn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n```"

#: src/keywords.md:156
msgid ""
"In the 2015 edition, [`dyn`](types/trait-object.md) is a keyword when used "
"in a type position followed by a path that does not start with `::` or `<`, "
"a lifetime, a question mark, a `for` keyword or an opening parenthesis."
msgstr "2015년 에디션에서 [`dyn`](types/trait-object.md)은 `::` 또는 `<`로 시작하지 않는 경로, 라이프타임, 물음표, `for` 키워드 또는 여는 괄호가 뒤따르는 타입 위치에서 사용될 때 키워드입니다."

#: src/keywords.md:160
msgid ""
"Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword."
msgstr "2018년 에디션부터 `dyn`은 엄격한 키워드로 승격되었습니다."

#: src/keywords.md:164
msgid ""
"`safe` is used for functions and statics, which has meaning in [external "
"blocks](items/external-blocks.md)."
msgstr "`safe`는 함수와 정적에 사용되며, [외부 블록](items/external-blocks.md)에서 의미를 가집니다."

#: src/keywords.md:168
msgid ""
"`raw` is used for [raw borrow operators](expressions/operator-expr.md#raw-"
"borrow-operators), and is only a keyword when matching a raw borrow operator "
"form (such as `&raw const expr` or `&raw mut expr`)."
msgstr "`raw`는 [원시 차용 연산자](expressions/operator-expr.md#raw-borrow-operators)에 사용되며, 원시 차용 연산자 형식(예: `&raw const expr` 또는 `&raw mut expr`)과 일치할 때만 키워드입니다."

#: src/identifiers.md:7
msgid ""
"**<sup>Lexer:</sup>**  \n"
"IDENTIFIER_OR_KEYWORD :  \n"
"      XID_Start XID_Continue<sup>\\*</sup>  \n"
"   | `_` XID_Continue<sup>+</sup>"
msgstr "**<sup>렉서:</sup>**  \n식별자_또는_키워드 :  \n      XID_시작 XID_계속<sup>*</sup>  \n   | `_` XID_계속<sup>+</sup>"

#: src/identifiers.md:12
msgid ""
"RAW_IDENTIFIER : `r#` IDENTIFIER_OR_KEYWORD <sub>_Except `crate`, `self`, "
"`super`, `Self`_</sub>"
msgstr "RAW_IDENTIFIER : `r#` 식별자_또는_키워드 <sub>_`crate`, `self`, `super`, `Self` 제외_</sub>"

#: src/identifiers.md:14
msgid ""
"NON_KEYWORD_IDENTIFIER : IDENTIFIER_OR_KEYWORD <sub>_Except a [strict]"
"(keywords.md#strict-keywords) or [reserved](keywords.md#reserved-keywords) "
"keyword_</sub>"
msgstr "비_키워드_식별자 : 식별자_또는_키워드 <sub>_[엄격한](keywords.md#strict-keywords) 또는 [예약된](keywords.md#reserved-keywords) 키워드 제외_</sub>"

#: src/identifiers.md:16
msgid ""
"IDENTIFIER :  \n"
"NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER"
msgstr "식별자 :  \n비_키워드_식별자 | 원시_식별자"

#: src/identifiers.md:19
msgid "RESERVED_RAW_IDENTIFIER : `r#_`"
msgstr "예약된_원시_식별자 : `r#_`"

#: src/identifiers.md:24
msgid ""
"Identifiers follow the specification in [Unicode Standard Annex #31](https://"
"www.unicode.org/reports/tr31/tr31-41.html) for Unicode version 16.0, with "
"the additions described below. Some examples of identifiers:"
msgstr "식별자는 유니코드 버전 16.0의 [유니코드 표준 부록 #31](https://www.unicode.org/reports/tr31/tr31-41.html) 사양을 따르며, 아래에 설명된 추가 사항이 있습니다. 식별자의 몇 가지 예:"

#: src/identifiers.md:26
msgid "`foo`"
msgstr "`foo`"

#: src/identifiers.md:27
msgid "`_identifier`"
msgstr "`_identifier`"

#: src/identifiers.md:28
msgid "`r#true`"
msgstr "`r#true`"

#: src/identifiers.md:29
msgid "`Москва`"
msgstr "`Москва`"

#: src/identifiers.md:30
msgid "`東京`"
msgstr "`東京`"

#: src/identifiers.md:34
msgid "The profile used from UAX #31 is:"
msgstr "UAX #31에서 사용된 프로필은 다음과 같습니다:"

#: src/identifiers.md:36
msgid ""
"Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?"
"a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=), plus the underscore character (U+005F)"
msgstr ""
"시작 := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=), 더하기 밑줄 문자 (U+005F)"

#: src/identifiers.md:37
msgid ""
"Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-"
"unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)"
msgstr ""
"계속 := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)"

#: src/identifiers.md:38
msgid "Medial := empty"
msgstr "중간 := 비어 있음"

#: src/identifiers.md:40
msgid ""
"with the additional constraint that a single underscore character is not an "
"identifier."
msgstr "단일 밑줄 문자는 식별자가 아니라는 추가 제약 조건과 함께."

#: src/identifiers.md:42
msgid ""
"**Note**: Identifiers starting with an underscore are typically used to "
"indicate an identifier that is intentionally unused, and will silence the "
"unused warning in `rustc`."
msgstr "**참고**: 밑줄로 시작하는 식별자는 일반적으로 의도적으로 사용되지 않는 식별자를 나타내는 데 사용되며, `rustc`의 사용되지 않는 경고를 억제합니다."

#: src/identifiers.md:46
msgid ""
"Identifiers may not be a [strict](keywords.md#strict-keywords) or [reserved]"
"(keywords.md#reserved-keywords) keyword without the `r#` prefix described "
"below in [raw identifiers](#raw-identifiers)."
msgstr "식별자는 아래 [원시 식별자](#raw-identifiers)에 설명된 `r#` 접두사 없이 [엄격한](keywords.md#strict-keywords) 또는 [예약된](keywords.md#reserved-keywords) 키워드일 수 없습니다."

#: src/identifiers.md:50
msgid ""
"Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) "
"characters are not allowed in identifiers."
msgstr "제로 너비 비결합자(ZWNJ U+200C) 및 제로 너비 결합자(ZWJ U+200D) 문자는 식별자에 허용되지 않습니다."

#: src/identifiers.md:54
msgid ""
"Identifiers are restricted to the ASCII subset of [`XID_Start`](http://"
"unicode.org/cldr/utility/list-unicodeset.jsp?"
"a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://"
"unicode.org/cldr/utility/list-unicodeset.jsp?"
"a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:"
msgstr "식별자는 다음 상황에서 [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) 및 [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)의 ASCII 서브셋으로 제한됩니다:"

#: src/identifiers.md:56
msgid ""
"[`extern crate`](items/extern-crates.md) declarations (except the _AsClause_ "
"identifier)"
msgstr "[`extern crate`](items/extern-crates.md) 선언 (_AsClause_ 식별자 제외)"

#: src/identifiers.md:57
msgid "External crate names referenced in a [path](paths.md)"
msgstr "[경로](paths.md)에서 참조되는 외부 크레이트 이름"

#: src/identifiers.md:58
msgid ""
"[Module](items/modules.md) names loaded from the filesystem without a "
"[`path` attribute](items/modules.md#the-path-attribute)"
msgstr "[`path` 속성](items/modules.md#the-path-attribute) 없이 파일 시스템에서 로드된 [모듈](items/modules.md) 이름"

#: src/identifiers.md:59
msgid "[`no_mangle`](abi.md#the-no_mangle-attribute) attributed items"
msgstr "[`no_mangle`](abi.md#the-no_mangle-attribute) 속성 항목"

#: src/identifiers.md:60
msgid "Item names in [external blocks](items/external-blocks.md)"
msgstr "[외부 블록](items/external-blocks.md)의 아이템 이름"

#: src/identifiers.md:64
msgid "Normalization"
msgstr "정규화"

#: src/identifiers.md:67
msgid ""
"Identifiers are normalized using Normalization Form C (NFC) as defined in "
"[Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/"
"tr15-56.html). Two identifiers are equal if their NFC forms are equal."
msgstr "식별자는 [유니코드 표준 부록 #15](https://www.unicode.org/reports/tr15/tr15-56.html)에 정의된 정규화 형식 C(NFC)를 사용하여 정규화됩니다. 두 식별자는 NFC 형식이 같으면 동일합니다."

#: src/identifiers.md:69
msgid ""
"[Procedural](procedural-macros.md) and [declarative](macros-by-example.md) "
"macros receive normalized identifiers in their input."
msgstr "[절차적](procedural-macros.md) 및 [선언적](macros-by-example.md) 매크로는 입력에서 정규화된 식별자를 받습니다."

#: src/identifiers.md:73
msgid "Raw identifiers"
msgstr "원시 식별자"

#: src/identifiers.md:77
msgid ""
"A raw identifier is like a normal identifier, but prefixed by `r#`. (Note "
"that the `r#` prefix is not included as part of the actual identifier.)"
msgstr "원시 식별자는 일반 식별자와 같지만 `r#` 접두사가 붙습니다. (`r#` 접두사는 실제 식별자의 일부로 포함되지 않습니다.)"

#: src/identifiers.md:82
msgid ""
"Unlike a normal identifier, a raw identifier may be any strict or reserved "
"keyword except the ones listed above for `RAW_IDENTIFIER`."
msgstr "일반 식별자와 달리, 원시 식별자는 `RAW_IDENTIFIER`에 대해 위에 나열된 키워드를 제외한 모든 엄격하거나 예약된 키워드일 수 있습니다."

#: src/identifiers.md:87
msgid ""
"It is an error to use the RESERVED_RAW_IDENTIFIER token `r#_` in order to "
"avoid confusion with the [_WildcardPattern_](patterns.md#wildcard-pattern)."
msgstr "[_와일드카드 패턴_](patterns.md#wildcard-pattern)과의 혼동을 피하기 위해 RESERVED_RAW_IDENTIFIER 토큰 `r#_`를 사용하는 것은 오류입니다."

#: src/comments.md:6
msgid ""
"**<sup>Lexer</sup>**  \n"
"LINE_COMMENT :  \n"
"      `//` (~\\[`/` `!` `\\n`\\] | `//`) ~`\\n`<sup>\\*</sup>  \n"
"   | `//`"
msgstr ""
"**<sup>렉서</sup>**  \n"
"라인_주석 :  \n"
"      `//` (~\\[`/` `!` `\\n`\\] | `//`) ~`\\n`<sup>\\*</sup>  \n"
"   | `//`"

#: src/comments.md:11
msgid ""
"BLOCK_COMMENT :  \n"
"      `/*` (~\\[`*` `!`\\] | `**` | _BlockCommentOrDoc_) "
"(_BlockCommentOrDoc_ | ~`*/`)<sup>\\*</sup> `*/`  \n"
"   | `/**/`  \n"
"   | `/***/`"
msgstr ""
"블록_주석 :  \n"
"      `/*` (~\\[`*` `!`\\] | `**` | _블록주석또는문서_) "
"(_블록주석또는문서_ | ~`*/`)<sup>\\*</sup> `*/`  \n"
"   | `/**/`  \n"
"   | `/***/`"

#: src/comments.md:17
msgid ""
"INNER_LINE_DOC :  \n"
"   `//!` ~\\[`\\n` _IsolatedCR_\\]<sup>\\*</sup>"
msgstr ""
"INNER_LINE_DOC :  \n"
"   `//!` ~\\[`\\n` _고립된CR_\\]<sup>\\*</sup>"

#: src/comments.md:20
msgid ""
"INNER_BLOCK_DOC :  \n"
"   `/*!` ( _BlockCommentOrDoc_ | ~\\[`*/` _IsolatedCR_\\] )<sup>\\*</sup> `*/`"
msgstr ""
"내부_블록_문서 :  \n"
"   `/*!` ( _블록주석또는문서_ | ~\\[`*/` _고립된CR_\\] )<sup>\\*</sup> `*/`"

#: src/comments.md:23
msgstr "OUTER_LINE_DOC :  \n" \
"   `///` (~`/` ~\\[`\\n` _IsolatedCR_\\]<sup>\\*</sup>)<sup>?</sup>"
"OUTER_LINE_DOC :  \n"
"   `///` (~`/` ~\\[`\\n` _IsolatedCR_\\]<sup>\\*</sup>)<sup>?</sup>"

#: src/comments.md:26
msgstr "OUTER_BLOCK_DOC :  \n" \
"   `/**` (~`*` | _BlockCommentOrDoc_ ) (_BlockCommentOrDoc_ | ~\\[`*/` _IsolatedCR_\\])<sup>\\*</sup> `*/`"
"OUTER_BLOCK_DOC :  \n"
"   `/**` (~`*` | _BlockCommentOrDoc_ ) (_BlockCommentOrDoc_ | ~\\[`*/` "
"_IsolatedCR_\\])<sup>\\*</sup> `*/`"

#: src/comments.md:30
msgid ""
"_BlockCommentOrDoc_ :  \n"
"      BLOCK_COMMENT  \n"
"   | OUTER_BLOCK_DOC  \n"
"   | INNER_BLOCK_DOC"
msgstr ""
"_블록주석또는문서_ :  \n"
"      블록_주석  \n"
"   | 외부_블록_문서  \n"
"   | 내부_블록_문서"

#: src/comments.md:35
msgid ""
"_IsolatedCR_ :  \n"
"   \\\\r"
msgstr ""
"_고립된CR_ :  \n"
"   \\\\r"

#: src/comments.md:40
msgid "Non-doc comments"
msgstr "비 문서 주석"

#: src/comments.md:43
msgid ""
"Comments follow the general C++ style of line (`//`) and block (`/* ... */`) "
"comment forms. Nested block comments are supported."
msgstr "주석은 일반적인 C++ 스타일의 라인 (`//`) 및 블록 (`/* ... */`) 주석 형식을 따릅니다. 중첩된 블록 주석이 지원됩니다."

#: src/comments.md:48
msgid "Non-doc comments are interpreted as a form of whitespace."
msgstr "비 문서 주석은 공백의 한 형태로 해석됩니다."

#: src/comments.md:52
msgid "Doc comments"
msgstr "문서 주석"

#: src/comments.md:56
msgid ""
"Line doc comments beginning with exactly _three_ slashes (`///`), and block "
"doc comments (`/** ... */`), both outer doc comments, are interpreted as a "
"special syntax for [`doc` attributes](../rustdoc/the-doc-attribute.html)."
msgstr "정확히 세 개의 슬래시(`///`)로 시작하는 라인 문서 주석과 블록 문서 주석(`/** ... */`), 이 두 가지 외부 문서 주석은 [`doc` 속성](../rustdoc/the-doc-attribute.html)을 위한 특별한 구문으로 해석됩니다."

#: src/comments.md:62
msgid ""
"That is, they are equivalent to writing `#[doc=\"...\"]` around the body of "
"the comment, i.e., `/// Foo` turns into `#[doc=\"Foo\"]` and `/** Bar */` "
"turns into `#[doc=\"Bar\"]`. They must therefore appear before something "
"that accepts an outer attribute."
msgstr "즉, 이들은 주석 본문 주위에 `#[doc=\"...\"]`를 작성하는 것과 동일합니다. 즉, `/// Foo`는 `#[doc=\"Foo\"]`로, `/** Bar */`는 `#[doc=\"Bar\"]`로 바뀝니다. 따라서 외부 속성을 허용하는 것 앞에 나타나야 합니다."

#: src/comments.md:69
msgid ""
"Line comments beginning with `//!` and block comments `/*! ... */` are doc "
"comments that apply to the parent of the comment, rather than the item that "
"follows."
msgstr "`//!`로 시작하는 라인 주석과 `/*! ... */` 블록 주석은 뒤따르는 항목이 아닌 주석의 부모에 적용되는 문서 주석입니다."

#: src/comments.md:75
msgid ""
"That is, they are equivalent to writing `#![doc=\"...\"]` around the body of "
"the comment. `//!` comments are usually used to document modules that occupy "
"a source file."
msgstr "즉, 이들은 주석 본문 주위에 `#![doc=\"...\"]`를 작성하는 것과 동일합니다. `//!` 주석은 일반적으로 소스 파일을 차지하는 모듈을 문서화하는 데 사용됩니다."

#: src/comments.md:81
msgid "The character `U+000D` (CR) is not allowed in doc comments."
msgstr "문서 주석에는 `U+000D` (CR) 문자가 허용되지 않습니다."

#: src/comments.md:83
msgid ""
"**Note**: It is conventional for doc comments to contain Markdown, as "
"expected by `rustdoc`. However, the comment syntax does not respect any "
"internal Markdown. ``/** `glob = \"*/*.rs\";` */`` terminates the comment at "
"the first `*/`, and the remaining code would cause a syntax error. This "
"slightly limits the content of block doc comments compared to line doc "
"comments."
msgstr "**참고**: `rustdoc`에서 예상하는 바와 같이 문서 주석에 마크다운을 포함하는 것이 일반적입니다. 그러나 주석 구문은 내부 마크다운을 존중하지 않습니다. ``/** `glob = \"*/*.rs\";` */``는 첫 번째 `*/`에서 주석을 종료하며, 나머지 코드는 구문 오류를 발생시킵니다. 이는 라인 문서 주석에 비해 블록 문서 주석의 내용을 약간 제한합니다."

#: src/comments.md:89
msgid ""
"**Note**:  The sequence `U+000D` (CR) immediately followed by `U+000A` (LF) "
"would have been previously transformed into a single `U+000A` (LF)."
msgstr "**참고**: `U+000D` (CR) 문자와 그 뒤에 바로 오는 `U+000A` (LF) 문자의 시퀀스는 이전에 단일 `U+000A` (LF)로 변환되었을 것입니다."

#: src/comments.md:94
msgid ""
"//! A doc comment that applies to the implicit anonymous module of this "
"crate\n"
msgstr "//! 이 크레이트의 암시적 익명 모듈에 적용되는 문서 주석\n"

#: src/comments.md:98
msgid ""
"//!  - Inner line doc\n"
"    //!! - Still an inner line doc (but with a bang at the beginning)\n"
msgstr ""
"//!  - 내부 라인 문서\n"
"    //!! - 여전히 내부 라인 문서 (하지만 시작에 느낌표가 있음)\n"

#: src/comments.md:101
msgid "/*!  - Inner block doc */"
msgstr "/*!  - 내부 블록 문서 */"

#: src/comments.md:102
msgid "/*!! - Still an inner block doc (but with a bang at the beginning) */"
msgstr "/*!! - 여전히 내부 블록 문서 (하지만 시작에 느낌표가 있음) */"

#: src/comments.md:104
msgid ""
"//   - Only a comment\n"
"    ///  - Outer line doc (exactly 3 slashes)\n"
"    //// - Only a comment\n"
msgstr ""
"//   - 단순 주석\n"
"    ///  - 외부 라인 문서 (정확히 슬래시 3개)\n"
"    //// - 단순 주석\n"

#: src/comments.md:108
msgid "/*   - Only a comment */"
msgstr "/*   - 단순 주석 */"

#: src/comments.md:109
msgid "/**  - Outer block doc (exactly) 2 asterisks */"
msgstr "/**  - 외부 블록 문서 (정확히) 별표 2개 */"

#: src/comments.md:110
msgid "/*** - Only a comment */"
msgstr "/*** - 단순 주석 */"

#: src/comments.md:115
msgid "/* In Rust /* we can /* nest comments */ */ */"
msgstr "/* Rust에서는 /* /* 주석을 중첩할 수 있습니다 */ */ */"

#: src/comments.md:117
msgid ""
"// All three types of block comments can contain or be nested inside\n"
"        // any other type:\n"
msgstr "// 세 가지 유형의 블록 주석은 다른 유형 내에 포함되거나 중첩될 수 있습니다:\n"

#: src/comments.md:120
msgid "/*   /* */  /** */  /*! */  */"
msgstr "/*   /* */  /** */  /*! */  */"

#: src/comments.md:121
msgid "/*!  /* */  /** */  /*! */  */"
msgstr "/*!  /* */  /** */  /*! */  */"

#: src/comments.md:122
msgid "/**  /* */  /** */  /*! */  */"
msgstr "/**  /* */  /** */  /*! */  */"

#: src/comments.md:127
msgid ""
"// empty inner line doc\n"
"        //!\n"
msgstr ""
"// 비어 있는 내부 라인 문서\n"
"        //!\n"

#: src/comments.md:130
msgid ""
"// empty inner block doc\n"
"        /*!*/"
msgstr ""
"// 비어 있는 내부 블록 문서\n"
"        /*!*/"

#: src/comments.md:133
msgid ""
"// empty line comment\n"
"        //\n"
msgstr ""
"// 비어 있는 라인 주석\n"
"        //\n"

#: src/comments.md:136
msgid ""
"// empty outer line doc\n"
"        ///\n"
msgstr ""
"// 비어 있는 외부 라인 문서\n"
"        ///\n"

#: src/comments.md:139
msgid ""
"// empty block comment\n"
"        /**/"
msgstr ""
"// 비어 있는 블록 주석\n"
"        /**/"

#: src/comments.md:144
msgid ""
"// empty 2-asterisk block isn't a doc block, it is a block comment\n"
"        /***/"
msgstr ""
"// 비어 있는 2-별표 블록은 문서 블록이 아니라 블록 주석입니다.\n"
"        /***/"

#: src/comments.md:149
msgid ""
"/* The next one isn't allowed because outer doc comments\n"
"       require an item that will receive the doc */"
msgstr "/* 다음은 외부 문서 주석이 문서를 받을 항목을 요구하기 때문에 허용되지 않습니다 */"

#: src/comments.md:152
msgid "/// Where is my item?\n"
msgstr "/// 내 항목은 어디에 있나요?\n"

#: src/whitespace.md:7
msgid ""
"Whitespace is any non-empty string containing only characters that have the "
"[`Pattern_White_Space`](https://www.unicode.org/reports/tr31/) Unicode "
"property, namely:"
msgstr "공백은 [`Pattern_White_Space`](https://www.unicode.org/reports/tr31/) 유니코드 속성을 가진 문자만 포함하는 비어 있지 않은 문자열입니다. 즉:"

#: src/whitespace.md:10
msgid "`U+0009` (horizontal tab, `'\\t'`)"
msgstr "`U+0009` (수평 탭, `'\\t'`)"

#: src/whitespace.md:11
msgid "`U+000A` (line feed, `'\\n'`)"
msgstr "`U+000A` (줄 바꿈, `'\\n'`)"

#: src/whitespace.md:12
msgid "`U+000B` (vertical tab)"
msgstr "`U+000B` (수직 탭)"

#: src/whitespace.md:13
msgid "`U+000C` (form feed)"
msgstr "`U+000C` (폼 피드)"

#: src/whitespace.md:14
msgid "`U+000D` (carriage return, `'\\r'`)"
msgstr "`U+000D` (캐리지 리턴, `'\\r'`)"

#: src/whitespace.md:15
msgid "`U+0020` (space, `' '`)"
msgstr "`U+0020` (공백, `' '`)"

#: src/whitespace.md:16
msgid "`U+0085` (next line)"
msgstr "`U+0085` (다음 줄)"

#: src/whitespace.md:17
msgid "`U+200E` (left-to-right mark)"
msgstr "`U+200E` (좌에서 우로 마크)"

#: src/whitespace.md:18
msgid "`U+200F` (right-to-left mark)"
msgstr "`U+200F` (우에서 좌로 마크)"

#: src/whitespace.md:19
msgid "`U+2028` (line separator)"
msgstr "`U+2028` (줄 구분자)"

#: src/whitespace.md:20
msgid "`U+2029` (paragraph separator)"
msgstr "`U+2029` (단락 구분자)"

#: src/whitespace.md:24
msgid ""
"Rust is a \"free-form\" language, meaning that all forms of whitespace serve "
"only to separate _tokens_ in the grammar, and have no semantic significance."
msgstr "Rust는 \"자유 형식\" 언어입니다. 즉, 모든 형태의 공백은 문법에서 _토큰_을 구분하는 역할만 하며, 의미론적 중요성은 없습니다."

#: src/whitespace.md:29
msgid ""
"A Rust program has identical meaning if each whitespace element is replaced "
"with any other legal whitespace element, such as a single space character."
msgstr "Rust 프로그램은 각 공백 요소가 단일 공백 문자처럼 다른 유효한 공백 요소로 대체되어도 동일한 의미를 가집니다."

#: src/tokens.md:7
msgid ""
"Tokens are primitive productions in the grammar defined by regular (non-"
"recursive) languages.  Rust source input can be broken down into the "
"following kinds of tokens:"
msgstr "토큰은 정규 (비재귀) 언어로 정의된 문법의 기본 생성물입니다. Rust 소스 입력은 다음 종류의 토큰으로 나눌 수 있습니다:"

#: src/tokens.md:11
msgid "[Keywords](keywords.md)"
msgstr "[키워드](keywords.md)"

#: src/tokens.md:12
msgid "[Identifiers](identifiers.md)"
msgstr "[식별자](identifiers.md)"

#: src/tokens.md:13
msgid "[Literals](#literals)"
msgstr "[리터럴](#literals)"

#: src/tokens.md:14
msgid "[Lifetimes](#lifetimes-and-loop-labels)"
msgstr "[라이프타임](#lifetimes-and-loop-labels)"

#: src/tokens.md:15
msgid "[Punctuation](#punctuation)"
msgstr "[구두점](#punctuation)"

#: src/tokens.md:16
msgid "[Delimiters](#delimiters)"
msgstr "[구분자](#delimiters)"

#: src/tokens.md:18
msgid ""
"Within this documentation's grammar, \"simple\" tokens are given in [string "
"table production](notation.md#string-table-productions) form, and appear in "
"`monospace` font."
msgstr "이 문서의 문법에서 \"단순\" 토큰은 [문자열 테이블 생성](notation.md#string-table-productions) 형식으로 주어지며, `monospace` 글꼴로 나타납니다."

#: src/tokens.md:25
msgid "Literals"
msgstr "리터럴"

#: src/tokens.md:27
msgid ""
"Literals are tokens used in [literal expressions](expressions/literal-"
"expr.md)."
msgstr "리터럴은 [리터럴 표현식](expressions/literal-expr.md)에 사용되는 토큰입니다."

#: src/tokens.md:31
msgid "Characters and strings"
msgstr "문자와 문자열"

#: src/tokens.md:33 src/tokens.md:85 src/attributes.md:224
#: src/expressions/closure-expr.md:99 src/inline-assembly.md:27
msgid "Example"
msgstr "예시"

#: src/tokens.md:33
msgid "`#` sets[^nsets]"
msgstr "`#` 세트[^nsets]"

#: src/tokens.md:33
msgid "Characters"
msgstr "문자"

#: src/tokens.md:33 src/expressions/literal-expr.md:47
msgid "Escapes"
msgstr "이스케이프"

#: src/tokens.md:35
msgid "[Character](#character-literals)"
msgstr "[문자](#character-literals)"

#: src/tokens.md:35
msgid "`'H'`"
msgstr "`'H'`"

#: src/tokens.md:35 src/tokens.md:36 src/tokens.md:38 src/tokens.md:39
#: src/tokens.md:41 src/types/numeric.md:15 src/types/numeric.md:16
#: src/types/numeric.md:17 src/types/numeric.md:18 src/types/numeric.md:19
msgid "0"
msgstr "0"

#: src/tokens.md:35 src/tokens.md:36 src/tokens.md:37 src/tokens.md:41
#: src/tokens.md:42
msgid "All Unicode"
msgstr "모든 유니코드"

#: src/tokens.md:35 src/tokens.md:36
msgid ""
"[Quote](#quote-escapes) & [ASCII](#ascii-escapes) & [Unicode](#unicode-"
"escapes)"
msgstr "[인용](#quote-escapes) & [ASCII](#ascii-escapes) & [유니코드](#unicode-escapes)"

#: src/tokens.md:36
msgid "[String](#string-literals)"
msgstr "[문자열](#string-literals)"

#: src/tokens.md:36
msgid "`\"hello\"`"
msgstr "`\"hello\"`"

#: src/tokens.md:37
msgid "[Raw string](#raw-string-literals)"
msgstr "[원시 문자열](#raw-string-literals)"

#: src/tokens.md:37
msgid "`r#\"hello\"#`"
msgstr "`r#\"hello\"#`"

#: src/tokens.md:37 src/tokens.md:40 src/tokens.md:42
msgid "\\<256"
msgstr "\\<256"

#: src/tokens.md:37 src/tokens.md:40 src/tokens.md:42 src/tokens.md:87
#: src/tokens.md:88 src/tokens.md:89 src/tokens.md:90
msgid "`N/A`"
msgstr "`N/A`"

#: src/tokens.md:38
msgid "[Byte](#byte-literals)"
msgstr "[바이트](#byte-literals)"

#: src/tokens.md:38
msgid "`b'H'`"
msgstr "`b'H'`"

#: src/tokens.md:38 src/tokens.md:39 src/tokens.md:40
msgid "All ASCII"
msgstr "모든 ASCII"

#: src/tokens.md:38 src/tokens.md:39
msgid "[Quote](#quote-escapes) & [Byte](#byte-escapes)"
msgstr "[인용](#quote-escapes) & [바이트](#byte-escapes)"

#: src/tokens.md:39
msgid "[Byte string](#byte-string-literals)"
msgstr "[바이트 문자열](#byte-string-literals)"

#: src/tokens.md:39
msgid "`b\"hello\"`"
msgstr "`b\"hello\"`"

#: src/tokens.md:40
msgid "[Raw byte string](#raw-byte-string-literals)"
msgstr "[원시 바이트 문자열](#raw-byte-string-literals)"

#: src/tokens.md:40
msgid "`br#\"hello\"#`"
msgstr "`br#\"hello\"#`"

#: src/tokens.md:41
msgid "[C string](#c-string-literals)"
msgstr "[C 문자열](#c-string-literals)"

#: src/tokens.md:41
msgid "`c\"hello\"`"
msgstr "`c\"hello\"`"

#: src/tokens.md:41
msgid ""
"[Quote](#quote-escapes) & [Byte](#byte-escapes) & [Unicode](#unicode-escapes)"
msgstr "[인용](#quote-escapes) & [바이트](#byte-escapes) & [유니코드](#unicode-escapes)"

#: src/tokens.md:42
msgid "[Raw C string](#raw-c-string-literals)"
msgstr "[원시 C 문자열](#raw-c-string-literals)"

#: src/tokens.md:42
msgid "`cr#\"hello\"#`"
msgstr "`cr#\"hello\"#`"

#: src/tokens.md:44
msgid "The number of `#`s on each side of the same literal must be equivalent."
msgstr "동일한 리터럴의 각 면에 있는 `#`의 수는 동일해야 합니다."

#: src/tokens.md:46
msgid ""
"**Note**:  Character and string literal tokens never include the sequence of "
"`U+000D` (CR) immediately followed by `U+000A` (LF): this pair would have "
"been previously transformed into a single `U+000A` (LF)."
msgstr "**참고**: 문자 및 문자열 리터럴 토큰은 `U+000D` (CR) 뒤에 `U+000A` (LF)가 즉시 오는 시퀀스를 포함하지 않습니다. 이 쌍은 이전에 단일 `U+000A` (LF)로 변환되었을 것입니다."

#: src/tokens.md:48
msgid "ASCII escapes"
msgstr "ASCII 이스케이프"

#: src/tokens.md:50 src/tokens.md:61 src/tokens.md:72 src/tokens.md:78
#: src/tokens.md:881 src/glossary.md:151
msgid "Name"
msgstr "이름"

#: src/tokens.md:52
msgid "`\\x41`"
msgstr "`\\x41`"

#: src/tokens.md:52
msgid "7-bit character code (exactly 2 digits, up to 0x7F)"
msgstr "7비트 문자 코드 (정확히 2자리, 최대 0x7F)"

#: src/tokens.md:53 src/tokens.md:64 src/expressions/literal-expr.md:75
msgid "`\\n`"
msgstr "`\\n`"

#: src/tokens.md:53 src/tokens.md:64
msgid "Newline"
msgstr "새 줄"

#: src/tokens.md:54 src/tokens.md:65 src/expressions/literal-expr.md:76
msgid "`\\r`"
msgstr "`\\r`"

#: src/tokens.md:54 src/tokens.md:65
msgid "Carriage return"
msgstr "캐리지 리턴"

#: src/tokens.md:55 src/tokens.md:66 src/expressions/literal-expr.md:74
msgid "`\\t`"
msgstr "`\\t`"

#: src/tokens.md:55 src/tokens.md:66
msgid "Tab"
msgstr "탭"

#: src/tokens.md:56 src/tokens.md:67 src/expressions/literal-expr.md:79
msgid "`\\\\`"
msgstr "`\\\\`"

#: src/tokens.md:56 src/tokens.md:67
msgid "Backslash"
msgstr "백슬래시"

#: src/tokens.md:57 src/tokens.md:68 src/expressions/literal-expr.md:73
msgid "`\\0`"
msgstr "`\\0`"

#: src/tokens.md:57 src/tokens.md:68
msgid "Null"
msgstr "널"

#: src/tokens.md:59
msgid "Byte escapes"
msgstr "바이트 이스케이프"

#: src/tokens.md:63
msgid "`\\x7F`"
msgstr "`\\x7F`"

#: src/tokens.md:63
msgid "8-bit character code (exactly 2 digits)"
msgstr "8비트 문자 코드 (정확히 2자리)"

#: src/tokens.md:70 src/expressions/literal-expr.md:101
msgid "Unicode escapes"
msgstr "유니코드 이스케이프"

#: src/tokens.md:74
msgid "`\\u{7FFF}`"
msgstr "`\\u{7FFF}`"

#: src/tokens.md:74
msgid "24-bit Unicode character code (up to 6 digits)"
msgstr "24비트 유니코드 문자 코드 (최대 6자리)"

#: src/tokens.md:76
msgid "Quote escapes"
msgstr "인용 이스케이프"

#: src/tokens.md:80 src/expressions/literal-expr.md:78
msgid "`\\'`"
msgstr "`\\'`"

#: src/tokens.md:80
msgid "Single quote"
msgstr "작은따옴표"

#: src/tokens.md:81 src/expressions/literal-expr.md:77
msgid "`\\\"`"
msgstr "큰따옴표"

#: src/tokens.md:81
msgid "Double quote"
msgstr "큰따옴표"

#: src/tokens.md:83
msgid "Numbers"
msgstr "숫자"

#: src/tokens.md:85
msgid "[Number literals](#number-literals)[^nl]"
msgstr "[숫자 리터럴](#number-literals)[^nl]"

#: src/tokens.md:85
msgid "Exponentiation"
msgstr "지수"

#: src/tokens.md:87
msgid "Decimal integer"
msgstr "10진수 정수"

#: src/tokens.md:87
msgid "`98_222`"
msgstr "`98_222`"

#: src/tokens.md:88
msgid "Hex integer"
msgstr "16진수 정수"

#: src/tokens.md:88
msgid "`0xff`"
msgstr "`0xff`"

#: src/tokens.md:89
msgid "Octal integer"
msgstr "8진수 정수"

#: src/tokens.md:89
msgid "`0o77`"
msgstr "`0o77`"

#: src/tokens.md:90
msgid "Binary integer"
msgstr "2진수 정수"

#: src/tokens.md:90
msgid "`0b1111_0000`"
msgstr "`0b1111_0000`"

#: src/tokens.md:91 src/tokens.md:131
msgid "Floating-point"
msgstr "부동 소수점"

#: src/tokens.md:91
msgid "`123.0E+77`"
msgstr "`123.0E+77`"

#: src/tokens.md:91
msgid "`Optional`"
msgstr "`선택 사항`"

#: src/tokens.md:93
msgid "All number literals allow `_` as a visual separator: `1_234.0E+18f64`"
msgstr "모든 숫자 리터럴은 `_`를 시각적 구분자로 허용합니다: `1_234.0E+18f64`"

#: src/tokens.md:97
msgid "Suffixes"
msgstr "접미사"

#: src/tokens.md:101
msgid ""
"A suffix is a sequence of characters following the primary part of a literal "
"(without intervening whitespace), of the same form as a non-raw identifier "
"or keyword."
msgstr "접미사는 리터럴의 주요 부분 뒤에 오는 문자 시퀀스(중간 공백 없이)로, 비원시 식별자 또는 키워드와 동일한 형태입니다."

#: src/tokens.md:105
msgid ""
"**<sup>Lexer</sup>**  \n"
"SUFFIX : IDENTIFIER_OR_KEYWORD  \n"
"SUFFIX_NO_E : SUFFIX <sub>_not beginning with `e` or `E`_</sub>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"SUFFIX : 식별자_또는_키워드  \n"
"SUFFIX_NO_E : SUFFIX <sub>_`e` 또는 `E`로 시작하지 않음_</sub>"
"**<sup>렉서</sup>**  \n"
"SUFFIX : 식별자_또는_키워드  \n"
"SUFFIX_NO_E : SUFFIX <sub>_`e` 또는 `E`로 시작하지 않음_</sub>"

#: src/tokens.md:111
msgid ""
"Any kind of literal (string, integer, etc) with any suffix is valid as a "
"token."
msgstr "어떤 종류의 리터럴(문자열, 정수 등)이든 어떤 접미사와 함께 사용되어도 유효한 토큰입니다."

#: src/tokens.md:113
msgid ""
"A literal token with any suffix can be passed to a macro without producing "
"an error. The macro itself will decide how to interpret such a token and "
"whether to produce an error or not. In particular, the `literal` fragment "
"specifier for by-example macros matches literal tokens with arbitrary "
"suffixes."
msgstr "어떤 접미사가 붙은 리터럴 토큰도 오류 없이 매크로에 전달될 수 있습니다. 매크로 자체는 그러한 토큰을 해석하는 방법과 오류를 발생시킬지 여부를 결정합니다. 특히, 예제 매크로의 `literal` 프래그먼트 지정자는 임의의 접미사가 붙은 리터럴 토큰과 일치합니다."

#: src/tokens.md:121
msgid "\"string\""
msgstr "\"string\""

#: src/tokens.md:121 src/tokens.md:122 src/items/type-aliases.md:37
#: src/names/scopes.md:161 src/names/scopes.md:162 src/names/scopes.md:163
msgid "// OK\n"
msgstr "// OK\n"

#: src/tokens.md:127
msgid ""
"However, suffixes on literal tokens which are interpreted as literal "
"expressions or patterns are restricted. Any suffixes are rejected on non-"
"numeric literal tokens, and numeric literal tokens are accepted only with "
"suffixes from the list below."
msgstr "그러나 리터럴 표현식 또는 패턴으로 해석되는 리터럴 토큰의 접미사는 제한됩니다. 비숫자 리터럴 토큰의 모든 접미사는 거부되며, 숫자 리터럴 토큰은 아래 목록의 접미사만 허용됩니다."

#: src/tokens.md:131 src/expressions/operator-expr.md:311
#: src/expressions/operator-expr.md:356 src/expressions/operator-expr.md:534
#: src/expressions/operator-expr.md:536
msgid "Integer"
msgstr "정수"

#: src/tokens.md:133
msgid ""
"`u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, "
"`usize`, `isize`"
msgstr "`u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, `isize`"

#: src/tokens.md:133 src/inline-assembly.md:617
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/tokens.md:135
msgid "Character and string literals"
msgstr "문자 및 문자열 리터럴"

#: src/tokens.md:139
msgid "Character literals"
msgstr "문자 리터럴"

#: src/tokens.md:143
msgid ""
"**<sup>Lexer</sup>**  \n"
"CHAR_LITERAL :  \n"
"   `'` ( ~\\[`'` `\\` \\\\n \\\\r \\\\t\\] | QUOTE_ESCAPE | ASCII_ESCAPE | "
"UNICODE_ESCAPE ) `'` SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"CHAR_LITERAL :  \n"
"   `'` ( ~\\[`'` `\\` \\\\n \\\\r \\\\t\\] | QUOTE_ESCAPE | ASCII_ESCAPE | "
"UNICODE_ESCAPE ) `'` SUFFIX<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"CHAR_LITERAL :  \n"
"   `'` ( ~\\[`'` `\\` \\\\n \\\\r \\\\t\\] | QUOTE_ESCAPE | ASCII_ESCAPE | "
"UNICODE_ESCAPE ) `'` SUFFIX<sup>?</sup>"

#: src/tokens.md:147
msgid ""
"QUOTE_ESCAPE :  \n"
"   `\\'` | `\\\"`"
msgstr ""
"QUOTE_ESCAPE :  \n"
"   `\\'` | `\\\"`"

#: src/tokens.md:150
msgid ""
"ASCII_ESCAPE :  \n"
"      `\\x` OCT_DIGIT HEX_DIGIT  \n"
"   | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0`"
msgstr ""
"ASCII_ESCAPE :  \n"
"      `\\x` 8진수_숫자 16진수_숫자  \n"
"   | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0`"
"ASCII_ESCAPE :  \n"
"      `\\x` 8진수_숫자 16진수_숫자  \n"
"   | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0`"

#: src/tokens.md:154
msgid ""
"UNICODE_ESCAPE :  \n"
"   `\\u{` ( HEX_DIGIT `_`<sup>\\*</sup> )<sup>1..6</sup> `}`"
msgstr ""
"UNICODE_ESCAPE :  \n"
"   `\\u{` ( 16진수_숫자 `_`<sup>*</sup> )<sup>1..6</sup> `}`"
"UNICODE_ESCAPE :  \n"
"   `\\u{` ( 16진수_숫자 `_`<sup>*</sup> )<sup>1..6</sup> `}`"

#: src/tokens.md:159
msgid ""
"A _character literal_ is a single Unicode character enclosed within two "
"`U+0027` (single-quote) characters, with the exception of `U+0027` itself, "
"which must be _escaped_ by a preceding `U+005C` character (`\\`)."
msgstr "_문자 리터럴_은 두 개의 `U+0027`(작은따옴표) 문자 안에 묶인 단일 유니코드 문자입니다. 단, `U+0027` 자체는 선행하는 `U+005C` 문자(`\\`)로 _이스케이프_되어야 합니다."

#: src/tokens.md:165
msgid "String literals"
msgstr "문자열 리터럴"

#: src/tokens.md:169
msgid ""
"**<sup>Lexer</sup>**  \n"
"STRING_LITERAL :  \n"
"   `\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_\\]  \n"
"      | QUOTE_ESCAPE  \n"
"      | ASCII_ESCAPE  \n"
"      | UNICODE_ESCAPE  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>\\*</sup> `\"` SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"STRING_LITERAL :  \n"
"   `\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_\\]  \n"
"      | QUOTE_ESCAPE  \n"
"      | ASCII_ESCAPE  \n"
"      | UNICODE_ESCAPE  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>*</sup> `\"` SUFFIX<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"STRING_LITERAL :  \n"
"   `\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_\\]  \n"
"      | QUOTE_ESCAPE  \n"
"      | ASCII_ESCAPE  \n"
"      | UNICODE_ESCAPE  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>*</sup> `\"` SUFFIX<sup>?</sup>"

#: src/tokens.md:179
msgid ""
"STRING_CONTINUE :  \n"
"   `\\` _followed by_ \\\\n"
msgstr ""
"STRING_CONTINUE :  \n"
"   `\\` _뒤에_ \\\\n"
"STRING_CONTINUE :  \n"
"   `\\` _뒤에_ \\\\n"

#: src/tokens.md:184
msgid ""
"A _string literal_ is a sequence of any Unicode characters enclosed within "
"two `U+0022` (double-quote) characters, with the exception of `U+0022` "
"itself, which must be _escaped_ by a preceding `U+005C` character (`\\`)."
msgstr "_문자열 리터럴_은 두 개의 `U+0022`(큰따옴표) 문자 안에 묶인 모든 유니코드 문자 시퀀스입니다. 단, `U+0022` 자체는 선행하는 `U+005C` 문자(`\\`)로 _이스케이프_되어야 합니다."

#: src/tokens.md:190
msgid ""
"Line-breaks, represented by the  character `U+000A` (LF), are allowed in "
"string literals. When an unescaped `U+005C` character (`\\`) occurs "
"immediately before a line break, the line break does not appear in the "
"string represented by the token. See [String continuation escapes]"
"(expressions/literal-expr.md#string-continuation-escapes) for details. The "
"character `U+000D` (CR) may not appear in a string literal other than as "
"part of such a string continuation escape."
msgstr "`U+000A`(LF) 문자로 표현되는 줄 바꿈은 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 `U+005C` 문자(`\\`)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 [문자열 연속 이스케이프](expressions/literal-expr.md#string-continuation-escapes)를 참조하십시오. `U+000D`(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 문자열 리터럴에 나타날 수 없습니다."

#: src/tokens.md:197
msgid "Character escapes"
msgstr "문자 이스케이프"

#: src/tokens.md:201
msgid ""
"Some additional _escapes_ are available in either character or non-raw "
"string literals. An escape starts with a `U+005C` (`\\`) and continues with "
"one of the following forms:"
msgstr "문자 또는 비원시 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 `U+005C`(`\\`)로 시작하며 다음 형식 중 하나로 이어집니다:"

#: src/tokens.md:207
msgid ""
"A _7-bit code point escape_ starts with `U+0078` (`x`) and is followed by "
"exactly two _hex digits_ with value up to `0x7F`. It denotes the ASCII "
"character with value equal to the provided hex value. Higher values are not "
"permitted because it is ambiguous whether they mean Unicode code points or "
"byte values."
msgstr "_7비트 코드 포인트 이스케이프_는 `U+0078`(`x`)로 시작하며, `0x7F`까지의 값을 가진 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 값을 가진 ASCII 문자를 나타냅니다. 더 높은 값은 유니코드 코드 포인트를 의미하는지 바이트 값을 의미하는지 모호하기 때문에 허용되지 않습니다."

#: src/tokens.md:215
msgid ""
"A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed by "
"up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D` (`}"
"`). It denotes the Unicode code point equal to the provided hex value."
msgstr "_24비트 코드 포인트 이스케이프_는 `U+0075`(`u`)로 시작하며, `U+007B`(`{`)와 `U+007D`(`}`) 중괄호로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타냅니다."

#: src/tokens.md:221
msgid ""
"A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072` "
"(`r`), or `U+0074` (`t`), denoting the Unicode values `U+000A` (LF), "
"`U+000D` (CR) or `U+0009` (HT) respectively."
msgstr "_공백 이스케이프_는 `U+006E`(`n`), `U+0072`(`r`), 또는 `U+0074`(`t`) 문자 중 하나이며, 각각 유니코드 값 `U+000A`(LF), `U+000D`(CR) 또는 `U+0009`(HT)를 나타냅니다."

#: src/tokens.md:227
msgid ""
"The _null escape_ is the character `U+0030` (`0`) and denotes the Unicode "
"value `U+0000` (NUL)."
msgstr "_널 이스케이프_는 `U+0030`(`0`) 문자이며 유니코드 값 `U+0000`(NUL)을 나타냅니다."

#: src/tokens.md:232
msgid ""
"The _backslash escape_ is the character `U+005C` (`\\`) which must be "
"_escaped_ in order to denote itself."
msgstr "_백슬래시 이스케이프_는 `U+005C`(`\\`) 문자이며, 자신을 나타내기 위해 _이스케이프_되어야 합니다."

#: src/tokens.md:237
msgid "Raw string literals"
msgstr "원시 문자열 리터럴"

#: src/tokens.md:241
msgid ""
"**<sup>Lexer</sup>**  \n"
"RAW_STRING_LITERAL :  \n"
"   `r` RAW_STRING_CONTENT SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"RAW_STRING_LITERAL :  \n"
"   `r` 원시_문자열_내용 접미사<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"RAW_STRING_LITERAL :  \n"
"   `r` 원시_문자열_내용 접미사<sup>?</sup>"

#: src/tokens.md:245
msgid ""
"RAW_STRING_CONTENT :  \n"
"      `\"` ( ~ _IsolatedCR_ )<sup>\\* (non-greedy)</sup> `\"`  \n"
"   | `#` RAW_STRING_CONTENT `#`"
msgstr ""
"RAW_STRING_CONTENT :  \n"
"      `\"` ( ~ _IsolatedCR_ )<sup>* (non-greedy)</sup> `\"`  \n"
"   | `#` 원시_문자열_내용 `#`"
"RAW_STRING_CONTENT :  \n"
"      `\"` ( ~ _IsolatedCR_ )<sup>* (non-greedy)</sup> `\"`  \n"
"   | `#` 원시_문자열_내용 `#`"

#: src/tokens.md:251
msgid ""
"Raw string literals do not process any escapes. They start with the "
"character `U+0072` (`r`), followed by fewer than 256 of the character "
"`U+0023` (`#`) and a `U+0022` (double-quote) character."
msgstr "원시 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 `U+0072`(`r`) 문자로 시작하며, 256개 미만의 `U+0023`(`#`) 문자와 `U+0022`(큰따옴표) 문자가 뒤따릅니다."

#: src/tokens.md:257
msgid ""
"The _raw string body_ can contain any sequence of Unicode characters other "
"than `U+000D` (CR). It is terminated only by another `U+0022` (double-quote) "
"character, followed by the same number of `U+0023` (`#`) characters that "
"preceded the opening `U+0022` (double-quote) character."
msgstr "_원시 문자열 본문_은 `U+000D`(CR)를 제외한 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 `U+0022`(큰따옴표) 문자로만 종료되며, 여는 `U+0022`(큰따옴표) 문자 앞에 있던 것과 동일한 수의 `U+0023`(`#`) 문자가 뒤따릅니다."

#: src/tokens.md:262
msgid ""
"All Unicode characters contained in the raw string body represent "
"themselves, the characters `U+0022` (double-quote) (except when followed by "
"at least as many `U+0023` (`#`) characters as were used to start the raw "
"string literal) or `U+005C` (`\\`) do not have any special meaning."
msgstr "원시 문자열 본문에 포함된 모든 유니코드 문자는 그 자체를 나타내며, `U+0022`(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 `U+0023`(`#`) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 `U+005C`(`\\`)는 특별한 의미를 갖지 않습니다."

#: src/tokens.md:267
msgid "Examples for string literals:"
msgstr "문자열 리터럴 예시:"

#: src/tokens.md:270 src/tokens.md:543 src/items/external-blocks.md:288
#: src/attributes/type_system.md:126 src/attributes/type_system.md:131
#: src/expressions/literal-expr.md:234 src/expressions/literal-expr.md:399
#: src/types/closure.md:296 src/types/closure.md:313 src/types/closure.md:647
#: src/types/closure.md:732
msgid "\"foo\""
msgstr "\"foo\""

#: src/tokens.md:270 src/tokens.md:543 src/expressions/literal-expr.md:234
#: src/expressions/literal-expr.md:399
msgid "r\"foo\""
msgstr "r\"foo\""

#: src/tokens.md:270 src/expressions/literal-expr.md:234
msgid ""
"// foo\n"
"\"\\\"foo\\\"\""
msgstr ""
"// foo\n"
"\"\\\"foo\\\"\""

#: src/tokens.md:271 src/tokens.md:544 src/expressions/literal-expr.md:235
#: src/expressions/literal-expr.md:400
msgid "r#\"\"foo\"\"#"
msgstr "r#\"\"foo\"\"#"

#: src/tokens.md:271 src/tokens.md:405 src/tokens.md:544
#: src/expressions/literal-expr.md:235 src/expressions/literal-expr.md:342
#: src/expressions/literal-expr.md:400
msgid "// \"foo\"\n"
msgstr "// \"foo\"\n"

#: src/tokens.md:272 src/tokens.md:546 src/expressions/literal-expr.md:236
#: src/expressions/literal-expr.md:402
msgid "\"foo #\\\"# bar\""
msgstr "\"foo #\\\"# bar\""

#: src/tokens.md:273 src/tokens.md:547 src/expressions/literal-expr.md:237
#: src/expressions/literal-expr.md:403
msgid "r##\"foo #\"# bar\"##"
msgstr "r##\"foo #\"# bar\"##"

#: src/tokens.md:274 src/tokens.md:408 src/tokens.md:547
#: src/expressions/literal-expr.md:238 src/expressions/literal-expr.md:345
#: src/expressions/literal-expr.md:403
msgid "// foo #\"# bar\n"
msgstr "// foo #\"# bar\n"

#: src/tokens.md:275 src/tokens.md:549 src/expressions/literal-expr.md:239
#: src/expressions/literal-expr.md:405
msgid "\"\\x52\""
msgstr "\"\\x52\""

#: src/tokens.md:276 src/tokens.md:549 src/expressions/literal-expr.md:240
#: src/expressions/literal-expr.md:405
msgid "\"R\""
msgstr "\"R\""

#: src/tokens.md:276 src/tokens.md:549 src/expressions/literal-expr.md:240
#: src/expressions/literal-expr.md:405
msgid "r\"R\""
msgstr "r\"R\""

#: src/tokens.md:276 src/expressions/literal-expr.md:240
msgid ""
"// R\n"
"\"\\\\x52\""
msgstr ""
"// R\n"
"\"\\\\x52\""

#: src/tokens.md:277 src/tokens.md:550 src/expressions/literal-expr.md:241
#: src/expressions/literal-expr.md:406
msgid "r\"\\x52\""
msgstr "r\"\\x52\""

#: src/tokens.md:277 src/tokens.md:411 src/tokens.md:550
#: src/expressions/literal-expr.md:241 src/expressions/literal-expr.md:348
#: src/expressions/literal-expr.md:406
msgid "// \\x52\n"
msgstr "// \\x52\n"

#: src/tokens.md:280
msgid "Byte and byte string literals"
msgstr "바이트 및 바이트 문자열 리터럴"

#: src/tokens.md:284
msgid "Byte literals"
msgstr "바이트 리터럴"

#: src/tokens.md:288
msgid ""
"**<sup>Lexer</sup>**  \n"
"BYTE_LITERAL :  \n"
"   `b'` ( ASCII_FOR_CHAR | BYTE_ESCAPE )  `'` SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"BYTE_LITERAL :  \n"
"   `b'` ( ASCII_FOR_CHAR | BYTE_ESCAPE )  `'` 접미사<sup>?</sup>"

#: src/tokens.md:292
msgid ""
"ASCII_FOR_CHAR :  \n"
"   _any ASCII (i.e. 0x00 to 0x7F), except_ `'`, `\\`, \\\\n, \\\\r or \\\\t"
msgstr ""
"ASCII_FOR_CHAR :  \n"
"   _모든 ASCII (즉, 0x00에서 0x7F까지), 단_ `'`, `\\`, \\\\n, \\\\r 또는 \\\\t 제외_"

#: src/tokens.md:295
msgid ""
"BYTE_ESCAPE :  \n"
"      `\\x` HEX_DIGIT HEX_DIGIT  \n"
"   | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0` | `\\'` | `\\\"`"
msgstr ""
"BYTE_ESCAPE :  \n"
"      `\\x` 16진수_숫자 16진수_숫자  \n"
"   | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0` | `\\'` | `\\\"`"

#: src/tokens.md:301
msgid ""
"A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F` "
"range) or a single _escape_ preceded by the characters `U+0062` (`b`) and "
"`U+0027` (single-quote), and followed by the character `U+0027`. If the "
"character `U+0027` is present within the literal, it must be _escaped_ by a "
"preceding `U+005C` (`\\`) character. It is equivalent to a `u8` unsigned 8-"
"bit integer _number literal_."
msgstr "_바이트 리터럴_은 `U+0062`(`b`)와 `U+0027`(작은따옴표) 문자로 시작하고 `U+0027` 문자로 끝나는 단일 ASCII 문자(`U+0000`에서 `U+007F` 범위) 또는 단일 _이스케이프_입니다. `U+0027` 문자가 리터럴 내에 있으면 선행하는 `U+005C`(`\\`) 문자로 _이스케이프_되어야 합니다. 이는 `u8` 부호 없는 8비트 정수 _숫자 리터럴_과 동일합니다."

#: src/tokens.md:310
msgid "Byte string literals"
msgstr "바이트 문자열 리터럴"

#: src/tokens.md:314
msgid ""
"**<sup>Lexer</sup>**  \n"
"BYTE_STRING_LITERAL :  \n"
"   `b\"` ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup>\\*</sup> "
"`\"` SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"BYTE_STRING_LITERAL :  \n"
"   `b\"` ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup>*</sup> "
"`\"` 접미사<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"BYTE_STRING_LITERAL :  \n"
"   `b\"` ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup>*</sup> "
"`\"` 접미사<sup>?</sup>"

#: src/tokens.md:318
msgid ""
"ASCII_FOR_STRING :  \n"
"   _any ASCII (i.e 0x00 to 0x7F), except_ `\"`, `\\` _and IsolatedCR_"
msgstr ""
"ASCII_FOR_STRING :  \n"
"   _모든 ASCII (즉, 0x00에서 0x7F까지), 단_ `\"`, `\\` _및 IsolatedCR 제외_"
"ASCII_FOR_STRING :  \n"
"   _모든 ASCII (즉, 0x00에서 0x7F까지), 단_ `\"`, `\\` _및 IsolatedCR 제외_"

#: src/tokens.md:323
msgid ""
"A non-raw _byte string literal_ is a sequence of ASCII characters and "
"_escapes_, preceded by the characters `U+0062` (`b`) and `U+0022` (double-"
"quote), and followed by the character `U+0022`. If the character `U+0022` is "
"present within the literal, it must be _escaped_ by a preceding `U+005C` "
"(`\\`) character. Alternatively, a byte string literal can be a _raw byte "
"string literal_, defined below."
msgstr "비원시 _바이트 문자열 리터럴_은 `U+0062`(`b`)와 `U+0022`(큰따옴표) 문자로 시작하고 `U+0022` 문자로 끝나는 ASCII 문자와 _이스케이프_ 시퀀스입니다. `U+0022` 문자가 리터럴 내에 있으면 선행하는 `U+005C`(`\\`) 문자로 _이스케이프_되어야 합니다. 또는 바이트 문자열 리터럴은 아래에 정의된 _원시 바이트 문자열 리터럴_일 수 있습니다."

#: src/tokens.md:332
msgid ""
"Line-breaks, represented by the  character `U+000A` (LF), are allowed in "
"byte string literals. When an unescaped `U+005C` character (`\\`) occurs "
"immediately before a line break, the line break does not appear in the "
"string represented by the token. See [String continuation escapes]"
"(expressions/literal-expr.md#string-continuation-escapes) for details. The "
"character `U+000D` (CR) may not appear in a byte string literal other than "
"as part of such a string continuation escape."
msgstr "`U+000A`(LF) 문자로 표현되는 줄 바꿈은 바이트 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 `U+005C` 문자(`\\`)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 [문자열 연속 이스케이프](expressions/literal-expr.md#string-continuation-escapes)를 참조하십시오. `U+000D`(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 바이트 문자열 리터럴에 나타날 수 없습니다."

#: src/tokens.md:339
msgid ""
"Some additional _escapes_ are available in either byte or non-raw byte "
"string literals. An escape starts with a `U+005C` (`\\`) and continues with "
"one of the following forms:"
msgstr "바이트 또는 비원시 바이트 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 `U+005C`(`\\`)로 시작하며 다음 형식 중 하나로 이어집니다:"

#: src/tokens.md:345 src/tokens.md:462
msgid ""
"A _byte escape_ escape starts with `U+0078` (`x`) and is followed by exactly "
"two _hex digits_. It denotes the byte equal to the provided hex value."
msgstr "_바이트 이스케이프_는 `U+0078`(`x`)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다."

#: src/tokens.md:351 src/tokens.md:474
msgid ""
"A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072` "
"(`r`), or `U+0074` (`t`), denoting the bytes values `0x0A` (ASCII LF), "
"`0x0D` (ASCII CR) or `0x09` (ASCII HT) respectively."
msgstr "_공백 이스케이프_는 `U+006E`(`n`), `U+0072`(`r`), 또는 `U+0074`(`t`) 문자 중 하나이며, 각각 바이트 값 `0x0A`(ASCII LF), `0x0D`(ASCII CR) 또는 `0x09`(ASCII HT)를 나타냅니다."

#: src/tokens.md:357
msgid ""
"The _null escape_ is the character `U+0030` (`0`) and denotes the byte value "
"`0x00` (ASCII NUL)."
msgstr "_널 이스케이프_는 `U+0030`(`0`) 문자이며 바이트 값 `0x00`(ASCII NUL)을 나타냅니다."

#: src/tokens.md:362 src/tokens.md:480
msgid ""
"The _backslash escape_ is the character `U+005C` (`\\`) which must be "
"_escaped_ in order to denote its ASCII encoding `0x5C`."
msgstr "_백슬래시 이스케이프_는 `U+005C`(`\\`) 문자이며, ASCII 인코딩 `0x5C`를 나타내기 위해 _이스케이프_되어야 합니다."

#: src/tokens.md:367
msgid "Raw byte string literals"
msgstr "원시 바이트 문자열 리터럴"

#: src/tokens.md:371
msgid ""
"**<sup>Lexer</sup>**  \n"
"RAW_BYTE_STRING_LITERAL :  \n"
"   `br` RAW_BYTE_STRING_CONTENT SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"RAW_BYTE_STRING_LITERAL :  \n"
"   `br` 원시_바이트_문자열_내용 접미사<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"RAW_BYTE_STRING_LITERAL :  \n"
"   `br` 원시_바이트_문자열_내용 접미사<sup>?</sup>"

#: src/tokens.md:375
msgid ""
"RAW_BYTE_STRING_CONTENT :  \n"
"      `\"` ASCII_FOR_RAW<sup>\\* (non-greedy)</sup> `\"`  \n"
"   | `#` RAW_BYTE_STRING_CONTENT `#`"
msgstr ""
"RAW_BYTE_STRING_CONTENT :  \n"
"      `\"` ASCII_FOR_RAW<sup>* (non-greedy)</sup> `\"`  \n"
"   | `#` 원시_바이트_문자열_내용 `#`"
"RAW_BYTE_STRING_CONTENT :  \n"
"      `\"` ASCII_FOR_RAW<sup>* (non-greedy)</sup> `\"`  \n"
"   | `#` 원시_바이트_문자열_내용 `#`"

#: src/tokens.md:379
msgid ""
"ASCII_FOR_RAW :  \n"
"   _any ASCII (i.e. 0x00 to 0x7F) except IsolatedCR_"
msgstr ""
"ASCII_FOR_RAW :  \n"
"   _모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외_"
"ASCII_FOR_RAW :  \n"
"   _모든 ASCII (즉, 0x00에서 0x7F까지) 단, IsolatedCR 제외_"

#: src/tokens.md:384
msgid ""
"Raw byte string literals do not process any escapes. They start with the "
"character `U+0062` (`b`), followed by `U+0072` (`r`), followed by fewer than "
"256 of the character `U+0023` (`#`), and a `U+0022` (double-quote) character."
msgstr "원시 바이트 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. 이들은 `U+0062`(`b`) 문자로 시작하고 `U+0072`(`r`) 문자가 뒤따르며, 256개 미만의 `U+0023`(`#`) 문자와 `U+0022`(큰따옴표) 문자가 뒤따릅니다."

#: src/tokens.md:390
msgid ""
"The _raw string body_ can contain any sequence of ASCII characters other "
"than `U+000D` (CR). It is terminated only by another `U+0022` (double-quote) "
"character, followed by the same number of `U+0023` (`#`) characters that "
"preceded the opening `U+0022` (double-quote) character. A raw byte string "
"literal can not contain any non-ASCII byte."
msgstr "_원시 문자열 본문_은 `U+000D`(CR)를 제외한 모든 ASCII 문자 시퀀스를 포함할 수 있습니다. 이스케이프는 다른 `U+0022`(큰따옴표) 문자로만 종료되며, 여는 `U+0022`(큰따옴표) 문자 앞에 있던 것과 동일한 수의 `U+0023`(`#`) 문자가 뒤따릅니다. 원시 바이트 문자열 리터럴은 비 ASCII 바이트를 포함할 수 없습니다."

#: src/tokens.md:396
msgid ""
"All characters contained in the raw string body represent their ASCII "
"encoding, the characters `U+0022` (double-quote) (except when followed by at "
"least as many `U+0023` (`#`) characters as were used to start the raw string "
"literal) or `U+005C` (`\\`) do not have any special meaning."
msgstr "원시 문자열 본문에 포함된 모든 문자는 ASCII 인코딩을 나타내며, `U+0022`(큰따옴표) 문자(원시 문자열 리터럴을 시작하는 데 사용된 `U+0023`(`#`) 문자 수만큼 이상이 뒤따르지 않는 경우) 또는 `U+005C`(`\\`)는 특별한 의미를 갖지 않습니다."

#: src/tokens.md:401
msgid "Examples for byte string literals:"
msgstr "바이트 문자열 리터럴 예시:"

#: src/tokens.md:404 src/expressions/literal-expr.md:341
msgid "b\"foo\""
msgstr "b\"foo\""

#: src/tokens.md:404 src/expressions/literal-expr.md:341
msgid "br\"foo\""
msgstr "br\"foo\""

#: src/tokens.md:404 src/expressions/literal-expr.md:341
msgid ""
"// foo\n"
"b\"\\\"foo\\\"\""
msgstr ""
"// foo\n"
"b\"\\\"foo\\\"\""

#: src/tokens.md:405 src/expressions/literal-expr.md:342
msgid "br#\"\"foo\"\"#"
msgstr "br#\"\"foo\"\"#"

#: src/tokens.md:406 src/expressions/literal-expr.md:343
msgid "b\"foo #\\\"# bar\""
msgstr "b\"foo #\\\"# bar\""

#: src/tokens.md:407 src/expressions/literal-expr.md:344
msgid "br##\"foo #\"# bar\"##"
msgstr "br##\"foo #\"# bar\"##"

#: src/tokens.md:409 src/expressions/literal-expr.md:346
msgid "b\"\\x52\""
msgstr "b\"\\x52\""

#: src/tokens.md:410 src/expressions/literal-expr.md:347
msgid "b\"R\""
msgstr "b\"R\""

#: src/tokens.md:410 src/expressions/literal-expr.md:347
msgid "br\"R\""
msgstr "br\"R\""

#: src/tokens.md:410 src/expressions/literal-expr.md:347
msgid ""
"// R\n"
"b\"\\\\x52\""
msgstr ""
"// R\n"
"b\"\\\\x52\""

#: src/tokens.md:411 src/expressions/literal-expr.md:348
msgid "br\"\\x52\""
msgstr "br\"\\x52\""

#: src/tokens.md:414
msgid "C string and raw C string literals"
msgstr "C 문자열 및 원시 C 문자열 리터럴"

#: src/tokens.md:418
msgid "C string literals"
msgstr "C 문자열 리터럴"

#: src/tokens.md:422
msgid ""
"**<sup>Lexer</sup>**  \n"
"C_STRING_LITERAL :  \n"
"   `c\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_ _NUL_\\]  \n"
"      | BYTE_ESCAPE _except `\\0` or `\\x00`_  \n"
"      | UNICODE_ESCAPE _except `\\u{0}`, `\\u{00}`, …, `\\u{000000}`_  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>\\*</sup> `\"` SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"C_STRING_LITERAL :  \n"
"   `c\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_ _NUL_\\]  \n"
"      | BYTE_ESCAPE _단, `\\0` 또는 `\\x00` 제외_  \n"
"      | UNICODE_ESCAPE _단, `\\u{0}`, `\\u{00}`, …, `\\u{000000}` 제외_  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>*</sup> `\"` 접미사<sup>?</sup>"
"**<sup>렉서</sup>**  \n"
"C_STRING_LITERAL :  \n"
"   `c\"` (  \n"
"      ~\\[`\"` `\\` _IsolatedCR_ _NUL_\\]  \n"
"      | BYTE_ESCAPE _단, `\\0` 또는 `\\x00` 제외_  \n"
"      | UNICODE_ESCAPE _단, `\\u{0}`, `\\u{00}`, …, `\\u{000000}` 제외_  \n"
"      | STRING_CONTINUE  \n"
"   )<sup>*</sup> `\"` 접미사<sup>?</sup>"

#: src/tokens.md:433
msgid ""
"A _C string literal_ is a sequence of Unicode characters and _escapes_, "
"preceded by the characters `U+0063` (`c`) and `U+0022` (double-quote), and "
"followed by the character `U+0022`. If the character `U+0022` is present "
"within the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) "
"character. Alternatively, a C string literal can be a _raw C string "
"literal_, defined below."
msgstr "_C 문자열 리터럴_은 `U+0063`(`c`)과 `U+0022`(큰따옴표) 문자로 시작하고 `U+0022` 문자로 끝나는 유니코드 문자와 _이스케이프_ 시퀀스입니다. `U+0022` 문자가 리터럴 내에 있으면 선행하는 `U+005C`(`\\`) 문자로 _이스케이프_되어야 합니다. 또는 C 문자열 리터럴은 아래에 정의된 _원시 C 문자열 리터럴_일 수 있습니다."

#: src/tokens.md:443
msgid ""
"C strings are implicitly terminated by byte `0x00`, so the C string literal "
"`c\"\"` is equivalent to manually constructing a `&CStr` from the byte "
"string literal `b\"\\x00\"`. Other than the implicit terminator, byte `0x00` "
"is not permitted within a C string."
msgstr "C 문자열은 바이트 `0x00`으로 암시적으로 종료되므로, C 문자열 리터럴 `c\"\"`는 바이트 문자열 리터럴 `b\"\\x00\"`에서 `&CStr`를 수동으로 구성하는 것과 동일합니다. 암시적 종료자를 제외하고, 바이트 `0x00`은 C 문자열 내에서 허용되지 않습니다."

#: src/tokens.md:450
msgid ""
"Line-breaks, represented by the  character `U+000A` (LF), are allowed in C "
"string literals. When an unescaped `U+005C` character (`\\`) occurs "
"immediately before a line break, the line break does not appear in the "
"string represented by the token. See [String continuation escapes]"
"(expressions/literal-expr.md#string-continuation-escapes) for details. The "
"character `U+000D` (CR) may not appear in a C string literal other than as "
"part of such a string continuation escape."
msgstr "`U+000A`(LF) 문자로 표현되는 줄 바꿈은 C 문자열 리터럴에서 허용됩니다. 이스케이프되지 않은 `U+005C` 문자(`\\`)가 줄 바꿈 바로 앞에 오면, 줄 바꿈은 토큰으로 표현되는 문자열에 나타나지 않습니다. 자세한 내용은 [문자열 연속 이스케이프](expressions/literal-expr.md#string-continuation-escapes)를 참조하십시오. `U+000D`(CR) 문자는 문자열 연속 이스케이프의 일부가 아닌 한 C 문자열 리터럴에 나타날 수 없습니다."

#: src/tokens.md:457
msgid ""
"Some additional _escapes_ are available in non-raw C string literals. An "
"escape starts with a `U+005C` (`\\`) and continues with one of the following "
"forms:"
msgstr "비원시 C 문자열 리터럴에는 몇 가지 추가 _이스케이프_가 사용 가능합니다. 이스케이프는 `U+005C`(`\\`)로 시작하며 다음 형식 중 하나로 이어집니다:"

#: src/tokens.md:467
msgid ""
"A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed by "
"up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D` (`}"
"`). It denotes the Unicode code point equal to the provided hex value, "
"encoded as UTF-8."
msgstr ""
"_24비트 코드 포인트 이스케이프_는 `U+0075`(`u`)로 시작하고 중괄호 `U+007B`(`{`) 및 `U+007D`(`}`)로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. "
"제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타내며 UTF-8로 인코딩됩니다."

#: src/tokens.md:485
msgid ""
"A C string represents bytes with no defined encoding, but a C string literal "
"may contain Unicode characters above `U+007F`. Such characters will be "
"replaced with the bytes of that character's UTF-8 representation."
msgstr "C 문자열은 정의된 인코딩이 없는 바이트를 나타내지만 C 문자열 리터럴에는 `U+007F` 이상의 유니코드 문자가 포함될 수 있습니다. 이러한 문자는 해당 문자의 UTF-8 표현 바이트로 대체됩니다."

#: src/tokens.md:489
msgid "The following C string literals are equivalent:"
msgstr "다음 C 문자열 리터럴은 동일합니다."

#: src/tokens.md:492 src/expressions/literal-expr.md:408
msgid "\"æ\""
msgstr "\"æ\""

#: src/tokens.md:492 src/expressions/literal-expr.md:184
#: src/expressions/literal-expr.md:408 src/expressions/literal-expr.md:409
#: src/expressions/literal-expr.md:410
msgid "// LATIN SMALL LETTER AE (U+00E6)\n"
msgstr "// 라틴어 소문자 AE (U+00E6)\n"

#: src/tokens.md:493 src/expressions/literal-expr.md:409
#: src/expressions/literal-expr.md:413
msgid "\"\\u{00E6}\""
msgstr "\"\\u{00E6}\""

#: src/tokens.md:494 src/expressions/literal-expr.md:410
msgid "\"\\xC3\\xA6\""
msgstr "\"\\xC3\\xA6\""

#: src/tokens.md:499
msgid ""
"**Edition differences**: C string literals are accepted in the 2021 edition "
"or later. In earlier additions the token `c\"\"` is lexed as `c \"\"`."
msgstr "**에디션 차이**: C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 `c\"\"` 토큰이 `c \"\"`로 분석됩니다."

#: src/tokens.md:504
msgid "Raw C string literals"
msgstr "원시 C 문자열 리터럴"

#: src/tokens.md:508
msgid ""
"**<sup>Lexer</sup>**  \n"
"RAW_C_STRING_LITERAL :  \n"
"   `cr` RAW_C_STRING_CONTENT SUFFIX<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"RAW_C_STRING_LITERAL :  \n"
"   `cr` RAW_C_STRING_CONTENT 접미사<sup>?</sup>"

#: src/tokens.md:512
msgid ""
"RAW_C_STRING_CONTENT :  \n"
"      `\"` ( ~ _IsolatedCR_ _NUL_ )<sup>\\* (non-greedy)</sup> `\"`  \n"
"   | `#` RAW_C_STRING_CONTENT `#`"
msgstr ""
"RAW_C_STRING_CONTENT :  \n"
"      `\"` ( ~ _IsolatedCR_ _NUL_ )<sup>* (non-greedy)</sup> `\"`  \n"
"   | `#` RAW_C_STRING_CONTENT `#`"

#: src/tokens.md:518
msgid ""
"Raw C string literals do not process any escapes. They start with the "
"character `U+0063` (`c`), followed by `U+0072` (`r`), followed by fewer than "
"256 of the character `U+0023` (`#`), and a `U+0022` (double-quote) character."
msgstr "원시 C 문자열 리터럴은 어떤 이스케이프도 처리하지 않습니다. `U+0063`(`c`) 문자로 시작하고 `U+0072`(`r`) 문자가 뒤따르며, 256자 미만의 `U+0023`(`#`) 문자와 `U+0022`(큰따옴표) 문자가 뒤따릅니다."

#: src/tokens.md:524
msgid ""
"The _raw C string body_ can contain any sequence of Unicode characters other "
"than `U+0000` (NUL) and `U+000D` (CR). It is terminated only by another "
"`U+0022` (double-quote) character, followed by the same number of `U+0023` "
"(`#`) characters that preceded the opening `U+0022` (double-quote) character."
msgstr "_원시 C 문자열 본문_은 `U+0000`(NUL) 및 `U+000D`(CR) 이외의 모든 유니코드 문자 시퀀스를 포함할 수 있습니다. 다른 `U+0022`(큰따옴표) 문자로만 종료되며, 여는 `U+0022`(큰따옴표) 문자 앞에 있던 것과 동일한 수의 `U+0023`(`#`) 문자가 뒤따릅니다."

#: src/tokens.md:529
msgid ""
"All characters contained in the raw C string body represent themselves in "
"UTF-8 encoding. The characters `U+0022` (double-quote) (except when followed "
"by at least as many `U+0023` (`#`) characters as were used to start the raw "
"C string literal) or `U+005C` (`\\`) do not have any special meaning."
msgstr "원시 C 문자열 본문에 포함된 모든 문자는 UTF-8 인코딩으로 자신을 나타냅니다. `U+0022`(큰따옴표) 문자(원시 C 문자열 리터럴을 시작하는 데 사용된 `U+0023`(`#`) 문자 수만큼 이상 뒤따르지 않는 경우) 또는 `U+005C`(`\\`)는 특별한 의미를 갖지 않습니다."

#: src/tokens.md:536
msgid ""
"**Edition differences**: Raw C string literals are accepted in the 2021 "
"edition or later. In earlier additions the token `cr\"\"` is lexed as `cr "
"\"\"`, and `cr#\"\"#` is lexed as `cr #\"\"#` (which is non-grammatical)."
msgstr "**에디션 차이**: 원시 C 문자열 리터럴은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 `cr\"\"` 토큰이 `cr \"\"`로, `cr#\"\"#`는 `cr #\"\"#`(문법에 맞지 않음)로 어휘 분석됩니다."

#: src/tokens.md:540
msgid "Examples for C string and raw C string literals"
msgstr "C 문자열 및 원시 C 문자열 리터럴의 예"

#: src/tokens.md:543 src/expressions/literal-expr.md:399
msgid "// foo\n"
msgstr "// foo\n"

#: src/tokens.md:544 src/expressions/literal-expr.md:400
msgid "\"\\\"foo\\\"\""
msgstr "\"\\\"foo\\\"\""

#: src/tokens.md:549 src/expressions/literal-expr.md:405
msgid "// R\n"
msgstr "// R\n"

#: src/tokens.md:550 src/expressions/literal-expr.md:406
msgid "\"\\\\x52\""
msgstr "\"\\\\x52\""

#: src/tokens.md:555
msgid "Number literals"
msgstr "숫자 리터럴"

#: src/tokens.md:558
msgid ""
"A _number literal_ is either an _integer literal_ or a _floating-point "
"literal_. The grammar for recognizing the two kinds of literals is mixed."
msgstr "_숫자 리터럴_은 _정수 리터럴_ 또는 _부동 소수점 리터럴_입니다. 두 종류의 리터럴을 인식하는 문법은 혼합되어 있습니다."

#: src/tokens.md:563
msgid "Integer literals"
msgstr "정수 리터럴"

#: src/tokens.md:567
msgid ""
"**<sup>Lexer</sup>**  \n"
"INTEGER_LITERAL :  \n"
"   ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) "
"SUFFIX_NO_E<sup>?</sup>"
msgstr ""
"**<sup>렉서</sup>**  \n"
"INTEGER_LITERAL :  \n"
"   ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) "
"SUFFIX_NO_E<sup>?</sup>"

#: src/tokens.md:572
msgid ""
"DEC_LITERAL :  \n"
"   DEC_DIGIT (DEC_DIGIT|`_`)<sup>\\*</sup>"
msgstr ""
"DEC_LITERAL :  \n"
"   DEC_DIGIT (DEC_DIGIT|`_`)<sup>*</sup>"

#: src/tokens.md:575
msgid ""
"BIN_LITERAL :  \n"
"   `0b` (BIN_DIGIT|`_`)<sup>\\*</sup> BIN_DIGIT (BIN_DIGIT|`_`)<sup>\\*</sup>"
msgstr ""
"BIN_LITERAL :  \n"
"   `0b` (BIN_DIGIT|`_`)<sup>*</sup> BIN_DIGIT (BIN_DIGIT|`_`)<sup>*</sup>"

#: src/tokens.md:578
msgid ""
"OCT_LITERAL :  \n"
"   `0o` (OCT_DIGIT|`_`)<sup>\\*</sup> OCT_DIGIT (OCT_DIGIT|`_`)<sup>\\*</sup>"
msgstr ""
"OCT_LITERAL :  \n"
"   `0o` (OCT_DIGIT|`_`)<sup>*</sup> OCT_DIGIT (OCT_DIGIT|`_`)<sup>*</sup>"

#: src/tokens.md:581
msgid ""
"HEX_LITERAL :  \n"
"   `0x` (HEX_DIGIT|`_`)<sup>\\*</sup> HEX_DIGIT (HEX_DIGIT|`_`)<sup>\\*</sup>"
msgstr ""
"HEX_LITERAL :  \n"
"   `0x` (HEX_DIGIT|`_`)<sup>*</sup> HEX_DIGIT (HEX_DIGIT|`_`)<sup>*</sup>"

#: src/tokens.md:584
msgid "BIN_DIGIT : \\[`0`\\-`1`\\]"
msgstr "BIN_DIGIT : \\[`0`\\-`1`\\]"

#: src/tokens.md:586
msgid "OCT_DIGIT : \\[`0`\\-`7`\\]"
msgstr "OCT_DIGIT : \\[`0`\\-`7`\\]"

#: src/tokens.md:588
msgid "DEC_DIGIT : \\[`0`\\-`9`\\]"
msgstr "DEC_DIGIT : \\[`0`\\-`9`\\]"

#: src/tokens.md:590
msgid "HEX_DIGIT : \\[`0`\\-`9` `a`\\-`f` `A`\\-`F`\\]"
msgstr "HEX_DIGIT : \\[`0`\\-`9` `a`\\-`f` `A`\\-`F`\\]"

#: src/tokens.md:594
msgid "An _integer literal_ has one of four forms:"
msgstr "_정수 리터럴_은 네 가지 형태 중 하나를 갖습니다."

#: src/tokens.md:598
msgid ""
"A _decimal literal_ starts with a _decimal digit_ and continues with any "
"mixture of _decimal digits_ and _underscores_."
msgstr "_십진수 리터럴_은 _십진수 숫자_로 시작하고 _십진수 숫자_와 _밑줄_의 혼합으로 이어집니다."

#: src/tokens.md:603
msgid ""
"A _hex literal_ starts with the character sequence `U+0030` `U+0078` (`0x`) "
"and continues as any mixture (with at least one digit) of hex digits and "
"underscores."
msgstr "_16진수 리터럴_은 문자 시퀀스 `U+0030` `U+0078`(`0x`)로 시작하고 16진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다."

#: src/tokens.md:609
msgid ""
"An _octal literal_ starts with the character sequence `U+0030` `U+006F` "
"(`0o`) and continues as any mixture (with at least one digit) of octal "
"digits and underscores."
msgstr "_8진수 리터럴_은 문자 시퀀스 `U+0030` `U+006F`(`0o`)로 시작하고 8진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다."

#: src/tokens.md:615
msgid ""
"A _binary literal_ starts with the character sequence `U+0030` `U+0062` "
"(`0b`) and continues as any mixture (with at least one digit) of binary "
"digits and underscores."
msgstr "_2진수 리터럴_은 문자 시퀀스 `U+0030` `U+0062`(`0b`)로 시작하고 2진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다."

#: src/tokens.md:621
msgid ""
"Like any literal, an integer literal may be followed (immediately, without "
"any spaces) by a suffix as described above. The suffix may not begin with "
"`e` or `E`, as that would be interpreted as the exponent of a floating-point "
"literal. See [Integer literal expressions](expressions/literal-"
"expr.md#integer-literal-expressions) for the effect of these suffixes."
msgstr "모든 리터럴과 마찬가지로 정수 리터럴 뒤에는 위에서 설명한 대로 접미사가 (공백 없이) 바로 올 수 있습니다. 접미사는 `e` 또는 `E`로 시작할 수 없습니다. 이는 부동 소수점 리터럴의 지수로 해석되기 때문입니다. 이러한 접미사의 효과에 대해서는 [정수 리터럴 표현식](expressions/literal-expr.md#integer-literal-expressions)을 참조하십시오."

#: src/tokens.md:625
msgid "Examples of integer literals which are accepted as literal expressions:"
msgstr "리터럴 표현식으로 허용되는 정수 리터럴의 예:"

#: src/tokens.md:636
msgid "// integer 7986, not floating-point 1.0\n"
msgstr "// 정수 7986, 부동 소수점 1.0 아님\n"

#: src/tokens.md:637
msgid "// integer 483, not floating-point 1000.0\n"
msgstr "// 정수 483, 부동 소수점 1000.0 아님\n"

#: src/tokens.md:647
msgid ""
"// These are too big for their type, but are accepted as literal "
"expressions.\n"
msgstr "// 이것들은 타입에 비해 너무 크지만, 리터럴 표현식으로 허용됩니다.\n"

#: src/tokens.md:651
msgid ""
"// This is an integer literal, accepted as a floating-point literal "
"expression.\n"
msgstr "// 이것은 정수 리터럴이며, 부동 소수점 리터럴 표현식으로 허용됩니다.\n"

#: src/tokens.md:656
msgid ""
"Note that `-1i8`, for example, is analyzed as two tokens: `-` followed by "
"`1i8`."
msgstr "예를 들어 `-1i8`은 `-`와 `1i8`의 두 토큰으로 분석됩니다."

#: src/tokens.md:659
msgid ""
"Examples of integer literals which are not accepted as literal expressions:"
msgstr "리터럴 표현식으로 허용되지 않는 정수 리터럴의 예:"

#: src/tokens.md:673
msgid "Tuple index"
msgstr "튜플 인덱스"

#: src/tokens.md:677
msgid ""
"**<sup>Lexer</sup>**  \n"
"TUPLE_INDEX:   \n"
"   INTEGER_LITERAL"
msgstr ""
"**<sup>렉서</sup>**  \n"
"TUPLE_INDEX:   \n"
"   INTEGER_LITERAL"

#: src/tokens.md:683
msgid ""
"A tuple index is used to refer to the fields of [tuples](types/tuple.md), "
"[tuple structs](items/structs.md), and [tuple variants](items/"
"enumerations.md)."
msgstr "튜플 인덱스는 [튜플](types/tuple.md), [튜플 구조체](items/structs.md) 및 [튜플 변형](items/enumerations.md)의 필드를 참조하는 데 사용됩니다."

#: src/tokens.md:688
msgid ""
"Tuple indices are compared with the literal token directly. Tuple indices "
"start with `0` and each successive index increments the value by `1` as a "
"decimal value. Thus, only decimal values will match, and the value must not "
"have any extra `0` prefix characters."
msgstr "튜플 인덱스는 리터럴 토큰과 직접 비교됩니다. 튜플 인덱스는 `0`으로 시작하고 각 연속 인덱스는 값을 1씩 10진수 값으로 증가시킵니다. 따라서 10진수 값만 일치하며 값에 추가 `0` 접두사 문자가 없어야 합니다."

#: src/tokens.md:694
msgid "\"dog\""
msgstr "개"

#: src/tokens.md:694
msgid "\\\"cat\\\""
msgstr "\\\"고양이\\\""

#: src/tokens.md:694
msgid "\"horse\""
msgstr "말"

#: src/tokens.md:696
msgid "// The following examples are invalid.\n"
msgstr "// 다음 예제는 유효하지 않습니다.\n"

#: src/tokens.md:698
msgid "// ERROR no field named `01`\n"
msgstr "// 오류: `01`이라는 필드가 없습니다\n"

#: src/tokens.md:699
msgid "// ERROR no field named `0b10`\n"
msgstr "// 오류: `0b10`이라는 필드가 없습니다\n"

#: src/tokens.md:702
msgid ""
"**Note**: Tuple indices may include certain suffixes, but this is not "
"intended to be valid, and may be removed in a future version. See <https://"
"github.com/rust-lang/rust/issues/60210> for more information."
msgstr "**참고**: 튜플 인덱스에는 특정 접미사가 포함될 수 있지만 이는 유효하도록 의도된 것이 아니며 향후 버전에서 제거될 수 있습니다. 자세한 내용은 <https://github.com/rust-lang/rust/issues/60210>을 참조하십시오."

#: src/tokens.md:707
msgid "Floating-point literals"
msgstr "부동 소수점 리터럴"

#: src/tokens.md:711
msgstr ""
"**<sup>렉서</sup>**  \n"
"부동_소수점_리터럴 :  \n"
"      십진_리터럴 `.` _(바로 뒤에 `.`, `_` 또는 XID_Start 문자가 오지 않음)_  \n"
"   | 십진_리터럴 `.` 십진_리터럴 E없는_접미사<sup>?</sup>  \n"
"   | 십진_리터럴 (`.` 십진_리터럴)<sup>?</sup> 부동_소수점_지수 접미사<sup>?</sup>"

#: src/tokens.md:718
msgstr ""
"부동_소수점_지수 :  \n"
"   (`e`\\|`E`) (`+`\\|`-`)<sup>?</sup> (십진_숫자|`_`)<sup>\\*</sup> "
"십진_숫자 (십진_숫자|`_`)<sup>\\*</sup>"

#: src/tokens.md:725
msgid "A _floating-point literal_ has one of two forms:"
msgstr "_부동 소수점 리터럴_은 두 가지 형태 중 하나를 갖습니다."

#: src/tokens.md:727
msgid ""
"A _decimal literal_ followed by a period character `U+002E` (`.`). This is "
"optionally followed by another decimal literal, with an optional _exponent_."
msgstr "_십진수 리터럴_ 뒤에 마침표 문자 `U+002E`(`.`)가 옵니다. 선택적으로 다른 십진수 리터럴과 선택적 _지수_가 뒤따를 수 있습니다."

#: src/tokens.md:729
msgid "A single _decimal literal_ followed by an _exponent_."
msgstr "단일 _십진수 리터럴_ 뒤에 _지수_가 옵니다."

#: src/tokens.md:733
msgid ""
"Like integer literals, a floating-point literal may be followed by a suffix, "
"so long as the pre-suffix part does not end with `U+002E` (`.`). The suffix "
"may not begin with `e` or `E` if the literal does not include an exponent. "
"See [Floating-point literal expressions](expressions/literal-"
"expr.md#floating-point-literal-expressions) for the effect of these suffixes."
msgstr "정수 리터럴과 마찬가지로 부동 소수점 리터럴 뒤에는 접미사가 올 수 있습니다. 단, 접미사 앞부분이 `U+002E`(`.`)로 끝나지 않아야 합니다. 리터럴에 지수가 포함되지 않은 경우 접미사는 `e` 또는 `E`로 시작할 수 없습니다. 이러한 접미사의 효과에 대해서는 [부동 소수점 리터럴 표현식](expressions/literal-expr.md#floating-point-literal-expressions)을 참조하십시오."

#: src/tokens.md:738
msgid ""
"Examples of floating-point literals which are accepted as literal "
"expressions:"
msgstr "리터럴 표현식으로 허용되는 부동 소수점 리터럴의 예:"

#: src/tokens.md:748
msgid ""
"This last example is different because it is not possible to use the suffix "
"syntax with a floating point literal end.token.ing in a period. `2.f64` "
"would attempt to call a method named `f64` on `2`."
msgstr "마지막 예는 마침표로 끝나는 부동 소수점 리터럴에 접미사 구문을 사용할 수 없기 때문에 다릅니다. `2.f64`는 `2`에서 `f64`라는 이름의 메서드를 호출하려고 시도합니다."

#: src/tokens.md:752
msgid ""
"Note that `-1.0`, for example, is analyzed as two tokens: `-` followed by "
"`1.0`."
msgstr "예를 들어 `-1.0`은 `-`와 `1.0`의 두 토큰으로 분석됩니다."

#: src/tokens.md:754
msgid ""
"Examples of floating-point literals which are not accepted as literal "
"expressions:"
msgstr "리터럴 표현식으로 허용되지 않는 부동 소수점 리터럴의 예:"

#: src/tokens.md:768
msgid "Reserved forms similar to number literals"
msgstr "숫자 리터럴과 유사한 예약된 형식"

#: src/tokens.md:771
msgid ""
"**<sup>Lexer</sup>**  \n"
"RESERVED_NUMBER :  \n"
"      BIN_LITERAL \\[`2`\\-`9`​\\]  \n"
"   | OCT_LITERAL \\[`8`\\-`9`​\\]  \n"
"   | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) `.`   \n"
"         _(not immediately followed by `.`, `_` or an XID_Start "
"character)_  \n"
"   | ( BIN_LITERAL | OCT_LITERAL ) (`e`\\|`E`)  \n"
"   | `0b` `_`<sup>\\*</sup> _end of input or not BIN_DIGIT_  \n"
"   | `0o` `_`<sup>\\*</sup> _end of input or not OCT_DIGIT_  \n"
"   | `0x` `_`<sup>\\*</sup> _end of input or not HEX_DIGIT_  \n"
"   | DEC_LITERAL ( . DEC_LITERAL)<sup>?</sup> (`e`\\|`E`) (`+`\\|`-`)<sup>?</"
"sup> _end of input or not DEC_DIGIT_"
msgstr ""
"**<sup>렉서</sup>**  \n"
"RESERVED_NUMBER :  \n"
"      BIN_LITERAL \\[`2`\\-`9`​\\]  \n"
"   | OCT_LITERAL \\[`8`\\-`9`​\\]  \n"
"   | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) `.`   \n"
"         _(바로 뒤에 `.`, `_` 또는 XID_시작 문자가 오지 않음)_  \n"
"   | ( BIN_LITERAL | OCT_LITERAL ) (`e`\\|`E`)  \n"
"   | `0b` `_`<sup>\\*</sup> _입력의 끝 또는 2진수_숫자가 아님_  \n"
"   | `0o` `_`<sup>\\*</sup> _입력의 끝 또는 8진수_숫자가 아님_  \n"
"   | `0x` `_`<sup>\\*</sup> _입력의 끝 또는 16진수_숫자가 아님_  \n"
"   | DEC_LITERAL ( . DEC_LITERAL)<sup>?</sup> (`e`\\|`E`) (`+`\\|`-`)<sup>?</"
"sup> _입력의 끝 또는 10진수_숫자가 아님_"

#: src/tokens.md:785
msgid ""
"The following lexical forms similar to number literals are _reserved forms_. "
"Due to the possible ambiguity these raise, they are rejected by the "
"tokenizer instead of being interpreted as separate tokens."
msgstr "숫자 리터럴과 유사한 다음 어휘 형식은 _예약된 형식_입니다. 이들이 제기하는 모호성 때문에 토크나이저는 이를 별도의 토큰으로 해석하는 대신 거부합니다."

#: src/tokens.md:790
msgid ""
"An unsuffixed binary or octal literal followed, without intervening "
"whitespace, by a decimal digit out of the range for its radix."
msgstr "접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 해당 기수 범위를 벗어나는 10진수 숫자가 오는 경우."

#: src/tokens.md:794
msgid ""
"An unsuffixed binary, octal, or hexadecimal literal followed, without "
"intervening whitespace, by a period character (with the same restrictions on "
"what follows the period as for floating-point literals)."
msgstr "접미사가 없는 2진수, 8진수 또는 16진수 리터럴 뒤에 공백 없이 마침표 문자가 오는 경우(마침표 뒤에 오는 내용에 대한 제한은 부동 소수점 리터럴과 동일)."

#: src/tokens.md:798
msgid ""
"An unsuffixed binary or octal literal followed, without intervening "
"whitespace, by the character `e` or `E`."
msgstr "접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 `e` 또는 `E` 문자가 오는 경우."

#: src/tokens.md:802
msgid ""
"Input which begins with one of the radix prefixes but is not a valid binary, "
"octal, or hexadecimal literal (because it contains no digits)."
msgstr "기수 접두사 중 하나로 시작하지만 유효한 2진수, 8진수 또는 16진수 리터럴이 아닌 입력 (숫자를 포함하지 않기 때문에)."

#: src/tokens.md:806
msgid ""
"Input which has the form of a floating-point literal with no digits in the "
"exponent."
msgstr "지수에 숫자가 없는 부동 소수점 리터럴 형식을 갖는 입력."

#: src/tokens.md:808
msgid "Examples of reserved forms:"
msgstr "예약된 형식의 예:"

#: src/tokens.md:811
msgid "// this is not `0b010` followed by `2`\n"
msgstr "// 이것은 `0b010` 뒤에 `2`가 오는 것이 아닙니다\n"

#: src/tokens.md:812
msgid "// this is not `0o127` followed by `9`\n"
msgstr "// 이것은 `0o127` 뒤에 `9`가 오는 것이 아닙니다\n"

#: src/tokens.md:813
msgid "// this is not `0x80` followed by `.` and `0`\n"
msgstr "// 이것은 `0x80` 뒤에 `.`와 `0`이 오는 것이 아닙니다\n"

#: src/tokens.md:814
msgid "// this is not a suffixed literal, or `0b101` followed by `e`\n"
msgstr "// 이것은 접미사가 붙은 리터럴이 아니거나, `0b101` 뒤에 `e`가 오는 것이 아닙니다\n"

#: src/tokens.md:815
msgid "// this is not an integer literal, or `0` followed by `b`\n"
msgstr "// 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b`가 오는 것이 아닙니다\n"

#: src/tokens.md:816
msgid "// this is not an integer literal, or `0` followed by `b_`\n"
msgstr "// 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b_`가 오는 것이 아닙니다\n"

#: src/tokens.md:817
msgid "// this is not a floating-point literal, or `2` followed by `e`\n"
msgstr "// 이것은 부동 소수점 리터럴이 아니거나, `2` 뒤에 `e`가 오는 것이 아닙니다\n"

#: src/tokens.md:818
msgid "// this is not a floating-point literal, or `2.0` followed by `e`\n"
msgstr "// 이것은 부동 소수점 리터럴이 아니거나, `2.0` 뒤에 `e`가 오는 것이 아닙니다\n"

#: src/tokens.md:819
msgid "// this is not a suffixed literal, or `2` followed by `em`\n"
msgstr "// 이것은 접미사가 붙은 리터럴이 아니거나, `2` 뒤에 `em`이 오는 것이 아닙니다\n"

#: src/tokens.md:820
msgid "// this is not a suffixed literal, or `2.0` followed by `em`\n"
msgstr "// 이것은 접미사가 붙은 리터럴이 아니거나, `2.0` 뒤에 `em`이 오는 것이 아닙니다\n"

#: src/tokens.md:825
msgid "Lifetimes and loop labels"
msgstr "라이프타임과 루프 레이블"

#: src/tokens.md:829
msgid ""
"**<sup>Lexer</sup>**  \n"
"LIFETIME_TOKEN :  \n"
"      `'` [IDENTIFIER_OR_KEYWORD](identifiers.md) _(not immediately followed "
"by `'`)_  \n"
"   | `'_` _(not immediately followed by `'`)_  \n"
"   | RAW_LIFETIME"
msgstr ""
"**<sup>렉서</sup>**  \n"
"LIFETIME_TOKEN :  \n"
"      `'` [IDENTIFIER_OR_KEYWORD](identifiers.md) _(`'`가 바로 뒤에 오지 않음)_  \n"
"   | `'_` _(`'`가 바로 뒤에 오지 않음)_  \n"
"   | RAW_LIFETIME"

#: src/tokens.md:837
msgid ""
"LIFETIME_OR_LABEL :  \n"
"      `'` [NON_KEYWORD_IDENTIFIER](identifiers.md) _(not immediately "
"followed by `'`)_  \n"
"   | RAW_LIFETIME"
msgstr ""
"LIFETIME_OR_LABEL :  \n"
"      `'` [NON_KEYWORD_IDENTIFIER](identifiers.md) _(`'`가 바로 뒤에 오지 않음)_  \n"
"   | RAW_LIFETIME"

#: src/tokens.md:842
msgid ""
"RAW_LIFETIME :  \n"
"   `'r#` [IDENTIFIER_OR_KEYWORD](identifiers.md) <sub>_Except `crate`, "
"`self`, `super`, `Self`_</sub> _(not immediately followed by `'`)_"
msgstr ""
"RAW_LIFETIME :  \n"
"   `'r#` [IDENTIFIER_OR_KEYWORD](identifiers.md) <sub>_`crate`, "
"`self`, `super`, `Self` 제외_</sub> _(`'`가 바로 뒤에 오지 않음)_"

#: src/tokens.md:846
msgid "RESERVED_RAW_LIFETIME : `'r#_` _(not immediately followed by `'`)_"
msgstr "RESERVED_RAW_LIFETIME : `'r#_` _(`'`가 바로 뒤에 오지 않음)_"

#: src/tokens.md:851
msgid ""
"Lifetime parameters and [loop labels](expressions/loop-expr.md) use "
"LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, "
"and for example, can be used in macros."
msgstr "라이프타임 매개변수와 [루프 레이블](expressions/loop-expr.md)은 LIFETIME_OR_LABEL 토큰을 사용합니다. 모든 LIFETIME_TOKEN은 렉서에 의해 허용되며, 예를 들어 매크로에서 사용될 수 있습니다."

#: src/tokens.md:857
msgid ""
"A raw lifetime is like a normal lifetime, but its identifier is prefixed by "
"`r#`. (Note that the `r#` prefix is not included as part of the actual "
"lifetime.)"
msgstr "원시 라이프타임은 일반 라이프타임과 같지만 식별자 앞에 `r#` 접두사가 붙습니다. (`r#` 접두사는 실제 라이프타임의 일부로 포함되지 않습니다.)"

#: src/tokens.md:861
msgid ""
"Unlike a normal lifetime, a raw lifetime may be any strict or reserved "
"keyword except the ones listed above for `RAW_LIFETIME`."
msgstr "일반 라이프타임과 달리 원시 라이프타임은 `RAW_LIFETIME`에 대해 위에 나열된 키워드를 제외한 모든 엄격하거나 예약된 키워드일 수 있습니다."

#: src/tokens.md:865
msgid ""
"It is an error to use the RESERVED_RAW_LIFETIME token `'r#_` in order to "
"avoid confusion with the [placeholder lifetime](lifetime-elision.md)."
msgstr "[자리표시자 라이프타임](lifetime-elision.md)과의 혼동을 피하기 위해 RESERVED_RAW_LIFETIME 토큰 `'r#_`를 사용하는 것은 오류입니다."

#: src/tokens.md:869
msgid ""
"**Edition differences**: Raw lifetimes are accepted in the 2021 edition or "
"later. In earlier additions the token `'r#lt` is lexed as `'r # lt`."
msgstr "**에디션 차이**: 원시 라이프타임은 2021 에디션 이상에서 허용됩니다. 이전 에디션에서는 `'r#lt` 토큰이 `'r # lt`로 어휘 분석됩니다."

#: src/tokens.md:874
msgid "Punctuation"
msgstr "구두점"

#: src/tokens.md:878
msgid ""
"Punctuation symbol tokens are listed here for completeness. Their individual "
"usages and meanings are defined in the linked pages."
msgstr "구두점 기호 토큰은 완전성을 위해 여기에 나열됩니다. 개별적인 사용법과 의미는 링크된 페이지에 정의되어 있습니다."

#: src/tokens.md:881 src/expressions/operator-expr.md:311
#: src/expressions/operator-expr.md:356 src/expressions/operator-expr.md:438
msgid "Symbol"
msgstr "기호"

#: src/tokens.md:881
msgid "Usage"
msgstr "용법"

#: src/tokens.md:883 src/expressions/operator-expr.md:358
msgid "`+`"
msgstr "`+`"

#: src/tokens.md:883
msgid "Plus"
msgstr "더하기"

#: src/tokens.md:883
msgid ""
"[Addition](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [Trait Bounds](trait-bounds.md), [Macro Kleene Matcher](macros-"
"by-example.md)"
msgstr "[더하기](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [트레이트 바운드](trait-bounds.md), [매크로 클리니 매처](macros-by-example.md)"

#: src/tokens.md:884 src/expressions/operator-expr.md:313
#: src/expressions/operator-expr.md:359
msgid "`-`"
msgstr "`-`"

#: src/tokens.md:884
msgid "Minus"
msgstr "빼기"

#: src/tokens.md:884
msgid ""
"[Subtraction](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [Negation](expressions/operator-expr.md#negation-operators)"
msgstr "[빼기](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [부정](expressions/operator-expr.md#negation-operators)"

#: src/tokens.md:885 src/expressions/operator-expr.md:360
msgid "`*`"
msgstr "`*`"

#: src/tokens.md:885
msgid "Star"
msgstr "별"

#: src/tokens.md:885
msgid ""
"[Multiplication](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [Dereference](expressions/operator-expr.md#the-dereference-"
"operator), [Raw Pointers](types/pointer.md#raw-pointers-const-and-mut), "
"[Macro Kleene Matcher](macros-by-example.md), [Use wildcards](items/use-"
"declarations.md)"
msgstr "[곱하기](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [역참조](expressions/operator-expr.md#the-dereference-operator), [원시 포인터](types/pointer.md#raw-pointers-const-and-mut), [매크로 클리니 매처](macros-by-example.md), [와일드카드 사용](items/use-declarations.md)"

#: src/tokens.md:886 src/expressions/operator-expr.md:361
msgid "`/`"
msgstr "`/`"

#: src/tokens.md:886
msgid "Slash"
msgstr "슬래시"

#: src/tokens.md:886
msgid ""
"[Division](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators)"
msgstr "[나누기](expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/tokens.md:887 src/expressions/operator-expr.md:362
msgid "`%`"
msgstr "`%`"

#: src/tokens.md:887
msgid "Percent"
msgstr "백분율"

#: src/tokens.md:887
msgid ""
"[Remainder](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators)"
msgstr "[나머지](expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/tokens.md:888 src/expressions.md:97 src/expressions/operator-expr.md:365
msgid "`^`"
msgstr "`^`"

#: src/tokens.md:888
msgid "Caret"
msgstr "캐럿"

#: src/tokens.md:888
msgid ""
"[Bitwise and Logical XOR](expressions/operator-expr.md#arithmetic-and-"
"logical-binary-operators)"
msgstr "[비트 및 논리 XOR](expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/tokens.md:889 src/attributes/testing.md:29
#: src/expressions/operator-expr.md:314
msgid "`!`"
msgstr "`!`"

#: src/tokens.md:889
msgid "Not"
msgstr "아님"

#: src/tokens.md:889
msgid ""
"[Bitwise and Logical NOT](expressions/operator-expr.md#negation-operators), "
"[Macro Calls](macros-by-example.md), [Inner Attributes](attributes.md), "
"[Never Type](types/never.md), [Negative impls](items/implementations.md)"
msgstr "[비트 및 논리 NOT](expressions/operator-expr.md#negation-operators), [매크로 호출](macros-by-example.md), [내부 속성](attributes.md), [Never 유형](types/never.md), [음수 impls](items/implementations.md)"

#: src/tokens.md:890 src/expressions.md:96 src/expressions/operator-expr.md:363
msgid "`&`"
msgstr "`&`"

#: src/tokens.md:890
msgid "And"
msgstr "그리고"

#: src/tokens.md:890
msgid ""
"[Bitwise and Logical AND](expressions/operator-expr.md#arithmetic-and-"
"logical-binary-operators), [Borrow](expressions/operator-expr.md#borrow-"
"operators), [References](types/pointer.md), [Reference patterns]"
"(patterns.md#reference-patterns)"
msgstr "[비트 및 논리 AND](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [차용](expressions/operator-expr.md#borrow-operators), [참조](types/pointer.md), [참조 패턴](patterns.md#reference-patterns)"

#: src/tokens.md:891 src/expressions.md:98 src/expressions/operator-expr.md:364
msgid "<code>\\|</code>"
msgstr "<code>\\|</code>"

#: src/tokens.md:891
msgid "Or"
msgstr "또는"

#: src/tokens.md:891
msgid ""
"[Bitwise and Logical OR](expressions/operator-expr.md#arithmetic-and-logical-"
"binary-operators), [Closures](expressions/closure-expr.md), Patterns in "
"[match](expressions/match-expr.md), [if let](expressions/if-expr.md#if-let-"
"expressions), and [while let](expressions/loop-expr.md#predicate-pattern-"
"loops)"
msgstr "[비트 및 논리 OR](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [클로저](expressions/closure-expr.md), [match](expressions/match-expr.md), [if let](expressions/if-expr.md#if-let-expressions) 및 [while let](expressions/loop-expr.md#predicate-pattern-loops)의 패턴"

#: src/tokens.md:892 src/expressions.md:100
msgid "`&&`"
msgstr "`&&`"

#: src/tokens.md:892
msgid "AndAnd"
msgstr "그리고 그리고"

#: src/tokens.md:892
msgid ""
"[Lazy AND](expressions/operator-expr.md#lazy-boolean-operators), [Borrow]"
"(expressions/operator-expr.md#borrow-operators), [References](types/"
"pointer.md), [Reference patterns](patterns.md#reference-patterns)"
msgstr "[지연 AND](expressions/operator-expr.md#lazy-boolean-operators), [차용](expressions/operator-expr.md#borrow-operators), [참조](types/pointer.md), [참조 패턴](patterns.md#reference-patterns)"

#: src/tokens.md:893 src/expressions.md:101
msgid "<code>\\|\\|</code>"
msgstr "<code>\\|\\|</code>"

#: src/tokens.md:893
msgid "OrOr"
msgstr "또는 또는"

#: src/tokens.md:893
msgid ""
"[Lazy OR](expressions/operator-expr.md#lazy-boolean-operators), [Closures]"
"(expressions/closure-expr.md)"
msgstr "[지연 OR](expressions/operator-expr.md#lazy-boolean-operators), [클로저](expressions/closure-expr.md)"

#: src/tokens.md:894 src/expressions/operator-expr.md:366
msgid "`<<`"
msgstr "`<<`"

#: src/tokens.md:894
msgid "Shl"
msgstr "Shl"

#: src/tokens.md:894
msgid ""
"[Shift Left](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [Nested Generics](items/generics.md)"
msgstr "[왼쪽 시프트](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [중첩 제네릭](items/generics.md)"

#: src/tokens.md:895 src/expressions/operator-expr.md:367
msgid "`>>`"
msgstr "`>>`"

#: src/tokens.md:895
msgid "Shr"
msgstr "Shr"

#: src/tokens.md:895
msgid ""
"[Shift Right](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [Nested Generics](items/generics.md)"
msgstr "[오른쪽 시프트](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [중첩 제네릭](items/generics.md)"

#: src/tokens.md:896
msgid "`+=`"
msgstr "`+=`"

#: src/tokens.md:896
msgid "PlusEq"
msgstr "PlusEq"

#: src/tokens.md:896
msgid ""
"[Addition assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[덧셈 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:897
msgid "`-=`"
msgstr "`-=`"

#: src/tokens.md:897
msgid "MinusEq"
msgstr "MinusEq"

#: src/tokens.md:897
msgid ""
"[Subtraction assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[뺄셈 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:898
msgid "`*=`"
msgstr "`*=`"

#: src/tokens.md:898
msgid "StarEq"
msgstr "StarEq"

#: src/tokens.md:898
msgid ""
"[Multiplication assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[곱셈 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:899
msgid "`/=`"
msgstr "`/=`"

#: src/tokens.md:899
msgid "SlashEq"
msgstr "SlashEq"

#: src/tokens.md:899
msgid ""
"[Division assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[나눗셈 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:900
msgid "`%=`"
msgstr "`%=`"

#: src/tokens.md:900
msgid "PercentEq"
msgstr "PercentEq"

#: src/tokens.md:900
msgid ""
"[Remainder assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[나머지 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:901
msgid "`^=`"
msgstr "`^=`"

#: src/tokens.md:901
msgid "CaretEq"
msgstr "CaretEq"

#: src/tokens.md:901
msgid ""
"[Bitwise XOR assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[비트 XOR 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:902
msgid "`&=`"
msgstr "`&=`"

#: src/tokens.md:902
msgid "AndEq"
msgstr "AndEq"

#: src/tokens.md:902
msgid ""
"[Bitwise And assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[비트 And 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:903
msgid "<code>\\|=</code>"
msgstr "<code>\\|=</code>"

#: src/tokens.md:903
msgid "OrEq"
msgstr "OrEq"

#: src/tokens.md:903
msgid ""
"[Bitwise Or assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[비트 Or 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:904
msgid "`<<=`"
msgstr "`<<=`"

#: src/tokens.md:904
msgid "ShlEq"
msgstr "ShlEq"

#: src/tokens.md:904
msgid ""
"[Shift Left assignment](expressions/operator-expr.md#compound-assignment-"
"expressions)"
msgstr "[왼쪽 시프트 할당](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/tokens.md:905
msgid "`>>=`"
msgstr "`>>=`"

#: src/tokens.md:905
msgid "ShrEq"
msgstr "ShrEq"

#: src/tokens.md:905
msgid ""
"[Shift Right assignment](expressions/operator-expr.md#compound-assignment-"
"expressions), [Nested Generics](items/generics.md)"
msgstr "[오른쪽 시프트 할당](expressions/operator-expr.md#compound-assignment-expressions), [중첩 제네릭](items/generics.md)"

#: src/tokens.md:906
msgid "`=`"
msgstr "`=`"

#: src/tokens.md:906
msgid "Eq"
msgstr "Eq"

#: src/tokens.md:906
msgid ""
"[Assignment](expressions/operator-expr.md#assignment-expressions), "
"[Attributes](attributes.md), Various type definitions"
msgstr "[할당](expressions/operator-expr.md#assignment-expressions), [속성](attributes.md), 다양한 유형 정의"

#: src/tokens.md:907 src/expressions/operator-expr.md:440
msgid "`==`"
msgstr "`==`"

#: src/tokens.md:907
msgid "EqEq"
msgstr "EqEq"

#: src/tokens.md:907
msgid "[Equal](expressions/operator-expr.md#comparison-operators)"
msgstr "[같음](expressions/operator-expr.md#comparison-operators)"

#: src/tokens.md:908 src/expressions/operator-expr.md:441
msgid "`!=`"
msgstr "`!=`"

#: src/tokens.md:908
msgid "Ne"
msgstr "Ne"

#: src/tokens.md:908
msgid "[Not Equal](expressions/operator-expr.md#comparison-operators)"
msgstr "[같지 않음](expressions/operator-expr.md#comparison-operators)"

#: src/tokens.md:909 src/expressions/operator-expr.md:442
msgid "`>`"
msgstr "`>`"

#: src/tokens.md:909
msgid "Gt"
msgstr "Gt"

#: src/tokens.md:909
msgid ""
"[Greater than](expressions/operator-expr.md#comparison-operators), [Generics]"
"(items/generics.md), [Paths](paths.md)"
msgstr "[보다 큼](expressions/operator-expr.md#comparison-operators), [제네릭](items/generics.md), [경로](paths.md)"

#: src/tokens.md:910 src/expressions/operator-expr.md:443
msgid "`<`"
msgstr "`<`"

#: src/tokens.md:910
msgid "Lt"
msgstr "Lt"

#: src/tokens.md:910
msgid ""
"[Less than](expressions/operator-expr.md#comparison-operators), [Generics]"
"(items/generics.md), [Paths](paths.md)"
msgstr "[보다 작음](expressions/operator-expr.md#comparison-operators), [제네릭](items/generics.md), [경로](paths.md)"

#: src/tokens.md:911 src/expressions/operator-expr.md:444
msgid "`>=`"
msgstr "`>=`"

#: src/tokens.md:911
msgid "Ge"
msgstr "Ge"

#: src/tokens.md:911
msgid ""
"[Greater than or equal to](expressions/operator-expr.md#comparison-"
"operators), [Generics](items/generics.md)"
msgstr "[크거나 같음](expressions/operator-expr.md#comparison-operators), [제네릭](items/generics.md)"

#: src/tokens.md:912 src/expressions/operator-expr.md:445
msgid "`<=`"
msgstr "`<=`"

#: src/tokens.md:912
msgid "Le"
msgstr "Le"

#: src/tokens.md:912
msgid ""
"[Less than or equal to](expressions/operator-expr.md#comparison-operators)"
msgstr "[작거나 같음](expressions/operator-expr.md#comparison-operators)"

#: src/tokens.md:913
msgid "`@`"
msgstr "`@`"

#: src/tokens.md:913
msgid "At"
msgstr "At"

#: src/tokens.md:913
msgid "[Subpattern binding](patterns.md#identifier-patterns)"
msgstr "[하위 패턴 바인딩](patterns.md#identifier-patterns)"

#: src/tokens.md:914
msgid "`_`"
msgstr "`_`"

#: src/tokens.md:914
msgid "Underscore"
msgstr "밑줄"

#: src/tokens.md:914
msgid ""
"[Wildcard patterns](patterns.md#wildcard-pattern), [Inferred types](types/"
"inferred.md), Unnamed items in [constants](items/constant-items.md), [extern "
"crates](items/extern-crates.md), [use declarations](items/use-"
"declarations.md), and [destructuring assignment](expressions/underscore-"
"expr.md)"
msgstr "[와일드카드 패턴](patterns.md#wildcard-pattern), [추론된 유형](types/inferred.md), [상수](items/constant-items.md)의 명명되지 않은 항목, [외부 상자](items/extern-crates.md), [사용 선언](items/use-declarations.md) 및 [구조 해체 할당](expressions/underscore-expr.md)"

#: src/tokens.md:915
msgid "`.`"
msgstr "`.`"

#: src/tokens.md:915
msgid "Dot"
msgstr "점"

#: src/tokens.md:915
msgid ""
"[Field access](expressions/field-expr.md), [Tuple index](expressions/tuple-"
"expr.md#tuple-indexing-expressions)"
msgstr "[필드 접근](expressions/field-expr.md), [튜플 인덱스](expressions/tuple-expr.md#tuple-indexing-expressions)"

#: src/tokens.md:916 src/expressions/range-expr.md:43
msgid "`..`"
msgstr "`..`"

#: src/tokens.md:916
msgid "DotDot"
msgstr "점점"

#: src/tokens.md:916
msgid ""
"[Range](expressions/range-expr.md), [Struct expressions](expressions/struct-"
"expr.md), [Patterns](patterns.md), [Range Patterns](patterns.md#range-"
"patterns)"
msgstr "[범위](expressions/range-expr.md), [구조체 표현식](expressions/struct-expr.md), [패턴](patterns.md), [범위 패턴](patterns.md#range-patterns)"

#: src/tokens.md:917
msgid "`...`"
msgstr "`...`"

#: src/tokens.md:917
msgid "DotDotDot"
msgstr "점점점"

#: src/tokens.md:917
msgid ""
"[Variadic functions](items/external-blocks.md), [Range patterns]"
"(patterns.md#range-patterns)"
msgstr "[가변 함수](items/external-blocks.md), [범위 패턴](patterns.md#range-patterns)"

#: src/tokens.md:918
msgid "`..=`"
msgstr "`..=`"

#: src/tokens.md:918
msgid "DotDotEq"
msgstr "DotDotEq"

#: src/tokens.md:918
msgid ""
"[Inclusive Range](expressions/range-expr.md), [Range patterns]"
"(patterns.md#range-patterns)"
msgstr "[포함 범위](expressions/range-expr.md), [범위 패턴](patterns.md#range-patterns)"

#: src/tokens.md:919
msgid "`,`"
msgstr "`,`"

#: src/tokens.md:919
msgid "Comma"
msgstr "쉼표"

#: src/tokens.md:919 src/tokens.md:921
msgid "Various separators"
msgstr "다양한 구분자"

#: src/tokens.md:920
msgid "`;`"
msgstr "`;`"

#: src/tokens.md:920
msgid "Semi"
msgstr "세미콜론"

#: src/tokens.md:920
msgid ""
"Terminator for various items and statements, [Array types](types/array.md)"
msgstr "다양한 항목 및 문의 종결자, [배열 유형](types/array.md)"

#: src/tokens.md:921
msgid "`:`"
msgstr "`:`"

#: src/tokens.md:921
msgid "Colon"
msgstr "콜론"

#: src/tokens.md:922 src/paths.md:205
msgid "`::`"
msgstr "`::`"

#: src/tokens.md:922
msgid "PathSep"
msgstr "PathSep"

#: src/tokens.md:922
msgid "[Path separator](paths.md)"
msgstr "[경로 구분자](paths.md)"

#: src/tokens.md:923
msgid "`->`"
msgstr "`->`"

#: src/tokens.md:923
msgid "RArrow"
msgstr "RArrow"

#: src/tokens.md:923
msgid ""
"[Function return type](items/functions.md), [Closure return type]"
"(expressions/closure-expr.md), [Function pointer type](types/function-"
"pointer.md)"
msgstr "[함수 반환 유형](items/functions.md), [클로저 반환 유형](expressions/closure-expr.md), [함수 포인터 유형](types/function-pointer.md)"

#: src/tokens.md:924
msgid "`=>`"
msgstr "`=>`"

#: src/tokens.md:924
msgid "FatArrow"
msgstr "FatArrow"

#: src/tokens.md:924
msgid "[Match arms](expressions/match-expr.md), [Macros](macros-by-example.md)"
msgstr "[일치 암](expressions/match-expr.md), [매크로](macros-by-example.md)"

#: src/tokens.md:925
msgid "`<-`"
msgstr "`<-`"

#: src/tokens.md:925
msgid "LArrow"
msgstr "LArrow"

#: src/tokens.md:925
msgid ""
"The left arrow symbol has been unused since before Rust 1.0, but it is still "
"treated as a single token"
msgstr "왼쪽 화살표 기호는 Rust 1.0 이전부터 사용되지 않았지만 여전히 단일 토큰으로 처리됩니다."

#: src/tokens.md:926
msgid "`#`"
msgstr "`#`"

#: src/tokens.md:926
msgid "Pound"
msgstr "파운드"

#: src/tokens.md:926
msgid "[Attributes](attributes.md)"
msgstr "[속성](attributes.md)"

#: src/tokens.md:927
msgid "`$`"
msgstr "`$`"

#: src/tokens.md:927
msgid "Dollar"
msgstr "달러"

#: src/tokens.md:927
msgid "[Macros](macros-by-example.md)"
msgstr "[매크로](macros-by-example.md)"

#: src/tokens.md:928 src/expressions.md:90
msgid "`?`"
msgstr "`?`"

#: src/tokens.md:928
msgid "Question"
msgstr "물음표"

#: src/tokens.md:928
msgid ""
"[Question mark operator](expressions/operator-expr.md#the-question-mark-"
"operator), [Questionably sized](trait-bounds.md#sized), [Macro Kleene "
"Matcher](macros-by-example.md)"
msgstr "[물음표 연산자](expressions/operator-expr.md#the-question-mark-operator), [크기가 의심스러운](trait-bounds.md#sized), [매크로 클리니 매처](macros-by-example.md)"

#: src/tokens.md:929
msgid "`~`"
msgstr "`~`"

#: src/tokens.md:929
msgid "Tilde"
msgstr "물결표"

#: src/tokens.md:929
msgid ""
"The tilde operator has been unused since before Rust 1.0, but its token may "
"still be used"
msgstr "물결 연산자는 Rust 1.0 이전부터 사용되지 않았지만 토큰은 여전히 사용될 수 있습니다."

#: src/tokens.md:933
msgid "Delimiters"
msgstr "구분자"

#: src/tokens.md:936
msgid ""
"Bracket punctuation is used in various parts of the grammar. An open bracket "
"must always be paired with a close bracket. Brackets and the tokens within "
"them are referred to as \"token trees\" in [macros](macros-by-example.md).  "
"The three types of brackets are:"
msgstr "대괄호 구두점은 문법의 다양한 부분에서 사용됩니다. 여는 대괄호는 항상 닫는 대괄호와 짝을 이루어야 합니다. 대괄호와 그 안의 토큰은 [매크로](macros-by-example.md)에서 \"토큰 트리\"라고 합니다. 세 가지 유형의 대괄호는 다음과 같습니다."

#: src/tokens.md:940
msgid "Bracket"
msgstr "대괄호"

#: src/tokens.md:940 src/expressions/tuple-expr.md:47
#: src/expressions/range-expr.md:38 src/types/numeric.md:13
#: src/types/numeric.md:25 src/type-layout.md:61 src/subtyping.md:79
msgid "Type"
msgstr "유형"

#: src/tokens.md:942
msgid "`{` `}`"
msgstr "`{` `}`"

#: src/tokens.md:942
msgid "Curly braces"
msgstr "중괄호"

#: src/tokens.md:943
msgid "`[` `]`"
msgstr "`[` `]`"

#: src/tokens.md:943
msgid "Square brackets"
msgstr "대괄호"

#: src/tokens.md:944
msgid "`(` `)`"
msgstr "`(` `)`"

#: src/tokens.md:944
msgid "Parentheses"
msgstr "괄호"

#: src/tokens.md:948
msgid "Reserved prefixes"
msgstr "예약된 접두사"

#: src/tokens.md:952
msgstr ""
"**<sup>렉서 2021+</sup>**  \n"
"예약된_토큰_큰따옴표 : ( 식별자_또는_키워드 <sub>_`b` 또는 "
"`c` 또는 `r` 또는 `br` 또는 `cr` 제외_</sub> | `_` ) `\"`  \n"
"예약된_토큰_작은따옴표 : ( 식별자_또는_키워드 <sub>_`b` 제외_</"
"sub> | `_` ) `'`  \n"
"예약된_토큰_해시 : ( 식별자_또는_키워드 <sub>_`r` 또는 `br` 또는 "
"`cr` 제외_</sub> | `_` ) `#`  \n"
"예약된_토큰_라이프타임 : `'` (식별자_또는_키워드 <sub>_`r` 제외_</sub> "
"| \\_) `#`"

#: src/tokens.md:960
msgid ""
"Some lexical forms known as _reserved prefixes_ are reserved for future use."
msgstr "_예약된 접두사_로 알려진 일부 어휘 형식은 향후 사용을 위해 예약되어 있습니다."

#: src/tokens.md:964
msgid ""
"Source input which would otherwise be lexically interpreted as a non-raw "
"identifier (or a keyword or `_`) which is immediately followed by a `#`, "
"`'`, or `\\\"` character (without intervening whitespace) is identified as a "
"reserved prefix."
msgstr "그렇지 않으면 어휘적으로 비원시 식별자(또는 키워드 또는 `_`)로 해석될 소스 입력은 `#`, `'` 또는 `\\\"` 문자가 바로 뒤에 오는(중간 공백 없이) 경우 예약된 접두사로 식별됩니다."

#: src/tokens.md:968
msgid ""
"Note that raw identifiers, raw string literals, and raw byte string literals "
"may contain a `#` character but are not interpreted as containing a reserved "
"prefix."
msgstr "원시 식별자, 원시 문자열 리터럴 및 원시 바이트 문자열 리터럴에는 `#` 문자가 포함될 수 있지만 예약된 접두사를 포함하는 것으로 해석되지 않습니다."

#: src/tokens.md:972
msgid ""
"Similarly the `r`, `b`, `br`, `c`, and `cr` prefixes used in raw string "
"literals, byte literals, byte string literals, raw byte string literals, C "
"string literals, and raw C string literals are not interpreted as reserved "
"prefixes."
msgstr "마찬가지로 원시 문자열 리터럴, 바이트 리터럴, 바이트 문자열 리터럴, 원시 바이트 문자열 리터럴, C 문자열 리터럴 및 원시 C 문자열 리터럴에 사용되는 `r`, `b`, `br`, `c` 및 `cr` 접두사는 예약된 접두사로 해석되지 않습니다."

#: src/tokens.md:976
msgid ""
"Source input which would otherwise be lexically interpreted as a non-raw "
"lifetime (or a keyword or `_`) which is immediately followed by a `#` "
"character (without intervening whitespace) is identified as a reserved "
"lifetime prefix."
msgstr "그렇지 않으면 어휘적으로 비원시 라이프타임(또는 키워드 또는 `_`)으로 해석될 소스 입력은 `#` 문자가 바로 뒤에 오는(중간 공백 없이) 경우 예약된 라이프타임 접두사로 식별됩니다."

#: src/tokens.md:980
msgid ""
"**Edition differences**: Starting with the 2021 edition, reserved prefixes "
"are reported as an error by the lexer (in particular, they cannot be passed "
"to macros)."
msgstr "**에디션 차이**: 2021 에디션부터 예약된 접두사는 렉서에 의해 오류로 보고됩니다(특히 매크로에 전달할 수 없음)."

#: src/tokens.md:982
msgid ""
"Before the 2021 edition, reserved prefixes are accepted by the lexer and "
"interpreted as multiple tokens (for example, one token for the identifier or "
"keyword, followed by a `#` token)."
msgstr "2021 에디션 이전에는 예약된 접두사가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다(예: 식별자 또는 키워드에 대한 하나의 토큰 뒤에 `#` 토큰이 옴)."

#: src/tokens.md:984
msgid "Examples accepted in all editions:"
msgstr "모든 에디션에서 허용되는 예:"

#: src/tokens.md:989 src/tokens.md:999
msgid "\"...\""
msgstr "\"...\""

#: src/tokens.md:990
msgid "// three tokens: r#let # foo\n"
msgstr "// 세 개의 토큰: r#let # foo\n"

#: src/tokens.md:994
msgid "Examples accepted before the 2021 edition but rejected later:"
msgstr "2021 에디션 이전에는 허용되었지만 이후에는 거부된 예:"

#: src/tokens.md:1005
msgid "Reserved guards"
msgstr "예약된 가드"

#: src/tokens.md:1009
msgid ""
"**<sup>Lexer 2024+</sup>**  \n"
"RESERVED_GUARDED_STRING_LITERAL : `#`<sup>+</sup> [STRING_LITERAL]"
"(tokens.md#string-literals)  \n"
"RESERVED_POUNDS : `#`<sup>2..</sup>"
msgstr ""
"**<sup>Lexer 2024+</sup>**  \n"
"RESERVED_GUARDED_STRING_LITERAL : `#`<sup>+</sup> [STRING_LITERAL]"
"(tokens.md#string-literals)  \n"
"RESERVED_POUNDS : `#`<sup>2..</sup>"

#: src/tokens.md:1015
msgid ""
"The reserved guards are syntax reserved for future use, and will generate a "
"compile error if used."
msgstr "예약된 가드는 향후 사용을 위해 예약된 구문이며 사용하면 컴파일 오류가 발생합니다."

#: src/tokens.md:1019
msgid ""
"The _reserved guarded string literal_ is a token of one or more `U+0023` "
"(`#`) immediately followed by a [STRING_LITERAL](tokens.md#string-literals)."
msgstr "_예약된 보호된 문자열 리터럴_은 하나 이상의 `U+0023`(`#`) 토큰 바로 뒤에 [STRING_LITERAL](tokens.md#string-literals)이 오는 토큰입니다."

#: src/tokens.md:1023
msgid "The _reserved pounds_ is a token of two or more `U+0023` (`#`)."
msgstr "_예약된 파운드_는 두 개 이상의 `U+0023`(`#`) 토큰입니다."

#: src/tokens.md:1027
msgid ""
"**Edition differences**: Before the 2024 edition, reserved guards are "
"accepted by the lexer and interpreted as multiple tokens. For example, the "
"`#\"foo\"#` form is interpreted as three tokens. `##` is interpreted as two "
"tokens."
msgstr "**에디션 차이**: 2024 에디션 이전에는 예약된 가드가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다. 예를 들어, `#\"foo\"#` 형식은 세 개의 토큰으로 해석됩니다. `##`은 두 개의 토큰으로 해석됩니다."

#: src/macros.md:7
msgid ""
"The functionality and syntax of Rust can be extended with custom definitions "
"called macros. They are given names, and invoked through a consistent "
"syntax: `some_extension!(...)`."
msgstr "Rust의 기능과 구문은 매크로라는 사용자 지정 정의로 확장할 수 있습니다. 이름이 주어지고 `some_extension!(...)`과 같은 일관된 구문을 통해 호출됩니다."

#: src/macros.md:11
msgid "There are two ways to define new macros:"
msgstr "새 매크로를 정의하는 두 가지 방법이 있습니다."

#: src/macros.md:13
msgid ""
"[Macros by Example](macros-by-example.md) define new syntax in a higher-"
"level, declarative way."
msgstr "[예제를 통한 매크로](macros-by-example.md)는 더 높은 수준의 선언적 방식으로 새로운 구문을 정의합니다."

#: src/macros.md:14
msgid ""
"[Procedural Macros](procedural-macros.md) define function-like macros, "
"custom derives, and custom attributes using functions that operate on input "
"tokens."
msgstr "[절차적 매크로](procedural-macros.md)는 입력 토큰에 대해 작동하는 함수를 사용하여 함수와 유사한 매크로, 사용자 지정 파생 및 사용자 지정 속성을 정의합니다."

#: src/macros.md:19
msgid "Macro Invocation"
msgstr "매크로 호출"

#: src/macros.md:23
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MacroInvocation_ :  \n"
"   [_SimplePath_](paths.md#simple-paths) `!` _DelimTokenTree_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_매크로호출_ :  \n"
"   [_단순경로_](paths.md#simple-paths) `!` _구분된토큰트리_"

#: src/macros.md:27
msgid ""
"_DelimTokenTree_ :  \n"
"       `(` _TokenTree_<sup>\\*</sup> `)`  \n"
"   | `[` _TokenTree_<sup>\\*</sup> `]`  \n"
"   | `{` _TokenTree_<sup>\\*</sup> `}`"
msgstr ""
"_구분된토큰트리_ :  \n"
"       `(` _토큰트리_<sup>\\*</sup> `)`  \n"
"   | `[` _토큰트리_<sup>\\*</sup> `]`  \n"
"   | `{` _토큰트리_<sup>\\*</sup> `}`"

#: src/macros.md:32
msgid ""
"_TokenTree_ :  \n"
"   [_Token_](tokens.md)<sub>_except [delimiters](tokens.md#delimiters)_</"
"sub> | _DelimTokenTree_"
msgstr ""
"_토큰트리_ :  \n"
"   [_토큰_](tokens.md)<sub>_단, [구분자](tokens.md#delimiters) 제외_</"
"sub> | _구분된토큰트리_"

#: src/macros.md:35
msgid ""
"_MacroInvocationSemi_ :  \n"
"      [_SimplePath_](paths.md#simple-paths) `!` `(` _TokenTree_<sup>\\*</"
"sup> `)` `;`  \n"
"   | [_SimplePath_](paths.md#simple-paths) `!` `[` _TokenTree_<sup>\\*</sup> "
"`]` `;`  \n"
"   | [_SimplePath_](paths.md#simple-paths) `!` `{` _TokenTree_<sup>\\*</sup> "
"`}`"
msgstr ""
"_세미콜론매크로호출_ :  \n"
"      [_단순경로_](paths.md#simple-paths) `!` `(` _토큰트리_<sup>\\*</"
"sup> `)` `;`  \n"
"   | [_단순경로_](paths.md#simple-paths) `!` `[` _토큰트리_<sup>\\*</sup> "
"`]` `;`  \n"
"   | [_단순경로_](paths.md#simple-paths) `!` `{` _토큰트리_<sup>\\*</sup> "
"`}`"

#: src/macros.md:42
msgid ""
"A macro invocation expands a macro at compile time and replaces the "
"invocation with the result of the macro. Macros may be invoked in the "
"following situations:"
msgstr "매크로 호출은 컴파일 타임에 매크로를 확장하고 호출을 매크로의 결과로 바꿉니다. 다음과 같은 상황에서 매크로를 호출할 수 있습니다."

#: src/macros.md:48
msgid "[Expressions](expressions.md) and [statements](statements.md)"
msgstr "[표현식](expressions.md) 및 [문](statements.md)"

#: src/macros.md:52
msgid "[Patterns](patterns.md)"
msgstr "[패턴](patterns.md)"

#: src/macros.md:56
msgid "[Types](types.md)"
msgstr "[유형](types.md)"

#: src/macros.md:60
msgid ""
"[Items](items.md) including [associated items](items/associated-items.md)"
msgstr "[항목](items.md) 포함 [연관 항목](items/associated-items.md)"

#: src/macros.md:64
msgid "[`macro_rules`](macros-by-example.md) transcribers"
msgstr "[`macro_rules`](macros-by-example.md) 트랜스크라이버"

#: src/macros.md:68
msgid "[External blocks](items/external-blocks.md)"
msgstr "[외부 블록](items/external-blocks.md)"

#: src/macros.md:72
msgid ""
"When used as an item or a statement, the _MacroInvocationSemi_ form is used "
"where a semicolon is required at the end when not using curly braces. "
"[Visibility qualifiers](visibility-and-privacy.md) are never allowed before "
"a macro invocation or [`macro_rules`](macros-by-example.md) definition."
msgstr "항목 또는 문으로 사용될 때, _MacroInvocationSemi_ 형식은 중괄호를 사용하지 않을 때 끝에 세미콜론이 필요한 경우에 사용됩니다. [가시성 한정자](visibility-and-privacy.md)는 매크로 호출 또는 [`macro_rules`](macros-by-example.md) 정의 앞에 절대 허용되지 않습니다."

#: src/macros.md:78 src/items/generics.md:107
msgid "// Used as an expression.\n"
msgstr "// 표현식으로 사용됩니다.\n"

#: src/macros.md:80
msgid "// Used as a statement.\n"
msgstr "// 문으로 사용됩니다.\n"

#: src/macros.md:83
msgid "// Used in a pattern.\n"
msgstr "// 패턴에서 사용됩니다.\n"

#: src/macros.md:92
msgid "// Used in a type.\n"
msgstr "// 유형에서 사용됩니다.\n"

#: src/macros.md:99
msgid "// Used as an item.\n"
msgstr "// 항목으로 사용됩니다.\n"

#: src/macros.md:103
msgid "// Used as an associated item.\n"
msgstr "// 연관 항목으로 사용됩니다.\n"
#: src/macros.md:111
msgid "// Macro calls within macros.\n"
msgstr "// 매크로 내의 매크로 호출.\n"

#: src/macros.md:114
msgid "\"Macro call in a macro!\""
msgstr "\"매크로 내의 매크로 호출!\""

#: src/macros.md:115
msgid ""
"// Outer macro `example` is expanded, then inner macro `println` is "
"expanded.\n"
msgstr ""
"// 외부 매크로 `example`이 확장된 후, 내부 매크로 `println`이 "
"확장됩니다.\n"

#: src/macros-by-example.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MacroRulesDefinition_ :  \n"
"   `macro_rules` `!` [IDENTIFIER](identifiers.md) _MacroRulesDef_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_MacroRulesDefinition_ :  \n"
"   `macro_rules` `!` [IDENTIFIER](identifiers.md) _MacroRulesDef_"

#: src/macros-by-example.md:11
msgid ""
"_MacroRulesDef_ :  \n"
"      `(` _MacroRules_ `)` `;`  \n"
"   | `[` _MacroRules_ `]` `;`  \n"
"   | `{` _MacroRules_ `}`"
msgstr ""
"_MacroRulesDef_ :  \n"
"      `(` _MacroRules_ `)` `;`  \n"
"   | `[` _MacroRules_ `]` `;`  \n"
"   | `{` _MacroRules_ `}`"

#: src/macros-by-example.md:16
msgstr ""
"_매크로규칙들_ :  \n"
"   _매크로규칙_ ( `;` _매크로규칙_ )<sup>\\*</sup> `;`<sup>?</sup>"

msgid ""
"_MacroRule_ :  \n"
"   _MacroMatcher_ `=>` _MacroTranscriber_"
msgstr ""
"_MacroRule_ :  \n"
"   _MacroMatcher_ `=>` _MacroTranscriber_"

#: src/macros-by-example.md:22
msgstr ""
"_매크로매처_ :  \n"
"      `(` _매크로매치_<sup>\\*</sup> `)`  \n"
"   | `[` _매크로매치_<sup>\\*</sup> `]`  \n"
"   | `{` _매크로매치_<sup>\\*</sup> `}`"

#: src/macros-by-example.md:27
msgstr ""
"_매크로매치_ :  \n"
"      [_토큰_](tokens.md)<sub>_`$` 및 [구분자]"
"(tokens.md#delimiters) 제외_</sub>  \n"
"   | _매크로매처_  \n"
"   | `$` ( [식별자_또는_키워드](identifiers.md) <sub>_`crate` 제외_</"
"sub> | [원시_식별자](identifiers.md) | `_` ) `:` _매크로조각지정자_  \n"
"   | `$` `(` _매크로매치_<sup>+</sup> `)` _매크로반복구분자_<sup>?</sup> "
"_매크로반복연산자_"

#: src/macros-by-example.md:33
msgstr ""
"_매크로조각지정자_ :  \n"
"      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | "
"`literal`  \n"
"   | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`"

#: src/macros-by-example.md:37
msgstr ""
"_매크로반복구분자_ :  \n"
"   [_토큰_](tokens.md)<sub>_[구분자](tokens.md#delimiters) 및 "
"매크로반복연산자 제외_</sub>"

#: src/macros-by-example.md:40
msgstr ""
"_매크로반복연산자_ :  \n"
"   `*` | `+` | `?`"

#: src/macros-by-example.md:43
msgstr ""
"_매크로트랜스크라이버_ :  \n"
"   [_구분된토큰트리_](macros.md)"

#: src/macros-by-example.md:48
msgid ""
"`macro_rules` allows users to define syntax extension in a declarative way.  "
"We call such extensions \"macros by example\" or simply \"macros\"."
msgstr "`macro_rules`는 사용자가 선언적인 방식으로 구문 확장을 정의할 수 있도록 합니다.  이러한 확장을 \"예제를 통한 매크로\" 또는 간단히 \"매크로\"라고 합니다."

#: src/macros-by-example.md:51
msgid ""
"Each macro by example has a name, and one or more _rules_. Each rule has two "
"parts: a _matcher_, describing the syntax that it matches, and a "
"_transcriber_, describing the syntax that will replace a successfully "
"matched invocation. Both the matcher and the transcriber must be surrounded "
"by delimiters. Macros can expand to expressions, statements, items "
"(including traits, impls, and foreign items), types, or patterns."
msgstr "각 예제별 매크로에는 이름과 하나 이상의 _규칙_이 있습니다. 각 규칙에는 두 부분이 있습니다. 일치하는 구문을 설명하는 _매처_와 성공적으로 일치한 호출을 대체할 구문을 설명하는 _트랜스크라이버_입니다. 매처와 트랜스크라이버는 모두 구분 기호로 둘러싸여 있어야 합니다. 매크로는 표현식, 문, 항목(트레이트, impl 및 외부 항목 포함), 유형 또는 패턴으로 확장될 수 있습니다."

#: src/macros-by-example.md:60
msgid "Transcribing"
msgstr "트랜스크라이빙"

#: src/macros-by-example.md:64
msgid ""
"When a macro is invoked, the macro expander looks up macro invocations by "
"name, and tries each macro rule in turn. It transcribes the first successful "
"match; if this results in an error, then future matches are not tried."
msgstr "매크로가 호출되면 매크로 확장기는 이름으로 매크로 호출을 조회하고 각 매크로 규칙을 차례로 시도합니다. 첫 번째 성공적인 일치를 트랜스크라이브합니다. 이로 인해 오류가 발생하면 이후 일치는 시도되지 않습니다."

#: src/macros-by-example.md:70
msgid ""
"When matching, no lookahead is performed; if the compiler cannot "
"unambiguously determine how to parse the macro invocation one token at a "
"time, then it is an error. In the following example, the compiler does not "
"look ahead past the identifier to see if the following token is a `)`, even "
"though that would allow it to parse the invocation unambiguously:"
msgstr "일치시킬 때 미리 보기를 수행하지 않습니다. 컴파일러가 한 번에 하나의 토큰으로 매크로 호출을 구문 분석하는 방법을 명확하게 결정할 수 없으면 오류입니다. 다음 예에서 컴파일러는 다음 토큰이 ')'인지 확인하기 위해 식별자를 지나 미리 보지 않습니다. 그렇게 하면 호출을 명확하게 구문 분석할 수 있음에도 불구하고 말입니다."

#: src/macros-by-example.md:81
msgid "// Error: local ambiguity\n"
msgstr "// 오류: 지역적 모호성\n"

#: src/macros-by-example.md:86
msgid ""
"In both the matcher and the transcriber, the `$` token is used to invoke "
"special behaviours from the macro engine (described below in [Metavariables]"
"(#metavariables) and [Repetitions](#repetitions)). Tokens that aren't part "
"of such an invocation are matched and transcribed literally, with one "
"exception. The exception is that the outer delimiters for the matcher will "
"match any pair of delimiters. Thus, for instance, the matcher `(())` will "
"match `{()}` but not `{{}}`. The character `$` cannot be matched or "
"transcribed literally."
msgstr "매처와 트랜스크라이버 모두에서 '$' 토큰은 매크로 엔진에서 특수 동작을 호출하는 데 사용됩니다([메타변수](#metavariables) 및 [반복](#repetitions)에서 아래에 설명됨). 이러한 호출의 일부가 아닌 토큰은 한 가지 예외를 제외하고 문자 그대로 일치되고 트랜스크라이브됩니다. 예외는 매처의 외부 구분 기호가 모든 구분 기호 쌍과 일치한다는 것입니다. 따라서 예를 들어 매처 '(())'는 '{()}'와 일치하지만 '{{}}'와는 일치하지 않습니다. '$' 문자는 문자 그대로 일치시키거나 트랜스크라이브할 수 없습니다."

#: src/macros-by-example.md:96
msgid "Forwarding a matched fragment"
msgstr "일치된 조각 전달"

#: src/macros-by-example.md:99
msgid ""
"When forwarding a matched fragment to another macro-by-example, matchers in "
"the second macro will see an opaque AST of the fragment type. The second "
"macro can't use literal tokens to match the fragments in the matcher, only a "
"fragment specifier of the same type. The `ident`, `lifetime`, and `tt` "
"fragment types are an exception, and _can_ be matched by literal tokens. The "
"following illustrates this restriction:"
msgstr "일치된 조각을 다른 예제별 매크로로 전달할 때 두 번째 매크로의 매처는 조각 유형의 불투명한 AST를 보게 됩니다. 두 번째 매크로는 매처의 조각을 일치시키기 위해 리터럴 토큰을 사용할 수 없으며 동일한 유형의 조각 지정자만 사용할 수 있습니다. `ident`, `lifetime` 및 `tt` 조각 유형은 예외이며 리터럴 토큰으로 일치시킬 수 있습니다. 다음은 이 제한 사항을 보여줍니다."

#: src/macros-by-example.md:108
msgid "// ERROR:               ^^ no rules expected this token in macro call\n"
msgstr "// 오류:               ^^ 매크로 호출에서 이 토큰을 예상한 규칙이 없습니다\n"

#: src/macros-by-example.md:119
msgid ""
"The following illustrates how tokens can be directly matched after matching "
"a `tt` fragment:"
msgstr "다음은 'tt' 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다."

#: src/macros-by-example.md:123
msgid "// compiles OK\n"
msgstr "// 컴파일 OK\n"

#: src/macros-by-example.md:137
msgid "Metavariables"
msgstr "메타변수"

#: src/macros-by-example.md:141
msgid ""
"In the matcher, `$` _name_ `:` _fragment-specifier_ matches a Rust syntax "
"fragment of the kind specified and binds it to the metavariable `$`_name_."
msgstr "매처에서 `$` _이름_ `:` _조각-지정자_는 지정된 종류의 Rust 구문 조각과 일치하고 메타변수 `$`_이름_에 바인딩합니다."

#: src/macros-by-example.md:146
msgid "Valid fragment specifiers are:"
msgstr "유효한 조각 지정자는 다음과 같습니다."

#: src/macros-by-example.md:148
msgid "`block`: a [_BlockExpression_](expressions/block-expr.md)"
msgstr "`block`: [_블록표현식_](expressions/block-expr.md)"

#: src/macros-by-example.md:149
msgid "`expr`: an [_Expression_](expressions.md)"
msgstr "`expr`: [_표현식_](expressions.md)"

#: src/macros-by-example.md:150
msgid ""
"`expr_2021`: an [_Expression_](expressions.md) except "
"[_UnderscoreExpression_](expressions/underscore-expr.md) and "
"[_ConstBlockExpression_](expressions/block-expr.md#const-blocks) (see "
"[macro.decl.meta.edition2024](macros-by-example.md#r-"
"macro.decl.meta.edition2024))"
msgstr "`expr_2021`: [_밑줄표현식_](expressions/underscore-expr.md) 및 [_상수블록표현식_](expressions/block-expr.md#const-blocks)을 제외한 [_표현식_](expressions.md) ([macro.decl.meta.edition2024](macros-by-example.md#r-macro.decl.meta.edition2024) 참조)"

#: src/macros-by-example.md:151
msgid ""
"`ident`: an [IDENTIFIER_OR_KEYWORD](identifiers.md) or [RAW_IDENTIFIER]"
"(identifiers.md)"
msgstr "`ident`: [식별자_또는_키워드](identifiers.md) 또는 [원시_식별자](identifiers.md)"

#: src/macros-by-example.md:152
msgid "`item`: an [_Item_](items.md)"
msgstr "`item`: [_아이템_](items.md)"

#: src/macros-by-example.md:153
msgid "`lifetime`: a [LIFETIME_TOKEN](tokens.md#lifetimes-and-loop-labels)"
msgstr "`lifetime`: [라이프타임_토큰](tokens.md#lifetimes-and-loop-labels)"

#: src/macros-by-example.md:154
msgid ""
"`literal`: matches `-`<sup>?</sup>[_LiteralExpression_](expressions/literal-"
"expr.md)"
msgstr "`literal`: `-`<sup>?</sup>[_리터럴표현식_](expressions/literal-expr.md)과 일치합니다"

#: src/macros-by-example.md:155
msgid "`meta`: an [_Attr_](attributes.md), the contents of an attribute"
msgstr "`meta`: [_속성_](attributes.md), 속성의 내용"

#: src/macros-by-example.md:156
msgid ""
"`pat`: a [_Pattern_](patterns.md) (see [macro.decl.meta.edition2021](macros-"
"by-example.md#r-macro.decl.meta.edition2021))"
msgstr "`pat`: [_패턴_](patterns.md) ([macro.decl.meta.edition2021](macros-by-example.md#r-macro.decl.meta.edition2021) 참조)"

#: src/macros-by-example.md:157
msgid "`pat_param`: a [_PatternNoTopAlt_](patterns.md)"
msgstr "`pat_param`: [_패턴상단대체없음_](patterns.md)"

#: src/macros-by-example.md:158
msgid "`path`: a [_TypePath_](paths.md#paths-in-types) style path"
msgstr "`path`: [_타입경로_](paths.md#paths-in-types) 스타일 경로"

#: src/macros-by-example.md:159
msgid ""
"`stmt`: a [_Statement_](statements.md) without the trailing semicolon "
"(except for item statements that require semicolons)"
msgstr "`stmt`: 후행 세미콜론이 없는 [_문_](statements.md) (세미콜론이 필요한 항목 문 제외)"

#: src/macros-by-example.md:160
msgid ""
"`tt`: a [_TokenTree_](macros.md#macro-invocation) (a single [token]"
"(tokens.md) or tokens in matching delimiters `()`, `[]`, or `{}`)"
msgstr "`tt`: [_토큰트리_](macros.md#macro-invocation) (단일 [토큰](tokens.md) 또는 일치하는 구분 기호 `()`, `[]` 또는 `{}`의 토큰)"

#: src/macros-by-example.md:161
msgid "`ty`: a [_Type_](types.md#type-expressions)"
msgstr "`ty`: [_타입_](types.md#type-expressions)"

#: src/macros-by-example.md:162
msgid ""
"`vis`: a possibly empty [_Visibility_](visibility-and-privacy.md) qualifier"
msgstr "`vis`: 비어 있을 수 있는 [_가시성_](visibility-and-privacy.md) 한정자"

#: src/macros-by-example.md:166
msgid ""
"In the transcriber, metavariables are referred to simply by `$`_name_, since "
"the fragment kind is specified in the matcher. Metavariables are replaced "
"with the syntax element that matched them."
msgstr "트랜스크라이버에서 메타변수는 조각 종류가 매처에 지정되어 있으므로 간단히 `$`_이름_으로 참조됩니다. 메타변수는 일치하는 구문 요소로 대체됩니다."

#: src/macros-by-example.md:172
msgid ""
"The keyword metavariable `$crate` can be used to refer to the current crate; "
"see [Hygiene](#hygiene) below. Metavariables can be transcribed more than "
"once or not at all."
msgstr "키워드 메타변수 `$crate`는 현재 크레이트를 참조하는 데 사용할 수 있습니다. 아래 [위생](#hygiene)을 참조하십시오. 메타변수는 두 번 이상 또는 전혀 트랜스크라이브되지 않을 수 있습니다."

#: src/macros-by-example.md:177
msgid ""
"**Edition differences**: Starting with the 2021 edition, `pat` fragment-"
"specifiers match top-level or-patterns (that is, they accept [_Pattern_]"
"(patterns.md))."
msgstr "**에디션 차이**: 2021 에디션부터 `pat` 조각 지정자는 최상위 또는 패턴과 일치합니다(즉, [_패턴_](patterns.md)을 허용합니다)."

#: src/macros-by-example.md:179
msgid ""
"Before the 2021 edition, they match exactly the same fragments as "
"`pat_param` (that is, they accept [_PatternNoTopAlt_](patterns.md))."
msgstr "2021 에디션 이전에는 `pat_param`과 정확히 동일한 조각과 일치합니다(즉, [_패턴상단대체없음_](patterns.md)을 허용합니다)."

#: src/macros-by-example.md:181
msgid ""
"The relevant edition is the one in effect for the `macro_rules!` definition."
msgstr "관련 에디션은 `macro_rules!` 정의에 적용되는 에디션입니다."

#: src/macros-by-example.md:185
msgid ""
"**Edition differences**: Before the 2024 edition, `expr` fragment specifiers "
"do not match [_UnderscoreExpression_](expressions/underscore-expr.md) or "
"[_ConstBlockExpression_](expressions/block-expr.md#const-blocks) at the top "
"level. They are allowed within subexpressions."
msgstr "**에디션 차이**: 2024 에디션 이전에는 `expr` 조각 지정자가 최상위 수준에서 [_밑줄표현식_](expressions/underscore-expr.md) 또는 [_상수블록표현식_](expressions/block-expr.md#const-blocks)과 일치하지 않습니다. 하위 표현식 내에서는 허용됩니다."

#: src/macros-by-example.md:187
msgid ""
"The `expr_2021` fragment specifier exists to maintain backwards "
"compatibility with editions before 2024."
msgstr "The `expr_2021` 조각 지정자는 2024 이전 에디션과의 하위 호환성을 유지하기 위해 존재합니다."

#: src/macros-by-example.md:191
msgid "Repetitions"
msgstr "반복"

#: src/macros-by-example.md:195
msgid ""
"In both the matcher and transcriber, repetitions are indicated by placing "
"the tokens to be repeated inside `$(`…`)`, followed by a repetition "
"operator, optionally with a separator token between."
msgstr "매처와 트랜스크라이버 모두에서 반복은 반복할 토큰을 `$(`…`)` 안에 넣고 반복 연산자를 뒤에 붙여 표시하며, 선택적으로 사이에 구분 기호 토큰을 넣을 수 있습니다."

#: src/macros-by-example.md:201
msgid ""
"The separator token can be any token other than a delimiter or one of the "
"repetition operators, but `;` and `,` are the most common. For instance, `$"
"( $i:ident ),*` represents any number of identifiers separated by commas. "
"Nested repetitions are permitted."
msgstr "구분 기호 토큰은 구분 기호나 반복 연산자 중 하나가 아닌 모든 토큰이 될 수 있지만 `;`와 `,`가 가장 일반적입니다. 예를 들어, `$( $i:ident ),*`는 쉼표로 구분된 임의의 수의 식별자를 나타냅니다. 중첩된 반복은 허용됩니다."

#: src/macros-by-example.md:208
msgid "The repetition operators are:"
msgstr "반복 연산자는 다음과 같습니다."

#: src/macros-by-example.md:210
msgid "`*` --- indicates any number of repetitions."
msgstr "`*` --- 임의의 횟수 반복을 나타냅니다."

#: src/macros-by-example.md:211
msgid "`+` --- indicates any number but at least one."
msgstr "`+` --- 임의의 횟수이지만 최소 한 번 이상을 나타냅니다."

#: src/macros-by-example.md:212
msgid "`?` --- indicates an optional fragment with zero or one occurrence."
msgstr "`?` --- 0 또는 1회 발생하는 선택적 조각을 나타냅니다."

#: src/macros-by-example.md:216
msgid ""
"Since `?` represents at most one occurrence, it cannot be used with a "
"separator."
msgstr "Since `?`는 최대 한 번 발생함을 나타내므로 구분 기호와 함께 사용할 수 없습니다."

#: src/macros-by-example.md:221
msgid ""
"The repeated fragment both matches and transcribes to the specified number "
"of the fragment, separated by the separator token. Metavariables are matched "
"to every repetition of their corresponding fragment. For instance, the `$"
"( $i:ident ),*` example above matches `$i` to all of the identifiers in the "
"list."
msgstr "반복되는 조각은 구분 기호 토큰으로 구분된 지정된 수의 조각과 일치하고 트랜스크라이브됩니다. 메타변수는 해당 조각의 모든 반복과 일치합니다. 예를 들어, 위의 `$( $i:ident ),*` 예제는 목록의 모든 식별자에 `$i`를 일치시킵니다."

#: src/macros-by-example.md:226
msgid ""
"During transcription, additional restrictions apply to repetitions so that "
"the compiler knows how to expand them properly:"
msgstr "트랜스크립션 중에는 컴파일러가 반복을 올바르게 확장하는 방법을 알 수 있도록 반복에 추가 제한 사항이 적용됩니다."

#: src/macros-by-example.md:229
msgid ""
"A metavariable must appear in exactly the same number, kind, and nesting "
"order of repetitions in the transcriber as it did in the matcher. So for the "
"matcher `$( $i:ident ),*`, the transcribers `=> { $i }`, `=> { $( $"
"( $i)* )* }`, and `=> { $( $i )+ }` are all illegal, but `=> { $( $i );* }` "
"is correct and replaces a comma-separated list of identifiers with a "
"semicolon-separated list."
msgstr "메타변수는 매처에서와 동일한 수, 종류 및 중첩 순서로 트랜스크라이버에 나타나야 합니다. 따라서 매처 `$( $i:ident ),*`의 경우 트랜스크라이버 `=> { $i }`, `=> { $( $( $i)* )* }` 및 `=> { $( $i )+ }`는 모두 불법이지만 `=> { $( $i );* }`는 올바르며 쉼표로 구분된 식별자 목록을 세미콜론으로 구분된 목록으로 바꿉니다."

#: src/macros-by-example.md:235
msgid ""
"Each repetition in the transcriber must contain at least one metavariable to "
"decide how many times to expand it. If multiple metavariables appear in the "
"same repetition, they must be bound to the same number of fragments. For "
"instance, `( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))` "
"must bind the same number of `$i` fragments as `$j` fragments. This means "
"that invoking the macro with `(a, b, c; d, e, f)` is legal and expands to "
"`((a,d), (b,e), (c,f))`, but `(a, b, c; d, e)` is illegal because it does "
"not have the same number. This requirement applies to every layer of nested "
"repetitions."
msgstr "트랜스크라이버의 각 반복에는 확장 횟수를 결정하기 위해 최소한 하나의 메타변수가 포함되어야 합니다. 동일한 반복에 여러 메타변수가 나타나면 동일한 수의 조각에 바인딩되어야 합니다. 예를 들어, `( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))`는 `$j` 조각과 동일한 수의 `$i` 조각을 바인딩해야 합니다. 즉, `(a, b, c; d, e, f)`로 매크로를 호출하는 것은 합법이며 `((a,d), (b,e), (c,f))`로 확장되지만, `(a, b, c; d, e)`는 동일한 수가 아니므로 불법입니다. 이 요구 사항은 중첩된 반복의 모든 계층에 적용됩니다."

#: src/macros-by-example.md:247
msgid "Scoping, Exporting, and Importing"
msgstr "스코핑, 내보내기 및 가져오기"

#: src/macros-by-example.md:251
msgid ""
"For historical reasons, the scoping of macros by example does not work "
"entirely like items. Macros have two forms of scope: textual scope, and path-"
"based scope. Textual scope is based on the order that things appear in "
"source files, or even across multiple files, and is the default scoping. It "
"is explained further below. Path-based scope works exactly the same way that "
"item scoping does. The scoping, exporting, and importing of macros is "
"controlled largely by attributes."
msgstr "역사적인 이유로 예제별 매크로의 범위 지정은 항목처럼 완전히 작동하지 않습니다. 매크로에는 텍스트 범위와 경로 기반 범위의 두 가지 범위 형식이 있습니다. 텍스트 범위는 소스 파일에 항목이 나타나는 순서 또는 여러 파일에 걸쳐 나타나는 순서를 기반으로 하며 기본 범위 지정입니다. 아래에서 자세히 설명합니다. 경로 기반 범위는 항목 범위 지정과 정확히 동일하게 작동합니다. 매크로의 범위 지정, 내보내기 및 가져오기는 주로 속성에 의해 제어됩니다."

#: src/macros-by-example.md:260
msgid ""
"When a macro is invoked by an unqualified identifier (not part of a multi-"
"part path), it is first looked up in textual scoping. If this does not yield "
"any results, then it is looked up in path-based scoping. If the macro's name "
"is qualified with a path, then it is only looked up in path-based scoping."
msgstr "매크로가 정규화되지 않은 식별자(다중 부분 경로의 일부가 아님)에 의해 호출되면 먼저 텍스트 범위에서 조회됩니다. 결과가 없으면 경로 기반 범위에서 조회됩니다. 매크로 이름이 경로로 정규화되면 경로 기반 범위에서만 조회됩니다."

#: src/macros-by-example.md:267
msgid "// Path-based import.\n"
msgstr "// 경로 기반 가져오기.\n"

#: src/macros-by-example.md:269
msgid "// Textual definition.\n"
msgstr "// 텍스트 정의.\n"

#: src/macros-by-example.md:273
msgid "// Textual lookup finds our macro first.\n"
msgstr "// 텍스트 조회는 먼저 우리 매크로를 찾습니다.\n"

#: src/macros-by-example.md:274
msgid "// Path-based lookup ignores our macro, finds imported one.\n"
msgstr "// 경로 기반 조회는 우리 매크로를 무시하고 가져온 매크로를 찾습니다.\n"

#: src/macros-by-example.md:279
msgid "Textual Scope"
msgstr "텍스트 범위"

#: src/macros-by-example.md:283
msgid ""
"Textual scope is based largely on the order that things appear in source "
"files, and works similarly to the scope of local variables declared with "
"`let` except it also applies at the module level. When `macro_rules!` is "
"used to define a macro, the macro enters the scope after the definition "
"(note that it can still be used recursively, since names are looked up from "
"the invocation site), up until its surrounding scope, typically a module, is "
"closed. This can enter child modules and even span across multiple files:"
msgstr "텍스트 범위는 주로 소스 파일에 항목이 나타나는 순서를 기반으로 하며 `let`으로 선언된 지역 변수의 범위와 유사하게 작동하지만 모듈 수준에서도 적용됩니다. `macro_rules!`를 사용하여 매크로를 정의하면 매크로는 정의 후 범위에 들어갑니다(이름은 호출 사이트에서 조회되므로 여전히 재귀적으로 사용할 수 있음). 일반적으로 모듈인 주변 범위가 닫힐 때까지입니다. 이것은 자식 모듈에 들어가거나 여러 파일에 걸쳐 있을 수도 있습니다."

#: src/macros-by-example.md:293
msgid "//// src/lib.rs\n"
msgstr "//// src/lib.rs\n"

#: src/macros-by-example.md:295 src/macros-by-example.md:304
msgid "// m!{} // Error: m is not in scope.\n"
msgstr "// m!{} // 오류: m이 범위에 없습니다.\n"

#: src/macros-by-example.md:300
msgid "// OK: appears after declaration of m.\n"
msgstr "// OK: m 선언 후에 나타납니다.\n"

#: src/macros-by-example.md:306
msgid "//// src/has_macro/uses_macro.rs\n"
msgstr "//// src/has_macro/uses_macro.rs\n"

#: src/macros-by-example.md:309
msgid "// OK: appears after declaration of m in src/lib.rs\n"
msgstr "// OK: src/lib.rs에서 m 선언 후에 나타납니다\n"

#: src/macros-by-example.md:314
msgid ""
"It is not an error to define a macro multiple times; the most recent "
"declaration will shadow the previous one unless it has gone out of scope."
msgstr "매크로를 여러 번 정의하는 것은 오류가 아닙니다. 가장 최근 선언은 범위를 벗어나지 않는 한 이전 선언을 가립니다."

#: src/macros-by-example.md:330
msgid "// m!(1); // Error: no rule matches '1'\n"
msgstr "// m!(1); // 오류: '1'과 일치하는 규칙이 없습니다\n"

#: src/macros-by-example.md:342
msgid ""
"Macros can be declared and used locally inside functions as well, and work "
"similarly:"
msgstr "매크로는 함수 내부에서도 로컬로 선언하고 사용할 수 있으며 유사하게 작동합니다."

#: src/macros-by-example.md:347 src/macros-by-example.md:353
msgid "// m!(); // Error: m is not in scope.\n"
msgstr "// m!(); // 오류: m이 범위에 없습니다.\n"

#: src/macros-by-example.md:359
msgid "The `macro_use` attribute"
msgstr "`macro_use` 속성"

#: src/macros-by-example.md:363
msgid ""
"The _`macro_use` attribute_ has two purposes. First, it can be used to make "
"a module's macro scope not end when the module is closed, by applying it to "
"a module:"
msgstr "The _`macro_use` 속성_은 두 가지 목적이 있습니다. 첫째, 모듈에 적용하여 모듈이 닫힐 때 모듈의 매크로 범위가 끝나지 않도록 하는 데 사용할 수 있습니다."

#: src/macros-by-example.md:380
msgid ""
"Second, it can be used to import macros from another crate, by attaching it "
"to an `extern crate` declaration appearing in the crate's root module. "
"Macros imported this way are imported into the [`macro_use` prelude](names/"
"preludes.md#macro_use-prelude), not textually, which means that they can be "
"shadowed by any other name. While macros imported by `#[macro_use]` can be "
"used before the import statement, in case of a conflict, the last macro "
"imported wins. Optionally, a list of macros to import can be specified using "
"the [_MetaListIdents_](attributes.md#meta-item-attribute-syntax) syntax; "
"this is not supported when `#[macro_use]` is applied to a module."
msgstr "둘째, 크레이트의 루트 모듈에 나타나는 `extern crate` 선언에 첨부하여 다른 크레이트에서 매크로를 가져오는 데 사용할 수 있습니다. 이런 식으로 가져온 매크로는 텍스트가 아닌 [`macro_use` 전주곡](names/preludes.md#macro_use-prelude)으로 가져오므로 다른 이름으로 가려질 수 있습니다. `#[macro_use]`로 가져온 매크로는 가져오기 문 앞에 사용할 수 있지만 충돌이 발생하면 마지막으로 가져온 매크로가 우선합니다. 선택적으로, [_MetaListIdents_](attributes.md#meta-item-attribute-syntax) 구문을 사용하여 가져올 매크로 목록을 지정할 수 있습니다. 이것은 `#[macro_use]`가 모듈에 적용될 때 지원되지 않습니다."

#: src/macros-by-example.md:391
msgid "// Or #[macro_use] to import all macros.\n"
msgstr "// 또는 #[macro_use]를 사용하여 모든 매크로를 가져옵니다.\n"

#: src/macros-by-example.md:394
msgid ""
"// self::lazy_static!{} // Error: lazy_static is not defined in `self`\n"
msgstr "// self::lazy_static!{} // 오류: `self`에 lazy_static이 정의되어 있지 않습니다\n"

#: src/macros-by-example.md:400
msgid ""
"Macros to be imported with `#[macro_use]` must be exported with "
"`#[macro_export]`, which is described below."
msgstr "`#[macro_use]`로 가져올 매크로는 아래에 설명된 `#[macro_export]`로 내보내야 합니다."

#: src/macros-by-example.md:405
msgid "Path-Based Scope"
msgstr "경로 기반 범위"

#: src/macros-by-example.md:409
msgid ""
"By default, a macro has no path-based scope. However, if it has the "
"`#[macro_export]` attribute, then it is declared in the crate root scope and "
"can be referred to normally as such:"
msgstr "기본적으로 매크로에는 경로 기반 범위가 없습니다. 그러나 `#[macro_export]` 속성이 있으면 크레이트 루트 범위에 선언되고 다음과 같이 정상적으로 참조할 수 있습니다."

#: src/macros-by-example.md:415
msgid "// OK: Path-based lookup finds m in the current module.\n"
msgstr "// OK: 경로 기반 조회는 현재 모듈에서 m을 찾습니다.\n"

#: src/macros-by-example.md:432
msgid ""
"Macros labeled with `#[macro_export]` are always `pub` and can be referred "
"to by other crates, either by path or by `#[macro_use]` as described above."
msgstr "`#[macro_export]`로 레이블이 지정된 매크로는 항상 `pub`이며 위에서 설명한 대로 경로 또는 `#[macro_use]`를 통해 다른 크레이트에서 참조할 수 있습니다."

#: src/macros-by-example.md:437
msgid "Hygiene"
msgstr "위생"

#: src/macros-by-example.md:441
msgid ""
"Macros by example have _mixed-site hygiene_. This means that [loop labels]"
"(expressions/loop-expr.md#loop-labels), [block labels](expressions/loop-"
"expr.md#labelled-block-expressions), and local variables are looked up at "
"the macro definition site while other symbols are looked up at the macro "
"invocation site. For example:"
msgstr ""
"매크로 바이 이그젬플은 _혼합-사이트 위생_을 가집니다. 이는 [루프 레이블]"
"(expressions/loop-expr.md#loop-labels), [블록 레이블](expressions/loop-"
"expr.md#labelled-block-expressions) 및 지역 변수는 매크로 정의 사이트에서 "
"조회되는 반면 다른 심볼은 매크로 호출 사이트에서 조회됨을 의미합니다. 예를 "
"들어:"

#: src/macros-by-example.md:446
msgid "\"this is never called\""
msgstr "\"이것은 절대 호출되지 않습니다\""

#: src/macros-by-example.md:451
msgid "// Uses `x` from the definition site.\n"
msgstr "// 정의 사이트의 `x`를 사용합니다.\n"

#: src/macros-by-example.md:452
msgid "// Uses `func` from the invocation site.\n"
msgstr "// 호출 사이트의 `func`를 사용합니다.\n"

#: src/macros-by-example.md:458
msgid "/* does not panic */"
msgstr "/* 패닉하지 않습니다 */"

#: src/macros-by-example.md:463
msgid ""
"Labels and local variables defined in macro expansion are not shared between "
"invocations, so this code doesn’t compile:"
msgstr "매크로 확장에서 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다."
"매크로 확장 시 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 "
"코드는 컴파일되지 않습니다:"

#: src/macros-by-example.md:481
msgid ""
"A special case is the `$crate` metavariable. It refers to the crate defining "
"the macro, and can be used at the start of the path to look up items or "
"macros which are not in scope at the invocation site."
msgstr ""
"특별한 경우는 `$crate` 메타변수입니다. 이것은 매크로를 정의하는 크레이트를 "
"참조하며, 호출 사이트에서 범위에 없는 아이템이나 매크로를 조회하기 위해 "
"경로의 시작 부분에서 사용될 수 있습니다."

#: src/macros-by-example.md:485
msgid "//// Definitions in the `helper_macro` crate.\n"
msgstr "//// `helper_macro` 크레이트의 정의.\n"

#: src/macros-by-example.md:488
msgid ""
"// () => { helper!() } // This might lead to an error due to 'helper' not "
"being in scope.\n"
msgstr "// () => { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.\n"
"// () => { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 "
"있습니다.\n"

#: src/macros-by-example.md:496
msgid ""
"//// Usage in another crate.\n"
"// Note that `helper_macro::helper` is not imported!\n"
msgstr "//// 다른 크레이트에서 사용.\n// `helper_macro::helper`는 가져오지 않았습니다!\n"
"//// 다른 크레이트에서 사용.\n"
"// `helper_macro::helper`는 임포트되지 않았습니다!\n"

#: src/macros-by-example.md:506
msgid ""
"Note that, because `$crate` refers to the current crate, it must be used "
"with a fully qualified module path when referring to non-macro items:"
msgstr "참고: `$crate`는 현재 크레이트를 참조하므로 매크로가 아닌 항목을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다."
"참고로, `$crate`는 현재 크레이트를 참조하므로, 매크로가 아닌 아이템을 "
"참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다:"

#: src/macros-by-example.md:522
msgid ""
"Additionally, even though `$crate` allows a macro to refer to items within "
"its own crate when expanding, its use has no effect on visibility. An item "
"or macro referred to must still be visible from the invocation site. In the "
"following example, any attempt to invoke `call_foo!()` from outside its "
"crate will fail because `foo()` is not public."
msgstr "또한 `$crate`를 사용하면 매크로가 확장될 때 자체 크레이트 내의 항목을 참조할 수 있지만 가시성에는 영향을 미치지 않습니다. 참조된 항목이나 매크로는 호출 사이트에서 계속 볼 수 있어야 합니다. 다음 예에서 `foo()`가 공개되지 않았기 때문에 크레이트 외부에서 `call_foo!()`를 호출하려는 모든 시도는 실패합니다."
"또한, `$crate`를 사용하면 매크로가 확장될 때 자신의 크레이트 내의 "
"아이템을 참조할 수 있지만, 가시성에는 영향을 미치지 않습니다. 참조된 "
"아이템이나 매크로는 호출 사이트에서 여전히 보여야 합니다. 다음 예제에서, "
"`foo()`가 공개되지 않았기 때문에 크레이트 외부에서 `call_foo!()`를 "
"호출하려는 모든 시도는 실패합니다."

#: src/macros-by-example.md:537
msgid ""
"**Version & Edition differences**: Prior to Rust 1.30, `$crate` and "
"`local_inner_macros` (below) were unsupported. They were added alongside "
"path-based imports of macros (described above), to ensure that helper macros "
"did not need to be manually imported by users of a macro-exporting crate. "
"Crates written for earlier versions of Rust that use helper macros need to "
"be modified to use `$crate` or `local_inner_macros` to work well with path-"
"based imports."
msgstr "**버전 및 에디션 차이**: Rust 1.30 이전에는 `$crate` 및 `local_inner_macros`(아래)가 지원되지 않았습니다. 매크로 내보내기 크레이트 사용자가 도우미 매크로를 수동으로 가져올 필요가 없도록 경로 기반 매크로 가져오기(위에 설명됨)와 함께 추가되었습니다. 도우미 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 가져오기와 잘 작동하도록 `$crate` 또는 `local_inner_macros`를 사용하도록 수정해야 합니다."
"**버전 및 에디션 차이**: Rust 1.30 이전에는 `$crate` 및 "
"`local_inner_macros`(아래)가 지원되지 않았습니다. 이것들은 매크로를 "
"내보내는 크레이트의 사용자가 헬퍼 매크로를 수동으로 임포트할 필요가 없도록 "
"하기 위해 (위에서 설명한) 경로 기반 매크로 임포트와 함께 추가되었습니다. "
"헬퍼 매크로를 사용하는 이전 버전의 Rust용으로 작성된 크레이트는 경로 기반 "
"임포트와 잘 작동하도록 `$crate` 또는 `local_inner_macros`를 사용하도록 "
"수정해야 합니다."

#: src/macros-by-example.md:547
msgid ""
"When a macro is exported, the `#[macro_export]` attribute can have the "
"`local_inner_macros` keyword added to automatically prefix all contained "
"macro invocations with `$crate::`. This is intended primarily as a tool to "
"migrate code written before `$crate` was added to the language to work with "
"Rust 2018's path-based imports of macros. Its use is discouraged in new code."
msgstr "매크로를 내보낼 때 `#[macro_export]` 속성에 `local_inner_macros` 키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 `$crate::` 접두사를 붙일 수 있습니다. 이것은 주로 `$crate`가 언어에 추가되기 전에 작성된 코드를 Rust 2018의 경로 기반 매크로 가져오기와 함께 작동하도록 마이그레이션하는 도구로 사용됩니다. 새 코드에서는 사용을 권장하지 않습니다."
"매크로가 내보내질 때, `#[macro_export]` 속성에 `local_inner_macros` "
"키워드를 추가하여 포함된 모든 매크로 호출에 자동으로 `$crate::` 접두사를 "
"붙일 수 있습니다. 이것은 주로 `$crate`가 언어에 추가되기 전에 작성된 "
"코드를 Rust 2018의 경로 기반 매크로 임포트와 함께 작동하도록 "
"마이그레이션하기 위한 도구로 의도되었습니다. 새 코드에서는 사용을 권장하지 "
"않습니다."

#: src/macros-by-example.md:556
msgid "// Automatically converted to $crate::helper!().\n"
msgstr "// 자동으로 $crate::helper!()로 변환됩니다.\n"

#: src/macros-by-example.md:567
msgid "Follow-set Ambiguity Restrictions"
msgstr "후속 집합 모호성 제한"

#: src/macros-by-example.md:571
msgid ""
"The parser used by the macro system is reasonably powerful, but it is "
"limited in order to prevent ambiguity in current or future versions of the "
"language."
msgstr "매크로 시스템에서 사용하는 파서는 상당히 강력하지만 현재 또는 미래 버전의 언어에서 모호성을 방지하기 위해 제한됩니다."
"매크로 시스템에서 사용하는 파서는 상당히 강력하지만, 현재 또는 미래 버전의 "
"언어에서 모호성을 방지하기 위해 제한됩니다."

#: src/macros-by-example.md:576
msgid ""
"In particular, in addition to the rule about ambiguous expansions, a "
"nonterminal matched by a metavariable must be followed by a token which has "
"been decided can be safely used after that kind of match."
msgstr "특히, 모호한 확장에 대한 규칙 외에도 메타변수와 일치하는 비단말은 해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 합니다."
"특히, 모호한 확장에 대한 규칙 외에도, 메타변수에 의해 일치된 비단말은 "
"해당 종류의 일치 후에 안전하게 사용할 수 있다고 결정된 토큰이 뒤따라야 "
"합니다."

#: src/macros-by-example.md:580
msgid ""
"As an example, a macro matcher like `$i:expr [ , ]` could in theory be "
"accepted in Rust today, since `[,]` cannot be part of a legal expression and "
"therefore the parse would always be unambiguous. However, because `[` can "
"start trailing expressions, `[` is not a character which can safely be ruled "
"out as coming after an expression. If `[,]` were accepted in a later version "
"of Rust, this matcher would become ambiguous or would misparse, breaking "
"working code. Matchers like `$i:expr,` or `$i:expr;` would be legal, "
"however, because `,` and `;` are legal expression separators. The specific "
"rules are:"
msgstr "예를 들어, `$i:expr [ , ]`와 같은 매크로 매처는 `[,]`가 합법적인 표현식의 일부가 될 수 없으므로 구문 분석이 항상 명확하기 때문에 오늘날 Rust에서 이론적으로 허용될 수 있습니다. 그러나 `[`는 후행 표현식을 시작할 수 있으므로 `[`는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 나중에 Rust 버전에서 `[,]`가 허용되면 이 매처는 모호해지거나 잘못 구문 분석되어 작동하는 코드를 손상시킬 수 있습니다. 그러나 `,`와 `;`는 합법적인 표현식 구분 기호이므로 `$i:expr,` 또는 `$i:expr;`와 같은 매처는 합법적입니다. 구체적인 규칙은 다음과 같습니다."
"예를 들어, `$i:expr [ , ]`와 같은 매크로 매처는 오늘날 Rust에서 "
"이론적으로 받아들여질 수 있습니다. 왜냐하면 `[,]`는 합법적인 표현식의 "
"일부가 될 수 없으므로 파싱이 항상 명확하기 때문입니다. 그러나 `[`는 후행 "
"표현식을 시작할 수 있기 때문에, `[`는 표현식 뒤에 오는 것으로 안전하게 "
"배제할 수 있는 문자가 아닙니다. 만약 `[,]`가 이후 버전의 Rust에서 "
"허용된다면, 이 매처는 모호해지거나 잘못 파싱되어 작동하는 코드를 깨뜨릴 "
"것입니다. 그러나 `,`와 `;`는 합법적인 표현식 구분자이므로 `$i:expr,` "
"또는 `$i:expr;`와 같은 매처는 합법적일 것입니다. 구체적인 규칙은 다음과 "
"같습니다:"

#: src/macros-by-example.md:591
msgid "`expr` and `stmt` may only be followed by one of: `=>`, `,`, or `;`."
msgstr "`expr`과 `stmt`는 `=>`, `,`, 또는 `;` 중 하나만 뒤에 올 수 있습니다."

#: src/macros-by-example.md:595
msgid ""
"`pat_param` may only be followed by one of: `=>`, `,`, `=`, `|`, `if`, or "
"`in`."
msgstr "`pat_param`은 `=>`, `,`, `=`, `|`, `if` 또는 `in` 중 하나만 뒤따를 수 있습니다."
"`pat_param`은 `=>`, `,`, `=`, `|`, `if`, 또는 `in` 중 하나만 뒤에 올 수 "
"있습니다."

#: src/macros-by-example.md:599
msgid "`pat` may only be followed by one of: `=>`, `,`, `=`, `if`, or `in`."
msgstr "`pat`은 `=>`, `,`, `=`, `if`, 또는 `in` 중 하나만 뒤에 올 수 있습니다."

#: src/macros-by-example.md:603
msgid ""
"`path` and `ty` may only be followed by one of: `=>`, `,`, `=`, `|`, `;`, "
"`:`, `>`, `>>`, `[`, `{`, `as`, `where`, or a macro variable of `block` "
"fragment specifier."
msgstr "`path`와 `ty`는 `=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where` 또는 `block` 조각 지정자의 매크로 변수 중 하나만 뒤따를 수 있습니다."
"`path`와 `ty`는 `=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, "
"`where` 또는 `block` 프래그먼트 지정자의 매크로 변수 중 하나만 뒤에 올 수 "
"있습니다."

#: src/macros-by-example.md:609
msgid ""
"`vis` may only be followed by one of: `,`, an identifier other than a non-"
"raw `priv`, any token that can begin a type, or a metavariable with a "
"`ident`, `ty`, or `path` fragment specifier."
msgstr "`vis`는 `,`, 비-원시 `priv`가 아닌 식별자, 유형을 시작할 수 있는 모든 토큰 또는 `ident`, `ty` 또는 `path` 조각 지정자가 있는 메타변수 중 하나만 뒤따를 수 있습니다."
"`vis`는 `,`, 비-원시 `priv`가 아닌 식별자, 타입을 시작할 수 있는 모든 "
"토큰, 또는 `ident`, `ty`, 또는 `path` 프래그먼트 지정자를 가진 메타변수 중 "
"하나만 뒤에 올 수 있습니다."

#: src/macros-by-example.md:615
msgid "All other fragment specifiers have no restrictions."
msgstr "다른 모든 조각 지정자에는 제한이 없습니다."

#: src/macros-by-example.md:619
msgid ""
"**Edition differences**: Before the 2021 edition, `pat` may also be followed "
"by `|`."
msgstr "**에디션 차이**: 2021 에디션 이전에는 `pat` 뒤에 `|`가 올 수도 있습니다."
"**에디션 차이**: 2021 에디션 이전에는 `pat` 뒤에 `|`가 올 수도 있습니다."

#: src/macros-by-example.md:623
msgid ""
"When repetitions are involved, then the rules apply to every possible number "
"of expansions, taking separators into account. This means:"
msgstr "반복이 포함된 경우 규칙은 구분 기호를 고려하여 가능한 모든 확장 수에 적용됩니다. 이는 다음을 의미합니다."
"반복이 포함된 경우, 구분 기호를 고려하여 가능한 모든 확장 수에 규칙이 "
"적용됩니다. 이는 다음을 의미합니다:"

#: src/macros-by-example.md:626
msgid ""
"If the repetition includes a separator, that separator must be able to "
"follow the contents of the repetition."
msgstr "반복에 구분 기호가 포함된 경우, 해당 구분 기호는 반복의 내용을 따를 수 있어야 합니다."

#: src/macros-by-example.md:628
msgid ""
"If the repetition can repeat multiple times (`*` or `+`), then the contents "
"must be able to follow themselves."
msgstr "반복이 여러 번 반복될 수 있는 경우(`*` 또는 `+`), 내용은 스스로를 따를 수 있어야 합니다."

#: src/macros-by-example.md:630
msgid ""
"The contents of the repetition must be able to follow whatever comes before, "
"and whatever comes after must be able to follow the contents of the "
"repetition."
msgstr "반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다."
"반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 "
"것은 반복의 내용을 따를 수 있어야 합니다."

#: src/macros-by-example.md:633
msgid ""
"If the repetition can match zero times (`*` or `?`), then whatever comes "
"after must be able to follow whatever comes before."
msgstr "반복이 0번 일치할 수 있는 경우(`*` 또는 `?`), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다."
"반복이 0번 일치할 수 있는 경우(`*` 또는 `?`), 뒤에 오는 모든 것은 이전에 "
"오는 모든 것을 따를 수 있어야 합니다."

#: src/macros-by-example.md:636
msgid "For more detail, see the [formal specification](macro-ambiguity.md)."
msgstr "자세한 내용은 [공식 사양](macro-ambiguity.md)을 참조하십시오."

#: src/procedural-macros.md:7
msgid ""
"_Procedural macros_ allow creating syntax extensions as execution of a "
"function. Procedural macros come in one of three flavors:"
msgstr ""
"_절차적 매크로_는 함수의 실행으로 구문 확장을 생성할 수 있습니다. 절차적 "
"매크로는 세 가지 종류 중 하나입니다:"

#: src/procedural-macros.md:10
msgid ""
"[Function-like macros](#function-like-procedural-macros) - `custom!(...)`"
msgstr "[함수형 매크로](#function-like-procedural-macros) - `custom!(...)`"

#: src/procedural-macros.md:11
msgid "[Derive macros](#derive-macros) - `#[derive(CustomDerive)]`"
msgstr "[파생 매크로](#derive-macros) - `#[derive(CustomDerive)]`"

#: src/procedural-macros.md:12
msgid "[Attribute macros](#attribute-macros) - `#[CustomAttribute]`"
msgstr "[속성 매크로](#attribute-macros) - `#[CustomAttribute]`"

#: src/procedural-macros.md:14
msgid ""
"Procedural macros allow you to run code at compile time that operates over "
"Rust syntax, both consuming and producing Rust syntax. You can sort of think "
"of procedural macros as functions from an AST to another AST."
msgstr ""
"절차적 매크로를 사용하면 컴파일 타임에 Rust 구문을 사용하고 생성하는 "
"코드를 실행할 수 있습니다. 절차적 매크로를 AST에서 다른 AST로의 함수로 "
"생각할 수 있습니다."

#: src/procedural-macros.md:20
msgid ""
"Procedural macros must be defined in the root of a crate with the [crate "
"type](linkage.md) of `proc-macro`. The macros may not be used from the crate "
"where they are defined, and can only be used when imported in another crate."
msgstr ""
"절차적 매크로는 `proc-macro`의 [크레이트 타입](linkage.md)을 가진 "
"크레이트의 루트에 정의되어야 합니다. 매크로는 정의된 크레이트에서 사용할 "
"수 없으며, 다른 크레이트에서 임포트될 때만 사용할 수 있습니다."

#: src/procedural-macros.md:24
msgid ""
"**Note**: When using Cargo, Procedural macro crates are defined with the "
"`proc-macro` key in your manifest:"
msgstr ""
"**참고**: Cargo를 사용할 때, 절차적 매크로 크레이트는 매니페스트에서 "
"`proc-macro` 키로 정의됩니다:"

#: src/procedural-macros.md:34
msgid ""
"As functions, they must either return syntax, panic, or loop endlessly. "
"Returned syntax either replaces or adds the syntax depending on the kind of "
"procedural macro. Panics are caught by the compiler and are turned into a "
"compiler error. Endless loops are not caught by the compiler which hangs the "
"compiler."
msgstr ""
"함수로서, 그들은 구문을 반환하거나, 패닉하거나, 또는 무한정 반복해야 "
"합니다. 반환된 구문은 절차적 매크로의 종류에 따라 구문을 대체하거나 "
"추가합니다. 패닉은 컴파일러에 의해 잡혀 컴파일러 오류로 바뀝니다. 무한 "
"루프는 컴파일러에 의해 잡히지 않아 컴파일러를 멈추게 합니다."

#: src/procedural-macros.md:39
msgid ""
"Procedural macros run during compilation, and thus have the same resources "
"that the compiler has. For example, standard input, error, and output are "
"the same that the compiler has access to. Similarly, file access is the "
"same. Because of this, procedural macros have the same security concerns "
"that [Cargo's build scripts](../cargo/reference/build-scripts.html) have."
msgstr ""
"절차적 매크로는 컴파일 중에 실행되므로 컴파일러와 동일한 리소스를 "
"갖습니다. 예를 들어, 표준 입력, 오류 및 출력은 컴파일러가 액세스할 수 "
"있는 것과 동일합니다. 마찬가지로 파일 액세스도 동일합니다. 이 때문에 "
"절차적 매크로는 [Cargo의 빌드 스크립트](../cargo/reference/build-scripts.html)와 "
"동일한 보안 문제를 가지고 있습니다."

#: src/procedural-macros.md:47
msgid ""
"Procedural macros have two ways of reporting errors. The first is to panic. "
"The second is to emit a [`compile_error`](../core/macro.compile_error.html) "
"macro invocation."
msgstr ""
"절차적 매크로는 오류를 보고하는 두 가지 방법이 있습니다. 첫 번째는 "
"패닉하는 것입니다. 두 번째는 [`compile_error`](../core/macro.compile_error.html) "
"매크로 호출을 내보내는 것입니다."

#: src/procedural-macros.md:52
msgid "The `proc_macro` crate"
msgstr "proc_macro 크레이트"

#: src/procedural-macros.md:56
msgid ""
"Procedural macro crates almost always will link to the compiler-provided "
"[`proc_macro` crate](../proc_macro/index.html). The `proc_macro` crate "
"provides types required for writing procedural macros and facilities to make "
"it easier."
msgstr ""
"절차적 매크로 크레이트는 거의 항상 컴파일러에서 제공하는 [`proc_macro` "
"크레이트](../proc_macro/index.html)에 링크됩니다. `proc_macro` 크레이트는 "
"절차적 매크로를 작성하는 데 필요한 유형과 이를 더 쉽게 만드는 기능을 "
"제공합니다."

#: src/procedural-macros.md:62
msgid ""
"This crate primarily contains a [`TokenStream`](../proc_macro/"
"struct.TokenStream.html) type. Procedural macros operate over _token "
"streams_ instead of AST nodes, which is a far more stable interface over "
"time for both the compiler and for procedural macros to target. A _token "
"stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can "
"roughly be thought of as lexical token. For example `foo` is an `Ident` "
"token, `.` is a `Punct` token, and `1.2` is a `Literal` token. The "
"`TokenStream` type, unlike `Vec<TokenTree>`, is cheap to clone."
msgstr ""
"이 크레이트는 주로 [`TokenStream`](../proc_macro/struct.TokenStream.html) "
"타입을 포함합니다. 절차적 매크로는 AST 노드 대신 _토큰 스트림_을 통해 "
"작동하며, 이는 컴파일러와 절차적 매크로 모두에게 시간이 지나도 훨씬 더 "
"안정적인 인터페이스입니다. _토큰 스트림_은 대략 `Vec<TokenTree>`와 "
"동일하며, 여기서 `TokenTree`는 어휘 토큰으로 생각할 수 있습니다. 예를 들어 "
"`foo`는 `Ident` 토큰이고, `.`는 `Punct` 토큰이며, `1.2`는 `Literal` "
"토큰입니다. `TokenStream` 타입은 `Vec<TokenTree>`와 달리 복제 비용이 "
"저렴합니다."

#: src/procedural-macros.md:72
msgid ""
"All tokens have an associated `Span`. A `Span` is an opaque value that "
"cannot be modified but can be manufactured. `Span`s represent an extent of "
"source code within a program and are primarily used for error reporting. "
"While you cannot modify a `Span` itself, you can always change the `Span` "
"_associated_ with any token, such as through getting a `Span` from another "
"token."
msgstr ""
"모든 토큰에는 연관된 `Span`이 있습니다. `Span`은 수정할 수 없지만 제조할 "
"수 있는 불투명한 값입니다. `Span`은 프로그램 내 소스 코드의 범위를 "
"나타내며 주로 오류 보고에 사용됩니다. `Span` 자체를 수정할 수는 없지만, "
"다른 토큰에서 `Span`을 가져오는 것과 같이 모든 토큰과 _연관된_ `Span`은 "
"언제든지 변경할 수 있습니다."

#: src/procedural-macros.md:80
msgid "Procedural macro hygiene"
msgstr "절차적 매크로 위생"

#: src/procedural-macros.md:83
msgid ""
"Procedural macros are _unhygienic_. This means they behave as if the output "
"token stream was simply written inline to the code it's next to. This means "
"that it's affected by external items and also affects external imports."
msgstr ""
"절차적 매크로는 _비위생적_입니다. 이는 출력 토큰 스트림이 바로 옆 코드에 "
"인라인으로 작성된 것처럼 동작함을 의미합니다. 이는 외부 항목의 영향을 "
"받고 외부 임포트에도 영향을 미친다는 것을 의미합니다."

#: src/procedural-macros.md:87
msgid ""
"Macro authors need to be careful to ensure their macros work in as many "
"contexts as possible given this limitation. This often includes using "
"absolute paths to items in libraries (for example, `::std::option::Option` "
"instead of `Option`) or by ensuring that generated functions have names that "
"are unlikely to clash with other functions (like `__internal_foo` instead of "
"`foo`)."
msgstr ""
"매크로 작성자는 이 제한 사항을 감안할 때 가능한 한 많은 컨텍스트에서 "
"매크로가 작동하도록 주의해야 합니다. 여기에는 종종 라이브러리의 아이템에 "
"대한 절대 경로를 사용하거나(예: `Option` 대신 `::std::option::Option`) "
"생성된 함수가 다른 함수와 충돌할 가능성이 없는 이름을 갖도록 하는 것(예: "
"`foo` 대신 `__internal_foo`)이 포함됩니다."

#: src/procedural-macros.md:95
msgid "Function-like procedural macros"
msgstr "함수형 절차적 매크로"

#: src/procedural-macros.md:99
msgid ""
"_Function-like procedural macros_ are procedural macros that are invoked "
"using the macro invocation operator (`!`)."
msgstr ""
"_함수형 절차적 매크로_는 매크로 호출 연산자(`!`)를 사용하여 호출되는 "
"절차적 매크로입니다."

#: src/procedural-macros.md:104
msgid ""
"These macros are defined by a [public](visibility-and-privacy.md) [function]"
"(items/functions.md) with the `proc_macro` [attribute](attributes.md) and a "
"signature of `(TokenStream) -> TokenStream`. The input [`TokenStream`](../"
"proc_macro/struct.TokenStream.html) is what is inside the delimiters of the "
"macro invocation and the output [`TokenStream`](../proc_macro/"
"struct.TokenStream.html) replaces the entire macro invocation."
msgstr ""
"이 매크로는 `proc_macro` [속성](attributes.md)과 `(TokenStream) -> "
"TokenStream` 시그니처를 가진 [공개](visibility-and-privacy.md) "
"[함수](items/functions.md)에 의해 정의됩니다. 입력 [`TokenStream`](../"
"proc_macro/struct.TokenStream.html)은 매크로 호출의 구분 기호 안에 있는 "
"것이고 출력 [`TokenStream`](../proc_macro/struct.TokenStream.html)은 전체 "
"매크로 호출을 대체합니다."

#: src/procedural-macros.md:111
msgid ""
"The `proc_macro` attribute defines the macro in the [macro namespace](names/"
"namespaces.md) in the root of the crate."
msgstr ""
"`proc_macro` 속성은 크레이트의 루트에 있는 [매크로 "
"네임스페이스](names/namespaces.md)에 매크로를 정의합니다."

#: src/procedural-macros.md:113
msgid ""
"For example, the following macro definition ignores its input and outputs a "
"function `answer` into its scope."
msgstr ""
"예를 들어, 다음 매크로 정의는 입력을 무시하고 `answer` 함수를 해당 "
"범위로 출력합니다."

#: src/procedural-macros.md:118 src/procedural-macros.md:180
#: src/procedural-macros.md:227 src/procedural-macros.md:277
msgid "\"proc-macro\""
msgstr "\"proc-macro\""

#: src/procedural-macros.md:124 src/procedural-macros.md:186
msgid "\"fn answer() -> u32 { 42 }\""
msgstr "\"fn answer() -> u32 { 42 }\""

#: src/procedural-macros.md:128
msgid ""
"And then we use it in a binary crate to print \"42\" to standard output."
msgstr ""
"그런 다음 바이너리 크레이트에서 이를 사용하여 표준 출력으로 \"42\"를 출력합니다."

#: src/procedural-macros.md:138 src/items/unions.md:167
#: src/items/generics.md:108 src/attributes/codegen.md:457
#: src/attributes/codegen.md:474 src/attributes/codegen.md:487
#: src/attributes/codegen.md:491 src/attributes/codegen.md:506
#: src/attributes/codegen.md:510 src/attributes/codegen.md:515
#: src/expressions/loop-expr.md:164 src/expressions/range-expr.md:75
#: src/patterns.md:125 src/patterns.md:663 src/patterns.md:688
#: src/patterns.md:718 src/types/closure.md:17 src/types/closure.md:317
#: src/types/trait-object.md:104 src/type-layout.md:721 src/destructors.md:39
#: src/destructors.md:366 src/names/scopes.md:286 src/names/scopes.md:288
#: src/runtime.md:56
msgid "\"{}\""
msgstr "\"{}\""

#: src/procedural-macros.md:144
msgid ""
"Function-like procedural macros may be invoked in any macro invocation "
"position, which includes [statements](statements.md), [expressions]"
"(expressions.md), [patterns](patterns.md), [type expressions](types.md#type-"
"expressions), [item](items.md) positions, including items in [`extern` "
"blocks](items/external-blocks.md), inherent and trait [implementations]"
"(items/implementations.md), and [trait definitions](items/traits.md)."
msgstr ""
"함수형 절차적 매크로는 [문](statements.md), [표현식](expressions.md), "
"[패턴](patterns.md), [타입 표현식](types.md#type-expressions), [`extern` "
"블록](items/external-blocks.md)의 아이템, 고유 및 트레잇 "
"[구현](items/implementations.md), 그리고 [트레잇 정의](items/traits.md)를 "
"포함한 [아이템](items.md) 위치 등 모든 매크로 호출 위치에서 호출될 수 "
"있습니다."

#: src/procedural-macros.md:151
msgid "Derive macros"
msgstr "파생 매크로"

#: src/procedural-macros.md:155
msgid ""
"_Derive macros_ define new inputs for the [`derive` attribute](attributes/"
"derive.md). These macros can create new [items](items.md) given the token "
"stream of a [struct](items/structs.md), [enum](items/enumerations.md), or "
"[union](items/unions.md). They can also define [derive macro helper "
"attributes](#derive-macro-helper-attributes)."
msgstr ""
"_파생 매크로_는 [`derive` 속성](attributes/derive.md)에 대한 새로운 "
"입력을 정의합니다. 이 매크로는 [구조체](items/structs.md), "
"[열거형](items/enumerations.md), 또는 [공용체](items/unions.md)의 토큰 "
"스트림이 주어지면 새로운 [아이템](items.md)을 생성할 수 있습니다. 또한 "
"[파생 매크로 헬퍼 속성](#derive-macro-helper-attributes)을 정의할 수도 "
"있습니다."

#: src/procedural-macros.md:161
msgid ""
"Custom derive macros are defined by a [public](visibility-and-privacy.md) "
"[function](items/functions.md) with the `proc_macro_derive` attribute and a "
"signature of `(TokenStream) -> TokenStream`."
msgstr ""
"사용자 정의 파생 매크로는 `proc_macro_derive` 속성과 `(TokenStream) -> "
"TokenStream` 시그니처를 가진 [공개](visibility-and-privacy.md) "
"[함수](items/functions.md)에 의해 정의됩니다."

#: src/procedural-macros.md:166
msgid ""
"The `proc_macro_derive` attribute defines the custom derive in the [macro "
"namespace](names/namespaces.md) in the root of the crate."
msgstr ""
"`proc_macro_derive` 속성은 크레이트의 루트에 있는 [매크로 "
"네임스페이스](names/namespaces.md)에 사용자 정의 파생을 정의합니다."

#: src/procedural-macros.md:170
msgid ""
"The input [`TokenStream`](../proc_macro/struct.TokenStream.html) is the "
"token stream of the item that has the `derive` attribute on it. The output "
"[`TokenStream`](../proc_macro/struct.TokenStream.html) must be a set of "
"items that are then appended to the [module](items/modules.md) or [block]"
"(expressions/block-expr.md) that the item from the input [`TokenStream`](../"
"proc_macro/struct.TokenStream.html) is in."
msgstr ""
"입력 [`TokenStream`](../proc_macro/struct.TokenStream.html)은 `derive` "
"속성을 가진 아이템의 토큰 스트림입니다. 출력 [`TokenStream`](../"
"proc_macro/struct.TokenStream.html)은 입력 [`TokenStream`](../proc_macro/"
"struct.TokenStream.html)의 아이템이 있는 [모듈](items/modules.md) 또는 "
"[블록](expressions/block-expr.md)에 추가되는 아이템 집합이어야 합니다."

#: src/procedural-macros.md:175
msgid ""
"The following is an example of a derive macro. Instead of doing anything "
"useful with its input, it just appends a function `answer`."
msgstr ""
"다음은 파생 매크로의 예입니다. 입력으로 유용한 작업을 수행하는 대신 "
"`answer` 함수를 추가하기만 합니다."

#: src/procedural-macros.md:190
msgid "And then using said derive macro:"
msgstr "그리고 나서 해당 파생 매크로를 사용합니다:"

#: src/procedural-macros.md:207 src/names/scopes.md:341
msgid "Derive macro helper attributes"
msgstr "파생 매크로 헬퍼 속성"

#: src/procedural-macros.md:211
msgid ""
"Derive macros can add additional [attributes](attributes.md) into the scope "
"of the [item](items.md) they are on. Said attributes are called _derive "
"macro helper attributes_. These attributes are [inert](attributes.md#active-"
"and-inert-attributes), and their only purpose is to be fed into the derive "
"macro that defined them. That said, they can be seen by all macros."
msgstr ""
"파생 매크로는 자신이 있는 [아이템](items.md)의 범위에 추가적인 "
"[속성](attributes.md)을 추가할 수 있습니다. 해당 속성은 _파생 매크로 "
"헬퍼 속성_이라고 합니다. 이러한 속성은 [비활성](attributes.md#active-"
"and-inert-attributes)이며, 유일한 목적은 자신을 정의한 파생 매크로에 "
"제공되는 것입니다. 즉, 모든 매크로에서 볼 수 있습니다."

#: src/procedural-macros.md:218
msgid ""
"The way to define helper attributes is to put an `attributes` key in the "
"`proc_macro_derive` macro with a comma separated list of identifiers that "
"are the names of the helper attributes."
msgstr ""
"헬퍼 속성을 정의하는 방법은 `proc_macro_derive` 매크로에 `attributes` "
"키를 넣고 헬퍼 속성의 이름인 식별자의 쉼표로 구분된 목록을 사용하는 "
"것입니다."

#: src/procedural-macros.md:222
msgid ""
"For example, the following derive macro defines a helper attribute `helper`, "
"but ultimately doesn't do anything with it."
msgstr ""
"예를 들어, 다음 파생 매크로는 헬퍼 속성 `helper`를 정의하지만, "
"궁극적으로는 아무것도 하지 않습니다."

#: src/procedural-macros.md:237
msgid "And then usage on the derive macro on a struct:"
msgstr "그리고 나서 구조체에서 파생 매크로를 사용합니다:"

#: src/procedural-macros.md:249
msgid "Attribute macros"
msgstr "속성 매크로"

#: src/procedural-macros.md:253
msgid ""
"_Attribute macros_ define new [outer attributes](attributes.md) which can be "
"attached to [items](items.md), including items in [`extern` blocks](items/"
"external-blocks.md), inherent and trait [implementations](items/"
"implementations.md), and [trait definitions](items/traits.md)."
msgstr ""
"_속성 매크로_는 [`extern` 블록](items/external-blocks.md)의 아이템, 고유 "
"및 트레잇 [구현](items/implementations.md), 그리고 [트레잇 "
"정의](items/traits.md)를 포함한 [아이템](items.md)에 첨부될 수 있는 새로운 "
"[외부 속성](attributes.md)을 정의합니다."

#: src/procedural-macros.md:259
msgid ""
"Attribute macros are defined by a [public](visibility-and-privacy.md) "
"[function](items/functions.md) with the `proc_macro_attribute` [attribute]"
"(attributes.md) that has a signature of `(TokenStream, TokenStream) -> "
"TokenStream`. The first [`TokenStream`](../proc_macro/"
"struct.TokenStream.html) is the delimited token tree following the "
"attribute's name, not including the outer delimiters. If the attribute is "
"written as a bare attribute name, the attribute [`TokenStream`](../"
"proc_macro/struct.TokenStream.html) is empty. The second [`TokenStream`](../"
"proc_macro/struct.TokenStream.html) is the rest of the [item](items.md) "
"including other [attributes](attributes.md) on the [item](items.md). The "
"returned [`TokenStream`](../proc_macro/struct.TokenStream.html) replaces the "
"[item](items.md) with an arbitrary number of [items](items.md)."
msgstr ""
"속성 매크로는 `(TokenStream, TokenStream) -> TokenStream` 시그니처를 가진 "
"`proc_macro_attribute` [속성](attributes.md)을 가진 "
"[공개](visibility-and-privacy.md) [함수](items/functions.md)에 의해 "
"정의됩니다. 첫 번째 [`TokenStream`](../proc_macro/struct.TokenStream.html)은 "
"속성 이름을 따르는 구분된 토큰 트리이며, 외부 구분 기호는 포함하지 "
"않습니다. 속성이 단순한 속성 이름으로 작성된 경우, 속성 [`TokenStream`](../"
"proc_macro/struct.TokenStream.html)은 비어 있습니다. 두 번째 "
"[`TokenStream`](../proc_macro/struct.TokenStream.html)은 [아이템](items.md)의 "
"다른 [속성](attributes.md)을 포함한 [아이템](items.md)의 나머지 부분입니다. "
"반환된 [`TokenStream`](../proc_macro/struct.TokenStream.html)은 "
"[아이템](items.md)을 임의의 수의 [아이템](items.md)으로 대체합니다."

#: src/procedural-macros.md:270
msgid ""
"The `proc_macro_attribute` attribute defines the attribute in the [macro "
"namespace](names/namespaces.md) in the root of the crate."
msgstr ""
"`proc_macro_attribute` 속성은 크레이트의 루트에 있는 [매크로 "
"네임스페이스](names/namespaces.md)에 속성을 정의합니다."

#: src/procedural-macros.md:272
msgid ""
"For example, this attribute macro takes the input stream and returns it as "
"is, effectively being the no-op of attributes."
msgstr ""
"예를 들어, 이 속성 매크로는 입력 스트림을 받아서 그대로 반환하므로, "
"사실상 속성의 no-op입니다."

#: src/procedural-macros.md:287
msgid ""
"This following example shows the stringified [`TokenStream`s](../proc_macro/"
"struct.TokenStream.html) that the attribute macros see. The output will show "
"in the output of the compiler. The output is shown in the comments after the "
"function prefixed with \"out:\"."
msgstr ""
"다음 예제는 속성 매크로가 보는 문자열화된 [`TokenStream`s](../proc_macro/"
"struct.TokenStream.html)을 보여줍니다. 출력은 컴파일러의 출력에 "
"표시됩니다. 출력은 \\\"out:\\\" 접두사가 붙은 함수 뒤의 주석에 표시됩니다."

#: src/procedural-macros.md:293
msgid "// my-macro/src/lib.rs\n"
msgstr "// my-macro/src/lib.rs\n"

#: src/procedural-macros.md:299
msgid "\"attr: \\\"{attr}\\\"\""
msgstr "\"attr: \\\"{attr}\\\"\""

#: src/procedural-macros.md:300
msgid "\"item: \\\"{item}\\\"\""
msgstr "\"item: \\\"{item}\\\"\""

#: src/procedural-macros.md:307
msgid "// src/lib.rs\n"
msgstr "// src/lib.rs\n"

#: src/procedural-macros.md:311
msgid "// Example: Basic function\n"
msgstr "// 예: 기본 함수\n"

#: src/procedural-macros.md:314
msgid ""
"// out: attr: \"\"\n"
"// out: item: \"fn invoke1() {}\"\n"
msgstr ""
"// out: attr: \"\"\n"
"// out: item: \"fn invoke1() {}\"\n"

#: src/procedural-macros.md:317
msgid "// Example: Attribute with input\n"
msgstr "// 예: 입력이 있는 속성\n"

#: src/procedural-macros.md:320
msgid ""
"// out: attr: \"bar\"\n"
"// out: item: \"fn invoke2() {}\"\n"
msgstr ""
"// out: attr: \"bar\"\n"
"// out: item: \"fn invoke2() {}\"\n"

#: src/procedural-macros.md:323
msgid "// Example: Multiple tokens in the input\n"
msgstr "// 예: 입력에 여러 토큰이 있는 경우\n"

#: src/procedural-macros.md:326
msgid ""
"// out: attr: \"multiple => tokens\"\n"
"// out: item: \"fn invoke3() {}\"\n"
msgstr ""
"// out: attr: \"multiple => tokens\"\n"
"// out: item: \"fn invoke3() {}\"\n"

#: src/procedural-macros.md:329
msgid "// Example:\n"
msgstr "// 예:\n"

#: src/procedural-macros.md:332
msgid ""
"// out: attr: \"delimiters\"\n"
"// out: item: \"fn invoke4() {}\"\n"
msgstr ""
"// out: attr: \"delimiters\"\n"
"// out: item: \"fn invoke4() {}\"\n"

#: src/procedural-macros.md:339
msgid "Declarative macro tokens and procedural macro tokens"
msgstr "선언적 매크로 토큰과 절차적 매크로 토큰"

#: src/procedural-macros.md:343
msgid ""
"Declarative `macro_rules` macros and procedural macros use similar, but "
"different definitions for tokens (or rather [`TokenTree`s](../proc_macro/"
"enum.TokenTree.html).)"
msgstr ""
"선언적 `macro_rules` 매크로와 절차적 매크로는 토큰(또는 [`TokenTree`s](../"
"proc_macro/enum.TokenTree.html))에 대해 비슷하지만 다른 정의를 사용합니다."

#: src/procedural-macros.md:348
msgid ""
"Token trees in `macro_rules` (corresponding to `tt` matchers) are defined as"
msgstr "`macro_rules`의 토큰 트리(`tt` 매처에 해당)는 다음과 같이 정의됩니다."

#: src/procedural-macros.md:349 src/procedural-macros.md:366
msgid "Delimited groups (`(...)`, `{...}`, etc)"
msgstr "구분된 그룹 (`(...)`, `{...}` 등)"

#: src/procedural-macros.md:350
msgid ""
"All operators supported by the language, both single-character and multi-"
"character ones (`+`, `+=`)."
msgstr "언어에서 지원하는 모든 연산자, 단일 문자 및 다중 문자 연산자 모두 포함(`+`, `+=`)."

#: src/procedural-macros.md:352
msgid "Note that this set doesn't include the single quote `'`."
msgstr "이 집합에는 작은따옴표 `'`가 포함되지 않음에 유의하세요."

#: src/procedural-macros.md:353 src/procedural-macros.md:370
msgid "Literals (`\"string\"`, `1`, etc)"
msgstr "리터럴 (`\"string\"`, `1` 등)"

#: src/procedural-macros.md:354
msgid ""
"Note that negation (e.g. `-1`) is never a part of such literal tokens, but a "
"separate operator token."
msgstr "부정(예: `-1`)은 절대 리터럴 토큰의 일부가 아니며, 별도의 연산자 토큰임에 유의하세요."

#: src/procedural-macros.md:356 src/procedural-macros.md:373
msgid "Identifiers, including keywords (`ident`, `r#ident`, `fn`)"
msgstr "키워드를 포함한 식별자 (`ident`, `r#ident`, `fn`)"

#: src/procedural-macros.md:357
msgid "Lifetimes (`'ident`)"
msgstr "라이프타임 (`'ident`)"

#: src/procedural-macros.md:358
msgid ""
"Metavariable substitutions in `macro_rules` (e.g. `$my_expr` in "
"`macro_rules! mac { ($my_expr: expr) => { $my_expr } }` after the `mac`'s "
"expansion, which will be considered a single token tree regardless of the "
"passed expression)"
msgstr ""
"`macro_rules`의 메타변수 치환 (예: `mac`의 확장 후 `macro_rules! mac { ($my_expr: "
"expr) => { $my_expr } }`에서의 `$my_expr`. 전달된 표현식과 관계없이 단일 토큰 트리로 "
"간주됨)"

#: src/procedural-macros.md:365
msgid "Token trees in procedural macros are defined as"
msgstr "절차적 매크로에서 토큰 트리는 다음과 같이 정의됩니다"

#: src/procedural-macros.md:367
msgid ""
"All punctuation characters used in operators supported by the language (`+`, "
"but not `+=`), and also the single quote `'` character (typically used in "
"lifetimes, see below for lifetime splitting and joining behavior)"
msgstr ""
"언어에서 지원하는 연산자에 사용되는 모든 구두점 문자(`+`, 단 `+=`는 아님) 및 작은따옴표 `'` "
"문자(주로 라이프타임에 사용됨. 라이프타임 분리 및 결합 동작은 아래 참조)"

#: src/procedural-macros.md:371
msgid ""
"Negation (e.g. `-1`) is supported as a part of integer and floating point "
"literals."
msgstr "부정(예: `-1`)은 정수 및 부동 소수점 리터럴의 일부로 지원됩니다."

#: src/procedural-macros.md:377
msgid ""
"Mismatches between these two definitions are accounted for when token "
"streams are passed to and from procedural macros.   \n"
"Note that the conversions below may happen lazily, so they might not happen "
"if the tokens are not actually inspected."
msgstr ""
"이 두 정의 간의 불일치는 토큰 스트림이 절차적 매크로로 전달되거나 반환될 때 고려됩니다.   \n"
"아래의 변환은 지연되어 발생할 수 있으므로, 토큰이 실제로 검사되지 않으면 발생하지 않을 수 있음에 유의하세요."

#: src/procedural-macros.md:384
msgid "When passed to a proc-macro"
msgstr "절차적 매크로로 전달될 때"

#: src/procedural-macros.md:385
msgid "All multi-character operators are broken into single characters."
msgstr "모든 다중 문자 연산자는 단일 문자로 분리됩니다."

#: src/procedural-macros.md:386
msgid "Lifetimes are broken into a `'` character and an identifier."
msgstr "라이프타임은 `'` 문자와 식별자로 분리됩니다."

#: src/procedural-macros.md:387
msgid ""
"All metavariable substitutions are represented as their underlying token "
"streams."
msgstr "모든 메타변수 치환은 기본 토큰 스트림으로 표현됩니다."

#: src/procedural-macros.md:389
msgid ""
"Such token streams may be wrapped into delimited groups ([`Group`](../"
"proc_macro/struct.Group.html)) with implicit delimiters ([`Delimiter::None`]"
"(../proc_macro/enum.Delimiter.html#variant.None)) when it's necessary for "
"preserving parsing priorities."
msgstr ""
"이러한 토큰 스트림은 파싱 우선순위를 보존하기 위해 필요한 경우 암시적 구분자([`Delimiter::None`]"
"(../proc_macro/enum.Delimiter.html#variant.None))를 가진 구분된 그룹([`Group`](../"
"proc_macro/struct.Group.html))으로 래핑될 수 있습니다."

#: src/procedural-macros.md:392
msgid ""
"`tt` and `ident` substitutions are never wrapped into such groups and always "
"represented as their underlying token trees."
msgstr ""
"`tt` 및 `ident` 치환은 절대 이러한 그룹으로 래핑되지 않으며 항상 기본 토큰 트리로 "
"표현됩니다."

#: src/procedural-macros.md:397
msgid "When emitted from a proc macro"
msgstr "절차적 매크로에서 방출될 때"

#: src/procedural-macros.md:398
msgid ""
"Punctuation characters are glued into multi-character operators when "
"applicable."
msgstr "구두점 문자는 가능한 경우 다중 문자 연산자로 결합됩니다."

#: src/procedural-macros.md:400
msgid "Single quotes `'` joined with identifiers are glued into lifetimes."
msgstr "식별자와 결합된 작은따옴표 `'`는 라이프타임으로 결합됩니다."

#: src/procedural-macros.md:401
msgid ""
"Negative literals are converted into two tokens (the `-` and the literal) "
"possibly wrapped into a delimited group ([`Group`](../proc_macro/"
"struct.Group.html)) with implicit delimiters ([`Delimiter::None`](../"
"proc_macro/enum.Delimiter.html#variant.None)) when it's necessary for "
"preserving parsing priorities."
msgstr ""
"음수 리터럴은 두 개의 토큰(`-`와 리터럴)으로 변환되며, 파싱 우선순위를 보존하기 위해 필요한 경우 "
"암시적 구분자([`Delimiter::None`](../proc_macro/enum.Delimiter.html#variant.None))를 "
"가진 구분된 그룹([`Group`](../proc_macro/struct.Group.html))으로 래핑될 수 있습니다."

#: src/procedural-macros.md:407
msgid ""
"Note that neither declarative nor procedural macros support doc comment "
"tokens (e.g. `/// Doc`), so they are always converted to token streams "
"representing their equivalent `#[doc = r\"str\"]` attributes when passed to "
"macros."
msgstr ""
"선언적 매크로와 절차적 매크로 모두 문서 주석 토큰(예: `/// Doc`)을 지원하지 않으므로, "
"매크로로 전달될 때는 항상 이에 상응하는 `#[doc = r\"str\"]` 속성을 나타내는 토큰 스트림으로 "
"변환된다는 점에 유의하세요."

#: src/crates-and-source-files.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Crate_ :  \n"
"   [_InnerAttribute_](attributes.md)<sup>\\*</sup>  \n"
"   [_Item_](items.md)<sup>\\*</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_크레이트_ :  \n"
"   [_내부속성_](attributes.md)<sup>\\*</sup>  \n"
"   [_아이템_](items.md)<sup>\\*</sup>"

#: src/crates-and-source-files.md:12
msgid ""
"Note: Although Rust, like any other language, can be implemented by an "
"interpreter as well as a compiler, the only existing implementation is a "
"compiler, and the language has always been designed to be compiled. For "
"these reasons, this section assumes a compiler."
msgstr ""
"참고: 러스트는 다른 언어들과 마찬가지로 컴파일러뿐만 아니라 인터프리터로도 "
"구현될 수 있지만, 현재 존재하는 유일한 구현은 컴파일러이며, 이 언어는 "
"항상 컴파일되도록 설계되었습니다. 이러한 이유로 이 섹션에서는 "
"컴파일러를 가정합니다."

#: src/crates-and-source-files.md:19
msgid ""
"Rust's semantics obey a _phase distinction_ between compile-time and run-"
"time.[^phase-distinction] Semantic rules that have a _static interpretation_ "
"govern the success or failure of compilation, while semantic rules that have "
"a _dynamic interpretation_ govern the behavior of the program at run-time."
msgstr ""
"러스트의 시맨틱은 컴파일 타임과 런타임 사이의 _단계 구분_을 따릅니다.[^phase-distinction] "
"_정적 해석_을 갖는 시맨틱 규칙은 컴파일의 성공 여부를 결정하며, "
"_동적 해석_을 갖는 시맨틱 규칙은 런타임에서의 프로그램 동작을 "
"결정합니다."

#: src/crates-and-source-files.md:27
msgid ""
"The compilation model centers on artifacts called _crates_. Each compilation "
"processes a single crate in source form, and if successful, produces a "
"single crate in binary form: either an executable or some sort of library."
"[^cratesourcefile]"
msgstr ""
"컴파일 모델은 _크레이트_라고 불리는 결과물을 중심으로 합니다. 각 컴파일 "
"과정은 소스 형태의 단일 크레이트를 처리하며, 성공하면 실행 파일이나 "
"라이브러리 형태의 단일 바이너리 크레이트를 생성합니다.[^cratesourcefile]"

#: src/crates-and-source-files.md:34
msgid ""
"A _crate_ is a unit of compilation and linking, as well as versioning, "
"distribution, and runtime loading. A crate contains a _tree_ of nested "
"[module](items/modules.md) scopes. The top level of this tree is a module "
"that is anonymous (from the point of view of paths within the module) and "
"any item within a crate has a canonical [module path](paths.md) denoting its "
"location within the crate's module tree."
msgstr ""
"_크레이트_는 컴파일과 링크의 단위일 뿐만 아니라 버전 관리, 배포 및 "
"런타임 로딩의 단위이기도 합니다. 크레이트는 중첩된 [모듈](items/modules.md) "
"스코프의 _트리_를 포함합니다. 이 트리의 최상위 레벨은 (모듈 내 경로의 "
"관점에서 볼 때) 익명 모듈이며, 크레이트 내의 모든 아이템은 크레이트의 "
"모듈 트리 내 위치를 나타내는 정규 [모듈 경로](paths.md)를 가집니다."

#: src/crates-and-source-files.md:43
msgid ""
"The Rust compiler is always invoked with a single source file as input, and "
"always produces a single output crate. The processing of that source file "
"may result in other source files being loaded as modules. Source files have "
"the extension `.rs`."
msgstr ""
"러스트 컴파일러는 항상 단일 소스 파일을 입력으로 호출되며, 항상 단일 "
"출력 크레이트를 생성합니다. 해당 소스 파일을 처리하는 과정에서 다른 소스 "
"파일이 모듈로 로드될 수 있습니다. 소스 파일의 확장자는 `.rs`입니다."

#: src/crates-and-source-files.md:50
msgid ""
"A Rust source file describes a module, the name and location of which — in "
"the module tree of the current crate — are defined from outside the source "
"file: either by an explicit [_Module_](items/modules.md) item in a "
"referencing source file, or by the name of the crate itself."
msgstr ""
"러스트 소스 파일은 모듈을 설명하며, 현재 크레이트의 모듈 트리 내에서의 "
"이름과 위치는 소스 파일 외부에서 정의됩니다. 이는 참조하는 소스 파일 "
"내의 명시적인 [_모듈_](items/modules.md) 아이템에 의하거나 크레이트 "
"자체의 이름에 의해 결정됩니다."

#: src/crates-and-source-files.md:57
msgid ""
"Every source file is a module, but not every module needs its own source "
"file: [module definitions](items/modules.md) can be nested within one file."
msgstr ""
"모든 소스 파일은 모듈이지만, 모든 모듈이 별도의 소스 파일을 가질 필요는 "
"없습니다. [모듈 정의](items/modules.md)는 하나의 파일 내에 중첩될 수 "
"있습니다."

#: src/crates-and-source-files.md:63
msgid ""
"Each source file contains a sequence of zero or more [_Item_](items.md) "
"definitions, and may optionally begin with any number of [attributes]"
"(attributes.md) that apply to the containing module, most of which influence "
"the behavior of the compiler."
msgstr ""
"각 소스 파일은 0개 이상의 [_아이템_](items.md) 정의 시퀀스를 포함하며, "
"선택적으로 해당 모듈에 적용되는 임의의 개수의 [속성](attributes.md)으로 "
"시작할 수 있습니다. 대부분의 속성은 컴파일러의 동작에 영향을 미칩니다."

#: src/crates-and-source-files.md:70
msgid ""
"The anonymous crate module can have additional attributes that apply to the "
"crate as a whole."
msgstr ""
"익명 크레이트 모듈은 크레이트 전체에 적용되는 추가 속성을 가질 수 "
"있습니다."

#: src/crates-and-source-files.md:73
msgid ""
"**Note**: The file's contents may be preceded by a [shebang](input-"
"format.md#shebang-removal)."
msgstr ""
"**참고**: 파일 내용 앞에 [쉬뱅](input-format.md#shebang-removal)이 올 수 "
"있습니다."

#: src/crates-and-source-files.md:76
msgid "// Specify the crate name.\n"
msgstr "// 크레이트 이름을 지정합니다.\n"

#: src/crates-and-source-files.md:77
msgid "\"projx\""
msgstr "\"projx\""

#: src/crates-and-source-files.md:78
msgid "// Specify the type of output artifact.\n"
msgstr "// 출력 아티팩트의 타입을 지정합니다.\n"

#: src/crates-and-source-files.md:80 src/attributes.md:115
msgid "\"lib\""
msgstr "\"lib\""

#: src/crates-and-source-files.md:81
msgid ""
"// Turn on a warning.\n"
"// This can be done in any module, not just the anonymous crate module.\n"
msgstr ""
"// 경고를 활성화합니다.\n"
"// 이 작업은 익명 크레이트 모듈뿐만 아니라 모든 모듈에서 수행할 수 "
"있습니다.\n"

#: src/crates-and-source-files.md:89
msgid "Main Functions"
msgstr "메인 함수"

#: src/crates-and-source-files.md:93
msgid ""
"A crate that contains a `main` [function](items/functions.md) can be "
"compiled to an executable."
msgstr ""
"`main` [함수](items/functions.md)를 포함하는 크레이트는 실행 파일로 "
"컴파일될 수 있습니다."

#: src/crates-and-source-files.md:97
msgid ""
"If a `main` function is present, it must take no arguments, must not declare "
"any [trait or lifetime bounds](trait-bounds.md), must not have any [where "
"clauses](items/generics.md#where-clauses), and its return type must "
"implement the [`Termination`](../std/process/trait.Termination.html) trait."
msgstr ""
"`main` 함수가 존재하는 경우, 인자를 받지 않아야 하며, 어떠한 "
"[트레잇 또는 라이프타임 바운드](trait-bounds.md)도 선언하지 않아야 하고, "
"[where 절](items/generics.md#where-clauses)을 가져서는 안 되며, 반환 "
"타입은 [`Termination`](../std/process/trait.Termination.html) 트레잇을 "
"구현해야 합니다."

#: src/crates-and-source-files.md:117
msgid ""
"The `main` function may be an import, e.g. from an external crate or from "
"the current one."
msgstr ""
"`main` 함수는 외부 크레이트나 현재 크레이트로부터 임포트된 것일 수 "
"있습니다."

#: src/crates-and-source-files.md:122
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/crates-and-source-files.md:128
msgid ""
"**Note**: Types with implementations of [`Termination`](../std/process/"
"trait.Termination.html) in the standard library include:"
msgstr ""
"**참고**: 표준 라이브러리에서 [`Termination`](../std/process/"
"trait.Termination.html) 구현을 가진 타입은 다음과 같습니다:"

#: src/crates-and-source-files.md:130 src/attributes/testing.md:27
#: src/expressions/tuple-expr.md:49
msgid "`()`"
msgstr "`()`"

#: src/crates-and-source-files.md:131
msgid "[`!`](types/never.md)"
msgstr "[`!`](types/never.md)"

#: src/crates-and-source-files.md:132
msgid "[`Infallible`](../core/convert/enum.Infallible.html)"
msgstr "[`Infallible`](../core/convert/enum.Infallible.html)"

#: src/crates-and-source-files.md:133
msgid "[`ExitCode`](../std/process/struct.ExitCode.html)"
msgstr "[`ExitCode`](../std/process/struct.ExitCode.html)"

#: src/crates-and-source-files.md:134 src/attributes/testing.md:28
msgid "`Result<T, E> where T: Termination, E: Debug`"
msgstr "`Result<T, E> where T: Termination, E: Debug`"

#: src/crates-and-source-files.md:141
msgid "The `no_main` attribute"
msgstr "`no_main` 속성"

#: src/crates-and-source-files.md:144
msgid ""
"The _`no_main` [attribute](attributes.md)_ may be applied at the crate level "
"to disable emitting the `main` symbol for an executable binary. This is "
"useful when some other object being linked to defines `main`."
msgstr "The _`no_main` [속성](attributes.md)_은 실행 가능한 바이너리에 대해 `main` 기호 내보내기를 비활성화하기 위해 크레이트 수준에서 적용될 수 있습니다. 이것은 연결되는 다른 일부 개체가 `main`을 정의할 때 유용합니다."

#: src/crates-and-source-files.md:150
msgid "The `crate_name` attribute"
msgstr "`crate_name` 속성"

#: src/crates-and-source-files.md:154
msgid ""
"The _`crate_name` [attribute](attributes.md)_ may be applied at the crate "
"level to specify the name of the crate with the [_MetaNameValueStr_]"
"(attributes.md#meta-item-attribute-syntax) syntax."
msgstr "The _`crate_name` [속성](attributes.md)_은 [_MetaNameValueStr_](attributes.md#meta-item-attribute-syntax) 구문을 사용하여 크레이트의 이름을 지정하기 위해 크레이트 수준에서 적용될 수 있습니다."

#: src/crates-and-source-files.md:158
msgid "\"mycrate\""
msgstr "\"mycrate\""

#: src/crates-and-source-files.md:163
msgid ""
"The crate name must not be empty, and must only contain [Unicode "
"alphanumeric](../std/primitive.char.html#method.is_alphanumeric) or `_` "
"(U+005F) characters."
msgstr "크레이트 이름은 비어 있으면 안 되며, [유니코드 영숫자](../std/primitive.char.html#method.is_alphanumeric) 또는 `_` (U+005F) 문자만 포함해야 합니다."

#: src/crates-and-source-files.md:166
msgid ""
"This distinction would also exist in an interpreter. Static checks like "
"syntactic analysis, type checking, and lints should happen before the "
"program is executed regardless of when it is executed."
msgstr "이러한 구별은 인터프리터에도 존재합니다. 구문 분석, 유형 검사 및 린트와 같은 정적 검사는 프로그램이 실행되는 시점과 관계없이 프로그램이 실행되기 전에 수행되어야 합니다."

#: src/crates-and-source-files.md:170
msgid ""
"A crate is somewhat analogous to an _assembly_ in the ECMA-335 CLI model, a "
"_library_ in the SML/NJ Compilation Manager, a _unit_ in the Owens and Flatt "
"module system, or a _configuration_ in Mesa."
msgstr "크레이트는 ECMA-335 CLI 모델의 _어셈블리_, SML/NJ 컴파일 관리자의 _라이브러리_, Owens 및 Flatt 모듈 시스템의 _단위_ 또는 Mesa의 _구성_과 다소 유사합니다."

#: src/conditional-compilation.md:7
msgstr ""
"**<sup>구문</sup>**  \n"
"_구성조건자_ :  \n"
"      _구성옵션_  \n"
"   | _구성모두_  \n"
"   | _구성하나라도_  \n"
"   | _구성아님_"

#: src/conditional-compilation.md:14
msgstr ""
"_구성옵션_ :  \n"
"   [식별자](identifiers.md) (`=` ([문자열_리터럴](tokens.md#string-"
"literals) | [원시_문자열_리터럴](tokens.md#raw-string-literals)))<sup>?</sup>"

#: src/conditional-compilation.md:17
msgstr ""
"_구성모두_  \n"
"   `all` `(` _구성조건자목록_<sup>?</sup> `)`"

#: src/conditional-compilation.md:20
msgstr ""
"_구성하나라도_  \n"
"   `any` `(` _구성조건자목록_<sup>?</sup> `)`"

#: src/conditional-compilation.md:23
msgstr ""
"_구성아님_  \n"
"   `not` `(` _구성조건자_ `)`"

#: src/conditional-compilation.md:26
msgstr ""
"_구성조건자목록_  \n"
"   _구성조건자_ (`,` _구성조건자_)<sup>\\*</sup> "
"`,`<sup>?</sup>"

#: src/conditional-compilation.md:31
msgid ""
"_Conditionally compiled source code_ is source code that is compiled only "
"under certain conditions."
msgstr "_조건부로 컴파일된 소스 코드_는 특정 조건에서만 컴파일되는 소스 코드입니다."

#: src/conditional-compilation.md:35
msgid ""
"Source code can be made conditionally compiled using the [`cfg`](#the-cfg-"
"attribute) and [`cfg_attr`](#the-cfg_attr-attribute) [attributes]"
"(attributes.md) and the built-in [`cfg` macro](#the-cfg-macro)."
msgstr "소스 코드는 [`cfg`](#the-cfg-attribute) 및 [`cfg_attr`](#the-cfg_attr-attribute) [속성](attributes.md)과 내장된 [`cfg` 매크로](#the-cfg-macro)를 사용하여 조건부로 컴파일할 수 있습니다."

#: src/conditional-compilation.md:39
msgid ""
"Whether to compile can depend on the target architecture of the compiled "
"crate, arbitrary values passed to the compiler, and other things further "
"described below."
msgstr "컴파일 여부는 컴파일된 크레이트의 대상 아키텍처, 컴파일러에 전달된 임의의 값 및 아래에 자세히 설명된 기타 사항에 따라 달라질 수 있습니다."

#: src/conditional-compilation.md:43
msgid ""
"Each form of conditional compilation takes a _configuration predicate_ that "
"evaluates to true or false. The predicate is one of the following:"
msgstr "각 형태의 조건부 컴파일은 참 또는 거짓으로 평가되는 _구성 술어_를 사용합니다. 술어는 다음 중 하나입니다."

#: src/conditional-compilation.md:48
msgid ""
"A configuration option. The predicate is true if the option is set, and "
"false if it is unset."
msgstr "구성 옵션. 옵션이 설정되면 술어는 참이고 설정되지 않으면 거짓입니다."

#: src/conditional-compilation.md:52
msgid ""
"`all()` with a comma-separated list of configuration predicates. It is true "
"if all of the given predicates are true, or if the list is empty."
msgstr "`all()`은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 모든 술어가 참이거나 목록이 비어 있으면 참입니다."

#: src/conditional-compilation.md:56
msgid ""
"`any()` with a comma-separated list of configuration predicates. It is true "
"if at least one of the given predicates is true. If there are no predicates, "
"it is false."
msgstr "`any()`은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 술어 중 하나 이상이 참이면 참입니다. 술어가 없으면 거짓입니다."

#: src/conditional-compilation.md:60
msgid ""
"`not()` with a configuration predicate. It is true if its predicate is false "
"and false if its predicate is true."
msgstr "`not()`은 구성 술어와 함께 사용됩니다. 술어가 거짓이면 참이고 술어가 참이면 거짓입니다."

#: src/conditional-compilation.md:64
msgid ""
"_Configuration options_ are either names or key-value pairs, and are either "
"set or unset."
msgstr "_구성 옵션_은 이름 또는 키-값 쌍이며 설정되거나 설정되지 않습니다."

#: src/conditional-compilation.md:68
msgid "Names are written as a single identifier, such as `unix`."
msgstr "이름은 `unix`와 같이 단일 식별자로 작성됩니다."

#: src/conditional-compilation.md:72
msgid ""
"Key-value pairs are written as an identifier, `=`, and then a string, such "
"as `target_arch = \"x86_64\"`."
msgstr "키-값 쌍은 식별자, `=`, 그리고 문자열로 작성됩니다(예: `target_arch = \"x86_64\"`)."

#: src/conditional-compilation.md:74
msgid ""
"**Note**: Whitespace around the `=` is ignored, so `foo=\"bar\"` and `foo = "
"\"bar\"` are equivalent."
msgstr "**참고**: `=` 주변의 공백은 무시되므로 `foo=\"bar\"`와 `foo = \"bar\"`는 동일합니다."

#: src/conditional-compilation.md:78
msgid ""
"Keys do not need to be unique. For example, both `feature = \"std\"` and "
"`feature = \"serde\"` can be set at the same time."
msgstr "키는 고유할 필요가 없습니다. 예를 들어, `feature = \"std\"`와 `feature = \"serde\"`를 동시에 설정할 수 있습니다."

#: src/conditional-compilation.md:82
msgid "Set Configuration Options"
msgstr "구성 옵션 설정"

#: src/conditional-compilation.md:86
msgid ""
"Which configuration options are set is determined statically during the "
"compilation of the crate."
msgstr "어떤 구성 옵션이 설정되는지는 크레이트 컴파일 중에 정적으로 결정됩니다."

#: src/conditional-compilation.md:91
msgid "Some options are _compiler-set_ based on data about the compilation."
msgstr "일부 옵션은 컴파일에 대한 데이터를 기반으로 _컴파일러 설정_됩니다."

#: src/conditional-compilation.md:95
msgid ""
"Other options are _arbitrarily-set_ based on input passed to the compiler "
"outside of the code."
msgstr "다른 옵션은 코드 외부에서 컴파일러에 전달된 입력을 기반으로 _임의로 설정_됩니다."

#: src/conditional-compilation.md:99
msgid ""
"It is not possible to set a configuration option from within the source code "
"of the crate being compiled."
msgstr "컴파일 중인 크레이트의 소스 코드 내에서 구성 옵션을 설정할 수 없습니다."

#: src/conditional-compilation.md:102
msgid ""
"**Note**: For `rustc`, arbitrary-set configuration options are set using the "
"[`--cfg`](../rustc/command-line-arguments.html#--cfg-configure-the-"
"compilation-environment) flag. Configuration values for a specified target "
"can be displayed with `rustc --print cfg --target $TARGET`."
msgstr "**참고**: `rustc`의 경우, 임의로 설정된 구성 옵션은 [`--cfg`](../rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment) 플래그를 사용하여 설정됩니다. 지정된 대상에 대한 구성 값은 `rustc --print cfg --target $TARGET`으로 표시할 수 있습니다."

#: src/conditional-compilation.md:105
msgid ""
"**Note**: Configuration options with the key `feature` are a convention used "
"by [Cargo](../cargo/reference/features.html) for specifying compile-time "
"options and optional dependencies."
msgstr "**참고**: `feature` 키가 있는 구성 옵션은 컴파일 시간 옵션 및 선택적 종속성을 지정하기 위해 [Cargo](../cargo/reference/features.html)에서 사용하는 규칙입니다."

#: src/conditional-compilation.md:111
msgid ""
"_**Warning:**_ Arbitrarily-set configuration options can clash with compiler-"
"set configuration options. For example, it is possible to do `rustc --cfg "
"\"unix\" program.rs` while compiling to a Windows target, and have both "
"`unix` and `windows` configuration options set at the same time. Doing this "
"would be unwise."
msgstr "_**경고:**_ 임의로 설정된 구성 옵션은 컴파일러 설정 구성 옵션과 충돌할 수 있습니다. 예를 들어, Windows 대상으로 컴파일하는 동안 `rustc --cfg \"unix\" program.rs`를 수행하고 `unix`와 `windows` 구성 옵션을 동시에 설정할 수 있습니다. 이렇게 하는 것은 현명하지 않습니다."

#: src/conditional-compilation.md:119
msgid "`target_arch`"
msgstr "`target_arch`"

#: src/conditional-compilation.md:123
msgid ""
"Key-value option set once with the target's CPU architecture. The value is "
"similar to the first element of the platform's target triple, but not "
"identical."
msgstr "키-값 옵션은 대상의 CPU 아키텍처로 한 번 설정됩니다. 값은 플랫폼의 대상 트리플의 첫 번째 요소와 유사하지만 동일하지는 않습니다."

#: src/conditional-compilation.md:129 src/conditional-compilation.md:150
#: src/conditional-compilation.md:179 src/conditional-compilation.md:204
#: src/conditional-compilation.md:237 src/conditional-compilation.md:262
#: src/conditional-compilation.md:288 src/conditional-compilation.md:304
#: src/conditional-compilation.md:373
msgid "Example values:"
msgstr "예제 값:"

#: src/conditional-compilation.md:131
msgid "`\"x86\"`"
msgstr "`\"x86\"`"

#: src/conditional-compilation.md:132
msgid "`\"x86_64\"`"
msgstr "`\"x86_64\"`"

#: src/conditional-compilation.md:133
msgid "`\"mips\"`"
msgstr "`\"mips\"`"

#: src/conditional-compilation.md:134
msgid "`\"powerpc\"`"
msgstr "`\"powerpc\"`"

#: src/conditional-compilation.md:135
msgid "`\"powerpc64\"`"
msgstr "`\"powerpc64\"`"

#: src/conditional-compilation.md:136
msgid "`\"arm\"`"
msgstr "`\"arm\"`"

#: src/conditional-compilation.md:137
msgid "`\"aarch64\"`"
msgstr "`\"aarch64\"`"

#: src/conditional-compilation.md:141
msgid "`target_feature`"
msgstr "`target_feature`"

#: src/conditional-compilation.md:145
msgid ""
"Key-value option set for each platform feature available for the current "
"compilation target."
msgstr "현재 컴파일 대상에 사용할 수 있는 각 플랫폼 기능에 대해 설정된 키-값 옵션입니다."

#: src/conditional-compilation.md:152
msgid "`\"avx\"`"
msgstr "`\"avx\"`"

#: src/conditional-compilation.md:153
msgid "`\"avx2\"`"
msgstr "`\"avx2\"`"

#: src/conditional-compilation.md:154
msgid "`\"crt-static\"`"
msgstr "`\"crt-static\"`"

#: src/conditional-compilation.md:155
msgid "`\"rdrand\"`"
msgstr "`\"rdrand\"`"

#: src/conditional-compilation.md:156
msgid "`\"sse\"`"
msgstr "`\"sse\"`"

#: src/conditional-compilation.md:157
msgid "`\"sse2\"`"
msgstr "`\"sse2\"`"

#: src/conditional-compilation.md:158
msgid "`\"sse4.1\"`"
msgstr "`\"sse4.1\"`"

#: src/conditional-compilation.md:160
msgid ""
"See the [`target_feature` attribute](attributes/codegen.md#the-"
"target_feature-attribute) for more details on the available features."
msgstr "사용 가능한 기능에 대한 자세한 내용은 [`target_feature` 속성](attributes/codegen.md#the-target_feature-attribute)을 참조하십시오."

#: src/conditional-compilation.md:165
msgid ""
"An additional feature of `crt-static` is available to the `target_feature` "
"option to indicate that a [static C runtime](linkage.md#static-and-dynamic-c-"
"runtimes) is available."
msgstr "An additional feature of `crt-static` is available to the `target_feature` option to indicate that a [static C runtime](linkage.md#static-and-dynamic-c-runtimes) is available."

#: src/conditional-compilation.md:170
msgid "`target_os`"
msgstr "`target_os`"

#: src/conditional-compilation.md:174
msgid ""
"Key-value option set once with the target's operating system. This value is "
"similar to the second and third element of the platform's target triple."
msgstr "키-값 옵션은 대상의 운영 체제로 한 번 설정됩니다. 이 값은 플랫폼의 대상 트리플의 두 번째 및 세 번째 요소와 유사합니다."

#: src/conditional-compilation.md:181 src/conditional-compilation.md:207
msgid "`\"windows\"`"
msgstr "`\"windows\"`"

#: src/conditional-compilation.md:182
msgid "`\"macos\"`"
msgstr "`\"macos\"`"

#: src/conditional-compilation.md:183
msgid "`\"ios\"`"
msgstr "`\"ios\"`"

#: src/conditional-compilation.md:184
msgid "`\"linux\"`"
msgstr "`\"linux\"`"

#: src/conditional-compilation.md:185
msgid "`\"android\"`"
msgstr "`\"android\"`"

#: src/conditional-compilation.md:186
msgid "`\"freebsd\"`"
msgstr "`\"freebsd\"`"

#: src/conditional-compilation.md:187
msgid "`\"dragonfly\"`"
msgstr "`\"dragonfly\"`"

#: src/conditional-compilation.md:188
msgid "`\"openbsd\"`"
msgstr "`\"openbsd\"`"

#: src/conditional-compilation.md:189
msgid "`\"netbsd\"`"
msgstr "`\"netbsd\"`"

#: src/conditional-compilation.md:190
msgid "`\"none\"` (typical for embedded targets)"
msgstr "`\"none\"` (임베디드 대상의 경우 일반적)"

#: src/conditional-compilation.md:194
msgid "`target_family`"
msgstr "`target_family`"

#: src/conditional-compilation.md:198
msgid ""
"Key-value option providing a more generic description of a target, such as "
"the family of the operating systems or architectures that the target "
"generally falls into. Any number of `target_family` key-value pairs can be "
"set."
msgstr "키-값 옵션은 대상이 일반적으로 속하는 운영 체제 또는 아키텍처 제품군과 같이 대상에 대한 보다 일반적인 설명을 제공합니다. `target_family` 키-값 쌍은 여러 개 설정할 수 있습니다."

#: src/conditional-compilation.md:206
msgid "`\"unix\"`"
msgstr "`\"unix\"`"

#: src/conditional-compilation.md:208
msgid "`\"wasm\"`"
msgstr "`\"wasm\"`"

#: src/conditional-compilation.md:209
msgid "Both `\"unix\"` and `\"wasm\"`"
msgstr "`\"unix\"`와 `\"wasm\"` 모두"

#: src/conditional-compilation.md:213
msgid "`unix` and `windows`"
msgstr "`unix` 및 `windows`"

#: src/conditional-compilation.md:215
msgid "`unix` is set if `target_family = \"unix\"` is set."
msgstr "`unix`는 `target_family = \"unix\"`가 설정되면 설정됩니다."

#: src/conditional-compilation.md:219
msgid "`windows` is set if `target_family = \"windows\"` is set."
msgstr "`windows`는 `target_family = \"windows\"`가 설정되면 설정됩니다."

#: src/conditional-compilation.md:223
msgid "`target_env`"
msgstr "`target_env`"

#: src/conditional-compilation.md:227
msgid ""
"Key-value option set with further disambiguating information about the "
"target platform with information about the ABI or `libc` used. For "
"historical reasons, this value is only defined as not the empty-string when "
"actually needed for disambiguation. Thus, for example, on many GNU "
"platforms, this value will be empty. This value is similar to the fourth "
"element of the platform's target triple. One difference is that embedded "
"ABIs such as `gnueabihf` will simply define `target_env` as `\"gnu\"`."
msgstr "사용된 ABI 또는 `libc`에 대한 정보와 함께 대상 플랫폼에 대한 추가 명확화 정보로 설정된 키-값 옵션입니다. 역사적인 이유로 이 값은 실제로 명확화가 필요할 때만 빈 문자열이 아닌 것으로 정의됩니다. 따라서 예를 들어 많은 GNU 플랫폼에서 이 값은 비어 있습니다. 이 값은 플랫폼의 대상 트리플의 네 번째 요소와 유사합니다. 한 가지 차이점은 `gnueabihf`와 같은 임베디드 ABI는 단순히 `target_env`를 `\"gnu\"`로 정의한다는 것입니다."

#: src/conditional-compilation.md:239 src/conditional-compilation.md:264
msgid "`\"\"`"
msgstr "`\"\"`"

#: src/conditional-compilation.md:240
msgid "`\"gnu\"`"
msgstr "`\"gnu\"`"

#: src/conditional-compilation.md:241
msgid "`\"msvc\"`"
msgstr "`\"msvc\"`"

#: src/conditional-compilation.md:242
msgid "`\"musl\"`"
msgstr "`\"musl\"`"

#: src/conditional-compilation.md:243
msgid "`\"sgx\"`"
msgstr "`\"sgx\"`"

#: src/conditional-compilation.md:247
msgid "`target_abi`"
msgstr "`target_abi`"

#: src/conditional-compilation.md:251
msgid ""
"Key-value option set to further disambiguate the `target_env` with "
"information about the target ABI."
msgstr "대상 ABI에 대한 정보로 `target_env`를 추가로 명확히 하기 위해 설정된 키-값 옵션입니다."

#: src/conditional-compilation.md:256
msgid ""
"For historical reasons, this value is only defined as not the empty-string "
"when actually needed for disambiguation. Thus, for example, on many GNU "
"platforms, this value will be empty."
msgstr "역사적인 이유로 이 값은 실제로 명확화가 필요할 때만 빈 문자열이 아닌 것으로 정의됩니다. 따라서 예를 들어 많은 GNU 플랫폼에서 이 값은 비어 있습니다."

#: src/conditional-compilation.md:265
msgid "`\"llvm\"`"
msgstr "`\"llvm\"`"

#: src/conditional-compilation.md:266
msgid "`\"eabihf\"`"
msgstr "`\"eabihf\"`"

#: src/conditional-compilation.md:267
msgid "`\"abi64\"`"
msgstr "`\"abi64\"`"

#: src/conditional-compilation.md:268
msgid "`\"sim\"`"
msgstr "`\"sim\"`"

#: src/conditional-compilation.md:269
msgid "`\"macabi\"`"
msgstr "`\"macabi\"`"

#: src/conditional-compilation.md:273
msgid "`target_endian`"
msgstr "`target_endian`"

#: src/conditional-compilation.md:275
msgid ""
"Key-value option set once with either a value of \"little\" or \"big\" "
"depending on the endianness of the target's CPU."
msgstr "키-값 옵션은 대상의 CPU 엔디안에 따라 \"little\" 또는 \"big\" 값으로 한 번 설정됩니다."

#: src/conditional-compilation.md:280
msgid "`target_pointer_width`"
msgstr "`target_pointer_width`"

#: src/conditional-compilation.md:284
msgid "Key-value option set once with the target's pointer width in bits."
msgstr "키-값 옵션은 대상의 포인터 너비를 비트 단위로 한 번 설정합니다."

#: src/conditional-compilation.md:290 src/conditional-compilation.md:331
msgid "`\"16\"`"
msgstr "`\"16\"`"

#: src/conditional-compilation.md:291 src/conditional-compilation.md:332
msgid "`\"32\"`"
msgstr "`\"32\"`"

#: src/conditional-compilation.md:292 src/conditional-compilation.md:333
msgid "`\"64\"`"
msgstr "`\"64\"`"

#: src/conditional-compilation.md:296
msgid "`target_vendor`"
msgstr "`target_vendor`"

#: src/conditional-compilation.md:300
msgid "Key-value option set once with the vendor of the target."
msgstr "키-값 옵션은 대상의 공급업체로 한 번 설정됩니다."

#: src/conditional-compilation.md:306
msgid "`\"apple\"`"
msgstr "`\"apple\"`"

#: src/conditional-compilation.md:307
msgid "`\"fortanix\"`"
msgstr "`\"fortanix\"`"

#: src/conditional-compilation.md:308
msgid "`\"pc\"`"
msgstr "`\"pc\"`"

#: src/conditional-compilation.md:309
msgid "`\"unknown\"`"
msgstr "`\"unknown\"`"

#: src/conditional-compilation.md:313
msgid "`target_has_atomic`"
msgstr "`target_has_atomic`"

#: src/conditional-compilation.md:317
msgid ""
"Key-value option set for each bit width that the target supports atomic "
"loads, stores, and compare-and-swap operations."
msgstr "대상이 원자적 로드, 저장 및 비교-스왑 작업을 지원하는 각 비트 너비에 대해 설정된 키-값 옵션입니다."

#: src/conditional-compilation.md:322
msgid ""
"When this cfg is present, all of the stable [`core::sync::atomic`](../core/"
"sync/atomic/index.html) APIs are available for the relevant atomic width."
msgstr "이 cfg가 있으면 관련 원자 너비에 대해 안정적인 [`core::sync::atomic`](../core/sync/atomic/index.html) API를 모두 사용할 수 있습니다."

#: src/conditional-compilation.md:328
msgid "Possible values:"
msgstr "가능한 값:"

#: src/conditional-compilation.md:330
msgid "`\"8\"`"
msgstr "`\"8\"`"

#: src/conditional-compilation.md:334
msgid "`\"128\"`"
msgstr "`\"128\"`"

#: src/conditional-compilation.md:335
msgid "`\"ptr\"`"
msgstr "`\"ptr\"`"

#: src/conditional-compilation.md:339
msgid "`test`"
msgstr "`test`"

#: src/conditional-compilation.md:342
msgid ""
"Enabled when compiling the test harness. Done with `rustc` by using the [`--"
"test`](../rustc/command-line-arguments.html#--test-build-a-test-harness) "
"flag. See [Testing](attributes/testing.md) for more on testing support."
msgstr "테스트 하네스를 컴파일할 때 활성화됩니다. `rustc`로 [`--test`](../rustc/command-line-arguments.html#--test-build-a-test-harness) 플래그를 사용하여 수행됩니다. 테스트 지원에 대한 자세한 내용은 [테스팅](attributes/testing.md)을 참조하십시오."

#: src/conditional-compilation.md:347
msgid "`debug_assertions`"
msgstr "`debug_assertions`"

#: src/conditional-compilation.md:350
msgid ""
"Enabled by default when compiling without optimizations. This can be used to "
"enable extra debugging code in development but not in production.  For "
"example, it controls the behavior of the standard library's [`debug_assert!`]"
"(../core/macro.debug_assert.html) macro."
msgstr ""
"최적화 없이 컴파일할 때 기본적으로 활성화됩니다. 이는 프로덕션이 아닌 개발 환경에서 추가 "
"디버깅 코드를 활성화하는 데 사용할 수 있습니다. 예를 들어, 표준 라이브러리의 [`debug_assert!`]"
"(../core/macro.debug_assert.html) 매크로의 동작을 제어합니다."

#: src/conditional-compilation.md:357
msgid "`proc_macro`"
msgstr "`proc_macro`"

#: src/conditional-compilation.md:360
msgid ""
"Set when the crate being compiled is being compiled with the `proc_macro` "
"[crate type](linkage.md)."
msgstr ""
"컴파일 중인 크레이트가 `proc_macro` [크레이트 타입](linkage.md)으로 컴파일될 때 "
"설정됩니다."

#: src/conditional-compilation.md:365
msgid "`panic`"
msgstr "`panic`"

#: src/conditional-compilation.md:369
msgid ""
"Key-value option set depending on the panic strategy. Note that more values "
"may be added in the future."
msgstr ""
"패닉 전략에 따라 설정되는 키-값 옵션입니다. 미래에 더 많은 값이 추가될 수 있음에 "
"유의하세요."

#: src/conditional-compilation.md:375
msgid "`\"abort\"`"
msgstr "`\"abort\"`"

#: src/conditional-compilation.md:376
msgid "`\"unwind\"`"
msgstr "`\"unwind\"`"

#: src/conditional-compilation.md:378
msgid "Forms of conditional compilation"
msgstr "조건부 컴파일의 형태"

#: src/conditional-compilation.md:382
msgid "The `cfg` attribute"
msgstr "`cfg` 속성"

#: src/conditional-compilation.md:386
msgid ""
"**<sup>Syntax</sup>**  \n"
"_CfgAttrAttribute_ :  \n"
"   `cfg` `(` _ConfigurationPredicate_ `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_CfgAttr속성_ :  \n"
"   `cfg` `(` _구성조건자_ `)`"

#: src/conditional-compilation.md:394
msgid ""
"The `cfg` [attribute](attributes.md) conditionally includes the thing it is "
"attached to based on a configuration predicate."
msgstr ""
"`cfg` [속성](attributes.md)은 구성 조건자에 따라 부착된 대상을 조건부로 "
"포함합니다."

#: src/conditional-compilation.md:399
msgid ""
"It is written as `cfg`, `(`, a configuration predicate, and finally `)`."
msgstr "`cfg`, `(`, 구성 조건자, 그리고 마지막으로 `)`로 작성됩니다."

#: src/conditional-compilation.md:403
msgid ""
"If the predicate is true, the thing is rewritten to not have the `cfg` "
"attribute on it. If the predicate is false, the thing is removed from the "
"source code."
msgstr ""
"조건자가 참이면, 대상은 `cfg` 속성이 없는 상태로 다시 작성됩니다. 조건자가 거짓이면, "
"대상은 소스 코드에서 제거됩니다."

#: src/conditional-compilation.md:408
msgid ""
"When a crate-level `cfg` has a false predicate, the behavior is slightly "
"different: any crate attributes preceding the `cfg` are kept, and any crate "
"attributes following the `cfg` are removed. This allows `#![no_std]` and `#!"
"[no_core]` crates to avoid linking `std`/`core` even if a `#![cfg(...)]` has "
"removed the entire crate."
msgstr ""
"크레이트 수준의 `cfg`가 거짓 술어를 가질 때, 동작이 약간 다릅니다. `cfg` "
"앞에 오는 모든 크레이트 속성은 유지되고, `cfg` 뒤에 오는 모든 크레이트 "
"속성은 제거됩니다. 이를 통해 `#![cfg(...)]`가 크레이트 전체를 제거하더라도 "
"#![no_std]` 및 `#![no_core]` 크레이트가 `std`/`core`를 링크하지 않도록 "
"할 수 있습니다."

#: src/conditional-compilation.md:414
msgid "Some examples on functions:"
msgstr "함수에 대한 몇 가지 예시:"

#: src/conditional-compilation.md:417
msgid ""
"// The function is only included in the build when compiling for macOS\n"
msgstr "// 이 함수는 macOS용으로 컴파일할 때만 빌드에 포함됩니다.\n"

#: src/conditional-compilation.md:418
msgid "\"macos\""
msgstr "\"macos\""

#: src/conditional-compilation.md:420 src/conditional-compilation.md:426
#: src/conditional-compilation.md:433 src/conditional-compilation.md:439
#: src/conditional-compilation.md:445 src/items/associated-items.md:215
#: src/items/associated-items.md:219 src/attributes/diagnostics.md:309
#: src/attributes/diagnostics.md:315 src/expressions.md:301
#: src/types/impl-trait.md:176 src/types/impl-trait.md:189
#: src/type-layout.md:605 src/type-layout.md:610 src/trait-bounds.md:178
#: src/names/scopes.md:251 src/paths.md:189
msgid "// ...\n"
msgstr "// ...\n"

#: src/conditional-compilation.md:422
msgid "// This function is only included when either foo or bar is defined\n"
msgstr "// 이 함수는 foo 또는 bar 중 하나가 정의된 경우에만 포함됩니다.\n"

#: src/conditional-compilation.md:428
msgid ""
"// This function is only included when compiling for a unixish OS with a 32-"
"bit\n"
"// architecture\n"
msgstr "// 이 함수는 32비트 아키텍처의 unix 계열 OS용으로 컴파일할 때만 포함됩니다.\n"

#: src/conditional-compilation.md:431
msgid "\"32\""
msgstr "\"32\""

#: src/conditional-compilation.md:435
msgid "// This function is only included when foo is not defined\n"
msgstr "// 이 함수는 foo가 정의되지 않은 경우에만 포함됩니다.\n"

#: src/conditional-compilation.md:441
msgid ""
"// This function is only included when the panic strategy is set to unwind\n"
msgstr "// 이 함수는 패닉 전략이 unwind로 설정된 경우에만 포함됩니다.\n"

#: src/conditional-compilation.md:443
msgid "\"unwind\""
msgstr "\"unwind\""

#: src/conditional-compilation.md:452
msgid "The `cfg` attribute is allowed anywhere attributes are allowed."
msgstr "`cfg` 속성은 속성이 허용되는 모든 곳에서 허용됩니다."

#: src/conditional-compilation.md:456
msgid "The `cfg_attr` attribute"
msgstr "`cfg_attr` 속성"

#: src/conditional-compilation.md:460
msgid ""
"**<sup>Syntax</sup>**  \n"
"_CfgAttrAttribute_ :  \n"
"   `cfg_attr` `(` _ConfigurationPredicate_ `,` _CfgAttrs_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_CfgAttr속성_ :  \n"
"   `cfg_attr` `(` _구성술어_ `,` _Cfg속성들_<sup>?</sup> `)`"

#: src/conditional-compilation.md:464
msgid ""
"_CfgAttrs_ :  \n"
"   [_Attr_](attributes.md) (`,` [_Attr_](attributes.md))<sup>\\*</sup> "
"`,`<sup>?</sup>"
msgstr ""
"_Cfg속성들_ :  \n"
"   [_속성_](attributes.md) (`,` [_속성_](attributes.md))<sup>\\*</sup> "
"`,`<sup>?</sup>"

#: src/conditional-compilation.md:469
msgid ""
"The `cfg_attr` [attribute](attributes.md) conditionally includes [attributes]"
"(attributes.md) based on a configuration predicate."
msgstr ""
"`cfg_attr` [속성](attributes.md)은 구성 술어에 기반하여 조건부로 "
"[속성](attributes.md)들을 포함합니다."

#: src/conditional-compilation.md:474
msgid ""
"When the configuration predicate is true, this attribute expands out to the "
"attributes listed after the predicate. For example, the following module "
"will either be found at `linux.rs` or `windows.rs` based on the target."
msgstr ""
"구성 술어가 참일 때, 이 속성은 술어 뒤에 나열된 속성들로 확장됩니다. "
"예를 들어, 다음 모듈은 대상에 따라 `linux.rs` 또는 `windows.rs`에서 "
"발견됩니다."

#: src/conditional-compilation.md:480 src/attributes.md:124
msgid "\"linux\""
msgstr "\"linux\""

#: src/conditional-compilation.md:480
msgid "\"linux.rs\""
msgstr "\"linux.rs\""

#: src/conditional-compilation.md:481
msgid "\"windows.rs\""
msgstr "\"windows.rs\""

#: src/conditional-compilation.md:487
msgid ""
"Zero, one, or more attributes may be listed. Multiple attributes will each "
"be expanded into separate attributes. For example:"
msgstr ""
"0개, 1개 또는 그 이상의 속성이 나열될 수 있습니다. 여러 속성은 각각 "
"별도의 속성으로 확장됩니다. 예를 들어:"

#: src/conditional-compilation.md:492
msgid "\"magic\""
msgstr "\"magic\""

#: src/conditional-compilation.md:494
msgid ""
"// When the `magic` feature flag is enabled, the above will expand to:\n"
msgstr "// `magic` 피처 플래그가 활성화되면, 위 코드는 다음과 같이 확장됩니다:\n"

#: src/conditional-compilation.md:501
msgid ""
"**Note**: The `cfg_attr` can expand to another `cfg_attr`. For example, "
"`#[cfg_attr(target_os = \"linux\", cfg_attr(feature = \"multithreaded\", "
"some_other_attribute))]` is valid. This example would be equivalent to "
"`#[cfg_attr(all(target_os = \"linux\", feature =\"multithreaded\"), "
"some_other_attribute)]`."
msgstr ""
"**참고**: `cfg_attr`은 다른 `cfg_attr`로 확장될 수 있습니다. 예를 들어, `#[cfg_attr("
"target_os = \"linux\", cfg_attr(feature = \"multithreaded\", "
"some_other_attribute))]`는 유효합니다. 이 예제는 `#[cfg_attr(all(target_os = "
"\"linux\", feature =\"multithreaded\"), some_other_attribute)]`와 동일합니다."

#: src/conditional-compilation.md:508
msgid "The `cfg_attr` attribute is allowed anywhere attributes are allowed."
msgstr "`cfg_attr` 속성은 속성이 허용되는 모든 곳에 허용됩니다."

#: src/conditional-compilation.md:510
msgid ""
"The [`crate_type`](linkage.md) and [`crate_name`](crates-and-source-"
"files.md#the-crate_name-attribute) attributes cannot be used with `cfg_attr`."
msgstr ""
"[`crate_type`](linkage.md) 및 [`crate_name`](crates-and-source-"
"files.md#the-crate_name-attribute) 속성은 `cfg_attr`과 함께 사용할 수 없습니다."

#: src/conditional-compilation.md:514
msgid "The `cfg` macro"
msgstr "`cfg` 매크로"

#: src/conditional-compilation.md:516
msgid ""
"The built-in `cfg` macro takes in a single configuration predicate and "
"evaluates to the `true` literal when the predicate is true and the `false` "
"literal when it is false."
msgstr ""
"내장된 `cfg` 매크로는 단일 구성 조건자를 취하며, 조건자가 참이면 `true` 리터럴로, "
"거짓이면 `false` 리터럴로 평가됩니다."

#: src/conditional-compilation.md:520 src/expressions/operator-expr.md:928
#: src/types/closure.md:121
msgid "For example:"
msgstr "예:"

#: src/conditional-compilation.md:524
msgid "\"unix\""
msgstr "\"unix\""

#: src/conditional-compilation.md:526 src/attributes/diagnostics.md:145
#: src/runtime.md:108
msgid "\"windows\""
msgstr "\"windows\""

#: src/conditional-compilation.md:528
msgid "\"unknown\""
msgstr "\"unknown\""

#: src/conditional-compilation.md:531
msgid "\"I'm running on a {} machine!\""
msgstr "\"저는 {} 머신에서 실행 중입니다!\""

#: src/items.md:7
msgid ""
"**<sup>Syntax:</sup>**  \n"
"_Item_:  \n"
"   [_OuterAttribute_](attributes.md)<sup>\\*</sup>  \n"
"      _VisItem_  \n"
"   | _MacroItem_"
msgstr ""
"**<sup>구문:</sup>**  \n"
"_아이템_:  \n"
"   [_외부속성_](attributes.md)<sup>\\*</sup>  \n"
"      _가시성아이템_  \n"
"   | _매크로아이템_"

#: src/items.md:13
msgid ""
"_VisItem_:  \n"
"   [_Visibility_](visibility-and-privacy.md)<sup>?</sup>  \n"
"   (  \n"
"          [_Module_](items/modules.md)  \n"
"      | [_ExternCrate_](items/extern-crates.md)  \n"
"      | [_UseDeclaration_](items/use-declarations.md)  \n"
"      | [_Function_](items/functions.md)  \n"
"      | [_TypeAlias_](items/type-aliases.md)  \n"
"      | [_Struct_](items/structs.md)  \n"
"      | [_Enumeration_](items/enumerations.md)  \n"
"      | [_Union_](items/unions.md)  \n"
"      | [_ConstantItem_](items/constant-items.md)  \n"
"      | [_StaticItem_](items/static-items.md)  \n"
"      | [_Trait_](items/traits.md)  \n"
"      | [_Implementation_](items/implementations.md)  \n"
"      | [_ExternBlock_](items/external-blocks.md)  \n"
"   )"
msgstr ""
"_가시성아이템_:  \n"
"   [_가시성_](visibility-and-privacy.md)<sup>?</sup>  \n"
"   (  \n"
"          [_모듈_](items/modules.md)  \n"
"      | [_외부크레이트_](items/extern-crates.md)  \n"
"      | [_사용선언_](items/use-declarations.md)  \n"
"      | [_함수_](items/functions.md)  \n"
"      | [_타입별칭_](items/type-aliases.md)  \n"
"      | [_구조체_](items/structs.md)  \n"
"      | [_열거형_](items/enumerations.md)  \n"
"      | [_공용체_](items/unions.md)  \n"
"      | [_상수아이템_](items/constant-items.md)  \n"
"      | [_정적아이템_](items/static-items.md)  \n"
"      | [_트레잇_](items/traits.md)  \n"
"      | [_구현_](items/implementations.md)  \n"
"      | [_외부블록_](items/external-blocks.md)  \n"
"   )"

#: src/items.md:31
msgid ""
"_MacroItem_:  \n"
"      [_MacroInvocationSemi_](macros.md#macro-invocation)  \n"
"   | [_MacroRulesDefinition_](macros-by-example.md)"
msgstr ""
"_매크로아이템_:  \n"
"      [_세미콜론매크로호출_](macros.md#macro-invocation)  \n"
"   | [_매크로규칙정의_](macros-by-example.md)"

#: src/items.md:37
msgid ""
"An _item_ is a component of a crate. Items are organized within a crate by a "
"nested set of [modules](items/modules.md). Every crate has a single "
"\"outermost\" anonymous module; all further items within the crate have "
"[paths](paths.md) within the module tree of the crate."
msgstr ""
"_아이템_은 크레이트의 구성 요소입니다. 아이템은 중첩된 [모듈](items/modules.md) 집합으로 "
"크레이트 내에 구성됩니다. 모든 크레이트는 단일 \"최상위\" 익명 모듈을 가지며, 크레이트 "
"내의 모든 추가 아이템은 크레이트의 모듈 트리 내에서 [경로](paths.md)를 가집니다."

#: src/items.md:44
msgid ""
"Items are entirely determined at compile-time, generally remain fixed during "
"execution, and may reside in read-only memory."
msgstr ""
"아이템은 컴파일 타임에 완전히 결정되며, 실행 중에 일반적으로 고정되어 있고, 읽기 전용 "
"메모리에 상주할 수 있습니다."

#: src/items.md:49
msgid "There are several kinds of items:"
msgstr "아이템에는 여러 종류가 있습니다:"

#: src/items.md:51
msgid "[modules](items/modules.md)"
msgstr "[모듈](items/modules.md)"

#: src/items.md:52
msgid "[`extern crate` declarations](items/extern-crates.md)"
msgstr "[`extern crate` 선언](items/extern-crates.md)"

#: src/items.md:53
msgid "[`use` declarations](items/use-declarations.md)"
msgstr "[`use` 선언](items/use-declarations.md)"

#: src/items.md:54
msgid "[function definitions](items/functions.md)"
msgstr "[함수 정의](items/functions.md)"

#: src/items.md:55
msgid "[type definitions](items/type-aliases.md)"
msgstr "[타입 정의](items/type-aliases.md)"

#: src/items.md:56
msgid "[struct definitions](items/structs.md)"
msgstr "[구조체 정의](items/structs.md)"

#: src/items.md:57
msgid "[enumeration definitions](items/enumerations.md)"
msgstr "[열거형 정의](items/enumerations.md)"

#: src/items.md:58
msgid "[union definitions](items/unions.md)"
msgstr "[공용체 정의](items/unions.md)"

#: src/items.md:59
msgid "[constant items](items/constant-items.md)"
msgstr "[상수 아이템](items/constant-items.md)"

#: src/items.md:60
msgid "[static items](items/static-items.md)"
msgstr "[정적 아이템](items/static-items.md)"

#: src/items.md:61
msgid "[trait definitions](items/traits.md)"
msgstr "[트레잇 정의](items/traits.md)"

#: src/items.md:62
msgid "[implementations](items/implementations.md)"
msgstr "[구현](items/implementations.md)"

#: src/items.md:63
msgid "[`extern` blocks](items/external-blocks.md)"
msgstr "[`extern` 블록](items/external-blocks.md)"

#: src/items.md:67
msgid ""
"Items may be declared in the [root of the crate](crates-and-source-"
"files.md), a [module](items/modules.md), or a [block expression](expressions/"
"block-expr.md)."
msgstr ""
"아이템은 [크레이트 루트](crates-and-source-files.md), [모듈](items/modules.md), "
"또는 [블록 표현식](expressions/block-expr.md)에서 선언될 수 있습니다."

#: src/items.md:71
msgid ""
"A subset of items, called [associated items](items/associated-items.md), may "
"be declared in [traits](items/traits.md) and [implementations](items/"
"implementations.md)."
msgstr ""
"[연관 아이템](items/associated-items.md)이라고 불리는 아이템의 일부는 [트레잇](items/traits.md)과 [구현](items/implementations.md)에서 "
"선언될 수 있습니다."

#: src/items.md:75
msgid ""
"A subset of items, called external items, may be declared in [`extern` "
"blocks](items/external-blocks.md)."
msgstr ""
"외부 아이템이라고 불리는 아이템의 일부는 [`extern` 블록](items/external-blocks.md)에서 "
"선언될 수 있습니다."

#: src/items.md:79
msgid ""
"Items may be defined in any order, with the exception of [`macro_rules`]"
"(macros-by-example.md) which has its own scoping behavior."
msgstr ""
"아이템은 임의의 순서로 정의될 수 있으나, 자체적인 스코프 동작을 갖는 [`macro_rules`](macros-by-example.md)는 "
"예외입니다."

#: src/items.md:83
msgid ""
"[Name resolution](names/name-resolution.md) of item names allows items to be "
"defined before or after where the item is referred to in the module or block."
msgstr ""
"아이템 이름의 [이름 확인](names/name-resolution.md)을 통해 아이템은 모듈이나 블록 내에서 "
"참조되는 지점의 앞이나 뒤에서 정의될 수 있습니다."

#: src/items.md:85
msgid ""
"See [item scopes](names/scopes.md#item-scopes) for information on the "
"scoping rules of items."
msgstr ""
"아이템의 스코프 규칙에 대한 정보는 [아이템 스코프](names/scopes.md#item-scopes)를 "
"참조하십시오."

#: src/items/modules.md:7
msgid ""
"**<sup>Syntax:</sup>**  \n"
"_Module_ :  \n"
"      `unsafe`<sup>?</sup> `mod` [IDENTIFIER](../identifiers.md) `;`  \n"
"   | `unsafe`<sup>?</sup> `mod` [IDENTIFIER](../identifiers.md) `{`  \n"
"        [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"        [_Item_](../items.md)<sup>\\*</sup>  \n"
"      `}`"
msgstr ""
"**<sup>구문:</sup>**  \n"
"_모듈_ :  \n"
"      `unsafe`<sup>?</sup> `mod` [식별자](../identifiers.md) `;`  \n"
"   | `unsafe`<sup>?</sup> `mod` [식별자](../identifiers.md) `{`  \n"
"        [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"        [_아이템_](../items.md)<sup>\\*</sup>  \n"
"      `}`"

#: src/items/modules.md:17
msgid "A module is a container for zero or more [items](../items.md)."
msgstr "모듈은 0개 이상의 [아이템](../items.md)을 담는 컨테이너입니다."

#: src/items/modules.md:21
msgid ""
"A _module item_ is a module, surrounded in braces, named, and prefixed with "
"the keyword `mod`. A module item introduces a new, named module into the "
"tree of modules making up a crate."
msgstr ""
"_모듈 아이템_은 중괄호로 둘러싸여 있고, 이름이 지정되며, `mod` 키워드가 "
"앞에 붙은 모듈입니다. 모듈 아이템은 크레이트를 구성하는 모듈 트리에 "
"이름이 지정된 새로운 모듈을 도입합니다."

#: src/items/modules.md:27
msgid "Modules can nest arbitrarily."
msgstr "모듈은 임의로 중첩될 수 있습니다."

#: src/items/modules.md:29
msgid "An example of a module:"
msgstr "모듈의 예:"

#: src/items/modules.md:35 src/items/modules.md:39 src/items/modules.md:43
#: src/items/functions.md:218 src/items/implementations.md:234
#: src/items/implementations.md:266 src/items/implementations.md:269
#: src/items/implementations.md:272 src/items/implementations.md:276
#: src/items/implementations.md:280 src/items/implementations.md:290
#: src/items/implementations.md:293 src/items/implementations.md:297
#: src/items/implementations.md:301 src/attributes.md:120 src/attributes.md:126
msgid "/* ... */"
msgstr "/* ... */"

#: src/items/modules.md:51
msgid ""
"Modules are defined in the [type namespace](../names/namespaces.md) of the "
"module or block where they are located."
msgstr ""
"모듈은 해당 모듈이나 블록이 위치한 [타입 네임스페이스](../names/namespaces.md)에 "
"정의됩니다."

#: src/items/modules.md:55
msgid ""
"It is an error to define multiple items with the same name in the same "
"namespace within a module. See the [scopes chapter](../names/scopes.md) for "
"more details on restrictions and shadowing behavior."
msgstr ""
"모듈 내 같은 네임스페이스에 같은 이름을 가진 아이템을 여러 개 정의하는 것은 오류입니다. "
"제약 사항 및 가려짐(shadowing) 동작에 대한 자세한 내용은 [스코프 챕터](../names/scopes.md)를 "
"참조하십시오."

#: src/items/modules.md:60
msgid ""
"The `unsafe` keyword is syntactically allowed to appear before the `mod` "
"keyword, but it is rejected at a semantic level. This allows macros to "
"consume the syntax and make use of the `unsafe` keyword, before removing it "
"from the token stream."
msgstr ""
"`unsafe` 키워드는 구문적으로 `mod` 키워드 앞에 나타나는 것이 허용되지만, 시맨틱 "
"수준에서는 거부됩니다. 이는 매크로가 해당 구문을 소비하고 `unsafe` 키워드를 토큰 "
"스트림에서 제거하기 전에 이를 사용할 수 있게 하기 위함입니다."

#: src/items/modules.md:67
msgid "Module Source Filenames"
msgstr "모듈 소스 파일 이름"

#: src/items/modules.md:71
msgid ""
"A module without a body is loaded from an external file. When the module "
"does not have a `path` attribute, the path to the file mirrors the logical "
"[module path](../paths.md)."
msgstr ""
"본문이 없는 모듈은 외부 파일에서 로드됩니다. 모듈에 `path` 속성이 없는 경우, 파일 "
"경로는 논리적 [모듈 경로](../paths.md)를 반영합니다."

#: src/items/modules.md:77
msgid ""
"Ancestor module path components are directories, and the module's contents "
"are in a file with the name of the module plus the `.rs` extension. For "
"example, the following module structure can have this corresponding "
"filesystem structure:"
msgstr ""
"상위 모듈 경로 구성 요소는 디렉터리이며, 모듈의 내용은 모듈 이름에 `.rs` 확장자를 "
"더한 파일에 있습니다. 예를 들어, 다음 모듈 구조는 이에 해당하는 파일 시스템 구조를 "
"가질 수 있습니다:"

#: src/items/modules.md:82
msgid "Module Path"
msgstr "모듈 경로"

#: src/items/modules.md:82
msgid "Filesystem Path"
msgstr "파일시스템 경로"

#: src/items/modules.md:82
msgid "File Contents"
msgstr "파일 내용"

#: src/items/modules.md:84 src/paths.md:395
msgid "`crate`"
msgstr "`crate`"

#: src/items/modules.md:84
msgid "`lib.rs`"
msgstr "`lib.rs`"

#: src/items/modules.md:84
msgid "`mod util;`"
msgstr "`mod util;`"

#: src/items/modules.md:85
msgid "`crate::util`"
msgstr "`crate::util`"

#: src/items/modules.md:85
msgid "`util.rs`"
msgstr "`util.rs`"

#: src/items/modules.md:85
msgid "`mod config;`"
msgstr "`mod config;`"

#: src/items/modules.md:86
msgid "`crate::util::config`"
msgstr "`crate::util::config`"

#: src/items/modules.md:86
msgid "`util/config.rs`"
msgstr "`util/config.rs`"

#: src/items/modules.md:90
msgid ""
"Module filenames may also be the name of the module as a directory with the "
"contents in a file named `mod.rs` within that directory. The above example "
"can alternately be expressed with `crate::util`'s contents in a file named "
"`util/mod.rs`. It is not allowed to have both `util.rs` and `util/mod.rs`."
msgstr ""
"모듈 파일 이름은 해당 디렉토리 내의 `mod.rs`라는 이름의 파일에 내용이 "
"있는 디렉토리로서의 모듈 이름일 수도 있습니다. 위의 예시는 "
"`crate::util`의 내용을 `util/mod.rs`라는 이름의 파일로 표현할 수도 "
"있습니다. `util.rs`와 `util/mod.rs`를 동시에 가질 수는 없습니다."

#: src/items/modules.md:95
msgid ""
"**Note**: Prior to `rustc` 1.30, using `mod.rs` files was the way to load a "
"module with nested children. It is encouraged to use the new naming "
"convention as it is more consistent, and avoids having many files named "
"`mod.rs` within a project."
msgstr ""
"**참고**: `rustc` 1.30 이전에는 중첩된 자식을 가진 모듈을 로드하기 "
"위해 `mod.rs` 파일을 사용하는 것이 방법이었습니다. 새로운 명명 "
"규칙은 더 일관성이 있고 프로젝트 내에 `mod.rs`라는 이름의 파일이 "
"너무 많아지는 것을 방지하므로 이를 사용하는 것이 권장됩니다."

#: src/items/modules.md:102
msgid "The `path` attribute"
msgstr "`path` 속성"

#: src/items/modules.md:106
msgid ""
"The directories and files used for loading external file modules can be "
"influenced with the `path` attribute."
msgstr ""
"외부 파일 모듈을 로드하는 데 사용되는 디렉토리와 파일은 `path` 속성의 "
"영향을 받을 수 있습니다."

#: src/items/modules.md:111
msgid ""
"For `path` attributes on modules not inside inline module blocks, the file "
"path is relative to the directory the source file is located. For example, "
"the following code snippet would use the paths shown based on where it is "
"located:"
msgstr ""
"인라인 모듈 블록 내에 있지 않은 모듈의 `path` 속성의 경우, 파일 "
"경로는 소스 파일이 위치한 디렉토리에 상대적입니다. 예를 들어, 다음 "
"코드 스니펫은 위치한 곳에 따라 표시된 경로를 사용합니다:"

#: src/items/modules.md:117
msgid "\"foo.rs\""
msgstr "\"foo.rs\""

#: src/items/modules.md:121 src/items/modules.md:147
msgid "Source File"
msgstr "소스 파일"

#: src/items/modules.md:121
msgid "`c`'s File Location"
msgstr "`c`의 파일 위치"

#: src/items/modules.md:121
msgid "`c`'s Module Path"
msgstr "`c`의 모듈 경로"

#: src/items/modules.md:123 src/items/modules.md:149
msgid "`src/a/b.rs`"
msgstr "`src/a/b.rs`"

#: src/items/modules.md:123 src/items/modules.md:124
msgid "`src/a/foo.rs`"
msgstr "`src/a/foo.rs`"

#: src/items/modules.md:123
msgid "`crate::a::b::c`"
msgstr "`crate::a::b::c`"

#: src/items/modules.md:124 src/items/modules.md:150
msgid "`src/a/mod.rs`"
msgstr "`src/a/mod.rs`"

#: src/items/modules.md:124
msgid "`crate::a::c`"
msgstr "`crate::a::c`"

#: src/items/modules.md:128
msgid ""
"For `path` attributes inside inline module blocks, the relative location of "
"the file path depends on the kind of source file the `path` attribute is "
"located in. \"mod-rs\" source files are root modules (such as `lib.rs` or "
"`main.rs`) and modules with files named `mod.rs`. \"non-mod-rs\" source "
"files are all other module files. Paths for `path` attributes inside inline "
"module blocks in a mod-rs file are relative to the directory of the mod-rs "
"file including the inline module components as directories. For non-mod-rs "
"files, it is the same except the path starts with a directory with the name "
"of the non-mod-rs module. For example, the following code snippet would use "
"the paths shown based on where it is located:"
msgstr ""
"인라인 모듈 블록 내부의 `path` 속성의 경우, 파일 경로의 상대적 "
"위치는 `path` 속성이 위치한 소스 파일의 종류에 따라 달라집니다. "
"\"mod-rs\" 소스 파일은 루트 모듈(`lib.rs` 또는 `main.rs` 등) 및 "
"`mod.rs`라는 이름의 파일을 가진 모듈입니다. \"non-mod-rs\" 소스 "
"파일은 그 외의 모든 모듈 파일입니다. mod-rs 파일 내의 인라인 모듈 "
"블록 내부의 `path` 속성에 대한 경로는 인라인 모듈 구성 요소를 "
"디렉토리로 포함하여 mod-rs 파일의 디렉토리에 상대적입니다. "
"non-mod-rs 파일의 경우, 경로가 non-mod-rs 모듈의 이름을 가진 "
"디렉토리로 시작한다는 점을 제외하고는 동일합니다. 예를 들어, 다음 "
"코드 스니펫은 위치한 곳에 따라 표시된 경로를 사용합니다:"

#: src/items/modules.md:142
msgid "\"other.rs\""
msgstr "\"other.rs\""

#: src/items/modules.md:147
msgid "`inner`'s File Location"
msgstr "`inner`의 파일 위치"

#: src/items/modules.md:147
msgid "`inner`'s Module Path"
msgstr "`inner`의 모듈 경로"

#: src/items/modules.md:149
msgid "`src/a/b/inline/other.rs`"
msgstr "`src/a/b/inline/other.rs`"

#: src/items/modules.md:149
msgid "`crate::a::b::inline::inner`"
msgstr "`crate::a::b::inline::inner`"

#: src/items/modules.md:150
msgid "`src/a/inline/other.rs`"
msgstr "`src/a/inline/other.rs`"

#: src/items/modules.md:150
msgid "`crate::a::inline::inner`"
msgstr "`crate::a::inline::inner`"

#: src/items/modules.md:152
msgid ""
"An example of combining the above rules of `path` attributes on inline "
"modules and nested modules within (applies to both mod-rs and non-mod-rs "
"files):"
msgstr ""
"인라인 모듈의 `path` 속성 규칙과 그 내부의 중첩된 모듈 규칙을 결합한 예(mod-rs 파일과 "
"non-mod-rs 파일 모두에 적용됨):"

#: src/items/modules.md:157
msgid "\"thread_files\""
msgstr "\"thread_files\""

#: src/items/modules.md:159
msgid ""
"// Load the `local_data` module from `thread_files/tls.rs` relative to\n"
"    // this source file's directory.\n"
msgstr ""
"// 이 소스 파일의 디렉토리를 기준으로 `thread_files/tls.rs`에서 `local_data` 모듈을 로드합니다.\n"

#: src/items/modules.md:161
msgid "\"tls.rs\""
msgstr "\"tls.rs\""

#: src/items/modules.md:168
msgid "Attributes on Modules"
msgstr "모듈의 속성"

#: src/items/modules.md:172
msgid ""
"Modules, like all items, accept outer attributes. They also accept inner "
"attributes: either after `{` for a module with a body, or at the beginning "
"of the source file, after the optional BOM and shebang."
msgstr ""
"모듈은 다른 모든 아이템과 마찬가지로 외부 속성을 허용합니다. 또한 내부 속성도 허용하는데, "
"본문이 있는 모듈의 경우 `{` 뒤에, 또는 소스 파일의 시작 부분(선택적인 BOM과 셰뱅 "
"뒤)에 위치합니다."

#: src/items/modules.md:178
msgid ""
"The built-in attributes that have meaning on a module are [`cfg`](../"
"conditional-compilation.md), [`deprecated`](../attributes/diagnostics.md#the-"
"deprecated-attribute), [`doc`](../../rustdoc/the-doc-attribute.html), [the "
"lint check attributes](../attributes/diagnostics.md#lint-check-attributes), "
"[`path`](#the-path-attribute), and [`no_implicit_prelude`](../names/"
"preludes.md#the-no_implicit_prelude-attribute). Modules also accept macro "
"attributes."
msgstr ""
"모듈에서 의미를 갖는 내장 속성은 [`cfg`](../conditional-compilation.md), "
"[`deprecated`](../attributes/diagnostics.md#the-deprecated-attribute), "
"[`doc`](../../rustdoc/the-doc-attribute.html), [린트 검사 속성](../attributes/diagnostics.md#lint-check-attributes), "
"[`path`](#the-path-attribute), 그리고 [`no_implicit_prelude`](../names/"
"preludes.md#the-no_implicit_prelude-attribute)입니다. 모듈은 매크로 속성도 허용합니다."

#: src/items/extern-crates.md:3
msgid "Extern crate declarations"
msgstr "외부 크레이트 선언"

#: src/items/extern-crates.md:7
msgid ""
"**<sup>Syntax:</sup>**  \n"
"_ExternCrate_ :  \n"
"   `extern` `crate` _CrateRef_ _AsClause_<sup>?</sup> `;`"
msgstr ""
"**<sup>구문:</sup>**  \n"
"_외부크레이트_ :  \n"
"   `extern` `crate` _크레이트참조_ _As절_<sup>?</sup> `;`"

#: src/items/extern-crates.md:11
msgid ""
"_CrateRef_ :  \n"
"   [IDENTIFIER](../identifiers.md) | `self`"
msgstr ""
"_크레이트참조_ :  \n"
"   [식별자](../identifiers.md) | `self`"

#: src/items/extern-crates.md:14
msgid ""
"_AsClause_ :  \n"
"   `as` ( [IDENTIFIER](../identifiers.md) | `_` )"
msgstr ""
"_As절_ :  \n"
"   `as` ( [식별자](../identifiers.md) | `_` )"

#: src/items/extern-crates.md:19
msgid ""
"An _`extern crate` declaration_ specifies a dependency on an external crate."
msgstr "_`extern crate` 선언_은 외부 크레이트에 대한 의존성을 명시합니다."

#: src/items/extern-crates.md:23
msgid ""
"The external crate is then bound into the declaring scope as the given "
"[identifier](../identifiers.md) in the [type namespace](../names/"
"namespaces.md)."
msgstr ""
"그러면 외부 크레이트는 선언 범위 내의 [타입 네임스페이스](../names/namespaces.md)에서 "
"주어진 [식별자](../identifiers.md)로 바인딩됩니다."

#: src/items/extern-crates.md:27
msgid ""
"Additionally, if the `extern crate` appears in the crate root, then the "
"crate name is also added to the [extern prelude](../names/preludes.md#extern-"
"prelude), making it automatically in scope in all modules."
msgstr ""
"또한, `extern crate`가 크레이트 루트에 나타나면, 크레이트 이름이 [외부 프렐류드](../names/"
"preludes.md#extern-prelude)에도 추가되어 모든 모듈의 스코프에 자동으로 포함됩니다."

#: src/items/extern-crates.md:31
msgid ""
"The `as` clause can be used to bind the imported crate to a different name."
msgstr "`as` 절은 임포트된 크레이트를 다른 이름으로 바인딩하는 데 사용할 수 있습니다."

#: src/items/extern-crates.md:35
msgid ""
"The external crate is resolved to a specific `soname` at compile time, and a "
"runtime linkage requirement to that `soname` is passed to the linker for "
"loading at runtime. The `soname` is resolved at compile time by scanning the "
"compiler's library path and matching the optional `crate_name` provided "
"against the [`crate_name` attributes](../crates-and-source-files.md#the-"
"crate_name-attribute) that were declared on the external crate when it was "
"compiled. If no `crate_name` is provided, a default `name` attribute is "
"assumed, equal to the [identifier](../identifiers.md) given in the `extern "
"crate` declaration."
msgstr ""
"외부 크레이트는 컴파일 타임에 특정 `soname`으로 해석되며, 해당 `soname`에 대한 "
"런타임 연결 요구 사항은 런타임 로딩을 위해 링커로 전달됩니다. `soname`은 컴파일러의 "
"라이브러리 경로를 스캔하고, 제공된 선택적 `crate_name`과 외부 크레이트가 컴파일될 때 "
"선언된 [`crate_name` 속성](../crates-and-source-files.md#the-crate_name-attribute)을 "
"매칭하여 컴파일 타임에 해석됩니다. `crate_name`이 제공되지 않으면, `extern crate` "
"선언에 주어진 [식별자](../identifiers.md)와 동일한 기본 `name` 속성이 가정됩니다."

#: src/items/extern-crates.md:45
msgid ""
"The `self` crate may be imported which creates a binding to the current "
"crate. In this case the `as` clause must be used to specify the name to bind "
"it to."
msgstr ""
"`self` 크레이트를 임포트하여 현재 크레이트에 대한 바인딩을 생성할 수 있습니다. "
"이 경우 바인딩할 이름을 지정하기 위해 `as` 절을 사용해야 합니다."

#: src/items/extern-crates.md:48
msgid "Three examples of `extern crate` declarations:"
msgstr "`extern crate` 선언의 세 가지 예시:"

#: src/items/extern-crates.md:54
msgid "// equivalent to: extern crate std as std;\n"
msgstr "// extern crate std as std;와 동일합니다.\n"

#: src/items/extern-crates.md:56
msgid "// linking to 'std' under another name\n"
msgstr "// 다른 이름으로 'std'를 링크합니다.\n"

#: src/items/extern-crates.md:61
msgid ""
"When naming Rust crates, hyphens are disallowed. However, Cargo packages may "
"make use of them. In such case, when `Cargo.toml` doesn't specify a crate "
"name, Cargo will transparently replace `-` with `_` (Refer to [RFC 940]"
"(https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-"
"harmful.md) for more details)."
msgstr ""
"러스트 크레이트의 이름을 지을 때 하이픈은 허용되지 않습니다. 그러나 Cargo "
"패키지는 이를 사용할 수 있습니다. 이러한 경우 `Cargo.toml`에서 크레이트 "
"이름을 지정하지 않으면, Cargo는 투명하게 `-`를 `_`로 대체합니다. (자세한 "
"내용은 [RFC 940](https://github.com/rust-lang/rfcs/blob/master/text/0940-"
"hyphens-considered-harmful.md)을 참조하십시오.)"

#: src/items/extern-crates.md:66 src/attributes/diagnostics.md:358
msgid "Here is an example:"
msgstr "예시는 다음과 같습니다:"

#: src/items/extern-crates.md:70
msgid "// Importing the Cargo package hello-world\n"
msgstr "// hello-world Cargo 패키지 임포트\n"

#: src/items/extern-crates.md:71
msgid "// hyphen replaced with an underscore\n"
msgstr "// 하이픈이 밑줄로 대체됨\n"

#: src/items/extern-crates.md:76 src/items/use-declarations.md:348
msgid "Underscore Imports"
msgstr "밑줄 임포트"

#: src/items/extern-crates.md:80
msgid ""
"An external crate dependency can be declared without binding its name in "
"scope by using an underscore with the form `extern crate foo as _`. This may "
"be useful for crates that only need to be linked, but are never referenced, "
"and will avoid being reported as unused."
msgstr ""
"`extern crate foo as _`와 같은 형태로 밑줄을 사용하여 이름을 스코프에 "
"바인딩하지 않고 외부 크레이트 의존성을 선언할 수 있습니다. 이는 링크만 "
"필요하고 참조되지는 않는 크레이트에 유용할 수 있으며, 사용되지 않음으로 "
"보고되는 것을 방지합니다."

#: src/items/extern-crates.md:87
msgid ""
"The [`macro_use` attribute](../macros-by-example.md#the-macro_use-attribute) "
"works as usual and imports the macro names into the [`macro_use` prelude](../"
"names/preludes.md#macro_use-prelude)."
msgstr ""
"[`macro_use` 속성](../macros-by-example.md#the-macro_use-attribute)은 "
"평소와 같이 작동하며 매크로 이름을 [`macro_use` 프렐류드](../names/"
"preludes.md#macro_use-prelude)로 가져옵니다."

#: src/items/extern-crates.md:92
msgid "The `no_link` attribute"
msgstr "`no_link` 속성"

#: src/items/extern-crates.md:94
msgid ""
"The _`no_link` attribute_ may be specified on an `extern crate` item to "
"prevent linking the crate into the output. This is commonly used to load a "
"crate to access only its macros."
msgstr ""
"_`no_link` 속성_은 크레이트가 출력물에 링크되는 것을 방지하기 위해 "
"`extern crate` 아이템에 지정될 수 있습니다. 이는 일반적으로 매크로에만 "
"접근하기 위해 크레이트를 로드할 때 사용됩니다."

#: src/items/use-declarations.md:7
msgid ""
"**<sup>Syntax:</sup>**  \n"
"_UseDeclaration_ :  \n"
"   `use` _UseTree_ `;`"
msgstr ""
"**<sup>구문:</sup>**  \n"
"_Use선언_ :  \n"
"   `use` _Use트리_ `;`"

#: src/items/use-declarations.md:11
msgid ""
"_UseTree_ :  \n"
"      ([_SimplePath_](../paths.md#simple-paths)<sup>?</sup> `::`)<sup>?</"
"sup> `*`  \n"
"   | ([_SimplePath_](../paths.md#simple-paths)<sup>?</sup> `::`)<sup>?</sup> "
"`{` (_UseTree_ ( `,`  _UseTree_ )<sup>\\*</sup> `,`<sup>?</sup>)<sup>?</sup> "
"`}`  \n"
"   | [_SimplePath_](../paths.md#simple-paths) ( `as` ( [IDENTIFIER](../"
"identifiers.md) | `_` ) )<sup>?</sup>"
msgstr ""
"_Use트리_ :  \n"
"      ([_단순경로_](../paths.md#simple-paths)<sup>?</sup> `::`)<sup>?</sup> "
"`*`  \n"
"   | ([_단순경로_](../paths.md#simple-paths)<sup>?</sup> `::`)<sup>?</sup> "
"`{` (_Use트리_ ( `,`  _Use트리_ )<sup>\\*</sup> `,`<sup>?</sup>)<sup>?</sup> "
"`}`  \n"
"   | [_단순경로_](../paths.md#simple-paths) ( `as` ( [식별자](../"
"identifiers.md) | `_` ) )<sup>?</sup>"

#: src/items/use-declarations.md:18
msgid ""
"A _use declaration_ creates one or more local name bindings synonymous with "
"some other [path](../paths.md). Usually a `use` declaration is used to "
"shorten the path required to refer to a module item. These declarations may "
"appear in [modules](modules.md) and [blocks](../expressions/block-expr.md), "
"usually at the top. A `use` declaration is also sometimes called an "
"_import_, or, if it is public, a _re-export_."
msgstr ""
"_use 선언_은 다른 [경로](../paths.md)와 동의어인 하나 이상의 로컬 이름 "
"바인딩을 생성합니다. 일반적으로 `use` 선언은 모듈 아이템을 참조하는 데 "
"필요한 경로를 단축하기 위해 사용됩니다. 이러한 선언은 [모듈](modules.md)과 "
"[블록](../expressions/block-expr.md)에 나타날 수 있으며, 보통 최상단에 "
"위치합니다. `use` 선언은 때때로 _임포트(import)_라고도 불리며, 공개된 "
"경우에는 _재내보내기(re-export)_라고도 합니다."

#: src/items/use-declarations.md:30
msgid "Use declarations support a number of convenient shortcuts:"
msgstr "`use` 선언은 여러 편리한 단축 표기법을 지원합니다:"

#: src/items/use-declarations.md:34
msgid ""
"Simultaneously binding a list of paths with a common prefix, using the brace "
"syntax `use a::b::{c, d, e::f, g::h::i};`"
msgstr ""
"`use a::b::{c, d, e::f, g::h::i};`와 같이 중괄호 구문을 사용하여 공통 "
"접두사를 가진 경로 목록을 동시에 바인딩합니다."

#: src/items/use-declarations.md:39
msgid ""
"Simultaneously binding a list of paths with a common prefix and their common "
"parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`"
msgstr ""
"`use a::b::{self, c, d::e};`와 같이 `self` 키워드를 사용하여 공통 "
"접두사를 가진 경로 목록과 그들의 공통 부모 모듈을 동시에 바인딩합니다."

#: src/items/use-declarations.md:44
msgid ""
"Rebinding the target name as a new local name, using the syntax `use p::q::r "
"as x;`. This can also be used with the last two features: `use a::b::{self "
"as ab, c as abc}`."
msgstr ""
"`use p::q::r as x;` 구문을 사용하여 대상 이름을 새로운 로컬 이름으로 다시 "
"바인딩합니다. 이는 앞의 두 기능과 함께 사용될 수도 있습니다: "
"`use a::b::{self as ab, c as abc}`."

#: src/items/use-declarations.md:50
msgid ""
"Binding all paths matching a given prefix, using the asterisk wildcard "
"syntax `use a::b::*;`."
msgstr ""
"별표 와일드카드 구문인 `use a::b::*;`를 사용하여 주어진 접두사와 일치하는 "
"모든 경로를 바인딩합니다."

#: src/items/use-declarations.md:55
msgid ""
"Nesting groups of the previous features multiple times, such as `use a::b::"
"{self as ab, c, d::{*, e::f}};`"
msgstr ""
"`use a::b::{self as ab, c, d::{*, e::f}};`와 같이 이전 기능들의 그룹을 "
"여러 번 중첩하여 사용합니다."

#: src/items/use-declarations.md:58
msgid "An example of `use` declarations:"
msgstr "`use` 선언의 예:"

#: src/items/use-declarations.md:67
msgid "// use declarations can also exist inside of functions\n"
msgstr "// use 선언은 함수 내부에도 존재할 수 있습니다\n"

#: src/items/use-declarations.md:70
msgid ""
"// Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n"
"    // std::option::Option::None]);'\n"
msgstr ""
"// 'foo(vec![std::option::Option::Some(1.0f64),\n"
"    // std::option::Option::None]);'와 동일합니다.\n"

#: src/items/use-declarations.md:74
msgid "// Both `hash_map` and `HashMap` are in scope.\n"
msgstr "// `hash_map`과 `HashMap` 모두 스코프에 있습니다.\n"

#: src/items/use-declarations.md:83
msgid "`use` Visibility"
msgstr "`use` 가시성"

#: src/items/use-declarations.md:87
msgid ""
"Like items, `use` declarations are private to the containing module, by "
"default. Also like items, a `use` declaration can be public, if qualified by "
"the `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A "
"public `use` declaration can therefore _redirect_ some public name to a "
"different target definition: even a definition with a private canonical "
"path, inside a different module."
msgstr ""
"아이템과 마찬가지로, `use` 선언은 기본적으로 포함하는 모듈에 비공개(private)입니다. 또한 "
"아이템과 마찬가지로 `use` 선언은 `pub` 키워드로 한정되면 공개(public)가 될 수 있습니다. "
"이러한 `use` 선언은 이름을 _다시 내보내기(re-export)_하는 역할을 합니다. 따라서 "
"공개 `use` 선언은 일부 공개 이름을 다른 대상 정의로, 심지어 다른 모듈 내부의 비공개 정규 "
"경로를 가진 정의로 _리디렉션_할 수 있습니다."

#: src/items/use-declarations.md:96
msgid ""
"If a sequence of such redirections form a cycle or cannot be resolved "
"unambiguously, they represent a compile-time error."
msgstr ""
"이러한 리디렉션의 시퀀스가 순환을 형성하거나 모호하지 않게 해석될 수 없는 경우, 컴파일 타임 "
"오류를 나타냅니다."

#: src/items/use-declarations.md:99
msgid "An example of re-exporting:"
msgstr "다시 내보내기(re-exporting)의 예:"

#: src/items/use-declarations.md:116
msgid ""
"In this example, the module `quux` re-exports two public names defined in "
"`foo`."
msgstr "이 예제에서 `quux` 모듈은 `foo`에 정의된 두 개의 공개 이름을 다시 내보냅니다."

#: src/items/use-declarations.md:121
msgid "`use` Paths"
msgstr "`use` 경로"

#: src/items/use-declarations.md:125
msgid ""
"The [paths](../paths.md) that are allowed in a `use` item follow the "
"[_SimplePath_](../paths.md#simple-paths) grammar and are similar to the "
"paths that may be used in an expression. They may create bindings for:"
msgstr ""
"`use` 아이템에서 허용되는 [경로](../paths.md)는 [_단순경로_](../paths.md#simple-paths) "
"문법을 따르며 표현식에서 사용될 수 있는 경로와 유사합니다. 이들은 다음에 대한 바인딩을 "
"생성할 수 있습니다:"

#: src/items/use-declarations.md:128
msgid "Nameable [items](../items.md)"
msgstr "이름을 지을 수 있는 [아이템](../items.md)"

#: src/items/use-declarations.md:129
msgid "[Enum variants](enumerations.md)"
msgstr "[열거형 변형](enumerations.md)"

#: src/items/use-declarations.md:130
msgid "[Built-in types](../types.md)"
msgstr "[내장 타입](../types.md)"

#: src/items/use-declarations.md:131
msgid "[Attributes](../attributes.md)"
msgstr "[속성](../attributes.md)"

#: src/items/use-declarations.md:132 src/names/namespaces.md:51
msgid "[Derive macros](../procedural-macros.md#derive-macros)"
msgstr "[Derive 매크로](../procedural-macros.md#derive-macros)"

#: src/items/use-declarations.md:136
msgid ""
"They cannot import [associated items](associated-items.md), [generic "
"parameters](generics.md), [local variables](../variables.md), paths with "
"[`Self`](../paths.md#self), or [tool attributes](../attributes.md#tool-"
"attributes). More restrictions are described below."
msgstr ""
"[연관 아이템](associated-items.md), [제네릭 매개변수](generics.md), "
"[지역 변수](../variables.md), [`Self`](../paths.md#self)가 포함된 경로, 또는 "
"[도구 속성](../attributes.md#tool-attributes)은 임포트할 수 없습니다. 더 많은 제약 "
"사항은 아래에 설명되어 있습니다."

#: src/items/use-declarations.md:140
msgid ""
"`use` will create bindings for all [namespaces](../names/namespaces.md) from "
"the imported entities, with the exception that a `self` import will only "
"import from the type namespace (as described below). For example, the "
"following illustrates creating bindings for the same name in two namespaces:"
msgstr ""
"`use`는 임포트된 엔티티의 모든 [네임스페이스](../names/namespaces.md)에 대한 "
"바인딩을 생성합니다. 단, `self` 임포트는 타입 네임스페이스에서만 임포트합니다(아래 "
"설명 참조). 예를 들어, 다음은 두 네임스페이스에서 동일한 이름에 대한 바인딩을 생성하는 "
"것을 보여줍니다:"

#: src/items/use-declarations.md:147
msgid "// Imports the `Foo` type and the `Foo` constructor.\n"
msgstr "// `Foo` 타입과 `Foo` 생성자를 임포트합니다.\n"

#: src/items/use-declarations.md:152
msgid "// Uses `Foo` from the value namespace.\n"
msgstr "// 값 네임스페이스에서 `Foo`를 사용합니다.\n"

#: src/items/use-declarations.md:153
msgid "// Uses `Foo` From the type namespace.\n"
msgstr "// 타입 네임스페이스에서 `Foo`를 사용합니다.\n"

#: src/items/use-declarations.md:159
msgid ""
"**Edition differences**: In the 2015 edition, `use` paths are relative to "
"the crate root. For example:"
msgstr ""
"**에디션 차이**: 2015 에디션에서 `use` 경로는 크레이트 루트에 상대적입니다. "
"예를 들어:"

#: src/items/use-declarations.md:168
msgid "// Resolves `foo` from the crate root.\n"
msgstr "// 크레이트 루트에서 `foo`를 확인합니다.\n"

#: src/items/use-declarations.md:170
msgid "// The `::` prefix explicitly resolves `foo`\n"
msgstr "// `::` 접두사는 명시적으로 `foo`를 확인합니다.\n"

#: src/items/use-declarations.md:171
msgid "// from the crate root.\n"
msgstr "// 크레이트 루트로부터.\n"

#: src/items/use-declarations.md:178
msgid ""
"The 2015 edition does not allow use declarations to reference the [extern "
"prelude](../names/preludes.md#extern-prelude). Thus, [`extern crate`](extern-"
"crates.md) declarations are still required in 2015 to reference an external "
"crate in a `use` declaration. Beginning with the 2018 edition, `use` "
"declarations can specify an external crate dependency the same way `extern "
"crate` can."
msgstr ""
"2015 에디션은 use 선언이 [extern 프렐류드](../names/preludes.md#extern-prelude)를 "
"참조하는 것을 허용하지 않습니다. 따라서 2015 에디션에서 use 선언으로 "
"외부 크레이트를 참조하려면 여전히 [`extern crate`](extern-crates.md) "
"선언이 필요합니다. 2018 에디션부터는 `use` 선언에서 `extern crate`와 "
"동일한 방식으로 외부 크레이트 의존성을 지정할 수 있습니다."

#: src/items/use-declarations.md:184
msgid "`as` renames"
msgstr "`as`를 이용한 이름 변경"

#: src/items/use-declarations.md:186
msgid ""
"The `as` keyword can be used to change the name of an imported entity. For "
"example:"
msgstr ""
"`as` 키워드는 임포트된 엔티티의 이름을 변경하는 데 사용될 수 있습니다. "
"예를 들어:"

#: src/items/use-declarations.md:190
msgid "// Creates a non-public alias `bar` for the function `foo`.\n"
msgstr "// 함수 `foo`에 대한 비공개 별칭 `bar`를 생성합니다.\n"

#: src/items/use-declarations.md:200
msgid "Brace syntax"
msgstr "중괄호 구문"

#: src/items/use-declarations.md:204
msgid ""
"Braces can be used in the last segment of the path to import multiple "
"entities from the previous segment, or, if there are no previous segments, "
"from the current scope. Braces can be nested, creating a tree of paths, "
"where each grouping of segments is logically combined with its parent to "
"create a full path."
msgstr ""
"중괄호는 경로의 마지막 세그먼트에서 이전 세그먼트로부터 여러 엔티티를 "
"임포트하거나, 이전 세그먼트가 없는 경우 현재 스코프에서 임포트하는 데 "
"사용될 수 있습니다. 중괄호는 중첩될 수 있으며, 각 세그먼트 그룹이 "
"부모와 논리적으로 결합되어 전체 경로를 형성하는 경로 트리를 생성합니다."

#: src/items/use-declarations.md:208
msgid ""
"// Creates bindings to:\n"
"// - `std::collections::BTreeSet`\n"
"// - `std::collections::hash_map`\n"
"// - `std::collections::hash_map::HashMap`\n"
msgstr ""
"// 다음에 대한 바인딩을 생성합니다:\n"
"// - `std::collections::BTreeSet`\n"
"// - `std::collections::hash_map`\n"
"// - `std::collections::hash_map::HashMap`\n"
"// 다음에 대한 바인딩을 생성합니다:\n"
"// - `std::collections::BTreeSet`\n"
"// - `std::collections::hash_map`\n"
"// - `std::collections::hash_map::HashMap`\n"

#: src/items/use-declarations.md:217
msgid ""
"An empty brace does not import anything, though the leading path is "
"validated that it is accessible."
msgstr ""
"빈 중괄호는 아무것도 임포트하지 않지만, 선행 경로가 접근 가능한지는 "
"확인됩니다."

#: src/items/use-declarations.md:222
msgid ""
"**Edition differences**: In the 2015 edition, paths are relative to the "
"crate root, so an import such as `use {foo, bar};` will import the names "
"`foo` and `bar` from the crate root, whereas starting in 2018, those names "
"are relative to the current scope."
msgstr ""
"**에디션 차이**: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, "
"`use {foo, bar};`와 같은 임포트는 크레이트 루트에서 `foo`와 `bar`라는 "
"이름을 임포트합니다. 반면 2018 에디션부터는 해당 이름들이 현재 스코프에 "
"상대적입니다."

#: src/items/use-declarations.md:226
msgid "`self` imports"
msgstr "`self` 임포트"

#: src/items/use-declarations.md:230
msgid ""
"The keyword `self` may be used within [brace syntax](#brace-syntax) to "
"create a binding of the parent entity under its own name."
msgstr ""
"`self` 키워드는 [중괄호 구문](#brace-syntax) 내에서 부모 엔티티를 자신의 "
"이름으로 바인딩하는 데 사용될 수 있습니다."

#: src/items/use-declarations.md:238
msgid "// Creates a binding for `stuff` and `foo`.\n"
msgstr "// `stuff`와 `foo`에 대한 바인딩을 생성합니다.\n"

#: src/items/use-declarations.md:250
msgid ""
"`self` only creates a binding from the [type namespace](../names/"
"namespaces.md) of the parent entity. For example, in the following, only the "
"`foo` mod is imported:"
msgstr ""
"`self`는 부모 엔티티의 [타입 네임스페이스](../names/namespaces.md)에서만 "
"바인딩을 생성합니다. 예를 들어, 다음 예시에서는 `foo` 모듈만 임포트됩니다."

#: src/items/use-declarations.md:258
msgid ""
"// This only imports the module `foo`. The function `foo` lives in\n"
"// the value namespace and is not imported.\n"
msgstr ""
"// 이는 `foo` 모듈만 임포트합니다. `foo` 함수는 값 네임스페이스에 "
"존재하므로 임포트되지 않습니다.\n"

#: src/items/use-declarations.md:264
msgid "//~ ERROR `foo` is a module\n"
msgstr "//~ 오류: `foo`는 모듈입니다.\n"

#: src/items/use-declarations.md:268
msgid ""
"**Note**: `self` may also be used as the first segment of a path. The usage "
"of `self` as the first segment and inside a `use` brace is logically the "
"same; it means the current module of the parent segment, or the current "
"module if there is no parent segment. See [`self`](../paths.md#self) in the "
"paths chapter for more information on the meaning of a leading `self`."
msgstr ""
"**참고**: `self`는 경로의 첫 번째 세그먼트로도 사용될 수 있습니다. `self`를 첫 번째 "
"세그먼트로 사용하는 것과 `use` 중괄호 내부에서 사용하는 것은 논리적으로 동일합니다. 이는 "
"부모 세그먼트의 현재 모듈을 의미하거나, 부모 세그먼트가 없는 경우 현재 모듈을 의미합니다. "
"선행 `self`의 의미에 대한 자세한 내용은 경로 챕터의 [`self`](../paths.md#self)를 참조하십시오."

#: src/items/use-declarations.md:274
msgid "Glob imports"
msgstr "글로브 임포트"

#: src/items/use-declarations.md:278
msgid ""
"The `*` character may be used as the last segment of a `use` path to import "
"all importable entities from the entity of the preceding segment. For "
"example:"
msgstr ""
"`*` 문자는 `use` 경로의 마지막 세그먼트로 사용하여 이전 세그먼트의 엔티티에서 임포트 "
"가능한 모든 엔티티를 임포트하는 데 사용할 수 있습니다. 예를 들어:"

#: src/items/use-declarations.md:282
msgid "// Creates a non-public alias to `bar`.\n"
msgstr "// `bar`에 대한 비공개 별칭을 생성합니다.\n"

#: src/items/use-declarations.md:292
msgid ""
"// Creates local aliases to `V1` and `V2`\n"
"        // of the `Example` enum.\n"
msgstr ""
"// `Example` 열거형의 `V1`과 `V2`에 대한\n"
"        // 지역 별칭을 생성합니다.\n"

#: src/items/use-declarations.md:302
msgid ""
"Items and named imports are allowed to shadow names from glob imports in the "
"same [namespace](../names/namespaces.md). That is, if there is a name "
"already defined by another item in the same namespace, the glob import will "
"be shadowed. For example:"
msgstr ""
"아이템과 명명된 임포트는 같은 [네임스페이스](../names/namespaces.md)에서 글로브 임포트로 "
"가져온 이름을 가리는(shadow) 것이 허용됩니다. 즉, 같은 네임스페이스에 다른 아이템에 의해 "
"이미 정의된 이름이 있다면, 글로브 임포트는 가려집니다. 예를 들어:"

#: src/items/use-declarations.md:307
msgid ""
"// This creates a binding to the `clashing::Foo` tuple struct\n"
"// constructor, but does not import its type because that would\n"
"// conflict with the `Foo` struct defined here.\n"
"//\n"
"// Note that the order of definition here is unimportant.\n"
msgstr ""
"// 이것은 `clashing::Foo` 튜플 구조체 생성자에 대한 바인딩을 생성하지만,\n"
"// 여기에 정의된 `Foo` 구조체와 충돌하기 때문에 그 타입은 임포트하지\n"
"// 않습니다.\n"
"//\n"
"// 여기서 정의 순서는 중요하지 않음에 유의하세요.\n"

#: src/items/use-declarations.md:318
msgid "// Uses the constructor from `clashing::Foo`.\n"
msgstr "// `clashing::Foo`의 생성자를 사용합니다.\n"

#: src/items/use-declarations.md:320
msgid ""
"// The struct expression uses the type from\n"
"    // the `Foo` struct defined above.\n"
msgstr ""
"// 구조체 표현식은 위에서 정의된\n"
"    // `Foo` 구조체의 타입을 사용합니다.\n"

#: src/items/use-declarations.md:323
msgid "// `Bar` is also in scope due to the glob import.\n"
msgstr "// 글로브 임포트로 인해 `Bar`도 스코프에 있습니다.\n"

#: src/items/use-declarations.md:335
msgid "`*` cannot be used as the first or intermediate segments."
msgstr "`*`는 첫 번째 또는 중간 세그먼트로 사용할 수 없습니다."

#: src/items/use-declarations.md:339
msgid ""
"`*` cannot be used to import a module's contents into itself (such as `use "
"self::*;`)."
msgstr ""
"`*`는 모듈의 내용을 자기 자신에게 임포트하는 데 사용할 수 없습니다(예: `use "
"self::*;`)."

#: src/items/use-declarations.md:343
msgid ""
"**Edition differences**: In the 2015 edition, paths are relative to the "
"crate root, so an import such as `use *;` is valid, and it means to import "
"everything from the crate root. This cannot be used in the crate root itself."
msgstr ""
"**에디션 차이**: 2015 에디션에서 경로는 크레이트 루트에 상대적이므로, `use *;`와 "
"같은 임포트는 유효하며 크레이트 루트의 모든 것을 임포트한다는 의미입니다. 이는 크레이트 "
"루트 자체에서는 사용할 수 없습니다."

#: src/items/use-declarations.md:352
msgid ""
"Items can be imported without binding to a name by using an underscore with "
"the form `use path as _`. This is particularly useful to import a trait so "
"that its methods may be used without importing the trait's symbol, for "
"example if the trait's symbol may conflict with another symbol. Another "
"example is to link an external crate without importing its name."
msgstr ""
"아이템은 `use path as _` 형식을 사용하여 이름에 바인딩하지 않고 임포트할 수 있습니다. "
"이는 트레잇의 심볼을 임포트하지 않고 메서드를 사용하려 할 때(예: 트레잇 심볼이 다른 "
"심볼과 충돌할 수 있는 경우) 특히 유용합니다. 다른 예로는 이름을 임포트하지 않고 외부 "
"크레이트를 링크하는 경우가 있습니다."

#: src/items/use-declarations.md:360
msgid ""
"Asterisk glob imports will import items imported with `_` in their "
"unnameable form."
msgstr ""
"별표 글로브 임포트는 `_`로 임포트된 아이템을 이름 지을 수 없는 형태로 임포트합니다."

#: src/items/use-declarations.md:373
msgid "// Underscore import avoids name conflict with this item.\n"
msgstr "// 밑줄 임포트는 이 아이템과의 이름 충돌을 방지합니다.\n"

#: src/items/use-declarations.md:383
msgid ""
"The unique, unnameable symbols are created after macro expansion so that "
"macros may safely emit multiple references to `_` imports. For example, the "
"following should not produce an error:"
msgstr ""
"고유하고 이름 지을 수 없는 심볼은 매크로 확장 후에 생성되므로, 매크로는 안전하게 "
"`_` 임포트에 대한 다중 참조를 내보낼 수 있습니다. 예를 들어, 다음 코드는 오류를 "
"생성하지 않아야 합니다:"

#: src/items/use-declarations.md:392
msgid ""
"// This expands to:\n"
"// use std as _;\n"
"// use std as _;\n"
msgstr ""
"// 다음과 같이 확장됩니다:\n"
"// use std as _;\n"
"// use std as _;\n"

#: src/items/use-declarations.md:400 src/items/enumerations.md:207
msgid "Restrictions"
msgstr "제약 사항"

#: src/items/use-declarations.md:402
msgid "The following are restrictions for valid `use` declarations:"
msgstr "다음은 유효한 `use` 선언에 대한 제약 사항입니다:"

#: src/items/use-declarations.md:406
msgid ""
"`use crate;` must use `as` to define the name to which to bind the crate "
"root."
msgstr ""
"`use crate;`는 크레이트 루트를 바인딩할 이름을 정의하기 위해 반드시 `as`를 "
"사용해야 합니다."

#: src/items/use-declarations.md:410
msgid ""
"`use {self};` is an error; there must be a leading segment when using `self`."
msgstr ""
"`use {self};`는 오류입니다. `self`를 사용할 때는 반드시 선행 세그먼트가 "
"있어야 합니다."

#: src/items/use-declarations.md:414
msgid ""
"As with any item definition, `use` imports cannot create duplicate bindings "
"of the same name in the same namespace in a module or block."
msgstr ""
"다른 아이템 정의와 마찬가지로, `use` 임포트는 모듈이나 블록 내의 동일한 "
"네임스페이스에서 같은 이름으로 중복 바인딩을 생성할 수 없습니다."

#: src/items/use-declarations.md:418
msgid ""
"`use` paths with `$crate` are not allowed in a [`macro_rules`](../macros-by-"
"example.md) expansion."
msgstr ""
"`$crate`를 포함한 `use` 경로는 [`macro_rules`](../macros-by-example.md) "
"확장 내에서 허용되지 않습니다."

#: src/items/use-declarations.md:422
msgid ""
"`use` paths cannot refer to enum variants through a [type alias](type-"
"aliases.md). For example:"
msgstr ""
"`use` 경로는 [타입 별칭](type-aliases.md)을 통해 열거형 변형을 참조할 수 "
"없습니다. 예를 들어:"

#: src/items/use-declarations.md:429
msgid "//~ OK\n"
msgstr "//~ OK\n"

#: src/items/use-declarations.md:430 src/patterns.md:379 src/patterns.md:380
#: src/patterns.md:381 src/patterns.md:393
msgid "//~ ERROR\n"
msgstr "//~ 오류\n"

#: src/items/use-declarations.md:435
msgid "Ambiguities"
msgstr "모호성"

#: src/items/use-declarations.md:437
msgid "**Note**: This section is incomplete."
msgstr "**참고**: 이 섹션은 미완성입니다."

#: src/items/use-declarations.md:441
msgid ""
"Some situations are an error when there is an ambiguity as to which name a "
"`use` declaration refers. This happens when there are two name candidates "
"that do not resolve to the same entity."
msgstr ""
"`use` 선언이 어떤 이름을 참조하는지 모호한 경우 오류가 발생하는 상황이 "
"있습니다. 이는 동일한 엔티티로 해석되지 않는 두 개의 이름 후보가 있을 때 "
"발생합니다."

#: src/items/use-declarations.md:445
msgid ""
"Glob imports are allowed to import conflicting names in the same namespace "
"as long as the name is not used. For example:"
msgstr ""
"글로브(Glob) 임포트는 해당 이름이 사용되지 않는 한 동일한 네임스페이스에서 "
"충돌하는 이름들을 임포트하는 것이 허용됩니다. 예를 들어:"

#: src/items/use-declarations.md:458
msgid "//~ OK, no name conflict.\n"
msgstr "//~ OK, 이름 충돌 없음.\n"

#: src/items/use-declarations.md:461
msgid ""
"// This would be an error, due to the ambiguity.\n"
"    //let x = Qux;\n"
msgstr ""
"// 이는 모호성으로 인해 오류가 됩니다.\n"
"    //let x = Qux;\n"

#: src/items/use-declarations.md:466
msgid ""
"Multiple glob imports are allowed to import the same name, and that name is "
"allowed to be used, if the imports are of the same item (following re-"
"exports). The visibility of the name is the maximum visibility of the "
"imports. For example:"
msgstr ""
"여러 글로브 임포트가 동일한 이름을 임포트할 수 있으며, 임포트된 항목들이 "
"(재내보내기를 거쳐) 동일한 아이템인 경우 해당 이름을 사용할 수 있습니다. "
"이름의 가시성은 임포트된 것들 중 최대 가시성을 가집니다. 예를 들어:"

#: src/items/use-declarations.md:476
msgid ""
"// These both import the same `Qux`. The visibility of `Qux`\n"
"// is `pub` because that is the maximum visibility between\n"
"// these two `use` declarations.\n"
msgstr ""
"// 이 둘은 모두 동일한 `Qux`를 임포트합니다. `Qux`의 가시성은 이 두 `use` "
"선언 사이의 최대 가시성인 `pub`이 됩니다.\n"

#: src/items/functions.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Function_ :  \n"
"   _FunctionQualifiers_ `fn` [IDENTIFIER](../"
"identifiers.md) [_GenericParams_](generics.md)<sup>?</sup>  \n"
"      `(` _FunctionParameters_<sup>?</sup> `)`  \n"
"      _FunctionReturnType_<sup>?</sup> [_WhereClause_](generics.md#where-"
"clauses)<sup>?</sup>  \n"
"      ( [_BlockExpression_](../expressions/block-expr.md) | `;` )"
msgstr ""
"**<sup>구문</sup>**  \n"
"_함수_ :  \n"
"   _함수한정자_ `fn` [식별자](../identifiers.md) [_제네릭파라미터_](generics.md)<sup>?</sup>  \n"
"      `(` _함수매개변수_<sup>?</sup> `)`  \n"
"      _함수반환타입_<sup>?</sup> [_Where절_](generics.md#where-clauses)<sup>?</sup>  \n"
"      ( [_블록표현식_](../expressions/block-expr.md) | `;` )"

#: src/items/functions.md:14
msgid ""
"_FunctionQualifiers_ :  \n"
"   `const`<sup>?</sup> `async`[^async-edition]<sup>?</sup> _ItemSafety_<sup>?"
"</sup>[^extern-qualifiers] (`extern` _Abi_<sup>?</sup>)<sup>?</sup>"
msgstr ""
"_함수한정자_ :  \n"
"   `const`<sup>?</sup> `async`[^async-edition]<sup>?</sup> _아이템안전성_<sup>?</sup>[^extern-qualifiers] (`extern` _Abi_<sup>?</sup>)<sup>?</sup>"

#: src/items/functions.md:17
msgid ""
"_ItemSafety_ :  \n"
"   `safe`[^extern-safe] | `unsafe`"
msgstr ""
"_아이템안전성_ :  \n"
"   `safe`[^extern-safe] | `unsafe`"

#: src/items/functions.md:20
msgid ""
"_Abi_ :  \n"
"   [STRING_LITERAL](../tokens.md#string-literals) | [RAW_STRING_LITERAL](../"
"tokens.md#raw-string-literals)"
msgstr ""
"_Abi_ :  \n"
"   [문자열_리터럴](../tokens.md#string-literals) | [원시_문자열_리터럴](../tokens.md#raw-string-literals)"

#: src/items/functions.md:23
msgid ""
"_FunctionParameters_ :  \n"
"      _SelfParam_ `,`<sup>?</sup>  \n"
"   | (_SelfParam_ `,`)<sup>?</sup> _FunctionParam_ (`,` "
"_FunctionParam_)<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_함수매개변수_ :  \n"
"      _Self매개변수_ `,`<sup>?</sup>  \n"
"   | (_Self매개변수_ `,`)<sup>?</sup> _함수매개변수단일_ (`,` _함수매개변수단일_)<sup>\\*</sup> `,`<sup>?</sup>"

#: src/items/functions.md:27
msgid ""
"_SelfParam_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> ( _ShorthandSelf_ | "
"_TypedSelf_ )"
msgstr ""
"_Self매개변수_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> ( _단축Self_ | "
"_타입Self_ )"

#: src/items/functions.md:30
msgid ""
"_ShorthandSelf_ :  \n"
"    (`&` | `&` [_Lifetime_](../trait-bounds.md))<sup>?</sup> `mut`<sup>?</"
"sup> `self`"
msgstr ""
"_단축Self_ :  \n"
"    (`&` | `&` [_라이프타임_](../trait-bounds.md))<sup>?</sup> `mut`<sup>?</"
"sup> `self`"

#: src/items/functions.md:33
msgid ""
"_TypedSelf_ :  \n"
"   `mut`<sup>?</sup> `self` `:` [_Type_](../types.md#type-expressions)"
msgstr ""
"_타입Self_ :  \n"
"   `mut`<sup>?</sup> `self` `:` [_타입_](../types.md#type-expressions)"

#: src/items/functions.md:36
msgid ""
"_FunctionParam_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> "
"( _FunctionParamPattern_ | `...` | [_Type_](../types.md#type-expressions) "
"[^fn-param-2015] )"
msgstr ""
"_함수매개변수단일_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> "
"( _함수매개변수패턴_ | `...` | [_타입_](../types.md#type-expressions) "
"[^fn-param-2015] )"

#: src/items/functions.md:41
msgid ""
"_FunctionParamPattern_ :  \n"
"   [_PatternNoTopAlt_](../patterns.md) `:` ( [_Type_](../types.md#type-"
"expressions) | `...` )"
msgstr ""
"_함수매개변수패턴_ :  \n"
"   [_최상위대안없는패턴_](../patterns.md) `:` ( [_타입_](../types.md#type-"
"expressions) | `...` )"

#: src/items/functions.md:44
msgid ""
"_FunctionReturnType_ :  \n"
"   `->` [_Type_](../types.md#type-expressions)"
msgstr ""
"_함수반환타입_ :  \n"
"   `->` [_타입_](../types.md#type-expressions)"

#: src/items/functions.md:47 src/expressions/closure-expr.md:20
msgid "The `async` qualifier is not allowed in the 2015 edition."
msgstr "`async` 한정자는 2015 에디션에서 허용되지 않습니다."

#: src/items/functions.md:49
msgid ""
"The `safe` function qualifier is only allowed semantically within `extern` "
"blocks."
msgstr ""
"`safe` 함수 한정자는 시맨틱적으로 `extern` 블록 내에서만 허용됩니다."

#: src/items/functions.md:52
msgid ""
"_Relevant to editions earlier than Rust 2024_: Within `extern` blocks, the "
"`safe` or `unsafe` function qualifier is only allowed when the `extern` is "
"qualified as `unsafe`."
msgstr ""
"_Rust 2024 이전 에디션 관련_: `extern` 블록 내에서, `safe` 또는 `unsafe` 함수 "
"한정자는 `extern`이 `unsafe`로 한정될 때만 허용됩니다."

#: src/items/functions.md:56
msgid ""
"Function parameters with only a type are only allowed in an associated "
"function of a [trait item](traits.md) in the 2015 edition."
msgstr ""
"타입만 있는 함수 매개변수는 2015 에디션에서 [트레잇 아이템](traits.md)의 연관 "
"함수에서만 허용됩니다."

#: src/items/functions.md:61
msgid ""
"A _function_ consists of a [block](../expressions/block-expr.md) (that's the "
"_body_ of the function), along with a name, a set of parameters, and an "
"output type. Other than a name, all these are optional."
msgstr ""
"_함수_는 [블록](../expressions/block-expr.md)(함수의 _본문_)과 이름, 매개변수 집합, "
"출력 타입으로 구성됩니다. 이름을 제외한 나머지는 모두 선택 사항입니다."

#: src/items/functions.md:67
msgid ""
"Functions are declared with the keyword `fn` which defines the given name in "
"the [value namespace](../names/namespaces.md) of the module or block where "
"it is located."
msgstr ""
"함수는 `fn` 키워드로 선언되며, 이는 해당 함수가 위치한 모듈이나 블록의 [값 네임스페이스](../names/namespaces.md)에 "
"주어진 이름을 정의합니다."

#: src/items/functions.md:71
msgid ""
"Functions may declare a set of _input_ [_variables_](../variables.md) as "
"parameters, through which the caller passes arguments into the function, and "
"the _output_ [_type_](../types.md#type-expressions) of the value the "
"function will return to its caller on completion."
msgstr ""
"함수는 호출자가 함수에 인수를 전달하는 _입력_ [_변수_](../variables.md) 집합을 매개변수로 "
"선언할 수 있으며, 함수가 완료될 때 호출자에게 반환할 값의 _출력_ [_타입_](../types.md#type-expressions)을 "
"선언할 수 있습니다."

#: src/items/functions.md:75
msgid ""
"If the output type is not explicitly stated, it is the [unit type](../types/"
"tuple.md)."
msgstr ""
"출력 타입이 명시적으로 지정되지 않은 경우, [유닛 타입](../types/tuple.md)입니다."

#: src/items/functions.md:79
msgid ""
"When referred to, a _function_ yields a first-class _value_ of the "
"corresponding zero-sized [_function item type_](../types/function-item.md), "
"which when called evaluates to a direct call to the function."
msgstr ""
"참조될 때, _함수_는 해당 0 크기 [_함수 아이템 타입_](../types/function-item.md)의 "
"일급(first-class) _값_을 산출합니다, "
"호출될 때 함수에 대한 직접 호출로 평가됩니다."

#: src/items/functions.md:81
msgid "For example, this is a simple function:"
msgstr "예를 들어, 이것은 간단한 함수입니다:"

#: src/items/functions.md:90
msgid ""
"The `safe` function is semantically only allowed when used in an [`extern` "
"block](external-blocks.md)."
msgstr ""
"`safe` 함수는 시맨틱적으로 [`extern` 블록](external-blocks.md)에서 사용될 때만 "
"허용됩니다."

#: src/items/functions.md:94
msgid "Function parameters"
msgstr "함수 매개변수"

#: src/items/functions.md:98
msgid ""
"Function parameters are irrefutable [patterns](../patterns.md), so any "
"pattern that is valid in an else-less `let` binding is also valid as a "
"parameter:"
msgstr ""
"함수 매개변수는 반박 불가능한(irrefutable) [패턴](../patterns.md)이므로, `else` 없는 "
"`let` 바인딩에서 유효한 모든 패턴은 매개변수로도 유효합니다:"

#: src/items/functions.md:107
msgid ""
"If the first parameter is a _SelfParam_, this indicates that the function is "
"a [method](associated-items.md#methods)."
msgstr ""
"첫 번째 매개변수가 _Self매개변수_이면, 이는 해당 함수가 [메서드](associated-items.md#methods)임을 "
"나타냅니다."

#: src/items/functions.md:112
msgid ""
"Functions with a self parameter may only appear as an [associated function]"
"(associated-items.md#associated-functions-and-methods) in a [trait]"
"(traits.md) or [implementation](implementations.md)."
msgstr ""
"self 매개변수가 있는 함수는 [트레잇](traits.md)이나 [구현](implementations.md)의 "
"[연관 함수](associated-items.md#associated-functions-and-methods)로만 "
"나타날 수 있습니다."

#: src/items/functions.md:117
msgid ""
"A parameter with the `...` token indicates a [variadic function](external-"
"blocks.md#variadic-functions), and may only be used as the last parameter of "
"an [external block](external-blocks.md) function. The variadic parameter may "
"have an optional identifier, such as `args: ...`."
msgstr ""
"`...` 토큰이 있는 매개변수는 [가변 인자 함수](external-blocks.md#variadic-functions)임을 "
"나타내며, 오직 [외부 블록](external-blocks.md) 함수의 마지막 매개변수로만 "
"사용될 수 있습니다. 가변 인자 매개변수는 `args: ...`와 같이 선택적인 "
"식별자를 가질 수 있습니다."

#: src/items/functions.md:123
msgid "Function body"
msgstr "함수 본문"

#: src/items/functions.md:127
msgid ""
"The body block of a function is conceptually wrapped in another block that "
"first binds the argument patterns and then `return`s the value of the "
"function's body. This means that the tail expression of the block, if "
"evaluated, ends up being returned to the caller. As usual, an explicit "
"return expression within the body of the function will short-cut that "
"implicit return, if reached."
msgstr ""
"함수의 본문 블록은 개념적으로 인자 패턴을 먼저 바인딩한 다음 함수 본문의 "
"값을 `return`하는 또 다른 블록으로 감싸져 있습니다. 이는 블록의 꼬리 "
"표현식이 평가될 경우 결국 호출자에게 반환됨을 의미합니다. 평소와 같이, "
"함수 본문 내의 명시적인 return 표현식은 도달할 경우 해당 암시적 반환을 "
"생략합니다."

#: src/items/functions.md:133
msgid "For example, the function above behaves as if it was written as:"
msgstr ""
"예를 들어, 위의 함수는 마치 다음과 같이 작성된 것처럼 동작합니다:"

#: src/items/functions.md:137
msgid "// argument_0 is the actual first argument passed from the caller\n"
msgstr "// argument_0은 호출자로부터 전달된 실제 첫 번째 인자입니다.\n"

#: src/items/functions.md:146
msgid ""
"Functions without a body block are terminated with a semicolon. This form "
"may only appear in a [trait](traits.md) or [external block](external-"
"blocks.md)."
msgstr ""
"본문 블록이 없는 함수는 세미콜론으로 종료됩니다. 이러한 형식은 "
"[트레잇](traits.md)이나 [외부 블록](external-blocks.md)에서만 나타날 수 "
"있습니다."

#: src/items/functions.md:151
msgid "Generic functions"
msgstr "제네릭 함수"

#: src/items/functions.md:155
msgid ""
"A _generic function_ allows one or more _parameterized types_ to appear in "
"its signature. Each type parameter must be explicitly declared in an angle-"
"bracket-enclosed and comma-separated list, following the function name."
msgstr ""
"_제네릭 함수_는 하나 이상의 _매개변수화된 타입_이 해당 시그니처에 나타날 "
"수 있도록 합니다. 각 타입 매개변수는 함수 이름 뒤에 오는 꺾쇠괄호로 "
"둘러싸이고 쉼표로 구분된 목록에 명시적으로 선언되어야 합니다."

#: src/items/functions.md:160
msgid "// foo is generic over A and B\n"
msgstr "// foo는 A와 B에 대해 제네릭합니다.\n"

#: src/items/functions.md:168
msgid ""
"Inside the function signature and body, the name of the type parameter can "
"be used as a type name."
msgstr ""
"함수 시그니처와 본문 내부에서, 타입 매개변수의 이름은 타입 이름으로 "
"사용될 수 있습니다."

#: src/items/functions.md:173
msgid ""
"[Trait](traits.md) bounds can be specified for type parameters to allow "
"methods with that trait to be called on values of that type. This is "
"specified using the `where` syntax:"
msgstr ""
"타입 매개변수에 대해 [트레잇](traits.md) 바운드를 지정하여 해당 트레잇의 "
"메서드를 해당 타입의 값에 대해 호출할 수 있도록 할 수 있습니다. 이는 "
"`where` 구문을 사용하여 지정됩니다:"

#: src/items/functions.md:185
msgid ""
"When a generic function is referenced, its type is instantiated based on the "
"context of the reference. For example, calling the `foo` function here:"
msgstr ""
"제네릭 함수가 참조될 때, 그 타입은 참조의 컨텍스트에 따라 인스턴스화됩니다. "
"예를 들어, 여기서 `foo` 함수를 호출하면:"

#: src/items/functions.md:192
msgid "// details elided\n"
msgstr "// 세부 사항 생략\n"

#: src/items/functions.md:198
msgid "will instantiate type parameter `T` with `i32`."
msgstr "타입 매개변수 `T`를 `i32`로 인스턴스화할 것입니다."

#: src/items/functions.md:202
msgid ""
"The type parameters can also be explicitly supplied in a trailing [path](../"
"paths.md) component after the function name. This might be necessary if "
"there is not sufficient context to determine the type parameters. For "
"example, `mem::size_of::<u32>() == 4`."
msgstr ""
"타입 매개변수는 함수 이름 뒤의 후행 [경로](../paths.md) 구성 요소에 "
"명시적으로 제공될 수도 있습니다. 이는 타입 매개변수를 결정하기 위한 "
"컨텍스트가 충분하지 않은 경우 필요할 수 있습니다. 예를 들어, "
"`mem::size_of::<u32>() == 4`와 같습니다."

#: src/items/functions.md:209
msgid "Extern function qualifier"
msgstr "외부 함수 한정자"

#: src/items/functions.md:213
msgid ""
"The `extern` function qualifier allows providing function _definitions_ that "
"can be called with a particular ABI:"
msgstr ""
"`extern` 함수 한정자는 특정 ABI로 호출될 수 있는 함수 _정의_를 제공할 수 "
"있게 합니다:"

#: src/items/functions.md:218 src/items/functions.md:229
msgid "\"ABI\""
msgstr "\"ABI\""

#: src/items/functions.md:223
msgid ""
"These are often used in combination with [external block](external-"
"blocks.md) items which provide function _declarations_ that can be used to "
"call functions without providing their _definition_:"
msgstr ""
"이들은 종종 함수의 _정의_를 제공하지 않고도 함수를 호출할 수 있게 해주는 "
"함수 _선언_을 제공하는 [외부 블록](external-blocks.md) 아이템과 결합되어 "
"사용됩니다."

#: src/items/functions.md:230 src/items/functions.md:231
msgid "/* no body */"
msgstr "/* 본문 없음 */"

#: src/items/functions.md:239
msgid ""
"When `\"extern\" Abi?*` is omitted from `FunctionQualifiers` in function "
"items, the ABI `\"Rust\"` is assigned. For example:"
msgstr ""
"함수 아이템의 `FunctionQualifiers`에서 `\"extern\" Abi?*`가 생략되면, "
"`\"Rust\"` ABI가 할당됩니다. 예를 들어:"

#: src/items/functions.md:246 src/items/functions.md:277
#: src/expressions/block-expr.md:209
msgid "is equivalent to:"
msgstr "다음과 동일합니다:"

#: src/items/functions.md:249 src/expressions/call-expr.md:41
msgid "\"Rust\""
msgstr "\"Rust\""

#: src/items/functions.md:254
msgid ""
"Functions can be called by foreign code, and using an ABI that differs from "
"Rust allows, for example, to provide functions that can be called from other "
"programming languages like C:"
msgstr ""
"함수는 외부 코드에 의해 호출될 수 있으며, Rust와 다른 ABI를 사용하면 C와 같은 다른 "
"프로그래밍 언어에서 호출할 수 있는 함수를 제공할 수 있습니다:"

#: src/items/functions.md:259
msgid "// Declares a function with the \"C\" ABI\n"
msgstr "// \"C\" ABI를 가진 함수를 선언합니다.\n"

#: src/items/functions.md:260 src/items/functions.md:280
#: src/items/functions.md:281 src/items/external-blocks.md:198
#: src/types/never.md:31 src/inline-assembly.md:354 src/inline-assembly.md:359
#: src/inline-assembly.md:494 src/inline-assembly.md:509
#: src/inline-assembly.md:916 src/inline-assembly.md:921
#: src/inline-assembly.md:946 src/inline-assembly.md:959
#: src/inline-assembly.md:969 src/abi.md:74
msgid "\"C\""
msgstr "\"C\""

#: src/items/functions.md:261
msgid "// Declares a function with the \"stdcall\" ABI\n"
msgstr "// \"stdcall\" ABI를 가진 함수를 선언합니다.\n"

#: src/items/functions.md:263 src/items/external-blocks.md:125
#: src/items/external-blocks.md:495
msgid "\"x86\""
msgstr "\"x86\""

#: src/items/functions.md:264 src/items/external-blocks.md:127
#: src/items/external-blocks.md:497
msgid "\"stdcall\""
msgstr "\"stdcall\""

#: src/items/functions.md:269
msgid ""
"Just as with [external block](external-blocks.md), when the `extern` keyword "
"is used and the `\"ABI\"` is omitted, the ABI used defaults to `\"C\"`. That "
"is, this:"
msgstr ""
"[외부 블록](external-blocks.md)과 마찬가지로, `extern` 키워드가 사용되고 "
"`\"ABI\"`가 생략되면, 사용되는 ABI는 `\"C\"`가 기본값입니다. 즉, 다음은:"

#: src/items/functions.md:286
msgid ""
"Functions with an ABI that differs from `\"Rust\"` do not support unwinding "
"in the exact same way that Rust does. Therefore, unwinding past the end of "
"functions with such ABIs causes the process to abort."
msgstr ""
"`\"Rust\"`와 다른 ABI를 가진 함수는 Rust와 정확히 같은 방식으로 언와인딩(unwinding)을 "
"지원하지 않습니다. 따라서 이러한 ABI를 가진 함수의 끝을 지나서 언와인딩하면 프로세스가 "
"중단(abort)됩니다."

#: src/items/functions.md:290
msgid ""
"**Note**: The LLVM backend of the `rustc` implementation aborts the process "
"by executing an illegal instruction."
msgstr ""
"**참고**: `rustc` 구현의 LLVM 백엔드는 잘못된 명령어를 실행하여 프로세스를 중단시킵니다."

#: src/items/functions.md:295
msgid "Const functions"
msgstr "const 함수"

#: src/items/functions.md:299
msgid ""
"Functions qualified with the `const` keyword are [const functions](../"
"const_eval.md#const-functions), as are [tuple struct](structs.md) and [tuple "
"variant](enumerations.md) constructors. _Const functions_  can be called "
"from within [const contexts](../const_eval.md#const-context)."
msgstr ""
"`const` 키워드로 한정된 함수는 [const 함수](../const_eval.md#const-functions)이며, "
"[튜플 구조체](structs.md) 및 [튜플 변형](enumerations.md) 생성자도 마찬가지입니다. "
"_const 함수_는 [const 컨텍스트](../const_eval.md#const-context) 내에서 호출될 수 "
"있습니다."

#: src/items/functions.md:305
msgid ""
"Const functions may use the [`extern`](#extern-function-qualifier) function "
"qualifier."
msgstr ""
"const 함수는 [`extern`](#extern-function-qualifier) 함수 한정자를 사용할 수 있습니다."

#: src/items/functions.md:309
msgid "Const functions are not allowed to be [async](#async-functions)."
msgstr "const 함수는 [async](#async-functions)가 될 수 없습니다."

#: src/items/functions.md:313
msgid "Async functions"
msgstr "비동기 함수"

#: src/items/functions.md:317
msgid ""
"Functions may be qualified as async, and this can also be combined with the "
"`unsafe` qualifier:"
msgstr ""
"함수는 `async`로 한정될 수 있으며, 이는 `unsafe` 한정자와 결합될 수도 있습니다:"

#: src/items/functions.md:327
msgid ""
"Async functions do no work when called: instead, they capture their "
"arguments into a future. When polled, that future will execute the "
"function's body."
msgstr ""
"비동기 함수는 호출될 때 작업을 수행하지 않습니다. 대신 인수를 퓨처(future)로 캡처합니다. "
"폴링(polled)될 때, 해당 퓨처는 함수의 본문을 실행합니다."

#: src/items/functions.md:333
msgid ""
"An async function is roughly equivalent to a function that returns [`impl "
"Future`](../types/impl-trait.md) and with an [`async move` block](../"
"expressions/block-expr.md#async-blocks) as its body:"
msgstr ""
"비동기 함수(async function)는 [`impl Future`](../types/impl-trait.md)를 "
"반환하고 [`async move` 블록](../expressions/block-expr.md#async-blocks)을 "
"본문으로 갖는 함수와 거의 동일합니다:"

#: src/items/functions.md:338
msgid "// Source\n"
msgstr "// 소스\n"

#: src/items/functions.md:344
msgid "is roughly equivalent to:"
msgstr "다음과 거의 동일합니다:"

#: src/items/functions.md:347
msgid "// Desugared\n"
msgstr "// 디슈거링(Desugared)\n"

#: src/items/functions.md:356
msgid "The actual desugaring is more complex:"
msgstr "실제 디슈거링은 더 복잡합니다:"

#: src/items/functions.md:360
msgid ""
"The return type in the desugaring is assumed to capture all lifetime "
"parameters from the `async fn` declaration. This can be seen in the "
"desugared example above, which explicitly outlives, and hence captures, `'a`."
msgstr ""
"디슈거링에서의 반환 타입은 `async fn` 선언의 모든 라이프타임 매개변수를 "
"캡처한다고 가정합니다. 이는 위의 디슈거링 예시에서 `'a`보다 명시적으로 "
"오래 살며, 따라서 이를 캡처하는 것에서 확인할 수 있습니다."

#: src/items/functions.md:367
msgid ""
"The [`async move` block](../expressions/block-expr.md#async-blocks) in the "
"body captures all function parameters, including those that are unused or "
"bound to a `_` pattern. This ensures that function parameters are dropped in "
"the same order as they would be if the function were not async, except that "
"the drop occurs when the returned future has been fully awaited."
msgstr ""
"본문의 [`async move` 블록](../expressions/block-expr.md#async-blocks)은 "
"사용되지 않거나 `_` 패턴에 바인딩된 매개변수를 포함하여 모든 함수 매개변수를 "
"캡처합니다. 이는 함수가 비동기가 아닐 때와 동일한 순서로 함수 매개변수가 "
"드롭되도록 보장하지만, 드롭은 반환된 퓨처가 완전히 어웨이트(awaited)되었을 "
"때 발생한다는 점이 다릅니다."

#: src/items/functions.md:374
msgid ""
"For more information on the effect of async, see [`async` blocks](../"
"expressions/block-expr.md#async-blocks)."
msgstr ""
"비동기의 효과에 대한 자세한 내용은 [`async` 블록](../expressions/block-expr.md#async-blocks)을 "
"참조하십시오."

#: src/items/functions.md:381
msgid ""
"**Edition differences**: Async functions are only available beginning with "
"Rust 2018."
msgstr ""
"**에디션 차이**: 비동기 함수는 러스트 2018부터 사용할 수 있습니다."

#: src/items/functions.md:386
msgid "Combining `async` and `unsafe`"
msgstr "`async`와 `unsafe` 결합하기"

#: src/items/functions.md:390
msgid ""
"It is legal to declare a function that is both async and unsafe. The "
"resulting function is unsafe to call and (like any async function) returns a "
"future. This future is just an ordinary future and thus an `unsafe` context "
"is not required to \"await\" it:"
msgstr ""
"비동기이면서 동시에 안전하지 않은(unsafe) 함수를 선언하는 것은 합법입니다. "
"결과 함수는 호출하기에 안전하지 않으며 (다른 비동기 함수와 마찬가지로) "
"퓨처를 반환합니다. 이 퓨처는 일반적인 퓨처이므로 이를 \"어웨이트(await)\" "
"하는 데 `unsafe` 컨텍스트가 필요하지 않습니다."

#: src/items/functions.md:396
msgid ""
"// Returns a future that, when awaited, dereferences `x`.\n"
"//\n"
"// Soundness condition: `x` must be safe to dereference until\n"
"// the resulting future is complete.\n"
msgstr ""
"// 어웨이트되었을 때 `x`를 역참조하는 퓨처를 반환합니다.\n"
"//\n"
"// 건전성 조건: 결과 퓨처가 완료될 때까지 `x`를 안전하게 역참조할 수 있어야 합니다.\n"

#: src/items/functions.md:405
msgid "// An `unsafe` block is required to invoke the function initially:\n"
msgstr "// 함수를 처음 호출하려면 `unsafe` 블록이 필요합니다.\n"

#: src/items/functions.md:409
msgid ""
"// But no `unsafe` block required here. This will\n"
"    // read the value of `p`:\n"
msgstr ""
"// 하지만 여기서는 `unsafe` 블록이 필요하지 않습니다. 이는 `p`의 값을 읽을 것입니다.\n"

#: src/items/functions.md:415
msgid ""
"Note that this behavior is a consequence of the desugaring to a function "
"that returns an `impl Future` -- in this case, the function we desugar to is "
"an `unsafe` function, but the return value remains the same."
msgstr ""
"이 동작은 `impl Future`를 반환하는 함수로의 디슈거링 결과입니다. "
"이 경우 디슈거링된 함수는 `unsafe` 함수이지만, 반환 값은 동일하게 유지됩니다."

#: src/items/functions.md:420
msgid ""
"Unsafe is used on an async function in precisely the same way that it is "
"used on other functions: it indicates that the function imposes some "
"additional obligations on its caller to ensure soundness. As in any other "
"unsafe function, these conditions may extend beyond the initial call itself "
"-- in the snippet above, for example, the `unsafe_example` function took a "
"pointer `x` as argument, and then (when awaited) dereferenced that pointer. "
"This implies that `x` would have to be valid until the future is finished "
"executing, and it is the caller's responsibility to ensure that."
msgstr ""
"Unsafe는 다른 함수에서 사용되는 것과 정확히 동일한 방식으로 비동기 "
"함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 "
"몇 가지 추가적인 의무를 부과함을 나타냅니다. 다른 모든 unsafe 함수와 "
"마찬가지로, 이러한 조건은 초기 호출 자체를 넘어 확장될 수 있습니다. "
"예를 들어, 위의 스니펫에서 `unsafe_example` 함수는 포인터 `x`를 "
"인자로 받았고, (어웨이트되었을 때) 해당 포인터를 역참조했습니다. "
"이는 퓨처가 실행을 마칠 때까지 `x`가 유효해야 함을 의미하며, "
"이를 보장하는 것은 호출자의 책임입니다."

#: src/items/functions.md:432
msgid "Attributes on functions"
msgstr "함수의 속성"

#: src/items/functions.md:436
msgid ""
"[Outer attributes](../attributes.md) are allowed on functions. [Inner "
"attributes](../attributes.md) are allowed directly after the `{` inside its "
"body [block](../expressions/block-expr.md)."
msgstr ""
"[외부 속성](../attributes.md)은 함수에 허용됩니다. [내부 속성](../attributes.md)은 "
"함수 본문 [블록](../expressions/block-expr.md) 내부의 `{` 바로 뒤에 허용됩니다."

#: src/items/functions.md:439
msgid ""
"This example shows an inner attribute on a function. The function is "
"documented with just the word \"Example\"."
msgstr ""
"이 예시는 함수의 내부 속성을 보여줍니다. 이 함수는 단지 \"Example\"이라는 "
"단어로 문서화됩니다."

#: src/items/functions.md:444
msgid "\"Example\""
msgstr "\"예시\""

#: src/items/functions.md:448
msgid ""
"Note: Except for lints, it is idiomatic to only use outer attributes on "
"function items."
msgstr ""
"참고: 린트(lints)를 제외하고, 함수 아이템에는 외부 속성만 사용하는 것이 관용적입니다."

#: src/items/functions.md:453
msgid ""
"The attributes that have meaning on a function are [`cfg`](../conditional-"
"compilation.md#the-cfg-attribute), [`cfg_attr`](../conditional-"
"compilation.md#the-cfg_attr-attribute), [`deprecated`](../attributes/"
"diagnostics.md#the-deprecated-attribute), [`doc`](../../rustdoc/the-doc-"
"attribute.html), [`export_name`](../abi.md#the-export_name-attribute), "
"[`link_section`](../abi.md#the-link_section-attribute), [`no_mangle`](../"
"abi.md#the-no_mangle-attribute), [the lint check attributes](../attributes/"
"diagnostics.md#lint-check-attributes), [`must_use`](../attributes/"
"diagnostics.md#the-must_use-attribute), [the procedural macro attributes](../"
"procedural-macros.md), [the testing attributes](../attributes/testing.md), "
"and [the optimization hint attributes](../attributes/codegen.md#optimization-"
"hints). Functions also accept attributes macros."
msgstr ""
"함수에서 의미를 갖는 속성은 [`cfg`](../conditional-compilation.md#the-cfg-attribute), "
"[`cfg_attr`](../conditional-compilation.md#the-cfg_attr-attribute), "
"[`deprecated`](../attributes/diagnostics.md#the-deprecated-attribute), "
"[`doc`](../../rustdoc/the-doc-attribute.html), [`export_name`](../abi.md#the-"
"export_name-attribute), [`link_section`](../abi.md#the-link_section-"
"attribute), [`no_mangle`](../abi.md#the-no_mangle-attribute), [린트 검사 속성](../"
"attributes/diagnostics.md#lint-check-attributes), [`must_use`](../attributes/"
"diagnostics.md#the-must_use-attribute), [절차적 매크로 속성](../procedural-macros."
"md), [테스팅 속성](../attributes/testing.md), 그리고 [최적화 힌트 속성](../attributes/"
"codegen.md#optimization-hints)입니다. 함수는 속성 매크로도 허용합니다."

#: src/items/functions.md:461 src/items/external-blocks.md:515
msgid "Attributes on function parameters"
msgstr "함수 매개변수의 속성"

#: src/items/functions.md:465
msgid ""
"[Outer attributes](../attributes.md) are allowed on function parameters and "
"the permitted [built-in attributes](../attributes.md#built-in-attributes-"
"index) are restricted to `cfg`, `cfg_attr`, `allow`, `warn`, `deny`, and "
"`forbid`."
msgstr ""
"[외부 속성](../attributes.md)은 함수 매개변수에 허용되며, 허용되는 [내장 속성](../"
"attributes.md#built-in-attributes-index)은 `cfg`, `cfg_attr`, `allow`, "
"`warn`, `deny`, `forbid`로 제한됩니다."

#: src/items/functions.md:480
msgid ""
"Inert helper attributes used by procedural macro attributes applied to items "
"are also allowed but be careful to not include these inert attributes in "
"your final `TokenStream`."
msgstr ""
"아이템에 적용되는 절차적 매크로 속성에서 사용하는 비활성(inert) 도우미 속성도 허용되지만, "
"최종 `TokenStream`에 이러한 비활성 속성을 포함하지 않도록 주의해야 합니다."

#: src/items/functions.md:483
msgid ""
"For example, the following code defines an inert `some_inert_attribute` "
"attribute that is not formally defined anywhere and the "
"`some_proc_macro_attribute` procedural macro is responsible for detecting "
"its presence and removing it from the output token stream."
msgstr ""
"예를 들어, 다음 코드는 어디에도 공식적으로 정의되지 않은 비활성 `some_inert_attribute` "
"속성을 정의하고, `some_proc_macro_attribute` 절차적 매크로가 그 존재를 감지하여 "
"출력 토큰 스트림에서 제거하는 역할을 담당합니다."

#: src/items/type-aliases.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TypeAlias_ :  \n"
"   `type` [IDENTIFIER](../identifiers.md) [_GenericParams_]"
"(generics.md)<sup>?</sup> ( `:` [_TypeParamBounds_](../trait-"
"bounds.md) )<sup>?</sup> [_WhereClause_](generics.md#where-clauses)<sup>?</"
"sup> ( `=` [_Type_](../types.md#type-expressions) [_WhereClause_]"
"(generics.md#where-clauses)<sup>?</sup>)<sup>?</sup> `;`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_타입별칭_ :  \n"
"   `type` [식별자](../identifiers.md) [_제네릭매개변수_](generics.md)<sup>?</sup> ( `:` [_타입매개변수바운드_](../trait-"
"bounds.md) )<sup>?</sup> [_Where절_](generics.md#where-clauses)<sup>?</"
"sup> ( `=` [_타입_](../types.md#type-expressions) [_Where절_]"
"(generics.md#where-clauses)<sup>?</sup>)<sup>?</sup> `;`"

#: src/items/type-aliases.md:15
msgid ""
"A _type alias_ defines a new name for an existing [type](../types.md) in the "
"[type namespace](../names/namespaces.md) of the module or block where it is "
"located. Type aliases are declared with the keyword `type`. Every value has "
"a single, specific type, but may implement several different traits, and may "
"be compatible with several different type constraints."
msgstr ""
"_타입 별칭_은 해당 모듈이나 블록의 [타입 네임스페이스](../names/namespaces.md)에 "
"있는 기존 [타입](../types.md)에 대한 새로운 이름을 정의합니다. 타입 별칭은 `type` "
"키워드로 선언됩니다. 모든 값은 단일하고 구체적인 타입을 갖지만, 여러 다른 트레잇을 구현할 수 "
"있으며, 여러 다른 타입 제약과 호환될 수 있습니다."

#: src/items/type-aliases.md:19
msgid ""
"For example, the following defines the type `Point` as a synonym for the "
"type `(u8, u8)`, the type of pairs of unsigned 8 bit integers:"
msgstr ""
"예를 들어, 다음은 `Point` 타입을 `(u8, u8)`(부호 없는 8비트 정수 쌍의 타입)의 "
"동의어로 정의합니다:"

#: src/items/type-aliases.md:29
msgid ""
"A type alias to a tuple-struct or unit-struct cannot be used to qualify that "
"type's constructor:"
msgstr ""
"튜플 구조체나 유닛 구조체에 대한 타입 별칭은 해당 타입의 생성자를 한정하는 데 사용할 수 "
"없습니다:"

#: src/items/type-aliases.md:38
msgid "// Doesn't work\n"
msgstr "// 작동하지 않음\n"

#: src/items/type-aliases.md:43
msgid ""
"A type alias, when not used as an [associated type](associated-"
"items.md#associated-types), must include a [_Type_](../types.md#type-"
"expressions) and may not include [_TypeParamBounds_](../trait-bounds.md)."
msgstr ""
"[연관 타입](associated-items.md#associated-types)으로 사용되지 않는 경우, 타입 별칭은 "
"반드시 [_타입_](../types.md#type-expressions)을 포함해야 하며 [_타입매개변수바운드_](../trait-bounds.md)는 "
"포함할 수 없습니다."

#: src/items/type-aliases.md:48

msgid ""

"A type alias, when used as an [associated type](associated-"

"items.md#associated-types) in a [trait](traits.md), must not include a "

"[_Type_](../types.md#type-expressions) specification but may include "

"[_TypeParamBounds_](../trait-bounds.md)."

msgstr "타입 별칭이 [트레잇](traits.md) 내에서 [연관 타입](associated-items.md#associated-types)으로 사용될 때는 [_타입_](../types.md#type-expressions) 명세를 포함해서는 안 되지만, [_타입 파라미터 바운드_](../trait-bounds.md)는 포함할 수 있습니다."

"타입 별칭이 [트레잇](traits.md)에서 [연관 타입](associated-items.md#associated-types)으로 "

"사용될 때는, 반드시 [_타입_](../types.md#type-expressions) 명세를 포함하지 않아야 "

"하지만 [_타입매개변수바운드_](../trait-bounds.md)는 포함할 수 있습니다."



#: src/items/type-aliases.md:53

msgid ""

"A type alias, when used as an [associated type](associated-"

"items.md#associated-types) in a [trait impl](implementations.md#trait-"

"implementations), must include a [_Type_](../types.md#type-expressions) "

"specification and may not include [_TypeParamBounds_](../trait-bounds.md)."

msgstr "타입 별칭이 [트레잇 구현](implementations.md#trait-implementations) 내에서 [연관 타입](associated-items.md#associated-types)으로 사용될 때는 반드시 [_타입_](../types.md#type-expressions) 명세를 포함해야 하며, [_타입 파라미터 바운드_](../trait-bounds.md)는 포함할 수 없습니다."

"타입 별칭이 [트레잇 구현](implementations.md#trait-implementations)에서 [연관 타입](associated-items.md#associated-types)으로 "

"사용될 때는, 반드시 [_타입_](../types.md#type-expressions) 명세를 포함해야 하며 "

"[_타입매개변수바운드_](../trait-bounds.md)는 포함할 수 없습니다."



#: src/items/type-aliases.md:58

msgid ""

"Where clauses before the equals sign on a type alias in a [trait impl]"

"(implementations.md#trait-implementations) (like `type TypeAlias<T> where T: "

"Foo = Bar<T>`) are deprecated. Where clauses after the equals sign (like "

"`type TypeAlias<T> = Bar<T> where T: Foo`) are preferred."

msgstr "[트레잇 구현](implementations.md#trait-implementations) 내 타입 별칭에서 등호 앞의 where 절(예: `type TypeAlias<T> where T: Foo = Bar<T>`)은 더 이상 사용되지 않습니다. 등호 뒤의 where 절(예: `type TypeAlias<T> = Bar<T> where T: Foo`)이 권장됩니다."

"[트레잇 구현](implementations.md#trait-implementations)의 타입 별칭에서 등호 앞의 "

"Where 절(예: `type TypeAlias<T> where T: Foo = Bar<T>`)은 더 이상 사용되지 않습니다(deprecated). "

"등호 뒤의 Where 절(예: `type TypeAlias<T> = Bar<T> where T: Foo`)을 사용하는 것이 권장됩니다."



#: src/items/structs.md:7

msgid ""

"**<sup>Syntax</sup>**  \n"

"_Struct_ :  \n"

"      _StructStruct_  \n"

"   | _TupleStruct_"

msgstr ""

"**<sup>구문</sup>**  \n"

"_구조체_ :  \n"

"      _일반구조체_  \n"

"   | _튜플구조체_"



#: src/items/structs.md:12

msgid ""

"_StructStruct_ :  \n"

"   `struct` [IDENTIFIER](../identifiers.md) [_GenericParams_]"

"(generics.md)<sup>?</sup> [_WhereClause_](generics.md#where-clauses)<sup>?</"

"sup> ( `{` _StructFields_<sup>?</sup> `}` | `;` )"

msgstr ""

"_일반구조체_ :  \n"

"   `struct` [식별자](../identifiers.md) [_제네릭매개변수_](generics.md)<sup>?</sup> [_Where절_](generics.md#where-clauses)<sup>?</"

"sup> ( `{` _구조체필드들_<sup>?</sup> `}` | `;` )"



#: src/items/structs.md:19

msgid ""

"_TupleStruct_ :  \n"

"   `struct` [IDENTIFIER](../identifiers.md) [_GenericParams_]"

"(generics.md)<sup>?</sup> `(` _TupleFields_<sup>?</sup> `)` [_WhereClause_]"

"(generics.md#where-clauses)<sup>?</sup> `;`"

msgstr ""

"_튜플구조체_ :  \n"

"   `struct` [식별자](../identifiers.md) [_제네릭매개변수_](generics.md)<sup>?</sup> `(` _튜플필드들_<sup>?</sup> `)` [_Where절_]"

"(generics.md#where-clauses)<sup>?</sup> `;`"



#: src/items/structs.md:27

msgid ""

"_StructFields_ :  \n"

"   _StructField_ (`,` _StructField_)<sup>\\*</sup> `,`<sup>?</sup>"

msgstr ""

"_구조체필드들_ :  \n"

"   _구조체필드_ (`,` _구조체필드_)<sup>\\*</sup> `,`<sup>?</sup>"



#: src/items/structs.md:30

msgid ""

"_StructField_ :  \n"

"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup>  \n"

"   [_Visibility_](../visibility-and-privacy.md)<sup>?</sup>  \n"

"   [IDENTIFIER](../identifiers.md) `:` [_Type_](../types.md#type-expressions)"

msgstr ""

"_구조체필드_ :  \n"

"   [_외부속성_](../attributes.md)<sup>\\*</sup>  \n"

"   [_가시성_](../visibility-and-privacy.md)<sup>?</sup>  \n"

"   [식별자](../identifiers.md) `:` [_타입_](../types.md#type-expressions)"

#: src/items/structs.md:35
msgid ""
"_TupleFields_ :  \n"
"   _TupleField_ (`,` _TupleField_)<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_튜플필드들_ :  \n"
"   _튜플필드_ (`,` _튜플필드_)<sup>\\*</sup> `,`<sup>?</sup>"

#: src/items/structs.md:38
msgid ""
"_TupleField_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"   [_Visibility_](../visibility-and-privacy.md)<sup>?</sup>  \n"
"   [_Type_](../types.md#type-expressions)"
msgstr ""
"_튜플필드_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup>  \n"
"   [_가시성_](../visibility-and-privacy.md)<sup>?</sup>  \n"
"   [_타입_](../types.md#type-expressions)"

#: src/items/structs.md:45
msgid ""
"A _struct_ is a nominal [struct type](../types/struct.md) defined with the "
"keyword `struct`."
msgstr ""
"_구조체(struct)_는 `struct` 키워드로 정의된 명목상의 [구조체 타입](../types/struct.md)입니다."

#: src/items/structs.md:49
msgid ""
"A struct declaration defines the given name in the [type namespace](../names/"
"namespaces.md) of the module or block where it is located."
msgstr ""
"구조체 선언은 해당 모듈이나 블록의 [타입 네임스페이스](../names/namespaces.md)에 "
"주어진 이름을 정의합니다."

#: src/items/structs.md:51
msgid "An example of a `struct` item and its use:"
msgstr "`struct` 아이템과 그 사용 예시:"

#: src/items/structs.md:61
msgid ""
"A _tuple struct_ is a nominal [tuple type](../types/tuple.md), and is also "
"defined with the keyword `struct`. In addition to defining a type, it also "
"defines a constructor of the same name in the [value namespace](../names/"
"namespaces.md). The constructor is a function which can be called to create "
"a new instance of the struct. For example:"
msgstr ""
"_튜플 구조체_는 명목상의 [튜플 타입](../types/tuple.md)이며, 역시 "
"`struct` 키워드로 정의됩니다. 타입을 정의하는 것 외에도, "
"[값 네임스페이스](../names/namespaces.md)에 동일한 이름의 생성자를 정의합니다. "
"생성자는 구조체의 새 인스턴스를 생성하기 위해 호출할 수 있는 함수입니다. "
"예를 들어:"

#: src/items/structs.md:74
msgid ""
"A _unit-like struct_ is a struct without any fields, defined by leaving off "
"the list of fields entirely. Such a struct implicitly defines a [constant]"
"(constant-items.md) of its type with the same name. For example:"
msgstr ""
"_유닛 유사 구조체(unit-like struct)_는 필드 목록을 완전히 생략하여 "
"정의된, 필드가 없는 구조체입니다. 이러한 구조체는 암시적으로 동일한 이름의 "
"해당 타입 [상수](constant-items.md)를 정의합니다. 예를 들어:"

#: src/items/structs.md:83 src/expressions/loop-expr.md:143
#: src/expressions/loop-expr.md:223 src/expressions/if-expr.md:147
msgid "is equivalent to"
msgstr "다음과 동일합니다."

#: src/items/structs.md:93
msgid ""
"The precise memory layout of a struct is not specified. One can specify a "
"particular layout using the [`repr` attribute](../type-layout.md#representations)."
msgstr ""
"구조체의 정확한 메모리 레이아웃은 지정되어 있지 않습니다. [`repr` 속성](../type-layout.md#representations)을 "
"사용하여 특정 레이아웃을 지정할 수 있습니다."

#: src/items/enumerations.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Enumeration_ :  \n"
"   `enum` [IDENTIFIER](../identifiers.md)  [_GenericParams_]"
"(generics.md)<sup>?</sup> [_WhereClause_](generics.md#where-clauses)<sup>?</"
"sup> `{` _EnumItems_<sup>?</sup> `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_열거형_ :  \n"
"   `enum` [식별자](../identifiers.md)  [_제네릭파라미터_](generics.md)<sup>?</sup> [_Where절_](generics.md#where-clauses)<sup>?</sup> `{` _열거형항목들_<sup>?</sup> `}`"

#: src/items/enumerations.md:15
msgid ""
"_EnumItems_ :  \n"
"   _EnumItem_ ( `,` _EnumItem_ )<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_열거형항목들_ :  \n"
"   _열거형항목_ ( `,` _열거형항목_ )<sup>\\*</sup> `,`<sup>?</sup>"

#: src/items/enumerations.md:18
msgid ""
"_EnumItem_ :  \n"
"   _OuterAttribute_<sup>\\*</sup> [_Visibility_](../visibility-and-"
"privacy.md)<sup>?</sup>  \n"
"   [IDENTIFIER](../identifiers.md) ( _EnumItemTuple_ | "
"_EnumItemStruct_ )<sup>?</sup> _EnumItemDiscriminant_<sup>?</sup>"
msgstr ""
"_열거형항목_ :  \n"
"   _외부속성_<sup>\\*</sup> [_가시성_](../visibility-and-privacy.md)<sup>?</sup>  \n"
"   [식별자](../identifiers.md) ( _튜플형열거형항목_ | _구조체형열거형항목_ )<sup>?</sup> _열거형항목판별자_<sup>?</sup>"

#: src/items/enumerations.md:23
msgid ""
"_EnumItemTuple_ :  \n"
"   `(` [_TupleFields_](structs.md)<sup>?</sup> `)`"
msgstr ""
"_튜플형열거형항목_ :  \n"
"   `(` [_튜플필드들_](structs.md)<sup>?</sup> `)`"

#: src/items/enumerations.md:26
msgid ""
"_EnumItemStruct_ :  \n"
"   `{` [_StructFields_](structs.md)<sup>?</sup> `}`"
msgstr ""
"_구조체형열거형항목_ :  \n"
"   `{` [_구조체필드들_](structs.md)<sup>?</sup> `}`"

#: src/items/enumerations.md:29
msgid ""
"_EnumItemDiscriminant_ :  \n"
"   `=` [_Expression_](../expressions.md)"
msgstr ""
"_열거형항목판별자_ :  \n"
"   `=` [_표현식_](../expressions.md)"

#: src/items/enumerations.md:34
msgid ""
"An _enumeration_, also referred to as an _enum_, is a simultaneous "
"definition of a nominal [enumerated type](../types/enum.md) as well as a set "
"of _constructors_, that can be used to create or pattern-match values of the "
"corresponding enumerated type."
msgstr ""
"_열거형(enumeration)_ 또는 줄여서 _enum_은 명목상의 [열거 타입](../types/enum.md)과 "
"함께, 해당 열거 타입의 값을 생성하거나 패턴 매칭하는 데 사용할 수 있는 "
"_생성자_ 세트를 동시에 정의하는 것입니다."

#: src/items/enumerations.md:40
msgid "Enumerations are declared with the keyword `enum`."
msgstr "열거형은 `enum` 키워드로 선언됩니다."

#: src/items/enumerations.md:44
msgid ""
"The `enum` declaration defines the enumeration type in the [type namespace]"
"(../names/namespaces.md) of the module or block where it is located."
msgstr ""
"`enum` 선언은 해당 모듈이나 블록의 [타입 네임스페이스](../names/namespaces.md)에 "
"열거형 타입을 정의합니다."

#: src/items/enumerations.md:46
msgid "An example of an `enum` item and its use:"
msgstr "`enum` 아이템과 그 사용 예시:"

#: src/items/enumerations.md:60
msgid "Enum constructors can have either named or unnamed fields:"
msgstr "열거형 생성자는 이름을 가진 필드나 이름이 없는 필드를 가질 수 있습니다:"

#: src/items/enumerations.md:68
msgid "\"Cocoa\""
msgstr "\"Cocoa\""

#: src/items/enumerations.md:69
msgid "\"Spotty\""
msgstr "\"Spotty\""

#: src/items/enumerations.md:72
msgid ""
"In this example, `Cat` is a _struct-like enum variant_, whereas `Dog` is "
"simply called an enum variant."
msgstr ""
"이 예제에서 `Cat`은 _구조체형 열거형 변형(struct-like enum variant)_인 반면, `Dog`는 "
"단순히 열거형 변형이라고 부릅니다."

#: src/items/enumerations.md:77
msgid ""
"An enum where no constructors contain fields are called a _<span id=\"field-"
"less-enum\">field-less enum</span>_. For example, this is a fieldless enum:"
msgstr ""
"생성자에 필드가 포함되지 않은 열거형을 _<span id=\"field-less-enum\">필드 없는 열거형"
"(field-less enum)</span>_이라고 합니다. 예를 들어, 다음은 필드 없는 열거형입니다:"

#: src/items/enumerations.md:90
msgid ""
"If a field-less enum only contains unit variants, the enum is called an "
"_<span id=\"unit-only-enum\">unit-only enum</span>_. For example:"
msgstr ""
"필드 없는 열거형이 유닛 변형만 포함하는 경우, 해당 열거형을 _<span id=\"unit-only-"
"enum\">유닛 전용 열거형(unit-only enum)</span>_이라고 합니다. 예를 들어:"

#: src/items/enumerations.md:103
msgid ""
"Variant constructors are similar to [struct](structs.md) definitions, and "
"can be referenced by a path from the enumeration name, including in [use "
"declarations](use-declarations.md)."
msgstr ""
"변형 생성자는 [구조체](structs.md) 정의와 유사하며, [use 선언](use-declarations.md)을 "
"포함하여 열거형 이름의 경로로 참조할 수 있습니다."

#: src/items/enumerations.md:107
msgid ""
"Each variant defines its type in the [type namespace](../names/"
"namespaces.md), though that type cannot be used as a type specifier. Tuple-"
"like and unit-like variants also define a constructor in the [value "
"namespace](../names/namespaces.md)."
msgstr ""
"각 변형은 [타입 네임스페이스](../names/namespaces.md)에 해당 타입을 정의하지만, 그 타입은 "
"타입 지정자로 사용할 수 없습니다. 튜플형 및 유닛형 변형은 [값 네임스페이스](../names/"
"namespaces.md)에 생성자도 정의합니다."

#: src/items/enumerations.md:112
msgid ""
"A struct-like variant can be instantiated with a [struct expression](../"
"expressions/struct-expr.md)."
msgstr ""
"구조체형 변형은 [구조체 표현식](../expressions/struct-expr.md)으로 인스턴스화할 수 "
"있습니다."

#: src/items/enumerations.md:116
msgid ""
"A tuple-like variant can be instantiated with a [call expression](../"
"expressions/call-expr.md) or a [struct expression](../expressions/struct-"
"expr.md)."
msgstr ""
"튜플형 변형은 [호출 표현식](../expressions/call-expr.md)이나 [구조체 표현식](../"
"expressions/struct-expr.md)으로 인스턴스화할 수 있습니다."

#: src/items/enumerations.md:120
msgid ""
"A unit-like variant can be instantiated with a [path expression](../"
"expressions/path-expr.md) or a [struct expression](../expressions/struct-"
"expr.md). For example:"
msgstr ""
"유닛형 변형은 [경로 표현식](../expressions/path-expr.md)이나 [구조체 표현식](../"
"expressions/struct-expr.md)으로 인스턴스화할 수 있습니다. 예를 들어:"

#: src/items/enumerations.md:130
msgid "// Creates aliases to all variants.\n"
msgstr "// 모든 변형에 대한 별칭을 생성합니다.\n"

#: src/items/enumerations.md:131
msgid "// Path expression of the const item.\n"
msgstr "// 상수 아이템의 경로 표현식.\n"

#: src/items/enumerations.md:132 src/items/enumerations.md:135
msgid "// Struct expression.\n"
msgstr "// 구조체 표현식.\n"

#: src/items/enumerations.md:133
msgid "// Call expression.\n"
msgstr "// 호출 표현식.\n"

#: src/items/enumerations.md:134
msgid "// Struct expression using integer field names.\n"
msgstr "// 정수 필드 이름을 사용하는 구조체 표현식.\n"

#: src/items/enumerations.md:138
msgid ""
"<span id=\"custom-discriminant-values-for-fieldless-enumerations\"></span>"
msgstr ""
"<span id=\"custom-discriminant-values-for-fieldless-enumerations\"></span>"

#: src/items/enumerations.md:141
msgid "Discriminants"
msgstr "판별자"

#: src/items/enumerations.md:145
msgid ""
"Each enum instance has a _discriminant_: an integer logically associated to "
"it that is used to determine which variant it holds."
msgstr ""
"각 열거형 인스턴스는 _판별자(discriminant)_를 가집니다. 이는 어떤 변형을 보유하고 있는지 "
"결정하는 데 사용되는 논리적으로 연결된 정수입니다."

#: src/items/enumerations.md:150
msgid ""
"Under the [`Rust` representation](../type-layout.md#the-rust-"
"representation), the discriminant is interpreted as an `isize` value. "
"However, the compiler is allowed to use a smaller type (or another means of "
"distinguishing variants) in its actual memory layout."
msgstr ""
"[`Rust` 표현](../type-layout.md#the-rust-representation) 하에서, 판별자는 `isize` "
"값으로 해석됩니다. 하지만, 컴파일러는 실제 메모리 레이아웃에서 더 작은 타입(또는 변형을 "
"구별하는 다른 수단)을 사용하는 것이 허용됩니다."

#: src/items/enumerations.md:154
msgid "Assigning discriminant values"
msgstr "판별자 값 할당"

#: src/items/enumerations.md:158
msgid "Explicit discriminants"
msgstr "명시적 판별자"

#: src/items/enumerations.md:162
msgid ""
"In two circumstances, the discriminant of a variant may be explicitly set by "
"following the variant name with `=` and a [constant expression](../"
"const_eval.md#constant-expressions):"
msgstr ""
"두 가지 상황에서, 변형 이름 뒤에 `=`와 [상수 표현식](../const_eval.md#constant-"
"expressions)을 붙여 변형의 판별자를 명시적으로 설정할 수 있습니다:"

#: src/items/enumerations.md:167
msgid "if the enumeration is \"[unit-only](#unit-only-enum)\"."
msgstr "열거형이 \"[유닛 전용](#unit-only-enum)\"인 경우."

#: src/items/enumerations.md:171
msgid ""
"if a [primitive representation](../type-layout.md#primitive-representations) "
"is used. For example:"
msgstr ""
"[원시 표현(primitive representation)](../type-layout.md#primitive-"
"representations)이 사용되는 경우. 예를 들어:"

#: src/items/enumerations.md:187
msgid "Implicit discriminants"
msgstr "암시적 판별자"

#: src/items/enumerations.md:189
msgid ""
"If a discriminant for a variant is not specified, then it is set to one "
"higher than the discriminant of the previous variant in the declaration. If "
"the discriminant of the first variant in the declaration is unspecified, "
"then it is set to zero."
msgstr ""
"변형에 대한 판별자가 지정되지 않으면, 선언 내 이전 변형의 판별자보다 1 큰 값으로 "
"설정됩니다. 선언의 첫 번째 변형의 판별자가 지정되지 않으면, 0으로 설정됩니다."

#: src/items/enumerations.md:196 src/items/enumerations.md:220
msgid "// 0\n"
msgstr "// 0\n"

#: src/items/enumerations.md:197
msgid "// 123\n"
msgstr "// 123\n"

#: src/items/enumerations.md:198
msgid "// 124\n"
msgstr "// 124\n"

#: src/items/enumerations.md:211
msgid "It is an error when two variants share the same discriminant."
msgstr "두 변형이 동일한 판별자를 공유하면 오류입니다."

#: src/items/enumerations.md:221
msgid "// 1\n"
msgstr "// 1\n"

#: src/items/enumerations.md:222
msgid "// 1 (collision with previous!)\n"
msgstr "// 1 (이전과 충돌!)\n"

#: src/items/enumerations.md:228
msgid ""
"It is also an error to have an unspecified discriminant where the previous "
"discriminant is the maximum value for the size of the discriminant."
msgstr ""
"이전 판별자가 판별자 크기의 최댓값일 때 판별자를 지정하지 않는 것도 오류입니다."

#: src/items/enumerations.md:235 src/items/enumerations.md:242
msgid "// Would be 256, but that overflows the enum.\n"
msgstr "// 256이어야 하지만, 열거형을 오버플로합니다.\n"

#: src/items/enumerations.md:240
msgid "// 254\n"
msgstr "// 254\n"

#: src/items/enumerations.md:241
msgid "// 255\n"
msgstr "// 255\n"

#: src/items/enumerations.md:246
msgid "Accessing discriminant"
msgstr "판별자 접근"

#: src/items/enumerations.md:248
msgid "Via `mem::discriminant`"
msgstr "`mem::discriminant`를 통해"

#: src/items/enumerations.md:253
msgid ""
"[`std::mem::discriminant`](../../core/mem/fn.discriminant.html) returns an "
"opaque reference to the discriminant of an enum value which can be compared. "
"This cannot be used to get the value of the discriminant."
msgstr ""
"[`std::mem::discriminant`](../../core/mem/fn.discriminant.html)는 비교 가능한 "
"열거형 값의 판별자에 대한 불투명한(opaque) 참조를 반환합니다. 이는 판별자의 값을 "
"얻는 데 사용할 수 없습니다."

#: src/items/enumerations.md:259
msgid "Casting"
msgstr "캐스팅"

#: src/items/enumerations.md:263
msgid ""
"If an enumeration is [unit-only](#unit-only-enum) (with no tuple and struct "
"variants), then its discriminant can be directly accessed with a [numeric "
"cast](../expressions/operator-expr.md#semantics); e.g.:"
msgstr ""
"열거형이 [유닛 전용](#unit-only-enum)(튜플 및 구조체 변형이 없음)인 경우, "
"[숫자 캐스트](../expressions/operator-expr.md#semantics)를 사용하여 판별자에 "
"직접 접근할 수 있습니다. 예를 들어:"

#: src/items/enumerations.md:280
msgid ""
"[Field-less enums](#field-less-enum) can be casted if they do not have "
"explicit discriminants, or where only unit variants are explicit."
msgstr ""
"[필드 없는 열거형](#field-less-enum)은 명시적 판별자가 없거나 유닛 변형만 "
"명시적인 경우 캐스팅될 수 있습니다."

#: src/items/enumerations.md:309
msgid "Pointer casting"
msgstr "포인터 캐스팅"

#: src/items/enumerations.md:314
msgid ""
"If the enumeration specifies a [primitive representation](../type-"
"layout.md#primitive-representations), then the discriminant may be reliably "
"accessed via unsafe pointer casting:"
msgstr ""
"열거형이 [원시 표현](../type-layout.md#primitive-representations)을 지정하는 경우, "
"`unsafe` 포인터 캐스팅을 통해 판별자에 안정적으로 접근할 수 있습니다:"

#: src/items/enumerations.md:342
msgid "Zero-variant enums"
msgstr "0-변형 열거형"

#: src/items/enumerations.md:346
msgid ""
"Enums with zero variants are known as _zero-variant enums_. As they have no "
"valid values, they cannot be instantiated."
msgstr ""
"변형이 0개인 열거형을 _0-변형 열거형(zero-variant enums)_이라고 합니다. 유효한 값이 "
"없으므로 인스턴스화할 수 없습니다."

#: src/items/enumerations.md:355
msgid ""
"Zero-variant enums are equivalent to the [never type](../types/never.md), "
"but they cannot be coerced into other types."
msgstr ""
"0-변형 열거형은 [never 타입](../types/never.md)과 동일하지만, 다른 타입으로 "
"강제 변환(coerced)될 수 없습니다."

#: src/items/enumerations.md:361
msgid "// mismatched type error\n"
msgstr "// 타입 불일치 오류\n"

#: src/items/enumerations.md:366
msgid "Variant visibility"
msgstr "변형 가시성"

#: src/items/enumerations.md:368
msgid ""
"Enum variants syntactically allow a [_Visibility_](../visibility-and-"
"privacy.md) annotation, but this is rejected when the enum is validated. "
"This allows items to be parsed with a unified syntax across different "
"contexts where they are used."
msgstr ""
"열거형 변형은 구문적으로 [_가시성_](../visibility-and-privacy.md) 주석을 허용하지만, "
"열거형이 검증될 때 거부됩니다. 이는 아이템이 사용되는 여러 컨텍스트에서 통일된 구문으로 "
"파싱될 수 있도록 하기 위함입니다."

#: src/items/enumerations.md:384 src/items/traits.md:377
msgid "// Empty `vis` is allowed.\n"
msgstr "// 빈 `vis`는 허용됩니다.\n"

#: src/items/enumerations.md:387
msgid "// This is allowed, since it is removed before being validated.\n"
msgstr "// 검증되기 전에 제거되므로 허용됩니다.\n"

#: src/items/unions.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Union_ :  \n"
"   `union` [IDENTIFIER](../identifiers.md) [_GenericParams_]"
"(generics.md)<sup>?</sup> [_WhereClause_](generics.md#where-clauses)<sup>?</"
"sup> `{`[_StructFields_](structs.md)<sup>?</sup> `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_공용체_ :  \n"
"   `union` [식별자](../identifiers.md) [_제네릭매개변수_]"
"(generics.md)<sup>?</sup> [_Where절_](generics.md#where-clauses)<sup>?</"
"sup> `{`[_구조체필드들_](structs.md)<sup>?</sup> `}`"

#: src/items/unions.md:14
msgid ""
"A union declaration uses the same syntax as a struct declaration, except "
"with `union` in place of `struct`."
msgstr ""
"공용체 선언은 `struct` 대신 `union`을 사용한다는 점을 제외하면 구조체 선언과 "
"동일한 구문을 사용합니다."

#: src/items/unions.md:19
msgid ""
"A union declaration defines the given name in the [type namespace](../names/"
"namespaces.md) of the module or block where it is located."
msgstr ""
"공용체 선언은 해당 모듈이나 블록의 [타입 네임스페이스](../names/namespaces.md)에 "
"주어진 이름을 정의합니다."

#: src/items/unions.md:31
msgid ""
"The key property of unions is that all fields of a union share common "
"storage. As a result, writes to one field of a union can overwrite its other "
"fields, and the size of a union is determined by the size of its largest "
"field."
msgstr ""
"공용체의 핵심 속성은 공용체의 모든 필드가 공통 저장 공간을 공유한다는 것입니다. "
"결과적으로, 공용체의 한 필드에 쓰면 다른 필드를 덮어쓸 수 있으며, 공용체의 크기는 "
"가장 큰 필드의 크기에 의해 결정됩니다."

#: src/items/unions.md:37
msgid "Union field types are restricted to the following subset of types:"
msgstr "공용체 필드 타입은 다음 타입의 하위 집합으로 제한됩니다:"

#: src/items/unions.md:41
msgid "`Copy` types"
msgstr "`Copy` 타입"

#: src/items/unions.md:45
msgid "References (`&T` and `&mut T` for arbitrary `T`)"
msgstr "참조(임의의 `T`에 대한 `&T` 및 `&mut T`)"

#: src/items/unions.md:49
msgid "`ManuallyDrop<T>` (for arbitrary `T`)"
msgstr "`ManuallyDrop<T>` (임의의 `T`에 대해)"

#: src/items/unions.md:53
msgid "Tuples and arrays containing only allowed union field types"
msgstr "허용된 공용체 필드 타입만 포함하는 튜플 및 배열"

#: src/items/unions.md:57
msgid ""
"This restriction ensures, in particular, that union fields never need to be "
"dropped. Like for structs and enums, it is possible to `impl Drop` for a "
"union to manually define what happens when it gets dropped."
msgstr ""
"이 제약은 특히 공용체 필드가 절대 드롭(drop)될 필요가 없음을 보장합니다. 구조체나 "
"열거형과 마찬가지로, 공용체에 대해 `impl Drop`을 구현하여 드롭될 때 일어날 일을 "
"수동으로 정의할 수 있습니다."

#: src/items/unions.md:63
msgid ""
"Unions without any fields are not accepted by the compiler, but can be "
"accepted by macros."
msgstr ""
"필드가 없는 공용체는 컴파일러에서 허용되지 않지만, 매크로에서는 허용될 수 있습니다."

#: src/items/unions.md:67
msgid "Initialization of a union"
msgstr "공용체 초기화"

#: src/items/unions.md:71
msgid ""
"A value of a union type can be created using the same syntax that is used "
"for struct types, except that it must specify exactly one field:"
msgstr ""
"공용체 타입의 값은 구조체 타입에 사용되는 것과 동일한 구문을 사용하여 생성할 수 "
"있지만, 정확히 하나의 필드만 지정해야 합니다:"

#: src/items/unions.md:82
msgid ""
"The expression above creates a value of type `MyUnion` and initializes the "
"storage using field `f1`. The union can be accessed using the same syntax as "
"struct fields:"
msgstr ""
"위의 표현식은 `MyUnion` 타입의 값을 생성하고 `f1` 필드를 사용하여 저장 공간을 "
"초기화합니다. 공용체는 구조체 필드와 동일한 구문을 사용하여 접근할 수 있습니다:"

#: src/items/unions.md:95
msgid "Reading and writing union fields"
msgstr "공용체 필드 읽기 및 쓰기"

#: src/items/unions.md:99
msgid ""
"Unions have no notion of an \"active field\". Instead, every union access "
"just interprets the storage as the type of the field used for the access."
msgstr ""
"공용체에는 \"활성 필드(active field)\"라는 개념이 없습니다. 대신, 모든 공용체 접근은 "
"저장 공간을 접근에 사용된 필드의 타입으로 해석할 뿐입니다."

#: src/items/unions.md:104
msgid "Reading a union field reads the bits of the union at the field's type."
msgstr "공용체 필드를 읽는 것은 필드의 타입에서 공용체의 비트를 읽는 것입니다."

#: src/items/unions.md:108
msgid ""
"Fields might have a non-zero offset (except when [the C representation](../"
"type-layout.md#reprc-unions) is used); in that case the bits starting at the "
"offset of the fields are read"
msgstr ""
"필드는 0이 아닌 오프셋을 가질 수 있습니다([C 표현](../type-layout.md#reprc-unions)이 "
"사용된 경우 제외). 이 경우 필드의 오프셋에서 시작하는 비트를 읽습니다"

#: src/items/unions.md:113
msgid ""
"It is the programmer's responsibility to make sure that the data is valid at "
"the field's type. Failing to do so results in [undefined behavior](../"
"behavior-considered-undefined.md). For example, reading the value `3` from a "
"field of the [boolean type](../types/boolean.md) is undefined behavior. "
"Effectively, writing to and then reading from a union with [the C "
"representation](../type-layout.md#reprc-unions) is analogous to a "
"[`transmute`](../../core/intrinsics/fn.transmute.html) from the type used "
"for writing to the type used for reading."
msgstr ""
"데이터가 필드의 타입에서 유효한지 확인하는 것은 프로그래머의 책임입니다. 이를 지키지 "
"않으면 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)이 "
"발생합니다. 예를 들어, [불리언 타입](../types/boolean.md)의 필드에서 값 `3`을 "
"읽는 것은 정의되지 않은 동작입니다. 사실상, [C 표현](../type-layout.md#reprc-unions)을 "
"사용하는 공용체에 쓴 다음 읽는 것은 쓰기에 사용된 타입에서 읽기에 사용된 타입으로의 "
"[`transmute`](../../core/intrinsics/fn.transmute.html)와 유사합니다."

#: src/items/unions.md:122
msgid ""
"Consequently, all reads of union fields have to be placed in `unsafe` blocks:"
msgstr ""
"결과적으로, 공용체 필드의 모든 읽기는 `unsafe` 블록 내에 배치되어야 합니다:"

#: src/items/unions.md:133
msgid ""
"Commonly, code using unions will provide safe wrappers around unsafe union "
"field accesses."
msgstr ""
"일반적으로 공용체를 사용하는 코드는 안전하지 않은 공용체 필드 접근에 대한 안전한 "
"래퍼를 제공합니다."

#: src/items/unions.md:138
msgid ""
"In contrast, writes to union fields are safe, since they just overwrite "
"arbitrary data, but cannot cause undefined behavior. (Note that union field "
"types can never have drop glue, so a union field write will never implicitly "
"drop anything.)"
msgstr ""
"반면에 공용체 필드에 쓰는 것은 안전합니다. 임의의 데이터를 덮어쓸 뿐이며 정의되지 않은 "
"동작을 유발할 수 없기 때문입니다. (공용체 필드 타입은 절대 드롭 글루(drop glue)를 "
"가질 수 없으므로, 공용체 필드 쓰기는 절대 암시적으로 아무것도 드롭하지 않음에 "
"유의하십시오.)"

#: src/items/unions.md:145
msgid "Pattern matching on unions"
msgstr "공용체 패턴 매칭"

#: src/items/unions.md:149
msgid "Another way to access union fields is to use pattern matching."
msgstr "공용체 필드에 접근하는 또 다른 방법은 패턴 매칭을 사용하는 것입니다."

#: src/items/unions.md:153
msgid ""
"Pattern matching on union fields uses the same syntax as struct patterns, "
"except that the pattern must specify exactly one field."
msgstr ""
"공용체 필드에 대한 패턴 매칭은 구조체 패턴과 동일한 구문을 사용하지만, 패턴이 "
"정확히 하나의 필드만 지정해야 한다는 점이 다릅니다."

#: src/items/unions.md:158
msgid ""
"Since pattern matching is like reading the union with a particular field, it "
"has to be placed in `unsafe` blocks as well."
msgstr ""
"패턴 매칭은 특정 필드로 공용체를 읽는 것과 같으므로, 마찬가지로 `unsafe` 블록 내에 "
"배치되어야 합니다."

#: src/items/unions.md:166 src/patterns.md:959 src/patterns.md:963
msgid "\"ten\""
msgstr "\"ten\""

#: src/items/unions.md:175
msgid ""
"Pattern matching may match a union as a field of a larger structure. In "
"particular, when using a Rust union to implement a C tagged union via FFI, "
"this allows matching on the tag and the corresponding field simultaneously:"
msgstr ""
"패턴 매칭은 더 큰 구조체의 필드로서 공용체와 매칭할 수 있습니다. 특히, FFI를 통해 C "
"태그가 지정된 공용체(C tagged union)를 구현하기 위해 Rust 공용체를 사용할 때, 이를 "
"통해 태그와 해당 필드에 동시에 매칭할 수 있습니다:"

#: src/items/unions.md:208
msgid "References to union fields"
msgstr "공용체 필드에 대한 참조"

#: src/items/unions.md:212
msgid ""
"Since union fields share common storage, gaining write access to one field "
"of a union can give write access to all its remaining fields."
msgstr ""
"공용체 필드는 공통 저장 공간을 공유하므로, 공용체의 한 필드에 대한 쓰기 접근 권한을 "
"얻으면 나머지 모든 필드에 대한 쓰기 접근 권한을 얻을 수 있습니다."

#: src/items/unions.md:217
msgid ""
"Borrow checking rules have to be adjusted to account for this fact. As a "
"result, if one field of a union is borrowed, all its remaining fields are "
"borrowed as well for the same lifetime."
msgstr ""
"대여 검사(borrow checking) 규칙은 이 사실을 고려하여 조정되어야 합니다. 결과적으로 "
"공용체의 한 필드가 대여되면 나머지 모든 필드도 동일한 수명 동안 대여됩니다."

#: src/items/unions.md:222
msgid ""
"// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a "
"time\n"
msgstr ""
"// 오류: `u`를 (`u.f2`를 통해) 한 번에 두 번 이상 가변으로 대여할 수 없습니다\n"

#: src/items/unions.md:227
msgid ""
"//                    ---- first mutable borrow occurs here (via `u.f1`)\n"
msgstr ""
"//                    ---- 첫 번째 가변 대여가 여기서 발생합니다 (`u.f1`을 통해)\n"

#: src/items/unions.md:229
msgid ""
"//                    ^^^^ second mutable borrow occurs here (via `u.f2`)\n"
msgstr ""
"//                    ^^^^ 두 번째 가변 대여가 여기서 발생합니다 (`u.f2`를 통해)\n"

#: src/items/unions.md:232
msgid "//  - first borrow ends here\n"
msgstr "//  - 첫 번째 대여가 여기서 끝납니다\n"

#: src/items/unions.md:240
msgid ""
"As you could see, in many aspects (except for layouts, safety, and "
"ownership) unions behave exactly like structs, largely as a consequence of "
"inheriting their syntactic shape from structs. This is also true for many "
"unmentioned aspects of Rust language (such as privacy, name resolution, type "
"inference, generics, trait implementations, inherent implementations, "
"coherence, pattern checking, etc etc etc)."
msgstr ""
"보시다시피, 많은 측면(레이아웃, 안전성, 소유권 제외)에서 공용체는 구조체와 정확히 "
"동일하게 동작하며, 이는 주로 구조체로부터 구문적 형태를 상속받았기 때문입니다. 이는 "
"Rust 언어의 언급되지 않은 많은 측면(예: 비공개(privacy), 이름 해석, 타입 추론, "
"제네릭, 트레잇 구현, 고유 구현(inherent implementations), 일관성(coherence), 패턴 "
"검사 등등)에서도 마찬가지입니다."

#: src/items/constant-items.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ConstantItem_ :  \n"
"   `const` ( [IDENTIFIER](../identifiers.md) | `_` ) `:` [_Type_](../"
"types.md#type-expressions) ( `=` [_Expression_](../expressions.md) )<sup>?</"
"sup> `;`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_상수아이템_ :  \n"
"   `const` ( [식별자](../identifiers.md) | `_` ) `:` [_타입_](../"
"types.md#type-expressions) ( `=` [_표현식_](../expressions.md) )<sup>?</"
"sup> `;`"

#: src/items/constant-items.md:13
msgid ""
"A _constant item_ is an optionally named _[constant value](../"
"const_eval.md#constant-expressions)_ which is not associated with a specific "
"memory location in the program."
msgstr ""
"_상수 아이템_은 프로그램의 특정 메모리 위치와 연관되지 않은 선택적으로 명명된 _[상수 값](../"
"const_eval.md#constant-expressions)_입니다."

#: src/items/constant-items.md:18
msgid ""
"Constants are essentially inlined wherever they are used, meaning that they "
"are copied directly into the relevant context when used. This includes usage "
"of constants from external crates, and non-[`Copy`](../special-types-and-"
"traits.md#copy) types. References to the same constant are not necessarily "
"guaranteed to refer to the same memory address."
msgstr ""
"상수는 사용되는 모든 곳에 본질적으로 인라인(inlined)되므로, 사용될 때 관련 컨텍스트로 "
"직접 복사됩니다. 여기에는 외부 크레이트의 상수 사용과, 비-[`Copy`](../special-types-"
"and-traits.md#copy) 타입의 상수가 포함됩니다. 동일한 상수에 대한 참조가 동일한 "
"메모리 주소를 참조한다고 보장할 수는 없습니다."

#: src/items/constant-items.md:25
msgid ""
"The constant declaration defines the constant value in the [value namespace]"
"(../names/namespaces.md) of the module or block where it is located."
msgstr ""
"상수 선언은 해당 모듈이나 블록의 [값 네임스페이스](../names/namespaces.md)에 "
"상수 값을 정의합니다."

#: src/items/constant-items.md:29
msgid ""
"Constants must be explicitly typed. The type must have a `'static` lifetime: "
"any references in the initializer must have `'static` lifetimes. References "
"in the type of a constant default to `'static` lifetime; see [static "
"lifetime elision](../lifetime-elision.md#const-and-static-elision)."
msgstr ""
"상수는 명시적으로 타입을 지정해야 합니다. 타입은 `'static` 라이프타임을 가져야 합니다. "
"초기화 식의 모든 참조는 `'static` 라이프타임을 가져야 합니다. 상수 타입 내의 참조는 "
"기본적으로 `'static` 라이프타임입니다. [정적 라이프타임 생략](../lifetime-elision."
"md#const-and-static-elision)을 참조하십시오."

#: src/items/constant-items.md:36
msgid ""
"A reference to a constant will have `'static` lifetime if the constant value "
"is eligible for [promotion](../destructors.md#constant-promotion); "
"otherwise, a temporary will be created."
msgstr ""
"상수 값이 [승격(promotion)](../destructors.md#constant-promotion)될 수 있는 "
"경우 상수에 대한 참조는 `'static` 라이프타임을 갖습니다. 그렇지 않으면 임시 값이 "
"생성됩니다."

#: src/items/constant-items.md:44 src/lifetime-elision.md:218
msgid "\"bitstring\""
msgstr "\"bitstring\""

#: src/items/constant-items.md:59
msgid ""
"The final value of a `const` item cannot contain references to anything "
"mutable."
msgstr ""
"`const` 아이템의 최종 값은 가변적인 것에 대한 참조를 포함할 수 없습니다."

#: src/items/constant-items.md:63
msgid ""
"The constant expression may only be omitted in a [trait definition]"
"(traits.md)."
msgstr ""
"상수 표현식은 [트레잇 정의](traits.md)에서만 생략될 수 있습니다."

#: src/items/constant-items.md:67
msgid "Constants with Destructors"
msgstr "소멸자가 있는 상수"

#: src/items/constant-items.md:69
msgid ""
"Constants can contain destructors. Destructors are run when the value goes "
"out of scope."
msgstr ""
"상수는 소멸자를 포함할 수 있습니다. 소멸자는 값이 스코프를 벗어날 때 실행됩니다."

#: src/items/constant-items.md:77
msgid "\"Dropped. Held {}.\""
msgstr "\"Dropped. Held {}.\""

#: src/items/constant-items.md:85
msgid ""
"// x gets dropped at end of function, calling drop.\n"
"    // prints \"Dropped. Held 0.\".\n"
msgstr ""
"// x는 함수가 끝날 때 드롭되어 drop을 호출합니다.\n"
"    // \"Dropped. Held 0.\"을 출력합니다.\n"

#: src/items/constant-items.md:92
msgid "Unnamed constant"
msgstr "이름 없는 상수"

#: src/items/constant-items.md:96
msgid ""
"Unlike an [associated constant](../items/associated-items.md#associated-"
"constants), a [free](../glossary.md#free-item) constant may be unnamed by "
"using an underscore instead of the name. For example:"
msgstr ""
"[연관 상수](../items/associated-items.md#associated-constants)와 달리, "
"[자유(free)](../glossary.md#free-item) 상수는 이름 대신 밑줄을 사용하여 이름 없이 "
"선언할 수 있습니다. 예를 들어:"

#: src/items/constant-items.md:101
msgid "// OK although it is the same name as above:\n"
msgstr "// 위와 같은 이름이지만 괜찮습니다:\n"

#: src/items/constant-items.md:108
msgid ""
"As with [underscore imports](use-declarations.md#underscore-imports), macros "
"may safely emit the same unnamed constant in the same scope more than once. "
"For example, the following should not produce an error:"
msgstr ""
"[밑줄 임포트](use-declarations.md#underscore-imports)와 마찬가지로, 매크로는 "
"동일한 스코프에서 동일한 이름 없는 상수를 안전하게 두 번 이상 내보낼 수 있습니다. "
"예를 들어, 다음 코드는 오류를 생성하지 않아야 합니다:"

#: src/items/constant-items.md:116
msgid ""
"// This expands to:\n"
"// const _: () = ();\n"
"// const _: () = ();\n"
msgstr ""
"// 다음과 같이 확장됩니다:\n"
"// const _: () = ();\n"
"// const _: () = ();\n"

#: src/items/constant-items.md:124
msgid "Evaluation"
msgstr "평가"

#: src/items/constant-items.md:126
msgid ""
"[Free](../glossary.md#free-item) constants are always [evaluated](../"
"const_eval.md) at compile-time to surface panics. This happens even within "
"an unused function:"
msgstr ""
"[자유(Free)](../glossary.md#free-item) 상수는 항상 컴파일 타임에 [평가되어](../"
"const_eval.md) 패닉을 드러냅니다. 이는 사용되지 않는 함수 내에서도 발생합니다:"

#: src/items/constant-items.md:130
msgid "// Compile-time panic\n"
msgstr "// 컴파일 타임 패닉\n"

#: src/items/constant-items.md:134
msgid "// A failing compile-time assertion\n"
msgstr "// 실패하는 컴파일 타임 어설션\n"

#: src/items/static-items.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_StaticItem_ :  \n"
"   [_ItemSafety_](functions.md)<sup>?</sup>[^extern-safety] `static` "
"`mut`<sup>?</sup> [IDENTIFIER](../identifiers.md) `:` [_Type_](../"
"types.md#type-expressions) ( `=` [_Expression_](../expressions.md) )<sup>?</"
"sup> `;`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_정적아이템_ :  \n"
"   [_아이템안전성_](functions.md)<sup>?</sup>[^extern-safety] `static` "
"`mut`<sup>?</sup> [식별자](../identifiers.md) `:` [_타입_](../"
"types.md#type-expressions) ( `=` [_표현식_](../expressions.md) )<sup>?</"
"sup> `;`"

#: src/items/static-items.md:12
msgid ""
"The `safe` and `unsafe` function qualifiers are only allowed semantically "
"within `extern` blocks."
msgstr ""
"`safe` 및 `unsafe` 함수 한정자는 시맨틱적으로 `extern` 블록 내에서만 허용됩니다."

#: src/items/static-items.md:17
msgid ""
"A _static item_ is similar to a [constant](constant-items.md), except that "
"it represents an allocated object in the program that is initialized with "
"the initializer expression. All references and raw pointers to the static "
"refer to the same allocated object."
msgstr ""
"_정적 아이템_은 [상수](constant-items.md)와 유사하지만, 프로그램 내에서 초기화 "
"표현식으로 초기화되는 할당된 객체를 나타낸다는 점이 다릅니다. 정적 아이템에 대한 모든 "
"참조와 원시 포인터는 동일한 할당된 객체를 참조합니다."

#: src/items/static-items.md:23
msgid ""
"Static items have the `static` lifetime, which outlives all other lifetimes "
"in a Rust program. Static items do not call [`drop`](../destructors.md) at "
"the end of the program."
msgstr ""
"정적 아이템은 `static` 라이프타임을 가지며, 이는 Rust 프로그램의 다른 모든 라이프타임보다 "
"오래 지속됩니다. 정적 아이템은 프로그램이 끝날 때 [`drop`](../destructors.md)을 호출하지 "
"않습니다."

#: src/items/static-items.md:28
msgid ""
"If the `static` has a size of at least 1 byte, this allocated object is "
"disjoint from all other such `static` objects as well as heap allocations "
"and stack-allocated variables. However, the storage of immutable `static` "
"items can overlap with objects that do not themselves have a unique address, "
"such as [promoteds](../destructors.md#constant-promotion) and [`const` items]"
"(constant-items.md)."
msgstr ""
"`static`의 크기가 최소 1바이트 이상이면, 할당된 이 객체는 다른 모든 `static` "
"객체, 힙 할당, 스택 할당 변수와 서로 겹치지 않습니다. 그러나 불변 `static` 아이템의 "
"저장 공간은 [승격된 값(promoteds)](../destructors.md#constant-promotion)이나 "
"[`const` 아이템](constant-items.md)과 같이 고유 주소가 없는 객체와 겹칠 수 있습니다."

#: src/items/static-items.md:35
msgid ""
"The static declaration defines a static value in the [value namespace](../"
"names/namespaces.md) of the module or block where it is located."
msgstr ""
"정적 선언은 해당 모듈이나 블록의 [값 네임스페이스](../names/namespaces.md)에 "
"정적 값을 정의합니다."

#: src/items/static-items.md:39
msgid ""
"The static initializer is a [constant expression](../const_eval.md#constant-"
"expressions) evaluated at compile time. Static initializers may refer to and "
"read from other statics. When reading from mutable statics, they read the "
"initial value of that static."
msgstr ""
"정적 초기화자는 컴파일 타임에 평가되는 [상수 표현식](../const_eval.md#constant-"
"expressions)입니다. 정적 초기화자는 다른 정적 아이템을 참조하고 읽을 수 있습니다. "
"가변 정적 아이템에서 읽을 때는 해당 정적 아이템의 초기 값을 읽습니다."

#: src/items/static-items.md:45
msgid ""
"Non-`mut` static items that contain a type that is not [interior mutable](../"
"interior-mutability.md) may be placed in read-only memory."
msgstr ""
"[내부 가변성(interior mutable)](../interior-mutability.md)이 없는 타입을 "
"포함하는 `mut`가 아닌 정적 아이템은 읽기 전용 메모리에 배치될 수 있습니다."

#: src/items/static-items.md:50
msgid ""
"All access to a static is safe, but there are a number of restrictions on "
"statics:"
msgstr ""
"정적 아이템에 대한 모든 접근은 안전하지만, 정적 아이템에는 몇 가지 제약 사항이 있습니다:"

#: src/items/static-items.md:55
msgid ""
"The type must have the [`Sync`](../../core/marker/trait.Sync.html) trait "
"bound to allow thread-safe access."
msgstr ""
"스레드 안전한 접근을 허용하려면 타입에 [`Sync`](../../core/marker/trait.Sync.html) "
"트레잇 바운드가 있어야 합니다."

#: src/items/static-items.md:59
msgid ""
"The initializer expression must be omitted in an [external block](external-"
"blocks.md), and must be provided for free static items."
msgstr ""
"초기화 표현식은 [외부 블록](external-blocks.md)에서는 생략되어야 하며, "
"자유(free) 정적 아이템의 경우에는 반드시 제공되어야 합니다."

#: src/items/static-items.md:64
msgid ""
"The `safe` and `unsafe` qualifiers are semantically only allowed when used "
"in an [external block](external-blocks.md)."
msgstr ""
"`safe` 및 `unsafe` 한정자는 시맨틱적으로 [외부 블록](external-blocks.md)에서 "
"사용될 때만 허용됩니다."

#: src/items/static-items.md:68
msgid "Statics & generics"
msgstr "정적 아이템과 제네릭"

#: src/items/static-items.md:70
msgid ""
"A static item defined in a generic scope (for example in a blanket or "
"default implementation) will result in exactly one static item being "
"defined, as if the static definition was pulled out of the current scope "
"into the module. There will _not_ be one item per monomorphization."
msgstr ""
"제네릭 스코프(예: blanket 또는 기본 구현)에 정의된 정적 아이템은 정적 정의가 현재 "
"스코프 밖으로 나와 모듈로 이동한 것처럼 정확히 하나의 정적 아이템만 정의되는 결과를 "
"낳습니다. 모노모르포화(monomorphization)마다 하나의 아이템이 생성되는 것은 _아닙니다_."

#: src/items/static-items.md:75
msgid "This code:"
msgstr "이 코드는:"

#: src/items/static-items.md:83
msgid "\"default_impl: counter was {}\""
msgstr "\"default_impl: 카운터는 {}였습니다\""

#: src/items/static-items.md:95
msgid "\"blanket_impl: counter was {}\""
msgstr "\"blanket_impl: 카운터는 {}였습니다\""

#: src/items/static-items.md:107
msgid "prints"
msgstr "다음과 같이 출력합니다:"

#: src/items/static-items.md:118
msgid "Mutable statics"
msgstr "가변 정적 아이템"

#: src/items/static-items.md:122
msgid ""
"If a static item is declared with the `mut` keyword, then it is allowed to "
"be modified by the program. One of Rust's goals is to make concurrency bugs "
"hard to run into, and this is obviously a very large source of race "
"conditions or other bugs"
msgstr ""
"정적 아이템이 `mut` 키워드로 선언되면, 프로그램에 의해 수정되는 것이 허용됩니다. "
"Rust의 목표 중 하나는 동시성 버그가 발생하기 어렵게 만드는 것인데, 이것은 분명히 "
"경쟁 상태(race conditions)나 다른 버그의 매우 큰 원인이 됩니다."

#: src/items/static-items.md:129
msgid ""
"For this reason, an `unsafe` block is required when either reading or "
"writing a mutable static variable. Care should be taken to ensure that "
"modifications to a mutable static are safe with respect to other threads "
"running in the same process."
msgstr ""
"이러한 이유로, 가변 정적 변수를 읽거나 쓸 때는 `unsafe` 블록이 필요합니다. 가변 정적 "
"변수에 대한 수정이 동일한 프로세스에서 실행되는 다른 스레드에 대해 안전한지 주의해야 "
"합니다."

#: src/items/static-items.md:136
msgid ""
"Mutable statics are still very useful, however. They can be used with C "
"libraries and can also be bound from C libraries in an `extern` block."
msgstr ""
"하지만 가변 정적 아이템은 여전히 매우 유용합니다. C 라이브러리와 함께 사용할 수 있으며 "
"`extern` 블록 내에서 C 라이브러리로부터 바인딩될 수도 있습니다."

#: src/items/static-items.md:143
msgid ""
"// This violates the idea of no shared state, and this doesn't internally\n"
"// protect against races, so this function is `unsafe`\n"
msgstr ""
"// 이것은 공유 상태가 없다는 아이디어를 위반하며, 내부적으로 경쟁 상태로부터\n"
"// 보호하지 않으므로, 이 함수는 `unsafe`입니다\n"

#: src/items/static-items.md:153
msgid ""
"// As an alternative to `bump_levels_unsafe`, this function is safe, "
"assuming\n"
"// that we have an atomic_add function which returns the old value. This\n"
"// function is safe only if no other code accesses the static in a non-"
"atomic\n"
"// fashion. If such accesses are possible (such as in "
"`bump_levels_unsafe`),\n"
"// then this would need to be `unsafe` to indicate to the caller that they\n"
"// must still guard against concurrent access.\n"
msgstr ""
"// `bump_levels_unsafe`의 대안으로, 이전 값을 반환하는 atomic_add 함수가\n"
"// 있다고 가정할 때 이 함수는 안전합니다. 이 함수는 다른 코드가 비원자적(non-atomic)\n"
"// 방식으로 정적 변수에 접근하지 않는 경우에만 안전합니다. 만약 그러한 접근이 가능하다면\n"
"// (`bump_levels_unsafe`에서처럼), 호출자에게 동시 접근을 여전히 막아야 함을\n"
"// 알리기 위해 `unsafe`여야 합니다.\n"

#: src/items/static-items.md:169
msgid ""
"Mutable statics have the same restrictions as normal statics, except that "
"the type does not have to implement the `Sync` trait."
msgstr ""
"가변 정적 아이템은 타입이 `Sync` 트레잇을 구현하지 않아도 된다는 점을 제외하면 "
"일반 정적 아이템과 동일한 제약 사항을 가집니다."

#: src/items/static-items.md:174
msgid "Using Statics or Consts"
msgstr "정적 아이템 또는 상수 사용하기"

#: src/items/static-items.md:176
msgid ""
"It can be confusing whether or not you should use a constant item or a "
"static item. Constants should, in general, be preferred over statics unless "
"one of the following are true:"
msgstr ""
"상수 아이템을 사용해야 할지 정적 아이템을 사용해야 할지 혼란스러울 수 있습니다. "
"다음 중 하나가 참이 아니라면 일반적으로 상수가 정적 아이템보다 선호되어야 합니다:"

#: src/items/static-items.md:180
msgid "Large amounts of data are being stored."
msgstr "대량의 데이터를 저장하고 있다."

#: src/items/static-items.md:181
msgid "The single-address property of statics is required."
msgstr "정적 아이템의 단일 주소 속성이 필요하다."

#: src/items/static-items.md:182
msgid "Interior mutability is required."
msgstr "내부 가변성(interior mutability)이 필요하다."

#: src/items/traits.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Trait_ :  \n"
"   `unsafe`<sup>?</sup> `trait` [IDENTIFIER](../identifiers.md)  "
"[_GenericParams_](generics.md)<sup>?</sup> ( `:` [_TypeParamBounds_](../"
"trait-bounds.md)<sup>?</sup> )<sup>?</sup> [_WhereClause_](generics.md#where-"
"clauses)<sup>?</sup> `{`  \n"
"     [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"     [_AssociatedItem_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_트레잇_ :  \n"
"   `unsafe`<sup>?</sup> `trait` [식별자](../identifiers.md)  "
"[_제네릭매개변수_](generics.md)<sup>?</sup> ( `:` [_타입매개변수바운드_](../"
"trait-bounds.md)<sup>?</sup> )<sup>?</sup> [_Where절_](generics.md#where-"
"clauses)<sup>?</sup> `{`  \n"
"     [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"     [_연관아이템_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"

#: src/items/traits.md:19
msgid ""
"A _trait_ describes an abstract interface that types can implement. This "
"interface consists of [associated items](associated-items.md), which come in "
"three varieties:"
msgstr ""
"_트레잇_은 타입이 구현할 수 있는 추상 인터페이스를 설명합니다. 이 인터페이스는 세 가지 "
"종류의 [연관 아이템](associated-items.md)으로 구성됩니다:"

#: src/items/traits.md:22
msgid "[functions](associated-items.md#associated-functions-and-methods)"
msgstr "[함수](associated-items.md#associated-functions-and-methods)"

#: src/items/traits.md:23
msgid "[types](associated-items.md#associated-types)"
msgstr "[타입](associated-items.md#associated-types)"

#: src/items/traits.md:24
msgid "[constants](associated-items.md#associated-constants)"
msgstr "[상수](associated-items.md#associated-constants)"

#: src/items/traits.md:28
msgid ""
"The trait declaration defines a trait in the [type namespace](../names/"
"namespaces.md) of the module or block where it is located."
msgstr ""
"트레잇 선언은 해당 모듈이나 블록의 [타입 네임스페이스](../names/namespaces.md)에 "
"트레잇을 정의합니다."

#: src/items/traits.md:32
msgid ""
"Associated items are defined as members of the trait within their respective "
"namespaces. Associated types are defined in the type namespace. Associated "
"constants and associated functions are defined in the value namespace."
msgstr ""
"연관 아이템은 트레잇의 멤버로서 각각의 네임스페이스 내에 정의됩니다. 연관 타입은 "
"타입 네임스페이스에 정의됩니다. 연관 상수와 연관 함수는 값 네임스페이스에 정의됩니다."

#: src/items/traits.md:36
msgid ""
"All traits define an implicit type parameter `Self` that refers to \"the "
"type that is implementing this interface\". Traits may also contain "
"additional type parameters. These type parameters, including `Self`, may be "
"constrained by other traits and so forth [as usual](generics.md)."
msgstr ""
"모든 트레잇은 \"이 인터페이스를 구현하는 타입\"을 참조하는 암시적 타입 매개변수 `Self`를 "
"정의합니다. 트레잇은 추가적인 타입 매개변수도 포함할 수 있습니다. `Self`를 포함한 이러한 "
"타입 매개변수는 [일반적인 방식대로](generics.md) 다른 트레잇 등에 의해 제약될 수 "
"있습니다."

#: src/items/traits.md:43
msgid ""
"Traits are implemented for specific types through separate [implementations]"
"(implementations.md)."
msgstr ""
"트레잇은 별도의 [구현](implementations.md)을 통해 특정 타입에 대해 구현됩니다."

#: src/items/traits.md:47
msgid ""
"Trait functions may omit the function body by replacing it with a semicolon. "
"This indicates that the implementation must define the function. If the "
"trait function defines a body, this definition acts as a default for any "
"implementation which does not override it. Similarly, associated constants "
"may omit the equals sign and expression to indicate implementations must "
"define the constant value. Associated types must never define the type, the "
"type may only be specified in an implementation."
msgstr ""
"트레잇 함수는 함수 본문을 세미콜론으로 대체하여 생략할 수 있습니다. 이는 구현에서 "
"함수를 정의해야 함을 나타냅니다. 트레잇 함수가 본문을 정의하면, 이 정의는 이를 오버라이드하지 "
"않는 구현에 대한 기본값으로 작동합니다. 마찬가지로, 연관 상수는 등호와 표현식을 생략하여 "
"구현에서 상수 값을 정의해야 함을 나타낼 수 있습니다. 연관 타입은 타입을 절대 정의해서는 "
"안 되며, 타입은 오직 구현에서만 지정될 수 있습니다."

#: src/items/traits.md:56
msgid "// Examples of associated trait items with and without definitions.\n"
msgstr "// 정의가 있거나 없는 연관 트레잇 아이템의 예시.\n"

#: src/items/traits.md:68
msgid ""
"Trait functions are not allowed to be [`const`](functions.md#const-"
"functions)."
msgstr ""
"트레잇 함수는 [`const`](functions.md#const-functions)가 될 수 없습니다."

#: src/items/traits.md:72
msgid "Trait bounds"
msgstr "트레잇 바운드"

#: src/items/traits.md:74
msgid ""
"Generic items may use traits as [bounds](../trait-bounds.md) on their type "
"parameters."
msgstr ""
"제네릭 아이템은 타입 매개변수에 대한 [바운드](../trait-bounds.md)로 트레잇을 사용할 수 "
"있습니다."

#: src/items/traits.md:78
msgid "Generic traits"
msgstr "제네릭 트레잇"

#: src/items/traits.md:80
msgid ""
"Type parameters can be specified for a trait to make it generic. These "
"appear after the trait name, using the same syntax used in [generic "
"functions](functions.md#generic-functions)."
msgstr ""
"타입 매개변수를 지정하여 트레잇을 제네릭으로 만들 수 있습니다. 이는 [제네릭 함수]"
"(functions.md#generic-functions)에서 사용되는 것과 동일한 구문을 사용하여 트레잇 이름 "
"뒤에 나타납니다."

#: src/items/traits.md:91
msgid "<a id=\"object-safety\"></a>"
msgstr "<a id=\"object-safety\"></a>"

#: src/items/traits.md:94
msgid "Dyn compatibility"
msgstr "Dyn 호환성"

#: src/items/traits.md:98
msgid ""
"A dyn-compatible trait can be the base trait of a [trait object](../types/"
"trait-object.md). A trait is _dyn compatible_ if it has the following "
"qualities:"
msgstr ""
"dyn 호환(dyn-compatible) 트레잇은 [트레잇 객체](../types/trait-object.md)의 기본 "
"트레잇이 될 수 있습니다. 트레잇은 다음 조건을 충족하면 _dyn 호환_입니다:"

#: src/items/traits.md:103
msgid "All [supertraits](#supertraits) must also be dyn compatible."
msgstr "모든 [슈퍼트레잇](#supertraits)도 dyn 호환이어야 합니다."

#: src/items/traits.md:107
msgid ""
"`Sized` must not be a [supertrait](#supertraits). In other words, it must "
"not require `Self: Sized`."
msgstr ""
"`Sized`는 [슈퍼트레잇](#supertraits)이 아니어야 합니다. 다시 말해, `Self: Sized`를 "
"요구하지 않아야 합니다."

#: src/items/traits.md:111
msgid "It must not have any associated constants."
msgstr "연관 상수를 갖지 않아야 합니다."

#: src/items/traits.md:115
msgid "It must not have any associated types with generics."
msgstr "제네릭을 포함한 연관 타입을 갖지 않아야 합니다."

#: src/items/traits.md:119
msgid ""
"All associated functions must either be dispatchable from a trait object or "
"be explicitly non-dispatchable:"
msgstr ""
"모든 연관 함수는 트레잇 객체에서 디스패치 가능하거나(dispatchable) 명시적으로 "
"디스패치 불가능해야 합니다:"

#: src/items/traits.md:120
msgid "Dispatchable functions must:"
msgstr "디스패치 가능한 함수는 다음 조건을 만족해야 합니다:"

#: src/items/traits.md:121
msgid ""
"Not have any type parameters (although lifetime parameters are allowed)."
msgstr "타입 매개변수를 갖지 않아야 합니다(라이프타임 매개변수는 허용됨)."

#: src/items/traits.md:122
msgid ""
"Be a [method](associated-items.md#methods) that does not use `Self` except "
"in the type of the receiver."
msgstr ""
"수신자(receiver)의 타입 이외에는 `Self`를 사용하지 않는 [메서드](associated-"
"items.md#methods)여야 합니다."

#: src/items/traits.md:123
msgid "Have a receiver with one of the following types:"
msgstr "다음 중 하나의 타입을 가진 수신자를 가져야 합니다:"

#: src/items/traits.md:124
msgid "`&Self` (i.e. `&self`)"
msgstr "`&Self` (즉, `&self`)"

#: src/items/traits.md:125
msgid "`&mut Self` (i.e `&mut self`)"
msgstr "`&mut Self` (즉, `&mut self`)"

#: src/items/traits.md:126
msgid "[`Box<Self>`](../special-types-and-traits.md#boxt)"
msgstr "[`Box<Self>`](../special-types-and-traits.md#boxt)"

#: src/items/traits.md:127
msgid "[`Rc<Self>`](../special-types-and-traits.md#rct)"
msgstr "[`Rc<Self>`](../special-types-and-traits.md#rct)"

#: src/items/traits.md:128
msgid "[`Arc<Self>`](../special-types-and-traits.md#arct)"
msgstr "[`Arc<Self>`](../special-types-and-traits.md#arct)"

#: src/items/traits.md:129
msgid ""
"[`Pin<P>`](../special-types-and-traits.md#pinp) where `P` is one of the "
"types above"
msgstr ""
"[`Pin<P>`](../special-types-and-traits.md#pinp) (여기서 `P`는 위의 타입 중 하나)"

#: src/items/traits.md:130
msgid "Not have an opaque return type; that is,"
msgstr "불투명한(opaque) 반환 타입을 갖지 않아야 합니다. 즉,"

#: src/items/traits.md:131
msgid "Not be an `async fn` (which has a hidden `Future` type)."
msgstr "`async fn`이 아니어야 합니다(숨겨진 `Future` 타입을 가짐)."

#: src/items/traits.md:132
msgid ""
"Not have a return position `impl Trait` type (`fn example(&self) -> impl "
"Trait`)."
msgstr ""
"반환 위치 `impl Trait` 타입을 갖지 않아야 합니다(`fn example(&self) -> impl "
"Trait`)."

#: src/items/traits.md:133
msgid ""
"Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) "
"implies this)."
msgstr ""
"`where Self: Sized` 바운드를 갖지 않아야 합니다(`Self` 수신자 타입(즉, `self`)은 "
"이를 암시합니다)."

#: src/items/traits.md:134
msgid "Explicitly non-dispatchable functions require:"
msgstr "명시적으로 디스패치 불가능한 함수는 다음을 요구합니다:"

#: src/items/traits.md:135
msgid ""
"Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) "
"implies this)."
msgstr ""
"`where Self: Sized` 바운드를 가져야 합니다(`Self` 수신자 타입(즉, `self`)은 이를 "
"암시합니다)."

#: src/items/traits.md:139
msgid ""
"The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html), "
"[`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html), and "
"[`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits "
"are not dyn-compatible."
msgstr ""
"[`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html), [`AsyncFnMut`]"
"(../../core/ops/async_function/trait.AsyncFnMut.html), 및 [`AsyncFnOnce`]"
"(../../core/ops/async_function/trait.AsyncFnOnce.html) 트레잇은 dyn 호환이 "
"아닙니다."

#: src/items/traits.md:141
msgid "**Note**: This concept was formerly known as _object safety_."
msgstr "**참고**: 이 개념은 이전에 _객체 안전성(object safety)_으로 알려져 있었습니다."

#: src/items/traits.md:146
msgid "// Examples of dyn compatible methods.\n"
msgstr "// dyn 호환 메서드의 예시.\n"

#: src/items/traits.md:164
msgid ""
"// This trait is dyn compatible, but these methods cannot be dispatched on a "
"trait object.\n"
msgstr ""
"// 이 트레잇은 dyn 호환이지만, 이 메서드들은 트레잇 객체에서 디스패치될 수 없습니다.\n"

#: src/items/traits.md:166
msgid "// Non-methods cannot be dispatched.\n"
msgstr "// 비-메서드(Non-methods)는 디스패치될 수 없습니다.\n"

#: src/items/traits.md:168
msgid "// Self type isn't known until runtime.\n"
msgstr "// Self 타입은 런타임까지 알 수 없습니다.\n"

#: src/items/traits.md:170
msgid "// `other` may be a different concrete type of the receiver.\n"
msgstr "// `other`는 수신자와 다른 구체적인 타입일 수 있습니다.\n"

#: src/items/traits.md:172
msgid "// Generics are not compatible with vtables.\n"
msgstr "// 제네릭은 vtable과 호환되지 않습니다.\n"

#: src/items/traits.md:181
msgid "// ERROR: cannot call with Self return\n"
msgstr "// 오류: Self 반환으로 호출할 수 없음\n"

#: src/items/traits.md:182
msgid "// ERROR: cannot call with Self parameter\n"
msgstr "// 오류: Self 매개변수로 호출할 수 없음\n"

#: src/items/traits.md:183
msgid "// ERROR: cannot call with generic type\n"
msgstr "// 오류: 제네릭 타입으로 호출할 수 없음\n"

#: src/items/traits.md:187
msgid "// Examples of dyn-incompatible traits.\n"
msgstr "// dyn 호환이 아닌 트레잇의 예시.\n"

#: src/items/traits.md:190
msgid "// ERROR: cannot have associated const\n"
msgstr "// 오류: 연관 상수를 가질 수 없음\n"

#: src/items/traits.md:192
msgid "// ERROR: associated function without Sized\n"
msgstr "// 오류: Sized 없는 연관 함수\n"

#: src/items/traits.md:193
msgid "// ERROR: Self in return type\n"
msgstr "// 오류: 반환 타입에 `Self`가 있음\n"

#: src/items/traits.md:194
msgid "// ERROR: has generic type parameters\n"
msgstr "// 오류: 제네릭 타입 매개변수가 있음\n"

#: src/items/traits.md:195
msgid "// ERROR: nested receiver not yet supported\n"
msgstr "// 오류: 중첩된 수신자는 아직 지원되지 않음\n"

#: src/items/traits.md:202 src/items/traits.md:211 src/destructors.md:461
#: src/destructors.md:462
msgid "// ERROR\n"
msgstr "// 오류\n"

#: src/items/traits.md:206
msgid "// `Self: Sized` traits are dyn-incompatible.\n"
msgstr "// `Self: Sized` 트레잇은 dyn 호환이 아닙니다.\n"

#: src/items/traits.md:215
msgid "// Dyn-incompatible if `Self` is a type argument.\n"
msgstr "// `Self`가 타입 인수인 경우 dyn 호환이 아닙니다.\n"

#: src/items/traits.md:222
msgid "// ERROR: cannot use `Self` type parameter\n"
msgstr "// 오류: `Self` 타입 매개변수를 사용할 수 없음\n"

#: src/items/traits.md:227
msgid "Supertraits"
msgstr "슈퍼트레잇"

#: src/items/traits.md:231
msgid ""
"**Supertraits** are traits that are required to be implemented for a type to "
"implement a specific trait. Furthermore, anywhere a [generic](generics.md) "
"or [trait object](../types/trait-object.md) is bounded by a trait, it has "
"access to the associated items of its supertraits."
msgstr ""
"**슈퍼트레잇(Supertraits)**은 특정 트레잇을 구현하기 위해 타입이 반드시 구현해야 하는 "
"트레잇입니다. 또한, [제네릭](generics.md)이나 [트레잇 객체](../types/trait-object.md)가 "
"트레잇으로 바운딩된 곳이면 어디서나 그 슈퍼트레잇의 연관 아이템에 접근할 수 있습니다."

#: src/items/traits.md:237
msgid ""
"Supertraits are declared by trait bounds on the `Self` type of a trait and "
"transitively the supertraits of the traits declared in those trait bounds. "
"It is an error for a trait to be its own supertrait."
msgstr ""
"슈퍼트레잇은 트레잇의 `Self` 타입에 대한 트레잇 바운드와, 해당 트레잇 바운드에 "
"선언된 트레잇의 슈퍼트레잇을 통해 추이적으로 선언됩니다. 트레잇이 자기 자신의 "
"슈퍼트레잇이 되는 것은 오류입니다."

#: src/items/traits.md:243
msgid "The trait with a supertrait is called a **subtrait** of its supertrait."
msgstr "슈퍼트레잇을 가진 트레잇을 그 슈퍼트레잇의 **서브트레잇(subtrait)**이라고 합니다."

#: src/items/traits.md:245
msgid ""
"The following is an example of declaring `Shape` to be a supertrait of "
"`Circle`."
msgstr "다음은 `Shape`를 `Circle`의 슈퍼트레잇으로 선언하는 예입니다."

#: src/items/traits.md:252
msgid ""
"And the following is the same example, except using [where clauses]"
"(generics.md#where-clauses)."
msgstr ""
"그리고 다음은 [Where 절](generics.md#where-clauses)을 사용한 것을 제외하고는 "
"동일한 예입니다."

#: src/items/traits.md:259
msgid ""
"This next example gives `radius` a default implementation using the `area` "
"function from `Shape`."
msgstr ""
"다음 예제는 `Shape`의 `area` 함수를 사용하여 `radius`에 기본 구현을 제공합니다."

#: src/items/traits.md:266
msgid ""
"// A = pi * r^2\n"
"        // so algebraically,\n"
"        // r = sqrt(A / pi)\n"
msgstr ""
"// A = pi * r^2\n"
"        // 따라서 대수적으로,\n"
"        // r = sqrt(A / pi)\n"

#: src/items/traits.md:274
msgid "This next example calls a supertrait method on a generic parameter."
msgstr "다음 예제는 제네릭 매개변수에서 슈퍼트레잇 메서드를 호출합니다."

#: src/items/traits.md:280
msgid ""
"// Here we call the area method from the supertrait `Shape` of `Circle`.\n"
msgstr "// 여기서 우리는 `Circle`의 슈퍼트레잇 `Shape`의 area 메서드를 호출합니다.\n"

#: src/items/traits.md:281
msgid "\"Area: {}\""
msgstr "\"면적: {}\""

#: src/items/traits.md:282
msgid "\"Radius: {}\""
msgstr "\"반지름: {}\""

#: src/items/traits.md:286
msgid ""
"Similarly, here is an example of calling supertrait methods on trait objects."
msgstr "마찬가지로, 다음은 트레잇 객체에서 슈퍼트레잇 메서드를 호출하는 예입니다."

#: src/items/traits.md:301
msgid "Unsafe traits"
msgstr "Unsafe 트레잇"

#: src/items/traits.md:305
msgid ""
"Traits items that begin with the `unsafe` keyword indicate that "
"_implementing_ the trait may be [unsafe](../unsafety.md). It is safe to use "
"a correctly implemented unsafe trait. The [trait implementation]"
"(implementations.md#trait-implementations) must also begin with the `unsafe` "
"keyword."
msgstr ""
"`unsafe` 키워드로 시작하는 트레잇 아이템은 해당 트레잇을 _구현_하는 것이 [안전하지 않을 수 있음]"
"(../unsafety.md)을 나타냅니다. 올바르게 구현된 unsafe 트레잇을 사용하는 것은 "
"안전합니다. [트레잇 구현](implementations.md#trait-implementations) 역시 "
"`unsafe` 키워드로 시작해야 합니다."

#: src/items/traits.md:309
msgid ""
"[`Sync`](../special-types-and-traits.md#sync) and [`Send`](../special-types-"
"and-traits.md#send) are examples of unsafe traits."
msgstr ""
"[`Sync`](../special-types-and-traits.md#sync)와 [`Send`](../special-types-"
"and-traits.md#send)는 unsafe 트레잇의 예입니다."

#: src/items/traits.md:313
msgid "Parameter patterns"
msgstr "매개변수 패턴"

#: src/items/traits.md:317
msgid ""
"Function or method declarations without a body only allow [IDENTIFIER](../"
"identifiers.md) or `_` [wild card](../patterns.md#wildcard-pattern) "
"patterns. `mut` [IDENTIFIER](../identifiers.md) is currently allowed, but it "
"is deprecated and will become a hard error in the future."
msgstr ""
"본문이 없는 함수 또는 메서드 선언은 [식별자](../identifiers.md) 또는 `_` [와일드카드]"
"(../patterns.md#wildcard-pattern) 패턴만 허용합니다. `mut` [식별자](../identifiers.md)는 "
"현재 허용되지만, 더 이상 사용되지 않으며(deprecated) 미래에는 오류가 될 것입니다."

#: src/items/traits.md:324
msgid ""
"In the 2015 edition, the pattern for a trait function or method parameter is "
"optional:"
msgstr ""
"2015 에디션에서 트레잇 함수 또는 메서드 매개변수의 패턴은 선택 사항입니다:"

#: src/items/traits.md:328 src/paths.md:233
msgid "// 2015 Edition\n"
msgstr "// 2015 에디션\n"

#: src/items/traits.md:330
msgid "// Parameter identifiers are not required.\n"
msgstr "// 매개변수 식별자는 필요하지 않습니다.\n"

#: src/items/traits.md:336
msgid ""
"The kinds of patterns for parameters is limited to one of the following:"
msgstr "매개변수에 대한 패턴의 종류는 다음 중 하나로 제한됩니다:"

#: src/items/traits.md:338
msgid "[IDENTIFIER](../identifiers.md)"
msgstr "[식별자](../identifiers.md)"

#: src/items/traits.md:339
msgid "`mut` [IDENTIFIER](../identifiers.md)"
msgstr "`mut` [식별자](../identifiers.md)"

#: src/items/traits.md:340
msgid "[`_`](../patterns.md#wildcard-pattern)"
msgstr "[`_`](../patterns.md#wildcard-pattern)"

#: src/items/traits.md:341
msgid "`&` [IDENTIFIER](../identifiers.md)"
msgstr "`&` [식별자](../identifiers.md)"

#: src/items/traits.md:342
msgid "`&&` [IDENTIFIER](../identifiers.md)"
msgstr "`&&` [식별자](../identifiers.md)"

#: src/items/traits.md:346
msgid ""
"Beginning in the 2018 edition, function or method parameter patterns are no "
"longer optional. Also, all irrefutable patterns are allowed as long as there "
"is a body. Without a body, the limitations listed above are still in effect."
msgstr ""
"2018 에디션부터는 함수 또는 메서드 매개변수 패턴이 더 이상 선택 사항이 아닙니다. "
"또한, 본문이 있는 한 모든 반박 불가능한(irrefutable) 패턴이 허용됩니다. 본문이 없는 "
"경우 위에 나열된 제한 사항이 여전히 적용됩니다."

#: src/items/traits.md:353
msgid "// Cannot use tuple pattern without a body.\n"
msgstr "// 본문 없이는 튜플 패턴을 사용할 수 없습니다.\n"

#: src/items/traits.md:359
msgid "Item visibility"
msgstr "아이템 가시성"

#: src/items/traits.md:363
msgid ""
"Trait items syntactically allow a [_Visibility_](../visibility-and-"
"privacy.md) annotation, but this is rejected when the trait is validated. "
"This allows items to be parsed with a unified syntax across different "
"contexts where they are used. As an example, an empty `vis` macro fragment "
"specifier can be used for trait items, where the macro rule may be used in "
"other situations where visibility is allowed."
msgstr ""
"트레잇 아이템은 구문적으로 [_가시성_](../visibility-and-privacy.md) 주석을 허용하지만, "
"트레잇이 검증될 때 거부됩니다. 이는 아이템이 사용되는 여러 컨텍스트에서 통일된 구문으로 "
"파싱될 수 있도록 하기 위함입니다. 예를 들어, 빈 `vis` 매크로 조각(fragment) "
"지정자는 트레잇 아이템에 사용될 수 있으며, 여기서 매크로 규칙은 가시성이 허용되는 다른 "
"상황에서도 사용될 수 있습니다."

#: src/items/traits.md:384
msgid "// Visibility is allowed here.\n"
msgstr "// 여기서 가시성은 허용됩니다.\n"

#: src/items/implementations.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Implementation_ :  \n"
"   _InherentImpl_ | _TraitImpl_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_구현_ :  \n"
"   _고유구현_ | _트레잇구현_"

#: src/items/implementations.md:11
msgid ""
"_InherentImpl_ :  \n"
"   `impl` [_GenericParams_](generics.md)<sup>?</sup> [_Type_](../"
"types.md#type-expressions) [_WhereClause_](generics.md#where-clauses)<sup>?</"
"sup> `{`  \n"
"      [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"      [_AssociatedItem_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"
msgstr ""
"_고유구현_ :  \n"
"   `impl` [_제네릭매개변수_](generics.md)<sup>?</sup> [_타입_](../"
"types.md#type-expressions) [_Where절_](generics.md#where-clauses)<sup>?</"
"sup> `{`  \n"
"      [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"      [_연관아이템_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"

#: src/items/implementations.md:17
msgid ""
"_TraitImpl_ :  \n"
"   `unsafe`<sup>?</sup> `impl` [_GenericParams_](generics.md)<sup>?</sup> `!"
"`<sup>?</sup> [_TypePath_](../paths.md#paths-in-types) `for` [_Type_](../"
"types.md#type-expressions)  \n"
"   [_WhereClause_](generics.md#where-clauses)<sup>?</sup>  \n"
"   `{`  \n"
"      [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"      [_AssociatedItem_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"
msgstr ""
"_트레잇구현_ :  \n"
"   `unsafe`<sup>?</sup> `impl` [_제네릭매개변수_](generics.md)<sup>?</sup> `!"
"`<sup>?</sup> [_타입경로_](../paths.md#paths-in-types) `for` [_타입_](../"
"types.md#type-expressions)  \n"
"   [_Where절_](generics.md#where-clauses)<sup>?</sup>  \n"
"   `{`  \n"
"      [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"      [_연관아이템_](associated-items.md)<sup>\\*</sup>  \n"
"   `}`"

#: src/items/implementations.md:28
msgid ""
"An _implementation_ is an item that associates items with an _implementing "
"type_. Implementations are defined with the keyword `impl` and contain "
"functions that belong to an instance of the type that is being implemented "
"or to the type statically."
msgstr ""
"_구현(implementation)_은 아이템을 _구현 타입(implementing type)_과 연관시키는 "
"아이템입니다. 구현은 `impl` 키워드로 정의되며, 구현되는 타입의 인스턴스에 속하거나 "
"타입에 정적으로 속하는 함수들을 포함합니다."

#: src/items/implementations.md:35
msgid "There are two types of implementations:"
msgstr "구현에는 두 가지 유형이 있습니다."

#: src/items/implementations.md:37
msgid "inherent implementations"
msgstr "고유 구현(inherent implementations)"

#: src/items/implementations.md:38
msgid "[trait](traits.md) implementations"
msgstr "[트레잇(trait)](traits.md) 구현"

#: src/items/implementations.md:42
msgid "Inherent Implementations"
msgstr "고유 구현"

#: src/items/implementations.md:46
msgid ""
"An inherent implementation is defined as the sequence of the `impl` keyword, "
"generic type declarations, a path to a nominal type, a where clause, and a "
"bracketed set of associable items."
msgstr ""
"고유 구현은 `impl` 키워드, 제네릭 타입 선언, 명목상 타입(nominal type)으로의 경로, "
"Where 절, 그리고 중괄호로 묶인 연관 가능한 아이템 집합의 시퀀스로 정의됩니다."

#: src/items/implementations.md:52
msgid ""
"The nominal type is called the _implementing type_ and the associable items "
"are the _associated items_ to the implementing type."
msgstr ""
"이 명목상 타입을 _구현 타입_이라고 하며, 연관 가능한 아이템들은 구현 타입에 대한 "
"_연관 아이템(associated items)_입니다."

#: src/items/implementations.md:57
msgid ""
"Inherent implementations associate the contained items to the implementing "
"type."
msgstr "고유 구현은 포함된 아이템들을 구현 타입과 연관시킵니다."

#: src/items/implementations.md:62
msgid ""
"Inherent implementations can contain [associated functions](associated-"
"items.md#associated-functions-and-methods) (including [methods](associated-"
"items.md#methods)) and [associated constants](associated-items.md#associated-"
"constants)."
msgstr ""
"고유 구현은 [연관 함수](associated-items.md#associated-functions-and-methods)"
"([메서드](associated-items.md#methods) 포함)와 [연관 상수](associated-items.md#associated-constants)"
"를 포함할 수 있습니다."

#: src/items/implementations.md:66
msgid "They cannot contain associated type aliases."
msgstr "연관 타입 별칭은 포함할 수 없습니다."

#: src/items/implementations.md:70
msgid ""
"The [path](../paths.md) to an associated item is any path to the "
"implementing type, followed by the associated item's identifier as the final "
"path component."
msgstr ""
"연관 아이템으로의 [경로](../paths.md)는 구현 타입으로의 임의의 경로 뒤에, "
"마지막 경로 구성 요소로서 연관 아이템의 식별자가 오는 형태입니다."

#: src/items/implementations.md:76
msgid ""
"A type can also have multiple inherent implementations. An implementing type "
"must be defined within the same crate as the original type definition."
msgstr ""
"하나의 타입은 여러 개의 고유 구현을 가질 수도 있습니다. 구현 타입은 반드시 "
"원본 타입 정의와 동일한 크레이트 내에서 정의되어야 합니다."

#: src/items/implementations.md:99
msgid "// Actual path to the implementing type and impl in the same module.\n"
msgstr "// 같은 모듈 내의 구현 타입과 구현에 대한 실제 경로.\n"

#: src/items/implementations.md:102
msgid ""
"// Impl blocks in different modules are still accessed through a path to the "
"type.\n"
msgstr "// 서로 다른 모듈에 있는 구현 블록들도 여전히 타입을 통한 경로로 접근됩니다.\n"

#: src/items/implementations.md:105
msgid "// Re-exported paths to the implementing type also work.\n"
msgstr "// 구현 타입에 대해 다시 내보내기(re-exported)된 경로들도 작동합니다.\n"

#: src/items/implementations.md:108
msgid ""
"// Does not work, because use in `values` is not pub.\n"
"    // values::Color::red();\n"
msgstr ""
"// 작동하지 않습니다. `values` 내의 사용(use)이 pub이 아니기 때문입니다.\n"
"    // values::Color::red();\n"

#: src/items/implementations.md:115
msgid "Trait Implementations"
msgstr "트레잇 구현"

#: src/items/implementations.md:119
msgid ""
"A _trait implementation_ is defined like an inherent implementation except "
"that the optional generic type declarations are followed by a [trait]"
"(traits.md), followed by the keyword `for`, followed by a path to a nominal "
"type."
msgstr ""
"_트레잇 구현_은 고유 구현과 비슷하게 정의되지만, 선택적인 제네릭 타입 선언 뒤에 "
"[트레잇](traits.md)이 오고, 그 뒤에 `for` 키워드와 명목상 타입으로의 경로가 온다는 "
"점이 다릅니다."

#: src/items/implementations.md:127
msgid ""
"The trait is known as the _implemented trait_. The implementing type "
"implements the implemented trait."
msgstr ""
"이 트레잇을 _구현된 트레잇_이라고 합니다. 구현 타입은 구현된 트레잇을 "
"구현합니다."

#: src/items/implementations.md:132
msgid ""
"A trait implementation must define all non-default associated items declared "
"by the implemented trait, may redefine default associated items defined by "
"the implemented trait, and cannot define any other items."
msgstr ""
"트레잇 구현은 구현된 트레잇에 선언된 기본값이 없는 모든 연관 아이템을 정의해야 하며, "
"구현된 트레잇에 정의된 기본 연관 아이템을 재정의할 수 있습니다. 그 외의 다른 "
"아이템은 정의할 수 없습니다."

#: src/items/implementations.md:138
msgid ""
"The path to the associated items is `<` followed by a path to the "
"implementing type followed by `as` followed by a path to the trait followed "
"by `>` as a path component followed by the associated item's path component."
msgstr ""
"연관 아이템으로의 경로는, 경로 구성 요소로서 `<` 뒤에 구현 타입 경로, 그 뒤에 `as`, "
"그 뒤에 트레잇 경로, 그 뒤에 `>`가 오고, 그 다음에 연관 아이템의 경로 구성 요소가 "
"오는 형태입니다."

#: src/items/implementations.md:144
msgid ""
"[Unsafe traits](traits.md#unsafe-traits) require the trait implementation to "
"begin with the `unsafe` keyword."
msgstr ""
"[Unsafe 트레잇](traits.md#unsafe-traits)은 트레잇 구현이 `unsafe` 키워드로 "
"시작할 것을 요구합니다."

#: src/items/implementations.md:181
msgid "Trait Implementation Coherence"
msgstr "트레잇 구현 일관성"

#: src/items/implementations.md:185
msgid ""
"A trait implementation is considered incoherent if either the orphan rules "
"check fails or there are overlapping implementation instances."
msgstr ""
"트레잇 구현은 고아 규칙(orphan rules) 검사에 실패하거나 중복되는 구현 인스턴스가 "
"있는 경우 일관성이 없는(incoherent) 것으로 간주됩니다."

#: src/items/implementations.md:190
msgid ""
"Two trait implementations overlap when there is a non-empty intersection of "
"the traits the implementation is for, the implementations can be "
"instantiated with the same type. <!-- This is probably wrong? Source: No two "
"implementations can\n"
"be instantiable with the same set of types for the input type parameters. -->"
msgstr ""
"두 트레잇 구현은 구현 대상 트레잇들의 교집합이 비어 있지 않고, 해당 구현들이 "
"동일한 타입으로 인스턴스화될 수 있을 때 중복(overlap)됩니다. <!-- 이것은 아마도 틀렸을 수 있습니다? "
"출처: 입력 타입 매개변수에 대해 동일한 타입 집합으로 인스턴스화할 수 있는 구현은 "
"둘 이상 존재할 수 없습니다. -->"

#: src/items/implementations.md:197
msgid "Orphan rules"
msgstr "고아 규칙"

#: src/items/implementations.md:201
msgid ""
"Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at "
"least one of the following is true:"
msgstr ""
"`impl<P1..=Pn> Trait<T1..=Tn> for T0`가 주어졌을 때, `impl`은 다음 중 "
"최소 하나가 참인 경우에만 유효합니다."

#: src/items/implementations.md:204
msgid "`Trait` is a [local trait](../glossary.md#local-trait)"
msgstr "`Trait`가 [로컬 트레잇](../glossary.md#local-trait)인 경우"

#: src/items/implementations.md:205
msgid "All of"
msgstr "다음 모두를 만족하는 경우"

#: src/items/implementations.md:206
msgid ""
"At least one of the types `T0..=Tn` must be a [local type](../"
"glossary.md#local-type). Let `Ti` be the first such type."
msgstr ""
"타입 `T0..=Tn` 중 적어도 하나는 [로컬 타입](../glossary.md#local-type)이어야 합니다. "
"이러한 첫 번째 타입을 `Ti`라고 합시다."

#: src/items/implementations.md:208
msgid ""
"No [uncovered type](../glossary.md#uncovered-type) parameters `P1..=Pn` may "
"appear in `T0..Ti` (excluding `Ti`)"
msgstr ""
"`T0..Ti`(`Ti` 제외)에는 [덮이지 않은 타입(uncovered type)](../glossary.md#uncovered-type) "
"매개변수 `P1..=Pn`이 나타날 수 없습니다."

#: src/items/implementations.md:213
msgid "Only the appearance of _uncovered_ type parameters is restricted."
msgstr "_덮이지 않은_ 타입 매개변수의 출현만이 제한됩니다."

#: src/items/implementations.md:217
msgid ""
"Note that for the purposes of coherence, [fundamental types](../"
"glossary.md#fundamental-type-constructors) are special. The `T` in `Box<T>` "
"is not considered covered, and `Box<LocalType>` is considered local."
msgstr ""
"일관성을 위해 [기초 타입(fundamental types)](../glossary.md#fundamental-type-constructors)은 "
"특별하게 취급된다는 점에 유의하세요. `Box<T>`에서 `T`는 덮인 것으로 간주되지 않으며, "
"`Box<LocalType>`은 로컬로 간주됩니다."

#: src/items/implementations.md:223
msgid "Generic Implementations"
msgstr "제네릭 구현"

#: src/items/implementations.md:227
msgid ""
"An implementation can take [generic parameters](generics.md), which can be "
"used in the rest of the implementation. Implementation parameters are "
"written directly after the `impl` keyword."
msgstr ""
"구현은 [제네릭 매개변수](generics.md)를 가질 수 있으며, 이는 구현의 나머지 부분에서 "
"사용될 수 있습니다. 구현 매개변수는 `impl` 키워드 바로 뒤에 작성됩니다."

#: src/items/implementations.md:237
msgid "/* Treat the integer as a sequence of bits */"
msgstr "/* 정수를 비트 시퀀스로 취급 */"

#: src/items/implementations.md:243
msgid ""
"Generic parameters _constrain_ an implementation if the parameter appears at "
"least once in one of:"
msgstr ""
"제네릭 매개변수가 다음 중 하나에 한 번이라도 나타나면 해당 구현을 _제약(constrain)_합니다."

#: src/items/implementations.md:246
msgid "The implemented trait, if it has one"
msgstr "구현된 트레잇(있는 경우)"

#: src/items/implementations.md:247
msgid "The implementing type"
msgstr "구현 타입"

#: src/items/implementations.md:248
msgid ""
"As an [associated type](associated-items.md#associated-types) in the [bounds]"
"(../trait-bounds.md) of a type that contains another parameter that "
"constrains the implementation"
msgstr ""
"구현을 제약하는 다른 매개변수를 포함하는 타입의 [바운드](../trait-bounds.md)에 있는 "
"[연관 타입](associated-items.md#associated-types)으로서"

#: src/items/implementations.md:253
msgid ""
"Type and const parameters must always constrain the implementation. "
"Lifetimes must constrain the implementation if the lifetime is used in an "
"associated type."
msgstr ""
"타입 및 상수(const) 매개변수는 반드시 구현을 제약해야 합니다. 라이프타임은 "
"연관 타입에서 사용되는 경우 반드시 구현을 제약해야 합니다."

#: src/items/implementations.md:256
msgid "Examples of constraining situations:"
msgstr "제약하는 상황의 예시:"

#: src/items/implementations.md:264
msgid "// T constrains by being an argument to GenericTrait.\n"
msgstr "// T는 GenericTrait의 인수가 됨으로써 제약합니다.\n"

#: src/items/implementations.md:267
msgid "// T constrains by being an argument to GenericStruct\n"
msgstr "// T는 GenericStruct의 인수가 됨으로써 제약합니다.\n"

#: src/items/implementations.md:270
msgid "// Likewise, N constrains by being an argument to ConstGenericStruct\n"
msgstr "// 마찬가지로, N은 ConstGenericStruct의 인수가 됨으로써 제약합니다.\n"

#: src/items/implementations.md:273
msgid ""
"// T constrains by being in an associated type in a bound for type `U` which "
"is\n"
"// itself a generic parameter constraining the trait.\n"
msgstr ""
"// T는 트레잇을 제약하는 제네릭 매개변수인 타입 `U`에 대한 바운드의\n"
"// 연관 타입 안에 있음으로써 제약합니다.\n"

#: src/items/implementations.md:277
msgid ""
"// Like previous, except the type is `(U, isize)`. `U` appears inside the "
"type\n"
"// that includes `T`, and is not the type itself.\n"
msgstr ""
"// 이전과 비슷하지만, 타입이 `(U, isize)`라는 점이 다릅니다. `U`는 `T`를 포함하는\n"
"// 타입 내부에 나타나며, 타입 자체는 아닙니다.\n"

#: src/items/implementations.md:283
msgid "Examples of non-constraining situations:"
msgstr "제약하지 않는 상황의 예시:"

#: src/items/implementations.md:286
msgid ""
"// 이 아래는 모두 오류입니다. 제약하지 않는 타입 또는 상수 매개변수를 "
"가지고 있기\n"
"// 때문입니다.\n"

#: src/items/implementations.md:288
msgid "// T does not constrain since it does not appear at all.\n"
msgstr "// T는 전혀 나타나지 않으므로 제약하지 않습니다.\n"

#: src/items/implementations.md:291
msgid "// N does not constrain for the same reason.\n"
msgstr "// N도 같은 이유로 제약하지 않습니다.\n"

#: src/items/implementations.md:294
msgid "// Usage of T inside the implementation does not constrain the impl.\n"
msgstr "// 구현 내부에서의 T의 사용은 구현을 제약하지 않습니다.\n"

#: src/items/implementations.md:299
msgid ""
"// T is used as an associated type in the bounds for U, but U does not "
"constrain.\n"
msgstr "// T는 U에 대한 바운드의 연관 타입으로 사용되지만, U가 제약하지 않습니다.\n"

#: src/items/implementations.md:302
msgid ""
"// T is used in the bounds, but not as an associated type, so it does not "
"constrain.\n"
msgstr "// T는 바운드에서 사용되지만, 연관 타입으로서가 아니므로 제약하지 않습니다.\n"

#: src/items/implementations.md:307
msgid "Example of an allowed unconstraining lifetime parameter:"
msgstr "허용되는, 제약하지 않는 라이프타임 매개변수의 예:"

#: src/items/implementations.md:314
msgid "Example of a disallowed unconstraining lifetime parameter:"
msgstr "허용되지 않는, 제약하지 않는 라이프타임 매개변수의 예:"

#: src/items/implementations.md:326
msgid "Attributes on Implementations"
msgstr "구현의 속성"

#: src/items/implementations.md:328
msgid ""
"Implementations may contain outer [attributes](../attributes.md) before the "
"`impl` keyword and inner [attributes](../attributes.md) inside the brackets "
"that contain the associated items. Inner attributes must come before any "
"associated items. The attributes that have meaning here are [`cfg`](../"
"conditional-compilation.md), [`deprecated`](../attributes/diagnostics.md#the-"
"deprecated-attribute), [`doc`](../../rustdoc/the-doc-attribute.html), and "
"[the lint check attributes](../attributes/diagnostics.md#lint-check-"
"attributes)."
msgstr ""
"구현은 `impl` 키워드 앞에 외부 [속성](../attributes.md)을, 연관 아이템을 "
"포함하는 중괄호 안에 내부 [속성](../attributes.md)을 가질 수 있습니다. "
"내부 속성은 반드시 모든 연관 아이템보다 먼저 와야 합니다. 여기서 의미를 "
"갖는 속성은 [`cfg`](../conditional-compilation.md), [`deprecated`]"
"(../attributes/diagnostics.md#the-deprecated-attribute), [`doc`]"
"(../../rustdoc/the-doc-attribute.html), 그리고 [린트 검사 속성]"
"(../attributes/diagnostics.md#lint-check-attributes)입니다."

#: src/items/external-blocks.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ExternBlock_ :  \n"
"   `unsafe`<sup>?</sup>[^unsafe-2024] `extern` [_Abi_](functions.md)<sup>?</"
"sup> `{`  \n"
"      [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"      _ExternalItem_<sup>\\*</sup>  \n"
"   `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_외부블록_ :  \n"
"   `unsafe`<sup>?</sup>[^unsafe-2024] `extern` [_Abi_](functions.md)<sup>?</"
"sup> `{`  \n"
"      [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"      _외부아이템_<sup>\\*</sup>  \n"
"   `}`"

#: src/items/external-blocks.md:14
msgid ""
"_ExternalItem_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> (  \n"
"         [_MacroInvocationSemi_](../macros.md#macro-invocation)  \n"
"      | ( [_Visibility_](../visibility-and-privacy.md)<sup>?</sup> "
"( [_StaticItem_](static-items.md) | [_Function_](functions.md) ) )  \n"
"   )"
msgstr ""
"_외부아이템_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> (  \n"
"         [_세미콜론매크로호출_](../macros.md#macro-invocation)  \n"
"      | ( [_가시성_](../visibility-and-privacy.md)<sup>?</sup> "
"( [_정적아이템_](static-items.md) | [_함수_](functions.md) ) )  \n"
"   )"

#: src/items/external-blocks.md:20
msgid ""
"Starting with the 2024 Edition, the `unsafe` keyword is required "
"semantically."
msgstr "2024 에디션부터는 `unsafe` 키워드가 시맨틱적으로 요구됩니다."

#: src/items/external-blocks.md:24
msgid ""
"External blocks provide _declarations_ of items that are not _defined_ in "
"the current crate and are the basis of Rust's foreign function interface. "
"These are akin to unchecked imports."
msgstr ""
"외부 블록은 현재 크레이트에서 _정의_되지 않은 아이템의 _선언_을 제공하며, "
"Rust의 외부 함수 인터페이스(foreign function interface)의 기초가 됩니다. "
"이들은 검사되지 않은 임포트(unchecked imports)와 유사합니다."

#: src/items/external-blocks.md:30
msgid ""
"Two kinds of item _declarations_ are allowed in external blocks: [functions]"
"(functions.md) and [statics](static-items.md)."
msgstr ""
"외부 블록에서는 두 가지 종류의 아이템 _선언_이 허용됩니다: [함수](functions.md)와 "
"[정적 아이템(statics)](static-items.md)입니다."

#: src/items/external-blocks.md:35
msgid ""
"Calling functions or accessing statics that are declared in external blocks "
"is only allowed in an `unsafe` context."
msgstr ""
"외부 블록에 선언된 함수를 호출하거나 정적 아이템에 접근하는 것은 오직 "
"`unsafe` 컨텍스트에서만 허용됩니다."

#: src/items/external-blocks.md:39
msgid ""
"The external block defines its functions and statics in the [value namespace]"
"(../names/namespaces.md) of the module or block where it is located."
msgstr ""
"외부 블록은 해당 모듈이나 블록의 [값 네임스페이스](../names/namespaces.md)에 "
"함수와 정적 아이템을 정의합니다."

#: src/items/external-blocks.md:43
msgid ""
"The `unsafe` keyword is semantically required to appear before the `extern` "
"keyword on external blocks."
msgstr ""
"`unsafe` 키워드는 외부 블록의 `extern` 키워드 앞에 나타나도록 시맨틱적으로 "
"요구됩니다."

#: src/items/external-blocks.md:47
msgid ""
"**Edition differences**: Prior to the 2024 edition, the `unsafe` keyword is "
"optional. The `safe` and `unsafe` item qualifiers are only allowed if the "
"external block itself is marked as `unsafe`."
msgstr ""
"**에디션 차이**: 2024 에디션 이전에는 `unsafe` 키워드가 선택 사항입니다. "
"`safe` 및 `unsafe` 아이템 한정자는 외부 블록 자체가 `unsafe`로 표시된 경우에만 "
"허용됩니다."

#: src/items/external-blocks.md:55
msgid ""
"Functions within external blocks are declared in the same way as other Rust "
"functions, with the exception that they must not have a body and are instead "
"terminated by a semicolon."
msgstr ""
"외부 블록 내의 함수는 다른 Rust 함수와 동일한 방식으로 선언되지만, 본문을 "
"가질 수 없으며 대신 세미콜론으로 끝난다는 점이 다릅니다."

#: src/items/external-blocks.md:61
msgid ""
"Patterns are not allowed in parameters, only [IDENTIFIER](../identifiers.md) "
"or `_` may be used."
msgstr ""
"매개변수에는 패턴이 허용되지 않으며, [식별자](../identifiers.md) 또는 `_`만 "
"사용할 수 있습니다."

#: src/items/external-blocks.md:65
msgid ""
"The `safe` and `unsafe` function qualifiers are allowed, but other function "
"qualifiers (e.g. `const`, `async`, `extern`) are not."
msgstr ""
"`safe` 및 `unsafe` 함수 한정자는 허용되지만, 다른 함수 한정자(예: `const`, "
"`async`, `extern`)는 허용되지 않습니다."

#: src/items/external-blocks.md:71
msgid ""
"Functions within external blocks may be called by Rust code, just like "
"functions defined in Rust. The Rust compiler automatically translates "
"between the Rust ABI and the foreign ABI."
msgstr ""
"외부 블록 내의 함수는 Rust에서 정의된 함수와 마찬가지로 Rust 코드에서 "
"호출될 수 있습니다. Rust 컴파일러는 Rust ABI와 외부 ABI 간의 변환을 "
"자동으로 처리합니다."

#: src/items/external-blocks.md:77
msgid ""
"A function declared in an extern block is implicitly `unsafe` unless the "
"`safe` function qualifier is present."
msgstr ""
"외부 블록에 선언된 함수는 `safe` 함수 한정자가 없는 한 암시적으로 "
"`unsafe`입니다."

#: src/items/external-blocks.md:82
msgid ""
"When coerced to a function pointer, a function declared in an extern block "
"has type `extern \"abi\" for<'l1, ..., 'lm> fn(A1, ..., An) -> R`, where "
"`'l1`, ... `'lm` are its lifetime parameters, `A1`, ..., `An` are the "
"declared types of its parameters, `R` is the declared return type."
msgstr ""
"함수 포인터로 강제 변환될 때, 외부 블록에 선언된 함수는 `extern \"abi\" "
"for<'l1, ..., 'lm> fn(A1, ..., An) -> R` 타입을 갖습니다. 여기서 "
"`'l1`, ..., `'lm`은 라이프타임 매개변수이고, `A1`, ..., `An`은 선언된 "
"매개변수 타입이며, `R`은 선언된 반환 타입입니다."

#: src/items/external-blocks.md:89
msgid "Statics"
msgstr "정적 아이템"

#: src/items/external-blocks.md:93
msgid ""
"Statics within external blocks are declared in the same way as [statics]"
"(static-items.md) outside of external blocks, except that they do not have "
"an expression initializing their value."
msgstr ""
"외부 블록 내의 정적 아이템은 외부 블록 밖의 [정적 아이템](static-items.md)과 "
"동일한 방식으로 선언되지만, 값을 초기화하는 표현식을 갖지 않는다는 점이 다릅니다."

#: src/items/external-blocks.md:98
msgid ""
"Unless a static item declared in an extern block is qualified as `safe`, it "
"is `unsafe` to access that item, whether or not it's mutable, because there "
"is nothing guaranteeing that the bit pattern at the static's memory is valid "
"for the type it is declared with, since some arbitrary (e.g. C) code is in "
"charge of initializing the static."
msgstr ""
"외부 블록에 선언된 정적 아이템이 `safe`로 한정되지 않는 한, 해당 아이템에 "
"접근하는 것은 가변성 여부와 상관없이 `unsafe`입니다. 왜냐하면 임의의 "
"(예: C) 코드가 정적 아이템의 초기화를 담당하므로, 해당 메모리의 비트 "
"패턴이 선언된 타입에 대해 유효하다는 보장이 없기 때문입니다."

#: src/items/external-blocks.md:105
msgid ""
"Extern statics can be either immutable or mutable just like [statics](static-"
"items.md) outside of external blocks."
msgstr ""
"외부 정적 아이템은 외부 블록 밖의 [정적 아이템](static-items.md)과 마찬가지로 "
"불변이거나 가변일 수 있습니다."

#: src/items/external-blocks.md:109
msgid ""
"An immutable static _must_ be initialized before any Rust code is executed. "
"It is not enough for the static to be initialized before Rust code reads "
"from it. Once Rust code runs, mutating an immutable static (from inside or "
"outside Rust) is UB, except if the mutation happens to bytes inside of an "
"`UnsafeCell`."
msgstr ""
"불변 정적 아이템은 어떠한 Rust 코드가 실행되기 전에 반드시 초기화되어야 합니다. "
"Rust 코드가 그것을 읽기 전에 초기화되는 것만으로는 충분하지 않습니다. 일단 Rust "
"코드가 실행되면, 불변 정적 아이템을 (Rust 내부에서든 외부에서든) 수정하는 "
"것은 `UnsafeCell` 내부의 바이트에 대한 수정이 아닌 한 정의되지 않은 동작(UB)입니다."

#: src/items/external-blocks.md:116
msgid "ABI"
msgstr "ABI"

#: src/items/external-blocks.md:120
msgid ""
"By default external blocks assume that the library they are calling uses the "
"standard C ABI on the specific platform. Other ABIs may be specified using "
"an `abi` string, as shown here:"
msgstr ""
"기본적으로 외부 블록은 호출하는 라이브러리가 해당 플랫폼의 표준 C ABI를 "
"사용한다고 가정합니다. 다음 예시와 같이 `abi` 문자열을 사용하여 다른 "
"ABI를 지정할 수 있습니다."

#: src/items/external-blocks.md:125
msgid "// Interface to the Windows API\n"
msgstr "// Windows API 인터페이스\n"

#: src/items/external-blocks.md:132
msgid ""
"There are three ABI strings which are cross-platform, and which all "
"compilers are guaranteed to support:"
msgstr ""
"모든 컴파일러가 지원하도록 보장된 세 가지 크로스 플랫폼 ABI 문자열이 있습니다."

#: src/items/external-blocks.md:137
msgid ""
"`unsafe extern \"Rust\"` -- The default ABI when you write a normal `fn "
"foo()` in any Rust code."
msgstr ""
"`unsafe extern \"Rust\"` -- Rust 코드에서 일반적인 `fn foo()`를 작성할 때의 기본 ABI입니다."

#: src/items/external-blocks.md:142
msgid ""
"`unsafe extern \"C\"` -- This is the same as `extern fn foo()`; whatever the "
"default your C compiler supports."
msgstr ""
"`unsafe extern \"C\"` -- `extern fn foo()`와 동일합니다. C 컴파일러가 지원하는 "
"기본값입니다."

#: src/items/external-blocks.md:147
msgid ""
"`unsafe extern \"system\"` -- Usually the same as `extern \"C\"`, except on "
"Win32, in which case it's `\"stdcall\"`, or what you should use to link to "
"the Windows API itself"
msgstr ""
"`unsafe extern \"system\"` -- 보통 `extern \"C\"`와 동일하지만, Win32에서는 "
"`\"stdcall\"`이며, Windows API 자체에 링크할 때 사용해야 하는 ABI입니다."

#: src/items/external-blocks.md:153
msgid "There are also some platform-specific ABI strings:"
msgstr "플랫폼별로 특화된 ABI 문자열들도 있습니다."

#: src/items/external-blocks.md:157
msgid "`unsafe extern \"cdecl\"` -- The default for x86\\_32 C code."
msgstr "`unsafe extern \"cdecl\"` -- x86\\_32 C 코드의 기본값입니다."

#: src/items/external-blocks.md:161
msgid ""
"`unsafe extern \"stdcall\"` -- The default for the Win32 API on x86\\_32."
msgstr ""
"`unsafe extern \"stdcall\"` -- x86\\_32 환경의 Win32 API 기본값입니다."

#: src/items/external-blocks.md:165
msgid ""
"`unsafe extern \"win64\"` -- The default for C code on x86\\_64 Windows."
msgstr ""
"`unsafe extern \"win64\"` -- x86\\_64 Windows 환경의 C 코드 기본값입니다."

#: src/items/external-blocks.md:169
msgid ""
"`unsafe extern \"sysv64\"` -- The default for C code on non-Windows x86\\_64."
msgstr ""
"`unsafe extern \"sysv64\"` -- Windows가 아닌 x86\\_64 환경의 C 코드 기본값입니다."

#: src/items/external-blocks.md:173
msgid "`unsafe extern \"aapcs\"` -- The default for ARM."
msgstr "`unsafe extern \"aapcs\"` -- ARM의 기본값입니다."

#: src/items/external-blocks.md:177
msgid ""
"`unsafe extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's "
"`__fastcall` and GCC and clang's `__attribute__((fastcall))`"
msgstr ""
"`unsafe extern \"fastcall\"` -- `fastcall` ABI입니다. MSVC의 `__fastcall` 및 "
"GCC와 clang의 `__attribute__((fastcall))`에 해당합니다."

#: src/items/external-blocks.md:182
msgid ""
"`unsafe extern \"thiscall\"` -- The default for C++ member functions on MSVC "
"-- corresponds to MSVC's `__thiscall` and GCC and clang's "
"`__attribute__((thiscall))`"
msgstr ""
"`unsafe extern \"thiscall\"` -- MSVC 환경의 C++ 멤버 함수 기본값입니다. MSVC의 "
"`__thiscall` 및 GCC와 clang의 `__attribute__((thiscall))`에 해당합니다."

#: src/items/external-blocks.md:187
msgid ""
"`unsafe extern \"efiapi\"` -- The ABI used for [UEFI](https://uefi.org/"
"specifications) functions."
msgstr ""
"`unsafe extern \"efiapi\"` -- [UEFI](https://uefi.org/specifications) "
"함수에 사용되는 ABI입니다."

#: src/items/external-blocks.md:191
msgid "Variadic functions"
msgstr "가변 인자 함수"

#: src/items/external-blocks.md:193
msgid ""
"Functions within external blocks may be variadic by specifying `...` as the "
"last argument. The variadic parameter may optionally be specified with an "
"identifier."
msgstr ""
"외부 블록 내의 함수는 마지막 인수로 `...`을 지정하여 가변 인자 함수가 될 수 있습니다. "
"가변 인자 매개변수는 선택적으로 식별자를 가질 수 있습니다."

#: src/items/external-blocks.md:207
msgid "Attributes on extern blocks"
msgstr "외부 블록의 속성"

#: src/items/external-blocks.md:211
msgid ""
"The following [attributes](../attributes.md) control the behavior of "
"external blocks."
msgstr ""
"다음 [속성들](../attributes.md)은 외부 블록의 동작을 제어합니다."

#: src/items/external-blocks.md:215
msgid "The `link` attribute"
msgstr "`link` 속성"

#: src/items/external-blocks.md:219
msgid ""
"The _`link` attribute_ specifies the name of a native library that the "
"compiler should link with for the items within an `extern` block."
msgstr ""
"_`link` 속성_은 `extern` 블록 내의 아이템들을 위해 컴파일러가 링크해야 할 "
"네이티브 라이브러리의 이름을 지정합니다."

#: src/items/external-blocks.md:224
msgid ""
"It uses the [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-"
"syntax) syntax to specify its inputs. The `name` key is the name of the "
"native library to link. The `kind` key is an optional value which specifies "
"the kind of library with the following possible values:"
msgstr ""
"이 속성은 입력을 지정하기 위해 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) "
"구문을 사용합니다. `name` 키는 링크할 네이티브 라이브러리의 이름입니다. "
"`kind` 키는 라이브러리의 종류를 지정하는 선택적 값이며, 다음과 같은 값들이 가능합니다."

#: src/items/external-blocks.md:230
msgid ""
"`dylib` --- Indicates a dynamic library. This is the default if `kind` is "
"not specified."
msgstr ""
"`dylib` --- 동적 라이브러리임을 나타냅니다. `kind`가 지정되지 않은 경우의 기본값입니다."

#: src/items/external-blocks.md:235
msgid "`static` --- Indicates a static library."
msgstr "`static` --- 정적 라이브러리임을 나타냅니다."

#: src/items/external-blocks.md:239
msgid ""
"`framework` --- Indicates a macOS framework. This is only valid for macOS "
"targets."
msgstr ""
"`framework` --- macOS 프레임워크임을 나타냅니다. macOS 타겟인 경우에만 유효합니다."

#: src/items/external-blocks.md:244
msgid ""
"`raw-dylib` --- Indicates a dynamic library where the compiler will generate "
"an import library to link against (see [`dylib` versus `raw-dylib`](#dylib-"
"versus-raw-dylib) below for details). This is only valid for Windows targets."
msgstr ""
"`raw-dylib` --- 컴파일러가 링크를 위해 임포트 라이브러리를 생성할 동적 "
"라이브러리임을 나타냅니다(자세한 내용은 아래의 [`dylib` 대 `raw-dylib`](#dylib-versus-raw-dylib) "
"섹션을 참조하세요). Windows 타겟인 경우에만 유효합니다."

#: src/items/external-blocks.md:250
msgid "The `name` key must be included if `kind` is specified."
msgstr "`kind`가 지정된 경우 `name` 키가 반드시 포함되어야 합니다."

#: src/items/external-blocks.md:254
msgid ""
"The optional `modifiers` argument is a way to specify linking modifiers for "
"the library to link."
msgstr ""
"선택적인 `modifiers` 인수는 링크할 라이브러리에 대해 링크 수정자(linking modifiers)를 "
"지정하는 방법입니다."

#: src/items/external-blocks.md:259
msgid ""
"Modifiers are specified as a comma-delimited string with each modifier "
"prefixed with either a `+` or `-` to indicate that the modifier is enabled "
"or disabled, respectively."
msgstr ""
"수정자들은 쉼표로 구분된 문자열로 지정하며, 각 수정자 앞에 `+` 또는 `-`를 "
"붙여서 각각 해당 수정자의 활성화 또는 비활성화 여부를 나타냅니다."

#: src/items/external-blocks.md:265
msgid ""
"Specifying multiple `modifiers` arguments in a single `link` attribute, or "
"multiple identical modifiers in the same `modifiers` argument is not "
"currently supported.   \n"
"Example: `#[link(name = \"mylib\", kind = \"static\", modifiers = \"+whole-"
"archive\")]`."
msgstr ""
"단일 `link` 속성 내에 여러 `modifiers` 인수를 지정하거나, 동일한 `modifiers` "
"인수 내에 중복된 수정자를 지정하는 것은 현재 지원되지 않습니다.   \n"
"예시: `#[link(name = \"mylib\", kind = \"static\", modifiers = \"+whole-archive\")]`."

#: src/items/external-blocks.md:271
msgid ""
"The `wasm_import_module` key may be used to specify the [WebAssembly module]"
"(https://webassembly.github.io/spec/core/syntax/modules.html) name for the "
"items within an `extern` block when importing symbols from the host "
"environment. The default module name is `env` if `wasm_import_module` is not "
"specified."
msgstr ""
"`wasm_import_module` 키는 호스트 환경으로부터 심볼을 임포트할 때 `extern` "
"블록 내 아이템들에 대한 [WebAssembly 모듈](https://webassembly.github.io/spec/core/syntax/modules.html) "
"이름을 지정하는 데 사용될 수 있습니다. `wasm_import_module`이 지정되지 않은 경우 "
"기본 모듈 이름은 `env`입니다."

#: src/items/external-blocks.md:278
msgid "\"crypto\""
msgstr "\"crypto\""

#: src/items/external-blocks.md:280 src/items/external-blocks.md:285
#: src/items/external-blocks.md:290 src/attributes/testing.md:77
msgid "// …\n"
msgstr "// …\n"

#: src/items/external-blocks.md:283
msgid "\"CoreFoundation\""
msgstr "\"CoreFoundation\""

#: src/items/external-blocks.md:283
msgid "\"framework\""
msgstr "\"framework\""

#: src/items/external-blocks.md:296
msgid ""
"It is valid to add the `link` attribute on an empty extern block. You can "
"use this to satisfy the linking requirements of extern blocks elsewhere in "
"your code (including upstream crates) instead of adding the attribute to "
"each extern block."
msgstr ""
"비어 있는 외부 블록에 `link` 속성을 추가하는 것도 유효합니다. 이를 통해 각 "
"외부 블록마다 속성을 추가하는 대신, 코드의 다른 부분(업스트림 크레이트 포함)에 "
"있는 외부 블록들의 링크 요구 사항을 충족시킬 수 있습니다."

#: src/items/external-blocks.md:303
msgid "Linking modifiers: `bundle`"
msgstr "링크 수정자: `bundle`"

#: src/items/external-blocks.md:307 src/items/external-blocks.md:342
msgid ""
"This modifier is only compatible with the `static` linking kind. Using any "
"other kind will result in a compiler error."
msgstr ""
"이 수정자는 `static` 링크 종류와만 호환됩니다. 다른 종류를 사용하면 컴파일러 "
"오류가 발생합니다."

#: src/items/external-blocks.md:312
msgid ""
"When building a rlib or staticlib `+bundle` means that the native static "
"library will be packed into the rlib or staticlib archive, and then "
"retrieved from there during linking of the final binary."
msgstr ""
"rlib나 staticlib을 빌드할 때 `+bundle`은 네이티브 정적 라이브러리가 rlib나 "
"staticlib 아카이브에 포함되고, 나중에 최종 바이너리를 링크할 때 그곳에서 "
"추출된다는 것을 의미합니다."

#: src/items/external-blocks.md:318
msgid ""
"When building a rlib `-bundle` means that the native static library is "
"registered as a dependency of that rlib \"by name\", and object files from "
"it are included only during linking of the final binary, the file search by "
"that name is also performed during final linking.   \n"
"When building a staticlib `-bundle` means that the native static library is "
"simply not included into the archive and some higher level build system will "
"need to add it later during linking of the final binary."
msgstr ""
"rlib를 빌드할 때 `-bundle`은 네이티브 정적 라이브러리가 해당 rlib의 의존성으로 "
"\"이름에 의해\" 등록되며, 해당 라이브러리의 객체 파일들은 최종 바이너리를 "
"링크할 때만 포함된다는 것을 의미합니다. 해당 이름에 의한 파일 검색 또한 최종 "
"링크 시점에 수행됩니다.   \n"
"staticlib을 빌드할 때 `-bundle`은 네이티브 정적 라이브러리가 아카이브에 "
"포함되지 않으며, 나중에 최종 바이너리를 링크할 때 더 높은 수준의 빌드 시스템에서 "
"이를 추가해야 함을 의미합니다."

#: src/items/external-blocks.md:327
msgid ""
"This modifier has no effect when building other targets like executables or "
"dynamic libraries."
msgstr ""
"이 수정자는 실행 파일이나 동적 라이브러리와 같은 다른 타겟을 빌드할 때는 "
"아무런 효과가 없습니다."

#: src/items/external-blocks.md:331
msgid "The default for this modifier is `+bundle`."
msgstr "이 수정자의 기본값은 `+bundle`입니다."

#: src/items/external-blocks.md:333
msgid ""
"More implementation details about this modifier can be found in [`bundle` "
"documentation for rustc](../../rustc/command-line-arguments.html#linking-"
"modifiers-bundle)."
msgstr ""
"이 수정자에 대한 더 자세한 구현 세부 사항은 [rustc의 `bundle` 문서]"
"(../../rustc/command-line-arguments.html#linking-modifiers-bundle)에서 "
"확인할 수 있습니다."

#: src/items/external-blocks.md:338
msgid "Linking modifiers: `whole-archive`"
msgstr "링크 수정자: `whole-archive`"

#: src/items/external-blocks.md:347
msgid ""
"`+whole-archive` means that the static library is linked as a whole archive "
"without throwing any object files away."
msgstr ""
"`+whole-archive`는 정적 라이브러리가 객체 파일을 하나도 버리지 않고 아카이브 "
"전체로서 링크된다는 것을 의미합니다."

#: src/items/external-blocks.md:352
msgid "The default for this modifier is `-whole-archive`."
msgstr "이 수정자의 기본값은 `-whole-archive`입니다."

#: src/items/external-blocks.md:354
msgid ""
"More implementation details about this modifier can be found in [`whole-"
"archive` documentation for rustc](../../rustc/command-line-"
"arguments.html#linking-modifiers-whole-archive)."
msgstr ""
"이 수정자에 대한 더 자세한 구현 세부 사항은 [rustc의 `whole-archive` 문서]"
"(../../rustc/command-line-arguments.html#linking-modifiers-whole-archive)에서 "
"확인할 수 있습니다."

#: src/items/external-blocks.md:359
msgid "Linking modifiers: `verbatim`"
msgstr "링크 수정자: `verbatim`"

#: src/items/external-blocks.md:363
msgid "This modifier is compatible with all linking kinds."
msgstr "이 수정자는 모든 링크 종류와 호환됩니다."

#: src/items/external-blocks.md:367
msgid ""
"`+verbatim` means that rustc itself won't add any target-specified library "
"prefixes or suffixes (like `lib` or `.a`) to the library name, and will try "
"its best to ask for the same thing from the linker."
msgstr ""
"`+verbatim`은 rustc가 라이브러리 이름에 타겟별 라이브러리 접두사나 접미사"
"(`lib` 또는 `.a` 등)를 직접 추가하지 않으며, 링커에게도 동일하게 요청하도록 "
"최선을 다한다는 것을 의미합니다."

#: src/items/external-blocks.md:373
msgid ""
"`-verbatim` means that rustc will either add a target-specific prefix and "
"suffix to the library name before passing it to linker, or won't prevent "
"linker from implicitly adding it."
msgstr ""
"`-verbatim`은 rustc가 라이브러리 이름을 링커에 전달하기 전에 타겟별 접두사와 "
"접미사를 추가하거나, 링커가 암시적으로 이를 추가하는 것을 막지 않는다는 것을 "
"의미합니다."

#: src/items/external-blocks.md:378
msgid "The default for this modifier is `-verbatim`."
msgstr "이 수정자의 기본값은 `-verbatim`입니다."

#: src/items/external-blocks.md:380
msgid ""
"More implementation details about this modifier can be found in [`verbatim` "
"documentation for rustc](../../rustc/command-line-arguments.html#linking-"
"modifiers-verbatim)."
msgstr ""
"이 수정자에 대한 더 자세한 구현 세부 사항은 [rustc의 `verbatim` 문서]"
"(../../rustc/command-line-arguments.html#linking-modifiers-verbatim)에서 "
"확인할 수 있습니다."

#: src/items/external-blocks.md:385
msgid "`dylib` versus `raw-dylib`"
msgstr "`dylib` 대 `raw-dylib`"

#: src/items/external-blocks.md:389
msgid ""
"On Windows, linking against a dynamic library requires that an import "
"library is provided to the linker: this is a special static library that "
"declares all of the symbols exported by the dynamic library in such a way "
"that the linker knows that they have to be dynamically loaded at runtime."
msgstr ""
"Windows에서 동적 라이브러리에 링크하려면 링커에 임포트 라이브러리(import library)를 "
"제공해야 합니다. 이것은 동적 라이브러리가 내보내는 모든 심볼을 선언하여, 링커가 "
"해당 심볼들이 런타임에 동적으로 로드되어야 함을 알 수 있게 해주는 특별한 "
"정적 라이브러리입니다."

#: src/items/external-blocks.md:396
msgid ""
"Specifying `kind = \"dylib\"` instructs the Rust compiler to link an import "
"library based on the `name` key. The linker will then use its normal library "
"resolution logic to find that import library. Alternatively, specifying "
"`kind = \"raw-dylib\"` instructs the compiler to generate an import library "
"during compilation and provide that to the linker instead."
msgstr ""
"`kind = \"dylib\"`을 지정하면 Rust 컴파일러가 `name` 키에 기반한 임포트 "
"라이브러리를 링크하도록 지시합니다. 그러면 링커는 일반적인 라이브러리 "
"해석 로직을 사용하여 해당 임포트 라이브러리를 찾습니다. 반면에, "
"`kind = \"raw-dylib\"`을 지정하면 컴파일러가 컴파일 중에 직접 임포트 "
"라이브러리를 생성하여 링커에 제공하도록 지시합니다."

#: src/items/external-blocks.md:404
msgid ""
"`raw-dylib` is only supported on Windows. Using it when targeting other "
"platforms will result in a compiler error."
msgstr ""
"`raw-dylib`은 Windows에서만 지원됩니다. 다른 플랫폼을 타겟으로 할 때 "
"사용하면 컴파일러 오류가 발생합니다."

#: src/items/external-blocks.md:409
msgid "The `import_name_type` key"
msgstr "`import_name_type` 키"

#: src/items/external-blocks.md:413
msgid ""
"On x86 Windows, names of functions are \"decorated\" (i.e., have a specific "
"prefix and/or suffix added) to indicate their calling convention. For "
"example, a `stdcall` calling convention function with the name `fn1` that "
"has no arguments would be decorated as `_fn1@0`. However, the [PE Format]"
"(https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type) "
"does also permit names to have no prefix or be undecorated. Additionally, "
"the MSVC and GNU toolchains use different decorations for the same calling "
"conventions which means, by default, some Win32 functions cannot be called "
"using the `raw-dylib` link kind via the GNU toolchain."
msgstr ""
"x86 Windows에서 함수 이름은 호출 규약(calling convention)을 나타내기 위해 "
"\"장식(decorated)\"됩니다(즉, 특정 접두사나 접미사가 추가됩니다). 예를 들어, "
"인수가 없는 `fn1`이라는 이름의 `stdcall` 호출 규약 함수는 `_fn1@0`으로 "
"장식됩니다. 하지만 [PE 포맷](https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type)은 "
"접두사가 없거나 장식되지 않은 이름도 허용합니다. 또한 MSVC와 GNU "
"툴체인은 동일한 호출 규약에 대해 서로 다른 장식을 사용하므로, 기본적으로 "
"일부 Win32 함수들은 GNU 툴체인을 통해 `raw-dylib` 링크 종류를 사용하여 "
"호출할 수 없습니다."

#: src/items/external-blocks.md:424
msgid ""
"To allow for these differences, when using the `raw-dylib` link kind you may "
"also specify the `import_name_type` key with one of the following values to "
"change how functions are named in the generated import library:"
msgstr ""
"이러한 차이점을 해결하기 위해, `raw-dylib` 링크 종류를 사용할 때 "
"`import_name_type` 키에 다음 값 중 하나를 지정하여 생성된 임포트 "
"라이브러리 내 함수 이름 지정 방식을 변경할 수 있습니다."

#: src/items/external-blocks.md:428
msgid ""
"`decorated`: The function name will be fully-decorated using the MSVC "
"toolchain format."
msgstr ""
"`decorated`: 함수 이름이 MSVC 툴체인 형식을 사용하여 완전히 장식됩니다."

#: src/items/external-blocks.md:430
msgid ""
"`noprefix`: The function name will be decorated using the MSVC toolchain "
"format, but skipping the leading `?`, `@`, or optionally `_`."
msgstr ""
"`noprefix`: 함수 이름이 MSVC 툴체인 형식을 사용하여 장식되지만, 앞의 "
"`?`, `@` 또는 선택적으로 `_`를 생략합니다."

#: src/items/external-blocks.md:432
msgid "`undecorated`: The function name will not be decorated."
msgstr "`undecorated`: 함수 이름이 장식되지 않습니다."

#: src/items/external-blocks.md:436
msgid ""
"If the `import_name_type` key is not specified, then the function name will "
"be fully-decorated using the target toolchain's format."
msgstr ""
"`import_name_type` 키가 지정되지 않으면, 함수 이름은 타겟 툴체인의 형식을 "
"사용하여 완전히 장식됩니다."

#: src/items/external-blocks.md:441
msgid ""
"Variables are never decorated and so the `import_name_type` key has no "
"effect on how they are named in the generated import library."
msgstr ""
"변수는 절대 장식되지 않으므로, `import_name_type` 키는 생성된 임포트 "
"라이브러리 내 변수 이름에 아무런 영향을 주지 않습니다."

#: src/items/external-blocks.md:446
msgid ""
"The `import_name_type` key is only supported on x86 Windows. Using it when "
"targeting other platforms will result in a compiler error."
msgstr ""
"`import_name_type` 키는 x86 Windows에서만 지원됩니다. 다른 플랫폼을 타겟으로 "
"할 때 사용하면 컴파일러 오류가 발생합니다."

#: src/items/external-blocks.md:451
msgid "The `link_name` attribute"
msgstr "`link_name` 속성"

#: src/items/external-blocks.md:455
msgid ""
"The _`link_name` attribute_ may be specified on declarations inside an "
"`extern` block to indicate the symbol to import for the given function or "
"static."
msgstr ""
"_`link_name` 속성_은 `extern` 블록 내의 선언에 지정되어 해당 함수나 "
"정적 아이템을 위해 임포트할 심볼을 나타낼 수 있습니다."

#: src/items/external-blocks.md:460
msgid ""
"It uses the [_MetaNameValueStr_](../attributes.md#meta-item-attribute-"
"syntax) syntax to specify the name of the symbol."
msgstr ""
"심볼의 이름을 지정하기 위해 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) "
"구문을 사용합니다."

#: src/items/external-blocks.md:464
msgid "\"actual_symbol_name\""
msgstr "\"actual_symbol_name\""

#: src/items/external-blocks.md:471
msgid ""
"Using this attribute with the `link_ordinal` attribute will result in a "
"compiler error."
msgstr ""
"이 속성을 `link_ordinal` 속성과 함께 사용하면 컴파일러 오류가 발생합니다."

#: src/items/external-blocks.md:476
msgid "The `link_ordinal` attribute"
msgstr "`link_ordinal` 속성"

#: src/items/external-blocks.md:480
msgid ""
"The _`link_ordinal` attribute_ can be applied on declarations inside an "
"`extern` block to indicate the numeric ordinal to use when generating the "
"import library to link against. An ordinal is a unique number per symbol "
"exported by a dynamic library on Windows and can be used when the library is "
"being loaded to find that symbol rather than having to look it up by name."
msgstr ""
"_`link_ordinal` 속성_은 `extern` 블록 내의 선언에 적용되어, 링크할 임포트 "
"라이브러리를 생성할 때 사용할 숫자 오디널(ordinal)을 나타낼 수 있습니다. "
"오디널은 Windows의 동적 라이브러리에서 내보내는 심볼마다 부여되는 고유한 "
"번호이며, 라이브러리가 로드될 때 이름을 검색하는 대신 이 번호를 사용하여 "
"심볼을 찾는 데 사용될 수 있습니다."

#: src/items/external-blocks.md:488
msgid ""
"_**Warning:**_ `link_ordinal` should only be used in cases where the ordinal "
"of the symbol is known to be stable: if the ordinal of a symbol is not "
"explicitly set when its containing binary is built then one will be "
"automatically assigned to it, and that assigned ordinal may change between "
"builds of the binary."
msgstr ""
"_**경고:**_ `link_ordinal`은 심볼의 오디널이 안정적임이 보장되는 경우에만 "
"사용해야 합니다. 심볼을 포함하는 바이너리가 빌드될 때 심볼의 오디널이 "
"명시적으로 설정되지 않으면 자동으로 할당되며, 이 할당된 오디널은 "
"바이너리 빌드 간에 변경될 수 있습니다."

#: src/items/external-blocks.md:496
msgid "\"exporter\""
msgstr "\"exporter\""

#: src/items/external-blocks.md:496
msgid "\"raw-dylib\""
msgstr "\"raw-dylib\""

#: src/items/external-blocks.md:505
msgid ""
"This attribute is only used with the `raw-dylib` linking kind. Using any "
"other kind will result in a compiler error."
msgstr ""
"이 속성은 오직 `raw-dylib` 링크 종류와 함께 사용됩니다. 다른 종류를 "
"사용하면 컴파일러 오류가 발생합니다."

#: src/items/external-blocks.md:510
msgid ""
"Using this attribute with the `link_name` attribute will result in a "
"compiler error."
msgstr ""
"이 속성을 `link_name` 속성과 함께 사용하면 컴파일러 오류가 발생합니다."

#: src/items/external-blocks.md:517
msgid ""
"Attributes on extern function parameters follow the same rules and "
"restrictions as [regular function parameters](functions.md#attributes-on-"
"function-parameters)."
msgstr ""
"외부 함수의 매개변수에 붙는 속성들은 [일반 함수 매개변수](functions.md#attributes-on-function-parameters)와 "
"동일한 규칙 및 제약 사항을 따릅니다."

#: src/items/generics.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_GenericParams_ :  \n"
"      `<` `>`  \n"
"    | `<` (_GenericParam_ `,`)<sup>\\*</sup> _GenericParam_ `,`<sup>?</sup> "
"`>`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_제네릭매개변수들_ :  \n"
"      `<` `>`  \n"
"    | `<` (_제네릭매개변수_ `,`)<sup>\\*</sup> _제네릭매개변수_ `,`<sup>?</sup> "
"`>`"

#: src/items/generics.md:12
msgid ""
"_GenericParam_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> ( _LifetimeParam_ | "
"_TypeParam_ | _ConstParam_ )"
msgstr ""
"_제네릭매개변수_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> ( _라이프타임매개변수_ | "
"_타입매개변수_ | _상수매개변수_ )"

#: src/items/generics.md:15
msgid ""
"_LifetimeParam_ :  \n"
"   [_Lifetime_](../trait-bounds.md) ( `:` [_LifetimeBounds_](../trait-"
"bounds.md) )<sup>?</sup>"
msgstr ""
"_라이프타임매개변수_ :  \n"
"   [_라이프타임_](../trait-bounds.md) ( `:` [_라이프타임바운드_](../trait-bounds.md) )<sup>?</sup>"

#: src/items/generics.md:18
msgid ""
"_TypeParam_ :  \n"
"   [IDENTIFIER](../identifiers.md) ( `:` [_TypeParamBounds_](../trait-"
"bounds.md)<sup>?</sup> )<sup>?</sup> ( `=` [_Type_](../types.md#type-"
"expressions) )<sup>?</sup>"
msgstr ""
"_타입매개변수_ :  \n"
"   [식별자](../identifiers.md) ( `:` [_타입매개변수바운드_](../trait-"
"bounds.md)<sup>?</sup> )<sup>?</sup> ( `=` [_타입_](../types.md#type-"
"expressions) )<sup>?</sup>"

#: src/items/generics.md:21
msgid ""
"_ConstParam_:  \n"
"   `const` [IDENTIFIER](../identifiers.md) `:` [_Type_](../types.md#type-"
"expressions) ( `=` _[Block](../expressions/block-expr.md)_ | [IDENTIFIER](../"
"identifiers.md) | -<sup>?</sup>[LITERAL](../expressions/literal-"
"expr.md) )<sup>?</sup>"
msgstr ""
"_상수매개변수_:  \n"
"   `const` [식별자](../identifiers.md) `:` [_타입_](../types.md#type-"
"expressions) ( `=` _[블록](../expressions/block-expr.md)_ | [식별자](../"
"identifiers.md) | -<sup>?</sup>[리터럴](../expressions/literal-expr.md) )<sup>?</sup>"

#: src/items/generics.md:26
msgid ""
"[Functions](functions.md), [type aliases](type-aliases.md), [structs]"
"(structs.md), [enumerations](enumerations.md), [unions](unions.md), [traits]"
"(traits.md), and [implementations](implementations.md) may be "
"_parameterized_ by types, constants, and lifetimes. These parameters are "
"listed in angle <span class=\"parenthetical\">brackets (`<...>`)</span>, "
"usually immediately after the name of the item and before its definition. "
"For implementations, which don't have a name, they come directly after "
"`impl`."
msgstr ""
"[함수](functions.md), [타입 별칭](type-aliases.md), [구조체](structs.md), "
"[열거형](enumerations.md), [공용체](unions.md), [트레잇](traits.md), 그리고 "
"[구현](implementations.md)은 타입, 상수, 라이프타임에 의해 _매개변수화_될 수 "
"있습니다. 이러한 매개변수들은 꺽쇠 <span class=\"parenthetical\">괄호(`<...>`)</span> "
"안에 나열되며, 보통 아이템의 이름 바로 뒤이자 정의 앞에 위치합니다. "
"이름이 없는 구현의 경우, `impl` 바로 뒤에 옵니다."

#: src/items/generics.md:34
msgid ""
"The order of generic parameters is restricted to lifetime parameters and "
"then type and const parameters intermixed."
msgstr ""
"제네릭 매개변수의 순서는 라이프타임 매개변수가 먼저 오고, 그 뒤에 타입 매개변수와 "
"상수 매개변수가 섞여서 오는 것으로 제한됩니다."

#: src/items/generics.md:38
msgid ""
"The same parameter name may not be declared more than once in a "
"_GenericParams_ list."
msgstr ""
"동일한 매개변수 이름을 하나의 _제네릭매개변수들_ 목록 내에서 두 번 이상 "
"선언할 수 없습니다."

#: src/items/generics.md:40
msgid "Some examples of items with type, const, and lifetime parameters:"
msgstr "타입, 상수, 라이프타임 매개변수를 가진 아이템의 몇 가지 예시:"

#: src/items/generics.md:52
msgid ""
"Generic parameters are in scope within the item definition where they are "
"declared. They are not in scope for items declared within the body of a "
"function as described in [item declarations](../statements.md#item-"
"declarations). See [generic parameter scopes](../names/scopes.md#generic-"
"parameter-scopes) for more details."
msgstr ""
"제네릭 매개변수는 그것이 선언된 아이템 정의 내의 스코프에 있습니다. [아이템 선언]"
"(../statements.md#item-declarations)에서 설명한 대로, 함수 본문 내에 "
"선언된 아이템들에 대해서는 스코프에 있지 않습니다. 자세한 내용은 "
"[제네릭 매개변수 스코프](../names/scopes.md#generic-parameter-scopes)를 "
"참조하세요."

#: src/items/generics.md:59
msgid ""
"[References](../types/pointer.md#shared-references-), [raw pointers](../"
"types/pointer.md#raw-pointers-const-and-mut), [arrays](../types/array.md), "
"[slices](../types/slice.md), [tuples](../types/tuple.md), and [function "
"pointers](../types/function-pointer.md) have lifetime or type parameters as "
"well, but are not referred to with path syntax."
msgstr ""
"[참조](../types/pointer.md#shared-references-), [원시 포인터](../types/pointer.md#raw-pointers-const-and-mut), "
"[배열](../types/array.md), [슬라이스](../types/slice.md), [튜플](../types/tuple.md), "
"그리고 [함수 포인터](../types/function-pointer.md) 또한 라이프타임 또는 타입 매개변수를 "
"가지지만, 경로 구문을 통해 참조되지는 않습니다."

#: src/items/generics.md:65
msgid "`'_` and `'static` are not valid lifetime parameter names."
msgstr "`'_`와 `'static`은 유효한 라이프타임 매개변수 이름이 아닙니다."

#: src/items/generics.md:69
msgid "Const generics"
msgstr "상수 제네릭"

#: src/items/generics.md:73
msgid ""
"_Const generic parameters_ allow items to be generic over constant values."
msgstr "_상수 제네릭 매개변수_를 통해 아이템이 상수 값에 대해 제네릭해질 수 있습니다."

#: src/items/generics.md:77
msgid ""
"The const identifier introduces a name in the [value namespace](../names/"
"namespaces.md) for the constant parameter, and all instances of the item "
"must be instantiated with a value of the given type."
msgstr ""
"상수 식별자는 [값 네임스페이스](../names/namespaces.md)에 상수 매개변수를 위한 "
"이름을 도입하며, 해당 아이템의 모든 인스턴스는 주어진 타입의 값으로 "
"인스턴스화되어야 합니다."

#: src/items/generics.md:81
msgid ""
"The only allowed types of const parameters are `u8`, `u16`, `u32`, `u64`, "
"`u128`, `usize`, `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `char` and "
"`bool`."
msgstr ""
"상수 매개변수로 허용되는 타입은 `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, "
"`i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `char` 그리고 `bool` 뿐입니다."

#: src/items/generics.md:86
msgid ""
"Const parameters can be used anywhere a [const item](constant-items.md) can "
"be used, with the exception that when used in a [type](../types.md) or "
"[array repeat expression](../expressions/array-expr.md), it must be "
"standalone (as described below). That is, they are allowed in the following "
"places:"
msgstr ""
"상수 매개변수는 [상수 아이템](constant-items.md)이 사용될 수 있는 모든 곳에서 "
"사용될 수 있습니다. 단, [타입](../types.md)이나 [배열 반복 표현식]"
"(../expressions/array-expr.md)에서 사용될 때는 (아래에서 설명하듯이) "
"단독으로(standalone) 사용되어야 합니다. 즉, 다음과 같은 장소에서 허용됩니다."

#: src/items/generics.md:91
msgid ""
"As an applied const to any type which forms a part of the signature of the "
"item in question."
msgstr ""
"해당 아이템 시그니처의 일부를 형성하는 모든 타입에 적용된 상수로 사용될 때."

#: src/items/generics.md:93
msgid ""
"As part of a const expression used to define an [associated const]"
"(associated-items.md#associated-constants), or as a parameter to an "
"[associated type](associated-items.md#associated-types)."
msgstr ""
"[연관 상수](associated-items.md#associated-constants)를 정의하는 데 "
"사용되는 상수 표현식의 일부로 사용되거나, [연관 타입](associated-items."
"md#associated-types)의 매개변수로 사용될 때."

#: src/items/generics.md:95
msgid ""
"As a value in any runtime expression in the body of any functions in the "
"item."
msgstr "해당 아이템 내 모든 함수의 본문에 있는 모든 런타임 표현식의 값으로 사용될 때."

#: src/items/generics.md:97
msgid ""
"As a parameter to any type used in the body of any functions in the item."
msgstr ""
"해당 아이템 내 모든 함수의 본문에서 사용되는 모든 타입의 매개변수로 사용될 때."

#: src/items/generics.md:98
msgid "As a part of the type of any fields in the item."
msgstr "해당 아이템 내 모든 필드의 타입의 일부로 사용될 때."

#: src/items/generics.md:101
msgid "// Examples where const generic parameters can be used.\n"
msgstr "// 상수 제네릭 매개변수를 사용할 수 있는 예시.\n"

#: src/items/generics.md:102
msgid "// Used in the signature of the item itself.\n"
msgstr "// 아이템 자체의 시그니처에서 사용됨.\n"

#: src/items/generics.md:105
msgid "// Used as a type within a function body.\n"
msgstr "// 함수 본문 내에서 타입으로 사용됨.\n"

#: src/items/generics.md:110
msgid "// Used as a field of a struct.\n"
msgstr "// 구조체의 필드로 사용됨.\n"

#: src/items/generics.md:115
msgid "// Used as an associated constant.\n"
msgstr "// 연관 상수로 사용됨.\n"

#: src/items/generics.md:124
msgid "// Used as an associated type.\n"
msgstr "// 연관 타입으로 사용됨.\n"

#: src/items/generics.md:130
msgid "// Examples where const generic parameters cannot be used.\n"
msgstr "// 상수 제네릭 매개변수를 사용할 수 없는 예시.\n"

#: src/items/generics.md:132
msgid "// Cannot use in item definitions within a function body.\n"
msgstr "// 함수 본문 내의 아이템 정의에서는 사용할 수 없음.\n"

#: src/items/generics.md:145
msgid ""
"As a further restriction, const parameters may only appear as a standalone "
"argument inside of a [type](../types.md) or [array repeat expression](../"
"expressions/array-expr.md). In those contexts, they may only be used as a "
"single segment [path expression](../expressions/path-expr.md), possibly "
"inside a [block](../expressions/block-expr.md) (such as `N` or `{N}`). That "
"is, they cannot be combined with other expressions."
msgstr ""
"추가적인 제약 사항으로, 상수 매개변수는 [타입](../types.md)이나 [배열 반복 "
"표현식](../expressions/array-expr.md) 내부에서 오직 단독(standalone) 인수로만 "
"나타날 수 있습니다. 이러한 컨텍스트에서 상수 매개변수는 오직 단일 세그먼트 "
"[경로 표현식](../expressions/path-expr.md)으로만 사용될 수 있으며, "
"필요한 경우 [블록](../expressions/block-expr.md) 내부(예: `N` 또는 `{N}`)에 "
"있을 수 있습니다. 즉, 다른 표현식과 결합될 수 없습니다."

#: src/items/generics.md:152
msgid "// Examples where const parameters may not be used.\n"
msgstr "// 상수 매개변수를 사용할 수 없는 예시.\n"

#: src/items/generics.md:153
msgid ""
"// Not allowed to combine in other expressions in types, such as the\n"
"// arithmetic expression in the return type here.\n"
msgstr ""
"// 타입 내에서 다른 표현식과 결합하는 것은 허용되지 않습니다. 예를 들어\n"
"// 여기 반환 타입에 있는 산술 표현식과 같은 경우입니다.\n"

#: src/items/generics.md:157
msgid "// Similarly not allowed for array repeat expressions.\n"
msgstr "// 배열 반복 표현식에서도 마찬가지로 허용되지 않습니다.\n"

#: src/items/generics.md:164
msgid ""
"A const argument in a [path](../paths.md) specifies the const value to use "
"for that item."
msgstr ""
"[경로](../paths.md)에 있는 상수 인수는 해당 아이템에 사용할 상수 값을 "
"지정합니다."

#: src/items/generics.md:168
msgid ""
"The argument must be a [const expression](../const_eval.md#constant-"
"expressions) of the type ascribed to the const parameter. The const "
"expression must be a [block expression](../expressions/block-expr.md) "
msgstr ""
"인수는 반드시 해당 상수 매개변수에 할당된 타입의 [상수 표현식](../const_eval."
"md#constant-expressions)이어야 합니다. 상수 표현식은 반드시 [블록 "
"표현식](../expressions/block-expr.md) "
"(surrounded with braces) unless it is a single path segment (an [IDENTIFIER]"
"(../identifiers.md)) or a [literal](../expressions/literal-expr.md) (with a "
"possibly leading `-` token)."
msgstr ""
"인수는 반드시 해당 상수 매개변수에 할당된 타입의 [상수 표현식](../const_eval."
"md#constant-expressions)이어야 합니다. 상수 표현식은 단일 경로 세그먼트([식별자]"
"(../identifiers.md))나 [리터럴](../expressions/literal-expr.md)(앞에 `-` 토큰이 "
"붙을 수 있음)이 아닌 한 반드시 [블록 표현식](../expressions/block-expr.md)"
"(중괄호로 둘러싸인 형태)이어야 합니다."

#: src/items/generics.md:173
msgid ""
"**Note**: This syntactic restriction is necessary to avoid requiring "
"infinite lookahead when parsing an expression inside of a type."
msgstr ""
"**참고**: 이 구문적 제약은 타입 내부에서 표현식을 파싱할 때 무한한 lookahead를 "
"피하기 위해 필요합니다."

#: src/items/generics.md:178
msgid "\"doubled: {}\""
msgstr "\"두 배: {}\""

#: src/items/generics.md:184
msgid "// Example usage of a const argument.\n"
msgstr "// 상수 인수의 사용 예시.\n"

#: src/items/generics.md:195
msgid ""
"When there is ambiguity if a generic argument could be resolved as either a "
"type or const argument, it is always resolved as a type. Placing the "
"argument in a block expression can force it to be interpreted as a const "
"argument."
msgstr ""
"제네릭 인수가 타입 인수와 상수 인수 중 어느 것으로도 해석될 수 있어 모호한 경우, "
"항상 타입으로 해석됩니다. 인수를 블록 표현식 안에 배치하면 강제로 상수 인수로 "
"해석되게 할 수 있습니다."

#: src/items/generics.md:205
msgid ""
"// The following is an error, because `N` is interpreted as the type alias "
"`N`.\n"
msgstr "// 다음은 오류입니다. `N`이 타입 별칭 `N`으로 해석되기 때문입니다.\n"

#: src/items/generics.md:207
msgid ""
"// ERROR\n"
"// Can be fixed by wrapping in braces to force it to be interpreted as the "
"`N`\n"
"// const parameter:\n"
msgstr ""
"// 오류\n"
"// 중괄호로 감싸서 강제로 상수 매개변수 `N`으로 해석되게 함으로써\n"
"// 해결할 수 있습니다.\n"

#: src/items/generics.md:210 src/items/generics.md:220
msgid "// ok\n"
msgstr "// ok\n"

#: src/items/generics.md:215
msgid ""
"Unlike type and lifetime parameters, const parameters can be declared "
"without being used inside of a parameterized item, with the exception of "
"implementations as described in [generic implementations]"
"(implementations.md#generic-implementations):"
msgstr ""
"타입 및 라이프타임 매개변수와 달리, 상수 매개변수는 [제네릭 구현]"
"(implementations.md#generic-implementations)에서 설명한 구현의 경우를 제외하고는 "
"매개변수화된 아이템 내부에서 사용되지 않고도 선언될 수 있습니다."

#: src/items/generics.md:223
msgid "// ERROR: unused parameter\n"
msgstr "// 오류: 사용되지 않은 매개변수\n"

#: src/items/generics.md:233
msgid ""
"When resolving a trait bound obligation, the exhaustiveness of all "
"implementations of const parameters is not considered when determining if "
"the bound is satisfied. For example, in the following, even though all "
"possible const values for the `bool` type are implemented, it is still an "
"error that the trait bound is not satisfied:"
msgstr ""
"트레잇 바운드 의무를 해결할 때, 바운드가 충족되는지 여부를 판단하기 위해 상수 매개변수의 "
"모든 구현에 대한 완전성(exhaustiveness)은 고려되지 않습니다. 예를 들어, 다음 코드에서는 "
"`bool` 타입에 대해 가능한 모든 상수 값들이 구현되었음에도 불구하고, 여전히 트레잇 바운드가 "
"충족되지 않았다는 오류가 발생합니다."

#: src/items/generics.md:248
msgid "// ERROR: trait bound `Foo<B>: Bar` is not satisfied\n"
msgstr "// 오류: 트레잇 바운드 `Foo<B>: Bar`가 충족되지 않음\n"

#: src/items/generics.md:254
msgid "Where clauses"
msgstr "Where 절"

#: src/items/generics.md:258
msgid ""
"**<sup>Syntax</sup>**  \n"
"_WhereClause_ :  \n"
"   `where` ( _WhereClauseItem_ `,` )<sup>\\*</sup> _WhereClauseItem_ <sup>?</"
"sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Where절_ :  \n"
"   `where` ( _Where절항목_ `,` )<sup>\\*</sup> _Where절항목_ <sup>?</"
"sup>"

#: src/items/generics.md:262
msgid ""
"_WhereClauseItem_ :  \n"
"      _LifetimeWhereClauseItem_  \n"
"   | _TypeBoundWhereClauseItem_"
msgstr ""
"_Where절항목_ :  \n"
"      _라이프타임Where절항목_  \n"
"   | _타입바운드Where절항목_"

#: src/items/generics.md:266
msgid ""
"_LifetimeWhereClauseItem_ :  \n"
"   [_Lifetime_](../trait-bounds.md) `:` [_LifetimeBounds_](../trait-"
"bounds.md)"
msgstr ""
"_라이프타임Where절항목_ :  \n"
"   [_라이프타임_](../trait-bounds.md) `:` [_라이프타임바운드_](../trait-"
"bounds.md)"

#: src/items/generics.md:269
msgid ""
"_TypeBoundWhereClauseItem_ :  \n"
"   [_ForLifetimes_](../trait-bounds.md#higher-ranked-trait-bounds)<sup>?</"
"sup> [_Type_](../types.md#type-expressions) `:` [_TypeParamBounds_](../trait-"
"bounds.md)<sup>?</sup>"
msgstr ""
"_타입바운드Where절항목_ :  \n"
"   [_For라이프타임_](../trait-bounds.md#higher-ranked-trait-bounds)<sup>?</"
"sup> [_타입_](../types.md#type-expressions) `:` [_타입매개변수바운드_](../trait-"
"bounds.md)<sup>?</sup>"

#: src/items/generics.md:274
msgid ""
"_Where clauses_ provide another way to specify bounds on type and lifetime "
"parameters as well as a way to specify bounds on types that aren't type "
"parameters."
msgstr ""
"_Where 절_은 타입 및 라이프타임 매개변수에 대한 바운드를 지정하는 또 다른 "
"방법이자, 타입 매개변수가 아닌 타입에 대해 바운드를 지정하는 방법을 제공합니다."

#: src/items/generics.md:280
msgid ""
"The `for` keyword can be used to introduce [higher-ranked lifetimes](../"
"trait-bounds.md#higher-ranked-trait-bounds). It only allows [_LifetimeParam_]"
"(#generic-parameters) parameters."
msgstr ""
"`for` 키워드는 [고위 라이프타임(higher-ranked lifetimes)](../trait-bounds."
"md#higher-ranked-trait-bounds)을 도입하는 데 사용될 수 있습니다. "
"오직 [_라이프타임매개변수_](#generic-parameters)만 허용합니다."

#: src/items/generics.md:286
msgid "// Could use A<T: Iterator> instead\n"
msgstr "// 대신 A<T: Iterator>를 사용할 수 있습니다.\n"

#: src/items/generics.md:287
msgid "// Bound on an associated type\n"
msgstr "// 연관 타입에 대한 바운드\n"

#: src/items/generics.md:288
msgid "// Bound on `String`, using the type parameter\n"
msgstr "// 타입 매개변수를 사용하여 `String`에 대한 바운드 지정\n"

#: src/items/generics.md:289 src/trait-bounds.md:113
msgid "// Allowed, but not useful\n"
msgstr "// 허용되지만 유용하지는 않음\n"

#: src/items/generics.md:299
msgid ""
"Generic lifetime and type parameters allow [attributes](../attributes.md) on "
"them. There are no built-in attributes that do anything in this position, "
"although custom derive attributes may give meaning to it."
msgstr ""
"제네릭 라이프타임 및 타입 매개변수에는 [속성](../attributes.md)을 붙일 수 "
"있습니다. 이 위치에서 무언가를 수행하는 내장 속성은 없지만, 커스텀 derive "
"속성이 여기에 의미를 부여할 수 있습니다."

#: src/items/generics.md:303
msgid ""
"This example shows using a custom derive attribute to modify the meaning of "
"a generic parameter."
msgstr ""
"이 예시는 커스텀 derive 속성을 사용하여 제네릭 매개변수의 의미를 수정하는 "
"방법을 보여줍니다."

#: src/items/generics.md:308
msgid ""
"// Assume that the derive for MyFlexibleClone declared `my_flexible_clone` "
"as\n"
"// an attribute it understands.\n"
msgstr ""
"// MyFlexibleClone에 대한 derive가 `my_flexible_clone`을 이해할 수 있는\n"
"// 속성으로 선언했다고 가정합니다.\n"

#: src/items/associated-items.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_AssociatedItem_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> (  \n"
"         [_MacroInvocationSemi_](../macros.md#macro-invocation)  \n"
"      | ( [_Visibility_](../visibility-and-privacy.md)<sup>?</sup> "
"( [_TypeAlias_](type-aliases.md) | [_ConstantItem_](constant-items.md) | "
"[_Function_](functions.md) ) )  \n"
"   )"
msgstr ""
"**<sup>구문</sup>**  \n"
"_연관아이템_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> (  \n"
"         [_세미콜론매크로호출_](../macros.md#macro-invocation)  \n"
"      | ( [_가시성_](../visibility-and-privacy.md)<sup>?</sup> "
"( [_타입별칭_](type-aliases.md) | [_상수아이템_](constant-items.md) | "
"[_함수_](functions.md) ) )  \n"
"   )"

#: src/items/associated-items.md:16
msgid ""
"_Associated Items_ are the items declared in [traits](traits.md) or defined "
"in [implementations](implementations.md). They are called this because they "
"are defined on an associate type — the type in the implementation."
msgstr ""
"_연관 아이템(Associated Items)_은 [트레잇](traits.md)에 선언되거나 "
"[구현](implementations.md)에 정의된 아이템들을 말합니다. 연관 아이템이라고 "
"불리는 이유는 그것들이 연관된 타입 — 즉 구현 내의 타입 — 에 정의되기 때문입니다."

#: src/items/associated-items.md:22
msgid ""
"They are a subset of the kinds of items you can declare in a module. "
"Specifically, there are [associated functions](#associated-functions-and-"
"methods) (including methods), [associated types](#associated-types), and "
"[associated constants](#associated-constants)."
msgstr ""
"이들은 모듈에서 선언할 수 있는 아이템 종류의 하위 집합입니다. 구체적으로 "
"[연관 함수](#associated-functions-and-methods)(메서드 포함), "
"[연관 타입](#associated-types), 그리고 [연관 상수](#associated-constants)가 "
"있습니다."

#: src/items/associated-items.md:31
msgid ""
"Associated items are useful when the associated item logically is related to "
"the associating item. For example, the `is_some` method on `Option` is "
"intrinsically related to Options, so should be associated."
msgstr ""
"연관 아이템은 해당 아이템이 논리적으로 다음 대상과 관련이 있을 때 유용합니다. "
"예를 들어, `Option`의 `is_some` 메서드는 본질적으로 Option과 관련이 있으므로 "
"연관되어야 합니다."

#: src/items/associated-items.md:37
msgid ""
"Every associated item kind comes in two varieties: definitions that contain "
"the actual implementation and declarations that declare signatures for "
"definitions."
msgstr ""
"모든 종류의 연관 아이템은 두 가지 변형으로 제공됩니다: 실제 구현을 포함하는 "
"정의(definitions)와 정의를 위한 시그니처를 선언하는 선언(declarations)입니다."

#: src/items/associated-items.md:43
msgid ""
"It is the declarations that make up the contract of traits and what is "
"available on generic types."
msgstr ""
"트레잇의 계약을 구성하고 제네릭 타입에서 무엇을 사용할 수 있는지를 결정하는 "
"것은 바로 선언입니다."

#: src/items/associated-items.md:48
msgid "Associated functions and methods"
msgstr "연관 함수와 메서드"

#: src/items/associated-items.md:52
msgid ""
"_Associated functions_ are [functions](functions.md) associated with a type."
msgstr "_연관 함수_는 타입과 연관된 [함수](functions.md)입니다."

#: src/items/associated-items.md:56
msgid ""
"An _associated function declaration_ declares a signature for an associated "
"function definition. It is written as a function item, except the function "
"body is replaced with a `;`."
msgstr ""
"_연관 함수 선언_은 연관 함수 정의를 위한 시그니처를 선언합니다. 함수 본문이 "
"`;`로 대체된다는 점을 제외하면 함수 아이템과 동일하게 작성됩니다."

#: src/items/associated-items.md:62
msgid "The identifier is the name of the function."
msgstr "식별자는 함수의 이름입니다."

#: src/items/associated-items.md:66
msgid ""
"The generics, parameter list, return type, and where clause of the "
"associated function must be the same as the associated function "
"declarations's."
msgstr ""
"연관 함수의 제네릭, 매개변수 목록, 반환 타입, 그리고 Where 절은 연관 함수 "
"선언과 동일해야 합니다."

#: src/items/associated-items.md:71
msgid ""
"An _associated function definition_ defines a function associated with "
"another type. It is written the same as a [function item](../types/function-"
"item.md)."
msgstr ""
"_연관 함수 정의_는 다른 타입과 연관된 함수를 정의합니다. [함수 아이템]"
"(../types/function-item.md)과 동일하게 작성됩니다."

#: src/items/associated-items.md:74
msgid ""
"An example of a common associated function is a `new` function that returns "
"a value of the type the associated function is associated with."
msgstr ""
"일반적인 연관 함수의 예로, 연관 함수가 연결된 타입의 값을 반환하는 `new` 함수가 "
"있습니다."

#: src/items/associated-items.md:97
msgid ""
"When the associated function is declared on a trait, the function can also "
"be called with a [path](../paths.md) that is a path to the trait appended by "
"the name of the trait. When this happens, it is substituted for `<_ as "
"Trait>::function_name`."
msgstr ""
"연관 함수가 트레잇에 선언된 경우, 해당 함수는 트레잇으로의 경로 뒤에 트레잇 "
"이름이 붙은 [경로](../paths.md)로도 호출될 수 있습니다. 이 경우, `<_ as "
"Trait>::function_name`으로 대체됩니다."

#: src/items/associated-items.md:109
msgid "// These 4 are all equivalent in this case.\n"
msgstr "// 이 경우 이 4가지는 모두 동일합니다.\n"

#: src/items/associated-items.md:119
msgid "Methods"
msgstr "메서드"

#: src/items/associated-items.md:123
msgid ""
"Associated functions whose first parameter is named `self` are called "
"_methods_ and may be invoked using the [method call operator](../expressions/"
"method-call-expr.md), for example, `x.foo()`, as well as the usual function "
"call notation."
msgstr ""
"첫 번째 매개변수의 이름이 `self`인 연관 함수를 _메서드_라고 하며, [메서드 호출 연산자]"
"(../expressions/method-call-expr.md)(예: `x.foo()`)를 사용하거나 일반적인 함수 호출 "
"표기법을 사용하여 호출할 수 있습니다."

#: src/items/associated-items.md:129
msgid ""
"If the type of the `self` parameter is specified, it is limited to types "
"resolving to one generated by the following grammar (where `'lt` denotes "
"some arbitrary lifetime):"
msgstr ""
"`self` 매개변수의 타입이 지정된 경우, 다음 문법에 의해 생성된 타입 중 하나로 해석되는 "
"타입으로 제한됩니다(여기서 `'lt`는 임의의 라이프타임을 나타냄):"

#: src/items/associated-items.md:138
msgid ""
"The `Self` terminal in this grammar denotes a type resolving to the "
"implementing type. This can also include the contextual type alias `Self`, "
"other type aliases, or associated type projections resolving to the "
"implementing type."
msgstr ""
"이 문법에서 `Self` 터미널(terminal)은 구현 타입으로 해석되는 타입을 나타냅니다. "
"여기에는 문맥적 타입 별칭 `Self`, 다른 타입 별칭, 또는 구현 타입으로 해석되는 "
"연관 타입 투영(associated type projections)이 포함될 수 있습니다."

#: src/items/associated-items.md:145
msgid "// Examples of methods implemented on struct `Example`.\n"
msgstr "// `Example` 구조체에 구현된 메서드의 예시.\n"

#: src/items/associated-items.md:168
msgid ""
"Shorthand syntax can be used without specifying a type, which have the "
"following equivalents:"
msgstr ""
"타입을 지정하지 않고 단축 구문을 사용할 수 있으며, 이는 다음과 동일합니다:"

#: src/items/associated-items.md:171
msgid "Shorthand"
msgstr "단축 구문"

#: src/items/associated-items.md:171
msgid "Equivalent"
msgstr "동등한 표현"

#: src/items/associated-items.md:173 src/paths.md:248
msgid "`self`"
msgstr "`self`"

#: src/items/associated-items.md:173
msgid "`self: Self`"
msgstr "`self: Self`"

#: src/items/associated-items.md:174
msgid "`&'lifetime self`"
msgstr "`&'lifetime self`"

#: src/items/associated-items.md:174
msgid "`self: &'lifetime Self`"
msgstr "`self: &'lifetime Self`"

#: src/items/associated-items.md:175
msgid "`&'lifetime mut self`"
msgstr "`&'lifetime mut self`"

#: src/items/associated-items.md:175
msgid "`self: &'lifetime mut Self`"
msgstr "`self: &'lifetime mut Self`"

#: src/items/associated-items.md:177
msgid ""
"**Note**: Lifetimes can be, and usually are, elided with this shorthand."
msgstr ""
"**참고**: 이 단축 구문을 사용하면 라이프타임이 생략될 수 있으며, 보통 생략됩니다."

#: src/items/associated-items.md:181
msgid ""
"If the `self` parameter is prefixed with `mut`, it becomes a mutable "
"variable, similar to regular parameters using a `mut` [identifier pattern]"
"(../patterns.md#identifier-patterns). For example:"
msgstr ""
"`self` 매개변수 앞에 `mut`가 붙으면, `mut` [식별자 패턴](../patterns.md#identifier-patterns)을 "
"사용하는 일반 매개변수와 마찬가지로 가변 변수가 됩니다. 예를 들어:"

#: src/items/associated-items.md:191
msgid "As an example of methods on a trait, consider the following:"
msgstr "트레잇의 메서드 예시는 다음과 같습니다:"

#: src/items/associated-items.md:202
msgid ""
"This defines a trait with two methods. All values that have [implementations]"
"(implementations.md) of this trait while the trait is in scope can have "
"their `draw` and `bounding_box` methods called."
msgstr ""
"이것은 두 개의 메서드를 가진 트레잇을 정의합니다. 트레잇이 스코프 내에 있는 동안 "
"이 트레잇의 [구현](implementations.md)을 가진 모든 값은 `draw` 및 `bounding_box` "
"메서드를 호출할 수 있습니다."

#: src/items/associated-items.md:234
msgid ""
"**Edition differences**: In the 2015 edition, it is possible to declare "
"trait methods with anonymous parameters (e.g. `fn foo(u8)`). This is "
"deprecated and an error as of the 2018 edition. All parameters must have an "
"argument name."
msgstr ""
"**에디션 차이**: 2015 에디션에서는 익명 매개변수(예: `fn foo(u8)`)로 트레잇 메서드를 "
"선언하는 것이 가능했습니다. 이는 2018 에디션부터 사용 중단(deprecated)되었으며 오류입니다. "
"모든 매개변수는 인수 이름을 가져야 합니다."

#: src/items/associated-items.md:240
msgid "Attributes on method parameters"
msgstr "메서드 매개변수의 속성"

#: src/items/associated-items.md:242
msgid ""
"Attributes on method parameters follow the same rules and restrictions as "
"[regular function parameters](functions.md#attributes-on-function-"
"parameters)."
msgstr ""
"메서드 매개변수의 속성은 [일반 함수 매개변수](functions.md#attributes-on-function-"
"parameters)와 동일한 규칙 및 제약 사항을 따릅니다."

#: src/items/associated-items.md:247
msgid "Associated Types"
msgstr "연관 타입"

#: src/items/associated-items.md:251
msgid ""
"_Associated types_ are [type aliases](type-aliases.md) associated with "
"another type."
msgstr "_연관 타입_은 다른 타입과 연관된 [타입 별칭](type-aliases.md)입니다."

#: src/items/associated-items.md:255
msgid ""
"Associated types cannot be defined in [inherent implementations]"
"(implementations.md#inherent-implementations) nor can they be given a "
"default implementation in traits."
msgstr ""
"연관 타입은 [고유 구현](implementations.md#inherent-implementations)에서 정의될 수 "
"없으며 트레잇에서 기본 구현을 가질 수도 없습니다."

#: src/items/associated-items.md:260
msgid ""
"An _associated type declaration_ declares a signature for associated type "
"definitions. It is written in one of the following forms, where `Assoc` is "
"the name of the associated type, `Params` is a comma-separated list of type, "
"lifetime or const parameters, `Bounds` is a plus-separated list of trait "
"bounds that the associated type must meet, and `WhereBounds` is a comma-"
"separated list of bounds that the parameters must meet:"
msgstr ""
"_연관 타입 선언_은 연관 타입 정의를 위한 시그니처를 선언합니다. 다음 형식 중 하나로 "
"작성되며, `Assoc`은 연관 타입의 이름, `Params`는 쉼표로 구분된 타입, 라이프타임 "
"또는 상수 매개변수 목록, `Bounds`는 연관 타입이 충족해야 하는 더하기로 구분된 "
"트레잇 바운드 목록, `WhereBounds`는 매개변수가 충족해야 하는 쉼표로 구분된 "
"바운드 목록입니다:"

#: src/items/associated-items.md:279
msgid "The identifier is the name of the declared type alias."
msgstr "식별자는 선언된 타입 별칭의 이름입니다."

#: src/items/associated-items.md:283
msgid ""
"The optional trait bounds must be fulfilled by the implementations of the "
"type alias."
msgstr "선택적 트레잇 바운드는 타입 별칭의 구현에 의해 충족되어야 합니다."

#: src/items/associated-items.md:287
msgid ""
"There is an implicit [`Sized`](../special-types-and-traits.md#sized) bound "
"on associated types that can be relaxed using the special `?Sized` bound."
msgstr ""
"연관 타입에는 암시적인 [`Sized`](../special-types-and-traits.md#sized) 바운드가 "
"있으며, 이는 특수한 `?Sized` 바운드를 사용하여 완화할 수 있습니다."

#: src/items/associated-items.md:291
msgid ""
"An _associated type definition_ defines a type alias for the implementation "
"of a trait on a type"
msgstr "_연관 타입 정의_는 타입에 대한 트레잇 구현을 위한 타입 별칭을 정의합니다."

#: src/items/associated-items.md:296
msgid ""
"They are written similarly to an _associated type declaration_, but cannot "
"contain `Bounds`, but instead must contain a `Type`:"
msgstr ""
"이들은 _연관 타입 선언_과 유사하게 작성되지만, `Bounds`를 포함할 수 없고 "
"대신 `Type`을 포함해야 합니다:"

#: src/items/associated-items.md:301
msgid "// the type `Type` here may reference `Params`\n"
msgstr "// 여기서 `Type` 타입은 `Params`를 참조할 수 있습니다\n"

#: src/items/associated-items.md:303
msgid "// deprecated, prefer the form above\n"
msgstr "// 사용 중단됨(deprecated), 위의 형식을 선호하세요\n"

#: src/items/associated-items.md:308
msgid ""
"If a type `Item` has an associated type `Assoc` from a trait `Trait`, then "
"`<Item as Trait>::Assoc` is a type that is an alias of the type specified in "
"the associated type definition"
msgstr "타입 `Item`이 트레잇 `Trait`으로부터 연관 타입 `Assoc`을 가진다면, `<Item as Trait>::Assoc`은 연관 타입 정의에 명시된 타입의 별칭인 타입입니다."

#: src/items/associated-items.md:314
msgid ""
"Furthermore, if `Item` is a type parameter, then `Item::Assoc` can be used "
"in type parameters."
msgstr "또한, `Item`이 타입 매개변수인 경우, `Item::Assoc`은 타입 매개변수 내에서 사용될 수 있습니다."

#: src/items/associated-items.md:318
msgid ""
"Associated types may include [generic parameters](generics.md) and [where "
"clauses](generics.md#where-clauses); these are often referred to as _generic "
"associated types_, or _GATs_. If the type `Thing` has an associated type "
"`Item` from a trait `Trait` with the generics `<'a>` , the type can be named "
"like `<Thing as Trait>::Item<'x>`, where `'x` is some lifetime in scope. In "
"this case, `'x` will be used wherever `'a` appears in the associated type "
"definitions on impls."
msgstr "연관 타입은 [제네릭 매개변수](generics.md)와 [where 절](generics.md#where-clauses)을 포함할 수 있습니다. 이들은 종종 _제네릭 연관 타입(generic associated types)_ 또는 _GAT_라고 불립니다. 타입 `Thing`이 제네릭 `<'a>`를 가진 트레잇 `Trait`으로부터 연관 타입 `Item`을 가진다면, 이 타입은 `<Thing as Trait>::Item<'x>`와 같이 명명될 수 있으며, 여기서 `'x`는 스코프 내의 어떤 라이프타임입니다. 이 경우, 구현(impl)의 연관 타입 정의에서 `'a`가 나타나는 모든 곳에 `'x`가 사용됩니다."

#: src/items/associated-items.md:327
msgid "// Associated type declaration\n"
msgstr "// 연관 타입 선언\n"

#: src/items/associated-items.md:336
msgid "// Associated type definition\n"
msgstr "// 연관 타입 정의\n"

#: src/items/associated-items.md:347
msgid ""
"// Usage of the associated type to refer to OtherStruct as <Struct as "
"AssociatedType>::Assoc\n"
msgstr "// <Struct as AssociatedType>::Assoc와 같이 OtherStruct를 참조하기 위해 연관 타입을 사용함\n"

#: src/items/associated-items.md:352
msgid "An example of associated types with generics and where clauses:"
msgstr "제네릭과 where 절을 사용한 연관 타입의 예시:"

#: src/items/associated-items.md:358
msgid "// Generic associated type declaration\n"
msgstr "// 제네릭 연관 타입 선언\n"

#: src/items/associated-items.md:364
msgid "// Generic associated type definition\n"
msgstr "// 제네릭 연관 타입 정의\n"

#: src/items/associated-items.md:382
msgid "Associated Types Container Example"
msgstr "연관 타입 컨테이너 예시"

#: src/items/associated-items.md:384
msgid ""
"Consider the following example of a `Container` trait. Notice that the type "
"is available for use in the method signatures:"
msgstr "다음 `Container` 트레잇 예시를 고려해 보세요. 해당 타입이 메서드 시그니처에서 사용 가능하다는 점에 주목하세요:"

#: src/items/associated-items.md:395
msgid ""
"In order for a type to implement this trait, it must not only provide "
"implementations for every method, but it must specify the type `E`. Here's "
"an implementation of `Container` for the standard library type `Vec`:"
msgstr "어떤 타입이 이 트레잇을 구현하기 위해서는, 모든 메서드에 대한 구현을 제공해야 할 뿐만 아니라 타입 `E`를 명시해야 합니다. 다음은 표준 라이브러리 타입 `Vec`에 대한 `Container` 구현입니다:"

#: src/items/associated-items.md:412
msgid "Relationship between `Bounds` and `WhereBounds`"
msgstr "`Bounds`와 `WhereBounds` 사이의 관계"

#: src/items/associated-items.md:414 src/attributes/diagnostics.md:567
msgid "In this example:"
msgstr "이 예시에서:"

#: src/items/associated-items.md:423
msgid ""
"Given a reference to the associated type like `<X as Example>::Output<Y>`, "
"the associated type itself must be `Ord`, and the type `Y` must be `Debug`."
msgstr "`<X as Example>::Output<Y>`와 같은 연관 타입에 대한 참조가 주어지면, 연관 타입 자체는 반드시 `Ord`여야 하고, 타입 `Y`는 반드시 `Debug`여야 합니다."

#: src/items/associated-items.md:427
msgid "Required where clauses on generic associated types"
msgstr "제네릭 연관 타입에 요구되는 where 절"

#: src/items/associated-items.md:431
msgid ""
"Generic associated type declarations on traits currently may require a list "
"of where clauses, dependent on functions in the trait and how the GAT is "
"used. These rules may be loosened in the future; updates can be found [on "
"the generic associated types initiative repository](https://rust-"
"lang.github.io/generic-associated-types-initiative/explainer/"
"required_bounds.html)."
msgstr "트레잇의 제네릭 연관 타입 선언은 현재 트레잇의 함수들과 GAT가 어떻게 사용되는지에 따라 where 절 목록을 요구할 수 있습니다. 이러한 규칙들은 미래에 완화될 수 있습니다. 업데이트는 [제네릭 연관 타입 이니셔티브 저장소](https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html)에서 확인할 수 있습니다."

#: src/items/associated-items.md:438
msgid ""
"In a few words, these where clauses are required in order to maximize the "
"allowed definitions of the associated type in impls. To do this, any clauses "
"that _can be proven to hold_ on functions (using the parameters of the "
"function or trait) where a GAT appears as an input or output must also be "
"written on the GAT itself."
msgstr "간단히 말해서, 이러한 where 절은 구현(impl)에서 연관 타입의 허용되는 정의를 최대화하기 위해 필요합니다. 이를 위해, GAT가 입력 또는 출력으로 나타나는 함수에서 (함수나 트레잇의 매개변수를 사용하여) _성립한다고 증명될 수 있는_ 모든 절은 GAT 자체에도 작성되어야 합니다."

#: src/items/associated-items.md:450
msgid ""
"In the above, on the `next` function, we can prove that `Self: 'a`, because "
"of the implied bounds from `&'a mut self`; therefore, we must write the "
"equivalent bound on the GAT itself: `where Self: 'x`."
msgstr "위의 `next` 함수에서, `&'a mut self`로부터 암시된 바운드 덕분에 `Self: 'a`임을 증명할 수 있습니다. 따라서 GAT 자체에 동일한 바운드인 `where Self: 'x`를 작성해야 합니다."

#: src/items/associated-items.md:456
msgid ""
"When there are multiple functions in a trait that use the GAT, then the "
"_intersection_ of the bounds from the different functions are used, rather "
"than the union."
msgstr "트레잇에 GAT를 사용하는 함수가 여러 개 있는 경우, 합집합이 아닌 각 함수의 바운드들의 _교집합_이 사용됩니다."

#: src/items/associated-items.md:468
msgid ""
"In this example, no bounds are required on the `type Checker<'a>;`. While we "
"know that `T: 'a` on `create_checker`, we do not know that on `do_check`. "
"However, if `do_check` was commented out, then the `where T: 'x` bound would "
"be required on `Checker`."
msgstr "이 예시에서는 `type Checker<'a>;`에 아무런 바운드가 요구되지 않습니다. `create_checker`에서는 `T: 'a`임을 알 수 있지만, `do_check`에서는 이를 알 수 없기 때문입니다. 하지만 만약 `do_check`가 주석 처리된다면, `Checker`에 `where T: 'x` 바운드가 요구될 것입니다."

#: src/items/associated-items.md:475
msgid "The bounds on associated types also propagate required where clauses."
msgstr "연관 타입에 대한 바운드는 요구되는 where 절을 전파하기도 합니다."

#: src/items/associated-items.md:485
msgid ""
"Here, `where Self: 'a` is required on `Item` because of `iter`. However, "
"`Item` is used in the bounds of `Iterator`, the `where Self: 'a` clause is "
"also required there."
msgstr "여기서 `iter` 때문에 `Item`에 `where Self: 'a`가 요구됩니다. 그런데 `Item`이 `Iterator`의 바운드에서 사용되므로, `where Self: 'a` 절이 거기서도 요구됩니다."

#: src/items/associated-items.md:491
msgid ""
"Finally, any explicit uses of `'static` on GATs in the trait do not count "
"towards the required bounds."
msgstr "마지막으로, 트레잇의 GAT에서 `'static`을 명시적으로 사용하는 것은 요구되는 바운드에 포함되지 않습니다."

#: src/items/associated-items.md:503
msgid "Associated Constants"
msgstr "연관 상수"

#: src/items/associated-items.md:507
msgid ""
"_Associated constants_ are [constants](constant-items.md) associated with a "
"type."
msgstr "_연관 상수_는 타입과 연관된 [상수](constant-items.md)입니다."

#: src/items/associated-items.md:511
msgid ""
"An _associated constant declaration_ declares a signature for associated "
"constant definitions. It is written as `const`, then an identifier, then "
"`:`, then a type, finished by a `;`."
msgstr "_연관 상수 선언_은 연관 상수 정의를 위한 시그니처를 선언합니다. `const`, 식별자, `:`, 타입 순으로 작성하고 `;`로 마칩니다."

#: src/items/associated-items.md:517
msgid ""
"The identifier is the name of the constant used in the path. The type is the "
"type that the definition has to implement."
msgstr "식별자는 경로에서 사용되는 상수의 이름입니다. 타입은 정의에서 구현해야 하는 타입입니다."

#: src/items/associated-items.md:522
msgid ""
"An _associated constant definition_ defines a constant associated with a "
"type. It is written the same as a [constant item](constant-items.md)."
msgstr "_연관 상수 정의_는 타입과 연관된 상수를 정의합니다. [상수 아이템](constant-items.md)과 동일하게 작성됩니다."

#: src/items/associated-items.md:527
msgid ""
"Associated constant definitions undergo [constant evaluation](../"
"const_eval.md) only when referenced. Further, definitions that include "
"[generic parameters](generics.md) are evaluated after monomorphization."
msgstr "연관 상수 정의는 참조될 때만 [상수 평가](../const_eval.md)를 거칩니다. 또한, [제네릭 매개변수](generics.md)를 포함하는 정의는 모노모르포화(monomorphization) 후에 평가됩니다."

#: src/items/associated-items.md:536 src/items/associated-items.md:541
msgid "// Definition not immediately evaluated\n"
msgstr "// 정의가 즉시 평가되지 않음\n"

#: src/items/associated-items.md:537
msgid "\"compile-time panic\""
msgstr "\"컴파일 타임 패닉\""

#: src/items/associated-items.md:543
msgid "\"contradiction\""
msgstr "\"모순\""

#: src/items/associated-items.md:548
msgid "// Referencing Struct::PANIC causes compilation error\n"
msgstr "// Struct::PANIC을 참조하면 컴파일 오류가 발생함\n"

#: src/items/associated-items.md:551
msgid "// Fine, ID is not 0\n"
msgstr "// 괜찮음, ID가 0이 아님\n"

#: src/items/associated-items.md:554
msgid "// Compilation error from evaluating NON_ZERO with ID=0\n"
msgstr "// ID=0으로 NON_ZERO를 평가할 때 발생하는 컴파일 오류\n"

#: src/items/associated-items.md:559
msgid "Associated Constants Examples"
msgstr "연관 상수 예시"

#: src/items/associated-items.md:561
msgid "A basic example:"
msgstr "기본 예시:"

#: src/items/associated-items.md:579
msgid "Using default values:"
msgstr "기본값 사용하기:"

#: src/attributes.md:34
msgid ""
"**<sup>Syntax</sup>**  \n"
"_InnerAttribute_ :  \n"
"   `#` `!` `[` _Attr_ `]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_내부속성_ :  \n"
"   `#` `!` `[` _속성_ `]`"

#: src/attributes.md:38
msgid ""
"_OuterAttribute_ :  \n"
"   `#` `[` _Attr_ `]`"
msgstr ""
"_외부속성_ :  \n"
"   `#` `[` _속성_ `]`"

#: src/attributes.md:41
msgid ""
"_Attr_ :  \n"
"      [_SimplePath_](paths.md#simple-paths) _AttrInput_<sup>?</sup>  \n"
"   | `unsafe` `(` [_SimplePath_](paths.md#simple-paths) _AttrInput_<sup>?</"
"sup> `)`"
msgstr ""
"_속성_ :  \n"
"      [_단순경로_](paths.md#simple-paths) _속성입력_<sup>?</sup>  \n"
"   | `unsafe` `(` [_단순경로_](paths.md#simple-paths) _속성입력_<sup>?</"
"sup> `)`"

#: src/attributes.md:45
msgid ""
"_AttrInput_ :  \n"
"      [_DelimTokenTree_](macros.md)  \n"
"   | `=` [_Expression_](expressions.md)"
msgstr ""
"_속성입력_ :  \n"
"      [_구분된토큰트리_](macros.md)  \n"
"   | `=` [_표현식_](expressions.md)"

#: src/attributes.md:51
msgid ""
"An _attribute_ is a general, free-form metadatum that is interpreted "
"according to name, convention, language, and compiler version. Attributes "
"are modeled on Attributes in [ECMA-335](https://www.ecma-international.org/"
"publications-and-standards/standards/ecma-335/), with the syntax coming from "
"[ECMA-334](https://www.ecma-international.org/publications-and-standards/"
"standards/ecma-334/) (C#)."
msgstr ""
"_속성(attribute)_은 이름, 관례, 언어, 컴파일러 버전에 따라 해석되는 일반적이고 자유로운 형식의 메타데이터입니다. 속성은 [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/)의 속성을 모델로 하며, 구문은 [ECMA-334](https://www.ecma-international.org/publications-and-standards/standards/ecma-334/)(C#)에서 유래했습니다."

#: src/attributes.md:57
msgid ""
"_Inner attributes_, written with a bang (`!`) after the hash (`#`), apply to "
"the item that the attribute is declared within. _Outer attributes_, written "
"without the bang after the hash, apply to the thing that follows the "
"attribute."
msgstr ""
"해시(`#`) 뒤에 느낌표(`!`)를 붙여 작성하는 _내부 속성_은 속성이 선언된 아이템 내부에 적용됩니다. 해시 뒤에 느낌표 없이 작성하는 _외부 속성_은 속성 뒤에 오는 대상에 적용됩니다."

#: src/attributes.md:63
msgid ""
"The attribute consists of a path to the attribute, followed by an optional "
"delimited token tree whose interpretation is defined by the attribute. "
"Attributes other than macro attributes also allow the input to be an equals "
"sign (`=`) followed by an expression. See the [meta item syntax](#meta-item-"
"attribute-syntax) below for more details."
msgstr ""
"속성은 속성으로의 경로와, 속성에 의해 해석이 정의되는 선택적인 구분된 토큰 트리로 구성됩니다. 매크로 속성을 제외한 속성들은 등호(`=`) 뒤에 표현식이 오는 입력도 허용합니다. 자세한 내용은 아래의 [메타 아이템 구문](#meta-item-attribute-syntax)을 참조하세요."

#: src/attributes.md:71
msgid ""
"An attribute may be unsafe to apply. To avoid undefined behavior when using "
"these attributes, certain obligations that cannot be checked by the compiler "
"must be met.  To assert these have been, the attribute is wrapped in "
"`unsafe(..)`, e.g. `#[unsafe(no_mangle)]`."
msgstr ""
"어떤 속성은 적용하기에 안전하지(unsafe) 않을 수 있습니다. 이러한 속성을 사용할 때 정의되지 않은 동작을 피하기 위해, 컴파일러가 확인할 수 없는 특정 의무사항들을 준수해야 합니다. 이러한 사항들이 준수되었음을 단언하기 위해, 속성을 `unsafe(..)`로 감쌉니다. 예: `#[unsafe(no_mangle)]`."

#: src/attributes.md:76
msgid "The following attributes are unsafe:"
msgstr "다음 속성들은 안전하지 않습니다:"

#: src/attributes.md:78
msgid "[`export_name`](abi.md#the-export_name-attribute)"
msgstr "[`export_name`](abi.md#the-export_name-attribute)"

#: src/attributes.md:79
msgid "[`link_section`](abi.md#the-link_section-attribute)"
msgstr "[`link_section`](abi.md#the-link_section-attribute)"

#: src/attributes.md:80
msgid "[`no_mangle`](abi.md#the-no_mangle-attribute)"
msgstr "[`no_mangle`](abi.md#the-no_mangle-attribute)"

#: src/attributes.md:84
msgid "Attributes can be classified into the following kinds:"
msgstr "속성은 다음과 같은 종류로 분류될 수 있습니다:"

#: src/attributes.md:86
msgid "[Built-in attributes](#built-in-attributes-index)"
msgstr "[내장 속성](#built-in-attributes-index)"

#: src/attributes.md:87
msgid "[Proc macro attributes](procedural-macros.md#attribute-macros)"
msgstr "[절차적 매크로 속성](procedural-macros.md#attribute-macros)"

#: src/attributes.md:88
msgid ""
"[Derive macro helper attributes](procedural-macros.md#derive-macro-helper-"
"attributes)"
msgstr "[Derive 매크로 도우미 속성](procedural-macros.md#derive-macro-helper-attributes)"

#: src/attributes.md:89
msgid "[Tool attributes](#tool-attributes)"
msgstr "[도구 속성](#tool-attributes)"

#: src/attributes.md:93
msgid "Attributes may be applied to many things in the language:"
msgstr "속성은 언어의 많은 요소에 적용될 수 있습니다:"

#: src/attributes.md:95
msgid ""
"All [item declarations](items.md) accept outer attributes while [external "
"blocks](items/external-blocks.md), [functions](items/functions.md), "
"[implementations](items/implementations.md), and [modules](items/modules.md) "
"accept inner attributes."
msgstr "모든 [아이템 선언](items.md)은 외부 속성을 허용하며, [외부 블록](items/external-blocks.md), [함수](items/functions.md), [구현](items/implementations.md), [모듈](items/modules.md)은 내부 속성을 허용합니다."

#: src/attributes.md:97
msgid ""
"Most [statements](statements.md) accept outer attributes (see [Expression "
"Attributes](expressions.md#expression-attributes) for limitations on "
"expression statements)."
msgstr "대부분의 [구문](statements.md)은 외부 속성을 허용합니다 (표현식 구문에 대한 제약 사항은 [표현식 속성](expressions.md#expression-attributes)을 참조하세요)."

#: src/attributes.md:99
msgid ""
"[Block expressions](expressions/block-expr.md) accept outer and inner "
"attributes, but only when they are the outer expression of an [expression "
"statement](statements.md#expression-statements) or the final expression of "
"another block expression."
msgstr "[블록 표현식](expressions/block-expr.md)은 외부 및 내부 속성을 허용하지만, [표현식 구문](statements.md#expression-statements)의 외부 표현식이거나 다른 블록 표현식의 마지막 표현식인 경우에만 해당합니다."

#: src/attributes.md:102
msgid ""
"[Enum](items/enumerations.md) variants and [struct](items/structs.md) and "
"[union](items/unions.md) fields accept outer attributes."
msgstr "[열거형](items/enumerations.md) 변형과 [구조체](items/structs.md) 및 [공용체](items/unions.md) 필드는 외부 속성을 허용합니다."

#: src/attributes.md:103
msgid ""
"[Match expression arms](expressions/match-expr.md) accept outer attributes."
msgstr "[매치 표현식 암(Match expression arms)](expressions/match-expr.md)은 외부 속성을 허용합니다."

#: src/attributes.md:104
msgid ""
"[Generic lifetime or type parameter](items/generics.md) accept outer "
"attributes."
msgstr "[제네릭 라이프타임 또는 타입 매개변수](items/generics.md)는 외부 속성을 허용합니다."

#: src/attributes.md:105
msgid ""
"Expressions accept outer attributes in limited situations, see [Expression "
"Attributes](expressions.md#expression-attributes) for details."
msgstr "표현식은 제한적인 상황에서 외부 속성을 허용합니다. 자세한 내용은 [표현식 속성](expressions.md#expression-attributes)을 참조하세요."

#: src/attributes.md:107
msgid ""
"[Function](items/functions.md), [closure](expressions/closure-expr.md) and "
"[function pointer](types/function-pointer.md) parameters accept outer "
"attributes. This includes attributes on variadic parameters denoted with "
"`...` in function pointers and [external blocks](items/external-"
"blocks.html#variadic-functions)."
msgstr "[함수](items/functions.md), [클로저](expressions/closure-expr.md) 및 [함수 포인터](types/function-pointer.md) 매개변수는 외부 속성을 허용합니다. 여기에는 함수 포인터와 [외부 블록](items/external-blocks.html#variadic-functions)에서 `...`로 표시된 가변 매개변수에 대한 속성도 포함됩니다."

#: src/attributes.md:111
msgid "Some examples of attributes:"
msgstr "속성의 몇 가지 예시:"

#: src/attributes.md:114
msgid "// General metadata applied to the enclosing module or crate.\n"
msgstr "// 둘러싼 모듈이나 크레이트에 적용되는 일반 메타데이터입니다.\n"

#: src/attributes.md:116
msgid "// A function marked as a unit test\n"
msgstr "// 유닛 테스트로 표시된 함수입니다.\n"

#: src/attributes.md:122
msgid "// A conditionally-compiled module\n"
msgstr "// 조건부 컴파일되는 모듈입니다.\n"

#: src/attributes.md:128
msgid "// A lint attribute used to suppress a warning/error\n"
msgstr "// 경고/오류를 억제하기 위해 사용되는 린트(lint) 속성입니다.\n"

#: src/attributes.md:132
msgid "// Inner attribute applies to the entire function.\n"
msgstr "// 내부 속성은 함수 전체에 적용됩니다.\n"

#: src/attributes.md:145
msgid "Meta Item Attribute Syntax"
msgstr "메타 아이템 속성 구문"

#: src/attributes.md:149
msgid ""
"A \"meta item\" is the syntax used for the _Attr_ rule by most [built-in "
"attributes](#built-in-attributes-index). It has the following grammar:"
msgstr "\"메타 아이템(meta item)\"은 대부분의 [내장 속성](#built-in-attributes-index)에서 _Attr_ 규칙을 위해 사용하는 구문입니다. 다음과 같은 문법을 가집니다:"

#: src/attributes.md:154
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MetaItem_ :  \n"
"      [_SimplePath_](paths.md#simple-paths)  \n"
"   | [_SimplePath_](paths.md#simple-paths) `=` [_Expression_]"
"(expressions.md)  \n"
"   | [_SimplePath_](paths.md#simple-paths) `(` _MetaSeq_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_메타아이템_ :  \n"
"      [_단순경로_](paths.md#simple-paths)  \n"
"   | [_단순경로_](paths.md#simple-paths) `=` [_표현식_]"
"(expressions.md)  \n"
"   | [_단순경로_](paths.md#simple-paths) `(` _메타시퀀스_<sup>?</sup> `)`"

#: src/attributes.md:160
msgid ""
"_MetaSeq_ :  \n"
"   _MetaItemInner_ ( `,` MetaItemInner )<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_메타시퀀스_ :  \n"
"   _내부메타아이템_ ( `,` 내부메타아이템 )<sup>\\*</sup> `,`<sup>?</sup>"

#: src/attributes.md:163
msgid ""
"_MetaItemInner_ :  \n"
"      _MetaItem_  \n"
"   | [_Expression_](expressions.md)"
msgstr ""
"_내부메타아이템_ :  \n"
"      _메타아이템_  \n"
"   | [_표현식_](expressions.md)"

#: src/attributes.md:169
msgid ""
"Expressions in meta items must macro-expand to literal expressions, which "
"must not include integer or float type suffixes. Expressions which are not "
"literal expressions will be syntactically accepted (and can be passed to "
"proc-macros), but will be rejected after parsing."
msgstr "메타 아이템 내의 표현식은 반드시 리터럴 표현식으로 매크로 확장되어야 하며, 여기에는 정수 또는 부동 소수점 타입 접미사가 포함되어서는 안 됩니다. 리터럴 표현식이 아닌 표현식은 구문적으로는 허용되지만(절차적 매크로로 전달될 수 있음), 파싱 후에는 거부됩니다."

#: src/attributes.md:175
msgid ""
"Note that if the attribute appears within another macro, it will be expanded "
"after that outer macro. For example, the following code will expand the "
"`Serialize` proc-macro first, which must preserve the `include_str!` call in "
"order for it to be expanded:"
msgstr "속성이 다른 매크로 내에 나타나는 경우, 해당 외부 매크로 다음에 확장된다는 점에 유의하세요. 예를 들어, 다음 코드는 `Serialize` 절차적 매크로를 먼저 확장하며, `include_str!` 호출이 확장되기 위해서는 이 매크로가 해당 호출을 보존해야 합니다."

#: src/attributes.md:180
msgid ""
"```rust ignore\n"
"#[derive(Serialize)]\n"
"struct Foo {\n"
"    #[doc = include_str!(\"x.md\")]\n"
"    x: u32\n"
"}\n"
"```"
msgstr ""
"```rust ignore\n"
"#[derive(Serialize)]\n"
"struct Foo {\n"
"    #[doc = include_str!(\"x.md\")]\n"
"    x: u32\n"
"}\n"
"```"

#: src/attributes.md:190
msgid ""
"Additionally, macros in attributes will be expanded only after all other "
"attributes applied to the item:"
msgstr "추가적으로, 속성 내의 매크로는 아이템에 적용된 다른 모든 속성들이 확장된 후에만 확장됩니다."

#: src/attributes.md:192
msgid ""
"```rust ignore\n"
"#[macro_attr1] // expanded first\n"
"#[doc = mac!()] // `mac!` is expanded fourth.\n"
"#[macro_attr2] // expanded second\n"
"#[derive(MacroDerive1, MacroDerive2)] // expanded third\n"
"fn foo() {}\n"
"```"
msgstr ""
"```rust ignore\n"
"#[macro_attr1] // 첫 번째로 확장됨\n"
"#[doc = mac!()] // `mac!`은 네 번째로 확장됨\n"
"#[macro_attr2] // 두 번째로 확장됨\n"
"#[derive(MacroDerive1, MacroDerive2)] // 세 번째로 확장됨\n"
"fn foo() {}\n"
"```"

#: src/attributes.md:202
msgid ""
"Various built-in attributes use different subsets of the meta item syntax to "
"specify their inputs. The following grammar rules show some commonly used "
"forms:"
msgstr "여러 내장 속성들은 입력을 지정하기 위해 메타 아이템 구문의 서로 다른 하위 집합을 사용합니다. 다음 문법 규칙들은 자주 사용되는 몇 가지 형식을 보여줍니다:"

#: src/attributes.md:206
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MetaWord_:  \n"
"   [IDENTIFIER](identifiers.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_메타단어_:  \n"
"   [식별자](identifiers.md)"

#: src/attributes.md:210
msgid ""
"_MetaNameValueStr_:  \n"
"   [IDENTIFIER](identifiers.md) `=` ([STRING_LITERAL](tokens.md#string-"
"literals) | [RAW_STRING_LITERAL](tokens.md#raw-string-literals))"
msgstr ""
"_메타이름값문자열_:  \n"
"   [식별자](identifiers.md) `=` ([문자열_리터럴](tokens.md#string-"
"literals) | [원시_문자열_리터럴](tokens.md#raw-string-literals))"

#: src/attributes.md:213
msgid ""
"_MetaListPaths_:  \n"
"   [IDENTIFIER](identifiers.md) `(` ( [_SimplePath_](paths.md#simple-paths) "
"(`,` [_SimplePath_](paths.md#simple-paths))\\* `,`<sup>?</sup> )<sup>?</sup> "
"`)`"
msgstr ""
"_메타목록경로_:  \n"
"   [식별자](identifiers.md) `(` ( [_단순경로_](paths.md#simple-paths) "
"(`,` [_단순경로_](paths.md#simple-paths))\\* `,`<sup>?</sup> )<sup>?</sup> "
"`)`"

#: src/attributes.md:216
msgid ""
"_MetaListIdents_:  \n"
"   [IDENTIFIER](identifiers.md) `(` ( [IDENTIFIER](identifiers.md) (`,` "
"[IDENTIFIER](identifiers.md))\\* `,`<sup>?</sup> )<sup>?</sup> `)`"
msgstr ""
"_메타목록식별자_:  \n"
"   [식별자](identifiers.md) `(` ( [식별자](identifiers.md) (`,` "
"[식별자](identifiers.md))\\* `,`<sup>?</sup> )<sup>?</sup> `)`"

#: src/attributes.md:219
msgid ""
"_MetaListNameValueStr_:  \n"
"   [IDENTIFIER](identifiers.md) `(` ( _MetaNameValueStr_ (`,` "
"_MetaNameValueStr_)\\* `,`<sup>?</sup> )<sup>?</sup> `)`"
msgstr ""
"_메타목록이름값문자열_:  \n"
"   [식별자](identifiers.md) `(` ( _메타이름값문자열_ (`,` "
"_메타이름값문자열_)\\* `,`<sup>?</sup> )<sup>?</sup> `)`"

#: src/attributes.md:222
msgid "Some examples of meta items are:"
msgstr "메타 아이템의 몇 가지 예시는 다음과 같습니다:"

#: src/attributes.md:224
msgid "Style"
msgstr "스타일"

#: src/attributes.md:226
msgid "_MetaWord_"
msgstr "_메타단어_"

#: src/attributes.md:226
msgid "`no_std`"
msgstr "`no_std`"

#: src/attributes.md:227
msgid "_MetaNameValueStr_"
msgstr "_메타이름값문자열_"

#: src/attributes.md:227
msgid "`doc = \"example\"`"
msgstr "`doc = \"example\"`"

#: src/attributes.md:228
msgid "_MetaListPaths_"
msgstr "_메타목록경로_"

#: src/attributes.md:228
msgid "`allow(unused, clippy::inline_always)`"
msgstr "`allow(unused, clippy::inline_always)`"

#: src/attributes.md:229
msgid "_MetaListIdents_"
msgstr "_메타목록식별자_"

#: src/attributes.md:229
msgid "`macro_use(foo, bar)`"
msgstr "`macro_use(foo, bar)`"

#: src/attributes.md:230
msgid "_MetaListNameValueStr_"
msgstr "_메타목록이름값문자열_"

#: src/attributes.md:230
msgid "`link(name = \"CoreFoundation\", kind = \"framework\")`"
msgstr "`link(name = \"CoreFoundation\", kind = \"framework\")`"

#: src/attributes.md:234
msgid "Active and inert attributes"
msgstr "활성 및 비활성 속성"

#: src/attributes.md:238
msgid ""
"An attribute is either active or inert. During attribute processing, _active "
"attributes_ remove themselves from the thing they are on while _inert "
"attributes_ stay on."
msgstr "속성은 활성(active) 또는 비활성(inert) 상태입니다. 속성 처리 과정에서 _활성 속성_은 자신이 붙어 있는 대상에서 스스로를 제거하는 반면, _비활성 속성_은 그대로 유지됩니다."

#: src/attributes.md:242
msgid ""
"The [`cfg`](conditional-compilation.md#the-cfg-attribute) and [`cfg_attr`]"
"(conditional-compilation.md#the-cfg_attr-attribute) attributes are active. "
"[Attribute macros](procedural-macros.md#attribute-macros) are active. All "
"other attributes are inert."
msgstr "[`cfg`](conditional-compilation.md#the-cfg-attribute) 및 [`cfg_attr`](conditional-compilation.md#the-cfg_attr-attribute) 속성은 활성 속성입니다. [속성 매크로](procedural-macros.md#attribute-macros)도 활성 속성입니다. 그 외의 모든 속성들은 비활성 속성입니다."

#: src/attributes.md:247
msgid "Tool attributes"
msgstr "도구 속성"

#: src/attributes.md:251
msgid ""
"The compiler may allow attributes for external tools where each tool resides "
"in its own module in the [tool prelude](names/preludes.md#tool-prelude). The "
"first segment of the attribute path is the name of the tool, with one or "
"more additional segments whose interpretation is up to the tool."
msgstr "컴파일러는 각 도구가 [도구 프렐류드(tool prelude)](names/preludes.md#tool-prelude)의 자체 모듈에 상주하는 외부 도구들을 위한 속성을 허용할 수 있습니다. 속성 경로의 첫 번째 세그먼트는 도구의 이름이며, 하나 이상의 추가 세그먼트의 해석은 도구에 달려 있습니다."

#: src/attributes.md:258
msgid ""
"When a tool is not in use, the tool's attributes are accepted without a "
"warning. When the tool is in use, the tool is responsible for processing and "
"interpretation of its attributes."
msgstr "도구가 사용되지 않을 때, 해당 도구의 속성은 경고 없이 수용됩니다. 도구가 사용 중일 때, 도구는 해당 속성의 처리 및 해석을 담당합니다."

#: src/attributes.md:264
msgid ""
"Tool attributes are not available if the [`no_implicit_prelude`](names/"
"preludes.md#the-no_implicit_prelude-attribute) attribute is used."
msgstr "[`no_implicit_prelude`](names/preludes.md#the-no_implicit_prelude-attribute) 속성이 사용되는 경우 도구 속성을 사용할 수 없습니다."

#: src/attributes.md:268
msgid "// Tells the rustfmt tool to not format the following element.\n"
msgstr "// rustfmt 도구에게 다음 요소를 포맷팅하지 않도록 지시합니다.\n"

#: src/attributes.md:272
msgid ""
"// Controls the \"cyclomatic complexity\" threshold for the clippy tool.\n"
msgstr "// clippy 도구의 \"순환 복잡도(cyclomatic complexity)\" 임계값을 제어합니다.\n"

#: src/attributes.md:274
msgid "\"100\""
msgstr "\"100\""

#: src/attributes.md:278
msgid ""
"Note: `rustc` currently recognizes the tools \"clippy\", \"rustfmt\", "
"\"diagnostic\", \"miri\" and \"rust_analyzer\"."
msgstr "참고: `rustc`는 현재 \"clippy\", \"rustfmt\", \"diagnostic\", \"miri\", \"rust_analyzer\" 도구를 인식합니다."

#: src/attributes.md:283
msgid "Built-in attributes index"
msgstr "내장 속성 색인"

#: src/attributes.md:285
msgid "The following is an index of all built-in attributes."
msgstr "다음은 모든 내장 속성의 색인입니다."

#: src/attributes.md:288
msgid ""
"[`cfg`](conditional-compilation.md#the-cfg-attribute) --- Controls "
"conditional compilation."
msgstr "[`cfg`](conditional-compilation.md#the-cfg-attribute) --- 조건부 컴파일을 제어합니다."

#: src/attributes.md:289
msgid ""
"[`cfg_attr`](conditional-compilation.md#the-cfg_attr-attribute) --- "
"Conditionally includes attributes."
msgstr "[`cfg_attr`](conditional-compilation.md#the-cfg_attr-attribute) --- 속성을 조건부로 포함합니다."

#: src/attributes.md:292
msgid ""
"[`test`](attributes/testing.md#the-test-attribute) --- Marks a function as a "
"test."
msgstr "[`test`](attributes/testing.md#the-test-attribute) --- 함수를 테스트로 표시합니다."

#: src/attributes.md:293
msgid ""
"[`ignore`](attributes/testing.md#the-ignore-attribute) --- Disables a test "
"function."
msgstr "[`ignore`](attributes/testing.md#the-ignore-attribute) --- 테스트 함수를 비활성화합니다."

#: src/attributes.md:294
msgid ""
"[`should_panic`](attributes/testing.md#the-should_panic-attribute) --- "
"Indicates a test should generate a panic."
msgstr "[`should_panic`](attributes/testing.md#the-should_panic-attribute) --- 테스트가 패닉을 발생시켜야 함을 나타냅니다."

#: src/attributes.md:297
msgid "[`derive`](attributes/derive.md) --- Automatic trait implementations."
msgstr "[`derive`](attributes/derive.md) --- 트레잇 자동 구현."

#: src/attributes.md:298
msgid ""
"[`automatically_derived`](attributes/derive.md#the-automatically_derived-"
"attribute) --- Marker for implementations created by `derive`."
msgstr "[`automatically_derived`](attributes/derive.md#the-automatically_derived-attribute) --- `derive`에 의해 생성된 구현을 위한 마커입니다."

#: src/attributes.md:302
msgid ""
"[`macro_export`](macros-by-example.md#path-based-scope) --- Exports a "
"`macro_rules` macro for cross-crate usage."
msgstr "[`macro_export`](macros-by-example.md#path-based-scope) --- 크레이트 간 사용을 위해 `macro_rules` 매크로를 내보냅니다."

#: src/attributes.md:303
msgid ""
"[`macro_use`](macros-by-example.md#the-macro_use-attribute) --- Expands "
"macro visibility, or imports macros from other crates."
msgstr "[`macro_use`](macros-by-example.md#the-macro_use-attribute) --- 매크로 가시성을 확장하거나 다른 크레이트에서 매크로를 임포트합니다."

#: src/attributes.md:305
msgid ""
"[`proc_macro`](procedural-macros.md#function-like-procedural-macros) --- "
"Defines a function-like macro."
msgstr "[`proc_macro`](procedural-macros.md#function-like-procedural-macros) --- 함수 유사 매크로(function-like macro)를 정의합니다."

#: src/attributes.md:306
msgid ""
"[`proc_macro_derive`](procedural-macros.md#derive-macros) --- Defines a "
"derive macro."
msgstr "[`proc_macro_derive`](procedural-macros.md#derive-macros) --- derive 매크로를 정의합니다."

#: src/attributes.md:307
msgid ""
"[`proc_macro_attribute`](procedural-macros.md#attribute-macros) --- Defines "
"an attribute macro."
msgstr "[`proc_macro_attribute`](procedural-macros.md#attribute-macros) --- 속성 매크로(attribute macro)를 정의합니다."

#: src/attributes.md:310
msgid ""
"[`allow`](attributes/diagnostics.md#lint-check-attributes), [`expect`]"
"(attributes/diagnostics.md#lint-check-attributes), [`warn`](attributes/"
"diagnostics.md#lint-check-attributes), [`deny`](attributes/"
"diagnostics.md#lint-check-attributes), [`forbid`](attributes/"
"diagnostics.md#lint-check-attributes) --- Alters the default lint level."
msgstr "[`allow`](attributes/diagnostics.md#lint-check-attributes), [`expect`](attributes/diagnostics.md#lint-check-attributes), [`warn`](attributes/diagnostics.md#lint-check-attributes), [`deny`](attributes/diagnostics.md#lint-check-attributes), [`forbid`](attributes/diagnostics.md#lint-check-attributes) --- 기본 린트(lint) 레벨을 변경합니다."

#: src/attributes.md:311
msgid ""
"[`deprecated`](attributes/diagnostics.md#the-deprecated-attribute) --- "
"Generates deprecation notices."
msgstr "[`deprecated`](attributes/diagnostics.md#the-deprecated-attribute) --- 사용 중단(deprecation) 공지를 생성합니다."

#: src/attributes.md:312
msgid ""
"[`must_use`](attributes/diagnostics.md#the-must_use-attribute) --- Generates "
"a lint for unused values."
msgstr "[`must_use`](attributes/diagnostics.md#the-must_use-attribute) --- 사용되지 않은 값에 대해 린트를 생성합니다."

#: src/attributes.md:313
msgid ""
"[`diagnostic::on_unimplemented`](attributes/diagnostics.md#the-"
"diagnosticon_unimplemented-attribute) --- Hints the compiler to emit a "
"certain error message if a trait is not implemented."
msgstr "[`diagnostic::on_unimplemented`](attributes/diagnostics.md#the-diagnosticon_unimplemented-attribute) --- 트레잇이 구현되지 않은 경우 특정 에러 메시지를 내보내도록 컴파일러에 힌트를 줍니다."

#: src/attributes.md:315
msgid ""
"[`diagnostic::do_not_recommend`](attributes/diagnostics.md#the-"
"diagnosticdo_not_recommend-attribute) --- Hints the compiler to not show a "
"certain trait impl in error messages."
msgstr "[`diagnostic::do_not_recommend`](attributes/diagnostics.md#the-diagnosticdo_not_recommend-attribute) --- 에러 메시지에서 특정 트레잇 구현을 표시하지 않도록 컴파일러에 힌트를 줍니다."

#: src/attributes.md:317
msgid "ABI, linking, symbols, and FFI"
msgstr "ABI, 링크, 심볼 및 FFI"

#: src/attributes.md:318
msgid ""
"[`link`](items/external-blocks.md#the-link-attribute) --- Specifies a native "
"library to link with an `extern` block."
msgstr "[`link`](items/external-blocks.md#the-link-attribute) --- `extern` 블록과 링크할 네이티브 라이브러리를 지정합니다."

#: src/attributes.md:319
msgid ""
"[`link_name`](items/external-blocks.md#the-link_name-attribute) --- "
"Specifies the name of the symbol for functions or statics in an `extern` "
"block."
msgstr "[`link_name`](items/external-blocks.md#the-link_name-attribute) --- `extern` 블록 내의 함수나 정적 아이템을 위한 심볼 이름을 지정합니다."

#: src/attributes.md:321
msgid ""
"[`link_ordinal`](items/external-blocks.md#the-link_ordinal-attribute) --- "
"Specifies the ordinal of the symbol for functions or statics in an `extern` "
"block."
msgstr "[`link_ordinal`](items/external-blocks.md#the-link_ordinal-attribute) --- `extern` 블록 내의 함수나 정적 아이템을 위한 심볼의 오디널(ordinal)을 지정합니다."

#: src/attributes.md:323
msgid ""
"[`no_link`](items/extern-crates.md#the-no_link-attribute) --- Prevents "
"linking an extern crate."
msgstr "[`no_link`](items/extern-crates.md#the-no_link-attribute) --- 외부 크레이트가 링크되는 것을 방지합니다."

#: src/attributes.md:324
msgid "[`repr`](type-layout.md#representations) --- Controls type layout."
msgstr "[`repr`](type-layout.md#representations) --- 타입 레이아웃을 제어합니다."

#: src/attributes.md:325
msgid ""
"[`crate_type`](linkage.md) --- Specifies the type of crate (library, "
"executable, etc.)."
msgstr "[`crate_type`](linkage.md) --- 크레이트의 종류(라이브러리, 실행 파일 등)를 지정합니다."

#: src/attributes.md:326
msgid ""
"[`no_main`](crates-and-source-files.md#the-no_main-attribute) --- Disables "
"emitting the `main` symbol."
msgstr "[`no_main`](crates-and-source-files.md#the-no_main-attribute) --- `main` 심볼 내보내기를 비활성화합니다."

#: src/attributes.md:327
msgid ""
"[`export_name`](abi.md#the-export_name-attribute) --- Specifies the exported "
"symbol name for a function or static."
msgstr "[`export_name`](abi.md#the-export_name-attribute) --- 함수나 정적 아이템에 대해 내보낼 심볼 이름을 지정합니다."

#: src/attributes.md:329
msgid ""
"[`link_section`](abi.md#the-link_section-attribute) --- Specifies the "
"section of an object file to use for a function or static."
msgstr "[`link_section`](abi.md#the-link_section-attribute) --- 함수나 정적 아이템에 사용할 객체 파일의 섹션을 지정합니다."

#: src/attributes.md:331
msgid ""
"[`no_mangle`](abi.md#the-no_mangle-attribute) --- Disables symbol name "
"encoding."
msgstr "[`no_mangle`](abi.md#the-no_mangle-attribute) --- 심볼 이름 인코딩(mangling)을 비활성화합니다."

#: src/attributes.md:332
msgid ""
"[`used`](abi.md#the-used-attribute) --- Forces the compiler to keep a static "
"item in the output object file."
msgstr "[`used`](abi.md#the-used-attribute) --- 컴파일러가 출력 객체 파일에서 정적 아이템을 유지하도록 강제합니다."

#: src/attributes.md:334
msgid ""
"[`crate_name`](crates-and-source-files.md#the-crate_name-attribute) --- "
"Specifies the crate name."
msgstr "[`crate_name`](crates-and-source-files.md#the-crate_name-attribute) --- 크레이트 이름을 지정합니다."

#: src/attributes.md:337
msgid ""
"[`inline`](attributes/codegen.md#the-inline-attribute) --- Hint to inline "
"code."
msgstr "[`inline`](attributes/codegen.md#the-inline-attribute) --- 코드 인라이닝에 대한 힌트입니다."

#: src/attributes.md:338
msgid ""
"[`cold`](attributes/codegen.md#the-cold-attribute) --- Hint that a function "
"is unlikely to be called."
msgstr "[`cold`](attributes/codegen.md#the-cold-attribute) --- 함수가 거의 호출되지 않을 것임을 나타내는 힌트입니다."

#: src/attributes.md:339
msgid ""
"[`no_builtins`](attributes/codegen.md#the-no_builtins-attribute) --- "
"Disables use of certain built-in functions."
msgstr "[`no_builtins`](attributes/codegen.md#the-no_builtins-attribute) --- 특정 내장 함수들의 사용을 비활성화합니다."

#: src/attributes.md:340
msgid ""
"[`target_feature`](attributes/codegen.md#the-target_feature-attribute) --- "
"Configure platform-specific code generation."
msgstr "[`target_feature`](attributes/codegen.md#the-target_feature-attribute) --- 플랫폼별 코드 생성을 구성합니다."

#: src/attributes.md:341
msgid ""
"[`track_caller`](attributes/codegen.md#the-track_caller-attribute) --- Pass "
"the parent call location to `std::panic::Location::caller()`."
msgstr "[`track_caller`](attributes/codegen.md#the-track_caller-attribute) --- 부모 호출 위치를 `std::panic::Location::caller()`로 전달합니다."

#: src/attributes.md:342
msgid ""
"[`instruction_set`](attributes/codegen.md#the-instruction_set-attribute) --- "
"Specify the instruction set used to generate a functions code"
msgstr "[`instruction_set`](attributes/codegen.md#the-instruction_set-attribute) --- 함수 코드 생성에 사용될 명령어 집합을 지정합니다."

#: src/attributes.md:344
msgid "Documentation"
msgstr "문서화"

#: src/attributes.md:345
msgid ""
"`doc` --- Specifies documentation. See [The Rustdoc Book](../rustdoc/the-doc-"
"attribute.html) for more information. [Doc comments](comments.md#doc-"
"comments) are transformed into `doc` attributes."
msgstr "`doc` --- 문서를 지정합니다. 자세한 내용은 [Rustdoc 책](../rustdoc/the-doc-attribute.html)을 참조하세요. [문서 주석](comments.md#doc-comments)은 `doc` 속성으로 변환됩니다."

#: src/attributes.md:349
msgid ""
"[`no_std`](names/preludes.md#the-no_std-attribute) --- Removes std from the "
"prelude."
msgstr "[`no_std`](names/preludes.md#the-no_std-attribute) --- 프렐류드에서 std를 제거합니다."

#: src/attributes.md:350
msgid ""
"[`no_implicit_prelude`](names/preludes.md#the-no_implicit_prelude-attribute) "
"--- Disables prelude lookups within a module."
msgstr "[`no_implicit_prelude`](names/preludes.md#the-no_implicit_prelude-attribute) --- 모듈 내에서 프렐류드 조회를 비활성화합니다."

#: src/attributes.md:353
msgid ""
"[`path`](items/modules.md#the-path-attribute) --- Specifies the filename for "
"a module."
msgstr "[`path`](items/modules.md#the-path-attribute) --- 모듈의 파일 이름을 지정합니다."

#: src/attributes.md:356
msgid ""
"[`recursion_limit`](attributes/limits.md#the-recursion_limit-attribute) --- "
"Sets the maximum recursion limit for certain compile-time operations."
msgstr "[`recursion_limit`](attributes/limits.md#the-recursion_limit-attribute) --- 특정 컴파일 타임 연산에 대한 최대 재귀 한도를 설정합니다."

#: src/attributes.md:358
msgid ""
"[`type_length_limit`](attributes/limits.md#the-type_length_limit-attribute) "
"--- Sets the maximum size of a polymorphic type."
msgstr "[`type_length_limit`](attributes/limits.md#the-type_length_limit-attribute) --- 다형성 타입(polymorphic type)의 최대 크기를 설정합니다."

#: src/attributes.md:360
msgid "Runtime"
msgstr "런타임"

#: src/attributes.md:361
msgid ""
"[`panic_handler`](runtime.md#the-panic_handler-attribute) --- Sets the "
"function to handle panics."
msgstr "[`panic_handler`](runtime.md#the-panic_handler-attribute) --- 패닉을 처리할 함수를 설정합니다."

#: src/attributes.md:362
msgid ""
"[`global_allocator`](runtime.md#the-global_allocator-attribute) --- Sets the "
"global memory allocator."
msgstr "[`global_allocator`](runtime.md#the-global_allocator-attribute) --- 전역 메모리 할당자를 설정합니다."

#: src/attributes.md:363
msgid ""
"[`windows_subsystem`](runtime.md#the-windows_subsystem-attribute) --- "
"Specifies the windows subsystem to link with."
msgstr "[`windows_subsystem`](runtime.md#the-windows_subsystem-attribute) --- 링크할 Windows 하위 시스템을 지정합니다."

#: src/attributes.md:365
msgid "Features"
msgstr "기능(Features)"

#: src/attributes.md:366
msgid ""
"`feature` --- Used to enable unstable or experimental compiler features. See "
"[The Unstable Book](../unstable-book/index.html) for features implemented in "
"`rustc`."
msgstr "`feature` --- 불안정하거나 실험적인 컴파일러 기능을 활성화하는 데 사용됩니다. `rustc`에 구현된 기능들에 대해서는 [Unstable Book](../unstable-book/index.html)을 참조하세요."

#: src/attributes.md:370
msgid ""
"[`non_exhaustive`](attributes/type_system.md#the-non_exhaustive-attribute) "
"--- Indicate that a type will have more fields/variants added in future."
msgstr "[`non_exhaustive`](attributes/type_system.md#the-non_exhaustive-attribute) --- 미래에 타입에 더 많은 필드나 변형이 추가될 것임을 나타냅니다."

#: src/attributes.md:374
msgid ""
"[`debugger_visualizer`](attributes/debugger.md#the-debugger_visualizer-"
"attribute) --- Embeds a file that specifies debugger output for a type."
msgstr "[`debugger_visualizer`](attributes/debugger.md#the-debugger_visualizer-attribute) --- 타입에 대한 디버거 출력을 지정하는 파일을 포함시킵니다."

#: src/attributes.md:375
msgid ""
"[`collapse_debuginfo`](attributes/debugger.md#the-collapse_debuginfo-"
"attribute) --- Controls how macro invocations are encoded in debuginfo."
msgstr "[`collapse_debuginfo`](attributes/debugger.md#the-collapse_debuginfo-attribute) --- 디버그 정보에서 매크로 호출이 인코딩되는 방식을 제어합니다."

#: src/attributes/testing.md:3
msgid "Testing attributes"
msgstr "테스팅 속성"

#: src/attributes/testing.md:6
msgid ""
"The following [attributes](../attributes.md) are used for specifying "
"functions for performing tests. Compiling a crate in \"test\" mode enables "
"building the test functions along with a test harness for executing the "
"tests. Enabling the test mode also enables the [`test` conditional "
"compilation option](../conditional-compilation.md#test)."
msgstr "다음 [속성들](../attributes.md)은 테스트를 수행하기 위한 함수를 지정하는 데 사용됩니다. 크레이트를 \"test\" 모드로 컴파일하면 테스트를 실행하기 위한 테스트 하네스와 함께 테스트 함수들이 빌드됩니다. 테스트 모드를 활성화하면 [`test` 조건부 컴파일 옵션](../conditional-compilation.md#test)도 활성화됩니다."

#: src/attributes/testing.md:13
msgid "The `test` attribute"
msgstr "`test` 속성"

#: src/attributes/testing.md:17
msgid "The _`test` attribute_ marks a function to be executed as a test."
msgstr "_`test` 속성_은 함수를 테스트로서 실행되도록 표시합니다."

#: src/attributes/testing.md:21
msgid "These functions are only compiled when in test mode."
msgstr "이러한 함수들은 테스트 모드일 때만 컴파일됩니다."

#: src/attributes/testing.md:25
msgid ""
"Test functions must be free, monomorphic functions that take no arguments, "
"and the return type must implement the [`Termination`](../../std/process/"
"trait.Termination.html) trait, for example:"
msgstr "테스트 함수는 인수를 받지 않는 자유(free) 함수이자 모노모르픽(monomorphic) 함수여야 하며, 반환 타입은 [`Termination`](../../std/process/trait.Termination.html) 트레잇을 구현해야 합니다. 예를 들어:"

#: src/attributes/testing.md:34
msgid ""
"Note: The test mode is enabled by passing the `--test` argument to `rustc` "
"or using `cargo test`."
msgstr "참고: 테스트 모드는 `rustc`에 `--test` 인수를 전달하거나 `cargo test`를 사용하여 활성화됩니다."

#: src/attributes/testing.md:39
msgid ""
"The test harness calls the returned value's [`report`](../../std/process/"
"trait.Termination.html#tymethod.report) method, and classifies the test as "
"passed or failed depending on whether the resulting [`ExitCode`](../../std/"
"process/struct.ExitCode.html) represents successful termination. In "
"particular:"
msgstr "테스트 하네스는 반환된 값의 [`report`](../../std/process/trait.Termination.html#tymethod.report) 메서드를 호출하며, 결과 [`ExitCode`](../../std/process/struct.ExitCode.html)가 성공적인 종료를 나타내는지 여부에 따라 테스트를 통과 또는 실패로 분류합니다. 특히:"

#: src/attributes/testing.md:41
msgid "Tests that return `()` pass as long as they terminate and do not panic."
msgstr "`()`를 반환하는 테스트는 종료되고 패닉이 발생하지 않는 한 통과합니다."

#: src/attributes/testing.md:42
msgid ""
"Tests that return a `Result<(), E>` pass as long as they return `Ok(())`."
msgstr "`Result<(), E>`를 반환하는 테스트는 `Ok(())`를 반환하는 한 통과합니다."

#: src/attributes/testing.md:43
msgid ""
"Tests that return `ExitCode::SUCCESS` pass, and tests that return "
"`ExitCode::FAILURE` fail."
msgstr "`ExitCode::SUCCESS`를 반환하는 테스트는 통과하고, `ExitCode::FAILURE`를 반환하는 테스트는 실패합니다."

#: src/attributes/testing.md:44
msgid "Tests that do not terminate neither pass nor fail."
msgstr "종료되지 않는 테스트는 통과도 실패도 하지 않습니다."

#: src/attributes/testing.md:52 src/attributes/testing.md:53
msgid "// expected to succeed\n"
msgstr "// 성공할 것으로 예상됨\n"

#: src/attributes/testing.md:60
msgid "The `ignore` attribute"
msgstr "`ignore` 속성"

#: src/attributes/testing.md:64
msgid ""
"A function annotated with the `test` attribute can also be annotated with "
"the `ignore` attribute. The _`ignore` attribute_ tells the test harness to "
"not execute that function as a test. It will still be compiled when in test "
"mode."
msgstr "`test` 속성이 지정된 함수에는 `ignore` 속성도 지정할 수 있습니다. _`ignore` 속성_은 테스트 하네스에게 해당 함수를 테스트로 실행하지 않도록 지시합니다. 테스트 모드일 때 여전히 컴파일은 됩니다."

#: src/attributes/testing.md:70
msgid ""
"The `ignore` attribute may optionally be written with the "
"[_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) syntax to "
"specify a reason why the test is ignored."
msgstr "`ignore` 속성은 선택적으로 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하여 테스트가 무시되는 이유를 명시할 수 있습니다."

#: src/attributes/testing.md:75
msgid "\"not yet implemented\""
msgstr "\"아직 구현되지 않음\""

#: src/attributes/testing.md:81
msgid ""
"**Note**: The `rustc` test harness supports the `--include-ignored` flag to "
"force ignored tests to be run."
msgstr "**참고**: `rustc` 테스트 하네스는 무시된 테스트를 강제로 실행하기 위한 `--include-ignored` 플래그를 지원합니다."

#: src/attributes/testing.md:86
msgid "The `should_panic` attribute"
msgstr "`should_panic` 속성"

#: src/attributes/testing.md:90
msgid ""
"A function annotated with the `test` attribute that returns `()` can also be "
"annotated with the `should_panic` attribute."
msgstr "`()`를 반환하고 `test` 속성이 지정된 함수에는 `should_panic` 속성도 지정할 수 있습니다."

#: src/attributes/testing.md:95
msgid ""
"The _`should_panic` attribute_ makes the test only pass if it actually "
"panics."
msgstr "_`should_panic` 속성_은 테스트가 실제로 패닉이 발생한 경우에만 통과하도록 만듭니다."

#: src/attributes/testing.md:100
msgid ""
"The `should_panic` attribute may optionally take an input string that must "
"appear within the panic message. If the string is not found in the message, "
"then the test will fail. The string may be passed using the "
"[_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) syntax or "
"the [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) "
"syntax with an `expected` field."
msgstr "`should_panic` 속성은 선택적으로 패닉 메시지 내에 나타나야 하는 입력 문자열을 받을 수 있습니다. 해당 문자열이 메시지 내에서 발견되지 않으면 테스트는 실패합니다. 이 문자열은 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문이나 `expected` 필드가 있는 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하여 전달할 수 있습니다."

#: src/attributes/testing.md:108 src/attributes/testing.md:110
msgid "\"values don't match\""
msgstr "\"값들이 일치하지 않음\""

#: src/attributes/derive.md:7
msgid ""
"The _`derive` attribute_ allows new [items](../items.md) to be automatically "
"generated for data structures."
msgstr "_`derive` 속성_은 데이터 구조에 대해 새로운 [아이템들](../items.md)이 자동으로 생성되도록 합니다."

#: src/attributes/derive.md:12
msgid ""
"It uses the [_MetaListPaths_](../attributes.md#meta-item-attribute-syntax) "
"syntax to specify a list of traits to implement or paths to [derive macros]"
"(../procedural-macros.md#derive-macros) to process."
msgstr "이 속성은 구현할 트레잇 목록이나 처리할 [derive 매크로](../procedural-macros.md#derive-macros) 경로를 지정하기 위해 [_MetaListPaths_](../attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/attributes/derive.md:15
msgid ""
"For example, the following will create an [`impl` item](../items/"
"implementations.md) for the [`PartialEq`](../../core/cmp/"
"trait.PartialEq.html) and [`Clone`](../../core/clone/trait.Clone.html) "
"traits for `Foo`, and the type parameter `T` will be given the `PartialEq` "
"or `Clone` constraints for the appropriate `impl`:"
msgstr "예를 들어, 다음 코드는 `Foo`에 대해 [`PartialEq`](../../core/cmp/trait.PartialEq.html) 및 [`Clone`](../../core/clone/trait.Clone.html) 트레잇을 위한 [`impl` 아이템](../items/implementations.md)을 생성하며, 타입 매개변수 `T`에는 적절한 `impl`을 위한 `PartialEq` 또는 `Clone` 제약 조건이 부여됩니다."

#: src/attributes/derive.md:27
msgid "The generated `impl` for `PartialEq` is equivalent to"
msgstr "`PartialEq`를 위해 생성된 `impl`은 다음과 동일합니다."

#: src/attributes/derive.md:40
msgid ""
"You can implement `derive` for your own traits through [procedural macros]"
"(../procedural-macros.md#derive-macros)."
msgstr "[절차적 매크로](../procedural-macros.md#derive-macros)를 통해 여러분의 트레잇에 대해서도 `derive`를 구현할 수 있습니다."

#: src/attributes/derive.md:44
msgid "The `automatically_derived` attribute"
msgstr "`automatically_derived` 속성"

#: src/attributes/derive.md:46
msgid ""
"The _`automatically_derived` attribute_ is automatically added to "
"[implementations](../items/implementations.md) created by the `derive` "
"attribute for built-in traits. It has no direct effect, but it may be used "
"by tools and diagnostic lints to detect these automatically generated "
"implementations."
msgstr "_`automatically_derived` 속성_은 내장 트레잇에 대해 `derive` 속성에 의해 생성된 [구현들](../items/implementations.md)에 자동으로 추가됩니다. 이 속성은 직접적인 효과는 없지만, 도구나 진단 린트에서 이렇게 자동으로 생성된 구현들을 감지하는 데 사용될 수 있습니다."

#: src/attributes/diagnostics.md:3
msgid "Diagnostic attributes"
msgstr "진단 속성"

#: src/attributes/diagnostics.md:5
msgid ""
"The following [attributes](../attributes.md) are used for controlling or "
"generating diagnostic messages during compilation."
msgstr "다음 [속성들](../attributes.md)은 컴파일 중에 진단 메시지를 제어하거나 생성하는 데 사용됩니다."

#: src/attributes/diagnostics.md:10
msgid "Lint check attributes"
msgstr "린트(Lint) 체크 속성"

#: src/attributes/diagnostics.md:12
msgid ""
"A lint check names a potentially undesirable coding pattern, such as "
"unreachable code or omitted documentation."
msgstr "린트 체크는 도달할 수 없는 코드나 누락된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴을 지적합니다."

#: src/attributes/diagnostics.md:17
msgid ""
"The lint attributes `allow`, `expect`, `warn`, `deny`, and `forbid` use the "
"[_MetaListPaths_](../attributes.md#meta-item-attribute-syntax) syntax to "
"specify a list of lint names to change the lint level for the entity to "
"which the attribute applies."
msgstr "린트 속성 `allow`, `expect`, `warn`, `deny`, `forbid`는 속성이 적용되는 엔티티의 린트 레벨을 변경하기 위한 린트 이름 목록을 지정하기 위해 [_MetaListPaths_](../attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/attributes/diagnostics.md:22
msgid "For any lint check `C`:"
msgstr "임의의 린트 체크 `C`에 대해:"

#: src/attributes/diagnostics.md:26
msgid ""
"`#[allow(C)]` overrides the check for `C` so that violations will go "
"unreported."
msgstr "`#[allow(C)]`는 `C`에 대한 체크를 무시하여 위반 사항이 보고되지 않도록 합니다."

#: src/attributes/diagnostics.md:31
msgid ""
"`#[expect(C)]` indicates that lint `C` is expected to be emitted. The "
"attribute will suppress the emission of `C` or issue a warning, if the "
"expectation is unfulfilled."
msgstr "`#[expect(C)]`는 린트 `C`가 발생할 것으로 예상됨을 나타냅니다. 이 속성은 `C`의 발생을 억제하거나, 예상이 충족되지 않은 경우 경고를 발생시킵니다."

#: src/attributes/diagnostics.md:37
msgid "`#[warn(C)]` warns about violations of `C` but continues compilation."
msgstr "`#[warn(C)]`는 `C` 위반에 대해 경고하지만 컴파일을 계속합니다."

#: src/attributes/diagnostics.md:41
msgid "`#[deny(C)]` signals an error after encountering a violation of `C`,"
msgstr "`#[deny(C)]`는 `C` 위반을 발견하면 에러를 발생시킵니다."

#: src/attributes/diagnostics.md:45
msgid ""
"`#[forbid(C)]` is the same as `deny(C)`, but also forbids changing the lint "
"level afterwards,"
msgstr ""
"`#[forbid(C)]`는 `deny(C)`와 동일하지만, 이후에 린트 레벨을 변경하는 것도 "
"금지합니다."

#: src/attributes/diagnostics.md:48
msgid ""
"Note: The lint checks supported by `rustc` can be found via `rustc -W help`, "
"along with their default settings and are documented in the [rustc book]"
"(../../rustc/lints/index.html)."
msgstr "참고: `rustc`에서 지원하는 린트 체크 목록과 기본 설정은 `rustc -W help`를 통해 확인할 수 있으며, [rustc 책](../../rustc/lints/index.html)에도 문서화되어 있습니다."

#: src/attributes/diagnostics.md:53 src/attributes/diagnostics.md:83
msgid "// Missing documentation is ignored here\n"
msgstr "// 여기서 누락된 문서는 무시됩니다.\n"

#: src/attributes/diagnostics.md:57 src/attributes/diagnostics.md:92
msgid "// Missing documentation signals a warning here\n"
msgstr "// 여기서 누락된 문서는 경고를 발생시킵니다.\n"

#: src/attributes/diagnostics.md:61
msgid "// Missing documentation signals an error here\n"
msgstr "// 여기서 누락된 문서는 에러를 발생시킵니다.\n"

#: src/attributes/diagnostics.md:69
msgid ""
"Lint attributes can override the level specified from a previous attribute, "
"as long as the level does not attempt to change a forbidden lint (except for "
"`deny`, which is allowed inside a `forbid` context, but ignored). Previous "
"attributes are those from a higher level in the syntax tree, or from a "
"previous attribute on the same entity as listed in left-to-right source "
"order."
msgstr "린트 속성은 이전 속성에서 지정된 레벨을 오버라이드할 수 있습니다. 단, 금지된(forbidden) 린트 레벨을 변경하려고 시도해서는 안 됩니다 (단, `deny`는 `forbid` 컨텍스트 내부에서 허용되지만 무시됩니다). 이전 속성이란 구문 트리에서 상위 레벨에 있는 속성이나, 소스 코드 순서상 왼쪽에서 오른쪽으로 나열된 동일한 엔티티의 이전 속성을 의미합니다."

#: src/attributes/diagnostics.md:75
msgid ""
"This example shows how one can use `allow` and `warn` to toggle a particular "
"check on and off:"
msgstr "이 예시는 `allow`와 `warn`을 사용하여 특정 체크를 켜고 끄는 방법을 보여줍니다."

#: src/attributes/diagnostics.md:86
msgid ""
"// Missing documentation signals a warning here,\n"
"        // despite the allow above.\n"
msgstr ""
"// 위의 allow에도 불구하고,\n"
"        // 여기서 누락된 문서는 경고를 발생시킵니다.\n"

#: src/attributes/diagnostics.md:97
msgid ""
"This example shows how one can use `forbid` to disallow uses of `allow` or "
"`expect` for that lint check:"
msgstr "이 예시는 특정 린트 체크에 대해 `allow`나 `expect`를 사용하는 것을 금지하기 위해 `forbid`를 사용하는 방법을 보여줍니다."

#: src/attributes/diagnostics.md:103
msgid "// Attempting to toggle warning signals an error here\n"
msgstr "// 경고를 토글하려고 시도하면 여기서 에러가 발생합니다.\n"

#: src/attributes/diagnostics.md:105
msgid "/// Returns 2.\n"
msgstr "/// 2를 반환합니다.\n"

#: src/attributes/diagnostics.md:110
msgid ""
"Note: `rustc` allows setting lint levels on the [command-line](../../rustc/"
"lints/levels.html#via-compiler-flag), and also supports [setting caps](../../"
"rustc/lints/levels.html#capping-lints) on the lints that are reported."
msgstr "참고: `rustc`는 [커맨드 라인](../../rustc/lints/levels.html#via-compiler-flag)에서 린트 레벨을 설정하는 것을 허용하며, 보고되는 린트에 대해 [상한(caps) 설정](../../rustc/lints/levels.html#capping-lints)도 지원합니다."

#: src/attributes/diagnostics.md:116
msgid "Lint Reasons"
msgstr "린트 사유(Lint Reasons)"

#: src/attributes/diagnostics.md:118
msgid ""
"All lint attributes support an additional `reason` parameter, to give "
"context why a certain attribute was added. This reason will be displayed as "
"part of the lint message if the lint is emitted at the defined level."
msgstr "모든 린트 속성은 특정 속성이 추가된 이유에 대한 문맥을 제공하기 위해 추가적인 `reason` 매개변수를 지원합니다. 이 사유는 린트가 정의된 레벨에서 내보내질 때 린트 메시지의 일부로 표시됩니다."

#: src/attributes/diagnostics.md:123
msgid ""
"// `keyword_idents` is allowed by default. Here we deny it to\n"
"// avoid migration of identifiers when we update the edition.\n"
msgstr ""
"// `keyword_idents`는 기본적으로 허용됩니다. 여기서는 에디션을 업데이트할 때\n"
"// 식별자 마이그레이션을 피하기 위해 이를 거부(deny)합니다.\n"

#: src/attributes/diagnostics.md:127
msgid "\"we want to avoid these idents to be future compatible\""
msgstr "\"미래 호환성을 위해 이러한 식별자들을 피하고 싶습니다\""

#: src/attributes/diagnostics.md:129
msgid ""
"// This name was allowed in Rust's 2015 edition. We still aim to avoid\n"
"// this to be future compatible and not confuse end users.\n"
msgstr ""
"// 이 이름은 Rust 2015 에디션에서 허용되었습니다. 우리는 여전히 피하고자 합니다\n"
"// 미래 호환성을 확보하고 최종 사용자에게 혼란을 주지 않기 위함입니다.\n"

#: src/attributes/diagnostics.md:135
msgid "Here is another example, where the lint is allowed with a reason:"
msgstr "사유와 함께 린트를 허용한 또 다른 예시입니다:"

#: src/attributes/diagnostics.md:141
msgid ""
"// The `reason` parameter on `allow` attributes acts as documentation for "
"the reader.\n"
msgstr "// `allow` 속성의 `reason` 매개변수는 독자를 위한 문서 역할을 합니다.\n"

#: src/attributes/diagnostics.md:142
msgid "\"this is only modified on some platforms\""
msgstr "\"이것은 일부 플랫폼에서만 수정됩니다\""

#: src/attributes/diagnostics.md:143
msgid "\"git\""
msgstr "\"git\""

#: src/attributes/diagnostics.md:146
msgid "\"exe\""
msgstr "\"exe\""

#: src/attributes/diagnostics.md:154
msgid "The `#[expect]` attribute"
msgstr "`#[expect]` 속성"

#: src/attributes/diagnostics.md:158
msgid ""
"The `#[expect(C)]` attribute creates a lint expectation for lint `C`. The "
"expectation will be fulfilled, if a `#[warn(C)]` attribute at the same "
"location would result in a lint emission. If the expectation is unfulfilled, "
"because lint `C` would not be emitted, the `unfulfilled_lint_expectations` "
"lint will be emitted at the attribute."
msgstr "`#[expect(C)]` 속성은 린트 `C`에 대한 린트 기대를 생성합니다. 동일한 위치의 `#[warn(C)]` 속성이 린트를 발생시키는 경우 기대가 충족됩니다. 린트 `C`가 발생하지 않아 기대가 충족되지 않으면, 해당 속성 위치에서 `unfulfilled_lint_expectations` 린트가 발생합니다."

#: src/attributes/diagnostics.md:166
msgid ""
"// This `#[expect]` attribute creates a lint expectation, that the "
"`unused_variables`\n"
"    // lint would be emitted by the following statement. This expectation "
"is\n"
"    // unfulfilled, since the `question` variable is used by the `println!` "
"macro.\n"
"    // Therefore, the `unfulfilled_lint_expectations` lint will be emitted "
"at the\n"
"    // attribute.\n"
msgstr ""
"// 이 `#[expect]` 속성은 `unused_variables` 린트가 다음 문장에서 발생할 것이라는\n"
"    // 린트 기대를 생성합니다. `question` 변수가 `println!` 매크로에 의해\n"
"    // 사용되므로 이 기대는 충족되지 않습니다. 따라서 해당 속성 위치에서\n"
"    // `unfulfilled_lint_expectations` 린트가 발생합니다.\n"

#: src/attributes/diagnostics.md:172
msgid "\"who lives in a pineapple under the sea?\""
msgstr "\"누가 바다 저 깊은 곳 파인애플에 살까요?\""

#: src/attributes/diagnostics.md:173
msgid "\"{question}\""
msgstr "\"{question}\""

#: src/attributes/diagnostics.md:175
msgid ""
"// This `#[expect]` attribute creates a lint expectation that will be "
"fulfilled, since\n"
"    // the `answer` variable is never used. The `unused_variables` lint, "
"that would usually\n"
"    // be emitted, is suppressed. No warning will be issued for the "
"statement or attribute.\n"
msgstr ""
"// 이 `#[expect]` 속성은 `answer` 변수가 전혀 사용되지 않으므로 충족될\n"
"    // 린트 기대를 생성합니다. 평소라면 발생했을 `unused_variables` 린트는\n"
"    // 억제됩니다. 해당 문장이나 속성에 대해 어떤 경고도 발생하지 않습니다.\n"

#: src/attributes/diagnostics.md:179
msgid "\"SpongeBob SquarePants!\""
msgstr "\"네모네모 스폰지밥!\""

#: src/attributes/diagnostics.md:185
msgid ""
"The lint expectation is only fulfilled by lint emissions which have been "
"suppressed by the `expect` attribute. If the lint level is modified in the "
"scope with other level attributes like `allow` or `warn`, the lint emission "
"will be handled accordingly and the expectation will remain unfulfilled."
msgstr "린트 기대는 `expect` 속성에 의해 억제된 린트 발생에 의해서만 충족됩니다. 만약 `allow`나 `warn` 같은 다른 레벨 속성에 의해 해당 스코프에서 린트 레벨이 수정되면, 린트 발생은 그에 맞춰 처리되며 기대는 충족되지 않은 상태로 남습니다."

#: src/attributes/diagnostics.md:193
msgid ""
"// This will emit the `unused_variables` lint at the warn level\n"
"    // as defined by the `warn` attribute. This will not fulfill the\n"
"    // expectation above the function.\n"
msgstr ""
"// 이것은 `warn` 속성에 정의된 대로 `unused_variables` 린트를 warn 레벨로\n"
"    // 내보낼 것입니다. 이는 함수 위에 있는 기대를 충족시키지 못합니다.\n"

#: src/attributes/diagnostics.md:197
msgid "\"Crab Rave\""
msgstr "\"Crab Rave\""

#: src/attributes/diagnostics.md:199
msgid ""
"// The `allow` attribute suppresses the lint emission. This will not\n"
"    // fulfill the expectation as it has been suppressed by the `allow`\n"
"    // attribute and not the `expect` attribute above the function.\n"
msgstr ""
"// `allow` 속성은 린트 발생을 억제합니다. 이는 `expect` 속성이 아닌\n"
"    // `allow` 속성에 의해 억제되었으므로 함수 위의 기대를\n"
"    // 충족시키지 못합니다.\n"

#: src/attributes/diagnostics.md:203
msgid "\"Noisestorm\""
msgstr "\"Noisestorm\""

#: src/attributes/diagnostics.md:205
msgid ""
"// This `expect` attribute will suppress the `unused_variables` lint "
"emission\n"
"    // at the variable. The `expect` attribute above the function will still "
"not\n"
"    // be fulfilled, since this lint emission has been suppressed by the "
"local\n"
"    // expect attribute.\n"
msgstr ""
"// 이 `expect` 속성은 변수 위치에서 `unused_variables` 린트 발생을\n"
"    // 억제할 것입니다. 이 린트 발생은 지역적인 expect 속성에 의해\n"
"    // 억제되었으므로 함수 위의 `expect` 속성은 여전히 충족되지 않습니다.\n"

#: src/attributes/diagnostics.md:210
msgid "\"Monstercat Release\""
msgstr "\"Monstercat Release\""

#: src/attributes/diagnostics.md:216
msgid ""
"If the `expect` attribute contains several lints, each one is expected "
"separately. For a lint group it's enough if one lint inside the group has "
"been emitted:"
msgstr "`expect` 속성이 여러 린트를 포함하는 경우, 각각은 개별적으로 기대됩니다. 린트 그룹의 경우 그룹 내의 한 린트라도 발생했다면 충분합니다."

#: src/attributes/diagnostics.md:220
msgid ""
"// This expectation will be fulfilled by the unused value inside the "
"function\n"
"// since the emitted `unused_variables` lint is inside the `unused` lint "
"group.\n"
msgstr ""
"// 이 기대는 함수 내부의 사용되지 않은 값에 의해 충족될 것입니다.\n"
"// 발생한 `unused_variables` 린트가 `unused` 린트 그룹에 속하기 때문입니다.\n"

#: src/attributes/diagnostics.md:224
msgid "\"I'm running out of examples\""
msgstr "\"예시가 떨어져 가고 있어요\""

#: src/attributes/diagnostics.md:228
msgid ""
"// This attribute creates two lint expectations. The `unused_mut` lint will "
"be\n"
"    // suppressed and with that fulfill the first expectation. The "
"`unused_variables`\n"
"    // wouldn't be emitted, since the variable is used. That expectation "
"will therefore\n"
"    // be unsatisfied, and a warning will be emitted.\n"
msgstr ""
"// 이 속성은 두 개의 린트 기대를 생성합니다. `unused_mut` 린트는\n"
"    // 억제되며 첫 번째 기대를 충족시킬 것입니다. `unused_variables` 린트는\n"
"    // 변수가 사용되므로 발생하지 않을 것입니다. 따라서 그 기대는 충족되지\n"
"    // 않은 상태로 남게 되며, 경고가 발생할 것입니다.\n"

#: src/attributes/diagnostics.md:233
msgid "\"https://www.rust-lang.org/\""
msgstr "\"https://www.rust-lang.org/\""

#: src/attributes/diagnostics.md:235
msgid "\"Welcome to our community: {link}\""
msgstr "\"우리 커뮤니티에 오신 것을 환영합니다: {link}\""

#: src/attributes/diagnostics.md:239
msgid ""
"Note: The behavior of `#[expect(unfulfilled_lint_expectations)]` is "
"currently defined to always generate the `unfulfilled_lint_expectations` "
"lint."
msgstr "참고: `#[expect(unfulfilled_lint_expectations)]`의 동작은 현재 항상 `unfulfilled_lint_expectations` 린트를 생성하도록 정의되어 있습니다."

#: src/attributes/diagnostics.md:244
msgid "Lint groups"
msgstr "린트 그룹"

#: src/attributes/diagnostics.md:246
msgid ""
"Lints may be organized into named groups so that the level of related lints "
"can be adjusted together. Using a named group is equivalent to listing out "
"the lints within that group."
msgstr "린트들은 관련된 린트들의 레벨을 함께 조정할 수 있도록 명명된 그룹으로 조직될 수 있습니다. 명명된 그룹을 사용하는 것은 해당 그룹 내의 린트들을 나열하는 것과 동일합니다."

#: src/attributes/diagnostics.md:251
msgid "// This allows all lints in the \"unused\" group.\n"
msgstr "// 이는 \"unused\" 그룹의 모든 린트를 허용합니다.\n"

#: src/attributes/diagnostics.md:252
msgid ""
"// This overrides the \"unused_must_use\" lint from the \"unused\"\n"
"// group to deny.\n"
msgstr ""
"// 이는 \"unused\" 그룹의 \"unused_must_use\" 린트를\n"
"// deny 레벨로 오버라이드합니다.\n"

#: src/attributes/diagnostics.md:257
msgid ""
"// This does not generate a warning because the \"unused_variables\"\n"
"    // lint is in the \"unused\" group.\n"
msgstr ""
"// \"unused_variables\" 린트가 \"unused\" 그룹에 속해 있으므로\n"
"    // 경고를 생성하지 않습니다.\n"

#: src/attributes/diagnostics.md:260
msgid ""
"// This generates an error because the result is unused and\n"
"    // \"unused_must_use\" is marked as \"deny\".\n"
msgstr ""
"// 결과가 사용되지 않았고 \"unused_must_use\"가 \"deny\"로 설정되었으므로\n"
"    // 에러를 생성합니다.\n"

#: src/attributes/diagnostics.md:262
msgid "\"some_file\""
msgstr "\"some_file\""

#: src/attributes/diagnostics.md:262
msgid "// ERROR: unused `Result` that must be used\n"
msgstr "// 에러: 반드시 사용되어야 할 `Result`가 사용되지 않음\n"

#: src/attributes/diagnostics.md:268
msgid ""
"There is a special group named \"warnings\" which includes all lints at the "
"\"warn\" level. The \"warnings\" group ignores attribute order and applies "
"to all lints that would otherwise warn within the entity."
msgstr "\"warnings\"라는 이름의 특별한 그룹이 있는데, 이는 \"warn\" 레벨의 모든 린트를 포함합니다. \"warnings\" 그룹은 속성 순서를 무시하며, 해당 엔티티 내에서 경고를 발생시킬 모든 린트에 적용됩니다."

#: src/attributes/diagnostics.md:273
msgid "// The order of these two attributes does not matter.\n"
msgstr "// 이 두 속성의 순서는 중요하지 않습니다.\n"

#: src/attributes/diagnostics.md:275
msgid "// The unsafe_code lint is normally \"allow\" by default.\n"
msgstr "// unsafe_code 린트는 보통 기본적으로 \"allow\"입니다.\n"

#: src/attributes/diagnostics.md:279
msgid ""
"// This is an error because the `unsafe_code` warning has\n"
"    // been lifted to \"deny\".\n"
msgstr ""
"// `unsafe_code` 경고가 \"deny\"로 격상되었으므로 이것은 에러입니다.\n"

#: src/attributes/diagnostics.md:281
msgid "// ERROR: usage of `unsafe` block\n"
msgstr "// 에러: `unsafe` 블록 사용\n"

#: src/attributes/diagnostics.md:287
msgid "Tool lint attributes"
msgstr "도구 린트 속성"

#: src/attributes/diagnostics.md:291
msgid ""
"Tool lints allows using scoped lints, to `allow`, `warn`, `deny` or `forbid` "
"lints of certain tools."
msgstr "도구 린트를 사용하면 범위가 지정된(scoped) 린트를 사용하여 특정 도구의 린트를 `allow`, `warn`, `deny`, `forbid` 할 수 있습니다."

#: src/attributes/diagnostics.md:296
msgid ""
"Tool lints only get checked when the associated tool is active. If a lint "
"attribute, such as `allow`, references a nonexistent tool lint, the compiler "
"will not warn about the nonexistent lint until you use the tool."
msgstr "도구 린트는 관련 도구가 활성화된 경우에만 체크됩니다. 만약 `allow`와 같은 린트 속성이 존재하지 않는 도구 린트를 참조하더라도, 컴파일러는 해당 도구를 사용하기 전까지는 존재하지 않는 린트에 대해 경고하지 않습니다."

#: src/attributes/diagnostics.md:300
msgid "Otherwise, they work just like regular lint attributes:"
msgstr "그 외에는 일반 린트 속성과 동일하게 작동합니다."

#: src/attributes/diagnostics.md:303
msgid "// set the entire `pedantic` clippy lint group to warn\n"
msgstr "// clippy의 `pedantic` 린트 그룹 전체를 warn으로 설정합니다.\n"

#: src/attributes/diagnostics.md:304
msgid "// silence warnings from the `filter_map` clippy lint\n"
msgstr "// clippy의 `filter_map` 린트 경고를 억제합니다.\n"

#: src/attributes/diagnostics.md:311
msgid "// silence the `cmp_nan` clippy lint just for this function\n"
msgstr "// 이 함수에서만 clippy의 `cmp_nan` 린트를 억제합니다.\n"

#: src/attributes/diagnostics.md:319
msgid ""
"Note: `rustc` currently recognizes the tool lints for \"[clippy](https://"
"github.com/rust-lang/rust-clippy)\" and \"[rustdoc](../../rustdoc/lints.html)"
"\"."
msgstr "참고: `rustc`는 현재 \"[clippy](https://github.com/rust-lang/rust-clippy)\"와 \"[rustdoc](../../rustdoc/lints.html)\" 도구 린트를 인식합니다."

#: src/attributes/diagnostics.md:323
msgid "The `deprecated` attribute"
msgstr "`deprecated` 속성"

#: src/attributes/diagnostics.md:327
msgid ""
"The _`deprecated` attribute_ marks an item as deprecated. `rustc` will issue "
"warnings on usage of `#[deprecated]` items. `rustdoc` will show item "
"deprecation, including the `since` version and `note`, if available."
msgstr "_`deprecated` 속성_은 아이템을 사용 중단된 것(deprecated)으로 표시합니다. `rustc`는 `#[deprecated]` 아이템 사용 시 경고를 발생시킵니다. `rustdoc`은 사용 가능한 경우 `since` 버전과 `note`를 포함하여 아이템의 사용 중단 여부를 표시합니다."

#: src/attributes/diagnostics.md:333
msgid "The `deprecated` attribute has several forms:"
msgstr "`deprecated` 속성은 여러 형식을 가집니다:"

#: src/attributes/diagnostics.md:335
msgid "`deprecated` --- Issues a generic message."
msgstr "`deprecated` --- 일반적인 메시지를 발생시킵니다."

#: src/attributes/diagnostics.md:336
msgid ""
"`deprecated = \"message\"` --- Includes the given string in the deprecation "
"message."
msgstr "`deprecated = \"message\"` --- 사용 중단 메시지에 주어진 문자열을 포함합니다."

#: src/attributes/diagnostics.md:338
msgid ""
"[_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) syntax "
"with two optional fields:"
msgstr "두 개의 선택적 필드가 있는 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문:"

#: src/attributes/diagnostics.md:339
msgid ""
"`since` --- Specifies a version number when the item was deprecated. `rustc` "
"does not currently interpret the string, but external tools like [Clippy]"
"(https://github.com/rust-lang/rust-clippy) may check the validity of the "
"value."
msgstr "`since` --- 아이템이 사용 중단된 버전 번호를 지정합니다. `rustc`는 현재 이 문자열을 해석하지 않지만, [Clippy](https://github.com/rust-lang/rust-clippy)와 같은 외부 도구가 이 값의 유효성을 검사할 수 있습니다."

#: src/attributes/diagnostics.md:342
msgid ""
"`note` --- Specifies a string that should be included in the deprecation "
"message. This is typically used to provide an explanation about the "
"deprecation and preferred alternatives."
msgstr "`note` --- 사용 중단 메시지에 포함되어야 할 문자열을 지정합니다. 이는 일반적으로 사용 중단에 대한 설명과 권장되는 대안을 제공하는 데 사용됩니다."

#: src/attributes/diagnostics.md:348
msgid ""
"The `deprecated` attribute may be applied to any [item](../items.md), [trait "
"item](../items/traits.md), [enum variant](../items/enumerations.md), [struct "
"field](../items/structs.md), [external block item](../items/external-"
"blocks.md), or [macro definition](../macros-by-example.md). It cannot be "
"applied to [trait implementation items](../items/implementations.md#trait-"
"implementations). When applied to an item containing other items, such as a "
"[module](../items/modules.md) or [implementation](../items/"
"implementations.md), all child items inherit the deprecation attribute."
msgstr "`deprecated` 속성은 모든 [아이템](../items.md), [트레잇 아이템](../items/traits.md), [열거형 변형](../items/enumerations.md), [구조체 필드](../items/structs.md), [외부 블록 아이템](../items/external-blocks.md) 또는 [매크로 정의](../macros-by-example.md)에 적용될 수 있습니다. [트레잇 구현 아이템](../items/implementations.md#trait-implementations)에는 적용할 수 없습니다. [모듈](../items/modules.md)이나 [구현](../items/implementations.md)과 같이 다른 아이템을 포함하는 아이템에 적용되면 모든 자식 아이템이 사용 중단 속성을 상속받습니다."

#: src/attributes/diagnostics.md:361
msgid "\"5.2.0\""
msgstr "\"5.2.0\""

#: src/attributes/diagnostics.md:361
msgid "\"foo was rarely used. Users should instead use bar\""
msgstr "\"foo는 거의 사용되지 않았습니다. 사용자들은 대신 bar를 사용해야 합니다\""

#: src/attributes/diagnostics.md:367
msgid ""
"The [RFC](https://github.com/rust-lang/rfcs/blob/master/text/1270-"
"deprecation.md) contains motivations and more details."
msgstr "[RFC](https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md)에 동기와 자세한 내용이 포함되어 있습니다."

#: src/attributes/diagnostics.md:373
msgid "The `must_use` attribute"
msgstr "`must_use` 속성"

#: src/attributes/diagnostics.md:377
msgid ""
"The _`must_use` attribute_ is used to issue a diagnostic warning when a "
"value is not \"used\"."
msgstr "_`must_use` 속성_은 값이 \"사용\"되지 않았을 때 진단 경고를 발생시키는 데 사용됩니다."

#: src/attributes/diagnostics.md:382
msgid ""
"The `must_use` attribute can be applied to user-defined composite types "
"([`struct`s](../items/structs.md), [`enum`s](../items/enumerations.md), and "
"[`union`s](../items/unions.md)), [functions](../items/functions.md), and "
"[traits](../items/traits.md)."
msgstr "`must_use` 속성은 사용자 정의 복합 타입([구조체](../items/structs.md), [열거형](../items/enumerations.md), [공용체](../items/unions.md)), [함수](../items/functions.md), 그리고 [트레잇](../items/traits.md)에 적용될 수 있습니다."

#: src/attributes/diagnostics.md:388
msgid ""
"The `must_use` attribute may include a message by using the "
"[_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) syntax "
"such as `#[must_use = \"example message\"]`. The message will be given "
"alongside the warning."
msgstr "`must_use` 속성은 `#[must_use = \"예시 메시지\"]`와 같이 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하여 메시지를 포함할 수 있습니다. 메시지는 경고와 함께 표시됩니다."

#: src/attributes/diagnostics.md:394
msgid ""
"When used on user-defined composite types, if the [expression](../"
"expressions.md) of an [expression statement](../statements.md#expression-"
"statements) has that type, then the `unused_must_use` lint is violated."
msgstr "사용자 정의 복합 타입에 사용된 경우, [표현식 구문](../statements.md#expression-statements)의 [표현식](../expressions.md)이 해당 타입을 가지면 `unused_must_use` 린트를 위반하게 됩니다."

#: src/attributes/diagnostics.md:401
msgid "// some fields\n"
msgstr "// 몇몇 필드들\n"

#: src/attributes/diagnostics.md:407 src/attributes/diagnostics.md:440
#: src/attributes/diagnostics.md:459
msgid "// Violates the `unused_must_use` lint.\n"
msgstr "// `unused_must_use` 린트를 위반합니다.\n"

#: src/attributes/diagnostics.md:414
msgid ""
"When used on a function, if the [expression](../expressions.md) of an "
"[expression statement](../statements.md#expression-statements) is a [call "
"expression](../expressions/call-expr.md) to that function, then the "
"`unused_must_use` lint is violated."
msgstr "함수에 사용된 경우, [표현식 구문](../statements.md#expression-statements)의 [표현식](../expressions.md)이 해당 함수에 대한 [호출 표현식](../expressions/call-expr.md)이면 `unused_must_use` 린트를 위반하게 됩니다."

#: src/attributes/diagnostics.md:421
msgid "// Violates the unused_must_use lint.\n"
msgstr "// `unused_must_use` 린트를 위반합니다.\n"

#: src/attributes/diagnostics.md:428
msgid ""
"When used on a [trait declaration](../items/traits.md), a [call expression]"
"(../expressions/call-expr.md) of an [expression statement](../"
"statements.md#expression-statements) to a function that returns an [impl "
"trait](../types/impl-trait.md) or a [dyn trait](../types/trait-object.md) of "
"that trait violates the `unused_must_use` lint."
msgstr "[트레잇 선언](../items/traits.md)에 사용된 경우, 해당 트레잇의 [impl 트레잇](../types/impl-trait.md) 또는 [dyn 트레잇](../types/trait-object.md)을 반환하는 함수에 대한 [표현식 구문](../statements.md#expression-statements)의 [호출 표현식](../expressions/call-expr.md)은 `unused_must_use` 린트를 위반합니다."

#: src/attributes/diagnostics.md:447
msgid ""
"When used on a function in a trait declaration, then the behavior also "
"applies when the call expression is a function from an implementation of the "
"trait."
msgstr "트레잇 선언 내의 함수에 사용된 경우, 호출 표현식이 해당 트레잇 구현체의 함수인 경우에도 동일하게 적용됩니다."

#: src/attributes/diagnostics.md:466
msgid ""
"When used on a function in a trait implementation, the attribute does "
"nothing."
msgstr "트레잇 구현 내의 함수에 사용된 경우, 이 속성은 아무런 동작도 하지 않습니다."

#: src/attributes/diagnostics.md:468
msgid ""
"Note: Trivial no-op expressions containing the value will not violate the "
"lint. Examples include wrapping the value in a type that does not implement "
"[`Drop`](../special-types-and-traits.md#drop) and then not using that type "
"and being the final expression of a [block expression](../expressions/block-"
"expr.md) that is not used."
msgstr "참고: 값을 포함하는 사소한 무부하(no-op) 표현식은 린트를 위반하지 않습니다. 예시로는 [`Drop`](../special-types-and-traits.md#drop)을 구현하지 않는 타입으로 값을 감싼 후 해당 타입을 사용하지 않거나, 사용되지 않는 [블록 표현식](../expressions/block-expr.md)의 마지막 표현식이 되는 경우가 있습니다."

#: src/attributes/diagnostics.md:477
msgid "// None of these violate the unused_must_use lint.\n"
msgstr "// 이들 중 어느 것도 `unused_must_use` 린트를 위반하지 않습니다.\n"

#: src/attributes/diagnostics.md:487
msgid ""
"Note: It is idiomatic to use a [let statement](../statements.md#let-"
"statements) with a pattern of `_` when a must-used value is purposely "
"discarded."
msgstr "참고: `must_use` 값이 의도적으로 버려질 때는 패턴이 `_`인 [let 문](../statements.md#let-statements)을 사용하는 것이 관용적입니다."

#: src/attributes/diagnostics.md:494
msgid "// Does not violate the unused_must_use lint.\n"
msgstr "// `unused_must_use` 린트를 위반하지 않습니다.\n"

#: src/attributes/diagnostics.md:500
msgid "The `diagnostic` tool attribute namespace"
msgstr "`diagnostic` 도구 속성 네임스페이스"

#: src/attributes/diagnostics.md:504
msgid ""
"The `#[diagnostic]` attribute namespace is a home for attributes to "
"influence compile-time error messages. The hints provided by these "
"attributes are not guaranteed to be used."
msgstr "`#[diagnostic]` 속성 네임스페이스는 컴파일 타임 에러 메시지에 영향을 주는 속성들을 위한 공간입니다. 이러한 속성들이 제공하는 힌트가 반드시 사용된다는 보장은 없습니다."

#: src/attributes/diagnostics.md:509
msgid ""
"Unknown attributes in this namespace are accepted, though they may emit "
"warnings for unused attributes. Additionally, invalid inputs to known "
"attributes will typically be a warning (see the attribute definitions for "
"details). This is meant to allow adding or discarding attributes and "
"changing inputs in the future to allow changes without the need to keep the "
"non-meaningful attributes or options working."
msgstr "이 네임스페이스 내의 알 수 없는 속성들은 수용되지만, 사용되지 않는 속성에 대해 경고를 내보낼 수 있습니다. 추가적으로, 알려진 속성에 대한 유효하지 않은 입력은 보통 경고가 됩니다 (자세한 내용은 속성 정의를 참조하세요). 이는 의미 없는 속성이나 옵션들을 계속 유지할 필요 없이 미래에 속성을 추가하거나 제거하고 입력을 변경할 수 있도록 하기 위함입니다."

#: src/attributes/diagnostics.md:515
msgid "The `diagnostic::on_unimplemented` attribute"
msgstr "`diagnostic::on_unimplemented` 속성"

#: src/attributes/diagnostics.md:519
msgid ""
"The `#[diagnostic::on_unimplemented]` attribute is a hint to the compiler to "
"supplement the error message that would normally be generated in scenarios "
"where a trait is required but not implemented on a type."
msgstr "`#[diagnostic::on_unimplemented]` 속성은 트레잇이 요구되지만 특정 타입에 구현되지 않은 상황에서 보통 생성되는 에러 메시지를 보완하도록 컴파일러에 주는 힌트입니다."

#: src/attributes/diagnostics.md:523
msgid ""
"The attribute should be placed on a [trait declaration](../items/traits.md), "
"though it is not an error to be located in other positions."
msgstr "이 속성은 [트레잇 선언](../items/traits.md)에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다."

#: src/attributes/diagnostics.md:527
msgid ""
"The attribute uses the [_MetaListNameValueStr_](../attributes.md#meta-item-"
"attribute-syntax) syntax to specify its inputs, though any malformed input "
"to the attribute is not considered as an error to provide both forwards and "
"backwards compatibility."
msgstr "이 속성은 입력을 지정하기 위해 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하지만, 전방 및 후방 호환성을 제공하기 위해 속성에 대한 잘못된 형식의 입력은 에러로 간주되지 않습니다."

#: src/attributes/diagnostics.md:531
msgid "The following keys have the given meaning:"
msgstr "다음 키들은 주어진 의미를 갖습니다:"

#: src/attributes/diagnostics.md:532
msgid "`message` --- The text for the top level error message."
msgstr "`message` --- 최상위 레벨 에러 메시지를 위한 텍스트입니다."

#: src/attributes/diagnostics.md:533
msgid ""
"`label` --- The text for the label shown inline in the broken code in the "
"error message."
msgstr "`label` --- 에러 메시지에서 잘못된 코드 내에 표시될 라벨을 위한 텍스트입니다."

#: src/attributes/diagnostics.md:534
msgid "`note` --- Provides additional notes."
msgstr "`note` --- 추가적인 노트를 제공합니다."

#: src/attributes/diagnostics.md:538
msgid ""
"The `note` option can appear several times, which results in several note "
"messages being emitted."
msgstr "`note` 옵션은 여러 번 나타날 수 있으며, 그 결과 여러 개의 노트 메시지가 내보내집니다."

#: src/attributes/diagnostics.md:542
msgid ""
"If any of the other options appears several times the first occurrence of "
"the relevant option specifies the actually used value. Subsequent "
"occurrences generates a warning."
msgstr "다른 옵션들이 여러 번 나타나는 경우, 해당 옵션의 첫 번째 출현이 실제로 사용되는 값을 지정합니다. 이후의 출현은 경고를 발생시킵니다."

#: src/attributes/diagnostics.md:546
msgid "A warning is generated for any unknown keys."
msgstr "알 수 없는 키에 대해서는 경고가 발생합니다."

#: src/attributes/diagnostics.md:550
msgid ""
"All three options accept a string as an argument, interpreted using the same "
"formatting as a [`std::fmt`](../../alloc/fmt/index.html) string."
msgstr "세 가지 옵션 모두 문자열을 인수로 받으며, [`std::fmt`](../../alloc/fmt/index.html) 문자열과 동일한 포맷팅 방식을 사용하여 해석됩니다."

#: src/attributes/diagnostics.md:554
msgid ""
"Format parameters with the given named parameter will be replaced with the "
"following text:"
msgstr "주어진 이름을 가진 포맷 매개변수들은 다음 텍스트로 대체됩니다:"

#: src/attributes/diagnostics.md:555
msgid "`{Self}` --- The name of the type implementing the trait."
msgstr "`{Self}` --- 트레잇을 구현하는 타입의 이름입니다."

#: src/attributes/diagnostics.md:556
msgid ""
"`{` _GenericParameterName_ `}` --- The name of the generic argument's type "
"for the given generic parameter."
msgstr "`{` _제네릭매개변수이름_ `}` --- 주어진 제네릭 매개변수에 대한 제네릭 인수의 타입 이름입니다."

#: src/attributes/diagnostics.md:560
msgid ""
"Any other format parameter will generate a warning, but will otherwise be "
"included in the string as-is."
msgstr "그 외의 포맷 매개변수는 경고를 발생시키지만, 문자열에는 그대로 포함됩니다."

#: src/attributes/diagnostics.md:564
msgid ""
"Invalid format strings may generate a warning, but are otherwise allowed, "
"but may not display as intended. Format specifiers may generate a warning, "
"but are otherwise ignored."
msgstr "유효하지 않은 포맷 문자열은 경고를 발생시킬 수 있지만, 허용은 됩니다. 다만 의도한 대로 표시되지 않을 수 있습니다. 포맷 지정자(Format specifiers)는 경고를 발생시킬 수 있지만, 무시됩니다."

#: src/attributes/diagnostics.md:571
msgid "\"My Message for `ImportantTrait<{A}>` implemented for `{Self}`\""
msgstr "\"`{Self}`에 구현된 `ImportantTrait<{A}>`에 대한 메시지\""

#: src/attributes/diagnostics.md:572
msgid "\"My Label\""
msgstr "\"나의 라벨\""

#: src/attributes/diagnostics.md:573
msgid "\"Note 1\""
msgstr "\"노트 1\""

#: src/attributes/diagnostics.md:574
msgid "\"Note 2\""
msgstr "\"노트 2\""

#: src/attributes/diagnostics.md:585
msgid "the compiler may generate an error message which looks like this:"
msgstr "컴파일러는 다음과 같은 에러 메시지를 생성할 수 있습니다:"

#: src/attributes/diagnostics.md:601
msgid "The `diagnostic::do_not_recommend` attribute"
msgstr "`diagnostic::do_not_recommend` 속성"

#: src/attributes/diagnostics.md:608
msgid ""
"The `#[diagnostic::do_not_recommend]` attribute is a hint to the compiler to "
"not show the annotated trait implementation as part of a diagnostic message."
msgstr "`#[diagnostic::do_not_recommend]` 속성은 진단 메시지의 일부로 해당 트레잇 구현을 표시하지 않도록 컴파일러에 주는 힌트입니다."

#: src/attributes/diagnostics.md:610
msgid ""
"**Note**: Suppressing the recommendation can be useful if you know that the "
"recommendation would normally not be useful to the programmer. This often "
"occurs with broad, blanket impls. The recommendation may send the programmer "
"down the wrong path, or the trait implementation may be an internal detail "
"that you don't want to expose, or the bounds may not be able to be satisfied "
"by the programmer."
msgstr "**참고**: 권장 사항을 억제하는 것은 해당 권장 사항이 프로그래머에게 보통 유용하지 않을 것임을 알고 있는 경우에 유용할 수 있습니다. 이는 광범위한 blanket 구현에서 종종 발생합니다. 권장 사항이 프로그래머를 잘못된 길로 안내할 수 있거나, 트레잇 구현이 노출하고 싶지 않은 내부 상세 정보일 수 있거나, 프로그래머가 바운드를 충족시킬 수 없는 경우 등이 해당됩니다."

#: src/attributes/diagnostics.md:612
msgid ""
"For example, in an error message about a type not implementing a required "
"trait, the compiler may find a trait implementation that would satisfy the "
"requirements if it weren't for specific bounds in the trait implementation. "
"The compiler may tell the user that there is an impl, but the problem is the "
"bounds in the trait implementation. The `#[diagnostic::do_not_recommend]` "
"attribute can be used to tell the compiler to _not_ tell the user about the "
"trait implementation, and instead simply tell the user the type doesn't "
"implement the required trait."
msgstr "예를 들어, 요구되는 트레잇을 구현하지 않은 타입에 대한 에러 메시지에서, 컴파일러는 트레잇 구현 내의 특정 바운드만 아니었다면 요구 사항을 충족했을 트레잇 구현을 찾을 수도 있습니다. 컴파일러는 사용자에게 구현이 존재하지만 트레잇 구현 내의 바운드가 문제라고 말할 수 있습니다. `#[diagnostic::do_not_recommend]` 속성은 컴파일러에게 해당 트레잇 구현에 대해 사용자에게 알리지 _말고_, 대신 단순히 해당 타입이 요구되는 트레잇을 구현하지 않는다고 알리도록 하는 데 사용될 수 있습니다."

#: src/attributes/diagnostics.md:616
msgid ""
"The attribute should be placed on a [trait implementation item](../items/"
"implementations.md#trait-implementations), though it is not an error to be "
"located in other positions."
msgstr "이 속성은 [트레잇 구현 아이템](../items/implementations.md#trait-implementations)에 위치해야 하지만, 다른 위치에 있어도 에러는 아닙니다."

#: src/attributes/diagnostics.md:620
msgid ""
"The attribute does not accept any arguments, though unexpected arguments are "
"not considered as an error."
msgstr "이 속성은 어떤 인수도 받지 않지만, 예상치 못한 인수가 있어도 에러로 간주되지 않습니다."

#: src/attributes/diagnostics.md:622
msgid ""
"In the following example, there is a trait called `AsExpression` which is "
"used for casting arbitrary types to the `Expression` type used in an SQL "
"library. There is a method called `check` which takes an `AsExpression`."
msgstr "다음 예시에는 SQL 라이브러리에서 사용되는 `Expression` 타입으로 임의의 타입을 캐스팅하는 데 사용되는 `AsExpression`이라는 트레잇이 있습니다. 여기에는 `AsExpression`을 인수로 받는 `check`라는 메서드가 있습니다."

#: src/attributes/diagnostics.md:656
msgid ""
"// Uncomment this line to change the recommendation.\n"
"// #[diagnostic::do_not_recommend]\n"
msgstr ""
"// 권장 사항을 변경하려면 이 라인의 주석을 해제하세요.\n"
"// #[diagnostic::do_not_recommend]\n"

#: src/attributes/diagnostics.md:676 src/types/closure.md:296
#: src/types/closure.md:313 src/types/closure.md:647 src/types/closure.md:732
msgid "\"bar\""
msgstr "\"bar\""

#: src/attributes/diagnostics.md:680
msgid ""
"The `SelectInt` type's `check` method is expecting an `Integer` type. "
"Calling it with an i32 type works, as it gets converted to an `Integer` by "
"the `AsExpression` trait. However, calling it with a string does not, and "
"generates a an error that may look like this:"
msgstr "`SelectInt` 타입의 `check` 메서드는 `Integer` 타입을 기대합니다. `AsExpression` 트레잇에 의해 `i32` 타입이 `Integer`로 변환되므로 `i32` 타입으로 호출하는 것은 작동합니다. 하지만 문자열로 호출하는 것은 작동하지 않으며, 다음과 같은 에러를 발생시킬 수 있습니다."

#: src/attributes/diagnostics.md:682
msgid ""
"```text\n"
"error[E0277]: the trait bound `&str: Expression` is not satisfied\n"
"  --> src/main.rs:53:15\n"
"   |\n"
"53 |     SelectInt.check(\"bar\");\n"
"   |               ^^^^^ the trait `Expression` is not implemented for "
"`&str`\n"
"   |\n"
"   = help: the following other types implement trait `Expression`:\n"
"             Bound<T>\n"
"             SelectInt\n"
"note: required for `&str` to implement `AsExpression<Integer>`\n"
"  --> src/main.rs:45:13\n"
"   |\n"
"45 | impl<T, ST> AsExpression<ST> for T\n"
"   |             ^^^^^^^^^^^^^^^^     ^\n"
"46 | where\n"
"47 |     T: Expression<SqlType = ST>,\n"
"   |        ------------------------ unsatisfied trait bound introduced "
"here\n"
"```"
msgstr ""
"```text\n"
"error[E0277]: the trait bound `&str: Expression` is not satisfied\n"
"  --> src/main.rs:53:15\n"
"   |\n"
"53 |     SelectInt.check(\"bar\");\n"
"   |               ^^^^^ the trait `Expression` is not implemented for "
"`&str`\n"
"   |\n"
"   = help: the following other types implement trait `Expression`:\n"
"             Bound<T>\n"
"             SelectInt\n"
"note: required for `&str` to implement `AsExpression<Integer>`\n"
"  --> src/main.rs:45:13\n"
"   |\n"
"45 | impl<T, ST> AsExpression<ST> for T\n"
"   |             ^^^^^^^^^^^^^^^^     ^\n"
"46 | where\n"
"47 |     T: Expression<SqlType = ST>,\n"
"   |        ------------------------ unsatisfied trait bound introduced "
"here\n"
"```"

#: src/attributes/diagnostics.md:702
msgid ""
"By adding the `#[diagnostic::do_no_recommend]` attribute to the blanket "
"`impl` for `AsExpression`, the message changes to:"
msgstr "`AsExpression`에 대한 blanket `impl`에 `#[diagnostic::do_no_recommend]` 속성을 추가하면 메시지가 다음과 같이 변경됩니다."

#: src/attributes/diagnostics.md:704
msgid ""
"```text\n"
"error[E0277]: the trait bound `&str: AsExpression<Integer>` is not "
"satisfied\n"
"  --> src/main.rs:53:15\n"
"   |\n"
"53 |     SelectInt.check(\"bar\");\n"
"   |               ^^^^^ the trait `AsExpression<Integer>` is not "
"implemented for `&str`\n"
"   |\n"
"   = help: the trait `AsExpression<Integer>` is not implemented for `&str`\n"
"           but trait `AsExpression<Text>` is implemented for it\n"
"   = help: for that trait implementation, expected `Text`, found `Integer`\n"
"```"
msgstr ""
"```text\n"
"error[E0277]: the trait bound `&str: AsExpression<Integer>` is not "
"satisfied\n"
"  --> src/main.rs:53:15\n"
"   |\n"
"53 |     SelectInt.check(\"bar\");\n"
"   |               ^^^^^ the trait `AsExpression<Integer>` is not "
"implemented for `&str`\n"
"   |\n"
"   = help: the trait `AsExpression<Integer>` is not implemented for `&str`\n"
"           but trait `AsExpression<Text>` is implemented for it\n"
"   = help: for that trait implementation, expected `Text`, found `Integer`\n"
"```"

#: src/attributes/diagnostics.md:716
msgid ""
"The first error message includes a somewhat confusing error message about "
"the relationship of `&str` and `Expression`, as well as the unsatisfied "
"trait bound in the blanket impl. After adding "
"`#[diagnostic::do_no_recommend]`, it no longer considers the blanket impl "
"for the recommendation. The message should be a little clearer, with an "
"indication that a string cannot be converted to an `Integer`."
msgstr "첫 번째 에러 메시지는 `&str`과 `Expression` 사이의 관계에 대한 다소 혼란스러운 에러 메시지와, blanket 구현에서의 충족되지 않은 트레잇 바운드를 포함합니다. `#[diagnostic::do_no_recommend]`를 추가한 후에는 권장 사항을 위해 blanket 구현을 더 이상 고려하지 않습니다. 메시지는 문자열을 `Integer`로 변환할 수 없음을 나타내며 조금 더 명확해질 것입니다."

#: src/attributes/codegen.md:3
msgid "Code generation attributes"
msgstr "코드 생성 속성"

#: src/attributes/codegen.md:6
msgid ""
"The following [attributes](../attributes.md) are used for controlling code "
"generation."
msgstr "다음 [속성들](../attributes.md)은 코드 생성을 제어하는 데 사용됩니다."

#: src/attributes/codegen.md:10
msgid "Optimization hints"
msgstr "최적화 힌트"

#: src/attributes/codegen.md:14
msgid ""
"The `cold` and `inline` [attributes](../attributes.md) give suggestions to "
"generate code in a way that may be faster than what it would do without the "
"hint. The attributes are only hints, and may be ignored."
msgstr "`cold`와 `inline` [속성들](../attributes.md)은 힌트가 없을 때보다 더 빠를 수 있는 방식으로 코드를 생성하도록 제안을 줍니다. 이러한 속성들은 단지 힌트일 뿐이며 무시될 수 있습니다."

#: src/attributes/codegen.md:20
msgid ""
"Both attributes can be used on [functions](../items/functions.md). When "
"applied to a function in a [trait](../items/traits.md), they apply only to "
"that function when used as a default function for a trait implementation and "
"not to all trait implementations. The attributes have no effect on a trait "
"function without a body."
msgstr "두 속성 모두 [함수](../items/functions.md)에 사용될 수 있습니다. [트레잇](../items/traits.md) 내의 함수에 적용될 때, 이들은 트레잇 구현의 기본 함수로 사용될 때만 해당 함수에 적용되며 모든 트레잇 구현에 적용되지는 않습니다. 본문이 없는 트레잇 함수에는 이 속성들이 아무런 영향을 주지 않습니다."

#: src/attributes/codegen.md:27
msgid "The `inline` attribute"
msgstr "`inline` 속성"

#: src/attributes/codegen.md:31
msgid ""
"The _`inline` [attribute](../attributes.md)_ suggests that a copy of the "
"attributed function should be placed in the caller, rather than generating "
"code to call the function where it is defined."
msgstr "_`inline` [속성](../attributes.md)_은 해당 함수가 정의된 곳에서 함수를 호출하는 코드를 생성하는 대신, 호출자 내부에 해당 함수의 복사본을 배치하도록 제안합니다."

#: src/attributes/codegen.md:35
msgid ""
"_**Note**_: The `rustc` compiler automatically inlines functions based on "
"internal heuristics. Incorrectly inlining functions can make the program "
"slower, so this attribute should be used with care."
msgstr "_**참고**_: `rustc` 컴파일러는 내부 휴리스틱에 기반하여 함수를 자동으로 인라인화합니다. 잘못된 인라인화는 프로그램을 더 느리게 만들 수 있으므로, 이 속성은 주의해서 사용해야 합니다."

#: src/attributes/codegen.md:41
msgid "There are three ways to use the inline attribute:"
msgstr "inline 속성을 사용하는 세 가지 방법이 있습니다:"

#: src/attributes/codegen.md:43
msgid "`#[inline]` _suggests_ performing an inline expansion."
msgstr "`#[inline]`은 인라인 확장을 수행할 것을 _제안_합니다."

#: src/attributes/codegen.md:44
msgid ""
"`#[inline(always)]` _suggests_ that an inline expansion should always be "
"performed."
msgstr "`#[inline(always)]`는 항상 인라인 확장이 수행되어야 함을 _제안_합니다."

#: src/attributes/codegen.md:46
msgid ""
"`#[inline(never)]` _suggests_ that an inline expansion should never be "
"performed."
msgstr "`#[inline(never)]`는 인라인 확장이 절대 수행되지 않아야 함을 _제안_합니다."

#: src/attributes/codegen.md:49
msgid ""
"_**Note**_: `#[inline]` in every form is a hint, with no _requirements_ on "
"the language to place a copy of the attributed function in the caller."
msgstr "_**참고**_: 모든 형식의 `#[inline]`은 힌트일 뿐이며, 언어 사양상 호출자 내부에 해당 함수의 복사본을 배치해야 한다는 _요구 사항_은 없습니다."

#: src/attributes/codegen.md:54
msgid "The `cold` attribute"
msgstr "`cold` 속성"

#: src/attributes/codegen.md:57
msgid ""
"The _`cold` [attribute](../attributes.md)_ suggests that the attributed "
"function is unlikely to be called."
msgstr "_`cold` [속성](../attributes.md)_은 해당 함수가 호출될 가능성이 낮음을 제안합니다."

#: src/attributes/codegen.md:62
msgid "The `no_builtins` attribute"
msgstr "`no_builtins` 속성"

#: src/attributes/codegen.md:65
msgid ""
"The _`no_builtins` [attribute](../attributes.md)_ may be applied at the "
"crate level to disable optimizing certain code patterns to invocations of "
"library functions that are assumed to exist."
msgstr "_`no_builtins` [속성](../attributes.md)_은 특정 코드 패턴을 존재한다고 가정되는 라이브러리 함수의 호출로 최적화하는 것을 비활성화하기 위해 크레이트 레벨에 적용될 수 있습니다."

#: src/attributes/codegen.md:71
msgid "The `target_feature` attribute"
msgstr "`target_feature` 속성"

#: src/attributes/codegen.md:75
msgid ""
"The _`target_feature` [attribute](../attributes.md)_ may be applied to a "
"function to enable code generation of that function for specific platform "
"architecture features. It uses the [_MetaListNameValueStr_](../"
"attributes.md#meta-item-attribute-syntax) syntax with a single key of "
"`enable` whose value is a string of comma-separated feature names to enable."
msgstr "_`target_feature` [속성](../attributes.md)_은 특정 플랫폼 아키텍처 기능을 위한 함수 코드 생성을 활성화하기 위해 함수에 적용될 수 있습니다. 활성화할 기능 이름들을 쉼표로 구분한 문자열을 값으로 가지는 단일 키 `enable`과 함께 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/attributes/codegen.md:81 src/attributes/codegen.md:82
msgid "\"avx2\""
msgstr "\"avx2\""

#: src/attributes/codegen.md:88
msgid ""
"Each [target architecture](../conditional-compilation.md#target_arch) has a "
"set of features that may be enabled. It is an error to specify a feature for "
"a target architecture that the crate is not being compiled for."
msgstr "각 [타겟 아키텍처](../conditional-compilation.md#target_arch)는 활성화할 수 있는 일련의 기능들을 가지고 있습니다. 크레이트가 컴파일되지 않는 타겟 아키텍처에 대한 기능을 지정하는 것은 에러입니다."

#: src/attributes/codegen.md:94
msgid ""
"Closures defined within a `target_feature`\\-annotated function inherit the "
"attribute from the enclosing function."
msgstr "`target_feature`가 주석 처리된 함수 내에 정의된 클로저는 둘러싼 함수의 속성을 상속받습니다."

#: src/attributes/codegen.md:99
msgid ""
"It is [undefined behavior](../behavior-considered-undefined.md) to call a "
"function that is compiled with a feature that is not supported on the "
"current platform the code is running on, _except_ if the platform explicitly "
"documents this to be safe."
msgstr "코드가 실행 중인 현재 플랫폼에서 지원하지 않는 기능으로 컴파일된 함수를 호출하는 것은 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)입니다. 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 예외입니다."

#: src/attributes/codegen.md:105
msgid ""
"The following restrictions apply unless otherwise specified by the platform "
"rules below:"
msgstr "아래 플랫폼 규칙에서 달리 명시하지 않는 한 다음 제약 사항이 적용됩니다."

#: src/attributes/codegen.md:107
msgid ""
"Safe `#[target_feature]` functions (and closures that inherit the attribute) "
"can only be safely called within a caller that enables all the "
"`target_feature`s that the callee enables. This restriction does not apply "
"in an `unsafe` context."
msgstr "안전한(safe) `#[target_feature]` 함수(및 속성을 상속받은 클로저)는 호출자가 피호출자가 활성화한 모든 `target_feature`를 활성화한 경우에만 안전하게 호출될 수 있습니다. 이 제약 사항은 `unsafe` 컨텍스트에서는 적용되지 않습니다."

#: src/attributes/codegen.md:109
msgid ""
"Safe `#[target_feature]` functions (and closures that inherit the attribute) "
"can only be coerced to _safe_ function pointers in contexts that enable all "
"the `target_feature`s that the coercee enables. This restriction does not "
"apply to `unsafe` function pointers."
msgstr "안전한 `#[target_feature]` 함수(및 속성을 상속받은 클로저)는 강제 변환되는 위치가 피강제변환자가 활성화한 모든 `target_feature`를 활성화한 컨텍스트인 경우에만 _안전한_ 함수 포인터로 강제 변환될 수 있습니다. 이 제약 사항은 `unsafe` 함수 포인터에는 적용되지 않습니다."

#: src/attributes/codegen.md:112
msgid ""
"Implicitly enabled features are included in this rule. For example an `sse2` "
"function can call ones marked with `sse`."
msgstr "암시적으로 활성화된 기능들도 이 규칙에 포함됩니다. 예를 들어 `sse2` 함수는 `sse`로 표시된 함수를 호출할 수 있습니다."

#: src/attributes/codegen.md:115 src/attributes/codegen.md:135
msgid "\"sse2\""
msgstr "\"sse2\""

#: src/attributes/codegen.md:116 src/attributes/codegen.md:128
msgid "\"sse\""
msgstr "\"sse\""

#: src/attributes/codegen.md:120
msgid ""
"// Calling `foo_sse` here is unsafe, as we must ensure that SSE is\n"
"    // available first, even if `sse` is enabled by default on the target\n"
"    // platform or manually enabled as compiler flags.\n"
msgstr ""
"// 여기서 `foo_sse`를 호출하는 것은 안전하지 않습니다. 비록 타겟 플랫폼에서\n"
"    // `sse`가 기본적으로 활성화되어 있거나 컴파일러 플래그로 수동 활성화되어 있더라도,\n"
"    // 먼저 SSE를 사용할 수 있는지 확인해야 하기 때문입니다.\n"

#: src/attributes/codegen.md:130
msgid "// Calling `foo_sse` here is safe.\n"
msgstr "// 여기서 `foo_sse`를 호출하는 것은 안전합니다.\n"

#: src/attributes/codegen.md:137
msgid "// Calling `foo_sse` here is safe because `sse2` implies `sse`.\n"
msgstr "// `sse2`는 `sse`를 포함하므로 여기서 `foo_sse`를 호출하는 것은 안전합니다.\n"

#: src/attributes/codegen.md:145
msgid ""
"A function with a `#[target_feature]` attribute _never_ implements the `Fn` "
"family of traits, although closures inheriting features from the enclosing "
"function do."
msgstr "`#[target_feature]` 속성이 있는 함수는 _절대_ `Fn` 계열 트레잇을 구현하지 않습니다. 단, 둘러싼 함수로부터 기능을 상속받은 클로저는 예외입니다."

#: src/attributes/codegen.md:149
msgid ""
"The `#[target_feature]` attribute is not allowed on the following places:"
msgstr "`#[target_feature]` 속성은 다음 위치에서 허용되지 않습니다:"

#: src/attributes/codegen.md:151
msgid "[the `main` function](../crates-and-source-files.md#r-crate.main)"
msgstr "[`main` 함수](../crates-and-source-files.md#r-crate.main)"

#: src/attributes/codegen.md:152
msgid "a [`panic_handler` function](../runtime.md#r-runtime.panic_handler)"
msgstr "[`panic_handler` 함수](../runtime.md#r-runtime.panic_handler)"

#: src/attributes/codegen.md:153
msgid "safe trait methods"
msgstr "안전한 트레잇 메서드"

#: src/attributes/codegen.md:154
msgid "safe default functions in traits"
msgstr "트레잇의 안전한 기본 함수"

#: src/attributes/codegen.md:158
msgid ""
"Functions marked with `target_feature` are not inlined into a context that "
"does not support the given features. The `#[inline(always)]` attribute may "
"not be used with a `target_feature` attribute."
msgstr "`target_feature`가 표시된 함수는 주어진 기능을 지원하지 않는 컨텍스트로 인라인화되지 않습니다. `#[inline(always)]` 속성은 `target_feature` 속성과 함께 사용될 수 없습니다."

#: src/attributes/codegen.md:164
msgid "Available features"
msgstr "사용 가능한 기능"

#: src/attributes/codegen.md:167
msgid "The following is a list of the available feature names."
msgstr "다음은 사용 가능한 기능 이름의 목록입니다."

#: src/attributes/codegen.md:171
msgid "`x86` or `x86_64`"
msgstr "`x86` 또는 `x86_64`"

#: src/attributes/codegen.md:174
msgid ""
"Executing code with unsupported features is undefined behavior on this "
"platform. Hence on this platform usage of `#[target_feature]` functions "
"follows the [above restrictions](codegen.md#r-"
"attributes.codegen.target_feature.safety-restrictions)."
msgstr "지원하지 않는 기능으로 코드를 실행하는 것은 이 플랫폼에서 정의되지 않은 동작입니다. 따라서 이 플랫폼에서 `#[target_feature]` 함수의 사용은 [위의 제약 사항](codegen.md#r-attributes.codegen.target_feature.safety-restrictions)을 따릅니다."

#: src/attributes/codegen.md:178 src/attributes/codegen.md:258
#: src/attributes/codegen.md:320 src/attributes/codegen.md:379
msgid "Feature"
msgstr "기능(Feature)"

#: src/attributes/codegen.md:178 src/attributes/codegen.md:258
#: src/attributes/codegen.md:320 src/attributes/codegen.md:379
msgid "Implicitly Enables"
msgstr "암시적으로 활성화함"

#: src/attributes/codegen.md:178 src/attributes/codegen.md:320
#: src/attributes/codegen.md:379
msgid "Description"
msgstr "설명"

#: src/attributes/codegen.md:180
msgid "`adx`"
msgstr "`adx`"

#: src/attributes/codegen.md:180
msgid ""
"[ADX](https://en.wikipedia.org/wiki/Intel_ADX) --- Multi-Precision Add-Carry "
"Instruction Extensions"
msgstr "[ADX](https://en.wikipedia.org/wiki/Intel_ADX) --- 다중 정밀도 덧셈-올림수(Multi-Precision Add-Carry) 명령어 확장"

#: src/attributes/codegen.md:181 src/attributes/codegen.md:260
msgid "`aes`"
msgstr "`aes`"

#: src/attributes/codegen.md:181 src/attributes/codegen.md:192
#: src/attributes/codegen.md:196 src/attributes/codegen.md:198
#: src/attributes/codegen.md:199
msgid "`sse2`"
msgstr "`sse2`"

#: src/attributes/codegen.md:181
msgid ""
"[AES](https://en.wikipedia.org/wiki/AES_instruction_set) --- Advanced "
"Encryption Standard"
msgstr "[AES](https://en.wikipedia.org/wiki/AES_instruction_set) --- 고급 암호화 표준(Advanced Encryption Standard)"

#: src/attributes/codegen.md:182 src/attributes/codegen.md:183
#: src/attributes/codegen.md:187 src/attributes/codegen.md:188
#: src/inline-assembly.md:592
msgid "`avx`"
msgstr "`avx`"

#: src/attributes/codegen.md:182 src/attributes/codegen.md:201
msgid "`sse4.2`"
msgstr "`sse4.2`"

#: src/attributes/codegen.md:182
msgid ""
"[AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) --- Advanced "
"Vector Extensions"
msgstr "[AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) --- 고급 벡터 확장(Advanced Vector Extensions)"

#: src/attributes/codegen.md:183
msgid "`avx2`"
msgstr "`avx2`"

#: src/attributes/codegen.md:183
msgid ""
"[AVX2](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2) --- "
"Advanced Vector Extensions 2"
msgstr "[AVX2](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2) --- 고급 벡터 확장 2(Advanced Vector Extensions 2)"

#: src/attributes/codegen.md:184
msgid "`bmi1`"
msgstr "`bmi1`"

#: src/attributes/codegen.md:184
msgid ""
"[BMI1](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets) --- "
"Bit Manipulation Instruction Sets"
msgstr "[BMI1](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets) --- 비트 조작 명령어 집합(Bit Manipulation Instruction Sets)"

#: src/attributes/codegen.md:185
msgid "`bmi2`"
msgstr "`bmi2`"

#: src/attributes/codegen.md:185
msgid ""
"[BMI2](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2) "
"--- Bit Manipulation Instruction Sets 2"
msgstr "[BMI2](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2) --- 비트 조작 명령어 집합 2(Bit Manipulation Instruction Sets 2)"

#: src/attributes/codegen.md:186
msgid "`cmpxchg16b`"
msgstr "`cmpxchg16b`"

#: src/attributes/codegen.md:186
msgid ""
"[`cmpxchg16b`](https://www.felixcloutier.com/x86/cmpxchg8b:cmpxchg16b) --- "
"Compares and exchange 16 bytes (128 bits) of data atomically"
msgstr "[`cmpxchg16b`](https://www.felixcloutier.com/x86/cmpxchg8b:cmpxchg16b) --- 16바이트(128비트) 데이터를 원자적으로 비교 및 교환"

#: src/attributes/codegen.md:187
msgid "`f16c`"
msgstr "`f16c`"

#: src/attributes/codegen.md:187
msgid ""
"[F16C](https://en.wikipedia.org/wiki/F16C) --- 16-bit floating point "
"conversion instructions"
msgstr "[F16C](https://en.wikipedia.org/wiki/F16C) --- 16비트 부동 소수점 변환 명령어"

#: src/attributes/codegen.md:188
msgid "`fma`"
msgstr "`fma`"

#: src/attributes/codegen.md:188
msgid ""
"[FMA3](https://en.wikipedia.org/wiki/FMA_instruction_set) --- Three-operand "
"fused multiply-add"
msgstr "[FMA3](https://en.wikipedia.org/wiki/FMA_instruction_set) --- 3-피연산자 융합 곱셈-더하기(Three-operand fused multiply-add)"

#: src/attributes/codegen.md:189
msgid "`fxsr`"
msgstr "`fxsr`"

#: src/attributes/codegen.md:189
msgid ""
"[`fxsave`](https://www.felixcloutier.com/x86/fxsave) and [`fxrstor`](https://"
"www.felixcloutier.com/x86/fxrstor) --- Save and restore x87 FPU, MMX "
"Technology, and SSE State"
msgstr "[`fxsave`](https://www.felixcloutier.com/x86/fxsave) 및 [`fxrstor`](https://www.felixcloutier.com/x86/fxrstor) --- x87 FPU, MMX 기술 및 SSE 상태 저장 및 복원"

#: src/attributes/codegen.md:190
msgid "`lzcnt`"
msgstr "`lzcnt`"

#: src/attributes/codegen.md:190
msgid ""
"[`lzcnt`](https://www.felixcloutier.com/x86/lzcnt) --- Leading zeros count"
msgstr "[`lzcnt`](https://www.felixcloutier.com/x86/lzcnt) --- 선행 제로 카운트(Leading zeros count)"

#: src/attributes/codegen.md:191
msgid "`movbe`"
msgstr "`movbe`"

#: src/attributes/codegen.md:191
msgid ""
"[`movbe`](https://www.felixcloutier.com/x86/movbe) --- Move data after "
"swapping bytes"
msgstr "[`movbe`](https://www.felixcloutier.com/x86/movbe) --- 바이트 스왑 후 데이터 이동"

#: src/attributes/codegen.md:192
msgid "`pclmulqdq`"
msgstr "`pclmulqdq`"

#: src/attributes/codegen.md:192
msgid ""
"[`pclmulqdq`](https://www.felixcloutier.com/x86/pclmulqdq) --- Packed carry-"
"less multiplication quadword"
msgstr "[`pclmulqdq`](https://www.felixcloutier.com/x86/pclmulqdq) --- 팩형 올림수 없는 곱셈 쿼드워드(Packed carry-less multiplication quadword)"

#: src/attributes/codegen.md:193
msgid "`popcnt`"
msgstr "`popcnt`"

#: src/attributes/codegen.md:193
msgid ""
"[`popcnt`](https://www.felixcloutier.com/x86/popcnt) --- Count of bits set "
"to 1"
msgstr "[`popcnt`](https://www.felixcloutier.com/x86/popcnt) --- 1로 설정된 비트의 개수"

#: src/attributes/codegen.md:194
msgid "`rdrand`"
msgstr "`rdrand`"

#: src/attributes/codegen.md:194
msgid "[`rdrand`](https://en.wikipedia.org/wiki/RdRand) --- Read random number"
msgstr "[`rdrand`](https://en.wikipedia.org/wiki/RdRand) --- 난수 읽기"

#: src/attributes/codegen.md:195
msgid "`rdseed`"
msgstr "`rdseed`"

#: src/attributes/codegen.md:195
msgid "[`rdseed`](https://en.wikipedia.org/wiki/RdRand) --- Read random seed"
msgstr "[`rdseed`](https://en.wikipedia.org/wiki/RdRand) --- 난수 시드 읽기"

#: src/attributes/codegen.md:196
msgid "`sha`"
msgstr "`sha`"

#: src/attributes/codegen.md:196
msgid ""
"[SHA](https://en.wikipedia.org/wiki/Intel_SHA_extensions) --- Secure Hash "
"Algorithm"
msgstr "[SHA](https://en.wikipedia.org/wiki/Intel_SHA_extensions) --- 안전한 해시 알고리즘(Secure Hash Algorithm)"

#: src/attributes/codegen.md:197 src/attributes/codegen.md:198
#: src/inline-assembly.md:591
msgid "`sse`"
msgstr "`sse`"

#: src/attributes/codegen.md:197
msgid ""
"[SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) --- Streaming "
"<abbr title=\"Single Instruction Multiple Data\">SIMD</abbr> Extensions"
msgstr "[SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) --- 스트리밍 <abbr title=\"Single Instruction Multiple Data\">SIMD</abbr> 확장"

#: src/attributes/codegen.md:198
msgid ""
"[SSE2](https://en.wikipedia.org/wiki/SSE2) --- Streaming SIMD Extensions 2"
msgstr "[SSE2](https://en.wikipedia.org/wiki/SSE2) --- 스트리밍 SIMD 확장 2"

#: src/attributes/codegen.md:199 src/attributes/codegen.md:202
msgid "`sse3`"
msgstr "`sse3`"

#: src/attributes/codegen.md:199
msgid ""
"[SSE3](https://en.wikipedia.org/wiki/SSE3) --- Streaming SIMD Extensions 3"
msgstr "[SSE3](https://en.wikipedia.org/wiki/SSE3) --- 스트리밍 SIMD 확장 3"

#: src/attributes/codegen.md:200 src/attributes/codegen.md:201
msgid "`sse4.1`"
msgstr "`sse4.1`"

#: src/attributes/codegen.md:200 src/attributes/codegen.md:202
msgid "`ssse3`"
msgstr "`ssse3`"

#: src/attributes/codegen.md:200
msgid ""
"[SSE4.1](https://en.wikipedia.org/wiki/SSE4#SSE4.1) --- Streaming SIMD "
"Extensions 4.1"
msgstr "[SSE4.1](https://en.wikipedia.org/wiki/SSE4#SSE4.1) --- 스트리밍 SIMD 확장 4.1"

#: src/attributes/codegen.md:201
msgid ""
"[SSE4.2](https://en.wikipedia.org/wiki/SSE4#SSE4.2) --- Streaming SIMD "
"Extensions 4.2"
msgstr "[SSE4.2](https://en.wikipedia.org/wiki/SSE4#SSE4.2) --- 스트리밍 SIMD 확장 4.2"

#: src/attributes/codegen.md:202
msgid ""
"[SSSE3](https://en.wikipedia.org/wiki/SSSE3) --- Supplemental Streaming SIMD "
msgstr "[SSSE3](https://en.wikipedia.org/wiki/SSSE3) --- 부가적인 스트리밍 SIMD "
"Extensions 3"
msgstr "확장 3"

#: src/attributes/codegen.md:203
msgid "`xsave`"
msgstr "`xsave`"

#: src/attributes/codegen.md:203
msgid ""
"[`xsave`](https://www.felixcloutier.com/x86/xsave) --- Save processor "
"extended states"
msgstr "[`xsave`](https://www.felixcloutier.com/x86/xsave) --- 프로세서 확장 상태 저장"

#: src/attributes/codegen.md:204
msgid "`xsavec`"
msgstr "`xsavec`"

#: src/attributes/codegen.md:204
msgid ""
"[`xsavec`](https://www.felixcloutier.com/x86/xsavec) --- Save processor "
"extended states with compaction"
msgstr "[`xsavec`](https://www.felixcloutier.com/x86/xsavec) --- 압축을 사용한 프로세서 확장 상태 저장"

#: src/attributes/codegen.md:205
msgid "`xsaveopt`"
msgstr "`xsaveopt`"

#: src/attributes/codegen.md:205
msgid ""
"[`xsaveopt`](https://www.felixcloutier.com/x86/xsaveopt) --- Save processor "
"extended states optimized"
msgstr "[`xsaveopt`](https://www.felixcloutier.com/x86/xsaveopt) --- 최적화된 프로세서 확장 상태 저장"

#: src/attributes/codegen.md:206
msgid "`xsaves`"
msgstr "`xsaves`"

#: src/attributes/codegen.md:206
msgid ""
"[`xsaves`](https://www.felixcloutier.com/x86/xsaves) --- Save processor "
"extended states supervisor"
msgstr "[`xsaves`](https://www.felixcloutier.com/x86/xsaves) --- 관리자용 프로세서 확장 상태 저장"

#: src/attributes/codegen.md:241
msgid "`aarch64`"
msgstr "`aarch64`"

#: src/attributes/codegen.md:244 src/attributes/codegen.md:310
msgid ""
"On this platform the usage of `#[target_feature]` functions follows the "
"[above restrictions](codegen.md#r-attributes.codegen.target_feature.safety-"
"restrictions)."
msgstr "이 플랫폼에서 `#[target_feature]` 함수의 사용은 [위의 제약 사항](codegen.md#r-attributes.codegen.target_feature.safety-restrictions)을 따릅니다."

#: src/attributes/codegen.md:247
msgid ""
"Further documentation on these features can be found in the [ARM "
"Architecture Reference Manual](https://developer.arm.com/documentation/"
"ddi0487/latest), or elsewhere on [developer.arm.com](https://"
"developer.arm.com)."
msgstr "이러한 기능들에 대한 추가 문서는 [ARM 아키텍처 참조 매뉴얼](https://developer.arm.com/documentation/ddi0487/latest) 또는 [developer.arm.com](https://developer.arm.com)에서 찾을 수 있습니다."

#: src/attributes/codegen.md:253
msgid ""
"_**Note**_: The following pairs of features should both be marked as enabled "
"or disabled together if used:"
msgstr "_**참고**_: 다음 기능 쌍들은 사용 시 둘 다 활성화되거나 비활성화되도록 표시되어야 합니다:"

#: src/attributes/codegen.md:255
msgid "`paca` and `pacg`, which LLVM currently implements as one feature."
msgstr "`paca` 및 `pacg` (LLVM은 현재 이를 하나의 기능으로 구현함)."

#: src/attributes/codegen.md:258
msgid "Feature Name"
msgstr "기능 이름"

#: src/attributes/codegen.md:260 src/attributes/codegen.md:270
#: src/attributes/codegen.md:273 src/attributes/codegen.md:276
#: src/attributes/codegen.md:280 src/attributes/codegen.md:291
#: src/attributes/codegen.md:293 src/inline-assembly.md:600
#: src/inline-assembly.md:603 src/inline-assembly.md:607
msgid "`neon`"
msgstr "`neon`"

#: src/attributes/codegen.md:260
msgid ""
"FEAT_AES & FEAT_PMULL --- Advanced <abbr title=\"Single Instruction Multiple "
"Data\">SIMD</abbr> AES & PMULL instructions"
msgstr "FEAT_AES & FEAT_PMULL --- 고급 <abbr title=\"Single Instruction Multiple Data\">SIMD</abbr> AES 및 PMULL 명령어"

#: src/attributes/codegen.md:261
msgid "`bf16`"
msgstr "`bf16`"

#: src/attributes/codegen.md:261
msgid "FEAT_BF16 --- BFloat16 instructions"
msgstr "FEAT_BF16 --- BFloat16 명령어"

#: src/attributes/codegen.md:262
msgid "`bti`"
msgstr "`bti`"

#: src/attributes/codegen.md:262
msgid "FEAT_BTI --- Branch Target Identification"
msgstr "FEAT_BTI --- 분기 타겟 식별(Branch Target Identification)"

#: src/attributes/codegen.md:263
msgid "`crc`"
msgstr "`crc`"

#: src/attributes/codegen.md:263
msgid "FEAT_CRC --- CRC32 checksum instructions"
msgstr "FEAT_CRC --- CRC32 체크섬 명령어"

#: src/attributes/codegen.md:264
msgid "`dit`"
msgstr "`dit`"

#: src/attributes/codegen.md:264
msgid "FEAT_DIT --- Data Independent Timing instructions"
msgstr "FEAT_DIT --- 데이터 독립 타이밍(Data Independent Timing) 명령어"

#: src/attributes/codegen.md:265
msgid "`dotprod`"
msgstr "`dotprod`"

#: src/attributes/codegen.md:265
msgid "FEAT_DotProd --- Advanced SIMD Int8 dot product instructions"
msgstr "FEAT_DotProd --- 고급 SIMD Int8 내적(dot product) 명령어"

#: src/attributes/codegen.md:266
msgid "`dpb`"
msgstr "`dpb`"

#: src/attributes/codegen.md:266
msgid "FEAT_DPB --- Data cache clean to point of persistence"
msgstr "FEAT_DPB --- 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of persistence)"

#: src/attributes/codegen.md:267
msgid "`dpb2`"
msgstr "`dpb2`"

#: src/attributes/codegen.md:267
msgid "FEAT_DPB2 --- Data cache clean to point of deep persistence"
msgstr "FEAT_DPB2 --- 깊은 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of deep persistence)"

#: src/attributes/codegen.md:268
msgid "`f32mm`"
msgstr "`f32mm`"

#: src/attributes/codegen.md:268 src/attributes/codegen.md:269
#: src/attributes/codegen.md:296 src/attributes/codegen.md:297
msgid "`sve`"
msgstr "`sve`"

#: src/attributes/codegen.md:268
msgid "FEAT_F32MM --- SVE single-precision FP matrix multiply instruction"
msgstr "FEAT_F32MM --- SVE 단정밀도 부동 소수점 행렬 곱셈 명령어"

#: src/attributes/codegen.md:269
msgid "`f64mm`"
msgstr "`f64mm`"

#: src/attributes/codegen.md:269
msgid "FEAT_F64MM --- SVE double-precision FP matrix multiply instruction"
msgstr "FEAT_F64MM --- SVE 배정밀도 부동 소수점 행렬 곱셈 명령어"

#: src/attributes/codegen.md:270
msgid "`fcma`"
msgstr "`fcma`"

#: src/attributes/codegen.md:270
msgid "FEAT_FCMA --- Floating point complex number support"
msgstr "FEAT_FCMA --- 부동 소수점 복소수 지원"

#: src/attributes/codegen.md:271
msgid "`fhm`"
msgstr "`fhm`"

#: src/attributes/codegen.md:271 src/attributes/codegen.md:273
#: src/attributes/codegen.md:296
msgid "`fp16`"
msgstr "`fp16`"

#: src/attributes/codegen.md:271
msgid "FEAT_FHM --- Half-precision FP FMLAL instructions"
msgstr "FEAT_FHM --- 반정밀도 부동 소수점 FMLAL 명령어"

#: src/attributes/codegen.md:272
msgid "`flagm`"
msgstr "`flagm`"

#: src/attributes/codegen.md:272
msgid "FEAT_FlagM --- Conditional flag manipulation"
msgstr "FEAT_FlagM --- 조건부 플래그 조작"

#: src/attributes/codegen.md:273
msgid "FEAT_FP16 --- Half-precision FP data processing"
msgstr "FEAT_FP16 --- 반정밀도 부동 소수점 데이터 처리"

#: src/attributes/codegen.md:274
msgid "`frintts`"
msgstr "`frintts`"

#: src/attributes/codegen.md:274
msgid "FEAT_FRINTTS --- Floating-point to int helper instructions"
msgstr "FEAT_FRINTTS --- 부동 소수점에서 정수로의 변환 도우미 명령어"

#: src/attributes/codegen.md:275
msgid "`i8mm`"
msgstr "`i8mm`"

#: src/attributes/codegen.md:275
msgid "FEAT_I8MM --- Int8 Matrix Multiplication"
msgstr "FEAT_I8MM --- Int8 행렬 곱셈"

#: src/attributes/codegen.md:276
msgid "`jsconv`"
msgstr "`jsconv`"

#: src/attributes/codegen.md:276
msgid "FEAT_JSCVT --- JavaScript conversion instruction"
msgstr "FEAT_JSCVT --- 자바스크립트 변환 명령어"

#: src/attributes/codegen.md:277
msgid "`lse`"
msgstr "`lse`"

#: src/attributes/codegen.md:277
msgid "FEAT_LSE --- Large System Extension"
msgstr "FEAT_LSE --- 대규모 시스템 확장(Large System Extension)"

#: src/attributes/codegen.md:278
msgid "`lor`"
msgstr "`lor`"

#: src/attributes/codegen.md:278
msgid "FEAT_LOR --- Limited Ordering Regions extension"
msgstr "FEAT_LOR --- 제한된 순서 영역(Limited Ordering Regions) 확장"

#: src/attributes/codegen.md:279
msgid "`mte`"
msgstr "`mte`"

#: src/attributes/codegen.md:279
msgid "FEAT_MTE & FEAT_MTE2 --- Memory Tagging Extension"
msgstr "FEAT_MTE & FEAT_MTE2 --- 메모리 태깅 확장(Memory Tagging Extension)"

#: src/attributes/codegen.md:280
msgid "FEAT_FP & FEAT_AdvSIMD --- Floating Point and Advanced SIMD extension"
msgstr "FEAT_FP & FEAT_AdvSIMD --- 부동 소수점 및 고급 SIMD 확장"

#: src/attributes/codegen.md:281
msgid "`pan`"
msgstr "`pan`"

#: src/attributes/codegen.md:281
msgid "FEAT_PAN --- Privileged Access-Never extension"
msgstr "FEAT_PAN --- 특권층 액세스 금지(Privileged Access-Never) 확장"

#: src/attributes/codegen.md:282
msgid "`paca`"
msgstr "`paca`"

#: src/attributes/codegen.md:282
msgid "FEAT_PAuth --- Pointer Authentication (address authentication)"
msgstr "FEAT_PAuth --- 포인터 인증 (주소 인증)"

#: src/attributes/codegen.md:283
msgid "`pacg`"
msgstr "`pacg`"

#: src/attributes/codegen.md:283
msgid "FEAT_PAuth --- Pointer Authentication (generic authentication)"
msgstr "FEAT_PAuth --- 포인터 인증 (일반 인증)"

#: src/attributes/codegen.md:284
msgid "`pmuv3`"
msgstr "`pmuv3`"

#: src/attributes/codegen.md:284
msgid "FEAT_PMUv3 --- Performance Monitors extension (v3)"
msgstr "FEAT_PMUv3 --- 성능 모니터 확장 (v3)"

#: src/attributes/codegen.md:285
msgid "`rand`"
msgstr "`rand`"

#: src/attributes/codegen.md:285
msgid "FEAT_RNG --- Random Number Generator"
msgstr "FEAT_RNG --- 난수 생성기(Random Number Generator)"

#: src/attributes/codegen.md:286
msgid "`ras`"
msgstr "`ras`"

#: src/attributes/codegen.md:286
msgid ""
"FEAT_RAS & FEAT_RASv1p1 --- Reliability, Availability and Serviceability "
"extension"
msgstr "FEAT_RAS & FEAT_RASv1p1 --- 신뢰성, 가용성 및 서비스성(Reliability, Availability and Serviceability) 확장"

#: src/attributes/codegen.md:287 src/attributes/codegen.md:288
msgid "`rcpc`"
msgstr "`rcpc`"

#: src/attributes/codegen.md:287
msgid "FEAT_LRCPC --- Release consistent Processor Consistent"
msgstr "FEAT_LRCPC --- 릴리스 일관성 프로세서 일관성(Release consistent Processor Consistent)"

#: src/attributes/codegen.md:288
msgid "`rcpc2`"
msgstr "`rcpc2`"

#: src/attributes/codegen.md:288
msgid "FEAT_LRCPC2 --- RcPc with immediate offsets"
msgstr "FEAT_LRCPC2 --- 즉시 오프셋을 포함한 RcPc"

#: src/attributes/codegen.md:289
msgid "`rdm`"
msgstr "`rdm`"

#: src/attributes/codegen.md:289
msgid "FEAT_RDM --- Rounding Double Multiply accumulate"
msgstr "FEAT_RDM --- 반올림 이중 곱셈 누산(Rounding Double Multiply accumulate)"

#: src/attributes/codegen.md:290
msgid "`sb`"
msgstr "`sb`"

#: src/attributes/codegen.md:290
msgid "FEAT_SB --- Speculation Barrier"
msgstr "FEAT_SB --- 투기적 실행 배리어(Speculation Barrier)"

#: src/attributes/codegen.md:291 src/attributes/codegen.md:292
msgid "`sha2`"
msgstr "`sha2`"

#: src/attributes/codegen.md:291
msgid "FEAT_SHA1 & FEAT_SHA256 --- Advanced SIMD SHA instructions"
msgstr "FEAT_SHA1 & FEAT_SHA256 --- 고급 SIMD SHA 명령어"

#: src/attributes/codegen.md:292
msgid "`sha3`"
msgstr "`sha3`"

#: src/attributes/codegen.md:292
msgid "FEAT_SHA512 & FEAT_SHA3 --- Advanced SIMD SHA instructions"
msgstr "FEAT_SHA512 & FEAT_SHA3 --- 고급 SIMD SHA 명령어"

#: src/attributes/codegen.md:293
msgid "`sm4`"
msgstr "`sm4`"

#: src/attributes/codegen.md:293
msgid "FEAT_SM3 & FEAT_SM4 --- Advanced SIMD SM3/4 instructions"
msgstr "FEAT_SM3 & FEAT_SM4 --- 고급 SIMD SM3/4 명령어"

#: src/attributes/codegen.md:294
msgid "`spe`"
msgstr "`spe`"

#: src/attributes/codegen.md:294
msgid "FEAT_SPE --- Statistical Profiling Extension"
msgstr "FEAT_SPE --- 통계적 프로파일링 확장(Statistical Profiling Extension)"

#: src/attributes/codegen.md:295
msgid "`ssbs`"
msgstr "`ssbs`"

#: src/attributes/codegen.md:295
msgid "FEAT_SSBS & FEAT_SSBS2 --- Speculative Store Bypass Safe"
msgstr "FEAT_SSBS & FEAT_SSBS2 --- 투기적 저장소 우회 안전(Speculative Store Bypass Safe)"

#: src/attributes/codegen.md:296
msgid "FEAT_SVE --- Scalable Vector Extension"
msgstr "FEAT_SVE --- 가변 벡터 확장(Scalable Vector Extension)"

#: src/attributes/codegen.md:297 src/attributes/codegen.md:301
msgid "`sve2`"
msgstr "`sve2`"

#: src/attributes/codegen.md:297
msgid "FEAT_SVE2 --- Scalable Vector Extension 2"
msgstr "FEAT_SVE2 --- 가변 벡터 확장 2"

#: src/attributes/codegen.md:298
msgid "`sve2-aes`"
msgstr "`sve2-aes`"

#: src/attributes/codegen.md:298
msgid "`sve2`, `aes`"
msgstr "`sve2`, `aes`"

#: src/attributes/codegen.md:298
msgid "FEAT_SVE_AES --- SVE AES instructions"
msgstr "FEAT_SVE_AES --- SVE AES 명령어"

#: src/attributes/codegen.md:299
msgid "`sve2-sm4`"
msgstr "`sve2-sm4`"

#: src/attributes/codegen.md:299
msgid "`sve2`, `sm4`"
msgstr "`sve2`, `sm4`"

#: src/attributes/codegen.md:299
msgid "FEAT_SVE_SM4 --- SVE SM4 instructions"
msgstr "FEAT_SVE_SM4 --- SVE SM4 명령어"

#: src/attributes/codegen.md:300
msgid "`sve2-sha3`"
msgstr "`sve2-sha3`"

#: src/attributes/codegen.md:300
msgid "`sve2`, `sha3`"
msgstr "`sve2`, `sha3`"

#: src/attributes/codegen.md:300
msgid "FEAT_SVE_SHA3 --- SVE SHA3 instructions"
msgstr "FEAT_SVE_SHA3 --- SVE SHA3 명령어"

#: src/attributes/codegen.md:301
msgid "`sve2-bitperm`"
msgstr "`sve2-bitperm`"

#: src/attributes/codegen.md:301
msgid "FEAT_SVE_BitPerm --- SVE Bit Permute"
msgstr "FEAT_SVE_BitPerm --- SVE 비트 치환(Bit Permute)"

#: src/attributes/codegen.md:302
msgid "`tme`"
msgstr "`tme`"

#: src/attributes/codegen.md:302
msgid "FEAT_TME --- Transactional Memory Extension"
msgstr "FEAT_TME --- 트랜잭셔널 메모리 확장(Transactional Memory Extension)"

#: src/attributes/codegen.md:303
msgid "`vh`"
msgstr "`vh`"

#: src/attributes/codegen.md:303
msgid "FEAT_VHE --- Virtualization Host Extensions"
msgstr "FEAT_VHE --- 가상화 호스트 확장(Virtualization Host Extensions)"

#: src/attributes/codegen.md:307
msgid "`riscv32` or `riscv64`"
msgstr "`riscv32` 또는 `riscv64`"

#: src/attributes/codegen.md:313
msgid ""
"Further documentation on these features can be found in their respective "
"specification. Many specifications are described in the [RISC-V ISA Manual]"
"(https://github.com/riscv/riscv-isa-manual) or in another manual hosted on "
"the [RISC-V GitHub Account](https://github.com/riscv)."
msgstr "이러한 기능들에 대한 추가 문서는 각각의 명세서에서 찾을 수 있습니다. 많은 명세들이 [RISC-V ISA 매뉴얼](https://github.com/riscv/riscv-isa-manual)이나 [RISC-V GitHub 계정](https://github.com/riscv)에서 호스팅되는 다른 매뉴얼들에 설명되어 있습니다."

#: src/attributes/codegen.md:322 src/types/boolean.md:77
#: src/types/boolean.md:88 src/types/boolean.md:99 src/types/boolean.md:112
#: src/types/boolean.md:121 src/inline-assembly.md:569
msgid "`a`"
msgstr "`a`"

#: src/attributes/codegen.md:322
msgid ""
"[A](https://github.com/riscv/riscv-isa-manual/blob/"
"de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/a-st-ext.adoc) --- Atomic "
"instructions"
msgstr "[A](https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/a-st-ext.adoc) --- 원자적(Atomic) 명령어"

#: src/attributes/codegen.md:323
msgid "`c`"
msgstr "`c`"

#: src/attributes/codegen.md:323
msgid ""
"[C](https://github.com/riscv/riscv-isa-manual/blob/"
"de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/c-st-ext.adoc) --- Compressed "
"instructions"
msgstr "[C](https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/c-st-ext.adoc) --- 압축(Compressed) 명령어"

#: src/attributes/codegen.md:324
msgid "`m`"
msgstr "`m`"

#: src/attributes/codegen.md:324
msgid ""
"[M](https://github.com/riscv/riscv-isa-manual/blob/"
"de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/m-st-ext.adoc) --- Integer "
"Multiplication and Division instructions"
msgstr "[M](https://github.com/riscv/riscv-isa-manual/blob/de46343a245c6ee1f7b1a40c92fe1a86bd4f4978/src/m-st-ext.adoc) --- 정수 곱셈 및 나눗셈 명령어"

#: src/attributes/codegen.md:325
msgid "`zb`"
msgstr "`zb`"

#: src/attributes/codegen.md:325
msgid "`zba`, `zbc`, `zbs`"
msgstr "`zba`, `zbc`, `zbs`"

#: src/attributes/codegen.md:325
msgid ""
"[Zb](https://github.com/riscv/riscv-bitmanip) --- Bit Manipulation "
"instructions"
msgstr "[Zb](https://github.com/riscv/riscv-bitmanip) --- 비트 조작 명령어"

#: src/attributes/codegen.md:326
msgid "`zba`"
msgstr "`zba`"

#: src/attributes/codegen.md:326
msgid ""
"[Zba](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zba.adoc) "
"--- Address Generation instructions"
msgstr "[Zba](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zba.adoc) --- 주소 생성 명령어"

#: src/attributes/codegen.md:327
msgid "`zbb`"
msgstr "`zbb`"

#: src/attributes/codegen.md:327
msgid ""
"[Zbb](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbb.adoc) "
"--- Basic bit-manipulation"
msgstr "[Zbb](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbb.adoc) --- 기본 비트 조작"

#: src/attributes/codegen.md:328
msgid "`zbc`"
msgstr "`zbc`"

#: src/attributes/codegen.md:328
msgid ""
"[Zbc](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc) "
"--- Carry-less multiplication"
msgstr "[Zbc](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc) --- 올림수 없는 곱셈(Carry-less multiplication)"

#: src/attributes/codegen.md:329
msgid "`zbkb`"
msgstr "`zbkb`"

#: src/attributes/codegen.md:329
msgid ""
"[Zbkb](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkb.adoc) "
"--- Bit Manipulation Instructions for Cryptography"
msgstr "[Zbkb](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkb.adoc) --- 암호화용 비트 조작 명령어"

#: src/attributes/codegen.md:330
msgid "`zbkc`"
msgstr "`zbkc`"

#: src/attributes/codegen.md:330
msgid ""
"[Zbkc](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc) "
"--- Carry-less multiplication for Cryptography"
msgstr "[Zbkc](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbc.adoc) --- 암호화용 올림수 없는 곱셈"

#: src/attributes/codegen.md:331
msgid "`zbkx`"
msgstr "`zbkx`"

#: src/attributes/codegen.md:331
msgid ""
"[Zbkx](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkx.adoc) "
"--- Crossbar permutations"
msgstr "[Zbkx](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbkx.adoc) --- 크로스바 치환(Crossbar permutations)"

#: src/attributes/codegen.md:332
msgid "`zbs`"
msgstr "`zbs`"

#: src/attributes/codegen.md:332
msgid ""
"[Zbs](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbs.adoc) "
"--- Single-bit instructions"
msgstr "[Zbs](https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/zbs.adoc) --- 단일 비트 명령어"

#: src/attributes/codegen.md:333
msgid "`zk`"
msgstr "`zk`"

#: src/attributes/codegen.md:333
msgid "`zkn`, `zkr`, `zks`, `zkt`, `zbkb`, `zbkc`, `zkbx`"
msgstr "`zkn`, `zkr`, `zks`, `zkt`, `zbkb`, `zbkc`, `zkbx`"

#: src/attributes/codegen.md:333
msgid ""
"[Zk](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zk.adoc) --- Scalar Cryptography"
msgstr "[Zk](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zk.adoc) --- 스칼라 암호화(Scalar Cryptography)"

#: src/attributes/codegen.md:334
msgid "`zkn`"
msgstr "`zkn`"

#: src/attributes/codegen.md:334
msgid "`zknd`, `zkne`, `zknh`, `zbkb`, `zbkc`, `zkbx`"
msgstr "`zknd`, `zkne`, `zknh`, `zbkb`, `zbkc`, `zkbx`"

#: src/attributes/codegen.md:334
msgid ""
"[Zkn](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zkn.adoc) --- NIST Algorithm suite extension"
msgstr "[Zkn](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkn.adoc) --- NIST 알고리즘 스위트 확장"

#: src/attributes/codegen.md:335
msgid "`zknd`"
msgstr "`zknd`"

#: src/attributes/codegen.md:335
msgid ""
"[Zknd](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zknd.adoc) --- NIST Suite: AES Decryption"
msgstr "[Zknd](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zknd.adoc) --- NIST 스위트: AES 복호화"

#: src/attributes/codegen.md:336
msgid "`zkne`"
msgstr "`zkne`"

#: src/attributes/codegen.md:336
msgid ""
"[Zkne](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zkne.adoc) --- NIST Suite: AES Encryption"
msgstr "[Zkne](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkne.adoc) --- NIST 스위트: AES 암호화"

#: src/attributes/codegen.md:337
msgid "`zknh`"
msgstr "`zknh`"

#: src/attributes/codegen.md:337
msgid ""
"[Zknh](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zknh.adoc) --- NIST Suite: Hash Function Instructions"
msgstr "[Zknh](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zknh.adoc) --- NIST 스위트: 해시 함수 명령어"

#: src/attributes/codegen.md:338
msgid "`zkr`"
msgstr "`zkr`"

#: src/attributes/codegen.md:338
msgid ""
"[Zkr](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zkr.adoc) --- Entropy Source Extension"
msgstr "[Zkr](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkr.adoc) --- 엔트로피 소스 확장"

#: src/attributes/codegen.md:339
msgid "`zks`"
msgstr "`zks`"

#: src/attributes/codegen.md:339
msgid "`zksed`, `zksh`, `zbkb`, `zbkc`, `zkbx`"
msgstr "`zksed`, `zksh`, `zbkb`, `zbkc`, `zkbx`"

#: src/attributes/codegen.md:339
msgid ""
"[Zks](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zks.adoc) --- ShangMi Algorithm Suite"
msgstr "[Zks](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zks.adoc) --- ShangMi 알고리즘 스위트"

#: src/attributes/codegen.md:340
msgid "`zksed`"
msgstr "`zksed`"

#: src/attributes/codegen.md:340
msgid ""
"[Zksed](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zksed.adoc) --- ShangMi Suite: SM4 Block Cipher Instructions"
msgstr "[Zksed](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zksed.adoc) --- ShangMi 스위트: SM4 블록 암호 명령어"

#: src/attributes/codegen.md:341
msgid "`zksh`"
msgstr "`zksh`"

#: src/attributes/codegen.md:341
msgid ""
"[Zksh](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zksh.adoc) --- ShangMi Suite: SM3 Hash Function Instructions"
msgstr "[Zksh](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zksh.adoc) --- ShangMi 스위트: SM3 해시 함수 명령어"

#: src/attributes/codegen.md:342
msgid "`zkt`"
msgstr "`zkt`"

#: src/attributes/codegen.md:342
msgid ""
"[Zkt](https://github.com/riscv/riscv-crypto/blob/"
"e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-"
"zkt.adoc) --- Data Independent Execution Latency Subset"
msgstr "[Zkt](https://github.com/riscv/riscv-crypto/blob/e2dd7d98b7f34d477e38cb5fd7a3af4379525189/doc/scalar/riscv-crypto-scalar-zkt.adoc) --- 데이터 독립적 실행 지연 시간(Data Independent Execution Latency) 서브셋"

#: src/attributes/codegen.md:370
msgid "`wasm32` or `wasm64`"
msgstr "`wasm32` 또는 `wasm64`"

#: src/attributes/codegen.md:373
msgid ""
"Safe `#[target_feature]` functions may always be used in safe contexts on "
"Wasm platforms. It is impossible to cause undefined behavior via the "
"`#[target_feature]` attribute because attempting to use instructions "
"unsupported by the Wasm engine will fail at load time without the risk of "
"being interpreted in a way different from what the compiler expected."
msgstr "Wasm 플랫폼에서 안전한(safe) `#[target_feature]` 함수는 항상 안전한 컨텍스트에서 사용될 수 있습니다. `#[target_feature]` 속성을 통해 정의되지 않은 동작을 유발하는 것은 불가능합니다. 왜냐하면 Wasm 엔진이 지원하지 않는 명령어를 사용하려는 시도는 로드 시점에 실패하며, 컴파일러가 예상한 것과 다르게 해석될 위험이 없기 때문입니다."

#: src/attributes/codegen.md:381
msgid "`bulk-memory`"
msgstr "`bulk-memory`"

#: src/attributes/codegen.md:381
msgid ""
"[WebAssembly bulk memory operations proposal](https://github.com/WebAssembly/"
"bulk-memory-operations)"
msgstr "[WebAssembly 대량 메모리 연산 제안(bulk memory operations proposal)](https://github.com/WebAssembly/bulk-memory-operations)"

#: src/attributes/codegen.md:382
msgid "`extended-const`"
msgstr "`extended-const`"

#: src/attributes/codegen.md:382
msgid ""
"[WebAssembly extended const expressions proposal](https://github.com/"
"WebAssembly/extended-const)"
msgstr "[WebAssembly 확장 상수 표현식 제안(extended const expressions proposal)](https://github.com/WebAssembly/extended-const)"

#: src/attributes/codegen.md:383
msgid "`mutable-globals`"
msgstr "`mutable-globals`"

#: src/attributes/codegen.md:383
msgid ""
"[WebAssembly mutable global proposal](https://github.com/WebAssembly/mutable-"
"global)"
msgstr "[WebAssembly 가변 전역 변수 제안(mutable global proposal)](https://github.com/WebAssembly/mutable-global)"

#: src/attributes/codegen.md:384
msgid "`nontrapping-fptoint`"
msgstr "`nontrapping-fptoint`"

#: src/attributes/codegen.md:384
msgid ""
"[WebAssembly non-trapping float-to-int conversion proposal](https://"
"github.com/WebAssembly/nontrapping-float-to-int-conversions)"
msgstr "[WebAssembly 비-트래핑 부동 소수점-정수 변환 제안(non-trapping float-to-int conversion proposal)](https://github.com/WebAssembly/nontrapping-float-to-int-conversions)"

#: src/attributes/codegen.md:385
msgid "`relaxed-simd`"
msgstr "`relaxed-simd`"

#: src/attributes/codegen.md:385 src/attributes/codegen.md:387
msgid "`simd128`"
msgstr "`simd128`"

#: src/attributes/codegen.md:385
msgid ""
"[WebAssembly relaxed simd proposal](https://github.com/WebAssembly/relaxed-"
"simd)"
msgstr "[WebAssembly relaxed SIMD 제안](https://github.com/WebAssembly/relaxed-simd)"

#: src/attributes/codegen.md:386
msgid "`sign-ext`"
msgstr "`sign-ext`"

#: src/attributes/codegen.md:386
msgid ""
"[WebAssembly sign extension operators Proposal](https://github.com/"
"WebAssembly/sign-extension-ops)"
msgstr "[WebAssembly 부호 확장 연산자 제안(sign extension operators Proposal)](https://github.com/WebAssembly/sign-extension-ops)"

#: src/attributes/codegen.md:387
msgid "[WebAssembly simd proposal](https://github.com/webassembly/simd)"
msgstr "[WebAssembly SIMD 제안](https://github.com/webassembly/simd)"

#: src/attributes/codegen.md:388
msgid "`multivalue`"
msgstr "`multivalue`"

#: src/attributes/codegen.md:388
msgid ""
"[WebAssembly multivalue proposal](https://github.com/webassembly/multi-value)"
msgstr "[WebAssembly multivalue 제안](https://github.com/webassembly/multi-value)"

#: src/attributes/codegen.md:389
msgid "`reference-types`"
msgstr "`reference-types`"

#: src/attributes/codegen.md:389
msgid ""
"[WebAssembly reference-types proposal](https://github.com/webassembly/"
"reference-types)"
msgstr "[WebAssembly reference-types 제안](https://github.com/webassembly/reference-types)"

#: src/attributes/codegen.md:390
msgid "`tail-call`"
msgstr "`tail-call`"

#: src/attributes/codegen.md:390
msgid ""
"[WebAssembly tail-call proposal](https://github.com/webassembly/tail-call)"
msgstr "[WebAssembly tail-call 제안](https://github.com/webassembly/tail-call)"

#: src/attributes/codegen.md:405
msgid "Additional information"
msgstr "추가 정보"

#: src/attributes/codegen.md:409
msgid ""
"See the [`target_feature` conditional compilation option](../conditional-"
"compilation.md#target_feature) for selectively enabling or disabling "
"compilation of code based on compile-time settings. Note that this option is "
"not affected by the `target_feature` attribute, and is only driven by the "
"features enabled for the entire crate."
msgstr "컴파일 타임 설정에 기반하여 코드 컴파일을 선택적으로 활성화하거나 비활성화하려면 [`target_feature` 조건부 컴파일 옵션](../conditional-compilation.md#target_feature)을 참조하세요. 이 옵션은 `target_feature` 속성의 영향을 받지 않으며, 오직 크레이트 전체에 대해 활성화된 기능들에 의해서만 구동된다는 점에 유의하세요."

#: src/attributes/codegen.md:416
msgid ""
"See the [`is_x86_feature_detected`](../../std/arch/"
"macro.is_x86_feature_detected.html) or [`is_aarch64_feature_detected`](../../"
"std/arch/macro.is_aarch64_feature_detected.html) macros in the standard "
"library for runtime feature detection on these platforms."
msgstr "이러한 플랫폼에서의 런타임 기능 감지에 대해서는 표준 라이브러리의 [`is_x86_feature_detected`](../../std/arch/macro.is_x86_feature_detected.html) 또는 [`is_aarch64_feature_detected`](../../std/arch/macro.is_aarch64_feature_detected.html) 매크로를 참조하세요."

#: src/attributes/codegen.md:419
msgid ""
"Note: `rustc` has a default set of features enabled for each target and CPU. "
"The CPU may be chosen with the [`-C target-cpu`](../../rustc/codegen-options/"
"index.html#target-cpu) flag. Individual features may be enabled or disabled "
"for an entire crate with the [`-C target-feature`](../../rustc/codegen-"
"options/index.html#target-feature) flag."
msgstr "참고: `rustc`는 각 타겟 및 CPU에 대해 기본적으로 활성화된 일련의 기능들을 가지고 있습니다. CPU는 [`-C target-cpu`](../../rustc/codegen-options/index.html#target-cpu) 플래그로 선택할 수 있습니다. 개별 기능들은 [`-C target-feature`](../../rustc/codegen-options/index.html#target-feature) 플래그를 사용하여 크레이트 전체에 대해 활성화하거나 비활성화할 수 있습니다."

#: src/attributes/codegen.md:426
msgid "The `track_caller` attribute"
msgstr "`track_caller` 속성"

#: src/attributes/codegen.md:430
msgid ""
"The `track_caller` attribute may be applied to any function with [`\"Rust\"` "
"ABI](../items/external-blocks.md#abi) with the exception of the entry point "
"`fn main`."
msgstr "`track_caller` 속성은 `fn main` 엔트리 포인트를 제외하고, [`\"Rust\"` ABI](../items/external-blocks.md#abi)를 가진 모든 함수에 적용될 수 있습니다."

#: src/attributes/codegen.md:435
msgid ""
"When applied to functions and methods in trait declarations, the attribute "
"applies to all implementations. If the trait provides a default "
"implementation with the attribute, then the attribute also applies to "
"override implementations."
msgstr "트레잇 선언의 함수와 메서드에 적용될 경우, 이 속성은 모든 구현체에 적용됩니다. 만약 트레잇이 속성과 함께 기본 구현을 제공한다면, 이 속성은 오버라이드된 구현체들에도 적용됩니다."

#: src/attributes/codegen.md:440
msgid ""
"When applied to a function in an `extern` block the attribute must also be "
"applied to any linked implementations, otherwise undefined behavior results. "
"When applied to a function which is made available to an `extern` block, the "
"declaration in the `extern` block must also have the attribute, otherwise "
"undefined behavior results."
msgstr "`extern` 블록 내의 함수에 적용될 경우, 이 속성은 연결된 모든 구현체에도 반드시 적용되어야 합니다. 그렇지 않으면 정의되지 않은 동작(undefined behavior)이 발생합니다. `extern` 블록에서 사용 가능하도록 만들어진 함수에 적용될 경우, `extern` 블록 내의 선언부에도 반드시 이 속성이 있어야 합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다."

#: src/attributes/codegen.md:447
msgid "Behavior"
msgstr "동작"

#: src/attributes/codegen.md:449
msgid ""
"Applying the attribute to a function `f` allows code within `f` to get a "
"hint of the [`Location`](../../core/panic/location/struct.Location.html) of "
"the \"topmost\" tracked call that led to `f`'s invocation. At the point of "
"observation, an implementation behaves as if it walks up the stack from "
"`f`'s frame to find the nearest frame of an _unattributed_ function `outer`, "
"and it returns the [`Location`](../../core/panic/location/"
"struct.Location.html) of the tracked call in `outer`."
msgstr "함수 `f`에 이 속성을 적용하면 `f` 내부의 코드가 `f`를 호출하게 만든 \"최상위\" 추적 호출의 [`Location`](../../core/panic/location/struct.Location.html) 힌트를 얻을 수 있게 됩니다. 관찰 시점에, 구현체는 `f`의 프레임에서 스택을 거슬러 올라가 속성이 붙지 않은 가장 가까운 함수 `outer`의 프레임을 찾고, `outer`에서의 추적된 호출 위치([`Location`](../../core/panic/location/struct.Location.html))를 반환하는 것처럼 동작합니다."

#: src/attributes/codegen.md:461
msgid ""
"Note: `core` provides [`core::panic::Location::caller`](../../core/panic/"
"location/struct.Location.html#method.caller) for observing caller locations. "
"It wraps the [`core::intrinsics::caller_location`](../../core/intrinsics/"
"fn.caller_location.html) intrinsic implemented by `rustc`."
msgstr "참고: `core`는 호출자의 위치를 관찰하기 위해 [`core::panic::Location::caller`](../../core/panic/location/struct.Location.html#method.caller)를 제공합니다. 이는 `rustc`에 의해 구현된 [`core::intrinsics::caller_location`](../../core/intrinsics/fn.caller_location.html) 내장(intrinsic) 기능을 감싸고 있습니다."

#: src/attributes/codegen.md:464
msgid ""
"Note: because the resulting `Location` is a hint, an implementation may halt "
"its walk up the stack early. See [Limitations](#limitations) for important "
"caveats."
msgstr "참고: 결과로 나오는 `Location`은 힌트이므로, 구현체는 스택을 거슬러 올라가는 과정을 일찍 중단할 수 있습니다. 중요한 주의 사항에 대해서는 [제한 사항](#limitations)을 참조하세요."

#: src/attributes/codegen.md:469
msgid ""
"When `f` is called directly by `calls_f`, code in `f` observes its callsite "
"within `calls_f`:"
msgstr "`f`가 `calls_f`에 의해 직접 호출될 때, `f` 내부의 코드는 `calls_f` 내의 호출 지점(callsite)을 관찰합니다."

#: src/attributes/codegen.md:477
msgid "// <-- f() prints this location\n"
msgstr "// <-- f()가 이 위치를 출력함\n"

#: src/attributes/codegen.md:481
msgid ""
"When `f` is called by another attributed function `g` which is in turn "
"called by `calls_g`, code in both `f` and `g` observes `g`'s callsite within "
"`calls_g`:"
msgstr "`f`가 속성이 붙은 다른 함수 `g`에 의해 호출되고, `g`가 다시 `calls_g`에 의해 호출될 때, `f`와 `g` 모두의 코드는 `calls_g` 내의 `g` 호출 지점을 관찰합니다."

#: src/attributes/codegen.md:496
msgid "// <-- g() prints this location twice, once itself and once from f()\n"
msgstr "// <-- g()가 이 위치를 두 번 출력함 (한 번은 자기 자신, 한 번은 f()로부터)\n"

#: src/attributes/codegen.md:500
msgid ""
"When `g` is called by another attributed function `h` which is in turn "
"called by `calls_h`, all code in `f`, `g`, and `h` observes `h`'s callsite "
"within `calls_h`:"
msgstr "`g`가 속성이 붙은 다른 함수 `h`에 의해 호출되고, `h`가 다시 `calls_h`에 의해 호출될 때, `f`, `g`, `h` 내부의 모든 코드는 `calls_h` 내의 `h` 호출 지점을 관찰합니다."

#: src/attributes/codegen.md:520
msgid ""
"// <-- prints this location three times, once itself, once from g(), once "
"from f()\n"
msgstr "// <-- 이 위치를 세 번 출력함 (한 번은 자기 자신, 한 번은 g()로부터, 한 번은 f()로부터)\n"

#: src/attributes/codegen.md:524
msgid "And so on."
msgstr "기타 등등."

#: src/attributes/codegen.md:528 src/types/impl-trait.md:198
msgid "Limitations"
msgstr "제한 사항"

#: src/attributes/codegen.md:532
msgid ""
"This information is a hint and implementations are not required to preserve "
"it."
msgstr "이 정보는 힌트일 뿐이며 구현체가 이를 반드시 보존해야 할 요구 사항은 없습니다."

#: src/attributes/codegen.md:536
msgid ""
"In particular, coercing a function with `#[track_caller]` to a function "
"pointer creates a shim which appears to observers to have been called at the "
"attributed function's definition site, losing actual caller information "
"across virtual calls. A common example of this coercion is the creation of a "
"trait object whose methods are attributed."
msgstr "특히, `#[track_caller]`가 붙은 함수를 함수 포인터로 강제 변환하면 심(shim)이 생성됩니다. 이 심은 관찰자에게 해당 함수가 정의된 위치에서 호출된 것처럼 보이게 하여, 가상 호출(virtual calls) 시 실제 호출자 정보를 잃게 만듭니다. 이러한 강제 변환의 흔한 예시는 메서드에 속성이 붙은 트레잇 객체를 생성하는 경우입니다."

#: src/attributes/codegen.md:541
msgid ""
"Note: The aforementioned shim for function pointers is necessary because "
"`rustc` implements `track_caller` in a codegen context by appending an "
"implicit parameter to the function ABI, but this would be unsound for an "
"indirect call because the parameter is not a part of the function's type and "
"a given function pointer type may or may not refer to a function with the "
"attribute. The creation of a shim hides the implicit parameter from callers "
"of the function pointer, preserving soundness."
msgstr "참고: 앞서 언급한 함수 포인터를 위한 심(shim)이 필요한 이유는, `rustc`가 함수 ABI에 암시적 매개변수를 추가함으로써 코드 생성 컨텍스트에서 `track_caller`를 구현하기 때문입니다. 하지만 이는 간접 호출(indirect call)의 경우 불안정할 수 있는데, 해당 매개변수가 함수의 타입의 일부가 아니며 주어진 함수 포인터 타입이 속성이 있는 함수를 참조할 수도 있고 아닐 수도 있기 때문입니다. 심을 생성함으로써 함수 포인터 호출자로부터 암시적 매개변수를 숨겨서 안정성을 유지합니다."

#: src/attributes/codegen.md:565
msgid "The `instruction_set` attribute"
msgstr "`instruction_set` 속성"

#: src/attributes/codegen.md:569
msgid ""
"The _`instruction_set` [attribute](../attributes.md)_ may be applied to a "
"function to control which instruction set the function will be generated for."
msgstr "_`instruction_set` [속성](../attributes.md)_은 해당 함수가 어떤 명령어 집합(instruction set)으로 생성될지를 제어하기 위해 함수에 적용될 수 있습니다."

#: src/attributes/codegen.md:573
msgid ""
"This allows mixing more than one instruction set in a single program on CPU "
"architectures that support it."
msgstr "이를 통해 이를 지원하는 CPU 아키텍처에서 단일 프로그램 내에 하나 이상의 명령어 집합을 혼용할 수 있습니다."

#: src/attributes/codegen.md:577
msgid ""
"It uses the [_MetaListPath_](../attributes.md#meta-item-attribute-syntax) "
"syntax, and a path comprised of the architecture family name and instruction "
"set name."
msgstr "이 속성은 [_MetaListPath_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하며, 아키텍처 계열 이름과 명령어 집합 이름으로 구성된 경로를 인수로 받습니다."

#: src/attributes/codegen.md:583
msgid ""
"It is a compilation error to use the `instruction_set` attribute on a target "
"that does not support it."
msgstr "지원을 하지 않는 타겟에서 `instruction_set` 속성을 사용하는 것은 컴파일 에러입니다."

#: src/attributes/codegen.md:587
msgid "On ARM"
msgstr "ARM에서"

#: src/attributes/codegen.md:590
msgid ""
"For the `ARMv4T` and `ARMv5te` architectures, the following are supported:"
msgstr "`ARMv4T` 및 `ARMv5te` 아키텍처의 경우, 다음이 지원됩니다:"

#: src/attributes/codegen.md:591
msgid "`arm::a32` --- Generate the function as A32 \"ARM\" code."
msgstr "`arm::a32` --- 함수를 A32 \"ARM\" 코드로 생성합니다."

#: src/attributes/codegen.md:592
msgid "`arm::t32` --- Generate the function as T32 \"Thumb\" code."
msgstr "`arm::t32` --- 함수를 T32 \"Thumb\" 코드로 생성합니다."

#: src/attributes/codegen.md:603
msgid "Using the `instruction_set` attribute has the following effects:"
msgstr "`instruction_set` 속성을 사용하는 것은 다음과 같은 효과를 가집니다:"

#: src/attributes/codegen.md:605
msgid ""
"If the address of the function is taken as a function pointer, the low bit "
"of the address will be set to 0 (arm) or 1 (thumb) depending on the "
"instruction set."
msgstr "함수의 주소를 함수 포인터로 취하는 경우, 명령어 집합에 따라 주소의 하위 비트가 0(arm) 또는 1(thumb)로 설정됩니다."

#: src/attributes/codegen.md:606
msgid ""
"Any inline assembly in the function must use the specified instruction set "
"instead of the target default."
msgstr "함수 내의 모든 인라인 어셈블리는 타겟 기본값 대신 지정된 명령어 집합을 사용해야 합니다."

#: src/attributes/limits.md:6
msgid ""
"The following [attributes](../attributes.md) affect compile-time limits."
msgstr "다음 [속성들](../attributes.md)은 컴파일 타임 제한에 영향을 줍니다."

#: src/attributes/limits.md:10
msgid "The `recursion_limit` attribute"
msgstr "`recursion_limit` 속성"

#: src/attributes/limits.md:14
msgid ""
"The _`recursion_limit` attribute_ may be applied at the [crate](../crates-"
"and-source-files.md) level to set the maximum depth for potentially "
"infinitely-recursive compile-time operations like macro expansion or auto-"
"dereference."
msgstr "_`recursion_limit` 속성_은 매크로 확장이나 자동 역참조(auto-dereference)와 같이 잠재적으로 무한히 재귀적인 컴파일 타임 연산의 최대 깊이를 설정하기 위해 [크레이트](../crates-and-source-files.md) 레벨에 적용될 수 있습니다."

#: src/attributes/limits.md:20
msgid ""
"It uses the [_MetaNameValueStr_](../attributes.md#meta-item-attribute-"
"syntax) syntax to specify the recursion depth."
msgstr "이 속성은 재귀 깊이를 지정하기 위해 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/attributes/limits.md:23
msgid "Note: The default in `rustc` is 128."
msgstr "참고: `rustc`의 기본값은 128입니다."

#: src/attributes/limits.md:26 src/attributes/limits.md:69
msgid "\"4\""
msgstr "\"4\""

#: src/attributes/limits.md:35
msgid ""
"// This fails to expand because it requires a recursion depth greater than "
"4.\n"
msgstr "// 이는 4보다 큰 재귀 깊이를 요구하므로 확장에 실패합니다.\n"

#: src/attributes/limits.md:41 src/destructors.md:183
msgid "\"1\""
msgstr "\"1\""

#: src/attributes/limits.md:42
msgid ""
"// This fails because it requires two recursive steps to auto-dereference.\n"
msgstr "// 이는 자동 역참조를 위해 두 번의 재귀 단계가 필요하므로 실패합니다.\n"

#: src/attributes/limits.md:49
msgid "The `type_length_limit` attribute"
msgstr "`type_length_limit` 속성"

#: src/attributes/limits.md:52
msgid ""
"**Note**: This limit is only enforced when the nightly `-Zenforce-type-"
"length-limit` flag is active."
msgstr "**참고**: 이 제한은 나이틀리(nightly) `-Zenforce-type-length-limit` 플래그가 활성화된 경우에만 적용됩니다."

#: src/attributes/limits.md:54
msgid ""
"For more information, see <https://github.com/rust-lang/rust/pull/127670>."
msgstr "자세한 내용은 <https://github.com/rust-lang/rust/pull/127670>을 참조하세요."

#: src/attributes/limits.md:58
msgid ""
"The _`type_length_limit` attribute_ limits the maximum number of type "
"substitutions made when constructing a concrete type during monomorphization."
msgstr "_`type_length_limit` 속성_은 모노모르포화 과정에서 구체적인 타입을 생성할 때 수행되는 타입 치환(type substitutions)의 최대 횟수를 제한합니다."

#: src/attributes/limits.md:63
msgid ""
"It is applied at the [crate](../crates-and-source-files.md) level, and uses "
"the [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) syntax "
"to set the limit based on the number of type substitutions."
msgstr "이 속성은 [크레이트](../crates-and-source-files.md) 레벨에 적용되며, 타입 치환 횟수에 기반하여 제한을 설정하기 위해 [_MetaNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/attributes/limits.md:66
msgid "Note: The default in `rustc` is 1048576."
msgstr "참고: `rustc`의 기본값은 1048576입니다."

#: src/attributes/limits.md:72
msgid ""
"// This fails to compile because monomorphizing to\n"
"// `f::<((((i32,), i32), i32), i32)>` requires more than 4 type elements.\n"
msgstr ""
"// 이는 `f::<((((i32,), i32), i32), i32)>`로 모노모르포화하는 데 4개 이상의 타입\n"
"// 요소가 필요하므로 컴파일에 실패합니다.\n"

#: src/attributes/type_system.md:3
msgid "Type system attributes"
msgstr "타입 시스템 속성"

#: src/attributes/type_system.md:5
msgid ""
"The following [attributes](../attributes.md) are used for changing how a "
"type can be used."
msgstr "다음 [속성들](../attributes.md)은 타입이 사용되는 방식을 변경하는 데 사용됩니다."

#: src/attributes/type_system.md:9
msgid "The `non_exhaustive` attribute"
msgstr "`non_exhaustive` 속성"

#: src/attributes/type_system.md:13
msgid ""
"The _`non_exhaustive` attribute_ indicates that a type or variant may have "
"more fields or variants added in the future."
msgstr "_`non_exhaustive` 속성_은 타입이나 변형에 미래에 더 많은 필드나 변형이 추가될 수 있음을 나타냅니다."

#: src/attributes/type_system.md:18
msgid ""
"It can be applied to [`struct`s](../items/structs.md), [`enum`s](../items/"
"enumerations.md), and `enum` variants."
msgstr "이 속성은 [구조체](../items/structs.md), [열거형](../items/enumerations.md), 그리고 열거형 변형에 적용될 수 있습니다."

#: src/attributes/type_system.md:22
msgid ""
"The `non_exhaustive` attribute uses the [_MetaWord_](../attributes.md#meta-"
"item-attribute-syntax) syntax and thus does not take any inputs."
msgstr "`non_exhaustive` 속성은 [_MetaWord_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하며, 따라서 어떠한 입력도 받지 않습니다."

#: src/attributes/type_system.md:27
msgid "Within the defining crate, `non_exhaustive` has no effect."
msgstr "정의하는 크레이트 내에서 `non_exhaustive`는 아무런 효과가 없습니다."

#: src/attributes/type_system.md:53
msgid ""
"// Non-exhaustive structs can be constructed as normal within the defining "
"crate.\n"
msgstr "// 비완전(non-exhaustive) 구조체는 정의하는 크레이트 내에서 평소와 같이 생성될 수 있습니다.\n"

#: src/attributes/type_system.md:58
msgid ""
"// Non-exhaustive structs can be matched on exhaustively within the defining "
"crate.\n"
msgstr "// 비완전 구조체는 정의하는 크레이트 내에서 완전하게(exhaustively) 매칭될 수 있습니다.\n"

#: src/attributes/type_system.md:66
msgid ""
"// Non-exhaustive enums can be matched on exhaustively within the defining "
"crate.\n"
msgstr "// 비완전 열거형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.\n"

#: src/attributes/type_system.md:74
msgid ""
"// Non-exhaustive variants can be matched on exhaustively within the "
"defining crate.\n"
msgstr "// 비완전 변형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.\n"

#: src/attributes/type_system.md:83
msgid ""
"Outside of the defining crate, types annotated with `non_exhaustive` have "
"limitations that preserve backwards compatibility when new fields or "
"variants are added."
msgstr "정의하는 크레이트 외부에서, `non_exhaustive`가 주석 처리된 타입은 새로운 필드나 변형이 추가될 때 하위 호환성을 유지하기 위한 제약 사항을 가집니다."

#: src/attributes/type_system.md:88
msgid ""
"Non-exhaustive types cannot be constructed outside of the defining crate:"
msgstr "비완전 타입은 정의하는 크레이트 외부에서 생성될 수 없습니다."

#: src/attributes/type_system.md:90
msgid ""
"Non-exhaustive variants ([`struct`](../items/structs.md) or [`enum` variant]"
"(../items/enumerations.md)) cannot be constructed with a [_StructExpression_]"
"(../expressions/struct-expr.md) (including with [functional update syntax]"
"(../expressions/struct-expr.md#functional-update-syntax))."
msgstr "비완전 변형([구조체](../items/structs.md) 또는 [열거형 변형](../items/enumerations.md))은 [_구조체표현식_](../expressions/struct-expr.md)([함수형 업데이트 구문](../expressions/struct-expr.md#functional-update-syntax) 포함)으로 생성될 수 없습니다."

#: src/attributes/type_system.md:92
msgid ""
"The implicitly defined same-named constant of a [unit-like struct](../items/"
"structs.md), or the same-named constructor function of a [tuple struct](../"
"items/structs.md), has a [visibility](../visibility-and-privacy.md) no "
"greater than `pub(crate)`. That is, if the struct’s visibility is `pub`, "
"then the constant or constructor’s visibility is `pub(crate)`, and otherwise "
"the visibility of the two items is the same (as is the case without "
"`#[non_exhaustive]`)."
msgstr "[유닛 유사 구조체](../items/structs.md)의 암시적으로 정의된 동일 이름의 상수나, [튜플 구조체](../items/structs.md)의 동일 이름의 생성자 함수는 `pub(crate)`보다 크지 않은 [가시성](../visibility-and-privacy.md)을 가집니다. 즉, 구조체의 가시성이 `pub`인 경우 상수나 생성자의 가시성은 `pub(crate)`가 되며, 그 외의 경우 두 아이템의 가시성은 동일합니다 (`#[non_exhaustive]`가 없는 경우와 같습니다)."

#: src/attributes/type_system.md:98
msgid "[`enum`](../items/enumerations.md) instances can be constructed."
msgstr "[`열거형(enum)`](../items/enumerations.md) 인스턴스는 생성될 수 있습니다."

#: src/attributes/type_system.md:100
msgid ""
"The following examples of construction do not compile when outside the "
"defining crate:"
msgstr "정의하는 크레이트 외부에서는 다음과 같은 생성 예시들이 컴파일되지 않습니다."

#: src/attributes/type_system.md:104 src/attributes/type_system.md:153
msgid ""
"// These are types defined in an upstream crate that have been annotated as\n"
"// `#[non_exhaustive]`.\n"
msgstr "// 이들은 업스트림 크레이트에서 `#[non_exhaustive]`가 주석 처리된 상태로 정의된 타입들입니다.\n"

#: src/attributes/type_system.md:107
msgid ""
"// Cannot construct an instance of `Config`; if new fields were added in\n"
"// a new version of `upstream` then this would fail to compile, so it is\n"
"// disallowed.\n"
msgstr ""
"// `Config` 인스턴스를 생성할 수 없습니다. 만약 업스트림의 새로운 버전에서\n"
"// 새로운 필드가 추가된다면 컴파일에 실패할 것이므로, 이를 불허합니다.\n"

#: src/attributes/type_system.md:112
msgid ""
"// Cannot construct an instance of `Token`; if new fields were added, then\n"
"// it would not be a unit-like struct any more, so the same-named constant\n"
"// created by it being a unit-like struct is not public outside the crate;\n"
"// this code fails to compile.\n"
msgstr ""
"// `Token` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면\n"
"// 더 이상 유닛 유사 구조체가 아닐 것이므로, 유닛 유사 구조체로서 생성된\n"
"// 동일 이름의 상수는 크레이트 외부에서 공개되지 않습니다.\n"
"// 이 코드는 컴파일에 실패합니다.\n"

#: src/attributes/type_system.md:118
msgid ""
"// Cannot construct an instance of `Id`; if new fields were added, then\n"
"// its constructor function signature would change, so its constructor\n"
"// function is not public outside the crate; this code fails to compile.\n"
msgstr ""
"// `Id` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면\n"
"// 생성자 함수의 시그니처가 변경될 것이므로, 생성자 함수가 크레이트 외부에서\n"
"// 공개되지 않습니다. 이 코드는 컴파일에 실패합니다.\n"

#: src/attributes/type_system.md:123
msgid ""
"// Can construct an instance of `Error`; new variants being introduced "
"would\n"
"// not result in this failing to compile.\n"
msgstr ""
"// `Error` 인스턴스는 생성할 수 있습니다. 새로운 변형이 도입되더라도\n"
"// 이 코드가 컴파일에 실패하는 결과로 이어지지는 않기 때문입니다.\n"

#: src/attributes/type_system.md:127
msgid ""
"// Cannot construct an instance of `Message::Send` or `Message::Reaction`;\n"
"// if new fields were added in a new version of `upstream` then this would\n"
"// fail to compile, so it is disallowed.\n"
msgstr ""
"// `Message::Send` 또는 `Message::Reaction` 인스턴스를 생성할 수 없습니다.\n"
"// 만약 업스트림의 새로운 버전에서 새로운 필드가 추가된다면\n"
"// 컴파일에 실패할 것이므로, 이를 불허합니다.\n"

#: src/attributes/type_system.md:133
msgid ""
"// Cannot construct an instance of `Message::Quit`; if this were converted "
"to\n"
"// a tuple-variant `upstream` then this would fail to compile.\n"
msgstr ""
"// `Message::Quit` 인스턴스를 생성할 수 없습니다. 만약 업스트림에서\n"
"// 이를 튜플 변형으로 변환한다면 컴파일에 실패할 것이기 때문입니다.\n"

#: src/attributes/type_system.md:141
msgid ""
"There are limitations when matching on non-exhaustive types outside of the "
"defining crate:"
msgstr "정의하는 크레이트 외부에서 비완전 타입을 매칭할 때 다음과 같은 제약 사항이 있습니다."

#: src/attributes/type_system.md:143
msgid ""
"When pattern matching on a non-exhaustive variant ([`struct`](../items/"
"structs.md) or [`enum` variant](../items/enumerations.md)), a "
"[_StructPattern_](../patterns.md#struct-patterns) must be used which must "
"include a `..`. A tuple variant's constructor's [visibility](../visibility-"
"and-privacy.md) is reduced to be no greater than `pub(crate)`."
msgstr "비완전 변형([구조체](../items/structs.md) 또는 [열거형 변형](../items/enumerations.md))에 대해 패턴 매칭을 할 때, 반드시 `..`을 포함하는 [_구조체패턴_](../patterns.md#struct-patterns)을 사용해야 합니다. 튜플 변형 생성자의 [가시성](../visibility-and-privacy.md)은 `pub(crate)`보다 크지 않도록 축소됩니다."

#: src/attributes/type_system.md:146
msgid ""
"When pattern matching on a non-exhaustive [`enum`](../items/"
"enumerations.md), matching on a variant does not contribute towards the "
"exhaustiveness of the arms."
msgstr "비완전 [`열거형(enum)`](../items/enumerations.md)에 대해 패턴 매칭을 할 때, 특정 변형에 대해 매치하는 것은 매치 암(arms)의 완전성(exhaustiveness)에 기여하지 않습니다."

#: src/attributes/type_system.md:149
msgid ""
"The following examples of matching do not compile when outside the defining "
"crate:"
msgstr "정의하는 크레이트 외부에서는 다음과 같은 매칭 예시들이 컴파일되지 않습니다."

#: src/attributes/type_system.md:156
msgid ""
"// Cannot match on a non-exhaustive enum without including a wildcard arm.\n"
msgstr "// 와일드카드 암(arm)을 포함하지 않고는 비완전 열거형을 매칭할 수 없습니다.\n"

#: src/attributes/type_system.md:161
msgid "// would compile with: `_ => {},`\n"
msgstr "// `_ => {},`를 추가하면 컴파일됩니다.\n"

#: src/attributes/type_system.md:163
msgid "// Cannot match on a non-exhaustive struct without a wildcard.\n"
msgstr "// 와일드카드 없이 비완전 구조체를 매칭할 수 없습니다.\n"

#: src/attributes/type_system.md:166
msgid "// would compile with: `..`\n"
msgstr "// `..`을 추가하면 컴파일됩니다.\n"

#: src/attributes/type_system.md:168
msgid ""
"// Cannot match a non-exhaustive unit-like or tuple struct except by using\n"
"// braced struct syntax with a wildcard.\n"
"// This would compile as `let Token { .. } = token;`\n"
msgstr ""
"// 중괄호 구조체 구문과 와일드카드를 사용하지 않고는 비완전 유닛 유사 또는 튜플 구조체를 매칭할 수 없습니다.\n"
"// 이는 `let Token { .. } = token;`으로 작성해야 컴파일됩니다.\n"

#: src/attributes/type_system.md:172
msgid "// This would compile as `let Id { 0: id_number, .. } = id;`\n"
msgstr "// 이는 `let Id { 0: id_number, .. } = id;`로 작성해야 컴파일됩니다.\n"

#: src/attributes/type_system.md:177
msgid ""
"// Cannot match on a non-exhaustive struct enum variant without including a "
"wildcard.\n"
msgstr "// 와일드카드를 포함하지 않고는 비완전 구조체형 열거형 변형을 매칭할 수 없습니다.\n"

#: src/attributes/type_system.md:179
msgid "// Cannot match on a non-exhaustive tuple or unit enum variant.\n"
msgstr "// 비완전 튜플형 또는 유닛형 열거형 변형은 매칭할 수 없습니다.\n"

#: src/attributes/type_system.md:185
msgid ""
"It's also not allowed to use numeric casts (`as`) on enums that contain any "
"non-exhaustive variants."
msgstr "또한 하나 이상의 비완전 변형을 포함하는 열거형에 대해서는 숫자 캐스팅(`as`)을 사용하는 것이 허용되지 않습니다."

#: src/attributes/type_system.md:187
msgid ""
"For example, the following enum can be cast because it doesn't contain any "
"non-exhaustive variants:"
msgstr "예를 들어, 다음 열거형은 비완전 변형을 포함하지 않으므로 캐스팅할 수 있습니다."

#: src/attributes/type_system.md:197
msgid ""
"However, if the enum contains even a single non-exhaustive variant, casting "
"will result in an error. Consider this modified version of the same enum:"
msgstr "하지만 열거형이 단 하나의 비완전 변형이라도 포함하고 있다면, 캐스팅은 에러가 됩니다. 동일한 열거형의 수정된 버전을 고려해 보세요."

#: src/attributes/type_system.md:211
msgid ""
"// Error: cannot cast an enum with a non-exhaustive variant when it's "
"defined in another crate\n"
msgstr "// 에러: 다른 크레이트에 정의된 비완전 변형을 가진 열거형은 캐스팅할 수 없습니다.\n"

#: src/attributes/type_system.md:216
msgid ""
"Non-exhaustive types are always considered inhabited in downstream crates."
msgstr "비완전 타입은 다운스트림 크레이트에서 항상 거주하는(inhabited) 타입으로 간주됩니다."

#: src/attributes/debugger.md:3
msgid "Debugger attributes"
msgstr "디버거 속성"

#: src/attributes/debugger.md:6
msgid ""
"The following [attributes](../attributes.md) are used for enhancing the "
"debugging experience when using third-party debuggers like GDB or WinDbg."
msgstr "다음 [속성들](../attributes.md)은 GDB나 WinDbg와 같은 서드파티 디버거를 사용할 때 디버깅 경험을 향상시키기 위해 사용됩니다."

#: src/attributes/debugger.md:10
msgid "The `debugger_visualizer` attribute"
msgstr "`debugger_visualizer` 속성"

#: src/attributes/debugger.md:14
msgid ""
"The _`debugger_visualizer` attribute_ can be used to embed a debugger "
"visualizer file into the debug information. This enables an improved "
"debugger experience for displaying values in the debugger."
msgstr "_`debugger_visualizer` 속성_은 디버거 시각화 도구 파일을 디버그 정보에 포함시키는 데 사용될 수 있습니다. 이를 통해 디버거에서 값을 표시할 때 더 나은 디버깅 경험을 제공합니다."

#: src/attributes/debugger.md:19
msgid ""
"It uses the [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-"
"syntax) syntax to specify its inputs, and must be specified as a crate "
"attribute."
msgstr "이 속성은 입력을 지정하기 위해 [_MetaListNameValueStr_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하며, 크레이트 속성으로 지정되어야 합니다."

#: src/attributes/debugger.md:23
msgid "Using `debugger_visualizer` with Natvis"
msgstr "Natvis와 함께 `debugger_visualizer` 사용하기"

#: src/attributes/debugger.md:27
msgid ""
"Natvis is an XML-based framework for Microsoft debuggers (such as Visual "
"Studio and WinDbg) that uses declarative rules to customize the display of "
"types. For detailed information on the Natvis format, refer to Microsoft's "
"[Natvis documentation](https://docs.microsoft.com/en-us/visualstudio/"
"debugger/create-custom-views-of-native-objects)."
msgstr "Natvis는 타입 표시를 사용자 정의하기 위해 선언적 규칙을 사용하는 Microsoft 디버거(예: Visual Studio 및 WinDbg)를 위한 XML 기반 프레임워크입니다. Natvis 형식에 대한 자세한 내용은 Microsoft의 [Natvis 문서](https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects)를 참조하세요."

#: src/attributes/debugger.md:32
msgid ""
"This attribute only supports embedding Natvis files on `-windows-msvc` "
"targets."
msgstr "이 속성은 `-windows-msvc` 타겟에서만 Natvis 파일 포함을 지원합니다."

#: src/attributes/debugger.md:36
msgid ""
"The path to the Natvis file is specified with the `natvis_file` key, which "
"is a path relative to the crate source file:"
msgstr "Natvis 파일의 경로는 `natvis_file` 키로 지정하며, 크레이트 소스 파일에 대한 상대 경로입니다."

#: src/attributes/debugger.md:39
msgid ""
"```rust ignore\n"
"#![debugger_visualizer(natvis_file = \"Rectangle.natvis\")]\n"
"\n"
"struct FancyRect {\n"
"    x: f32,\n"
"    y: f32,\n"
"    dx: f32,\n"
"    dy: f32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 };\n"
"    println!(\"set breakpoint here\");\n"
"}\n"
"```"
msgstr ""
"```rust ignore\n"
"#![debugger_visualizer(natvis_file = \"Rectangle.natvis\")]\n"
"\n"
"struct FancyRect {\n"
"    x: f32,\n"
"    y: f32,\n"
"    dx: f32,\n"
"    dy: f32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 };\n"
"    println!(\"set breakpoint here\");\n"
"}\n"
"```"

#: src/attributes/debugger.md:55
msgid "and `Rectangle.natvis` contains:"
msgstr "그리고 `Rectangle.natvis`는 다음을 포함합니다:"

#: src/attributes/debugger.md:58
msgid "\"1.0\""
msgstr "\"1.0\""

#: src/attributes/debugger.md:58
msgid "\"utf-8\""
msgstr "\"utf-8\""

#: src/attributes/debugger.md:59
msgid "\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\""
msgstr "\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\""

#: src/attributes/debugger.md:60
msgid "\"foo::FancyRect\""
msgstr "\"foo::FancyRect\""

#: src/attributes/debugger.md:63
msgid "\"LowerLeft\""
msgstr "\"LowerLeft\""

#: src/attributes/debugger.md:66
msgid "\"UpperLeft\""
msgstr "\"UpperLeft\""

#: src/attributes/debugger.md:69
msgid "\"UpperRight\""
msgstr "\"UpperRight\""

#: src/attributes/debugger.md:72
msgid "\"LowerRight\""
msgstr "\"LowerRight\""

#: src/attributes/debugger.md:80
msgid ""
"When viewed under WinDbg, the `fancy_rect` variable would be shown as "
"follows:"
msgstr "WinDbg에서 볼 때, `fancy_rect` 변수는 다음과 같이 표시될 것입니다:"

#: src/attributes/debugger.md:93
msgid "Using `debugger_visualizer` with GDB"
msgstr "GDB와 함께 `debugger_visualizer` 사용하기"

#: src/attributes/debugger.md:97
msgid ""
"GDB supports the use of a structured Python script, called a _pretty "
"printer_, that describes how a type should be visualized in the debugger "
"view. For detailed information on pretty printers, refer to GDB's [pretty "
"printing documentation](https://sourceware.org/gdb/onlinedocs/gdb/Pretty-"
"Printing.html)."
msgstr "GDB는 타입이 디버거 뷰에서 시각화되는 방식을 설명하는 _프리티 프린터(pretty printer)_라고 불리는 구조화된 파이썬 스크립트의 사용을 지원합니다. 프리티 프린터에 대한 자세한 내용은 GDB의 [프리티 프린팅 문서](https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html)를 참조하세요."

#: src/attributes/debugger.md:100
msgid ""
"Embedded pretty printers are not automatically loaded when debugging a "
"binary under GDB. There are two ways to enable auto-loading embedded pretty "
"printers:"
msgstr "임베디드 프리티 프린터는 GDB에서 바이너리를 디버깅할 때 자동으로 로드되지 않습니다. 임베디드 프리티 프린터의 자동 로드를 활성화하는 두 가지 방법이 있습니다."

#: src/attributes/debugger.md:102
msgid ""
"Launch GDB with extra arguments to explicitly add a directory or binary to "
"the auto-load safe path: `gdb -iex \"add-auto-load-safe-path safe-path path/"
"to/binary\" path/to/binary` For more information, see GDB's [auto-loading "
"documentation](https://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-"
"safe-path.html)."
msgstr "자동 로드 안전 경로에 디렉터리나 바이너리를 명시적으로 추가하기 위해 추가 인수를 사용하여 GDB를 실행합니다: `gdb -iex \"add-auto-load-safe-path safe-path path/to/binary\" path/to/binary`. 자세한 내용은 GDB의 [자동 로드 문서](https://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-safe-path.html)를 참조하세요."

#: src/attributes/debugger.md:104
msgid ""
"Create a file named `gdbinit` under `$HOME/.config/gdb` (you may need to "
"create the directory if it doesn't already exist). Add the following line to "
"that file: `add-auto-load-safe-path path/to/binary`."
msgstr "`$HOME/.config/gdb` 아래에 `gdbinit`이라는 파일을 생성합니다(디렉터리가 없으면 생성해야 할 수도 있습니다). 해당 파일에 다음 라인을 추가합니다: `add-auto-load-safe-path path/to/binary`."

#: src/attributes/debugger.md:108
msgid ""
"These scripts are embedded using the `gdb_script_file` key, which is a path "
"relative to the crate source file."
msgstr "이러한 스크립트들은 `gdb_script_file` 키를 사용하여 포함되며, 크레이트 소스 파일에 대한 상대 경로입니다."

#: src/attributes/debugger.md:111
msgid ""
"```rust ignore\n"
"#![debugger_visualizer(gdb_script_file = \"printer.py\")]\n"
"\n"
"struct Person {\n"
"    name: String,\n"
"    age: i32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = Person { name: String::from(\"Bob\"), age: 10 };\n"
"    println!(\"set breakpoint here\");\n"
"}\n"
"```"
msgstr ""
"```rust ignore\n"
"#![debugger_visualizer(gdb_script_file = \"printer.py\")]\n"
"\n"
"struct Person {\n"
"    name: String,\n"
"    age: i32,\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = Person { name: String::from(\"Bob\"), age: 10 };\n"
"    println!(\"set breakpoint here\");\n"
"}\n"
"```"

#: src/attributes/debugger.md:125
msgid "and `printer.py` contains:"
msgstr "그리고 `printer.py`는 다음을 포함합니다:"

#: src/attributes/debugger.md:131
msgid "\"Print a Person\""
msgstr "\"Person 출력\""

#: src/attributes/debugger.md:135
msgid "\"name\""
msgstr "\"이름\""

#: src/attributes/debugger.md:136
msgid "\"age\""
msgstr "\"나이\""

#: src/attributes/debugger.md:139
msgid "\"{} is {} years old.\""
msgstr "\"{}는 {}살입니다.\""

#: src/attributes/debugger.md:145
msgid "\"foo::Person\""
msgstr "\"foo::Person\""

#: src/attributes/debugger.md:153
msgid ""
"When the crate's debug executable is passed into GDB[^rust-gdb], `print bob` "
"will display:"
msgstr "크레이트의 디버그 실행 파일이 GDB[^rust-gdb]로 전달되면, `print bob`은 다음과 같이 표시될 것입니다:"

#: src/attributes/debugger.md:155
msgid ""
"```text\n"
"\"Bob\" is 10 years old.\n"
"```"
msgstr ""
"```text\n"
"\"Bob\" is 10 years old.\n"
"```"

#: src/attributes/debugger.md:159
msgid ""
"Note: This assumes you are using the `rust-gdb` script which configures "
"pretty-printers for standard library types like `String`."
msgstr "참고: 이는 `String`과 같은 표준 라이브러리 타입에 대해 프리티 프린터를 구성하는 `rust-gdb` 스크립트를 사용하고 있다고 가정합니다."

#: src/attributes/debugger.md:169
msgid "The `collapse_debuginfo` attribute"
msgstr "`collapse_debuginfo` 속성"

#: src/attributes/debugger.md:173
msgid ""
"The _`collapse_debuginfo` [attribute](../attributes.md)_ controls whether "
"code locations from a macro definition are collapsed into a single location "
"associated with the macro's call site, when generating debuginfo for code "
"calling this macro."
msgstr "_`collapse_debuginfo` [속성](../attributes.md)_은 해당 매크로를 호출하는 코드에 대한 디버그 정보를 생성할 때, 매크로 정의로부터의 코드 위치들을 매크로 호출 지점과 연관된 단일 위치로 축소할지 여부를 제어합니다."

#: src/attributes/debugger.md:178
msgid ""
"The attribute uses the [_MetaListIdents_](../attributes.md#meta-item-"
"attribute-syntax) syntax to specify its inputs, and can only be applied to "
"macro definitions."
msgstr "이 속성은 입력을 지정하기 위해 [_MetaListIdents_](../attributes.md#meta-item-attribute-syntax) 구문을 사용하며, 오직 매크로 정의에만 적용될 수 있습니다."

#: src/attributes/debugger.md:182
msgid "Accepted options:"
msgstr "허용되는 옵션:"

#: src/attributes/debugger.md:183
msgid ""
"`#[collapse_debuginfo(yes)]` --- code locations in debuginfo are collapsed."
msgstr "`#[collapse_debuginfo(yes)]` --- 디버그 정보의 코드 위치들이 축소됩니다."

#: src/attributes/debugger.md:184
msgid ""
"`#[collapse_debuginfo(no)]` --- code locations in debuginfo are not "
"collapsed."
msgstr "`#[collapse_debuginfo(no)]` --- 디버그 정보의 코드 위치들이 축소되지 않습니다."

#: src/attributes/debugger.md:185
msgid ""
"`#[collapse_debuginfo(external)]` --- code locations in debuginfo are "
"collapsed only if the macro comes from a different crate."
msgstr "`#[collapse_debuginfo(external)]` --- 매크로가 다른 크레이트에서 온 경우에만 디버그 정보의 코드 위치들이 축소됩니다."

#: src/attributes/debugger.md:189
msgid ""
"The `external` behavior is the default for macros that don't have this "
"attribute, unless they are built-in macros. For built-in macros the default "
"is `yes`."
msgstr "`external` 동작은 이 속성이 없는 매크로들의 기본값입니다(내장 매크로 제외). 내장 매크로의 경우 기본값은 `yes`입니다."

#: src/attributes/debugger.md:192
msgid ""
"**Note**: `rustc` has a `-C collapse-macro-debuginfo` CLI option to override "
"both the default collapsing behavior and `#[collapse_debuginfo]` attributes."
msgstr "**참고**: `rustc`는 기본 축소 동작과 `#[collapse_debuginfo]` 속성 모두를 오버라이드하기 위한 `-C collapse-macro-debuginfo` CLI 옵션을 가지고 있습니다."

#: src/attributes/debugger.md:198
msgid "\"hello!\""
msgstr "\"hello!\""

#: src/statements-and-expressions.md:6
msgid ""
"Rust is _primarily_ an expression language. This means that most forms of "
"value-producing or effect-causing evaluation are directed by the uniform "
"syntax category of _expressions_. Each kind of expression can typically "
"_nest_ within each other kind of expression, and rules for evaluation of "
"expressions involve specifying both the value produced by the expression and "
"the order in which its sub-expressions are themselves evaluated."
msgstr "Rust는 _주로_ 표현식(expression) 언어입니다. 이는 대부분의 값을 생성하거나 부수 효과를 일으키는 평가가 _표현식_이라는 통일된 구문 범주에 의해 유도됨을 의미합니다. 각 종류의 표현식은 일반적으로 다른 종류의 표현식 내에 _중첩_될 수 있으며, 표현식의 평가 규칙에는 표현식에 의해 생성되는 값과 그 하위 표현식들이 평가되는 순서를 모두 명시하는 것이 포함됩니다."

#: src/statements-and-expressions.md:10
msgid ""
"In contrast, statements serve _mostly_ to contain and explicitly sequence "
"expression evaluation."
msgstr "반면, 구문(statement)은 _주로_ 표현식 평가를 포함하고 명시적으로 순서를 지정하는 역할을 합니다."

#: src/statements.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Statement_ :  \n"
"      `;`  \n"
"   | [_Item_](items.md)  \n"
"   | [_LetStatement_](#let-statements)  \n"
"   | [_ExpressionStatement_](#expression-statements)  \n"
"   | [_MacroInvocationSemi_](macros.md#macro-invocation)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_구문_ :  \n"
"      `;`  \n"
"   | [_아이템_](items.md)  \n"
"   | [_Let구문_](#let-statements)  \n"
"   | [_표현식구문_](#expression-statements)  \n"
"   | [_세미콜론매크로호출_](macros.md#macro-invocation)"

#: src/statements.md:17
msgid ""
"A _statement_ is a component of a [block](expressions/block-expr.md), which "
"is in turn a component of an outer [expression](expressions.md) or [function]"
"(items/functions.md)."
msgstr "_구문(statement)_은 [블록](expressions/block-expr.md)의 구성 요소이며, 블록은 다시 외부 [표현식](expressions.md)이나 [함수](items/functions.md)의 구성 요소가 됩니다."

#: src/statements.md:21
msgid ""
"Rust has two kinds of statement: [declaration statements](#declaration-"
"statements) and [expression statements](#expression-statements)."
msgstr "Rust에는 두 가지 종류의 구문이 있습니다: [선언 구문](#declaration-statements)과 [표현식 구문](#expression-statements)."

#: src/statements.md:25
msgid "Declaration statements"
msgstr "선언 구문"

#: src/statements.md:28
msgid ""
"A _declaration statement_ is one that introduces one or more _names_ into "
"the enclosing statement block. The declared names may denote new variables "
"or new [items](items.md)."
msgstr "_선언 구문(declaration statement)_은 둘러싼 구문 블록에 하나 이상의 _이름_을 도입하는 구문입니다. 선언된 이름은 새로운 변수나 새로운 [아이템](items.md)을 나타낼 수 있습니다."

#: src/statements.md:31
msgid ""
"The two kinds of declaration statements are item declarations and `let` "
"statements."
msgstr "선언 구문의 두 가지 종류는 아이템 선언과 `let` 구문입니다."

#: src/statements.md:35
msgid "Item declarations"
msgstr "아이템 선언"

#: src/statements.md:39
msgid ""
"An _item declaration statement_ has a syntactic form identical to an [item "
"declaration](items.md) within a [module](items/modules.md)."
msgstr "_아이템 선언 구문_은 [모듈](items/modules.md) 내의 [아이템 선언](items.md)과 동일한 구문 형식을 가집니다."

#: src/statements.md:43
msgid ""
"Declaring an item within a statement block restricts its [scope](names/"
"scopes.md) to the block containing the statement. The item is not given a "
"[canonical path](paths.md#canonical-paths) nor are any sub-items it may "
"declare."
msgstr "구문 블록 내에서 아이템을 선언하면 해당 아이템의 [스코프(scope)](names/scopes.md)는 해당 구문을 포함하는 블록으로 제한됩니다. 아이템에는 [정규 경로(canonical path)](paths.md#canonical-paths)가 주어지지 않으며, 해당 아이템이 선언할 수 있는 하위 아이템들도 마찬가지입니다."

#: src/statements.md:48
msgid ""
"The exception to this is that associated items defined by [implementations]"
"(items/implementations.md) are still accessible in outer scopes as long as "
"the item and, if applicable, trait are accessible. It is otherwise identical "
"in meaning to declaring the item inside a module."
msgstr "이에 대한 예외로, [구현(implementations)](items/implementations.md)에 의해 정의된 연관 아이템들은 해당 아이템과 (해당되는 경우) 트레잇에 접근 가능한 한 외부 스코프에서도 여전히 접근 가능합니다. 그 외의 경우에는 모듈 내부에 아이템을 선언하는 것과 의미상 동일합니다."

#: src/statements.md:53
msgid ""
"There is no implicit capture of the containing function's generic "
"parameters, parameters, and local variables. For example, `inner` may not "
"access `outer_var`."
msgstr "둘러싼 함수의 제네릭 매개변수, 매개변수, 지역 변수들을 암시적으로 캡처하지 않습니다. 예를 들어, `inner`는 `outer_var`에 접근할 수 없습니다."

#: src/statements.md:60
msgid "/* outer_var is not in scope here */"
msgstr "/* 여기서 outer_var는 스코프에 없습니다 */"

#: src/statements.md:68
msgid "`let` statements"
msgstr "`let` 구문"

#: src/statements.md:72
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LetStatement_ :  \n"
"   [_OuterAttribute_](attributes.md)<sup>\\*</sup> `let` [_PatternNoTopAlt_]"
"(patterns.md) ( `:` [_Type_](types.md) )<sup>?</sup> (`=` [_Expression_]"
"(expressions.md) [†](#let-else-restriction) ( `else` [_BlockExpression_]"
"(expressions/block-expr.md)) <sup>?</sup> ) <sup>?</sup> `;`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Let구문_ :  \n"
"   [_외부속성_](attributes.md)<sup>\\*</sup> `let` [_최상위대안없는패턴_]"
"(patterns.md) ( `:` [_타입_](types.md) )<sup>?</sup> (`=` [_표현식_]"
"(expressions.md) [†](#let-else-restriction) ( `else` [_블록표현식_]"
"(expressions/block-expr.md)) <sup>?</sup> ) <sup>?</sup> `;`"

#: src/statements.md:78
msgid ""
"<span id=\"let-else-restriction\">† When an `else` block is specified, the "
"_Expression_ must not be a [_LazyBooleanExpression_](expressions/operator-"
"expr.md#lazy-boolean-operators), or end with a `}`.</span>"
msgstr "<span id=\"let-else-restriction\">† `else` 블록이 지정된 경우, _표현식_은 [_지연 불리언 표현식(LazyBooleanExpression)_](expressions/operator-expr.md#lazy-boolean-operators)이 아니어야 하며, `}`로 끝나서도 안 됩니다.</span>"

#: src/statements.md:83
msgid ""
"A _`let` statement_ introduces a new set of [variables](variables.md), given "
"by a [pattern](patterns.md). The pattern is followed optionally by a type "
"annotation and then either ends, or is followed by an initializer expression "
"plus an optional `else` block."
msgstr "_`let` 구문_은 [패턴](patterns.md)에 의해 주어지는 새로운 [변수](variables.md) 집합을 도입합니다. 패턴 뒤에는 선택적으로 타입 주석이 올 수 있으며, 그 후 구문이 끝나거나 초기화 표현식과 선택적인 `else` 블록이 뒤따릅니다."

#: src/statements.md:88
msgid ""
"When no type annotation is given, the compiler will infer the type, or "
"signal an error if insufficient type information is available for definite "
"inference."
msgstr "타입 주석이 주어지지 않으면 컴파일러가 타입을 추론하며, 확정적인 추론을 위한 타입 정보가 부족하면 에러를 발생시킵니다."

#: src/statements.md:92
msgid ""
"Any variables introduced by a variable declaration are visible from the "
"point of declaration until the end of the enclosing block scope, except when "
"they are shadowed by another variable declaration."
msgstr "변수 선언에 의해 도입된 모든 변수들은 선언 지점부터 해당 블록 스코프가 끝날 때까지 가시성을 가집니다. 단, 다른 변수 선언에 의해 가려지는(shadowed) 경우는 제외합니다."

#: src/statements.md:96
msgid ""
"If an `else` block is not present, the pattern must be irrefutable. If an "
"`else` block is present, the pattern may be refutable."
msgstr "`else` 블록이 없는 경우 패턴은 반박 불가능(irrefutable)해야 합니다. `else` 블록이 있는 경우 패턴은 반박 가능(refutable)할 수 있습니다."

#: src/statements.md:101
msgid ""
"If the pattern does not match (this requires it to be refutable), the `else` "
"block is executed. The `else` block must always diverge (evaluate to the "
"[never type](types/never.md))."
msgstr "패턴이 일치하지 않으면(`else`가 있으므로 반박 가능한 패턴이어야 함) `else` 블록이 실행됩니다. `else` 블록은 반드시 발산(diverge)해야 합니다 (즉, [never 타입](types/never.md)으로 평가되어야 함)."

#: src/statements.md:105
msgid "// The bindings may be mut or const\n"
msgstr "// 바인딩은 mut 또는 const일 수 있습니다\n"

#: src/statements.md:106
msgid "// Refutable patterns require an else block\n"
msgstr "// 반박 가능한 패턴은 else 블록을 요구합니다\n"

#: src/statements.md:107
msgid "// The else block must diverge\n"
msgstr "// else 블록은 반드시 발산해야 합니다\n"

#: src/statements.md:109
msgid ""
"// This pattern is irrefutable, so the compiler\n"
"                                 // will lint as the else block is "
"redundant.\n"
msgstr ""
"// 이 패턴은 반박 불가능하므로, 컴파일러는 else 블록이\n"
"                                 // 불필요하다는 린트를 발생시킬 것입니다.\n"

#: src/statements.md:117
msgid "Expression statements"
msgstr "표현식 구문"

#: src/statements.md:121
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ExpressionStatement_ :  \n"
"      [_ExpressionWithoutBlock_](expressions.md) `;`  \n"
"   | [_ExpressionWithBlock_](expressions.md) `;`<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_표현식구문_ :  \n"
"      [_블록없는표현식_](expressions.md) `;`  \n"
"   | [_블록있는표현식_](expressions.md) `;`<sup>?</sup>"

#: src/statements.md:128
msgid ""
"An _expression statement_ is one that evaluates an [expression]"
"(expressions.md) and ignores its result. As a rule, an expression "
"statement's purpose is to trigger the effects of evaluating its expression."
msgstr "_표현식 구문(expression statement)_은 [표현식](expressions.md)을 평가하고 그 결과를 무시하는 구문입니다. 일반적으로 표현식 구문의 목적은 표현식 평가에 따른 부수 효과를 일으키는 것입니다."

#: src/statements.md:133
msgid ""
"An expression that consists of only a [block expression](expressions/block-"
"expr.md) or control flow expression, if used in a context where a statement "
"is permitted, can omit the trailing semicolon. This can cause an ambiguity "
"between it being parsed as a standalone statement and as a part of another "
"expression; in this case, it is parsed as a statement."
msgstr "블록 표현식이나 제어 흐름 표현식으로만 구성된 표현식이 구문이 허용되는 컨텍스트에서 사용되는 경우, 뒤따르는 세미콜론을 생략할 수 있습니다. 이는 독립적인 구문으로 파싱되는 것과 다른 표현식의 일부로 파싱되는 것 사이의 모호함을 유발할 수 있는데, 이 경우 구문으로 파싱됩니다."

#: src/statements.md:139
msgid ""
"The type of [_ExpressionWithBlock_](expressions.md) expressions when used as "
"statements must be the unit type."
msgstr "구문으로 사용될 때 [_블록있는표현식_](expressions.md)의 타입은 반드시 유닛 타입(unit type)이어야 합니다."

#: src/statements.md:143
msgid "// Ignore the element returned from pop\n"
msgstr "// pop에서 반환된 요소를 무시합니다\n"

#: src/statements.md:148
msgid "// Semicolon can be omitted.\n"
msgstr "// 세미콜론은 생략될 수 있습니다.\n"

#: src/statements.md:149
msgid "// Separate expression statement, not an indexing expression.\n"
msgstr "// 별개의 표현식 구문이며, 인덱싱 표현식이 아닙니다.\n"

#: src/statements.md:152
msgid "When the trailing semicolon is omitted, the result must be type `()`."
msgstr "마지막 세미콜론이 생략된 경우, 결과는 반드시 `()` 타입이어야 합니다."

#: src/statements.md:155
msgid ""
"// bad: the block's type is i32, not ()\n"
"// Error: expected `()` because of default return type\n"
"// if true {\n"
"//   1\n"
"// }\n"
msgstr ""
"// 나쁨: 블록의 타입이 ()가 아니라 i32임\n"
"// 에러: 기본 반환 타입 때문에 `()`가 기대됨\n"
"// if true {\n"
"//   1\n"
"// }\n"

#: src/statements.md:160
msgid "// good: the block's type is i32\n"
msgstr "// 좋음: 블록의 타입이 i32임\n"

#: src/statements.md:171
msgid "Attributes on Statements"
msgstr "구문의 속성"

#: src/statements.md:174
msgid ""
"Statements accept [outer attributes](attributes.md). The attributes that "
"have meaning on a statement are [`cfg`](conditional-compilation.md), and "
"[the lint check attributes](attributes/diagnostics.md#lint-check-attributes)."
msgstr "구문은 [외부 속성](attributes.md)을 허용합니다. 구문에서 의미를 갖는 속성은 [`cfg`](conditional-compilation.md)와 [린트 체크 속성](attributes/diagnostics.md#lint-check-attributes)입니다."

#: src/expressions.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Expression_ :  \n"
"      _ExpressionWithoutBlock_  \n"
"   | _ExpressionWithBlock_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_표현식_ :  \n"
"      _블록없는표현식_  \n"
"   | _블록있는표현식_"

#: src/expressions.md:12
msgid ""
"_ExpressionWithoutBlock_ :  \n"
"   [_OuterAttribute_](attributes.md)<sup>\\*</sup>[†](#expression-"
"attributes)  \n"
msgstr ""
"_블록없는표현식_ :  \n"
"   [_외부속성_](attributes.md)<sup>\\*</sup>[†](#expression-attributes)  \n"
"   (  \n"
"         [_LiteralExpression_](expressions/literal-expr.md)  \n"
"      | [_PathExpression_](expressions/path-expr.md)  \n"
"      | [_OperatorExpression_](expressions/operator-expr.md)  \n"
"      | [_GroupedExpression_](expressions/grouped-expr.md)  \n"
"      | [_ArrayExpression_](expressions/array-expr.md)  \n"
"      | [_AwaitExpression_](expressions/await-expr.md)  \n"
"      | [_IndexExpression_](expressions/array-expr.md#array-and-slice-"
"indexing-expressions)  \n"
"      | [_TupleExpression_](expressions/tuple-expr.md)  \n"
"      | [_TupleIndexingExpression_](expressions/tuple-expr.md#tuple-indexing-"
"expressions)  \n"
"      | [_StructExpression_](expressions/struct-expr.md)  \n"
"      | [_CallExpression_](expressions/call-expr.md)  \n"
"      | [_MethodCallExpression_](expressions/method-call-expr.md)  \n"
"      | [_FieldExpression_](expressions/field-expr.md)  \n"
"      | [_ClosureExpression_](expressions/closure-expr.md)  \n"
"      | [_AsyncBlockExpression_](expressions/block-expr.md#async-blocks)  \n"
"      | [_ContinueExpression_](expressions/loop-expr.md#continue-"
"expressions)  \n"
"      | [_BreakExpression_](expressions/loop-expr.md#break-expressions)  \n"
"      | [_RangeExpression_](expressions/range-expr.md)  \n"
"      | [_ReturnExpression_](expressions/return-expr.md)  \n"
"      | [_UnderscoreExpression_](expressions/underscore-expr.md)  \n"
"      | [_MacroInvocation_](macros.md#macro-invocation)  \n"
"   )"
msgstr ""
"   (  \n"
"         [_리터럴표현식_](expressions/literal-expr.md)  \n"
"      | [_경로표현식_](expressions/path-expr.md)  \n"
"      | [_연산자표현식_](expressions/operator-expr.md)  \n"
"      | [_그룹화된표현식_](expressions/grouped-expr.md)  \n"
"      | [_배열표현식_](expressions/array-expr.md)  \n"
"      | [_Await표현식_](expressions/await-expr.md)  \n"
"      | [_인덱스표현식_](expressions/array-expr.md#array-and-slice-"
"indexing-expressions)  \n"
"      | [_튜플표현식_](expressions/tuple-expr.md)  \n"
"      | [_튜플인덱싱표현식_](expressions/tuple-expr.md#tuple-indexing-"
"expressions)  \n"
"      | [_구조체표현식_](expressions/struct-expr.md)  \n"
"      | [_호출표현식_](expressions/call-expr.md)  \n"
"      | [_메서드호출표현식_](expressions/method-call-expr.md)  \n"
"      | [_필드표현식_](expressions/field-expr.md)  \n"
"      | [_클로저표현식_](expressions/closure-expr.md)  \n"
"      | [_비동기블록표현식_](expressions/block-expr.md#async-blocks)  \n"
"      | [_Continue표현식_](expressions/loop-expr.md#continue-"
"expressions)  \n"
"      | [_Break표현식_](expressions/loop-expr.md#break-expressions)  \n"
"      | [_범위표현식_](expressions/range-expr.md)  \n"
"      | [_Return표현식_](expressions/return-expr.md)  \n"
"      | [_밑줄표현식_](expressions/underscore-expr.md)  \n"
"      | [_매크로호출_](macros.md#macro-invocation)  \n"
"   )"

#: src/expressions.md:38
msgid ""
"_ExpressionWithBlock_ :  \n"
"   [_OuterAttribute_](attributes.md)<sup>\\*</sup>[†](#expression-"
"attributes)  \n"
"   (  \n"
"         [_BlockExpression_](expressions/block-expr.md)  \n"
"      | [_ConstBlockExpression_](expressions/block-expr.md#const-blocks)  \n"
"      | [_UnsafeBlockExpression_](expressions/block-expr.md#unsafe-"
"blocks)  \n"
"      | [_LoopExpression_](expressions/loop-expr.md)  \n"
"      | [_IfExpression_](expressions/if-expr.md#if-expressions)  \n"
"      | [_IfLetExpression_](expressions/if-expr.md#if-let-expressions)  \n"
"      | [_MatchExpression_](expressions/match-expr.md)  \n"
"   )"
msgstr ""
"_블록있는표현식_ :  \n"
"   [_외부속성_](attributes.md)<sup>\\*</sup>[†](#expression-attributes)  \n"
"   (  \n"
"          [_블록표현식_](expressions/block-expr.md)  \n"
"      | [_Const블록표현식_](expressions/block-expr.md#const-blocks)  \n"
"      | [_Unsafe블록표현식_](expressions/block-expr.md#unsafe-blocks)  \n"
"      | [_루프표현식_](expressions/loop-expr.md)  \n"
"      | [_If표현식_](expressions/if-expr.md#if-expressions)  \n"
"      | [_IfLet표현식_](expressions/if-expr.md#if-let-expressions)  \n"
"      | [_매치표현식_](expressions/match-expr.md)  \n"
"   )"

#: src/expressions.md:52
msgid ""
"An expression may have two roles: it always produces a _value_, and it may "
"have _effects_ (otherwise known as \"side effects\")."
msgstr "표현식은 두 가지 역할을 가질 수 있습니다: 항상 _값(value)_을 생성하며, _효과(effects)_ (또는 \"부수 효과\")를 가질 수 있습니다."

#: src/expressions.md:56
msgid ""
"An expression _evaluates to_ a value, and has effects during _evaluation_."
msgstr "표현식은 값으로 _평가(evaluates to)_되며, _평가_ 중에 효과를 가집니다."

#: src/expressions.md:60
msgid ""
"Many expressions contain sub-expressions, called the _operands_ of the "
"expression."
msgstr "많은 표현식은 하위 표현식을 포함하며, 이를 표현식의 _피연산자(operands)_라고 부릅니다."

#: src/expressions.md:64
msgid "The meaning of each kind of expression dictates several things:"
msgstr "각 종류의 표현식의 의미는 몇 가지 사항을 결정합니다:"

#: src/expressions.md:66
msgid "Whether or not to evaluate the operands when evaluating the expression"
msgstr "표현식을 평가할 때 피연산자를 평가할지 여부"

#: src/expressions.md:67
msgid "The order in which to evaluate the operands"
msgstr "피연산자를 평가하는 순서"

#: src/expressions.md:68
msgid ""
"How to combine the operands' values to obtain the value of the expression"
msgstr "표현식의 값을 얻기 위해 피연산자들의 값을 결합하는 방법"

#: src/expressions.md:72
msgid ""
"In this way, the structure of expressions dictates the structure of "
"execution. Blocks are just another kind of expression, so blocks, "
"statements, expressions, and blocks again can recursively nest inside each "
"other to an arbitrary depth."
msgstr "이러한 방식으로 표현식의 구조는 실행 구조를 결정합니다. 블록은 단지 또 다른 종류의 표현식일 뿐이므로, 블록, 구문, 표현식 그리고 다시 블록이 임의의 깊이로 서로 재귀적으로 중첩될 수 있습니다."

#: src/expressions.md:75
msgid ""
"**Note**: We give names to the operands of expressions so that we may "
"discuss them, but these names are not stable and may be changed."
msgstr "**참고**: 논의를 위해 표현식의 피연산자에 이름을 붙였지만, 이러한 이름은 고정된 것이 아니며 변경될 수 있습니다."

#: src/expressions.md:79
msgid "Expression precedence"
msgstr "표현식 우선순위"

#: src/expressions.md:81
msgid ""
"The precedence of Rust operators and expressions is ordered as follows, "
"going from strong to weak. Binary Operators at the same precedence level are "
"grouped in the order given by their associativity."
msgstr "Rust 연산자와 표현식의 우선순위는 다음과 같으며, 강한 것부터 약한 것 순으로 나열되어 있습니다. 동일한 우선순위 수준의 이항 연산자들은 그들의 결합성(associativity)에 따라 그룹화됩니다."

#: src/expressions.md:84
msgid "Operator/Expression"
msgstr "연산자/표현식"

#: src/expressions.md:84
msgid "Associativity"
msgstr "결합성"

#: src/expressions.md:87
msgid "Method calls"
msgstr "메서드 호출"

#: src/expressions.md:88
msgid "Field expressions"
msgstr "필드 표현식"

#: src/expressions.md:88 src/expressions.md:92 src/expressions.md:93
#: src/expressions.md:94 src/expressions.md:95 src/expressions.md:96
#: src/expressions.md:97 src/expressions.md:98 src/expressions.md:100
#: src/expressions.md:101
msgid "left to right"
msgstr "왼쪽에서 오른쪽으로"

#: src/expressions.md:89
msgid "Function calls, array indexing"
msgstr "함수 호출, 배열 인덱싱"

#: src/expressions.md:91
msgid "Unary `-` `*` `!` `&` `&mut`"
msgstr "단항 `-` `*` `!` `&` `&mut`"

#: src/expressions.md:92
msgid "`as`"
msgstr "`as`"

#: src/expressions.md:93
msgid "`*` `/` `%`"
msgstr "`*` `/` `%`"

#: src/expressions.md:94
msgid "`+` `-`"
msgstr "`+` `-`"

#: src/expressions.md:95
msgid "`<<` `>>`"
msgstr "`<<` `>>`"

#: src/expressions.md:99
msgid "`==` `!=` `<` `>` `<=` `>=`"
msgstr "`==` `!=` `<` `>` `<=` `>=`"

#: src/expressions.md:99 src/expressions.md:102
msgid "Require parentheses"
msgstr "괄호 필요"

#: src/expressions.md:102
msgid "`..` `..=`"
msgstr "`..` `..=`"

#: src/expressions.md:103
msgid ""
"`=` `+=` `-=` `*=` `/=` `%=` <br> `&=` <code>\\|=</code> `^=` `<<=` `>>=`"
msgstr "`=` `+=` `-=` `*=` `/=` `%=` <br> `&=` <code>\\|=</code> `^=` `<<=` `>>=`"

#: src/expressions.md:103
msgid "right to left"
msgstr "오른쪽에서 왼쪽으로"

#: src/expressions.md:104
msgid "`return` `break` closures"
msgstr "`return` `break` 클로저"

#: src/expressions.md:108
msgid "Evaluation order of operands"
msgstr "피연산자의 평가 순서"

#: src/expressions.md:112
msgid ""
"The following list of expressions all evaluate their operands the same way, "
"as described after the list. Other expressions either don't take operands or "
"evaluate them conditionally as described on their respective pages."
msgstr "다음 목록의 표현식들은 모두 목록 뒤에 설명된 것과 동일한 방식으로 피연산자를 평가합니다. 다른 표현식들은 피연산자를 취하지 않거나, 각각의 페이지에 설명된 대로 조건부로 평가합니다."

#: src/expressions.md:115
msgid "Dereference expression"
msgstr "역참조 표현식"

#: src/expressions.md:116
msgid "Error propagation expression"
msgstr "에러 전파 표현식"

#: src/expressions.md:117
msgid "Negation expression"
msgstr "부정 표현식"

#: src/expressions.md:118
msgid "Arithmetic and logical binary operators"
msgstr "산술 및 논리 이항 연산자"

#: src/expressions.md:119
msgid "Comparison operators"
msgstr "비교 연산자"

#: src/expressions.md:120
msgid "Type cast expression"
msgstr "타입 캐스트 표현식"

#: src/expressions.md:121
msgid "Grouped expression"
msgstr "그룹화된 표현식"

#: src/expressions.md:122
msgid "Array expression"
msgstr "배열 표현식"

#: src/expressions.md:123
msgid "Await expression"
msgstr "Await 표현식"

#: src/expressions.md:124
msgid "Index expression"
msgstr "인덱스 표현식"

#: src/expressions.md:125
msgid "Tuple expression"
msgstr "튜플 표현식"

#: src/expressions.md:126
msgid "Tuple index expression"
msgstr "튜플 인덱스 표현식"

#: src/expressions.md:127
msgid "Struct expression"
msgstr "구조체 표현식"

#: src/expressions.md:128
msgid "Call expression"
msgstr "호출 표현식"

#: src/expressions.md:129
msgid "Method call expression"
msgstr "메서드 호출 표현식"

#: src/expressions.md:130
msgid "Field expression"
msgstr "필드 표현식"

#: src/expressions.md:131
msgid "Break expression"
msgstr "Break 표현식"

#: src/expressions.md:132
msgid "Range expression"
msgstr "범위 표현식"

#: src/expressions.md:133
msgid "Return expression"
msgstr "Return 표현식"

#: src/expressions.md:137
msgid ""
"The operands of these expressions are evaluated prior to applying the "
"effects of the expression. Expressions taking multiple operands are "
"evaluated left to right as written in the source code."
msgstr "이러한 표현식의 피연산자들은 표현식의 효과가 적용되기 전에 평가됩니다. 여러 피연산자를 취하는 표현식은 소스 코드에 작성된 대로 왼쪽에서 오른쪽으로 평가됩니다."

#: src/expressions.md:140
msgid ""
"**Note**: Which subexpressions are the operands of an expression is "
"determined by expression precedence as per the previous section."
msgstr "**참고**: 어떤 하위 표현식이 표현식의 피연산자인지는 이전 섹션에서 설명한 표현식 우선순위에 의해 결정됩니다."

#: src/expressions.md:143
msgid ""
"For example, the two `next` method calls will always be called in the same "
"order:"
msgstr "예를 들어, 두 개의 `next` 메서드 호출은 항상 동일한 순서로 호출됩니다:"

#: src/expressions.md:146
msgid "// Using vec instead of array to avoid references\n"
msgstr "// 참조를 피하기 위해 배열 대신 vec를 사용합니다.\n"

#: src/expressions.md:147
msgid "// since there is no stable owned array iterator\n"
msgstr "// 이 예제가 작성된 시점에는 안정적인 소유권 있는(owned) 배열 반복자가\n"

#: src/expressions.md:148
msgid "// at the time this example was written.\n"
msgstr "// 없었기 때문입니다.\n"

#: src/expressions.md:156
msgid ""
"**Note**: Since this is applied recursively, these expressions are also "
"evaluated from innermost to outermost, ignoring siblings until there are no "
"inner subexpressions."
msgstr "**참고**: 이는 재귀적으로 적용되므로, 이러한 표현식들은 또한 가장 안쪽에서 바깥쪽 순서로 평가되며, 내부에 더 이상의 하위 표현식이 없을 때까지 형제 노드들을 무시합니다."

#: src/expressions.md:160
msgid "Place Expressions and Value Expressions"
msgstr "장소 표현식과 값 표현식"

#: src/expressions.md:164
msgid ""
"Expressions are divided into two main categories: place expressions and "
"value expressions; there is also a third, minor category of expressions "
"called assignee expressions. Within each expression, operands may likewise "
"occur in either place context or value context. The evaluation of an "
"expression depends both on its own category and the context it occurs within."
msgstr "표현식은 두 가지 주요 범주로 나뉩니다: 장소 표현식(place expressions)과 값 표현식(value expressions). 또한 피할당자 표현식(assignee expressions)이라고 불리는 세 번째 보조 범주도 있습니다. 각 표현식 내에서 피연산자들은 마찬가지로 장소 컨텍스트나 값 컨텍스트 중 하나에서 나타날 수 있습니다. 표현식의 평가는 표현식 자체의 범주와 표현식이 나타나는 컨텍스트 모두에 달려 있습니다."

#: src/expressions.md:171
msgid ""
"A _place expression_ is an expression that represents a memory location."
msgstr "_장소 표현식(place expression)_은 메모리 위치를 나타내는 표현식입니다."

#: src/expressions.md:175
msgid ""
"These expressions are [paths](expressions/path-expr.md) which refer to local "
"variables, [static variables](items/static-items.md), [dereferences]"
"(expressions/operator-expr.md#the-dereference-operator) (`*expr`), [array "
"indexing](expressions/array-expr.md#array-and-slice-indexing-expressions) "
"expressions (`expr[expr]`), [field](expressions/field-expr.md) references "
"(`expr.f`) and parenthesized place expressions."
msgstr "이러한 표현식들은 지역 변수, [정적 변수](items/static-items.md)를 참조하는 [경로](expressions/path-expr.md), [역참조](expressions/operator-expr.md#the-dereference-operator) (`*expr`), [배열 인덱싱](expressions/array-expr.md#array-and-slice-indexing-expressions) 표현식 (`expr[expr]`), [필드](expressions/field-expr.md) 참조 (`expr.f`) 및 괄호로 둘러싸인 장소 표현식입니다."

#: src/expressions.md:179
msgid "All other expressions are value expressions."
msgstr "다른 모든 표현식은 값 표현식입니다."

#: src/expressions.md:183
msgid "A _value expression_ is an expression that represents an actual value."
msgstr "_값 표현식(value expression)_은 실제 값을 나타내는 표현식입니다."

#: src/expressions.md:187
msgid "The following contexts are _place expression_ contexts:"
msgstr "다음 컨텍스트들은 _장소 표현식_ 컨텍스트입니다:"

#: src/expressions.md:189
msgid ""
"The left operand of a [compound assignment](expressions/operator-"
"expr.md#compound-assignment-expressions) expression."
msgstr "[복합 할당(compound assignment)](expressions/operator-expr.md#compound-assignment-expressions) 표현식의 왼쪽 피연산자."

#: src/expressions.md:190
msgid ""
"The operand of a unary [borrow](expressions/operator-expr.md#borrow-"
"operators), [raw borrow](expressions/operator-expr.md#raw-borrow-operators) "
"or [dereference](expressions/operator-expr.md#the-dereference-operator) "
"operator."
msgstr "단항 [차용(borrow)](expressions/operator-expr.md#borrow-operators), [원시 차용(raw borrow)](expressions/operator-expr.md#raw-borrow-operators) 또는 [역참조(dereference)](expressions/operator-expr.md#the-dereference-operator) 연산자의 피연산자."

#: src/expressions.md:191
msgid "The operand of a field expression."
msgstr "필드 표현식의 피연산자."

#: src/expressions.md:192
msgid "The indexed operand of an array indexing expression."
msgstr "배열 인덱싱 표현식의 인덱스된 피연산자."

#: src/expressions.md:193
msgid "The operand of any [implicit borrow](#implicit-borrows)."
msgstr "임의의 [암시적 차용(implicit borrow)](#implicit-borrows)의 피연산자."

#: src/expressions.md:194
msgid "The initializer of a [let statement](statements.md#let-statements)."
msgstr "[let 문](statements.md#let-statements)의 초기화 식(initializer)."

#: src/expressions.md:195
msgid ""
"The [scrutinee](glossary.md#scrutinee) of an [`if let`](expressions/if-"
"expr.md#if-let-expressions), [`match`](expressions/match-expr.md), or "
"[`while let`](expressions/loop-expr.md#predicate-pattern-loops) expression."
msgstr "[`if let`](expressions/if-expr.md#if-let-expressions), [`match`](expressions/match-expr.md) 또는 [`while let`](expressions/loop-expr.md#predicate-pattern-loops) 표현식의 [피검사대상(scrutinee)](glossary.md#scrutinee)."

#: src/expressions.md:197
msgid ""
"The base of a [functional update](expressions/struct-expr.md#functional-"
"update-syntax) struct expression."
msgstr "[함수형 업데이트(functional update)](expressions/struct-expr.md#functional-update-syntax) 구조체 표현식의 베이스(base)."

#: src/expressions.md:199
msgid ""
"Note: Historically, place expressions were called _lvalues_ and value "
"expressions were called _rvalues_."
msgstr "참고: 역사적으로 장소 표현식은 _lvalues_로, 값 표현식은 _rvalues_로 불렸습니다."

#: src/expressions.md:203
msgid ""
"An _assignee expression_ is an expression that appears in the left operand "
"of an [assignment](expressions/operator-expr.md#assignment-expressions) "
"expression. Explicitly, the assignee expressions are:"
msgstr "_피할당자 표현식(assignee expression)_은 [할당(assignment)](expressions/operator-expr.md#assignment-expressions) 표현식의 왼쪽 피연산자로 나타나는 표현식입니다. 명시적으로, 피할당자 표현식은 다음과 같습니다:"

#: src/expressions.md:206
msgid "Place expressions."
msgstr "장소 표현식."

#: src/expressions.md:207
msgid "[Underscores](expressions/underscore-expr.md)."
msgstr "[밑줄(Underscores)](expressions/underscore-expr.md)."

#: src/expressions.md:208
msgid "[Tuples](expressions/tuple-expr.md) of assignee expressions."
msgstr "피할당자 표현식의 [튜플](expressions/tuple-expr.md)."

#: src/expressions.md:209
msgid "[Slices](expressions/array-expr.md) of assignee expressions."
msgstr "피할당자 표현식의 [슬라이스](expressions/array-expr.md)."

#: src/expressions.md:210
msgid "[Tuple structs](expressions/struct-expr.md) of assignee expressions."
msgstr "피할당자 표현식의 [튜플 구조체](expressions/struct-expr.md)."

#: src/expressions.md:211
msgid ""
"[Structs](expressions/struct-expr.md) of assignee expressions (with "
"optionally named fields)."
msgstr "피할당자 표현식의 [구조체](expressions/struct-expr.md) (선택적으로 이름이 붙은 필드 포함)."

#: src/expressions.md:213
msgid "[Unit structs](expressions/struct-expr.md)."
msgstr "[유닛 구조체](expressions/struct-expr.md)."

#: src/expressions.md:217
msgid "Arbitrary parenthesisation is permitted inside assignee expressions."
msgstr "피할당자 표현식 내에서는 임의의 괄호 사용이 허용됩니다."

#: src/expressions.md:221
msgid "Moved and copied types"
msgstr "이동 및 복사 타입"

#: src/expressions.md:225
msgid ""
"When a place expression is evaluated in a value expression context, or is "
"bound by value in a pattern, it denotes the value held _in_ that memory "
"location."
msgstr "장소 표현식이 값 표현식 컨텍스트에서 평가되거나 패턴에서 값으로 바인딩될 때, 이는 해당 메모리 위치_에_ 저장된 값을 나타냅니다."

#: src/expressions.md:229
msgid ""
"If the type of that value implements [`Copy`](special-types-and-"
"traits.md#copy), then the value will be copied."
msgstr "해당 값의 타입이 [`Copy`](special-types-and-traits.md#copy)를 구현한다면, 값이 복사됩니다."

#: src/expressions.md:233
msgid ""
"In the remaining situations, if that type is [`Sized`](special-types-and-"
"traits.md#sized), then it may be possible to move the value."
msgstr "그 외의 상황에서 해당 타입이 [`Sized`](special-types-and-traits.md#sized)라면, 값을 이동(move)시키는 것이 가능할 수 있습니다."

#: src/expressions.md:237
msgid "Only the following place expressions may be moved out of:"
msgstr "오직 다음 장소 표현식들로부터만 값을 이동시킬 수 있습니다:"

#: src/expressions.md:239
msgid "[Variables](variables.md) which are not currently borrowed."
msgstr "현재 차용(borrow)되지 않은 [변수](variables.md)."

#: src/expressions.md:240 src/expressions.md:268
msgid "[Temporary values](#temporaries)."
msgstr "[임시 값](#temporaries)."

#: src/expressions.md:241
msgid ""
"[Fields](expressions/field-expr.md) of a place expression which can be moved "
"out of and don't implement [`Drop`](special-types-and-traits.md#drop)."
msgstr "값을 이동시킬 수 있는 장소 표현식의 [필드](expressions/field-expr.md)들 중 [`Drop`](special-types-and-traits.md#drop)을 구현하지 않은 것."

#: src/expressions.md:242
msgid ""
"The result of [dereferencing](expressions/operator-expr.md#the-dereference-"
"operator) an expression with type [`Box<T>`](../alloc/boxed/struct.Box.html) "
"and that can also be moved out of."
msgstr "[`Box<T>`](../alloc/boxed/struct.Box.html) 타입을 가진 표현식을 [역참조](expressions/operator-expr.md#the-dereference-operator)한 결과로서, 마찬가지로 값을 이동시킬 수 있는 경우."

#: src/expressions.md:246
msgid ""
"After moving out of a place expression that evaluates to a local variable, "
"the location is deinitialized and cannot be read from again until it is "
"reinitialized."
msgstr "지역 변수로 평가되는 장소 표현식에서 값을 이동시킨 후에는 해당 위치가 초기화 해제(deinitialized)되며, 다시 초기화될 때까지 다시 읽을 수 없습니다."

#: src/expressions.md:250
msgid ""
"In all other cases, trying to use a place expression in a value expression "
"context is an error."
msgstr "그 외의 모든 경우, 값 표현식 컨텍스트에서 장소 표현식을 사용하려고 시도하는 것은 에러입니다."

#: src/expressions.md:254
msgid "Mutability"
msgstr "가변성(Mutability)"

#: src/expressions.md:258
msgid ""
"For a place expression to be [assigned](expressions/operator-"
"expr.md#assignment-expressions) to, mutably [borrowed](expressions/operator-"
"expr.md#borrow-operators), [implicitly mutably borrowed](#implicit-borrows), "
"or bound to a pattern containing `ref mut`, it must be _mutable_. We call "
"these _mutable place expressions_. In contrast, other place expressions are "
"called _immutable place expressions_."
msgstr "장소 표현식에 [할당(assigned)](expressions/operator-expr.md#assignment-expressions)하거나, 가변적으로 [차용(borrowed)](expressions/operator-expr.md#borrow-operators)하거나, [암시적으로 가변 차용](#implicit-borrows)하거나, `ref mut`를 포함하는 패턴에 바인딩하려면 해당 표현식은 반드시 _가변(mutable)_이어야 합니다. 이를 _가변 장소 표현식(mutable place expressions)_이라고 부릅니다. 반면에 다른 장소 표현식들은 _불변 장소 표현식(immutable place expressions)_이라고 부릅니다."

#: src/expressions.md:264
msgid "The following expressions can be mutable place expression contexts:"
msgstr "다음 표현식들은 가변 장소 표현식 컨텍스트가 될 수 있습니다:"

#: src/expressions.md:266
msgid "Mutable [variables](variables.md) which are not currently borrowed."
msgstr "현재 차용되지 않은 가변 [변수(variables)](variables.md)."

#: src/expressions.md:267
msgid "[Mutable `static` items](items/static-items.md#mutable-statics)."
msgstr "[가변 `static` 아이템](items/static-items.md#mutable-statics)."

#: src/expressions.md:269
msgid ""
"[Fields](expressions/field-expr.md): this evaluates the subexpression in a "
"mutable place expression context."
msgstr "[필드(Fields)](expressions/field-expr.md): 이는 하위 표현식을 가변 장소 표현식 컨텍스트에서 평가합니다."

#: src/expressions.md:270
msgid ""
"[Dereferences](expressions/operator-expr.md#the-dereference-operator) of a "
"`*mut T` pointer."
msgstr "`*mut T` 포인터의 [역참조(Dereferences)](expressions/operator-expr.md#the-dereference-operator)."

#: src/expressions.md:271
msgid ""
"Dereference of a variable, or field of a variable, with type `&mut T`. Note: "
"This is an exception to the requirement of the next rule."
msgstr "`&mut T` 타입을 가진 변수 또는 변수 필드의 역참조. 참고: 이는 다음 규칙의 요구 사항에 대한 예외입니다."

#: src/expressions.md:273
msgid ""
"Dereferences of a type that implements `DerefMut`: this then requires that "
"the value being dereferenced is evaluated in a mutable place expression "
"context."
msgstr "`DerefMut`를 구현하는 타입의 역참조: 이는 역참조되는 값이 가변 장소 표현식 컨텍스트에서 평가될 것을 요구합니다."

#: src/expressions.md:275
msgid ""
"[Array indexing](expressions/array-expr.md#array-and-slice-indexing-"
"expressions) of a type that implements `IndexMut`: this then evaluates the "
"value being indexed, but not the index, in mutable place expression context."
msgstr "`IndexMut`를 구현하는 타입의 [배열 인덱싱(Array indexing)](expressions/array-expr.md#array-and-slice-indexing-expressions): 이는 인덱싱되는 값을 가변 장소 표현식 컨텍스트에서 평가하지만, 인덱스는 그렇지 않습니다."

#: src/expressions.md:280
msgid "Temporaries"
msgstr "임시 값(Temporaries)"

#: src/expressions.md:282
msgid ""
"When using a value expression in most place expression contexts, a temporary "
"unnamed memory location is created and initialized to that value. The "
"expression evaluates to that location instead, except if [promoted]"
"(destructors.md#constant-promotion) to a `static`. The [drop scope]"
"(destructors.md#drop-scopes) of the temporary is usually the end of the "
"enclosing statement."
msgstr "대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용할 때, 이름 없는 임시 메모리 위치가 생성되고 해당 값으로 초기화됩니다. 표현식은 `static`으로 [승격(promoted)](destructors.md#constant-promotion)되지 않는 한 해당 위치로 평가됩니다. 임시 값의 [드롭 스코프(drop scope)](destructors.md#drop-scopes)는 보통 이를 둘러싼 구문의 끝입니다."

#: src/expressions.md:288
msgid "Implicit Borrows"
msgstr "암시적 차용(Implicit Borrows)"

#: src/expressions.md:292
msgid ""
"Certain expressions will treat an expression as a place expression by "
"implicitly borrowing it. For example, it is possible to compare two unsized "
"[slices](types/slice.md) for equality directly, because the `==` operator "
"implicitly borrows its operands:"
msgstr "특정 표현식들은 표현식을 암시적으로 차용함으로써 장소 표현식으로 취급합니다. 예를 들어, `==` 연산자는 피연산자를 암시적으로 차용하기 때문에 두 개의 크기 미지정 [슬라이스(slices)](types/slice.md)의 동등성을 직접 비교하는 것이 가능합니다."

#: src/expressions.md:303
msgid "// Equivalent form:\n"
msgstr "// 동등한 형태:\n"

#: src/expressions.md:310
msgid "Implicit borrows may be taken in the following expressions:"
msgstr "암시적 차용은 다음 표현식들에서 발생할 수 있습니다:"

#: src/expressions.md:312
msgid ""
"Left operand in [method-call](expressions/method-call-expr.md) expressions."
msgstr "[메서드 호출(method-call)](expressions/method-call-expr.md) 표현식의 왼쪽 피연산자."

#: src/expressions.md:313
msgid "Left operand in [field](expressions/field-expr.md) expressions."
msgstr "[필드(field)](expressions/field-expr.md) 표현식의 왼쪽 피연산자."

#: src/expressions.md:314
msgid "Left operand in [call expressions](expressions/call-expr.md)."
msgstr "[호출 표현식(call expressions)](expressions/call-expr.md)의 왼쪽 피연산자."

#: src/expressions.md:315
msgid ""
"Left operand in [array indexing](expressions/array-expr.md#array-and-slice-"
"indexing-expressions) expressions."
msgstr "[배열 인덱싱(array indexing)](expressions/array-expr.md#array-and-slice-indexing-expressions) 표현식의 왼쪽 피연산자."

#: src/expressions.md:316
msgid ""
"Operand of the [dereference operator](expressions/operator-expr.md#the-"
"dereference-operator) (`*`)."
msgstr "[역참조 연산자(dereference operator)](expressions/operator-expr.md#the-dereference-operator) (`*`)의 피연산자."

#: src/expressions.md:317
msgid ""
"Operands of [comparison](expressions/operator-expr.md#comparison-operators)."
msgstr "[비교(comparison)](expressions/operator-expr.md#comparison-operators)의 피연산자들."

#: src/expressions.md:318
msgid ""
"Left operands of the [compound assignment](expressions/operator-"
"expr.md#compound-assignment-expressions)."
msgstr "[복합 할당(compound assignment)](expressions/operator-expr.md#compound-assignment-expressions)의 왼쪽 피연산자들."

#: src/expressions.md:322
msgid "Overloading Traits"
msgstr "오버로딩 트레잇"

#: src/expressions.md:324
msgid ""
"Many of the following operators and expressions can also be overloaded for "
"other types using traits in `std::ops` or `std::cmp`. These traits also "
"exist in `core::ops` and `core::cmp` with the same names."
msgstr "다음 중 많은 연산자와 표현식들은 `std::ops`나 `std::cmp`에 있는 트레잇들을 사용하여 다른 타입에 대해 오버로드될 수 있습니다. 이러한 트레잇들은 `core::ops` 및 `core::cmp`에도 동일한 이름으로 존재합니다."

#: src/expressions.md:329
msgid "Expression Attributes"
msgstr "표현식 속성"

#: src/expressions.md:333
msgid ""
"[Outer attributes](attributes.md) before an expression are allowed only in a "
"few specific cases:"
msgstr "표현식 앞의 [외부 속성(Outer attributes)](attributes.md)은 오직 다음 몇 가지 구체적인 경우에만 허용됩니다:"

#: src/expressions.md:335
msgid "Before an expression used as a [statement](statements.md)."
msgstr "[구문(statement)](statements.md)으로 사용된 표현식 앞에 올 때."

#: src/expressions.md:336
msgid ""
"Elements of [array expressions](expressions/array-expr.md), [tuple "
"expressions](expressions/tuple-expr.md), [call expressions](expressions/call-"
"expr.md), and tuple-style [struct](expressions/struct-expr.md) expressions."
msgstr "[배열 표현식(array expressions)](expressions/array-expr.md), [튜플 표현식(tuple expressions)](expressions/tuple-expr.md), [호출 표현식(call expressions)](expressions/call-expr.md), 그리고 튜플 스타일 [구조체(struct)](expressions/struct-expr.md) 표현식의 요소들에 올 때."

#: src/expressions.md:337
msgid "The tail expression of [block expressions](expressions/block-expr.md)."
msgstr "[블록 표현식(block expressions)](expressions/block-expr.md)의 마지막 표현식(tail expression)에 올 때."

#: src/expressions.md:342
msgid "They are never allowed before:"
msgstr "다음의 경우에는 절대 허용되지 않습니다:"

#: src/expressions.md:343
msgid "[Range](expressions/range-expr.md) expressions."
msgstr "[범위(Range)](expressions/range-expr.md) 표현식 앞."

#: src/expressions.md:344
msgid ""
"Binary operator expressions ([_ArithmeticOrLogicalExpression_](expressions/"
"operator-expr.md#arithmetic-and-logical-binary-operators), "
"[_ComparisonExpression_](expressions/operator-expr.md#comparison-operators), "
"[_LazyBooleanExpression_](expressions/operator-expr.md#lazy-boolean-"
"operators), [_TypeCastExpression_](expressions/operator-expr.md#type-cast-"
"expressions), [_AssignmentExpression_](expressions/operator-"
"expr.md#assignment-expressions), [_CompoundAssignmentExpression_]"
"(expressions/operator-expr.md#compound-assignment-expressions))."
msgstr "이항 연산자 표현식 ([_산술또는논리표현식_](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), [_비교표현식_](expressions/operator-expr.md#comparison-operators), [_지연불리언표현식_](expressions/operator-expr.md#lazy-boolean-operators), [_타입캐스트표현식_](expressions/operator-expr.md#type-cast-expressions), [_할당표현식_](expressions/operator-expr.md#assignment-expressions), [_복합할당표현식_](expressions/operator-expr.md#compound-assignment-expressions)) 앞."

#: src/expressions/literal-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LiteralExpression_ :  \n"
"      [CHAR_LITERAL](../tokens.md#character-literals)  \n"
"   | [STRING_LITERAL](../tokens.md#string-literals)  \n"
"   | [RAW_STRING_LITERAL](../tokens.md#raw-string-literals)  \n"
"   | [BYTE_LITERAL](../tokens.md#byte-literals)  \n"
"   | [BYTE_STRING_LITERAL](../tokens.md#byte-string-literals)  \n"
"   | [RAW_BYTE_STRING_LITERAL](../tokens.md#raw-byte-string-literals)  \n"
"   | [C_STRING_LITERAL](../tokens.md#c-string-literals)  \n"
"   | [RAW_C_STRING_LITERAL](../tokens.md#raw-c-string-literals)  \n"
"   | [INTEGER_LITERAL](../tokens.md#integer-literals)  \n"
"   | [FLOAT_LITERAL](../tokens.md#floating-point-literals)  \n"
"   | `true` | `false`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_리터럴표현식_ :  \n"
"      [문자리터럴](../tokens.md#character-literals)  \n"
"   | [문자열리터럴](../tokens.md#string-literals)  \n"
"   | [원시문자열리터럴](../tokens.md#raw-string-literals)  \n"
"   | [바이트리터럴](../tokens.md#byte-literals)  \n"
"   | [바이트문자열리터럴](../tokens.md#byte-string-literals)  \n"
"   | [원시바이트문자열리터럴](../tokens.md#raw-byte-string-literals)  \n"
"   | [C문자열리터럴](../tokens.md#c-string-literals)  \n"
"   | [원시C문자열리터럴](../tokens.md#raw-c-string-literals)  \n"
"   | [정수리터럴](../tokens.md#integer-literals)  \n"
"   | [부동소수점리터럴](../tokens.md#floating-point-literals)  \n"
"   | `true` | `false`"

#: src/expressions/literal-expr.md:23
msgid ""
"A _literal expression_ is an expression consisting of a single token, rather "
"than a sequence of tokens, that immediately and directly denotes the value "
"it evaluates to, rather than referring to it by name or some other "
"evaluation rule."
msgstr "_리터럴 표현식(literal expression)_은 단일 토큰으로 구성된 표현식으로, 이름을 통해 참조하거나 다른 평가 규칙을 따르는 대신, 그것이 평가되는 값을 즉시 그리고 직접적으로 나타냅니다."

#: src/expressions/literal-expr.md:27
msgid ""
"A literal is a form of [constant expression](../const_eval.md#constant-"
"expressions), so is evaluated (primarily) at compile time."
msgstr "리터럴은 [상수 표현식](../const_eval.md#constant-expressions)의 한 형태이므로, (주로) 컴파일 타임에 평가됩니다."

#: src/expressions/literal-expr.md:31
msgid ""
"Each of the lexical [literal](../tokens.md#literals) forms described earlier "
"can make up a literal expression, as can the keywords `true` and `false`."
msgstr "앞서 설명한 어휘적 [리터럴](../tokens.md#literals) 형식들은 각각 리터럴 표현식을 구성할 수 있으며, `true`와 `false` 키워드도 마찬가지입니다."

#: src/expressions/literal-expr.md:34 src/expressions/loop-expr.md:94
#: src/types/closure.md:208
msgid "\"hello\""
msgstr "\"hello\""

#: src/expressions/literal-expr.md:34
msgid ""
"// string type\n"
"'5'"
msgstr ""
"// 문자열 타입\n"
"'5'"

#: src/expressions/literal-expr.md:35
msgid "// character type\n"
msgstr "// 문자 타입\n"

#: src/expressions/literal-expr.md:36
msgid "// integer type\n"
msgstr "// 정수 타입\n"

#: src/expressions/literal-expr.md:41
msgid ""
"In the descriptions below, the _string representation_ of a token is the "
"sequence of characters from the input which matched the token's production "
"in a _Lexer_ grammar snippet."
msgstr "아래 설명에서 토큰의 _문자열 표현(string representation)_은 _렉서_ 문법 스니펫의 토큰 생성물과 일치하는 입력 문자 시퀀스를 의미합니다."

#: src/expressions/literal-expr.md:43
msgid ""
"**Note**: this string representation never includes a character `U+000D` "
"(CR) immediately followed by `U+000A` (LF): this pair would have been "
"previously transformed into a single `U+000A` (LF)."
msgstr "**참고**: 이 문자열 표현에는 `U+000D` (CR) 뒤에 바로 `U+000A` (LF)가 오는 문자가 포함되지 않습니다. 이 쌍은 이전에 이미 단일 `U+000A` (LF)로 변환되었을 것이기 때문입니다."

#: src/expressions/literal-expr.md:51
msgid ""
"The descriptions of textual literal expressions below make use of several "
"forms of _escape_."
msgstr "아래의 텍스트 리터럴 표현식에 대한 설명에서는 여러 형태의 _이스케이프(escape)_를 사용합니다."

#: src/expressions/literal-expr.md:55
msgid "Each form of escape is characterised by:"
msgstr "각 이스케이프 형태는 다음으로 특징지어집니다:"

#: src/expressions/literal-expr.md:56
msgid ""
"an _escape sequence_: a sequence of characters, which always begins with "
"`U+005C` (`\\`)"
msgstr "_이스케이프 시퀀스(escape sequence)_: 항상 `U+005C` (`\\`)로 시작하는 문자 시퀀스"

#: src/expressions/literal-expr.md:57
msgid ""
"an _escaped value_: either a single character or an empty sequence of "
"characters"
msgstr "_이스케이프된 값(escaped value)_: 단일 문자 또는 빈 문자 시퀀스"

#: src/expressions/literal-expr.md:59
msgid "In the definitions of escapes below:"
msgstr "아래의 이스케이프 정의에서:"

#: src/expressions/literal-expr.md:60
msgid "An _octal digit_ is any of the characters in the range \\[`0`\\-`7`\\]."
msgstr "_8진수 숫자(octal digit)_는 `0`-`7` 범위의 문자 중 하나입니다."

#: src/expressions/literal-expr.md:61
msgid ""
"A _hexadecimal digit_ is any of the characters in the ranges \\[`0`\\-"
"`9`\\], \\[`a`\\-`f`\\], or \\[`A`\\-`F`\\]."
msgstr "_16진수 숫자(hexadecimal digit)_는 `0`-`9`, `a`-`f`, 또는 `A`-`F` 범위의 문자 중 하나입니다."

#: src/expressions/literal-expr.md:65
msgid "Simple escapes"
msgstr "단순 이스케이프"

#: src/expressions/literal-expr.md:67
msgid ""
"Each sequence of characters occurring in the first column of the following "
"table is an escape sequence."
msgstr "다음 표의 첫 번째 열에 나타나는 각 문자 시퀀스는 이스케이프 시퀀스입니다."

#: src/expressions/literal-expr.md:69
msgid ""
"In each case, the escaped value is the character given in the corresponding "
"entry in the second column."
msgstr "각 경우에, 이스케이프된 값은 두 번째 열의 해당 항목에 주어진 문자입니다."

#: src/expressions/literal-expr.md:71
msgid "Escape sequence"
msgstr "이스케이프 시퀀스"

#: src/expressions/literal-expr.md:71
msgid "Escaped value"
msgstr "이스케이프된 값"

#: src/expressions/literal-expr.md:73
msgid "U+0000 (NUL)"
msgstr "U+0000 (NUL)"

#: src/expressions/literal-expr.md:74
msgid "U+0009 (HT)"
msgstr "U+0009 (HT)"

#: src/expressions/literal-expr.md:75
msgid "U+000A (LF)"
msgstr "U+000A (LF)"

#: src/expressions/literal-expr.md:76
msgid "U+000D (CR)"
msgstr "U+000D (CR)"

#: src/expressions/literal-expr.md:77
msgid "U+0022 (QUOTATION MARK)"
msgstr "U+0022 (큰따옴표)"

#: src/expressions/literal-expr.md:78
msgid "U+0027 (APOSTROPHE)"
msgstr "U+0027 (작은따옴표)"

#: src/expressions/literal-expr.md:79
msgid "U+005C (REVERSE SOLIDUS)"
msgstr "U+005C (역슬래시)"

#: src/expressions/literal-expr.md:83
msgid "8-bit escapes"
msgstr "8비트 이스케이프"

#: src/expressions/literal-expr.md:85
msgid ""
"The escape sequence consists of `\\x` followed by two hexadecimal digits."
msgstr "이스케이프 시퀀스는 `\\x` 뒤에 두 개의 16진수 숫자가 오는 것으로 구성됩니다."

#: src/expressions/literal-expr.md:87 src/expressions/literal-expr.md:97
msgid ""
"The escaped value is the character whose [Unicode scalar value](http://"
"www.unicode.org/glossary/#unicode_scalar_value) is the result of "
"interpreting the final two characters in the escape sequence as a "
"hexadecimal integer, as if by [`u8::from_str_radix`](../../std/"
"primitive.u8.html#method.from_str_radix) with radix 16."
msgstr "이스케이프된 값은 이스케이프 시퀀스의 마지막 두 문자를 16진수 정수로 해석한 결과(기수가 16인 [`u8::from_str_radix`](../../std/primitive.u8.html#method.from_str_radix)를 사용한 것과 같음)를 [유니코드 스칼라 값(Unicode scalar value)](http://www.unicode.org/glossary/#unicode_scalar_value)으로 가지는 문자입니다."

#: src/expressions/literal-expr.md:89
msgid ""
"**Note**: the escaped value therefore has a [Unicode scalar value](http://"
"www.unicode.org/glossary/#unicode_scalar_value) in the range of [`u8`](../"
"types/numeric.md)."
msgstr "**참고**: 따라서 이스케이프된 값은 [`u8`](../types/numeric.md) 범위 내의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)을 가집니다."

#: src/expressions/literal-expr.md:93
msgid "7-bit escapes"
msgstr "7비트 이스케이프"

#: src/expressions/literal-expr.md:95
msgid ""
"The escape sequence consists of `\\x` followed by an octal digit then a "
"hexadecimal digit."
msgstr "이스케이프 시퀀스는 `\\x` 뒤에 8진수 숫자 하나와 16진수 숫자 하나가 차례로 오는 것으로 구성됩니다."

#: src/expressions/literal-expr.md:103
msgid ""
"The escape sequence consists of `\\u{`, followed by a sequence of characters "
"each of which is a hexadecimal digit or `_`, followed by `}`."
msgstr "이스케이프 시퀀스는 `\\u{` 뒤에 16진수 숫자 또는 `_`로 구성된 문자 시퀀스가 오고, 그 뒤에 `}`가 오는 것으로 구성됩니다."

#: src/expressions/literal-expr.md:105
msgid ""
"The escaped value is the character whose [Unicode scalar value](http://"
"www.unicode.org/glossary/#unicode_scalar_value) is the result of "
"interpreting the hexadecimal digits contained in the escape sequence as a "
"hexadecimal integer, as if by [`u32::from_str_radix`](../../std/"
"primitive.u32.html#method.from_str_radix) with radix 16."
msgstr "이스케이프된 값은 이스케이프 시퀀스에 포함된 16진수 숫자들을 16진수 정수로 해석한 결과(기수가 16인 [`u32::from_str_radix`](../../std/primitive.u32.html#method.from_str_radix)를 사용한 것과 같음)를 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)으로 가지는 문자입니다."

#: src/expressions/literal-expr.md:107
msgid ""
"**Note**: the permitted forms of a [CHAR_LITERAL](../tokens.md#character-"
"literals) or [STRING_LITERAL](../tokens.md#string-literals) token ensure "
"that there is such a character."
msgstr "**참고**: 허용되는 [문자리터럴(CHAR_LITERAL)](../tokens.md#character-literals) 또는 [문자열리터럴(STRING_LITERAL)](../tokens.md#string-literals) 토큰의 형식은 그러한 문자가 반드시 존재함을 보장합니다."

#: src/expressions/literal-expr.md:111
msgid "String continuation escapes"
msgstr "문자열 연속 이스케이프"

#: src/expressions/literal-expr.md:113
msgid ""
"The escape sequence consists of `\\` followed immediately by `U+000A` (LF), "
"and all following whitespace characters before the next non-whitespace "
"character. For this purpose, the whitespace characters are `U+0009` (HT), "
"`U+000A` (LF), `U+000D` (CR), and `U+0020` (SPACE)."
msgstr "이스케이프 시퀀스는 `\\` 뒤에 즉시 `U+000A` (LF)가 오고, 그다음 비-공백 문자 전까지의 모든 공백 문자들로 구성됩니다. 이 목적을 위해 공백 문자는 `U+0009` (HT), `U+000A` (LF), `U+000D` (CR), 그리고 `U+0020` (SPACE)입니다."

#: src/expressions/literal-expr.md:116
msgid "The escaped value is an empty sequence of characters."
msgstr "이스케이프된 값은 빈 문자 시퀀스입니다."

#: src/expressions/literal-expr.md:118
msgid ""
"**Note**: The effect of this form of escape is that a string continuation "
"skips following whitespace, including additional newlines. Thus `a`, `b` and "
"`c` are equal:"
msgstr "**참고**: 이 형태의 이스케이프 효과는 문자열 연속 시퀀스가 뒤따르는 공백(추가적인 줄 바꿈 포함)을 건너뛴다는 것입니다. 따라서 `a`, `b`, `c`는 동일합니다."

#: src/expressions/literal-expr.md:121
msgid "\"foobar\""
msgstr "\"foobar\""

#: src/expressions/literal-expr.md:122 src/expressions/literal-expr.md:124
msgid "\"foo\\\n"
msgstr "\"foo\\\n"

#: src/expressions/literal-expr.md:132
msgid ""
"Skipping additional newlines (as in example c) is potentially confusing and "
"unexpected. This behavior may be adjusted in the future. Until a decision is "
"made, it is recommended to avoid relying on skipping multiple newlines with "
"line continuations. See [this issue](https://github.com/rust-lang/reference/"
"pull/1042) for more information."
msgstr "추가적인 줄 바꿈을 건너뛰는 것(예시 c와 같은 경우)은 잠재적으로 혼란스럽고 예상치 못한 일일 수 있습니다. 이 동작은 미래에 조정될 수 있습니다. 결정이 내려지기 전까지는 라인 연속 기능을 사용하여 여러 줄 바꿈을 건너뛰는 것에 의존하지 않는 것이 권장됩니다. 자세한 내용은 [이 이슈](https://github.com/rust-lang/reference/pull/1042)를 참조하세요."

#: src/expressions/literal-expr.md:139
msgid "Character literal expressions"
msgstr "문자 리터럴 표현식"

#: src/expressions/literal-expr.md:143
msgid ""
"A character literal expression consists of a single [CHAR_LITERAL](../"
"tokens.md#character-literals) token."
msgstr "문자 리터럴 표현식은 단일 [문자리터럴(CHAR_LITERAL)](../tokens.md#character-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:147
msgid ""
"The expression's type is the primitive [`char`](../types/textual.md) type."
msgstr "표현식의 타입은 기본 [`char`](../types/textual.md) 타입입니다."

#: src/expressions/literal-expr.md:151 src/expressions/literal-expr.md:202
#: src/expressions/literal-expr.md:258 src/expressions/literal-expr.md:308
#: src/expressions/literal-expr.md:366
msgid "The token must not have a suffix."
msgstr "토큰은 접미사(suffix)를 가져서는 안 됩니다."

#: src/expressions/literal-expr.md:155 src/expressions/literal-expr.md:262
msgid ""
"The token's _literal content_ is the sequence of characters following the "
"first `U+0027` (`'`) and preceding the last `U+0027` (`'`) in the string "
"representation of the token."
msgstr "토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 `U+0027` (`'`) 뒤에 오고 마지막 `U+0027` (`'`) 앞에 오는 문자 시퀀스입니다."

#: src/expressions/literal-expr.md:159 src/expressions/literal-expr.md:266
msgid ""
"The literal expression's _represented character_ is derived from the literal "
"content as follows:"
msgstr "리터럴 표현식의 _표현된 문자(represented character)_는 다음과 같이 리터럴 내용으로부터 유도됩니다:"

#: src/expressions/literal-expr.md:163 src/expressions/literal-expr.md:270
msgid ""
"If the literal content is one of the following forms of escape sequence, the "
"represented character is the escape sequence's escaped value:"
msgstr "리터럴 내용이 다음 형태의 이스케이프 시퀀스 중 하나인 경우, 표현된 문자는 해당 이스케이프 시퀀스의 이스케이프된 값입니다."

#: src/expressions/literal-expr.md:164 src/expressions/literal-expr.md:215
#: src/expressions/literal-expr.md:271 src/expressions/literal-expr.md:321
msgid "[Simple escapes](#simple-escapes)"
msgstr "[단순 이스케이프](#simple-escapes)"

#: src/expressions/literal-expr.md:165 src/expressions/literal-expr.md:216
msgid "[7-bit escapes](#7-bit-escapes)"
msgstr "[7비트 이스케이프](#7-bit-escapes)"

#: src/expressions/literal-expr.md:166 src/expressions/literal-expr.md:217
msgid "[Unicode escapes](#unicode-escapes)"
msgstr "[유니코드 이스케이프](#unicode-escapes)"

#: src/expressions/literal-expr.md:170 src/expressions/literal-expr.md:276
msgid ""
"Otherwise the represented character is the single character that makes up "
"the literal content."
msgstr "그렇지 않은 경우, 표현된 문자는 리터럴 내용을 구성하는 단일 문자입니다."

#: src/expressions/literal-expr.md:174
msgid ""
"The expression's value is the [`char`](../types/textual.md) corresponding to "
"the represented character's [Unicode scalar value](http://www.unicode.org/"
"glossary/#unicode_scalar_value)."
msgstr "표현식의 값은 표현된 문자의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)에 해당하는 [`char`](../types/textual.md)입니다."

#: src/expressions/literal-expr.md:176
msgid ""
"**Note**: the permitted forms of a [CHAR_LITERAL](../tokens.md#character-"
"literals) token ensure that these rules always produce a single character."
msgstr "**참고**: 허용되는 [문자리터럴(CHAR_LITERAL)](../tokens.md#character-literals) 토큰의 형식은 이러한 규칙들이 항상 단일 문자를 생성함을 보장합니다."

#: src/expressions/literal-expr.md:178
msgid "Examples of character literal expressions:"
msgstr "문자 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:181
msgid "'R'"
msgstr "'R'"

#: src/expressions/literal-expr.md:181
msgid ""
"// R\n"
"'\\''"
msgstr ""
"// R\n"
"'\\''"

#: src/expressions/literal-expr.md:182
msgid ""
"// '\n"
"'\\x52'"
msgstr ""
"// '\n"
"'\\x52'"

#: src/expressions/literal-expr.md:183
msgid ""
"// R\n"
"'\\u{00E6}'"
msgstr ""
"// R\n"
"'\\u{00E6}'"

#: src/expressions/literal-expr.md:189
msgid "String literal expressions"
msgstr "문자열 리터럴 표현식"

#: src/expressions/literal-expr.md:193
msgid ""
"A string literal expression consists of a single [STRING_LITERAL](../"
"tokens.md#string-literals) or [RAW_STRING_LITERAL](../tokens.md#raw-string-"
"literals) token."
msgstr "문자열 리터럴 표현식은 단일 [문자열리터럴(STRING_LITERAL)](../tokens.md#string-literals) 또는 [원시문자열리터럴(RAW_STRING_LITERAL)](../tokens.md#raw-string-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:197
msgid ""
"The expression's type is a shared reference (with `static` lifetime) to the "
"primitive [`str`](../types/textual.md) type. That is, the type is `&'static "
"str`."
msgstr "표현식의 타입은 기본 [`str`](../types/textual.md) 타입에 대한 공유 참조(`static` 라이프타임을 가짐)입니다. 즉, 타입은 `&'static str`입니다."

#: src/expressions/literal-expr.md:206 src/expressions/literal-expr.md:312
msgid ""
"The token's _literal content_ is the sequence of characters following the "
"first `U+0022` (`\"`) and preceding the last `U+0022` (`\"`) in the string "
"representation of the token."
msgstr "토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 `U+0022` (`\"`) 뒤에 오고 마지막 `U+0022` (`\"`) 앞에 오는 문자 시퀀스입니다."

#: src/expressions/literal-expr.md:210 src/expressions/literal-expr.md:316
msgid ""
"The literal expression's _represented string_ is a sequence of characters "
"derived from the literal content as follows:"
msgstr "리터럴 표현식의 _표현된 문자열(represented string)_은 다음과 같이 리터럴 내용으로부터 유도된 문자 시퀀스입니다:"

#: src/expressions/literal-expr.md:214
msgid ""
"If the token is a [STRING_LITERAL](../tokens.md#string-literals), each "
"escape sequence of any of the following forms occurring in the literal "
"content is replaced by the escape sequence's escaped value."
msgstr "토큰이 [문자열리터럴(STRING_LITERAL)](../tokens.md#string-literals)인 경우, 리터럴 내용에서 나타나는 다음 형태의 각 이스케이프 시퀀스는 해당 이스케이프 시퀀스의 이스케이프된 값으로 대체됩니다."

#: src/expressions/literal-expr.md:218 src/expressions/literal-expr.md:323
msgid "[String continuation escapes](#string-continuation-escapes)"
msgstr "[문자열 연속 이스케이프](#string-continuation-escapes)"

#: src/expressions/literal-expr.md:220
msgid ""
"These replacements take place in left-to-right order. For example, the token "
"`\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`."
msgstr "이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, `\"\\\\x41\"` 토큰은 문자 `\\`, `x`, `4`, `1`로 변환됩니다."

#: src/expressions/literal-expr.md:225
msgid ""
"If the token is a [RAW_STRING_LITERAL](../tokens.md#raw-string-literals), "
"the represented string is identical to the literal content."
msgstr "토큰이 [원시문자열리터럴(RAW_STRING_LITERAL)](../tokens.md#raw-string-literals)인 경우, 표현된 문자열은 리터럴 내용과 동일합니다."

#: src/expressions/literal-expr.md:229
msgid ""
"The expression's value is a reference to a statically allocated [`str`](../"
"types/textual.md) containing the UTF-8 encoding of the represented string."
msgstr "표현식의 값은 표현된 문자열의 UTF-8 인코딩을 포함하는 정적으로 할당된 [`str`](../types/textual.md)에 대한 참조입니다."

#: src/expressions/literal-expr.md:231
msgid "Examples of string literal expressions:"
msgstr "문자열 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:246
msgid "Byte literal expressions"
msgstr "바이트 리터럴 표현식"

#: src/expressions/literal-expr.md:250
msgid ""
"A byte literal expression consists of a single [BYTE_LITERAL](../"
"tokens.md#byte-literals) token."
msgstr "바이트 리터럴 표현식은 단일 [바이트리터럴(BYTE_LITERAL)](../tokens.md#byte-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:254
msgid ""
"The expression's type is the primitive [`u8`](../types/numeric.md) type."
msgstr "표현식의 타입은 기본 [`u8`](../types/numeric.md) 타입입니다."

#: src/expressions/literal-expr.md:272 src/expressions/literal-expr.md:322
msgid "[8-bit escapes](#8-bit-escapes)"
msgstr "[8비트 이스케이프](#8-bit-escapes)"

#: src/expressions/literal-expr.md:280
msgid ""
"The expression's value is the represented character's [Unicode scalar value]"
"(http://www.unicode.org/glossary/#unicode_scalar_value)."
msgstr "표현식의 값은 표현된 문자의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)입니다."

#: src/expressions/literal-expr.md:282
msgid ""
"**Note**: the permitted forms of a [BYTE_LITERAL](../tokens.md#byte-"
"literals) token ensure that these rules always produce a single character, "
"whose Unicode scalar value is in the range of [`u8`](../types/numeric.md)."
msgstr "**참고**: 허용되는 [바이트리터럴(BYTE_LITERAL)](../tokens.md#byte-literals) 토큰의 형식은 이러한 규칙들이 항상 [`u8`](../types/numeric.md) 범위의 유니코드 스칼라 값을 가지는 단일 문자를 생성함을 보장합니다."

#: src/expressions/literal-expr.md:284
msgid "Examples of byte literal expressions:"
msgstr "바이트 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:287
msgid "b'R'"
msgstr "b'R'"

#: src/expressions/literal-expr.md:287
msgid ""
"// 82\n"
"b'\\''"
msgstr ""
"// 82\n"
"b'\\''"

#: src/expressions/literal-expr.md:288
msgid ""
"// 39\n"
"b'\\x52'"
msgstr ""
"// 39\n"
"b'\\x52'"

#: src/expressions/literal-expr.md:289
msgid ""
"// 82\n"
"b'\\xA0'"
msgstr ""
"// 82\n"
"b'\\xA0'"

#: src/expressions/literal-expr.md:290
msgid "// 160\n"
msgstr "// 160\n"

#: src/expressions/literal-expr.md:295
msgid "Byte string literal expressions"
msgstr "바이트 문자열 리터럴 표현식"

#: src/expressions/literal-expr.md:299
msgid ""
"A byte string literal expression consists of a single [BYTE_STRING_LITERAL]"
"(../tokens.md#byte-string-literals) or [RAW_BYTE_STRING_LITERAL](../"
"tokens.md#raw-byte-string-literals) token."
msgstr "바이트 문자열 리터럴 표현식은 단일 [바이트문자열리터럴(BYTE_STRING_LITERAL)](../tokens.md#byte-string-literals) 또는 [원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)](../tokens.md#raw-byte-string-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:303
msgid ""
"The expression's type is a shared reference (with `static` lifetime) to an "
"array whose element type is [`u8`](../types/numeric.md). That is, the type "
"is `&'static [u8; N]`, where `N` is the number of bytes in the represented "
"string described below."
msgstr "표현식의 타입은 요소 타입이 [`u8`](../types/numeric.md)인 배열에 대한 공유 참조(`static` 라이프타임을 가짐)입니다. 즉, 타입은 `&'static [u8; N]`이며, 여기서 `N`은 아래에서 설명하는 표현된 문자열의 바이트 수입니다."

#: src/expressions/literal-expr.md:320
msgid ""
"If the token is a [BYTE_STRING_LITERAL](../tokens.md#byte-string-literals), "
"each escape sequence of any of the following forms occurring in the literal "
"content is replaced by the escape sequence's escaped value."
msgstr "토큰이 [바이트문자열리터럴(BYTE_STRING_LITERAL)](../tokens.md#byte-string-literals)인 경우, 리터럴 내용에서 나타나는 다음 형태의 각 이스케이프 시퀀스는 해당 이스케이프 시퀀스의 이스케이프된 값으로 대체됩니다."

#: src/expressions/literal-expr.md:325
msgid ""
"These replacements take place in left-to-right order. For example, the token "
"`b\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`."
msgstr "이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, `b\"\\\\x41\"` 토큰은 문자 `\\`, `x`, `4`, `1`로 변환됩니다."

#: src/expressions/literal-expr.md:330
msgid ""
"If the token is a [RAW_BYTE_STRING_LITERAL](../tokens.md#raw-byte-string-"
"literals), the represented string is identical to the literal content."
msgstr "토큰이 [원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)](../tokens.md#raw-byte-string-literals)인 경우, 표현된 문자열은 리터럴 내용과 동일합니다."

#: src/expressions/literal-expr.md:334
msgid ""
"The expression's value is a reference to a statically allocated array "
"containing the [Unicode scalar values](http://www.unicode.org/glossary/"
"#unicode_scalar_value) of the characters in the represented string, in the "
"same order."
msgstr "표현식의 값은 표현된 문자열 속 문자들의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)들을 동일한 순서로 포함하는 정적으로 할당된 배열에 대한 참조입니다."

#: src/expressions/literal-expr.md:336
msgid ""
"**Note**: the permitted forms of [BYTE_STRING_LITERAL](../tokens.md#byte-"
"string-literals) and [RAW_BYTE_STRING_LITERAL](../tokens.md#raw-byte-string-"
"literals) tokens ensure that these rules always produce array element values "
"in the range of [`u8`](../types/numeric.md)."
msgstr "**참고**: 허용되는 [바이트문자열리터럴(BYTE_STRING_LITERAL)](../tokens.md#byte-string-literals) 및 [원시바이트문자열리터럴(RAW_BYTE_STRING_LITERAL)](../tokens.md#raw-byte-string-literals) 토큰의 형식은 이러한 규칙들이 항상 [`u8`](../types/numeric.md) 범위의 배열 요소 값을 생성함을 보장합니다."

#: src/expressions/literal-expr.md:338
msgid "Examples of byte string literal expressions:"
msgstr "바이트 문자열 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:353
msgid "C string literal expressions"
msgstr "C 문자열 리터럴 표현식"

#: src/expressions/literal-expr.md:357
msgid ""
"A C string literal expression consists of a single [C_STRING_LITERAL](../"
"tokens.md#c-string-literals) or [RAW_C_STRING_LITERAL](../tokens.md#raw-c-"
"string-literals) token."
msgstr "C 문자열 리터럴 표현식은 단일 [C문자열리터럴(C_STRING_LITERAL)](../tokens.md#c-string-literals) 또는 [원시C문자열리터럴(RAW_C_STRING_LITERAL)](../tokens.md#raw-c-string-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:361
msgid ""
"The expression's type is a shared reference (with `static` lifetime) to the "
"standard library [CStr](../../core/ffi/c_str/struct.CStr.html) type. That "
"is, the type is `&'static core::ffi::CStr`."
msgstr "표현식의 타입은 표준 라이브러리 [CStr](../../core/ffi/c_str/struct.CStr.html) 타입에 대한 공유 참조(`static` 라이프타임을 가짐)입니다. 즉, 타입은 `&'static core::ffi::CStr`입니다."

#: src/expressions/literal-expr.md:370
msgid ""
"The token's _literal content_ is the sequence of characters following the "
"first `\"` and preceding the last `\"` in the string representation of the "
"token."
msgstr "토큰의 _리터럴 내용(literal content)_은 토큰의 문자열 표현에서 첫 번째 `U+0022` (`\"`) 뒤에 오고 마지막 `U+0022` (`\"`) 앞에 오는 문자 시퀀스입니다."

#: src/expressions/literal-expr.md:374
msgid ""
"The literal expression's _represented bytes_ are a sequence of bytes derived "
"from the literal content as follows:"
msgstr "리터럴 표현식의 _표현된 바이트(represented bytes)_는 다음과 같이 리터럴 내용으로부터 유도된 바이트 시퀀스입니다:"

#: src/expressions/literal-expr.md:378
msgid ""
"If the token is a [C_STRING_LITERAL](../tokens.md#c-string-literals), the "
"literal content is treated as a sequence of items, each of which is either a "
"single Unicode character other than `\\` or an [escape](#escapes). The "
"sequence of items is converted to a sequence of bytes as follows:"
msgstr "토큰이 [C문자열리터럴(C_STRING_LITERAL)](../tokens.md#c-string-literals)인 경우, 리터럴 내용은 `\\`가 아닌 단일 유니코드 문자 또는 [이스케이프](#escapes)인 항목들의 시퀀스로 취급됩니다. 항목들의 시퀀스는 다음과 같이 바이트 시퀀스로 변환됩니다:"

#: src/expressions/literal-expr.md:380
msgid "Each single Unicode character contributes its UTF-8 representation."
msgstr "각 단일 유니코드 문자는 자신의 UTF-8 표현을 기여합니다."

#: src/expressions/literal-expr.md:381
msgid ""
"Each [simple escape](#simple-escapes) contributes the [Unicode scalar value]"
"(http://www.unicode.org/glossary/#unicode_scalar_value) of its escaped value."
msgstr "각 [단순 이스케이프](#simple-escapes)는 이스케이프된 값의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)을 기여합니다."

#: src/expressions/literal-expr.md:382
msgid ""
"Each [8-bit escape](#8-bit-escapes) contributes a single byte containing the "
"[Unicode scalar value](http://www.unicode.org/glossary/"
"#unicode_scalar_value) of its escaped value."
msgstr "각 [8비트 이스케이프](#8-bit-escapes)는 이스케이프된 값의 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)을 포함하는 단일 바이트를 기여합니다."

#: src/expressions/literal-expr.md:383
msgid ""
"Each [unicode escape](#unicode-escapes) contributes the UTF-8 representation "
"of its escaped value."
msgstr "각 [유니코드 이스케이프](#unicode-escapes)는 이스케이프된 값의 UTF-8 표현을 기여합니다."

#: src/expressions/literal-expr.md:384
msgid ""
"Each [string continuation escape](#string-continuation-escapes) contributes "
"no bytes."
msgstr "각 [문자열 연속 이스케이프](#string-continuation-escapes)는 어떠한 바이트도 기여하지 않습니다."

#: src/expressions/literal-expr.md:388
msgid ""
"If the token is a [RAW_C_STRING_LITERAL](../tokens.md#raw-c-string-"
"literals), the represented bytes are the UTF-8 encoding of the literal "
"content."
msgstr "토큰이 [원시C문자열리터럴(RAW_C_STRING_LITERAL)](../tokens.md#raw-c-string-literals)인 경우, 표현된 바이트는 리터럴 내용의 UTF-8 인코딩입니다."

#: src/expressions/literal-expr.md:390
msgid ""
"**Note**: the permitted forms of [C_STRING_LITERAL](../tokens.md#c-string-"
"literals) and [RAW_C_STRING_LITERAL](../tokens.md#raw-c-string-literals) "
"tokens ensure that the represented bytes never include a null byte."
msgstr "**참고**: 허용되는 [C문자열리터럴(C_STRING_LITERAL)](../tokens.md#c-string-literals) 및 [원시C문자열리터럴(RAW_C_STRING_LITERAL)](../tokens.md#raw-c-string-literals) 토큰의 형식은 표현된 바이트에 널 바이트가 포함되지 않음을 보장합니다."

#: src/expressions/literal-expr.md:394
msgid ""
"The expression's value is a reference to a statically allocated [CStr](../../"
"core/ffi/c_str/struct.CStr.html) whose array of bytes contains the "
"represented bytes followed by a null byte."
msgstr "표현식의 값은 표현된 바이트 뒤에 널 바이트가 뒤따르는 바이트 배열을 포함하는 정적으로 할당된 [CStr](../../core/ffi/c_str/struct.CStr.html)에 대한 참조입니다."

#: src/expressions/literal-expr.md:396
msgid "Examples of C string literal expressions:"
msgstr "C 문자열 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:412
msgid "\"\\xE6\""
msgstr "\"\\xE6\""

#: src/expressions/literal-expr.md:412
msgid "// [230]\n"
msgstr "// [230]\n"

#: src/expressions/literal-expr.md:413
msgid "// [195, 166]\n"
msgstr "// [195, 166]\n"

#: src/expressions/literal-expr.md:418
msgid "Integer literal expressions"
msgstr "정수 리터럴 표현식"

#: src/expressions/literal-expr.md:422
msgid ""
"An integer literal expression consists of a single [INTEGER_LITERAL](../"
"tokens.md#integer-literals) token."
msgstr "정수 리터럴 표현식은 단일 [정수리터럴(INTEGER_LITERAL)](../tokens.md#integer-literals) 토큰으로 구성됩니다."

#: src/expressions/literal-expr.md:426
msgid ""
"If the token has a [suffix](../tokens.md#suffixes), the suffix must be the "
"name of one of the [primitive integer types](../types/numeric.md): `u8`, "
"`i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, or "
"`isize`, and the expression has that type."
msgstr "토큰에 [접미사(suffix)](../tokens.md#suffixes)가 있는 경우, 접미사는 [기본 정수 타입](../types/numeric.md) 중 하나인 `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, 또는 `isize`여야 하며, 표현식은 해당 타입을 가집니다."

#: src/expressions/literal-expr.md:430 src/expressions/literal-expr.md:521
msgid ""
"If the token has no suffix, the expression's type is determined by type "
"inference:"
msgstr "토큰에 접미사가 없는 경우, 표현식의 타입은 타입 추론에 의해 결정됩니다."

#: src/expressions/literal-expr.md:434
msgid ""
"If an integer type can be _uniquely_ determined from the surrounding program "
"context, the expression has that type."
msgstr "주변 프로그램 문맥으로부터 정수 타입을 _유일하게_ 결정할 수 있다면, 표현식은 해당 타입을 가집니다."

#: src/expressions/literal-expr.md:438
msgid ""
"If the program context under-constrains the type, it defaults to the signed "
"32-bit integer `i32`."
msgstr "프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 부호 있는 32비트 정수인 `i32`가 사용됩니다."

#: src/expressions/literal-expr.md:442 src/expressions/literal-expr.md:533
msgid ""
"If the program context over-constrains the type, it is considered a static "
"type error."
msgstr "프로그램 문맥이 타입을 과도하게 제약하는 경우, 정적 타입 에러로 간주됩니다."

#: src/expressions/literal-expr.md:444
msgid "Examples of integer literal expressions:"
msgstr "정수 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:447 src/expressions/literal-expr.md:448
#: src/expressions/literal-expr.md:453 src/expressions/literal-expr.md:456
#: src/expressions/literal-expr.md:459
msgid "// type i32\n"
msgstr "// i32 타입\n"

#: src/expressions/literal-expr.md:449 src/expressions/literal-expr.md:450
msgid "// type u32\n"
msgstr "// u32 타입\n"

#: src/expressions/literal-expr.md:451
msgid "// type u64\n"
msgstr "// u64 타입\n"

#: src/expressions/literal-expr.md:454
msgid "// type u8\n"
msgstr "// u8 타입\n"

#: src/expressions/literal-expr.md:457
msgid "// type i16\n"
msgstr "// i16 타입\n"

#: src/expressions/literal-expr.md:460
msgid "// type i64\n"
msgstr "// i64 타입\n"

#: src/expressions/literal-expr.md:462
msgid "// type usize\n"
msgstr "// usize 타입\n"

#: src/expressions/literal-expr.md:467 src/expressions/literal-expr.md:548
msgid ""
"The value of the expression is determined from the string representation of "
"the token as follows:"
msgstr "표현식의 값은 다음과 같이 토큰의 문자열 표현으로부터 결정됩니다:"

#: src/expressions/literal-expr.md:471
msgid ""
"An integer radix is chosen by inspecting the first two characters of the "
"string, as follows:"
msgstr "정수 기수(radix)는 문자열의 처음 두 문자를 조사하여 다음과 같이 결정됩니다:"

#: src/expressions/literal-expr.md:473
msgid "`0b` indicates radix 2"
msgstr "`0b`는 기수 2를 나타냅니다."

#: src/expressions/literal-expr.md:474
msgid "`0o` indicates radix 8"
msgstr "`0o`는 기수 8을 나타냅니다."

#: src/expressions/literal-expr.md:475
msgid "`0x` indicates radix 16"
msgstr "`0x`는 기수 16을 나타냅니다."

#: src/expressions/literal-expr.md:476
msgid "otherwise the radix is 10."
msgstr "그 외의 경우 기수는 10입니다."

#: src/expressions/literal-expr.md:480
msgid ""
"If the radix is not 10, the first two characters are removed from the string."
msgstr "기수가 10이 아닌 경우, 처음 두 문자가 문자열에서 제거됩니다."

#: src/expressions/literal-expr.md:484 src/expressions/literal-expr.md:552
msgid "Any suffix is removed from the string."
msgstr "모든 접미사는 문자열에서 제거됩니다."

#: src/expressions/literal-expr.md:488 src/expressions/literal-expr.md:556
msgid "Any underscores are removed from the string."
msgstr "모든 밑줄(`_`)은 문자열에서 제거됩니다."

#: src/expressions/literal-expr.md:492
msgid ""
"The string is converted to a `u128` value as if by [`u128::from_str_radix`]"
"(../../std/primitive.u128.html#method.from_str_radix) with the chosen radix. "
"If the value does not fit in `u128`, it is a compiler error."
msgstr "문자열은 선택된 기수와 함께 [`u128::from_str_radix`](../../std/primitive.u128.html#method.from_str_radix)를 사용한 것처럼 `u128` 값으로 변환됩니다. 만약 값이 `u128`에 맞지 않으면 컴파일 에러입니다."

#: src/expressions/literal-expr.md:497
msgid ""
"The `u128` value is converted to the expression's type via a [numeric cast]"
"(operator-expr.md#numeric-cast)."
msgstr "`u128` 값은 [숫자 캐스트(numeric cast)](operator-expr.md#numeric-cast)를 통해 표현식의 타입으로 변환됩니다."

#: src/expressions/literal-expr.md:499
msgid ""
"**Note**: The final cast will truncate the value of the literal if it does "
"not fit in the expression's type. `rustc` includes a [lint check](../"
"attributes/diagnostics.md#lint-check-attributes) named "
"`overflowing_literals`, defaulting to `deny`, which rejects expressions "
"where this occurs."
msgstr "**참고**: 최종 캐스트는 리터럴의 값이 표현식의 타입에 맞지 않을 경우 값을 잘라냅니다(truncate). `rustc`에는 `overflowing_literals`라는 이름의 [린트 체크](../attributes/diagnostics.md#lint-check-attributes)가 포함되어 있으며 기본값은 `deny`로, 이러한 상황이 발생하는 표현식을 거부합니다."

#: src/expressions/literal-expr.md:502
msgid ""
"**Note**: `-1i8`, for example, is an application of the [negation operator]"
"(operator-expr.md#negation-operators) to the literal expression `1i8`, not a "
"single integer literal expression. See [Overflow](operator-expr.md#overflow) "
"for notes on representing the most negative value for a signed type."
msgstr "**참고**: 예를 들어 `-1i8`은 리터럴 표현식 `1i8`에 [부정 연산자(negation operator)](operator-expr.md#negation-operators)를 적용한 것이지, 단일 정수 리터럴 표현식이 아닙니다. 부호 있는 타입에서 가장 작은 음수 값을 표현하는 방식에 대한 노트는 [오버플로(Overflow)](operator-expr.md#overflow)를 참조하세요."

#: src/expressions/literal-expr.md:507
msgid "Floating-point literal expressions"
msgstr "부동 소수점 리터럴 표현식"

#: src/expressions/literal-expr.md:511
msgid "A floating-point literal expression has one of two forms:"
msgstr "부동 소수점 리터럴 표현식은 다음 두 가지 형식 중 하나를 가집니다:"

#: src/expressions/literal-expr.md:512
msgid "a single [FLOAT_LITERAL](../tokens.md#floating-point-literals) token"
msgstr "단일 [부동소수점리터럴(FLOAT_LITERAL)](../tokens.md#floating-point-literals) 토큰"

#: src/expressions/literal-expr.md:513
msgid ""
"a single [INTEGER_LITERAL](../tokens.md#integer-literals) token which has a "
"suffix and no radix indicator"
msgstr "접미사가 있고 기수 표시가 없는 단일 [정수리터럴(INTEGER_LITERAL)](../tokens.md#integer-literals) 토큰"

#: src/expressions/literal-expr.md:517
msgid ""
"If the token has a [suffix](../tokens.md#suffixes), the suffix must be the "
"name of one of the [primitive floating-point types](../types/"
"numeric.md#floating-point-types): `f32` or `f64`, and the expression has "
"that type."
msgstr "토큰에 [접미사(suffix)](../tokens.md#suffixes)가 있는 경우, 접미사는 [기본 부동 소수점 타입](../types/numeric.md#floating-point-types) 중 하나인 `f32` 또는 `f64`여야 하며, 표현식은 해당 타입을 가집니다."

#: src/expressions/literal-expr.md:525
msgid ""
"If a floating-point type can be _uniquely_ determined from the surrounding "
"program context, the expression has that type."
msgstr "주변 프로그램 문맥으로부터 부동 소수점 타입을 _유일하게_ 결정할 수 있다면, 표현식은 해당 타입을 가집니다."

#: src/expressions/literal-expr.md:529
msgid "If the program context under-constrains the type, it defaults to `f64`."
msgstr "프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 `f64`가 사용됩니다."

#: src/expressions/literal-expr.md:535
msgid "Examples of floating-point literal expressions:"
msgstr "부동 소수점 리터럴 표현식의 예시:"

#: src/expressions/literal-expr.md:538 src/expressions/literal-expr.md:539
#: src/expressions/literal-expr.md:541 src/expressions/literal-expr.md:543
msgid "// type f64\n"
msgstr "// f64 타입\n"

#: src/expressions/literal-expr.md:540 src/expressions/literal-expr.md:542
msgid "// type f32\n"
msgstr "// f32 타입\n"

#: src/expressions/literal-expr.md:560
msgid ""
"The string is converted to the expression's type as if by [`f32::from_str`]"
"(../../core/primitive.f32.md#method.from_str) or [`f64::from_str`](../../"
"core/primitive.f64.md#method.from_str)."
msgstr "문자열은 [`f32::from_str`](../../core/primitive.f32.md#method.from_str) 또는 [`f64::from_str`](../../core/primitive.f64.md#method.from_str)을 사용한 것처럼 표현식의 타입으로 변환됩니다."

#: src/expressions/literal-expr.md:562
msgid ""
"**Note**: `-1.0`, for example, is an application of the [negation operator]"
"(operator-expr.md#negation-operators) to the literal expression `1.0`, not a "
"single floating-point literal expression."
msgstr "**참고**: 예를 들어 `-1.0`은 리터럴 표현식 `1.0`에 [부정 연산자(negation operator)](operator-expr.md#negation-operators)를 적용한 것이지, 단일 부동 소수점 리터럴 표현식이 아닙니다."

#: src/expressions/literal-expr.md:564
msgid ""
"**Note**: `inf` and `NaN` are not literal tokens. The [`f32::INFINITY`]"
"(../../std/primitive.f32.html#associatedconstant.INFINITY), [`f64::INFINITY`]"
"(../../std/primitive.f64.html#associatedconstant.INFINITY), [`f32::NAN`]"
"(../../std/primitive.f32.html#associatedconstant.NAN), and [`f64::NAN`]"
"(../../std/primitive.f64.html#associatedconstant.NAN) constants can be used "
"instead of literal expressions. In `rustc`, a literal large enough to be "
"evaluated as infinite will trigger the `overflowing_literals` lint check."
msgstr "**참고**: `inf`와 `NaN`은 리터럴 토큰이 아닙니다. 리터럴 표현식 대신 [`f32::INFINITY`](../../std/primitive.f32.html#associatedconstant.INFINITY), [`f64::INFINITY`](../../std/primitive.f64.html#associatedconstant.INFINITY), [`f32::NAN`](../../std/primitive.f32.html#associatedconstant.NAN), [`f64::NAN`](../../std/primitive.f64.html#associatedconstant.NAN) 상수들을 사용할 수 있습니다. `rustc`에서 무한대로 평가될 만큼 큰 리터럴은 `overflowing_literals` 린트 체크를 발생시킵니다."

#: src/expressions/literal-expr.md:570
msgid "Boolean literal expressions"
msgstr "불리언 리터럴 표현식"

#: src/expressions/literal-expr.md:574
msgid ""
"A boolean literal expression consists of one of the keywords `true` or "
"`false`."
msgstr "불리언 리터럴 표현식은 `true` 또는 `false` 키워드 중 하나로 구성됩니다."

#: src/expressions/literal-expr.md:578
msgid ""
"The expression's type is the primitive [boolean type](../types/boolean.md), "
"and its value is:"
msgstr "표현식의 타입은 기본 [불리언 타입](../types/boolean.md)이며, 그 값은 다음과 같습니다:"

#: src/expressions/literal-expr.md:579
msgid "true if the keyword is `true`"
msgstr "키워드가 `true`인 경우 true"

#: src/expressions/literal-expr.md:580
msgid "false if the keyword is `false`"
msgstr "키워드가 `false`인 경우 false"

#: src/expressions/path-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_PathExpression_ :  \n"
"      [_PathInExpression_](../paths.md#paths-in-expressions)  \n"
"   | [_QualifiedPathInExpression_](../paths.md#qualified-paths)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_경로표현식_ :  \n"
"      [_표현식내경로_](../paths.md#paths-in-expressions)  \n"
"   | [_한정된표현식내경로_](../paths.md#qualified-paths)"

#: src/expressions/path-expr.md:14
msgid ""
"A [path](../paths.md) used as an expression context denotes either a local "
"variable or an item."
msgstr "표현식 컨텍스트에서 사용된 [경로](../paths.md)는 지역 변수 또는 아이템을 나타냅니다."

#: src/expressions/path-expr.md:18
msgid ""
"Path expressions that resolve to local or static variables are [place "
"expressions](../expressions.md#place-expressions-and-value-expressions), "
"other paths are [value expressions](../expressions.md#place-expressions-and-"
"value-expressions)."
msgstr "지역 변수 또는 정적 변수로 해석되는 경로 표현식은 [장소 표현식](../expressions.md#place-expressions-and-value-expressions)이며, 그 외의 경로는 [값 표현식](../expressions.md#place-expressions-and-value-expressions)입니다."

#: src/expressions/path-expr.md:22
msgid ""
"Using a [`static mut`](../items/static-items.md#mutable-statics) variable "
"requires an [`unsafe` block](block-expr.md#unsafe-blocks)."
msgstr "[`static mut`](../items/static-items.md#mutable-statics) 변수를 사용하는 것은 [`unsafe` 블록](block-expr.md#unsafe-blocks)을 요구합니다."

#: src/expressions/path-expr.md:40
msgid ""
"Evaluation of associated constants is handled the same way as [`const` "
"blocks](block-expr.md#const-blocks)."
msgstr "연관 상수의 평가는 [`const` 블록](block-expr.md#const-blocks)과 동일한 방식으로 처리됩니다."

#: src/expressions/block-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_BlockExpression_ :  \n"
"   `{`  \n"
"      [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"      _Statements_<sup>?</sup>  \n"
"   `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_블록표현식_ :  \n"
"   `{`  \n"
"      [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"      _구문들_<sup>?</sup>  \n"
"   `}`"

#: src/expressions/block-expr.md:14
msgid ""
"_Statements_ :  \n"
"      [_Statement_](../statements.md)<sup>+</sup>  \n"
"   | [_Statement_](../statements.md)<sup>+</sup> [_ExpressionWithoutBlock_]"
"(../expressions.md)  \n"
"   | [_ExpressionWithoutBlock_](../expressions.md)"
msgstr ""
"_구문들_ :  \n"
"      [_구문_](../statements.md)<sup>+</sup>  \n"
"   | [_구문_](../statements.md)<sup>+</sup> [_블록없는표현식_]"
"(../expressions.md)  \n"
"   | [_블록없는표현식_](../expressions.md)"

#: src/expressions/block-expr.md:21
msgid ""
"A _block expression_, or _block_, is a control flow expression and anonymous "
"namespace scope for items and variable declarations."
msgstr "_블록 표현식(block expression)_ 또는 줄여서 _블록_은 제어 흐름 표현식이자 아이템 및 변수 선언을 위한 익명 네임스페이스 스코프입니다."

#: src/expressions/block-expr.md:25
msgid ""
"As a control flow expression, a block sequentially executes its component "
"non-item declaration statements and then its final optional expression."
msgstr "제어 흐름 표현식으로서 블록은 구성 요소인 비-아이템 선언 구문들을 순차적으로 실행한 후, 마지막의 선택적 표현식을 실행합니다."

#: src/expressions/block-expr.md:29
msgid ""
"As an anonymous namespace scope, item declarations are only in scope inside "
"the block itself and variables declared by `let` statements are in scope "
"from the next statement until the end of the block. See the [scopes](../"
"names/scopes.md) chapter for more details."
msgstr "익명 네임스페이스 스코프로서 아이템 선언은 블록 내부에서만 스코프 내에 있으며, `let` 문에 의해 선언된 변수들은 다음 구문부터 블록 끝까지 스코프 내에 있습니다. 자세한 내용은 [스코프](../names/scopes.md) 장을 참조하세요."

#: src/expressions/block-expr.md:34
msgid ""
"The syntax for a block is `{`, then any [inner attributes](../"
"attributes.md), then any number of [statements](../statements.md), then an "
"optional expression, called the final operand, and finally a `}`."
msgstr "블록의 구문은 `{`로 시작하여 내부 속성들(../attributes.md), 임의의 개수의 구문들(../statements.md), 마지막 피연산자라고 불리는 선택적 표현식, 그리고 마지막으로 `}`가 오는 형태입니다."

#: src/expressions/block-expr.md:38
msgid ""
"Statements are usually required to be followed by a semicolon, with two "
"exceptions:"
msgstr "구문 뒤에는 보통 세미콜론이 붙어야 하지만, 다음 두 가지 예외가 있습니다:"

#: src/expressions/block-expr.md:40
msgid "Item declaration statements do not need to be followed by a semicolon."
msgstr "아이템 선언 구문 뒤에는 세미콜론이 붙을 필요가 없습니다."

#: src/expressions/block-expr.md:41
msgid ""
"Expression statements usually require a following semicolon except if its "
"outer expression is a flow control expression."
msgstr "표현식 구문은 보통 뒤에 세미콜론이 필요하지만, 해당 구문의 외부 표현식이 흐름 제어 표현식인 경우는 제외합니다."

#: src/expressions/block-expr.md:45
msgid ""
"Furthermore, extra semicolons between statements are allowed, but these "
"semicolons do not affect semantics."
msgstr "또한, 구문들 사이에 추가적인 세미콜론을 사용하는 것이 허용되지만, 이러한 세미콜론들은 시맨틱(의미론)에 영향을 주지 않습니다."

#: src/expressions/block-expr.md:49
msgid ""
"When evaluating a block expression, each statement, except for item "
"call items, is executed sequentially."
msgstr "블록 표현식을 평가할 때, 아이템 선언 구문을 제외한 각 구문은 순차적으로 실행됩니다."

#: src/expressions/block-expr.md:53
msgid "Then the final operand is executed, if given."
msgstr "그 후, 마지막 피연산자가 주어진 경우 이를 실행합니다."

#: src/expressions/block-expr.md:57
msgid ""
"The type of a block is the type of the final operand, or `()` if the final "
"operand is omitted."
msgstr "블록의 타입은 마지막 피연산자의 타입이며, 마지막 피연산자가 생략된 경우 `()`입니다."

#: src/expressions/block-expr.md:73
msgid ""
"Note: As a control flow expression, if a block expression is the outer "
"expression of an expression statement, the expected type is `()` unless it "
"is followed immediately by a semicolon."
msgstr "참고: 제어 흐름 표현식으로서, 블록 표현식이 표현식 구문의 외부 표현식인 경우, 뒤에 즉시 세미콜론이 오지 않는 한 기대되는 타입은 `()`입니다."

#: src/expressions/block-expr.md:77
msgid ""
"Blocks are always [value expressions](../expressions.md#place-expressions-"
"and-value-expressions) and evaluate the last operand in value expression "
"context."
msgstr "블록은 항상 [값 표현식](../expressions.md#place-expressions-and-value-expressions)이며, 마지막 피연산자를 값 표현식 컨텍스트에서 평가합니다."

#: src/expressions/block-expr.md:79
msgid ""
"**Note**: This can be used to force moving a value if really needed. For "
"example, the following example fails on the call to `consume_self` because "
"the struct was moved out of `s` in the block expression."
msgstr "**참고**: 이는 정말 필요한 경우 값을 강제로 이동(move)시키는 데 사용될 수 있습니다. 예를 들어, 다음 예제는 블록 표현식 내에서 구조체가 `s`로부터 이동되었기 때문에 `consume_self` 호출에서 실패합니다."

#: src/expressions/block-expr.md:93
msgid "// Move the value out of `s` in the block expression.\n"
msgstr "// 블록 표현식 내에서 `s`로부터 값을 이동시킵니다.\n"

#: src/expressions/block-expr.md:96
msgid "// Fails to execute because `s` is moved out of.\n"
msgstr "// `s`가 이동되었으므로 실행에 실패합니다.\n"

#: src/expressions/block-expr.md:103
msgid "`async` blocks"
msgstr "`async` 블록"

#: src/expressions/block-expr.md:107
msgid ""
"**<sup>Syntax</sup>**  \n"
"_AsyncBlockExpression_ :  \n"
"   `async` `move`<sup>?</sup> _BlockExpression_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_비동기블록표현식_ :  \n"
"   `async` `move`<sup>?</sup> _블록표현식_"

#: src/expressions/block-expr.md:113
msgid ""
"An _async block_ is a variant of a block expression which evaluates to a "
"future."
msgstr "_비동기 블록(async block)_은 퓨처(future)로 평가되는 블록 표현식의 변형입니다."

#: src/expressions/block-expr.md:117
msgid ""
"The final expression of the block, if present, determines the result value "
"of the future."
msgstr "블록의 마지막 표현식이 존재하는 경우, 퓨처의 결과 값을 결정합니다."

#: src/expressions/block-expr.md:121
msgid ""
"Executing an async block is similar to executing a closure expression: its "
"immediate effect is to produce and return an anonymous type."
msgstr "비동기 블록을 실행하는 것은 클로저 표현식을 실행하는 것과 유사합니다. 즉각적인 효과는 익명 타입을 생성하고 반환하는 것입니다."

#: src/expressions/block-expr.md:126
msgid ""
"Whereas closures return a type that implements one or more of the "
"[`std::ops::Fn`](../../core/ops/function/trait.Fn.html) traits, however, the "
"type returned for an async block implements the [`std::future::Future`]"
"(../../core/future/future/trait.Future.html) trait."
msgstr "클로저는 하나 이상의 [`std::ops::Fn`](../../core/ops/function/trait.Fn.html) 트레잇을 구현하는 타입을 반환하는 반면, 비동기 블록에 대해 반환되는 타입은 [`std::future::Future`](../../core/future/future/trait.Future.html) 트레잇을 구현합니다."

#: src/expressions/block-expr.md:130
msgid "The actual data format for this type is unspecified."
msgstr "이 타입의 실제 데이터 형식은 지정되어 있지 않습니다."

#: src/expressions/block-expr.md:132
msgid ""
"**Note:** The future type that rustc generates is roughly equivalent to an "
"enum with one variant per `await` point, where each variant stores the data "
"needed to resume from its corresponding point."
msgstr "**참고:** rustc가 생성하는 퓨처 타입은 각 `await` 지점마다 하나의 변형(variant)을 가진 열거형과 거의 동일하며, 각 변형은 해당 지점에서 재개하는 데 필요한 데이터를 저장합니다."

#: src/expressions/block-expr.md:134
msgid ""
"**Edition differences**: Async blocks are only available beginning with Rust "
"2018."
msgstr "**에디션 차이**: 비동기 블록은 러스트 2018부터만 사용할 수 있습니다."

#: src/expressions/block-expr.md:138 src/types/closure.md:66
msgid "Capture modes"
msgstr "캡처 모드"

#: src/expressions/block-expr.md:140
msgid ""
"Async blocks capture variables from their environment using the same "
"[capture modes](../types/closure.md#capture-modes) as closures. Like "
"closures, when written `async { .. }` the capture mode for each variable "
"will be inferred from the content of the block. `async move { .. }` blocks "
"however will move all referenced variables into the resulting future."
msgstr "비동기 블록은 클로저와 동일한 [캡처 모드](../types/closure.md#capture-modes)를 사용하여 환경으로부터 변수를 캡처합니다. 클로저와 마찬가지로, `async { .. }`라고 작성하면 각 변수에 대한 캡처 모드가 블록의 내용으로부터 추론됩니다. 반면 `async move { .. }` 블록은 참조된 모든 변수를 결과 퓨처로 이동(move)시킵니다."

#: src/expressions/block-expr.md:146
msgid "Async context"
msgstr "비동기 컨텍스트"

#: src/expressions/block-expr.md:148
msgid ""
"Because async blocks construct a future, they define an **async context** "
"which can in turn contain [`await` expressions](await-expr.md). Async "
"contexts are established by async blocks as well as the bodies of async "
"functions, whose semantics are defined in terms of async blocks."
msgstr "비동기 블록은 퓨처를 생성하므로, 다시 [`await` 표현식](await-expr.md)을 포함할 수 있는 **비동기 컨텍스트(async context)**를 정의합니다. 비동기 컨텍스트는 비동기 블록뿐만 아니라, 비동기 블록의 관점에서 시맨틱이 정의되는 비동기 함수의 본문에 의해 형성됩니다."

#: src/expressions/block-expr.md:153
msgid "Control-flow operators"
msgstr "제어 흐름 연산자"

#: src/expressions/block-expr.md:157
msgid "Async blocks act like a function boundary, much like closures."
msgstr "비동기 블록은 클로저와 매우 비슷하게 함수의 경계처럼 작동합니다."

#: src/expressions/block-expr.md:161
msgid ""
"Therefore, the `?` operator and `return` expressions both affect the output "
"of the future, not the enclosing function or other context. That is, `return "
"<expr>` from within an async block will return the result of `<expr>` as the "
"output of the future. Similarly, if `<expr>?` propagates an error, that "
"error is propagated as the result of the future."
msgstr "따라서 `?` 연산자와 `return` 표현식은 모두 둘러싼 함수나 다른 컨텍스트가 아닌, 퓨처의 출력에 영향을 줍니다. 즉, 비동기 블록 내에서의 `return <expr>`은 `<expr>`의 결과를 퓨처의 출력으로 반환합니다. 마찬가지로, `<expr>?`가 에러를 전파하면, 해당 에러는 퓨처의 결과로서 전파됩니다."

#: src/expressions/block-expr.md:167
msgid ""
"Finally, the `break` and `continue` keywords cannot be used to branch out "
"from an async block. Therefore the following is illegal:"
msgstr "마지막으로, `break`와 `continue` 키워드는 비동기 블록 밖으로 분기하는 데 사용될 수 없습니다. 따라서 다음은 유효하지 않습니다."

#: src/expressions/block-expr.md:173
msgid "// error[E0267]: `break` inside of an `async` block\n"
msgstr "// error[E0267]: `async` 블록 내부의 `break`\n"

#: src/expressions/block-expr.md:180
msgid "`const` blocks"
msgstr "`const` 블록"

#: src/expressions/block-expr.md:184
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ConstBlockExpression_ :  \n"
"   `const` _BlockExpression_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Const블록표현식_ :  \n"
"   `const` _블록표현식_"

#: src/expressions/block-expr.md:190
msgid ""
"A _const block_ is a variant of a block expression whose body evaluates at "
"compile-time instead of at runtime."
msgstr "_const 블록_은 본문이 런타임이 아닌 컴파일 타임에 평가되는 블록 표현식의 변형입니다."

#: src/expressions/block-expr.md:194
msgid ""
"Const blocks allows you to define a constant value without having to define "
"new [constant items](../items/constant-items.md), and thus they are also "
"sometimes referred as _inline consts_. It also supports type inference so "
"there is no need to specify the type, unlike [constant items](../items/"
"constant-items.md)."
msgstr "const 블록을 사용하면 새로운 [상수 아이템](../items/constant-items.md)을 정의할 필요 없이 상수 값을 정의할 수 있으며, 이러한 이유로 때때로 _인라인 상수(inline consts)_라고도 불립니다. 또한 타입 추론을 지원하므로 [상수 아이템](../items/constant-items.md)과 달리 타입을 명시할 필요가 없습니다."

#: src/expressions/block-expr.md:199
msgid ""
"Const blocks have the ability to reference generic parameters in scope, "
"unlike [free](../glossary.md#free-item) constant items. They are desugared "
"to constant items with generic parameters in scope (similar to associated "
"constants, but without a trait or type they are associated with). For "
"example, this code:"
msgstr "const 블록은 [자유(free)](../glossary.md#free-item) 상수 아이템과 달리 스코프 내의 제네릭 매개변수를 참조할 수 있는 능력이 있습니다. 이들은 스코프 내의 제네릭 매개변수를 가진 상수 아이템으로 디슈거링(desugared)됩니다 (연관 상수와 유사하지만, 연관된 트레잇이나 타입이 없는 형태입니다). 예를 들어, 다음 코드는:"

#: src/expressions/block-expr.md:226
msgid ""
"If the const block expression is executed at runtime, then the constant is "
"guaranteed to be evaluated, even if its return value is ignored:"
msgstr "const 블록 표현식이 런타임에 실행되면, 반환 값이 무시되더라도 해당 상수는 반드시 평가됨이 보장됩니다:"

#: src/expressions/block-expr.md:230
msgid ""
"// If this code ever gets executed, then the assertion has definitely\n"
"    // been evaluated at compile-time.\n"
msgstr ""
"// 이 코드가 실행된다면, 해당 어설션(assertion)은 분명히 컴파일 타임에\n"
"    // 평가된 것입니다.\n"

#: src/expressions/block-expr.md:233
msgid ""
"// Here we can have unsafe code relying on the type being non-zero-sized.\n"
"    /* ... */"
msgstr ""
"// 여기서 타입이 0 크기가 아님에 의존하는 unsafe 코드를 가질 수 있습니다.\n"
"    /* ... */"

#: src/expressions/block-expr.md:242
msgid ""
"If the const block expression is not executed at runtime, it may or may not "
"be evaluated:"
msgstr "const 블록 표현식이 런타임에 실행되지 않는 경우, 평가될 수도 있고 되지 않을 수도 있습니다:"

#: src/expressions/block-expr.md:245
msgid "// The panic may or may not occur when the program is built.\n"
msgstr "// 프로그램이 빌드될 때 패닉이 발생할 수도 있고 발생하지 않을 수도 있습니다.\n"

#: src/expressions/block-expr.md:252
msgid "`unsafe` blocks"
msgstr "`unsafe` 블록"

#: src/expressions/block-expr.md:254
msgid ""
"**<sup>Syntax</sup>**  \n"
"_UnsafeBlockExpression_ :  \n"
"   `unsafe` _BlockExpression_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Unsafe블록표현식_ :  \n"
"   `unsafe` _블록표현식_"

#: src/expressions/block-expr.md:258
msgid ""
"_See [`unsafe` blocks](../unsafe-keyword.md#unsafe-blocks-unsafe-) for more "
"information on when to use `unsafe`_."
msgstr "_`unsafe`를 언제 사용해야 하는지에 대한 자세한 내용은 [`unsafe` 블록](../unsafe-keyword.md#unsafe-blocks-unsafe-)을 참조하세요._"

#: src/expressions/block-expr.md:260
msgid ""
"A block of code can be prefixed with the `unsafe` keyword to permit [unsafe "
"operations](../unsafety.md). Examples:"
msgstr "코드 블록 앞에 `unsafe` 키워드를 붙여 [안전하지 않은 연산(unsafe operations)](../unsafety.md)을 허용할 수 있습니다. 예시:"

#: src/expressions/block-expr.md:277 src/expressions/loop-expr.md:332
msgid "Labelled block expressions"
msgstr "레이블이 붙은 블록 표현식"

#: src/expressions/block-expr.md:279
msgid ""
"Labelled block expressions are documented in the [Loops and other breakable "
"expressions](loop-expr.md#labelled-block-expressions) section."
msgstr "레이블이 붙은 블록 표현식은 [루프 및 기타 중단 가능한 표현식](loop-expr.md#labelled-block-expressions) 섹션에 문서화되어 있습니다."

#: src/expressions/block-expr.md:283
msgid "Attributes on block expressions"
msgstr "블록 표현식의 속성"

#: src/expressions/block-expr.md:287
msgid ""
"[Inner attributes](../attributes.md) are allowed directly after the opening "
"brace of a block expression in the following situations:"
msgstr "[내부 속성](../attributes.md)은 다음 상황에서 블록 표현식의 여는 중괄호 바로 뒤에 허용됩니다."

#: src/expressions/block-expr.md:289
msgid ""
"[Function](../items/functions.md) and [method](../items/associated-"
"items.md#methods) bodies."
msgstr "[함수](../items/functions.md) 및 [메서드](../items/associated-items.md#methods) 본문."

#: src/expressions/block-expr.md:290
msgid ""
"Loop bodies ([`loop`](loop-expr.md#infinite-loops), [`while`](loop-"
"expr.md#predicate-loops), [`while let`](loop-expr.md#predicate-pattern-"
"loops), and [`for`](loop-expr.md#iterator-loops))."
msgstr "루프 본문([`loop`](loop-expr.md#infinite-loops), [`while`](loop-expr.md#predicate-loops), [`while let`](loop-expr.md#predicate-pattern-loops), 그리고 [`for`](loop-expr.md#iterator-loops))."

#: src/expressions/block-expr.md:291
msgid "Block expressions used as a [statement](../statements.md)."
msgstr "[구문](../statements.md)으로 사용된 블록 표현식."

#: src/expressions/block-expr.md:292
msgid ""
"Block expressions as elements of [array expressions](array-expr.md), [tuple "
"expressions](tuple-expr.md), [call expressions](call-expr.md), and tuple-"
"style [struct](struct-expr.md) expressions."
msgstr "[배열 표현식](array-expr.md), [튜플 표현식](tuple-expr.md), [호출 표현식](call-expr.md), 그리고 튜플 스타일 [구조체](struct-expr.md) 표현식의 요소로서의 블록 표현식."

#: src/expressions/block-expr.md:294
msgid "A block expression as the tail expression of another block expression."
msgstr "다른 블록 표현식의 꼬리 표현식으로서의 블록 표현식."

#: src/expressions/block-expr.md:299
msgid ""
"The attributes that have meaning on a block expression are [`cfg`](../"
"conditional-compilation.md) and [the lint check attributes](../attributes/"
"diagnostics.md#lint-check-attributes)."
msgstr "블록 표현식에서 의미가 있는 속성은 [`cfg`](../conditional-compilation.md)와 [린트 검사 속성](../attributes/diagnostics.md#lint-check-attributes)입니다."

#: src/expressions/block-expr.md:301
msgid ""
"For example, this function returns `true` on unix platforms and `false` on "
"other platforms."
msgstr "예를 들어, 이 함수는 유닉스 플랫폼에서는 `true`를 반환하고 다른 플랫폼에서는 `false`를 반환합니다."

#: src/expressions/operator-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_OperatorExpression_ :  \n"
"      [_BorrowExpression_](#borrow-operators)  \n"
"   | [_DereferenceExpression_](#the-dereference-operator)  \n"
"   | [_ErrorPropagationExpression_](#the-question-mark-operator)  \n"
"   | [_NegationExpression_](#negation-operators)  \n"
"   | [_ArithmeticOrLogicalExpression_](#arithmetic-and-logical-binary-"
"operators)  \n"
"   | [_ComparisonExpression_](#comparison-operators)  \n"
"   | [_LazyBooleanExpression_](#lazy-boolean-operators)  \n"
"   | [_TypeCastExpression_](#type-cast-expressions)  \n"
"   | [_AssignmentExpression_](#assignment-expressions)  \n"
"   | [_CompoundAssignmentExpression_](#compound-assignment-expressions)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_연산자표현식_ :  \n"
"      [_차용표현식_](#borrow-operators)  \n"
"   | [_역참조표현식_](#the-dereference-operator)  \n"
"   | [_오류전파표현식_](#the-question-mark-operator)  \n"
"   | [_부정표현식_](#negation-operators)  \n"
"   | [_산술또는논리표현식_](#arithmetic-and-logical-binary-operators)  \n"
"   | [_비교표현식_](#comparison-operators)  \n"
"   | [_지연불리언표현식_](#lazy-boolean-operators)  \n"
"   | [_타입캐스트표현식_](#type-cast-expressions)  \n"
"   | [_할당표현식_](#assignment-expressions)  \n"
"   | [_복합할당표현식_](#compound-assignment-expressions)"

#: src/expressions/operator-expr.md:22
msgid "Operators are defined for built in types by the Rust language."
msgstr "연산자는 러스트 언어에 의해 내장 타입에 대해 정의됩니다."

#: src/expressions/operator-expr.md:26
msgid ""
"Many of the following operators can also be overloaded using traits in "
"`std::ops` or `std::cmp`."
msgstr "다음 연산자 중 다수는 `std::ops` 또는 `std::cmp`의 트레잇을 사용하여 오버로딩할 수도 있습니다."

#: src/expressions/operator-expr.md:30
msgid "Overflow"
msgstr "오버플로"

#: src/expressions/operator-expr.md:34
msgid ""
"Integer operators will panic when they overflow when compiled in debug mode. "
"The `-C debug-assertions` and `-C overflow-checks` compiler flags can be "
"used to control this more directly. The following things are considered to "
"be overflow:"
msgstr "정수 연산자는 디버그 모드에서 컴파일될 때 오버플로가 발생하면 패닉을 일으킵니다. `-C debug-assertions` 및 `-C overflow-checks` 컴파일러 플래그를 사용하여 이를 더 직접적으로 제어할 수 있습니다. 다음 사항들은 오버플로로 간주됩니다:"

#: src/expressions/operator-expr.md:40
msgid ""
"When `+`, `*` or binary `-` create a value greater than the maximum value, "
"or less than the minimum value that can be stored."
msgstr "`+`, `*` 또는 이항 `-`가 저장할 수 있는 최대값보다 크거나 최소값보다 작은 값을 생성할 때."

#: src/expressions/operator-expr.md:44
msgid ""
"Applying unary `-` to the most negative value of any signed integer type, "
"unless the operand is a [literal expression](literal-expr.md#integer-literal-"
"expressions) (or a literal expression standing alone inside one or more "
"[grouped expressions](grouped-expr.md))."
msgstr "피연산자가 [리터럴 표현식](literal-expr.md#integer-literal-expressions) (또는 하나 이상의 [그룹화된 표현식](grouped-expr.md) 내에 단독으로 있는 리터럴 표현식)이 아닌 경우, 부호 있는 정수 타입의 가장 작은 음수 값에 단항 `-`를 적용할 때."

#: src/expressions/operator-expr.md:48
msgid ""
"Using `/` or `%`, where the left-hand argument is the smallest integer of a "
"signed integer type and the right-hand argument is `-1`. These checks occur "
"even when `-C overflow-checks` is disabled, for legacy reasons."
msgstr "왼쪽 인수가 부호 있는 정수 타입의 가장 작은 정수이고 오른쪽 인수가 `-1`인 경우 `/` 또는 `%` 사용. 이러한 검사는 레거시 이유로 `-C overflow-checks`가 비활성화된 경우에도 발생합니다."

#: src/expressions/operator-expr.md:53
msgid ""
"Using `<<` or `>>` where the right-hand argument is greater than or equal to "
"the number of bits in the type of the left-hand argument, or is negative."
msgstr "오른쪽 인수가 왼쪽 인수 타입의 비트 수보다 크거나 같거나 음수인 경우 `<<` 또는 `>>` 사용."

#: src/expressions/operator-expr.md:55
msgid ""
"**Note**: The exception for literal expressions behind unary `-` means that "
"forms such as `-128_i8` or `let j: i8 = -(128)` never cause a panic and have "
"the expected value of -128."
msgstr "**참고**: 단항 `-` 뒤의 리터럴 표현식에 대한 예외는 `-128_i8` 또는 `let j: i8 = -(128)`과 같은 형식은 절대 패닉을 일으키지 않으며 예상 값 -128을 갖는다는 것을 의미합니다."

#: src/expressions/operator-expr.md:57
msgid ""
"In these cases, the literal expression already has the most negative value "
"for its type (for example, `128_i8` has the value -128) because integer "
"literals are truncated to their type per the description in [Integer literal "
"expressions](literal-expr.md#integer-literal-expressions)."
msgstr "이러한 경우, [정수 리터럴 표현식](literal-expr.md#integer-literal-expressions)의 설명에 따라 정수 리터럴이 해당 타입으로 잘리기 때문에 리터럴 표현식은 이미 해당 타입에 대해 가장 작은 음수 값을 가집니다(예: `128_i8`은 값 -128을 가짐)."

#: src/expressions/operator-expr.md:59
msgid ""
"Negation of these most negative values leaves the value unchanged due to "
"two's complement overflow conventions."
msgstr "이러한 가장 작은 음수 값의 부정은 2의 보수 오버플로 규칙으로 인해 값이 변경되지 않고 그대로 유지됩니다."

#: src/expressions/operator-expr.md:61
msgid ""
"In `rustc`, these most negative expressions are also ignored by the "
"`overflowing_literals` lint check."
msgstr "`rustc`에서 이러한 가장 작은 음수 표현식은 `overflowing_literals` 린트 검사에서도 무시됩니다."

#: src/expressions/operator-expr.md:65
msgid "Borrow operators"
msgstr "차용 연산자"

#: src/expressions/operator-expr.md:67
msgid ""
"**<sup>Syntax</sup>**  \n"
"_BorrowExpression_ :  \n"
"      (`&`\\|`&&`) [_Expression_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `mut` [_Expression_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `raw` `const` [_Expression_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `raw` `mut` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_차용표현식_ :  \n"
"      (`&`\\|`&&`) [_표현식_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `mut` [_표현식_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `raw` `const` [_표현식_](../expressions.md)  \n"
"   | (`&`\\|`&&`) `raw` `mut` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:76
msgid ""
"The `&` (shared borrow) and `&mut` (mutable borrow) operators are unary "
"prefix operators."
msgstr "`&` (공유 차용) 및 `&mut` (가변 차용) 연산자는 단항 접두사 연산자입니다."

#: src/expressions/operator-expr.md:80
msgid ""
"When applied to a [place expression](../expressions.md#place-expressions-and-"
"value-expressions), this expressions produces a reference (pointer) to the "
"location that the value refers to."
msgstr "[장소 표현식](../expressions.md#place-expressions-and-value-expressions)에 적용될 때, 이 표현식은 값이 참조하는 위치에 대한 참조(포인터)를 생성합니다."

#: src/expressions/operator-expr.md:84
msgid ""
"The memory location is also placed into a borrowed state for the duration of "
"the reference. For a shared borrow (`&`), this implies that the place may "
"not be mutated, but it may be read or shared again. For a mutable borrow "
"(`&mut`), the place may not be accessed in any way until the borrow expires."
msgstr "메모리 위치는 또한 참조 기간 동안 차용 상태로 놓입니다. 공유 차용(`&`)의 경우, 이는 장소를 변경할 수 없지만 읽거나 다시 공유할 수 있음을 의미합니다. 가변 차용(`&mut`)의 경우, 차용이 만료될 때까지 어떤 방식으로도 장소에 접근할 수 없습니다."

#: src/expressions/operator-expr.md:90
msgid "`&mut` evaluates its operand in a mutable place expression context."
msgstr "`&mut`은 피연산자를 가변 장소 표현식 컨텍스트에서 평가합니다."

#: src/expressions/operator-expr.md:94
msgid ""
"If the `&` or `&mut` operators are applied to a [value expression](../"
"expressions.md#place-expressions-and-value-expressions), then a [temporary "
"value](../expressions.md#temporaries) is created."
msgstr "`&` 또는 `&mut` 연산자가 [값 표현식](../expressions.md#place-expressions-and-value-expressions)에 적용되면 [임시 값](../expressions.md#temporaries)이 생성됩니다."

#: src/expressions/operator-expr.md:96
msgid "These operators cannot be overloaded."
msgstr "이 연산자들은 오버로딩할 수 없습니다."

#: src/expressions/operator-expr.md:100
msgid "// a temporary with value 7 is created that lasts for this scope.\n"
msgstr "// 이 스코프 동안 지속되는 값 7을 가진 임시 값이 생성됩니다.\n"

#: src/expressions/operator-expr.md:105
msgid ""
"// Mutably borrows `array` for this scope.\n"
"    // `array` may only be used through `mutable_reference`.\n"
msgstr ""
"// 이 스코프 동안 `array`를 가변적으로 차용합니다.\n"
"    // `array`는 `mutable_reference`를 통해서만 사용할 수 있습니다.\n"

#: src/expressions/operator-expr.md:113
msgid ""
"Even though `&&` is a single token ([the lazy 'and' operator](#lazy-boolean-"
"operators)), when used in the context of borrow expressions it works as two "
"borrows:"
msgstr "`&&`가 단일 토큰([지연 'and' 연산자](#lazy-boolean-operators))임에도 불구하고, 차용 표현식의 컨텍스트에서 사용될 때는 두 번의 차용으로 작동합니다:"

#: src/expressions/operator-expr.md:116 src/expressions/operator-expr.md:119
msgid "// same meanings:\n"
msgstr "// 같은 의미:\n"

#: src/expressions/operator-expr.md:128
msgid "Raw borrow operators"
msgstr "원시 차용 연산자"

#: src/expressions/operator-expr.md:132
msgid "`&raw const` and `&raw mut` are the _raw borrow operators_."
msgstr "`&raw const`와 `&raw mut`는 _원시 차용 연산자_입니다."

#: src/expressions/operator-expr.md:136
msgid ""
"The operand expression of these operators is evaluated in place expression "
"context."
msgstr "이 연산자들의 피연산자 표현식은 장소 표현식 컨텍스트에서 평가됩니다."

#: src/expressions/operator-expr.md:140
msgid ""
"`&raw const expr` then creates a const raw pointer of type `*const T` to the "
"given place, and `&raw mut expr` creates a mutable raw pointer of type `*mut "
"T`."
msgstr "`&raw const expr`은 주어진 장소에 대한 `*const T` 타입의 상수 원시 포인터를 생성하고, `&raw mut expr`은 `*mut T` 타입의 가변 원시 포인터를 생성합니다."

#: src/expressions/operator-expr.md:144
msgid ""
"The raw borrow operators must be used instead of a borrow operator whenever "
"the place expression could evaluate to a place that is not properly aligned "
"or does not store a valid value as determined by its type, or whenever "
"creating a reference would introduce incorrect aliasing assumptions. In "
"those situations, using a borrow operator would cause [undefined behavior]"
"(../behavior-considered-undefined.md) by creating an invalid reference, but "
"a raw pointer may still be constructed."
msgstr "장소 표현식이 적절하게 정렬되지 않은 장소로 평가되거나 해당 타입에 의해 결정된 유효한 값을 저장하지 않을 수 있는 경우, 또는 참조를 생성하면 잘못된 앨리어싱 가정이 도입되는 경우 항상 차용 연산자 대신 원시 차용 연산자를 사용해야 합니다. 이러한 상황에서 차용 연산자를 사용하면 잘못된 참조가 생성되어 [정의되지 않은 동작](../behavior-considered-undefined.md)을 유발할 수 있지만, 원시 포인터는 여전히 생성될 수 있습니다."

#: src/expressions/operator-expr.md:147
msgid ""
"The following is an example of creating a raw pointer to an unaligned place "
"through a `packed` struct:"
msgstr "다음은 `packed` 구조체를 통해 정렬되지 않은 장소에 대한 원시 포인터를 생성하는 예입니다:"

#: src/expressions/operator-expr.md:156
msgid ""
"// `&packed.f2` would create an unaligned reference, and thus be undefined "
"behavior!\n"
msgstr "// `&packed.f2`는 정렬되지 않은 참조를 생성하므로 정의되지 않은 동작이 됩니다!\n"

#: src/expressions/operator-expr.md:162
msgid ""
"The following is an example of creating a raw pointer to a place that does "
"not contain a valid value:"
msgstr "다음은 유효한 값을 포함하지 않는 장소에 대한 원시 포인터를 생성하는 예입니다:"

#: src/expressions/operator-expr.md:171
msgid ""
"// `&uninit.as_mut().field` would create a reference to an uninitialized "
"`bool`,\n"
"// and thus be undefined behavior!\n"
msgstr ""
"// `&uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하므로,\n"
"// 정의되지 않은 동작이 됩니다!\n"

#: src/expressions/operator-expr.md:181
msgid "The dereference operator"
msgstr "역참조 연산자"

#: src/expressions/operator-expr.md:185
msgid ""
"**<sup>Syntax</sup>**  \n"
"_DereferenceExpression_ :  \n"
"   `*` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_역참조표현식_ :  \n"
"   `*` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:191
msgid "The `*` (dereference) operator is also a unary prefix operator."
msgstr "`*` (역참조) 연산자는 또한 단항 접두사 연산자입니다."

#: src/expressions/operator-expr.md:195
msgid ""
"When applied to a [pointer](../types/pointer.md) it denotes the pointed-to "
"location."
msgstr "[포인터](../types/pointer.md)에 적용될 때, 이는 가리키는 위치를 나타냅니다."

#: src/expressions/operator-expr.md:199
msgid ""
"If the expression is of type `&mut T` or `*mut T`, and is either a local "
"variable, a (nested) field of a local variable or is a mutable [place "
"expression](../expressions.md#place-expressions-and-value-expressions), then "
"the resulting memory location can be assigned to."
msgstr "표현식이 `&mut T` 또는 `*mut T` 타입이고, 지역 변수, 지역 변수의 (중첩된) 필드 또는 가변 [장소 표현식](../expressions.md#place-expressions-and-value-expressions)인 경우, 결과 메모리 위치에 할당할 수 있습니다."

#: src/expressions/operator-expr.md:203
msgid "Dereferencing a raw pointer requires `unsafe`."
msgstr "원시 포인터를 역참조하려면 `unsafe`가 필요합니다."

#: src/expressions/operator-expr.md:207
msgid ""
"On non-pointer types `*x` is equivalent to `*std::ops::Deref::deref(&x)` in "
"an [immutable place expression context](../expressions.md#mutability) and "
"`*std::ops::DerefMut::deref_mut(&mut x)` in a mutable place expression "
"context."
msgstr "비 포인터 타입에서 `*x`는 [불변 장소 표현식 컨텍스트](../expressions.md#mutability)에서는 `*std::ops::Deref::deref(&x)`와 동일하고, 가변 장소 표현식 컨텍스트에서는 `*std::ops::DerefMut::deref_mut(&mut x)`와 동일합니다."

#: src/expressions/operator-expr.md:219
msgid "The question mark operator"
msgstr "물음표 연산자"

#: src/expressions/operator-expr.md:223
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ErrorPropagationExpression_ :  \n"
"   [_Expression_](../expressions.md) `?`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_오류전파표현식_ :  \n"
"   [_표현식_](../expressions.md) `?`"

#: src/expressions/operator-expr.md:229
msgid ""
"The question mark operator (`?`) unwraps valid values or returns erroneous "
"values, propagating them to the calling function."
msgstr "물음표 연산자 (`?`)는 유효한 값을 풀거나(unwrap) 오류 값을 반환하여 호출 함수로 전파합니다."

#: src/expressions/operator-expr.md:233
msgid ""
"It is a unary postfix operator that can only be applied to the types "
"`Result<T, E>` and `Option<T>`."
msgstr "이것은 `Result<T, E>` 및 `Option<T>` 타입에만 적용할 수 있는 단항 후위 연산자입니다."

#: src/expressions/operator-expr.md:237
msgid ""
"When applied to values of the `Result<T, E>` type, it propagates errors."
msgstr "`Result<T, E>` 타입의 값에 적용되면 오류를 전파합니다."

#: src/expressions/operator-expr.md:241
msgid ""
"If the value is `Err(e)`, then it will return `Err(From::from(e))` from the "
"enclosing function or closure."
msgstr "값이 `Err(e)`이면, 둘러싼 함수나 클로저에서 `Err(From::from(e))`를 반환합니다."

#: src/expressions/operator-expr.md:245
msgid ""
"If applied to `Ok(x)`, then it will unwrap the value to evaluate to `x`."
msgstr "`Ok(x)`에 적용되면 값을 풀어 `x`로 평가합니다."

#: src/expressions/operator-expr.md:250 src/types/closure.md:299
msgid "\"123\""
msgstr "\"123\""

#: src/expressions/operator-expr.md:250
msgid "// x = 123\n"
msgstr "// x = 123\n"

#: src/expressions/operator-expr.md:251
msgid "\"24a\""
msgstr "\"24a\""

#: src/expressions/operator-expr.md:251
msgid "// returns an Err() immediately\n"
msgstr "// 즉시 Err()를 반환합니다\n"

#: src/expressions/operator-expr.md:252
msgid "// Doesn't run.\n"
msgstr "// 실행되지 않습니다.\n"

#: src/expressions/operator-expr.md:256 src/patterns.md:521
#: src/types/closure.md:28 src/types/closure.md:50 src/types/closure.md:161
#: src/types/closure.md:231 src/types/closure.md:250 src/types/closure.md:268
#: src/types/closure.md:676 src/destructors.md:379 src/paths.md:228
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/expressions/operator-expr.md:262
msgid "When applied to values of the `Option<T>` type, it propagates `None`s."
msgstr "`Option<T>` 타입의 값에 적용되면 `None`을 전파합니다."

#: src/expressions/operator-expr.md:266
msgid "If the value is `None`, then it will return `None`."
msgstr "값이 `None`이면 `None`을 반환합니다."

#: src/expressions/operator-expr.md:270
msgid ""
"If applied to `Some(x)`, then it will unwrap the value to evaluate to `x`."
msgstr "`Some(x)`에 적용되면 값을 풀어 `x`로 평가합니다."

#: src/expressions/operator-expr.md:288
msgid "`?` cannot be overloaded."
msgstr "`?`는 오버로딩할 수 없습니다."

#: src/expressions/operator-expr.md:292
msgid "Negation operators"
msgstr "부정 연산자"

#: src/expressions/operator-expr.md:296
msgid ""
"**<sup>Syntax</sup>**  \n"
"_NegationExpression_ :  \n"
"      `-` [_Expression_](../expressions.md)  \n"
"   | `!` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_부정표현식_ :  \n"
"      `-` [_표현식_](../expressions.md)  \n"
"   | `!` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:303
msgid "These are the last two unary operators."
msgstr "이것들은 마지막 두 단항 연산자입니다."

#: src/expressions/operator-expr.md:307
msgid ""
"This table summarizes the behavior of them on primitive types and which "
"traits are used to overload these operators for other types. Remember that "
"signed integers are always represented using two's complement. The operands "
"of all of these operators are evaluated in [value expression context](../"
"expressions.md#place-expressions-and-value-expressions) so are moved or "
"copied."
msgstr "이 표는 기본 타입에 대한 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 [값 표현식 컨텍스트](../expressions.md#place-expressions-and-value-expressions)에서 평가되므로 이동하거나 복사됩니다."

#: src/expressions/operator-expr.md:311 src/expressions/operator-expr.md:356
#: src/type-layout.md:63
msgid "`bool`"
msgstr "`bool`"

#: src/expressions/operator-expr.md:311 src/expressions/operator-expr.md:356
msgid "Floating Point"
msgstr "부동 소수점"

#: src/expressions/operator-expr.md:311 src/expressions/operator-expr.md:356
msgid "Overloading Trait"
msgstr "오버로딩 트레잇"

#: src/expressions/operator-expr.md:313
msgid "Negation\\*"
msgstr "부정\\*"

#: src/expressions/operator-expr.md:313
msgid "Negation"
msgstr "부정"

#: src/expressions/operator-expr.md:313
msgid "`std::ops::Neg`"
msgstr "`std::ops::Neg`"

#: src/expressions/operator-expr.md:314
msgid "Bitwise NOT"
msgstr "비트 NOT"

#: src/expressions/operator-expr.md:314
msgid "[Logical NOT](../types/boolean.md#logical-not)"
msgstr "[논리적 NOT](../types/boolean.md#logical-not)"

#: src/expressions/operator-expr.md:314
msgid "`std::ops::Not`"
msgstr "`std::ops::Not`"

#: src/expressions/operator-expr.md:316
msgid "\\* Only for signed integer types."
msgstr "* 부호 있는 정수 타입에만 해당."

#: src/expressions/operator-expr.md:318
msgid "Here are some example of these operators"
msgstr "다음은 이러한 연산자의 몇 가지 예입니다"

#: src/expressions/operator-expr.md:329
msgid "Arithmetic and Logical Binary Operators"
msgstr "산술 및 논리 이항 연산자"

#: src/expressions/operator-expr.md:333
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ArithmeticOrLogicalExpression_ :  \n"
"      [_Expression_](../expressions.md) `+` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `-` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `*` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `/` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `%` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `&` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `|` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `^` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `<<` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `>>` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_산술또는논리표현식_ :  \n"
"      [_표현식_](../expressions.md) `+` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `-` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `*` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `/` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `%` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `&` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `|` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `^` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `<<` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `>>` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:348
msgid "Binary operators expressions are all written with infix notation."
msgstr "이항 연산자 표현식은 모두 중위 표기법으로 작성됩니다."

#: src/expressions/operator-expr.md:352
msgid ""
"This table summarizes the behavior of arithmetic and logical binary "
"operators on primitive types and which traits are used to overload these "
"operators for other types. Remember that signed integers are always "
"represented using two's complement. The operands of all of these operators "
"are evaluated in [value expression context](../expressions.md#place-"
"expressions-and-value-expressions) so are moved or copied."
msgstr "이 표는 기본 타입에 대한 산술 및 논리 이항 연산자의 동작과 다른 타입에 대해 이 연산자를 오버로딩하는 데 사용되는 트레잇을 요약합니다. 부호 있는 정수는 항상 2의 보수를 사용하여 표현된다는 것을 기억하십시오. 이러한 모든 연산자의 피연산자는 [값 표현식 컨텍스트](../expressions.md#place-expressions-and-value-expressions)에서 평가되므로 이동하거나 복사됩니다."

#: src/expressions/operator-expr.md:356
msgid "Overloading Compound Assignment Trait"
msgstr "복합 할당 트레잇 오버로딩"

#: src/expressions/operator-expr.md:358
msgid "Addition"
msgstr "덧셈"

#: src/expressions/operator-expr.md:358
msgid "`std::ops::Add`"
msgstr "`std::ops::Add`"

#: src/expressions/operator-expr.md:358
msgid "`std::ops::AddAssign`"
msgstr "`std::ops::AddAssign`"

#: src/expressions/operator-expr.md:359
msgid "Subtraction"
msgstr "뺄셈"

#: src/expressions/operator-expr.md:359
msgid "`std::ops::Sub`"
msgstr "`std::ops::Sub`"

#: src/expressions/operator-expr.md:359
msgid "`std::ops::SubAssign`"
msgstr "`std::ops::SubAssign`"

#: src/expressions/operator-expr.md:360
msgid "Multiplication"
msgstr "곱셈"

#: src/expressions/operator-expr.md:360
msgid "`std::ops::Mul`"
msgstr "`std::ops::Mul`"

#: src/expressions/operator-expr.md:360
msgid "`std::ops::MulAssign`"
msgstr "`std::ops::MulAssign`"

#: src/expressions/operator-expr.md:361
msgid "Division\\*†"
msgstr "나눗셈\\*†"

#: src/expressions/operator-expr.md:361
msgid "Division"
msgstr "나눗셈"

#: src/expressions/operator-expr.md:361
msgid "`std::ops::Div`"
msgstr "`std::ops::Div`"

#: src/expressions/operator-expr.md:361
msgid "`std::ops::DivAssign`"
msgstr "`std::ops::DivAssign`"

#: src/expressions/operator-expr.md:362
msgid "Remainder\\*\\*†"
msgstr "나머지\\*\\*†"

#: src/expressions/operator-expr.md:362
msgid "Remainder"
msgstr "나머지"

#: src/expressions/operator-expr.md:362
msgid "`std::ops::Rem`"
msgstr "`std::ops::Rem`"

#: src/expressions/operator-expr.md:362
msgid "`std::ops::RemAssign`"
msgstr "`std::ops::RemAssign`"

#: src/expressions/operator-expr.md:363
msgid "Bitwise AND"
msgstr "비트 AND"

#: src/expressions/operator-expr.md:363
msgid "[Logical AND](../types/boolean.md#logical-and)"
msgstr "[논리적 AND](../types/boolean.md#logical-and)"

#: src/expressions/operator-expr.md:363
msgid "`std::ops::BitAnd`"
msgstr "`std::ops::BitAnd`"

#: src/expressions/operator-expr.md:363
msgid "`std::ops::BitAndAssign`"
msgstr "`std::ops::BitAndAssign`"

#: src/expressions/operator-expr.md:364
msgid "Bitwise OR"
msgstr "비트 OR"

#: src/expressions/operator-expr.md:364
msgid "[Logical OR](../types/boolean.md#logical-or)"
msgstr "[논리적 OR](../types/boolean.md#logical-or)"

#: src/expressions/operator-expr.md:364
msgid "`std::ops::BitOr`"
msgstr "`std::ops::BitOr`"

#: src/expressions/operator-expr.md:364
msgid "`std::ops::BitOrAssign`"
msgstr "`std::ops::BitOrAssign`"

#: src/expressions/operator-expr.md:365
msgid "Bitwise XOR"
msgstr "비트 XOR"

#: src/expressions/operator-expr.md:365
msgid "[Logical XOR](../types/boolean.md#logical-xor)"
msgstr "[논리적 XOR](../types/boolean.md#logical-xor)"

#: src/expressions/operator-expr.md:365
msgid "`std::ops::BitXor`"
msgstr "`std::ops::BitXor`"

#: src/expressions/operator-expr.md:365
msgid "`std::ops::BitXorAssign`"
msgstr "`std::ops::BitXorAssign`"

#: src/expressions/operator-expr.md:366
msgid "Left Shift"
msgstr "왼쪽 시프트"

#: src/expressions/operator-expr.md:366
msgid "`std::ops::Shl`"
msgstr "`std::ops::Shl`"

#: src/expressions/operator-expr.md:366
msgid "`std::ops::ShlAssign`"
msgstr "`std::ops::ShlAssign`"

#: src/expressions/operator-expr.md:367
msgid "Right Shift\\*\\*\\*"
msgstr "오른쪽 시프트\\*\\*\\*"

#: src/expressions/operator-expr.md:367
msgid "`std::ops::Shr`"
msgstr "`std::ops::Shr`"

#: src/expressions/operator-expr.md:367
msgid "`std::ops::ShrAssign`"
msgstr "`std::ops::ShrAssign`"

#: src/expressions/operator-expr.md:369
msgid "\\* Integer division rounds towards zero."
msgstr "* 정수 나눗셈은 0을 향해 반올림합니다."

#: src/expressions/operator-expr.md:371
msgid ""
"\\*\\* Rust uses a remainder defined with [truncating division](https://"
"en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition). Given "
"`remainder = dividend % divisor`, the remainder will have the same sign as "
"the dividend."
msgstr "** Rust는 [절단 나눗셈](https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition)으로 정의된 나머지를 사용합니다. `remainder = dividend % divisor`라고 할 때, 나머지는 피제수(dividend)와 같은 부호를 가집니다."

#: src/expressions/operator-expr.md:373
msgid ""
"\\*\\*\\* Arithmetic right shift on signed integer types, logical right "
"shift on unsigned integer types."
msgstr "*** 부호 있는 정수 타입에서는 산술 오른쪽 시프트, 부호 없는 정수 타입에서는 논리 오른쪽 시프트입니다."

#: src/expressions/operator-expr.md:376
msgid "† For integer types, division by zero panics."
msgstr "† 정수 타입의 경우, 0으로 나누면 패닉이 발생합니다."

#: src/expressions/operator-expr.md:378
msgid "Here are examples of these operators being used."
msgstr "다음은 이러한 연산자가 사용되는 예입니다."

#: src/expressions/operator-expr.md:395
msgid "Comparison Operators"
msgstr "비교 연산자"

#: src/expressions/operator-expr.md:399
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ComparisonExpression_ :  \n"
"      [_Expression_](../expressions.md) `==` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `!=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `>` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `<` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `>=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `<=` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_비교표현식_ :  \n"
"      [_표현식_](../expressions.md) `==` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `!=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `>` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `<` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `>=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `<=` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:410
msgid ""
"Comparison operators are also defined both for primitive types and many "
"types in the standard library."
msgstr "비교 연산자는 기본 타입과 표준 라이브러리의 많은 타입에 대해 정의되어 있습니다."

#: src/expressions/operator-expr.md:414
msgid ""
"Parentheses are required when chaining comparison operators. For example, "
"the expression `a == b == c` is invalid and may be written as `(a == b) == "
"c`."
msgstr "비교 연산자를 연결할 때는 괄호가 필요합니다. 예를 들어, 표현식 `a == b == c`는 유효하지 않으며 `(a == b) == c`로 작성해야 합니다."

#: src/expressions/operator-expr.md:418
msgid ""
"Unlike arithmetic and logical operators, the traits for overloading these "
"operators are used more generally to show how a type may be compared and "
"will likely be assumed to define actual comparisons by functions that use "
"these traits as bounds. Many functions and macros in the standard library "
"can then use that assumption (although not to ensure safety)."
msgstr "산술 및 논리 연산자와 달리, 이 연산자를 오버로딩하는 트레잇은 타입이 비교되는 방식을 보여주는 데 더 일반적으로 사용되며, 이러한 트레잇을 바운드로 사용하는 함수에 의해 실제 비교를 정의한다고 가정될 가능성이 높습니다. 표준 라이브러리의 많은 함수와 매크로는 이러한 가정을 사용할 수 있습니다(안전성을 보장하기 위한 것은 아니지만)."

#: src/expressions/operator-expr.md:423
msgid ""
"Unlike the arithmetic and logical operators above, these operators "
"implicitly take shared borrows of their operands, evaluating them in [place "
"expression context](../expressions.md#place-expressions-and-value-"
"expressions):"
msgstr "위의 산술 및 논리 연산자와 달리, 이 연산자들은 암시적으로 피연산자의 공유 차용을 취하여 [장소 표현식 컨텍스트](../expressions.md#place-expressions-and-value-expressions)에서 평가합니다:"

#: src/expressions/operator-expr.md:428
msgid "// is equivalent to\n"
msgstr "// 다음과 동일합니다\n"

#: src/expressions/operator-expr.md:433
msgid "This means that the operands don't have to be moved out of."
msgstr "이는 피연산자를 밖으로 이동시킬 필요가 없음을 의미합니다."

#: src/expressions/operator-expr.md:438
msgid "Overloading method"
msgstr "오버로딩 메서드"

#: src/expressions/operator-expr.md:440
msgid "Equal"
msgstr "같음"

#: src/expressions/operator-expr.md:440
msgid "`std::cmp::PartialEq::eq`"
msgstr "`std::cmp::PartialEq::eq`"

#: src/expressions/operator-expr.md:441
msgid "Not equal"
msgstr "같지 않음"

#: src/expressions/operator-expr.md:441
msgid "`std::cmp::PartialEq::ne`"
msgstr "`std::cmp::PartialEq::ne`"

#: src/expressions/operator-expr.md:442
msgid "Greater than"
msgstr "보다 큼"

#: src/expressions/operator-expr.md:442
msgid "`std::cmp::PartialOrd::gt`"
msgstr "`std::cmp::PartialOrd::gt`"

#: src/expressions/operator-expr.md:443
msgid "Less than"
msgstr "보다 작음"

#: src/expressions/operator-expr.md:443
msgid "`std::cmp::PartialOrd::lt`"
msgstr "`std::cmp::PartialOrd::lt`"

#: src/expressions/operator-expr.md:444
msgid "Greater than or equal to"
msgstr "보다 크거나 같음"

#: src/expressions/operator-expr.md:444
msgid "`std::cmp::PartialOrd::ge`"
msgstr "`std::cmp::PartialOrd::ge`"

#: src/expressions/operator-expr.md:445
msgid "Less than or equal to"
msgstr "보다 작거나 같음"

#: src/expressions/operator-expr.md:445
msgid "`std::cmp::PartialOrd::le`"
msgstr "`std::cmp::PartialOrd::le`"

#: src/expressions/operator-expr.md:447
msgid "Here are examples of the comparison operators being used."
msgstr "다음은 비교 연산자가 사용되는 예입니다."

#: src/expressions/operator-expr.md:454 src/expressions/operator-expr.md:696
#: src/expressions/operator-expr.md:707 src/patterns.md:657
msgid "'A'"
msgstr "'A'"

#: src/expressions/operator-expr.md:454
msgid "'B'"
msgstr "'B'"

#: src/expressions/operator-expr.md:455
msgid "\"World\""
msgstr "\"World\""

#: src/expressions/operator-expr.md:455
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/expressions/operator-expr.md:460
msgid "Lazy boolean operators"
msgstr "지연 불리언 연산자"

#: src/expressions/operator-expr.md:464
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LazyBooleanExpression_ :  \n"
"      [_Expression_](../expressions.md) `||` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `&&` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_지연불리언표현식_ :  \n"
"      [_표현식_](../expressions.md) `||` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `&&` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:471
msgid ""
"The operators `||` and `&&` may be applied to operands of boolean type. The "
"`||` operator denotes logical 'or', and the `&&` operator denotes logical "
"'and'. They differ from `|` and `&` in that the right-hand operand is only "
"evaluated if the left-hand operand does not already determine the result of "
"the expression. That is, `||` only evaluates its right-hand operand when the "
"left-hand operand evaluates to `false`, and `&&` only evaluates its right-"
"hand operand when the left-hand operand evaluates to `true`."
msgstr "`||` 및 `&&` 연산자는 불리언 타입의 피연산자에 적용될 수 있습니다. `||` 연산자는 논리 'or'를, `&&` 연산자는 논리 'and'를 나타냅니다. 이들은 `|` 및 `&`와 달리, 왼쪽 피연산자가 표현식의 결과를 이미 결정하지 않은 경우에만 오른쪽 피연산자가 평가된다는 점에서 다릅니다. 즉, `||`는 왼쪽 피연산자가 `false`로 평가될 때만 오른쪽 피연산자를 평가하고, `&&`는 왼쪽 피연산자가 `true`로 평가될 때만 오른쪽 피연산자를 평가합니다."
"'and'."
msgstr "'and'."

#: src/expressions/operator-expr.md:476
msgid ""
"They differ from `|` and `&` in that the right-hand operand is only "
"evaluated when the left-hand operand does not already determine the result "
"of the expression. That is, `||` only evaluates its right-hand operand when "
"the left-hand operand evaluates to `false`, and `&&` only when it evaluates "
"to `true`."
msgstr "이들은 `|` 및 `&`와 달리, 왼쪽 피연산자가 표현식의 결과를 이미 결정하지 않은 경우에만 오른쪽 피연산자가 평가된다는 점에서 다릅니다. 즉, `||`는 왼쪽 피연산자가 `false`로 평가될 때만 오른쪽 피연산자를 평가하고, `&&`는 `true`로 평가될 때만 평가합니다."

#: src/expressions/operator-expr.md:480
msgid "// true\n"
msgstr "// 참(true)\n"

#: src/expressions/operator-expr.md:481
msgid "// false, doesn't evaluate `panic!()`\n"
msgstr "// 거짓(false), `panic!()`을 평가하지 않음\n"

#: src/expressions/operator-expr.md:486
msgid "Type cast expressions"
msgstr "타입 캐스트 표현식"

#: src/expressions/operator-expr.md:490
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TypeCastExpression_ :  \n"
"   [_Expression_](../expressions.md) `as` [_TypeNoBounds_](../types.md#type-"
"expressions)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_타입캐스트표현식_ :  \n"
"   [_표현식_](../expressions.md) `as` [_TypeNoBounds_](../types.md#type-"
"expressions)"

#: src/expressions/operator-expr.md:496
msgid "A type cast expression is denoted with the binary operator `as`."
msgstr "타입 캐스트 표현식은 이항 연산자 `as`로 표시됩니다."

#: src/expressions/operator-expr.md:500
msgid ""
"Executing an `as` expression casts the value on the left-hand side to the "
"type on the right-hand side."
msgstr "`as` 표현식을 실행하면 왼쪽의 값이 오른쪽의 타입으로 캐스팅됩니다."

#: src/expressions/operator-expr.md:502
msgid "An example of an `as` expression:"
msgstr "`as` 표현식의 예:"

#: src/expressions/operator-expr.md:516
msgid ""
"`as` can be used to explicitly perform [coercions](../type-coercions.md), as "
"well as the following additional casts. Any cast that does not fit either a "
"coercion rule or an entry in the table is a compiler error. Here `*T` means "
"either `*const T` or `*mut T`. `m` stands for optional `mut` in reference "
"types and `mut` or `const` in pointer types."
msgstr "`as`는 [강제 변환](../type-coercions.md)을 명시적으로 수행하는 데 사용될 수 있으며, 다음의 추가 캐스트에도 사용됩니다. 강제 변환 규칙이나 표의 항목에 맞지 않는 캐스트는 컴파일러 오류입니다. 여기서 `*T`는 `*const T` 또는 `*mut T`를 의미합니다. `m`은 참조 타입에서 선택적 `mut`를 나타내고, 포인터 타입에서는 `mut` 또는 `const`를 나타냅니다."

#: src/expressions/operator-expr.md:521
msgid "Type of `e`"
msgstr "`e`의 타입"

#: src/expressions/operator-expr.md:521
msgid "`U`"
msgstr "`U`"

#: src/expressions/operator-expr.md:521
msgid "Cast performed by `e as U`"
msgstr "`e as U`에 의해 수행되는 캐스트"

#: src/expressions/operator-expr.md:523
msgid "Integer or Float type"
msgstr "정수 또는 부동 소수점 타입"

#: src/expressions/operator-expr.md:523
msgid "[Numeric cast](operator-expr.md#r-expr.as.numeric)"
msgstr "[숫자 캐스트](operator-expr.md#r-expr.as.numeric)"

#: src/expressions/operator-expr.md:524
msgid "Enumeration"
msgstr "열거형"

#: src/expressions/operator-expr.md:524 src/expressions/operator-expr.md:525
#: src/expressions/operator-expr.md:528 src/expressions/operator-expr.md:529
msgid "Integer type"
msgstr "정수 타입"

#: src/expressions/operator-expr.md:524
msgid "[Enum cast](operator-expr.md#r-expr.as.enum)"
msgstr "[열거형 캐스트](operator-expr.md#r-expr.as.enum)"

#: src/expressions/operator-expr.md:525
msgid "`bool` or `char`"
msgstr "`bool` 또는 `char`"

#: src/expressions/operator-expr.md:525
msgid ""
"[Primitive to integer cast](operator-expr.md#r-expr.as.bool-char-as-int)"
msgstr "[기본 타입에서 정수로의 캐스트](operator-expr.md#r-expr.as.bool-char-as-int)"

#: src/expressions/operator-expr.md:526 src/types/numeric.md:15
msgid "`u8`"
msgstr "`u8`"

#: src/expressions/operator-expr.md:526 src/type-layout.md:72
msgid "`char`"
msgstr "`char`"

#: src/expressions/operator-expr.md:526
msgid "[`u8` to `char` cast](operator-expr.md#r-expr.as.u8-as-char)"
msgstr "[`u8`에서 `char`로의 캐스트](operator-expr.md#r-expr.as.u8-as-char)"

#: src/expressions/operator-expr.md:527
msgid "`*T`"
msgstr "`*T`"

#: src/expressions/operator-expr.md:527
msgid "`*V` [^meta-compat]"
msgstr "`*V` [^meta-compat]"

#: src/expressions/operator-expr.md:527
msgid "[Pointer to pointer cast](operator-expr.md#r-expr.as.pointer)"
msgstr "[포인터에서 포인터로의 캐스트](operator-expr.md#r-expr.as.pointer)"

#: src/expressions/operator-expr.md:528
msgid "`*T` where `T: Sized`"
msgstr "`*T` (여기서 `T: Sized`)"

#: src/expressions/operator-expr.md:528
msgid "[Pointer to address cast](operator-expr.md#r-expr.as.pointer-as-int)"
msgstr "[포인터에서 주소로의 캐스트](operator-expr.md#r-expr.as.pointer-as-int)"

#: src/expressions/operator-expr.md:529 src/expressions/operator-expr.md:533
#: src/expressions/operator-expr.md:535
msgid "`*V` where `V: Sized`"
msgstr "`*V` (여기서 `V: Sized`)"

#: src/expressions/operator-expr.md:529
msgid "[Address to pointer cast](operator-expr.md#r-expr.as.int-as-pointer)"
msgstr "[주소에서 포인터로의 캐스트](operator-expr.md#r-expr.as.int-as-pointer)"

#: src/expressions/operator-expr.md:530
msgid "`&m₁ [T; n]`"
msgstr "`&m₁ [T; n]`"

#: src/expressions/operator-expr.md:530 src/expressions/operator-expr.md:531
msgid "`*m₂ T` [^lessmut]"
msgstr "`*m₂ T` [^lessmut]"

#: src/expressions/operator-expr.md:530 src/expressions/operator-expr.md:531
msgid "Array to pointer cast"
msgstr "배열에서 포인터로의 캐스트"

#: src/expressions/operator-expr.md:531
msgid "`*m₁ [T; n]`"
msgstr "`*m₁ [T; n]`"

#: src/expressions/operator-expr.md:532 src/expressions/operator-expr.md:533
#: src/expressions/operator-expr.md:534
msgid "[Function item](../types/function-item.md)"
msgstr "[함수 아이템](../types/function-item.md)"

#: src/expressions/operator-expr.md:532 src/expressions/operator-expr.md:535
#: src/expressions/operator-expr.md:536
msgid "[Function pointer](../types/function-pointer.md)"
msgstr "[함수 포인터](../types/function-pointer.md)"

#: src/expressions/operator-expr.md:532
msgid "Function item to function pointer cast"
msgstr "함수 아이템에서 함수 포인터로의 캐스트"

#: src/expressions/operator-expr.md:533
msgid "Function item to pointer cast"
msgstr "함수 아이템에서 포인터로의 캐스트"

#: src/expressions/operator-expr.md:534
msgid "Function item to address cast"
msgstr "함수 아이템에서 주소로의 캐스트"

#: src/expressions/operator-expr.md:535
msgid "Function pointer to pointer cast"
msgstr "함수 포인터에서 포인터로의 캐스트"

#: src/expressions/operator-expr.md:536
msgid "Function pointer to address cast"
msgstr "함수 포인터에서 주소로의 캐스트"

#: src/expressions/operator-expr.md:537
msgid "Closure [^no-capture]"
msgstr "클로저 [^no-capture]"

#: src/expressions/operator-expr.md:537
msgid "Function pointer"
msgstr "함수 포인터"

#: src/expressions/operator-expr.md:537
msgid "Closure to function pointer cast"
msgstr "클로저에서 함수 포인터로의 캐스트"

#: src/expressions/operator-expr.md:539
msgid ""
"where `T` and `V` have compatible metadata: \\* `V: Sized`, or \\* Both "
"slice metadata (`*[u16]` -> `*[u8]`, `*str` -> `*(u8, [u32])`), or \\* Both "
"the same trait object metadata, modulo dropping auto traits (`*dyn Debug` -> "
"`*(u16, dyn Debug)`, `*dyn Debug + Send` -> `*dyn Debug`) \\* **Note**: "
"_adding_ auto traits is only allowed if the principal trait has the auto "
"trait as a super trait (given `trait T: Send {}`, `*dyn T` -> `*dyn T + "
"Send` is valid, but `*dyn Debug` -> `*dyn Debug + Send` is not) \\* "
"**Note**: Generics (including lifetimes) must match (`*dyn T<'a, A>` -> "
"`*dyn T<'b, B>` requires `'a = 'b` and `A = B`)"
msgstr "`T`와 `V`가 호환되는 메타데이터를 갖는 경우: \\* `V: Sized`이거나, \\* 둘 다 슬라이스 메타데이터(`*[u16]` -> `*[u8]`, `*str` -> `*(u8, [u32])`)이거나, \\* 둘 다 동일한 트레잇 객체 메타데이터(자동 트레잇 제거 제외) (`*dyn Debug` -> `*(u16, dyn Debug)`, `*dyn Debug + Send` -> `*dyn Debug`) \\* **참고**: 자동 트레잇 _추가_는 주 트레잇이 해당 자동 트레잇을 슈퍼 트레잇으로 갖는 경우에만 허용됩니다(`trait T: Send {}`가 주어졌을 때, `*dyn T` -> `*dyn T + Send`는 유효하지만 `*dyn Debug` -> `*dyn Debug + Send`는 유효하지 않음) \\* **참고**: 제네릭(라이프타임 포함)은 일치해야 합니다(`*dyn T<'a, A>` -> `*dyn T<'b, B>`는 `'a = 'b` 및 `A = B`를 요구함)"

#: src/expressions/operator-expr.md:546
msgid ""
"only when `m₁` is `mut` or `m₂` is `const`. Casting `mut` reference/pointer "
"to `const` pointer is allowed."
msgstr "`m₁`이 `mut`이거나 `m₂`가 `const`인 경우에만 해당합니다. `mut` 참조/포인터를 `const` 포인터로 캐스팅하는 것은 허용됩니다."

#: src/expressions/operator-expr.md:549
msgid ""
"only for closures that do not capture (close over) any local variables can "
"be casted to function pointers."
msgstr "지역 변수를 캡처(close over)하지 않는 클로저만 함수 포인터로 캐스팅될 수 있습니다."

#: src/expressions/operator-expr.md:551
msgid "Semantics"
msgstr "의미론"

#: src/expressions/operator-expr.md:555
msgid "Numeric cast"
msgstr "숫자 캐스트"

#: src/expressions/operator-expr.md:559
msgid ""
"Casting between two integers of the same size (e.g. i32 -> u32) is a no-op "
"(Rust uses 2's complement for negative values of fixed integers)"
msgstr "같은 크기의 두 정수 간 캐스팅(예: i32 -> u32)은 무연산(no-op)입니다(러스트는 고정 정수의 음수 값에 2의 보수를 사용합니다)."

#: src/expressions/operator-expr.md:571
msgid ""
"Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will "
"truncate"
msgstr "더 큰 정수에서 더 작은 정수로의 캐스팅(예: u32 -> u8)은 잘라냅니다(truncate)."

#: src/expressions/operator-expr.md:586
msgid ""
"Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will"
msgstr "더 작은 정수에서 더 큰 정수로의 캐스팅(예: u8 -> u32)은 다음과 같습니다."

#: src/expressions/operator-expr.md:587
msgid "zero-extend if the source is unsigned"
msgstr "소스가 부호 없으면 0으로 확장(zero-extend)"

#: src/expressions/operator-expr.md:588
msgid "sign-extend if the source is signed"
msgstr "소스가 부호 있으면 부호 확장(sign-extend)"

#: src/expressions/operator-expr.md:593
msgid "\"Zero-extend\""
msgstr "\"0으로 확장\""

#: src/expressions/operator-expr.md:594
msgid "\"Sign-extend 0\""
msgstr "\"부호 확장 0\""

#: src/expressions/operator-expr.md:595
msgid "\"Sign-extend 1\""
msgstr "\"부호 확장 1\""

#: src/expressions/operator-expr.md:600
msgid "Casting from a float to an integer will round the float towards zero"
msgstr "부동 소수점에서 정수로의 캐스팅은 부동 소수점을 0을 향해 반올림합니다."

#: src/expressions/operator-expr.md:601
msgid "`NaN` will return `0`"
msgstr "`NaN`은 `0`을 반환합니다."

#: src/expressions/operator-expr.md:602
msgid ""
"Values larger than the maximum integer value, including `INFINITY`, will "
"saturate to the maximum value of the integer type."
msgstr "`INFINITY`를 포함하여 최대 정수 값보다 큰 값은 정수 타입의 최대 값으로 포화(saturate)됩니다."

#: src/expressions/operator-expr.md:603
msgid ""
"Values smaller than the minimum integer value, including `NEG_INFINITY`, "
"will saturate to the minimum value of the integer type."
msgstr "`NEG_INFINITY`를 포함하여 최소 정수 값보다 작은 값은 정수 타입의 최소 값으로 포화(saturate)됩니다."

#: src/expressions/operator-expr.md:616
msgid ""
"Casting from an integer to float will produce the closest possible float \\*"
msgstr "정수에서 부동 소수점으로의 캐스팅은 가능한 가장 가까운 부동 소수점을 생성합니다 \\*"

#: src/expressions/operator-expr.md:617 src/expressions/operator-expr.md:641
msgid "if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*"
msgstr "필요한 경우, 반올림은 `roundTiesToEven` 모드에 따릅니다 \\*\\*\\*"

#: src/expressions/operator-expr.md:618 src/expressions/operator-expr.md:642
msgid "on overflow, infinity (of the same sign as the input) is produced"
msgstr "오버플로 시 무한대(입력과 같은 부호)가 생성됩니다"

#: src/expressions/operator-expr.md:619
msgid ""
"note: with the current set of numeric types, overflow can only happen on "
"`u128 as f32` for values greater or equal to `f32::MAX + (0.5 ULP)`"
msgstr "참고: 현재 숫자 타입 세트에서는 `f32::MAX + (0.5 ULP)`보다 크거나 같은 값에 대해 `u128 as f32`에서만 오버플로가 발생할 수 있습니다"

#: src/expressions/operator-expr.md:624 src/expressions/operator-expr.md:646
msgid "\"Rounded\""
msgstr "\"반올림됨\""

#: src/expressions/operator-expr.md:630
msgid "Casting from an f32 to an f64 is perfect and lossless"
msgstr "f32에서 f64로의 캐스팅은 완벽하며 손실이 없습니다"

#: src/expressions/operator-expr.md:640
msgid ""
"Casting from an f64 to an f32 will produce the closest possible f32 \\*\\*"
msgstr "f64에서 f32로의 캐스팅은 가능한 가장 가까운 f32를 생성합니다 \\*\\*"

#: src/expressions/operator-expr.md:651
msgid ""
"\\* if integer-to-float casts with this rounding mode and overflow behavior "
"are not supported natively by the hardware, these casts will likely be "
"slower than expected."
msgstr "\\* 이 반올림 모드와 오버플로 동작을 사용하는 정수-부동 소수점 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다."

#: src/expressions/operator-expr.md:655
msgid ""
"\\*\\* if f64-to-f32 casts with this rounding mode and overflow behavior are "
"not supported natively by the hardware, these casts will likely be slower "
"than expected."
msgstr "\\*\\* 이 반올림 모드와 오버플로 동작을 사용하는 f64-f32 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다."

#: src/expressions/operator-expr.md:659
msgid ""
"\\*\\*\\* as defined in IEEE 754-2008 §4.3.1: pick the nearest floating "
"point number, preferring the one with an even least significant digit if "
"exactly halfway between two floating point numbers."
msgstr "\\*\\*\\* IEEE 754-2008 §4.3.1에 정의된 대로: 가장 가까운 부동 소수점 숫자를 선택하고, 두 부동 소수점 숫자 사이의 정확히 중간인 경우 최하위 자릿수가 짝수인 것을 선호합니다."

#: src/expressions/operator-expr.md:665
msgid "Enum cast"
msgstr "열거형 캐스트"

#: src/expressions/operator-expr.md:669
msgid ""
"Casts an enum to its discriminant, then uses a numeric cast if needed. "
"Casting is limited to the following kinds of enumerations:"
msgstr "열거형을 판별자(discriminant)로 캐스팅한 다음 필요한 경우 숫자 캐스트를 사용합니다. 캐스팅은 다음 종류의 열거형으로 제한됩니다:"

#: src/expressions/operator-expr.md:672
msgid "[Unit-only enums](../items/enumerations.md#unit-only-enum)"
msgstr "[유닛 전용 열거형](../items/enumerations.md#unit-only-enum)"

#: src/expressions/operator-expr.md:673
msgid ""
"[Field-less enums](../items/enumerations.md#field-less-enum) without "
"[explicit discriminants](../items/enumerations.md#explicit-discriminants), "
"or where only unit-variants have explicit discriminants"
msgstr "[명시적 판별자](../items/enumerations.md#explicit-discriminants)가 없는 [필드 없는 열거형](../items/enumerations.md#field-less-enum), 또는 유닛 변형만 명시적 판별자를 갖는 경우"

#: src/expressions/operator-expr.md:684
msgid ""
"Casting is not allowed if the enum implements [`Drop`](../../core/ops/drop/"
"trait.Drop.html)."
msgstr "열거형이 [`Drop`](../../core/ops/drop/trait.Drop.html)을 구현하는 경우 캐스팅이 허용되지 않습니다."

#: src/expressions/operator-expr.md:688
msgid "Primitive to integer cast"
msgstr "기본 타입에서 정수로의 캐스트"

#: src/expressions/operator-expr.md:690
msgid "`false` casts to `0`, `true` casts to `1`"
msgstr "`false`는 `0`으로, `true`는 `1`로 캐스팅됩니다"

#: src/expressions/operator-expr.md:691
msgid ""
"`char` casts to the value of the code point, then uses a numeric cast if "
"needed."
msgstr "`char`는 코드 포인트 값으로 캐스팅된 다음 필요한 경우 숫자 캐스트를 사용합니다."

#: src/expressions/operator-expr.md:697 src/expressions/operator-expr.md:708
msgid "'Ö'"
msgstr "'Ö'"

#: src/expressions/operator-expr.md:702
msgid "`u8` to `char` cast"
msgstr "`u8`에서 `char`로의 캐스트"

#: src/expressions/operator-expr.md:704
msgid "Casts to the `char` with the corresponding code point."
msgstr "해당 코드 포인트를 가진 `char`로 캐스팅합니다."

#: src/expressions/operator-expr.md:713
msgid "Pointer to address cast"
msgstr "포인터에서 주소로의 캐스트"

#: src/expressions/operator-expr.md:715
msgid ""
"Casting from a raw pointer to an integer produces the machine address of the "
"referenced memory. If the integer type is smaller than the pointer type, the "
"address may be truncated; using `usize` avoids this."
msgstr "원시 포인터에서 정수로의 캐스팅은 참조된 메모리의 기계 주소를 생성합니다. 정수 타입이 포인터 타입보다 작은 경우 주소가 잘릴 수 있습니다. `usize`를 사용하면 이를 방지할 수 있습니다."

#: src/expressions/operator-expr.md:720
msgid "Address to pointer cast"
msgstr "주소에서 포인터로의 캐스트"

#: src/expressions/operator-expr.md:722
msgid ""
"Casting from an integer to a raw pointer interprets the integer as a memory "
"address and produces a pointer referencing that memory."
msgstr "정수에서 원시 포인터로의 캐스팅은 정수를 메모리 주소로 해석하고 해당 메모리를 참조하는 포인터를 생성합니다."

#: src/expressions/operator-expr.md:726
msgid ""
"_**Warning:**_ This interacts with the Rust memory model, which is still "
"under development. A pointer obtained from this cast may suffer additional "
"restrictions even if it is bitwise equal to a valid pointer. Dereferencing "
"such a pointer may be [undefined behavior](../behavior-considered-"
"undefined.md) if aliasing rules are not followed."
msgstr "_**경고:**_ 이것은 아직 개발 중인 러스트 메모리 모델과 상호 작용합니다. 이 캐스트에서 얻은 포인터는 유효한 포인터와 비트 단위로 동일하더라도 추가적인 제한을 받을 수 있습니다. 이러한 포인터를 역참조하는 것은 앨리어싱 규칙을 따르지 않을 경우 [정의되지 않은 동작](../behavior-considered-undefined.md)이 될 수 있습니다."

#: src/expressions/operator-expr.md:734
msgid "A trivial example of sound address arithmetic:"
msgstr "건전한 주소 연산의 간단한 예:"

#: src/expressions/operator-expr.md:740
msgid "// 4 == size_of::<i32>()\n"
msgstr "// 4 == size_of::<i32>()\n"

#: src/expressions/operator-expr.md:750
msgid "Pointer-to-pointer cast"
msgstr "포인터에서 포인터로의 캐스트"

#: src/expressions/operator-expr.md:754
msgid ""
"`*const T` / `*mut T` can be cast to `*const U` / `*mut U` with the "
"following behavior:"
msgstr "`*const T` / `*mut T`는 다음과 같은 동작으로 `*const U` / `*mut U`로 캐스팅될 수 있습니다:"

#: src/expressions/operator-expr.md:758
msgid "If `T` and `U` are both sized, the pointer is returned unchanged."
msgstr "`T`와 `U`가 모두 크기가 있는(sized) 경우, 포인터는 변경되지 않고 반환됩니다."

#: src/expressions/operator-expr.md:762
msgid ""
"If `T` and `U` are both unsized, the pointer is also returned unchanged. In "
"particular, the metadata is preserved exactly."
msgstr "`T`와 `U`가 모두 크기가 없는(unsized) 경우, 포인터도 변경되지 않고 반환됩니다. 특히 메타데이터는 정확하게 보존됩니다."

#: src/expressions/operator-expr.md:765
msgid ""
"For instance, a cast from `*const [T]` to `*const [U]` preserves the number "
"of elements. Note that, as a consequence, such casts do not necessarily "
"preserve the size of the pointer's referent (e.g., casting `*const [u16]` to "
"`*const [u8]` will result in a raw pointer which refers to an object of half "
"the size of the original). The same holds for `str` and any compound type "
"whose unsized tail is a slice type, such as `struct Foo(i32, [u8])` or "
"`(u64, Foo)`."
msgstr "예를 들어, `*const [T]`에서 `*const [U]`로의 캐스트는 요소 수를 보존합니다. 결과적으로 이러한 캐스트는 포인터가 참조하는 대상의 크기를 반드시 보존하지는 않는다는 점에 유의하십시오(예: `*const [u16]`을 `*const [u8]`로 캐스팅하면 원본 크기의 절반인 객체를 참조하는 원시 포인터가 됩니다). `str` 및 `struct Foo(i32, [u8])` 또는 `(u64, Foo)`와 같이 크기가 없는 꼬리가 슬라이스 타입인 복합 타입에도 동일하게 적용됩니다."

#: src/expressions/operator-expr.md:773
msgid ""
"If `T` is unsized and `U` is sized, the cast discards all metadata that "
"completes the wide pointer `T` and produces a thin pointer `U` consisting of "
"the data part of the unsized pointer."
msgstr "`T`는 크기가 없고 `U`는 크기가 있는 경우, 캐스트는 넓은 포인터(wide pointer) `T`를 완성하는 모든 메타데이터를 버리고 크기가 없는 포인터의 데이터 부분으로 구성된 얇은 포인터(thin pointer) `U`를 생성합니다."

#: src/expressions/operator-expr.md:777
msgid "Assignment expressions"
msgstr "할당 표현식"

#: src/expressions/operator-expr.md:781
msgid ""
"**<sup>Syntax</sup>**  \n"
"_AssignmentExpression_ :  \n"
"   [_Expression_](../expressions.md) `=` [_Expression_](../expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_할당표현식_ :  \n"
"   [_표현식_](../expressions.md) `=` [_표현식_](../expressions.md)"

#: src/expressions/operator-expr.md:787
msgid "An _assignment expression_ moves a value into a specified place."
msgstr "_할당 표현식_은 값을 지정된 장소로 이동합니다."

#: src/expressions/operator-expr.md:791
msgid ""
"An assignment expression consists of a [mutable](../"
"expressions.md#mutability) [assignee expression](../expressions.md#place-"
"expressions-and-value-expressions), the _assignee operand_, followed by an "
"equals sign (`=`) and a [value expression](../expressions.md#place-"
"expressions-and-value-expressions), the _assigned value operand_."
msgstr "할당 표현식은 [가변](../expressions.md#mutability) [피할당자 표현식](../expressions.md#place-expressions-and-value-expressions)(_피할당자 피연산자_)과 그 뒤에 오는 등호(`=`), 그리고 [값 표현식](../expressions.md#place-expressions-and-value-expressions)(_할당된 값 피연산자_)으로 구성됩니다."

#: src/expressions/operator-expr.md:795
msgid ""
"In its most basic form, an assignee expression is a [place expression](../"
"expressions.md#place-expressions-and-value-expressions), and we discuss this "
"case first."
msgstr "가장 기본적인 형태에서, 피할당자 표현식은 [장소 표현식](../expressions.md#place-expressions-and-value-expressions)이며, 이 경우를 먼저 논의합니다."

#: src/expressions/operator-expr.md:799
msgid ""
"The more general case of destructuring assignment is discussed below, but "
"this case always decomposes into sequential assignments to place "
"expressions, which may be considered the more fundamental case."
msgstr "더 일반적인 구조 분해 할당의 경우는 아래에서 논의되지만, 이 경우는 항상 장소 표현식에 대한 순차적인 할당으로 분해되므로, 장소 표현식 할당이 더 근본적인 경우로 간주될 수 있습니다."

#: src/expressions/operator-expr.md:803
msgid "Basic assignments"
msgstr "기본 할당"

#: src/expressions/operator-expr.md:807
msgid ""
"Evaluating assignment expressions begins by evaluating its operands. The "
"assigned value operand is evaluated first, followed by the assignee "
"expression."
msgstr "할당 표현식의 평가는 피연산자의 평가로 시작됩니다. 할당된 값 피연산자가 먼저 평가되고, 그 다음에 피할당자 표현식이 평가됩니다."

#: src/expressions/operator-expr.md:812
msgid ""
"For destructuring assignment, subexpressions of the assignee expression are "
"evaluated left-to-right."
msgstr "구조 분해 할당의 경우, 피할당자 표현식의 하위 표현식은 왼쪽에서 오른쪽으로 평가됩니다."

#: src/expressions/operator-expr.md:814 src/expressions/operator-expr.md:955
msgid ""
"**Note**: This is different than other expressions in that the right operand "
"is evaluated before the left one."
msgstr "**참고**: 이것은 오른쪽 피연산자가 왼쪽 피연산자보다 먼저 평가된다는 점에서 다른 표현식과 다릅니다."

#: src/expressions/operator-expr.md:818
msgid ""
"It then has the effect of first [dropping](../destructors.md) the value at "
"the assigned place, unless the place is an uninitialized local variable or "
"an uninitialized field of a local variable."
msgstr "그런 다음 할당된 장소의 값이 초기화되지 않은 지역 변수나 초기화되지 않은 지역 변수의 필드가 아닌 경우, 할당된 장소의 값을 먼저 [드랍](../destructors.md)하는 효과를 가집니다."

#: src/expressions/operator-expr.md:822
msgid ""
"Next it either [copies or moves](../expressions.md#moved-and-copied-types) "
"the assigned value to the assigned place."
msgstr "그 다음 할당된 값을 할당된 장소로 [복사하거나 이동](../expressions.md#moved-and-copied-types)합니다."

#: src/expressions/operator-expr.md:826
msgid ""
"An assignment expression always produces [the unit value](../types/tuple.md)."
msgstr "할당 표현식은 항상 [유닛 값](../types/tuple.md)을 생성합니다."

#: src/expressions/operator-expr.md:828 src/patterns.md:409
#: src/macro-ambiguity.md:48
msgid "Example:"
msgstr "예:"

#: src/expressions/operator-expr.md:838
msgid "Destructuring assignments"
msgstr "구조 분해 할당"

#: src/expressions/operator-expr.md:842
msgid ""
"Destructuring assignment is a counterpart to destructuring pattern matches "
"for variable declaration, permitting assignment to complex values, such as "
"tuples or structs. For instance, we may swap two mutable variables:"
msgstr "구조 분해 할당은 변수 선언을 위한 구조 분해 패턴 매칭의 대응으로, 튜플이나 구조체와 같은 복합 값에 대한 할당을 허용합니다. 예를 들어, 두 개의 가변 변수를 교환할 수 있습니다:"

#: src/expressions/operator-expr.md:846
msgid "// Swap `a` and `b` using destructuring assignment.\n"
msgstr "// 구조 분해 할당을 사용하여 `a`와 `b`를 교환합니다.\n"

#: src/expressions/operator-expr.md:853
msgid ""
"In contrast to destructuring declarations using `let`, patterns may not "
"appear on the left-hand side of an assignment due to syntactic ambiguities. "
"Instead, a group of expressions that correspond to patterns are designated "
"to be [assignee expressions](../expressions.md#place-expressions-and-value-"
"expressions), and permitted on the left-hand side of an assignment. Assignee "
"expressions are then desugared to pattern matches followed by sequential "
"assignment."
msgstr "`let`을 사용한 구조 분해 선언과 달리, 구문상의 모호성 때문에 패턴은 할당의 왼쪽에 나타날 수 없습니다. 대신 패턴에 해당하는 표현식 그룹이 [피할당자 표현식](../expressions.md#place-expressions-and-value-expressions)으로 지정되어 할당의 왼쪽에 허용됩니다. 피할당자 표현식은 그런 다음 패턴 매칭과 순차적 할당으로 탈설탕(desugared)됩니다."

#: src/expressions/operator-expr.md:859
msgid ""
"The desugared patterns must be irrefutable: in particular, this means that "
"only slice patterns whose length is known at compile-time, and the trivial "
"slice `[..]`, are permitted for destructuring assignment."
msgstr "탈설탕된 패턴은 반박할 수 없어야 합니다(irrefutable). 특히 이는 컴파일 타임에 길이가 알려진 슬라이스 패턴과 사소한 슬라이스 `[..]`만이 구조 분해 할당에 허용됨을 의미합니다."

#: src/expressions/operator-expr.md:861
msgid ""
"The desugaring method is straightforward, and is illustrated best by example."
msgstr "탈설탕 방법은 간단하며, 예제로 설명하는 것이 가장 좋습니다."

#: src/expressions/operator-expr.md:871
msgid "// desugars to:\n"
msgstr "// 다음과 같이 탈설탕됩니다:\n"

#: src/expressions/operator-expr.md:895
msgid ""
"Identifiers are not forbidden from being used multiple times in a single "
"assignee expression."
msgstr "단일 피할당자 표현식에서 식별자를 여러 번 사용하는 것은 금지되지 않습니다."

#: src/expressions/operator-expr.md:899
msgid ""
"[Underscore expressions](./underscore-expr.md) and empty [range expressions]"
"(./range-expr.md) may be used to ignore certain values, without binding them."
msgstr "[밑줄 표현식](./underscore-expr.md)과 빈 [범위 표현식](./range-expr.md)을 사용하여 특정 값을 바인딩하지 않고 무시할 수 있습니다."

#: src/expressions/operator-expr.md:903
msgid ""
"Note that default binding modes do not apply for the desugared expression."
msgstr "탈설탕된 표현식에는 기본 바인딩 모드가 적용되지 않는다는 점에 유의하십시오."

#: src/expressions/operator-expr.md:907
msgid "Compound assignment expressions"
msgstr "복합 할당 표현식"

#: src/expressions/operator-expr.md:911
msgid ""
"**<sup>Syntax</sup>**  \n"
"_CompoundAssignmentExpression_ :  \n"
"      [_Expression_](../expressions.md) `+=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `-=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `*=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `/=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `%=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `&=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `|=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `^=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `<<=` [_Expression_](../"
"expressions.md)  \n"
"   | [_Expression_](../expressions.md) `>>=` [_Expression_](../"
"expressions.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_복합할당표현식_ :  \n"
"      [_표현식_](../expressions.md) `+=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `-=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `*=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `/=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `%=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `&=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `|=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `^=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `<<=` [_표현식_](../"
"expressions.md)  \n"
"   | [_표현식_](../expressions.md) `>>=` [_표현식_](../"
"expressions.md)"

#: src/expressions/operator-expr.md:926
msgid ""
"_Compound assignment expressions_ combine arithmetic and logical binary "
"operators with assignment expressions."
msgstr "_복합 할당 표현식_은 산술 및 논리 이항 연산자와 할당 표현식을 결합한 것입니다."

#: src/expressions/operator-expr.md:936
msgid ""
"The syntax of compound assignment is a [mutable](../"
"expressions.md#mutability) [place expression](../expressions.md#place-"
"expressions-and-value-expressions), the _assigned operand_, then one of the "
"operators followed by an `=` as a single token (no whitespace), and then a "
"[value expression](../expressions.md#place-expressions-and-value-"
"expressions), the _modifying operand_."
msgstr "복합 할당의 구문은 [가변](../expressions.md#mutability) [장소 표현식](../expressions.md#place-expressions-and-value-expressions)(_할당된 피연산자_), 그 다음에 단일 토큰(공백 없음)으로 `=`이 뒤따르는 연산자 중 하나, 그리고 [값 표현식](../expressions.md#place-expressions-and-value-expressions)(_수정하는 피연산자_)입니다."

#: src/expressions/operator-expr.md:940
msgid ""
"Unlike other place operands, the assigned place operand must be a place "
"expression."
msgstr "다른 장소 피연산자와 달리, 할당된 장소 피연산자는 반드시 장소 표현식이어야 합니다."

#: src/expressions/operator-expr.md:944
msgid ""
"Attempting to use a value expression is a compiler error rather than "
"promoting it to a temporary."
msgstr "값 표현식을 사용하려고 시도하면 이를 임시 값으로 승격시키는 대신 컴파일러 오류가 발생합니다."

#: src/expressions/operator-expr.md:948
msgid ""
"Evaluation of compound assignment expressions depends on the types of the "
"operators."
msgstr "복합 할당 표현식의 평가는 연산자의 타입에 따라 다릅니다."

#: src/expressions/operator-expr.md:952
msgid ""
"If both types are primitives, then the modifying operand will be evaluated "
"first followed by the assigned operand. It will then set the value of the "
"assigned operand's place to the value of performing the operation of the "
"operator with the values of the assigned operand and modifying operand."
msgstr "두 타입이 모두 기본 타입인 경우, 수정하는 피연산자가 먼저 평가된 다음 할당된 피연산자가 평가됩니다. 그런 다음 할당된 피연산자와 수정하는 피연산자의 값으로 연산자의 연산을 수행한 값으로 할당된 피연산자 장소의 값을 설정합니다."

#: src/expressions/operator-expr.md:959
msgid ""
"Otherwise, this expression is syntactic sugar for calling the function of "
"the overloading compound assignment trait of the operator (see the table "
"earlier in this chapter). A mutable borrow of the assigned operand is "
"automatically taken."
msgstr "그렇지 않으면, 이 표현식은 연산자의 오버로딩 복합 할당 트레잇의 함수를 호출하기 위한 구문 설탕입니다(이 장의 앞부분에 있는 표 참조). 할당된 피연산자의 가변 차용이 자동으로 취해집니다."

#: src/expressions/operator-expr.md:962
msgid ""
"For example, the following expression statements in `example` are equivalent:"
msgstr "예를 들어, `example`의 다음 표현식 문은 동일합니다:"

#: src/expressions/operator-expr.md:969
msgid "/* */"
msgstr "/* */"

#: src/expressions/operator-expr.md:984
msgid ""
"Like assignment expressions, compound assignment expressions always produce "
"[the unit value](../types/tuple.md)."
msgstr "할당 표현식과 마찬가지로, 복합 할당 표현식은 항상 [유닛 값](../types/tuple.md)을 생성합니다."

#: src/expressions/operator-expr.md:988
msgid ""
"_**Warning:**_ The evaluation order of operands swaps depending on the types "
"of the operands: with primitive types the right-hand side will get evaluated "
"first, while with non-primitive types the left-hand side will get evaluated "
"first. Try not to write code that depends on the evaluation order of "
"operands in compound assignment expressions. See [this test](https://"
"github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/"
"eval-order.rs) for an example of using this dependency."
msgstr "_**경고:**_ 피연산자의 평가 순서는 피연산자의 타입에 따라 바뀝니다. 기본 타입의 경우 오른쪽이 먼저 평가되고, 비기본 타입의 경우 왼쪽이 먼저 평가됩니다. 복합 할당 표현식에서 피연산자의 평가 순서에 의존하는 코드를 작성하지 않도록 하십시오. 이 의존성을 사용하는 예는 [이 테스트](https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs)를 참조하십시오."

#: src/expressions/grouped-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_GroupedExpression_ :  \n"
"   `(` [_Expression_](../expressions.md) `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_그룹화된표현식_ :  \n"
"   `(` [_표현식_](../expressions.md) `)`"

#: src/expressions/grouped-expr.md:13
msgid ""
"A _parenthesized expression_ wraps a single expression, evaluating to that "
"expression. The syntax for a parenthesized expression is a `(`, then an "
"expression, called the _enclosed operand_, and then a `)`."
msgstr "_괄호로 묶인 표현식_은 단일 표현식을 감싸며 해당 표현식으로 평가됩니다. 괄호로 묶인 표현식의 구문은 `(`, 그 다음에 _둘러싸인 피연산자_라고 하는 표현식, 그리고 `)`입니다."

#: src/expressions/grouped-expr.md:18
msgid ""
"Parenthesized expressions evaluate to the value of the enclosed operand."
msgstr "괄호로 묶인 표현식은 둘러싸인 피연산자의 값으로 평가됩니다."

#: src/expressions/grouped-expr.md:22
msgid ""
"Unlike other expressions, parenthesized expressions are both [place "
"expressions and value expressions](../expressions.md#place-expressions-and-"
"value-expressions). When the enclosed operand is a place expression, it is a "
"place expression and when the enclosed operand is a value expression, it is "
"a value expression."
msgstr "다른 표현식과 달리, 괄호로 묶인 표현식은 [장소 표현식이자 값 표현식](../expressions.md#place-expressions-and-value-expressions)입니다. 둘러싸인 피연산자가 장소 표현식이면 장소 표현식이고, 둘러싸인 피연산자가 값 표현식이면 값 표현식입니다."

#: src/expressions/grouped-expr.md:27
msgid ""
"Parentheses can be used to explicitly modify the precedence order of "
"subexpressions within an expression."
msgstr "괄호는 표현식 내의 하위 표현식의 우선 순위를 명시적으로 수정하는 데 사용할 수 있습니다."

#: src/expressions/grouped-expr.md:29
msgid "An example of a parenthesized expression:"
msgstr "괄호로 묶인 표현식의 예:"

#: src/expressions/grouped-expr.md:32
msgid "// not parenthesized\n"
msgstr "// 괄호로 묶이지 않음\n"

#: src/expressions/grouped-expr.md:33
msgid "// parenthesized\n"
msgstr "// 괄호로 묶임\n"

#: src/expressions/grouped-expr.md:38
msgid ""
"An example of a necessary use of parentheses is when calling a function "
"pointer that is a member of a struct:"
msgstr "괄호가 반드시 필요한 경우의 예는 구조체의 멤버인 함수 포인터를 호출할 때입니다:"

#: src/expressions/grouped-expr.md:46 src/expressions/grouped-expr.md:51
msgid "\"The method f\""
msgstr "\"메서드 f\""

#: src/expressions/grouped-expr.md:49 src/expressions/grouped-expr.md:52
msgid "\"The field f\""
msgstr "\"필드 f\""

#: src/expressions/array-expr.md:3
msgid "Array and array index expressions"
msgstr "배열 및 배열 인덱스 표현식"

#: src/expressions/array-expr.md:5
msgid "Array expressions"
msgstr "배열 표현식"

#: src/expressions/array-expr.md:9
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ArrayExpression_ :  \n"
"   `[` _ArrayElements_<sup>?</sup> `]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_배열표현식_ :  \n"
"   `[` _배열요소_<sup>?</sup> `]`"

#: src/expressions/array-expr.md:13
msgid ""
"_ArrayElements_ :  \n"
"      [_Expression_](../expressions.md) ( `,` [_Expression_](../"
"expressions.md) )<sup>\\*</sup> `,`<sup>?</sup>  \n"
"   | [_Expression_](../expressions.md) `;` [_Expression_](../expressions.md)"
msgstr ""
"_배열요소_ :  \n"
"      [_표현식_](../expressions.md) ( `,` [_표현식_](../"
"expressions.md) )<sup>\\*</sup> `,`<sup>?</sup>  \n"
"   | [_표현식_](../expressions.md) `;` [_표현식_](../expressions.md)"

#: src/expressions/array-expr.md:19
msgid ""
"_Array expressions_ construct [arrays](../types/array.md). Array expressions "
"come in two forms."
msgstr "_배열 표현식_은 [배열](../types/array.md)을 생성합니다. 배열 표현식에는 두 가지 형식이 있습니다."

#: src/expressions/array-expr.md:24
msgid "The first form lists out every value in the array."
msgstr "첫 번째 형식은 배열의 모든 값을 나열합니다."

#: src/expressions/array-expr.md:28
msgid ""
"The syntax for this form is a comma-separated list of expressions of uniform "
"type enclosed in square brackets."
msgstr "이 형식의 구문은 대괄호 안에 쉼표로 구분된 동일한 타입의 표현식 목록입니다."

#: src/expressions/array-expr.md:32
msgid ""
"This produces an array containing each of these values in the order they are "
"written."
msgstr "이것은 각 값을 작성된 순서대로 포함하는 배열을 생성합니다."

#: src/expressions/array-expr.md:36
msgid ""
"The syntax for the second form is two expressions separated by a semicolon "
"(`;`) enclosed in square brackets."
msgstr "두 번째 형식의 구문은 대괄호 안에 세미콜론(`;`)으로 구분된 두 개의 표현식입니다."

#: src/expressions/array-expr.md:40
msgid "The expression before the `;` is called the _repeat operand_."
msgstr "`;` 앞의 표현식을 _반복 피연산자_라고 합니다."

#: src/expressions/array-expr.md:44
msgid "The expression after the `;` is called the _length operand_."
msgstr "`;` 뒤의 표현식을 _길이 피연산자_라고 합니다."

#: src/expressions/array-expr.md:48
msgid ""
"It must have type `usize` and be a [constant expression](../"
"const_eval.md#constant-expressions), such as a [literal](../"
"tokens.md#literals) or a [constant item](../items/constant-items.md)."
msgstr "이것은 `usize` 타입이어야 하며, [리터럴](../tokens.md#literals)이나 [상수 아이템](../items/constant-items.md)과 같은 [상수 표현식](../const_eval.md#constant-expressions)이어야 합니다."

#: src/expressions/array-expr.md:52
msgid ""
"An array expression of this form creates an array with the length of the "
"value of the length operand with each element being a copy of the repeat "
"operand. That is, `[a; b]` creates an array containing `b` copies of the "
"value of `a`."
msgstr "이 형식의 배열 표현식은 길이 피연산자의 값만큼의 길이를 가지며, 각 요소가 반복 피연산자의 복사본인 배열을 생성합니다. 즉, `[a; b]`는 `a` 값의 복사본 `b`개를 포함하는 배열을 생성합니다."

#: src/expressions/array-expr.md:57
msgid ""
"If the length operand has a value greater than 1 then this requires that the "
"type of the repeat operand is [`Copy`](../special-types-and-traits.md#copy) "
"or that it must be a [path](path-expr.md) to a constant item."
msgstr "길이 피연산자의 값이 1보다 큰 경우, 반복 피연산자의 타입이 [`Copy`](../special-types-and-traits.md#copy)이거나 상수 아이템에 대한 [경로](path-expr.md)여야 합니다."

#: src/expressions/array-expr.md:61
msgid ""
"When the repeat operand is a constant item, it is evaluated the length "
"operand's value times."
msgstr "반복 피연산자가 상수 아이템인 경우, 길이 피연산자의 값만큼 평가됩니다."

#: src/expressions/array-expr.md:65
msgid "If that value is `0`, then the constant item is not evaluated at all."
msgstr "그 값이 `0`이면, 상수 아이템은 전혀 평가되지 않습니다."

#: src/expressions/array-expr.md:69
msgid ""
"For expressions that are not a constant item, it is evaluated exactly once, "
"and then the result is copied the length operand's value times."
msgstr "상수 아이템이 아닌 표현식의 경우, 정확히 한 번 평가되고 결과는 길이 피연산자의 값만큼 복사됩니다."

#: src/expressions/array-expr.md:73 src/expressions/array-expr.md:117
#: src/expressions/array-expr.md:120 src/expressions/array-expr.md:122
#: src/patterns.md:500 src/patterns.md:516 src/types/closure.md:225
msgid "\"a\""
msgstr "\"a\""

#: src/expressions/array-expr.md:73 src/expressions/array-expr.md:117
#: src/expressions/array-expr.md:120 src/expressions/array-expr.md:122
#: src/patterns.md:500 src/types/closure.md:225
msgid "\"b\""
msgstr "\"b\""

#: src/expressions/array-expr.md:73 src/patterns.md:500
msgid "\"c\""
msgstr "\"c\""

#: src/expressions/array-expr.md:73
msgid "\"d\""
msgstr "\"d\""

#: src/expressions/array-expr.md:74
msgid "// array with 128 zeros\n"
msgstr "// 128개의 0을 가진 배열\n"

#: src/expressions/array-expr.md:76
msgid "// 2D array\n"
msgstr "// 2차원 배열\n"

#: src/expressions/array-expr.md:83
msgid "Array and slice indexing expressions"
msgstr "배열 및 슬라이스 인덱싱 표현식"

#: src/expressions/array-expr.md:85
msgid ""
"**<sup>Syntax</sup>**  \n"
"_IndexExpression_ :  \n"
"   [_Expression_](../expressions.md) `[` [_Expression_](../expressions.md) "
"`]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_인덱스표현식_ :  \n"
"   [_표현식_](../expressions.md) `[` [_표현식_](../expressions.md) "
"`]`"

#: src/expressions/array-expr.md:91
msgid ""
"[Array](../types/array.md) and [slice](../types/slice.md)\\-typed values can "
"be indexed by writing a square-bracket-enclosed expression of type `usize` "
"(the index) after them. When the array is mutable, the resulting [memory "
"location](../expressions.md#place-expressions-and-value-expressions) can be "
"assigned to."
msgstr "[배열](../types/array.md) 및 [슬라이스](../types/slice.md) 타입의 값은 그 뒤에 `usize` 타입의 대괄호로 묶인 표현식(인덱스)을 작성하여 인덱싱할 수 있습니다. 배열이 가변인 경우 결과 [메모리 위치](../expressions.md#place-expressions-and-value-expressions)에 할당할 수 있습니다."

#: src/expressions/array-expr.md:96
msgid ""
"For other types an index expression `a[b]` is equivalent to "
"`*std::ops::Index::index(&a, b)`, or `*std::ops::IndexMut::index_mut(&mut a, "
"b)` in a mutable place expression context. Just as with methods, Rust will "
"also insert dereference operations on `a` repeatedly to find an "
"implementation."
msgstr "다른 타입의 경우 인덱스 표현식 `a[b]`는 `*std::ops::Index::index(&a, b)`와 동일하며, 가변 장소 표현식 컨텍스트에서는 `*std::ops::IndexMut::index_mut(&mut a, b)`와 동일합니다. 메서드와 마찬가지로, Rust는 구현을 찾기 위해 `a`에 대해 반복적으로 역참조 작업을 수행합니다."

#: src/expressions/array-expr.md:101
msgid "Indices are zero-based for arrays and slices."
msgstr "배열과 슬라이스의 인덱스는 0부터 시작합니다."

#: src/expressions/array-expr.md:105
msgid ""
"Array access is a [constant expression](../const_eval.md#constant-"
"expressions), so bounds can be checked at compile-time with a constant index "
"value. Otherwise a check will be performed at run-time that will put the "
"thread in a _panicked state_ if it fails."
msgstr "배열 접근은 [상수 표현식](../const_eval.md#constant-expressions)이므로 상수 인덱스 값을 사용하여 컴파일 타임에 범위를 확인할 수 있습니다. 그렇지 않으면 런타임에 확인이 수행되며, 실패할 경우 스레드가 _패닉 상태_가 됩니다."

#: src/expressions/array-expr.md:109
msgid "// lint is deny by default.\n"
msgstr "// 린트는 기본적으로 거부(deny)됩니다.\n"

#: src/expressions/array-expr.md:112
msgid "// Evaluates to 3\n"
msgstr "// 3으로 평가됩니다\n"

#: src/expressions/array-expr.md:115
msgid "// multidimensional array indexing\n"
msgstr "// 다차원 배열 인덱싱\n"

#: src/expressions/array-expr.md:117 src/expressions/array-expr.md:123
msgid "// warning: index out of bounds\n"
msgstr "// 경고: 인덱스가 범위를 벗어남\n"

#: src/expressions/array-expr.md:120
msgid "// panics\n"
msgstr "// 패닉 발생\n"

#: src/expressions/array-expr.md:128
msgid ""
"The array index expression can be implemented for types other than arrays "
"and slices by implementing the [Index](../../core/ops/index/"
"trait.Index.html) and [IndexMut](../../core/ops/index/trait.IndexMut.html) "
"traits."
msgstr "배열 인덱스 표현식은 [Index](../../core/ops/index/trait.Index.html) 및 [IndexMut](../../core/ops/index/trait.IndexMut.html) 트레잇을 구현하여 배열 및 슬라이스 이외의 타입에 대해 구현할 수 있습니다."

#: src/expressions/tuple-expr.md:3
msgid "Tuple and tuple indexing expressions"
msgstr "튜플 및 튜플 인덱싱 표현식"

#: src/expressions/tuple-expr.md:5
msgid "Tuple expressions"
msgstr "튜플 표현식"

#: src/expressions/tuple-expr.md:9
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TupleExpression_ :  \n"
"   `(` _TupleElements_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_튜플표현식_ :  \n"
"   `(` _튜플요소_<sup>?</sup> `)`"

#: src/expressions/tuple-expr.md:13
msgid ""
"_TupleElements_ :  \n"
"   ( [_Expression_](../expressions.md) `,` )<sup>+</sup> [_Expression_](../"
"expressions.md)<sup>?</sup>"
msgstr ""
"_튜플요소_ :  \n"
"   ( [_표현식_](../expressions.md) `,` )<sup>+</sup> [_표현식_](../"
"expressions.md)<sup>?</sup>"

#: src/expressions/tuple-expr.md:18
msgid "A _tuple expression_ constructs [tuple values](../types/tuple.md)."
msgstr "_튜플 표현식_은 [튜플 값](../types/tuple.md)을 생성합니다."

#: src/expressions/tuple-expr.md:22
msgid ""
"The syntax for tuple expressions is a parenthesized, comma separated list of "
"expressions, called the _tuple initializer operands_."
msgstr "튜플 표현식의 구문은 _튜플 초기화 피연산자_라고 하는 괄호로 묶인 쉼표로 구분된 표현식 목록입니다."

#: src/expressions/tuple-expr.md:26
msgid ""
"1-ary tuple expressions require a comma after their tuple initializer "
"operand to be disambiguated with a [parenthetical expression](grouped-"
"expr.md)."
msgstr "단항(1-ary) 튜플 표현식은 [괄호로 묶인 표현식](grouped-expr.md)과 구분하기 위해 튜플 초기화 피연산자 뒤에 쉼표가 필요합니다."

#: src/expressions/tuple-expr.md:30
msgid ""
"Tuple expressions are a [value expression](../expressions.md#place-"
"expressions-and-value-expressions) that evaluate into a newly constructed "
"value of a tuple type."
msgstr "튜플 표현식은 새로 생성된 튜플 타입 값으로 평가되는 [값 표현식](../expressions.md#place-expressions-and-value-expressions)입니다."

#: src/expressions/tuple-expr.md:34
msgid ""
"The number of tuple initializer operands is the arity of the constructed "
"tuple."
msgstr "튜플 초기화 피연산자의 수는 생성된 튜플의 항수(arity)입니다."

#: src/expressions/tuple-expr.md:38
msgid ""
"Tuple expressions without any tuple initializer operands produce the unit "
"tuple."
msgstr "튜플 초기화 피연산자가 없는 튜플 표현식은 유닛 튜플을 생성합니다."

#: src/expressions/tuple-expr.md:42
msgid ""
"For other tuple expressions, the first written tuple initializer operand "
"initializes the field `0` and subsequent operands initializes the next "
"highest field. For example, in the tuple expression `('a', 'b', 'c')`, `'a'` "
"initializes the value of the field `0`, `'b'` field `1`, and `'c'` field `2`."
msgstr "다른 튜플 표현식의 경우, 첫 번째로 작성된 튜플 초기화 피연산자는 필드 `0`을 초기화하고 후속 피연산자는 다음으로 높은 필드를 초기화합니다. 예를 들어, 튜플 표현식 `('a', 'b', 'c')`에서 `'a'`는 필드 `0`의 값을 초기화하고, `'b'`는 필드 `1`, `'c'`는 필드 `2`를 초기화합니다."

#: src/expressions/tuple-expr.md:45
msgid "Examples of tuple expressions and their types:"
msgstr "튜플 표현식과 그 타입의 예:"

#: src/expressions/tuple-expr.md:47 src/glossary.md:81
msgid "Expression"
msgstr "표현식"

#: src/expressions/tuple-expr.md:49 src/types/tuple.md:44
msgid "`()` (unit)"
msgstr "`()` (유닛)"

#: src/expressions/tuple-expr.md:50
msgid "`(0.0, 4.5)`"
msgstr "`(0.0, 4.5)`"

#: src/expressions/tuple-expr.md:50 src/types/tuple.md:46
msgid "`(f64, f64)`"
msgstr "`(f64, f64)`"

#: src/expressions/tuple-expr.md:51
msgid "`(\"x\".to_string(), )`"
msgstr "`(\"x\".to_string(), )`"

#: src/expressions/tuple-expr.md:51
msgid "`(String, )`"
msgstr "`(String, )`"

#: src/expressions/tuple-expr.md:52
msgid "`(\"a\", 4usize, true)`"
msgstr "`(\"a\", 4usize, true)`"

#: src/expressions/tuple-expr.md:52
msgid "`(&'static str, usize, bool)`"
msgstr "`(&'static str, usize, bool)`"

#: src/expressions/tuple-expr.md:56
msgid "Tuple indexing expressions"
msgstr "튜플 인덱싱 표현식"

#: src/expressions/tuple-expr.md:60
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TupleIndexingExpression_ :  \n"
"   [_Expression_](../expressions.md) `.` [TUPLE_INDEX](../tokens.md#tuple-"
"index)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_튜플인덱싱표현식_ :  \n"
"   [_표현식_](../expressions.md) `.` [튜플_인덱스](../tokens.md#tuple-"
"index)"

#: src/expressions/tuple-expr.md:66
msgid ""
"A _tuple indexing expression_ accesses fields of [tuples](../types/tuple.md) "
"and [tuple structs](../types/struct.md)."
msgstr "_튜플 인덱싱 표현식_은 [튜플](../types/tuple.md)과 [튜플 구조체](../types/struct.md)의 필드에 접근합니다."

#: src/expressions/tuple-expr.md:68
msgid ""
"The syntax for a tuple index expression is an expression, called the _tuple "
"operand_, then a `.`, then finally a tuple index."
msgstr "튜플 인덱스 표현식의 구문은 _튜플 피연산자_라고 하는 표현식, 그 다음 `.`, 그리고 마지막으로 튜플 인덱스입니다."

#: src/expressions/tuple-expr.md:72
msgid ""
"The syntax for the _tuple index_ is a [decimal literal](../tokens.md#integer-"
"literals) with no leading zeros, underscores, or suffix. For example `0` and "
"`2` are valid tuple indices but not `01`, `0_`, nor `0i32`."
msgstr "_튜플 인덱스_의 구문은 선행 0, 밑줄 또는 접미사가 없는 [십진 리터럴](../tokens.md#integer-literals)입니다. 예를 들어 `0`과 `2`는 유효한 튜플 인덱스이지만, `01`, `0_`, `0i32`는 그렇지 않습니다."

#: src/expressions/tuple-expr.md:77
msgid ""
"The type of the tuple operand must be a [tuple type](../types/tuple.md) or a "
"[tuple struct](../types/struct.md)."
msgstr "튜플 피연산자의 타입은 [튜플 타입](../types/tuple.md) 또는 [튜플 구조체](../types/struct.md)여야 합니다."

#: src/expressions/tuple-expr.md:81
msgid ""
"The tuple index must be a name of a field of the type of the tuple operand."
msgstr "튜플 인덱스는 튜플 피연산자 타입의 필드 이름이어야 합니다."

#: src/expressions/tuple-expr.md:85
msgid ""
"Evaluation of tuple index expressions has no side effects beyond evaluation "
"of its tuple operand. As a [place expression](../expressions.md#place-"
"expressions-and-value-expressions), it evaluates to the location of the "
"field of the tuple operand with the same name as the tuple index."
msgstr "튜플 인덱스 표현식의 평가는 튜플 피연산자의 평가 외에 부작용이 없습니다. [장소 표현식](../expressions.md#place-expressions-and-value-expressions)으로서, 튜플 인덱스와 이름이 같은 튜플 피연산자 필드의 위치로 평가됩니다."

#: src/expressions/tuple-expr.md:88
msgid "Examples of tuple indexing expressions:"
msgstr "튜플 인덱싱 표현식의 예:"

#: src/expressions/tuple-expr.md:91
msgid "// Indexing a tuple\n"
msgstr "// 튜플 인덱싱\n"

#: src/expressions/tuple-expr.md:92
msgid "\"a string\""
msgstr "\"문자열\""

#: src/expressions/tuple-expr.md:94
msgid "// Indexing a tuple struct\n"
msgstr "// 튜플 구조체 인덱싱\n"

#: src/expressions/tuple-expr.md:102
msgid ""
"**Note**: Unlike field access expressions, tuple index expressions can be "
"the function operand of a [call expression](./call-expr.md) as it cannot be "
"confused with a method call since method names cannot be numbers."
msgstr "**참고**: 필드 접근 표현식과 달리, 튜플 인덱스 표현식은 메서드 이름이 숫자가 될 수 없으므로 메서드 호출과 혼동될 수 없기 때문에 [호출 표현식](./call-expr.md)의 함수 피연산자가 될 수 있습니다."

#: src/expressions/tuple-expr.md:104
msgid ""
"**Note**: Although arrays and slices also have elements, you must use an "
"[array or slice indexing expression](array-expr.md#array-and-slice-indexing-"
"expressions) or a [slice pattern](../patterns.md#slice-patterns) to access "
"their elements."
msgstr "**참고**: 배열과 슬라이스에도 요소가 있지만, 해당 요소에 접근하려면 [배열 또는 슬라이스 인덱싱 표현식](array-expr.md#array-and-slice-indexing-expressions)이나 [슬라이스 패턴](../patterns.md#slice-patterns)을 사용해야 합니다."

#: src/expressions/struct-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_StructExpression_ :  \n"
"      _StructExprStruct_  \n"
"   | _StructExprTuple_  \n"
"   | _StructExprUnit_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_구조체표현식_ :  \n"
"      _구조체표현식구조체_  \n"
"   | _구조체표현식튜플_  \n"
"   | _구조체표현식유닛_"

#: src/expressions/struct-expr.md:13
msgid ""
"_StructExprStruct_ :  \n"
"   [_PathInExpression_](../paths.md#paths-in-expressions) `{` "
"(_StructExprFields_ | _StructBase_)<sup>?</sup> `}`"
msgstr ""
"_구조체표현식구조체_ :  \n"
"   [_표현식내경로_](../paths.md#paths-in-expressions) `{` "
"(_구조체표현식필드_ | _구조체베이스_)<sup>?</sup> `}`"

#: src/expressions/struct-expr.md:16
msgid ""
"_StructExprFields_ :  \n"
"   _StructExprField_ (`,` _StructExprField_)<sup>\\*</sup> (`,` _StructBase_ "
"| `,`<sup>?</sup>)"
msgstr ""
"_구조체표현식필드_ :  \n"
"   _구조체표현식필드_ (`,` _구조체표현식필드_)<sup>\\*</sup> (`,` _구조체베이스_ "
"| `,`<sup>?</sup>)"

#: src/expressions/struct-expr.md:19
msgid ""
"_StructExprField_ :  \n"
"   [_OuterAttribute_](../attributes.md) <sup>\\*</sup>  \n"
"   (  \n"
"         [IDENTIFIER](../identifiers.md)  \n"
"      | ([IDENTIFIER](../identifiers.md) | [TUPLE_INDEX](../tokens.md#tuple-"
"index)) `:` [_Expression_](../expressions.md)  \n"
"   )"
msgstr ""
"_구조체표현식필드_ :  \n"
"   [_외부속성_](../attributes.md) <sup>\\*</sup>  \n"
"   (  \n"
"         [식별자](../identifiers.md)  \n"
"      | ([식별자](../identifiers.md) | [튜플_인덱스](../tokens.md#tuple-"
"index)) `:` [_표현식_](../expressions.md)  \n"
"   )"

#: src/expressions/struct-expr.md:26
msgid ""
"_StructBase_ :  \n"
"   `..` [_Expression_](../expressions.md)"
msgstr ""
"_구조체베이스_ :  \n"
"   `..` [_표현식_](../expressions.md)"

#: src/expressions/struct-expr.md:29
msgid ""
"_StructExprTuple_ :  \n"
"   [_PathInExpression_](../paths.md#paths-in-expressions) `(`  \n"
"      ( [_Expression_](../expressions.md) (`,` [_Expression_](../"
"expressions.md))<sup>\\*</sup> `,`<sup>?</sup> )<sup>?</sup>  \n"
"   `)`"
msgstr ""
"_구조체표현식튜플_ :  \n"
"   [_표현식내경로_](../paths.md#paths-in-expressions) `(`  \n"
"      ( [_표현식_](../expressions.md) (`,` [_표현식_](../"
"expressions.md))<sup>\\*</sup> `,`<sup>?</sup> )<sup>?</sup>  \n"
"   `)`"

#: src/expressions/struct-expr.md:34
msgid ""
"_StructExprUnit_ : [_PathInExpression_](../paths.md#paths-in-expressions)"
msgstr "_구조체표현식유닛_ : [_표현식내경로_](../paths.md#paths-in-expressions)"

#: src/expressions/struct-expr.md:38
msgid ""
"A _struct expression_ creates a struct, enum, or union value. It consists of "
"a path to a [struct](../items/structs.md), [enum variant](../items/"
"enumerations.md), or [union](../items/unions.md) item followed by the values "
"for the fields of the item. There are three forms of struct expressions: "
"struct, tuple, and unit."
msgstr "_구조체 표현식_은 구조체, 열거형 또는 공용체 값을 생성합니다. 이는 [구조체](../items/structs.md), [열거형 변형](../items/enumerations.md) 또는 [공용체](../items/unions.md) 아이템에 대한 경로와 그 뒤에 오는 아이템의 필드 값들로 구성됩니다. 구조체 표현식에는 구조체, 튜플, 유닛의 세 가지 형식이 있습니다."

#: src/expressions/struct-expr.md:42
msgid "The following are examples of struct expressions:"
msgstr "다음은 구조체 표현식의 예입니다:"

#: src/expressions/struct-expr.md:53
msgid "// Results in the same value as the above line\n"
msgstr "// 윗줄과 같은 결과를 가집니다\n"

#: src/expressions/struct-expr.md:54
msgid "\"Joe\""
msgstr "\"Joe\""

#: src/expressions/struct-expr.md:60
msgid "Field struct expression"
msgstr "필드 구조체 표현식"

#: src/expressions/struct-expr.md:64
msgid ""
"A struct expression with fields enclosed in curly braces allows you to "
"specify the value for each individual field in any order. The field name is "
"separated from its value with a colon."
msgstr "중괄호로 묶인 필드가 있는 구조체 표현식을 사용하면 각 개별 필드의 값을 순서에 관계없이 지정할 수 있습니다. 필드 이름은 콜론으로 값과 구분됩니다."

#: src/expressions/struct-expr.md:69
msgid ""
"A value of a [union](../items/unions.md) type can only be created using this "
"syntax, and it must specify exactly one field."
msgstr "[공용체](../items/unions.md) 타입의 값은 이 구문을 사용하여 생성할 수 있으며, 정확히 하나의 필드를 지정해야 합니다."

#: src/expressions/struct-expr.md:73
msgid "Functional update syntax"
msgstr "함수형 업데이트 구문"

#: src/expressions/struct-expr.md:77
msgid ""
"A struct expression that constructs a value of a struct type can terminate "
"with the syntax `..` followed by an expression to denote a functional update."
msgstr "구조체 타입의 값을 생성하는 구조체 표현식은 함수형 업데이트를 나타내기 위해 `..` 뒤에 표현식이 오는 구문으로 끝날 수 있습니다."

#: src/expressions/struct-expr.md:81
msgid ""
"The expression following `..` (the base) must have the same struct type as "
"the new struct type being formed."
msgstr "`..` 뒤에 오는 표현식(베이스)은 생성되는 새 구조체 타입과 동일한 구조체 타입을 가져야 합니다."

#: src/expressions/struct-expr.md:85
msgid ""
"The entire expression uses the given values for the fields that were "
"specified and moves or copies the remaining fields from the base expression."
msgstr "전체 표현식은 지정된 필드에 대해 주어진 값을 사용하고 베이스 표현식에서 나머지 필드를 이동하거나 복사합니다."

#: src/expressions/struct-expr.md:89
msgid ""
"As with all struct expressions, all of the fields of the struct must be "
"[visible](../visibility-and-privacy.md), even those not explicitly named."
msgstr "모든 구조체 표현식과 마찬가지로, 명시적으로 명명되지 않은 필드를 포함하여 구조체의 모든 필드는 [보여야](../visibility-and-privacy.md) 합니다."

#: src/expressions/struct-expr.md:95
msgid "// OK, only base.x is accessed\n"
msgstr "// OK, base.x만 접근됩니다\n"

#: src/expressions/struct-expr.md:101
msgid ""
"Struct expressions with curly braces can't be used directly in a [loop](loop-"
"expr.md) or [if](if-expr.md#if-expressions) expression's head, or in the "
"[scrutinee](../glossary.md#scrutinee) of an [if let](if-expr.md#if-let-"
"expressions) or [match](match-expr.md) expression. However, struct "
"expressions can be used in these situations if they are within another "
"expression, for example inside [parentheses](grouped-expr.md)."
msgstr "중괄호가 있는 구조체 표현식은 [loop](loop-expr.md) 또는 [if](if-expr.md#if-expressions) 표현식의 헤드, 또는 [if let](if-expr.md#if-let-expressions)이나 [match](match-expr.md) 표현식의 [scrutinee](../glossary.md#scrutinee)에서 직접 사용할 수 없습니다. 그러나 구조체 표현식이 다른 표현식 내에 있는 경우(예: [괄호](grouped-expr.md) 내부), 이러한 상황에서 사용할 수 있습니다."

#: src/expressions/struct-expr.md:106
msgid ""
"The field names can be decimal integer values to specify indices for "
"constructing tuple structs. This can be used with base structs to fill out "
"the remaining indices not specified:"
msgstr "필드 이름은 십진 정수 값이 되어 튜플 구조체 생성 시 인덱스를 지정할 수 있습니다. 이것은 기본 구조체와 함께 사용하여 지정되지 않은 나머지 인덱스를 채우는 데 사용할 수 있습니다."

#: src/expressions/struct-expr.md:111 src/expressions/struct-expr.md:142
msgid "// Typical way of creating a tuple struct.\n"
msgstr "// 튜플 구조체를 생성하는 전형적인 방법.\n"

#: src/expressions/struct-expr.md:112
msgid "// Specifying fields by index.\n"
msgstr "// 인덱스로 필드 지정.\n"

#: src/expressions/struct-expr.md:113
msgid "// Fill out all other fields using a base struct.\n"
msgstr "// 기본 구조체를 사용하여 다른 모든 필드를 채웁니다.\n"

#: src/expressions/struct-expr.md:118
msgid "Struct field init shorthand"
msgstr "구조체 필드 초기화 단축형"

#: src/expressions/struct-expr.md:120
msgid ""
"When initializing a data structure (struct, enum, union) with named (but not "
"numbered) fields, it is allowed to write `fieldname` as a shorthand for "
"`fieldname: fieldname`. This allows a compact syntax with less duplication. "
"For example:"
msgstr "명명된(번호가 매겨지지 않은) 필드가 있는 데이터 구조(구조체, 열거형, 공용체)를 초기화할 때, `fieldname: fieldname`의 약어로 `fieldname`을 작성할 수 있습니다. 이를 통해 중복이 적은 간결한 구문을 사용할 수 있습니다. 예를 들면:"

#: src/expressions/struct-expr.md:135
msgid "Tuple struct expression"
msgstr "튜플 구조체 표현식"

#: src/expressions/struct-expr.md:137
msgid ""
"A struct expression with fields enclosed in parentheses constructs a tuple "
"struct. Though it is listed here as a specific expression for completeness, "
"it is equivalent to a [call expression](call-expr.md) to the tuple struct's "
"constructor. For example:"
msgstr "괄호로 묶인 필드가 있는 구조체 표현식은 튜플 구조체를 생성합니다. 완전성을 위해 여기에 특정 표현식으로 나열되어 있지만, 이는 튜플 구조체의 생성자에 대한 [호출 표현식](call-expr.md)과 동일합니다. 예를 들면:"

#: src/expressions/struct-expr.md:143
msgid "// `c` is a function that takes 3 arguments.\n"
msgstr "// `c`는 3개의 인수를 받는 함수입니다.\n"

#: src/expressions/struct-expr.md:144
msgid "// Creates a `Position` value.\n"
msgstr "// `Position` 값을 생성합니다.\n"

#: src/expressions/struct-expr.md:149
msgid "Unit struct expression"
msgstr "유닛 구조체 표현식"

#: src/expressions/struct-expr.md:151
msgid ""
"A unit struct expression is just the path to a unit struct item. This refers "
"to the unit struct's implicit constant of its value. The unit struct value "
"can also be constructed with a fieldless struct expression. For example:"
msgstr "유닛 구조체 표현식은 단순히 유닛 구조체 아이템에 대한 경로입니다. 이는 유닛 구조체 값의 암시적 상수를 나타냅니다. 유닛 구조체 값은 필드 없는 구조체 표현식으로도 생성할 수 있습니다. 예를 들면:"

#: src/expressions/struct-expr.md:157
msgid "// Gamma unit value.\n"
msgstr "// Gamma 유닛 값.\n"

#: src/expressions/struct-expr.md:158
msgid "// Exact same value as `a`.\n"
msgstr "// `a`와 정확히 같은 값.\n"

#: src/expressions/call-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_CallExpression_ :  \n"
"   [_Expression_](../expressions.md) `(` _CallParams_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_호출표현식_ :  \n"
"   [_표현식_](../expressions.md) `(` _호출매개변수_<sup>?</sup> `)`"

#: src/expressions/call-expr.md:11
msgid ""
"_CallParams_ :  \n"
"   [_Expression_](../expressions.md) ( `,` [_Expression_](../"
"expressions.md) )<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_호출매개변수_ :  \n"
"   [_표현식_](../expressions.md) ( `,` [_표현식_](../"
"expressions.md) )<sup>\\*</sup> `,`<sup>?</sup>"

#: src/expressions/call-expr.md:16
msgid ""
"A _call expression_ calls a function. The syntax of a call expression is an "
"expression, called the _function operand_, followed by a parenthesized comma-"
"separated list of expression, called the _argument operands_."
msgstr "_호출 표현식_은 함수를 호출합니다. 호출 표현식의 구문은 _함수 피연산자_라고 하는 표현식과 그 뒤에 오는 _인수 피연산자_라고 하는 괄호로 묶인 쉼표로 구분된 표현식 목록입니다."

#: src/expressions/call-expr.md:21
msgid "If the function eventually returns, then the expression completes."
msgstr "함수가 결국 반환되면 표현식이 완료됩니다."

#: src/expressions/call-expr.md:25
msgid ""
"For [non-function types](../types/function-item.md), the expression `f(...)` "
"uses the method on one of the following traits based on the function operand:"
msgstr "[비 함수 타입](../types/function-item.md)의 경우, 표현식 `f(...)`는 함수 피연산자에 따라 다음 트레잇 중 하나의 메서드를 사용합니다:"

#: src/expressions/call-expr.md:27
msgid ""
"[`Fn`](../../core/ops/function/trait.Fn.html) or [`AsyncFn`](../../core/ops/"
"async_function/trait.AsyncFn.html) --- shared reference."
msgstr "[`Fn`](../../core/ops/function/trait.Fn.html) 또는 [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) --- 공유 참조."

#: src/expressions/call-expr.md:28
msgid ""
"[`FnMut`](../../core/ops/function/trait.FnMut.html) or [`AsyncFnMut`](../../"
"core/ops/async_function/trait.AsyncFnMut.html) --- mutable reference."
msgstr "[`FnMut`](../../core/ops/function/trait.FnMut.html) 또는 [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) --- 가변 참조."

#: src/expressions/call-expr.md:29
msgid ""
"[`FnOnce`](../../core/ops/function/trait.FnOnce.html) or [`AsyncFnOnce`]"
"(../../core/ops/async_function/trait.AsyncFnOnce.html) --- value."
msgstr "[`FnOnce`](../../core/ops/function/trait.FnOnce.html) 또는 [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) --- 값."

#: src/expressions/call-expr.md:33
msgid ""
"An automatic borrow will be taken if needed. The function operand will also "
"be [automatically dereferenced](field-expr.md#automatic-dereferencing) if "
"required."
msgstr "필요한 경우 자동 차용이 취해집니다. 필요한 경우 함수 피연산자도 [자동으로 역참조](field-expr.md#automatic-dereferencing)됩니다."

#: src/expressions/call-expr.md:36
msgid "Some examples of call expressions:"
msgstr "호출 표현식의 몇 가지 예:"

#: src/expressions/call-expr.md:46
msgid "Disambiguating Function Calls"
msgstr "함수 호출의 모호성 해결"

#: src/expressions/call-expr.md:50
msgid ""
"All function calls are sugar for a more explicit [fully-qualified syntax](../"
"paths.md#qualified-paths)."
msgstr "모든 함수 호출은 더 명시적인 [정규화된 구문](../paths.md#qualified-paths)에 대한 설탕입니다."

#: src/expressions/call-expr.md:54
msgid ""
"Function calls may need to be fully qualified, depending on the ambiguity of "
"a call in light of in-scope items."
msgstr "함수 호출은 스코프 내 아이템에 비추어 호출의 모호성에 따라 완전히 정규화되어야 할 수도 있습니다."

#: src/expressions/call-expr.md:56
msgid ""
"**Note**: In the past, the terms \"Unambiguous Function Call Syntax\", "
"\"Universal Function Call Syntax\", or \"UFCS\", have been used in "
"documentation, issues, RFCs, and other community writings. However, these "
"terms lack descriptive power and potentially confuse the issue at hand. We "
"mention them here for searchability's sake."
msgstr "**참고**: 과거에는 문서, 이슈, RFC 및 기타 커뮤니티 글에서 \"모호하지 않은 함수 호출 구문(Unambiguous Function Call Syntax)\", \"범용 함수 호출 구문(Universal Function Call Syntax)\" 또는 \"UFCS\"라는 용어가 사용되었습니다. 그러나 이러한 용어는 설명력이 부족하고 당면한 문제를 혼란스럽게 할 수 있습니다. 검색 가능성을 위해 여기에서 언급합니다."

#: src/expressions/call-expr.md:62
msgid ""
"Several situations often occur which result in ambiguities about the "
"receiver or referent of method or associated function calls. These "
"situations may include:"
msgstr "메서드 또는 연관 함수 호출의 수신자 또는 참조 대상에 대한 모호성을 초래하는 상황이 종종 발생합니다. 이러한 상황은 다음을 포함할 수 있습니다:"

#: src/expressions/call-expr.md:65
msgid ""
"Multiple in-scope traits define methods with the same name for the same types"
msgstr "여러 스코프 내 트레잇이 동일한 타입에 대해 동일한 이름의 메서드를 정의하는 경우"

#: src/expressions/call-expr.md:66
msgid ""
"Auto-`deref` is undesirable; for example, distinguishing between methods on "
"a smart pointer itself and the pointer's referent"
msgstr "자동 `deref`가 바람직하지 않은 경우; 예를 들어, 스마트 포인터 자체의 메서드와 포인터가 참조하는 대상의 메서드를 구별하는 경우"

#: src/expressions/call-expr.md:67
msgid ""
"Methods which take no arguments, like [`default()`](../../core/default/"
"trait.Default.html#tymethod.default), and return properties of a type, like "
"[`size_of()`](../../core/mem/fn.size_of.html)"
msgstr "[`default()`](../../core/default/trait.Default.html#tymethod.default)와 같이 인수를 받지 않는 메서드, 그리고 [`size_of()`](../../core/mem/fn.size_of.html)와 같이 타입의 속성을 반환하는 메서드"

#: src/expressions/call-expr.md:71
msgid ""
"To resolve the ambiguity, the programmer may refer to their desired method "
"or function using more specific paths, types, or traits."
msgstr "모호성을 해결하기 위해, 프로그래머는 더 구체적인 경로, 타입 또는 트레잇을 사용하여 원하는 메서드나 함수를 참조할 수 있습니다."

#: src/expressions/call-expr.md:73
msgid "For example,"
msgstr "예를 들어,"

#: src/expressions/call-expr.md:101
msgid ""
"// we can do this because we only have one item called `print` for `Foo`s\n"
msgstr ""
"// `Foo`에 대해 `print`라고 불리는 아이템이 하나만 있기 때문에 이렇게 할 수 있습니다\n"

#: src/expressions/call-expr.md:103
msgid "// more explicit, and, in the case of `Foo`, not necessary\n"
msgstr "// 더 명시적이며, `Foo`의 경우 필요하지 않습니다\n"

#: src/expressions/call-expr.md:105
msgid "// if you're not into the whole brevity thing\n"
msgstr "// 간결함을 선호하지 않는다면\n"

#: src/expressions/call-expr.md:108
msgid ""
"// b.print(); // Error: multiple 'print' found\n"
"    // Bar::print(&b); // Still an error: multiple `print` found\n"
msgstr ""
"// b.print(); // 오류: 여러 개의 'print' 발견됨\n"
"    // Bar::print(&b); // 여전히 오류: 여러 개의 `print` 발견됨\n"

#: src/expressions/call-expr.md:111
msgid "// necessary because of in-scope items defining `print`\n"
msgstr "// `print`를 정의하는 스코프 내 아이템 때문에 필요함\n"

#: src/expressions/call-expr.md:116
msgid ""
"Refer to [RFC 132](https://github.com/rust-lang/rfcs/blob/master/text/0132-"
"ufcs.md) for further details and motivations."
msgstr "자세한 내용과 동기는 [RFC 132](https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md)를 참조하십시오."

#: src/expressions/method-call-expr.md:3
msgid "Method-call expressions"
msgstr "메서드 호출 표현식"

#: src/expressions/method-call-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MethodCallExpression_ :  \n"
"   [_Expression_](../expressions.md) `.` [_PathExprSegment_](../"
"paths.md#paths-in-expressions) `(`[_CallParams_](call-expr.md)<sup>?</sup> "
"`)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_메서드호출표현식_ :  \n"
"   [_표현식_](../expressions.md) `.` [_경로표현식세그먼트_](../"
"paths.md#paths-in-expressions) `(`[_호출매개변수_](call-expr.md)<sup>?</sup> "
"`)`"

#: src/expressions/method-call-expr.md:13
msgid ""
"A _method call_ consists of an expression (the _receiver_) followed by a "
"single dot, an expression path segment, and a parenthesized expression-list."
msgstr "_메서드 호출_은 표현식(_수신자_), 그 뒤에 오는 단일 점, 표현식 경로 세그먼트, 괄호로 묶인 표현식 목록으로 구성됩니다."

#: src/expressions/method-call-expr.md:17
msgid ""
"Method calls are resolved to associated [methods](../items/associated-"
"items.md#methods) on specific traits, either statically dispatching to a "
"method if the exact `self`\\-type of the left-hand-side is known, or "
"dynamically dispatching if the left-hand-side expression is an indirect "
"[trait object](../types/trait-object.md)."
msgstr "메서드 호출은 특정 트레잇의 연관 [메서드](../items/associated-items.md#methods)로 확인되며, 왼쪽의 정확한 `self` 타입이 알려진 경우 메서드에 정적으로 디스패치하거나, 왼쪽 표현식이 간접 [트레잇 객체](../types/trait-object.md)인 경우 동적으로 디스패치합니다."

#: src/expressions/method-call-expr.md:20
msgid "\"3.14\""
msgstr "\"3.14\""

#: src/expressions/method-call-expr.md:27
msgid ""
"When looking up a method call, the receiver may be automatically "
"dereferenced or borrowed in order to call a method. This requires a more "
"complex lookup process than for other functions, since there may be a number "
"of possible methods to call. The following procedure is used:"
msgstr "메서드 호출을 찾을 때, 메서드를 호출하기 위해 수신자가 자동으로 역참조되거나 차용될 수 있습니다. 호출할 수 있는 메서드가 여러 개일 수 있으므로 다른 함수보다 더 복잡한 조회 과정이 필요합니다. 다음 절차가 사용됩니다:"

#: src/expressions/method-call-expr.md:33
msgid ""
"The first step is to build a list of candidate receiver types. Obtain these "
"by repeatedly [dereferencing](operator-expr.md#the-dereference-operator) the "
"receiver expression's type, adding each type encountered to the list, then "
"finally attempting an [unsized coercion](../type-coercions.md#unsized-"
"coercions) at the end, and adding the result type if that is successful."
msgstr "첫 번째 단계는 후보 수신자 타입 목록을 작성하는 것입니다. 수신자 표현식의 타입을 반복적으로 [역참조](operator-expr.md#the-dereference-operator)하여 얻은 각 타입을 목록에 추가한 다음, 마지막으로 [크기 없는 강제 변환](../type-coercions.md#unsized-coercions)을 시도하고 성공하면 결과 타입을 추가합니다."

#: src/expressions/method-call-expr.md:38
msgid ""
"Then, for each candidate `T`, add `&T` and `&mut T` to the list immediately "
"after `T`."
msgstr "그런 다음 각 후보 `T`에 대해, `T` 바로 뒤에 목록에 `&T`와 `&mut T`를 추가합니다."

#: src/expressions/method-call-expr.md:40
msgid ""
"For instance, if the receiver has type `Box<[i32;2]>`, then the candidate "
"types will be `Box<[i32;2]>`, `&Box<[i32;2]>`, `&mut Box<[i32;2]>`, `[i32; "
"2]` (by dereferencing), `&[i32; 2]`, `&mut [i32; 2]`, `[i32]` (by unsized "
"coercion), `&[i32]`, and finally `&mut [i32]`."
msgstr "예를 들어, 수신자의 타입이 `Box<[i32;2]>`인 경우 후보 타입은 `Box<[i32;2]>`, `&Box<[i32;2]>`, `&mut Box<[i32;2]>`, `[i32; 2]` (역참조에 의해), `&[i32; 2]`, `&mut [i32; 2]`, `[i32]` (크기 없는 강제 변환에 의해), `&[i32]`, 마지막으로 `&mut [i32]`가 됩니다."

#: src/expressions/method-call-expr.md:44
msgid ""
"Then, for each candidate type `T`, search for a [visible](../visibility-and-"
"privacy.md) method with a receiver of that type in the following places:"
msgstr "그런 다음 각 후보 타입 `T`에 대해 다음 위치에서 해당 타입의 수신자가 있는 [보이는](../visibility-and-privacy.md) 메서드를 검색합니다:"

#: src/expressions/method-call-expr.md:46
msgid "`T`'s inherent methods (methods implemented directly on `T`)."
msgstr "`T`의 고유 메서드 (`T`에 직접 구현된 메서드)."

#: src/expressions/method-call-expr.md:47
msgid ""
"Any of the methods provided by a [visible](../visibility-and-privacy.md) "
"trait implemented by `T`. If `T` is a type parameter, methods provided by "
"trait bounds on `T` are looked up first. Then all remaining methods in scope "
"are looked up."
msgstr "`T`에 의해 구현된 [보이는](../visibility-and-privacy.md) 트레잇이 제공하는 메서드 중 하나. `T`가 타입 매개변수인 경우 `T`의 트레잇 바운드가 제공하는 메서드가 먼저 조회됩니다. 그런 다음 스코프에 있는 나머지 모든 메서드가 조회됩니다."

#: src/expressions/method-call-expr.md:51
msgid ""
"Note: the lookup is done for each type in order, which can occasionally lead "
"to surprising results. The below code will print \"In trait impl!\", because "
"`&self` methods are looked up first, the trait method is found before the "
"struct's `&mut self` method is found."
msgstr "참고: 조회는 각 타입에 대해 순서대로 수행되므로 때때로 놀라운 결과가 발생할 수 있습니다. 아래 코드는 \"In trait impl!\"을 출력하는데, 이는 `&self` 메서드가 먼저 조회되어 구조체의 `&mut self` 메서드가 발견되기 전에 트레잇 메서드가 발견되기 때문입니다."

#: src/expressions/method-call-expr.md:63
msgid "\"In struct impl!\""
msgstr "\"In struct impl!\""

#: src/expressions/method-call-expr.md:69
msgid "\"In trait impl!\""
msgstr "\"In trait impl!\""

#: src/expressions/method-call-expr.md:81
msgid ""
"If this results in multiple possible candidates, then it is an error, and "
"the receiver must be [converted](call-expr.md#disambiguating-function-calls) "
"to an appropriate receiver type to make the method call."
msgstr "만약 여러 가능한 후보가 생성되면 오류이며, 메서드 호출을 하려면 수신자를 적절한 수신자 타입으로 [변환](call-expr.md#disambiguating-function-calls)해야 합니다."

#: src/expressions/method-call-expr.md:85
msgid ""
"This process does not take into account the mutability or lifetime of the "
"receiver, or whether a method is `unsafe`. Once a method is looked up, if it "
"can't be called for one (or more) of those reasons, the result is a compiler "
"error."
msgstr "이 과정은 수신자의 가변성이나 라이프타임, 또는 메서드가 `unsafe`인지 여부를 고려하지 않습니다. 메서드가 조회된 후, 이러한 이유 중 하나(또는 그 이상)로 호출할 수 없는 경우 결과는 컴파일러 오류입니다."

#: src/expressions/method-call-expr.md:90
msgid ""
"If a step is reached where there is more than one possible method, such as "
"where generic methods or traits are considered the same, then it is a "
"compiler error. These cases require a [disambiguating function call syntax]"
"(call-expr.md#disambiguating-function-calls) for method and function "
"invocation."
msgstr "제네릭 메서드나 트레잇이 동일하게 간주되는 등 가능한 메서드가 하나 이상 있는 단계에 도달하면 컴파일러 오류입니다. 이러한 경우 메서드 및 함수 호출을 위해 [모호하지 않은 함수 호출 구문](call-expr.md#disambiguating-function-calls)이 필요합니다."

#: src/expressions/method-call-expr.md:93
msgid ""
"**Edition differences**: Before the 2021 edition, during the search for "
"visible methods, if the candidate receiver type is an [array type](../types/"
"array.md), methods provided by the standard library [`IntoIterator`](../../"
"core/iter/traits/collect/trait.IntoIterator.html) trait are ignored."
msgstr "**에디션 차이**: 2021년 에디션 이전에는 보이는 메서드를 검색하는 동안 후보 수신자 타입이 [배열 타입](../types/array.md)인 경우 표준 라이브러리 [`IntoIterator`](../../core/iter/traits/collect/trait.IntoIterator.html) 트레잇에서 제공하는 메서드는 무시됩니다."

#: src/expressions/method-call-expr.md:95
msgid ""
"The edition used for this purpose is determined by the token representing "
"the method name."
msgstr "이 목적에 사용되는 에디션은 메서드 이름을 나타내는 토큰에 의해 결정됩니다."

#: src/expressions/method-call-expr.md:97
msgid "This special case may be removed in the future."
msgstr "이 특별한 경우는 나중에 제거될 수 있습니다."

#: src/expressions/method-call-expr.md:101
msgid ""
"_**Warning:**_ For [trait objects](../types/trait-object.md), if there is an "
"inherent method of the same name as a trait method, it will give a compiler "
"error when trying to call the method in a method call expression. Instead, "
"you can call the method using [disambiguating function call syntax](call-"
"expr.md#disambiguating-function-calls), in which case it calls the trait "
"method, not the inherent method. There is no way to call the inherent "
"method. Just don't define inherent methods on trait objects with the same "
"name as a trait method and you'll be fine."
msgstr "_**경고:**_ [트레잇 객체](../types/trait-object.md)의 경우, 트레잇 메서드와 동일한 이름의 고유 메서드가 있으면 메서드 호출 표현식에서 해당 메서드를 호출하려고 할 때 컴파일러 오류가 발생합니다. 대신 [모호하지 않은 함수 호출 구문](call-expr.md#disambiguating-function-calls)을 사용하여 메서드를 호출할 수 있는데, 이 경우 고유 메서드가 아니라 트레잇 메서드를 호출합니다. 고유 메서드를 호출할 방법은 없습니다. 트레잇 객체에 트레잇 메서드와 동일한 이름의 고유 메서드를 정의하지 않으면 괜찮습니다."

#: src/expressions/field-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_FieldExpression_ :  \n"
"   [_Expression_](../expressions.md) `.` [IDENTIFIER](../identifiers.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_필드표현식_ :  \n"
"   [_표현식_](../expressions.md) `.` [식별자](../identifiers.md)"

#: src/expressions/field-expr.md:13
msgid ""
"A _field expression_ is a [place expression](../expressions.md#place-"
"expressions-and-value-expressions) that evaluates to the location of a field "
"of a [struct](../items/structs.md) or [union](../items/unions.md)."
msgstr "_필드 표현식_은 [구조체](../items/structs.md) 또는 [공용체](../items/unions.md) 필드의 위치로 평가되는 [장소 표현식](../expressions.md#place-expressions-and-value-expressions)입니다."

#: src/expressions/field-expr.md:17
msgid ""
"When the operand is [mutable](../expressions.md#mutability), the field "
"expression is also mutable."
msgstr "피연산자가 [가변](../expressions.md#mutability)이면 필드 표현식도 가변입니다."

#: src/expressions/field-expr.md:21
msgid ""
"The syntax for a field expression is an expression, called the _container "
"operand_, then a `.`, and finally an [identifier](../identifiers.md)."
msgstr "필드 표현식의 구문은 _컨테이너 피연산자_라고 하는 표현식, 그 다음 `.`, 그리고 마지막으로 [식별자](../identifiers.md)입니다."

#: src/expressions/field-expr.md:25
msgid ""
"Field expressions cannot be followed by a parenthetical comma-separated list "
"of expressions, as that is instead parsed as a [method call expression]"
"(method-call-expr.md). That is, they cannot be the function operand of a "
"[call expression](call-expr.md)."
msgstr "필드 표현식 뒤에는 괄호로 묶인 쉼표로 구분된 표현식 목록이 올 수 없습니다. 이는 대신 [메서드 호출 표현식](method-call-expr.md)으로 파싱되기 때문입니다. 즉, [호출 표현식](call-expr.md)의 함수 피연산자가 될 수 없습니다."

#: src/expressions/field-expr.md:28
msgid ""
"**Note**: Wrap the field expression in a [parenthesized expression](grouped-"
"expr.md) to use it in a call expression."
msgstr "**참고**: 필드 표현식을 호출 표현식에서 사용하려면 [괄호로 묶인 표현식](grouped-expr.md)으로 감싸십시오."

#: src/expressions/field-expr.md:34
msgid "// Invalid: Parsed as calling the method \"callable\"\n"
msgstr "// 잘못됨: 메서드 \"callable\" 호출로 파싱됨\n"

#: src/expressions/field-expr.md:35
msgid "// holds_callable.callable();\n"
msgstr "// holds_callable.callable();\n"

#: src/expressions/field-expr.md:37
msgid "// Valid\n"
msgstr "// 유효함\n"

#: src/expressions/field-expr.md:41 src/expressions/range-expr.md:47
#: src/patterns.md:200 src/patterns.md:444 src/patterns.md:497
#: src/patterns.md:651 src/types/array.md:20 src/types/slice.md:25
#: src/type-coercions.md:311 src/lifetime-elision.md:48 src/glossary.md:263
msgid "Examples:"
msgstr "예:"

#: src/expressions/field-expr.md:48
msgid "// Call expression containing a field expression\n"
msgstr "// 필드 표현식을 포함하는 호출 표현식\n"

#: src/expressions/field-expr.md:53
msgid "Automatic dereferencing"
msgstr "자동 역참조"

#: src/expressions/field-expr.md:55
msgid ""
"If the type of the container operand implements [`Deref`](../special-types-"
"and-traits.md#deref-and-derefmut) or [`DerefMut`](../special-types-and-"
"traits.md#deref-and-derefmut) depending on whether the operand is [mutable]"
"(../expressions.md#mutability), it is _automatically dereferenced_ as many "
"times as necessary to make the field access possible. This process is also "
"called _autoderef_ for short."
msgstr "컨테이너 피연산자의 타입이 피연산자의 [가변성](../expressions.md#mutability)에 따라 [`Deref`](../special-types-and-traits.md#deref-and-derefmut) 또는 [`DerefMut`](../special-types-and-traits.md#deref-and-derefmut)를 구현하는 경우, 필드 접근이 가능하도록 필요한 횟수만큼 _자동으로 역참조_됩니다. 이 과정을 줄여서 _자동 역참조(autoderef)_라고도 합니다."

#: src/expressions/field-expr.md:60
msgid "Borrowing"
msgstr "차용"

#: src/expressions/field-expr.md:62
msgid ""
"The fields of a struct or a reference to a struct are treated as separate "
"entities when borrowing. If the struct does not implement [`Drop`](../"
"special-types-and-traits.md#drop) and is stored in a local variable, this "
"also applies to moving out of each of its fields. This also does not apply "
"if automatic dereferencing is done though user-defined types other than "
"[`Box`](../special-types-and-traits.md#boxt)."
msgstr "구조체의 필드 또는 구조체에 대한 참조는 차용 시 별개의 엔티티로 취급됩니다. 구조체가 [`Drop`](../special-types-and-traits.md#drop)을 구현하지 않고 지역 변수에 저장되어 있는 경우, 이는 각 필드에서 이동하는 것에도 적용됩니다. 이는 자동 역참조가 [`Box`](../special-types-and-traits.md#boxt) 이외의 사용자 정의 타입을 통해 수행되는 경우에는 적용되지 않습니다."

#: src/expressions/field-expr.md:70
msgid "\"f1\""
msgstr "\"f1\""

#: src/expressions/field-expr.md:71
msgid "\"f2\""
msgstr "\"f2\""

#: src/expressions/field-expr.md:72
msgid "\"f3\""
msgstr "\"f3\""

#: src/expressions/field-expr.md:74
msgid "// x.f1 borrowed mutably\n"
msgstr "// x.f1 가변적으로 차용됨\n"

#: src/expressions/field-expr.md:75
msgid "// x.f2 borrowed immutably\n"
msgstr "// x.f2 불변적으로 차용됨\n"

#: src/expressions/field-expr.md:76
msgid "// Can borrow again\n"
msgstr "// 다시 차용 가능\n"

#: src/expressions/field-expr.md:77
msgid "// Move out of x.f3\n"
msgstr "// x.f3에서 이동\n"

#: src/expressions/closure-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ClosureExpression_ :  \n"
"   `async`[^cl-async-edition]<sup>?</sup>  \n"
"   `move`<sup>?</sup>  \n"
"   ( `||` | `|` _ClosureParameters_<sup>?</sup> `|` )  \n"
"   ([_Expression_](../expressions.md) | `->` [_TypeNoBounds_](../"
"types.md#type-expressions) [_BlockExpression_](block-expr.md))"
msgstr ""
"**<sup>구문</sup>**  \n"
"_클로저표현식_ :  \n"
"   `async`[^cl-async-edition]<sup>?</sup>  \n"
"   `move`<sup>?</sup>  \n"
"   ( `||` | `|` _클로저매개변수_<sup>?</sup> `|` )  \n"
"   ([_표현식_](../expressions.md) | `->` [_경계없는타입_](../"
"types.md#type-expressions) [_블록표현식_](block-expr.md))"

#: src/expressions/closure-expr.md:14
msgid ""
"_ClosureParameters_ :  \n"
"   _ClosureParam_ (`,` _ClosureParam_)<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_클로저매개변수_ :  \n"
"   _클로저인자_ (`,` _클로저인자_)<sup>\\*</sup> `,`<sup>?</sup>"

#: src/expressions/closure-expr.md:17
msgid ""
"_ClosureParam_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> [_PatternNoTopAlt_](../"
"patterns.md) ( `:` [_Type_](../types.md#type-expressions) )<sup>?</sup>"
msgstr ""
"_클로저인자_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> [_최상위대안없는패턴_](../"
"patterns.md) ( `:` [_타입_](../types.md#type-expressions) )<sup>?</sup>"

#: src/expressions/closure-expr.md:24
msgid ""
"A _closure expression_, also known as a lambda expression or a lambda, "
"defines a [closure type](../types/closure.md) and evaluates to a value of "
"that type. The syntax for a closure expression is an optional `async` "
"keyword, an optional `move` keyword, then a pipe-symbol-delimited (`|`) "
"comma-separated list of [patterns](../patterns.md), called the _closure "
"parameters_ each optionally followed by a `:` and a type, then an optional `-"
">` and type, called the _return type_, and then an expression, called the "
"_closure body operand_."
msgstr "_클로저 표현식_(람다 표현식 또는 람다로도 알려짐)은 [클로저 타입](../types/closure.md)을 정의하고 해당 타입의 값으로 평가됩니다. 클로저 표현식의 구문은 선택적인 `async` 키워드, 선택적인 `move` 키워드, 그 다음 파이프 기호(`|`)로 구분된 쉼표로 구분된 [패턴](../patterns.md) 목록(_클로저 매개변수_라고 함, 각 패턴 뒤에는 선택적으로 `:`와 타입이 올 수 있음), 그 다음 선택적인 `->`와 타입(_반환 타입_이라고 함), 그리고 마지막으로 표현식(_클로저 본문 피연산자_라고 함)입니다."

#: src/expressions/closure-expr.md:29
msgid ""
"The optional type after each pattern is a type annotation for the pattern."
msgstr "각 패턴 뒤의 선택적 타입은 패턴에 대한 타입 주석입니다."

#: src/expressions/closure-expr.md:33
msgid ""
"If there is a return type, the closure body must be a [block](block-expr.md)."
msgstr "반환 타입이 있는 경우 클로저 본문은 [블록](block-expr.md)이어야 합니다."

#: src/expressions/closure-expr.md:37
msgid ""
"A closure expression denotes a function that maps a list of parameters onto "
"the expression that follows the parameters. Just like a [`let` binding](../"
"statements.md#let-statements), the closure parameters are irrefutable "
"[patterns](../patterns.md), whose type annotation is optional and will be "
"inferred from context if not given."
msgstr "클로저 표현식은 매개변수 목록을 매개변수 뒤에 오는 표현식에 매핑하는 함수를 나타냅니다. [`let` 바인딩](../statements.md#let-statements)과 마찬가지로, 클로저 매개변수는 반박할 수 없는 [패턴](../patterns.md)이며, 타입 주석은 선택 사항이고 주어지지 않은 경우 문맥에서 유추됩니다."

#: src/expressions/closure-expr.md:42
msgid "Each closure expression has a unique, anonymous type."
msgstr "각 클로저 표현식은 고유하고 익명인 타입을 가집니다."

#: src/expressions/closure-expr.md:46
msgid ""
"Significantly, closure expressions _capture their environment_, which "
"regular [function definitions](../items/functions.md) do not."
msgstr "중요한 점은 클로저 표현식이 _환경을 캡처_한다는 것인데, 이는 일반적인 [함수 정의](../items/functions.md)와 다른 점입니다."

#: src/expressions/closure-expr.md:50
msgid ""
"Without the `move` keyword, the closure expression [infers how it captures "
"each variable from its environment](../types/closure.md#capture-modes), "
"preferring to capture by shared reference, effectively borrowing all outer "
"variables mentioned inside the closure's body."
msgstr "`move` 키워드가 없으면 클로저 표현식은 [환경에서 각 변수를 캡처하는 방법을 추론](../types/closure.md#capture-modes)하며, 공유 참조로 캡처하는 것을 선호하여 클로저 본문 내에서 언급된 모든 외부 변수를 효과적으로 차용합니다."

#: src/expressions/closure-expr.md:54
msgid ""
"If needed the compiler will infer that instead mutable references should be "
"taken, or that the values should be moved or copied (depending on their "
"type) from the environment."
msgstr "필요한 경우 컴파일러는 대신 가변 참조를 취하거나, 값(타입에 따라)을 환경에서 이동하거나 복사해야 한다고 추론합니다."

#: src/expressions/closure-expr.md:58
msgid ""
"A closure can be forced to capture its environment by copying or moving "
"values by prefixing it with the `move` keyword. This is often used to ensure "
"that the closure's lifetime is `'static`."
msgstr "클로저 앞에 `move` 키워드를 붙여 값을 복사하거나 이동함으로써 환경을 강제로 캡처하게 할 수 있습니다. 이는 종종 클로저의 라이프타임이 `'static`임을 보장하기 위해 사용됩니다."

#: src/expressions/closure-expr.md:63
msgid "Closure trait implementations"
msgstr "클로저 트레잇 구현"

#: src/expressions/closure-expr.md:65
msgid ""
"Which traits the closure type implement depends on how variables are "
"captured, the types of the captured variables, and the presence of `async`. "
"See the [call traits and coercions](../types/closure.md#call-traits-and-"
"coercions) chapter for how and when a closure implements `Fn`, `FnMut`, and "
"`FnOnce`. The closure type implements [`Send`](../special-types-and-"
"traits.md#send) and [`Sync`](../special-types-and-traits.md#sync) if the "
"type of every captured variable also implements the trait."
msgstr "클로저 타입이 구현하는 트레잇은 변수가 캡처되는 방식, 캡처된 변수의 타입, 그리고 `async`의 존재 여부에 따라 달라집니다. 클로저가 `Fn`, `FnMut`, `FnOnce`를 어떻게 그리고 언제 구현하는지에 대해서는 [호출 트레잇 및 강제 변환](../types/closure.md#call-traits-and-coercions) 장을 참조하십시오. 캡처된 모든 변수의 타입도 해당 트레잇을 구현하는 경우 클로저 타입은 [`Send`](../special-types-and-traits.md#send) 및 [`Sync`](../special-types-and-traits.md#sync)를 구현합니다."

#: src/expressions/closure-expr.md:71
msgid "Async closures"
msgstr "비동기 클로저"

#: src/expressions/closure-expr.md:75
msgid ""
"Closures marked with the `async` keyword indicate that they are asynchronous "
"in an analogous way to an [async function](../items/functions.md#r-"
"items.fn.async)."
msgstr "`async` 키워드로 표시된 클로저는 [비동기 함수](../items/functions.md#r-items.fn.async)와 유사한 방식으로 비동기임을 나타냅니다."

#: src/expressions/closure-expr.md:79
msgid ""
"Calling the async closure does not perform any work, but instead evaluates "
"to a value that implements [`Future`](../../core/future/future/"
"trait.Future.html) that corresponds to the computation of the body of the "
"closure."
msgstr "비동기 클로저를 호출하면 아무 작업도 수행되지 않는 대신 클로저 본문의 계산에 해당하는 [`Future`](../../core/future/future/trait.Future.html)를 구현하는 값으로 평가됩니다."

#: src/expressions/closure-expr.md:90
msgid "\"done with {i}.\""
msgstr "\"{i} 완료.\""

#: src/expressions/closure-expr.md:97
msgid ""
"**Edition differences**: Async closures are only available beginning with "
"Rust 2018."
msgstr "**에디션 차이**: 비동기 클로저는 Rust 2018부터 사용할 수 있습니다."

#: src/expressions/closure-expr.md:101
msgid ""
"In this example, we define a function `ten_times` that takes a higher-order "
"function argument, and we then call it with a closure expression as an "
"argument, followed by a closure expression that moves values from its "
"environment."
msgstr "이 예제에서는 고차 함수 인수를 받는 함수 `ten_times`를 정의한 다음, 이를 클로저 표현식을 인수로 호출하고, 그 뒤에 환경에서 값을 이동하는 클로저 표현식을 사용하여 호출합니다."

#: src/expressions/closure-expr.md:110 src/expressions/closure-expr.md:112
msgid "\"hello, {}\""
msgstr "\"안녕하세요, {}\""

#: src/expressions/closure-expr.md:110
msgid "// With type annotations\n"
msgstr "// 타입 주석 포함\n"

#: src/expressions/closure-expr.md:114
msgid "\"konnichiwa\""
msgstr "\"곤니찌와\""

#: src/expressions/closure-expr.md:115
msgid "\"{}, {}\""
msgstr "\"{}, {}\""

#: src/expressions/closure-expr.md:118
msgid "Attributes on closure parameters"
msgstr "클로저 매개변수의 속성"

#: src/expressions/closure-expr.md:122
msgid ""
"Attributes on closure parameters follow the same rules and restrictions as "
"[regular function parameters](../items/functions.md#attributes-on-function-"
"parameters)."
msgstr "클로저 매개변수의 속성은 [일반 함수 매개변수](../items/functions.md#attributes-on-function-parameters)와 동일한 규칙 및 제한 사항을 따릅니다."

#: src/expressions/loop-expr.md:3
msgid "Loops and other breakable expressions"
msgstr "루프 및 기타 중단 가능한 표현식"

#: src/expressions/loop-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LoopExpression_ :  \n"
"   [_LoopLabel_](#loop-labels)<sup>?</sup> (  \n"
"         [_InfiniteLoopExpression_](#infinite-loops)  \n"
"      | [_PredicateLoopExpression_](#predicate-loops)  \n"
"      | [_PredicatePatternLoopExpression_](#predicate-pattern-loops)  \n"
"      | [_IteratorLoopExpression_](#iterator-loops)  \n"
"      | [_LabelBlockExpression_](#labelled-block-expressions)  \n"
"   )"
msgstr ""
"**<sup>구문</sup>**  \n"
"_루프표현식_ :  \n"
"   [_루프레이블_](#loop-labels)<sup>?</sup> (  \n"
"         [_무한루프표현식_](#infinite-loops)  \n"
"      | [_조건루프표현식_](#predicate-loops)  \n"
"      | [_조건패턴루프표현식_](#predicate-pattern-loops)  \n"
"      | [_반복자루프표현식_](#iterator-loops)  \n"
"      | [_레이블블록표현식_](#labelled-block-expressions)  \n"
"   )"

#: src/expressions/loop-expr.md:26
msgid "Rust supports five loop expressions:"
msgstr "Rust는 다섯 가지 루프 표현식을 지원합니다:"

#: src/expressions/loop-expr.md:28
msgid "A [`loop` expression](#infinite-loops) denotes an infinite loop."
msgstr "[`loop` 표현식](#infinite-loops)은 무한 루프를 나타냅니다."

#: src/expressions/loop-expr.md:29
msgid ""
"A [`while` expression](#predicate-loops) loops until a predicate is false."
msgstr "[`while` 표현식](#predicate-loops)은 조건자가 거짓이 될 때까지 반복합니다."

#: src/expressions/loop-expr.md:30
msgid "A [`while let` expression](#predicate-pattern-loops) tests a pattern."
msgstr "[`while let` 표현식](#predicate-pattern-loops)은 패턴을 검사합니다."

#: src/expressions/loop-expr.md:31
msgid ""
"A [`for` expression](#iterator-loops) extracts values from an iterator, "
"looping until the iterator is empty."
msgstr "[`for` 표현식](#iterator-loops)은 반복자에서 값을 추출하여 반복자가 빌 때까지 반복합니다."

#: src/expressions/loop-expr.md:32
msgid ""
"A [labelled block expression](#labelled-block-expressions) runs a loop "
"exactly once, but allows exiting the loop early with `break`."
msgstr "[레이블 블록 표현식](#labelled-block-expressions)은 루프를 정확히 한 번 실행하지만 `break`로 루프를 일찍 종료할 수 있습니다."

#: src/expressions/loop-expr.md:36
msgid ""
"All five types of loop support [`break` expressions](#break-expressions), "
"and [labels](#loop-labels)."
msgstr "다섯 가지 유형의 루프 모두 [`break` 표현식](#break-expressions)과 [레이블](#loop-labels)을 지원합니다."

#: src/expressions/loop-expr.md:40
msgid ""
"All except labelled block expressions support [`continue` expressions]"
"(#continue-expressions)."
msgstr "레이블 블록 표현식을 제외한 모든 루프는 [`continue` 표현식](#continue-expressions)을 지원합니다."

#: src/expressions/loop-expr.md:44
msgid ""
"Only `loop` and labelled block expressions support [evaluation to non-"
"trivial values](#break-and-loop-values)."
msgstr "`loop`와 레이블 블록 표현식만이 [의미 있는 값으로의 평가](#break-and-loop-values)를 지원합니다."

#: src/expressions/loop-expr.md:48
msgid "Infinite loops"
msgstr "무한 루프"

#: src/expressions/loop-expr.md:52
msgid ""
"**<sup>Syntax</sup>**  \n"
"_InfiniteLoopExpression_ :  \n"
"   `loop` [_BlockExpression_](block-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_무한루프표현식_ :  \n"
"   `loop` [_블록표현식_](block-expr.md)"

#: src/expressions/loop-expr.md:58
msgid ""
"A `loop` expression repeats execution of its body continuously: `loop "
"{ println!(\"I live.\"); }`."
msgstr "`loop` 표현식은 본문 실행을 지속적으로 반복합니다: `loop { println!(\"I live.\"); }`."

#: src/expressions/loop-expr.md:63
msgid ""
"A `loop` expression without an associated `break` expression is diverging "
"and has type [`!`](../types/never.md)."
msgstr "연관된 `break` 표현식이 없는 `loop` 표현식은 발산하며 [`!`](../types/never.md) 타입을 가집니다."

#: src/expressions/loop-expr.md:67
msgid ""
"A `loop` expression containing associated [`break` expression(s)](#break-"
"expressions) may terminate, and must have type compatible with the value of "
"the `break` expression(s)."
msgstr "연관된 [`break` 표현식(들)](#break-expressions)을 포함하는 `loop` 표현식은 종료될 수 있으며, `break` 표현식(들)의 값과 호환되는 타입을 가져야 합니다."

#: src/expressions/loop-expr.md:71
msgid "Predicate loops"
msgstr "조건자 루프"

#: src/expressions/loop-expr.md:75
msgid ""
"**<sup>Syntax</sup>**  \n"
"_PredicateLoopExpression_ :  \n"
"   `while` [_Expression_](../expressions.md)<sub>_except struct expression_</"
"sub> [_BlockExpression_](block-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_조건루프표현식_ :  \n"
"   `while` [_표현식_](../expressions.md)<sub>_구조체 표현식 제외_</"
"sub> [_블록표현식_](block-expr.md)"

#: src/expressions/loop-expr.md:81
msgid ""
"A `while` loop begins by evaluating the [boolean](../types/boolean.md) loop "
"conditional operand."
msgstr "`while` 루프는 [불리언](../types/boolean.md) 루프 조건 피연산자를 평가하는 것으로 시작합니다."

#: src/expressions/loop-expr.md:85
msgid ""
"If the loop conditional operand evaluates to `true`, the loop body block "
"executes, then control returns to the loop conditional operand. If the loop "
"conditional expression evaluates to `false`, the `while` expression "
"completes."
msgstr "루프 조건 피연산자가 `true`로 평가되면 루프 본문 블록이 실행된 다음 제어가 루프 조건 피연산자로 돌아갑니다. 루프 조건 표현식이 `false`로 평가되면 `while` 표현식이 완료됩니다."

#: src/expressions/loop-expr.md:88
msgid "An example:"
msgstr "예:"

#: src/expressions/loop-expr.md:101
msgid "Predicate pattern loops"
msgstr "조건 패턴 루프"

#: src/expressions/loop-expr.md:105
msgid ""
"**<sup>Syntax</sup>**  \n"
"[_PredicatePatternLoopExpression_](#predicate-pattern-loops) :  \n"
"   `while` `let` [_Pattern_](../patterns.md) `=` [_Scrutinee_](match-"
"expr.md)<sub>_except lazy boolean operator expression_</sub> "
"[_BlockExpression_](block-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"[_조건패턴루프표현식_](#predicate-pattern-loops) :  \n"
"   `while` `let` [_패턴_](../patterns.md) `=` [_검사대상_](match-"
"expr.md)<sub>_지연 불리언 연산자 표현식 제외_</sub> "
"[_블록표현식_](block-expr.md)"

#: src/expressions/loop-expr.md:112
msgid ""
"A `while let` loop is semantically similar to a `while` loop but in place of "
"a condition expression it expects the keyword `let` followed by a pattern, "
"an `=`, a [scrutinee](../glossary.md#scrutinee) expression and a block "
"expression."
msgstr "`while let` 루프는 의미상 `while` 루프와 유사하지만, 조건 표현식 대신 키워드 `let`, 그 뒤에 패턴, `=`, [검사 대상(scrutinee)](../glossary.md#scrutinee) 표현식 및 블록 표현식이 옵니다."

#: src/expressions/loop-expr.md:116
msgid ""
"If the value of the scrutinee matches the pattern, the loop body block "
"executes then control returns to the pattern matching statement. Otherwise, "
"the while expression completes."
msgstr "검사 대상의 값이 패턴과 일치하면 루프 본문 블록이 실행된 다음 제어가 패턴 매칭 구문으로 돌아갑니다. 그렇지 않으면 while 표현식이 완료됩니다."

#: src/expressions/loop-expr.md:123
msgid "\"y = {}\""
msgstr "\"y = {}\""

#: src/expressions/loop-expr.md:127 src/expressions/if-expr.md:112
msgid "\"Irrefutable patterns are always true\""
msgstr "\"반박할 수 없는 패턴은 항상 참입니다\""

#: src/expressions/loop-expr.md:134
msgid ""
"A `while let` loop is equivalent to a `loop` expression containing a "
"[`match` expression](match-expr.md) as follows."
msgstr "`while let` 루프는 다음과 같이 [`match` 표현식](match-expr.md)을 포함하는 `loop` 표현식과 동일합니다."

#: src/expressions/loop-expr.md:139 src/expressions/loop-expr.md:149
#: src/expressions/loop-expr.md:219 src/expressions/loop-expr.md:236
msgid "/* loop body */"
msgstr "/* 루프 본문 */"

#: src/expressions/loop-expr.md:157 src/expressions/if-expr.md:159
msgid ""
"Multiple patterns may be specified with the `|` operator. This has the same "
"semantics as with `|` in `match` expressions:"
msgstr "여러 패턴을 `|` 연산자로 지정할 수 있습니다. 이는 `match` 표현식의 `|`와 동일한 의미를 갖습니다:"

#: src/expressions/loop-expr.md:163
msgid "// Prints 2, 2, then 1\n"
msgstr "// 2, 2, 그 다음 1을 출력합니다\n"

#: src/expressions/loop-expr.md:170
msgid ""
"As is the case in [`if let` expressions](if-expr.md#if-let-expressions), the "
"scrutinee cannot be a [lazy boolean operator expression](operator-"
"expr.md#lazy-boolean-operators)."
msgstr "[`if let` 표현식](if-expr.md#if-let-expressions)의 경우와 마찬가지로, 검사 대상은 [지연 불리언 연산자 표현식](operator-expr.md#lazy-boolean-operators)이 될 수 없습니다."

#: src/expressions/loop-expr.md:174
msgid "Iterator loops"
msgstr "반복자 루프"

#: src/expressions/loop-expr.md:178
msgid ""
"**<sup>Syntax</sup>**  \n"
"_IteratorLoopExpression_ :  \n"
"   `for` [_Pattern_](../patterns.md) `in` [_Expression_](../"
"expressions.md)<sub>_except struct expression_</sub> [_BlockExpression_]"
"(block-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_반복자루프표현식_ :  \n"
"   `for` [_패턴_](../patterns.md) `in` [_표현식_](../"
"expressions.md)<sub>_구조체 표현식 제외_</sub> [_블록표현식_]"
"(block-expr.md)"

#: src/expressions/loop-expr.md:185
msgid ""
"A `for` expression is a syntactic construct for looping over elements "
"provided by an implementation of `std::iter::IntoIterator`."
msgstr "`for` 표현식은 `std::iter::IntoIterator` 구현에서 제공하는 요소를 반복하기 위한 구문 구조입니다."

#: src/expressions/loop-expr.md:189
msgid ""
"If the iterator yields a value, that value is matched against the "
"irrefutable pattern, the body of the loop is executed, and then control "
"returns to the head of the `for` loop. If the iterator is empty, the `for` "
"expression completes."
msgstr "반복자가 값을 산출하면 해당 값은 반박할 수 없는 패턴과 매칭되고 루프 본문이 실행된 다음 제어가 `for` 루프의 헤드로 돌아갑니다. 반복자가 비어 있으면 `for` 표현식이 완료됩니다."

#: src/expressions/loop-expr.md:192
msgid "An example of a `for` loop over the contents of an array:"
msgstr "배열의 내용에 대한 `for` 루프의 예:"

#: src/expressions/loop-expr.md:195
msgid "\"apples\""
msgstr "\"사과\""

#: src/expressions/loop-expr.md:195
msgid "\"cake\""
msgstr "\"케이크\""

#: src/expressions/loop-expr.md:195
msgid "\"coffee\""
msgstr "\"커피\""

#: src/expressions/loop-expr.md:198
msgid "\"I like {}.\""
msgstr "\"저는 {}를 좋아합니다.\""

#: src/expressions/loop-expr.md:202
msgid "An example of a for loop over a series of integers:"
msgstr "일련의 정수에 대한 for 루프의 예:"

#: src/expressions/loop-expr.md:214
msgid ""
"A `for` loop is equivalent to a `loop` expression containing a [`match` "
"expression](match-expr.md) as follows:"
msgstr "`for` 루프는 다음과 같이 [`match` 표현식](match-expr.md)을 포함하는 `loop` 표현식과 동일합니다:"

#: src/expressions/loop-expr.md:245
msgid ""
"`IntoIterator`, `Iterator`, and `Option` are always the standard library "
"items here, not whatever those names resolve to in the current scope."
msgstr "여기서 `IntoIterator`, `Iterator`, `Option`은 현재 스코프에서 해당 이름이 무엇으로 확인되든 상관없이 항상 표준 라이브러리 항목입니다."

#: src/expressions/loop-expr.md:247
msgid ""
"The variable names `next`, `iter`, and `val` are for exposition only, they "
"do not actually have names the user can type."
msgstr "변수 이름 `next`, `iter`, `val`은 설명용일 뿐이며, 실제로 사용자가 입력할 수 있는 이름은 아닙니다."

#: src/expressions/loop-expr.md:249
msgid ""
"**Note**: that the outer `match` is used to ensure that any [temporary "
"values](../expressions.md#temporaries) in `iter_expr` don't get dropped "
"before the loop is finished. `next` is declared before being assigned "
"because it results in types being inferred correctly more often."
msgstr "**참고**: 외부 `match`는 `iter_expr`의 [임시 값](../expressions.md#temporaries)이 루프가 끝나기 전에 드랍되지 않도록 하는 데 사용됩니다. `next`는 할당되기 전에 선언되는데, 이는 타입이 더 자주 올바르게 추론되도록 하기 때문입니다."

#: src/expressions/loop-expr.md:254
msgid "Loop labels"
msgstr "루프 레이블"

#: src/expressions/loop-expr.md:258
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LoopLabel_ :  \n"
"   [LIFETIME_OR_LABEL](../tokens.md#lifetimes-and-loop-labels) `:`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_루프레이블_ :  \n"
"   [라이프타임_또는_레이블](../tokens.md#lifetimes-and-loop-labels) `:`"

#: src/expressions/loop-expr.md:264
msgid ""
"A loop expression may optionally have a _label_. The label is written as a "
"lifetime preceding the loop expression, as in `'foo: loop { break 'foo; }`, "
"`'bar: while false {}`, `'humbug: for _ in 0..0 {}`."
msgstr "루프 표현식은 선택적으로 _레이블_을 가질 수 있습니다. 레이블은 `'foo: loop { break 'foo; }`, `'bar: while false {}`, `'humbug: for _ in 0..0 {}`과 같이 루프 표현식 앞에 라이프타임으로 작성됩니다."

#: src/expressions/loop-expr.md:268
msgid ""
"If a label is present, then labeled `break` and `continue` expressions "
"nested within this loop may exit out of this loop or return control to its "
"head. See [break expressions](#break-expressions) and [continue expressions]"
"(#continue-expressions)."
msgstr "레이블이 있는 경우, 이 루프 내에 중첩된 레이블이 있는 `break` 및 `continue` 표현식은 이 루프를 빠져나가거나 제어를 루프 헤드로 반환할 수 있습니다. [break 표현식](#break-expressions) 및 [continue 표현식](#continue-expressions)을 참조하십시오."

#: src/expressions/loop-expr.md:273
msgid ""
"Labels follow the hygiene and shadowing rules of local variables. For "
"example, this code will print \"outer loop\":"
msgstr "레이블은 지역 변수의 위생(hygiene) 및 섀도잉 규칙을 따릅니다. 예를 들어, 이 코드는 \"outer loop\"를 출력합니다:"

#: src/expressions/loop-expr.md:280
msgid "\"outer loop\""
msgstr "\"outer loop\""

#: src/expressions/loop-expr.md:285
msgid "`'_` is not a valid loop label."
msgstr "`'_`는 유효한 루프 레이블이 아닙니다."

#: src/expressions/loop-expr.md:289
msgid "`break` expressions"
msgstr "`break` 표현식"

#: src/expressions/loop-expr.md:293
msgid ""
"**<sup>Syntax</sup>**  \n"
"_BreakExpression_ :  \n"
"   `break` [LIFETIME_OR_LABEL](../tokens.md#lifetimes-and-loop-labels)<sup>?"
"</sup> [_Expression_](../expressions.md)<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_중단표현식_ :  \n"
"   `break` [라이프타임_또는_레이블](../tokens.md#lifetimes-and-loop-labels)<sup>?"
"</sup> [_표현식_](../expressions.md)<sup>?</sup>"

#: src/expressions/loop-expr.md:299
msgid ""
"When `break` is encountered, execution of the associated loop body is "
"immediately terminated, for example:"
msgstr "`break`를 만나면 연관된 루프 본문의 실행이 즉시 종료됩니다. 예를 들면:"

#: src/expressions/loop-expr.md:314
msgid ""
"A `break` expression is normally associated with the innermost `loop`, `for` "
"or `while` loop enclosing the `break` expression, but a [label](#loop-"
"labels) can be used to specify which enclosing loop is affected. Example:"
msgstr "`break` 표현식은 일반적으로 `break` 표현식을 감싸는 가장 안쪽의 `loop`, `for` 또는 `while` 루프와 연관되지만, [레이블](#loop-labels)을 사용하여 영향을 받는 둘러싸는 루프를 지정할 수 있습니다. 예:"

#: src/expressions/loop-expr.md:328
msgid ""
"A `break` expression is only permitted in the body of a loop, and has one of "
"the forms `break`, `break 'label` or ([see below](#break-and-loop-values)) "
"`break EXPR` or `break 'label EXPR`."
msgstr "`break` 표현식은 루프 본문에서만 허용되며, `break`, `break 'label` 또는 ([아래 참조](#break-and-loop-values)) `break EXPR` 또는 `break 'label EXPR` 중 하나의 형식을 가집니다."

#: src/expressions/loop-expr.md:334
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LabelBlockExpression_ :  \n"
"   [_BlockExpression_](block-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_레이블블록표현식_ :  \n"
"   [_블록표현식_](block-expr.md)"

#: src/expressions/loop-expr.md:340
msgid ""
"Labelled block expressions are exactly like block expressions, except that "
"they allow using `break` expressions within the block."
msgstr "레이블 블록 표현식은 블록 내에서 `break` 표현식을 사용할 수 있다는 점을 제외하고는 블록 표현식과 정확히 같습니다."

#: src/expressions/loop-expr.md:344
msgid ""
"Unlike loops, `break` expressions within a labelled block expression _must_ "
"have a label (i.e. the label is not optional)."
msgstr "루프와 달리, 레이블 블록 표현식 내의 `break` 표현식은 _반드시_ 레이블을 가져야 합니다(즉, 레이블은 선택 사항이 아닙니다)."

#: src/expressions/loop-expr.md:348
msgid "Similarly, labelled block expressions _must_ begin with a label."
msgstr "마찬가지로, 레이블 블록 표현식은 _반드시_ 레이블로 시작해야 합니다."

#: src/expressions/loop-expr.md:371
msgid "`continue` expressions"
msgstr "`continue` 표현식"

#: src/expressions/loop-expr.md:375
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ContinueExpression_ :  \n"
"   `continue` [LIFETIME_OR_LABEL](../tokens.md#lifetimes-and-loop-"
"labels)<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_계속표현식_ :  \n"
"   `continue` [라이프타임_또는_레이블](../tokens.md#lifetimes-and-loop-"
"labels)<sup>?</sup>"

#: src/expressions/loop-expr.md:381
msgid ""
"When `continue` is encountered, the current iteration of the associated loop "
"body is immediately terminated, returning control to the loop _head_."
msgstr "`continue`를 만나면 연관된 루프 본문의 현재 반복이 즉시 종료되고, 제어가 루프 _헤드_로 반환됩니다."

#: src/expressions/loop-expr.md:385
msgid ""
"In the case of a `while` loop, the head is the conditional expression "
"controlling the loop."
msgstr "`while` 루프의 경우, 헤드는 루프를 제어하는 조건 표현식입니다."

#: src/expressions/loop-expr.md:389
msgid ""
"In the case of a `for` loop, the head is the call-expression controlling the "
"loop."
msgstr "`for` 루프의 경우, 헤드는 루프를 제어하는 호출 표현식입니다."

#: src/expressions/loop-expr.md:393
msgid ""
"Like `break`, `continue` is normally associated with the innermost enclosing "
"loop, but `continue 'label` may be used to specify the loop affected."
msgstr "`break`와 마찬가지로, `continue`는 일반적으로 가장 안쪽의 둘러싸는 루프와 연관되지만, `continue 'label`을 사용하여 영향을 받는 루프를 지정할 수 있습니다."

#: src/expressions/loop-expr.md:397
msgid "A `continue` expression is only permitted in the body of a loop."
msgstr "`continue` 표현식은 루프 본문에서만 허용됩니다."

#: src/expressions/loop-expr.md:401
msgid "`break` and loop values"
msgstr "`break`와 루프 값"

#: src/expressions/loop-expr.md:405
msgid ""
"When associated with a `loop`, a break expression may be used to return a "
"value from that loop, via one of the forms `break EXPR` or `break 'label "
"EXPR`, where `EXPR` is an expression whose type is that of the loop. For "
"example:"
msgstr "`loop`와 연관된 경우, break 표현식은 `break EXPR` 또는 `break 'label EXPR` 형식 중 하나를 통해 해당 루프에서 값을 반환하는 데 사용될 수 있습니다. 여기서 `EXPR`은 루프와 동일한 타입의 표현식입니다. 예를 들어:"

#: src/expressions/loop-expr.md:417
msgid "// first number in Fibonacci sequence over 10:\n"
msgstr "// 피보나치 수열에서 10을 넘는 첫 번째 수:\n"

#: src/expressions/loop-expr.md:424
msgid ""
"In the case a `loop` has an associated `break`, it is not considered "
"diverging, and the `loop` must have a type compatible with each `break` "
"expression. `break` without an expression is considered identical to `break` "
"with expression `()`."
msgstr "`loop`에 연관된 `break`가 있는 경우 발산하는 것으로 간주되지 않으며, `loop`는 각 `break` 표현식과 호환되는 타입을 가져야 합니다. 표현식이 없는 `break`는 표현식 `()`가 있는 `break`와 동일한 것으로 간주됩니다."

#: src/expressions/range-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_RangeExpression_ :  \n"
"      _RangeExpr_  \n"
"   | _RangeFromExpr_  \n"
"   | _RangeToExpr_  \n"
"   | _RangeFullExpr_  \n"
"   | _RangeInclusiveExpr_  \n"
"   | _RangeToInclusiveExpr_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_범위표현식_ :  \n"
"      _범위표현식_  \n"
"   | _시작범위표현식_  \n"
"   | _끝범위표현식_  \n"
"   | _전체범위표현식_  \n"
"   | _포함범위표현식_  \n"
"   | _끝포함범위표현식_"

#: src/expressions/range-expr.md:16
msgid ""
"_RangeExpr_ :  \n"
"   [_Expression_](../expressions.md) `..` [_Expression_](../expressions.md)"
msgstr ""
"_범위표현식_ :  \n"
"   [_표현식_](../expressions.md) `..` [_표현식_](../expressions.md)"

#: src/expressions/range-expr.md:19
msgid ""
"_RangeFromExpr_ :  \n"
"   [_Expression_](../expressions.md) `..`"
msgstr ""
"_시작범위표현식_ :  \n"
"   [_표현식_](../expressions.md) `..`"

#: src/expressions/range-expr.md:22
msgid ""
"_RangeToExpr_ :  \n"
"   `..` [_Expression_](../expressions.md)"
msgstr ""
"_끝범위표현식_ :  \n"
"   `..` [_표현식_](../expressions.md)"

#: src/expressions/range-expr.md:25
msgid ""
"_RangeFullExpr_ :  \n"
"   `..`"
msgstr ""
"_전체범위표현식_ :  \n"
"   `..`"

#: src/expressions/range-expr.md:28
msgid ""
"_RangeInclusiveExpr_ :  \n"
"   [_Expression_](../expressions.md) `..=` [_Expression_](../expressions.md)"
msgstr ""
"_포함범위표현식_ :  \n"
"   [_표현식_](../expressions.md) `..=` [_표현식_](../expressions.md)"

#: src/expressions/range-expr.md:31
msgid ""
"_RangeToInclusiveExpr_ :  \n"
"   `..=` [_Expression_](../expressions.md)"
msgstr ""
"_끝포함범위표현식_ :  \n"
"   `..=` [_표현식_](../expressions.md)"

#: src/expressions/range-expr.md:36
msgid ""
"The `..` and `..=` operators will construct an object of one of the "
"`std::ops::Range` (or `core::ops::Range`) variants, according to the "
"following table:"
msgstr "`..` 및 `..=` 연산자는 다음 표에 따라 `std::ops::Range`(또는 `core::ops::Range`) 변형 중 하나의 객체를 생성합니다:"

#: src/expressions/range-expr.md:38
msgid "Production"
msgstr "생성"

#: src/expressions/range-expr.md:38 src/inline-assembly.md:51
msgid "Syntax"
msgstr "구문"

#: src/expressions/range-expr.md:38
msgid "Range"
msgstr "범위"

#: src/expressions/range-expr.md:40
msgid "_RangeExpr_"
msgstr "_범위표현식_"

#: src/expressions/range-expr.md:40
msgid "start`..`end"
msgstr "start`..`end"

#: src/expressions/range-expr.md:40
msgid "[std::ops::Range](https://doc.rust-lang.org/std/ops/struct.Range.html)"
msgstr "[std::ops::Range](https://doc.rust-lang.org/std/ops/struct.Range.html)"

#: src/expressions/range-expr.md:40
msgid "start ≤ x \\< end"
msgstr "start ≤ x \\< end"

#: src/expressions/range-expr.md:41
msgid "_RangeFromExpr_"
msgstr "_시작범위표현식_"

#: src/expressions/range-expr.md:41
msgid "start`..`"
msgstr "start`..`"

#: src/expressions/range-expr.md:41
msgid ""
"[std::ops::RangeFrom](https://doc.rust-lang.org/std/ops/"
"struct.RangeFrom.html)"
msgstr ""
"[std::ops::RangeFrom](https://doc.rust-lang.org/std/ops/"
"struct.RangeFrom.html)"

#: src/expressions/range-expr.md:41
msgid "start ≤ x"
msgstr "start ≤ x"

#: src/expressions/range-expr.md:42
msgid "_RangeToExpr_"
msgstr "_끝범위표현식_"

#: src/expressions/range-expr.md:42
msgid "`..`end"
msgstr "`..`end"

#: src/expressions/range-expr.md:42
msgid ""
"[std::ops::RangeTo](https://doc.rust-lang.org/std/ops/struct.RangeTo.html)"
msgstr ""
"[std::ops::RangeTo](https://doc.rust-lang.org/std/ops/struct.RangeTo.html)"

#: src/expressions/range-expr.md:42
msgid "x \\< end"
msgstr "x \\< end"

#: src/expressions/range-expr.md:43
msgid "_RangeFullExpr_"
msgstr "_전체범위표현식_"

#: src/expressions/range-expr.md:43
msgid ""
"[std::ops::RangeFull](https://doc.rust-lang.org/std/ops/"
"struct.RangeFull.html)"
msgstr ""
"[std::ops::RangeFull](https://doc.rust-lang.org/std/ops/"
"struct.RangeFull.html)"

#: src/expressions/range-expr.md:43
msgid "\\-"
msgstr "\\-"

#: src/expressions/range-expr.md:44
msgid "_RangeInclusiveExpr_"
msgstr "_포함범위표현식_"

#: src/expressions/range-expr.md:44
msgid "start`..=`end"
msgstr "start`..=`end"

#: src/expressions/range-expr.md:44
msgid ""
"[std::ops::RangeInclusive](https://doc.rust-lang.org/std/ops/"
"struct.RangeInclusive.html)"
msgstr ""
"[std::ops::RangeInclusive](https://doc.rust-lang.org/std/ops/"
"struct.RangeInclusive.html)"

#: src/expressions/range-expr.md:44
msgid "start ≤ x ≤ end"
msgstr "start ≤ x ≤ end"

#: src/expressions/range-expr.md:45
msgid "_RangeToInclusiveExpr_"
msgstr "_끝포함범위표현식_"

#: src/expressions/range-expr.md:45
msgid "`..=`end"
msgstr "`..=`end"

#: src/expressions/range-expr.md:45
msgid ""
"[std::ops::RangeToInclusive](https://doc.rust-lang.org/std/ops/"
"struct.RangeToInclusive.html)"
msgstr ""
"[std::ops::RangeToInclusive](https://doc.rust-lang.org/std/ops/"
"struct.RangeToInclusive.html)"

#: src/expressions/range-expr.md:45
msgid "x ≤ end"
msgstr "x ≤ end"

#: src/expressions/range-expr.md:50
msgid "// std::ops::Range\n"
msgstr "// std::ops::Range\n"

#: src/expressions/range-expr.md:51
msgid "// std::ops::RangeFrom\n"
msgstr "// std::ops::RangeFrom\n"

#: src/expressions/range-expr.md:52
msgid "// std::ops::RangeTo\n"
msgstr "// std::ops::RangeTo\n"

#: src/expressions/range-expr.md:53
msgid "// std::ops::RangeFull\n"
msgstr "// std::ops::RangeFull\n"

#: src/expressions/range-expr.md:54
msgid "// std::ops::RangeInclusive\n"
msgstr "// std::ops::RangeInclusive\n"

#: src/expressions/range-expr.md:55
msgid "// std::ops::RangeToInclusive\n"
msgstr "// std::ops::RangeToInclusive\n"

#: src/expressions/range-expr.md:60
msgid "The following expressions are equivalent."
msgstr "다음 표현식들은 동일합니다."

#: src/expressions/range-expr.md:71
msgid "Ranges can be used in `for` loops:"
msgstr "범위는 `for` 루프에서 사용할 수 있습니다:"

#: src/expressions/if-expr.md:3
msgid "`if` and `if let` expressions"
msgstr "`if` 및 `if let` 표현식"

#: src/expressions/if-expr.md:5
msgid "`if` expressions"
msgstr "`if` 표현식"

#: src/expressions/if-expr.md:9
msgid ""
"**<sup>Syntax</sup>**  \n"
"_IfExpression_ :  \n"
"   `if` [_Expression_](../expressions.md)<sub>_except struct expression_</"
"sub> [_BlockExpression_](block-expr.md)  \n"
"   (`else` ( [_BlockExpression_](block-expr.md) \\| _IfExpression_ \\| "
"_IfLetExpression_ ) )<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_If표현식_ :  \n"
"   `if` [_표현식_](../expressions.md)<sub>_구조체 표현식 제외_</"
"sub> [_블록표현식_](block-expr.md)  \n"
"   (`else` ( [_블록표현식_](block-expr.md) \\| _If표현식_ \\| "
"_IfLet표현식_ ) )<sup>?</sup>"

#: src/expressions/if-expr.md:19
msgid ""
"An `if` expression is a conditional branch in program control. The syntax of "
"an `if` expression is a condition operand, followed by a consequent block, "
"any number of `else if` conditions and blocks, and an optional trailing "
"`else` block."
msgstr "`if` 표현식은 프로그램 제어의 조건부 분기입니다. `if` 표현식의 구문은 조건 피연산자, 그 뒤에 오는 결과 블록, 임의의 수의 `else if` 조건 및 블록, 그리고 선택적 후행 `else` 블록입니다."

#: src/expressions/if-expr.md:24
msgid ""
"The condition operands must have the [boolean type](../types/boolean.md)."
msgstr "조건 피연산자는 [불리언 타입](../types/boolean.md)이어야 합니다."

#: src/expressions/if-expr.md:28
msgid ""
"If a condition operand evaluates to `true`, the consequent block is executed "
"and any subsequent `else if` or `else` block is skipped."
msgstr "조건 피연산자가 `true`로 평가되면 결과 블록이 실행되고 후속 `else if` 또는 `else` 블록은 건너뜁니다."

#: src/expressions/if-expr.md:32
msgid ""
"If a condition operand evaluates to `false`, the consequent block is skipped "
"and any subsequent `else if` condition is evaluated."
msgstr "조건 피연산자가 `false`로 평가되면 결과 블록은 건너뛰고 후속 `else if` 조건이 평가됩니다."

#: src/expressions/if-expr.md:36
msgid ""
"If all `if` and `else if` conditions evaluate to `false` then any `else` "
"block is executed."
msgstr "모든 `if` 및 `else if` 조건이 `false`로 평가되면 `else` 블록이 실행됩니다."

#: src/expressions/if-expr.md:40
msgid ""
"An if expression evaluates to the same value as the executed block, or `()` "
"if no block is evaluated."
msgstr "if 표현식은 실행된 블록과 동일한 값으로 평가되거나, 어떤 블록도 평가되지 않으면 `()`로 평가됩니다."

#: src/expressions/if-expr.md:44
msgid "An `if` expression must have the same type in all situations."
msgstr "`if` 표현식은 모든 상황에서 동일한 타입을 가져야 합니다."

#: src/expressions/if-expr.md:49
msgid "\"x is four\""
msgstr "\"x는 4\""

#: src/expressions/if-expr.md:51
msgid "\"x is three\""
msgstr "\"x는 3\""

#: src/expressions/if-expr.md:53
msgid "\"x is something else\""
msgstr "\"x는 다른 것\""

#: src/expressions/if-expr.md:57 src/expressions/if-expr.md:61
msgid "\"Bigger\""
msgstr "\"더 큼\""

#: src/expressions/if-expr.md:59
msgid "\"Smaller\""
msgstr "\"더 작음\""

#: src/expressions/if-expr.md:66
msgid "`if let` expressions"
msgstr "`if let` 표현식"

#: src/expressions/if-expr.md:70
msgid ""
"**<sup>Syntax</sup>**  \n"
"_IfLetExpression_ :  \n"
"   `if` `let` [_Pattern_](../patterns.md) `=` [_Scrutinee_](match-"
"expr.md)<sub>_except lazy boolean operator expression_</sub> "
"[_BlockExpression_](block-expr.md)  \n"
"   (`else` ( [_BlockExpression_](block-expr.md) \\| _IfExpression_ \\| "
"_IfLetExpression_ ) )<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_IfLet표현식_ :  \n"
"   `if` `let` [_패턴_](../patterns.md) `=` [_검사대상_](match-"
"expr.md)<sub>_지연 불리언 연산자 표현식 제외_</sub> "
"[_블록표현식_](block-expr.md)  \n"
"   (`else` ( [_블록표현식_](block-expr.md) \\| _If표현식_ \\| "
"_IfLet표현식_ ) )<sup>?</sup>"

#: src/expressions/if-expr.md:81
msgid ""
"An `if let` expression is semantically similar to an `if` expression but in "
"place of a condition operand it expects the keyword `let` followed by a "
"pattern, an `=` and a [scrutinee](../glossary.md#scrutinee) operand."
msgstr "`if let` 표현식은 의미상 `if` 표현식과 유사하지만, 조건 피연산자 대신 키워드 `let`, 그 뒤에 패턴, `=` 그리고 [검사 대상(scrutinee)](../glossary.md#scrutinee) 피연산자가 옵니다."

#: src/expressions/if-expr.md:85
msgid ""
"If the value of the scrutinee matches the pattern, the corresponding block "
"will execute."
msgstr "검사 대상의 값이 패턴과 일치하면 해당 블록이 실행됩니다."

#: src/expressions/if-expr.md:89
msgid "Otherwise, flow proceeds to the following `else` block if it exists."
msgstr "그렇지 않으면 흐름은 다음 `else` 블록(있는 경우)으로 진행됩니다."

#: src/expressions/if-expr.md:93
msgid ""
"Like `if` expressions, `if let` expressions have a value determined by the "
"block that is evaluated."
msgstr "`if` 표현식과 마찬가지로 `if let` 표현식은 평가되는 블록에 의해 결정되는 값을 가집니다."

#: src/expressions/if-expr.md:96 src/expressions/if-expr.md:107
msgid "\"Ham\""
msgstr "\"햄\""

#: src/expressions/if-expr.md:96
msgid "\"Eggs\""
msgstr "\"달걀\""

#: src/expressions/if-expr.md:97
msgid "// this body will be skipped because the pattern is refuted\n"
msgstr "// 패턴이 반박되므로 이 본문은 건너뜁니다\n"

#: src/expressions/if-expr.md:99
msgid "\"Bacon\""
msgstr "\"베이컨\""

#: src/expressions/if-expr.md:100
msgid "\"Bacon is served with {}\""
msgstr "\"베이컨은 {}와(과) 함께 제공됩니다\""

#: src/expressions/if-expr.md:102
msgid "// This block is evaluated instead.\n"
msgstr "// 대신 이 블록이 평가됩니다.\n"

#: src/expressions/if-expr.md:103
msgid "\"No bacon will be served\""
msgstr "\"베이컨은 제공되지 않습니다\""

#: src/expressions/if-expr.md:105
msgid "// this body will execute\n"
msgstr "// 이 본문이 실행됩니다\n"

#: src/expressions/if-expr.md:108
msgid "\"Ham is served with {}\""
msgstr "\"햄은 {}와(과) 함께 제공됩니다\""

#: src/expressions/if-expr.md:118
msgid "`if` and `if let` expressions can be intermixed:"
msgstr "`if` 및 `if let` 표현식을 섞어 쓸 수 있습니다:"

#: src/expressions/if-expr.md:136
msgid ""
"An `if let` expression is equivalent to a [`match` expression](match-"
"expr.md) as follows:"
msgstr "`if let` 표현식은 다음과 같이 [`match` 표현식](match-expr.md)과 동일합니다:"

#: src/expressions/if-expr.md:141 src/expressions/if-expr.md:152
msgid "/* body */"
msgstr "/* 본문 */"

#: src/expressions/if-expr.md:143
msgid "/*else */"
msgstr "/* else */"

#: src/expressions/if-expr.md:153
msgid "/* else */"
msgstr "/* else */"

#: src/expressions/if-expr.md:153
msgid "// () if there is no else\n"
msgstr "// else가 없으면 ()\n"

#: src/expressions/if-expr.md:175
msgid ""
"The expression cannot be a [lazy boolean operator expression](operator-"
"expr.md#lazy-boolean-operators). Use of a lazy boolean operator is ambiguous "
"with a planned feature change of the language (the implementation of if-let "
"chains - see [eRFC 2947](https://github.com/rust-lang/rfcs/blob/master/text/"
"2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018)). When "
"lazy boolean operator expression is desired, this can be achieved by using "
"parenthesis as below:"
msgstr "표현식은 [지연 불리언 연산자 표현식](operator-expr.md#lazy-boolean-operators)이 될 수 없습니다. 지연 불리언 연산자의 사용은 언어의 계획된 기능 변경(if-let 체인의 구현 - [eRFC 2947](https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018) 참조)과 모호합니다. 지연 불리언 연산자 표현식을 사용하려면 다음과 같이 괄호를 사용하여 달성할 수 있습니다:"

#: src/expressions/if-expr.md:181 src/expressions/if-expr.md:186
msgid "// Before...\n"
msgstr "// 전...\n"

#: src/expressions/if-expr.md:183 src/expressions/if-expr.md:189
msgid "// After...\n"
msgstr "// 후...\n"

#: src/expressions/match-expr.md:3
msgid "`match` expressions"
msgstr "`match` 표현식"

#: src/expressions/match-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_MatchExpression_ :  \n"
"   `match` _Scrutinee_ `{`  \n"
"      [_InnerAttribute_](../attributes.md)<sup>\\*</sup>  \n"
"      _MatchArms_<sup>?</sup>  \n"
"   `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Match표현식_ :  \n"
"   `match` _검사대상_ `{`  \n"
"      [_내부속성_](../attributes.md)<sup>\\*</sup>  \n"
"      _Match분기_<sup>?</sup>  \n"
"   `}`"

#: src/expressions/match-expr.md:14
msgid ""
"_Scrutinee_ :  \n"
"   [_Expression_](../expressions.md)<sub>_except struct expression_</sub>"
msgstr ""
"_검사대상_ :  \n"
"   [_표현식_](../expressions.md)<sub>_구조체 표현식 제외_</sub>"

#: src/expressions/match-expr.md:17
msgid ""
"_MatchArms_ :  \n"
"   ( _MatchArm_ `=>` ( [_ExpressionWithoutBlock_](../expressions.md) `,` \\| "
"[_ExpressionWithBlock_](../expressions.md) `,`<sup>?</sup> ) )<sup>\\*</"
"sup>  \n"
"   _MatchArm_ `=>` [_Expression_](../expressions.md) `,`<sup>?</sup>"
msgstr ""
"_Match분기_ :  \n"
"   ( _Match분기항목_ `=>` ( [_블록없는표현식_](../expressions.md) `,` \\| "
"[_블록있는표현식_](../expressions.md) `,`<sup>?</sup> ) )<sup>\\*</"
"sup>  \n"
"   _Match분기항목_ `=>` [_표현식_](../expressions.md) `,`<sup>?</sup>"

#: src/expressions/match-expr.md:24
msgid ""
"_MatchArm_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> [_Pattern_](../"
"patterns.md) _MatchArmGuard_<sup>?</sup>"
msgstr ""
"_Match분기항목_ :  \n"
"   [_외부속성_](../attributes.md)<sup>\\*</sup> [_패턴_](../"
"patterns.md) _Match분기가드_<sup>?</sup>"

#: src/expressions/match-expr.md:27
msgid ""
"_MatchArmGuard_ :  \n"
"   `if` [_Expression_](../expressions.md)"
msgstr ""
"_Match분기가드_ :  \n"
"   `if` [_표현식_](../expressions.md)"

#: src/expressions/match-expr.md:32
msgid ""
"A _`match` expression_ branches on a pattern. The exact form of matching "
"that occurs depends on the [pattern](../patterns.md)."
msgstr "_`match` 표현식_은 패턴에 따라 분기합니다. 발생하는 매칭의 정확한 형태는 [패턴](../patterns.md)에 따라 다릅니다."

#: src/expressions/match-expr.md:37
msgid ""
"A `match` expression has a _[scrutinee](../glossary.md#scrutinee) "
"expression_, which is the value to compare to the patterns."
msgstr "`match` 표현식에는 패턴과 비교할 값인 _[검사 대상](../glossary.md#scrutinee) 표현식_이 있습니다."

#: src/expressions/match-expr.md:41
msgid "The scrutinee expression and the patterns must have the same type."
msgstr "검사 대상 표현식과 패턴은 동일한 타입을 가져야 합니다."

#: src/expressions/match-expr.md:45
msgid ""
"A `match` behaves differently depending on whether or not the scrutinee "
"expression is a [place expression or value expression](../"
"expressions.md#place-expressions-and-value-expressions)."
msgstr "`match`는 검사 대상 표현식이 [장소 표현식인지 값 표현식인지](../expressions.md#place-expressions-and-value-expressions)에 따라 다르게 동작합니다."

#: src/expressions/match-expr.md:49
msgid ""
"If the scrutinee expression is a [value expression](../expressions.md#place-"
"expressions-and-value-expressions), it is first evaluated into a temporary "
"location, and the resulting value is sequentially compared to the patterns "
"in the arms until a match is found. The first arm with a matching pattern is "
"chosen as the branch target of the `match`, any variables bound by the "
"pattern are assigned to local variables in the arm's block, and control "
"enters the block."
msgstr "검사 대상 표현식이 [값 표현식](../expressions.md#place-expressions-and-value-expressions)인 경우, 먼저 임시 위치로 평가되고, 결과 값은 일치하는 항목을 찾을 때까지 분기의 패턴과 순차적으로 비교됩니다. 일치하는 패턴이 있는 첫 번째 분기가 `match`의 분기 대상으로 선택되고, 패턴에 의해 바인딩된 모든 변수는 분기 블록의 지역 변수에 할당되며, 제어가 블록으로 들어갑니다."

#: src/expressions/match-expr.md:54
msgid ""
"When the scrutinee expression is a [place expression](../"
"expressions.md#place-expressions-and-value-expressions), the match does not "
"allocate a temporary location; however, a by-value binding may copy or move "
"from the memory location. When possible, it is preferable to match on place "
"expressions, as the lifetime of these matches inherits the lifetime of the "
"place expression rather than being restricted to the inside of the match."
msgstr "검사 대상 표현식이 [장소 표현식](../expressions.md#place-expressions-and-value-expressions)인 경우, 매치는 임시 위치를 할당하지 않습니다. 그러나 값에 의한 바인딩은 메모리 위치에서 복사하거나 이동할 수 있습니다. 가능한 경우 장소 표현식에 대해 매칭하는 것이 바람직한데, 이러한 매칭의 라이프타임은 매치 내부로 제한되지 않고 장소 표현식의 라이프타임을 상속하기 때문입니다."

#: src/expressions/match-expr.md:58
msgid "An example of a `match` expression:"
msgstr "`match` 표현식의 예:"

#: src/expressions/match-expr.md:64
msgid "\"one\""
msgstr "\"하나\""

#: src/expressions/match-expr.md:65
msgid "\"two\""
msgstr "\"둘\""

#: src/expressions/match-expr.md:66
msgid "\"three\""
msgstr "\"셋\""

#: src/expressions/match-expr.md:67
msgid "\"four\""
msgstr "\"넷\""

#: src/expressions/match-expr.md:68
msgid "\"five\""
msgstr "\"다섯\""

#: src/expressions/match-expr.md:69
msgid "\"something else\""
msgstr "\"그 외의 것\""

#: src/expressions/match-expr.md:75
msgid ""
"Variables bound within the pattern are scoped to the match guard and the "
"arm's expression."
msgstr "패턴 내에 바인딩된 변수의 스코프는 매치 가드와 분기의 표현식으로 제한됩니다."

#: src/expressions/match-expr.md:79
msgid ""
"The [binding mode](../patterns.md#binding-modes) (move, copy, or reference) "
"depends on the pattern."
msgstr "[바인딩 모드](../patterns.md#binding-modes)(이동, 복사 또는 참조)는 패턴에 따라 다릅니다."

#: src/expressions/match-expr.md:83
msgid ""
"Multiple match patterns may be joined with the `|` operator. Each pattern "
"will be tested in left-to-right sequence until a successful match is found."
msgstr "여러 매치 패턴을 `|` 연산자로 결합할 수 있습니다. 성공적인 매치를 찾을 때까지 각 패턴을 왼쪽에서 오른쪽 순서로 테스트합니다."

#: src/expressions/match-expr.md:89
msgid "\"not many\""
msgstr "\"많지 않음\""

#: src/expressions/match-expr.md:90 src/expressions/match-expr.md:94
msgid "\"a few\""
msgstr "\"약간\""

#: src/expressions/match-expr.md:91
msgid "\"lots\""
msgstr "\"많음\""

#: src/expressions/match-expr.md:95
msgid "// Demonstration of pattern match order.\n"
msgstr "// 패턴 매칭 순서 예시.\n"

#: src/expressions/match-expr.md:105
msgid ""
"Note: The `2..=9` is a [Range Pattern](../patterns.md#range-patterns), not a "
"[Range Expression](range-expr.md). Thus, only those types of ranges "
"supported by range patterns can be used in match arms."
msgstr "참고: `2..=9`는 [범위 표현식](range-expr.md)이 아니라 [범위 패턴](../patterns.md#range-patterns)입니다. 따라서 범위 패턴에서 지원하는 범위 타입만 매치 분기에서 사용할 수 있습니다."

#: src/expressions/match-expr.md:110
msgid ""
"Every binding in each `|` separated pattern must appear in all of the "
"patterns in the arm."
msgstr "각 `|`로 구분된 패턴의 모든 바인딩은 분기의 모든 패턴에 나타나야 합니다."

#: src/expressions/match-expr.md:114
msgid ""
"Every binding of the same name must have the same type, and have the same "
"binding mode."
msgstr "동일한 이름의 모든 바인딩은 동일한 타입과 동일한 바인딩 모드를 가져야 합니다."

#: src/expressions/match-expr.md:118
msgid "Match guards"
msgstr "매치 가드"

#: src/expressions/match-expr.md:122
msgid ""
"Match arms can accept _match guards_ to further refine the criteria for "
"matching a case."
msgstr "매치 분기는 케이스 일치 기준을 더 구체화하기 위해 _매치 가드_를 허용할 수 있습니다."

#: src/expressions/match-expr.md:126
msgid ""
"Pattern guards appear after the pattern and consist of a `bool`\\-typed "
"expression following the `if` keyword."
msgstr "패턴 가드는 패턴 뒤에 나타나며 `if` 키워드 뒤에 오는 `bool` 타입 표현식으로 구성됩니다."

#: src/expressions/match-expr.md:130
msgid ""
"When the pattern matches successfully, the pattern guard expression is "
"executed. If the expression evaluates to true, the pattern is successfully "
"matched against."
msgstr "패턴이 성공적으로 일치하면 패턴 가드 표현식이 실행됩니다. 표현식이 참으로 평가되면 패턴이 성공적으로 일치한 것입니다."

#: src/expressions/match-expr.md:135
msgid ""
"Otherwise, the next pattern, including other matches with the `|` operator "
"in the same arm, is tested."
msgstr "그렇지 않으면, 동일한 분기의 `|` 연산자를 사용한 다른 일치 항목을 포함하여 다음 패턴이 테스트됩니다."

#: src/expressions/match-expr.md:148
msgid ""
"Note: Multiple matches using the `|` operator can cause the pattern guard "
"and the side effects it has to execute multiple times. For example:"
msgstr "참고: `|` 연산자를 사용한 다중 매치는 패턴 가드와 그 부작용을 여러 번 실행하게 할 수 있습니다. 예를 들면:"

#: src/expressions/match-expr.md:163
msgid ""
"A pattern guard may refer to the variables bound within the pattern they "
"follow."
msgstr "패턴 가드는 뒤따르는 패턴 내에 바인딩된 변수를 참조할 수 있습니다."

#: src/expressions/match-expr.md:167
msgid ""
"Before evaluating the guard, a shared reference is taken to the part of the "
"scrutinee the variable matches on. While evaluating the guard, this shared "
"reference is then used when accessing the variable."
msgstr "가드를 평가하기 전에, 변수가 일치하는 검사 대상의 부분에 대한 공유 참조가 취해집니다. 가드를 평가하는 동안 변수에 접근할 때 이 공유 참조가 사용됩니다."

#: src/expressions/match-expr.md:172
msgid ""
"Only when the guard evaluates to true is the value moved, or copied, from "
"the scrutinee into the variable. This allows shared borrows to be used "
"inside guards without moving out of the scrutinee in case guard fails to "
"match."
msgstr "가드가 참으로 평가될 때만 값이 검사 대상에서 변수로 이동되거나 복사됩니다. 이를 통해 가드가 일치에 실패할 경우 검사 대상에서 이동하지 않고도 가드 내부에서 공유 참조를 사용할 수 있습니다."

#: src/expressions/match-expr.md:177
msgid ""
"Moreover, by holding a shared reference while evaluating the guard, mutation "
"inside guards is also prevented."
msgstr "게다가, 가드를 평가하는 동안 공유 참조를 유지함으로써 가드 내부에서의 변경도 방지됩니다."

#: src/expressions/match-expr.md:181
msgid "Attributes on match arms"
msgstr "매치 분기의 속성"

#: src/expressions/match-expr.md:185
msgid ""
"Outer attributes are allowed on match arms. The only attributes that have "
"meaning on match arms are [`cfg`](../conditional-compilation.md) and the "
"[lint check attributes](../attributes/diagnostics.md#lint-check-attributes)."
msgstr "매치 분기에 외부 속성이 허용됩니다. 매치 분기에서 의미가 있는 속성은 [`cfg`](../conditional-compilation.md)와 [린트 검사 속성](../attributes/diagnostics.md#lint-check-attributes)뿐입니다."

#: src/expressions/match-expr.md:190
msgid ""
"[Inner attributes](../attributes.md) are allowed directly after the opening "
"brace of the match expression in the same expression contexts as [attributes "
"on block expressions](block-expr.md#attributes-on-block-expressions)."
msgstr "[내부 속성](../attributes.md)은 [블록 표현식의 속성](block-expr.md#attributes-on-block-expressions)과 동일한 표현식 문맥에서 매치 표현식의 여는 중괄호 바로 뒤에 허용됩니다."

#: src/expressions/return-expr.md:3
msgid "`return` expressions"
msgstr "`return` 표현식"

#: src/expressions/return-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ReturnExpression_ :  \n"
"   `return` [_Expression_](../expressions.md)<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_리턴표현식_ :  \n"
"   `return` [_표현식_](../expressions.md)<sup>?</sup>"

#: src/expressions/return-expr.md:13
msgid "Return expressions are denoted with the keyword `return`."
msgstr "리턴 표현식은 키워드 `return`으로 표시됩니다."

#: src/expressions/return-expr.md:17
msgid ""
"Evaluating a `return` expression moves its argument into the designated "
"output location for the current function call, destroys the current function "
"activation frame, and transfers control to the caller frame."
msgstr "`return` 표현식을 평가하면 인수를 현재 함수 호출에 지정된 출력 위치로 이동하고, 현재 함수 활성화 프레임을 파괴하며, 제어를 호출자 프레임으로 전달합니다."

#: src/expressions/return-expr.md:19
msgid "An example of a `return` expression:"
msgstr "`return` 표현식의 예:"

#: src/expressions/await-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_AwaitExpression_ :  \n"
"   [_Expression_](../expressions.md) `.` `await`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Await표현식_ :  \n"
"   [_표현식_](../expressions.md) `.` `await`"

#: src/expressions/await-expr.md:13
msgid ""
"An `await` expression is a syntactic construct for suspending a computation "
"provided by an implementation of `std::future::IntoFuture` until the given "
"future is ready to produce a value."
msgstr "`await` 표현식은 `std::future::IntoFuture` 구현에서 제공하는 계산을 주어진 퓨처가 값을 생성할 준비가 될 때까지 일시 중단하기 위한 구문 구조입니다."

#: src/expressions/await-expr.md:19
msgid ""
"The syntax for an await expression is an expression with a type that "
"implements the [`IntoFuture`](../../core/future/into_future/"
"trait.IntoFuture.html) trait, called the _future operand_, then the token "
"`.`, and then the `await` keyword."
msgstr "await 표현식의 구문은 [`IntoFuture`](../../core/future/into_future/trait.IntoFuture.html) 트레잇을 구현하는 타입의 표현식(_퓨처 피연산자_라고 함), 그 다음 토큰 `.`, 그리고 `await` 키워드입니다."

#: src/expressions/await-expr.md:23
msgid ""
"Await expressions are legal only within an [async context](../expressions/"
"block-expr.md#async-context), like an [`async fn`](../items/"
"functions.md#async-functions), [`async` closure](closure-expr.md#async-"
"closures), or [`async` block](block-expr.md#async-blocks)."
msgstr "Await 표현식은 [`async fn`](../items/functions.md#async-functions), [`async` 클로저](closure-expr.md#async-closures) 또는 [`async` 블록](block-expr.md#async-blocks)과 같은 [비동기 컨텍스트](../expressions/block-expr.md#async-context) 내에서만 유효합니다."

#: src/expressions/await-expr.md:27
msgid "More specifically, an await expression has the following effect."
msgstr "더 구체적으로, await 표현식은 다음과 같은 효과를 가집니다."

#: src/expressions/await-expr.md:29
msgid ""
"Create a future by calling [`IntoFuture::into_future`](../../core/future/"
"into_future/trait.IntoFuture.html#tymethod.into_future) on the future "
"operand."
msgstr "퓨처 피연산자에서 [`IntoFuture::into_future`](../../core/future/into_future/trait.IntoFuture.html#tymethod.into_future)를 호출하여 퓨처를 생성합니다."

#: src/expressions/await-expr.md:30
msgid ""
"Evaluate the future to a [future](../../core/future/future/"
"trait.Future.html) `tmp`;"
msgstr "퓨처를 [퓨처](../../core/future/future/trait.Future.html) `tmp`로 평가합니다;"

#: src/expressions/await-expr.md:31
msgid ""
"Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/"
"struct.Pin.html#method.new_unchecked);"
msgstr "[`Pin::new_unchecked`](../../core/pin/struct.Pin.html#method.new_unchecked)를 사용하여 `tmp`를 고정(pin)합니다;"

#: src/expressions/await-expr.md:32
msgid ""
"This pinned future is then polled by calling the [`Future::poll`](../../core/"
"future/future/trait.Future.html#tymethod.poll) method and passing it the "
"current [task context](#task-context);"
msgstr "그런 다음 이 고정된 퓨처는 [`Future::poll`](../../core/future/future/trait.Future.html#tymethod.poll) 메서드를 호출하고 현재 [태스크 컨텍스트](#task-context)를 전달하여 폴링됩니다;"

#: src/expressions/await-expr.md:33
msgid ""
"If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/"
"enum.Poll.html#variant.Pending), then the future returns `Poll::Pending`, "
"suspending its state so that, when the surrounding async context is re-"
"polled,execution returns to step 3;"
msgstr "`poll` 호출이 [`Poll::Pending`](../../core/task/poll/enum.Poll.html#variant.Pending)을 반환하면, 퓨처는 `Poll::Pending`을 반환하고, 상태를 일시 중단하여 둘러싼 비동기 컨텍스트가 다시 폴링될 때 실행이 3단계로 돌아가게 합니다;"

#: src/expressions/await-expr.md:34
msgid ""
"Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/"
"task/poll/enum.Poll.html#variant.Ready), in which case the value contained "
"in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html#variant.Ready) "
"variant is used as the result of the `await` expression itself."
msgstr "그렇지 않으면 `poll` 호출은 [`Poll::Ready`](../../core/task/poll/enum.Poll.html#variant.Ready)를 반환했어야 하며, 이 경우 [`Poll::Ready`](../../core/task/poll/enum.Poll.html#variant.Ready) 변형에 포함된 값이 `await` 표현식 자체의 결과로 사용됩니다."

#: src/expressions/await-expr.md:36
msgid ""
"**Edition differences**: Await expressions are only available beginning with "
"Rust 2018."
msgstr "**에디션 차이**: Await 표현식은 Rust 2018부터 사용할 수 있습니다."

#: src/expressions/await-expr.md:40
msgid "Task context"
msgstr "태스크 컨텍스트"

#: src/expressions/await-expr.md:42
msgid ""
"The task context refers to the [`Context`](../../core/task/wake/"
"struct.Context.html) which was supplied to the current [async context](../"
"expressions/block-expr.md#async-context) when the async context itself was "
"polled. Because `await` expressions are only legal in an async context, "
"there must be some task context available."
msgstr "태스크 컨텍스트는 비동기 컨텍스트 자체가 폴링될 때 현재 [비동기 컨텍스트](../expressions/block-expr.md#async-context)에 제공된 [`Context`](../../core/task/wake/struct.Context.html)를 나타냅니다. `await` 표현식은 비동기 컨텍스트에서만 유효하기 때문에, 사용 가능한 태스크 컨텍스트가 있어야 합니다."

#: src/expressions/await-expr.md:47
msgid "Approximate desugaring"
msgstr "대략적인 탈설탕"

#: src/expressions/await-expr.md:49
msgid ""
"Effectively, an await expression is roughly equivalent to the following non-"
"normative desugaring:"
msgstr "사실상, await 표현식은 다음의 비규범적 탈설탕과 대략적으로 동일합니다:"

#: src/expressions/await-expr.md:64
msgid ""
"where the `yield` pseudo-code returns `Poll::Pending` and, when re-invoked, "
"resumes execution from that point. The variable `current_context` refers to "
"the context taken from the async environment."
msgstr "여기서 `yield` 의사 코드는 `Poll::Pending`을 반환하고, 다시 호출될 때 해당 지점에서 실행을 재개합니다. 변수 `current_context`는 비동기 환경에서 가져온 컨텍스트를 나타냅니다."

#: src/expressions/underscore-expr.md:3
msgid "`_` expressions"
msgstr "`_` 표현식"

#: src/expressions/underscore-expr.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_UnderscoreExpression_ :  \n"
"   `_`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_밑줄표현식_ :  \n"
"   `_`"

#: src/expressions/underscore-expr.md:13
msgid ""
"Underscore expressions, denoted with the symbol `_`, are used to signify a "
"placeholder in a destructuring assignment."
msgstr "`_` 기호로 표시되는 밑줄 표현식은 구조 분해 할당에서 플레이스홀더를 나타내는 데 사용됩니다."

#: src/expressions/underscore-expr.md:18
msgid "They may only appear in the left-hand side of an assignment."
msgstr "이들은 할당의 왼쪽에만 나타날 수 있습니다."

#: src/expressions/underscore-expr.md:22
msgid ""
"Note that this is distinct from the [wildcard pattern](../"
"patterns.md#wildcard-pattern)."
msgstr "이것은 [와일드카드 패턴](../patterns.md#wildcard-pattern)과는 구별된다는 점에 유의하십시오."

#: src/expressions/underscore-expr.md:24
msgid "Examples of `_` expressions:"
msgstr "`_` 표현식의 예:"

#: src/expressions/underscore-expr.md:37
msgid ""
"// unused result, assignment to `_` used to declare intent and remove a "
"warning\n"
msgstr "// 사용되지 않는 결과, 의도를 선언하고 경고를 제거하기 위해 `_`에 할당함\n"

#: src/expressions/underscore-expr.md:39
msgid ""
"// triggers unused_must_use warning\n"
"// 2 + 2;\n"
msgstr ""
"// unused_must_use 경고 발생\n"
"// 2 + 2;\n"

#: src/expressions/underscore-expr.md:42
msgid "// equivalent technique using a wildcard pattern in a let-binding\n"
msgstr "// let 바인딩에서 와일드카드 패턴을 사용하는 동일한 기법\n"

#: src/patterns.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Pattern_ :  \n"
"      `|`<sup>?</sup> _PatternNoTopAlt_  ( `|` _PatternNoTopAlt_ )<sup>\\*</"
"sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_패턴_ :  \n"
"      `|`<sup>?</sup> _최상위대안없는패턴_  ( `|` _최상위대안없는패턴_ )<sup>\\*</"
"sup>"

#: src/patterns.md:11
msgid ""
"_PatternNoTopAlt_ :  \n"
"      _PatternWithoutRange_  \n"
"   | [_RangePattern_](#range-patterns)"
msgstr ""
"_최상위대안없는패턴_ :  \n"
"      _범위없는패턴_  \n"
"   | [_범위패턴_](#range-patterns)"

#: src/patterns.md:15
msgid ""
"_PatternWithoutRange_ :  \n"
"      [_LiteralPattern_](#literal-patterns)  \n"
"   | [_IdentifierPattern_](#identifier-patterns)  \n"
"   | [_WildcardPattern_](#wildcard-pattern)  \n"
"   | [_RestPattern_](#rest-patterns)  \n"
"   | [_ReferencePattern_](#reference-patterns)  \n"
"   | [_StructPattern_](#struct-patterns)  \n"
"   | [_TupleStructPattern_](#tuple-struct-patterns)  \n"
"   | [_TuplePattern_](#tuple-patterns)  \n"
"   | [_GroupedPattern_](#grouped-patterns)  \n"
"   | [_SlicePattern_](#slice-patterns)  \n"
"   | [_PathPattern_](#path-patterns)  \n"
"   | [_MacroInvocation_](macros.md#macro-invocation)"
msgstr ""
"_범위없는패턴_ :  \n"
"      [_리터럴패턴_](#literal-patterns)  \n"
"   | [_식별자패턴_](#identifier-patterns)  \n"
"   | [_와일드카드패턴_](#wildcard-pattern)  \n"
"   | [_나머지패턴_](#rest-patterns)  \n"
"   | [_참조패턴_](#reference-patterns)  \n"
"   | [_구조체패턴_](#struct-patterns)  \n"
"   | [_튜플구조체패턴_](#tuple-struct-patterns)  \n"
"   | [_튜플패턴_](#tuple-patterns)  \n"
"   | [_그룹화된패턴_](#grouped-patterns)  \n"
"   | [_슬라이스패턴_](#slice-patterns)  \n"
"   | [_경로패턴_](#path-patterns)  \n"
"   | [_매크로호출_](macros.md#macro-invocation)"

#: src/patterns.md:31
msgid ""
"Patterns are used to match values against structures and to, optionally, "
"bind variables to values inside these structures. They are also used in "
"variable declarations and parameters for functions and closures."
msgstr "패턴은 값을 구조에 대해 매칭하고, 선택적으로 구조 내부의 값에 변수를 바인딩하는 데 사용됩니다. 또한 변수 선언과 함수 및 클로저의 매개변수에도 사용됩니다."

#: src/patterns.md:34
msgid "The pattern in the following example does four things:"
msgstr "다음 예제의 패턴은 네 가지 작업을 수행합니다:"

#: src/patterns.md:36
msgid "Tests if `person` has the `car` field filled with something."
msgstr "`person`의 `car` 필드가 무언가로 채워져 있는지 테스트합니다."

#: src/patterns.md:37
msgid ""
"Tests if the person's `age` field is between 13 and 19, and binds its value "
"to the `person_age` variable."
msgstr "사람의 `age` 필드가 13에서 19 사이인지 테스트하고, 그 값을 `person_age` 변수에 바인딩합니다."

#: src/patterns.md:38
msgid "Binds a reference to the `name` field to the variable `person_name`."
msgstr "`name` 필드에 대한 참조를 `person_name` 변수에 바인딩합니다."

#: src/patterns.md:39
msgid ""
"Ignores the rest of the fields of `person`. The remaining fields can have "
"any value and are not bound to any variables."
msgstr "`person`의 나머지 필드를 무시합니다. 나머지 필드는 어떤 값이든 가질 수 있으며 어떤 변수에도 바인딩되지 않습니다."

#: src/patterns.md:52 src/patterns.md:293 src/patterns.md:304
#: src/patterns.md:416
msgid "\"John\""
msgstr "\"John\""

#: src/patterns.md:65
msgid "\"{} has a car and is {} years old.\""
msgstr "\"{}는 차가 있고 {}살입니다.\""

#: src/patterns.md:71
msgid "Patterns are used in:"
msgstr "패턴은 다음에서 사용됩니다:"

#: src/patterns.md:75
msgid "[`let` declarations](statements.md#let-statements)"
msgstr "[`let` 선언](statements.md#let-statements)"

#: src/patterns.md:79
msgid ""
"[Function](items/functions.md) and [closure](expressions/closure-expr.md) "
"parameters"
msgstr "[함수](items/functions.md) 및 [클로저](expressions/closure-expr.md) 매개변수"

#: src/patterns.md:83
msgid "[`match` expressions](expressions/match-expr.md)"
msgstr "[`match` 표현식](expressions/match-expr.md)"

#: src/patterns.md:87
msgid "[`if let` expressions](expressions/if-expr.md)"
msgstr "[`if let` 표현식](expressions/if-expr.md)"

#: src/patterns.md:91
msgid ""
"[`while let` expressions](expressions/loop-expr.md#predicate-pattern-loops)"
msgstr "[`while let` 표현식](expressions/loop-expr.md#predicate-pattern-loops)"

#: src/patterns.md:95
msgid "[`for` expressions](expressions/loop-expr.md#iterator-loops)"
msgstr "[`for` 표현식](expressions/loop-expr.md#iterator-loops)"

#: src/patterns.md:99
msgid "Destructuring"
msgstr "구조 분해"

#: src/patterns.md:103
msgid ""
"Patterns can be used to _destructure_ [structs](items/structs.md), [enums]"
"(items/enumerations.md), and [tuples](types/tuple.md). Destructuring breaks "
"up a value into its component pieces. The syntax used is almost the same as "
"when creating such values."
msgstr "패턴은 [구조체](items/structs.md), [열거형](items/enumerations.md), [튜플](types/tuple.md)을 _구조 분해_하는 데 사용될 수 있습니다. 구조 분해는 값을 구성 요소로 나눕니다. 사용되는 구문은 해당 값을 생성할 때와 거의 동일합니다."

#: src/patterns.md:109
msgid ""
"In a pattern whose [scrutinee](glossary.md#scrutinee) expression has a "
"`struct`, `enum` or `tuple` type, a placeholder (`_`) stands in for a "
"_single_ data field, whereas a wildcard `..`  stands in for _all_ the "
"remaining fields of a particular variant."
msgstr "[조사 대상](glossary.md#scrutinee) 표현식이 `struct`, `enum` 또는 `tuple` 타입인 패턴에서, 플레이스홀더(`_`)는 _단일_ 데이터 필드를 나타내며, 와일드카드 `..`는 특정 변형의 _모든_ 나머지 필드를 나타냅니다."

#: src/patterns.md:113
msgid ""
"When destructuring a data structure with named (but not numbered) fields, it "
"is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`."
msgstr "이름이 있는(번호가 아닌) 필드를 가진 데이터 구조를 구조 분해할 때, `fieldname: fieldname`의 단축형으로 `fieldname`을 작성할 수 있습니다."

#: src/patterns.md:124
msgid "\"Quit\""
msgstr "\"Quit\""

#: src/patterns.md:126
msgid "\"move {} horizontally\""
msgstr "\"가로로 {}만큼 이동\""

#: src/patterns.md:127
msgid "\"other move\""
msgstr "\"다른 이동\""

#: src/patterns.md:129
msgid "\"color change, red: {}, green: {}\""
msgstr "\"색상 변경, 빨강: {}, 초록: {}\""

#: src/patterns.md:136
msgid "Refutability"
msgstr "반박 가능성"

#: src/patterns.md:138
msgid ""
"A pattern is said to be _refutable_ when it has the possibility of not being "
"matched by the value it is being matched against. _Irrefutable_ patterns, on "
"the other hand, always match the value they are being matched against. "
"Examples:"
msgstr "패턴이 비교 대상 값과 일치하지 않을 가능성이 있는 경우를 _반박 가능(refutable)_하다고 합니다. 반면에 _반박 불가능(irrefutable)_한 패턴은 비교 대상 값과 항상 일치합니다. 예시:"

#: src/patterns.md:143
msgid "// \"(x, y)\" is an irrefutable pattern\n"
msgstr "// \"(x, y)\"는 반박 불가능한 패턴입니다\n"

#: src/patterns.md:145
msgid "// \"(a, 3)\" is refutable, and will not match\n"
msgstr "// \"(a, 3)\"은 반박 가능하며, 일치하지 않을 수 있습니다\n"

#: src/patterns.md:146
msgid "\"Shouldn't reach here\""
msgstr "\"여기에 도달해서는 안 됩니다\""

#: src/patterns.md:147
msgid "// \"(a, 4)\" is refutable, and will match\n"
msgstr "// \"(a, 4)\"는 반박 가능하며, 일치하게 됩니다\n"

#: src/patterns.md:148
msgid "\"Matched ({}, 4)\""
msgstr "\"({}, 4)와 일치함\""

#: src/patterns.md:154
msgid "Literal patterns"
msgstr "리터럴 패턴"

#: src/patterns.md:158
msgid ""
"**<sup>Syntax</sup>**  \n"
"_LiteralPattern_ :  \n"
"      `true` | `false`  \n"
"   | [CHAR_LITERAL](tokens.md#character-literals)  \n"
"   | [BYTE_LITERAL](tokens.md#byte-literals)  \n"
"   | [STRING_LITERAL](tokens.md#string-literals)  \n"
"   | [RAW_STRING_LITERAL](tokens.md#raw-string-literals)  \n"
"   | [BYTE_STRING_LITERAL](tokens.md#byte-string-literals)  \n"
"   | [RAW_BYTE_STRING_LITERAL](tokens.md#raw-byte-string-literals)  \n"
"   | [C_STRING_LITERAL](tokens.md#c-string-literals)  \n"
"   | [RAW_C_STRING_LITERAL](tokens.md#raw-c-string-literals)  \n"
"   | `-`<sup>?</sup> [INTEGER_LITERAL](tokens.md#integer-literals)  \n"
"   | `-`<sup>?</sup> [FLOAT_LITERAL](tokens.md#floating-point-literals)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_리터럴패턴_ :  \n"
"      `true` | `false`  \n"
"   | [문자리터럴](tokens.md#character-literals)  \n"
"   | [바이트리터럴](tokens.md#byte-literals)  \n"
"   | [문자열리터럴](tokens.md#string-literals)  \n"
"   | [원시문자열리터럴](tokens.md#raw-string-literals)  \n"
"   | [바이트문자열리터럴](tokens.md#byte-string-literals)  \n"
"   | [원시바이트문자열리터럴](tokens.md#raw-byte-string-literals)  \n"
"   | [C문자열리터럴](tokens.md#c-string-literals)  \n"
"   | [원시C문자열리터럴](tokens.md#raw-c-string-literals)  \n"
"   | `-`<sup>?</sup> [정수리터럴](tokens.md#integer-literals)  \n"
"   | `-`<sup>?</sup> [부동소수점리터럴](tokens.md#floating-point-literals)"

#: src/patterns.md:185
msgid ""
"_Literal patterns_ match exactly the same value as what is created by the "
"literal. Since negative numbers are not [literals](expressions/literal-"
"expr.md), literal patterns also accept an optional minus sign before the "
"literal, which acts like the negation operator."
msgstr "_리터럴 패턴_은 리터럴에 의해 생성된 값과 정확히 동일한 값에 매치됩니다. 음수는 [리터럴](expressions/literal-expr.md)이 아니므로, 리터럴 패턴은 리터럴 앞에 선택적으로 마이너스 기호를 허용하며, 이는 부정 연산자처럼 작동합니다."

#: src/patterns.md:190
msgid ""
"_**Warning:**_ C string and raw C string literals are accepted in literal "
"patterns, but `&CStr` doesn't implement structural equality (`#[derive(Eq, "
"PartialEq)]`) and therefore any such `match` on a `&CStr` will be rejected "
"with a type error."
msgstr "_**경고:**_ C 문자열 및 원시 C 문자열 리터럴은 리터럴 패턴에서 허용되지만, `&CStr`은 구조적 동등성(`#[derive(Eq, PartialEq)]`)을 구현하지 않으므로 `&CStr`에 대한 어떠한 `match`도 타입 오류로 인해 거부됩니다."

#: src/patterns.md:198
msgid "Literal patterns are always refutable."
msgstr "리터럴 패턴은 항상 반박 가능합니다."

#: src/patterns.md:205
msgid "\"It's minus one\""
msgstr "\"마이너스 1입니다\""

#: src/patterns.md:206
msgid "\"It's a one\""
msgstr "\"1입니다\""

#: src/patterns.md:207
msgid "\"It's either a two or a four\""
msgstr "\"2 또는 4입니다\""

#: src/patterns.md:208
msgid "\"Matched none of the arms\""
msgstr "\"어떠한 매치 암(arm)과도 일치하지 않았습니다\""

#: src/patterns.md:215
msgid "Identifier patterns"
msgstr "식별자 패턴"

#: src/patterns.md:219
msgid ""
"**<sup>Syntax</sup>**  \n"
"_IdentifierPattern_ :  \n"
"      `ref`<sup>?</sup> `mut`<sup>?</sup> [IDENTIFIER](identifiers.md) (`@` "
"[_PatternNoTopAlt_](#patterns) ) <sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_식별자패턴_ :  \n"
"      `ref`<sup>?</sup> `mut`<sup>?</sup> [식별자](identifiers.md) (`@` "
"[_최상위대안없는패턴_](#patterns) ) <sup>?</sup>"

#: src/patterns.md:225
msgid ""
"Identifier patterns bind the value they match to a variable in the [value "
"namespace](names/namespaces.md)."
msgstr "식별자 패턴은 매치된 값을 [값 네임스페이스](names/namespaces.md)의 변수에 바인딩합니다."

#: src/patterns.md:229
msgid "The identifier must be unique within the pattern."
msgstr "식별자는 패턴 내에서 유일해야 합니다."

#: src/patterns.md:233
msgid ""
"The variable will shadow any variables of the same name in scope. The [scope]"
"(names/scopes.md) of the new binding depends on the context of where the "
"pattern is used (such as a `let` binding or a `match` arm)."
msgstr "변수는 스코프 내의 동일한 이름을 가진 다른 변수를 섀도잉(shadowing)합니다. 새 바인딩의 [스코프](names/scopes.md)는 패턴이 사용되는 컨텍스트(`let` 바인딩 또는 `match` 암 등)에 따라 달라집니다."

#: src/patterns.md:238
msgid ""
"Patterns that consist of only an identifier, possibly with a `mut`, match "
"any value and bind it to that identifier. This is the most commonly used "
"pattern in variable declarations and parameters for functions and closures."
msgstr "식별자만으로 구성된(선택적으로 `mut`가 붙은) 패턴은 모든 값과 매치되며 그 값을 해당 식별자에 바인딩합니다. 이는 변수 선언과 함수 및 클로저의 매개변수에서 가장 흔히 사용되는 패턴입니다."

#: src/patterns.md:250
msgid ""
"To bind the matched value of a pattern to a variable, use the syntax "
"`variable @ subpattern`. For example, the following binds the value 2 to `e` "
"(not the entire range: the range here is a range subpattern)."
msgstr "패턴의 매치된 값을 변수에 바인딩하려면 `variable @ 서브패턴` 구문을 사용합니다. 예를 들어, 다음은 값 2를 `e`에 바인딩합니다(전체 범위가 아니라, 여기서 범위는 범위 서브패턴입니다)."

#: src/patterns.md:257
msgid "\"got a range element {}\""
msgstr "\"범위 요소 {}를 얻음\""

#: src/patterns.md:258
msgid "\"anything\""
msgstr "\"아무거나\""

#: src/patterns.md:264
msgid ""
"By default, identifier patterns bind a variable to a copy of or move from "
"the matched value depending on whether the matched value implements [`Copy`]"
"(special-types-and-traits.md#copy)."
msgstr "기본적으로 식별자 패턴은 매치된 값이 [`Copy`](special-types-and-traits.md#copy)를 구현하는지 여부에 따라 매치된 값을 복사하거나 이동하여 변수에 바인딩합니다."

#: src/patterns.md:268
msgid ""
"This can be changed to bind to a reference by using the `ref` keyword, or to "
"a mutable reference using `ref mut`. For example:"
msgstr "`ref` 키워드를 사용하여 참조로 바인딩하거나, `ref mut`를 사용하여 가변 참조로 바인딩하도록 변경할 수 있습니다. 예시:"

#: src/patterns.md:283
msgid ""
"In the first match expression, the value is copied (or moved). In the second "
"match, a reference to the same memory location is bound to the variable "
"value. This syntax is needed because in destructuring subpatterns the `&` "
"operator can't be applied to the value's fields. For example, the following "
"is not valid:"
msgstr "첫 번째 match 표현식에서 값은 복사(또는 이동)됩니다. 두 번째 match에서 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 구조 분해 서브패턴에서는 `&` 연산자를 값의 필드에 적용할 수 없기 때문에 이 구문이 필요합니다. 예를 들어, 다음은 유효하지 않습니다:"

#: src/patterns.md:297
msgid "To make it valid, write the following:"
msgstr "이를 유효하게 만들려면 다음과 같이 작성하십시오:"

#: src/patterns.md:310
msgid ""
"Thus, `ref` is not something that is being matched against. Its objective is "
"exclusively to make the matched binding a reference, instead of potentially "
"copying or moving what was matched."
msgstr "따라서 `ref`는 매치 대상이 아닙니다. 이것의 목적은 오로지 매치된 바인딩을 복사하거나 이동하는 대신 참조로 만드는 것입니다."

#: src/patterns.md:315
msgid ""
"[Path patterns](#path-patterns) take precedence over identifier patterns."
msgstr "[경로 패턴](#path-patterns)은 식별자 패턴보다 우선순위가 높습니다."

#: src/patterns.md:319
msgid ""
"It is an error if `ref` or `ref mut` is specified and the identifier shadows "
"a constant."
msgstr "`ref` 또는 `ref mut`가 지정되고 식별자가 상수를 섀도잉하면 오류입니다."

#: src/patterns.md:323
msgid ""
"Identifier patterns are irrefutable if the `@` subpattern is irrefutable or "
"the subpattern is not specified."
msgstr "`@` 서브패턴이 반박 불가능하거나 서브패턴이 지정되지 않은 경우 식별자 패턴은 반박 불가능합니다."

#: src/patterns.md:327
msgid "Binding modes"
msgstr "바인딩 모드"

#: src/patterns.md:331
msgid ""
"To service better ergonomics, patterns operate in different _binding modes_ "
"in order to make it easier to bind references to values. When a reference "
"value is matched by a non-reference pattern, it will be automatically "
"treated as a `ref` or `ref mut` binding. Example:"
msgstr "더 나은 편의성을 제공하기 위해, 패턴은 값에 참조를 더 쉽게 바인딩할 수 있도록 서로 다른 _바인딩 모드_에서 작동합니다. 참조 값이 비참조 패턴에 의해 매치될 때, 자동으로 `ref` 또는 `ref mut` 바인딩으로 취급됩니다. 예시:"

#: src/patterns.md:338
msgid "// y was converted to `ref y` and its type is &i32\n"
msgstr "// y는 `ref y`로 변환되었으며 타입은 &i32입니다\n"

#: src/patterns.md:344
msgid ""
"_Non-reference patterns_ include all patterns except bindings, [wildcard "
"patterns](#wildcard-pattern) (`_`), [`const` patterns](#path-patterns) of "
"reference types, and [reference patterns](#reference-patterns)."
msgstr "_비참조 패턴_에는 바인딩, [와일드카드 패턴](#wildcard-pattern) (`_`), 참조 타입의 [`const` 패턴](#path-patterns), [참조 패턴](#reference-patterns)을 제외한 모든 패턴이 포함됩니다."

#: src/patterns.md:348
msgid ""
"If a binding pattern does not explicitly have `ref`, `ref mut`, or `mut`, "
"then it uses the _default binding mode_ to determine how the variable is "
"bound."
msgstr "바인딩 패턴에 `ref`, `ref mut`, 또는 `mut`가 명시적으로 없는 경우, 변수가 바인딩되는 방식을 결정하기 위해 _기본 바인딩 모드_를 사용합니다."

#: src/patterns.md:352
msgid ""
"The default binding mode starts in \"move\" mode which uses move semantics."
msgstr "기본 바인딩 모드는 이동 시맨틱을 사용하는 \"move\" 모드에서 시작합니다."

#: src/patterns.md:356
msgid ""
"When matching a pattern, the compiler starts from the outside of the pattern "
"and works inwards."
msgstr "패턴을 매치할 때, 컴파일러는 패턴의 바깥쪽에서 시작하여 안쪽으로 진행합니다."

#: src/patterns.md:360
msgid ""
"Each time a reference is matched using a non-reference pattern, it will "
"automatically dereference the value and update the default binding mode."
msgstr "비참조 패턴을 사용하여 참조를 매치할 때마다, 자동으로 값을 역참조하고 기본 바인딩 모드를 업데이트합니다."

#: src/patterns.md:364
msgid "References will set the default binding mode to `ref`."
msgstr "참조는 기본 바인딩 모드를 `ref`로 설정합니다."

#: src/patterns.md:368
msgid ""
"Mutable references will set the mode to `ref mut` unless the mode is already "
"`ref` in which case it remains `ref`."
msgstr "가변 참조는 모드가 이미 `ref`가 아닌 한 `ref mut`로 설정하며, 이미 `ref`인 경우에는 `ref`로 유지됩니다."

#: src/patterns.md:372
msgid ""
"If the automatically dereferenced value is still a reference, it is "
"dereferenced and this process repeats."
msgstr "자동으로 역참조된 값이 여전히 참조인 경우, 다시 역참조되며 이 과정이 반복됩니다."

#: src/patterns.md:376
msgid ""
"The binding pattern may only explicitly specify a `ref` or `ref mut` binding "
"mode, or specify mutability with `mut`, when the default binding mode is "
"\"move\". For example, these are not accepted:"
msgstr "바인딩 패턴은 기본 바인딩 모드가 \"move\"일 때만 `ref` 또는 `ref mut` 바인딩 모드를 명시적으로 지정하거나 `mut`로 가변성을 지정할 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:"

#: src/patterns.md:386
msgid ""
"**Edition differences**: Before the 2024 edition, bindings could explicitly "
"specify a `ref` or `ref mut` binding mode even when the default binding mode "
"was not \"move\", and they could specify mutability on such bindings with "
"`mut`. In these editions, specifying `mut` on a binding set the binding mode "
"to \"move\" regardless of the current default binding mode."
msgstr "**에디션 차이**: 2024 에디션 이전에는 기본 바인딩 모드가 \"move\"가 아닐 때도 바인딩에 `ref` 또는 `ref mut` 바인딩 모드를 명시적으로 지정할 수 있었고, 이러한 바인딩에 `mut`로 가변성을 지정할 수 있었습니다. 이 에디션들에서는 바인딩에 `mut`를 지정하면 현재 기본 바인딩 모드에 상관없이 바인딩 모드가 \"move\"로 설정되었습니다."

#: src/patterns.md:390
msgid ""
"Similarly, a reference pattern may only appear when the default binding mode "
"is \"move\". For example, this is not accepted:"
msgstr "마찬가지로, 참조 패턴은 기본 바인딩 모드가 \"move\"일 때만 나타날 수 있습니다. 예를 들어, 다음은 허용되지 않습니다:"

#: src/patterns.md:398
msgid ""
"**Edition differences**: Before the 2024 edition, reference patterns could "
"appear even when the default binding mode was not \"move\", and had both the "
"effect of matching against the scrutinee and of causing the default binding "
"mode to be reset to \"move\"."
msgstr "**에디션 차이**: 2024 에디션 이전에는 기본 바인딩 모드가 \"move\"가 아닐 때도 참조 패턴이 나타날 수 있었으며, 이는 조사 대상(scrutinee)과 매치되는 효과와 기본 바인딩 모드를 \"move\"로 재설정하는 효과를 모두 가졌습니다."

#: src/patterns.md:402
msgid ""
"Move bindings and reference bindings can be mixed together in the same "
"pattern. Doing so will result in partial move of the object bound to and the "
"object cannot be used afterwards. This applies only if the type cannot be "
"copied."
msgstr "이동 바인딩과 참조 바인딩은 동일한 패턴에서 혼합될 수 있습니다. 이렇게 하면 바인딩된 객체의 부분 이동(partial move)이 발생하며, 해당 객체는 이후에 사용할 수 없습니다. 이는 타입이 복사 가능하지 않은 경우에만 적용됩니다."

#: src/patterns.md:406
msgid ""
"In the example below, `name` is moved out of `person`. Trying to use "
"`person` as a whole or `person.name` would result in an error because of "
"_partial move_."
msgstr "아래 예시에서 `name`은 `person`에서 이동됩니다. `person` 전체를 사용하거나 `person.name`을 사용하려고 하면 _부분 이동_으로 인해 오류가 발생합니다."

#: src/patterns.md:416
msgid "// `name` is moved from person and `age` referenced\n"
msgstr "// `name`은 person에서 이동되고 `age`는 참조됩니다\n"

#: src/patterns.md:423
msgid "Wildcard pattern"
msgstr "와일드카드 패턴"

#: src/patterns.md:427
msgid ""
"**<sup>Syntax</sup>**  \n"
"_WildcardPattern_ :  \n"
"   `_`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_와일드카드패턴_ :  \n"
"   `_`"

#: src/patterns.md:433
msgid ""
"The _wildcard pattern_ (an underscore symbol) matches any value. It is used "
"to ignore values when they don't matter."
msgstr "_와일드카드 패턴_(밑줄 기호)은 모든 값과 매치됩니다. 이는 값이 중요하지 않을 때 값을 무시하는 데 사용됩니다."

#: src/patterns.md:438
msgid ""
"Inside other patterns it matches a single data field (as opposed to the `..` "
"which matches the remaining fields)."
msgstr "다른 패턴 내부에서 이는 단일 데이터 필드와 매치됩니다(나머지 필드들과 매치되는 `..`와 대조적임)."

#: src/patterns.md:442
msgid ""
"Unlike identifier patterns, it does not copy, move or borrow the value it "
"matches."
msgstr "식별자 패턴과 달리, 매치되는 값을 복사, 이동 또는 차용하지 않습니다."

#: src/patterns.md:448
msgid "// the x is always matched by _\n"
msgstr "// x는 항상 _와 매치됩니다\n"

#: src/patterns.md:450
msgid "// ignore a function/closure param\n"
msgstr "// 함수/클로저 매개변수를 무시합니다\n"

#: src/patterns.md:453
msgid "// ignore a field from a struct\n"
msgstr "// 구조체의 필드를 무시합니다\n"

#: src/patterns.md:466
msgid "// accept any Some, with any value\n"
msgstr "// 어떤 값이든 Some이면 허용합니다\n"

#: src/patterns.md:474
msgid "The wildcard pattern is always irrefutable."
msgstr "와일드카드 패턴은 항상 반박 불가능합니다."

#: src/patterns.md:478
msgid "Rest patterns"
msgstr "나머지 패턴"

#: src/patterns.md:480
msgid ""
"**<sup>Syntax</sup>**  \n"
"_RestPattern_ :  \n"
"   `..`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_나머지패턴_ :  \n"
"   `..`"

#: src/patterns.md:486
msgid ""
"The _rest pattern_ (the `..` token) acts as a variable-length pattern which "
"matches zero or more elements that haven't been matched already before and "
"after."
msgstr "_나머지 패턴_(`..` 토큰)은 가변 길이 패턴으로 작동하며, 앞뒤에서 이미 매치되지 않은 0개 이상의 요소와 매치됩니다."

#: src/patterns.md:490
msgid ""
"It may only be used in [tuple](#tuple-patterns), [tuple struct](#tuple-"
"struct-patterns), and [slice](#slice-patterns) patterns, and may only appear "
"once as one of the elements in those patterns. It is also allowed in an "
"[identifier pattern](#identifier-patterns) for [slice patterns](#slice-"
"patterns) only."
msgstr "이는 [튜플](#tuple-patterns), [튜플 구조체](#tuple-struct-patterns), [슬라이스](#slice-patterns) 패턴에서만 사용될 수 있으며, 해당 패턴의 요소 중 하나로 단 한 번만 나타날 수 있습니다. 또한 [슬라이스 패턴](#slice-patterns)에 한해서만 [식별자 패턴](#identifier-patterns)에서도 허용됩니다."

#: src/patterns.md:495
msgid "The rest pattern is always irrefutable."
msgstr "나머지 패턴은 항상 반박 불가능합니다."

#: src/patterns.md:503
msgid "\"slice is empty\""
msgstr "\"슬라이스가 비어 있음\""

#: src/patterns.md:504
msgid "\"single element {}\""
msgstr "\"단일 요소 {}\""

#: src/patterns.md:505
msgid "\"head={} tail={:?}\""
msgstr "\"head={} tail={:?}\""

#: src/patterns.md:509
msgid "// Ignore everything but the last element, which must be \"!\".\n"
msgstr "// \"!\"여야 하는 마지막 요소를 제외한 모든 것을 무시합니다.\n"

#: src/patterns.md:510
msgid "\"!\""
msgstr "\"!\""

#: src/patterns.md:510
msgid "\"!!!\""
msgstr "\"!!!\""

#: src/patterns.md:512
msgid ""
"// `start` is a slice of everything except the last element, which must be "
"\"z\".\n"
msgstr "// `start`는 \"z\"여야 하는 마지막 요소를 제외한 모든 것의 슬라이스입니다.\n"

#: src/patterns.md:513
msgid "\"z\""
msgstr "\"z\""

#: src/patterns.md:513
msgid "\"starts with: {:?}\""
msgstr "\"다음으로 시작함: {:?}\""

#: src/patterns.md:515
msgid ""
"// `end` is a slice of everything but the first element, which must be "
"\"a\".\n"
msgstr "// `end`는 \"a\"여야 하는 첫 번째 요소를 제외한 모든 것의 슬라이스입니다.\n"

#: src/patterns.md:516
msgid "\"ends with: {:?}\""
msgstr "\"다음으로 끝남: {:?}\""

#: src/patterns.md:518
msgid "// 'whole' is the entire slice and `last` is the final element\n"
msgstr "// 'whole'은 전체 슬라이스이고 `last`는 마지막 요소입니다\n"

#: src/patterns.md:519
msgid "\"the last element of {:?} is {}\""
msgstr "\"{:?}의 마지막 요소는 {}입니다\""

#: src/patterns.md:525
msgid "\"next to last is {}\""
msgstr "\"마지막에서 두 번째는 {}입니다\""

#: src/patterns.md:528
msgid "// Rest patterns may also be used in tuple and tuple struct patterns.\n"
msgstr "// 나머지 패턴은 튜플 및 튜플 구조체 패턴에서도 사용될 수 있습니다.\n"

#: src/patterns.md:531
msgid "\"y={} z={}\""
msgstr "\"y={} z={}\""

#: src/patterns.md:532
msgid "\"tail must be 5\""
msgstr "\"꼬리(tail)는 5여야 함\""

#: src/patterns.md:533
msgid "\"matches everything else\""
msgstr "\"그 외 모든 것과 일치함\""

#: src/patterns.md:539
msgid "Range patterns"
msgstr "범위 패턴"

#: src/patterns.md:543
msgid ""
"**<sup>Syntax</sup>**  \n"
"_RangePattern_ :  \n"
"      _RangeInclusivePattern_  \n"
"   | _RangeFromPattern_  \n"
"   | _RangeToInclusivePattern_  \n"
"   | _ObsoleteRangePattern_"
msgstr ""
"**<sup>구문</sup>**  \n"
"_범위패턴_ :  \n"
"      _포함범위패턴_  \n"
"   | _시작범위패턴_  \n"
"   | _끝포함범위패턴_  \n"
"   | _오래된범위패턴_"

#: src/patterns.md:550
msgid ""
"_RangeExclusivePattern_ :  \n"
"      _RangePatternBound_ `..` _RangePatternBound_"
msgstr ""
"_배타범위패턴_ :  \n"
"      _범위패턴경계_ `..` _범위패턴경계_"

#: src/patterns.md:553
msgid ""
"_RangeInclusivePattern_ :  \n"
"      _RangePatternBound_ `..=` _RangePatternBound_"
msgstr ""
"_포함범위패턴_ :  \n"
"      _범위패턴경계_ `..=` _범위패턴경계_"

#: src/patterns.md:556
msgid ""
"_RangeFromPattern_ :  \n"
"      _RangePatternBound_ `..`"
msgstr ""
"_시작범위패턴_ :  \n"
"      _범위패턴경계_ `..`"

#: src/patterns.md:559
msgid ""
"_RangeToInclusivePattern_ :  \n"
"      `..=` _RangePatternBound_"
msgstr ""
"_끝포함범위패턴_ :  \n"
"      `..=` _범위패턴경계_"

#: src/patterns.md:562
msgid ""
"_ObsoleteRangePattern_ :  \n"
"   _RangePatternBound_ `...` _RangePatternBound_"
msgstr ""
"_오래된범위패턴_ :  \n"
"   _범위패턴경계_ `...` _범위패턴경계_"

#: src/patterns.md:565
msgid ""
"_RangePatternBound_ :  \n"
"      [CHAR_LITERAL](tokens.md#character-literals)  \n"
"   | [BYTE_LITERAL](tokens.md#byte-literals)  \n"
"   | `-`<sup>?</sup> [INTEGER_LITERAL](tokens.md#integer-literals)  \n"
"   | `-`<sup>?</sup> [FLOAT_LITERAL](tokens.md#floating-point-literals)  \n"
"   | [_PathExpression_](expressions/path-expr.md)"
msgstr ""
"_범위패턴경계_ :  \n"
"      [문자리터럴](tokens.md#character-literals)  \n"
"   | [바이트리터럴](tokens.md#byte-literals)  \n"
"   | `-`<sup>?</sup> [정수리터럴](tokens.md#integer-literals)  \n"
"   | `-`<sup>?</sup> [부동소수점리터럴](tokens.md#floating-point-literals)  \n"
"   | [_경로표현식_](expressions/path-expr.md)"

#: src/patterns.md:574
msgid ""
"_Range patterns_ match scalar values within the range defined by their "
"bounds. They comprise a _sigil_ (one of `..`, `..=`, or `...`) and a bound "
"on one or both sides."
msgstr "_범위 패턴_은 경계로 정의된 범위 내의 스칼라 값과 매치됩니다. 이들은 _기호(sigil)_(`..`, `..=`, `...` 중 하나)와 한쪽 또는 양쪽의 경계로 구성됩니다."

#: src/patterns.md:579
msgid "A bound on the left of the sigil is a _lower bound_."
msgstr "기호 왼쪽의 경계는 _하한(lower bound)_입니다."

#: src/patterns.md:583
msgid "A bound on the right is an _upper bound_."
msgstr "오른쪽의 경계는 _상한(upper bound)_입니다."

#: src/patterns.md:587
msgid ""
"A range pattern with both a lower and upper bound will match all values "
"between and including both of its bounds. It is written as its lower bound, "
"followed by `..` for end-exclusive or `..=` for end-inclusive, followed by "
"its upper bound."
msgstr "하한과 상한을 모두 가진 범위 패턴은 두 경계 사이의 모든 값(경계 포함)과 매치됩니다. 이는 하한 뒤에 끝을 제외하는 `..` 또는 끝을 포함하는 `..=`가 오고, 그 뒤에 상한이 오는 방식으로 작성됩니다."

#: src/patterns.md:592
msgid ""
"The type of the range pattern is the type unification of its upper and lower "
"bounds."
msgstr "범위 패턴의 타입은 상한과 하한 타입의 통합된 타입입니다."

#: src/patterns.md:594
msgid ""
"For example, a pattern `'m'..='p'` will match only the values `'m'`, `'n'`, "
"`'o'`, and `'p'`. Similarly, `'m'..'p'` will match only `'m'`, `'n'` and "
"`'o'`, specifically **not** including `'p'`."
msgstr "예를 들어, `'m'..='p'` 패턴은 `'m'`, `'n'`, `'o'`, `'p'` 값과만 매치됩니다. 마찬가지로 `'m'..'p'`는 `'m'`, `'n'`, `'o'`와만 매치되며, 특히 `'p'`는 포함되지 **않습니다**."

#: src/patterns.md:599
msgid ""
"The lower bound cannot be greater than the upper bound. That is, in `a..=b`, "
"a ≤ b must be the case. For example, it is an error to have a range pattern "
"`10..=0`."
msgstr "하한은 상한보다 클 수 없습니다. 즉, `a..=b`에서 a ≤ b여야 합니다. 예를 들어, `10..=0`과 같은 범위 패턴은 오류입니다."

#: src/patterns.md:605
msgid ""
"A range pattern with only a lower bound will match any value greater than or "
"equal to the lower bound. It is written as its lower bound followed by `..`, "
"and has the same type as its lower bound. For example, `1..` will match 1, "
"9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not "
"0, and not negative numbers for signed integers."
msgstr "하한만 있는 범위 패턴은 하한보다 크거나 같은 모든 값과 매치됩니다. 이는 하한 뒤에 `..`가 오는 방식으로 작성되며, 하한과 동일한 타입을 갖습니다. 예를 들어, `1..`은 1, 9, 9001, 또는 (적절한 크기인 경우) 9007199254740991과 매치되지만, 0이나 부호 있는 정수의 경우 음수와는 매치되지 않습니다."

#: src/patterns.md:611
msgid ""
"A range pattern with only an upper bound matches any value less than or "
"equal to the upper bound. It is written as `..=` followed by its upper "
"bound, and has the same type as its upper bound. For example, `..=10` will "
"match 10, 1, 0, and for signed integer types, all negative values."
msgstr "상한만 있는 범위 패턴은 상한보다 작거나 같은 모든 값과 매치됩니다. 이는 `..=` 뒤에 상한이 오는 방식으로 작성되며, 상한과 동일한 타입을 갖습니다. 예를 들어, `..=10`은 10, 1, 0, 그리고 부호 있는 정수 타입의 경우 모든 음수 값과 매치됩니다."

#: src/patterns.md:617
msgid ""
"Range patterns with only one bound cannot be used as the top-level pattern "
"for subpatterns in [slice patterns](#slice-patterns)."
msgstr "하나의 경계만 있는 범위 패턴은 [슬라이스 패턴](#slice-patterns)의 서브패턴에서 최상위 패턴으로 사용될 수 없습니다."

#: src/patterns.md:621
msgid "The bounds is written as one of:"
msgstr "경계는 다음 중 하나로 작성됩니다:"

#: src/patterns.md:623
msgid "A character, byte, integer, or float literal."
msgstr "문자, 바이트, 정수 또는 부동 소수점 리터럴."

#: src/patterns.md:624
msgid "A `-` followed by an integer or float literal."
msgstr "정수 또는 부동 소수점 리터럴 앞에 `-`가 붙은 형태."

#: src/patterns.md:625
msgid "A [path](expressions/path-expr.md)"
msgstr "[경로](expressions/path-expr.md)"

#: src/patterns.md:629
msgid ""
"If the bounds is written as a path, after macro resolution, the path must "
"resolve to a constant item of the type `char`, an integer type, or a float "
"type."
msgstr "경계가 경로로 작성된 경우, 매크로 확인 후에 해당 경로는 `char`, 정수 타입 또는 부동 소수점 타입의 상수 아이템으로 해석되어야 합니다."

#: src/patterns.md:633
msgid ""
"The type and value of the bounds is dependent upon how it is written out."
msgstr "경계의 타입과 값은 그것이 어떻게 작성되었느냐에 따라 달라집니다."

#: src/patterns.md:637
msgid ""
"If the bounds is a [path](expressions/path-expr.md), the pattern has the "
"type and value of the [constant](items/constant-items.md) the path resolves "
"to."
msgstr "경계가 [경로](expressions/path-expr.md)인 경우, 패턴은 해당 경로가 해석되는 [상수](items/constant-items.md)의 타입과 값을 갖습니다."

#: src/patterns.md:641
msgid "For float range patterns, the constant may not be a `NaN`."
msgstr "부동 소수점 범위 패턴의 경우, 상수는 `NaN`일 수 없습니다."

#: src/patterns.md:645
msgid ""
"If it is a literal, it has the type and value of the corresponding [literal "
"expression](expressions/literal-expr.md)."
msgstr "리터럴인 경우, 해당 [리터럴 표현식](expressions/literal-expr.md)의 타입과 값을 갖습니다."

#: src/patterns.md:649
msgid ""
"If is a literal preceded by a `-`, it has the same type as the corresponding "
"[literal expression](expressions/literal-expr.md) and the value of [negating]"
"(expressions/operator-expr.md#negation-operators) the value of the "
"corresponding literal expression."
msgstr "리터럴 앞에 `-`가 붙은 경우, 해당 [리터럴 표현식](expressions/literal-expr.md)과 동일한 타입을 가지며, 해당 리터럴 표현식의 값을 [부정한(negating)](expressions/operator-expr.md#negation-operators) 값을 갖습니다."

#: src/patterns.md:654
msgid "'f'"
msgstr "'f'"

#: src/patterns.md:656
msgid "'a'"
msgstr "'a'"

#: src/patterns.md:656
msgid "'z'"
msgstr "'z'"

#: src/patterns.md:657
msgid "'Z'"
msgstr "'Z'"

#: src/patterns.md:658
msgid "'α'"
msgstr "'α'"

#: src/patterns.md:658
msgid "'ω'"
msgstr "'ω'"

#: src/patterns.md:664
msgid "\"acid\""
msgstr "\"산성\""

#: src/patterns.md:665
msgid "\"neutral\""
msgstr "\"중성\""

#: src/patterns.md:666
msgid "\"base\""
msgstr "\"염기성\""

#: src/patterns.md:672
msgid "\"zero!\""
msgstr "\"0입니다!\""

#: src/patterns.md:673
msgid "\"positive number!\""
msgstr "\"양수입니다!\""

#: src/patterns.md:675
msgid "// using paths to constants:\n"
msgstr "// 상수에 대한 경로 사용:\n"

#: src/patterns.md:689
msgid "\"troposphere\""
msgstr "\"대류권\""

#: src/patterns.md:690
msgid "\"stratosphere\""
msgstr "\"성층권\""

#: src/patterns.md:691
msgid "\"mesosphere\""
msgstr "\"중간권\""

#: src/patterns.md:692
msgid "\"outer space, maybe\""
msgstr "\"아마도 외계 공간\""

#: src/patterns.md:702
msgid "\"It fits and occupies {} bytes\""
msgstr "\"크기가 적절하며 {}바이트를 차지함\""

#: src/patterns.md:716
msgid "// using qualified paths:\n"
msgstr "// 정규화된 경로 사용:\n"

#: src/patterns.md:719
msgid "\"fits in a u8\""
msgstr "\"u8에 맞음\""

#: src/patterns.md:720
msgid "\"fits in a u16\""
msgstr "\"u16에 맞음\""

#: src/patterns.md:721
msgid "\"fits in a u32\""
msgstr "\"u32에 맞음\""

#: src/patterns.md:722
msgid "\"too big\""
msgstr "\"너무 큼\""

#: src/patterns.md:728
msgid ""
"Range patterns for fix-width integer and `char` types are irrefutable when "
"they span the entire set of possible values of a type. For example, "
"`0u8..=255u8` is irrefutable."
msgstr "고정 너비 정수 및 `char` 타입에 대한 범위 패턴이 타입의 가능한 모든 값 세트를 포괄하는 경우 반박 불가능(irrefutable)합니다. 예를 들어, `0u8..=255u8`은 반박 불가능합니다."

#: src/patterns.md:733
msgid ""
"The range of values for an integer type is the closed range from its minimum "
"to maximum value."
msgstr "정수 타입의 값 범위는 최소값부터 최대값까지의 닫힌 범위입니다."

#: src/patterns.md:737
msgid ""
"The range of values for a `char` type are precisely those ranges containing "
"all Unicode Scalar Values: `'\\u{0000}'..='\\u{D7FF}'` and "
"`'\\u{E000}'..='\\u{10FFFF}'`."
msgstr "`char` 타입의 값 범위는 정확히 모든 유니코드 스칼라 값을 포함하는 범위인 `'\\u{0000}'..='\\u{D7FF}'`와 `'\\u{E000}'..='\\u{10FFFF}'`입니다."

#: src/patterns.md:741
msgid ""
"**Edition differences**: Before the 2021 edition, range patterns with both a "
"lower and upper bound may also be written using `...` in place of `..=`, "
"with the same meaning."
msgstr "**에디션 차이**: 2021 에디션 이전에는 하한과 상한을 모두 가진 범위 패턴을 `..=` 대신 `...`를 사용하여 동일한 의미로 작성할 수도 있었습니다."

#: src/patterns.md:745
msgid "Reference patterns"
msgstr "참조 패턴"

#: src/patterns.md:749
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ReferencePattern_ :  \n"
"   (`&`\\|`&&`) `mut`<sup>?</sup> [_PatternWithoutRange_](#patterns)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_참조패턴_ :  \n"
"   (`&`|`&&`) `mut`<sup>?</sup> [_범위없는패턴_](#patterns)"

#: src/patterns.md:755
msgid ""
"Reference patterns dereference the pointers that are being matched and, "
"thus, borrow them."
msgstr "참조 패턴은 매치되는 포인터를 역참조하며, 따라서 이를 차용합니다."

#: src/patterns.md:757
msgid "For example, these two matches on `x: &i32` are equivalent:"
msgstr "예를 들어, `x: &i32`에 대한 다음 두 매치는 동일합니다:"

#: src/patterns.md:762 src/patterns.md:763
msgid "\"zero\""
msgstr "\"0\""

#: src/patterns.md:762 src/patterns.md:763
msgid "\"some\""
msgstr "\"some\""

#: src/patterns.md:770
msgid ""
"The grammar production for reference patterns has to match the token `&&` to "
"match a reference to a reference because it is a token by itself, not two "
"`&` tokens."
msgstr "참조 패턴에 대한 문법 생성물은 참조의 참조를 매치하기 위해 `&&` 토큰과 매치되어야 합니다. 이는 그 자체로 하나의 토큰이며, 두 개의 `&` 토큰이 아니기 때문입니다."

#: src/patterns.md:774
msgid ""
"Adding the `mut` keyword dereferences a mutable reference. The mutability "
"must match the mutability of the reference."
msgstr "`mut` 키워드를 추가하면 가변 참조를 역참조합니다. 가변성은 참조의 가변성과 일치해야 합니다."

#: src/patterns.md:778
msgid "Reference patterns are always irrefutable."
msgstr "참조 패턴은 항상 반박 불가능합니다."

#: src/patterns.md:782
msgid "Struct patterns"
msgstr "구조체 패턴"

#: src/patterns.md:786
msgid ""
"**<sup>Syntax</sup>**  \n"
"_StructPattern_ :  \n"
"   [_PathInExpression_](paths.md#paths-in-expressions) `{`  \n"
"      _StructPatternElements_ <sup>?</sup>  \n"
"   `}`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_구조체패턴_ :  \n"
"   [_표현식내경로_](paths.md#paths-in-expressions) `{`  \n"
"      _구조체패턴요소_ <sup>?</sup>  \n"
"   `}`"

#: src/patterns.md:792
msgid ""
"_StructPatternElements_ :  \n"
"      _StructPatternFields_ (`,` | `,` _StructPatternEtCetera_)<sup>?</"
"sup>  \n"
"   | _StructPatternEtCetera_"
msgstr ""
"_구조체패턴요소_ :  \n"
"      _구조체패턴필드_ (`,` | `,` _구조체패턴기타_)<sup>?</sup>  \n"
"   | _구조체패턴기타_"

#: src/patterns.md:796
msgid ""
"_StructPatternFields_ :  \n"
"   _StructPatternField_ (`,` _StructPatternField_) <sup>\\*</sup>"
msgstr ""
"_구조체패턴필드_ :  \n"
"   _구조체패턴필드_ (`,` _구조체패턴필드_) <sup>*</sup>"

#: src/patterns.md:799
msgid ""
"_StructPatternField_ :  \n"
"   [_OuterAttribute_](attributes.md) <sup>\\*</sup>  \n"
"   (  \n"
"         [TUPLE_INDEX](tokens.md#tuple-index) `:` [_Pattern_](#patterns)  \n"
"      | [IDENTIFIER](identifiers.md) `:` [_Pattern_](#patterns)  \n"
"      | `ref`<sup>?</sup> `mut`<sup>?</sup> [IDENTIFIER](identifiers.md)  \n"
"   )"
msgstr ""
"_구조체패턴필드_ :  \n"
"   [_외부속성_](attributes.md) <sup>*</sup>  \n"
"   (  \n"
"         [튜플인덱스](tokens.md#tuple-index) `:` [_패턴_](#patterns)  \n"
"      | [식별자](identifiers.md) `:` [_패턴_](#patterns)  \n"
"      | `ref`<sup>?</sup> `mut`<sup>?</sup> [식별자](identifiers.md)  \n"
"   )"

#: src/patterns.md:807
msgid ""
"_StructPatternEtCetera_ :  \n"
"   `..`"
msgstr ""
"_구조체패턴기타_ :  \n"
"   `..`"

#: src/patterns.md:815
msgid ""
"Struct patterns match struct, enum, and union values that match all criteria "
"defined by its subpatterns. They are also used to [destructure]"
"(#destructuring) a struct, enum, or union value."
msgstr "구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 구조체, 열거형 및 공용체 값과 매치됩니다. 또한 구조체, 열거형 또는 공용체 값을 [구조 분해](#destructuring)하는 데 사용됩니다."

#: src/patterns.md:820
msgid ""
"On a struct pattern, the fields are referenced by name, index (in the case "
"of tuple structs) or ignored by use of `..`:"
msgstr "구조체 패턴에서 필드는 이름이나 인덱스(튜플 구조체의 경우)로 참조되거나 `..`을 사용하여 무시됩니다."

#: src/patterns.md:831 src/patterns.md:844
msgid "// order doesn't matter\n"
msgstr "// 순서는 중요하지 않음\n"

#: src/patterns.md:864
msgid ""
"If `..` is not used, a struct pattern used to match a struct is required to "
"specify all fields:"
msgstr "`..`이 사용되지 않으면, 구조체를 매치하는 데 사용되는 구조체 패턴은 모든 필드를 명시해야 합니다."

#: src/patterns.md:872 src/patterns.md:875 src/patterns.md:876
#: src/patterns.md:877 src/patterns.md:878 src/patterns.md:897
msgid "'X'"
msgstr "'X'"

#: src/patterns.md:885
msgid ""
"A struct pattern used to match a union must specify exactly one field (see "
"[Pattern matching on unions](items/unions.md#pattern-matching-on-unions))."
msgstr "공용체(union)를 매치하는 데 사용되는 구조체 패턴은 정확히 하나의 필드만 지정해야 합니다 ([공용체에서의 패턴 매칭](items/unions.md#pattern-matching-on-unions) 참조)。"

#: src/patterns.md:889
msgid ""
"The `ref` and/or `mut` _IDENTIFIER_ syntax matches any value and binds it to "
"a variable with the same name as the given field."
msgstr "`ref` 및/또는 `mut` _식별자_ 구문은 모든 값과 매치되며, 주어진 필드와 동일한 이름을 가진 변수에 바인딩합니다."

#: src/patterns.md:899
msgid "// destructure all fields\n"
msgstr "// 모든 필드 구조 분해\n"

#: src/patterns.md:904
msgid ""
"A struct pattern is refutable if the _PathInExpression_ resolves to a "
"constructor of an enum with more than one variant, or one of its subpatterns "
"is refutable."
msgstr "_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다."

#: src/patterns.md:908
msgid "Tuple struct patterns"
msgstr "튜플 구조체 패턴"

#: src/patterns.md:912
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TupleStructPattern_ :  \n"
"   [_PathInExpression_](paths.md#paths-in-expressions) `(` "
"_TupleStructItems_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_튜플구조체패턴_ :  \n"
"   [_표현식내경로_](paths.md#paths-in-expressions) `(` _튜플구조체항목_ <sup>?</sup> `)`"

#: src/patterns.md:916
msgid ""
"_TupleStructItems_ :  \n"
"   [_Pattern_](#patterns) ( `,` [_Pattern_](#patterns) )<sup>\\*</sup> "
"`,`<sup>?</sup>"
msgstr ""
"_튜플구조체항목_ :  \n"
"   [_패턴_](#patterns) ( `,` [_패턴_](#patterns) ) <sup>*</sup> `,` <sup>?</sup>"

#: src/patterns.md:921
msgid ""
"Tuple struct patterns match tuple struct and enum values that match all "
"criteria defined by its subpatterns. They are also used to [destructure]"
"(#destructuring) a tuple struct or enum value."
msgstr "튜플 구조체 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 구조체 및 열거형 값과 매치됩니다. 또한 튜플 구조체 또는 열거형 값을 [구조 분해](#destructuring)하는 데 사용됩니다."

#: src/patterns.md:926
msgid ""
"A tuple struct pattern is refutable if the _PathInExpression_ resolves to a "
"constructor of an enum with more than one variant, or one of its subpatterns "
"is refutable."
msgstr "_표현식내경로_가 둘 이상의 변형을 가진 열거형의 생성자로 해석되거나, 서브패턴 중 하나가 반박 가능한 경우 튜플 구조체 패턴은 반박 가능합니다."

#: src/patterns.md:930
msgid "Tuple patterns"
msgstr "튜플 패턴"

#: src/patterns.md:934
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TuplePattern_ :  \n"
"   `(` _TuplePatternItems_<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_튜플패턴_ :  \n"
"   `(` _튜플패턴항목_ <sup>?</sup> `)`"

#: src/patterns.md:938
msgid ""
"_TuplePatternItems_ :  \n"
"      [_Pattern_](#patterns) `,`  \n"
"   | [_RestPattern_](#rest-patterns)  \n"
"   | [_Pattern_](#patterns) (`,` [_Pattern_](#patterns))<sup>+</sup> "
"`,`<sup>?</sup>"
msgstr ""
"_튜플패턴항목_ :  \n"
"      [_패턴_](#patterns) `,`  \n"
"   | [_나머지패턴_](#rest-patterns)  \n"
"   | [_패턴_](#patterns) ( `,` [_패턴_](#patterns) ) <sup>+</sup> `,` <sup>?</sup>"

#: src/patterns.md:945
msgid ""
"Tuple patterns match tuple values that match all criteria defined by its "
"subpatterns. They are also used to [destructure](#destructuring) a tuple."
msgstr "튜플 패턴은 서브패턴에 의해 정의된 모든 기준을 만족하는 튜플 값과 매치됩니다. 또한 튜플을 [구조 분해](#destructuring)하는 데 사용됩니다."

#: src/patterns.md:950
msgid ""
"The form `(..)` with a single [_RestPattern_](#rest-patterns) is a special "
"form that does not require a comma, and matches a tuple of any size."
msgstr "단일 [_나머지 패턴_](#rest-patterns)을 포함하는 `(..)` 형식은 쉼표가 필요하지 않은 특별한 형식으로, 모든 크기의 튜플과 매치됩니다."

#: src/patterns.md:954
msgid ""
"The tuple pattern is refutable when one of its subpatterns is refutable."
msgstr "튜플 패턴은 서브패턴 중 하나가 반박 가능한 경우 반박 가능합니다."

#: src/patterns.md:956
msgid "An example of using tuple patterns:"
msgstr "튜플 패턴 사용 예시:"

#: src/patterns.md:968
msgid "Grouped patterns"
msgstr "그룹화된 패턴"

#: src/patterns.md:972
msgid ""
"**<sup>Syntax</sup>**  \n"
"_GroupedPattern_ :  \n"
"   `(` [_Pattern_](#patterns) `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_그룹화된패턴_ :  \n"
"   `(` [_패턴_](#patterns) `)`"

#: src/patterns.md:978
msgid ""
"Enclosing a pattern in parentheses can be used to explicitly control the "
"precedence of compound patterns. For example, a reference pattern next to a "
"range pattern such as `&0..=5` is ambiguous and is not allowed, but can be "
"expressed with parentheses."
msgstr "패턴을 괄호로 묶으면 복합 패턴의 우선순위를 명시적으로 제어할 수 있습니다. 예를 들어, `&0..=5`와 같이 참조 패턴이 범위 패턴 옆에 오는 것은 모호하여 허용되지 않지만, 괄호를 사용하여 표현할 수 있습니다."

#: src/patterns.md:991
msgid "Slice patterns"
msgstr "슬라이스 패턴"

#: src/patterns.md:995
msgid ""
"**<sup>Syntax</sup>**  \n"
"_SlicePattern_ :  \n"
"   `[` _SlicePatternItems_<sup>?</sup> `]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_슬라이스패턴_ :  \n"
"   `[` _슬라이스패턴항목_ <sup>?</sup> `]`"

#: src/patterns.md:999
msgid ""
"_SlicePatternItems_ :  \n"
"   [_Pattern_](#patterns) (`,` [_Pattern_](#patterns))<sup>\\*</sup> "
"`,`<sup>?</sup>"
msgstr ""
"_슬라이스패턴항목_ :  \n"
"   [_패턴_](#patterns) ( `,` [_패턴_](#patterns) ) <sup>*</sup> `,` <sup>?</sup>"

#: src/patterns.md:1004
msgid ""
"Slice patterns can match both arrays of fixed size and slices of dynamic "
"size."
msgstr "슬라이스 패턴은 고정 크기 배열과 동적 크기 슬라이스 모두와 매치될 수 있습니다."

#: src/patterns.md:1007
msgid "// Fixed size\n"
msgstr "// 고정 크기\n"

#: src/patterns.md:1010
msgid "\"starts with one\""
msgstr "\"1로 시작함\""

#: src/patterns.md:1011
msgid "\"starts with something else\""
msgstr "\"다른 것으로 시작함\""

#: src/patterns.md:1015
msgid "// Dynamic size\n"
msgstr "// 동적 크기\n"

#: src/patterns.md:1018
msgid "/* this arm will not apply because the length doesn't match */"
msgstr "/* 이 암(arm)은 길이가 일치하지 않으므로 적용되지 않습니다 */"

#: src/patterns.md:1019
msgid "/* this arm will apply */"
msgstr "/* 이 암(arm)이 적용됩니다 */"

#: src/patterns.md:1020
msgid ""
"/* this wildcard is required, since the length is not known statically */"
msgstr "/* 길이를 정적으로 알 수 없으므로 이 와일드카드가 필요합니다 */"

#: src/patterns.md:1026
msgid ""
"Slice patterns are irrefutable when matching an array as long as each "
"element is irrefutable."
msgstr "슬라이스 패턴은 배열을 매치할 때 각 요소가 반박 불가능하다면 반박 불가능합니다."

#: src/patterns.md:1030
msgid ""
"When matching a slice, it is irrefutable only in the form with a single `..` "
"[rest pattern](#rest-patterns) or [identifier pattern](#identifier-patterns) "
"with the `..` rest pattern as a subpattern."
msgstr "슬라이스를 매치할 때, 단일 `..` [나머지 패턴](#rest-patterns)이거나 `..` 나머지 패턴을 서브패턴으로 가진 [식별자 패턴](#identifier-patterns) 형식인 경우에만 반박 불가능합니다."

#: src/patterns.md:1034
msgid ""
"Within a slice, a range pattern without both lower and upper bound must be "
"enclosed in parentheses, as in `(a..)`, to clarify it is intended to match "
"against a single slice element. A range pattern with both lower and upper "
"bound, like `a..=b`, is not required to be enclosed in parentheses."
msgstr "슬라이스 내에서 하한과 상한이 모두 있지 않은 범위 패턴은 단일 슬라이스 요소와 매치하려는 의도임을 명확히 하기 위해 `(a..)`와 같이 괄호로 묶어야 합니다. `a..=b`와 같이 하한과 상한이 모두 있는 범위 패턴은 괄호로 묶을 필요가 없습니다."

#: src/patterns.md:1039
msgid "Path patterns"
msgstr "경로 패턴"

#: src/patterns.md:1043
msgid ""
"**<sup>Syntax</sup>**  \n"
"_PathPattern_ :  \n"
"      [_PathExpression_](expressions/path-expr.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_경로패턴_ :  \n"
"      [_경로표현식_](expressions/path-expr.md)"

#: src/patterns.md:1049
msgid ""
"_Path patterns_ are patterns that refer either to constant values or to "
"structs or enum variants that have no fields."
msgstr "_경로 패턴_은 상수 값이나 필드가 없는 구조체 또는 열거형 변형을 참조하는 패턴입니다."

#: src/patterns.md:1054
msgid "Unqualified path patterns can refer to:"
msgstr "수식되지 않은(unqualified) 경로 패턴은 다음을 참조할 수 있습니다:"

#: src/patterns.md:1056
msgid "enum variants"
msgstr "열거형 변형"

#: src/patterns.md:1057
msgid "structs"
msgstr "구조체"

#: src/patterns.md:1058
msgid "constants"
msgstr "상수"

#: src/patterns.md:1059
msgid "associated constants"
msgstr "연관 상수"

#: src/patterns.md:1063
msgid "Qualified path patterns can only refer to associated constants."
msgstr "수식된(qualified) 경로 패턴은 연관 상수만 참조할 수 있습니다."

#: src/patterns.md:1067
msgid ""
"Path patterns are irrefutable when they refer to structs or an enum variant "
"when the enum has only one variant or a constant whose type is irrefutable. "
"They are refutable when they refer to refutable constants or enum variants "
"for enums with multiple variants."
msgstr "경로 패턴은 구조체를 참조하거나, 열거형이 단 하나의 변형만 가질 때 해당 열거형 변형을 참조하거나, 타입이 반박 불가능한 상수를 참조할 때 반박 불가능합니다. 여러 변형을 가진 열거형의 변형이나 반박 가능한 상수를 참조할 때는 반박 가능합니다."

#: src/patterns.md:1072
msgid "Constant patterns"
msgstr "상수 패턴"

#: src/patterns.md:1076
msgid ""
"When a constant `C` of type `T` is used as a pattern, we first check that "
"`T: PartialEq`."
msgstr "`T` 타입의 상수 `C`가 패턴으로 사용될 때, 먼저 `T: PartialEq`인지 확인합니다."

#: src/patterns.md:1080
msgid ""
"Furthermore we require that the value of `C` _has (recursive) structural "
"equality_, which is defined recursively as follows:"
msgstr "나아가 상수 `C`의 값이 _(재귀적) 구조적 동등성_을 가져야 하며, 이는 다음과 같이 재귀적으로 정의됩니다:"

#: src/patterns.md:1084
msgid ""
"Integers as well as `str`, `bool` and `char` values always have structural "
"equality."
msgstr "정수뿐만 아니라 `str`, `bool`, `char` 값은 항상 구조적 동등성을 갖습니다."

#: src/patterns.md:1088
msgid ""
"Tuples, arrays, and slices have structural equality if all their fields/"
"elements have structural equality. (In particular, `()` and `[]` always have "
"structural equality.)"
msgstr "튜플, 배열, 슬라이스는 모든 필드/요소가 구조적 동등성을 가지면 구조적 동등성을 갖습니다. (특히, `()`와 `[]`는 항상 구조적 동등성을 갖습니다.)"

#: src/patterns.md:1093
msgid ""
"References have structural equality if the value they point to has "
"structural equality."
msgstr "참조는 가리키는 값이 구조적 동등성을 가지면 구조적 동등성을 갖습니다."

#: src/patterns.md:1097
msgid ""
"A value of `struct` or `enum` type has structural equality if its "
"`PartialEq` instance is derived via `#[derive(PartialEq)]`, and all fields "
"(for enums: of the active variant) have structural equality."
msgstr "`struct` 또는 `enum` 타입의 값은 `PartialEq` 인스턴스가 `#[derive(PartialEq)]`를 통해 파생되었고, 모든 필드(열거형의 경우 현재 활성화된 변형의 필드)가 구조적 동등성을 가지면 구조적 동등성을 갖습니다."

#: src/patterns.md:1102
msgid ""
"A raw pointer has structural equality if it was defined as a constant "
"integer (and then cast/transmuted)."
msgstr "원시 포인터는 상수 정수로 정의된 경우(그 후 캐스팅되거나 transmute된 경우) 구조적 동등성을 갖습니다."

#: src/patterns.md:1106
msgid "A float value has structural equality if it is not a `NaN`."
msgstr "부동 소수점 값은 `NaN`이 아니면 구조적 동등성을 갖습니다."

#: src/patterns.md:1110
msgid "Nothing else has structural equality."
msgstr "그 외에는 구조적 동등성을 갖지 않습니다."

#: src/patterns.md:1114
msgid ""
"In particular, the value of `C` must be known at pattern-building time "
"(which is pre-monomorphization). This means that associated consts that "
"involve generic parameters cannot be used as patterns."
msgstr "특히, 상수 `C`의 값은 패턴 구축 시점(단형성화(monomorphization) 이전)에 알려져야 합니다. 이는 제네릭 파라미터가 포함된 연관 상수는 패턴으로 사용될 수 없음을 의미합니다."

#: src/patterns.md:1119
msgid ""
"After ensuring all conditions are met, the constant value is translated into "
"a pattern, and now behaves exactly as-if that pattern had been written "
"directly. In particular, it fully participates in exhaustiveness checking. "
"(For raw pointers, constants are the only way to write such patterns. Only "
"`_` is ever considered exhaustive for these types.)"
msgstr "모든 조건이 충족되면, 상수 값은 패턴으로 번역되며 이제 해당 패턴을 직접 작성한 것과 정확히 동일하게 동작합니다. 특히, 이는 망라성 검사(exhaustiveness checking)에 완전히 참여합니다. (원시 포인터의 경우, 상수가 이러한 패턴을 작성하는 유일한 방법입니다. 이러한 타입들에 대해서는 오직 `_`만이 망라적인 것으로 간주됩니다.)"

#: src/patterns.md:1125
msgid "Or-patterns"
msgstr "Or 패턴"

#: src/patterns.md:1127
msgid ""
"_Or-patterns_ are patterns that match on one of two or more sub-patterns "
"(for example `A | B | C`). They can nest arbitrarily. Syntactically, or-"
"patterns are allowed in any of the places where other patterns are allowed "
"(represented by the _Pattern_ production), with the exceptions of `let`\\-"
"bindings and function and closure arguments (represented by the "
"_PatternNoTopAlt_ production)."
msgstr "_Or 패턴_은 둘 이상의 서브패턴 중 하나와 매치되는 패턴입니다(예: `A | B | C`). 이들은 임의로 중첩될 수 있습니다. 구문상으로 Or 패턴은 다른 패턴이 허용되는 모든 위치(_패턴_ 생성물로 표현됨)에서 허용되지만, `let` 바인딩과 함수 및 클로저의 인자(_최상위대안없는패턴_ 생성물로 표현됨)는 제외됩니다."

#: src/patterns.md:1133
msgid "Static semantics"
msgstr "정적 시맨틱"

#: src/patterns.md:1137
msgid ""
"Given a pattern `p | q` at some depth for some arbitrary patterns `p` and "
"`q`, the pattern is considered ill-formed if:"
msgstr "임의의 패턴 `p`와 `q`에 대해 어떤 깊이에서든 `p | q` 패턴이 주어졌을 때, 다음의 경우 해당 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다:"

#: src/patterns.md:1139
msgid ""
"the type inferred for `p` does not unify with the type inferred for `q`, or"
msgstr "`p`에 대해 추론된 타입이 `q`에 대해 추론된 타입과 통합(unify)되지 않거나,"

#: src/patterns.md:1140
msgid "the same set of bindings are not introduced in `p` and `q`, or"
msgstr "`p`와 `q`에서 동일한 바인딩 집합이 도입되지 않거나,"

#: src/patterns.md:1141
msgid ""
"the type of any two bindings with the same name in `p` and `q` do not unify "
"with respect to types or binding modes."
msgstr "`p`와 `q`에 있는 동일한 이름의 두 바인딩 타입이 타입 또는 바인딩 모드 관점에서 통합되지 않는 경우."

#: src/patterns.md:1143
msgid ""
"Unification of types is in all instances aforementioned exact and implicit "
"[type coercions](type-coercions.md) do not apply."
msgstr "타입 통합은 모든 인스턴스에서 앞서 언급한 대로 정확해야 하며, 암시적인 [타입 강제 변환](type-coercions.md)은 적용되지 않습니다."

#: src/patterns.md:1147
msgid ""
"When type checking an expression `match e_s { a_1 => e_1, ... a_n => e_n }`, "
"for each match arm `a_i` which contains a pattern of form `p_i | q_i`, the "
"pattern `p_i | q_i` is considered ill formed if, at the depth `d` where it "
"exists the fragment of `e_s` at depth `d`, the type of the expression "
"fragment does not unify with `p_i | q_i`."
msgstr "`match e_s { a_1 => e_1, ... a_n => e_n }` 표현식을 타입 검사할 때, `p_i | q_i` 형식의 패턴을 포함하는 각 매치 암 `a_i`에 대해, 해당 패턴이 존재하는 깊이 `d`에서 `e_s`의 깊이 `d` 조각의 타입이 `p_i | q_i`와 통합(unify)되지 않으면 `p_i | q_i` 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다."

#: src/patterns.md:1155
msgid ""
"With respect to exhaustiveness checking, a pattern `p | q` is considered to "
"cover `p` as well as `q`. For some constructor `c(x, ..)` the distributive "
"law applies such that `c(p | q, ..rest)` covers the same set of value as "
"`c(p, ..rest) | c(q, ..rest)` does. This can be applied recursively until "
"there are no more nested patterns of form `p | q` other than those that "
"exist at the top level."
msgstr "망라성 검사와 관련하여, `p | q` 패턴은 `p`와 `q`를 모두 포괄하는 것으로 간주됩니다. 어떤 생성자 `c(x, ..)`에 대해 분배 법칙이 적용되어, `c(p | q, ..rest)`는 `c(p, ..rest) | c(q, ..rest)`와 동일한 값 집합을 포괄합니다. 이는 최상위 레벨에 존재하는 패턴을 제외하고 `p | q` 형식의 중첩된 패턴이 더 이상 없을 때까지 재귀적으로 적용될 수 있습니다."

#: src/patterns.md:1159
msgid ""
"Note that by _\"constructor\"_ we do not refer to tuple struct patterns, but "
"rather we refer to a pattern for any product type. This includes enum "
"variants, tuple structs, structs with named fields, arrays, tuples, and "
"slices."
msgstr "여기서 _\"생성자\"_는 튜플 구조체 패턴만을 가리키는 것이 아니라, 모든 곱 타입(product type)에 대한 패턴을 의미합니다. 여기에는 열거형 변형, 튜플 구조체, 이름 있는 필드가 있는 구조체, 배열, 튜플, 슬라이스가 포함됩니다."

#: src/patterns.md:1164
msgid "Dynamic semantics"
msgstr "동적 시맨틱"

#: src/patterns.md:1168
msgid ""
"The dynamic semantics of pattern matching a scrutinee expression `e_s` "
"against a pattern `c(p | q, ..rest)` at depth `d` where `c` is some "
"constructor, `p` and `q` are arbitrary patterns, and `rest` is optionally "
"any remaining potential factors in `c`, is defined as being the same as that "
"of `c(p, ..rest) | c(q, ..rest)`."
msgstr "조사 대상 표현식 `e_s`를 깊이 `d`에서 `c(p | q, ..rest)` 패턴(여기서 `c`는 어떤 생성자, `p`와 `q`는 임의의 패턴, `rest`는 `c`의 나머지 선택적 요소)과 매치하는 동적 시맨틱은 `c(p, ..rest) | c(q, ..rest)`와 동일한 것으로 정의됩니다."

#: src/patterns.md:1175
msgid "Precedence with other undelimited patterns"
msgstr "구분 기호가 없는 다른 패턴과의 우선순위"

#: src/patterns.md:1177
msgid ""
"As shown elsewhere in this chapter, there are several types of patterns that "
"are syntactically undelimited, including identifier patterns, reference "
"patterns, and or-patterns. Or-patterns always have the lowest-precedence. "
"This allows us to reserve syntactic space for a possible future type "
"ascription feature and also to reduce ambiguity. For example, `x @ A(..) | "
"B(..)` will result in an error that `x` is not bound in all patterns. `&A(x) "
"| B(x)` will result in a type mismatch between `x` in the different "
"subpatterns."
msgstr "이 장의 다른 곳에서 보여준 것처럼, 식별자 패턴, 참조 패턴, Or 패턴을 포함하여 구문상으로 구분 기호가 없는(undelimited) 여러 유형의 패턴이 있습니다. Or 패턴은 항상 가장 낮은 우선순위를 갖습니다. 이를 통해 향후 타입 어스크립션(type ascription) 기능을 위한 구문적 공간을 확보하고 모호성을 줄일 수 있습니다. 예를 들어, `x @ A(..) | B(..)`는 `x`가 모든 패턴에 바인딩되지 않았다는 오류를 발생시킵니다. `&A(x) | B(x)`는 서로 다른 서브패턴에 있는 `x` 사이의 타입 불일치를 발생시킵니다."

#: src/types.md:50
msgid ""
"Every variable, item, and value in a Rust program has a type. The _type_ of "
"a _value_ defines the interpretation of the memory holding it and the "
"operations that may be performed on the value."
msgstr "러스트 프로그램의 모든 변수, 아이템, 값은 타입을 가집니다. _값_의 _타입_은 해당 값을 보유한 메모리의 해석 방식과 해당 값에 대해 수행할 수 있는 연산을 정의합니다."

#: src/types.md:56
msgid ""
"Built-in types are tightly integrated into the language, in nontrivial ways "
"that are not possible to emulate in user-defined types."
msgstr "내장 타입(Built-in types)은 언어에 긴밀하게 통합되어 있으며, 사용자 정의 타입으로는 흉내 낼 수 없는 복잡한 방식으로 작동합니다."

#: src/types.md:61
msgid "User-defined types have limited capabilities."
msgstr "사용자 정의 타입은 제한된 능력을 갖습니다."

#: src/types.md:65
msgid "The list of types is:"
msgstr "타입 목록은 다음과 같습니다:"

#: src/types.md:67
msgid "Primitive types:"
msgstr "기본 타입(Primitive types):"

#: src/types.md:68
msgid "[Boolean](types/boolean.md) --- `bool`"
msgstr "[불리언](types/boolean.md) --- `bool`"

#: src/types.md:69
msgid "[Numeric](types/numeric.md) --- integer and float"
msgstr "[숫자](types/numeric.md) --- 정수 및 부동 소수점"

#: src/types.md:70
msgid "[Textual](types/textual.md) --- `char` and `str`"
msgstr "[텍스트](types/textual.md) --- `char` 및 `str`"

#: src/types.md:71
msgid "[Never](types/never.md) --- `!` --- a type with no values"
msgstr "[네버](types/never.md) --- `!` --- 값이 없는 타입"

#: src/types.md:72
msgid "Sequence types:"
msgstr "시퀀스 타입:"

#: src/types.md:73
msgid "[Tuple](types/tuple.md)"
msgstr "[튜플](types/tuple.md)"

#: src/types.md:74
msgid "[Array](types/array.md)"
msgstr "[배열](types/array.md)"

#: src/types.md:75
msgid "[Slice](types/slice.md)"
msgstr "[슬라이스](types/slice.md)"

#: src/types.md:76
msgid "User-defined types:"
msgstr "사용자 정의 타입:"

#: src/types.md:77
msgid "[Struct](types/struct.md)"
msgstr "[구조체](types/struct.md)"

#: src/types.md:78
msgid "[Enum](types/enum.md)"
msgstr "[열거형](types/enum.md)"

#: src/types.md:79
msgid "[Union](types/union.md)"
msgstr "[공용체](types/union.md)"

#: src/types.md:80
msgid "Function types:"
msgstr "함수 타입:"

#: src/types.md:81
msgid "[Functions](types/function-item.md)"
msgstr "[함수](types/function-item.md)"

#: src/types.md:82
msgid "[Closures](types/closure.md)"
msgstr "[클로저](types/closure.md)"

#: src/types.md:83
msgid "Pointer types:"
msgstr "포인터 타입:"

#: src/types.md:84
msgid "[References](types/pointer.md#shared-references-)"
msgstr "[참조](types/pointer.md#shared-references-)"

#: src/types.md:85
msgid "[Raw pointers](types/pointer.md#raw-pointers-const-and-mut)"
msgstr "[원시 포인터](types/pointer.md#raw-pointers-const-and-mut)"

#: src/types.md:86 src/special-types-and-traits.md:132
msgid "[Function pointers](types/function-pointer.md)"
msgstr "[함수 포인터](types/function-pointer.md)"

#: src/types.md:87
msgid "Trait types:"
msgstr "트레잇 타입:"

#: src/types.md:88
msgid "[Trait objects](types/trait-object.md)"
msgstr "[트레잇 객체](types/trait-object.md)"

#: src/types.md:89
msgid "[Impl trait](types/impl-trait.md)"
msgstr "[Impl 트레잇](types/impl-trait.md)"

#: src/types.md:93
msgid "Type expressions"
msgstr "타입 표현식"

#: src/types.md:97
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Type_ :  \n"
"      _TypeNoBounds_  \n"
"   | [_ImplTraitType_](types/impl-trait.md)  \n"
"   | [_TraitObjectType_](types/trait-object.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_타입_ :  \n"
"      _바운드없는타입_  \n"
"   | [_Impl트레잇타입_](types/impl-trait.md)  \n"
"   | [_트레잇객체타입_](types/trait-object.md)"

#: src/types.md:103
msgid ""
"_TypeNoBounds_ :  \n"
"      [_ParenthesizedType_](types.md#parenthesized-types)  \n"
"   | [_ImplTraitTypeOneBound_](types/impl-trait.md)  \n"
"   | [_TraitObjectTypeOneBound_](types/trait-object.md)  \n"
"   | [_TypePath_](paths.md#paths-in-types)  \n"
"   | [_TupleType_](types/tuple.md#tuple-types)  \n"
"   | [_NeverType_](types/never.md)  \n"
"   | [_RawPointerType_](types/pointer.md#raw-pointers-const-and-mut)  \n"
"   | [_ReferenceType_](types/pointer.md#shared-references-)  \n"
"   | [_ArrayType_](types/array.md)  \n"
"   | [_SliceType_](types/slice.md)  \n"
"   | [_InferredType_](types/inferred.md)  \n"
"   | [_QualifiedPathInType_](paths.md#qualified-paths)  \n"
"   | [_BareFunctionType_](types/function-pointer.md)  \n"
"   | [_MacroInvocation_](macros.md#macro-invocation)"
msgstr ""
"_바운드없는타입_ :  \n"
"      [_괄호로둘러싸인타입_](types.md#parenthesized-types)  \n"
"   | [_하나의바운드를가진Impl트레잇타입_](types/impl-trait.md)  \n"
"   | [_하나의바운드를가진트레잇객체타입_](types/trait-object.md)  \n"
"   | [_타입경로_](paths.md#paths-in-types)  \n"
"   | [_튜플타입_](types/tuple.md#tuple-types)  \n"
"   | [_네버타입_](types/never.md)  \n"
"   | [_원시포인터타입_](types/pointer.md#raw-pointers-const-and-mut)  \n"
"   | [_참조타입_](types/pointer.md#shared-references-)  \n"
"   | [_배열타입_](types/array.md)  \n"
"   | [_슬라이스타입_](types/slice.md)  \n"
"   | [_추론된타입_](types/inferred.md)  \n"
"   | [_타입내한정된경로_](paths.md#qualified-paths)  \n"
"   | [_Bare함수타입_](types/function-pointer.md)  \n"
"   | [_매크로호출_](macros.md#macro-invocation)"

#: src/types.md:121
msgid ""
"A _type expression_ as defined in the _Type_ grammar rule above is the "
"syntax for referring to a type. It may refer to:"
msgstr "위의 _Type_ 구문 규칙에 정의된 _타입 표현식_은 타입을 참조하기 위한 구문입니다. 이는 다음을 참조할 수 있습니다:"

#: src/types.md:126
msgid ""
"Sequence types ([tuple](types/tuple.md), [array](types/array.md), [slice]"
"(types/slice.md))."
msgstr "시퀀스 타입 ([튜플](types/tuple.md), [배열](types/array.md), [슬라이스](types/slice.md))."

#: src/types.md:130
msgid "[Type paths](paths.md#paths-in-types) which can reference:"
msgstr "다음을 참조할 수 있는 [타입 경로](paths.md#paths-in-types):"

#: src/types.md:131
msgid ""
"Primitive types ([boolean](types/boolean.md), [numeric](types/numeric.md), "
"[textual](types/textual.md))."
msgstr "기본 타입 ([불리언](types/boolean.md), [숫자](types/numeric.md), [텍스트](types/textual.md))."

#: src/types.md:132
msgid ""
"Paths to an [item](items.md) ([struct](types/struct.md), [enum](types/"
"enum.md), [union](types/union.md), [type alias](items/type-aliases.md), "
"[trait](types/trait-object.md))."
msgstr "[아이템](items.md)으로의 경로 ([구조체](types/struct.md), [열거형](types/enum.md), [공용체](types/union.md), [타입 별칭](items/type-aliases.md), [트레잇](types/trait-object.md))."

#: src/types.md:133
msgid "[`Self` path](paths.md#self-1) where `Self` is the implementing type."
msgstr "`Self`가 구현 타입인 [`Self` 경로](paths.md#self-1)."

#: src/types.md:134
msgid "Generic [type parameters](types/parameters.md)."
msgstr "제네릭 [타입 파라미터](types/parameters.md)."

#: src/types.md:138
msgid ""
"Pointer types ([reference](types/pointer.md#shared-references-), [raw "
"pointer](types/pointer.md#raw-pointers-const-and-mut), [function pointer]"
"(types/function-pointer.md))."
msgstr "포인터 타입 ([참조](types/pointer.md#shared-references-), [원시 포인터](types/pointer.md#raw-pointers-const-and-mut), [함수 포인터](types/function-pointer.md))."

#: src/types.md:142
msgid ""
"The [inferred type](types/inferred.md) which asks the compiler to determine "
"the type."
msgstr "컴파일러에게 타입을 결정하도록 요청하는 [추론된 타입](types/inferred.md)."

#: src/types.md:146
msgid "[Parentheses](#parenthesized-types) which are used for disambiguation."
msgstr "모호성을 제거하기 위해 사용되는 [괄호](#parenthesized-types)."

#: src/types.md:150
msgid ""
"Trait types: [Trait objects](types/trait-object.md) and [impl trait](types/"
"impl-trait.md)."
msgstr "트레잇 타입: [트레잇 객체](types/trait-object.md) 및 [impl 트레잇](types/impl-trait.md)."

#: src/types.md:154
msgid "The [never](types/never.md) type."
msgstr "[네버](types/never.md) 타입."

#: src/types.md:158
msgid "[Macros](macros.md) which expand to a type expression."
msgstr "타입 표현식으로 확장되는 [매크로](macros.md)."

#: src/types.md:162
msgid "Parenthesized types"
msgstr "괄호로 둘러싸인 타입"

#: src/types.md:166
msgid ""
"_ParenthesizedType_ :  \n"
"   `(` [_Type_](types.md#type-expressions) `)`"
msgstr ""
"_괄호로둘러싸인타입_ :  \n"
"   `(` [_타입_](types.md#type-expressions) `)`"

#: src/types.md:171
msgid ""
"In some situations the combination of types may be ambiguous. Use "
"parentheses around a type to avoid ambiguity. For example, the `+` operator "
"for [type boundaries](trait-bounds.md) within a [reference type](types/"
"pointer.md#shared-references-) is unclear where the boundary applies, so the "
"use of parentheses is required. Grammar rules that require this "
"disambiguation use the [_TypeNoBounds_](types.md#type-expressions) rule "
"instead of [_Type_](types.md#type-expressions)."
msgstr "어떤 상황에서는 타입의 조합이 모호할 수 있습니다. 모호성을 피하기 위해 타입 주위에 괄호를 사용하십시오. 예를 들어, [참조 타입](types/pointer.md#shared-references-) 내의 [타입 바운드](trait-bounds.md)를 위한 `+` 연산자는 바운드가 어디에 적용되는지 불분명하므로 괄호를 사용해야 합니다. 이러한 모호성 제거가 필요한 구문 규칙은 [_Type_](types.md#type-expressions) 규칙 대신 [_TypeNoBounds_](types.md#type-expressions) 규칙을 사용합니다."

#: src/types.md:185
msgid "Recursive types"
msgstr "재귀적 타입"

#: src/types.md:189
msgid ""
"Nominal types — [structs](types/struct.md), [enumerations](types/enum.md), "
"and [unions](types/union.md) — may be recursive. That is, each `enum` "
"variant or `struct` or `union` field may refer, directly or indirectly, to "
"the enclosing `enum` or `struct` type itself."
msgstr "명목적 타입(Nominal types)인 [구조체](types/struct.md), [열거형](types/enum.md), [공용체](types/union.md)는 재귀적일 수 있습니다. 즉, 각 `enum` 변형이나 `struct` 또는 `union` 필드는 자신을 둘러싼 `enum` 또는 `struct` 타입 자체를 직접적 또는 간접적으로 참조할 수 있습니다."

#: src/types.md:196
msgid "Such recursion has restrictions:"
msgstr "이러한 재귀에는 제한 사항이 있습니다:"

#: src/types.md:198
msgid ""
"Recursive types must include a nominal type in the recursion (not mere [type "
"aliases](items/type-aliases.md), or other structural types such as [arrays]"
"(types/array.md) or [tuples](types/tuple.md)). So `type Rec = &'static "
"[Rec]` is not allowed."
msgstr "재귀적 타입은 재귀 과정에 반드시 명목적 타입을 포함해야 합니다(단순한 [타입 별칭](items/type-aliases.md)이나 [배열](types/array.md), [튜플](types/tuple.md)과 같은 다른 구조적 타입만으로는 안 됩니다). 따라서 `type Rec = &'static [Rec]`은 허용되지 않습니다."

#: src/types.md:201
msgid ""
"The size of a recursive type must be finite; in other words the recursive "
"fields of the type must be [pointer types](types/pointer.md)."
msgstr "재귀적 타입의 크기는 유한해야 합니다. 다시 말해, 해당 타입의 재귀적 필드는 반드시 [포인터 타입](types/pointer.md)이어야 합니다."

#: src/types.md:204
msgid "An example of a _recursive_ type and its use:"
msgstr "_재귀적_ 타입과 그 사용 예시:"

#: src/types/boolean.md:11
msgid ""
"The _boolean type_ or _bool_ is a primitive data type that can take on one "
"of two values, called _true_ and _false_."
msgstr "_불리언 타입_ 또는 _bool_은 _true_와 _false_라고 불리는 두 가지 값 중 하나를 가질 수 있는 기본 데이터 타입입니다."

#: src/types/boolean.md:16
msgid ""
"Values of this type may be created using a [literal expression](../"
"expressions/literal-expr.md) using the keywords `true` and `false` "
"corresponding to the value of the same name."
msgstr "이 타입의 값은 같은 이름의 값에 해당하는 `true` 및 `false` 키워드를 사용한 [리터럴 표현식](../expressions/literal-expr.md)을 통해 생성될 수 있습니다."

#: src/types/boolean.md:21
msgid ""
"This type is a part of the [language prelude](../names/preludes.md#language-"
"prelude) with the [name](../names.md) `bool`."
msgstr "이 타입은 [`bool`](../names.md)이라는 이름으로 [언어 프렐류드](../names/preludes.md#language-prelude)의 일부입니다."

#: src/types/boolean.md:25
msgid ""
"An object with the boolean type has a [size and alignment](../type-"
"layout.md#size-and-alignment) of 1 each."
msgstr "불리언 타입을 가진 객체는 [크기와 정렬](../type-layout.md#size-and-alignment)이 각각 1입니다."

#: src/types/boolean.md:29
msgid ""
"The value false has the bit pattern `0x00` and the value true has the bit "
"pattern `0x01`. It is [undefined behavior](../behavior-considered-"
"undefined.md) for an object with the boolean type to have any other bit "
"pattern."
msgstr "false 값은 비트 패턴 `0x00`을 가지며, true 값은 비트 패턴 `0x01`을 가집니다. 불리언 타입을 가진 객체가 그 외의 비트 패턴을 갖는 것은 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)입니다."

#: src/types/boolean.md:35
msgid ""
"The boolean type is the type of many operands in various [expressions](../"
"expressions.md):"
msgstr "불리언 타입은 다양한 [표현식](../expressions.md)에서 많은 피연산자의 타입으로 사용됩니다:"

#: src/types/boolean.md:39
msgid ""
"The condition operand in [if expressions](../expressions/if-expr.md#if-"
"expressions) and [while expressions](../expressions/loop-expr.md#predicate-"
"loops)"
msgstr "[`if` 표현식](../expressions/if-expr.md#if-expressions) 및 [`while` 표현식](../expressions/loop-expr.md#predicate-loops)의 조건 피연산자"

#: src/types/boolean.md:43
msgid ""
"The operands in [lazy boolean operator expressions](../expressions/operator-"
"expr.md#lazy-boolean-operators)"
msgstr "[지연 불리언 연산자 표현식](../expressions/operator-expr.md#lazy-boolean-operators)의 피연산자"

#: src/types/boolean.md:45
msgid ""
"**Note**: The boolean type acts similarly to but is not an [enumerated type]"
"(enum.md). In practice, this mostly means that constructors are not "
"associated to the type (e.g. `bool::true`)."
msgstr "**참고**: 불리언 타입은 [열거형 타입](enum.md)과 유사하게 작동하지만 열거형은 아닙니다. 실제로 이는 주로 생성자가 타입에 연관되지 않음을 의미합니다 (예: `bool::true`)."

#: src/types/boolean.md:51
msgid ""
"Like all primitives, the boolean type [implements](../items/"
"implementations.md) the [traits](../items/traits.md) [`Clone`](../special-"
"types-and-traits.md#clone), [`Copy`](../special-types-and-traits.md#copy), "
"[`Sized`](../special-types-and-traits.md#sized), [`Send`](../special-types-"
"and-traits.md#send), and [`Sync`](../special-types-and-traits.md#sync)."
msgstr "모든 기본 타입과 마찬가지로, 불리언 타입은 [`Clone`](../special-types-and-traits.md#clone), [`Copy`](../special-types-and-traits.md#copy), [`Sized`](../special-types-and-traits.md#sized), [`Send`](../special-types-and-traits.md#send), [`Sync`](../special-types-and-traits.md#sync) [트레잇](../items/traits.md)을 [구현](../items/implementations.md)합니다."

#: src/types/boolean.md:55
msgid ""
"**Note**: See the [standard library docs](../../std/primitive.bool.html) for "
"library operations."
msgstr "**참고**: 라이브러리 연산에 대해서는 [표준 라이브러리 문서](../../std/primitive.bool.html)를 참조하십시오."

#: src/types/boolean.md:59
msgid "Operations on boolean values"
msgstr "불리언 값에 대한 연산"

#: src/types/boolean.md:62
msgid ""
"boolean type for its operands, they evaluate using the rules of [boolean "
"logic](https://en.wikipedia.org/wiki/Boolean_algebra)."
msgstr "피연산자로 불리언 타입을 사용하며, [불리언 로직](https://ko.wikipedia.org/wiki/%EB%B6%88_%EB%8C%80%EC%88%98) 규칙을 사용하여 평가됩니다."

#: src/types/boolean.md:66
msgid "Logical not"
msgstr "논리 부정 (Logical not)"

#: src/types/boolean.md:68 src/types/boolean.md:77 src/types/boolean.md:88
#: src/types/boolean.md:99 src/types/boolean.md:112 src/types/boolean.md:121
#: src/inline-assembly.md:842 src/inline-assembly.md:843
#: src/inline-assembly.md:861
msgid "`b`"
msgstr "`b`"

#: src/types/boolean.md:68
msgid "[`!b`](../expressions/operator-expr.md#negation-operators)"
msgstr "[`!b`](../expressions/operator-expr.md#negation-operators)"

#: src/types/boolean.md:70 src/types/boolean.md:71 src/types/boolean.md:79
#: src/types/boolean.md:80 src/types/boolean.md:81 src/types/boolean.md:90
#: src/types/boolean.md:91 src/types/boolean.md:92 src/types/boolean.md:101
#: src/types/boolean.md:102 src/types/boolean.md:103 src/types/boolean.md:114
#: src/types/boolean.md:115 src/types/boolean.md:116 src/types/boolean.md:117
#: src/types/boolean.md:123 src/types/boolean.md:124 src/types/boolean.md:125
msgid "`true`"
msgstr "`true`"

#: src/types/boolean.md:70 src/types/boolean.md:71 src/types/boolean.md:80
#: src/types/boolean.md:81 src/types/boolean.md:82 src/types/boolean.md:91
#: src/types/boolean.md:92 src/types/boolean.md:93 src/types/boolean.md:101
#: src/types/boolean.md:102 src/types/boolean.md:103 src/types/boolean.md:104
#: src/types/boolean.md:115 src/types/boolean.md:116 src/types/boolean.md:117
#: src/types/boolean.md:123 src/types/boolean.md:124 src/types/boolean.md:125
#: src/types/boolean.md:126
msgid "`false`"
msgstr "`false`"

#: src/types/boolean.md:75
msgid "Logical or"
msgstr "논리 합 (Logical or)"

#: src/types/boolean.md:77
msgid ""
"[<code>a \\| b</code>](../expressions/operator-expr.md#arithmetic-and-"
"logical-binary-operators)"
msgstr "[<code>a | b</code>](../expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/types/boolean.md:86
msgid "Logical and"
msgstr "논리 곱 (Logical and)"

#: src/types/boolean.md:88
msgid ""
"[`a & b`](../expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators)"
msgstr "[`a & b`](../expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/types/boolean.md:97
msgid "Logical xor"
msgstr "논리 배타적 합 (Logical xor)"

#: src/types/boolean.md:99
msgid ""
"[`a ^ b`](../expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators)"
msgstr "[`a ^ b`](../expressions/operator-expr.md#arithmetic-and-logical-binary-operators)"

#: src/types/boolean.md:108
msgid "Comparisons"
msgstr "비교"

#: src/types/boolean.md:112
msgid "[`a == b`](../expressions/operator-expr.md#comparison-operators)"
msgstr "[`a == b`](../expressions/operator-expr.md#comparison-operators)"

#: src/types/boolean.md:121
msgid "[`a > b`](../expressions/operator-expr.md#comparison-operators)"
msgstr "[`a > b`](../expressions/operator-expr.md#comparison-operators)"

#: src/types/boolean.md:130
msgid "`a != b` is the same as `!(a == b)`"
msgstr "`a != b`는 `!(a == b)`와 동일합니다"

#: src/types/boolean.md:134
msgid "`a >= b` is the same as `a == b | a > b`"
msgstr "`a >= b`는 `a == b | a > b`와 동일합니다"

#: src/types/boolean.md:138
msgid "`a < b` is the same as `!(a >= b)`"
msgstr "`a < b`는 `!(a >= b)`와 동일합니다"

#: src/types/boolean.md:142
msgid "`a <= b` is the same as `a == b | a < b`"
msgstr "`a <= b`는 `a == b | a < b`와 동일합니다"

#: src/types/boolean.md:146 src/types/numeric.md:69 src/types/pointer.md:99
msgid "Bit validity"
msgstr "비트 유효성"

#: src/types/boolean.md:148
msgid ""
"The single byte of a `bool` is guaranteed to be initialized (in other words, "
"`transmute::<bool, u8>(...)` is always sound -- but since some bit patterns "
"are invalid `bool`s, the inverse is not always sound)."
msgstr "`bool`의 단일 바이트는 초기화됨이 보장됩니다 (다시 말해, `transmute::<bool, u8>(...)`는 항상 안전(sound)합니다. 하지만 일부 비트 패턴은 유효하지 않은 `bool` 값이므로, 그 역은 항상 안전하지는 않습니다)."

#: src/types/numeric.md:7
msgid "Integer types"
msgstr "정수 타입"

#: src/types/numeric.md:11
msgid "The unsigned integer types consist of:"
msgstr "부호 없는 정수 타입은 다음과 같이 구성됩니다:"

#: src/types/numeric.md:13 src/types/numeric.md:25
msgid "Minimum"
msgstr "최소값"

#: src/types/numeric.md:13 src/types/numeric.md:25
msgid "Maximum"
msgstr "최대값"

#: src/types/numeric.md:15
msgid "2<sup>8</sup>\\-1"
msgstr "2<sup>8</sup>-1"

#: src/types/numeric.md:16
msgid "`u16`"
msgstr "`u16`"

#: src/types/numeric.md:16
msgid "2<sup>16</sup>\\-1"
msgstr "2<sup>16</sup>-1"

#: src/types/numeric.md:17
msgid "`u32`"
msgstr "`u32`"

#: src/types/numeric.md:17
msgid "2<sup>32</sup>\\-1"
msgstr "2<sup>32</sup>-1"

#: src/types/numeric.md:18
msgid "`u64`"
msgstr "`u64`"

#: src/types/numeric.md:18
msgid "2<sup>64</sup>\\-1"
msgstr "2<sup>64</sup>-1"

#: src/types/numeric.md:19
msgid "`u128`"
msgstr "`u128`"

#: src/types/numeric.md:19
msgid "2<sup>128</sup>\\-1"
msgstr "2<sup>128</sup>-1"

#: src/types/numeric.md:23
msgid "The signed two's complement integer types consist of:"
msgstr "부호 있는 2의 보수 정수 타입은 다음과 같이 구성됩니다:"

#: src/types/numeric.md:27 src/inline-assembly.md:590
msgid "`i8`"
msgstr "`i8`"

#: src/types/numeric.md:27
msgid "\\-(2<sup>7</sup>)"
msgstr "-(2<sup>7</sup>)"

#: src/types/numeric.md:27
msgid "2<sup>7</sup>\\-1"
msgstr "2<sup>7</sup>-1"

#: src/types/numeric.md:28
msgid "`i16`"
msgstr "`i16`"

#: src/types/numeric.md:28
msgid "\\-(2<sup>15</sup>)"
msgstr "-(2<sup>15</sup>)"

#: src/types/numeric.md:28
msgid "2<sup>15</sup>\\-1"
msgstr "2<sup>15</sup>-1"

#: src/types/numeric.md:29
msgid "`i32`"
msgstr "`i32`"

#: src/types/numeric.md:29
msgid "\\-(2<sup>31</sup>)"
msgstr "-(2<sup>31</sup>)"

#: src/types/numeric.md:29
msgid "2<sup>31</sup>\\-1"
msgstr "2<sup>31</sup>-1"

#: src/types/numeric.md:30
msgid "`i64`"
msgstr "`i64`"

#: src/types/numeric.md:30
msgid "\\-(2<sup>63</sup>)"
msgstr "-(2<sup>63</sup>)"

#: src/types/numeric.md:30
msgid "2<sup>63</sup>\\-1"
msgstr "2<sup>63</sup>-1"

#: src/types/numeric.md:31
msgid "`i128`"
msgstr "`i128`"

#: src/types/numeric.md:31
msgid "\\-(2<sup>127</sup>)"
msgstr "-(2<sup>127</sup>)"

#: src/types/numeric.md:31
msgid "2<sup>127</sup>\\-1"
msgstr "2<sup>127</sup>-1"

#: src/types/numeric.md:36
msgid "Floating-point types"
msgstr "부동 소수점 타입"

#: src/types/numeric.md:38
msgid ""
"The IEEE 754-2008 \"binary32\" and \"binary64\" floating-point types are "
"`f32` and `f64`, respectively."
msgstr "IEEE 754-2008 \"binary32\" 및 \"binary64\" 부동 소수점 타입은 각각 `f32`와 `f64`입니다."

#: src/types/numeric.md:43
msgid "Machine-dependent integer types"
msgstr "머신 의존적 정수 타입"

#: src/types/numeric.md:47
msgid ""
"The `usize` type is an unsigned integer type with the same number of bits as "
"the platform's pointer type. It can represent every memory address in the "
"process."
msgstr "`usize` 타입은 플랫폼의 포인터 타입과 동일한 비트 수를 가진 부호 없는 정수 타입입니다. 이는 프로세스의 모든 메모리 주소를 나타낼 수 있습니다."

#: src/types/numeric.md:52
msgid ""
"The `isize` type is a signed integer type with the same number of bits as "
"the platform's pointer type. The theoretical upper bound on object and array "
"size is the maximum `isize` value. This ensures that `isize` can be used to "
"calculate differences between pointers into an object or array and can "
"address every byte within an object along with one byte past the end."
msgstr "`isize` 타입은 플랫폼의 포인터 타입과 동일한 비트 수를 가진 부호 있는 정수 타입입니다. 객체 및 배열 크기의 이론적 상한선은 `isize`의 최대값입니다. 이를 통해 `isize`를 사용하여 객체나 배열 내부의 포인터 간 차이를 계산할 수 있으며, 객체 내의 모든 바이트와 끝에서 한 바이트 더 뒤의 주소를 가리킬 수 있음을 보장합니다."

#: src/types/numeric.md:60
msgid "`usize` and `isize` are at least 16-bits wide."
msgstr "`usize` 및 `isize`는 최소 16비트 너비입니다."

#: src/types/numeric.md:62
msgid ""
"**Note**: Many pieces of Rust code may assume that pointers, `usize`, and "
"`isize` are either 32-bit or 64-bit. As a consequence, 16-bit pointer "
"support is limited and may require explicit care and acknowledgment from a "
"library to support."
msgstr "**참고**: 많은 러스트 코드들이 포인터, `usize`, `isize`가 32비트 또는 64비트라고 가정할 수 있습니다. 결과적으로 16비트 포인터 지원은 제한적이며, 라이브러리에서 이를 지원하려면 명시적인 주의와 인지가 필요할 수 있습니다."

#: src/types/numeric.md:71
msgid ""
"For every numeric type, `T`, the bit validity of `T` is equivalent to the "
"bit validity of `[u8; size_of::<T>()]`. An uninitialized byte is not a valid "
"`u8`."
msgstr "모든 숫자 타입 `T`에 대해, `T`의 비트 유효성은 `[u8; size_of::<T>()]`의 비트 유효성과 동일합니다. 초기화되지 않은 바이트는 유효한 `u8`이 아닙니다."

#: src/types/textual.md:7
msgid "The types `char` and `str` hold textual data."
msgstr "`char` 및 `str` 타입은 텍스트 데이터를 보유합니다."

#: src/types/textual.md:11
msgid ""
"A value of type `char` is a [Unicode scalar value](http://www.unicode.org/"
"glossary/#unicode_scalar_value) (i.e. a code point that is not a surrogate), "
"represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to "
"0x10FFFF range."
msgstr "`char` 타입의 값은 [유니코드 스칼라 값](http://www.unicode.org/glossary/#unicode_scalar_value)(즉, 서로게이트가 아닌 코드 포인트)이며, 0x0000에서 0xD7FF 또는 0xE000에서 0x10FFFF 범위의 32비트 부호 없는 워드로 표현됩니다."

#: src/types/textual.md:17
msgid ""
"It is immediate [undefined behavior](../behavior-considered-undefined.md) to "
"create a `char` that falls outside this range. A `[char]` is effectively a "
"UCS-4 / UTF-32 string of length 1."
msgstr "이 범위를 벗어나는 `char`를 생성하는 것은 즉각적인 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)입니다. `[char]`는 실질적으로 길이가 1인 UCS-4 / UTF-32 문자열입니다."

#: src/types/textual.md:23
msgid ""
"A value of type `str` is represented the same way as `[u8]`, a slice of 8-"
"bit unsigned bytes. However, the Rust standard library makes extra "
"assumptions about `str`: methods working on `str` assume and ensure that the "
"data in there is valid UTF-8. Calling a `str` method with a non-UTF-8 buffer "
"can cause [undefined behavior](../behavior-considered-undefined.md) now or "
"in the future."
msgstr "`str` 타입의 값은 8비트 부호 없는 바이트의 슬라이스인 `[u8]`과 동일한 방식으로 표현됩니다. 그러나 러스트 표준 라이브러리는 `str`에 대해 추가적인 가정을 합니다. `str`에서 작동하는 메서드들은 그 안의 데이터가 유효한 UTF-8이라고 가정하고 이를 보장합니다. UTF-8이 아닌 버퍼로 `str` 메서드를 호출하는 것은 현재 또는 미래에 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)을 유발할 수 있습니다."

#: src/types/textual.md:31
msgid ""
"Since `str` is a [dynamically sized type](../dynamically-sized-types.md), it "
"can only be instantiated through a pointer type, such as `&str`."
msgstr "`str`은 [동적 크기 타입(dynamically sized type)](../dynamically-sized-types.md)이므로, `&str`과 같은 포인터 타입을 통해서만 인스턴스화할 수 있습니다."

#: src/types/textual.md:36
msgid "Layout and bit validity"
msgstr "레이아웃 및 비트 유효성"

#: src/types/textual.md:40
msgid ""
"`char` is guaranteed to have the same size and alignment as `u32` on all "
"platforms."
msgstr "`char`는 모든 플랫폼에서 `u32`와 동일한 크기 및 정렬을 가짐이 보장됩니다."

#: src/types/textual.md:44
msgid ""
"Every byte of a `char` is guaranteed to be initialized (in other words, "
"`transmute::<char, [u8; size_of::<char>()]>(...)` is always sound -- but "
"since some bit patterns are invalid `char`s, the inverse is not always "
"sound)."
msgstr "`char`의 모든 바이트는 초기화됨이 보장됩니다 (다시 말해, `transmute::<char, [u8; size_of::<char>()]>(...)`는 항상 안전(sound)합니다. 하지만 일부 비트 패턴은 유효하지 않은 `char` 값이므로, 그 역은 항상 안전하지는 않습니다)."

#: src/types/never.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_NeverType_ : `!`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_네버타입_ : `!`"
"**<sup>구문</sup>**  \n"
"_네버타입_ : `!`"

#: src/types/never.md:12
msgid ""
"The never type `!` is a type with no values, representing the result of "
"computations that never complete."
msgstr "네버 타입 `!`은 값이 없는 타입으로, 결코 완료되지 않는 계산의 결과를 나타냅니다."

#: src/types/never.md:17
msgid "Expressions of type `!` can be coerced into any other type."
msgstr "`!` 타입의 표현식은 다른 어떤 타입으로도 강제 변환(coerced)될 수 있습니다."

#: src/types/never.md:21
msgid ""
"The `!` type can **only** appear in function return types presently, "
"indicating it is a diverging function that never returns."
msgstr "현재 `!` 타입은 함수의 반환 타입에만 나타날 수 있으며, 이는 함수가 결코 반환되지 않는 발산 함수(diverging function)임을 나타냅니다."

#: src/types/never.md:26
msgid "\"This call never returns.\""
msgstr "\"이 호출은 결코 반환되지 않습니다.\""

#: src/types/tuple.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TupleType_ :  \n"
"      `(` `)`  \n"
"   | `(` ( [_Type_](../types.md#type-expressions) `,` )<sup>+</sup> [_Type_]"
"(../types.md#type-expressions)<sup>?</sup> `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_튜플타입_ :  \n"
"      `( )`  \n"
"   | `(` ( [_타입_](../types.md#type-expressions) `,` )<sup>+</sup> [_타입_](../types.md#type-expressions)<sup>?</sup> `)`"

#: src/types/tuple.md:14
msgid ""
"_Tuple types_ are a family of structural types[^1] for heterogeneous lists "
"of other types."
msgstr "_튜플 타입_은 다른 타입들의 이종 목록(heterogeneous list)을 위한 구조적 타입[^1] 군입니다."

#: src/types/tuple.md:16
msgid ""
"The syntax for a tuple type is a parenthesized, comma-separated list of "
"types."
msgstr "튜플 타입의 구문은 괄호로 둘러싸인, 쉼표로 구분된 타입 목록입니다."

#: src/types/tuple.md:20
msgid ""
"1-ary tuples require a comma after their element type to be disambiguated "
"from [parenthesized types](../types.md#parenthesized-types)."
msgstr "1-ary 튜플은 단일 요소 타입 뒤에 쉼표를 붙여야만 [괄호로 둘러싸인 타입](../types.md#parenthesized-types)과 모호하지 않게 구분됩니다."

#: src/types/tuple.md:24
msgid ""
"A tuple type has a number of fields equal to the length of the list of "
"types. This number of fields determines the _arity_ of the tuple. A tuple "
"with `n` fields is called an _n-ary tuple_. For example, a tuple with 2 "
"fields is a 2-ary tuple."
msgstr "튜플 타입은 타입 목록의 길이와 동일한 수의 필드를 가집니다. 이 필드의 수는 튜플의 _항수(arity)_를 결정합니다. `n`개의 필드를 가진 튜플을 _n-항 튜플(n-ary tuple)_이라고 합니다. 예를 들어, 2개의 필드를 가진 튜플은 2-항 튜플입니다."

#: src/types/tuple.md:31
msgid ""
"Fields of tuples are named using increasing numeric names matching their "
"position in the list of types. The first field is `0`. The second field is "
"`1`. And so on. The type of each field is the type of the same position in "
"the tuple's list of types."
msgstr "튜플의 필드 이름은 타입 목록에서의 위치에 따라 증가하는 숫자를 사용하여 명명됩니다. 첫 번째 필드는 `0`, 두 번째 필드는 `1`과 같은 식입니다. 각 필드의 타입은 튜플의 타입 목록에서 동일한 위치에 있는 타입입니다."

#: src/types/tuple.md:39
msgid ""
"For convenience and historical reasons, the tuple type with no fields (`()`) "
"is often called _unit_ or _the unit type_. Its one value is also called "
"_unit_ or _the unit value_."
msgstr "편의상 그리고 역사적인 이유로, 필드가 없는 튜플 타입(`()`)은 흔히 _유닛(unit)_ 또는 _유닛 타입_이라고 불립니다. 이 타입의 유일한 값 또한 _유닛_ 또는 _유닛 값_이라고 불립니다."

#: src/types/tuple.md:42
msgid "Some examples of tuple types:"
msgstr "튜플 타입의 몇 가지 예시:"

#: src/types/tuple.md:45
msgid "`(i32,)` (1-ary tuple)"
msgstr "`(i32,)` (1-항 튜플)"

#: src/types/tuple.md:47
msgid "`(String, i32)`"
msgstr "`(String, i32)`"

#: src/types/tuple.md:48
msgid "`(i32, String)` (different type from the previous example)"
msgstr "`(i32, String)` (이전 예시와는 다른 타입임)"

#: src/types/tuple.md:49
msgid "`(i32, f64, Vec<String>, Option<bool>)`"
msgstr "`(i32, f64, Vec<String>, Option<bool>)`"

#: src/types/tuple.md:53
msgid ""
"Values of this type are constructed using a [tuple expression](../"
"expressions/tuple-expr.md#tuple-expressions). Furthermore, various "
"expressions will produce the unit value if there is no other meaningful "
"value for it to evaluate to."
msgstr "이 타입의 값은 [튜플 표현식](../expressions/tuple-expr.md#tuple-expressions)을 사용하여 생성됩니다. 나아가, 다양한 표현식들이 평가할 다른 의미 있는 값이 없을 때 유닛 값을 생성합니다."

#: src/types/tuple.md:58
msgid ""
"Tuple fields can be accessed by either a [tuple index expression](../"
"expressions/tuple-expr.md#tuple-indexing-expressions) or [pattern matching]"
"(../patterns.md#tuple-patterns)."
msgstr "튜플 필드는 [튜플 인덱스 표현식](../expressions/tuple-expr.md#tuple-indexing-expressions)이나 [패턴 매칭](../patterns.md#tuple-patterns)을 통해 접근할 수 있습니다."

#: src/types/tuple.md:60
msgid ""
"Structural types are always equivalent if their internal types are "
"equivalent. For a nominal version of tuples, see [tuple structs](./"
"struct.md)."
msgstr "구조적 타입은 내부 타입들이 동일하면 항상 동일한 것으로 간주됩니다. 튜플의 명목적 버전(nominal version)에 대해서는 [튜플 구조체](./struct.md)를 참조하십시오."

#: src/types/array.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ArrayType_ :  \n"
"   `[` [_Type_](../types.md#type-expressions) `;` [_Expression_](../"
"expressions.md) `]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_배열타입_ :  \n"
"   `[` [_타입_](../types.md#type-expressions) `;` [_표현식_](../expressions.md) `]`"

#: src/types/array.md:13
msgid ""
"An array is a fixed-size sequence of `N` elements of type `T`. The array "
"type is written as `[T; N]`."
msgstr "배열은 `T` 타입의 요소 `N`개로 구성된 고정 크기 시퀀스입니다. 배열 타입은 `[T; N]`으로 작성됩니다."

#: src/types/array.md:18
msgid ""
"The size is a [constant expression](../const_eval.md#constant-expressions) "
"that evaluates to a [`usize`](numeric.md#machine-dependent-integer-types)."
msgstr "크기는 [`usize`](numeric.md#machine-dependent-integer-types)로 평가되는 [상수 표현식](../const_eval.md#constant-expressions)입니다."

#: src/types/array.md:23
msgid "// A stack-allocated array\n"
msgstr "// 스택에 할당된 배열\n"

#: src/types/array.md:25 src/types/slice.md:28
msgid "// A heap-allocated array, coerced to a slice\n"
msgstr "// 힙에 할당된 배열, 슬라이스로 강제 변환됨\n"

#: src/types/array.md:32
msgid ""
"All elements of arrays are always initialized, and access to an array is "
"always bounds-checked in safe methods and operators."
msgstr "배열의 모든 요소는 항상 초기화되며, 안전한 메서드 및 연산자에서의 배열 접근은 항상 경계 검사(bounds-checked)가 이루어집니다."

#: src/types/array.md:35
msgid ""
"Note: The [`Vec<T>`](../../alloc/vec/struct.Vec.html) standard library type "
"provides a heap-allocated resizable array type."
msgstr "참고: [`Vec<T>`](../../alloc/vec/struct.Vec.html) 표준 라이브러리 타입은 힙에 할당되는 크기 조정 가능한 배열 타입을 제공합니다."

#: src/types/slice.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_SliceType_ :  \n"
"   `[` [_Type_](../types.md#type-expressions) `]`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_슬라이스타입_ :  \n"
"   `[` [_타입_](../types.md#type-expressions) `]`"

#: src/types/slice.md:13
msgid ""
"A slice is a [dynamically sized type](../dynamically-sized-types.md) "
"representing a 'view' into a sequence of elements of type `T`. The slice "
"type is written as `[T]`."
msgstr "슬라이스는 `T` 타입 요소 시퀀스에 대한 '뷰(view)'를 나타내는 [동적 크기 타입(dynamically sized type)](../dynamically-sized-types.md)입니다. 슬라이스 타입은 `[T]`로 작성됩니다."

#: src/types/slice.md:18
msgid "Slice types are generally used through pointer types. For example:"
msgstr "슬라이스 타입은 일반적으로 포인터 타입을 통해 사용됩니다. 예시:"

#: src/types/slice.md:20
msgid ""
"`&[T]`: a 'shared slice', often just called a 'slice'. It doesn't own the "
"data it points to; it borrows it."
msgstr "`&[T]`: '공유 슬라이스'로, 흔히 그냥 '슬라이스'라고 불립니다. 가리키는 데이터를 소유하지 않고 차용합니다."

#: src/types/slice.md:22
msgid ""
"`&mut [T]`: a 'mutable slice'. It mutably borrows the data it points to."
msgstr "`&mut [T]`: '가변 슬라이스'입니다. 가리키는 데이터를 가변적으로 차용합니다."

#: src/types/slice.md:23
msgid "`Box<[T]>`: a 'boxed slice'"
msgstr "`Box<[T]>`: '박스드 슬라이스(boxed slice)'"

#: src/types/slice.md:30
msgid "// A (shared) slice into an array\n"
msgstr "// 배열에 대한 (공유) 슬라이스\n"

#: src/types/slice.md:37
msgid ""
"All elements of slices are always initialized, and access to a slice is "
"always bounds-checked in safe methods and operators."
msgstr "슬라이스의 모든 요소는 항상 초기화되며, 안전한 메서드 및 연산자에서의 슬라이스 접근은 항상 경계 검사(bounds-checked)가 이루어집니다."

#: src/types/struct.md:7
msgid ""
"A `struct` _type_ is a heterogeneous product of other types, called the "
"_fields_ of the type.[^structtype]"
msgstr "`struct` _타입_은 해당 타입의 _필드_라고 불리는 다른 타입들의 이종 곱(heterogeneous product)입니다.[^structtype]"

#: src/types/struct.md:12
msgid ""
"New instances of a `struct` can be constructed with a [struct expression](../"
"expressions/struct-expr.md)."
msgstr "`struct`의 새 인스턴스는 [구조체 표현식](../expressions/struct-expr.md)을 통해 생성될 수 있습니다."

#: src/types/struct.md:16
msgid ""
"The memory layout of a `struct` is undefined by default to allow for "
"compiler optimizations like field reordering, but it can be fixed with the "
"[`repr` attribute](../type-layout.md#representations). In either case, "
"fields may be given in any order in a corresponding struct _expression_; the "
"resulting `struct` value will always have the same memory layout."
msgstr "`struct`의 메모리 레이아웃은 필드 재정렬과 같은 컴파일러 최적화를 허용하기 위해 기본적으로 정의되지 않지만, [`repr` 속성](../type-layout.md#representations)을 사용하여 고정할 수 있습니다. 어떤 경우든 대응하는 구조체 _표현식_에서는 필드를 어떤 순서로든 제공할 수 있으며, 결과물인 `struct` 값은 항상 동일한 메모리 레이아웃을 갖습니다."

#: src/types/struct.md:24
msgid ""
"The fields of a `struct` may be qualified by [visibility modifiers](../"
"visibility-and-privacy.md), to allow access to data in a struct outside a "
"module."
msgstr "`struct`의 필드는 모듈 외부에서 구조체 데이터에 접근할 수 있도록 [가시성 수정자(visibility modifiers)](../visibility-and-privacy.md)로 수식될 수 있습니다."

#: src/types/struct.md:29
msgid ""
"A _tuple struct_ type is just like a struct type, except that the fields are "
"anonymous."
msgstr "_튜플 구조체_ 타입은 필드가 익명이라는 점을 제외하면 구조체 타입과 동일합니다."

#: src/types/struct.md:34
msgid ""
"A _unit-like struct_ type is like a struct type, except that it has no "
"fields. The one value constructed by the associated [struct expression](../"
"expressions/struct-expr.md) is the only value that inhabits such a type."
msgstr "_유닛 형태 구조체_ 타입은 필드가 없다는 점을 제외하면 구조체 타입과 같습니다. 연관된 [구조체 표현식](../expressions/struct-expr.md)에 의해 생성된 유일한 값이 이 타입에 속하는 유일한 값입니다."

#: src/types/struct.md:38
msgid ""
"`struct` types are analogous to `struct` types in C, the _record_ types of "
"the ML family, or the _struct_ types of the Lisp family."
msgstr "`struct` 타입은 C의 `struct` 타입, ML 언어군의 _레코드(record)_ 타입, 또는 Lisp 언어군의 _struct_ 타입과 유사합니다."

#: src/types/enum.md:7
msgid ""
"An _enumerated type_ is a nominal, heterogeneous disjoint union type, "
"denoted by the name of an [`enum` item](../items/enumerations.md). "
"[^enumtype]"
msgstr "_열거형 타입(enumerated type)_은 명목적이고 이종의 서로소 합집합(disjoint union) 타입이며, [`enum` 아이템](../items/enumerations.md)의 이름으로 나타내어집니다. [^enumtype]"

#: src/types/enum.md:12
msgid ""
"An [`enum` item](../items/enumerations.md) declares both the type and a "
"number of _variants_, each of which is independently named and has the "
"syntax of a struct, tuple struct or unit-like struct."
msgstr "[`enum` 아이템](../items/enumerations.md)은 타입과 여러 개의 _변형(variants)_을 선언하며, 각 변형은 독립적인 이름을 가지고 구조체, 튜플 구조체 또는 유닛 형태 구조체의 구문을 가집니다."

#: src/types/enum.md:18
msgid ""
"New instances of an `enum` can be constructed with a [struct expression](../"
"expressions/struct-expr.md)."
msgstr "`enum`의 새 인스턴스는 [구조체 표현식](../expressions/struct-expr.md)을 통해 생성될 수 있습니다."

#: src/types/enum.md:22
msgid ""
"Any `enum` value consumes as much memory as the largest variant for its "
"corresponding `enum` type, as well as the size needed to store a "
"discriminant."
msgstr "모든 `enum` 값은 대응하는 `enum` 타입의 가장 큰 변형만큼의 메모리와 판별자(discriminant)를 저장하는 데 필요한 크기를 소비합니다."

#: src/types/enum.md:27
msgid ""
"Enum types cannot be denoted _structurally_ as types, but must be denoted by "
"named reference to an [`enum` item](../items/enumerations.md)."
msgstr "열거형 타입은 타입으로서 _구조적으로_ 나타낼 수 없으며, 반드시 [`enum` 아이템](../items/enumerations.md)에 대한 이름 있는 참조로 나타내어야 합니다."

#: src/types/enum.md:30
msgid ""
"The `enum` type is analogous to a `data` constructor declaration in Haskell, "
"or a _pick ADT_ in Limbo."
msgstr "`enum` 타입은 Haskell의 `data` 생성자 선언이나 Limbo의 _pick ADT_와 유사합니다."

#: src/types/union.md:7
msgid ""
"A _union type_ is a nominal, heterogeneous C-like union, denoted by the name "
"of a [`union` item](../items/unions.md)."
msgstr "_공용체 타입(union type)_은 명목적이고 이종의 C와 유사한 공용체이며, [`union` 아이템](../items/unions.md)의 이름으로 나타내어집니다."

#: src/types/union.md:12
msgid ""
"Unions have no notion of an \"active field\". Instead, every union access "
"transmutes parts of the content of the union to the type of the accessed "
"field."
msgstr "공용체에는 \"활성 필드\"라는 개념이 없습니다. 대신, 모든 공용체 접근은 공용체 내용의 일부를 접근된 필드의 타입으로 transmute합니다."

#: src/types/union.md:17
msgid ""
"Since transmutes can cause unexpected or undefined behaviour, `unsafe` is "
"required to read from a union field."
msgstr "transmute는 예기치 않거나 정의되지 않은 동작을 유발할 수 있으므로, 공용체 필드에서 읽으려면 `unsafe`가 필요합니다."

#: src/types/union.md:22
msgid ""
"Union field types are also restricted to a subset of types which ensures "
"that they never need dropping. See the [item](../items/unions.md) "
"documentation for further details."
msgstr "공용체 필드 타입은 또한 드롭(drop)이 전혀 필요하지 않음을 보장하는 타입의 서브셋으로 제한됩니다. 자세한 내용은 [아이템](../items/unions.md) 문서를 참조하십시오."

#: src/types/union.md:28
msgid ""
"The memory layout of a `union` is undefined by default (in particular, "
"fields do _not_ have to be at offset 0), but the `#[repr(...)]` attribute "
"can be used to fix a layout."
msgstr "`union`의 메모리 레이아웃은 기본적으로 정의되지 않으며(특히, 필드가 오프셋 0에 위치할 필요가 없음), `#[repr(...)]` 속성을 사용하여 레이아웃을 고정할 수 있습니다."

#: src/types/function-item.md:7
msgid ""
"When referred to, a function item, or the constructor of a tuple-like struct "
"or enum variant, yields a zero-sized value of its _function item type_."
msgstr "참조될 때, 함수 아이템이나 튜플 형태 구조체 또는 열거형 변형의 생성자는 해당 _함수 아이템 타입_의 크기가 0인 값을 생성합니다."

#: src/types/function-item.md:12
msgid ""
"That type explicitly identifies the function - its name, its type arguments, "
"and its early-bound lifetime arguments (but not its late-bound lifetime "
"arguments, which are only assigned when the function is called) - so the "
"value does not need to contain an actual function pointer, and no "
"indirection is needed when the function is called."
msgstr "해당 타입은 함수(이름, 타입 인자, 조기 바인딩된(early-bound) 라이프타임 인자 등. 단, 함수 호출 시에만 할당되는 지연 바인딩된(late-bound) 라이프타임 인자는 제외)를 명시적으로 식별합니다. 따라서 값에 실제 함수 포인터를 포함할 필요가 없으며, 함수 호출 시 간접 참조(indirection)가 필요하지 않습니다."

#: src/types/function-item.md:20
msgid ""
"There is no syntax that directly refers to a function item type, but the "
"compiler will display the type as something like `fn(u32) -> i32 {fn_name}` "
"in error messages."
msgstr "함수 아이템 타입을 직접 참조하는 구문은 없지만, 컴파일러는 오류 메시지에서 해당 타입을 `fn(u32) -> i32 {fn_name}`과 같이 표시합니다."

#: src/types/function-item.md:24
msgid ""
"Because the function item type explicitly identifies the function, the item "
"types of different functions - different items, or the same item with "
"different generics - are distinct, and mixing them will create a type error:"
msgstr "함수 아이템 타입은 함수를 명시적으로 식별하기 때문에, 서로 다른 함수(서로 다른 아이템, 또는 제네릭이 다른 동일 아이템)의 아이템 타입은 구별되며, 이들을 혼합하면 타입 오류가 발생합니다:"

#: src/types/function-item.md:31
msgid "//~ ERROR mismatched types\n"
msgstr "//~ ERROR 타입 불일치\n"

#: src/types/function-item.md:36
msgid ""
"However, there is a [coercion](../type-coercions.md) from function items to "
"[function pointers](function-pointer.md) with the same signature, which is "
"triggered not only when a function item is used when a function pointer is "
"directly expected, but also when different function item types with the same "
"signature meet in different arms of the same `if` or `match`:"
msgstr "그러나 함수 아이템에서 동일한 시그니처를 가진 [함수 포인터](function-pointer.md)로의 [강제 변환(coercion)](../type-coercions.md)이 존재합니다. 이는 함수 포인터가 직접 요구되는 위치에 함수 아이템이 사용될 때뿐만 아니라, 동일한 시그니처를 가진 서로 다른 함수 아이템 타입들이 동일한 `if` 또는 `match`의 서로 다른 암(arm)에서 만날 때도 발생합니다."

#: src/types/function-item.md:45
msgid "// `foo_ptr_1` has function pointer type `fn()` here\n"
msgstr "// 여기서 `foo_ptr_1`은 함수 포인터 타입 `fn()`을 가집니다\n"

#: src/types/function-item.md:48
msgid "// ... and so does `foo_ptr_2` - this type-checks.\n"
msgstr "// ... `foo_ptr_2`도 마찬가지입니다 - 이 코드는 타입 검사를 통과합니다.\n"

#: src/types/function-item.md:59
msgid ""
"All function items implement [`Fn`](../../core/ops/function/trait.Fn.html), "
"[`FnMut`](../../core/ops/function/trait.FnMut.html), [`FnOnce`](../../core/"
"ops/function/trait.FnOnce.html), [`Copy`](../special-types-and-"
"traits.md#copy), [`Clone`](../special-types-and-traits.md#clone), [`Send`]"
"(../special-types-and-traits.md#send), and [`Sync`](../special-types-and-"
"traits.md#sync)."
msgstr "모든 함수 아이템은 [`Fn`](../../core/ops/function/trait.Fn.html), [`FnMut`](../../core/ops/function/trait.FnMut.html), [`FnOnce`](../../core/ops/function/trait.FnOnce.html), [`Copy`](../special-types-and-traits.md#copy), [`Clone`](../special-types-and-traits.md#clone), [`Send`](../special-types-and-traits.md#send), [`Sync`](../special-types-and-traits.md#sync)을 구현합니다."

#: src/types/closure.md:7
msgid ""
"A [closure expression](../expressions/closure-expr.md) produces a closure "
"value with a unique, anonymous type that cannot be written out. A closure "
"type is approximately equivalent to a struct which contains the captured "
"values. For instance, the following closure:"
msgstr "[클로저 표현식](../expressions/closure-expr.md)은 직접 작성할 수 없는 고유하고 익명인 타입을 가진 클로저 값을 생성합니다. 클로저 타입은 캡처된 값들을 포함하는 구조체와 거의 동일합니다. 예를 들어, 다음과 같은 클로저는:"

#: src/types/closure.md:30
msgid "// Prints \"Point { x: 2, y: 1 }\".\n"
msgstr "// \"Point { x: 2, y: 1 }\"을 출력합니다.\n"

#: src/types/closure.md:33
msgid "generates a closure type roughly like the following:"
msgstr "대략 다음과 같은 클로저 타입을 생성합니다:"

#: src/types/closure.md:37
msgid ""
"// Note: This is not exactly how it is translated, this is only for\n"
"// illustration.\n"
msgstr "// 참고: 이것은 실제 번역되는 방식과 정확히 일치하지 않으며, 단지 설명을 위한 것입니다.\n"

#: src/types/closure.md:47 src/types/closure.md:673
msgid "\"rust-call\""
msgstr "\"rust-call\""

#: src/types/closure.md:55
msgid "so that the call to `f` works as if it were:"
msgstr "그리하여 `f`에 대한 호출이 다음과 같이 작동하도록 합니다:"

#: src/types/closure.md:59
msgid ""
"// Note: This is not valid Rust due to the duplicate mutable borrows.\n"
"// This is only provided as an illustration.\n"
msgstr "// 참고: 중복된 가변 차용으로 인해 이는 유효한 러스트 코드가 아닙니다.\n// 이는 오직 설명을 위해서만 제공됩니다.\n"

#: src/types/closure.md:70
msgid ""
"A _capture mode_ determines how a [place expression](../expressions.md#place-"
"expressions-and-value-expressions) from the environment is borrowed or moved "
"into the closure. The capture modes are:"
msgstr "_캡처 모드_는 환경의 [장소 표현식(place expression)](../expressions.md#place-expressions-and-value-expressions)이 클로저 내부로 어떻게 차용되거나 이동되는지를 결정합니다. 캡처 모드는 다음과 같습니다:"

#: src/types/closure.md:73
msgid ""
"Immutable borrow (`ImmBorrow`) --- The place expression is captured as a "
"[shared reference](pointer.md#references--and-mut)."
msgstr "불변 차용 (`ImmBorrow`) --- 장소 표현식이 [공유 참조](pointer.md#references--and-mut)로 캡처됩니다."

#: src/types/closure.md:74
msgid ""
"Unique immutable borrow (`UniqueImmBorrow`) --- This is similar to an "
"immutable borrow, but must be unique as described [below](#unique-immutable-"
"borrows-in-captures)."
msgstr "고유 불변 차용 (`UniqueImmBorrow`) --- 이는 불변 차용과 유사하지만, [아래](#unique-immutable-borrows-in-captures)에 설명된 대로 고유해야 합니다."

#: src/types/closure.md:75
msgid ""
"Mutable borrow (`MutBorrow`) --- The place expression is captured as a "
"[mutable reference](pointer.md#mutable-references-mut)."
msgstr "가변 차용 (`MutBorrow`) --- 장소 표현식이 [가변 참조](pointer.md#mutable-references-mut)로 캡처됩니다."

#: src/types/closure.md:76
msgid ""
"Move (`ByValue`) --- The place expression is captured by [moving the value]"
"(../expressions.md#moved-and-copied-types) into the closure."
msgstr "이동 (`ByValue`) --- [값을 이동](../expressions.md#moved-and-copied-types)시켜서 장소 표현식을 캡처합니다."

#: src/types/closure.md:80
msgid ""
"Place expressions from the environment are captured from the first mode that "
"is compatible with how the captured value is used inside the closure body. "
"The mode is not affected by the code surrounding the closure, such as the "
"lifetimes of involved variables or fields, or of the closure itself."
msgstr "환경의 장소 표현식은 클로저 본문 내에서 캡처된 값이 사용되는 방식과 호환되는 첫 번째 모드로 캡처됩니다. 캡처 모드는 관련된 변수나 필드의 라이프타임, 또는 클로저 자체의 라이프타임과 같은 클로저 주변의 코드에 의해 영향을 받지 않습니다."

#: src/types/closure.md:90
msgid "`Copy` values"
msgstr "`Copy` 값"

#: src/types/closure.md:92
msgid ""
"Values that implement [`Copy`](../special-types-and-traits.md#copy) that are "
"moved into the closure are captured with the `ImmBorrow` mode."
msgstr "클로저 내부로 이동된 [`Copy`](../special-types-and-traits.md#copy)를 구현하는 값은 `ImmBorrow` 모드로 캡처됩니다."

#: src/types/closure.md:97
msgid "// x captured by ImmBorrow\n"
msgstr "// x는 ImmBorrow로 캡처됨\n"

#: src/types/closure.md:103
msgid "Async input capture"
msgstr "비동기 입력 캡처"

#: src/types/closure.md:105
msgid ""
"Async closures always capture all input arguments, regardless of whether or "
"not they are used within the body."
msgstr "비동기 클로저는 본문에서 사용되는지 여부에 관계없이 항상 모든 입력 인자를 캡처합니다."

#: src/types/closure.md:107
msgid "Capture Precision"
msgstr "캡처 정밀도"

#: src/types/closure.md:111
msgid ""
"A _capture path_ is a sequence starting with a variable from the environment "
"followed by zero or more place projections that were applied to that "
"variable."
msgstr "_캡처 경로_는 환경의 변수에서 시작하여 해당 변수에 적용된 0개 이상의 장소 투영(place projection)으로 이어지는 시퀀스입니다."

#: src/types/closure.md:115
msgid ""
"A _place projection_ is a [field access](../expressions/field-expr.md), "
"[tuple index](../expressions/tuple-expr.md#tuple-indexing-expressions), "
"[dereference](../expressions/operator-expr.md#the-dereference-operator) (and "
"automatic dereferences), or [array or slice index](../expressions/array-"
"expr.md#array-and-slice-indexing-expressions) expression applied to a "
"variable."
msgstr "_장소 투영_은 변수에 적용된 [필드 접근](../expressions/field-expr.md), [튜플 인덱스](../expressions/tuple-expr.md#tuple-indexing-expressions), [역참조](../expressions/operator-expr.md#the-dereference-operator)(및 자동 역참조), 또는 [배열이나 슬라이스 인덱스](../expressions/array-expr.md#array-and-slice-indexing-expressions) 표현식입니다."

#: src/types/closure.md:119
msgid ""
"The closure borrows or moves the capture path, which may be truncated based "
"on the rules described below."
msgstr "클로저는 캡처 경로를 차용하거나 이동하며, 이는 아래에 설명된 규칙에 따라 잘릴(truncated) 수 있습니다."

#: src/types/closure.md:130
msgid "// s.f1.1 captured by ImmBorrow\n"
msgstr "// s.f1.1은 ImmBorrow로 캡처됨\n"

#: src/types/closure.md:135
msgid ""
"Here the capture path is the local variable `s`, followed by a field access "
"`.f1`, and then a tuple index `.1`. This closure captures an immutable "
"borrow of `s.f1.1`."
msgstr "여기서 캡처 경로는 로컬 변수 `s`, 필드 접근 `.f1`, 그리고 튜플 인덱스 `.1`로 이어집니다. 이 클로저는 `s.f1.1`의 불변 차용을 캡처합니다."

#: src/types/closure.md:145
msgid "Shared prefix"
msgstr "공유 접두어"

#: src/types/closure.md:147
msgid ""
"In the case where a capture path and one of the ancestor’s of that path are "
"both captured by a closure, the ancestor path is captured with the highest "
"capture mode among the two captures, `CaptureMode = max(AncestorCaptureMode, "
"DescendantCaptureMode)`, using the strict weak ordering:"
msgstr "캡처 경로와 그 경로의 조상 중 하나가 모두 클로저에 의해 캡처되는 경우, 조상 경로는 두 캡처 중 가장 높은 캡처 모드로 캡처됩니다. `CaptureMode = max(조상캡처모드, 자손캡처모드)`이며, 다음의 엄격한 약순서(strict weak ordering)를 사용합니다:"

#: src/types/closure.md:149
msgid "`ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue`"
msgstr "`ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue`"

#: src/types/closure.md:151
msgid "Note that this might need to be applied recursively."
msgstr "이는 재귀적으로 적용되어야 할 수도 있음에 유의하십시오."

#: src/types/closure.md:154
msgid ""
"// In this example, there are three different capture paths with a shared "
"ancestor:\n"
msgstr "// 이 예시에서, 공유된 조상을 가진 세 가지 서로 다른 캡처 경로가 있습니다:\n"

#: src/types/closure.md:156 src/paths.md:136
msgid "\"S\""
msgstr "\"S\""

#: src/types/closure.md:157
msgid "\"T\""
msgstr "\"T\""

#: src/types/closure.md:158
msgid "\"U\""
msgstr "\"U\""

#: src/types/closure.md:161
msgid "// u captured by ImmBorrow\n"
msgstr "// u는 ImmBorrow로 캡처됨\n"

#: src/types/closure.md:162
msgid "// u.0 captured by MutBorrow\n"
msgstr "// u.0은 MutBorrow로 캡처됨\n"

#: src/types/closure.md:163
msgid "// u.0.0 captured by ByValue\n"
msgstr "// u.0.0은 ByValue로 캡처됨\n"

#: src/types/closure.md:168
msgid "Overall this closure will capture `u` by `ByValue`."
msgstr "전체적으로 이 클로저는 `u`를 `ByValue`로 캡처하게 됩니다."

#: src/types/closure.md:172
msgid "Rightmost shared reference truncation"
msgstr "가장 오른쪽 공유 참조 자르기"

#: src/types/closure.md:174
msgid ""
"The capture path is truncated at the rightmost dereference in the capture "
"path if the dereference is applied to a shared reference."
msgstr "공유 참조에 대해 역참조가 적용되는 경우, 캡처 경로는 가장 오른쪽 역참조 지점에서 잘립니다."

#: src/types/closure.md:176
msgid ""
"This truncation is allowed because fields that are read through a shared "
"reference will always be read via a shared reference or a copy. This helps "
"reduce the size of the capture when the extra precision does not yield any "
"benefit from a borrow checking perspective."
msgstr "이러한 자르기가 허용되는 이유는 공유 참조를 통해 읽는 필드는 항상 공유 참조나 복사를 통해 읽히기 때문입니다. 이는 추가적인 정밀도가 차용 검사 관점에서 아무런 이득을 주지 않을 때 캡처 크기를 줄이는 데 도움이 됩니다."

#: src/types/closure.md:179
msgid ""
"The reason it is the _rightmost_ dereference is to help avoid a shorter "
"lifetime than is necessary. Consider the following example:"
msgstr "_가장 오른쪽_ 역참조인 이유는 필요 이상으로 짧은 라이프타임을 피하기 위해서입니다. 다음 예시를 보십시오:"

#: src/types/closure.md:197
msgid ""
"If this were to capture `m`, then the closure would no longer outlive "
"`'static`, since `m` is constrained to `'a`. Instead, it captures "
"`(*(*m).a)` by `ImmBorrow`."
msgstr "만약 이것이 `m`을 캡처한다면, `m`은 `'a`로 제한되어 있으므로 클로저는 더 이상 `'static`보다 오래 살 수 없게 됩니다. 대신, `(*(*m).a)`를 `ImmBorrow`로 캡처합니다."

#: src/types/closure.md:201
msgid "Wildcard pattern bindings"
msgstr "와일드카드 패턴 바인딩"

#: src/types/closure.md:203
msgid ""
"Closures only capture data that needs to be read. Binding a value with a "
"[wildcard pattern](../patterns.md#wildcard-pattern) does not count as a "
"read, and thus won't be captured. For example, the following closures will "
"not capture `x`:"
msgstr "클로저는 읽어야 할 필요가 있는 데이터만 캡처합니다. [와일드카드 패턴](../patterns.md#wildcard-pattern)으로 값을 바인딩하는 것은 읽기로 간주되지 않으며, 따라서 캡처되지 않습니다. 예를 들어, 다음 클로저들은 `x`를 캡처하지 않습니다:"

#: src/types/closure.md:210 src/types/closure.md:214
msgid "// x is not captured\n"
msgstr "// x는 캡처되지 않음\n"

#: src/types/closure.md:215 src/inline-assembly.md:1535
msgid "\"Hello World!\""
msgstr "\"Hello World!\""

#: src/types/closure.md:220
msgid ""
"This also includes destructuring of tuples, structs, and enums. Fields "
"matched with the [_RestPattern_](../patterns.md#rest-patterns) or "
"[_StructPatternEtCetera_](../patterns.md#struct-patterns) are also not "
"considered as read, and thus those fields will not be captured. The "
"following illustrates some of these:"
msgstr "이는 튜플, 구조체, 열거형의 구조 분해에도 포함됩니다. [_나머지 패턴_](../patterns.md#rest-patterns)이나 [_구조체패턴기타_](../patterns.md#struct-patterns)와 매치되는 필드들도 읽기로 간주되지 않으며, 따라서 해당 필드들은 캡처되지 않습니다. 다음은 이에 대한 몇 가지 설명입니다:"

#: src/types/closure.md:227
msgid "// captures `x.0` ByValue\n"
msgstr "// `x.0`을 ByValue로 캡처함\n"

#: src/types/closure.md:228
msgid ""
"// The first tuple field has been moved into the closure.\n"
"// The second tuple field is still accessible.\n"
msgstr "// 첫 번째 튜플 필드는 클로저 내부로 이동되었습니다.\n// 두 번째 튜플 필드는 여전히 접근 가능합니다.\n"

#: src/types/closure.md:242 src/destructors.md:58
msgid "\"first\""
msgstr "\"first\""

#: src/types/closure.md:243
msgid "\"second\""
msgstr "\"second\""

#: src/types/closure.md:246
msgid "// captures `e.f2` ByValue\n"
msgstr "// `e.f2`를 ByValue로 캡처함\n"

#: src/types/closure.md:247
msgid ""
"// Field f2 cannot be accessed since it is moved into the closure.\n"
"// Field f1 is still accessible.\n"
msgstr ""
"// f2 필드는 클로저 내부로 이동되었으므로 접근할 수 없습니다.\n"
"// f1 필드는 여전히 접근 가능합니다.\n"

#: src/types/closure.md:256
msgid ""
"Partial captures of arrays and slices are not supported; the entire slice or "
"array is always captured even if used with wildcard pattern matching, "
"indexing, or sub-slicing. For example:"
msgstr "배열과 슬라이스의 부분 캡처는 지원되지 않습니다. 와일드카드 패턴 매칭, 인덱싱 또는 서브 슬라이싱과 함께 사용되더라도 항상 전체 슬라이스나 배열이 캡처됩니다. 예시:"

#: src/types/closure.md:265
msgid "// captures all of `x` ByValue\n"
msgstr "// `x` 전체를 ByValue로 캡처함\n"

#: src/types/closure.md:268
msgid "// ERROR: borrow of moved value: `x`\n"
msgstr "// ERROR: 이동된 값의 차용: `x`\n"

#: src/types/closure.md:273
msgid "Values that are matched with wildcards must still be initialized."
msgstr "와일드카드와 매치되는 값들도 여전히 초기화되어 있어야 합니다."

#: src/types/closure.md:278
msgid "// ERROR: used binding `x` isn't initialized\n"
msgstr "// ERROR: 사용된 바인딩 `x`가 초기화되지 않음\n"

#: src/types/closure.md:288
msgid "Capturing references in move contexts"
msgstr "이동 컨텍스트에서의 참조 캡처"

#: src/types/closure.md:290
msgid ""
"Because it is not allowed to move fields out of a reference, `move` closures "
"will only capture the prefix of a capture path that runs up to, but not "
"including, the first dereference of a reference. The reference itself will "
"be moved into the closure."
msgstr "참조에서 필드를 끄집어내어 이동하는 것은 허용되지 않으므로, `move` 클로저는 참조의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다. 참조 자체는 클로저 내부로 이동됩니다."

#: src/types/closure.md:299
msgid "// captures `t_mut_ref` ByValue\n"
msgstr "// `t_mut_ref`를 ByValue로 캡처함\n"

#: src/types/closure.md:306
msgid "Raw pointer dereference"
msgstr "원시 포인터 역참조"

#: src/types/closure.md:308
msgid ""
"Because it is `unsafe` to dereference a raw pointer, closures will only "
"capture the prefix of a capture path that runs up to, but not including, the "
"first dereference of a raw pointer."
msgstr "원시 포인터를 역참조하는 것은 `unsafe`하므로, 클로저는 원시 포인터의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다."

#: src/types/closure.md:317
msgid "// captures `t_ptr` by ImmBorrow\n"
msgstr "// `t_ptr`을 ImmBorrow로 캡처함\n"

#: src/types/closure.md:324
msgid "Union fields"
msgstr "공용체 필드"

#: src/types/closure.md:326
msgid ""
"Because it is `unsafe` to access a union field, closures will only capture "
"the prefix of a capture path that runs up to the union itself."
msgstr "공용체 필드에 접근하는 것은 `unsafe`하므로, 클로저는 공용체 자체까지만의 캡처 경로 접두어를 캡처합니다."

#: src/types/closure.md:336
msgid "// captures `u` ByValue\n"
msgstr "// `u`를 ByValue로 캡처함\n"

#: src/types/closure.md:339
msgid "// This also includes writing to fields.\n"
msgstr "// 이는 필드에 쓰는 경우도 포함합니다.\n"

#: src/types/closure.md:344
msgid "// captures `u` with MutBorrow\n"
msgstr "// `u`를 MutBorrow로 캡처함\n"

#: src/types/closure.md:351
msgid "Reference into unaligned `struct`s"
msgstr "정렬되지 않은 `struct`로의 참조"

#: src/types/closure.md:353
msgid ""
"Because it is [undefined behavior](../behavior-considered-undefined.md) to "
"create references to unaligned fields in a structure, closures will only "
"capture the prefix of the capture path that runs up to, but not including, "
"the first field access into a structure that uses [the `packed` "
"representation](../type-layout.md#the-alignment-modifiers). This includes "
"all fields, even those that are aligned, to protect against compatibility "
msgstr "구조체의 정렬되지 않은 필드에 대한 참조를 생성하는 것은 [정의되지 않은 동작(undefined behavior)](../behavior-considered-undefined.md)이므로, 클로저는 [`packed` 표현](../type-layout.md#the-alignment-modifiers)을 사용하는 구조체의 첫 번째 필드 접근 전까지의 캡처 경로 접두어만 캡처합니다. 이는 호환성을 위해 정렬된 필드를 포함한 모든 필드에 적용됩니다."
"concerns should any of the fields in the structure change in the future."
msgstr "구조체의 필드가 나중에 변경될 경우 발생할 수 있는 호환성 문제를 방지하기 위함입니다."

#: src/types/closure.md:363 src/types/closure.md:378
msgid "// captures `t` with ImmBorrow\n"
msgstr "// `t`를 ImmBorrow로 캡처함\n"

#: src/types/closure.md:364
msgid "// Copies out of `t` are ok.\n"
msgstr "// `t`에서 복사하는 것은 괜찮습니다.\n"

#: src/types/closure.md:370
msgid ""
"Similarly, taking the address of an unaligned field also captures the entire "
"struct:"
msgstr "마찬가지로, 정렬되지 않은 필드의 주소를 취하는 것도 구조체 전체를 캡처합니다:"

#: src/types/closure.md:380
msgid "// ERROR: cannot move out of `t.0` because it is borrowed\n"
msgstr "// ERROR: `t.0`이 차용되었으므로 이동할 수 없음\n"

#: src/types/closure.md:384
msgid ""
"but the above works if it is not packed since it captures the field "
"precisely:"
msgstr "하지만 packed가 아니라면 필드를 정밀하게 캡처하므로 위 코드가 작동합니다:"

#: src/types/closure.md:391
msgid "// captures `t.1` with ImmBorrow\n"
msgstr "// `t.1`을 ImmBorrow로 캡처함\n"

#: src/types/closure.md:392
msgid "// The move here is allowed.\n"
msgstr "// 여기서의 이동은 허용됩니다.\n"

#: src/types/closure.md:403
msgid "`Box` vs other `Deref` implementations"
msgstr "`Box` 대 다른 `Deref` 구현체"

#: src/types/closure.md:405
msgid ""
"The implementation of the [`Deref`](../special-types-and-traits.md#deref-and-"
"derefmut) trait for [`Box`](../special-types-and-traits.md#boxt) is treated "
"differently from other `Deref` implementations, as it is considered a "
"special entity."
msgstr "`Box`에 대한 [`Deref`](../special-types-and-traits.md#deref-and-derefmut) 트레잇 구현은 특별한 엔티티로 간주되어 다른 `Deref` 구현과 다르게 취급됩니다."

#: src/types/closure.md:407
msgid ""
"For example, let us look at examples involving `Rc` and `Box`. The `*rc` is "
"desugared to a call to the trait method `deref` defined on `Rc`, but since "
"`*box` is treated differently, it is possible to do a precise capture of the "
"contents of the `Box`."
msgstr "예를 들어, `Rc`와 `Box`가 포함된 예시를 보겠습니다. `*rc`는 `Rc`에 정의된 트레잇 메서드 `deref`의 호출로 디슈거링(desugar)되지만, `*box`는 다르게 취급되므로 `Box` 내부 콘텐츠의 정밀한 캡처가 가능합니다."

#: src/types/closure.md:414
msgid "`Box` with non-`move` closure"
msgstr "non-`move` 클로저에서의 `Box`"

#: src/types/closure.md:416
msgid ""
"In a non-`move` closure, if the contents of the `Box` are not moved into the "
"closure body, the contents of the `Box` are precisely captured."
msgstr "non-`move` 클로저에서 `Box`의 내용물이 클로저 본문으로 이동되지 않는다면, `Box`의 내용물은 정밀하게 캡처됩니다."

#: src/types/closure.md:423
msgid "// captures `(*b).0` by ImmBorrow\n"
msgstr "// `(*b).0`을 ImmBorrow로 캡처함\n"

#: src/types/closure.md:426
msgid "// Contrast `Box` with another type that implements Deref:\n"
msgstr "// `Box`를 Deref를 구현하는 다른 타입과 비교해 보십시오:\n"

#: src/types/closure.md:430
msgid "// captures `r` by ImmBorrow\n"
msgstr "// `r`을 ImmBorrow로 캡처함\n"

#: src/types/closure.md:437
msgid ""
"However, if the contents of the `Box` are moved into the closure, then the "
"box is entirely captured. This is done so the amount of data that needs to "
"be moved into the closure is minimized."
msgstr "그러나 `Box`의 내용물이 클로저로 이동된다면, 박스 전체가 캡처됩니다. 이는 클로저로 이동해야 하는 데이터의 양을 최소화하기 위함입니다."

#: src/types/closure.md:440
msgid ""
"// This is the same as the example above except the closure\n"
"// moves the value instead of taking a reference to it.\n"
msgstr "// 클로저가 참조를 취하는 대신 값을 이동시킨다는 점을 제외하면 위 예시와 동일합니다.\n"

#: src/types/closure.md:447 src/types/closure.md:463
msgid "// captures `b` with ByValue\n"
msgstr "// `b`를 ByValue로 캡처함\n"

#: src/types/closure.md:454
msgid "`Box` with move closure"
msgstr "`move` 클로저에서의 `Box`"

#: src/types/closure.md:456
msgid ""
"Similarly to moving contents of a `Box` in a non-`move` closure, reading the "
"contents of a `Box` in a `move` closure will capture the `Box` entirely."
msgstr "non-`move` 클로저에서 `Box`의 내용을 이동시키는 것과 유사하게, `move` 클로저에서 `Box`의 내용을 읽는 것은 `Box` 전체를 캡처하게 됩니다."

#: src/types/closure.md:469
msgid "Unique immutable borrows in captures"
msgstr "캡처에서의 고유 불변 차용"

#: src/types/closure.md:471
msgid ""
"Captures can occur by a special kind of borrow called a _unique immutable "
"borrow_, which cannot be used anywhere else in the language and cannot be "
"written out explicitly. It occurs when modifying the referent of a mutable "
"reference, as in the following example:"
msgstr "캡처는 _고유 불변 차용(unique immutable borrow)_이라고 불리는 특수한 종류의 차용을 통해 발생할 수 있습니다. 이는 언어의 다른 어디에서도 사용될 수 없으며 명시적으로 작성할 수도 없습니다. 다음 예시와 같이 가변 참조의 대상(referent)을 수정할 때 발생합니다:"

#: src/types/closure.md:479
msgid "// An ImmBorrow and a MutBorrow of `x`.\n"
msgstr "// `x`의 ImmBorrow 및 MutBorrow.\n"

#: src/types/closure.md:481
msgid "// `x` captured by UniqueImmBorrow\n"
msgstr "// `x`는 UniqueImmBorrow로 캡처됨\n"

#: src/types/closure.md:482
msgid ""
"// The following line is an error:\n"
"// let y = &x;\n"
msgstr ""
"// 다음 줄은 오류입니다:\n"
"// let y = &x;\n"

#: src/types/closure.md:485
msgid "// However, the following is OK.\n"
msgstr "// 그러나 다음은 괜찮습니다.\n"

#: src/types/closure.md:490
msgid ""
"In this case, borrowing `x` mutably is not possible, because `x` is not "
"`mut`. But at the same time, borrowing `x` immutably would make the "
"assignment illegal, because a `& &mut` reference might not be unique, so Ta "
"cannot safely be used to modify a value. So a unique immutable borrow is "
"used: it borrows `x` immutably, but like a mutable borrow, it must be unique."
msgstr "이 경우 `x`가 `mut`가 아니므로 `x`를 가변적으로 차용하는 것은 불가능합니다. 하지만 동시에 `x`를 불변으로 차용하면 할당이 불법이 되는데, `& &mut` 참조는 고유하지 않을 수 있어 값을 수정하는 데 안전하게 사용될 수 없기 때문입니다. 따라서 고유 불변 차용이 사용됩니다. 이는 `x`를 불변으로 차용하지만, 가변 차용과 마찬가지로 고유해야 합니다."

#: src/types/closure.md:495
msgid ""
"In the above example, uncommenting the declaration of `y` will produce an "
"error because it would violate the uniqueness of the closure's borrow of "
"`x`; the declaration of z is valid because the closure's lifetime has "
"expired at the end of the block, releasing the borrow."
msgstr "위의 예시에서 `y`의 선언을 주석 해제하면 클로저의 `x` 차용에 대한 고유성을 위반하므로 오류가 발생합니다. z의 선언은 블록 끝에서 클로저의 라이프타임이 만료되어 차용이 해제되었으므로 유효합니다."

#: src/types/closure.md:499
msgid "Call traits and coercions"
msgstr "호출 트레잇 및 강제 변환"

#: src/types/closure.md:503
msgid ""
"Closure types all implement [`FnOnce`](../../core/ops/function/"
"trait.FnOnce.html), indicating that they can be called once by consuming "
"ownership of the closure. Additionally, some closures implement more "
"specific call traits:"
msgstr "모든 클로저 타입은 [`FnOnce`](../../core/ops/function/trait.FnOnce.html)를 구현하며, 이는 클로저의 소유권을 소비함으로써 한 번 호출될 수 있음을 나타냅니다. 또한 일부 클로저는 더 구체적인 호출 트레잇을 구현합니다:"

#: src/types/closure.md:509
msgid ""
"A closure which does not move out of any captured variables implements "
"[`FnMut`](../../core/ops/function/trait.FnMut.html), indicating that it can "
"be called by mutable reference."
msgstr "캡처된 변수 중 어느 것도 밖으로 이동시키지 않는 클로저는 [`FnMut`](../../core/ops/function/trait.FnMut.html)를 구현하며, 이는 가변 참조로 호출될 수 있음을 나타냅니다."

#: src/types/closure.md:514
msgid ""
"A closure which does not mutate or move out of any captured variables "
"implements [`Fn`](../../core/ops/function/trait.Fn.html), indicating that it "
"can be called by shared reference."
msgstr "캡처된 변수를 변경하거나 밖으로 이동시키지 않는 클로저는 [`Fn`](../../core/ops/function/trait.Fn.html)를 구현하며, 이는 공유 참조로 호출될 수 있음을 나타냅니다."

#: src/types/closure.md:517
msgid ""
"Note: `move` closures may still implement [`Fn`](../../core/ops/function/"
"trait.Fn.html) or [`FnMut`](../../core/ops/function/trait.FnMut.html), even "
"though they capture variables by move. This is because the traits "
"implemented by a closure type are determined by what the closure does with "
"captured values, not how it captures them."
msgstr "참고: `move` 클로저는 변수를 이동으로 캡처하더라도 여전히 [`Fn`](../../core/ops/function/trait.Fn.html) 또는 [`FnMut`](../../core/ops/function/trait.FnMut.html)을 구현할 수 있습니다. 이는 클로저 타입이 구현하는 트레잇이 변수를 어떻게 캡처하느냐가 아니라, 캡처된 값으로 무엇을 하느냐에 따라 결정되기 때문입니다."

#: src/types/closure.md:524
msgid ""
"_Non-capturing closures_ are closures that don't capture anything from their "
"environment. Non-async, non-capturing closures can be coerced to function "
"pointers (e.g., `fn()`) with the matching signature."
msgstr "_비캡처 클로저(Non-capturing closures)_는 환경에서 아무것도 캡처하지 않는 클로저입니다. 비동기가 아닌 비캡처 클로저는 일치하는 시그니처를 가진 함수 포인터(예: `fn()`)로 강제 변환될 수 있습니다."

#: src/types/closure.md:540
msgid "Async closure traits"
msgstr "비동기 클로저 트레잇"

#: src/types/closure.md:544
msgid ""
"Async closures have a further restriction of whether or not they implement "
"[`FnMut`](../../core/ops/function/trait.FnMut.html) or [`Fn`](../../core/ops/"
"function/trait.Fn.html)."
msgstr "비동기 클로저는 [`FnMut`](../../core/ops/function/trait.FnMut.html) 또는 [`Fn`](../../core/ops/function/trait.Fn.html) 구현 여부에 대해 추가적인 제한을 가집니다."

#: src/types/closure.md:546
msgid ""
"The [`Future`](../../core/future/future/trait.Future.html) returned by the "
"async closure has similar capturing characteristics as a closure. It "
"captures place expressions from the async closure based on how they are "
"used. The async closure is said to be _lending_ to its [`Future`](../../core/"
"future/future/trait.Future.html) if it has either of the following "
"properties:"
msgstr "비동기 클로저가 반환하는 [`Future`](../../core/future/future/trait.Future.html)는 클로저와 유사한 캡처 특성을 가집니다. 이는 사용 방식에 따라 비동기 클로저로부터 장소 표현식을 캡처합니다. 비동기 클로저가 다음 속성 중 하나를 가지면 [`Future`](../../core/future/future/trait.Future.html)에게 _대여(lending)_ 중이라고 합니다:"

#: src/types/closure.md:548
msgid "The `Future` includes a mutable capture."
msgstr "`Future`가 가변 캡처를 포함하는 경우."

#: src/types/closure.md:549
msgid ""
"The async closure captures by value, except when the value is accessed with "
"a dereference projection."
msgstr "비동기 클로저가 값으로 캡처하는 경우 (단, 역참조 투영을 통해 값에 접근하는 경우는 제외)."

#: src/types/closure.md:551
msgid ""
"If the async closure is lending to its `Future`, then [`FnMut`](../../core/"
"ops/function/trait.FnMut.html) and [`Fn`](../../core/ops/function/"
"trait.Fn.html) are _not_ implemented. [`FnOnce`](../../core/ops/function/"
"trait.FnOnce.html) is always implemented."
msgstr "비동기 클로저가 `Future`에게 대여 중인 경우, [`FnMut`](../../core/ops/function/trait.FnMut.html) 및 [`Fn`](../../core/ops/function/trait.Fn.html)은 구현되지 _않습니다_. [`FnOnce`](../../core/ops/function/trait.FnOnce.html)는 항상 구현됩니다."

#: src/types/closure.md:553
msgid ""
"**Example**: The first clause for a mutable capture can be illustrated with "
"the following:"
msgstr "**예시**: 가변 캡처에 대한 첫 번째 조건은 다음과 같이 설명될 수 있습니다:"

#: src/types/closure.md:561
msgid "// x captured with MutBorrow\n"
msgstr "// x는 MutBorrow로 캡처됨\n"

#: src/types/closure.md:563
msgid "// ERROR: async closure does not implement `FnMut`\n"
msgstr "// ERROR: 비동기 클로저가 `FnMut`를 구현하지 않음\n"

#: src/types/closure.md:567
msgid ""
"The second clause for a regular value capture can be illustrated with the "
"following:"
msgstr "일반 값 캡처에 대한 두 번째 조건은 다음과 같이 설명될 수 있습니다:"

#: src/types/closure.md:575
msgid "// x captured ByValue\n"
msgstr "// x는 ByValue로 캡처됨\n"

#: src/types/closure.md:577
msgid "// ERROR: async closure does not implement `Fn`\n"
msgstr "// ERROR: 비동기 클로저가 `Fn`을 구현하지 않음\n"

#: src/types/closure.md:581
msgid ""
"The exception of the the second clause can be illustrated by using a "
"dereference, which does allow `Fn` and `FnMut` to be implemented:"
msgstr "두 번째 조건의 예외는 역참조를 사용하여 설명될 수 있으며, 이 경우 `Fn` 및 `FnMut` 구현이 허용됩니다:"

#: src/types/closure.md:591
msgid "// OK: implements `Fn`\n"
msgstr "// OK: `Fn`을 구현함\n"

#: src/types/closure.md:597
msgid ""
"Async closures implement [`AsyncFn`](../../core/ops/async_function/"
"trait.AsyncFn.html), [`AsyncFnMut`](../../core/ops/async_function/"
"trait.AsyncFnMut.html), and [`AsyncFnOnce`](../../core/ops/async_function/"
"trait.AsyncFnOnce.html) in an analogous way as regular closures implement "
"[`Fn`](../../core/ops/function/trait.Fn.html), [`FnMut`](../../core/ops/"
"function/trait.FnMut.html), and [`FnOnce`](../../core/ops/function/"
"trait.FnOnce.html); that is, depending on the use of the captured variables "
"in its body."
msgstr "비동기 클로저는 일반 클로저가 [`Fn`](../../core/ops/function/trait.Fn.html), [`FnMut`](../../core/ops/function/trait.FnMut.html), [`FnOnce`](../../core/ops/function/trait.FnOnce.html)을 구현하는 것과 유사한 방식으로 [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html), [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html), [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html)을 구현합니다. 즉, 본문에서 캡처된 변수들이 어떻게 사용되느냐에 따라 결정됩니다."

#: src/types/closure.md:601
msgid "Other traits"
msgstr "기타 트레잇"

#: src/types/closure.md:605
msgid ""
"All closure types implement [`Sized`](../special-types-and-traits.md#sized). "
"Additionally, closure types implement the following traits if allowed to do "
"so by the types of the captures it stores:"
msgstr "모든 클로저 타입은 [`Sized`](../special-types-and-traits.md#sized)를 구현합니다. 또한 클로저 타입은 저장된 캡처 타입들이 허용하는 경우 다음 트레잇들을 구현합니다:"

#: src/types/closure.md:608
msgid "[`Clone`](../special-types-and-traits.md#clone)"
msgstr "[`Clone`](../special-types-and-traits.md#clone)"

#: src/types/closure.md:609
msgid "[`Copy`](../special-types-and-traits.md#copy)"
msgstr "[`Copy`](../special-types-and-traits.md#copy)"

#: src/types/closure.md:610
msgid "[`Sync`](../special-types-and-traits.md#sync)"
msgstr "[`Sync`](../special-types-and-traits.md#sync)"

#: src/types/closure.md:611
msgid "[`Send`](../special-types-and-traits.md#send)"
msgstr "[`Send`](../special-types-and-traits.md#send)"

#: src/types/closure.md:615
msgid ""
"The rules for [`Send`](../special-types-and-traits.md#send) and [`Sync`](../"
"special-types-and-traits.md#sync) match those for normal struct types, while "
"[`Clone`](../special-types-and-traits.md#clone) and [`Copy`](../special-"
"types-and-traits.md#copy) behave as if [derived](../attributes/derive.md). "
"For [`Clone`](../special-types-and-traits.md#clone), the order of cloning of "
"the captured values is left unspecified."
msgstr "[`Send`](../special-types-and-traits.md#send) 및 [`Sync`](../special-types-and-traits.md#sync)에 대한 규칙은 일반 구조체 타입과 일치하며, [`Clone`](../special-types-and-traits.md#clone) 및 [`Copy`](../special-types-and-traits.md#copy)는 마치 [파생(derived)](../attributes/derive.md)된 것처럼 작동합니다. [`Clone`](../special-types-and-traits.md#clone)의 경우, 캡처된 값들이 클로닝되는 순서는 지정되지 않습니다."

#: src/types/closure.md:620
msgid ""
"Because captures are often by reference, the following general rules arise:"
msgstr "캡처는 종종 참조에 의해 발생하므로 다음과 같은 일반적인 규칙이 나타납니다:"

#: src/types/closure.md:622
msgid ""
"A closure is [`Sync`](../special-types-and-traits.md#sync) if all captured "
"values are [`Sync`](../special-types-and-traits.md#sync)."
msgstr "모든 캡처된 값이 [`Sync`](../special-types-and-traits.md#sync)이면 클로저는 [`Sync`](../special-types-and-traits.md#sync)입니다."

#: src/types/closure.md:623
msgid ""
"A closure is [`Send`](../special-types-and-traits.md#send) if all values "
"captured by non-unique immutable reference are [`Sync`](../special-types-and-"
"traits.md#sync), and all values captured by unique immutable or mutable "
"reference, copy, or move are [`Send`](../special-types-and-traits.md#send)."
msgstr "비고유 불변 참조로 캡처된 모든 값이 [`Sync`](../special-types-and-traits.md#sync)이고, 고유 불변 참조나 가변 참조, 복사 또는 이동으로 캡처된 모든 값이 [`Send`](../special-types-and-traits.md#send)이면 클로저는 [`Send`](../special-types-and-traits.md#send)입니다."

#: src/types/closure.md:626
msgid ""
"A closure is [`Clone`](../special-types-and-traits.md#clone) or [`Copy`](../"
"special-types-and-traits.md#copy) if it does not capture any values by "
"unique immutable or mutable reference, and if all values it captures by copy "
"or move are [`Clone`](../special-types-and-traits.md#clone) or [`Copy`](../"
"special-types-and-traits.md#copy), respectively."
msgstr "클로저가 고유 불변 참조나 가변 참조로 값을 캡처하지 않고, 복사나 이동으로 캡처하는 모든 값이 각각 [`Clone`](../special-types-and-traits.md#clone) 또는 [`Copy`](../special-types-and-traits.md#copy)이면 클로저는 [`Clone`](../special-types-and-traits.md#clone) 또는 [`Copy`](../special-types-and-traits.md#copy)입니다."

#: src/types/closure.md:640
msgid "Drop Order"
msgstr "드롭 순서"

#: src/types/closure.md:642
msgid ""
"If a closure captures a field of a composite types such as structs, tuples, "
"and enums by value, the field's lifetime would now be tied to the closure. "
"As a result, it is possible for disjoint fields of a composite types to be "
"dropped at different times."
msgstr "클로저가 구조체, 튜플, 열거형과 같은 복합 타입의 필드를 값으로 캡처하면, 해당 필드의 라이프타임은 이제 클로저에 묶이게 됩니다. 결과적으로 복합 타입의 서로 다른 필드들이 서로 다른 시점에 드롭될 수 있습니다."

#: src/types/closure.md:647
msgid "// --+\n"
msgstr "// --+\n"

#: src/types/closure.md:648
msgid "//                                               |\n"
msgstr "//                                               |\n"

#: src/types/closure.md:649
msgid ""
"// ----------------------------+  |\n"
"            // tuple.0 is captured into the closure |  |\n"
msgstr ""
"// ----------------------------+  |\n"
"            // tuple.0은 클로저 내부로 캡처됨 |  |\n"

#: src/types/closure.md:651
msgid "//                       |  |\n"
msgstr "//                       |  |\n"

#: src/types/closure.md:652
msgid "//                                       |  |\n"
msgstr "//                                       |  |\n"

#: src/types/closure.md:653
msgid "// 'c' and 'tuple.0' dropped here ------------+  |\n"
msgstr "// 'c'와 'tuple.0'이 여기서 드롭됨 ------------+  |\n"

#: src/types/closure.md:654
msgid "// tuple.1 dropped here -----------------------------+\n"
msgstr "// tuple.1이 여기서 드롭됨 -----------------------------+\n"

#: src/types/closure.md:659
msgid "Edition 2018 and before"
msgstr "2018 에디션 및 이전"

#: src/types/closure.md:661
msgid "Closure types difference"
msgstr "클로저 타입의 차이점"

#: src/types/closure.md:663
msgid ""
"In Edition 2018 and before, closures always capture a variable in its "
"entirety, without its precise capture path. This means that for the example "
"used in the [Closure types](#closure-types) section, the generated closure "
"type would instead look something like this:"
msgstr "2018 에디션 및 이전 버전에서, 클로저는 항상 변수 전체를 캡처하며 정밀한 캡처 경로를 사용하지 않습니다. 이는 [클로저 타입](#closure-types) 섹션에서 사용된 예시의 경우, 생성된 클로저 타입이 대신 다음과 같은 모습이 됨을 의미합니다:"

#: src/types/closure.md:681
msgid "and the call to `f` would work as follows:"
msgstr "그리고 `f`에 대한 호출은 다음과 같이 작동합니다:"

#: src/types/closure.md:690
msgid "Capture precision difference"
msgstr "캡처 정밀도의 차이"

#: src/types/closure.md:692
msgid ""
"Composite types such as structs, tuples, and enums are always captured in "
"its entirety, not by individual fields. As a result, it may be necessary to "
"borrow into a local variable in order to capture a single field:"
msgstr "구조체, 튜플, 열거형과 같은 복합 타입은 개별 필드가 아니라 항상 전체가 캡처됩니다. 결과적으로, 단일 필드만 캡처하려면 로컬 변수로 차용해야 할 수도 있습니다:"

#: src/types/closure.md:713
msgid ""
"If, instead, the closure were to use `self.vec` directly, then it would "
"attempt to capture `self` by mutable reference. But since `self.set` is "
"already borrowed to iterate over, the code would not compile."
msgstr "만약 클로저가 `self.vec`을 직접 사용했다면 `self`를 가변 참조로 캡처하려고 시도했을 것입니다. 하지만 `self.set`이 이미 반복을 위해 차용된 상태이므로 코드가 컴파일되지 않았을 것입니다."

#: src/types/closure.md:717
msgid ""
"If the `move` keyword is used, then all captures are by move or, for `Copy` "
"types, by copy, regardless of whether a borrow would work. The `move` "
"keyword is usually used to allow the closure to outlive the captured values, "
"such as if the closure is being returned or used to spawn a new thread."
msgstr "`move` 키워드가 사용되면, 차용이 가능하더라도 모든 캡처는 이동(또는 `Copy` 타입의 경우 복사)에 의해 이루어집니다. `move` 키워드는 보통 클로저가 반환되거나 새 스레드를 생성하는 데 사용되는 경우와 같이, 클로저가 캡처된 값보다 더 오래 살아남을 수 있도록 하기 위해 사용됩니다."

#: src/types/closure.md:721
msgid ""
"Regardless of if the data will be read by the closure, i.e. in case of wild "
"card patterns, if a variable defined outside the closure is mentioned within "
"the closure the variable will be captured in its entirety."
msgstr "와일드카드 패턴의 경우처럼 클로저가 데이터를 실제로 읽는지 여부와 관계없이, 클로저 외부에서 정의된 변수가 클로저 내부에서 언급되면 해당 변수는 전체가 캡처됩니다."

#: src/types/closure.md:725
msgid "Drop order difference"
msgstr "드롭 순서의 차이"

#: src/types/closure.md:727
msgid ""
"As composite types are captured in their entirety, a closure which captures "
"one of those composite types by value would drop the entire captured "
"variable at the same time as the closure gets dropped."
msgstr "복합 타입은 전체가 캡처되므로, 이러한 복합 타입 중 하나를 값으로 캡처하는 클로저는 클로저가 드롭될 때 캡처된 변수 전체를 동시에 드롭합니다."

#: src/types/closure.md:734
msgid ""
"// --------------------------+\n"
"            // tuple is captured into the closure |\n"
msgstr ""
"// --------------------------+\n"
"            // tuple은 클로저 내부로 캡처됨 |\n"
"// --------------------------+\n"
"            // tuple은 클로저 내부로 캡처됨 |\n"

#: src/types/closure.md:736
msgid "//                     |\n"
msgstr "//                     |\n"

#: src/types/closure.md:737
msgid "//                                     |\n"
msgstr "//                                     |\n"

#: src/types/closure.md:738
msgid "// 'c' and 'tuple' dropped here ------------+\n"
msgstr "// 'c'와 'tuple'이 여기서 드롭됨 ------------+\n"

#: src/types/pointer.md:7
msgid ""
"All pointers are explicit first-class values. They can be moved or copied, "
"stored into data structs, and returned from functions."
msgstr "모든 포인터는 명시적인 일급 객체(first-class values)입니다. 이들은 이동하거나 복사할 수 있고, 데이터 구조체에 저장할 수 있으며, 함수에서 반환될 수도 있습니다."

#: src/types/pointer.md:12
msgid "References (`&` and `&mut`)"
msgstr "참조 (`&` 및 `&mut`)"

#: src/types/pointer.md:16
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ReferenceType_ :  \n"
"   `&` [_Lifetime_](../trait-bounds.md)<sup>?</sup> `mut`<sup>?</sup> "
"[_TypeNoBounds_](../types.md#type-expressions)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_참조타입_ :  \n"
"   `&` [_라이프타임_](../trait-bounds.md)<sup>?</sup> `mut`<sup>?</sup> [_바운드없는타입_](../types.md#type-expressions)"
"**<sup>구문</sup>**  \n"
"_참조타입_ :  \n"
"   `&` [_라이프타임_](../trait-bounds.md)<sup>?</sup> `mut`<sup>?</sup> [_바운드없는타입_](../types.md#type-expressions)"

#: src/types/pointer.md:22
msgid "Shared references (`&`)"
msgstr "공유 참조 (`&`)"

#: src/types/pointer.md:26
msgid "Shared references point to memory which is owned by some other value."
msgstr "공유 참조는 다른 어떤 값에 의해 소유된 메모리를 가리킵니다."

#: src/types/pointer.md:30
msgid ""
"When a shared reference to a value is created, it prevents direct mutation "
"of the value. [Interior mutability](../interior-mutability.md) provides an "
"exception for this in certain circumstances. As the name suggests, any "
"number of shared references to a value may exist. A shared reference type is "
"written `&type`, or `&'a type` when you need to specify an explicit lifetime."
msgstr "값에 대한 공유 참조가 생성되면, 해당 값의 직접적인 변경이 방지됩니다. [내부 가변성](../interior-mutability.md)은 특정 상황에서 이에 대한 예외를 제공합니다. 이름에서 알 수 있듯이, 값에 대한 공유 참조는 몇 개든지 존재할 수 있습니다. 공유 참조 타입은 `&type`으로 작성되거나, 명시적인 라이프타임을 지정해야 할 경우 `&'a type`으로 작성됩니다."

#: src/types/pointer.md:37
msgid ""
"Copying a reference is a \"shallow\" operation: it involves only copying the "
"pointer itself, that is, pointers are `Copy`. Releasing a reference has no "
"effect on the value it points to, but referencing of a [temporary value](../"
"expressions.md#temporaries) will keep it alive during the scope of the "
"reference itself."
msgstr "참조 복사는 \"얕은(shallow)\" 연산입니다. 이는 포인터 자체만 복사하며, 즉 포인터는 `Copy`입니다. 참조를 해제하는 것은 가리키는 값에 아무런 영향을 주지 않지만, [임시 값](../expressions.md#temporaries)을 참조하는 경우 참조 자체의 스코프 동안 그 값을 유지합니다."

#: src/types/pointer.md:43
msgid "Mutable references (`&mut`)"
msgstr "가변 참조 (`&mut`)"

#: src/types/pointer.md:47
msgid ""
"Mutable references point to memory which is owned by some other value. A "
"mutable reference type is written `&mut type` or `&'a mut type`."
msgstr "가변 참조는 다른 어떤 값에 의해 소유된 메모리를 가리킵니다. 가변 참조 타입은 `&mut type` 또는 `&'a mut type`으로 작성됩니다."

#: src/types/pointer.md:52
msgid ""
"A mutable reference (that hasn't been borrowed) is the only way to access "
"the value it points to, so is not `Copy`."
msgstr "(차용되지 않은) 가변 참조는 가리키는 값에 접근할 수 있는 유일한 방법이므로, `Copy`가 아닙니다."

#: src/types/pointer.md:56
msgid "Raw pointers (`*const` and `*mut`)"
msgstr "원시 포인터 (`*const` 및 `*mut`)"

#: src/types/pointer.md:60
msgid ""
"**<sup>Syntax</sup>**  \n"
"_RawPointerType_ :  \n"
"   `*` ( `mut` | `const` ) [_TypeNoBounds_](../types.md#type-expressions)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_원시포인터타입_ :  \n"
"   `*` ( `mut` | `const` ) [_바운드없는타입_](../types.md#type-expressions)"

#: src/types/pointer.md:66
msgid ""
"Raw pointers are pointers without safety or liveness guarantees. Raw "
"pointers are written as `*const T` or `*mut T`. For example `*const i32` "
"means a raw pointer to a 32-bit integer."
msgstr "원시 포인터는 안전성이나 생존성(liveness) 보장이 없는 포인터입니다. 원시 포인터는 `*const T` 또는 `*mut T`로 작성됩니다. 예를 들어 `*const i32`는 32비트 정수에 대한 원시 포인터를 의미합니다."

#: src/types/pointer.md:72
msgid ""
"Copying or dropping a raw pointer has no effect on the lifecycle of any "
"other value."
msgstr "원시 포인터를 복사하거나 드롭하는 것은 다른 어떤 값의 수명 주기에도 영향을 미치지 않습니다."

#: src/types/pointer.md:76
msgid "Dereferencing a raw pointer is an [`unsafe` operation](../unsafety.md)."
msgstr "원시 포인터를 역참조하는 것은 [`unsafe` 연산](../unsafety.md)입니다."

#: src/types/pointer.md:78
msgid ""
"This can also be used to convert a raw pointer to a reference by reborrowing "
"it (`&*` or `&mut *`). Raw pointers are generally discouraged; they exist to "
"support interoperability with foreign code, and writing performance-critical "
"or low-level functions."
msgstr "이는 원시 포인터를 다시 차용(`&*` 또는 `&mut *`)하여 참조로 변환하는 데에도 사용될 수 있습니다. 원시 포인터는 일반적으로 권장되지 않습니다. 이들은 외부 코드와의 상호 운용성을 지원하고, 성능에 민감하거나 저수준 함수를 작성하기 위해 존재합니다."

#: src/types/pointer.md:84
msgid ""
"When comparing raw pointers they are compared by their address, rather than "
"by what they point to. When comparing raw pointers to [dynamically sized "
"types](../dynamically-sized-types.md) they also have their additional data "
"compared."
msgstr "원시 포인터를 비교할 때는 가리키는 대상이 아니라 주소로 비교합니다. [동적 크기 타입](../dynamically-sized-types.md)에 대한 원시 포인터를 비교할 때는 추가 데이터도 함께 비교됩니다."

#: src/types/pointer.md:89
msgid ""
"Raw pointers can be created directly using `&raw const` for `*const` "
"pointers and `&raw mut` for `*mut` pointers."
msgstr "원시 포인터는 `*const` 포인터의 경우 `&raw const`를, `*mut` 포인터의 경우 `&raw mut`을 사용하여 직접 생성할 수 있습니다."

#: src/types/pointer.md:93
msgid "Smart Pointers"
msgstr "스마트 포인터"

#: src/types/pointer.md:95
msgid ""
"The standard library contains additional 'smart pointer' types beyond "
"references and raw pointers."
msgstr "표준 라이브러리는 참조와 원시 포인터 외에도 추가적인 '스마트 포인터' 타입을 포함합니다."

#: src/types/pointer.md:103
msgid ""
"Despite pointers and references being similar to `usize`s in the machine "
"code emitted on most platforms, the semantics of transmuting a reference or "
"pointer type to a non-pointer type is currently undecided. Thus, it may not "
"be valid to transmute a pointer or reference type, `P`, to a `[u8; size_of::"
"<P>()]`."
msgstr "대부분의 플랫폼에서 방출되는 기계어 코드상으로 포인터와 참조가 `usize`와 유사함에도 불구하고, 참조나 포인터 타입을 비포인터 타입으로 transmute하는 것의 의미론은 현재 미정입니다. 따라서 포인터나 참조 타입 `P`를 `[u8; size_of::<P>()]`로 transmute하는 것은 유효하지 않을 수 있습니다."

#: src/types/pointer.md:109
msgid ""
"For thin raw pointers (i.e., for `P = *const T` or `P = *mut T` for `T: "
"Sized`), the inverse direction (transmuting from an integer or array of "
"integers to `P`) is always valid. However, the pointer produced via such a "
"transmutation may not be dereferenced (not even if `T` has size zero)."
msgstr "얇은(thin) 원시 포인터의 경우(즉, `T: Sized`에 대해 `P = *const T` 또는 `P = *mut T`), 역방향(정수 또는 정수 배열에서 `P`로 transmute)은 항상 유효합니다. 그러나 이러한 transmute를 통해 생성된 포인터는 역참조할 수 없습니다(`T`의 크기가 0이어도 마찬가지입니다)."

#: src/types/function-pointer.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_BareFunctionType_ :  \n"
"   [_ForLifetimes_](../trait-bounds.md#higher-ranked-trait-bounds)<sup>?</"
"sup> _FunctionTypeQualifiers_ `fn`  \n"
"       `(` _FunctionParametersMaybeNamedVariadic_<sup>?</sup> `)` "
"_BareFunctionReturnType_<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Bare함수타입_ :  \n"
"   [_라이프타임_](../trait-bounds.md#higher-ranked-trait-bounds)<sup>?</sup> _함수타입한정자_ `fn`  \n"
"       `(` _이름있을수있는함수매개변수가변_<sup>?</sup> `)` _Bare함수반환타입_<sup>?</sup>"

#: src/types/function-pointer.md:12
msgid ""
"_FunctionTypeQualifiers_:  \n"
"   `unsafe`<sup>?</sup> (`extern` [_Abi_](../items/functions.md)<sup>?</"
"sup>)<sup>?</sup>"
msgstr ""
"_함수타입한정자_:  \n"
"   `unsafe`<sup>?</sup> (`extern` [_Abi_](../items/functions.md)<sup>?</sup>)<sup>?</sup>"

#: src/types/function-pointer.md:15
msgid ""
"_BareFunctionReturnType_:  \n"
"   `->` [_TypeNoBounds_](../types.md#type-expressions)"
msgstr ""
"_Bare함수반환타입_:  \n"
"   `->` [_바운드없는타입_](../types.md#type-expressions)"

#: src/types/function-pointer.md:18
msgid ""
"_FunctionParametersMaybeNamedVariadic_ :  \n"
"   _MaybeNamedFunctionParameters_ | _MaybeNamedFunctionParametersVariadic_"
msgstr ""
"_이름있을수있는함수매개변수가변_ :  \n"
"   _이름있을수있는함수매개변수_ | _이름있을수있는함수매개변수가변형_"

#: src/types/function-pointer.md:21
msgid ""
"_MaybeNamedFunctionParameters_ :  \n"
"   _MaybeNamedParam_ ( `,` _MaybeNamedParam_ )<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_이름있을수있는함수매개변수_ :  \n"
"   _이름있을수있는매개변수_ ( `,` _이름있을수있는매개변수_ )<sup>*</sup> `,`<sup>?</sup>"

#: src/types/function-pointer.md:24
msgid ""
"_MaybeNamedParam_ :  \n"
"   [_OuterAttribute_](../attributes.md)<sup>\\*</sup> ( ( [IDENTIFIER](../"
"identifiers.md) | `_` ) `:` )<sup>?</sup> [_Type_](../types.md#type-"
"expressions)"
msgstr ""
"_이름있을수있는매개변수_ :  \n"
"   [_외부속성_](../attributes.md)<sup>*</sup> ( ( [식별자](../identifiers.md) | `_` ) `:` )<sup>?</sup> [_타입_](../types.md#type-expressions)"

#: src/types/function-pointer.md:27
msgid ""
"_MaybeNamedFunctionParametersVariadic_ :  \n"
"   ( _MaybeNamedParam_ `,` )<sup>\\*</sup> _MaybeNamedParam_ `,` "
"[_OuterAttribute_](../attributes.md)<sup>\\*</sup> `...`"
msgstr ""
"_이름있을수있는함수매개변수가변형_ :  \n"
"   ( _이름있을수있는매개변수_ `,` )<sup>*</sup> _이름있을수있는매개변수_ `,` "
"[_외부속성_](../attributes.md)<sup>*</sup> `...`"

#: src/types/function-pointer.md:32
msgid ""
"Function pointer types, written using the `fn` keyword, refer to a function "
"whose identity is not necessarily known at compile-time."
msgstr "`fn` 키워드를 사용하여 작성된 함수 포인터 타입은 컴파일 타임에 그 정체가 반드시 알려져 있지는 않은 함수를 참조합니다."

#: src/types/function-pointer.md:35
msgid "An example where `Binop` is defined as a function pointer type:"
msgstr "`Binop`이 함수 포인터 타입으로 정의된 예시:"

#: src/types/function-pointer.md:51
msgid ""
"Function pointers can be created via a coercion from both [function items]"
"(function-item.md) and non-capturing, non-async [closures](closure.md)."
msgstr "함수 포인터는 [함수 아이템](function-item.md) 및 비캡처, 비동기가 아닌 [클로저](closure.md)로부터의 강제 변환을 통해 생성될 수 있습니다."

#: src/types/function-pointer.md:55
msgid ""
"The `unsafe` qualifier indicates that the type's value is an [unsafe "
"function](../unsafe-keyword.md), and the `extern` qualifier indicates it is "
"an [extern function](../items/functions.md#extern-function-qualifier)."
msgstr "`unsafe` 한정자는 해당 타입의 값이 [unsafe 함수](../unsafe-keyword.md)임을 나타내며, `extern` 한정자는 이것이 [extern 함수](../items/functions.md#extern-function-qualifier)임을 나타냅니다."

#: src/types/function-pointer.md:60
msgid ""
"Variadic parameters can only be specified with [`extern`](../items/external-"
"blocks.md) function types with the `\"C\"` or `\"cdecl\"` calling convention."
msgstr "가변 인자(variadic parameters)는 `\"C\"` 또는 `\"cdecl\"` 호출 규약(calling convention)을 사용하는 [`extern`](../items/external-blocks.md) 함수 타입에서만 지정될 수 있습니다."

#: src/types/function-pointer.md:65
msgid "Attributes on function pointer parameters"
msgstr "함수 포인터 매개변수의 속성"

#: src/types/function-pointer.md:67
msgid ""
"Attributes on function pointer parameters follow the same rules and "
"restrictions as [regular function parameters](../items/"
"functions.md#attributes-on-function-parameters)."
msgstr "함수 포인터 매개변수의 속성은 [일반 함수 매개변수](../items/functions.md#attributes-on-function-parameters)와 동일한 규칙 및 제한을 따릅니다."

#: src/types/trait-object.md:3
msgid "Trait objects"
msgstr "트레잇 객체"

#: src/types/trait-object.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TraitObjectType_ :  \n"
"   `dyn`<sup>?</sup> [_TypeParamBounds_](../trait-bounds.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_트레잇객체타입_ :  \n"
"   `dyn`<sup>?</sup> [_타입매개변수바운드_](../trait-bounds.md)"

#: src/types/trait-object.md:11
msgid ""
"_TraitObjectTypeOneBound_ :  \n"
"   `dyn`<sup>?</sup> [_TraitBound_](../trait-bounds.md)"
msgstr ""
"_하나의바운드를가진트레잇객체타입_ :  \n"
"   `dyn`<sup>?</sup> [_트레잇바운드_](../trait-bounds.md)"

#: src/types/trait-object.md:16
msgid ""
"A _trait object_ is an opaque value of another type that implements a set of "
"traits. The set of traits is made up of a [dyn compatible](../items/"
"traits.md#dyn-compatibility) _base trait_ plus any number of [auto traits]"
"(../special-types-and-traits.md#auto-traits)."
msgstr "_트레잇 객체_는 트레잇 집합을 구현하는 다른 타입의 불투명한(opaque) 값입니다. 트레잇 집합은 [dyn 호환(dyn compatible)](../items/traits.md#dyn-compatibility) _기반 트레잇_과 임의 개수의 [자동 트레잇](../special-types-and-traits.md#auto-traits)으로 구성됩니다."

#: src/types/trait-object.md:22
msgid ""
"Trait objects implement the base trait, its auto traits, and any "
"[supertraits](../items/traits.md#supertraits) of the base trait."
msgstr "트레잇 객체는 기반 트레잇, 해당 자동 트레잇, 그리고 기반 트레잇의 모든 [상위 트레잇(supertraits)](../items/traits.md#supertraits)을 구현합니다."

#: src/types/trait-object.md:27
msgid ""
"Trait objects are written as the keyword `dyn` followed by a set of trait "
"bounds, but with the following restrictions on the trait bounds."
msgstr "트레잇 객체는 `dyn` 키워드 뒤에 트레잇 바운드 집합이 오는 형태로 작성되지만, 트레잇 바운드에 다음과 같은 제한이 있습니다."

#: src/types/trait-object.md:32
msgid ""
"There may not be more than one non-auto trait, no more than one lifetime, "
"and opt-out bounds (e.g. `?Sized`) are not allowed. Furthermore, paths to "
"traits may be parenthesized."
msgstr "비자동 트레잇은 하나를 초과할 수 없고, 라이프타임도 하나를 초과할 수 없으며, 제외(opt-out) 바운드(예: `?Sized`)는 허용되지 않습니다. 또한, 트레잇 경로는 괄호로 묶을 수 있습니다."

#: src/types/trait-object.md:36
msgid ""
"For example, given a trait `Trait`, the following are all trait objects:"
msgstr "예를 들어, `Trait`라는 트레잇이 주어졌을 때, 다음은 모두 트레잇 객체입니다:"

#: src/types/trait-object.md:38
msgid "`dyn Trait`"
msgstr "`dyn Trait`"

#: src/types/trait-object.md:39
msgid "`dyn Trait + Send`"
msgstr "`dyn Trait + Send`"

#: src/types/trait-object.md:40
msgid "`dyn Trait + Send + Sync`"
msgstr "`dyn Trait + Send + Sync`"

#: src/types/trait-object.md:41
msgid "`dyn Trait + 'static`"
msgstr "`dyn Trait + 'static`"

#: src/types/trait-object.md:42
msgid "`dyn Trait + Send + 'static`"
msgstr "`dyn Trait + Send + 'static`"

#: src/types/trait-object.md:43
msgid "`dyn Trait +`"
msgstr "`dyn Trait +`"

#: src/types/trait-object.md:44
msgid "`dyn 'static + Trait`."
msgstr "`dyn 'static + Trait`."

#: src/types/trait-object.md:45
msgid "`dyn (Trait)`"
msgstr "`dyn (Trait)`"

#: src/types/trait-object.md:49
msgid ""
"**Edition differences**: Before the 2021 edition, the `dyn` keyword may be "
"omitted."
msgstr "**에디션 차이**: 2021 에디션 이전에는 `dyn` 키워드를 생략할 수 있었습니다."

#: src/types/trait-object.md:52
msgid ""
"Note: For clarity, it is recommended to always use the `dyn` keyword on your "
"trait objects unless your codebase supports compiling with Rust 1.26 or "
"lower."
msgstr "참고: 코드베이스가 Rust 1.26 이하에서의 컴파일을 지원해야 하는 경우가 아니라면, 명확성을 위해 트레잇 객체에 항상 `dyn` 키워드를 사용하는 것이 권장됩니다."

#: src/types/trait-object.md:57
msgid ""
"**Edition differences**: In the 2015 edition, if the first bound of the "
"trait object is a path that starts with `::`, then the `dyn` will be treated "
"as a part of the path. The first path can be put in parenthesis to get "
"around this. As such, if you want a trait object with the trait "
"`::your_module::Trait`, you should write it as `dyn (::your_module::Trait)`."
msgstr "**에디션 차이**: 2015 에디션에서 트레잇 객체의 첫 번째 바운드가 `::`로 시작하는 경로인 경우, `dyn`은 경로의 일부로 취급됩니다. 첫 번째 경로를 괄호로 묶으면 이를 피할 수 있습니다. 따라서 `::your_module::Trait` 트레잇을 가진 트레잇 객체를 원한다면, `dyn (::your_module::Trait)`라고 작성해야 합니다."

#: src/types/trait-object.md:63
msgid ""
"Beginning in the 2018 edition, `dyn` is a true keyword and is not allowed in "
"paths, so the parentheses are not necessary."
msgstr "2018 에디션부터 `dyn`은 진정한 키워드이며 경로에 허용되지 않으므로, 괄호가 필요하지 않습니다."

#: src/types/trait-object.md:68
msgid ""
"Two trait object types alias each other if the base traits alias each other "
"and if the sets of auto traits are the same and the lifetime bounds are the "
"same. For example, `dyn Trait + Send + UnwindSafe` is the same as `dyn Trait "
"+ UnwindSafe + Send`."
msgstr "기반 트레잇이 서로 별칭(alias) 관계이고 자동 트레잇 집합과 라이프타임 바운드가 동일하다면, 두 트레잇 객체 타입은 서로 별칭 관계입니다. 예를 들어, `dyn Trait + Send + UnwindSafe`는 `dyn Trait + UnwindSafe + Send`와 같습니다."

#: src/types/trait-object.md:75
msgid ""
"Due to the opaqueness of which concrete type the value is of, trait objects "
"are [dynamically sized types](../dynamically-sized-types.md). Like all <abbr "
"title=\"dynamically sized types\">DSTs</abbr>, trait objects are used behind "
"some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`. "
"Each instance of a pointer to a trait object includes:"
msgstr "값이 어떤 구체적인 타입인지 불투명하기 때문에, 트레잇 객체는 [동적 크기 타입](../dynamically-sized-types.md)입니다. 모든 <abbr title=\"dynamically sized types\">DST</abbr>와 마찬가지로, 트레잇 객체는 `&dyn SomeTrait` 또는 `Box<dyn SomeTrait>`와 같이 어떤 포인터 타입 뒤에서 사용됩니다. 트레잇 객체에 대한 포인터의 각 인스턴스는 다음을 포함합니다:"

#: src/types/trait-object.md:81
msgid "a pointer to an instance of a type `T` that implements `SomeTrait`"
msgstr "`SomeTrait`를 구현하는 타입 `T`의 인스턴스에 대한 포인터"

#: src/types/trait-object.md:82
msgid ""
"a _virtual method table_, often just called a _vtable_, which contains, for "
"each method of `SomeTrait` and its [supertraits](../items/"
"traits.md#supertraits) that `T` implements, a pointer to `T`'s "
"implementation (i.e. a function pointer)."
msgstr "_가상 메서드 테이블_(흔히 _vtable_이라고 함)은 `T`가 구현하는 `SomeTrait` 및 그 [상위 트레잇](../items/traits.md#supertraits)의 각 메서드에 대해 `T`의 구현에 대한 포인터(즉, 함수 포인터)를 포함합니다."

#: src/types/trait-object.md:86
msgid ""
"The purpose of trait objects is to permit \"late binding\" of methods. "
"Calling a method on a trait object results in virtual dispatch at runtime: "
"that is, a function pointer is loaded from the trait object vtable and "
"invoked indirectly. The actual implementation for each vtable entry can vary "
"on an object-by-object basis."
msgstr "트레잇 객체의 목적은 메서드의 \"지연 바인딩(late binding)\"을 허용하는 것입니다. 트레잇 객체에서 메서드를 호출하면 런타임에 가상 디스패치(virtual dispatch)가 발생합니다. 즉, 트레잇 객체 vtable에서 함수 포인터를 로드하여 간접적으로 호출합니다. 각 vtable 항목에 대한 실제 구현은 객체마다 다를 수 있습니다."

#: src/types/trait-object.md:92
msgid "An example of a trait object:"
msgstr "트레잇 객체의 예시:"

#: src/types/trait-object.md:112
msgid ""
"In this example, the trait `Printable` occurs as a trait object in both the "
"type signature of `print`, and the cast expression in `main`."
msgstr "이 예시에서, 트레잇 `Printable`은 `print`의 타입 시그니처와 `main`의 캐스트 표현식 양쪽 모두에서 트레잇 객체로 나타납니다."

#: src/types/trait-object.md:117
msgid "Trait Object Lifetime Bounds"
msgstr "트레잇 객체 라이프타임 바운드"

#: src/types/trait-object.md:119
msgid ""
"Since a trait object can contain references, the lifetimes of those "
"references need to be expressed as part of the trait object. This lifetime "
"is written as `Trait + 'a`. There are [defaults](../lifetime-"
"elision.md#default-trait-object-lifetimes) that allow this lifetime to "
"usually be inferred with a sensible choice."
msgstr "트레잇 객체는 참조를 포함할 수 있으므로, 해당 참조들의 라이프타임은 트레잇 객체의 일부로 표현되어야 합니다. 이 라이프타임은 `Trait + 'a`로 작성됩니다. [기본값](../lifetime-elision.md#default-trait-object-lifetimes)이 있어 보통은 이 라이프타임이 합리적인 선택으로 추론될 수 있게 합니다."

#: src/types/impl-trait.md:3
msgid "Impl trait"
msgstr "Impl 트레잇"

#: src/types/impl-trait.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_ImplTraitType_ : `impl` [_TypeParamBounds_](../trait-bounds.md)"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Impl트레잇타입_ : `impl` [_타입매개변수바운드_](../trait-bounds.md)"

#: src/types/impl-trait.md:10
msgid "_ImplTraitTypeOneBound_ : `impl` [_TraitBound_](../trait-bounds.md)"
msgstr "_하나의바운드를가진Impl트레잇타입_ : `impl` [_트레잇바운드_](../trait-bounds.md)"

#: src/types/impl-trait.md:14
msgid ""
"`impl Trait` provides ways to specify unnamed but concrete types that "
"implement a specific trait. It can appear in two sorts of places: argument "
"position (where it can act as an anonymous type parameter to functions), and "
"return position (where it can act as an abstract return type)."
msgstr "`impl Trait`는 특정 트레잇을 구현하는 이름은 없지만 구체적인 타입을 지정하는 방법을 제공합니다. 이는 두 가지 위치에 나타날 수 있습니다: 인자 위치(함수에 대한 익명 타입 매개변수 역할)와 반환 위치(추상 반환 타입 역할)입니다."

#: src/types/impl-trait.md:21
msgid "// argument position: anonymous type parameter\n"
msgstr "// 인자 위치: 익명 타입 매개변수\n"

#: src/types/impl-trait.md:25
msgid "// return position: abstract return type\n"
msgstr "// 반환 위치: 추상 반환 타입\n"

#: src/types/impl-trait.md:32
msgid "Anonymous type parameters"
msgstr "익명 타입 매개변수"

#: src/types/impl-trait.md:34
msgid ""
"Note: This is often called \"impl Trait in argument position\". (The term "
"\"parameter\" is more correct here, but \"impl Trait in argument position\" "
"is the phrasing used during the development of this feature, and it remains "
"in parts of the implementation.)"
msgstr "참고: 이는 흔히 \"인자 위치의 impl Trait\"라고 불립니다. (여기서는 \"매개변수\"라는 용어가 더 정확하지만, \"인자 위치의 impl Trait\"는 이 기능의 개발 중에 사용된 표현이며 구현의 일부에 남아 있습니다.)"

#: src/types/impl-trait.md:39
msgid ""
"Functions can use `impl` followed by a set of trait bounds to declare a "
"parameter as having an anonymous type. The caller must provide a type that "
"satisfies the bounds declared by the anonymous type parameter, and the "
"function can only use the methods available through the trait bounds of the "
"anonymous type parameter."
msgstr "함수는 `impl` 뒤에 트레잇 바운드 집합을 사용하여 매개변수가 익명 타입을 갖도록 선언할 수 있습니다. 호출자는 익명 타입 매개변수에 선언된 바운드를 만족하는 타입을 제공해야 하며, 함수는 익명 타입 매개변수의 트레잇 바운드를 통해 사용할 수 있는 메서드만 사용할 수 있습니다."

#: src/types/impl-trait.md:42
msgid "For example, these two forms are almost equivalent:"
msgstr "예를 들어, 다음 두 형식은 거의 동일합니다:"

#: src/types/impl-trait.md:46
msgid "// generic type parameter\n"
msgstr "// 제네릭 타입 매개변수\n"

#: src/types/impl-trait.md:50
msgid "// impl Trait in argument position\n"
msgstr "// 인자 위치의 impl Trait\n"

#: src/types/impl-trait.md:58
msgid ""
"That is, `impl Trait` in argument position is syntactic sugar for a generic "
"type parameter like `<T: Trait>`, except that the type is anonymous and "
"doesn't appear in the [_GenericParams_](../items/generics.md) list."
msgstr "즉, 인자 위치의 `impl Trait`는 `<T: Trait>`와 같은 제네릭 타입 매개변수에 대한 문법적 설탕(syntactic sugar)입니다. 단, 타입이 익명이며 [_제네릭 매개변수_](../items/generics.md) 목록에 나타나지 않는다는 점이 다릅니다."

#: src/types/impl-trait.md:60
msgid ""
"**Note:** For function parameters, generic type parameters and `impl Trait` "
"are not exactly equivalent. With a generic parameter such as `<T: Trait>`, "
"the caller has the option to explicitly specify the generic argument for `T` "
"at the call site using [_GenericArgs_](../paths.md#paths-in-expressions), "
"for example, `foo::<usize>(1)`. Changing a parameter from either one to the "
"other can constitute a breaking change for the callers of a function, since "
"this changes the number of generic arguments."
msgstr "**참고:** 함수 매개변수의 경우, 제네릭 타입 매개변수와 `impl Trait`가 정확히 동일하지는 않습니다. `<T: Trait>`와 같은 제네릭 매개변수를 사용하면, 호출자는 호출 지점에서 [_제네릭 인자_](../paths.md#paths-in-expressions)를 사용하여 `T`에 대한 제네릭 인자를 명시적으로 지정할 수 있는 옵션이 있습니다(예: `foo::<usize>(1)`). 매개변수를 둘 중 하나에서 다른 것으로 변경하는 것은 제네릭 인자의 수를 변경하므로 함수 호출자에게 주요 변경 사항(breaking change)이 될 수 있습니다."

#: src/types/impl-trait.md:67
msgid "Abstract return types"
msgstr "추상 반환 타입"

#: src/types/impl-trait.md:69
msgid "Note: This is often called \"impl Trait in return position\"."
msgstr "참고: 이는 흔히 \"반환 위치의 impl Trait\"라고 불립니다."

#: src/types/impl-trait.md:73
msgid ""
"Functions can use `impl Trait` to return an abstract return type. These "
"types stand in for another concrete type where the caller may only use the "
"methods declared by the specified `Trait`."
msgstr "함수는 `impl Trait`를 사용하여 추상 반환 타입을 반환할 수 있습니다. 이러한 타입은 호출자가 지정된 `Trait`에 의해 선언된 메서드만 사용할 수 있는 다른 구체적인 타입을 대신합니다."

#: src/types/impl-trait.md:78
msgid ""
"Each possible return value from the function must resolve to the same "
"concrete type."
msgstr "함수에서 가능한 각 반환 값은 동일한 구체적인 타입으로 해석되어야 합니다."

#: src/types/impl-trait.md:80
msgid ""
"`impl Trait` in return position allows a function to return an unboxed "
"abstract type. This is particularly useful with [closures](closure.md) and "
"iterators. For example, closures have a unique, un-writable type. "
"Previously, the only way to return a closure from a function was to use a "
"[trait object](trait-object.md):"
msgstr "반환 위치의 `impl Trait`는 함수가 박싱되지 않은(unboxed) 추상 타입을 반환할 수 있게 합니다. 이는 [클로저](closure.md) 및 반복자와 함께 사용할 때 특히 유용합니다. 예를 들어, 클로저는 작성할 수 없는 고유한 타입을 가집니다. 이전에는 함수에서 클로저를 반환하는 유일한 방법이 [트레잇 객체](trait-object.md)를 사용하는 것이었습니다:"

#: src/types/impl-trait.md:91
msgid ""
"This could incur performance penalties from heap allocation and dynamic "
"dispatch. It wasn't possible to fully specify the type of the closure, only "
"to use the `Fn` trait. That means that the trait object is necessary. "
"However, with `impl Trait`, it is possible to write this more simply:"
msgstr "이는 힙 할당 및 동적 디스패치로 인한 성능 저하를 초래할 수 있습니다. 클로저의 타입을 완전히 명시하는 것은 불가능했고, 오직 `Fn` 트레잇만 사용할 수 있었습니다. 즉, 트레잇 객체가 필요하다는 뜻입니다. 하지만 `impl Trait`를 사용하면 이를 더 간단하게 작성할 수 있습니다:"

#: src/types/impl-trait.md:102
msgid "which also avoids the drawbacks of using a boxed trait object."
msgstr "이는 또한 박싱된 트레잇 객체 사용의 단점을 피할 수 있게 해줍니다."

#: src/types/impl-trait.md:104
msgid ""
"Similarly, the concrete types of iterators could become very complex, "
"incorporating the types of all previous iterators in a chain. Returning "
"`impl Iterator` means that a function only exposes the `Iterator` trait as a "
"bound on its return type, instead of explicitly specifying all of the other "
"iterator types involved."
msgstr "마찬가지로, 반복자의 구체적인 타입은 체인에 있는 이전의 모든 반복자의 타입을 포함하여 매우 복잡해질 수 있습니다. `impl Iterator`를 반환한다는 것은 함수가 관련된 다른 모든 반복자 타입을 명시적으로 지정하는 대신, 반환 타입에 대한 바운드로서 `Iterator` 트레잇만을 노출한다는 것을 의미합니다."

#: src/types/impl-trait.md:109
msgid "Return-position `impl Trait` in traits and trait implementations"
msgstr "트레잇 및 트레잇 구현에서의 반환 위치 `impl Trait`"

#: src/types/impl-trait.md:113
msgid ""
"Functions in traits may also use `impl Trait` as a syntax for an anonymous "
"associated type."
msgstr "트레잇 내의 함수들도 익명 연관 타입을 위한 구문으로 `impl Trait`를 사용할 수 있습니다."

#: src/types/impl-trait.md:117
msgid ""
"Every `impl Trait` in the return type of an associated function in a trait "
"is desugared to an anonymous associated type. The return type that appears "
"in the implementation's function signature is used to determine the value of "
"the associated type."
msgstr "트레잇 내 연관 함수의 반환 타입에 있는 모든 `impl Trait`는 익명 연관 타입으로 디슈거링(desugared)됩니다. 구현의 함수 시그니처에 나타나는 반환 타입이 연관 타입의 값을 결정하는 데 사용됩니다."

#: src/types/impl-trait.md:121
msgid "Capturing"
msgstr "캡처링"

#: src/types/impl-trait.md:123
msgid ""
"Behind each return-position `impl Trait` abstract type is some hidden "
"concrete type.  For this concrete type to use a generic parameter, that "
"generic parameter must be _captured_ by the abstract type."
msgstr "각 반환 위치 `impl Trait` 추상 타입 뒤에는 숨겨진 구체적인 타입이 있습니다. 이 구체적인 타입이 제네릭 매개변수를 사용하려면, 해당 제네릭 매개변수가 추상 타입에 의해 _캡처_되어야 합니다."

#: src/types/impl-trait.md:127
msgid "Automatic capturing"
msgstr "자동 캡처링"

#: src/types/impl-trait.md:131
msgid ""
"Return-position `impl Trait` abstract types automatically capture all in-"
"scope generic parameters, including generic type, const, and lifetime "
"parameters (including higher-ranked ones)."
msgstr "반환 위치의 `impl Trait` 추상 타입은 제네릭 타입, 상수, 라이프타임 매개변수(고차원(higher-ranked) 매개변수 포함)를 포함한 스코프 내의 모든 제네릭 매개변수를 자동으로 캡처합니다."

#: src/types/impl-trait.md:135
msgid ""
"**Edition differences**: Before the 2024 edition, on free functions and on "
"associated functions and methods of inherent impls, generic lifetime "
"parameters that do not appear in the bounds of the abstract return type are "
"not automatically captured."
msgstr "**에디션 차이**: 2024 에디션 이전에는, 자유 함수(free functions)와 고유 구현(inherent impls)의 연관 함수 및 메서드에서, 추상 반환 타입의 바운드에 나타나지 않는 제네릭 라이프타임 매개변수는 자동으로 캡처되지 않습니다."

#: src/types/impl-trait.md:139
msgid "Precise capturing"
msgstr "정밀 캡처링"

#: src/types/impl-trait.md:143
msgid ""
"The set of generic parameters captured by a return-position `impl Trait` "
"abstract type may be explicitly controlled with a [`use<..>` bound](../trait-"
"bounds.md#use-bounds).  If present, only the generic parameters listed in "
"the `use<..>` bound will be captured.  E.g.:"
msgstr "반환 위치의 `impl Trait` 추상 타입에 의해 캡처되는 제네릭 매개변수 집합은 [`use<..>` 바운드](../trait-bounds.md#use-bounds)를 사용하여 명시적으로 제어할 수 있습니다. 이것이 존재하면, `use<..>` 바운드에 나열된 제네릭 매개변수만 캡처됩니다. 예:"

#: src/types/impl-trait.md:147
msgid ""
"//                                      ~~~~~~~~~~~~~~~~~~~~~~~\n"
"  //                                     Captures `'a` and `T` only.\n"
msgstr ""
"//                                      ~~~~~~~~~~~~~~~~~~~~~~~\n"
"  //                                     오직 `'a`와 `T`만 캡처합니다.\n"

#: src/types/impl-trait.md:155
msgid ""
"Currently, only one `use<..>` bound may be present in a bounds list, such "
"bounds are not allowed in the signature of items of a trait definition, all "
"in-scope type and const generic parameters must be included, and all "
"lifetime parameters that appear in other bounds of the abstract type must be "
"included."
msgstr "현재 바운드 목록에는 `use<..>` 바운드가 하나만 존재할 수 있으며, 트레잇 정의의 아이템 시그니처에는 이러한 바운드가 허용되지 않습니다. 또한 스코프 내의 모든 타입 및 상수 제네릭 매개변수가 포함되어야 하며, 추상 타입의 다른 바운드에 나타나는 모든 라이프타임 매개변수도 포함되어야 합니다."

#: src/types/impl-trait.md:159
msgid ""
"Within the `use<..>` bound, any lifetime parameters present must appear "
"before all type and const generic parameters, and the elided lifetime (`'_`) "
"may be present if it is otherwise allowed to appear within the `impl Trait` "
"return type."
msgstr "`use<..>` 바운드 내에서, 존재하는 모든 라이프타임 매개변수는 모든 타입 및 상수 제네릭 매개변수보다 앞에 나타나야 하며, `impl Trait` 반환 타입 내에서 허용되는 경우 생략된 라이프타임(`'_`)이 나타날 수 있습니다."

#: src/types/impl-trait.md:163
msgid ""
"Because all in-scope type parameters must be included by name, a `use<..>` "
"bound may not be used in the signature of items that use argument-position "
"`impl Trait`, as those items have anonymous type parameters in scope."
msgstr "스코프 내의 모든 타입 매개변수가 이름으로 포함되어야 하므로, 인자 위치 `impl Trait`를 사용하는 아이템의 시그니처에는 `use<..>` 바운드를 사용할 수 없습니다. 해당 아이템들은 스코프 내에 익명 타입 매개변수를 갖기 때문입니다."

#: src/types/impl-trait.md:165
msgid "Differences between generics and `impl Trait` in return position"
msgstr "반환 위치에서의 제네릭과 `impl Trait`의 차이점"

#: src/types/impl-trait.md:167
msgid ""
"In argument position, `impl Trait` is very similar in semantics to a generic "
"type parameter. However, there are significant differences between the two "
"in return position. With `impl Trait`, unlike with a generic type parameter, "
"the function chooses the return type, and the caller cannot choose the "
"return type."
msgstr "인자 위치에서 `impl Trait`는 의미론적으로 제네릭 타입 매개변수와 매우 유사합니다. 그러나 반환 위치에서는 둘 사이에 중요한 차이가 있습니다. `impl Trait`를 사용하면 제네릭 타입 매개변수와 달리 함수가 반환 타입을 선택하며, 호출자는 반환 타입을 선택할 수 없습니다."

#: src/types/impl-trait.md:171 src/types/impl-trait.md:183
msgid "The function:"
msgstr "다음 함수는:"

#: src/types/impl-trait.md:181
msgid ""
"allows the caller to determine the return type, `T`, and the function "
"returns that type."
msgstr "호출자가 반환 타입 `T`를 결정하도록 허용하며, 함수는 해당 타입을 반환합니다."

#: src/types/impl-trait.md:193
msgid ""
"doesn't allow the caller to determine the return type. Instead, the function "
"chooses the return type, but only promises that it will implement `Trait`."
msgstr "호출자가 반환 타입을 결정하는 것을 허용하지 않습니다. 대신 함수가 반환 타입을 선택하지만, 오직 그 타입이 `Trait`를 구현한다는 것만 약속합니다."

#: src/types/impl-trait.md:200
msgid ""
"`impl Trait` can only appear as a parameter or return type of a non-`extern` "
"function. It cannot be the type of a `let` binding, field type, or appear "
"inside a type alias."
msgstr "`impl Trait`는 `extern`이 아닌 함수의 매개변수 또는 반환 타입으로만 나타날 수 있습니다. `let` 바인딩의 타입이나 필드 타입이 될 수 없으며, 타입 별칭 내부에 나타날 수 없습니다."

#: src/types/parameters.md:5
msgid ""
"Within the body of an item that has type parameter declarations, the names "
"of its type parameters are types:"
msgstr "타입 매개변수 선언이 있는 아이템의 본문 내에서, 해당 타입 매개변수의 이름은 타입입니다:"

#: src/types/parameters.md:20
msgid ""
"Here, `first` has type `A`, referring to `to_vec`'s `A` type parameter; and "
"`rest` has type `Vec<A>`, a vector with element type `A`."
msgstr "여기서 `first`는 `to_vec`의 `A` 타입 매개변수를 참조하는 `A` 타입을 가지며, `rest`는 요소 타입이 `A`인 벡터 `Vec<A>` 타입을 가집니다."

#: src/types/inferred.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_InferredType_ : `_`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_추론된타입_ : `_`"

#: src/types/inferred.md:12
msgid ""
"The inferred type asks the compiler to infer the type if possible based on "
"the surrounding information available."
msgstr "추론된 타입은 컴파일러에게 사용 가능한 주변 정보를 기반으로 가능한 경우 타입을 추론하도록 요청합니다."

#: src/types/inferred.md:17
msgid "It cannot be used in item signatures."
msgstr "이는 아이템 시그니처에서 사용될 수 없습니다."

#: src/types/inferred.md:19
msgid "It is often used in generic arguments:"
msgstr "이는 흔히 제네릭 인자에서 사용됩니다:"

#: src/dynamically-sized-types.md:8
msgid ""
"Most types have a fixed size that is known at compile time and implement the "
"trait [`Sized`](special-types-and-traits.md#sized). A type with a size that "
"is known only at run-time is called a _dynamically sized type_ (_DST_) or, "
"informally, an unsized type. [Slices](types/slice.md) and [trait objects]"
"(types/trait-object.md) are two examples of <abbr title=\"dynamically sized\n"
"types\">DSTs</abbr>."
msgstr "대부분의 타입은 컴파일 타임에 알려진 고정된 크기를 가지며 [`Sized`](special-types-and-traits.md#sized) 트레잇을 구현합니다. 런타임에만 크기가 알려지는 타입을 _동적 크기 타입_(_DST_) 또는 비공식적으로 크기가 없는(unsized) 타입이라고 부릅니다. [슬라이스](types/slice.md)와 [트레잇 객체](types/trait-object.md)는 <abbr title=\"dynamically sized types\">DST</abbr>의 두 가지 예입니다."

#: src/dynamically-sized-types.md:16
msgid "Such types can only be used in certain cases:"
msgstr "이러한 타입은 특정 경우에만 사용될 수 있습니다:"

#: src/dynamically-sized-types.md:20
msgid ""
"[Pointer types](types/pointer.md) to <abbr title=\"dynamically sized "
"types\">DSTs</abbr> are sized but have twice the size of pointers to sized "
"types"
msgstr "<abbr title=\"dynamically sized types\">DST</abbr>에 대한 [포인터 타입](types/pointer.md)은 크기가 있지만, 크기가 있는 타입에 대한 포인터보다 두 배의 크기를 가집니다."

#: src/dynamically-sized-types.md:22
msgid "Pointers to slices also store the number of elements of the slice."
msgstr "슬라이스에 대한 포인터는 슬라이스의 요소 수도 저장합니다."

#: src/dynamically-sized-types.md:23
msgid "Pointers to trait objects also store a pointer to a vtable."
msgstr "트레잇 객체에 대한 포인터는 vtable에 대한 포인터도 저장합니다."

#: src/dynamically-sized-types.md:27
msgid ""
"<abbr title=\"dynamically sized types\">DSTs</abbr> can be provided as type "
"arguments to generic type parameters having the special `?Sized` bound. They "
"can also be used for associated type definitions when the corresponding "
"associated type declaration has a `?Sized` bound. By default, any type "
"parameter or associated type has a `Sized` bound, unless it is relaxed using "
"`?Sized`."
msgstr "<abbr title=\"dynamically sized types\">DST</abbr>는 특별한 `?Sized` 바운드를 가진 제네릭 타입 매개변수에 타입 인자로 제공될 수 있습니다. 또한 대응하는 연관 타입 선언에 `?Sized` 바운드가 있을 때 연관 타입 정의에도 사용될 수 있습니다. 기본적으로 모든 타입 매개변수나 연관 타입은 `?Sized`를 사용하여 완화되지 않는 한 `Sized` 바운드를 가집니다."

#: src/dynamically-sized-types.md:34
msgid ""
"Traits may be implemented for <abbr title=\"dynamically sized\n"
"types\">DSTs</abbr>. Unlike with generic type parameters, `Self: ?Sized` is "
"the default in trait definitions."
msgstr "트레잇은 <abbr title=\"dynamically sized types\">DST</abbr>에 대해 구현될 수 있습니다. 제네릭 타입 매개변수와 달리, 트레잇 정의에서는 `Self: ?Sized`가 기본값입니다."

#: src/dynamically-sized-types.md:40
msgid ""
"Structs may contain a <abbr title=\"dynamically sized type\">DST</abbr> as "
"the last field; this makes the struct itself a <abbr title=\"dynamically "
"sized type\">DST</abbr>."
msgstr "구조체는 마지막 필드로 <abbr title=\"dynamically sized type\">DST</abbr>를 포함할 수 있으며, 이 경우 구조체 자체도 <abbr title=\"dynamically sized type\">DST</abbr>가 됩니다."

#: src/dynamically-sized-types.md:44
msgid ""
"**Note**: [variables](variables.md), function parameters, [const](items/"
"constant-items.md) items, and [static](items/static-items.md) items must be "
"`Sized`."
msgstr "**참고**: [변수](variables.md), 함수 매개변수, [const](items/constant-items.md) 아이템, [static](items/static-items.md) 아이템은 반드시 `Sized`여야 합니다."

#: src/type-layout.md:3
msgid "Type Layout"
msgstr "타입 레이아웃"

#: src/type-layout.md:7
msgid ""
"The layout of a type is its size, alignment, and the relative offsets of its "
"fields. For enums, how the discriminant is laid out and interpreted is also "
"part of type layout."
msgstr "타입의 레이아웃은 크기, 정렬, 그리고 필드들의 상대적 오프셋을 의미합니다. 열거형의 경우, 판별자(discriminant)가 어떻게 배치되고 해석되는지 또한 타입 레이아웃의 일부입니다."

#: src/type-layout.md:13
msgid ""
"Type layout can be changed with each compilation. Instead of trying to "
"document exactly what is done, we only document what is guaranteed today."
msgstr "타입 레이아웃은 컴파일할 때마다 변경될 수 있습니다. 정확히 어떻게 수행되는지 문서화하려고 시도하는 대신, 우리는 현재 보장되는 내용만을 문서화합니다."

#: src/type-layout.md:16
msgid ""
"Note that even types with the same layout can still differ in how they are "
"passed across function boundaries. For function call ABI compatibility of "
"types, see [here](../core/primitive.fn.md#abi-compatibility)."
msgstr "동일한 레이아웃을 가진 타입이라도 함수 경계를 넘어 전달되는 방식은 다를 수 있다는 점에 유의하십시오. 타입의 함수 호출 ABI 호환성에 대해서는 [여기](../core/primitive.fn.md#abi-compatibility)를 참조하십시오."

#: src/type-layout.md:22
msgid "Size and Alignment"
msgstr "크기와 정렬"

#: src/type-layout.md:24
msgid "All values have an alignment and size."
msgstr "모든 값은 정렬과 크기를 가집니다."

#: src/type-layout.md:28
msgid ""
"The _alignment_ of a value specifies what addresses are valid to store the "
"value at. A value of alignment `n` must only be stored at an address that is "
"a multiple of n. For example, a value with an alignment of 2 must be stored "
"at an even address, while a value with an alignment of 1 can be stored at "
"any address. Alignment is measured in bytes, and must be at least 1, and "
"always a power of 2. The alignment of a value can be checked with the "
"[`align_of_val`](../core/mem/fn.align_of_val.html) function."
msgstr "값의 _정렬(alignment)_은 해당 값을 저장하기에 유효한 주소가 무엇인지 지정합니다. 정렬이 `n`인 값은 반드시 n의 배수인 주소에만 저장되어야 합니다. 예를 들어, 정렬이 2인 값은 짝수 주소에 저장되어야 하며, 정렬이 1인 값은 아무 주소에나 저장될 수 있습니다. 정렬은 바이트 단위로 측정되며, 최소 1이어야 하고 항상 2의 거듭제곱이어야 합니다. 값의 정렬은 [`align_of_val`](../core/mem/fn.align_of_val.html) 함수로 확인할 수 있습니다."

#: src/type-layout.md:37
msgid ""
"The _size_ of a value is the offset in bytes between successive elements in "
"an array with that item type including alignment padding. The size of a "
"value is always a multiple of its alignment. Note that some types are zero-"
"sized; 0 is considered a multiple of any alignment (for example, on some "
"platforms, the type `[u16; 0]` has size 0 and alignment 2). The size of a "
"value can be checked with the [`size_of_val`](../core/mem/"
"fn.size_of_val.html) function."
msgstr "값의 _크기(size)_는 해당 아이템 타입을 가진 배열에서 연속된 요소 사이의 바이트 단위 오프셋이며, 정렬 패딩을 포함합니다. 값의 크기는 항상 정렬의 배수입니다. 일부 타입은 크기가 0일 수 있음에 유의하십시오; 0은 모든 정렬의 배수로 간주됩니다(예를 들어, 일부 플랫폼에서 `[u16; 0]` 타입은 크기가 0이고 정렬이 2입니다). 값의 크기는 [`size_of_val`](../core/mem/fn.size_of_val.html) 함수로 확인할 수 있습니다."

#: src/type-layout.md:46
msgid ""
"Types where all values have the same size and alignment, and both are known "
"at compile time, implement the [`Sized`](../core/marker/trait.Sized.html) "
"trait and can be checked with the [`size_of`](../core/mem/fn.size_of.html) "
"and [`align_of`](../core/mem/fn.align_of.html) functions. Types that are not "
"[`Sized`](../core/marker/trait.Sized.html) are known as [dynamically sized "
"types](dynamically-sized-types.md). Since all values of a `Sized` type share "
"the same size and alignment, we refer to those shared values as the size of "
"the type and the alignment of the type respectively."
msgstr "모든 값이 동일한 크기와 정렬을 가지며 컴파일 타임에 둘 다 알려진 타입은 [`Sized`](../core/marker/trait.Sized.html) 트레잇을 구현하고, [`size_of`](../core/mem/fn.size_of.html) 및 [`align_of`](../core/mem/fn.align_of.html) 함수로 확인할 수 있습니다. [`Sized`](../core/marker/trait.Sized.html)가 아닌 타입은 [동적 크기 타입](dynamically-sized-types.md)으로 알려져 있습니다. `Sized` 타입의 모든 값은 동일한 크기와 정렬을 공유하므로, 이러한 공유된 값을 각각 해당 타입의 크기와 타입의 정렬이라고 부릅니다."

#: src/type-layout.md:55
msgid "Primitive Data Layout"
msgstr "기본 데이터 레이아웃"

#: src/type-layout.md:59
msgid "The size of most primitives is given in this table."
msgstr "대부분의 기본 타입들의 크기는 이 표에 주어져 있습니다."

#: src/type-layout.md:61
msgid "`size_of::<Type>()`"
msgstr "`size_of::<Type>()`"

#: src/type-layout.md:63 src/type-layout.md:64
msgid "1"
msgstr "1"

#: src/type-layout.md:64
msgid "`u8` / `i8`"
msgstr "`u8` / `i8`"

#: src/type-layout.md:65
msgid "`u16` / `i16`"
msgstr "`u16` / `i16`"

#: src/type-layout.md:65
msgid "2"
msgstr "2"

#: src/type-layout.md:66
msgid "`u32` / `i32`"
msgstr "`u32` / `i32`"

#: src/type-layout.md:66 src/type-layout.md:70 src/type-layout.md:72
msgid "4"
msgstr "4"

#: src/type-layout.md:67
msgid "`u64` / `i64`"
msgstr "`u64` / `i64`"

#: src/type-layout.md:67 src/type-layout.md:71
msgid "8"
msgstr "8"

#: src/type-layout.md:68
msgid "`u128` / `i128`"
msgstr "`u128` / `i128`"

#: src/type-layout.md:68
msgid "16"
msgstr "16"

#: src/type-layout.md:69
msgid "`usize` / `isize`"
msgstr "`usize` / `isize`"

#: src/type-layout.md:69
msgid "See below"
msgstr "아래 참조"

#: src/type-layout.md:70 src/inline-assembly.md:610 src/inline-assembly.md:614
msgid "`f32`"
msgstr "`f32`"

#: src/type-layout.md:71 src/inline-assembly.md:611 src/inline-assembly.md:615
msgid "`f64`"
msgstr "`f64`"

#: src/type-layout.md:76
msgid ""
"`usize` and `isize` have a size big enough to contain every address on the "
"target platform. For example, on a 32 bit target, this is 4 bytes, and on a "
"64 bit target, this is 8 bytes."
msgstr "`usize`와 `isize`는 대상 플랫폼의 모든 주소를 포함할 수 있을 만큼 큰 크기를 가집니다. 예를 들어, 32비트 대상에서는 4바이트이고, 64비트 대상에서는 8바이트입니다."

#: src/type-layout.md:82
msgid ""
"The alignment of primitives is platform-specific. In most cases, their "
"alignment is equal to their size, but it may be less. In particular, `i128` "
"and `u128` are often aligned to 4 or 8 bytes even though their size is 16, "
"and on many 32-bit platforms, `i64`, `u64`, and `f64` are only aligned to 4 "
"bytes, not 8."
msgstr "기본 타입의 정렬은 플랫폼에 따라 다릅니다. 대부분의 경우 정렬은 크기와 같지만, 더 작을 수도 있습니다. 특히 `i128`과 `u128`은 크기가 16임에도 불구하고 종종 4 또는 8 바이트로 정렬되며, 많은 32비트 플랫폼에서 `i64`, `u64`, `f64`는 8이 아닌 4 바이트로만 정렬됩니다."

#: src/type-layout.md:90
msgid "Pointers and References Layout"
msgstr "포인터 및 참조 레이아웃"

#: src/type-layout.md:94
msgid ""
"Pointers and references have the same layout. Mutability of the pointer or "
"reference does not change the layout."
msgstr "포인터와 참조는 동일한 레이아웃을 가집니다. 포인터나 참조의 가변성은 레이아웃을 변경하지 않습니다."

#: src/type-layout.md:99
msgid "Pointers to sized types have the same size and alignment as `usize`."
msgstr "크기가 있는 타입에 대한 포인터는 `usize`와 동일한 크기와 정렬을 가집니다."

#: src/type-layout.md:103
msgid ""
"Pointers to unsized types are sized. The size and alignment is guaranteed to "
"be at least equal to the size and alignment of a pointer."
msgstr "크기가 없는 타입(unsized types)에 대한 포인터는 크기를 가집니다. 크기와 정렬은 적어도 포인터의 크기 및 정렬과 동일함이 보장됩니다."

#: src/type-layout.md:106
msgid ""
"Note: Though you should not rely on this, all pointers to <abbr "
"title=\"Dynamically Sized Types\">DSTs</abbr> are currently twice the size "
"of the size of `usize` and have the same alignment."
msgstr "참고: 이에 의존해서는 안 되지만, 현재 모든 <abbr title=\"Dynamically Sized Types\">DST</abbr>에 대한 포인터는 `usize` 크기의 두 배이며 정렬은 동일합니다."

#: src/type-layout.md:112
msgid "Array Layout"
msgstr "배열 레이아웃"

#: src/type-layout.md:115
msgid ""
"An array of `[T; N]` has a size of `size_of::<T>() * N` and the same "
"alignment of `T`. Arrays are laid out so that the zero-based `nth` element "
"of the array is offset from the start of the array by `n * size_of::<T>()` "
"bytes."
msgstr "`[T; N]` 배열은 `size_of::<T>() * N`의 크기를 가지며 `T`와 동일한 정렬을 가집니다. 배열은 0부터 시작하는 `nth` 요소가 배열 시작점으로부터 `n * size_of::<T>()` 바이트만큼 오프셋되도록 배치됩니다."

#: src/type-layout.md:121
msgid "Slice Layout"
msgstr "슬라이스 레이아웃"

#: src/type-layout.md:124
msgid "Slices have the same layout as the section of the array they slice."
msgstr "슬라이스는 자신이 슬라이싱하는 배열 섹션과 동일한 레이아웃을 가집니다."

#: src/type-layout.md:126
msgid ""
"Note: This is about the raw `[T]` type, not pointers (`&[T]`, `Box<[T]>`, "
"etc.) to slices."
msgstr "참고: 이것은 슬라이스에 대한 포인터(`&[T]`, `Box<[T]>` 등)가 아니라 원시 `[T]` 타입에 대한 내용입니다."

#: src/type-layout.md:131
msgid "`str` Layout"
msgstr "`str` 레이아웃"

#: src/type-layout.md:134
msgid ""
"String slices are a UTF-8 representation of characters that have the same "
"layout as slices of type `[u8]`."
msgstr "문자열 슬라이스는 `[u8]` 타입의 슬라이스와 동일한 레이아웃을 가진 문자의 UTF-8 표현입니다."

#: src/type-layout.md:138
msgid "Tuple Layout"
msgstr "튜플 레이아웃"

#: src/type-layout.md:142
msgid ""
"Tuples are laid out according to the [`Rust` representation](#the-rust-"
"representation)."
msgstr "튜플은 [`Rust` 표현](#the-rust-representation)에 따라 배치됩니다."

#: src/type-layout.md:146
msgid ""
"The exception to this is the unit tuple (`()`), which is guaranteed as a "
"zero-sized type to have a size of 0 and an alignment of 1."
msgstr "이에 대한 예외는 유닛 튜플(`()`)로, 크기가 0이고 정렬이 1인 0크기 타입(zero-sized type)으로 보장됩니다."

#: src/type-layout.md:151
msgid "Trait Object Layout"
msgstr "트레잇 객체 레이아웃"

#: src/type-layout.md:154
msgid "Trait objects have the same layout as the value the trait object is of."
msgstr "트레잇 객체는 해당 트레잇 객체가 나타내는 값과 동일한 레이아웃을 가집니다."

#: src/type-layout.md:156
msgid ""
"Note: This is about the raw trait object types, not pointers (`&dyn Trait`, "
"`Box<dyn Trait>`, etc.) to trait objects."
msgstr "참고: 이것은 트레잇 객체에 대한 포인터(`&dyn Trait`, `Box<dyn Trait>` 등)가 아니라 원시 트레잇 객체 타입에 대한 내용입니다."

#: src/type-layout.md:161
msgid "Closure Layout"
msgstr "클로저 레이아웃"

#: src/type-layout.md:164
msgid "Closures have no layout guarantees."
msgstr "클로저는 레이아웃 보장이 없습니다."

#: src/type-layout.md:168
msgid "Representations"
msgstr "표현 (Representations)"

#: src/type-layout.md:172
msgid ""
"All user-defined composite types (`struct`s, `enum`s, and `union`s) have a "
"_representation_ that specifies what the layout is for the type."
msgstr "모든 사용자 정의 복합 타입(`struct`, `enum`, `union`)은 해당 타입의 레이아웃이 무엇인지 지정하는 _표현(representation)_을 가집니다."

#: src/type-layout.md:177
msgid "The possible representations for a type are:"
msgstr "타입에 대해 가능한 표현은 다음과 같습니다:"

#: src/type-layout.md:179
msgid "[`Rust`](#the-rust-representation) (default)"
msgstr "[`Rust`](#the-rust-representation) (기본값)"

#: src/type-layout.md:180
msgid "[`C`](#the-c-representation)"
msgstr "[`C`](#the-c-representation)"

#: src/type-layout.md:181
msgid "The [primitive representations](#primitive-representations)"
msgstr "[기본 표현(primitive representations)](#primitive-representations)"

#: src/type-layout.md:182
msgid "[`transparent`](#the-transparent-representation)"
msgstr "[`transparent`](#the-transparent-representation)"

#: src/type-layout.md:186
msgid ""
"The representation of a type can be changed by applying the `repr` attribute "
"to it. The following example shows a struct with a `C` representation."
msgstr "타입의 표현은 `repr` 속성을 적용하여 변경할 수 있습니다. 다음 예시는 `C` 표현을 가진 구조체를 보여줍니다."

#: src/type-layout.md:200
msgid ""
"The alignment may be raised or lowered with the `align` and `packed` "
"modifiers respectively. They alter the representation specified in the "
"attribute. If no representation is specified, the default one is altered."
msgstr "정렬은 각각 `align`과 `packed` 수정자를 사용하여 높이거나 낮출 수 있습니다. 이들은 속성에 지정된 표현을 변경합니다. 지정된 표현이 없으면 기본 표현이 변경됩니다."

#: src/type-layout.md:205
msgid "// Default representation, alignment lowered to 2.\n"
msgstr "// 기본 표현, 정렬이 2로 낮아짐.\n"

#: src/type-layout.md:212
msgid "// C representation, alignment raised to 8\n"
msgstr "// C 표현, 정렬이 8로 높아짐\n"

#: src/type-layout.md:222
msgid ""
"Note: As a consequence of the representation being an attribute on the item, "
"the representation does not depend on generic parameters. Any two types with "
"the same name have the same representation. For example, `Foo<Bar>` and "
"`Foo<Baz>` both have the same representation."
msgstr "참고: 표현이 아이템의 속성이라는 점 때문에, 표현은 제네릭 매개변수에 의존하지 않습니다. 동일한 이름을 가진 두 타입은 동일한 표현을 가집니다. 예를 들어, `Foo<Bar>`와 `Foo<Baz>`는 둘 다 동일한 표현을 가집니다."

#: src/type-layout.md:229
msgid ""
"The representation of a type can change the padding between fields, but does "
"not change the layout of the fields themselves. For example, a struct with a "
"`C` representation that contains a struct `Inner` with the `Rust` "
"representation will not change the layout of `Inner`."
msgstr "타입의 표현은 필드 간의 패딩을 변경할 수 있지만, 필드 자체의 레이아웃은 변경하지 않습니다. 예를 들어, `Rust` 표현을 가진 `Inner` 구조체를 포함하는 `C` 표현의 구조체는 `Inner`의 레이아웃을 변경하지 않습니다."

#: src/type-layout.md:234
msgid "<a id=\"the-default-representation\"></a>"
msgstr "<a id=\"the-default-representation\"></a>"

#: src/type-layout.md:237
msgid "The `Rust` Representation"
msgstr "`Rust` 표현"

#: src/type-layout.md:241
msgid ""
"The `Rust` representation is the default representation for nominal types "
"without a `repr` attribute. Using this representation explicitly through a "
"`repr` attribute is guaranteed to be the same as omitting the attribute "
"entirely."
msgstr "`Rust` 표현은 `repr` 속성이 없는 명목적 타입의 기본 표현입니다. `repr` 속성을 통해 이 표현을 명시적으로 사용하는 것은 속성을 완전히 생략하는 것과 동일함이 보장됩니다."

#: src/type-layout.md:248
msgid ""
"The only data layout guarantees made by this representation are those "
"required for soundness. They are:"
msgstr "이 표현이 제공하는 유일한 데이터 레이아웃 보장은 안전성(soundness)을 위해 필요한 것들뿐입니다. 그 보장들은 다음과 같습니다:"

#: src/type-layout.md:251
msgid "The fields are properly aligned."
msgstr "필드들이 올바르게 정렬됩니다."

#: src/type-layout.md:252
msgid "The fields do not overlap."
msgstr "필드들이 겹치지 않습니다."

#: src/type-layout.md:253
msgid ""
"The alignment of the type is at least the maximum alignment of its fields."
msgstr "타입의 정렬은 최소한 그 필드들의 최대 정렬 이상입니다."

#: src/type-layout.md:257
msgid ""
"Formally, the first guarantee means that the offset of any field is "
"divisible by that field's alignment."
msgstr "형식적으로, 첫 번째 보장은 모든 필드의 오프셋이 해당 필드의 정렬로 나누어떨어진다는 것을 의미합니다."

#: src/type-layout.md:262
msgid ""
"The second guarantee means that the fields can be ordered such that the "
"offset plus the size of any field is less than or equal to the offset of the "
"next field in the ordering. The ordering does not have to be the same as the "
"order in which the fields are specified in the declaration of the type."
msgstr "두 번째 보장은 필드들이 순서대로 정렬될 때, 어떤 필드의 오프셋 더하기 크기가 다음 필드의 오프셋보다 작거나 같도록 정렬될 수 있음을 의미합니다. 이 순서는 타입 선언에 필드가 지정된 순서와 동일할 필요는 없습니다."

#: src/type-layout.md:268
msgid ""
"Be aware that the second guarantee does not imply that the fields have "
"distinct addresses: zero-sized types may have the same address as other "
"fields in the same struct."
msgstr "두 번째 보장이 필드들이 서로 다른 주소를 갖는다는 것을 의미하지는 않음에 유의하십시오. 크기가 0인 타입은 동일한 구조체 내의 다른 필드와 같은 주소를 가질 수 있습니다."

#: src/type-layout.md:274
msgid ""
"There are no other guarantees of data layout made by this representation."
msgstr "이 표현이 제공하는 데이터 레이아웃에 대한 다른 보장은 없습니다."

#: src/type-layout.md:278
msgid "The `C` Representation"
msgstr "`C` 표현"

#: src/type-layout.md:282
msgid ""
"The `C` representation is designed for dual purposes. One purpose is for "
"creating types that are interoperable with the C Language. The second "
"purpose is to create types that you can soundly perform operations on that "
"rely on data layout such as reinterpreting values as a different type."
msgstr "`C` 표현은 이중 목적으로 설계되었습니다. 첫 번째 목적은 C 언어와 상호 운용 가능한 타입을 생성하는 것입니다. 두 번째 목적은 값을 다른 타입으로 재해석하는 것과 같이 데이터 레이아웃에 의존하는 연산을 안전하게 수행할 수 있는 타입을 생성하는 것입니다."

#: src/type-layout.md:287
msgid ""
"Because of this dual purpose, it is possible to create types that are not "
"useful for interfacing with the C programming language."
msgstr "이러한 이중 목적 때문에, C 프로그래밍 언어와의 인터페이스에는 유용하지 않은 타입을 생성하는 것도 가능합니다."

#: src/type-layout.md:292
msgid ""
"This representation can be applied to structs, unions, and enums. The "
"exception is [zero-variant enums](items/enumerations.md#zero-variant-enums) "
"for which the `C` representation is an error."
msgstr "이 표현은 구조체, 공용체, 열거형에 적용될 수 있습니다. 예외는 [변형이 없는 열거형](items/enumerations.md#zero-variant-enums)으로, 이에 대해 `C` 표현을 사용하는 것은 오류입니다."

#: src/type-layout.md:297
msgid "`#[repr(C)]` Structs"
msgstr "`#[repr(C)]` 구조체"

#: src/type-layout.md:301
msgid ""
"The alignment of the struct is the alignment of the most-aligned field in it."
msgstr "구조체의 정렬은 그 안에 있는 가장 크게 정렬된 필드의 정렬입니다."

#: src/type-layout.md:305
msgid "The size and offset of fields is determined by the following algorithm."
msgstr "필드의 크기와 오프셋은 다음 알고리즘에 의해 결정됩니다."

#: src/type-layout.md:307
msgid "Start with a current offset of 0 bytes."
msgstr "현재 오프셋 0바이트로 시작합니다."

#: src/type-layout.md:309
msgid ""
"For each field in declaration order in the struct, first determine the size "
"and alignment of the field. If the current offset is not a multiple of the "
"field's alignment, then add padding bytes to the current offset until it is "
"a multiple of the field's alignment. The offset for the field is what the "
"current offset is now. Then increase the current offset by the size of the "
"field."
msgstr "구조체의 선언 순서대로 각 필드에 대해, 먼저 필드의 크기와 정렬을 결정합니다. 현재 오프셋이 필드의 정렬의 배수가 아니라면, 필드 정렬의 배수가 될 때까지 현재 오프셋에 패딩 바이트를 추가합니다. 해당 필드의 오프셋은 현재 오프셋 값이 됩니다. 그런 다음 현재 오프셋을 필드의 크기만큼 증가시킵니다."

#: src/type-layout.md:315
msgid ""
"Finally, the size of the struct is the current offset rounded up to the "
"nearest multiple of the struct's alignment."
msgstr "마지막으로, 구조체의 크기는 현재 오프셋을 구조체의 정렬의 가장 가까운 배수로 올림한 값입니다."

#: src/type-layout.md:318
msgid "Here is this algorithm described in pseudocode."
msgstr "다음은 의사코드로 설명된 이 알고리즘입니다."

#: src/type-layout.md:322
msgid ""
"/// Returns the amount of padding needed after `offset` to ensure that the\n"
"/// following address will be aligned to `alignment`.\n"
msgstr ""
"/// 다음 주소가 `alignment`에 맞춰 정렬되도록 하기 위해\n"
"/// `offset` 뒤에 필요한 패딩의 양을 반환합니다.\n"

#: src/type-layout.md:327
msgid "// round up to next multiple of `alignment`\n"
msgstr "// `alignment`의 다음 배수로 올림\n"

#: src/type-layout.md:330
msgid "// already a multiple of `alignment`\n"
msgstr "// 이미 `alignment`의 배수임\n"

#: src/type-layout.md:340
msgid ""
"// Increase the current offset so that it's a multiple of the alignment\n"
"    // of this field. For the first field, this will always be zero.\n"
"    // The skipped bytes are called padding bytes.\n"
msgstr ""
"// 현재 오프셋을 증가시켜 이 필드의 정렬의 배수가 되도록 합니다.\n"
"    // 첫 번째 필드의 경우, 이는 항상 0이 됩니다.\n"
"    // 건너뛴 바이트를 패딩 바이트라고 합니다.\n"

#: src/type-layout.md:355
msgid ""
"_**Warning:**_ This pseudocode uses a naive algorithm that ignores overflow "
"issues for the sake of clarity. To perform memory layout computations in "
"actual code, use [`Layout`](../core/alloc/layout/struct.Layout.html)."
msgstr "_**경고:**_ 이 의사코드는 명확성을 위해 오버플로 문제를 무시하는 단순한 알고리즘을 사용합니다. 실제 코드에서 메모리 레이아웃 계산을 수행하려면 [`Layout`](../core/alloc/layout/struct.Layout.html)을 사용하십시오."

#: src/type-layout.md:361
msgid ""
"Note: This algorithm can produce zero-sized structs. In C, an empty struct "
"declaration like `struct Foo { }` is illegal. However, both gcc and clang "
"support options to enable such structs, and assign them size zero. C++, in "
"contrast, gives empty structs a size of 1, unless they are inherited from or "
"they are fields that have the `[[no_unique_address]]` attribute, in which "
"case they do not increase the overall size of the struct."
msgstr "참고: 이 알고리즘은 크기가 0인 구조체를 생성할 수 있습니다. C에서 `struct Foo { }`와 같은 빈 구조체 선언은 불법입니다. 그러나 gcc와 clang 모두 이러한 구조체를 활성화하고 크기를 0으로 할당하는 옵션을 지원합니다. 대조적으로 C++는 빈 구조체에 크기 1을 부여합니다. 단, 상속받았거나 `[[no_unique_address]]` 속성을 가진 필드인 경우는 제외하며, 이 경우 구조체의 전체 크기를 증가시키지 않습니다."

#: src/type-layout.md:370
msgid "`#[repr(C)]` Unions"
msgstr "`#[repr(C)]` 공용체"

#: src/type-layout.md:374
msgid ""
"A union declared with `#[repr(C)]` will have the same size and alignment as "
"an equivalent C union declaration in the C language for the target platform."
msgstr "`#[repr(C)]`로 선언된 공용체는 대상 플랫폼의 C 언어에서 동등한 C 공용체 선언과 동일한 크기와 정렬을 가집니다."

#: src/type-layout.md:379
msgid ""
"The union will have a size of the maximum size of all of its fields rounded "
"to its alignment, and an alignment of the maximum alignment of all of its "
"fields. These maximums may come from different fields."
msgstr "공용체는 모든 필드의 최대 크기를 정렬에 맞춰 올림한 크기와, 모든 필드의 최대 정렬인 정렬을 가집니다. 이러한 최대값들은 서로 다른 필드에서 올 수 있습니다."

#: src/type-layout.md:390
msgid "// From f2\n"
msgstr "// f2에서 옴\n"

#: src/type-layout.md:391
msgid "// From f1\n"
msgstr "// f1에서 옴\n"

#: src/type-layout.md:399
msgid ""
"// Size of 6 from b,\n"
"                                                      // rounded up to 8 "
"from\n"
"                                                      // alignment of a.\n"
msgstr ""
"// b에서 크기 6,\n"
"                                                      // a의 정렬에 따라\n"
"                                                      // 8로 올림.\n"

#: src/type-layout.md:402
msgid "// From a\n"
msgstr "// a에서 옴\n"

#: src/type-layout.md:407
msgid "`#[repr(C)]` Field-less Enums"
msgstr "`#[repr(C)]` 필드 없는 열거형"

#: src/type-layout.md:410
msgid ""
"For [field-less enums](items/enumerations.md#field-less-enum), the `C` "
"representation has the size and alignment of the default `enum` size and "
"alignment for the target platform's C ABI."
msgstr "[필드 없는 열거형](items/enumerations.md#field-less-enum)의 경우, `C` 표현은 대상 플랫폼의 C ABI에 대한 기본 `enum` 크기 및 정렬과 동일한 크기 및 정렬을 가집니다."

#: src/type-layout.md:413
msgid ""
"Note: The enum representation in C is implementation defined, so this is "
"really a \"best guess\". In particular, this may be incorrect when the C "
"code of interest is compiled with certain flags."
msgstr "참고: C의 열거형 표현은 구현 정의(implementation defined)이므로 이는 사실상 \"최선의 추측\"입니다. 특히, 관심 있는 C 코드가 특정 플래그로 컴파일된 경우 이것이 부정확할 수 있습니다."

#: src/type-layout.md:419
msgid ""
"_**Warning:**_ There are crucial differences between an `enum` in the C "
"language and Rust's [field-less enums](items/enumerations.md#field-less-"
"enum) with this representation. An `enum` in C is mostly a `typedef` plus "
"some named constants; in other words, an object of an `enum` type can hold "
"any integer value. For example, this is often used for bitflags in `C`. In "
"contrast, Rust’s [field-less enums](items/enumerations.md#field-less-enum) "
"can only legally hold the discriminant values, everything else is [undefined "
"behavior](behavior-considered-undefined.md). Therefore, using a field-less "
"enum in FFI to model a C `enum` is often wrong."
msgstr "_**경고:**_ C 언어의 `enum`과 이 표현을 사용하는 러스트의 [필드 없는 열거형](items/enumerations.md#field-less-enum) 사이에는 결정적인 차이가 있습니다. C의 `enum`은 주로 `typedef`에 이름 있는 상수를 더한 것입니다. 다시 말해, `enum` 타입의 객체는 어떤 정수 값이든 가질 수 있습니다. 예를 들어, 이는 `C`에서 비트 플래그로 자주 사용됩니다. 대조적으로, 러스트의 [필드 없는 열거형](items/enumerations.md#field-less-enum)은 판별자 값만을 합법적으로 가질 수 있으며, 그 외의 모든 것은 [정의되지 않은 동작(undefined behavior)](behavior-considered-undefined.md)입니다. 따라서 C `enum`을 모델링하기 위해 FFI에서 필드 없는 열거형을 사용하는 것은 종종 잘못된 것입니다."

#: src/type-layout.md:427
msgid "`#[repr(C)]` Enums With Fields"
msgstr "`#[repr(C)]` 필드 있는 열거형"

#: src/type-layout.md:431
msgid ""
"The representation of a `repr(C)` enum with fields is a `repr(C)` struct "
"with two fields, also called a \"tagged union\" in C:"
msgstr "필드가 있는 `repr(C)` 열거형의 표현은 두 개의 필드를 가진 `repr(C)` 구조체이며, C에서는 \"태그된 공용체(tagged union)\"라고도 불립니다:"

#: src/type-layout.md:436
msgid "a `repr(C)` version of the enum with all fields removed (\"the tag\")"
msgstr "모든 필드가 제거된 열거형의 `repr(C)` 버전 (\"태그\")"

#: src/type-layout.md:440
msgid ""
"a `repr(C)` union of `repr(C)` structs for the fields of each variant that "
"had them (\"the payload\")"
msgstr "필드를 가진 각 변형의 필드들을 위한 `repr(C)` 구조체들의 `repr(C)` 공용체 (\"페이로드\")"

#: src/type-layout.md:443
msgid ""
"Note: Due to the representation of `repr(C)` structs and unions, if a "
"variant has a single field there is no difference between putting that field "
"directly in the union or wrapping it in a struct; any system which wishes to "
"manipulate such an `enum`'s representation may therefore use whichever form "
"is more convenient or consistent for them."
msgstr "참고: `repr(C)` 구조체 및 공용체의 표현 방식으로 인해, 변형이 단일 필드를 가질 경우 해당 필드를 공용체에 직접 넣는 것과 구조체로 감싸는 것 사이에 차이가 없습니다. 따라서 그러한 `enum`의 표현을 조작하려는 시스템은 자신에게 더 편리하거나 일관된 형태를 사용할 수 있습니다."

#: src/type-layout.md:450
msgid "// This Enum has the same representation as ...\n"
msgstr "// 이 Enum은 다음 구조체와 동일한 표현을 가집니다 ...\n"

#: src/type-layout.md:458
msgid "// ... this struct.\n"
msgstr "// ... 이 구조체와.\n"

#: src/type-layout.md:465 src/type-layout.md:559
msgid "// This is the discriminant enum.\n"
msgstr "// 이것은 판별자 열거형입니다.\n"

#: src/type-layout.md:469
msgid "// This is the variant union.\n"
msgstr "// 이것은 변형 공용체입니다.\n"

#: src/type-layout.md:490
msgid ""
"// This struct could be omitted (it is a zero-sized type), and it must be "
"in\n"
"// C/C++ headers.\n"
msgstr "// 이 구조체는 생략될 수 있으며(0크기 타입임), C/C++ 헤더에 있어야 합니다.\n"

#: src/type-layout.md:498 src/type-layout.md:582
msgid ""
"Note: `union`s with non-`Copy` fields are unstable, see [55149](https://"
"github.com/rust-lang/rust/issues/55149)."
msgstr "참고: `Copy`가 아닌 필드를 가진 `union`은 불안정합니다. [55149](https://github.com/rust-lang/rust/issues/55149)를 참조하십시오."

#: src/type-layout.md:502
msgid "Primitive representations"
msgstr "기본 표현 (Primitive representations)"

#: src/type-layout.md:506
msgid ""
"The _primitive representations_ are the representations with the same names "
"as the primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`, "
"`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize`."
msgstr "_기본 표현_은 기본 정수 타입과 동일한 이름을 가진 표현입니다. 즉: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, `i8`, `i16`, `i32`, `i64`, `i128`, `isize`입니다."

#: src/type-layout.md:512
msgid ""
"Primitive representations can only be applied to enumerations and have "
"different behavior whether the enum has fields or no fields. It is an error "
"for [zero-variant enums](items/enumerations.md#zero-variant-enums) to have a "
"primitive representation. Combining two primitive representations together "
"is an error."
msgstr "기본 표현은 열거형에만 적용될 수 있으며 열거형에 필드가 있는지 없는지에 따라 다르게 동작합니다. [변형이 없는 열거형](items/enumerations.md#zero-variant-enums)이 기본 표현을 갖는 것은 오류입니다. 두 개의 기본 표현을 결합하는 것은 오류입니다."

#: src/type-layout.md:519
msgid "Primitive Representation of Field-less Enums"
msgstr "필드 없는 열거형의 기본 표현"

#: src/type-layout.md:522
msgid ""
"For [field-less enums](items/enumerations.md#field-less-enum), primitive "
"representations set the size and alignment to be the same as the primitive "
"type of the same name. For example, a field-less enum with a `u8` "
"representation can only have discriminants between 0 and 255 inclusive."
msgstr "[필드 없는 열거형](items/enumerations.md#field-less-enum)의 경우, 기본 표현은 크기와 정렬을 동일한 이름의 기본 타입과 같게 설정합니다. 예를 들어, `u8` 표현을 가진 필드 없는 열거형은 0에서 255(포함) 사이의 판별자만 가질 수 있습니다."

#: src/type-layout.md:529
msgid "Primitive Representation of Enums With Fields"
msgstr "필드 있는 열거형의 기본 표현"

#: src/type-layout.md:532
msgid ""
"The representation of a primitive representation enum is a `repr(C)` union "
"of `repr(C)` structs for each variant with a field. The first field of each "
"struct in the union is the primitive representation version of the enum with "
"all fields removed (\"the tag\") and the remaining fields are the fields of "
"that variant."
msgstr "기본 표현 열거형의 표현은 `repr(C)` 공용체입니다"

#: src/type-layout.md:537
msgid ""
"Note: This representation is unchanged if the tag is given its own member in "
"the union, should that make manipulation more clear for you (although to "
"follow the C++ standard the tag member should be wrapped in a `struct`)."
msgstr "참고: 만약 조작을 더 명확하게 하기 위해 태그에 공용체 내의 별도 멤버를 부여하더라도 이 표현은 변경되지 않습니다(단, C++ 표준을 따르려면 태그 멤버는 `struct`로 감싸져야 합니다)."

#: src/type-layout.md:542
msgid "// This enum has the same representation as ...\n"
msgstr "// 이 열거형은 다음 공용체와 동일한 표현을 가집니다 ...\n"

#: src/type-layout.md:550
msgid "// ... this union.\n"
msgstr "// ... 이 공용체와.\n"

#: src/type-layout.md:586
msgid ""
"Combining primitive representations of enums with fields and `#[repr(C)]`"
msgstr "필드가 있는 열거형의 기본 표현과 `#[repr(C)]` 결합하기"

#: src/type-layout.md:589
msgid ""
"For enums with fields, it is also possible to combine `repr(C)` and a "
"primitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`]"
"(#reprc-enums-with-fields) by changing the representation of the "
"discriminant enum to the chosen primitive instead. So, if you chose the `u8` "
"representation, then the discriminant enum would have a size and alignment "
"of 1 byte."
msgstr "필드가 있는 열거형의 경우, `repr(C)`와 기본 표현을 결합하는 것도 가능합니다(예: `repr(C, u8)`). 이는 판별자 열거형의 표현을 선택된 기본 타입으로 변경함으로써 [`repr(C)`](#reprc-enums-with-fields)를 수정합니다. 따라서 `u8` 표현을 선택했다면, 판별자 열거형은 1바이트의 크기와 정렬을 갖게 됩니다."

#: src/type-layout.md:595
msgid ""
"The discriminant enum from the example [earlier](#reprc-enums-with-fields) "
"then becomes:"
msgstr "[앞서](#reprc-enums-with-fields) 나온 예시의 판별자 열거형은 다음과 같이 됩니다:"

#: src/type-layout.md:598
msgid "// `u8` was added\n"
msgstr "// `u8`이 추가됨\n"

#: src/type-layout.md:608
msgid "// So `u8` is used here instead of `C`\n"
msgstr "// 따라서 여기서 `C` 대신 `u8`이 사용됨\n"

#: src/type-layout.md:614
msgid ""
"For example, with a `repr(C, u8)` enum it is not possible to have 257 unique "
"discriminants (\"tags\") whereas the same enum with only a `repr(C)` "
"attribute will compile without any problems."
msgstr "예를 들어, `repr(C, u8)` 열거형은 257개의 고유한 판별자(\"태그\")를 가질 수 없는 반면, `repr(C)` 속성만 있는 동일한 열거형은 문제없이 컴파일됩니다."

#: src/type-layout.md:618
msgid ""
"Using a primitive representation in addition to `repr(C)` can change the "
"size of an enum from the `repr(C)` form:"
msgstr "`repr(C)`에 더해 기본 표현을 사용하면 `repr(C)` 형태로부터 열거형의 크기가 변경될 수 있습니다:"

#: src/type-layout.md:639
msgid "// The size of the C representation is platform dependant\n"
msgstr "// C 표현의 크기는 플랫폼에 따라 다릅니다\n"

#: src/type-layout.md:641
msgid ""
"// One byte for the discriminant and one byte for the value in "
"Enum8::Variant0\n"
msgstr "// 판별자를 위한 1바이트와 Enum8::Variant0의 값을 위한 1바이트\n"

#: src/type-layout.md:643
msgid ""
"// Two bytes for the discriminant and one byte for the value in "
"Enum16::Variant0\n"
"// plus one byte of padding.\n"
msgstr "// 판별자를 위한 2바이트와 Enum16::Variant0의 값을 위한 1바이트\n// 더하기 1바이트의 패딩.\n"

#: src/type-layout.md:653
msgid "The alignment modifiers"
msgstr "정렬 수정자"

#: src/type-layout.md:657
msgid ""
"The `align` and `packed` modifiers can be used to respectively raise or "
"lower the alignment of `struct`s and `union`s. `packed` may also alter the "
"padding between fields (although it will not alter the padding inside of any "
"field). On their own, `align` and `packed` do not provide guarantees about "
"the order of fields in the layout of a struct or the layout of an enum "
"variant, although they may be combined with representations (such as `C`) "
"which do provide such guarantees."
msgstr "`align`과 `packed` 수정자는 각각 `struct`와 `union`의 정렬을 높이거나 낮출 때 사용할 수 있습니다. `packed`는 필드 사이의 패딩을 변경할 수도 있습니다(단, 필드 내부의 패딩은 변경하지 않습니다). `align`과 `packed`는 그 자체로는 구조체 레이아웃이나 열거형 변형 레이아웃의 필드 순서에 대한 보장을 제공하지 않지만, 그러한 보장을 제공하는 표현(예: `C`)과 결합될 수 있습니다."

#: src/type-layout.md:667
msgid ""
"The alignment is specified as an integer parameter in the form of "
"`#[repr(align(x))]` or `#[repr(packed(x))]`. The alignment value must be a "
"power of two from 1 up to 2<sup>29</sup>. For `packed`, if no value is "
msgstr "정렬은 `#[repr(align(x))]` 또는 `#[repr(packed(x))]` 형식의 정수 매개변수로 지정됩니다. 정렬 값은 1부터 2<sup>29</sup>까지의 2의 거듭제곱이어야 합니다. `packed`의 경우, 값이 지정되지 않으면"

#: src/type-layout.md:674
msgid ""
"For `align`, if the specified alignment is less than the alignment of the "
"type without the `align` modifier, then the alignment is unaffected."
msgstr "`align`의 경우, 지정된 정렬이 `align` 수정자가 없을 때의 타입 정렬보다 작으면 정렬은 영향을 받지 않습니다."

#: src/type-layout.md:679
msgid ""
"For `packed`, if the specified alignment is greater than the type's "
"alignment without the `packed` modifier, then the alignment and layout is "
"unaffected."
msgstr "`packed`의 경우, 지정된 정렬이 `packed` 수정자가 없을 때의 타입 정렬보다 크면 정렬과 레이아웃은 영향을 받지 않습니다."

#: src/type-layout.md:684
msgid ""
"The alignments of each field, for the purpose of positioning fields, is the "
"smaller of the specified alignment and the alignment of the field's type."
msgstr "필드 배치를 위한 각 필드의 정렬은 지정된 정렬과 필드 타입의 정렬 중 더 작은 값입니다."

#: src/type-layout.md:689
msgid ""
"Inter-field padding is guaranteed to be the minimum required in order to "
"satisfy each field's (possibly altered) alignment (although note that, on "
"its own, `packed` does not provide any guarantee about field ordering). An "
"important consequence of these rules is that a type with "
"`#[repr(packed(1))]` (or `#[repr(packed)]`) will have no inter-field padding."
msgstr "필드 간 패딩은 각 필드의 (변경되었을 수 있는) 정렬을 충족하기 위해 필요한 최소한의 양으로 보장됩니다(단, `packed` 자체는 필드 순서에 대한 어떤 보장도 제공하지 않음에 유의하십시오). 이 규칙의 중요한 결과는 `#[repr(packed(1))]`(또는 `#[repr(packed)]`)을 가진 타입은 필드 간 패딩이 없다는 것입니다."

#: src/type-layout.md:697
msgid ""
"The `align` and `packed` modifiers cannot be applied on the same type and a "
"`packed` type cannot transitively contain another `align`ed type. `align` "
"and `packed` may only be applied to the [`Rust`](#the-rust-representation) "
"and [`C`](#the-c-representation) representations."
msgstr "`align`과 `packed` 수정자는 동일한 타입에 적용될 수 없으며, `packed` 타입은 전이적으로 다른 `align`된 타입을 포함할 수 없습니다. `align`과 `packed`는 [`Rust`](#the-rust-representation) 및 [`C`](#the-c-representation) 표현에만 적용될 수 있습니다."

#: src/type-layout.md:703
msgid ""
"The `align` modifier can also be applied on an `enum`. When it is, the "
"effect on the `enum`'s alignment is the same as if the `enum` was wrapped in "
"a newtype `struct` with the same `align` modifier."
msgstr "`align` 수정자는 `enum`에도 적용될 수 있습니다. 이 경우, `enum`의 정렬에 미치는 효과는 `enum`이 동일한 `align` 수정자를 가진 뉴타입 `struct`로 감싸진 경우와 동일합니다."

#: src/type-layout.md:707
msgid ""
"Note: References to unaligned fields are not allowed because it is "
"[undefined behavior](behavior-considered-undefined.md). When fields are "
"unaligned due to an alignment modifier, consider the following options for "
msgstr "참고: 정렬되지 않은 필드에 대한 참조는 [정의되지 않은 동작](behavior-considered-undefined.md)이므로 허용되지 않습니다. 정렬 수정자로 인해 필드가 정렬되지 않은 경우, 다음 옵션을 고려하십시오:"

#: src/type-layout.md:717
msgid ""
"// Instead of creating a reference to a field, copy the value to a local "
"variable.\n"
msgstr "// 필드에 대한 참조를 생성하는 대신, 값을 로컬 변수로 복사하십시오.\n"

#: src/type-layout.md:719
msgid ""
"// Or in situations like `println!` which creates a reference, use braces\n"
msgstr "// 또는 참조를 생성하는 `println!`과 같은 상황에서는 중괄호를 사용하여\n"

#: src/type-layout.md:720
msgid "// to change it to a copy of the value.\n"
msgstr "// 값의 복사본으로 변경하십시오.\n"

#: src/type-layout.md:722
msgid ""
"// Or if you need a pointer, use the unaligned methods for reading and "
"writing\n"
msgstr "// 포인터가 필요한 경우, 포인터를 직접 역참조하는 대신\n"

#: src/type-layout.md:723
msgid "// instead of dereferencing the pointer directly.\n"
msgstr "// 읽기 및 쓰기에 정렬되지 않은 메서드를 사용하십시오.\n"

#: src/type-layout.md:732
msgid "The `transparent` Representation"
msgstr "`transparent` 표현"

#: src/type-layout.md:736
msgid ""
"The `transparent` representation can only be used on a [`struct`](items/"
"structs.md) or an [`enum`](items/enumerations.md) with a single variant that "
"has:"
msgstr "`transparent` 표현은 다음을 가진 [`struct`](items/structs.md) 또는 단일 변형 [`enum`](items/enumerations.md)에서만 사용될 수 있습니다:"

#: src/type-layout.md:738
msgid ""
"any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`]"
"(special-types-and-traits.md#phantomdatat)), and"
msgstr "크기가 0이고 정렬이 1인 임의 개수의 필드 (예: [`PhantomData<T>`](special-types-and-traits.md#phantomdatat)), 그리고"

#: src/type-layout.md:739
msgid "at most one other field."
msgstr "최대 하나의 다른 필드."

#: src/type-layout.md:743
#: src/type-layout.md:743
msgid ""
"Structs and enums with this representation have the same layout and ABI as "
"the only non-size 0 non-alignment 1 field, if present, or unit otherwise."
msgstr "이 표현을 가진 구조체와 열거형은 크기가 0이 아니고 정렬이 1이 아닌 유일한 필드(존재하는 경우)와 동일한 레이아웃 및 ABI를 가지며, 그렇지 않으면 유닛과 동일합니다."

#: src/type-layout.md:746
msgid ""
"This is different than the `C` representation because a struct with the `C` "
"representation will always have the ABI of a `C` `struct` while, for "
"example, a struct with the `transparent` representation with a primitive "
"field will have the ABI of the primitive field."
msgstr "이는 `C` 표현과는 다릅니다. `C` 표현을 가진 구조체는 항상 `C` `struct`의 ABI를 갖는 반면, 예를 들어 기본(primitive) 필드를 가진 `transparent` 표현의 구조체는 해당 기본 필드의 ABI를 갖기 때문입니다."

#: src/type-layout.md:753
msgid ""
"Because this representation delegates type layout to another type, it cannot "
"be used with any other representation."
msgstr "이 표현은 타입 레이아웃을 다른 타입에 위임하므로, 다른 어떤 표현과도 함께 사용될 수 없습니다."

#: src/interior-mutability.md:3
msgid "Interior Mutability"
msgstr "내부 가변성 (Interior Mutability)"

#: src/interior-mutability.md:7
msgid ""
"Sometimes a type needs to be mutated while having multiple aliases. In Rust "
"this is achieved using a pattern called _interior mutability_."
msgstr "때로는 여러 별칭(aliases)을 가진 상태에서 타입을 변경해야 할 때가 있습니다. 러스트에서는 _내부 가변성_이라는 패턴을 사용하여 이를 달성합니다."

#: src/interior-mutability.md:12
msgid ""
"A type has interior mutability if its internal state can be changed through "
"a [shared reference](types/pointer.md#shared-references-) to it."
msgstr "타입에 대한 [공유 참조](types/pointer.md#shared-references-)를 통해 내부 상태를 변경할 수 있다면 그 타입은 내부 가변성을 가집니다."

#: src/interior-mutability.md:17
msgid ""
"This goes against the usual [requirement](behavior-considered-undefined.md) "
"that the value pointed to by a shared reference is not mutated."
msgstr "이는 공유 참조가 가리키는 값은 변경되지 않는다는 일반적인 [요구사항](behavior-considered-undefined.md)에 반하는 것입니다."

#: src/interior-mutability.md:22
msgid ""
"[`std::cell::UnsafeCell<T>`](../core/cell/struct.UnsafeCell.html) type is "
"the only allowed way to disable this requirement. When `UnsafeCell<T>` is "
"immutably aliased, it is still safe to mutate, or obtain a mutable reference "
"to, the `T` it contains."
msgstr "[`std::cell::UnsafeCell<T>`](../core/cell/struct.UnsafeCell.html) 타입은 이 요구사항을 비활성화하는 유일한 허용된 방법입니다. `UnsafeCell<T>`가 불변으로 별칭이 지정되어 있더라도, 그 안에 포함된 `T`를 변경하거나 `T`에 대한 가변 참조를 얻는 것은 여전히 안전합니다."

#: src/interior-mutability.md:28
msgid ""
"As with all other types, it is undefined behavior to have multiple `&mut "
"UnsafeCell<T>` aliases."
msgstr "다른 모든 타입과 마찬가지로, 여러 개의 `&mut UnsafeCell<T>` 별칭을 갖는 것은 정의되지 않은 동작입니다."

#: src/interior-mutability.md:33
msgid ""
"Other types with interior mutability can be created by using `UnsafeCell<T>` "
"as a field. The standard library provides a variety of types that provide "
"safe interior mutability APIs."
msgstr "내부 가변성을 가진 다른 타입들은 `UnsafeCell<T>`를 필드로 사용하여 생성될 수 있습니다. 표준 라이브러리는 안전한 내부 가변성 API를 제공하는 다양한 타입을 제공합니다."

#: src/interior-mutability.md:39
msgid ""
"For example, [`std::cell::RefCell<T>`](../core/cell/struct.RefCell.html) "
"uses run-time borrow checks to ensure the usual rules around multiple "
"references."
msgstr "예를 들어, [`std::cell::RefCell<T>`](../core/cell/struct.RefCell.html)은 런타임 차용 검사를 사용하여 다중 참조에 대한 일반적인 규칙을 보장합니다."

#: src/interior-mutability.md:43
msgid ""
"The [`std::sync::atomic`](../core/sync/atomic/index.html) module contains "
"types that wrap a value that is only accessed with atomic operations, "
"allowing the value to be shared and mutated across threads."
msgstr "[`std::sync::atomic`](../core/sync/atomic/index.html) 모듈은 원자적 연산으로만 접근되는 값을 감싸는 타입을 포함하여, 값이 스레드 간에 공유되고 변경될 수 있도록 합니다."

#: src/subtyping.md:7
msgid ""
"Subtyping is implicit and can occur at any stage in type checking or "
"inference."
msgstr "서브타이핑은 암시적이며 타입 검사나 추론의 어느 단계에서든 발생할 수 있습니다."

#: src/subtyping.md:12
msgid ""
"Subtyping is restricted to two cases: variance with respect to lifetimes and "
"between types with higher ranked lifetimes. If we were to erase lifetimes "
"from types, then the only subtyping would be due to type equality."
msgstr "서브타이핑은 두 가지 경우로 제한됩니다: 라이프타임에 대한 가변성(variance)과 고차원(higher ranked) 라이프타임을 가진 타입 간의 관계입니다. 만약 타입에서 라이프타임을 제거한다면, 유일한 서브타이핑은 타입 동등성 때문일 것입니다."

#: src/subtyping.md:17
msgid ""
"Consider the following example: string literals always have `'static` "
"lifetime. Nevertheless, we can assign `s` to `t`:"
msgstr "다음 예시를 고려해보십시오: 문자열 리터럴은 항상 `'static` 라이프타임을 가집니다. 그럼에도 불구하고 우리는 `s`를 `t`에 할당할 수 있습니다:"

#: src/subtyping.md:22
msgid "\"hi\""
msgstr "\"hi\""

#: src/subtyping.md:27
msgid ""
"Since `'static` outlives the lifetime parameter `'a`, `&'static str` is a "
"subtype of `&'a str`."
msgstr "`'static`은 라이프타임 매개변수 `'a`보다 오래 생존하므로, `&'static str`은 `&'a str`의 서브타입입니다."

#: src/subtyping.md:32
msgid ""
"[Higher-ranked](../nomicon/hrtb.html) [function pointers](types/function-"
"pointer.md) and [trait objects](types/trait-object.md) have another subtype "
"relation. They are subtypes of types that are given by substitutions of the "
"higher-ranked lifetimes. Some examples:"
msgstr "[고차원(Higher-ranked)](../nomicon/hrtb.html) [함수 포인터](types/function-pointer.md)와 [트레잇 객체](types/trait-object.md)는 또 다른 서브타입 관계를 가집니다. 이들은 고차원 라이프타임의 대체로 주어지는 타입들의 서브타입입니다. 몇 가지 예시:"

#: src/subtyping.md:37
msgid "// Here 'a is substituted for 'static\n"
msgstr "// 여기서 'a는 'static으로 대체됩니다\n"

#: src/subtyping.md:40
msgid "// This works similarly for trait objects\n"
msgstr "// 이는 트레잇 객체에 대해서도 유사하게 작동합니다\n"

#: src/subtyping.md:44
msgid "// We can also substitute one higher-ranked lifetime for another\n"
msgstr "// 하나의 고차원 라이프타임을 다른 것으로 대체할 수도 있습니다\n"

#: src/subtyping.md:52
msgid "Variance"
msgstr "가변성 (Variance)"

#: src/subtyping.md:56
msgid ""
"Variance is a property that generic types have with respect to their "
"arguments. A generic type's _variance_ in a parameter is how the subtyping "
"of the parameter affects the subtyping of the type."
msgstr "가변성은 제네릭 타입이 그 인자에 대해 갖는 속성입니다. 매개변수에 대한 제네릭 타입의 _가변성_은 매개변수의 서브타이핑이 타입의 서브타이핑에 어떻게 영향을 미치는지를 나타냅니다."

#: src/subtyping.md:62
msgid ""
"`F<T>` is _covariant_ over `T` if `T` being a subtype of `U` implies that "
"`F<T>` is a subtype of `F<U>` (subtyping \"passes through\")"
msgstr "`T`가 `U`의 서브타입일 때 `F<T>`가 `F<U>`의 서브타입이면, `F<T>`는 `T`에 대해 _공변적(covariant)_입니다 (서브타이핑이 \"통과\"함)."

#: src/subtyping.md:67
msgid ""
"`F<T>` is _contravariant_ over `T` if `T` being a subtype of `U` implies "
"that `F<U>` is a subtype of `F<T>`"
msgstr "`T`가 `U`의 서브타입일 때 `F<U>`가 `F<T>`의 서브타입이면, `F<T>`는 `T`에 대해 _반변적(contravariant)_입니다."

#: src/subtyping.md:72
msgid ""
"`F<T>` is _invariant_ over `T` otherwise (no subtyping relation can be "
"derived)"
msgstr "그렇지 않으면 `F<T>`는 `T`에 대해 _불변적(invariant)_입니다 (서브타입 관계가 유도될 수 없음)"

#: src/subtyping.md:77
msgid "Variance of types is automatically determined as follows"
msgstr "타입의 가변성은 다음과 같이 자동으로 결정됩니다"

#: src/subtyping.md:79
msgid "Variance in `'a`"
msgstr "`'a`에 대한 가변성"

#: src/subtyping.md:79
msgid "Variance in `T`"
msgstr "`T`에 대한 가변성"

#: src/subtyping.md:81
msgid "`&'a T`"
msgstr "`&'a T`"

#: src/subtyping.md:81 src/subtyping.md:82 src/subtyping.md:83
#: src/subtyping.md:85 src/subtyping.md:86 src/subtyping.md:89
#: src/subtyping.md:90
msgid "covariant"
msgstr "공변적"

#: src/subtyping.md:82
msgid "`&'a mut T`"
msgstr "`&'a mut T`"

#: src/subtyping.md:82 src/subtyping.md:84 src/subtyping.md:88
#: src/subtyping.md:90
msgid "invariant"
msgstr "불변적"

#: src/subtyping.md:83 src/type-coercions.md:197
msgid "`*const T`"
msgstr "`*const T`"

#: src/subtyping.md:84 src/type-coercions.md:198
msgid "`*mut T`"
msgstr "`*mut T`"

#: src/subtyping.md:85
msgid "`[T]` and `[T; n]`"
msgstr "`[T]` 및 `[T; n]`"

#: src/subtyping.md:86
msgid "`fn() -> T`"
msgstr "`fn() -> T`"

#: src/subtyping.md:87
msgid "`fn(T) -> ()`"
msgstr "`fn(T) -> ()`"

#: src/subtyping.md:87
msgid "contravariant"
msgstr "반변적"

#: src/subtyping.md:88
msgid "`std::cell::UnsafeCell<T>`"
msgstr "`std::cell::UnsafeCell<T>`"

#: src/subtyping.md:89
msgid "`std::marker::PhantomData<T>`"
msgstr "`std::marker::PhantomData<T>`"

#: src/subtyping.md:90
msgid "`dyn Trait<T> + 'a`"
msgstr "`dyn Trait<T> + 'a`"

#: src/subtyping.md:94
msgid ""
"The variance of other `struct`, `enum`, and `union` types is decided by "
"looking at the variance of the types of their fields. If the parameter is "
"used in positions with different variances then the parameter is invariant. "
"For example the following struct is covariant in `'a` and `T` and invariant "
"in `'b`, `'c`, and `U`."
msgstr "다른 `struct`, `enum`, `union` 타입의 가변성은 필드 타입의 가변성을 보고 결정됩니다. 매개변수가 서로 다른 가변성을 가진 위치에서 사용되면 해당 매개변수는 불변적입니다. 예를 들어, 다음 구조체는 `'a`와 `T`에 대해 공변적이며, `'b`, `'c`, `U`에 대해서는 불변적입니다."

#: src/subtyping.md:103
msgid ""
"// This makes `Variance` covariant in 'a, and would\n"
"                            // make it covariant in U, but U is used later\n"
msgstr "// 이것은 `Variance`를 'a에 대해 공변적으로 만들고,\n// U에 대해서도 공변적으로 만들겠지만, U는 나중에 사용됩니다\n"

#: src/subtyping.md:105
msgid "// Covariant in T\n"
msgstr "// T에 대해 공변적\n"

#: src/subtyping.md:106
msgid "// Invariant in 'b\n"
msgstr "// 'b에 대해 불변적\n"

#: src/subtyping.md:107
msgid "// Invariant in U, makes the whole struct invariant\n"
msgstr "// U에 대해 불변적이며, 전체 구조체를 불변적으로 만듦\n"

#: src/subtyping.md:109
msgid ""
"// Both co- and contravariant, makes 'c invariant\n"
"                            // in the struct.\n"
msgstr "// 공변적이면서 동시에 반변적이므로, 구조체 내에서 'c를 불변적으로 만듭니다.\n"

#: src/subtyping.md:116
msgid ""
"When used outside of an `struct`, `enum`, or `union`, the variance for "
"parameters is checked at each location separately."
msgstr "`struct`, `enum`, `union` 외부에서 사용될 때, 매개변수의 가변성은 각 위치에서 개별적으로 확인됩니다."

#: src/subtyping.md:121
msgid ""
"// 'long is used inside of a tuple in both a co- and invariant position.\n"
msgstr "// 'long은 튜플 내부의 공변적 위치와 불변적 위치 모두에서 사용됩니다.\n"

#: src/subtyping.md:124
msgid ""
"// As the variance at these positions is computed separately,\n"
"    // we can freely shrink 'long in the covariant position.\n"
msgstr "// 이 위치들에서의 가변성은 개별적으로 계산되므로,\n    // 공변적 위치에서 'long을 자유롭게 줄일 수 있습니다.\n"

#: src/subtyping.md:130
msgid "// 'middle is used in both a co- and contravariant position.\n"
msgstr "// 'middle은 공변적 위치와 반변적 위치 모두에서 사용됩니다.\n"

#: src/subtyping.md:133
msgid ""
"// As the variance at these positions is computed separately,\n"
"    // we can freely shrink 'middle in the covariant position\n"
"    // and extend it in the contravariant position.\n"
msgstr "// 이 위치들에서의 가변성은 개별적으로 계산되므로,\n    // 공변적 위치에서 'middle을 자유롭게 줄일 수 있고\n    // 반변적 위치에서 늘릴 수 있습니다.\n"

#: src/trait-bounds.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TypeParamBounds_ :  \n"
"   _TypeParamBound_ ( `+` _TypeParamBound_ )<sup>\\*</sup> `+`<sup>?</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_타입매개변수바운드_ :  \n"
"   _타입매개변수바운드_ ( `+` _타입매개변수바운드_ )<sup>*</sup> `+`<sup>?</sup>"

#: src/trait-bounds.md:11
msgid ""
"_TypeParamBound_ :  \n"
"      _Lifetime_ | _TraitBound_ | _UseBound_"
msgstr ""
"_타입매개변수바운드_ :  \n"
"      _라이프타임_ | _트레잇바운드_ | _사용바운드_"

#: src/trait-bounds.md:14
msgid ""
"_TraitBound_ :  \n"
"      ( `?` | [_ForLifetimes_](#higher-ranked-trait-bounds) )<sup>?</sup> "
"[_TypePath_](paths.md#paths-in-types)  \n"
"   | `(` ( `?` | [_ForLifetimes_](#higher-ranked-trait-bounds) )<sup>?</sup> "
"[_TypePath_](paths.md#paths-in-types) `)`"
msgstr ""
"_트레잇바운드_ :  \n"
"      ( `?` | [_For라이프타임_](#higher-ranked-trait-bounds) )<sup>?</sup> "
"[_타입경로_](paths.md#paths-in-types)  \n"
"   | `(` ( `?` | [_For라이프타임_](#higher-ranked-trait-bounds) )<sup>?</sup> "
"[_타입경로_](paths.md#paths-in-types) `)`"

#: src/trait-bounds.md:20
msgid ""
"_LifetimeBounds_ :  \n"
"   ( _Lifetime_ `+` )<sup>\\*</sup> _Lifetime_<sup>?</sup>"
msgstr ""
"_라이프타임바운드_ :  \n"
"   ( _라이프타임_ `+` )<sup>*</sup> _라이프타임_<sup>?</sup>"

#: src/trait-bounds.md:23
msgid ""
"_Lifetime_ :  \n"
"      [LIFETIME_OR_LABEL](tokens.md#lifetimes-and-loop-labels)  \n"
"   | `'static`  \n"
"   | `'_`"
msgstr ""
"_라이프타임_ :  \n"
"      [라이프타임또는레이블](tokens.md#lifetimes-and-loop-labels)  \n"
"   | `'static`  \n"
"   | `'_`"

#: src/trait-bounds.md:28
msgid ""
"_UseBound_ :  \n"
"   `use` _UseBoundGenericArgs_"
msgstr ""
"_사용바운드_ :  \n"
"   `use` _사용바운드제네릭인자_"

#: src/trait-bounds.md:31
msgid ""
"_UseBoundGenericArgs_ :  \n"
"      `<` `>`   \n"
"   | `<`   \n"
"      ( _UseBoundGenericArg_ `,`)<sup>\\*</sup>   \n"
"      _UseBoundGenericArg_ `,`<sup>?</sup>   \n"
"      `>`"
msgstr ""
"_사용바운드제네릭인자_ :  \n"
"      `<` `>`   \n"
"   | `<`   \n"
"      ( _사용바운드제네릭인자요소_ `,`)<sup>*</sup>   \n"
"      _사용바운드제네릭인자요소_ `,`<sup>?</sup>   \n"
"      `>`"

#: src/trait-bounds.md:38
msgid ""
"_UseBoundGenericArg_ :  \n"
"      _Lifetime_   \n"
"   | [IDENTIFIER](identifiers.html)   \n"
"   | `Self`"
msgstr ""
"_사용바운드제네릭인자요소_ :  \n"
"      _라이프타임_   \n"
"   | [식별자](identifiers.html)   \n"
"   | `Self`"

#: src/trait-bounds.md:45
msgid ""
"[Trait](items/traits.md#trait-bounds) and lifetime bounds provide a way for "
"[generic items](items/generics.md) to restrict which types and lifetimes are "
"used as their parameters. Bounds can be provided on any type in a [where "
"clause](items/generics.md#where-clauses). There are also shorter forms for "
"certain common cases:"
msgstr "[트레잇](items/traits.md#trait-bounds) 및 라이프타임 바운드는 [제네릭 아이템](items/generics.md)이 매개변수로 사용될 수 있는 타입과 라이프타임을 제한하는 방법을 제공합니다. 바운드는 [where 절](items/generics.md#where-clauses)의 모든 타입에 대해 제공될 수 있습니다. 특정 일반적인 경우에 대한 더 짧은 형식도 있습니다:"

#: src/trait-bounds.md:50
msgid ""
"Bounds written after declaring a [generic parameter](items/generics.md): `fn "
"f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`."
msgstr "[제네릭 매개변수](items/generics.md) 선언 뒤에 작성된 바운드: `fn f<A: Copy>() {}`는 `fn f<A>() where A: Copy {}`와 같습니다."

#: src/trait-bounds.md:52
msgid ""
"In trait declarations as [supertraits](items/traits.md#supertraits): `trait "
"Circle : Shape {}` is equivalent to `trait Circle where Self : Shape {}`."
msgstr "트레잇 선언에서 [상위 트레잇(supertraits)](items/traits.md#supertraits)으로서: `trait Circle : Shape {}`는 `trait Circle where Self : Shape {}`와 동일합니다."

#: src/trait-bounds.md:54
msgid ""
"In trait declarations as bounds on [associated types](items/associated-"
"items.md#associated-types): `trait A { type B: Copy; }` is equivalent to "
"`trait A where Self::B: Copy { type B; }`."
msgstr "트레잇 선언에서 [연관 타입](items/associated-items.md#associated-types)에 대한 바운드로서: `trait A { type B: Copy; }`는 `trait A where Self::B: Copy { type B; }`와 동일합니다."

#: src/trait-bounds.md:60
msgid ""
"Bounds on an item must be satisfied when using the item. When type checking "
"and borrow checking a generic item, the bounds can be used to determine that "
"a trait is implemented for a type. For example, given `Ty: Trait`"
msgstr "아이템의 바운드는 아이템을 사용할 때 만족되어야 합니다. 제네릭 아이템을 타입 검사하고 차용 검사할 때, 바운드는 어떤 타입에 대해 트레잇이 구현되었는지를 판단하는 데 사용될 수 있습니다. 예를 들어, `Ty: Trait`가 주어졌을 때"

#: src/trait-bounds.md:64
msgid ""
"In the body of a generic function, methods from `Trait` can be called on "
"`Ty` values. Likewise associated constants on the `Trait` can be used."
msgstr "제네릭 함수의 본문에서, `Trait`의 메서드를 `Ty` 값에 대해 호출할 수 있습니다. 마찬가지로 `Trait`의 연관 상수도 사용할 수 있습니다."

#: src/trait-bounds.md:66
msgid "Associated types from `Trait` can be used."
msgstr "`Trait`의 연관 타입을 사용할 수 있습니다."

#: src/trait-bounds.md:67
msgid ""
"Generic functions and types with a `T: Trait` bounds can be used with `Ty` "
"being used for `T`."
msgstr "`T: Trait` 바운드가 있는 제네릭 함수 및 타입은 `T` 대신 `Ty`를 사용하여 사용될 수 있습니다."

#: src/trait-bounds.md:78
msgid "// Can call method because T: Shape\n"
msgstr "// T: Shape이므로 메서드 호출 가능\n"

#: src/trait-bounds.md:83
msgid "// doesn't move sh because T: Copy\n"
msgstr "// T: Copy이므로 sh를 이동시키지 않음\n"

#: src/trait-bounds.md:84
msgid "// Can use generic function because T: Shape\n"
msgstr "// T: Shape이므로 제네릭 함수 사용 가능\n"

#: src/trait-bounds.md:90
msgid "// Type Figure<U> is well-formed because U: Shape\n"
msgstr "// U: Shape이므로 타입 Figure<U>는 잘 형성됨(well-formed)\n"

#: src/trait-bounds.md:93
msgid "\"Figure of two {}\""
msgstr "\"두 개의 {} 모양\""

#: src/trait-bounds.md:94
msgid "// Can use associated function\n"
msgstr "// 연관 함수 사용 가능\n"

#: src/trait-bounds.md:101
msgid ""
"Bounds that don't use the item's parameters or [higher-ranked lifetimes]"
"(#higher-ranked-trait-bounds) are checked when the item is defined. It is an "
"error for such a bound to be false."
msgstr "아이템의 매개변수나 [고차원 라이프타임](#higher-ranked-trait-bounds)을 사용하지 않는 바운드는 아이템이 정의될 때 검사됩니다. 그러한 바운드가 거짓이면 오류입니다."

#: src/trait-bounds.md:106
msgid ""
"[`Copy`](special-types-and-traits.md#copy), [`Clone`](special-types-and-"
"traits.md#clone), and [`Sized`](special-types-and-traits.md#sized) bounds "
"are also checked for certain generic types when using the item, even if the "
"use does not provide a concrete type. It is an error to have `Copy` or "
"`Clone` as a bound on a mutable reference, [trait object](types/trait-"
"object.md), or [slice](types/slice.md). It is an error to have `Sized` as a "
"bound on a trait object or slice."
msgstr "아이템을 사용할 때, [`Copy`](special-types-and-traits.md#copy), [`Clone`](special-types-and-traits.md#clone), [`Sized`](special-types-and-traits.md#sized) 바운드는 사용 시 구체적인 타입이 제공되지 않더라도 특정 제네릭 타입에 대해 검사됩니다. 가변 참조, [트레잇 객체](types/trait-object.md), 또는 [슬라이스](types/slice.md)에 대해 `Copy`나 `Clone`을 바운드로 갖는 것은 오류입니다. 트레잇 객체나 슬라이스에 대해 `Sized`를 바운드로 갖는 것도 오류입니다."

#: src/trait-bounds.md:114
msgid "// Error: `i32` is not an iterator\n"
msgstr "// 오류: `i32`는 반복자가 아님\n"

#: src/trait-bounds.md:115
msgid "// (at use) Error: the trait bound is not satisfied\n"
msgstr "// (사용 시) 오류: 트레잇 바운드가 만족되지 않음\n"

#: src/trait-bounds.md:116
msgid "// (at use) Error: size cannot be known at compilation\n"
msgstr "// (사용 시) 오류: 컴파일 시에 크기를 알 수 없음\n"

#: src/trait-bounds.md:125
msgid ""
"Trait and lifetime bounds are also used to name [trait objects](types/trait-"
"object.md)."
msgstr "트레잇 및 라이프타임 바운드는 [트레잇 객체](types/trait-object.md)를 명명하는 데에도 사용됩니다."

#: src/trait-bounds.md:129
msgid "`?Sized`"
msgstr "`?Sized`"

#: src/trait-bounds.md:132
msgid ""
"`?` is only used to relax the implicit [`Sized`](special-types-and-"
"traits.md#sized) trait bound for [type parameters](types/parameters.md) or "
"[associated types](items/associated-items.md#associated-types). `?Sized` may "
"not be used as a bound for other types."
msgstr "`?`는 [타입 매개변수](types/parameters.md) 또는 [연관 타입](items/associated-items.md#associated-types)에 대한 암시적인 [`Sized`](special-types-and-traits.md#sized) 트레잇 바운드를 완화하는 데에만 사용됩니다. `?Sized`는 다른 타입에 대한 바운드로 사용될 수 없습니다."

#: src/trait-bounds.md:137
msgid "Lifetime bounds"
msgstr "라이프타임 바운드"

#: src/trait-bounds.md:141
msgid "Lifetime bounds can be applied to types or to other lifetimes."
msgstr "라이프타임 바운드는 타입이나 다른 라이프타임에 적용될 수 있습니다."

#: src/trait-bounds.md:145
msgid ""
"The bound `'a: 'b` is usually read as `'a` _outlives_ `'b`. `'a: 'b` means "
"that `'a` lasts at least as long as `'b`, so a reference `&'a ()` is valid "
"whenever `&'b ()` is valid."
msgstr "`'a: 'b` 바운드는 보통 `'a`가 `'b`보다 _오래 산다(outlives)_라고 읽습니다. `'a: 'b`는 `'a`가 적어도 `'b`만큼 오래 지속됨을 의미하므로, `&'b ()`가 유효할 때마다 `&'a ()` 참조도 유효합니다."

#: src/trait-bounds.md:150
msgid "// &'a i32 is a subtype of &'b i32 because 'a: 'b\n"
msgstr "// 'a: 'b이므로 &'a i32는 &'b i32의 서브타입입니다\n"

#: src/trait-bounds.md:151
msgid "// &'b &'a i32 is well formed because 'a: 'b\n"
msgstr "// 'a: 'b이므로 &'b &'a i32는 잘 형성되었습니다\n"

#: src/trait-bounds.md:157
msgid ""
"`T: 'a` means that all lifetime parameters of `T` outlive `'a`. For example, "
"if `'a` is an unconstrained lifetime parameter, then `i32: 'static` and "
"`&'static str: 'a` are satisfied, but `Vec<&'a ()>: 'static` is not."
msgstr "`T: 'a`는 `T`의 모든 라이프타임 매개변수가 `'a`보다 오래 산다는 것을 의미합니다. 예를 들어, `'a`가 제약 없는 라이프타임 매개변수라면 `i32: 'static`과 `&'static str: 'a`는 만족되지만, `Vec<&'a ()>: 'static`은 만족되지 않습니다."

#: src/trait-bounds.md:162
msgid "Higher-ranked trait bounds"
msgstr "고차원 트레잇 바운드"

#: src/trait-bounds.md:166
msgid ""
"_ForLifetimes_ :  \n"
"   `for` `<` [_GenericParams_](items/generics.md) `>`"
msgstr ""
"_For라이프타임_ :  \n"
"   `for` `<` [_제네릭매개변수_](items/generics.md) `>`"

#: src/trait-bounds.md:171
msgid ""
"Trait bounds may be _higher ranked_ over lifetimes. These bounds specify a "
"bound that is true _for all_ lifetimes. For example, a bound such as "
"`for<'a> &'a T: PartialEq<i32>` would require an implementation like"
msgstr ""
"트레잇 바운드는 라이프타임에 대해 _고차원(higher ranked)_일 수 있습니다. 이 바운드들은 _모든_ 라이프타임에 대해 참인 바운드를 지정합니다. 예를 들어, `for<'a> &'a T: PartialEq<i32>`와 같은 바운드는 다음과 같은 구현을 요구합니다."

#: src/trait-bounds.md:183
msgid ""
"and could then be used to compare a `&'a T` with any lifetime to an `i32`."
msgstr ""
"그러면 어떤 라이프타임을 가진 `&'a T`라도 `i32`와 비교하는 데 사용될 수 있습니다."

#: src/trait-bounds.md:185
msgid ""
"Only a higher-ranked bound can be used here, because the lifetime of the "
"reference is shorter than any possible lifetime parameter on the function:"
msgstr ""
"여기서는 고차원 바운드만 사용될 수 있는데, 이는 참조의 라이프타임이 함수의 모든 가능한 라이프타임 매개변수보다 짧기 때문입니다."

#: src/trait-bounds.md:196
msgid ""
"Higher-ranked lifetimes may also be specified just before the trait: the "
"only difference is the [scope](names/scopes.md#higher-ranked-trait-bound-"
"scopes) of the lifetime parameter, which extends only to the end of the "
"following trait instead of the whole bound. This function is equivalent to "
"the last one."
msgstr ""
"고차원 라이프타임은 트레잇 바로 앞에서 지정될 수도 있습니다. 유일한 차이점은 라이프타임 매개변수의 [스코프(scope)](names/scopes.md#higher-ranked-trait-bound-scopes)이며, 이는 전체 바운드가 아닌 뒤따르는 트레잇의 끝까지만 확장됩니다. 이 함수는 이전 함수와 동일합니다."

#: src/trait-bounds.md:210
msgid "Implied bounds"
msgstr "함축된 바운드"

#: src/trait-bounds.md:214
msgid ""
"Lifetime bounds required for types to be well-formed are sometimes inferred."
msgstr ""
"타입이 잘 형성되기 위해 필요한 라이프타임 바운드는 때때로 추론됩니다."

#: src/trait-bounds.md:220
msgid ""
"The type parameter `T` is required to outlive `'a` for the type `&'a T` to "
"be well-formed. This is inferred because the function signature contains the "
"type `&'a T` which is only valid if `T: 'a` holds."
msgstr ""
"타입 `&'a T`가 잘 형성되기 위해서는 타입 매개변수 `T`가 `'a`보다 오래 살아야 합니다. 이는 함수 시그니처에 `T: 'a`가 성립해야만 유효한 `&'a T` 타입이 포함되어 있기 때문에 추론됩니다."

#: src/trait-bounds.md:226
msgid ""
"Implied bounds are added for all parameters and outputs of functions. Inside "
"of `requires_t_outlives_a` you can assume `T: 'a` to hold even if you don't "
"explicitly specify this:"
msgstr ""
"함수의 모든 매개변수와 출력에 대해 함축된 바운드가 추가됩니다. `requires_t_outlives_a` 내부에서는 명시적으로 지정하지 않더라도 `T: 'a`가 성립한다고 가정할 수 있습니다."

#: src/trait-bounds.md:233
msgid ""
"// This compiles, because `T: 'a` is implied by\n"
"    // the reference type `&'a T`.\n"
msgstr ""
"// 이 코드는 컴파일됩니다. 참조 타입 `&'a T`에 의해\n"
"    // `T: 'a`가 함축되기 때문입니다.\n"

#: src/trait-bounds.md:242
msgid ""
"// This errors, because `T: 'a` is not implied by\n"
"    // the function signature.\n"
msgstr ""
"// 이 코드는 오류가 발생합니다. 함수 시그니처에 의해\n"
"    // `T: 'a`가 함축되지 않기 때문입니다.\n"

#: src/trait-bounds.md:250
msgid ""
"Only lifetime bounds are implied, trait bounds still have to be explicitly "
"added. The following example therefore causes an error:"
msgstr ""
"라이프타임 바운드만 함축될 뿐이며, 트레잇 바운드는 여전히 명시적으로 추가해야 합니다. 따라서 다음 예제는 오류를 발생시킵니다."

#: src/trait-bounds.md:255
msgid "// error[E0277]: `T` doesn't implement `Debug`\n"
msgstr "// error[E0277]: `T`가 `Debug`를 구현하지 않음\n"

#: src/trait-bounds.md:262
msgid ""
"Lifetime bounds are also inferred for type definitions and impl blocks for "
"any type:"
msgstr ""
"라이프타임 바운드는 타입 정의 및 모든 타입에 대한 impl 블록에서도 추론됩니다."

#: src/trait-bounds.md:266
msgid ""
"// This requires `T: 'a` to be well-formed\n"
"    // which is inferred by the compiler.\n"
msgstr ""
"// 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,\n"
"    // 이는 컴파일러에 의해 추론됩니다.\n"

#: src/trait-bounds.md:272
msgid ""
"// This requires `T: 'a` to be well-formed,\n"
"    // which is inferred by the compiler.\n"
"    //\n"
"    // Note that `T: 'a` is required even when only\n"
"    // using `Enum::OtherVariant`.\n"
msgstr ""
"// 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,\n"
"    // 이는 컴파일러에 의해 추론됩니다.\n"
"    //\n"
"    // `Enum::OtherVariant`만 사용하는 경우에도\n"
"    // `T: 'a`가 필요함에 유의하세요.\n"

#: src/trait-bounds.md:282
msgid ""
"// This would error because `T: 'a` is not implied by any type\n"
"// in the impl header.\n"
"//     impl<'a, T> Trait<'a, T> for () {}\n"
msgstr ""
"// 이 코드는 오류가 발생합니다. impl 헤더의 어떤 타입에 의해서도\n"
"// `T: 'a`가 함축되지 않기 때문입니다.\n"
"//     impl<'a, T> Trait<'a, T> for () {}\n"

#: src/trait-bounds.md:286
msgid "// This compiles as `T: 'a` is implied by the self type `&'a T`.\n"
msgstr "// 이 코드는 컴파일됩니다. 셀프 타입 `&'a T`에 의해 `T: 'a`가 함축되기 때문입니다.\n"

#: src/trait-bounds.md:293
msgid "Use bounds"
msgstr "사용 바운드"

#: src/trait-bounds.md:296
msgid ""
"Certain bounds lists may include a `use<..>` bound to control which generic "
"parameters are captured by the `impl Trait` [abstract return type](types/"
"impl-trait.md#abstract-return-types).  See [precise capturing](types/impl-"
"trait.md#precise-capturing) for more details."
msgstr ""
"일부 바운드 목록에는 `impl Trait` [추상 반환 타입(abstract return type)](types/impl-trait.md#abstract-return-types)에 의해 캡처되는 제네릭 매개변수를 제어하기 위해 `use<..>` 바운드가 포함될 수 있습니다. 자세한 내용은 [정밀한 캡처(precise capturing)](types/impl-trait.md#precise-capturing)를 참조하세요."

#: src/type-coercions.md:7
msgid ""
"**Type coercions** are implicit operations that change the type of a value. "
"They happen automatically at specific locations and are highly restricted in "
"what types actually coerce."
msgstr ""
"**타입 강제 변환(Type coercions)**은 값의 타입을 변경하는 암시적 연산입니다. 프로그램의 특정 위치에서 자동으로 발생하며, 실제로 강제 변환이 가능한 타입은 엄격히 제한됩니다."

#: src/type-coercions.md:13
msgid ""
"Any conversions allowed by coercion can also be explicitly performed by the "
"[type cast operator](expressions/operator-expr.md#type-cast-expressions), "
"`as`."
msgstr ""
"강제 변환에 의해 허용되는 모든 변환은 [타입 캐스트 연산자(type cast operator)](expressions/operator-expr.md#type-cast-expressions)인 `as`를 통해 명시적으로 수행될 수도 있습니다."

#: src/type-coercions.md:16
msgid ""
"Coercions are originally defined in [RFC 401](https://github.com/rust-lang/"
"rfcs/blob/master/text/0401-coercions.md) and expanded upon in [RFC 1558]"
"(https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-"
"coercion.md)."
msgstr ""
"강제 변환은 원래 [RFC 401](https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md)에서 정의되었으며, [RFC 1558](https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md)에서 확장되었습니다."

#: src/type-coercions.md:20
msgid "Coercion sites"
msgstr "강제 변환 지점"

#: src/type-coercions.md:24
msgid ""
"A coercion can only occur at certain coercion sites in a program; these are "
"typically places where the desired type is explicit or can be derived by "
"propagation from explicit types (without type inference). Possible coercion "
"sites are:"
msgstr ""
"강제 변환은 프로그램의 특정 강제 변환 지점에서만 발생할 수 있습니다. 이러한 지점은 일반적으로 원하는 타입이 명시되어 있거나, 명시적인 타입으로부터 (타입 추론 없이) 전파되어 유도될 수 있는 곳입니다. 가능한 강제 변환 지점은 다음과 같습니다."

#: src/type-coercions.md:31
msgid "`let` statements where an explicit type is given."
msgstr "명시적인 타입이 주어진 `let` 구문."

#: src/type-coercions.md:33 src/type-coercions.md:50 src/type-coercions.md:67
msgid "For example, `&mut 42` is coerced to have type `&i8` in the following:"
msgstr "예를 들어, 다음 코드에서 `&mut 42`는 `&i8` 타입으로 강제 변환됩니다."

#: src/type-coercions.md:41
msgid "`static` and `const` item declarations (similar to `let` statements)."
msgstr "`static` 및 `const` 아이템 선언 (`let` 구문과 유사함)."

#: src/type-coercions.md:45
msgid "Arguments for function calls"
msgstr "함수 호출 인자"

#: src/type-coercions.md:47
msgid ""
"The value being coerced is the actual parameter, and it is coerced to the "
"type of the formal parameter."
msgstr ""
"강제 변환되는 값은 실제 매개변수(actual parameter)이며, 이는 형식 매개변수(formal parameter)의 타입으로 강제 변환됩니다."

#: src/type-coercions.md:60
msgid ""
"For method calls, the receiver (`self` parameter) type is coerced "
"differently, see the documentation on [method-call expressions](expressions/"
"method-call-expr.md) for details."
msgstr ""
"메서드 호출의 경우, 리시버(`self` 매개변수) 타입은 다르게 강제 변환됩니다. 자세한 내용은 [메서드 호출 표현식(method-call expressions)](expressions/method-call-expr.md) 문서를 참조하세요."

#: src/type-coercions.md:65
msgid "Instantiations of struct, union, or enum variant fields"
msgstr "구조체, 공용체, 또는 열거형 변형 필드의 인스턴스화"

#: src/type-coercions.md:79
msgid ""
"Function results—either the final line of a block if it is not semicolon-"
"terminated or any expression in a `return` statement"
msgstr ""
"함수 결과 — 세미콜론으로 끝나지 않은 블록의 마지막 줄 또는 `return` 구문의 모든 표현식"

#: src/type-coercions.md:82
msgid ""
"For example, `x` is coerced to have type `&dyn Display` in the following:"
msgstr "예를 들어, 다음 코드에서 `x`는 `&dyn Display` 타입으로 강제 변환됩니다."

#: src/type-coercions.md:93
msgid ""
"If the expression in one of these coercion sites is a coercion-propagating "
"expression, then the relevant sub-expressions in that expression are also "
"coercion sites. Propagation recurses from these new coercion sites. "
"Propagating expressions and their relevant sub-expressions are:"
msgstr ""
"만약 이러한 강제 변환 지점 중 하나에 있는 표현식이 강제 변환 전파 표현식인 경우, 해당 표현식의 관련 하위 표현식들 또한 강제 변환 지점이 됩니다. 전파는 이러한 새로운 강제 변환 지점들로부터 재귀적으로 발생합니다. 전파 표현식과 그와 관련된 하위 표현식들은 다음과 같습니다."

#: src/type-coercions.md:100
msgid ""
"Array literals, where the array has type `[U; n]`. Each sub-expression in "
"the array literal is a coercion site for coercion to type `U`."
msgstr ""
"배열 리터럴 (배열의 타입이 `[U; n]`인 경우). 배열 리터럴의 각 하위 표현식은 `U` 타입으로의 강제 변환을 위한 강제 변환 지점입니다."

#: src/type-coercions.md:105
msgid ""
"Array literals with repeating syntax, where the array has type `[U; n]`. The "
"repeated sub-expression is a coercion site for coercion to type `U`."
msgstr ""
"반복 구문을 사용하는 배열 리터럴 (배열의 타입이 `[U; n]`인 경우). 반복되는 하위 표현식은 `U` 타입으로의 강제 변환을 위한 강제 변환 지점입니다."

#: src/type-coercions.md:110
msgid ""
"Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`. "
"Each sub-expression is a coercion site to the respective type, e.g. the "
"zeroth sub-expression is a coercion site to type `U_0`."
msgstr ""
"튜플 (튜플이 `(U_0, U_1, ..., U_n)` 타입으로의 강제 변환 지점인 경우). 각 하위 표현식은 해당 타입으로의 강제 변환 지점입니다. 예를 들어, 0번째 하위 표현식은 `U_0` 타입으로의 강제 변환 지점입니다."

#: src/type-coercions.md:116
msgid ""
"Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then "
"the sub-expression is a coercion site to `U`."
msgstr ""
"괄호로 묶인 하위 표현식 (`(e)`): 표현식의 타입이 `U`인 경우, 하위 표현식은 `U`로의 강제 변환 지점입니다."

#: src/type-coercions.md:121
msgid ""
"Blocks: if a block has type `U`, then the last expression in the block (if "
"it is not semicolon-terminated) is a coercion site to `U`. This includes "
"blocks which are part of control flow statements, such as `if`/`else`, if "
"the block has a known type."
msgstr ""
"블록: 블록의 타입이 `U`인 경우, 블록의 마지막 표현식(세미콜론으로 끝나지 않은 경우)은 `U`로의 강제 변환 지점입니다. 여기에는 블록이 알려진 타입을 가진 경우 `if`/`else`와 같은 제어 흐름 구문의 일부인 블록도 포함됩니다."

#: src/type-coercions.md:128
msgid "Coercion types"
msgstr "강제 변환 타입"

#: src/type-coercions.md:132
msgid "Coercion is allowed between the following types:"
msgstr "강제 변환은 다음 타입들 사이에서 허용됩니다."

#: src/type-coercions.md:136
msgid ""
"`T` to `U` if `T` is a [subtype](subtyping.md) of `U` (_reflexive case_)"
msgstr "`T`가 `U`의 [서브타입(subtype)](subtyping.md)인 경우 `T`에서 `U`로 (_반사적 사례_)"

#: src/type-coercions.md:140
msgid ""
"`T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3` "
"(_transitive case_)"
msgstr "`T_1`이 `T_2`로 강제 변환되고 `T_2`가 `T_3`으로 강제 변환되는 경우 `T_1`에서 `T_3`으로 (_이행적 사례_)"

#: src/type-coercions.md:143
msgid "Note that this is not fully supported yet."
msgstr "이는 아직 완전히 지원되지 않음에 유의하세요."

#: src/type-coercions.md:147
msgid "`&mut T` to `&T`"
msgstr "`&mut T`에서 `&T`로"

#: src/type-coercions.md:151
msgid "`*mut T` to `*const T`"
msgstr "`*mut T`에서 `*const T`로"

#: src/type-coercions.md:155
msgid "`&T` to `*const T`"
msgstr "`&T`에서 `*const T`로"

#: src/type-coercions.md:159
msgid "`&mut T` to `*mut T`"
msgstr "`&mut T`에서 `*mut T`로"

#: src/type-coercions.md:163
msgid ""
"`&T` or `&mut T` to `&U` if `T` implements `Deref<Target = U>`. For example:"
msgstr "`T`가 `Deref<Target = U>`를 구현하는 경우 `&T` 또는 `&mut T`에서 `&U`로. 예를 들어:"

#: src/type-coercions.md:183
msgid "'y'"
msgstr "'y'"

#: src/type-coercions.md:184
msgid "//&mut CharContainer is coerced to &char.\n"
msgstr "//&mut CharContainer가 &char로 강제 변환됩니다.\n"

#: src/type-coercions.md:190
msgid "`&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`."
msgstr "`T`가 `DerefMut<Target = U>`를 구현하는 경우 `&mut T`에서 `&mut U`로."

#: src/type-coercions.md:194
msgid "TyCtor(`T`) to TyCtor(`U`), where TyCtor(`T`) is one of"
msgstr "TyCtor(`T`)에서 TyCtor(`U`)로. 여기서 TyCtor(`T`)는 다음 중 하나입니다."

#: src/type-coercions.md:195
msgid "`&T`"
msgstr "`&T`"

#: src/type-coercions.md:196
msgid "`&mut T`"
msgstr "`&mut T`"

#: src/type-coercions.md:199 src/special-types-and-traits.md:13
msgid "`Box<T>`"
msgstr "`Box<T>`"

#: src/type-coercions.md:201
msgid ""
"and where `U` can be obtained from `T` by [unsized coercion](#unsized-"
"coercions)."
msgstr "여기서 `U`는 [크기 미지정 강제 변환(unsized coercion)](#unsized-coercions)을 통해 `T`로부터 얻을 수 있는 타입입니다."

#: src/type-coercions.md:209
msgid "Function item types to `fn` pointers"
msgstr "함수 아이템 타입에서 `fn` 포인터로"

#: src/type-coercions.md:213
msgid "Non capturing closures to `fn` pointers"
msgstr "캡처하지 않는 클로저에서 `fn` 포인터로"

#: src/type-coercions.md:217
msgid "`!` to any `T`"
msgstr "`!`에서 임의의 `T`로"

#: src/type-coercions.md:221
msgid "Unsized Coercions"
msgstr "크기 미지정 강제 변환"

#: src/type-coercions.md:225
msgid ""
"The following coercions are called `unsized coercions`, since they relate to "
"converting types to unsized types, and are permitted in a few cases where "
"other coercions are not, as described above. They can still happen anywhere "
"else a coercion can occur."
msgstr ""
"다음 강제 변환들은 타입을 크기 미지정 타입으로 변환하는 것과 관련이 있기 때문에 `크기 미지정 강제 변환(unsized coercions)`이라고 불립니다. 위에서 설명한 것처럼 다른 강제 변환이 허용되지 않는 몇 가지 경우에도 허용되지만, 여전히 다른 강제 변환이 발생할 수 있는 모든 곳에서도 발생할 수 있습니다."

#: src/type-coercions.md:232
msgid ""
"Two traits, [`Unsize`](../core/marker/trait.Unsize.html) and "
"[`CoerceUnsized`](../core/ops/unsize/trait.CoerceUnsized.html), are used to "
"assist in this process and expose it for library use. The following "
"coercions are built-ins and, if `T` can be coerced to `U` with one of them, "
"then an implementation of `Unsize<U>` for `T` will be provided:"
msgstr ""
"이 과정을 돕고 라이브러리에서 사용할 수 있도록 노출하기 위해 [`Unsize`](../core/marker/trait.Unsize.html)와 [`CoerceUnsized`](../core/ops/unsize/trait.CoerceUnsized.html)라는 두 트레잇이 사용됩니다. 다음 강제 변환들은 내장된 기능이며, 만약 `T`가 이들 중 하나를 통해 `U`로 강제 변환될 수 있다면, `T`에 대한 `Unsize<U>` 구현이 제공됩니다."

#: src/type-coercions.md:239
msgid "`[T; n]` to `[T]`."
msgstr "`[T; n]`에서 `[T]`로."

#: src/type-coercions.md:243
msgid ""
"`T` to `dyn U`, when `T` implements `U + Sized`, and `U` is [dyn compatible]"
"(items/traits.md#dyn-compatibility)."
msgstr "`T`가 `U + Sized`를 구현하고 `U`가 [dyn 호환(dyn compatible)](items/traits.md#dyn-compatibility)인 경우, `T`에서 `dyn U`로."

#: src/type-coercions.md:247
msgid ""
"`dyn T` to `dyn U`, when `U` is one of `T`'s [supertraits](items/"
"traits.md#supertraits)."
msgstr "`U`가 `T`의 [상위 트레잇(supertraits)](items/traits.md#supertraits) 중 하나인 경우, `dyn T`에서 `dyn U`로."

#: src/type-coercions.md:248
msgid ""
"This allows dropping auto traits, i.e. `dyn T + Auto` to `dyn U` is allowed."
msgstr "이는 자동 트레잇을 제거하는 것을 허용합니다. 즉, `dyn T + Auto`에서 `dyn U`로의 강제 변환이 허용됩니다."

#: src/type-coercions.md:249
msgid ""
"This allows adding auto traits if the principal trait has the auto trait as "
"a super trait, i.e. given `trait T: U + Send {}`, `dyn T` to `dyn T + Send` "
"or to `dyn U + Send` coercions are allowed."
msgstr "주요 트레잇(principal trait)이 자동 트레잇을 상위 트레잇으로 가지고 있는 경우 자동 트레잇을 추가하는 것을 허용합니다. 즉, `trait T: U + Send {}`가 주어지면, `dyn T`에서 `dyn T + Send` 또는 `dyn U + Send`로의 강제 변환이 허용됩니다."

#: src/type-coercions.md:253
msgid "`Foo<..., T, ...>` to `Foo<..., U, ...>`, when:"
msgstr "다음의 경우, `Foo<..., T, ...>`에서 `Foo<..., U, ...>`로."

#: src/type-coercions.md:254
msgid "`Foo` is a struct."
msgstr "`Foo`는 구조체입니다."

#: src/type-coercions.md:255
msgid "`T` implements `Unsize<U>`."
msgstr "`T`가 `Unsize<U>`를 구현합니다."

#: src/type-coercions.md:256
msgid "The last field of `Foo` has a type involving `T`."
msgstr "`Foo`의 마지막 필드가 `T`를 포함하는 타입을 가집니다."

#: src/type-coercions.md:257
msgid ""
"If that field has type `Bar<T>`, then `Bar<T>` implements `Unsize<Bar<U>>`."
msgstr "해당 필드의 타입이 `Bar<T>`라면, `Bar<T>`는 `Unsize<Bar<U>>`를 구현합니다."

#: src/type-coercions.md:258
msgid "T is not part of the type of any other fields."
msgstr "`T`가 다른 필드의 타입에는 포함되지 않습니다."

#: src/type-coercions.md:262
msgid ""
"Additionally, a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` when `T` "
"implements `Unsize<U>` or `CoerceUnsized<Foo<U>>`. This allows it to provide "
"an unsized coercion to `Foo<U>`."
msgstr ""
"추가적으로, `T`가 `Unsize<U>` 또는 `CoerceUnsized<Foo<U>>`를 구현하는 경우 타입 `Foo<T>`는 `CoerceUnsized<Foo<U>>`를 구현할 수 있습니다. 이를 통해 `Foo<U>`로의 크기 미지정 강제 변환을 제공할 수 있습니다."

#: src/type-coercions.md:266
msgid ""
"Note: While the definition of the unsized coercions and their implementation "
"has been stabilized, the traits themselves are not yet stable and therefore "
"can't be used directly in stable Rust."
msgstr ""
"참고: 크기 미지정 강제 변환의 정의와 그 구현은 안정화되었지만, 트레잇 자체는 아직 안정화되지 않았으므로 안정 버전의 Rust에서 직접 사용할 수는 없습니다."

#: src/type-coercions.md:272
msgid "Least upper bound coercions"
msgstr "최소 상한 강제 변환"

#: src/type-coercions.md:276
msgid ""
"In some contexts, the compiler must coerce together multiple types to try "
"and find the most general type. This is called a \"Least Upper Bound\" "
"coercion. LUB coercion is used and only used in the following situations:"
msgstr ""
"일부 문맥에서 컴파일러는 가장 일반적인 타입을 찾기 위해 여러 타입을 함께 강제 변환해야 합니다. 이를 \"최소 상한(Least Upper Bound)\" 강제 변환이라고 합니다. LUB 강제 변환은 오직 다음과 같은 상황에서만 사용됩니다."

#: src/type-coercions.md:280
msgid "To find the common type for a series of if branches."
msgstr "일련의 if 분기들에 대한 공통 타입을 찾을 때."

#: src/type-coercions.md:281
msgid "To find the common type for a series of match arms."
msgstr "일련의 매치 암(match arms)들에 대한 공통 타입을 찾을 때."

#: src/type-coercions.md:282
msgid "To find the common type for array elements."
msgstr "배열 요소들에 대한 공통 타입을 찾을 때."

#: src/type-coercions.md:283
msgid ""
"To find the type for the return type of a closure with multiple return "
"statements."
msgstr "여러 개의 return 문이 있는 클로저의 반환 타입을 찾을 때."

#: src/type-coercions.md:284
msgid ""
"To check the type for the return type of a function with multiple return "
"statements."
msgstr "여러 개의 return 문이 있는 함수의 반환 타입을 검사할 때."

#: src/type-coercions.md:288
msgid ""
"In each such case, there are a set of types `T0..Tn` to be mutually coerced "
"to some target type `T_t`, which is unknown to start."
msgstr "이러한 각 사례에서, 시작 시점에는 알 수 없는 어떤 대상 타입 `T_t`로 서로 강제 변환되어야 하는 일련의 타입 `T0..Tn`이 존재합니다."

#: src/type-coercions.md:293
msgid ""
"Computing the LUB coercion is done iteratively. The target type `T_t` begins "
"as the type `T0`. For each new type `Ti`, we consider whether"
msgstr "LUB 강제 변환 계산은 반복적으로 수행됩니다. 대상 타입 `T_t`는 타입 `T0`에서 시작합니다. 각각의 새로운 타입 `Ti`에 대해 다음을 고려합니다."

#: src/type-coercions.md:299
msgid ""
"If `Ti` can be coerced to the current target type `T_t`, then no change is "
"made."
msgstr "`Ti`가 현재 대상 타입 `T_t`로 강제 변환될 수 있다면, 아무런 변경도 하지 않습니다."

#: src/type-coercions.md:303
msgid ""
"Otherwise, check whether `T_t` can be coerced to `Ti`; if so, the `T_t` is "
"changed to `Ti`. (This check is also conditioned on whether all of the "
"source expressions considered thus far have implicit coercions.)"
msgstr "그렇지 않은 경우, `T_t`가 `Ti`로 강제 변환될 수 있는지 확인합니다. 만약 가능하다면, `T_t`는 `Ti`로 변경됩니다. (이 확인 과정은 지금까지 고려된 모든 소스 표현식들에 암시적 강제 변환이 있는지 여부도 조건으로 합니다.)"

#: src/type-coercions.md:309
msgid ""
"If not, try to compute a mutual supertype of `T_t` and `Ti`, which will "
"become the new target type."
msgstr "그렇지 않다면, `T_t`와 `Ti` 사이의 상호 상위 타입(mutual supertype) 계산을 시도하며, 이것이 새로운 대상 타입이 됩니다."

#: src/type-coercions.md:314
msgid "// For if branches\n"
msgstr "// if 분기들의 경우\n"

#: src/type-coercions.md:323
msgid "// For match arms\n"
msgstr "// 매치 암들의 경우\n"

#: src/type-coercions.md:330
msgid "// For array elements\n"
msgstr "// 배열 요소들의 경우\n"

#: src/type-coercions.md:333
msgid "// For closure with multiple return statements\n"
msgstr "// 여러 개의 return 문이 있는 클로저의 경우\n"

#: src/type-coercions.md:345
msgid "// For type checking of function with multiple return statements\n"
msgstr "// 여러 개의 return 문이 있는 함수의 타입 검사의 경우\n"

#: src/type-coercions.md:357
msgid ""
"In these examples, types of the `ba*` are found by LUB coercion. And the "
"compiler checks whether LUB coercion result of `a`, `b`, `c` is `i32` in the "
"processing of the function `foo`."
msgstr "이 예제들에서 `ba*` 변수들의 타입은 LUB 강제 변환을 통해 찾아집니다. 그리고 컴파일러는 함수 `foo`를 처리하는 과정에서 `a`, `b`, `c`의 LUB 강제 변환 결과가 `i32`인지 확인합니다."

#: src/type-coercions.md:361
msgid "Caveat"
msgstr "주의 사항"

#: src/type-coercions.md:363
msgid ""
"This description is obviously informal. Making it more precise is expected "
"to proceed as part of a general effort to specify the Rust type checker more "
"precisely."
msgstr "이 설명은 분명히 비공식적인 것입니다. 이를 더 정밀하게 만드는 작업은 러스트 타입 검사기를 더 정밀하게 명세하려는 전반적인 노력의 일환으로 진행될 예정입니다."

#: src/destructors.md:5
msgid ""
"When an [initialized](glossary.md#initialized) [variable](variables.md) or "
"[temporary](expressions.md#temporaries) goes out of [scope](#drop-scopes), "
"its _destructor_ is run, or it is _dropped_. [Assignment](expressions/"
"operator-expr.md#assignment-expressions) also runs the destructor of its "
"left-hand operand, if it's initialized. If a variable has been partially "
"initialized, only its initialized fields are dropped."
msgstr ""
"[초기화된(initialized)](glossary.md#initialized) [변수](variables.md) 또는 [임시 값(temporary)](expressions.md#temporaries)이 [스코프(scope)](#drop-scopes)를 벗어나면, 해당 값의 _소멸자(destructor)_가 실행되거나 해당 값이 _드롭(dropped)_됩니다. [할당(Assignment)](expressions/operator-expr.md#assignment-expressions) 또한 좌항 피연산자가 초기화된 상태라면 그 소멸자를 실행합니다. 변수가 부분적으로만 초기화된 경우, 초기화된 필드만 드롭됩니다."

#: src/destructors.md:13
msgid "The destructor of a type `T` consists of:"
msgstr "타입 `T`의 소멸자는 다음과 같이 구성됩니다."

#: src/destructors.md:15
msgid ""
"If `T: Drop`, calling [`<T as std::ops::Drop>::drop`](../core/ops/drop/"
"trait.Drop.html#tymethod.drop)"
msgstr "`T: Drop`인 경우, [`<T as std::ops::Drop>::drop`](../core/ops/drop/trait.Drop.html#tymethod.drop) 호출"

#: src/destructors.md:16
msgid "Recursively running the destructor of all of its fields."
msgstr "모든 필드에 대해 재귀적으로 소멸자 실행."

#: src/destructors.md:17
msgid ""
"The fields of a [struct](types/struct.md) are dropped in declaration order."
msgstr "[구조체(struct)](types/struct.md)의 필드들은 선언된 순서대로 드롭됩니다."

#: src/destructors.md:18
msgid ""
"The fields of the active [enum variant](types/enum.md) are dropped in "
"declaration order."
msgstr "활성 [열거형 변형(enum variant)](types/enum.md)의 필드들은 선언된 순서대로 드롭됩니다."

#: src/destructors.md:19
msgid "The fields of a [tuple](types/tuple.md) are dropped in order."
msgstr "[튜플(tuple)](types/tuple.md)의 필드들은 순서대로 드롭됩니다."

#: src/destructors.md:20
msgid ""
"The elements of an [array](types/array.md) or owned [slice](types/slice.md) "
"are dropped from the first element to the last."
msgstr "[배열(array)](types/array.md) 또는 소유권이 있는 [슬라이스(slice)](types/slice.md)의 요소들은 첫 번째 요소부터 마지막 요소 순으로 드롭됩니다."

#: src/destructors.md:22
msgid ""
"The variables that a [closure](types/closure.md) captures by move are "
"dropped in an unspecified order."
msgstr "[클로저(closure)](types/closure.md)가 이동(move)으로 캡처한 변수들은 지정되지 않은 순서대로 드롭됩니다."

#: src/destructors.md:24
msgid ""
"[Trait objects](types/trait-object.md) run the destructor of the underlying "
"type."
msgstr "[트레잇 객체(Trait objects)](types/trait-object.md)는 기저 타입(underlying type)의 소멸자를 실행합니다."

#: src/destructors.md:25
msgid "Other types don't result in any further drops."
msgstr "다른 타입들은 추가적인 드롭을 발생시키지 않습니다."

#: src/destructors.md:29
msgid ""
"If a destructor must be run manually, such as when implementing your own "
"smart pointer, [`std::ptr::drop_in_place`](../core/ptr/"
"fn.drop_in_place.html) can be used."
msgstr "자신만의 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야 하는 경우, [`std::ptr::drop_in_place`](../core/ptr/fn.drop_in_place.html)를 사용할 수 있습니다."

#: src/destructors.md:32 src/destructors.md:255
msgid "Some examples:"
msgstr "몇 가지 예제:"

#: src/destructors.md:43
msgid "\"drops when overwritten\""
msgstr "\"덮어써질 때 드롭됨\""

#: src/destructors.md:44
msgid "\"drops when scope ends\""
msgstr "\"스코프가 끝날 때 드롭됨\""

#: src/destructors.md:46
msgid "\"Tuple first\""
msgstr "\"튜플 첫 번째\""

#: src/destructors.md:46
msgid "\"Tuple second\""
msgstr "\"튜플 두 번째\""

#: src/destructors.md:48
msgid "// No destructor run on assignment.\n"
msgstr "// 할당 시 소멸자가 실행되지 않음.\n"

#: src/destructors.md:50
msgid "\"Drops when moved\""
msgstr "\"이동될 때 드롭됨\""

#: src/destructors.md:50
msgid "// Drops now, but is then uninitialized.\n"
msgstr "// 지금 드롭되지만, 그 후에는 초기화되지 않은 상태가 됩니다.\n"

#: src/destructors.md:53
msgid "// Uninitialized does not drop.\n"
msgstr "// 초기화되지 않은 상태에서는 드롭되지 않습니다.\n"

#: src/destructors.md:56
msgid "// After a partial move, only the remaining fields are dropped.\n"
msgstr "// 부분 이동 후에는 남아 있는 필드만 드롭됩니다.\n"

#: src/destructors.md:58
msgid "\"forgotten\""
msgstr "\"잊힘(forgotten)\""

#: src/destructors.md:58
msgid "// Perform a partial move, leaving only `partial_move.0` initialized.\n"
msgstr "// 부분 이동을 수행하여 `partial_move.0`만 초기화된 상태로 남깁니다.\n"

#: src/destructors.md:60
msgid "// When partial_move's scope ends, only the first field is dropped.\n"
msgstr "// partial_move의 스코프가 끝나면 첫 번째 필드만 드롭됩니다.\n"

#: src/destructors.md:66
msgid "Drop scopes"
msgstr "드롭 스코프"

#: src/destructors.md:70
msgid ""
"Each variable or temporary is associated to a _drop scope_. When control "
"flow leaves a drop scope all variables associated to that scope are dropped "
"in reverse order of declaration (for variables) or creation (for "
"temporaries)."
msgstr ""
"각 변수나 임시 값은 _드롭 스코프(drop scope)_와 연관됩니다. 제어 흐름이 드롭 스코프를 벗어나면 해당 스코프와 연관된 모든 변수는 선언된 역순으로, 임시 값은 생성된 역순으로 드롭됩니다."

#: src/destructors.md:76
msgid ""
"Drop scopes are determined after replacing [`for`](expressions/loop-"
"expr.md#iterator-loops), [`if let`](expressions/if-expr.md#if-let-"
"expressions), and [`while let`](expressions/loop-expr.md#predicate-pattern-"
"loops) expressions with the equivalent expressions using [`match`]"
"(expressions/match-expr.md)."
msgstr ""
"드롭 스코프는 [`for`](expressions/loop-expr.md#iterator-loops), [`if let`](expressions/if-expr.md#if-let-expressions), [`while let`](expressions/loop-expr.md#predicate-pattern-loops) 표현식을 [`match`](expressions/match-expr.md)를 사용한 등가의 표현식으로 대체한 후에 결정됩니다."

#: src/destructors.md:81
msgid ""
"Overloaded operators are not distinguished from built-in operators and "
"[binding modes](patterns.md#binding-modes) are not considered."
msgstr ""
"오버로드된 연산자는 내장 연산자와 구별되지 않으며, [바인딩 모드(binding modes)](patterns.md#binding-modes)는 고려되지 않습니다."

#: src/destructors.md:86
msgid "Given a function, or closure, there are drop scopes for:"
msgstr "함수 또는 클로저가 주어지면, 다음과 같은 것들에 대한 드롭 스코프가 존재합니다."

#: src/destructors.md:90
msgid "The entire function"
msgstr "함수 전체"

#: src/destructors.md:94
msgid "Each [statement](statements.md)"
msgstr "각 [구문(statement)](statements.md)"

#: src/destructors.md:98
msgid "Each [expression](expressions.md)"
msgstr "각 [표현식(expression)](expressions.md)"

#: src/destructors.md:102
msgid "Each block, including the function body"
msgstr "함수 본문을 포함한 각 블록"

#: src/destructors.md:103
msgid ""
"In the case of a [block expression](expressions/block-expr.md), the scope "
"for the block and the expression are the same scope."
msgstr "[블록 표현식(block expression)](expressions/block-expr.md)의 경우, 블록의 스코프와 표현식의 스코프는 동일합니다."

#: src/destructors.md:108
msgid "Each arm of a `match` expression"
msgstr "`match` 표현식의 각 암(arm)"

#: src/destructors.md:112
msgid ""
"Drop scopes are nested within one another as follows. When multiple scopes "
"are left at once, such as when returning from a function, variables are "
"dropped from the inside outwards."
msgstr ""
"드롭 스코프들은 다음과 같이 서로 중첩됩니다. 함수에서 반환될 때와 같이 여러 스코프를 한꺼번에 벗어날 때, 변수들은 안쪽에서 바깥쪽 순서로 드롭됩니다."

#: src/destructors.md:118
msgid "The entire function scope is the outer most scope."
msgstr "함수 전체 스코프가 최외곽 스코프입니다."

#: src/destructors.md:122
msgid ""
"The function body block is contained within the scope of the entire function."
msgstr "함수 본문 블록은 함수 전체 스코프 내에 포함됩니다."

#: src/destructors.md:126
msgid ""
"The parent of the expression in an expression statement is the scope of the "
"statement."
msgstr "표현식 구문 내 표현식의 부모는 해당 구문의 스코프입니다."

#: src/destructors.md:131
msgid ""
"The parent of the initializer of a [`let` statement](statements.md#let-"
"statements) is the `let` statement's scope."
msgstr "[`let` 구문(let statement)](statements.md#let-statements)의 초기화식의 부모는 해당 `let` 구문의 스코프입니다."

#: src/destructors.md:136
msgid ""
"The parent of a statement scope is the scope of the block that contains the "
"statement."
msgstr "구문 스코프의 부모는 해당 구문을 포함하는 블록의 스코프입니다."

#: src/destructors.md:141
msgid ""
"The parent of the expression for a `match` guard is the scope of the arm "
"that the guard is for."
msgstr "`match` 가드(guard) 표현식의 부모는 해당 가드가 속한 매치 암의 스코프입니다."

#: src/destructors.md:146
msgid ""
"The parent of the expression after the `=>` in a `match` expression is the "
"scope of the arm that it's in."
msgstr "`match` 표현식에서 `=>` 뒤에 오는 표현식의 부모는 그것이 속한 매치 암의 스코프입니다."

#: src/destructors.md:151
msgid ""
"The parent of the arm scope is the scope of the `match` expression that it "
"belongs to."
msgstr "매치 암 스코프의 부모는 그것이 속한 `match` 표현식의 스코프입니다."

#: src/destructors.md:156
msgid ""
"The parent of all other scopes is the scope of the immediately enclosing "
"expression."
msgstr "그 외 모든 스코프의 부모는 그것을 직접 감싸고 있는 표현식의 스코프입니다."

#: src/destructors.md:161
msgid "Scopes of function parameters"
msgstr "함수 매개변수의 스코프"

#: src/destructors.md:164
msgid ""
"All function parameters are in the scope of the entire function body, so are "
"dropped last when evaluating the function. Each actual function parameter is "
"dropped after any bindings introduced in that parameter's pattern."
msgstr ""
"모든 함수 매개변수는 함수 본문 전체의 스코프에 속하므로, 함수가 평가될 때 가장 마지막에 드롭됩니다. 각 실제 함수 매개변수는 해당 매개변수의 패턴에서 도입된 모든 바인딩이 드롭된 후에 드롭됩니다."

#: src/destructors.md:172 src/destructors.md:203 src/destructors.md:261
#: src/destructors.md:315
msgid "\"drop({})\""
msgstr "\"드롭({})\""

#: src/destructors.md:174
msgid ""
"// Drops `y`, then the second parameter, then `x`, then the first parameter\n"
msgstr ""
"// `y`가 드롭되고, 그다음 두 번째 매개변수, 그다음 `x`, 그다음 첫 번째 매개변수 순으로 드롭됩니다.\n"

#: src/destructors.md:180
msgid "// drop order is 3 2 0 1\n"
msgstr "// 드롭 순서는 3 2 0 1입니다.\n"

#: src/destructors.md:183 src/paths.md:41
msgid "\"0\""
msgstr "\"0\""

#: src/destructors.md:184
msgid "\"2\""
msgstr "\"2\""

#: src/destructors.md:184
msgid "\"3\""
msgstr "\"3\""

#: src/destructors.md:190
msgid "Scopes of local variables"
msgstr "지역 변수의 스코프"

#: src/destructors.md:194
msgid ""
"Local variables declared in a `let` statement are associated to the scope of "
"the block that contains the `let` statement. Local variables declared in a "
"`match` expression are associated to the arm scope of the `match` arm that "
"they are declared in."
msgstr ""
"`let` 구문에서 선언된 지역 변수는 해당 `let` 구문을 포함하는 블록의 스코프와 연관됩니다. `match` 표현식에서 선언된 지역 변수는 그것이 선언된 `match` 암의 암 스코프와 연관됩니다."

#: src/destructors.md:206
msgid "\"Dropped last in outer scope\""
msgstr "\"바깥쪽 스코프에서 마지막에 드롭됨\""

#: src/destructors.md:208
msgid "\"Dropped in inner scope\""
msgstr "\"안쪽 스코프에서 드롭됨\""

#: src/destructors.md:210
msgid "\"Dropped first in outer scope\""
msgstr "\"바깥쪽 스코프에서 먼저 드롭됨\""

#: src/destructors.md:215
msgid ""
"If multiple patterns are used in the same arm for a `match` expression, then "
"an unspecified pattern will be used to determine the drop order."
msgstr "`match` 표현식의 동일한 암(arm)에서 여러 패턴이 사용되는 경우, 지정되지 않은 패턴 중 하나가 드롭 순서를 결정하는 데 사용됩니다."

#: src/destructors.md:220
msgid "Temporary scopes"
msgstr "임시 스코프"

#: src/destructors.md:224
msgid ""
"The _temporary scope_ of an expression is the scope that is used for the "
"temporary variable that holds the result of that expression when used in a "
"[place context](expressions.md#place-expressions-and-value-expressions), "
"unless it is [promoted](destructors.md#constant-promotion)."
msgstr ""
"어떤 표현식의 _임시 스코프(temporary scope)_는 해당 표현식이 [장소 컨텍스트(place context)](expressions.md#place-expressions-and-value-expressions)에서 사용될 때 그 결과를 보관하는 임시 변수에 사용되는 스코프입니다. 다만 해당 표현식이 [승격(promoted)](destructors.md#constant-promotion)된 경우는 제외합니다."

#: src/destructors.md:230
msgid ""
"Apart from lifetime extension, the temporary scope of an expression is the "
"smallest scope that contains the expression and is one of the following:"
msgstr "라이프타임 확장을 제외하면, 표현식의 임시 스코프는 해당 표현식을 포함하는 가장 작은 스코프이며 다음 중 하나입니다."

#: src/destructors.md:233
msgid "The entire function."
msgstr "함수 전체."

#: src/destructors.md:234
msgid "A statement."
msgstr "구문(statement)."

#: src/destructors.md:235
msgid ""
"The body of an [`if`](expressions/if-expr.md#if-expressions), [`while`]"
"(expressions/loop-expr.md#predicate-loops) or [`loop`](expressions/loop-"
"expr.md#infinite-loops) expression."
msgstr "[`if`](expressions/if-expr.md#if-expressions), [`while`](expressions/loop-expr.md#predicate-loops) 또는 [`loop`](expressions/loop-expr.md#infinite-loops) 표현식의 본문."

#: src/destructors.md:236
msgid "The `else` block of an `if` expression."
msgstr "`if` 표현식의 `else` 블록."

#: src/destructors.md:237
msgid ""
"The condition expression of an `if` or `while` expression, or a `match` "
"guard."
msgstr "`if` 또는 `while` 표현식의 조건식, 혹은 `match` 가드(guard)."

#: src/destructors.md:239
msgid "The body expression for a match arm."
msgstr "매치 암의 본문 표현식."

#: src/destructors.md:240
msgid ""
"Each operand of a [lazy boolean expression](expressions/operator-"
"expr.md#lazy-boolean-operators)."
msgstr "[지연 불리언 표현식(lazy boolean expression)](expressions/operator-expr.md#lazy-boolean-operators)의 각 피연산자."

#: src/destructors.md:241
msgid ""
"The pattern-matching condition and consequent body of [`if let`](expressions/"
"if-expr.md#if-let-expressions) ([destructors.scope.temporary.edition2024]"
"(destructors.md#r-destructors.scope.temporary.edition2024))."
msgstr "[`if let`](expressions/if-expr.md#if-let-expressions)의 패턴 매칭 조건과 그에 따른 본문 ([destructors.scope.temporary.edition2024](destructors.md#r-destructors.scope.temporary.edition2024))."

#: src/destructors.md:242
msgid ""
"The entirety of the tail expression of a block "
"([destructors.scope.temporary.edition2024](destructors.md#r-"
"destructors.scope.temporary.edition2024))."
msgstr "블록 꼬리 표현식(tail expression)의 전체 ([destructors.scope.temporary.edition2024](destructors.md#r-destructors.scope.temporary.edition2024))."

#: src/destructors.md:244 src/inline-assembly.md:574 src/inline-assembly.md:879
msgid "**Notes**:"
msgstr "**참고**:"

#: src/destructors.md:246
msgid ""
"The [scrutinee](glossary.md#scrutinee) of a `match` expression is not a "
"temporary scope, so temporaries in the scrutinee can be dropped after the "
"`match` expression. For example, the temporary for `1` in `match 1 { ref mut "
"z => z };` lives until the end of the statement."
msgstr "`match` 표현식의 [스크루티니(scrutinee)](glossary.md#scrutinee)는 임시 스코프가 아니므로, 스크루티니 내의 임시 값들은 `match` 표현식 이후에 드롭될 수 있습니다. 예를 들어, `match 1 { ref mut z => z };`에서 `1`을 위한 임시 값은 구문이 끝날 때까지 유지됩니다."

#: src/destructors.md:253
msgid ""
"**Edition differences**: The 2024 edition added two new temporary scope "
"narrowing rules: `if let` temporaries are dropped before the `else` block, "
"and temporaries of tail expressions of blocks are dropped immediately after "
"the tail expression is evaluated."
msgstr "**에디션 차이**: 2024 에디션에는 두 가지 새로운 임시 스코프 축소 규칙이 추가되었습니다. `if let` 임시 값은 `else` 블록 이전에 드롭되며, 블록 꼬리 표현식의 임시 값은 꼬리 표현식이 평가된 직후에 드롭됩니다."

#: src/destructors.md:264
msgid "\"local var\""
msgstr "\"지역 변수\""

#: src/destructors.md:265 src/destructors.md:294
msgid "// Dropped once the condition has been evaluated\n"
msgstr "// 조건이 평가되면 드롭됨\n"

#: src/destructors.md:267
msgid "\"If condition\""
msgstr "\"If 조건\""

#: src/destructors.md:268
msgid "// Dropped at the end of the block\n"
msgstr "// 블록 끝에서 드롭됨\n"

#: src/destructors.md:269
msgid "\"If body\""
msgstr "\"If 본문\""

#: src/destructors.md:274
msgid "\"if let scrutinee\""
msgstr "\"if let 스크루티니\""

#: src/destructors.md:275
msgid "\"if let consequent\""
msgstr "\"if let 결과절\""

#: src/destructors.md:276
msgid "// `if let consequent` dropped here\n"
msgstr "// `if let 결과절`이 여기서 드롭됨\n"

#: src/destructors.md:277
msgid "// `if let scrutinee` is dropped here\n"
msgstr "// `if let 스크루티니`가 여기서 드롭됨\n"

#: src/destructors.md:280
msgid "\"if let else\""
msgstr "\"if let else\""

#: src/destructors.md:281
msgid "// `if let else` dropped here\n"
msgstr "// `if let else`가 여기서 드롭됨\n"

#: src/destructors.md:283
msgid "// Dropped before the first ||\n"
msgstr "// 첫 번째 || 이전에 드롭됨\n"

#: src/destructors.md:285
msgid "\"first operand\""
msgstr "\"첫 번째 피연산자\""

#: src/destructors.md:285 src/destructors.md:287 src/destructors.md:289
#: src/destructors.md:295 src/inline-assembly.md:216 src/inline-assembly.md:410
#: src/inline-assembly.md:454 src/inline-assembly.md:462
#: src/inline-assembly.md:476 src/inline-assembly.md:769
#: src/inline-assembly.md:802 src/inline-assembly.md:1162
#: src/inline-assembly.md:1216 src/inline-assembly.md:1229
#: src/inline-assembly.md:1258
msgid "\"\""
msgstr "\"\""

#: src/destructors.md:285
msgid "// Dropped before the )\n"
msgstr "// ) 이전에 드롭됨\n"

#: src/destructors.md:287
msgid "\"second operand\""
msgstr "\"두 번째 피연산자\""

#: src/destructors.md:287
msgid "// Dropped before the ;\n"
msgstr "// ; 이전에 드롭됨\n"

#: src/destructors.md:289
msgid "\"third operand\""
msgstr "\"세 번째 피연산자\""

#: src/destructors.md:290
msgid ""
"// Scrutinee is dropped at the end of the function, before local variables\n"
"// (because this is the tail expression of the function body block).\n"
msgstr ""
"// 스크루티니는 함수의 끝에서 지역 변수들 이전에 드롭됩니다\n"
"// (이것이 함수 본문 블록의 꼬리 표현식이기 때문입니다).\n"

#: src/destructors.md:293
msgid "\"Matched value in final expression\""
msgstr "\"최종 표현식의 매치된 값\""

#: src/destructors.md:295
msgid "\"guard condition\""
msgstr "\"가드 조건\""

#: src/destructors.md:302
msgid "Operands"
msgstr "피연산자"

#: src/destructors.md:305
msgid ""
"Temporaries are also created to hold the result of operands to an expression "
"while the other operands are evaluated. The temporaries are associated to "
"the scope of the expression with that operand. Since the temporaries are "
"moved from once the expression is evaluated, dropping them has no effect "
"unless one of the operands to an expression breaks out of the expression, "
"returns, or panics."
msgstr ""
"다른 피연산자가 평가되는 동안 표현식의 피연산자 결과를 보관하기 위해 임시 값이 생성되기도 합니다. 이러한 임시 값은 해당 피연산자가 속한 표현식의 스코프와 연관됩니다. 표현식이 평가되면 임시 값으로부터 데이터가 이동하므로, 표현식의 피연산자 중 하나가 표현식을 벗어나거나(break), 반환되거나(return), 패닉(panic)이 발생하지 않는 한 이들을 드롭하는 것은 아무런 효과가 없습니다."

#: src/destructors.md:319
msgid ""
"// Tuple expression doesn't finish evaluating so operands drop in reverse "
"order\n"
msgstr "// 튜플 표현식의 평가가 완료되지 않았으므로 피연산자들이 역순으로 드롭됩니다.\n"

#: src/destructors.md:321
msgid "\"Outer tuple first\""
msgstr "\"바깥쪽 튜플 첫 번째\""

#: src/destructors.md:322
msgid "\"Outer tuple second\""
msgstr "\"바깥쪽 튜플 두 번째\""

#: src/destructors.md:324
msgid "\"Inner tuple first\""
msgstr "\"안쪽 튜플 첫 번째\""

#: src/destructors.md:325
msgid "\"Inner tuple second\""
msgstr "\"안쪽 튜플 두 번째\""

#: src/destructors.md:328
msgid "\"Never created\""
msgstr "\"절대로 생성되지 않음\""

#: src/destructors.md:335
msgid "Constant promotion"
msgstr "상수 승격"

#: src/destructors.md:338
msgid ""
"Promotion of a value expression to a `'static` slot occurs when the "
"expression could be written in a constant and borrowed, and that borrow "
"could be dereferenced where the expression was originally written, without "
"changing the runtime behavior. That is, the promoted expression can be "
"evaluated at compile-time and the resulting value does not contain [interior "
"mutability](interior-mutability.md) or [destructors](destructors.md) (these "
"properties are determined based on the value where possible, e.g. `&None` "
"always has the type `&'static Option<_>`, as it contains nothing disallowed)."
msgstr ""
"값 표현식을 `'static` 슬롯으로 승격시키는 것은, 해당 표현식을 상수로 작성하여 차용할 수 있고, 그 차용을 원래 표현식이 작성된 위치에서 런타임 동작의 변경 없이 역참조할 수 있을 때 발생합니다. 즉, 승격된 표현식은 컴파일 타임에 평가될 수 있어야 하며, 그 결과값은 [내부 가변성(interior mutability)](interior-mutability.md)이나 [소멸자(destructors)](destructors.md)를 포함하지 않아야 합니다 (이러한 속성들은 가능한 경우 값을 기반으로 결정됩니다. 예를 들어, `&None`은 허용되지 않는 것을 아무것도 포함하지 않으므로 항상 `&'static Option<_>` 타입을 가집니다)."

#: src/destructors.md:349
msgid "Temporary lifetime extension"
msgstr "임시 라이프타임 확장"

#: src/destructors.md:352
msgid ""
"**Note**: The exact rules for temporary lifetime extension are subject to "
"change. This is describing the current behavior only."
msgstr "**참고**: 임시 라이프타임 확장의 정확한 규칙은 변경될 수 있습니다. 여기서는 현재의 동작만을 설명합니다."

#: src/destructors.md:357
msgid ""
"The temporary scopes for expressions in `let` statements are sometimes "
"_extended_ to the scope of the block containing the `let` statement. This is "
"done when the usual temporary scope would be too small, based on certain "
"syntactic rules. For example:"
msgstr "`let` 구문의 표현식에 대한 임시 스코프는 때때로 `let` 구문을 포함하는 블록의 스코프로 _확장(extended)_되기도 합니다. 이는 특정한 구문 규칙에 따라 일반적인 임시 스코프가 너무 작을 때 수행됩니다. 예를 들어:"

#: src/destructors.md:363
msgid ""
"// Usually a temporary would be dropped by now, but the temporary for `0` "
"lives\n"
"// to the end of the block.\n"
msgstr "// 보통이라면 임시 값은 지금쯤 드롭되었겠지만, `0`을 위한 임시 값은 블록 끝까지 유지됩니다.\n"

#: src/destructors.md:371
msgid ""
"Lifetime extension also applies to `static` and `const` items, where it "
"makes temporaries live until the end of the program. For example:"
msgstr "라이프타임 확장은 `static` 및 `const` 아이템에도 적용되어, 임시 값이 프로그램이 종료될 때까지 유지되게 합니다. 예를 들어:"

#: src/destructors.md:375
msgid ""
"// Usually this would be a dangling reference as the `Vec` would only\n"
"// exist inside the initializer expression of `C`, but instead the\n"
"// borrow gets lifetime-extended so it effectively has `'static` lifetime.\n"
msgstr ""
"// 보통이라면 `Vec`은 `C`의 초기화식 내부에만 존재하므로 이는 댕글링 참조(dangling reference)가 되겠지만,\n"
"// 대신 차용(borrow)이 라이프타임 확장되어 사실상 `'static` 라이프타임을 갖게 됩니다.\n"

#: src/destructors.md:384
msgid ""
"If a [borrow](expressions/operator-expr.md#borrow-operators), [dereference]"
"(expressions/operator-expr.md#the-dereference-operator), [field](expressions/"
"field-expr.md), or [tuple indexing expression](expressions/tuple-"
"expr.md#tuple-indexing-expressions) has an extended temporary scope then so "
"does its operand. If an [indexing expression](expressions/array-"
"expr.md#array-and-slice-indexing-expressions) has an extended temporary "
"scope then the indexed expression also has an extended temporary scope."
msgstr ""
"[차용(borrow)](expressions/operator-expr.md#borrow-operators), [역참조(dereference)](expressions/operator-expr.md#the-dereference-operator), [필드(field)](expressions/field-expr.md), 또는 [튜플 인덱싱 표현식(tuple indexing expression)](expressions/tuple-expr.md#tuple-indexing-expressions)이 연장된 임시 스코프를 갖는다면 그 피연산자도 마찬가지입니다. 만약 [인덱싱 표현식(indexing expression)](expressions/array-expr.md#array-and-slice-indexing-expressions)이 연장된 임시 스코프를 갖는다면 인덱싱되는 표현식도 연장된 임시 스코프를 갖습니다."

#: src/destructors.md:392
msgid "Extending based on patterns"
msgstr "패턴에 기반한 연장"

#: src/destructors.md:396
msgid "An _extending pattern_ is either"
msgstr "_연장 패턴(extending pattern)_은 다음 중 하나입니다."

#: src/destructors.md:398
msgid ""
"An [identifier pattern](patterns.md#identifier-patterns) that binds by "
"reference or mutable reference."
msgstr "참조 또는 가변 참조로 바인딩하는 [식별자 패턴(identifier pattern)](patterns.md#identifier-patterns)."

#: src/destructors.md:399
msgid ""
"A [struct](patterns.md#struct-patterns), [tuple](patterns.md#tuple-"
"patterns), [tuple struct](patterns.md#tuple-struct-patterns), or [slice]"
"(patterns.md#slice-patterns) pattern where at least one of the direct "
"subpatterns is an extending pattern."
msgstr "직접적인 하위 패턴 중 적어도 하나가 연장 패턴인 [구조체(struct)](patterns.md#struct-patterns), [튜플(tuple)](patterns.md#tuple-patterns), [튜플 구조체(tuple struct)](patterns.md#tuple-struct-patterns), 또는 [슬라이스(slice)](patterns.md#slice-patterns) 패턴."

#: src/destructors.md:403
msgid ""
"So `ref x`, `V(ref x)` and `[ref x, y]` are all extending patterns, but `x`, "
"`&ref x` and `&(ref x,)` are not."
msgstr "따라서 `ref x`, `V(ref x)`, `[ref x, y]`는 모두 연장 패턴이지만, `x`, `&ref x`, `&(ref x,)`는 그렇지 않습니다."

#: src/destructors.md:408
msgid ""
"If the pattern in a `let` statement is an extending pattern then the "
"temporary scope of the initializer expression is extended."
msgstr "`let` 구문의 패턴이 연장 패턴이면 초기화식 표현식의 임시 스코프가 연장됩니다."

#: src/destructors.md:413
msgid "Extending based on expressions"
msgstr "표현식에 기반한 연장"

#: src/destructors.md:416
msgid ""
"For a let statement with an initializer, an _extending expression_ is an "
"expression which is one of the following:"
msgstr "초기화식이 있는 let 구문의 경우, _연장 표현식(extending expression)_은 다음 중 하나인 표현식입니다."

#: src/destructors.md:419
msgid "The initializer expression."
msgstr "초기화식 표현식."

#: src/destructors.md:420
msgid ""
"The operand of an extending [borrow expression](expressions/operator-"
"expr.md#borrow-operators)."
msgstr "연장 [차용 표현식(borrow expression)](expressions/operator-expr.md#borrow-operators)의 피연산자."

#: src/destructors.md:421
msgid ""
"The operand(s) of an extending [array](expressions/array-expr.md#array-"
"expressions), [cast](expressions/operator-expr.md#type-cast-expressions), "
"[braced struct](expressions/struct-expr.md), or [tuple](expressions/tuple-"
"expr.md#tuple-expressions) expression."
msgstr "연장 [배열(array)](expressions/array-expr.md#array-expressions), [캐스트(cast)](expressions/operator-expr.md#type-cast-expressions), [중괄호 구조체(braced struct)](expressions/struct-expr.md), 또는 [튜플(tuple)](expressions/tuple-expressions) 표현식의 피연산자(들)."

#: src/destructors.md:424
msgid ""
"The final expression of any extending [block expression](expressions/block-"
"expr.md)."
msgstr "모든 연장 [블록 표현식(block expression)](expressions/block-expr.md)의 최종 표현식."

#: src/destructors.md:426
msgid ""
"So the borrow expressions in `&mut 0`, `(&1, &mut 2)`, and `Some { 0: &mut "
"3 }` are all extending expressions. The borrows in `&0 + &1` and `Some(&mut "
"0)` are not: the latter is syntactically a function call expression."
msgstr "따라서 `&mut 0`, `(&1, &mut 2)`, `Some { 0: &mut 3 }`에 있는 차용 표현식은 모두 연장 표현식입니다. `&0 + &1`과 `Some(&mut 0)`에 있는 차용은 연장 표현식이 아닙니다. 후자는 구문론적으로 함수 호출 표현식이기 때문입니다."

#: src/destructors.md:430
msgid ""
"The operand of any extending borrow expression has its temporary scope "
"extended."
msgstr "모든 연장 차용 표현식의 피연산자는 그 임시 스코프가 연장됩니다."

#: src/destructors.md:435
msgid ""
"Here are some examples where expressions have extended temporary scopes:"
msgstr "다음은 표현식이 연장된 임시 스코프를 갖는 몇 가지 예입니다."

#: src/destructors.md:440
msgid ""
"// The temporary that stores the result of `temp()` lives in the same scope\n"
"// as x in these cases.\n"
msgstr ""
"// 이 경우 `temp()`의 결과를 저장하는 임시 값은\n"
"// x와 동일한 스코프 동안 유지됩니다.\n"

#: src/destructors.md:452
msgid ""
"Here are some examples where expressions don't have extended temporary "
"scopes:"
msgstr "다음은 표현식이 연장된 임시 스코프를 갖지 않는 몇 가지 예입니다."

#: src/destructors.md:457
msgid ""
"// The temporary that stores the result of `temp()` only lives until the\n"
"// end of the let statement in these cases.\n"
msgstr ""
"// 이 경우 `temp()`의 결과를 저장하는 임시 값은\n"
"// let 구문이 끝날 때까지만 유지됩니다.\n"

#: src/destructors.md:468
msgid "Not running destructors"
msgstr "소멸자를 실행하지 않는 경우"

#: src/destructors.md:471
msgid ""
"[`std::mem::forget`](../core/mem/fn.forget.html) can be used to prevent the "
"destructor of a variable from being run, and [`std::mem::ManuallyDrop`](../"
"core/mem/manually_drop/struct.ManuallyDrop.html) provides a wrapper to "
"prevent a variable or field from being dropped automatically."
msgstr "[`std::mem::forget`](../core/mem/fn.forget.html)은 변수의 소멸자가 실행되는 것을 방지하기 위해 사용될 수 있으며, [`std::mem::ManuallyDrop`](../core/mem/manually_drop/struct.ManuallyDrop.html)은 변수나 필드가 자동으로 드롭되는 것을 방지하는 래퍼를 제공합니다."

#: src/destructors.md:475
msgid ""
"Note: Preventing a destructor from being run via [`std::mem::forget`](../"
"core/mem/fn.forget.html) or other means is safe even if it has a type that "
"isn't `'static`. Besides the places where destructors are guaranteed to run "
"as defined by this document, types may _not_ safely rely on a destructor "
"being run for soundness."
msgstr "참고: [`std::mem::forget`](../core/mem/fn.forget.html) 또는 다른 수단을 통해 소멸자가 실행되는 것을 방지하는 것은 해당 타입이 `'static`이 아니더라도 안전합니다. 이 문서에서 정의된 소멸자 실행이 보장되는 장소들 외에, 타입들은 건전성(soundness)을 위해 소멸자가 실행되는 것에 안전하게 의존할 수 _없을_ 수도 있습니다."

#: src/lifetime-elision.md:5
msgid ""
"Rust has rules that allow lifetimes to be elided in various places where the "
"compiler can infer a sensible default choice."
msgstr "러스트에는 컴파일러가 합리적인 기본 선택을 추론할 수 있는 다양한 위치에서 라이프타임을 생략할 수 있게 해주는 규칙들이 있습니다."

#: src/lifetime-elision.md:10
msgid "Lifetime elision in functions"
msgstr "함수에서의 라이프타임 생략"

#: src/lifetime-elision.md:14
msgid ""
"In order to make common patterns more ergonomic, lifetime arguments can be "
"_elided_ in [function item](types/function-item.md), [function pointer]"
"(types/function-pointer.md), and [closure trait](types/closure.md) "
"signatures. The following rules are used to infer lifetime parameters for "
"elided lifetimes."
msgstr "일반적인 패턴을 더 인체공학적으로 만들기 위해, [함수 아이템(function item)](types/function-item.md), [함수 포인터(function pointer)](types/function-pointer.md), [클로저 트레잇(closure trait)](types/closure.md) 시그니처에서 라이프타임 인자가 _생략(elided)_될 수 있습니다. 생략된 라이프타임에 대한 라이프타임 파라미터를 추론하기 위해 다음 규칙들이 사용됩니다."

#: src/lifetime-elision.md:20
msgid "It is an error to elide lifetime parameters that cannot be inferred."
msgstr "추론할 수 없는 라이프타임 파라미터를 생략하는 것은 오류입니다."

#: src/lifetime-elision.md:24
msgid ""
"The placeholder lifetime, `'_`, can also be used to have a lifetime inferred "
"in the same way. For lifetimes in paths, using `'_` is preferred."
msgstr "플레이스홀더 라이프타임인 `'_`도 동일한 방식으로 라이프타임을 추론하도록 하기 위해 사용될 수 있습니다. 경로에서의 라이프타임에 대해서는 `'_`를 사용하는 것이 선호됩니다."

#: src/lifetime-elision.md:29
msgid ""
"Trait object lifetimes follow different rules discussed [below](#default-"
"trait-object-lifetimes)."
msgstr "트레잇 객체 라이프타임은 [아래](#default-trait-object-lifetimes)에서 논의될 다른 규칙을 따릅니다."

#: src/lifetime-elision.md:34
msgid ""
"Each elided lifetime in the parameters becomes a distinct lifetime parameter."
msgstr "파라미터에서 생략된 각 라이프타임은 별개의 라이프타임 파라미터가 됩니다."

#: src/lifetime-elision.md:38
msgid ""
"If there is exactly one lifetime used in the parameters (elided or not), "
"that lifetime is assigned to _all_ elided output lifetimes."
msgstr "파라미터에서 사용된 라이프타임(생략되었든 아니든)이 정확히 하나라면, 그 라이프타임이 _모든_ 생략된 출력 라이프타임에 할당됩니다."

#: src/lifetime-elision.md:43
msgid "In method signatures there is another rule"
msgstr "메서드 시그니처에는 또 다른 규칙이 있습니다"

#: src/lifetime-elision.md:45
msgid ""
"If the receiver has type `&Self`  or `&mut Self`, then the lifetime of that "
"reference to `Self` is assigned to all elided output lifetime parameters."
msgstr "리시버(receiver)가 `&Self` 또는 `&mut Self` 타입을 가지면, 그 `Self`에 대한 참조의 라이프타임이 모든 생략된 출력 라이프타임 파라미터에 할당됩니다."

#: src/lifetime-elision.md:57 src/lifetime-elision.md:61
#: src/lifetime-elision.md:64 src/lifetime-elision.md:67
#: src/lifetime-elision.md:70 src/lifetime-elision.md:73
#: src/lifetime-elision.md:77 src/lifetime-elision.md:81
#: src/lifetime-elision.md:84
msgid "// elided\n"
msgstr "// 생략됨\n"

#: src/lifetime-elision.md:58
msgid "// also elided\n"
msgstr "// 역시 생략됨\n"

#: src/lifetime-elision.md:59 src/lifetime-elision.md:62
#: src/lifetime-elision.md:65 src/lifetime-elision.md:68
#: src/lifetime-elision.md:71 src/lifetime-elision.md:74
#: src/lifetime-elision.md:78 src/lifetime-elision.md:82
#: src/lifetime-elision.md:85
msgid "// expanded\n"
msgstr "// 확장됨\n"

#: src/lifetime-elision.md:76
msgid "// elided - preferred\n"
msgstr "// 생략됨 - 선호됨\n"

#: src/lifetime-elision.md:89
msgid ""
"// The following examples show situations where it is not allowed to elide "
"the\n"
"// lifetime parameter.\n"
msgstr "// 다음 예제들은 라이프타임 파라미터를 생략할 수 없는 상황들을 보여줍니다.\n"

#: src/lifetime-elision.md:92
msgid "// Cannot infer, because there are no parameters to infer from.\n"
msgstr "// 추론할 수 있는 파라미터가 없기 때문에 추론할 수 없습니다.\n"

#: src/lifetime-elision.md:94 src/lifetime-elision.md:97
msgid "// ILLEGAL\n"
msgstr "// 허용되지 않음\n"

#: src/lifetime-elision.md:95
msgid ""
"// Cannot infer, ambiguous if it is borrowed from the first or second "
"parameter.\n"
msgstr "// 첫 번째 파라미터에서 차용된 것인지 두 번째 파라미터에서 차용된 것인지 모호하기 때문에 추론할 수 없습니다.\n"

#: src/lifetime-elision.md:103
msgid "Default trait object lifetimes"
msgstr "기본 트레잇 객체 라이프타임"

#: src/lifetime-elision.md:107
msgid ""
"The assumed lifetime of references held by a [trait object](types/trait-"
"object.md) is called its _default object lifetime bound_. These were defined "
"in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-"
"object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/"
"blob/master/text/1156-adjust-default-object-bounds.md)."
msgstr "[트레잇 객체(trait object)](types/trait-object.md)가 보유한 참조의 추정 라이프타임을 _기본 객체 라이프타임 바운드(default object lifetime bound)_라고 합니다. 이들은 [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md)에서 정의되었고 [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md)에서 개정되었습니다."

#: src/lifetime-elision.md:113
msgid ""
"These default object lifetime bounds are used instead of the lifetime "
"parameter elision rules defined above when the lifetime bound is omitted "
"entirely."
msgstr "이러한 기본 객체 라이프타임 바운드는 라이프타임 바운드가 완전히 생략되었을 때 위에서 정의된 라이프타임 파라미터 생략 규칙 대신 사용됩니다."

#: src/lifetime-elision.md:118
msgid ""
"If `'_` is used as the lifetime bound then the bound follows the usual "
"elision rules."
msgstr "`'_`가 라이프타임 바운드로 사용되면 해당 바운드는 일반적인 생략 규칙을 따릅니다."

#: src/lifetime-elision.md:123
msgid ""
"If the trait object is used as a type argument of a generic type then the "
"containing type is first used to try to infer a bound."
msgstr "트레잇 객체가 제네릭 타입의 타입 인자로 사용되면, 먼저 이를 포함하는 타입을 사용하여 바운드를 추론하려고 시도합니다."

#: src/lifetime-elision.md:128
msgid ""
"If there is a unique bound from the containing type then that is the default"
msgstr "포함하는 타입으로부터 유일한 바운드가 있다면 그것이 기본값이 됩니다."

#: src/lifetime-elision.md:132
msgid ""
"If there is more than one bound from the containing type then an explicit "
"bound must be specified"
msgstr "포함하는 타입으로부터 둘 이상의 바운드가 있다면 명시적인 바운드를 지정해야 합니다."

#: src/lifetime-elision.md:137
msgid "If neither of those rules apply, then the bounds on the trait are used:"
msgstr "두 규칙 모두 적용되지 않는 경우, 트레잇에 지정된 바운드가 사용됩니다."

#: src/lifetime-elision.md:141
msgid ""
"If the trait is defined with a single lifetime _bound_ then that bound is "
"used."
msgstr "트레잇이 단일 라이프타임 _바운드_와 함께 정의되었다면 그 바운드가 사용됩니다."

#: src/lifetime-elision.md:146
msgid "If `'static` is used for any lifetime bound then `'static` is used."
msgstr "어떤 라이프타임 바운드에라도 `'static`이 사용되었다면 `'static`이 사용됩니다."

#: src/lifetime-elision.md:150
msgid ""
"If the trait has no lifetime bounds, then the lifetime is inferred in "
"expressions and is `'static` outside of expressions."
msgstr "트레잇에 라이프타임 바운드가 없다면, 라이프타임은 표현식 내에서는 추론되고 표현식 외부에서는 `'static`이 됩니다."

#: src/lifetime-elision.md:154 src/lifetime-elision.md:193
msgid "// For the following trait...\n"
msgstr "// 다음 트레잇에 대하여...\n"

#: src/lifetime-elision.md:156
msgid "// These two are the same because Box<T> has no lifetime bound on T\n"
msgstr "// Box<T>는 T에 대한 라이프타임 바운드가 없으므로 이 둘은 동일합니다.\n"

#: src/lifetime-elision.md:160 src/lifetime-elision.md:199
msgid "// ...and so are these:\n"
msgstr "// ...그리고 다음의 경우들도 그렇습니다:\n"

#: src/lifetime-elision.md:164
msgid "// ...so are these, because &'a T requires T: 'a\n"
msgstr "// ...&'a T가 T: 'a를 요구하므로 다음의 경우들도 그렇습니다:\n"

#: src/lifetime-elision.md:168
msgid "// std::cell::Ref<'a, T> also requires T: 'a, so these are the same\n"
msgstr "// std::cell::Ref<'a, T> 역시 T: 'a를 요구하므로 이들은 동일합니다.\n"

#: src/lifetime-elision.md:175
msgid "// This is an example of an error.\n"
msgstr "// 이는 오류의 한 예입니다.\n"

#: src/lifetime-elision.md:182
msgid ""
"//                                  ^^^^^^^\n"
"// Error: the lifetime bound for this object type cannot be deduced from "
"context\n"
msgstr ""
"//                                  ^^^^^^^\n"
"// 오류: 이 객체 타입에 대한 라이프타임 바운드를 문맥으로부터 추론할 수 없습니다.\n"

#: src/lifetime-elision.md:189
msgid ""
"Note that the innermost object sets the bound, so `&'a Box<dyn Foo>` is "
"still `&'a Box<dyn Foo + 'static>`."
msgstr "가장 안쪽의 객체가 바운드를 설정하므로, `&'a Box<dyn Foo>`는 여전히 `&'a Box<dyn Foo + 'static>`임에 유의하세요."

#: src/lifetime-elision.md:195
msgid "// ...these two are the same:\n"
msgstr "// ...이 둘은 동일합니다:\n"

#: src/lifetime-elision.md:207
msgid "`const` and `static` elision"
msgstr "`const` 및 `static` 생략"

#: src/lifetime-elision.md:211
msgid ""
"Both [constant](items/constant-items.md) and [static](items/static-items.md) "
"declarations of reference types have _implicit_ `'static` lifetimes unless "
"an explicit lifetime is specified. As such, the constant declarations "
"involving `'static` above may be written without the lifetimes."
msgstr "[상수(constant)](items/constant-items.md) 및 [정적(static)](items/static-items.md) 참조 타입 선언은 명시적인 라이프타임이 지정되지 않는 한 _암시적인_ `'static` 라이프타임을 갖습니다. 따라서 위에서 `'static`을 포함하는 상수 선언들은 라이프타임 없이 작성될 수 있습니다."

#: src/lifetime-elision.md:217
msgid "// STRING: &'static str\n"
msgstr "// STRING: &'static str\n"

#: src/lifetime-elision.md:224
msgid "// BITS_N_STRINGS: BitsNStrings<'static>\n"
msgstr "// BITS_N_STRINGS: BitsNStrings<'static>\n"

#: src/lifetime-elision.md:234
msgid ""
"Note that if the `static` or `const` items include function or closure "
"references, which themselves include references, the compiler will first try "
"the standard elision rules. If it is unable to resolve the lifetimes by its "
"usual rules, then it will error. By way of example:"
msgstr "`static` 또는 `const` 아이템이 함수나 클로저 참조를 포함하고, 그 함수나 클로저가 다시 참조를 포함하는 경우, 컴파일러는 먼저 표준 생략 규칙을 시도합니다. 일반적인 규칙으로 라이프타임을 해결할 수 없다면 오류가 발생합니다. 예를 들어:"

#: src/lifetime-elision.md:243
msgid "// Resolved as `for<'a> fn(&'a str) -> &'a str`.\n"
msgstr "// `for<'a> fn(&'a str) -> &'a str`로 해결됩니다.\n"

#: src/lifetime-elision.md:246
msgid ""
"// Resolved as `for<'a, 'b, 'c> Fn(&'a Foo, &'b Bar, &'c Baz) -> usize`.\n"
msgstr "// `for<'a, 'b, 'c> Fn(&'a Foo, &'b Bar, &'c Baz) -> usize`로 해결됩니다.\n"

#: src/lifetime-elision.md:255
msgid ""
"// There is insufficient information to bound the return reference lifetime\n"
"// relative to the argument lifetimes, so this is an error.\n"
msgstr "// 인자 라이프타임과 관련하여 반환 참조 라이프타임을 제한할 정보가 충분하지 않으므로, 이는 오류입니다.\n"

#: src/lifetime-elision.md:258
msgid ""
"//                                            ^\n"
"// this function's return type contains a borrowed value, but the signature\n"
"// does not say whether it is borrowed from argument 1 or argument 2\n"
msgstr ""
"//                                            ^\n"
"// 이 함수의 반환 타입은 차용된 값을 포함하지만, 시그니처에는 이것이 인자 1에서 차용된 것인지 인자 2에서 차용된 것인지 명시되어 있지 않습니다.\n"

#: src/special-types-and-traits.md:7
msgid ""
"Certain types and traits that exist in [the standard library](../std/"
"index.html) are known to the Rust compiler. This chapter documents the "
"special features of these types and traits."
msgstr "[표준 라이브러리](../std/index.html)에 존재하는 특정 타입과 트레잇은 러스트 컴파일러에게 알려져 있습니다. 이 장에서는 이러한 타입과 트레잇의 특별한 기능들을 문서화합니다."

#: src/special-types-and-traits.md:17
msgid ""
"[`Box<T>`](../alloc/boxed/struct.Box.html) has a few special features that "
"Rust doesn't currently allow for user defined types."
msgstr "[`Box<T>`](../alloc/boxed/struct.Box.html)는 현재 러스트가 사용자 정의 타입에 대해서는 허용하지 않는 몇 가지 특별한 기능을 가지고 있습니다."

#: src/special-types-and-traits.md:22
msgid ""
"The [dereference operator](expressions/operator-expr.md#the-dereference-"
"operator) for `Box<T>` produces a place which can be moved from. This means "
"that the `*` operator and the destructor of `Box<T>` are built-in to the "
"language."
msgstr "`Box<T>`에 대한 [역참조 연산자(dereference operator)](expressions/operator-expr.md#the-dereference-operator)는 데이터를 이동(move)할 수 있는 장소(place)를 생성합니다. 이는 `*` 연산자와 `Box<T>`의 소멸자가 언어 자체에 내장되어 있음을 의미합니다."

#: src/special-types-and-traits.md:28
msgid ""
"[Methods](items/associated-items.md#associated-functions-and-methods) can "
"take `Box<Self>` as a receiver."
msgstr "[메서드(Methods)](items/associated-items.md#associated-functions-and-methods)는 `Box<Self>`를 리시버로 취할 수 있습니다."

#: src/special-types-and-traits.md:32
msgid ""
"A trait may be implemented for `Box<T>` in the same crate as `T`, which the "
"[orphan rules](items/implementations.md#trait-implementation-coherence) "
"prevent for other generic types."
msgstr "[고아 규칙(orphan rules)](items/implementations.md#trait-implementation-coherence)이 다른 제네릭 타입에 대해서는 금지하는 것과 달리, `T`와 동일한 크레이트에서 `Box<T>`에 대해 트레잇을 구현할 수 있습니다."

#: src/special-types-and-traits.md:39
msgid "`Rc<T>`"
msgstr "`Rc<T>`"

#: src/special-types-and-traits.md:43
msgid ""
"[Methods](items/associated-items.md#associated-functions-and-methods) can "
"take [`Rc<Self>`](../alloc/rc/struct.Rc.html) as a receiver."
msgstr "[메서드(Methods)](items/associated-items.md#associated-functions-and-methods)는 [`Rc<Self>`](../alloc/rc/struct.Rc.html)를 리시버로 취할 수 있습니다."

#: src/special-types-and-traits.md:47
msgid "`Arc<T>`"
msgstr "`Arc<T>`"

#: src/special-types-and-traits.md:51
msgid ""
"[Methods](items/associated-items.md#associated-functions-and-methods) can "
"take [`Arc<Self>`](../alloc/sync/struct.Arc.html) as a receiver."
msgstr "[메서드(Methods)](items/associated-items.md#associated-functions-and-methods)는 [`Arc<Self>`](../alloc/sync/struct.Arc.html)를 리시버로 취할 수 있습니다."

#: src/special-types-and-traits.md:55
msgid "`Pin<P>`"
msgstr "`Pin<P>`"

#: src/special-types-and-traits.md:59
msgid ""
"[Methods](items/associated-items.md#associated-functions-and-methods) can "
"take [`Pin<P>`](../core/pin/struct.Pin.html) as a receiver."
msgstr "[메서드(Methods)](items/associated-items.md#associated-functions-and-methods)는 [`Pin<P>`](../core/pin/struct.Pin.html)를 리시버로 취할 수 있습니다."

#: src/special-types-and-traits.md:63
msgid "`UnsafeCell<T>`"
msgstr "`UnsafeCell<T>`"

#: src/special-types-and-traits.md:67
msgid ""
"[`std::cell::UnsafeCell<T>`](../core/cell/struct.UnsafeCell.html) is used "
"for [interior mutability](interior-mutability.md). It ensures that the "
"compiler doesn't perform optimisations that are incorrect for such types."
msgstr "[`std::cell::UnsafeCell<T>`](../core/cell/struct.UnsafeCell.html)는 [내부 가변성(interior mutability)](interior-mutability.md)을 위해 사용됩니다. 이는 컴파일러가 해당 타입들에 대해 부적절한 최적화를 수행하지 않도록 보장합니다."

#: src/special-types-and-traits.md:72
msgid ""
"It also ensures that [`static` items](items/static-items.md) which have a "
"type with interior mutability aren't placed in memory marked as read only."
msgstr "또한 내부 가변성을 가진 타입을 가진 [`static` 아이템](items/static-items.md)이 읽기 전용으로 표시된 메모리에 배치되지 않도록 보장합니다."

#: src/special-types-and-traits.md:77
msgid "`PhantomData<T>`"
msgstr "`PhantomData<T>`"

#: src/special-types-and-traits.md:79
msgid ""
"[`std::marker::PhantomData<T>`](../core/marker/struct.PhantomData.html) is a "
"zero-sized, minimum alignment, type that is considered to own a `T` for the "
"purposes of [variance](subtyping.md#variance), [drop check](../nomicon/"
"dropck.html), and [auto traits](#auto-traits)."
msgstr "[`std::marker::PhantomData<T>`](../core/marker/struct.PhantomData.html)는 크기가 0이고 정렬(alignment)이 최소인 타입으로, [가변성(variance)](subtyping.md#variance), [드롭 검사(drop check)](../nomicon/dropck.html), 그리고 [자동 트레잇(auto traits)](#auto-traits)의 목적을 위해 `T`를 소유하는 것으로 간주됩니다."

#: src/special-types-and-traits.md:85
msgid "Operator Traits"
msgstr "연산자 트레잇"

#: src/special-types-and-traits.md:87
msgid ""
"The traits in [`std::ops`](../core/ops/index.html) and [`std::cmp`](../core/"
"cmp/index.html) are used to overload [operators](expressions/operator-"
"expr.md), [indexing expressions](expressions/array-expr.md#array-and-slice-"
"indexing-expressions), and [call expressions](expressions/call-expr.md)."
msgstr "[`std::ops`](../core/ops/index.html) 및 [`std::cmp`](../core/cmp/index.html)에 있는 트레잇들은 [연산자(operators)](expressions/operator-expr.md), [인덱싱 표현식(indexing expressions)](expressions/array-expr.md#array-and-slice-indexing-expressions), 그리고 [호출 표현식(call expressions)](expressions/call-expr.md)을 오버로드하는 데 사용됩니다."

#: src/special-types-and-traits.md:92
msgid "`Deref` and `DerefMut`"
msgstr "`Deref` 및 `DerefMut`"

#: src/special-types-and-traits.md:94
msgid ""
"As well as overloading the unary `*` operator, [`Deref`](../core/ops/deref/"
"trait.Deref.html) and [`DerefMut`](../core/ops/deref/trait.DerefMut.html) "
"are also used in [method resolution](expressions/method-call-expr.md) and "
"[deref coercions](type-coercions.md#coercion-types)."
msgstr "단항 `*` 연산자를 오버로드하는 것뿐만 아니라, [`Deref`](../core/ops/deref/trait.Deref.html)와 [`DerefMut`](../core/ops/deref/trait.DerefMut.html)는 [메서드 확인(method resolution)](expressions/method-call-expr.md) 및 [deref 강제 변환(deref coercions)](type-coercions.md#coercion-types)에서도 사용됩니다."

#: src/special-types-and-traits.md:99
msgid "`Drop`"
msgstr "`Drop`"

#: src/special-types-and-traits.md:101
msgid ""
"The [`Drop`](../core/ops/drop/trait.Drop.html) trait provides a [destructor]"
"(destructors.md), to be run whenever a value of this type is to be destroyed."
msgstr "[`Drop`](../core/ops/drop/trait.Drop.html) 트레잇은 이 타입의 값이 파괴될 때마다 실행될 [소멸자(destructor)](destructors.md)를 제공합니다."

#: src/special-types-and-traits.md:106
msgid "`Copy`"
msgstr "`Copy`"

#: src/special-types-and-traits.md:110
msgid ""
"The [`Copy`](../core/marker/trait.Copy.html) trait changes the semantics of "
"a type implementing it."
msgstr "[`Copy`](../core/marker/trait.Copy.html) 트레잇은 이를 구현하는 타입의 의미론(semantics)을 변경합니다."

#: src/special-types-and-traits.md:114
msgid ""
"Values whose type implements `Copy` are copied rather than moved upon "
"assignment."
msgstr "`Copy`를 구현하는 타입의 값은 할당 시 이동(move)되지 않고 복사(copy)됩니다."

#: src/special-types-and-traits.md:118
msgid ""
"`Copy` can only be implemented for types which do not implement `Drop`, and "
"whose fields are all `Copy`. For enums, this means all fields of all "
"variants have to be `Copy`. For unions, this means all variants have to be "
"`Copy`."
msgstr "`Copy`는 `Drop`을 구현하지 않고 모든 필드가 `Copy`인 타입에 대해서만 구현될 수 있습니다. 열거형의 경우 모든 변형(variant)의 모든 필드가 `Copy`여야 함을 의미합니다. 공용체(union)의 경우 모든 변형이 `Copy`여야 함을 의미합니다."

#: src/special-types-and-traits.md:124
msgid "`Copy` is implemented by the compiler for"
msgstr "컴파일러는 다음의 경우들에 대해 `Copy`를 구현합니다."

#: src/special-types-and-traits.md:128
msgid "[Tuples](types/tuple.md) of `Copy` types"
msgstr "`Copy` 타입들로 구성된 [튜플(Tuples)](types/tuple.md)"

#: src/special-types-and-traits.md:136
msgid "[Function items](types/function-item.md)"
msgstr "[함수 아이템(Function items)](types/function-item.md)"

#: src/special-types-and-traits.md:140
msgid ""
"[Closures](types/closure.md) that capture no values or that only capture "
"values of `Copy` types"
msgstr "아무 값도 캡처하지 않거나 `Copy` 타입의 값만 캡처하는 [클로저(Closures)](types/closure.md)"

#: src/special-types-and-traits.md:144
msgid "`Clone`"
msgstr "`Clone`"

#: src/special-types-and-traits.md:148
msgid ""
"The [`Clone`](../core/clone/trait.Clone.html) trait is a supertrait of "
"`Copy`, so it also needs compiler generated implementations."
msgstr "[`Clone`](../core/clone/trait.Clone.html) 트레잇은 `Copy`의 상위 트레잇(supertrait)이므로, 역시 컴파일러가 생성한 구현이 필요합니다."

#: src/special-types-and-traits.md:153
msgid "It is implemented by the compiler for the following types:"
msgstr "컴파일러는 다음 타입들에 대해 이를 구현합니다."

#: src/special-types-and-traits.md:157
msgid "Types with a built-in `Copy` implementation (see above)"
msgstr "내장된 `Copy` 구현을 가진 타입 (위 참조)"

#: src/special-types-and-traits.md:161
msgid "[Tuples](types/tuple.md) of `Clone` types"
msgstr "`Clone` 타입들로 구성된 [튜플(Tuples)](types/tuple.md)"

#: src/special-types-and-traits.md:165
msgid ""
"[Closures](types/closure.md) that only capture values of `Clone` types or "
"capture no values from the environment"
msgstr "`Clone` 타입의 값만 캡처하거나 환경에서 아무 값도 캡처하지 않는 [클로저(Closures)](types/closure.md)"

#: src/special-types-and-traits.md:169
msgid "`Send`"
msgstr "`Send`"

#: src/special-types-and-traits.md:171
msgid ""
"The [`Send`](../core/marker/trait.Send.html) trait indicates that a value of "
"this type is safe to send from one thread to another."
msgstr "[`Send`](../core/marker/trait.Send.html) 트레잇은 이 타입의 값이 한 스레드에서 다른 스레드로 안전하게 전달될 수 있음을 나타냅니다."

#: src/special-types-and-traits.md:176
msgid "`Sync`"
msgstr "`Sync`"

#: src/special-types-and-traits.md:180
msgid ""
"The [`Sync`](../core/marker/trait.Sync.html) trait indicates that a value of "
"this type is safe to share between multiple threads."
msgstr "[`Sync`](../core/marker/trait.Sync.html) 트레잇은 이 타입의 값을 여러 스레드 간에 안전하게 공유할 수 있음을 나타냅니다."

#: src/special-types-and-traits.md:185
msgid ""
"This trait must be implemented for all types used in immutable [`static` "
"items](items/static-items.md)."
msgstr "이 트레잇은 불변 [`static` 아이템(static items)](items/static-items.md)에 사용되는 모든 타입에 대해 구현되어야 합니다."

#: src/special-types-and-traits.md:189
msgid "`Termination`"
msgstr "`Termination`"

#: src/special-types-and-traits.md:191
msgid ""
"The [`Termination`](../std/process/trait.Termination.html) trait indicates "
"the acceptable return types for the [main function](crates-and-source-"
"files.md#main-functions) and [test functions](attributes/testing.md#the-test-"
"attribute)."
msgstr "[`Termination`](../std/process/trait.Termination.html) 트레잇은 [메인 함수(main function)](crates-and-source-files.md#main-functions) 및 [테스트 함수(test functions)](attributes/testing.md#the-test-attribute)에서 허용되는 반환 타입들을 나타냅니다."

#: src/special-types-and-traits.md:195
msgid "Auto traits"
msgstr "자동 트레잇(Auto traits)"

#: src/special-types-and-traits.md:197
msgid ""
"The [`Send`](../core/marker/trait.Send.html), [`Sync`](../core/marker/"
"trait.Sync.html), [`Unpin`](../core/marker/trait.Unpin.html), [`UnwindSafe`]"
"(../core/panic/unwind_safe/trait.UnwindSafe.html), and [`RefUnwindSafe`](../"
"core/panic/unwind_safe/trait.RefUnwindSafe.html) traits are _auto traits_. "
"Auto traits have special properties."
msgstr "[`Send`](../core/marker/trait.Send.html), [`Sync`](../core/marker/trait.Sync.html), [`Unpin`](../core/marker/trait.Unpin.html), [`UnwindSafe`](../core/panic/unwind_safe/trait.UnwindSafe.html), 그리고 [`RefUnwindSafe`](../core/panic/unwind_safe/trait.RefUnwindSafe.html) 트레잇은 _자동 트레잇(auto traits)_입니다. 자동 트레잇은 특별한 속성을 가집니다."

#: src/special-types-and-traits.md:202
msgid ""
"If no explicit implementation or negative implementation is written out for "
"an auto trait for a given type, then the compiler implements it "
"automatically according to the following rules:"
msgstr "주어진 타입에 대해 자동 트레잇에 대한 명시적인 구현이나 부정적인 구현(negative implementation)이 작성되어 있지 않다면, 컴파일러는 다음 규칙에 따라 자동으로 이를 구현합니다."

#: src/special-types-and-traits.md:208
msgid ""
"`&T`, `&mut T`, `*const T`, `*mut T`, `[T; n]`, and `[T]` implement the "
"trait if `T` does."
msgstr "`T`가 해당 트레잇을 구현하면 `&T`, `&mut T`, `*const T`, `*mut T`, `[T; n]`, 그리고 `[T]`도 이를 구현합니다."

#: src/special-types-and-traits.md:213
msgid ""
"Function item types and function pointers automatically implement the trait."
msgstr "함수 아이템 타입과 함수 포인터는 자동으로 트레잇을 구현합니다."

#: src/special-types-and-traits.md:217
msgid ""
"Structs, enums, unions, and tuples implement the trait if all of their "
"fields do."
msgstr "구조체, 열거형, 공용체, 그리고 튜플은 모든 필드가 해당 트레잇을 구현하면 이를 구현합니다."

#: src/special-types-and-traits.md:222
msgid ""
"Closures implement the trait if the types of all of their captures do. A "
"closure that captures a `T` by shared reference and a `U` by value "
"implements any auto traits that both `&T` and `U` do."
msgstr "클로저는 캡처한 모든 것의 타입이 해당 트레잇을 구현하면 이를 구현합니다. `T`를 공유 참조로 캡처하고 `U`를 값으로 캡처하는 클로저는 `&T`와 `U`가 모두 구현하는 자동 트레잇들을 구현합니다."

#: src/special-types-and-traits.md:228
msgid ""
"For generic types (counting the built-in types above as generic over `T`), "
"if a generic implementation is available, then the compiler does not "
"automatically implement it for types that could use the implementation "
"except that they do not meet the requisite trait bounds. For instance, the "
"standard library implements `Send` for all `&T` where `T` is `Sync`; this "
"means that the compiler will not implement `Send` for `&T` if `T` is `Send` "
"but not `Sync`."
msgstr "제네릭 타입의 경우 (위의 내장 타입들도 `T`에 대한 제네릭으로 간주함), 제네릭 구현이 가능하다면 컴파일러는 필요한 트레잇 바운드를 충족하지 못해 해당 구현을 사용할 수 없는 타입들에 대해 자동으로 이를 구현하지 않습니다. 예를 들어, 표준 라이브러리는 `T`가 `Sync`인 모든 `&T`에 대해 `Send`를 구현합니다. 이는 `T`가 `Send`이지만 `Sync`가 아닌 경우 컴파일러가 `&T`에 대해 `Send`를 구현하지 않음을 의미합니다."

#: src/special-types-and-traits.md:237
msgid ""
"Auto traits can also have negative implementations, shown as `impl !"
"AutoTrait for T` in the standard library documentation, that override the "
"automatic implementations. For example `*mut T` has a negative "
"implementation of `Send`, and so `*mut T` is not `Send`, even if `T` is. "
"There is currently no stable way to specify additional negative "
"implementations; they exist only in the standard library."
msgstr "자동 트레잇은 또한 부정적인 구현을 가질 수 있으며, 이는 표준 라이브러리 문서에서 `impl !AutoTrait for T`로 표시되어 자동 구현을 재정의(override)합니다. 예를 들어 `*mut T`는 `Send`에 대한 부정적인 구현을 가지고 있으므로, `T`가 `Send`이더라도 `*mut T`는 `Send`가 아닙니다. 현재 추가적인 부정적인 구현을 지정하는 안정적인 방법은 없으며, 표준 라이브러리에만 존재합니다."

#: src/special-types-and-traits.md:246
msgid ""
"Auto traits may be added as an additional bound to any [trait object](types/"
"trait-object.md), even though normally only one trait is allowed. For "
"instance, `Box<dyn Debug + Send + UnwindSafe>` is a valid type."
msgstr "자동 트레잇은 보통 하나의 트레잇만 허용되는 [트레잇 객체(trait object)](types/trait-object.md)에도 추가적인 바운드로 추가될 수 있습니다. 예를 들어, `Box<dyn Debug + Send + UnwindSafe>`는 유효한 타입입니다."

#: src/special-types-and-traits.md:252
msgid "`Sized`"
msgstr "`Sized`"

#: src/special-types-and-traits.md:256
msgid ""
"The [`Sized`](../core/marker/trait.Sized.html) trait indicates that the size "
"of this type is known at compile-time; that is, it's not a [dynamically "
"sized type](dynamically-sized-types.md)."
msgstr "[`Sized`](../core/marker/trait.Sized.html) 트레잇은 이 타입의 크기가 컴파일 타임에 알려져 있음을 나타냅니다. 즉, [동적 크기 타입(dynamically sized type)](dynamically-sized-types.md)이 아님을 의미합니다."

#: src/special-types-and-traits.md:260
msgid ""
"[Type parameters](types/parameters.md) (except `Self` in traits) are `Sized` "
"by default, as are [associated types](items/associated-items.md#associated-"
"types)."
msgstr "[타입 파라미터(Type parameters)](types/parameters.md) (트레잇의 `Self` 제외)와 [연관 타입(associated types)](items/associated-items.md#associated-types)은 기본적으로 `Sized`입니다."

#: src/special-types-and-traits.md:264
msgid ""
"`Sized` is always implemented automatically by the compiler, not by "
"[implementation items](items/implementations.md)."
msgstr "`Sized`는 항상 [구현 아이템(implementation items)](items/implementations.md)이 아니라 컴파일러에 의해 자동으로 구현됩니다."

#: src/special-types-and-traits.md:268
msgid ""
"These implicit `Sized` bounds may be relaxed by using the special `?Sized` "
"bound."
msgstr "이러한 암시적인 `Sized` 바운드는 특별한 `?Sized` 바운드를 사용하여 완화될 수 있습니다."

#: src/names.md:7
msgid ""
"An _entity_ is a language construct that can be referred to in some way "
"within the source program, usually via a [path](paths.md). Entities include "
"[types](types.md), [items](items.md), [generic parameters](items/"
"generics.md), [variable bindings](patterns.md), [loop labels](expressions/"
"loop-expr.md#loop-labels), [lifetimes](tokens.md#lifetimes-and-loop-labels), "
"[fields](expressions/field-expr.md), [attributes](attributes.md), and [lints]"
"(attributes/diagnostics.md#lint-check-attributes)."
msgstr "_엔티티(entity)_는 소스 프로그램 내에서 어떤 방식으로든(보통 [경로(path)](paths.md)를 통해) 참조될 수 있는 언어 구성 요소입니다. 엔티티에는 [타입](types.md), [아이템](items.md), [제네릭 파라미터](items/generics.md), [변수 바인딩](patterns.md), [루프 레이블](expressions/loop-expr.md#loop-labels), [라이프타임](tokens.md#lifetimes-and-loop-labels), [필드](expressions/field-expr.md), [속성(attributes)](attributes.md), 그리고 [린트(lints)](attributes/diagnostics.md#lint-check-attributes)가 포함됩니다."

#: src/names.md:14
msgid ""
"A _declaration_ is a syntactical construct that can introduce a _name_ to "
"refer to an entity. Entity names are valid within a [_scope_](names/"
"scopes.md) --- a region of source text where that name may be referenced."
msgstr "_선언(declaration)_은 엔티티를 참조하기 위한 _이름_을 도입할 수 있는 구문론적 구성 요소입니다. 엔티티 이름은 [_스코프(scope)_](names/scopes.md)(해당 이름이 참조될 수 있는 소스 텍스트의 영역) 내에서 유효합니다."

#: src/names.md:20
msgid ""
"Some entities are [explicitly declared](#explicitly-declared-entities) in "
"the source code, and some are [implicitly declared](#implicitly-declared-"
"entities) as part of the language or compiler extensions."
msgstr "일부 엔티티는 소스 코드에서 [명시적으로 선언](#explicitly-declared-entities)되며, 일부는 언어의 일부나 컴파일러 확장의 일환으로 [암시적으로 선언](#implicitly-declared-entities)됩니다."

#: src/names.md:26
msgid ""
"[_Paths_](paths.md) are used to refer to an entity, possibly in another "
"module or type."
msgstr "[_경로(Paths)_](paths.md)는 엔티티(다른 모듈이나 타입에 있을 수 있음)를 참조하는 데 사용됩니다."

#: src/names.md:30
msgid ""
"Lifetimes and loop labels use a [dedicated syntax](tokens.md#lifetimes-and-"
"loop-labels) using a leading quote."
msgstr "라이프타임과 루프 레이블은 앞에 따옴표가 붙는 [전용 구문](tokens.md#lifetimes-and-loop-labels)을 사용합니다."

#: src/names.md:35
msgid ""
"Names are segregated into different [_namespaces_](names/namespaces.md), "
"allowing entities in different namespaces to share the same name without "
"conflict."
msgstr "이름은 서로 다른 [_네임스페이스(namespaces)_](names/namespaces.md)로 격리되어, 서로 다른 네임스페이스에 있는 엔티티들이 충돌 없이 동일한 이름을 공유할 수 있게 합니다."

#: src/names.md:40
msgid ""
"[_Name resolution_](names/name-resolution.md) is the compile-time process of "
"tying paths, identifiers, and labels to entity declarations."
msgstr "[_이름 확인(Name resolution)_](names/name-resolution.md)은 경로, 식별자, 레이블을 엔티티 선언에 연결하는 컴파일 타임 프로세스입니다."

#: src/names.md:45
msgid ""
"Access to certain names may be restricted based on their [_visibility_]"
"(visibility-and-privacy.md)."
msgstr "특정 이름에 대한 접근은 해당 이름의 [_가시성(visibility)_](visibility-and-privacy.md)에 따라 제한될 수 있습니다."

#: src/names.md:49
msgid "Explicitly declared entities"
msgstr "명시적으로 선언된 엔티티"

#: src/names.md:53
msgid "Entities that explicitly introduce a name in the source code are:"
msgstr "소스 코드에서 명시적으로 이름을 도입하는 엔티티는 다음과 같습니다."

#: src/names.md:57
msgid "[Items](items.md):"
msgstr "[아이템(Items)](items.md):"

#: src/names.md:58
msgid "[Module declarations](items/modules.md)"
msgstr "[모듈 선언](items/modules.md)"

#: src/names.md:59
msgid "[External crate declarations](items/extern-crates.md)"
msgstr "[외부 크레이트 선언](items/extern-crates.md)"

#: src/names.md:60
msgid "[Use declarations](items/use-declarations.md)"
msgstr "[Use 선언](items/use-declarations.md)"

#: src/names.md:61
msgid ""
"[Function declarations](items/functions.md) and [function parameters](items/"
"functions.md#function-parameters)"
msgstr "[함수 선언](items/functions.md) 및 [함수 매개변수](items/functions.md#function-parameters)"

#: src/names.md:62
msgid "[Type aliases](items/type-aliases.md)"
msgstr "[타입 별칭](items/type-aliases.md)"

#: src/names.md:63
msgid ""
"[struct](items/structs.md), [union](items/unions.md), [enum](items/"
"enumerations.md), enum variant declarations, and their named fields"
msgstr "[구조체](items/structs.md), [공용체](items/unions.md), [열거형](items/enumerations.md), 열거형 변형 선언 및 이름 있는 필드들"

#: src/names.md:65
msgid "[Constant item declarations](items/constant-items.md)"
msgstr "[상수 아이템 선언](items/constant-items.md)"

#: src/names.md:66
msgid "[Static item declarations](items/static-items.md)"
msgstr "[정적 아이템 선언](items/static-items.md)"

#: src/names.md:67
msgid ""
"[Trait item declarations](items/traits.md) and their [associated items]"
"(items/associated-items.md)"
msgstr "[트레잇 아이템 선언](items/traits.md) 및 [연관 아이템](items/associated-items.md)"

#: src/names.md:68
msgid "[External block items](items/external-blocks.md)"
msgstr "[외부 블록 아이템](items/external-blocks.md)"

#: src/names.md:69
msgid ""
"[`macro_rules` declarations](macros-by-example.md) and [matcher "
"metavariables](macros-by-example.md#metavariables)"
msgstr "[`macro_rules` 선언](macros-by-example.md) 및 [매처 메타변수](macros-by-example.md#metavariables)"

#: src/names.md:70
msgid "[Implementation](items/implementations.md) associated items"
msgstr "[구현](items/implementations.md) 연관 아이템"

#: src/names.md:74
msgid "[Expressions](expressions.md):"
msgstr "[표현식](expressions.md):"

#: src/names.md:75
msgid "[Closure](expressions/closure-expr.md) parameters"
msgstr "[클로저](expressions/closure-expr.md) 매개변수"

#: src/names.md:76
msgid ""
"[`while let`](expressions/loop-expr.md#predicate-pattern-loops) pattern "
"bindings"
msgstr "[`while let`](expressions/loop-expr.md#predicate-pattern-loops) 패턴 바인딩"

#: src/names.md:77
msgid "[`for`](expressions/loop-expr.md#iterator-loops) pattern bindings"
msgstr "[`for`](expressions/loop-expr.md#iterator-loops) 패턴 바인딩"

#: src/names.md:78
msgid "[`if let`](expressions/if-expr.md#if-let-expressions) pattern bindings"
msgstr "[`if let`](expressions/if-expr.md#if-let-expressions) 패턴 바인딩"

#: src/names.md:79
msgid "[`match`](expressions/match-expr.md) pattern bindings"
msgstr "[`match`](expressions/match-expr.md) 패턴 바인딩"

#: src/names.md:80
msgid "[Loop labels](expressions/loop-expr.md#loop-labels)"
msgstr "[루프 레이블](expressions/loop-expr.md#loop-labels)"

#: src/names.md:84
msgid "[Generic parameters](items/generics.md)"
msgstr "[제네릭 파라미터](items/generics.md)"

#: src/names.md:88
msgid ""
"[Higher ranked trait bounds](trait-bounds.md#higher-ranked-trait-bounds)"
msgstr "[고차 트레잇 바운드](trait-bounds.md#higher-ranked-trait-bounds)"

#: src/names.md:92
msgid "[`let` statement](statements.md#let-statements) pattern bindings"
msgstr "[`let` 문](statements.md#let-statements) 패턴 바인딩"

#: src/names.md:96
msgid ""
"The [`macro_use` attribute](macros-by-example.md#the-macro_use-attribute) "
"can introduce macro names from another crate"
msgstr "`macro_use` 속성](macros-by-example.md#the-macro_use-attribute)은 다른 크레이트에서 매크로 이름을 가져올 수 있습니다."

#: src/names.md:100
msgid ""
"The [`macro_export` attribute](macros-by-example.md#path-based-scope) can "
"introduce an alias for the macro into the crate root"
msgstr "`macro_export` 속성](macros-by-example.md#path-based-scope)은 크레이트 루트에 매크로 별칭을 도입할 수 있습니다."

#: src/names.md:104
msgid ""
"Additionally, [macro invocations](macros.md#macro-invocation) and "
"[attributes](attributes.md) can introduce names by expanding to one of the "
"above items."
msgstr "또한, [매크로 호출](macros.md#macro-invocation) 및 [속성](attributes.md)은 위의 항목 중 하나로 확장되어 이름을 도입할 수 있습니다."

#: src/names.md:109
msgid "Implicitly declared entities"
msgstr "암시적으로 선언된 엔티티"

#: src/names.md:113
msgid ""
"The following entities are implicitly defined by the language, or are "
"introduced by compiler options and extensions:"
msgstr "다음 엔티티들은 언어에 의해 암시적으로 정의되거나, 컴파일러 옵션 및 확장 기능을 통해 도입됩니다."

#: src/names.md:118
msgid "[Language prelude](names/preludes.md#language-prelude):"
msgstr "[언어 프렐류드](names/preludes.md#language-prelude):"

#: src/names.md:119
msgid "[Boolean type](types/boolean.md) --- `bool`"
msgstr "[불리언 타입](types/boolean.md) --- `bool`"

#: src/names.md:120
msgid "[Textual types](types/textual.md) --- `char` and `str`"
msgstr "[텍스트 타입](types/textual.md) --- `char` 및 `str`"

#: src/names.md:121
msgid ""
"[Integer types](types/numeric.md#integer-types) --- `i8`, `i16`, `i32`, "
"`i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`"
msgstr "[정수 타입](types/numeric.md#integer-types) --- `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`"

#: src/names.md:122
msgid ""
"[Machine-dependent integer types](types/numeric.md#machine-dependent-integer-"
"types) --- `usize` and `isize`"
msgstr "[머신 의존적 정수 타입](types/numeric.md#machine-dependent-integer-types) --- `usize` 및 `isize`"

#: src/names.md:123
msgid ""
"[floating-point types](types/numeric.md#floating-point-types) --- `f32` and "
"`f64`"
msgstr "[부동 소수점 타입](types/numeric.md#floating-point-types) --- `f32` 및 `f64`"

#: src/names.md:127
msgid "[Built-in attributes](attributes.md#built-in-attributes-index)"
msgstr "[내장 속성](attributes.md#built-in-attributes-index)"

#: src/names.md:131
msgid ""
"[Standard library prelude](names/preludes.md#standard-library-prelude) "
"items, attributes, and macros"
msgstr "[표준 라이브러리 프렐류드](names/preludes.md#standard-library-prelude) 아이템, 속성 및 매크로"

#: src/names.md:135
msgid ""
"[Standard library](names/preludes.md#extern-prelude) crates in the root "
"module"
msgstr "루트 모듈의 [표준 라이브러리](names/preludes.md#extern-prelude) 크레이트"

#: src/names.md:139
msgid ""
"[External crates](names/preludes.md#extern-prelude) linked by the compiler"
msgstr "컴파일러에 의해 링크된 [외부 크레이트](names/preludes.md#extern-prelude)"

#: src/names.md:143
msgid "[Tool attributes](attributes.md#tool-attributes)"
msgstr "[도구 속성](attributes.md#tool-attributes)"

#: src/names.md:147
msgid ""
"[Lints](attributes/diagnostics.md#lint-check-attributes) and [tool lint "
"attributes](attributes/diagnostics.md#tool-lint-attributes)"
msgstr "[린트](attributes/diagnostics.md#lint-check-attributes) 및 [도구 린트 속성](attributes/diagnostics.md#tool-lint-attributes)"

#: src/names.md:151
msgid ""
"[Derive helper attributes](procedural-macros.md#derive-macro-helper-"
"attributes) are valid within an item without being explicitly imported"
msgstr "[Derive 헬퍼 속성](procedural-macros.md#derive-macro-helper-attributes)은 명시적으로 가져오지 않아도 아이템 내에서 유효합니다."

#: src/names.md:155
msgid "The [`'static`](keywords.md#weak-keywords) lifetime"
msgstr "[`'static`](keywords.md#weak-keywords) 라이프타임"

#: src/names.md:159
msgid ""
"Additionally, the crate root module does not have a name, but can be "
"referred to with certain [path qualifiers](paths.md#path-qualifiers) or "
"aliases."
msgstr "또한, 크레이트 루트 모듈은 이름을 가지지 않지만, 특정 [경로 한정자](paths.md#path-qualifiers)나 별칭을 통해 참조될 수 있습니다."

#: src/names/namespaces.md:7
msgid ""
"A _namespace_ is a logical grouping of declared [names](../names.md). Names "
"are segregated into separate namespaces based on the kind of entity the name "
"refers to. Namespaces allow the occurrence of a name in one namespace to not "
"conflict with the same name in another namespace."
msgstr "_네임스페이스_는 선언된 [이름](../names.md)의 논리적 그룹입니다. 이름은 해당 이름이 참조하는 엔티티의 종류에 따라 별도의 네임스페이스로 분리됩니다. 네임스페이스를 사용하면 한 네임스페이스에 있는 이름이 다른 네임스페이스에 있는 같은 이름과 충돌하지 않습니다."

#: src/names/namespaces.md:12
msgid ""
"There are several different namespaces that each contain different kinds of "
"entities. The usage of a name will look for the declaration of that name in "
"different namespaces, based on the context, as described in the [name "
"resolution](name-resolution.md) chapter."
msgstr "각각 다른 종류의 엔티티를 포함하는 여러 가지 네임스페이스가 있습니다. 이름의 사용은 [이름 해석](name-resolution.md) 장에서 설명한 대로 문맥에 따라 다른 네임스페이스에서 해당 이름의 선언을 찾습니다."

#: src/names/namespaces.md:19
msgid ""
"The following is a list of namespaces, with their corresponding entities:"
msgstr "다음은 네임스페이스와 그에 해당하는 엔티티의 목록입니다:"

#: src/names/namespaces.md:21
msgid "Type Namespace"
msgstr "타입 네임스페이스"

#: src/names/namespaces.md:22
msgid "[Module declarations](../items/modules.md)"
msgstr "[모듈 선언](../items/modules.md)"

#: src/names/namespaces.md:23
msgid "[External crate declarations](../items/extern-crates.md)"
msgstr "[외부 크레이트 선언](../items/extern-crates.md)"

#: src/names/namespaces.md:24
msgid "[External crate prelude](preludes.md#extern-prelude) items"
msgstr "[외부 크레이트 프렐류드](preludes.md#extern-prelude) 아이템"

#: src/names/namespaces.md:25
msgid ""
"[Struct](../items/structs.md), [union](../items/unions.md), [enum](../items/"
"enumerations.md), enum variant declarations"
msgstr "[구조체](../items/structs.md), [공용체](../items/unions.md), [열거형](../items/enumerations.md), 열거형 변형 선언"

#: src/names/namespaces.md:26
msgid "[Trait item declarations](../items/traits.md)"
msgstr "[트레잇 아이템 선언](../items/traits.md)"

#: src/names/namespaces.md:27
msgid "[Type aliases](../items/type-aliases.md)"
msgstr "[타입 별칭](../items/type-aliases.md)"

#: src/names/namespaces.md:28
msgid ""
"[Associated type declarations](../items/associated-items.md#associated-types)"
msgstr "[연관 타입 선언](../items/associated-items.md#associated-types)"

#: src/names/namespaces.md:29
msgid ""
"Built-in types: [boolean](../types/boolean.md), [numeric](../types/"
"numeric.md), and [textual](../types/textual.md)"
msgstr "내장 타입: [불리언](../types/boolean.md), [숫자](../types/numeric.md), [텍스트](../types/textual.md)"

#: src/names/namespaces.md:30
msgid "[Generic type parameters](../items/generics.md)"
msgstr "[제네릭 타입 매개변수](../items/generics.md)"

#: src/names/namespaces.md:31
msgid "[`Self` type](../paths.md#self-1)"
msgstr "[`Self` 타입](../paths.md#self-1)"

#: src/names/namespaces.md:32
msgid "[Tool attribute modules](../attributes.md#tool-attributes)"
msgstr "[도구 속성 모듈](../attributes.md#tool-attributes)"

#: src/names/namespaces.md:33
msgid "Value Namespace"
msgstr "값 네임스페이스"

#: src/names/namespaces.md:34
msgid "[Function declarations](../items/functions.md)"
msgstr "[함수 선언](../items/functions.md)"

#: src/names/namespaces.md:35
msgid "[Constant item declarations](../items/constant-items.md)"
msgstr "[상수 아이템 선언](../items/constant-items.md)"

#: src/names/namespaces.md:36
msgid "[Static item declarations](../items/static-items.md)"
msgstr "[정적 아이템 선언](../items/static-items.md)"

#: src/names/namespaces.md:37
msgid "[Struct constructors](../items/structs.md)"
msgstr "[구조체 생성자](../items/structs.md)"

#: src/names/namespaces.md:38
msgid "[Enum variant constructors](../items/enumerations.md)"
msgstr "[열거형 변형 생성자](../items/enumerations.md)"

#: src/names/namespaces.md:39
msgid "[`Self` constructors](../paths.md#self-1)"
msgstr "[`Self` 생성자](../paths.md#self-1)"

#: src/names/namespaces.md:40
msgid "[Generic const parameters](../items/generics.md#const-generics)"
msgstr "[제네릭 상수 매개변수](../items/generics.md#const-generics)"

#: src/names/namespaces.md:41
msgid ""
"[Associated const declarations](../items/associated-items.md#associated-"
"constants)"
msgstr "[연관 상수 선언](../items/associated-items.md#associated-constants)"

#: src/names/namespaces.md:42
msgid ""
"[Associated function declarations](../items/associated-items.md#associated-"
"functions-and-methods)"
msgstr "[연관 함수 선언](../items/associated-items.md#associated-functions-and-methods)"

#: src/names/namespaces.md:43
msgid ""
"Local bindings --- [`let`](../statements.md#let-statements), [`if let`](../"
"expressions/if-expr.md#if-let-expressions), [`while let`](../expressions/"
"loop-expr.md#predicate-pattern-loops), [`for`](../expressions/loop-"
"expr.md#iterator-loops), [`match`](../expressions/match-expr.md) arms, "
"[function parameters](../items/functions.md#function-parameters), [closure "
"parameters](../expressions/closure-expr.md)"
msgstr "지역 바인딩 --- [`let`](../statements.md#let-statements), [`if let`](../expressions/if-expr.md#if-let-expressions), [`while let`](../expressions/loop-expr.md#predicate-pattern-loops), [`for`](../expressions/loop-expr.md#iterator-loops), [`match`](../expressions/match-expr.md) 분기, [함수 매개변수](../items/functions.md#function-parameters), [클로저 매개변수](../expressions/closure-expr.md)"

#: src/names/namespaces.md:45
msgid "Captured [closure](../expressions/closure-expr.md) variables"
msgstr "캡처된 [클로저](../expressions/closure-expr.md) 변수"

#: src/names/namespaces.md:46
msgid "Macro Namespace"
msgstr "매크로 네임스페이스"

#: src/names/namespaces.md:47
msgid "[`macro_rules` declarations](../macros-by-example.md)"
msgstr "[`macro_rules` 선언](../macros-by-example.md)"

#: src/names/namespaces.md:48 src/names/preludes.md:161
msgid "[Built-in attributes](../attributes.md#built-in-attributes-index)"
msgstr "[내장 속성](../attributes.md#built-in-attributes-index)"

#: src/names/namespaces.md:49
msgid "[Tool attributes](../attributes.md#tool-attributes)"
msgstr "[도구 속성](../attributes.md#tool-attributes)"

#: src/names/namespaces.md:50
msgid ""
"[Function-like procedural macros](../procedural-macros.md#function-like-"
"procedural-macros)"
msgstr "[함수형 절차적 매크로](../procedural-macros.md#function-like-procedural-macros)"

#: src/names/namespaces.md:52
msgid ""
"[Derive macro helpers](../procedural-macros.md#derive-macro-helper-"
"attributes)"
msgstr "[Derive 매크로 도우미](../procedural-macros.md#derive-macro-helper-attributes)"

#: src/names/namespaces.md:53
msgid "[Attribute macros](../procedural-macros.md#attribute-macros)"
msgstr "[속성 매크로](../procedural-macros.md#attribute-macros)"

#: src/names/namespaces.md:54
msgid "Lifetime Namespace"
msgstr "라이프타임 네임스페이스"

#: src/names/namespaces.md:55
msgid "[Generic lifetime parameters](../items/generics.md)"
msgstr "[제네릭 라이프타임 매개변수](../items/generics.md)"

#: src/names/namespaces.md:56
msgid "Label Namespace"
msgstr "레이블 네임스페이스"

#: src/names/namespaces.md:57
msgid "[Loop labels](../expressions/loop-expr.md#loop-labels)"
msgstr "[루프 레이블](../expressions/loop-expr.md#loop-labels)"

#: src/names/namespaces.md:58
msgid "[Block labels](../expressions/loop-expr.md#labelled-block-expressions)"
msgstr "[블록 레이블](../expressions/loop-expr.md#labelled-block-expressions)"

#: src/names/namespaces.md:60
msgid ""
"An example of how overlapping names in different namespaces can be used "
"unambiguously:"
msgstr "다른 네임스페이스에서 겹치는 이름을 모호하지 않게 사용하는 예:"

#: src/names/namespaces.md:63
msgid ""
"// Foo introduces a type in the type namespace and a constructor in the "
"value\n"
"// namespace.\n"
msgstr ""
"// Foo는 타입 네임스페이스에 타입을 도입하고 값 네임스페이스에\n"
"// 생성자를 도입합니다.\n"

#: src/names/namespaces.md:66
msgid "// The `Foo` macro is declared in the macro namespace.\n"
msgstr "// `Foo` 매크로는 매크로 네임스페이스에 선언됩니다.\n"

#: src/names/namespaces.md:71
msgid ""
"// `Foo` in the `f` parameter type refers to `Foo` in the type namespace.\n"
"// `'Foo` introduces a new lifetime in the lifetime namespace.\n"
msgstr ""
"// `f` 매개변수 타입의 `Foo`는 타입 네임스페이스의 `Foo`를 참조합니다.\n"
"// `'Foo`는 라이프타임 네임스페이스에 새로운 라이프타임을 도입합니다.\n"

#: src/names/namespaces.md:75
msgid "// `Foo` refers to the `Foo` constructor in the value namespace.\n"
msgstr "// `Foo`는 값 네임스페이스의 `Foo` 생성자를 참조합니다.\n"

#: src/names/namespaces.md:77
msgid "// `Foo` refers to the `Foo` macro in the macro namespace.\n"
msgstr "// `Foo`는 매크로 네임스페이스의 `Foo` 매크로를 참조합니다.\n"

#: src/names/namespaces.md:79
msgid "// `'Foo` introduces a label in the label namespace.\n"
msgstr "// `'Foo`는 레이블 네임스페이스에 레이블을 도입합니다.\n"

#: src/names/namespaces.md:81
msgid ""
"// `'Foo` refers to the `'Foo` lifetime parameter, and `Foo`\n"
"        // refers to the type namespace.\n"
msgstr ""
"// `'Foo`는 `'Foo` 라이프타임 매개변수를 참조하며, `Foo`는\n"
"        // 타입 네임스페이스를 참조합니다.\n"

#: src/names/namespaces.md:84
msgid "// `'Foo` refers to the label.\n"
msgstr "// `'Foo`는 레이블을 참조합니다.\n"

#: src/names/namespaces.md:92
msgid "Named entities without a namespace"
msgstr "네임스페이스가 없는 명명된 엔터티"

#: src/names/namespaces.md:94
msgid ""
"The following entities have explicit names, but the names are not a part of "
"any specific namespace."
msgstr "다음 엔터티는 명시적인 이름을 가지고 있지만, 그 이름은 특정 네임스페이스의 일부가 아닙니다."

#: src/names/namespaces.md:97
msgid "Fields"
msgstr "필드"

#: src/names/namespaces.md:101
msgid ""
"Even though struct, enum, and union fields are named, the named fields do "
"not live in an explicit namespace. They can only be accessed via a [field "
"expression](../expressions/field-expr.md), which only inspects the field "
"names of the specific type being accessed."
msgstr ""
"구조체, 열거형 및 유니온 필드에 이름이 지정되어 있더라도, 명명된 필드는 "
"명시적 네임스페이스에 존재하지 않습니다. 이들은 [필드 표현식](../expressions/field-expr.md)을 "
"통해서만 접근할 수 있으며, 이는 접근하려는 특정 타입의 필드 이름만 검사합니다."

#: src/names/namespaces.md:110
msgid ""
"A [use declaration](../items/use-declarations.md) has named aliases that it "
"imports into scope, but the `use` item itself does not belong to a specific "
"namespace. Instead, it can introduce aliases into multiple namespaces, "
"depending on the item kind being imported."
msgstr ""
"[Use 선언](../items/use-declarations.md)은 스코프로 가져오는 명명된 별칭을 가지지만, "
"`use` 아이템 자체는 특정 네임스페이스에 속하지 않습니다. 대신, 가져오는 아이템 종류에 따라 "
"여러 네임스페이스에 별칭을 도입할 수 있습니다."

#: src/names/namespaces.md:117
msgid "Sub-namespaces"
msgstr "서브 네임스페이스"

#: src/names/namespaces.md:121
msgid ""
"The macro namespace is split into two sub-namespaces: one for [bang-style "
"macros](../macros.md) and one for [attributes](../attributes.md). When an "
"attribute is resolved, any bang-style macros in scope will be ignored. And "
"conversely resolving a bang-style macro will ignore attribute macros in "
"scope. This prevents one style from shadowing another."
msgstr ""
"매크로 네임스페이스는 두 개의 서브 네임스페이스로 나뉩니다: 하나는 [느낌표 스타일 매크로](../macros.md)용이고 "
"다른 하나는 [속성](../attributes.md)용입니다. 속성이 확인될 때, 스코프 내의 느낌표 스타일 매크로는 무시됩니다. "
"반대로 느낌표 스타일 매크로를 확인할 때는 스코프 내의 속성 매크로가 무시됩니다. "
"이는 한 스타일이 다른 스타일을 가리는 것을 방지합니다."

#: src/names/namespaces.md:126
msgid ""
"For example, the [`cfg` attribute](../conditional-compilation.md#the-cfg-"
"attribute) and the [`cfg` macro](../conditional-compilation.md#the-cfg-"
"macro) are two different entities with the same name in the macro namespace, "
"but they can still be used in their respective context."
msgstr ""
"예를 들어, [`cfg` 속성](../conditional-compilation.md#the-cfg-attribute)과 "
"[`cfg` 매크로](../conditional-compilation.md#the-cfg-macro)는 매크로 네임스페이스에서 "
"같은 이름을 가진 서로 다른 두 엔터티이지만, 여전히 각각의 컨텍스트에서 사용할 수 있습니다."

#: src/names/namespaces.md:130
msgid ""
"It is still an error for a [`use` import](../items/use-declarations.md) to "
"shadow another macro, regardless of their sub-namespaces."
msgstr ""
"서브 네임스페이스와 관계없이 [`use` 임포트](../items/use-declarations.md)가 "
"다른 매크로를 가리는 것은 여전히 오류입니다."

#: src/names/scopes.md:7
msgid ""
"A _scope_ is the region of source text where a named [entity](../names.md) "
"may be referenced with that name. The following sections provide details on "
"the scoping rules and behavior, which depend on the kind of entity and where "
"it is declared. The process of how names are resolved to entities is "
"described in the [name resolution](name-resolution.md) chapter. More "
"information on \"drop scopes\" used for the purpose of running destructors "
"may be found in the [destructors](../destructors.md) chapter."
msgstr ""
"_스코프_는 명명된 [엔터티](../names.md)가 해당 이름으로 참조될 수 있는 "
"소스 텍스트 영역입니다. 다음 섹션에서는 엔터티의 종류와 선언된 위치에 따라 달라지는 "
"스코핑 규칙 및 동작에 대한 세부 정보를 제공합니다. 이름이 엔터티로 확인되는 과정은 "
"[이름 확인](name-resolution.md) 장에 설명되어 있습니다. 소멸자를 실행하기 위해 사용되는 "
"\"드롭 스코프\"에 대한 자세한 정보는 [소멸자](../destructors.md) 장에서 찾을 수 있습니다."

#: src/names/scopes.md:14
msgid "Item scopes"
msgstr "아이템 스코프"

#: src/names/scopes.md:18
msgid ""
"The name of an [item](../items.md) declared directly in a [module](../items/"
"modules.md) has a scope that extends from the start of the module to the end "
"of the module. These items are also members of the module and can be "
"referred to with a [path](../paths.md) leading from their module."
msgstr ""
"[모듈](../items/modules.md)에 직접 선언된 [아이템](../items.md)의 이름은 "
"모듈의 시작부터 모듈의 끝까지 확장되는 스코프를 가집니다. 이 아이템들은 또한 모듈의 "
"멤버이며 해당 모듈에서 이어지는 [경로](../paths.md)로 참조할 수 있습니다."

#: src/names/scopes.md:22
msgid ""
"The name of an item declared as a [statement](../statements.md) has a scope "
"that extends from the start of the block the item statement is in until the "
"end of the block."
msgstr ""
"[구문](../statements.md)으로 선언된 아이템의 이름은 "
"아이템 구문이 있는 블록의 시작부터 블록의 끝까지 확장되는 스코프를 가집니다."

#: src/names/scopes.md:26
msgid ""
"It is an error to introduce an item with a duplicate name of another item in "
"the same [namespace](namespaces.md) within the same module or block. "
"[Asterisk glob imports](../items/use-declarations.md) have special behavior "
"for dealing with duplicate names and shadowing, see the linked chapter for "
"more details."
msgstr ""
"동일한 모듈이나 블록 내의 동일한 [네임스페이스](namespaces.md)에 있는 "
"다른 아이템과 중복된 이름으로 아이템을 도입하는 것은 오류입니다. "
"[별표 글롭 임포트](../items/use-declarations.md)는 중복된 이름과 가림을 처리하는 데 "
"특별한 동작을 가지고 있으며, 자세한 내용은 링크된 장을 참조하십시오."

#: src/names/scopes.md:31
msgid "Items in a module may shadow items in a [prelude](#prelude-scopes)."
msgstr "모듈의 아이템은 [프렐류드](#prelude-scopes)의 아이템을 가릴 수 있습니다."

#: src/names/scopes.md:35
msgid ""
"Item names from outer modules are not in scope within a nested module. A "
"[path](../paths.md) may be used to refer to an item in another module."
msgstr ""
"외부 모듈의 아이템 이름은 중첩된 모듈 내의 스코프에 없습니다. "
"[경로](../paths.md)를 사용하여 다른 모듈의 아이템을 참조할 수 있습니다."

#: src/names/scopes.md:40
msgid "Associated item scopes"
msgstr "연관 아이템 스코프"

#: src/names/scopes.md:44
msgid ""
"[Associated items](../items/associated-items.md) are not scoped and can only "
"be referred to by using a [path](../paths.md) leading from the type or trait "
"they are associated with. [Methods](../items/associated-items.md#methods) "
"can also be referred to via [call expressions](../expressions/call-expr.md)."
msgstr ""
"[연관 아이템](../items/associated-items.md)은 스코프가 지정되지 않으며 "
"연관된 타입이나 트레잇에서 이어지는 [경로](../paths.md)를 사용해야만 참조할 수 있습니다. "
"[메서드](../items/associated-items.md#methods)는 [호출 표현식](../expressions/call-expr.md)을 "
"통해서도 참조할 수 있습니다."

#: src/names/scopes.md:49
msgid ""
"Similar to items within a module or block,  it is an error to introduce an "
"item within a trait or implementation that is a duplicate of another item in "
"the trait or impl in the same namespace."
msgstr ""
"모듈이나 블록 내의 아이템과 마찬가지로, 동일한 네임스페이스의 트레잇이나 구현 내에 "
"다른 아이템과 중복되는 아이템을 트레잇이나 구현 내에 도입하는 것은 오류입니다."

#: src/names/scopes.md:53
msgid "Pattern binding scopes"
msgstr "패턴 바인딩 스코프"

#: src/names/scopes.md:55
msgid ""
"The scope of a local variable [pattern](../patterns.md) binding depends on "
"where it is used:"
msgstr "지역 변수 [패턴](../patterns.md) 바인딩의 스코프는 사용되는 위치에 따라 다릅니다:"

#: src/names/scopes.md:59
msgid ""
"[`let` statement](../statements.md#let-statements) bindings range from just "
"after the `let` statement until the end of the block where it is declared."
msgstr ""
"[`let` 구문](../statements.md#let-statements) 바인딩은 `let` 구문 바로 뒤부터 "
"선언된 블록의 끝까지 범위가 지정됩니다."

#: src/names/scopes.md:62
msgid ""
"[Function parameter](../items/functions.md#function-parameters) bindings are "
"within the body of the function."
msgstr "[함수 매개변수](../items/functions.md#function-parameters) 바인딩은 함수 본문 내에 있습니다."

#: src/names/scopes.md:65
msgid ""
"[Closure parameter](../expressions/closure-expr.md) bindings are within the "
"closure body."
msgstr "[클로저 매개변수](../expressions/closure-expr.md) 바인딩은 클로저 본문 내에 있습니다."

#: src/names/scopes.md:68
msgid ""
"[`for`](../expressions/loop-expr.md#iterator-loops) and [`while let`](../"
"expressions/loop-expr.md#predicate-pattern-loops) bindings are within the "
"loop body."
msgstr ""
"[`for`](../expressions/loop-expr.md#iterator-loops) 및 "
"[`while let`](../expressions/loop-expr.md#predicate-pattern-loops) 바인딩은 루프 본문 내에 있습니다."

#: src/names/scopes.md:71
msgid ""
"[`if let`](../expressions/if-expr.md#if-let-expressions) bindings are within "
"the consequent block."
msgstr "[`if let`](../expressions/if-expr.md#if-let-expressions) 바인딩은 후속 블록 내에 있습니다."

#: src/names/scopes.md:74
msgid ""
"[`match` arms](../expressions/match-expr.md) bindings are within the [match "
"guard](../expressions/match-expr.md#match-guards) and the match arm "
"expression."
msgstr ""
"[`match` 암](../expressions/match-expr.md) 바인딩은 [매치 가드](../expressions/match-expr.md#match-guards) "
"및 매치 암 표현식 내에 있습니다."

#: src/names/scopes.md:78
msgid "Local variable scopes do not extend into item declarations."
msgstr "지역 변수 스코프는 아이템 선언으로 확장되지 않습니다."

#: src/names/scopes.md:81
msgid "Pattern binding shadowing"
msgstr "패턴 바인딩 가림"

#: src/names/scopes.md:85
msgid ""
"Pattern bindings are allowed to shadow any name in scope with the following "
"exceptions which are an error:"
msgstr "패턴 바인딩은 오류인 다음 예외를 제외하고 스코프 내의 모든 이름을 가릴 수 있습니다:"

#: src/names/scopes.md:87
msgid "[Const generic parameters](../items/generics.md#const-generics)"
msgstr "[상수 제네릭 매개변수](../items/generics.md#const-generics)"

#: src/names/scopes.md:88
msgid "[Static items](../items/static-items.md)"
msgstr "[정적 아이템](../items/static-items.md)"

#: src/names/scopes.md:89
msgid "[Const items](../items/constant-items.md)"
msgstr "[상수 아이템](../items/constant-items.md)"

#: src/names/scopes.md:90
msgid ""
"Constructors for [structs](../items/structs.md) and [enums](../items/"
"enumerations.md)"
msgstr "[구조체](../items/structs.md) 및 [열거형](../items/enumerations.md)의 생성자"

#: src/names/scopes.md:92
msgid ""
"The following example illustrates how local bindings can shadow item "
"declarations:"
msgstr "다음 예제는 지역 바인딩이 아이템 선언을 어떻게 가릴 수 있는지 보여줍니다:"

#: src/names/scopes.md:96
msgid ""
"// Since there are no local variables in scope yet, this resolves to the "
"function.\n"
msgstr "// 아직 스코프에 지역 변수가 없으므로, 이것은 함수로 확인됩니다.\n"

#: src/names/scopes.md:97
msgid "// prints `function`\n"
msgstr "// `function` 출력\n"

#: src/names/scopes.md:98
msgid "\"closure\""
msgstr "\"클로저\""

#: src/names/scopes.md:99
msgid "\"function\""
msgstr "\"함수\""

#: src/names/scopes.md:100
msgid "// This resolves to the local closure since it shadows the item.\n"
msgstr "// 아이템을 가리므로 이것은 지역 클로저로 확인됩니다.\n"

#: src/names/scopes.md:101
msgid "// prints `closure`\n"
msgstr "// `closure` 출력\n"

#: src/names/scopes.md:107
msgid "Generic parameter scopes"
msgstr "제네릭 매개변수 스코프"

#: src/names/scopes.md:111
msgid ""
"Generic parameters are declared in a [_GenericParams_](../items/generics.md) "
"list. The scope of a generic parameter is within the item it is declared on."
msgstr "제네릭 매개변수는 [_제네릭매개변수_](../items/generics.md) 목록에 선언됩니다. 제네릭 매개변수의 스코프는 그것이 선언된 아이템 내부입니다."

#: src/names/scopes.md:116
msgid ""
"All parameters are in scope within the generic parameter list regardless of "
"the order they are declared. The following shows some examples where a "
"parameter may be referenced before it is declared:"
msgstr "모든 매개변수는 선언된 순서와 관계없이 제네릭 매개변수 목록 내에서 스코프에 있습니다. 다음은 매개변수가 선언되기 전에 참조될 수 있는 몇 가지 예시를 보여줍니다:"

#: src/names/scopes.md:120
msgid "// The 'b bound is referenced before it is declared.\n"
msgstr "// 'b 바운드는 선언되기 전에 참조됩니다.\n"

#: src/names/scopes.md:123
msgid ""
"// The const N is referenced in the trait bound before it is declared.\n"
msgstr ""
"// 상수 N은 선언되기 전에 트레잇 바운드에서 참조됩니다.\n"

#: src/names/scopes.md:130
msgid ""
"Generic parameters are also in scope for type bounds and where clauses, for "
"example:"
msgstr "제네릭 매개변수는 타입 바운드와 where 절에서도 스코프에 있습니다. 예를 들어:"

#: src/names/scopes.md:133
msgid ""
"// The <'a, U> for `SomeTrait` refer to the 'a and U parameters of "
"`bounds_scope`.\n"
msgstr ""
"// `SomeTrait`의 <'a, U>는 `bounds_scope`의 'a와 U 매개변수를 참조합니다.\n"

#: src/names/scopes.md:144
msgid ""
"It is an error for [items](../items.md) declared inside a function to refer "
"to a generic parameter from their outer scope."
msgstr "함수 내부에 선언된 [아이템](../items.md)이 외부 스코프의 제네릭 매개변수를 참조하는 것은 오류입니다."

#: src/names/scopes.md:148
msgid "// ERROR: can't use generic parameters from outer function\n"
msgstr "// 오류: 외부 함수의 제네릭 매개변수를 사용할 수 없습니다\n"

#: src/names/scopes.md:152
msgid "Generic parameter shadowing"
msgstr "제네릭 매개변수 가리기(Shadowing)"

#: src/names/scopes.md:156
msgid ""
"It is an error to shadow a generic parameter with the exception that items "
"declared within functions are allowed to shadow generic parameter names from "
"the function."
msgstr "함수 내에 선언된 아이템이 함수의 제네릭 매개변수 이름을 가리는 것이 허용되는 경우를 제외하고, 제네릭 매개변수를 가리는 것은 오류입니다."

#: src/names/scopes.md:160
msgid ""
"// Items within functions are allowed to shadow generic parameter in scope.\n"
msgstr "// 함수 내의 아이템은 스코프 내의 제네릭 매개변수를 가릴 수 있습니다.\n"

#: src/names/scopes.md:169
msgid "// ERROR: 'a is already in use\n"
msgstr "// 오류: 'a는 이미 사용 중입니다\n"

#: src/names/scopes.md:170 src/names/scopes.md:172
msgid "// ERROR: T is already in use\n"
msgstr "// 오류: T는 이미 사용 중입니다\n"

#: src/names/scopes.md:171
msgid "// ERROR: N is already in use\n"
msgstr "// 오류: N은 이미 사용 중입니다\n"

#: src/names/scopes.md:178
msgid "Lifetime scopes"
msgstr "라이프타임 스코프"

#: src/names/scopes.md:180
msgid ""
"Lifetime parameters are declared in a [_GenericParams_](../items/"
"generics.md) list and [higher-ranked trait bounds](../trait-bounds.md#higher-"
"ranked-trait-bounds)."
msgstr "라이프타임 매개변수는 [_제네릭매개변수_](../items/generics.md) 목록과 [고차 트레잇 바운드](../trait-bounds.md#higher-ranked-trait-bounds)에서 선언됩니다."

#: src/names/scopes.md:184
msgid ""
"The `'static` lifetime and [placeholder lifetime](../lifetime-elision.md) "
"`'_` have a special meaning and cannot be declared as a parameter."
msgstr "'static` 라이프타임과 [플레이스홀더 라이프타임](../lifetime-elision.md) `'_`는 특별한 의미를 가지며 매개변수로 선언될 수 없습니다."

#: src/names/scopes.md:186
msgid "Lifetime generic parameter scopes"
msgstr "라이프타임 제네릭 매개변수 스코프"

#: src/names/scopes.md:190
msgid ""
"[Constant](../items/constant-items.md) and [static](../items/static-"
"items.md) items and [const contexts](../const_eval.md#const-context) only "
"ever allow `'static` lifetime references, so no other lifetime may be in "
"scope within them. [Associated consts](../items/associated-"
"items.md#associated-constants) do allow referring to lifetimes declared in "
"their trait or implementation."
msgstr "[상수](../items/constant-items.md) 및 [정적](../items/static-items.md) 아이템과 [const 컨텍스트](../const_eval.md#const-context)는 오직 `'static` 라이프타임 참조만 허용하므로, 그 안에는 다른 어떤 라이프타임도 스코프에 있을 수 없습니다. [연관 상수](../items/associated-items.md#associated-constants)는 트레잇이나 구현에 선언된 라이프타임을 참조하는 것을 허용합니다."

#: src/names/scopes.md:193
msgid "Higher-ranked trait bound scopes"
msgstr "고차 트레잇 바운드 스코프"

#: src/names/scopes.md:197
msgid ""
"The scope of a lifetime parameter declared as a [higher-ranked trait bound]"
"(../trait-bounds.md#higher-ranked-trait-bounds) depends on the scenario "
"where it is used."
msgstr "[고차 트레잇 바운드](../trait-bounds.md#higher-ranked-trait-bounds)로 선언된 라이프타임 매개변수의 스코프는 그것이 사용되는 시나리오에 따라 다릅니다."

#: src/names/scopes.md:199
msgid ""
"As a [_TypeBoundWhereClauseItem_](../items/generics.md) the declared "
"lifetimes are in scope in the type and the type bounds."
msgstr "[_타입바운드Where절항목_](../items/generics.md)으로서 선언된 라이프타임은 타입과 타입 바운드 내에서 스코프에 있습니다."

#: src/names/scopes.md:200
msgid ""
"As a [_TraitBound_](../trait-bounds.md) the declared lifetimes are in scope "
"within the bound type path."
msgstr "[_트레잇바운드_](../trait-bounds.md)으로서 선언된 라이프타임은 바운드 타입 경로 내에서 스코프에 있습니다."

#: src/names/scopes.md:201
msgid ""
"As a [_BareFunctionType_](../types/function-pointer.md) the declared "
"lifetimes are in scope within the function parameters and return type."
msgstr "[_Bare함수타입_](../types/function-pointer.md)으로서 선언된 라이프타임은 함수 매개변수와 반환 타입 내에서 스코프에 있습니다."

#: src/names/scopes.md:207
msgid "// 'a is in scope in both the type and the type bounds.\n"
msgstr "// 'a는 타입과 타입 바운드 모두에서 스코프에 있습니다.\n"

#: src/names/scopes.md:212
msgid "// 'a is in scope within the bound.\n"
msgstr "// 'a는 바운드 내에서 스코프에 있습니다.\n"

#: src/names/scopes.md:219
msgid "// 'a is in scope in both the parameters and return type.\n"
msgstr "// 'a는 매개변수와 반환 타입 모두에서 스코프에 있습니다.\n"

#: src/names/scopes.md:224
msgid "Impl trait restrictions"
msgstr "Impl 트레잇 제약"

#: src/names/scopes.md:228
msgid ""
"[Impl trait](../types/impl-trait.md) types can only reference lifetimes "
"declared on a function or implementation."
msgstr "[Impl 트레잇](../types/impl-trait.md) 타입은 함수나 구현에 선언된 라이프타임만 참조할 수 있습니다."

#: src/names/scopes.md:247
msgid ""
"// The `impl Trait2` here is not allowed to refer to 'b but it is allowed "
"to\n"
"// refer to 'a.\n"
msgstr ""
"// 여기의 `impl Trait2`는 'b를 참조할 수 없지만 'a를 참조하는 것은\n"
"// 허용됩니다.\n"

#: src/names/scopes.md:258
msgid "Loop label scopes"
msgstr "루프 레이블 스코프"

#: src/names/scopes.md:262
msgid ""
"[Loop labels](../expressions/loop-expr.md#loop-labels) may be declared by a "
"[loop expression](../expressions/loop-expr.md). The scope of a loop label is "
"from the point it is declared till the end of the loop expression. The scope "
"does not extend into [items](../items.md), [closures](../expressions/closure-"
"expr.md), [async blocks](../expressions/block-expr.md#async-blocks), [const "
"arguments](../items/generics.md#const-generics), [const contexts](../"
"const_eval.md#const-context), and the iterator expression of the defining "
"[`for` loop](../expressions/loop-expr.md#iterator-loops)."
msgstr "[루프 레이블](../expressions/loop-expr.md#loop-labels)은 [루프 표현식](../expressions/loop-expr.md)에 의해 선언될 수 있습니다. 루프 레이블의 스코프는 선언된 지점부터 루프 표현식이 끝날 때까지입니다. 스코프는 [아이템](../items.md), [클로저](../expressions/closure-expr.md), [비동기 블록](../expressions/block-expr.md#async-blocks), [상수 인수](../items/generics.md#const-generics), [const 컨텍스트](../const_eval.md#const-context), 그리고 정의하는 [`for` 루프](../expressions/loop-expr.md#iterator-loops)의 반복자 표현식으로 확장되지 않습니다."

#: src/names/scopes.md:272
msgid ""
"// Using 'a here would be an error.\n"
"        // break 'a;\n"
msgstr ""
"// 여기서 'a를 사용하는 것은 오류입니다.\n"
"        // break 'a;\n"

#: src/names/scopes.md:276
msgid "// The label is in scope for the expression of `while` loops.\n"
msgstr "// 레이블은 `while` 루프의 표현식에 대한 스코프에 있습니다.\n"

#: src/names/scopes.md:278 src/names/scopes.md:279
msgid "// Loop does not run.\n"
msgstr "// 루프가 실행되지 않습니다.\n"

#: src/names/scopes.md:280
msgid "// The label is not in scope in the defining `for` loop:\n"
msgstr "// 레이블은 정의하는 `for` 루프에서 스코프에 있지 않습니다:\n"

#: src/names/scopes.md:283
msgid ""
"// This will break the outer loop, skipping the inner loop and stopping\n"
"    // the outer loop.\n"
msgstr ""
"// 이것은 외부 루프를 중단하여 내부 루프를 건너뛰고\n"
"    // 외부 루프를 멈춥니다.\n"

#: src/names/scopes.md:286
msgid "// This does not run.\n"
msgstr "// 이것은 실행되지 않습니다.\n"

#: src/names/scopes.md:288
msgid "// This does not run, either.\n"
msgstr "// 이것도 실행되지 않습니다.\n"

#: src/names/scopes.md:295
msgid ""
"Loop labels may shadow labels of the same name in outer scopes. References "
"to a label refer to the closest definition."
msgstr "루프 레이블은 외부 스코프에 있는 같은 이름의 레이블을 가릴 수 있습니다. 레이블에 대한 참조는 가장 가까운 정의를 가리킵니다."

#: src/names/scopes.md:299
msgid "// Loop label shadowing example.\n"
msgstr "// 루프 레이블 가림 예제.\n"

#: src/names/scopes.md:302
msgid ""
"// This terminates the inner loop, but the outer loop continues to run.\n"
msgstr "// 이것은 내부 루프를 종료하지만, 외부 루프는 계속 실행됩니다.\n"

#: src/names/scopes.md:310
msgid "Prelude scopes"
msgstr "프렐류드 스코프"

#: src/names/scopes.md:314
msgid ""
"[Preludes](preludes.md) bring entities into scope of every module. The "
"entities are not members of the module, but are implicitly queried during "
"[name resolution](name-resolution.md)."
msgstr "[프렐류드](preludes.md)는 엔티티를 모든 모듈의 스코프로 가져옵니다. 엔티티는 모듈의 멤버는 아니지만, [이름 해석](name-resolution.md) 중에 암시적으로 조회됩니다."

#: src/names/scopes.md:319
msgid "The prelude names may be shadowed by declarations in a module."
msgstr "프렐류드 이름은 모듈 내의 선언에 의해 가려질 수 있습니다."

#: src/names/scopes.md:323
msgid ""
"The preludes are layered such that one shadows another if they contain "
"entities of the same name. The order that preludes may shadow other preludes "
"is the following where earlier entries may shadow later ones:"
msgstr "프렐류드는 계층화되어 있어 동일한 이름의 엔티티를 포함할 경우 하나가 다른 하나를 가립니다. 프렐류드가 다른 프렐류드를 가릴 수 있는 순서는 다음과 같으며, 앞의 항목이 뒤의 항목을 가릴 수 있습니다:"

#: src/names/scopes.md:326
msgid "[Extern prelude](preludes.md#extern-prelude)"
msgstr "[외부 프렐류드](preludes.md#extern-prelude)"

#: src/names/scopes.md:327
msgid "[Tool prelude](preludes.md#tool-prelude)"
msgstr "[도구 프렐류드](preludes.md#tool-prelude)"

#: src/names/scopes.md:328
msgid "[`macro_use` prelude](preludes.md#macro_use-prelude)"
msgstr "[`macro_use` 프렐류드](preludes.md#macro_use-prelude)"

#: src/names/scopes.md:329
msgid "[Standard library prelude](preludes.md#standard-library-prelude)"
msgstr "[표준 라이브러리 프렐류드](preludes.md#standard-library-prelude)"

#: src/names/scopes.md:330
msgid "[Language prelude](preludes.md#language-prelude)"
msgstr "[언어 프렐류드](preludes.md#language-prelude)"

#: src/names/scopes.md:334
msgid "`macro_rules` scopes"
msgstr "`macro_rules` 스코프"

#: src/names/scopes.md:336
msgid ""
"The scope of `macro_rules` macros is described in the [Macros By Example](../"
"macros-by-example.md) chapter. The behavior depends on the use of the "
"[`macro_use`](../macros-by-example.md#the-macro_use-attribute) and "
"[`macro_export`](../macros-by-example.md#path-based-scope) attributes."
msgstr ""
"`macro_rules` 매크로의 스코프는 [예제를 통한 매크로](../macros-by-example.md) 장에 설명되어 있습니다. "
"이 동작은 [`macro_use`](../macros-by-example.md#the-macro_use-attribute) 및 "
"[`macro_export`](../macros-by-example.md#path-based-scope) 속성의 사용에 따라 달라집니다."

#: src/names/scopes.md:345
msgid ""
"[Derive macro helper attributes](../procedural-macros.md#derive-macro-helper-"
"attributes) are in scope in the item where their corresponding [`derive` "
"attribute](../attributes/derive.md) is specified. The scope extends from "
"just after the `derive` attribute to the end of the item. <!-- Note: Not "
"strictly true, see https://github.com/rust-lang/rust/issues/79202, but this "
"is the intention. -->"
msgstr ""
"[Derive 매크로 도우미 속성](../procedural-macros.md#derive-macro-helper-attributes)은 "
"해당 [`derive` 속성](../attributes/derive.md)이 지정된 아이템 내에서 스코프에 있습니다. "
"스코프는 `derive` 속성 직후부터 아이템의 끝까지 확장됩니다. <!-- 참고: 엄격하게 사실은 아니지만, "
"https://github.com/rust-lang/rust/issues/79202를 참조하십시오. 이것이 의도된 바입니다. -->"

#: src/names/scopes.md:350
msgid "Helper attributes shadow other attributes of the same name in scope."
msgstr "도우미 속성은 스코프 내의 같은 이름을 가진 다른 속성을 가립니다."

#: src/names/scopes.md:354
msgid "`Self` scope"
msgstr "`Self` 스코프"

#: src/names/scopes.md:358
msgid ""
"Although [`Self`](../paths.md#self-1) is a keyword with special meaning, it "
"interacts with name resolution in a way similar to normal names."
msgstr ""
"[`Self`](../paths.md#self-1)는 특별한 의미를 가진 키워드이지만, "
"일반 이름과 유사한 방식으로 이름 확인과 상호 작용합니다."

#: src/names/scopes.md:362
msgid ""
"The implicit `Self` type in the definition of a [struct](../items/"
"structs.md), [enum](../items/enumerations.mdr), [union](../items/unions.md), "
"[trait](../items/traits.md), or [implementation](../items/"
"implementations.md) is treated similarly to a [generic parameter](#generic-"
"parameter-scopes), and is in scope in the same way as a generic type "
"parameter."
msgstr ""
"[구조체](../items/structs.md), [열거형](../items/enumerations.mdr), "
"[유니온](../items/unions.md), [트레잇](../items/traits.md), 또는 "
"[구현](../items/implementations.md)의 정의에 있는 암시적 `Self` 타입은 "
"[제네릭 매개변수](#generic-parameter-scopes)와 유사하게 처리되며, "
"제네릭 타입 매개변수와 동일한 방식으로 스코프에 있습니다."

#: src/names/scopes.md:366
msgid ""
"The implicit `Self` constructor in the value [namespace](namespaces.md) of "
"an [implementation](../items/implementations.md) is in scope within the body "
"of the implementation (the implementation's [associated items](../items/"
"associated-items.md))."
msgstr ""
"[구현](../items/implementations.md)의 값 [네임스페이스](namespaces.md)에 있는 "
"암시적 `Self` 생성자는 구현의 본문(구현의 [연관 아이템](../items/associated-items.md)) 내에서 스코프에 있습니다."

#: src/names/scopes.md:369
msgid "// Self type within struct definition.\n"
msgstr "// 구조체 정의 내의 Self 타입.\n"

#: src/names/scopes.md:373
msgid "// Self type within generic parameters.\n"
msgstr "// 제네릭 매개변수 내의 Self 타입.\n"

#: src/names/scopes.md:376
msgid "// Self value constructor within an implementation.\n"
msgstr "// 구현 내의 Self 값 생성자.\n"

#: src/names/scopes.md:380
msgid "// Self type\n"
msgstr "// Self 타입\n"

#: src/names/scopes.md:381
msgid "// Self value constructor\n"
msgstr "// Self 값 생성자\n"

#: src/names/preludes.md:7
msgid ""
"A _prelude_ is a collection of names that are automatically brought into "
"scope of every module in a crate."
msgstr "_프렐류드(prelude)_는 크레이트의 모든 모듈 스코프에 자동으로 도입되는 이름들의 집합입니다."

#: src/names/preludes.md:10
msgid ""
"These prelude names are not part of the module itself: they are implicitly "
"queried during [name resolution](name-resolution.md). For example, even "
"though something like [`Box`](../../alloc/boxed/struct.Box.html) is in scope "
"in every module, you cannot refer to it as `self::Box` because it is not a "
"member of the current module."
msgstr ""
"이러한 프렐류드 이름은 모듈 자체의 일부가 아닙니다. 이들은 [이름 확인](name-resolution.md) 중에 "
"암시적으로 조회됩니다. 예를 들어, [`Box`](../../alloc/boxed/struct.Box.html)와 같은 것이 "
"모든 모듈의 스코프에 있더라도, 현재 모듈의 멤버가 아니기 때문에 `self::Box`로 참조할 수 없습니다."

#: src/names/preludes.md:17
msgid "There are several different preludes:"
msgstr "여러 가지 다른 프렐류드가 있습니다:"

#: src/names/preludes.md:19
msgid "[Standard library prelude](#standard-library-prelude)"
msgstr "[표준 라이브러리 프렐류드](#standard-library-prelude)"

#: src/names/preludes.md:20
msgid "[Extern prelude](#extern-prelude)"
msgstr "[외부 프렐류드](#extern-prelude)"

#: src/names/preludes.md:21
msgid "[Language prelude](#language-prelude)"
msgstr "[언어 프렐류드](#language-prelude)"

#: src/names/preludes.md:22
msgid "[`macro_use` prelude](#macro_use-prelude)"
msgstr "[`macro_use` 프렐류드](#macro_use-prelude)"

#: src/names/preludes.md:23
msgid "[Tool prelude](#tool-prelude)"
msgstr "[도구 프렐류드](#tool-prelude)"

#: src/names/preludes.md:27
msgid "Standard library prelude"
msgstr "표준 라이브러리 프렐류드"

#: src/names/preludes.md:31
msgid ""
"Each crate has a standard library prelude, which consists of the names from "
"a single standard library module."
msgstr "각 크레이트에는 단일 표준 라이브러리 모듈의 이름으로 구성된 표준 라이브러리 프렐류드가 있습니다."

#: src/names/preludes.md:35
msgid ""
"The module used depends on the crate's edition, and on whether the [`no_std` "
"attribute](#the-no_std-attribute) is applied to the crate:"
msgstr ""
"사용되는 모듈은 크레이트의 에디션과 크레이트에 [`no_std` 속성](#the-no_std-attribute)이 "
"적용되었는지 여부에 따라 달라집니다."

#: src/names/preludes.md:37
msgid "Edition"
msgstr "에디션"

#: src/names/preludes.md:37
msgid "`no_std` not applied"
msgstr "`no_std` 적용되지 않음"

#: src/names/preludes.md:37
msgid "`no_std` applied"
msgstr "`no_std` 적용됨"

#: src/names/preludes.md:39
msgid "2015"
msgstr "2015"

#: src/names/preludes.md:39
msgid "[`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html)"
msgstr "[`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html)"

#: src/names/preludes.md:39
msgid "[`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html)"
msgstr "[`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html)"

#: src/names/preludes.md:40
msgid "2018"
msgstr "2018"

#: src/names/preludes.md:40
msgid "[`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html)"
msgstr "[`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html)"

#: src/names/preludes.md:40
msgid "[`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html)"
msgstr "[`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html)"

#: src/names/preludes.md:41
msgid "2021"
msgstr "2021"

#: src/names/preludes.md:41
msgid "[`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html)"
msgstr "[`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html)"

#: src/names/preludes.md:41
msgid "[`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html)"
msgstr "[`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html)"

#: src/names/preludes.md:42
msgid "2024"
msgstr "2024"

#: src/names/preludes.md:42
msgid "[`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html)"
msgstr "[`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html)"

#: src/names/preludes.md:42
msgid "[`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html)"
msgstr "[`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html)"

#: src/names/preludes.md:45
msgid "**Note**:"
msgstr "**참고**:"

#: src/names/preludes.md:47
msgid ""
"[`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) and "
"[`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html) have the "
"same contents as [`std::prelude::v1`](../../std/prelude/v1/index.html)."
msgstr ""
"[`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) 및 "
"[`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html)은 "
"[`std::prelude::v1`](../../std/prelude/v1/index.html)과 동일한 내용을 가집니다."

#: src/names/preludes.md:49
msgid ""
"[`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) and "
"[`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html) have "
"the same contents as [`core::prelude::v1`](../../core/prelude/v1/index.html)."
msgstr ""
"[`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) 및 "
"[`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html)은 "
"[`core::prelude::v1`](../../core/prelude/v1/index.html)과 동일한 내용을 가집니다."

#: src/names/preludes.md:53
msgid "Extern prelude"
msgstr "외부 프렐류드"

#: src/names/preludes.md:57
msgid ""
"External crates imported with [`extern crate`](../items/extern-crates.md) in "
"the root module or provided to the compiler (as with the `--extern` flag "
"with `rustc`) are added to the _extern prelude_. If imported with an alias "
"such as `extern crate orig_name as new_name`, then the symbol `new_name` is "
"instead added to the prelude."
msgstr ""
"루트 모듈에서 [`extern crate`](../items/extern-crates.md)로 임포트되거나 "
"컴파일러에 제공된(예: `rustc`의 `--extern` 플래그) 외부 크레이트들은 _외부 프렐류드_에 추가됩니다. "
"만약 `extern crate orig_name as new_name`과 같이 별칭으로 임포트했다면, "
"대신 `new_name` 심볼이 프렐류드에 추가됩니다."

#: src/names/preludes.md:64
msgid ""
"The [`core`](../../core/index.html) crate is always added to the extern "
"prelude."
msgstr "[`core`](../../core/index.html) 크레이트는 항상 외부 프렐류드에 추가됩니다."

#: src/names/preludes.md:68
msgid ""
"The [`std`](../../std/index.html) crate is added as long as the [`no_std` "
"attribute](#the-no_std-attribute) is not specified in the crate root."
msgstr ""
"크레이트 루트에 [`no_std` 속성](#the-no_std-attribute)이 지정되지 않은 한 "
"[`std`](../../std/index.html) 크레이트가 추가됩니다."

#: src/names/preludes.md:72
msgid ""
"**Edition differences**: In the 2015 edition, crates in the extern prelude "
"cannot be referenced via [use declarations](../items/use-declarations.md), "
"so it is generally standard practice to include `extern crate` declarations "
"to bring them into scope."
msgstr ""
"**에디션 차이**: 2015 에디션에서는 외부 프렐류드에 있는 크레이트들을 "
"[use 선언](../items/use-declarations.md)을 통해 참조할 수 없습니다. 따라서 일반적으로 "
"이들을 스코프로 가져오기 위해 `extern crate` 선언을 포함하는 것이 표준적인 관례입니다."

#: src/names/preludes.md:76
msgid ""
"Beginning in the 2018 edition, [use declarations](../items/use-"
"declarations.md) can reference crates in the extern prelude, so it is "
"considered unidiomatic to use `extern crate`."
msgstr ""
"2018 에디션부터 [use 선언](../items/use-declarations.md)은 외부 프렐류드의 "
"크레이트를 참조할 수 있으므로, `extern crate`를 사용하는 것은 관용적이지(unidiomatic) 않은 것으로 간주됩니다."

#: src/names/preludes.md:79
msgid ""
"**Note**: Additional crates that ship with `rustc`, such as [`alloc`](../../"
"alloc/index.html), and [`test`](../../test/index.html), are not "
"automatically included with the `--extern` flag when using Cargo. They must "
"be brought into scope with an `extern crate` declaration, even in the 2018 "
"edition."
msgstr ""
"**참고**: Cargo를 사용할 때 [`alloc`](../../alloc/index.html) 및 [`test`](../../test/index.html)와 같이 "
"`rustc`와 함께 제공되는 추가 크레이트들은 `--extern` 플래그로 자동으로 포함되지 않습니다. "
"이들은 2018 에디션에서도 `extern crate` 선언을 통해 스코프로 가져와야 합니다."

#: src/names/preludes.md:89
msgid ""
"Cargo does bring in `proc_macro` to the extern prelude for proc-macro crates "
"only."
msgstr "Cargo는 오직 절차적 매크로(proc-macro) 크레이트에 대해서만 `proc_macro`를 외부 프렐류드로 가져옵니다."

#: src/names/preludes.md:99
msgid "The `no_std` attribute"
msgstr "`no_std` 속성"

#: src/names/preludes.md:103
msgid ""
"By default, the standard library is automatically included in the crate root "
"module. The [`std`](../../std/index.html) crate is added to the root, along "
"with an implicit [`macro_use` attribute](../macros-by-example.md#the-"
"macro_use-attribute) pulling in all macros exported from `std` into the "
"[`macro_use` prelude](#macro_use-prelude). Both [`core`](../../core/"
"index.html) and [`std`](../../std/index.html) are added to the [extern "
"prelude](#extern-prelude)."
msgstr ""
"기본적으로 표준 라이브러리는 크레이트 루트 모듈에 자동으로 포함됩니다. "
"[`std`](../../std/index.html) 크레이트가 루트에 추가되며, 암시적인 "
"[`macro_use` 속성](../macros-by-example.md#the-macro_use-attribute)과 함께 "
"`std`에서 내보낸 모든 매크로를 [`macro_use` 프렐류드](#macro_use-prelude)로 가져옵니다. "
"[`core`](../../core/index.html)와 [`std`](../../std/index.html) 모두 "
"[외부 프렐류드](#extern-prelude)에 추가됩니다."

#: src/names/preludes.md:111
msgid ""
"The _`no_std` [attribute](../attributes.md)_ may be applied at the crate "
"level to prevent the [`std`](../../std/index.html) crate from being "
"automatically added into scope."
msgstr ""
"[`std`](../../std/index.html) 크레이트가 자동으로 스코프에 추가되는 것을 방지하기 위해 "
"크레이트 레벨에서 _`no_std` [속성](../attributes.md)_을 적용할 수 있습니다."

#: src/names/preludes.md:114
msgid "It does three things:"
msgstr "이 속성은 다음 세 가지 일을 수행합니다:"

#: src/names/preludes.md:118
msgid ""
"Prevents `std` from being added to the [extern prelude](#extern-prelude)."
msgstr "`std`가 [외부 프렐류드](#extern-prelude)에 추가되는 것을 방지합니다."

#: src/names/preludes.md:121
msgid ""
"Affects which module is used to make up the [standard library prelude]"
"(#standard-library-prelude) (as described above)."
msgstr ""
"(위에서 설명한 대로) 어떤 모듈이 [표준 라이브러리 프렐류드](#standard-library-prelude)를 "
"구성하는 데 사용될지에 영향을 줍니다."

#: src/names/preludes.md:124
msgid ""
"Injects the [`core`](../../core/index.html) crate into the crate root "
"instead of [`std`](../../std/index.html), and pulls in all macros exported "
"from `core` in the [`macro_use` prelude](#macro_use-prelude)."
msgstr ""
"[`std`](../../std/index.html) 대신 [`core`](../../core/index.html) 크레이트를 "
"크레이트 루트에 주입하고, `core`에서 내보낸 모든 매크로를 "
"[`macro_use` 프렐류드](#macro_use-prelude)로 가져옵니다."

#: src/names/preludes.md:127
msgid ""
"**Note**: Using the core prelude over the standard prelude is useful when "
"either the crate is targeting a platform that does not support the standard "
"library or is purposefully not using the capabilities of the standard "
"library. Those capabilities are mainly dynamic memory allocation (e.g. `Box` "
"and `Vec`) and file and network capabilities (e.g. `std::fs` and `std::io`)."
msgstr ""
"**참고**: 표준 프렐류드 대신 코어 프렐류드를 사용하는 것은 크레이트가 표준 라이브러리를 "
"지원하지 않는 플랫폼을 대상으로 하거나, 의도적으로 표준 라이브러리의 기능을 사용하지 "
"않으려는 경우에 유용합니다. 이러한 기능들은 주로 동적 메모리 할당(예: `Box` 및 `Vec`), "
"파일 및 네트워크 기능(예: `std::fs` 및 `std::io`)입니다."

#: src/names/preludes.md:135
msgid ""
"_**Warning:**_ Using `no_std` does not prevent the standard library from "
"being linked in. It is still valid to put `extern crate std;` into the crate "
"and dependencies can also link it in."
msgstr ""
"_**경고:**_ `no_std`를 사용한다고 해서 표준 라이브러리가 링크되는 것을 방지하지는 않습니다. "
"크레이트에 `extern crate std;`를 넣는 것은 여전히 유효하며, 의존성(dependencies)들이 "
"이를 링크할 수도 있습니다."

#: src/names/preludes.md:143
msgid "Language prelude"
msgstr "언어 프렐류드"

#: src/names/preludes.md:147
msgid ""
"The language prelude includes names of types and attributes that are built-"
"in to the language. The language prelude is always in scope."
msgstr ""
"언어 프렐류드에는 언어에 내장된 타입과 속성들의 이름이 포함됩니다. "
"언어 프렐류드는 항상 스코프에 있습니다."

#: src/names/preludes.md:152
msgid "It includes the following:"
msgstr "여기에는 다음이 포함됩니다:"

#: src/names/preludes.md:154
msgid "[Type namespace](namespaces.md)"
msgstr "[타입 네임스페이스](namespaces.md)"

#: src/names/preludes.md:155
msgid "[Boolean type](../types/boolean.md) --- `bool`"
msgstr "[불리언 타입](../types/boolean.md) --- `bool`"

#: src/names/preludes.md:156
msgid "[Textual types](../types/textual.md) --- `char` and `str`"
msgstr "[텍스트 타입](../types/textual.md) --- `char` 및 `str`"

#: src/names/preludes.md:157
msgid ""
"[Integer types](../types/numeric.md#integer-types) --- `i8`, `i16`, `i32`, "
"`i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`"
msgstr ""
"[정수 타입](../types/numeric.md#integer-types) --- `i8`, `i16`, `i32`, "
"`i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`"

#: src/names/preludes.md:158
msgid ""
"[Machine-dependent integer types](../types/numeric.md#machine-dependent-"
"integer-types) --- `usize` and `isize`"
msgstr ""
"[머신 의존적 정수 타입](../types/numeric.md#machine-dependent-integer-types) --- `usize` 및 `isize`"

#: src/names/preludes.md:159
msgid ""
"[floating-point types](../types/numeric.md#floating-point-types) --- `f32` "
"and `f64`"
msgstr ""
"[부동 소수점 타입](../types/numeric.md#floating-point-types) --- `f32` 및 `f64`"

#: src/names/preludes.md:160
msgid "[Macro namespace](namespaces.md)"
msgstr "[매크로 네임스페이스](namespaces.md)"

#: src/names/preludes.md:165
msgid "`macro_use` prelude"
msgstr "`macro_use` 프렐류드"

#: src/names/preludes.md:169
msgid ""
"The `macro_use` prelude includes macros from external crates that were "
"imported by the [`macro_use` attribute](../macros-by-example.md#the-"
"macro_use-attribute) applied to an [`extern crate`](../items/extern-"
"crates.md)."
msgstr ""
"`macro_use` 프렐류드에는 [`extern crate`](../items/extern-crates.md)에 적용된 "
"[`macro_use` 속성](../macros-by-example.md#the-macro_use-attribute)을 통해 "
"임포트된 외부 크레이트의 매크로들이 포함됩니다."

#: src/names/preludes.md:174
msgid "Tool prelude"
msgstr "도구 프렐류드"

#: src/names/preludes.md:178
msgid ""
"The tool prelude includes tool names for external tools in the [type "
"namespace](namespaces.md). See the [tool attributes](../attributes.md#tool-"
"attributes) section for more details."
msgstr ""
"도구 프렐류드에는 [타입 네임스페이스](namespaces.md)에 있는 외부 도구들의 이름이 포함됩니다. "
"자세한 내용은 [도구 속성](../attributes.md#tool-attributes) 섹션을 참조하십시오."

#: src/names/preludes.md:183
msgid "The `no_implicit_prelude` attribute"
msgstr "`no_implicit_prelude` 속성"

#: src/names/preludes.md:187
msgid ""
"The _`no_implicit_prelude` [attribute](../attributes.md)_ may be applied at "
"the crate level or on a module to indicate that it should not automatically "
"bring the [standard library prelude](#standard-library-prelude), [extern "
"prelude](#extern-prelude), or [tool prelude](#tool-prelude) into scope for "
"that module or any of its descendants."
msgstr ""
"_`no_implicit_prelude` [속성](../attributes.md)_은 크레이트 레벨이나 모듈에 적용되어, "
"해당 모듈 또는 그 하위 모듈들의 스코프에 [표준 라이브러리 프렐류드](#standard-library-prelude), "
"[외부 프렐류드](#extern-prelude), 또는 [도구 프렐류드](#tool-prelude)를 "
"자동으로 가져오지 않아야 함을 나타낼 수 있습니다."

#: src/names/preludes.md:194
msgid ""
"This attribute does not affect the [language prelude](#language-prelude)."
msgstr "이 속성은 [언어 프렐류드](#language-prelude)에는 영향을 주지 않습니다."

#: src/names/preludes.md:198
msgid ""
"**Edition differences**: In the 2015 edition, the `no_implicit_prelude` "
"attribute does not affect the [`macro_use` prelude](#macro_use-prelude), and "
"all macros exported from the standard library are still included in the "
"`macro_use` prelude. Starting in the 2018 edition, it will remove the "
"`macro_use` prelude."
msgstr ""
"**에디션 차이**: 2015 에디션에서 `no_implicit_prelude` 속성은 "
"[`macro_use` 프렐류드](#macro_use-prelude)에 영향을 주지 않으며, 표준 라이브러리에서 "
"내보낸 모든 매크로가 여전히 `macro_use` 프렐류드에 포함됩니다. 2018 에디션부터는 "
"`macro_use` 프렐류드도 제거합니다."

#: src/paths.md:7
msgid ""
"A _path_ is a sequence of one or more path segments separated by `::` "
"tokens. Paths are used to refer to [items](items.md), values, [types]"
"(types.md), [macros](macros.md), and [attributes](attributes.md)."
msgstr ""
"_경로(path)_는 `::` 토큰으로 구분된 하나 이상의 경로 세그먼트 시퀀스입니다. "
"경로는 [아이템](items.md), 값, [타입](types.md), [매크로](macros.md) 및 "
"[속성](attributes.md)을 참조하는 데 사용됩니다."

#: src/paths.md:10
msgid "Two examples of simple paths consisting of only identifier segments:"
msgstr "식별자 세그먼트로만 구성된 단순 경로의 두 가지 예:"

#: src/paths.md:18
msgid "Types of paths"
msgstr "경로의 종류"

#: src/paths.md:22
msgid "Simple Paths"
msgstr "단순 경로"

#: src/paths.md:26
msgid ""
"**<sup>Syntax</sup>**  \n"
"_SimplePath_ :  \n"
"   `::`<sup>?</sup> _SimplePathSegment_ (`::` _SimplePathSegment_)<sup>\\*</"
"sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_SimplePath_ :  \n"
"   `::`<sup>?</sup> _SimplePathSegment_ (`::` _SimplePathSegment_)<sup>*</sup>"

#: src/paths.md:30
msgid ""
"_SimplePathSegment_ :  \n"
"   [IDENTIFIER](identifiers.md) | `super` | `self` | `crate` | `$crate`"
msgstr ""
"_SimplePathSegment_ :  \n"
"   [IDENTIFIER](identifiers.md) | `super` | `self` | `crate` | `$crate`"

#: src/paths.md:35
msgid ""
"Simple paths are used in [visibility](visibility-and-privacy.md) markers, "
"[attributes](attributes.md), [macros](macros-by-example.md), and [`use`]"
"(items/use-declarations.md) items. For example:"
msgstr ""
"단순 경로는 [가시성](visibility-and-privacy.md) 표시어, [속성](attributes.md), "
"[매크로](macros-by-example.md) 및 [`use`](items/use-declarations.md) 아이템에서 사용됩니다. "
"예를 들어:"

#: src/paths.md:48
msgid "Paths in expressions"
msgstr "표현식에서의 경로"

#: src/paths.md:52
msgid ""
"**<sup>Syntax</sup>**  \n"
"_PathInExpression_ :  \n"
"   `::`<sup>?</sup> _PathExprSegment_ (`::` _PathExprSegment_)<sup>\\*</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_PathInExpression_ :  \n"
"   `::`<sup>?</sup> _PathExprSegment_ (`::` _PathExprSegment_)<sup>*</sup>"

#: src/paths.md:56
msgid ""
"_PathExprSegment_ :  \n"
"   _PathIdentSegment_ (`::` _GenericArgs_)<sup>?</sup>"
msgstr ""
"_PathExprSegment_ :  \n"
"   _PathIdentSegment_ (`::` _GenericArgs_)<sup>?</sup>"

#: src/paths.md:59
msgid ""
"_PathIdentSegment_ :  \n"
"   [IDENTIFIER](identifiers.md) | `super` | `self` | `Self` | `crate` | "
"`$crate`"
msgstr ""
"_PathIdentSegment_ :  \n"
"   [IDENTIFIER](identifiers.md) | `super` | `self` | `Self` | `crate` | "
"`$crate`"

#: src/paths.md:62
msgid ""
"_GenericArgs_ :  \n"
"      `<` `>`  \n"
"   | `<` ( _GenericArg_ `,` )<sup>\\*</sup> _GenericArg_ `,`<sup>?</sup> `>`"
msgstr ""
"_GenericArgs_ :  \n"
"      `<` `>`  \n"
"   | `<` ( _GenericArg_ `,` )<sup>*</sup> _GenericArg_ `,`<sup>?</sup> `>`"

#: src/paths.md:66
msgid ""
"_GenericArg_ :  \n"
"   [_Lifetime_](trait-bounds.md) | [_Type_](types.md#type-expressions) | "
"_GenericArgsConst_ | _GenericArgsBinding_ | _GenericArgsBounds_"
msgstr ""
"_GenericArg_ :  \n"
"   [_Lifetime_](trait-bounds.md) | [_Type_](types.md#type-expressions) | "
"_GenericArgsConst_ | _GenericArgsBinding_ | _GenericArgsBounds_"

#: src/paths.md:69
msgid ""
"_GenericArgsConst_ :  \n"
"      [_BlockExpression_](expressions/block-expr.md)  \n"
"   | [_LiteralExpression_](expressions/literal-expr.md)  \n"
"   | `-` [_LiteralExpression_](expressions/literal-expr.md)  \n"
"   | [_SimplePathSegment_](#simple-paths)"
msgstr ""
"_GenericArgsConst_ :  \n"
"      [_BlockExpression_](expressions/block-expr.md)  \n"
"   | [_LiteralExpression_](expressions/literal-expr.md)  \n"
"   | `-` [_LiteralExpression_](expressions/literal-expr.md)  \n"
"   | [_SimplePathSegment_](#simple-paths)"

#: src/paths.md:75
msgid ""
"_GenericArgsBinding_ :  \n"
"   [IDENTIFIER](identifiers.md) _GenericArgs_<sup>?</sup> `=` [_Type_]"
"(types.md#type-expressions)"
msgstr ""
"_GenericArgsBinding_ :  \n"
"   [IDENTIFIER](identifiers.md) _GenericArgs_<sup>?</sup> `=` [_Type_](types.md#type-expressions)"

#: src/paths.md:78
msgid ""
"_GenericArgsBounds_ :  \n"
"   [IDENTIFIER](identifiers.md) _GenericArgs_<sup>?</sup> `:` "
"[_TypeParamBounds_](trait-bounds.md)"
msgstr ""
"_GenericArgsBounds_ :  \n"
"   [IDENTIFIER](identifiers.md) _GenericArgs_<sup>?</sup> `:` [_TypeParamBounds_](trait-bounds.md)"

#: src/paths.md:83
msgid ""
"Paths in expressions allow for paths with generic arguments to be specified. "
"They are used in various places in [expressions](expressions.md) and "
"[patterns](patterns.md)."
msgstr ""
"표현식에서의 경로는 제네릭 인자가 포함된 경로를 지정할 수 있게 해줍니다. "
"이들은 [표현식](expressions.md)과 [패턴](patterns.md)의 다양한 곳에서 사용됩니다."

#: src/paths.md:88
msgid ""
"The `::` token is required before the opening `<` for generic arguments to "
"avoid ambiguity with the less-than operator. This is colloquially known as "
"\"turbofish\" syntax."
msgstr ""
"제네릭 인자를 위한 여는 `<` 앞에는 작음(less-than) 연산자와의 모호성을 피하기 위해 "
"`::` 토큰이 필요합니다. 이것은 구어체로 \"터보피쉬(turbofish)\" 구문이라고 알려져 있습니다."

#: src/paths.md:98
msgid ""
"The order of generic arguments is restricted to lifetime arguments, then "
"type arguments, then const arguments, then equality constraints."
msgstr ""
"제네릭 인자의 순서는 라이프타임 인자, 그 다음 타입 인자, 그 다음 상수 인자, "
"그 다음 등치 제약 조건(equality constraints) 순으로 제한됩니다."

#: src/paths.md:103
msgid ""
"Const arguments must be surrounded by braces unless they are a [literal]"
"(expressions/literal-expr.md) or a single segment path."
msgstr ""
"상수 인자가 [리터럴](expressions/literal-expr.md)이거나 단일 세그먼트 경로가 아닌 경우에는 "
"중괄호로 둘러싸야 합니다."

#: src/paths.md:108
msgid ""
"The synthetic type parameters corresponding to `impl Trait` types are "
"implicit, and these cannot be explicitly specified."
msgstr ""
"`impl Trait` 타입에 대응하는 합성 타입 파라미터(synthetic type parameters)는 "
"암시적이며, 이를 명시적으로 지정할 수 없습니다."

#: src/paths.md:113
msgid "Qualified paths"
msgstr "정규화된 경로(Qualified paths)"

#: src/paths.md:117
msgid ""
"**<sup>Syntax</sup>**  \n"
"_QualifiedPathInExpression_ :  \n"
"   _QualifiedPathType_ (`::` _PathExprSegment_)<sup>+</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_QualifiedPathInExpression_ :  \n"
"   _QualifiedPathType_ (`::` _PathExprSegment_)<sup>+</sup>"

#: src/paths.md:121
msgid ""
"_QualifiedPathType_ :  \n"
"   `<` [_Type_](types.md#type-expressions) (`as` _TypePath_)<sup>?</sup> `>`"
msgstr ""
"_QualifiedPathType_ :  \n"
"   `<` [_Type_](types.md#type-expressions) (`as` _TypePath_)<sup>?</sup> `>`"

#: src/paths.md:124
msgid ""
"_QualifiedPathInType_ :  \n"
"   _QualifiedPathType_ (`::` _TypePathSegment_)<sup>+</sup>"
msgstr ""
"_QualifiedPathInType_ :  \n"
"   _QualifiedPathType_ (`::` _TypePathSegment_)<sup>+</sup>"

#: src/paths.md:129
msgid ""
"Fully qualified paths allow for disambiguating the path for [trait "
"implementations](items/implementations.md#trait-implementations) and for "
"specifying [canonical paths](#canonical-paths). When used in a type "
"specification, it supports using the type syntax specified below."
msgstr ""
"완전하게 정규화된 경로(Fully qualified paths)는 [트레잇 구현](items/implementations.md#trait-implementations)에 "
"대한 경로의 모호성을 제거하고 [표준 경로(canonical paths)](#canonical-paths)를 지정할 수 있게 해줍니다. "
"타입 명세에서 사용될 때는 아래에 명시된 타입 구문을 사용하는 것을 지원합니다."

#: src/paths.md:139
msgid "\"T1 f\""
msgstr "\"T1 f\""

#: src/paths.md:143
msgid "\"T2 f\""
msgstr "\"T2 f\""

#: src/paths.md:146
msgid "// Calls the inherent impl.\n"
msgstr "// 내재적 구현(inherent impl)을 호출합니다.\n"

#: src/paths.md:147
msgid "// Calls the T1 trait function.\n"
msgstr "// T1 트레잇 함수를 호출합니다.\n"

#: src/paths.md:148
msgid "// Calls the T2 trait function.\n"
msgstr "// T2 트레잇 함수를 호출합니다.\n"

#: src/paths.md:153
msgid "Paths in types"
msgstr "타입에서의 경로"

#: src/paths.md:157
msgid ""
"**<sup>Syntax</sup>**  \n"
"_TypePath_ :  \n"
"   `::`<sup>?</sup> _TypePathSegment_ (`::` _TypePathSegment_)<sup>\\*</sup>"
msgstr ""
"**<sup>구문</sup>**  \n"
"_TypePath_ :  \n"
"   `::`<sup>?</sup> _TypePathSegment_ (`::` _TypePathSegment_)<sup>*</sup>"

#: src/paths.md:161
msgid ""
"_TypePathSegment_ :  \n"
"   _PathIdentSegment_ (`::`<sup>?</sup> ([_GenericArgs_](#paths-in-"
"expressions) | _TypePathFn_))<sup>?</sup>"
msgstr ""
"_TypePathSegment_ :  \n"
"   _PathIdentSegment_ (`::`<sup>?</sup> ([_GenericArgs_](#paths-in-expressions) | _TypePathFn_))<sup>?</sup>"

#: src/paths.md:164
msgid ""
"_TypePathFn_ :  \n"
"`(` _TypePathFnInputs_<sup>?</sup> `)` (`->` [_TypeNoBounds_](types.md#type-"
"expressions))<sup>?</sup>"
msgstr ""
"_TypePathFn_ :  \n"
"`(` _TypePathFnInputs_<sup>?</sup> `)` (`->` [_TypeNoBounds_](types.md#type-expressions))<sup>?</sup>"

#: src/paths.md:167
msgid ""
"_TypePathFnInputs_ :  \n"
"[_Type_](types.md#type-expressions) (`,` [_Type_](types.md#type-"
"expressions))<sup>\\*</sup> `,`<sup>?</sup>"
msgstr ""
"_TypePathFnInputs_ :  \n"
"[_Type_](types.md#type-expressions) (`,` [_Type_](types.md#type-expressions))<sup>*</sup> `,`<sup>?</sup>"

#: src/paths.md:172
msgid ""
"Type paths are used within type definitions, trait bounds, type parameter "
"bounds, and qualified paths."
msgstr ""
"타입 경로는 타입 정의, 트레잇 바운드, 타입 파라미터 바운드 및 정규화된 경로 내에서 사용됩니다."

#: src/paths.md:177
msgid ""
"Although the `::` token is allowed before the generics arguments, it is not "
"required because there is no ambiguity like there is in _PathInExpression_."
msgstr ""
"제네릭 인자 앞에 `::` 토큰을 사용할 수 있지만, _PathInExpression_에서와 같은 "
"모호성이 없기 때문에 필수사항은 아닙니다."

#: src/paths.md:187
msgid "/*...*/"
msgstr "/*...*/"

#: src/paths.md:198
msgid "Path qualifiers"
msgstr "경로 한정자(Path qualifiers)"

#: src/paths.md:200
msgid ""
"Paths can be denoted with various leading qualifiers to change the meaning "
"of how it is resolved."
msgstr ""
"경로는 해석 방식의 의미를 변경하기 위해 앞에 다양한 한정자를 붙여 표시할 수 있습니다."

#: src/paths.md:209
msgid ""
"Paths starting with `::` are considered to be _global paths_ where the "
"segments of the path start being resolved from a place which differs based "
"on edition. Each identifier in the path must resolve to an item."
msgstr ""
"`::`로 시작하는 경로는 _전역 경로(global paths)_로 간주되며, 경로의 세그먼트가 "
"해석되기 시작하는 위치는 에디션에 따라 다릅니다. 경로의 각 식별자는 아이템으로 해석되어야 합니다."

#: src/paths.md:215
msgid ""
"**Edition Differences**: In the 2015 Edition, identifiers resolve from the "
"\"crate root\" (`crate::` in the 2018 edition), which contains a variety of "
"different items, including external crates, default crates such as `std` or "
"`core`, and items in the top level of the crate (including `use` imports)."
msgstr ""
"**에디션 차이**: 2015 에디션에서 식별자는 \"크레이트 루트(crate root)\"(2018 에디션의 `crate::`)에서 "
"해석됩니다. 여기에는 외부 크레이트, `std` 또는 `core`와 같은 기본 크레이트, "
"그리고 크레이트 최상위 레벨의 아이템들(`use` 임포트 포함)을 포함한 다양한 아이템들이 들어 있습니다."

#: src/paths.md:220
msgid ""
"Beginning with the 2018 Edition, paths starting with `::` resolve from "
"crates in the [extern prelude](names/preludes.md#extern-prelude). That is, "
"they must be followed by the name of a crate."
msgstr ""
"2018 에디션부터 `::`로 시작하는 경로는 [외부 프렐류드(extern prelude)](names/preludes.md#extern-prelude)에 "
"있는 크레이트에서 해석됩니다. 즉, 그 뒤에는 반드시 크레이트 이름이 와야 합니다."

#: src/paths.md:225
msgid ""
"// In the 2018 edition, this accesses `std` via the extern prelude.\n"
"    // In the 2015 edition, this accesses `std` via the crate root.\n"
msgstr ""
"// 2018 에디션에서는 외부 프렐류드를 통해 `std`에 접근합니다.\n"
"    // 2015 에디션에서는 크레이트 루트를 통해 `std`에 접근합니다.\n"

#: src/paths.md:239
msgid ""
"// call `a`'s foo function\n"
"        // In Rust 2018, `::a` would be interpreted as the crate `a`.\n"
msgstr ""
"// `a`의 foo 함수를 호출합니다.\n"
"        // Rust 2018에서 `::a`는 크레이트 `a`로 해석됩니다.\n"

#: src/paths.md:252
msgid "`self` resolves the path relative to the current module."
msgstr "`self`는 현재 모듈을 기준으로 상대적인 경로를 해석합니다."

#: src/paths.md:256
msgid "`self` can only be used as the first segment, without a preceding `::`."
msgstr "`self`는 앞에 `::` 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다."

#: src/paths.md:260
msgid ""
"In a method body, a path which consists of a single `self` segment resolves "
"to the method's self parameter."
msgstr ""
"메서드 본문에서 단일 `self` 세그먼트로 구성된 경로는 해당 메서드의 self 파라미터로 해석됩니다."

#: src/paths.md:278
msgid "`Self`"
msgstr "`Self`"

#: src/paths.md:282
msgid ""
"`Self`, with a capital \"S\", is used to refer to the current type being "
"implemented or defined. It may be used in the following situations:"
msgstr ""
"대문자 \"S\"로 시작하는 `Self`는 현재 구현되거나 정의되고 있는 타입을 참조하는 데 사용됩니다. "
"다음과 같은 상황에서 사용될 수 있습니다:"

#: src/paths.md:286
msgid ""
"In a [trait](items/traits.md) definition, it refers to the type implementing "
"the trait."
msgstr "[트레잇(trait)](items/traits.md) 정의에서, 이는 해당 트레잇을 구현하는 타입을 참조합니다."

#: src/paths.md:290
msgid ""
"In an [implementation](items/implementations.md), it refers to the type "
"being implemented. When implementing a tuple or unit [struct](items/"
"structs.md), it also refers to the constructor in the [value namespace]"
"(names/namespaces.md)."
msgstr ""
"[구현(implementation)](items/implementations.md)에서, 이는 구현되고 있는 타입을 참조합니다. "
"튜플 또는 유닛 [구조체(struct)](items/structs.md)를 구현할 때는 [값 네임스페이스](names/namespaces.md)의 "
"생성자도 참조합니다."

#: src/paths.md:295
msgid ""
"In the definition of a [struct](items/structs.md), [enumeration](items/"
"enumerations.md), or [union](items/unions.md), it refers to the type being "
"defined. The definition is not allowed to be infinitely recursive (there "
"must be an indirection)."
msgstr ""
"[구조체](items/structs.md), [열거형(enumeration)](items/enumerations.md) 또는 "
"[공용체(union)](items/unions.md)의 정의에서, 이는 정의되고 있는 타입을 참조합니다. "
"정의가 무한히 재귀적일 수는 없습니다(반드시 간접 참조(indirection)가 있어야 합니다)."

#: src/paths.md:300
msgid ""
"The scope of `Self` behaves similarly to a generic parameter; see the "
"[`Self` scope](names/scopes.md#self-scope) section for more details."
msgstr ""
"`Self`의 스코프는 제네릭 파라미터와 유사하게 동작합니다. "
"자세한 내용은 [`Self` 스코프](names/scopes.md#self-scope) 섹션을 참조하십시오."

#: src/paths.md:304
msgid "`Self` can only be used as the first segment, without a preceding `::`."
msgstr "`Self`는 앞에 `::` 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다."

#: src/paths.md:308
msgid "The `Self` path cannot include generic arguments (as in `Self::<i32>`)."
msgstr "`Self` 경로는 (`Self::<i32>`와 같이) 제네릭 인자를 포함할 수 없습니다."

#: src/paths.md:314
msgid "// `Self` will be whatever type that implements `T`.\n"
msgstr "// `Self`는 `T`를 구현하는 어떤 타입이든 될 수 있습니다.\n"

#: src/paths.md:316
msgid "// `Self::Item` will be the type alias in the implementation.\n"
msgstr "// `Self::Item`은 구현체에서의 타입 별칭(type alias)이 됩니다.\n"

#: src/paths.md:323
msgid "// `Self` is the type `S`.\n"
msgstr "// `Self`는 `S` 타입입니다.\n"

#: src/paths.md:326
msgid "// `Self::Item` is the type `i32`.\n"
msgstr "// `Self::Item`은 `i32` 타입입니다.\n"

#: src/paths.md:327
msgid "// `Self::C` is the constant value `9`.\n"
msgstr "// `Self::C`는 상수 값 `9`입니다.\n"

#: src/paths.md:330
msgid ""
"// `Self` is in scope within the generics of a trait definition,\n"
"// to refer to the type being defined.\n"
msgstr ""
"// `Self`는 트레잇 정의의 제네릭 내에서 스코프에 있으며,\n"
"// 정의되고 있는 타입을 참조합니다.\n"

#: src/paths.md:335
msgid ""
"// `Self` can also reference associated items of the\n"
"    // type being implemented.\n"
msgstr ""
"// `Self`는 또한 구현되고 있는 타입의\n"
"    // 연관 아이템을 참조할 수 있습니다.\n"

#: src/paths.md:342
msgid ""
"// A struct can reference itself (as long as it is not\n"
"    // infinitely recursive).\n"
msgstr ""
"// 구조체는 자기 자신을 참조할 수 있습니다(무한히\n"
"    // 재귀적이지 않은 한).\n"

#: src/paths.md:350
msgid "`super`"
msgstr "`super`"

#: src/paths.md:354
msgid "`super` in a path resolves to the parent module."
msgstr "경로에서의 `super`는 부모 모듈로 해석됩니다."

#: src/paths.md:358
msgid ""
"It may only be used in leading segments of the path, possibly after an "
"initial `self` segment."
msgstr ""
"이는 경로의 앞부분 세그먼트에서만 사용될 수 있으며, 초기 `self` 세그먼트 뒤에 올 수도 있습니다."

#: src/paths.md:366 src/paths.md:384 src/paths.md:385
msgid "// call a's foo function\n"
msgstr "// a의 foo 함수를 호출합니다.\n"

#: src/paths.md:374
msgid ""
"`super` may be repeated several times after the first `super` or `self` to "
"refer to ancestor modules."
msgstr ""
"`super`는 조상 모듈을 참조하기 위해 첫 번째 `super` 또는 `self` 뒤에 여러 번 반복될 수 있습니다."

#: src/paths.md:399
msgid "`crate` resolves the path relative to the current crate."
msgstr "`crate`는 현재 크레이트를 기준으로 상대적인 경로를 해석합니다."

#: src/paths.md:403
msgid ""
"`crate` can only be used as the first segment, without a preceding `::`."
msgstr "`crate`는 앞에 `::` 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다."

#: src/paths.md:417
msgid "`$crate`"
msgstr "`$crate`"

#: src/paths.md:421
msgid ""
"`$crate` is only used within [macro transcribers](macros-by-example.md), and "
"can only be used as the first segment, without a preceding `::`."
msgstr ""
"`$crate`는 [매크로 전사기(macro transcribers)](macros-by-example.md) 내에서만 사용되며, "
"앞에 `::` 없이 오직 첫 번째 세그먼트로만 사용될 수 있습니다."

#: src/paths.md:426
msgid ""
"`$crate` will expand to a path to access items from the top level of the "
"crate where the macro is defined, regardless of which crate the macro is "
"invoked."
msgstr ""
"`$crate`는 매크로가 호출된 크레이트에 관계없이, 매크로가 정의된 크레이트의 "
"최상위 레벨에 있는 아이템에 접근하기 위한 경로로 확장됩니다."

#: src/paths.md:444
msgid "Canonical paths"
msgstr "표준 경로(Canonical paths)"

#: src/paths.md:448
msgid ""
"Items defined in a module or implementation have a _canonical path_ that "
"corresponds to where within its crate it is defined."
msgstr ""
"모듈이나 구현체에 정의된 아이템은 해당 크레이트 내의 정의된 위치에 대응하는 "
"_표준 경로(canonical path)_를 갖습니다."

#: src/paths.md:453
msgid "All other paths to these items are aliases."
msgstr "이러한 아이템들에 대한 다른 모든 경로들은 별칭(aliases)입니다."

#: src/paths.md:457
msgid ""
"The canonical path is defined as a _path prefix_ appended by the path "
"segment the item itself defines."
msgstr ""
"표준 경로는 아이템 자체가 정의하는 경로 세그먼트가 추가된 _경로 접두사(path prefix)_로 정의됩니다."

#: src/paths.md:462
msgid ""
"[Implementations](items/implementations.md) and [use declarations](items/use-"
"declarations.md) do not have canonical paths, although the items that "
"implementations define do have them. Items defined in block expressions do "
"not have canonical paths. Items defined in a module that does not have a "
"canonical path do not have a canonical path. Associated items defined in an "
"implementation that refers to an item without a canonical path, e.g. as the "
"implementing type, the trait being implemented, a type parameter or bound on "
"a type parameter, do not have canonical paths."
msgstr ""
"[구현체(Implementations)](items/implementations.md)와 [use 선언(use declarations)](items/use-declarations.md)은 "
"표준 경로를 갖지 않지만, 구현체가 정의하는 아이템들은 표준 경로를 갖습니다. "
"블록 표현식에 정의된 아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 모듈에 정의된 "
"아이템은 표준 경로를 갖지 않습니다. 표준 경로가 없는 아이템(예: 구현하는 타입, "
"구현되는 트레잇, 타입 파라미터 또는 타입 파라미터의 바운드)을 참조하는 "
"구현체에 정의된 연관 아이템들은 표준 경로를 갖지 않습니다."

#: src/paths.md:472
msgid "The path prefix for modules is the canonical path to that module."
msgstr "모듈의 경로 접두사는 해당 모듈에 대한 표준 경로입니다."

#: src/paths.md:476
msgid ""
"For bare implementations, it is the canonical path of the item being "
"implemented surrounded by <span class=\"parenthetical\">angle (`<>`)</span> "
"brackets."
msgstr ""
"단순 구현체(bare implementations)의 경우, 구현되고 있는 아이템의 표준 경로를 "
"<span class=\"parenthetical\">화살괄호(`<>`)</span>로 둘러싼 형태가 접두사가 됩니다."

#: src/paths.md:481
msgid ""
"For [trait implementations](items/implementations.md#trait-implementations), "
"it is the canonical path of the item being implemented followed by `as` "
"followed by the canonical path to the trait all surrounded in <span "
"class=\"parenthetical\">angle (`<>`)</span> brackets."
msgstr ""
"[트레잇 구현체(trait implementations)](items/implementations.md#trait-implementations)의 경우, "
"구현되고 있는 아이템의 표준 경로 뒤에 `as`와 트레잇의 표준 경로를 붙인 후 전체를 "
"<span class=\"parenthetical\">화살괄호(`<>`)</span>로 둘러싼 형태가 접두사가 됩니다."

#: src/paths.md:487
msgid ""
"The canonical path is only meaningful within a given crate. There is no "
"global namespace across crates; an item's canonical path merely identifies "
"it within the crate."
msgstr ""
"표준 경로는 오직 주어진 크레이트 내에서만 의미가 있습니다. 크레이트들 사이에 "
"공통된 전역 네임스페이스는 존재하지 않습니다. 아이템의 표준 경로는 단지 "
"크레이트 내에서 아이템을 식별할 뿐입니다."

#: src/paths.md:492
msgid "// Comments show the canonical path of the item.\n"
msgstr "// 주석은 아이템의 표준 경로를 나타냅니다.\n"

#: src/paths.md:494
msgid "// crate::a\n"
msgstr "// crate::a\n"

#: src/paths.md:495
msgid "// crate::a::Struct\n"
msgstr "// crate::a::Struct\n"

#: src/paths.md:497
msgid "// crate::a::Trait\n"
msgstr "// crate::a::Trait\n"

#: src/paths.md:498
msgid "// crate::a::Trait::f\n"
msgstr "// crate::a::Trait::f\n"

#: src/paths.md:502
msgid "// <crate::a::Struct as crate::a::Trait>::f\n"
msgstr "// <crate::a::Struct as crate::a::Trait>::f\n"

#: src/paths.md:506
msgid "// <crate::a::Struct>::g\n"
msgstr "// <crate::a::Struct>::g\n"

#: src/paths.md:510
msgid "// crate::without\n"
msgstr "// crate::without\n"

#: src/paths.md:511
msgid "// crate::without::canonicals\n"
msgstr "// crate::without::canonicals\n"

#: src/paths.md:512 src/paths.md:514 src/paths.md:515 src/paths.md:519
#: src/paths.md:523 src/paths.md:527
msgid "// None\n"
msgstr "// 없음(None)\n"

#: src/names/name-resolution.md:3
msgid "**Note**: This is a placeholder for future expansion."
msgstr "**참고**: 이것은 향후 확장을 위한 플레이스홀더입니다."

#: src/visibility-and-privacy.md:3
msgid "Visibility and Privacy"
msgstr "가시성과 프라이버시"

#: src/visibility-and-privacy.md:7
msgid ""
"**<sup>Syntax</sup>**  \n"
"_Visibility_ :  \n"
"      `pub`  \n"
"   | `pub` `(` `crate` `)`  \n"
"   | `pub` `(` `self` `)`  \n"
"   | `pub` `(` `super` `)`  \n"
"   | `pub` `(` `in` [_SimplePath_](paths.md#simple-paths) `)`"
msgstr ""
"**<sup>구문</sup>**  \n"
"_Visibility_ :  \n"
"      `pub`  \n"
"   | `pub` `(` `crate` `)`  \n"
"   | `pub` `(` `self` `)`  \n"
"   | `pub` `(` `super` `)`  \n"
"   | `pub` `(` `in` [_SimplePath_](paths.md#simple-paths) `)`"

#: src/visibility-and-privacy.md:17
msgid ""
"These two terms are often used interchangeably, and what they are attempting "
"to convey is the answer to the question \"Can this item be used at this "
"location?\""
msgstr ""
"이 두 용어는 종종 혼용되어 사용되며, 이들이 전달하고자 하는 것은 "
"\"이 아이템을 이 위치에서 사용할 수 있는가?\"라는 질문에 대한 답변입니다."

#: src/visibility-and-privacy.md:22
msgid ""
"Rust's name resolution operates on a global hierarchy of namespaces. Each "
"level in the hierarchy can be thought of as some item. The items are one of "
"those mentioned above, but also include external crates. Declaring or "
"defining a new module can be thought of as inserting a new tree into the "
"hierarchy at the location of the definition."
msgstr ""
"러스트의 이름 확인(name resolution)은 네임스페이스의 전역 계층 구조 위에서 작동합니다. "
"계층 구조의 각 레벨은 어떤 아이템으로 생각할 수 있습니다. 아이템은 위에서 언급된 것들 중 "
"하나이거나 외부 크레이트도 포함합니다. 새로운 모듈을 선언하거나 정의하는 것은 "
"정의된 위치의 계층 구조에 새로운 트리를 삽입하는 것으로 생각할 수 있습니다."

#: src/visibility-and-privacy.md:30
msgid ""
"To control whether interfaces can be used across modules, Rust checks each "
"use of an item to see whether it should be allowed or not. This is where "
"privacy warnings are generated, or otherwise \"you used a private item of "
"another module and weren't allowed to.\""
msgstr ""
"인터페이스가 모듈 간에 사용될 수 있는지 제어하기 위해, 러스트는 각 아이템의 사용이 "
"허용되어야 하는지 여부를 확인합니다. 여기서 프라이버시 경고가 생성되거나, "
"그렇지 않으면 \"다른 모듈의 비공개 아이템을 사용했으며 이는 허용되지 않습니다\"라는 "
"오류가 발생합니다."

#: src/visibility-and-privacy.md:37
msgid ""
"By default, everything is _private_, with two exceptions: Associated items "
"in a `pub` Trait are public by default; Enum variants in a `pub` enum are "
"also public by default. When an item is declared as `pub`, it can be thought "
"of as being accessible to the outside world. For example:"
msgstr ""
"기본적으로 모든 것은 _비공개(private)_이며, 두 가지 예외가 있습니다: `pub` 트레잇의 연관 아이템은 "
"기본적으로 공개이며, `pub` 열거형의 열거형 변형(Enum variants) 또한 기본적으로 공개입니다. "
"아이템이 `pub`으로 선언되면 외부에서 접근 가능한 것으로 생각할 수 있습니다. 예를 들어:"

#: src/visibility-and-privacy.md:43
msgid "// Declare a private struct\n"
msgstr "// 비공개(private) 구조체를 선언합니다.\n"

#: src/visibility-and-privacy.md:46
msgid "// Declare a public struct with a private field\n"
msgstr "// 비공개 필드를 가진 공개(public) 구조체를 선언합니다.\n"

#: src/visibility-and-privacy.md:51
msgid "// Declare a public enum with two public variants\n"
msgstr "// 두 개의 공개 변형(variants)을 가진 공개 열거형을 선언합니다.\n"

#: src/visibility-and-privacy.md:61
msgid ""
"With the notion of an item being either public or private, Rust allows item "
"accesses in two cases:"
msgstr ""
"아이템이 공개 또는 비공개라는 개념과 함께, 러스트는 다음 두 가지 경우에 아이템 접근을 허용합니다:"

#: src/visibility-and-privacy.md:64
msgid ""
"If an item is public, then it can be accessed externally from some module "
"`m` if you can access all the item's ancestor modules from `m`. You can also "
"potentially be able to name the item through re-exports. See below."
msgstr ""
"아이템이 공개라면, 모듈 `m`에서 아이템의 모든 조상 모듈에 접근할 수 있는 경우 `m` 외부에서 "
"해당 아이템에 접근할 수 있습니다. 또한 재내보내기(re-exports)를 통해 해당 아이템의 이름을 "
"지정할 수도 있습니다. 아래를 참조하십시오."

#: src/visibility-and-privacy.md:67
msgid ""
"If an item is private, it may be accessed by the current module and its "
"descendants."
msgstr "아이템이 비공개라면, 현재 모듈과 그 하위 모듈들에서만 접근할 수 있습니다."

#: src/visibility-and-privacy.md:70
msgid ""
"These two cases are surprisingly powerful for creating module hierarchies "
"exposing public APIs while hiding internal implementation details. To help "
"explain, here's a few use cases and what they would entail:"
msgstr ""
"이 두 가지 경우는 내부 구현 세부 사항을 숨기면서 공개 API를 노출하는 모듈 계층 구조를 "
"만드는 데 매우 강력합니다. 설명을 돕기 위해 몇 가지 유스케이스와 그에 따른 결과를 소개합니다:"

#: src/visibility-and-privacy.md:74
msgid ""
"A library developer needs to expose functionality to crates which link "
"against their library. As a consequence of the first case, this means that "
"anything which is usable externally must be `pub` from the root down to the "
"destination item. Any private item in the chain will disallow external "
"accesses."
msgstr ""
"라이브러리 개발자는 자신의 라이브러리에 링크하는 크레이트들에 기능을 노출해야 합니다. "
"첫 번째 경우의 결과로서, 이는 외부에서 사용 가능한 모든 것이 루트부터 대상 아이템까지 "
"`pub`이어야 함을 의미합니다. 체인의 어느 한 아이템이라도 비공개라면 외부 접근이 허용되지 않습니다."

#: src/visibility-and-privacy.md:80
msgid ""
"A crate needs a global available \"helper module\" to itself, but it doesn't "
"want to expose the helper module as a public API. To accomplish this, the "
"root of the crate's hierarchy would have a private module which then "
"internally has a \"public API\". Because the entire crate is a descendant of "
"the root, then the entire local crate can access this private module through "
"the second case."
msgstr ""
"크레이트 내에서 전역적으로 사용 가능한 \"도우미 모듈\"이 필요하지만, 이를 공개 API로 "
"노출하고 싶지 않을 수 있습니다. 이를 위해 크레이트 계층 구조의 루트에 비공개 모듈을 두고, "
"그 내부에 \"공개 API\"를 갖게 합니다. 크레이트 전체가 루트의 하위 모듈이므로, "
"두 번째 경우를 통해 로컬 크레이트 전체가 이 비공개 모듈에 접근할 수 있습니다."

#: src/visibility-and-privacy.md:87
msgid ""
"When writing unit tests for a module, it's often a common idiom to have an "
"immediate child of the module to-be-tested named `mod test`. This module "
"could access any items of the parent module through the second case, meaning "
"that internal implementation details could also be seamlessly tested from "
"the child module."
msgstr ""
"모듈에 대한 유닛 테스트를 작성할 때, 테스트 대상 모듈의 직계 자식 모듈로 `mod test`를 "
"두는 것이 일반적인 관례입니다. 이 모듈은 두 번째 경우를 통해 부모 모듈의 모든 아이템에 "
"접근할 수 있으며, 이는 내부 구현 세부 사항도 자식 모듈에서 원활하게 테스트될 수 있음을 의미합니다."

#: src/visibility-and-privacy.md:93
msgid ""
"In the second case, it mentions that a private item \"can be accessed\" by "
"the current module and its descendants, but the exact meaning of accessing "
"an item depends on what the item is."
msgstr ""
"두 번째 경우에서 비공개 아이템이 현재 모듈과 그 하위 모듈들에 의해 \"접근될 수 있다\"고 "
"언급했는데, 아이템에 접근한다는 것의 정확한 의미는 아이템이 무엇인지에 따라 다릅니다."

#: src/visibility-and-privacy.md:99
msgid ""
"Accessing a module, for example, would mean looking inside of it (to import "
"more items). On the other hand, accessing a function would mean that it is "
"invoked. Additionally, path expressions and import statements are considered "
"to access an item in the sense that the import/expression is only valid if "
"the destination is in the current visibility scope."
msgstr ""
"예를 들어, 모듈에 접근한다는 것은 그 내부를 들여다보는 것(더 많은 아이템을 임포트하기 위해)을 "
"의미합니다. 반면, 함수에 접근한다는 것은 그것을 호출하는 것을 의미합니다. "
"또한, 경로 표현식과 임포트 문은 대상이 현재 가시성 스코프 내에 있는 경우에만 유효하다는 "
"의미에서 아이템에 접근하는 것으로 간주됩니다."

#: src/visibility-and-privacy.md:105
msgid ""
"Here's an example of a program which exemplifies the three cases outlined "
"above:"
msgstr "위에서 설명한 세 가지 경우를 보여주는 프로그램의 예입니다:"

#: src/visibility-and-privacy.md:109
msgid ""
"// This module is private, meaning that no external crate can access this\n"
"// module. Because it is private at the root of this current crate, however, "
"any\n"
"// module in the crate may access any publicly visible item in this module.\n"
msgstr ""
"// 이 모듈은 비공개이므로 외부 크레이트가 접근할 수 없습니다.\n"
"// 하지만 이 현재 크레이트의 루트에서는 비공개이므로,\n"
"// 크레이트 내의 모든 모듈은 이 모듈 내의 공개적으로 표시되는 아이템에 접근할 수 있습니다.\n"

#: src/visibility-and-privacy.md:114
msgid "// This function can be used by anything in the current crate\n"
msgstr "// 이 함수는 현재 크레이트 내의 무엇이든 사용할 수 있습니다.\n"

#: src/visibility-and-privacy.md:117
msgid ""
"// This function *cannot* be used by anything else in the crate. It is not\n"
"    // publicly visible outside of the `crate_helper_module`, so only this\n"
"    // current module and its descendants may access it.\n"
msgstr ""
"// 이 함수는 크레이트 내의 다른 어떤 곳에서도 사용할 수 *없습니다*.\n"
"// `crate_helper_module` 외부에서는 공개적으로 보이지 않으므로,\n"
"// 오직 이 현재 모듈과 그 하위 모듈들만 접근할 수 있습니다.\n"

#: src/visibility-and-privacy.md:122
msgid ""
"// This function is \"public to the root\" meaning that it's available to "
"external\n"
"// crates linking against this one.\n"
msgstr ""
"// 이 함수는 \"루트에 공개\"되어 있으므로 이 라이브러리에 링크하는\n"
"// 외부 크레이트가 사용할 수 있습니다.\n"

#: src/visibility-and-privacy.md:126
msgid ""
"// Similarly to 'public_api', this module is public so external crates may "
"look\n"
"// inside of it.\n"
msgstr ""
"// 'public_api'와 마찬가지로 이 모듈은 공개되어 있어 외부 크레이트가\n"
"// 내부를 들여다볼 수 있습니다.\n"

#: src/visibility-and-privacy.md:133
msgid ""
"// Any item in the local crate may invoke the helper module's public\n"
"        // interface through a combination of the two rules above.\n"
msgstr ""
"// 로컬 크레이트의 모든 아이템은 위의 두 규칙의 조합을 통해\n"
"        // 도우미 모듈의 공개 인터페이스를 호출할 수 있습니다.\n"

#: src/visibility-and-privacy.md:138
msgid ""
"// This function is hidden to any module which is not a descendant of\n"
"    // `submodule`\n"
msgstr "// 이 함수는 `submodule`의 하위 모듈이 아닌 모듈에는 숨겨집니다.\n"

#: src/visibility-and-privacy.md:147
msgid ""
"// Because this module is a descendant of `submodule`, it's allowed\n"
"            // to access private items inside of `submodule` without a "
"privacy\n"
"            // violation.\n"
msgstr ""
"// 이 모듈은 `submodule`의 하위 모듈이므로 프라이버시 위반 없이\n"
"            // `submodule` 내부의 비공개 아이템에 접근하는 것이 허용됩니다.\n"

#: src/visibility-and-privacy.md:158
msgid ""
"For a Rust program to pass the privacy checking pass, all paths must be "
"valid accesses given the two rules above. This includes all use statements, "
"expressions, types, etc."
msgstr ""
"러스트 프로그램이 프라이버시 검사 단계를 통과하려면 모든 경로가 위에서 언급한 "
"두 규칙에 따라 유효한 접근이어야 합니다. 여기에는 모든 use 문, 표현식, 타입 등이 포함됩니다."

#: src/visibility-and-privacy.md:164
msgid "`pub(in path)`, `pub(crate)`, `pub(super)`, and `pub(self)`"
msgstr "`pub(in path)`, `pub(crate)`, `pub(super)`, 그리고 `pub(self)`"

#: src/visibility-and-privacy.md:168
msgid ""
"In addition to public and private, Rust allows users to declare an item as "
"visible only within a given scope. The rules for `pub` restrictions are as "
"follows:"
msgstr ""
"공개와 비공개 외에도, 러스트는 아이템을 특정 스코프 내에서만 볼 수 있도록 선언할 수 있게 해줍니다. "
"`pub` 제약 조건에 대한 규칙은 다음과 같습니다:"

#: src/visibility-and-privacy.md:174
msgid ""
"`pub(in path)` makes an item visible within the provided `path`. `path` must "
"be a simple path which resolves to an ancestor module of the item whose "
"visibility is being declared. Each identifier in `path` must refer directly "
"to a module (not to a name introduced by a `use` statement)."
msgstr ""
"`pub(in path)`는 제공된 `path` 내에서 아이템을 볼 수 있게 합니다. `path`는 "
"가시성이 선언되는 아이템의 조상 모듈로 해석되는 단순 경로(simple path)여야 합니다. "
"`path` 내의 각 식별자는 모듈을 직접 참조해야 합니다(`use` 문에 의해 도입된 이름이 아니어야 합니다)."

#: src/visibility-and-privacy.md:180
msgid "`pub(crate)` makes an item visible within the current crate."
msgstr "`pub(crate)`는 현재 크레이트 내에서 아이템을 볼 수 있게 합니다."

#: src/visibility-and-privacy.md:184
msgid ""
"`pub(super)` makes an item visible to the parent module. This is equivalent "
"to `pub(in super)`."
msgstr ""
"`pub(super)`는 부모 모듈에서 아이템을 볼 수 있게 합니다. "
"이는 `pub(in super)`와 동일합니다."

#: src/visibility-and-privacy.md:189
msgid ""
"`pub(self)` makes an item visible to the current module. This is equivalent "
"to `pub(in self)` or not using `pub` at all."
msgstr ""
"`pub(self)`는 현재 모듈에서 아이템을 볼 수 있게 합니다. "
"이는 `pub(in self)`와 동일하거나 `pub`을 전혀 사용하지 않는 것과 같습니다."

#: src/visibility-and-privacy.md:194
msgid ""
"**Edition differences**: Starting with the 2018 edition, paths for `pub(in "
"path)` must start with `crate`, `self`, or `super`. The 2015 edition may "
"also use paths starting with `::` or modules from the crate root."
msgstr ""
"**에디션 차이**: 2018 에디션부터 `pub(in path)`의 경로는 `crate`, `self`, "
"또는 `super`로 시작해야 합니다. 2015 에디션은 `::`로 시작하는 경로나 "
"크레이트 루트의 모듈을 사용할 수도 있습니다."

#: src/visibility-and-privacy.md:198
msgid "Here's an example:"
msgstr "예제입니다:"

#: src/visibility-and-privacy.md:203 src/visibility-and-privacy.md:211
msgid "// This function is visible within `outer_mod`\n"
msgstr "// 이 함수는 `outer_mod` 내에서 볼 수 있습니다.\n"

#: src/visibility-and-privacy.md:205
msgid "// Same as above, this is only valid in the 2015 edition.\n"
msgstr "// 위와 동일하며, 2015 에디션에서만 유효합니다.\n"

#: src/visibility-and-privacy.md:208
msgid "// This function is visible to the entire crate\n"
msgstr "// 이 함수는 크레이트 전체에서 볼 수 있습니다.\n"

#: src/visibility-and-privacy.md:213
msgid "// This function is visible since we're in the same `mod`\n"
msgstr "// 동일한 `mod`에 있으므로 이 함수를 볼 수 있습니다.\n"

#: src/visibility-and-privacy.md:217
msgid ""
"// This function is visible only within `inner_mod`,\n"
"        // which is the same as leaving it private.\n"
msgstr ""
"// 이 함수는 오직 `inner_mod` 내에서만 볼 수 있으며,\n"
"        // 이는 비공개로 두는 것과 같습니다.\n"

#: src/visibility-and-privacy.md:226
msgid ""
"// This function is no longer visible since we're outside of `inner_mod`\n"
"        // Error! `inner_mod_visible_fn` is private\n"
"        //inner_mod::inner_mod_visible_fn();\n"
msgstr ""
"// `inner_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.\n"
"        // 오류! `inner_mod_visible_fn`은 비공개입니다.\n"
"        //inner_mod::inner_mod_visible_fn();\n"

#: src/visibility-and-privacy.md:233
msgid "// This function is still visible since we're in the same crate\n"
msgstr "// 동일한 크레이트에 있으므로 이 함수는 여전히 보입니다.\n"

#: src/visibility-and-privacy.md:236
msgid ""
"// This function is no longer visible since we're outside of `outer_mod`\n"
"    // Error! `super_mod_visible_fn` is private\n"
"    //outer_mod::inner_mod::super_mod_visible_fn();\n"
msgstr ""
"// `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.\n"
"    // 오류! `super_mod_visible_fn`은 비공개입니다.\n"
"    //outer_mod::inner_mod::super_mod_visible_fn();\n"

#: src/visibility-and-privacy.md:240
msgid ""
"// This function is no longer visible since we're outside of `outer_mod`\n"
"    // Error! `outer_mod_visible_fn` is private\n"
"    //outer_mod::inner_mod::outer_mod_visible_fn();\n"
msgstr ""
"// `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.\n"
"    // 오류! `outer_mod_visible_fn`은 비공개입니다.\n"
"    //outer_mod::inner_mod::outer_mod_visible_fn();\n"

#: src/visibility-and-privacy.md:250
msgid ""
"**Note:** This syntax only adds another restriction to the visibility of an "
"item. It does not guarantee that the item is visible within all parts of the "
"specified scope. To access an item, all of its parent items up to the "
"current scope must still be visible as well."
msgstr ""
"**참고:** 이 구문은 아이템의 가시성에 또 다른 제약 조건을 추가할 뿐입니다. "
"아이템이 지정된 스코프의 모든 부분에서 보인다는 것을 보장하지는 않습니다. "
"아이템에 접근하려면, 현재 스코프에 이르기까지의 모든 부모 아이템들도 보여야 합니다."

#: src/visibility-and-privacy.md:257
msgid "Re-exporting and Visibility"
msgstr "재내보내기(Re-exporting)와 가시성"

#: src/visibility-and-privacy.md:261
msgid ""
"Rust allows publicly re-exporting items through a `pub use` directive. "
"Because this is a public directive, this allows the item to be used in the "
"current module through the rules above. It essentially allows public access "
"into the re-exported item. For example, this program is valid:"
msgstr ""
"러스트는 `pub use` 지시어를 통해 아이템을 공개적으로 재내보낼 수 있게 해줍니다. "
"이것은 공개 지시어이므로, 위의 규칙에 따라 현재 모듈에서 해당 아이템을 사용할 수 있게 됩니다. "
"본질적으로 재내보낸 아이템에 대한 공개 접근을 허용하는 것입니다. 예를 들어, 다음 프로그램은 유효합니다:"

#: src/visibility-and-privacy.md:278
msgid ""
"This means that any external crate referencing `implementation::api::f` "
"would receive a privacy violation, while the path `api::f` would be allowed."
msgstr ""
"즉, `implementation::api::f`를 참조하는 외부 크레이트는 프라이버시 위반 오류를 "
"받게 되지만, `api::f` 경로는 허용됩니다."

#: src/visibility-and-privacy.md:283
msgid ""
"When re-exporting a private item, it can be thought of as allowing the "
"\"privacy chain\" being short-circuited through the reexport instead of "
"passing through the namespace hierarchy as it normally would."
msgstr ""
"비공개 아이템을 재내보낼 때, 이는 \"프라이버시 체인\"이 일반적인 네임스페이스 "
"계층 구조를 거치지 않고 재내보내기를 통해 단락(short-circuited)되는 것을 "
"허용하는 것으로 생각할 수 있습니다."

#: src/memory-model.md:3
msgid ""
"Rust does not yet have a defined memory model. Various academics and "
"industry professionals are working on various proposals, but for now, this "
"is an under-defined place in the language."
msgstr ""
"러스트는 아직 정의된 메모리 모델이 없습니다. 다양한 학계 및 산업계 전문가들이 "
"여러 제안을 작업 중이지만, 현재로서는 언어에서 명확히 정의되지 않은 부분입니다."

#: src/memory-allocation-and-lifetime.md:7
msgid ""
"The _items_ of a program are those functions, modules, and types that have "
"their value calculated at compile-time and stored uniquely in the memory "
"image of the rust process. Items are neither dynamically allocated nor freed."
msgstr ""
"프로그램의 _아이템(items)_은 컴파일 시간에 값이 계산되고 러스트 프로세스의 메모리 이미지에 "
"고유하게 저장되는 함수, 모듈, 타입들입니다. 아이템은 동적으로 할당되거나 해제되지 않습니다."

#: src/memory-allocation-and-lifetime.md:13
msgid ""
"The _heap_ is a general term that describes boxes.  The lifetime of an "
"allocation in the heap depends on the lifetime of the box values pointing to "
"it. Since box values may themselves be passed in and out of frames, or "
"stored in the heap, heap allocations may outlive the frame they are "
"allocated within. An allocation in the heap is guaranteed to reside at a "
"single location in the heap for the whole lifetime of the allocation - it "
"will never be relocated as a result of moving a box value."
msgstr ""
"_힙(heap)_은 박스(boxes)를 설명하는 일반적인 용어입니다. 힙 할당의 수명은 "
"이를 가리키는 박스 값의 수명에 따라 달라집니다. 박스 값 자체가 스택 프레임(frame) "
"내외부로 전달되거나 힙에 저장될 수 있으므로, 힙 할당은 할당된 프레임보다 더 오래 "
"지속될 수 있습니다. 힙 할당은 할당된 전체 수명 동안 힙의 단일 위치에 머무르는 것이 "
"보장됩니다. 즉, 박스 값을 이동하더라도 재배치되지 않습니다."

#: src/variables.md:7
msgid ""
"A _variable_ is a component of a stack frame, either a named function "
"parameter, an anonymous [temporary](expressions.md#temporaries), or a named "
"local variable."
msgstr ""
"_변수(variable)_는 스택 프레임의 구성 요소로, 이름을 가진 함수 파라미터, "
"익명 [임시 값(temporary)](expressions.md#temporaries), 또는 이름을 가진 지역 변수입니다."

#: src/variables.md:13
msgid ""
"A _local variable_ (or _stack-local_ allocation) holds a value directly, "
"allocated within the stack's memory. The value is a part of the stack frame."
msgstr ""
"_지역 변수(local variable)_(또는 _스택-로컬_ 할당)는 스택 메모리 내에 할당되어 "
"값을 직접 보관합니다. 이 값은 스택 프레임의 일부입니다."

#: src/variables.md:18
msgid ""
"Local variables are immutable unless declared otherwise. For example: `let "
"mut x = ...`."
msgstr "지역 변수는 별도로 선언하지 않는 한 불변(immutable)입니다. 예: `let mut x = ...`."

#: src/variables.md:23
msgid ""
"Function parameters are immutable unless declared with `mut`. The `mut` "
"keyword applies only to the following parameter. For example: `|mut x, y|` "
"and `fn f(mut x: Box<i32>, y: Box<i32>)` declare one mutable variable `x` "
"and one immutable variable `y`."
msgstr ""
"함수 파라미터는 `mut`로 선언되지 않는 한 불변입니다. `mut` 키워드는 바로 다음에 오는 "
"파라미터에만 적용됩니다. 예를 들어, `|mut x, y|`와 `fn f(mut x: Box<i32>, y: Box<i32>)`는 "
"가변 변수 `x` 하나와 불변 변수 `y` 하나를 선언합니다."

#: src/variables.md:30
msgid ""
"Local variables are not initialized when allocated. Instead, the entire "
"frame worth of local variables are allocated, on frame-entry, in an "
"uninitialized state. Subsequent statements within a function may or may not "
"initialize the local variables. Local variables can be used only after they "
"have been initialized through all reachable control flow paths."
msgstr ""
"지역 변수는 할당될 때 초기화되지 않습니다. 대신, 프레임에 진입할 때 프레임에 "
"해당하는 전체 지역 변수가 초기화되지 않은 상태로 할당됩니다. 함수 내의 후속 "
"구문들이 지역 변수를 초기화할 수도 있고 그렇지 않을 수도 있습니다. 지역 변수는 "
"모든 도달 가능한 제어 흐름 경로를 통해 초기화된 후에만 사용할 수 있습니다."

#: src/variables.md:36
msgid ""
"In this next example, `init_after_if` is initialized after the [`if` "
"expression](expressions/if-expr.md#if-expressions) while `uninit_after_if` "
"is not because it is not initialized in the `else` case."
msgstr ""
"다음 예제에서 `init_after_if`는 [`if` 표현식](expressions/if-expr.md#if-expressions) 이후에 "
"초기화되지만, `uninit_after_if`는 `else` 케이스에서 초기화되지 않으므로 초기화되지 않은 상태로 남습니다."

#: src/variables.md:52
msgid ""
"// ok\n"
"    // uninit_after_if; // err: use of possibly uninitialized "
"`uninit_after_if`\n"
msgstr ""
"// ok\n"
"    // uninit_after_if; // err: 초기화되지 않았을 가능성이 있는 `uninit_after_if` 사용\n"

#: src/linkage.md:6
msgid ""
"Note: This section is described more in terms of the compiler than of the "
"language."
msgstr "참고: 이 섹션은 언어 자체보다는 컴파일러 관점에서 설명됩니다."

#: src/linkage.md:11
msgid ""
"The compiler supports various methods to link crates together both "
"statically and dynamically. This section will explore the various methods to "
"link crates together, and more information about native libraries can be "
"found in the [FFI section of the book](../book/ch19-01-unsafe-"
"rust.html#using-extern-functions-to-call-external-code)."
msgstr ""
"컴파일러는 크레이트들을 정적 및 동적으로 링크하는 다양한 방법을 지원합니다. "
"이 섹션에서는 크레이트를 연결하는 여러 방법들을 살펴볼 것이며, 네이티브 "
"라이브러리에 대한 더 자세한 정보는 [책의 FFI 섹션](../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code)에서 "
"찾을 수 있습니다."

#: src/linkage.md:20
msgid ""
"In one session of compilation, the compiler can generate multiple artifacts "
"through the usage of either command line flags or the `crate_type` "
"attribute. If one or more command line flags are specified, all `crate_type` "
"attributes will be ignored in favor of only building the artifacts specified "
"by command line."
msgstr ""
"한 번의 컴파일 세션에서 컴파일러는 커맨드 라인 플래그나 `crate_type` 속성을 "
"사용하여 여러 결과물(artifacts)을 생성할 수 있습니다. 하나 이상의 커맨드 라인 플래그가 "
"지정되면 모든 `crate_type` 속성은 무시되고 커맨드 라인에서 지정된 결과물만 빌드됩니다."

#: src/linkage.md:27
msgid ""
"`--crate-type=bin`, `#![crate_type = \"bin\"]` - A runnable executable will "
"be produced. This requires that there is a `main` function in the crate "
"which will be run when the program begins executing. This will link in all "
"Rust and native dependencies, producing a single distributable binary. This "
"is the default crate type."
msgstr ""
"`--crate-type=bin`, `#![crate_type = \"bin\"]` - 실행 가능한 프로그램이 생성됩니다. "
"이 경우 프로그램이 실행될 때 호출될 `main` 함수가 크레이트 내에 반드시 있어야 합니다. "
"모든 러스트 및 네이티브 의존성을 링크하여 배포 가능한 단일 바이너리를 생성합니다. "
"이것이 기본 크레이트 타입입니다."

#: src/linkage.md:35
msgid ""
"`--crate-type=lib`, `#![crate_type = \"lib\"]` - A Rust library will be "
"produced. This is an ambiguous concept as to what exactly is produced "
"because a library can manifest itself in several forms. The purpose of this "
"generic `lib` option is to generate the \"compiler recommended\" style of "
"library. The output library will always be usable by rustc, but the actual "
"type of library may change from time-to-time. The remaining output types are "
"all different flavors of libraries, and the `lib` type can be seen as an "
"alias for one of them (but the actual one is compiler-defined)."
msgstr ""
"`--crate-type=lib`, `#![crate_type = \"lib\"]` - 러스트 라이브러리가 생성됩니다. "
"라이브러리는 여러 형태로 나타날 수 있기 때문에 무엇이 정확히 생성되는지는 모호할 수 있습니다. "
"이 일반적인 `lib` 옵션의 목적은 \"컴파일러가 권장하는\" 스타일의 라이브러리를 생성하는 것입니다. "
"생성된 라이브러리는 항상 rustc에서 사용할 수 있지만, 실제 라이브러리 타입은 수시로 "
"바뀔 수 있습니다. 나머지 출력 타입들은 모두 서로 다른 종류의 라이브러리들이며, "
"`lib` 타입은 그 중 하나에 대한 별칭으로 볼 수 있습니다(실제 타입은 컴파일러가 정의합니다)."

#: src/linkage.md:46
msgid ""
"`--crate-type=dylib`, `#![crate_type = \"dylib\"]` - A dynamic Rust library "
"will be produced. This is different from the `lib` output type in that this "
"forces dynamic library generation. The resulting dynamic library can be used "
"as a dependency for other libraries and/or executables. This output type "
"will create `*.so` files on Linux, `*.dylib` files on macOS, and `*.dll` "
"files on Windows."
msgstr ""
"`--crate-type=dylib`, `#![crate_type = \"dylib\"]` - 동적 러스트 라이브러리가 생성됩니다. "
"이는 `lib` 출력 타입과 달리 동적 라이브러리 생성을 강제합니다. 생성된 동적 라이브러리는 "
"다른 라이브러리나 실행 파일의 의존성으로 사용될 수 있습니다. 이 출력 타입은 "
"리눅스에서는 `*.so`, macOS에서는 `*.dylib`, 윈도우에서는 `*.dll` 파일을 생성합니다."

#: src/linkage.md:55
msgid ""
"`--crate-type=staticlib`, `#![crate_type = \"staticlib\"]` - A static system "
"library will be produced. This is different from other library outputs in "
"that the compiler will never attempt to link to `staticlib` outputs. The "
"purpose of this output type is to create a static library containing all of "
"the local crate's code along with all upstream dependencies. This output "
"type will create `*.a` files on Linux, macOS and Windows (MinGW), and "
"`*.lib` files on Windows (MSVC). This format is recommended for use in "
"situations such as linking Rust code into an existing non-Rust application "
"because it will not have dynamic dependencies on other Rust code."
msgstr ""
"`--crate-type=staticlib`, `#![crate_type = \"staticlib\"]` - 정적 시스템 라이브러리가 생성됩니다. "
"이는 다른 라이브러리 출력과 달리, 컴파일러가 `staticlib` 출력에 링크하려고 시도하지 않습니다. "
"이 출력 타입의 목적은 로컬 크레이트의 모든 코드와 모든 업스트림 의존성을 포함하는 "
"정적 라이브러리를 만드는 것입니다. 이 출력 타입은 리눅스, macOS 및 윈도우(MinGW)에서는 `*.a` 파일을, "
"윈도우(MSVC)에서는 `*.lib` 파일을 생성합니다. 이 형식은 다른 러스트 코드에 대한 동적 의존성이 "
"없기 때문에, 기존의 비-러스트 애플리케이션에 러스트 코드를 링크하는 것과 같은 상황에서 "
"사용하는 것을 권장합니다."

#: src/linkage.md:65
msgid ""
"Note that any dynamic dependencies that the static library may have (such as "
"dependencies on system libraries, or dependencies on Rust libraries that are "
"compiled as dynamic libraries) will have to be specified manually when "
"linking that static library from somewhere. The `--print=native-static-libs` "
"flag may help with this."
msgstr ""
"정적 라이브러리가 가질 수 있는 모든 동적 의존성(예: 시스템 라이브러리에 대한 의존성, 또는 "
"동적 라이브러리로 컴파일된 러스트 라이브러리에 대한 의존성)은 해당 정적 라이브러리를 "
"어딘가에서 링크할 때 수동으로 지정해야 함에 유의하십시오. `--print=native-static-libs` "
"플래그가 이 작업에 도움이 될 수 있습니다."

#: src/linkage.md:70
msgid ""
"Note that, because the resulting static library contains the code of all the "
"dependencies, including the standard library, and also exports all public "
"symbols of them, linking the static library into an executable or shared "
"library may need special care. In case of a shared library the list of "
"exported symbols will have to be limited via e.g. a linker or symbol version "
"script, exported symbols list (macOS), or module definition file (Windows). "
"Additionally, unused sections can be removed to remove all code of "
"dependencies that is not actually used (e.g. `--gc-sections` or `-"
"dead_strip` for macOS)."
msgstr ""
"생성된 정적 라이브러리는 표준 라이브러리를 포함한 모든 의존성의 코드를 포함하고 "
"이들의 모든 공개 심볼을 내보내기 때문에, 정적 라이브러리를 실행 파일이나 공유 라이브러리에 "
"링크할 때는 특별한 주의가 필요할 수 있음에 유의하십시오. 공유 라이브러리의 경우, "
"내보낼 심볼 목록을 링커나 심볼 버전 스크립트, 내보낸 심볼 목록(macOS) 또는 "
"모듈 정의 파일(윈도우) 등을 통해 제한해야 합니다. 또한, 실제로 사용되지 않는 "
"의존성 코드를 모두 제거하기 위해 사용되지 않는 섹션을 제거할 수 있습니다 "
"(예: `--gc-sections` 또는 macOS의 `-dead_strip`)."

#: src/linkage.md:82
msgid ""
"`--crate-type=cdylib`, `#![crate_type = \"cdylib\"]` - A dynamic system "
"library will be produced.  This is used when compiling a dynamic library to "
"be loaded from another language.  This output type will create `*.so` files "
"on Linux, `*.dylib` files on macOS, and `*.dll` files on Windows."
msgstr ""
"`--crate-type=cdylib`, `#![crate_type = \"cdylib\"]` - 동적 시스템 라이브러리가 생성됩니다. "
"이는 다른 언어에서 로드할 동적 라이브러리를 컴파일할 때 사용됩니다. 이 출력 타입은 "
"리눅스에서는 `*.so`, macOS에서는 `*.dylib`, 윈도우에서는 `*.dll` 파일을 생성합니다."

#: src/linkage.md:90
msgid ""
"`--crate-type=rlib`, `#![crate_type = \"rlib\"]` - A \"Rust library\" file "
"will be produced. This is used as an intermediate artifact and can be "
"thought of as a \"static Rust library\". These `rlib` files, unlike "
"`staticlib` files, are interpreted by the compiler in future linkage. This "
"essentially means that `rustc` will look for metadata in `rlib` files like "
"it looks for metadata in dynamic libraries. This form of output is used to "
"produce statically linked executables as well as `staticlib` outputs."
msgstr ""
"`--crate-type=rlib`, `#![crate_type = \"rlib\"]` - \"러스트 라이브러리\" 파일이 생성됩니다. "
"이는 중간 생성물로 사용되며 \"정적 러스트 라이브러리\"라고 생각할 수 있습니다. "
"이러한 `rlib` 파일은 `staticlib` 파일과 달리 향후 링크 시 컴파일러에 의해 해석됩니다. "
"이는 본질적으로 `rustc`가 동적 라이브러리에서 메타데이터를 찾는 것처럼 `rlib` 파일에서도 "
"메타데이터를 찾는다는 것을 의미합니다. 이 출력 형식은 정적으로 링크된 실행 파일과 "
"`staticlib` 출력을 생성하는 데 사용됩니다."

#: src/linkage.md:100
msgid ""
"`--crate-type=proc-macro`, `#![crate_type = \"proc-macro\"]` - The output "
"produced is not specified, but if a `-L` path is provided to it then the "
"compiler will recognize the output artifacts as a macro and it can be loaded "
"for a program. Crates compiled with this crate type  must only export "
"[procedural macros](procedural-macros.md). The compiler will automatically "
"set the `proc_macro` [configuration option](conditional-compilation.md). The "
"crates are always compiled with the same target that the compiler itself was "
"built with. For example, if you are executing the compiler from Linux with "
"an `x86_64` CPU, the target will be `x86_64-unknown-linux-gnu` even if the "
"crate is a dependency of another crate being built for a different target."
msgstr ""
"`--crate-type=proc-macro`, `#![crate_type = \"proc-macro\"]` - 생성되는 출력은 "
"명시되지 않았지만, `-L` 경로가 제공되면 컴파일러는 출력 결과물을 매크로로 인식하고 "
"프로그램에 로드할 수 있습니다. 이 크레이트 타입으로 컴파일된 크레이트는 반드시 "
"[절차적 매크로](procedural-macros.md)만 내보내야 합니다. 컴파일러는 자동으로 "
"`proc_macro` [설정 옵션](conditional-compilation.md)을 설정합니다. 크레이트는 항상 "
"컴파일러 자체가 빌드된 것과 동일한 타겟으로 컴파일됩니다. 예를 들어, 리눅스 `x86_64` CPU에서 "
"컴파일러를 실행 중이라면, 다른 타겟을 위해 빌드 중인 다른 크레이트의 의존성일지라도 "
"타겟은 `x86_64-unknown-linux-gnu`가 됩니다."

#: src/linkage.md:113
msgid ""
"Note that these outputs are stackable in the sense that if multiple are "
"specified, then the compiler will produce each form of output without having "
"to recompile. However, this only applies for outputs specified by the same "
"method. If only `crate_type` attributes are specified, then they will all be "
"built, but if one or more `--crate-type` command line flags are specified, "
"then only those outputs will be built."
msgstr ""
"이러한 출력들은 여러 개가 지정된 경우 컴파일러가 재컴파일 없이 각 형식의 출력을 "
"생성한다는 의미에서 중첩 가능함에 유의하십시오. 하지만 이는 동일한 방법으로 지정된 "
"출력에만 적용됩니다. `crate_type` 속성만 지정된 경우 모두 빌드되지만, "
"하나 이상의 `--crate-type` 커맨드 라인 플래그가 지정된 경우 해당 출력들만 빌드됩니다."

#: src/linkage.md:122
msgid ""
"With all these different kinds of outputs, if crate A depends on crate B, "
"then the compiler could find B in various different forms throughout the "
"system. The only forms looked for by the compiler, however, are the `rlib` "
"format and the dynamic library format. With these two options for a "
"dependent library, the compiler must at some point make a choice between "
"these two formats. With this in mind, the compiler follows these rules when "
"determining what format of dependencies will be used:"
msgstr ""
"이러한 다양한 종류의 출력들과 함께, 만약 크레이트 A가 크레이트 B에 의존한다면 "
"컴파일러는 시스템 전체에서 B를 여러 가지 다른 형식으로 찾을 수 있습니다. 하지만 "
"컴파일러가 찾는 유일한 형식은 `rlib` 형식과 동적 라이브러리 형식입니다. "
"의존 라이브러리에 대한 이 두 가지 옵션 중에서 컴파일러는 어느 시점에 이 두 형식 중 "
"하나를 선택해야 합니다. 이를 염두에 두고, 컴파일러는 어떤 형식의 의존성을 사용할지 "
"결정할 때 다음 규칙을 따릅니다."

#: src/linkage.md:132
msgid ""
"If a static library is being produced, all upstream dependencies are "
"required to be available in `rlib` formats. This requirement stems from the "
"reason that a dynamic library cannot be converted into a static format."
msgstr ""
"정적 라이브러리가 생성되는 경우, 모든 업스트림 의존성은 `rlib` 형식으로 "
"사용 가능해야 합니다. 이 요구 사항은 동적 라이브러리를 정적 형식으로 "
"변환할 수 없다는 이유에서 비롯됩니다."

#: src/linkage.md:136
msgid ""
"Note that it is impossible to link in native dynamic dependencies to a "
"static library, and in this case warnings will be printed about all unlinked "
"native dynamic dependencies."
msgstr ""
"정적 라이브러리에 네이티브 동적 의존성을 링크하는 것은 불가능하며, 이 경우 "
"링크되지 않은 모든 네이티브 동적 의존성에 대한 경고가 출력됨에 유의하십시오."

#: src/linkage.md:143
msgid ""
"If an `rlib` file is being produced, then there are no restrictions on what "
"format the upstream dependencies are available in. It is simply required "
"that all upstream dependencies be available for reading metadata from."
msgstr ""
"`rlib` 파일이 생성되는 경우, 업스트림 의존성이 어떤 형식으로 제공되는지에 대한 "
"제한은 없습니다. 단지 메타데이터를 읽기 위해 모든 업스트림 의존성이 "
"사용 가능해야 합니다."

#: src/linkage.md:147
msgid ""
"The reason for this is that `rlib` files do not contain any of their "
"upstream dependencies. It wouldn't be very efficient for all `rlib` files to "
"contain a copy of `libstd.rlib`!"
msgstr ""
그 이유는 `rlib` 파일이 업스트림 의존성을 전혀 포함하지 않기 때문입니다. 모든 "
"`rlib` 파일이 `libstd.rlib` 사본을 포함한다면 그다지 효율적이지 않을 것입니다!"

#: src/linkage.md:154
msgid ""
"If an executable is being produced and the `-C prefer-dynamic` flag is not "
"specified, then dependencies are first attempted to be found in the `rlib` "
"format. If some dependencies are not available in an rlib format, then "
"dynamic linking is attempted (see below)."
msgstr ""
"실행 파일이 생성되고 `-C prefer-dynamic` 플래그가 지정되지 않은 경우, "
"먼저 `rlib` 형식의 의존성을 찾으려고 시도합니다. 일부 의존성을 rlib 형식으로 "
"사용할 수 없는 경우, 동적 링크가 시도됩니다(아래 참조)."

#: src/linkage.md:162
msgid ""
"If a dynamic library or an executable that is being dynamically linked is "
"being produced, then the compiler will attempt to reconcile the available "
"dependencies in either the rlib or dylib format to create a final product."
msgstr ""
"동적 라이브러리나 동적으로 링크되는 실행 파일이 생성되는 경우, 컴파일러는 "
"최종 결과물을 만들기 위해 사용 가능한 의존성들을 rlib 또는 dylib 형식 중에서 "
"조정하려고 시도합니다."

#: src/linkage.md:166
msgid ""
"A major goal of the compiler is to ensure that a library never appears more "
"than once in any artifact. For example, if dynamic libraries B and C were "
"each statically linked to library A, then a crate could not link to B and C "
"together because there would be two copies of A. The compiler allows mixing "
"the rlib and dylib formats, but this restriction must be satisfied."
msgstr ""
"컴파일러의 주요 목표는 라이브러리가 어떤 결과물에서도 두 번 이상 나타나지 않도록 "
"보장하는 것입니다. 예를 들어, 만약 동적 라이브러리 B와 C가 각각 라이브러리 A에 "
"정적으로 링크되어 있다면, A의 사본이 두 개가 되기 때문에 어떤 크레이트도 B와 C를 "
"동시에 링크할 수 없습니다. 컴파일러는 rlib와 dylib 형식의 혼합을 허용하지만, "
"이 제한 사항은 반드시 준수되어야 합니다."

#: src/linkage.md:172
msgid ""
"The compiler currently implements no method of hinting what format a library "
"should be linked with. When dynamically linking, the compiler will attempt "
"to maximize dynamic dependencies while still allowing some dependencies to "
"be linked in via an rlib."
msgstr ""
"컴파일러는 현재 라이브러리를 어떤 형식으로 링크해야 하는지에 대한 힌트를 제공하는 "
"방법을 구현하고 있지 않습니다. 동적 링크 시 컴파일러는 일부 의존성을 rlib를 통해 "
"링크하는 것을 허용하면서도 동적 의존성을 최대화하려고 시도합니다."

#: src/linkage.md:177
msgid ""
"For most situations, having all libraries available as a dylib is "
"recommended if dynamically linking. For other situations, the compiler will "
"emit a warning if it is unable to determine which formats to link each "
"library with."
msgstr ""
"대부분의 상황에서, 동적 링크를 하는 경우 모든 라이브러리를 dylib로 사용할 수 있도록 "
"하는 것이 권장됩니다. 다른 상황에서 컴파일러는 각 라이브러리를 어떤 형식으로 "
"링크해야 할지 결정할 수 없는 경우 경고를 출력합니다."

#: src/linkage.md:181
msgid ""
"In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient "
"for all compilation needs, and the other options are just available if more "
"fine-grained control is desired over the output format of a crate."
msgstr ""
"일반적으로 모든 컴파일 요구 사항에 대해 `--crate-type=bin` 또는 `--crate-type=lib`로 "
"충분하며, 다른 옵션들은 크레이트의 출력 형식에 대해 더 세밀한 제어가 필요한 경우에만 "
"사용 가능합니다."

#: src/linkage.md:187
msgid "Static and dynamic C runtimes"
msgstr "정적 및 동적 C 런타임"

#: src/linkage.md:191
msgid ""
"The standard library in general strives to support both statically linked "
"and dynamically linked C runtimes for targets as appropriate. For example "
"the `x86_64-pc-windows-msvc` and `x86_64-unknown-linux-musl` targets "
"typically come with both runtimes and the user selects which one they'd "
"like. All targets in the compiler have a default mode of linking to the C "
"runtime. Typically targets are linked dynamically by default, but there are "
"exceptions which are static by default such as:"
msgstr ""
"표준 라이브러리는 일반적으로 타겟에 적절하게 정적 링크 및 동적 링크 C 런타임을 "
"모두 지원하려고 노력합니다. 예를 들어 `x86_64-pc-windows-msvc` 및 "
"`x86_64-unknown-linux-musl` 타겟은 일반적으로 두 런타임을 모두 제공하며 "
"사용자가 원하는 것을 선택합니다. 컴파일러의 모든 타겟은 C 런타임에 링크하는 "
"기본 모드를 가지고 있습니다. 일반적으로 타겟은 기본적으로 동적으로 링크되지만, "
"다음과 같이 기본적으로 정적인 예외도 있습니다."

#: src/linkage.md:199
msgid "`arm-unknown-linux-musleabi`"
msgstr "`arm-unknown-linux-musleabi`"

#: src/linkage.md:200
msgid "`arm-unknown-linux-musleabihf`"
msgstr "`arm-unknown-linux-musleabihf`"

#: src/linkage.md:201
msgid "`armv7-unknown-linux-musleabihf`"
msgstr "`armv7-unknown-linux-musleabihf`"

#: src/linkage.md:202
msgid "`i686-unknown-linux-musl`"
msgstr "`i686-unknown-linux-musl`"

#: src/linkage.md:203
msgid "`x86_64-unknown-linux-musl`"
msgstr "`x86_64-unknown-linux-musl`"

#: src/linkage.md:207
msgid ""
"The linkage of the C runtime is configured to respect the `crt-static` "
"target feature. These target features are typically configured from the "
"command line via flags to the compiler itself. For example to enable a "
"static runtime you would execute:"
msgstr ""
"C 런타임의 링크는 `crt-static` 타겟 기능을 준수하도록 설정됩니다. 이러한 타겟 "
"기능은 일반적으로 컴파일러 자체에 대한 플래그를 통해 커맨드 라인에서 설정됩니다. "
"예를 들어 정적 런타임을 활성화하려면 다음과 같이 실행합니다."

#: src/linkage.md:216
msgid "whereas to link dynamically to the C runtime you would execute:"
msgstr "반면 C 런타임에 동적으로 링크하려면 다음과 같이 실행합니다."

#: src/linkage.md:224
msgid ""
"Targets which do not support switching between linkage of the C runtime will "
"ignore this flag. It's recommended to inspect the resulting binary to ensure "
"that it's linked as you would expect after the compiler succeeds."
msgstr ""
"C 런타임 링크 방식의 전환을 지원하지 않는 타겟은 이 플래그를 무시합니다. "
"컴파일러가 성공적으로 종료된 후 결과 바이너리를 검사하여 예상대로 "
"링크되었는지 확인하는 것이 좋습니다."

#: src/linkage.md:230
msgid ""
"Crates may also learn about how the C runtime is being linked. Code on MSVC, "
"for example, needs to be compiled differently (e.g. with `/MT` or `/MD`) "
"depending on the runtime being linked. This is exported currently through "
"the [`cfg` attribute `target_feature` option](conditional-"
"compilation.md#target_feature):"
msgstr ""
"크레이트 또한 C 런타임이 어떻게 링크되었는지 알 수 있습니다. 예를 들어, "
"MSVC에서의 코드는 링크되는 런타임에 따라 다르게 컴파일되어야 합니다(예: `/MT` 또는 `/MD`). "
"이 정보는 현재 [`cfg` 속성의 `target_feature` 옵션](conditional-compilation.md#target_feature)을 "
"통해 제공됩니다:"

#: src/linkage.md:236 src/linkage.md:241 src/linkage.md:257
msgid "\"crt-static\""
msgstr "\"crt-static\""

#: src/linkage.md:238
msgid "\"the C runtime should be statically linked\""
msgstr "\"C 런타임은 정적으로 링크되어야 함\""

#: src/linkage.md:243
msgid "\"the C runtime should be dynamically linked\""
msgstr "\"C 런타임은 동적으로 링크되어야 함\""

#: src/linkage.md:247
msgid ""
"Also note that Cargo build scripts can learn about this feature through "
"[environment variables](../cargo/reference/environment-"
"variables.html#environment-variables-cargo-sets-for-build-scripts). In a "
"build script you can detect the linkage via:"
msgstr ""
"또한 Cargo 빌드 스크립트는 [환경 변수](../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts)를 "
"통해 이 기능에 대해 알 수 있습니다. 빌드 스크립트에서는 다음과 같이 링크 여부를 감지할 수 있습니다:"

#: src/linkage.md:255
msgid "\"CARGO_CFG_TARGET_FEATURE\""
msgstr "\"CARGO_CFG_TARGET_FEATURE\""

#: src/linkage.md:258
msgid "\"the C runtime will be statically linked\""
msgstr "\"C 런타임은 정적으로 링크될 것임\""

#: src/linkage.md:260
msgid "\"the C runtime will be dynamically linked\""
msgstr "\"C 런타임은 동적으로 링크될 것임\""

#: src/linkage.md:267
msgid ""
"To use this feature locally, you typically will use the `RUSTFLAGS` "
"environment variable to specify flags to the compiler through Cargo. For "
"example to compile a statically linked binary on MSVC you would execute:"
msgstr ""
"로컬에서 이 기능을 사용하려면 일반적으로 `RUSTFLAGS` 환경 변수를 사용하여 Cargo를 통해 "
"컴파일러 플래그를 지정합니다. 예를 들어 MSVC에서 정적으로 링크된 바이너리를 컴파일하려면 "
"다음과 같이 실행합니다:"

#: src/linkage.md:272
msgid "'-C target-feature=+crt-static'"
msgstr "'-C target-feature=+crt-static'"

#: src/linkage.md:275
msgid "Mixed Rust and foreign codebases"
msgstr "러스트와 외부 코드베이스의 혼합"

#: src/linkage.md:277
msgid ""
"If you are mixing Rust with foreign code (e.g. C, C++) and wish to make a "
"single binary containing both types of code, you have two approaches for the "
"final binary link:"
msgstr ""
"러스트를 외부 코드(예: C, C++)와 혼합하여 두 종류의 코드를 모두 포함하는 "
"단일 바이너리를 만들고자 한다면, 최종 바이너리 링크를 위해 두 가지 접근 방식이 있습니다."

#: src/linkage.md:281
msgid ""
"Use `rustc`. Pass any non-Rust libraries using `-L <directory>` and `-"
"l<library>` rustc arguments, and/or `#[link]` directives in your Rust code. "
"If you need to link against `.o` files you can use `-Clink-arg=file.o`."
msgstr ""
"`rustc`를 사용합니다. 비-러스트 라이브러리는 `rustc` 인자인 `-L <directory>` 및 "
"`-l<library>`를 사용하거나 러스트 코드의 `#[link]` 지시어를 통해 전달합니다. "
"`.o` 파일에 링크해야 한다면 `-Clink-arg=file.o`를 사용할 수 있습니다."

#: src/linkage.md:284
msgid ""
"Use your foreign linker. In this case, you first need to generate a Rust "
"`staticlib` target and pass that into your foreign linker invocation. If you "
"need to link multiple Rust subsystems, you will need to generate a _single_ "
"`staticlib` perhaps using lots of `extern crate` statements to include "
"multiple Rust `rlib`s. Multiple Rust `staticlib` files are likely to "
"conflict."
msgstr ""
"외부 링커를 사용합니다. 이 경우, 먼저 러스트 `staticlib` 타겟을 생성하고 이를 "
"외부 링커 호출 시 전달해야 합니다. 여러 개의 러스트 서브시스템을 링크해야 한다면, "
"여러 개의 `extern crate` 문을 사용하여 여러 러스트 `rlib`를 포함하는 "
"단일 `staticlib`를 생성해야 할 수도 있습니다. 여러 개의 러스트 `staticlib` 파일은 "
"충돌할 가능성이 높습니다."

#: src/linkage.md:290
msgid ""
"Passing `rlib`s directly into your foreign linker is currently unsupported."
msgstr "러스트 `rlib`를 외부 링커에 직접 전달하는 것은 현재 지원되지 않습니다."

#: src/inline-assembly.md:7
msgid ""
"Support for inline assembly is provided via the [`asm!`](../core/arch/"
"macro.asm.html) and [`global_asm!`](../core/arch/macro.global_asm.html) "
"macros. It can be used to embed handwritten assembly in the assembly output "
"generated by the compiler."
msgstr ""
"인라인 어셈블리에 대한 지원은 [`asm!`](../core/arch/macro.asm.html) 및 "
"[`global_asm!`](../core/arch/macro.global_asm.html) 매크로를 통해 제공됩니다. "
"이들은 컴파일러가 생성하는 어셈블리 출력에 직접 작성한 어셈블리를 삽입하는 데 사용됩니다."

#: src/inline-assembly.md:15
msgid "Support for inline assembly is stable on the following architectures:"
msgstr "인라인 어셈블리 지원은 다음 아키텍처에서 안정화되었습니다:"

#: src/inline-assembly.md:16
msgid "x86 and x86-64"
msgstr "x86 및 x86-64"

#: src/inline-assembly.md:17 src/inline-assembly.md:555
#: src/inline-assembly.md:556 src/inline-assembly.md:557
#: src/inline-assembly.md:558 src/inline-assembly.md:559
#: src/inline-assembly.md:560 src/inline-assembly.md:561
#: src/inline-assembly.md:562 src/inline-assembly.md:604
#: src/inline-assembly.md:605 src/inline-assembly.md:606
#: src/inline-assembly.md:607 src/inline-assembly.md:727
#: src/inline-assembly.md:728 src/inline-assembly.md:729
#: src/inline-assembly.md:730 src/inline-assembly.md:731
#: src/inline-assembly.md:732 src/inline-assembly.md:733
#: src/inline-assembly.md:734 src/inline-assembly.md:735
#: src/inline-assembly.md:781 src/inline-assembly.md:789
#: src/inline-assembly.md:790 src/inline-assembly.md:866
#: src/inline-assembly.md:867 src/inline-assembly.md:868
#: src/inline-assembly.md:869 src/inline-assembly.md:870
#: src/inline-assembly.md:993 src/inline-assembly.md:1330
msgid "ARM"
msgstr "ARM"

#: src/inline-assembly.md:18 src/inline-assembly.md:1337
msgid "AArch64 and Arm64EC"
msgstr "AArch64 및 Arm64EC"

#: src/inline-assembly.md:19 src/inline-assembly.md:563
#: src/inline-assembly.md:564 src/inline-assembly.md:565
#: src/inline-assembly.md:610 src/inline-assembly.md:611
#: src/inline-assembly.md:612 src/inline-assembly.md:736
#: src/inline-assembly.md:737 src/inline-assembly.md:738
#: src/inline-assembly.md:739 src/inline-assembly.md:740
#: src/inline-assembly.md:741 src/inline-assembly.md:742
#: src/inline-assembly.md:743 src/inline-assembly.md:744
#: src/inline-assembly.md:745 src/inline-assembly.md:746
#: src/inline-assembly.md:747 src/inline-assembly.md:748
#: src/inline-assembly.md:749 src/inline-assembly.md:750
#: src/inline-assembly.md:751 src/inline-assembly.md:791
#: src/inline-assembly.md:792 src/inline-assembly.md:871
#: src/inline-assembly.md:872 src/inline-assembly.md:994
#: src/inline-assembly.md:1340
msgid "RISC-V"
msgstr "RISC-V"

#: src/inline-assembly.md:20 src/inline-assembly.md:566
#: src/inline-assembly.md:567 src/inline-assembly.md:752
#: src/inline-assembly.md:753 src/inline-assembly.md:754
#: src/inline-assembly.md:755 src/inline-assembly.md:756
#: src/inline-assembly.md:757 src/inline-assembly.md:758
#: src/inline-assembly.md:759 src/inline-assembly.md:760
#: src/inline-assembly.md:761 src/inline-assembly.md:762
#: src/inline-assembly.md:763 src/inline-assembly.md:793
#: src/inline-assembly.md:794 src/inline-assembly.md:795
#: src/inline-assembly.md:873 src/inline-assembly.md:874
#: src/inline-assembly.md:995 src/inline-assembly.md:1343
msgid "LoongArch"
msgstr "LoongArch"

#: src/inline-assembly.md:21 src/inline-assembly.md:568
#: src/inline-assembly.md:569 src/inline-assembly.md:570
#: src/inline-assembly.md:571 src/inline-assembly.md:572
#: src/inline-assembly.md:616 src/inline-assembly.md:617
#: src/inline-assembly.md:618 src/inline-assembly.md:619
#: src/inline-assembly.md:796 src/inline-assembly.md:797
#: src/inline-assembly.md:875 src/inline-assembly.md:876
#: src/inline-assembly.md:877 src/inline-assembly.md:996
#: src/inline-assembly.md:1345
msgid "s390x"
msgstr "s390x"

#: src/inline-assembly.md:23
msgid ""
"The compiler will emit an error if `asm!` is used on an unsupported target."
msgstr "지원되지 않는 타겟에서 `asm!`을 사용하면 컴파일러가 오류를 발생시킵니다."

#: src/inline-assembly.md:30 src/inline-assembly.md:84
#: src/inline-assembly.md:96 src/inline-assembly.md:113
#: src/inline-assembly.md:134 src/inline-assembly.md:139
#: src/inline-assembly.md:148 src/inline-assembly.md:163
#: src/inline-assembly.md:167 src/inline-assembly.md:175
#: src/inline-assembly.md:181 src/inline-assembly.md:185
#: src/inline-assembly.md:191 src/inline-assembly.md:199
#: src/inline-assembly.md:205 src/inline-assembly.md:213
#: src/inline-assembly.md:219 src/inline-assembly.md:255
#: src/inline-assembly.md:271 src/inline-assembly.md:285
#: src/inline-assembly.md:304 src/inline-assembly.md:321
#: src/inline-assembly.md:336 src/inline-assembly.md:353
#: src/inline-assembly.md:369 src/inline-assembly.md:393
#: src/inline-assembly.md:409 src/inline-assembly.md:412
#: src/inline-assembly.md:419 src/inline-assembly.md:434
#: src/inline-assembly.md:452 src/inline-assembly.md:457
#: src/inline-assembly.md:460 src/inline-assembly.md:465
#: src/inline-assembly.md:473 src/inline-assembly.md:479
#: src/inline-assembly.md:493 src/inline-assembly.md:518
#: src/inline-assembly.md:525 src/inline-assembly.md:624
#: src/inline-assembly.md:636 src/inline-assembly.md:642
#: src/inline-assembly.md:652 src/inline-assembly.md:670
#: src/inline-assembly.md:681 src/inline-assembly.md:688
#: src/inline-assembly.md:766 src/inline-assembly.md:800
#: src/inline-assembly.md:805 src/inline-assembly.md:826
#: src/inline-assembly.md:831 src/inline-assembly.md:886
#: src/inline-assembly.md:915 src/inline-assembly.md:931
#: src/inline-assembly.md:958 src/inline-assembly.md:975
#: src/inline-assembly.md:1020 src/inline-assembly.md:1030
#: src/inline-assembly.md:1039 src/inline-assembly.md:1050
#: src/inline-assembly.md:1074 src/inline-assembly.md:1097
#: src/inline-assembly.md:1107 src/inline-assembly.md:1122
#: src/inline-assembly.md:1150 src/inline-assembly.md:1154
#: src/inline-assembly.md:1160 src/inline-assembly.md:1173
#: src/inline-assembly.md:1185 src/inline-assembly.md:1214
#: src/inline-assembly.md:1219 src/inline-assembly.md:1227
#: src/inline-assembly.md:1232 src/inline-assembly.md:1240
#: src/inline-assembly.md:1246 src/inline-assembly.md:1256
#: src/inline-assembly.md:1259 src/inline-assembly.md:1359
#: src/inline-assembly.md:1385 src/inline-assembly.md:1520
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/inline-assembly.md:32
msgid "// Multiply x by 6 using shifts and adds\n"
msgstr "// 시프트와 덧셈을 사용하여 x에 6을 곱합니다.\n"

#: src/inline-assembly.md:37
msgid "\"mov {tmp}, {x}\""
msgstr "\"mov {tmp}, {x}\""

#: src/inline-assembly.md:38
msgid "\"shl {tmp}, 1\""
msgstr "\"shl {tmp}, 1\""

#: src/inline-assembly.md:39
msgid "\"shl {x}, 2\""
msgstr "\"shl {x}, 2\""

#: src/inline-assembly.md:40
msgid "\"add {x}, {tmp}\""
msgstr "\"add {x}, {tmp}\""

#: src/inline-assembly.md:53
msgid "The following ABNF specifies the general syntax:"
msgstr "다음 ABNF는 일반적인 구문을 명시합니다:"

#: src/inline-assembly.md:55
msgid ""
"```text\n"
"format_string := STRING_LITERAL / RAW_STRING_LITERAL\n"
"dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n"
"reg_spec := <register class> / \"\\\"\" <explicit register> \"\\\"\"\n"
"operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n"
"reg_operand := [ident \"=\"] dir_spec \"(\" reg_spec \")\" operand_expr / "
"sym <path> / const <expr>\n"
"clobber_abi := \"clobber_abi(\" <abi> *(\",\" <abi>) [\",\"] \")\"\n"
"option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / "
"\"noreturn\" / \"nostack\" / \"att_syntax\" / \"raw\"\n"
"options := \"options(\" option *(\",\" option) [\",\"] \")\"\n"
"operand := reg_operand / clobber_abi / options\n"
"asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" operand) [\","
"\"] \")\"\n"
"global_asm := \"global_asm!(\" format_string *(\",\" format_string) *(\",\" "
"operand) [\",\"] \")\"\n"
"```"
msgstr ""
"```text\n"
"format_string := STRING_LITERAL / RAW_STRING_LITERAL\n"
"dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n"
"reg_spec := <register class> / \"\\\"\" <explicit register> \"\\\"\"\n"
"operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n"
"reg_operand := [ident \"=\"] dir_spec \"(\" reg_spec \")\" operand_expr / "
"sym <path> / const <expr>\n"
"clobber_abi := \"clobber_abi(\" <abi> *(\",\" <abi>) [\",\"] \")\"\n"
"option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / "
"\"noreturn\" / \"nostack\" / \"att_syntax\" / \"raw\"\n"
"options := \"options(\" option *(\",\" option) [\",\"] \")\"\n"
"operand := reg_operand / clobber_abi / options\n"
"asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" operand) [\","
"\"] \")\"\n"
"global_asm := \"global_asm!(\" format_string *(\",\" format_string) *(\",\" "
"operand) [\",\"] \")\"\n"
"```"

#: src/inline-assembly.md:71 src/glossary.md:196
msgid "Scope"
msgstr "스코프"

#: src/inline-assembly.md:75
msgid "Inline assembly can be used in one of two ways."
msgstr "인라인 어셈블리는 두 가지 방법 중 하나로 사용될 수 있습니다."

#: src/inline-assembly.md:79
msgid ""
"With the `asm!` macro, the assembly code is emitted in a function scope and "
"integrated into the compiler-generated assembly code of a function. This "
"assembly code must obey [strict rules](#rules-for-inline-assembly) to avoid "
"undefined behavior. Note that in some cases the compiler may choose to emit "
"the assembly code as a separate function and generate a call to it."
msgstr ""
"`asm!` 매크로를 사용하면, 어셈블리 코드는 함수 스코프에서 배출되어 컴파일러가 생성한 "
"함수의 어셈블리 코드와 통합됩니다. 이 어셈블리 코드는 정의되지 않은 동작을 피하기 위해 "
"[엄격한 규칙](#rules-for-inline-assembly)을 따라야 합니다. 경우에 따라 컴파일러는 "
"어셈블리 코드를 별도의 함수로 배출하고 그 함수에 대한 호출을 생성할 수도 있습니다."

#: src/inline-assembly.md:85 src/inline-assembly.md:97
#: src/inline-assembly.md:188 src/inline-assembly.md:202
#: src/inline-assembly.md:257 src/inline-assembly.md:274
#: src/inline-assembly.md:498 src/inline-assembly.md:502
#: src/inline-assembly.md:506 src/inline-assembly.md:510
#: src/inline-assembly.md:513 src/inline-assembly.md:522
#: src/inline-assembly.md:639 src/inline-assembly.md:685
msgid "\"/* {} */\""
msgstr "\"/* {} */\""

#: src/inline-assembly.md:91
msgid ""
"With the `global_asm!` macro, the assembly code is emitted in a global "
"scope, outside a function. This can be used to hand-write entire functions "
msgstr ""
"`global_asm!` 매크로를 사용하면, 어셈블리 코드는 함수 외부의 전역 스코프에서 배출됩니다. "
"이는 전체 함수를 수동으로 작성하는 데 사용될 수 있습니다. "
"using assembly code, and generally provides much more freedom to use "
"arbitrary registers and assembler directives."
msgstr ""
"이는 어셈블리 코드를 사용하여 전체 함수를 수동으로 작성하는 데 사용될 수 있으며, "
"일반적으로 임의의 레지스터와 어셈블러 지시어를 사용할 수 있는 훨씬 더 많은 자유를 제공합니다."

#: src/inline-assembly.md:102
msgid "Template string arguments"
msgstr "템플릿 문자열 인자"

#: src/inline-assembly.md:106
msgid ""
"The assembler template uses the same syntax as [format strings](../alloc/fmt/"
"index.html#syntax) (i.e. placeholders are specified by curly braces)."
msgstr ""
"어셈블러 템플릿은 [포맷 문자열](../alloc/fmt/index.html#syntax)과 동일한 구문을 사용합니다 "
"(즉, 플레이스홀더는 중괄호로 지정됩니다)."

#: src/inline-assembly.md:110
msgid ""
"The corresponding arguments are accessed in order, by index, or by name."
msgstr "해당 인자들은 순서대로, 인덱스로, 또는 이름으로 접근됩니다."

#: src/inline-assembly.md:116
msgid "// This\n"
msgstr "// 이것과\n"

#: src/inline-assembly.md:118 src/inline-assembly.md:656
msgid "\"mov {}, {}\""
msgstr "\"mov {}, {}\""

#: src/inline-assembly.md:118
msgid "// ... this\n"
msgstr "// ... 이것\n"

#: src/inline-assembly.md:120
msgid "\"mov {0}, {1}\""
msgstr "\"mov {0}, {1}\""

#: src/inline-assembly.md:120
msgid "// ... and this\n"
msgstr "// ... 그리고 이것은\n"

#: src/inline-assembly.md:122
msgid "\"mov {out}, {in}\""
msgstr "\"mov {out}, {in}\""

#: src/inline-assembly.md:122
msgid "// all have the same behavior\n"
msgstr "// 모두 동일하게 동작합니다.\n"

#: src/inline-assembly.md:131
msgid ""
"However, implicit named arguments (introduced by [RFC #2795](https://"
"github.com/rust-lang/rfcs/pull/2795)) are not supported."
msgstr ""
"하지만, ([RFC #2795](https://github.com/rust-lang/rfcs/pull/2795)에서 도입된) "
"암시적 명명된 인자(implicit named arguments)는 지원되지 않습니다."

#: src/inline-assembly.md:135
msgid ""
"// We can't refer to `x` from the scope directly, we need an operand like "
"`in(reg) x`\n"
msgstr "// 스코프에서 직접 `x`를 참조할 수 없으며, `in(reg) x`와 같은 피연산자가 필요합니다.\n"

#: src/inline-assembly.md:137 src/inline-assembly.md:165
msgid "\"/* {x} */\""
msgstr "\"/* {x} */\""

#: src/inline-assembly.md:137
msgid "// ERROR: no argument named x\n"
msgstr "// 오류: x라는 이름의 인자가 없습니다.\n"

#: src/inline-assembly.md:139 src/inline-assembly.md:167
#: src/inline-assembly.md:181 src/inline-assembly.md:191
#: src/inline-assembly.md:205 src/inline-assembly.md:219
#: src/inline-assembly.md:412 src/inline-assembly.md:457
#: src/inline-assembly.md:465 src/inline-assembly.md:479
#: src/inline-assembly.md:525 src/inline-assembly.md:642
#: src/inline-assembly.md:688 src/inline-assembly.md:805
#: src/inline-assembly.md:831 src/inline-assembly.md:975
#: src/inline-assembly.md:1039 src/inline-assembly.md:1219
#: src/inline-assembly.md:1232 src/inline-assembly.md:1246
#: src/inline-assembly.md:1259
msgid "\"Test not supported on this arch\""
msgstr "\"이 아키텍처에서는 테스트가 지원되지 않습니다\""

#: src/inline-assembly.md:144
msgid ""
"An `asm!` invocation may have one or more template string arguments; an `asm!"
"` with multiple template string arguments is treated as if all the strings "
"were concatenated with a `\\n` between them. The expected usage is for each "
"template string argument to correspond to a line of assembly code."
msgstr ""
"`asm!` 호출은 하나 이상의 템플릿 문자열 인자를 가질 수 있습니다. 여러 개의 템플릿 "
"문자열 인자가 있는 `asm!`은 모든 문자열이 사이에 `\\n`을 두고 연결된 것처럼 처리됩니다. "
"권장되는 사용법은 각 템플릿 문자열 인자가 어셈블리 코드의 한 줄에 대응하도록 하는 것입니다."

#: src/inline-assembly.md:150
msgid "// We can separate multiple strings as if they were written together\n"
msgstr "// 여러 문자열을 마치 함께 작성된 것처럼 분리할 수 있습니다.\n"

#: src/inline-assembly.md:152
msgid "\"mov eax, 5\""
msgstr "\"mov eax, 5\""

#: src/inline-assembly.md:152 src/inline-assembly.md:941
msgid "\"mov ecx, eax\""
msgstr "\"mov ecx, eax\""

#: src/inline-assembly.md:152 src/inline-assembly.md:462
#: src/inline-assembly.md:769 src/inline-assembly.md:921
#: src/inline-assembly.md:945
msgid "\"rax\""
msgstr "\"rax\""

#: src/inline-assembly.md:152
msgid "\"rcx\""
msgstr "\"rcx\""

#: src/inline-assembly.md:159
msgid "All template string arguments must appear before any other arguments."
msgstr "모든 템플릿 문자열 인자는 다른 인자들보다 먼저 나타나야 합니다."

#: src/inline-assembly.md:163
msgid "// The template strings need to appear first in the asm invocation\n"
msgstr "// 템플릿 문자열은 asm 호출에서 가장 먼저 나타나야 합니다.\n"

#: src/inline-assembly.md:165 src/inline-assembly.md:1152
msgid "\"ud2\""
msgstr "\"ud2\""

#: src/inline-assembly.md:165
msgid "// ERROR: unexpected token\n"
msgstr "// 오류: 예상치 못한 토큰\n"

#: src/inline-assembly.md:172
msgid ""
"As with format strings, positional arguments must appear before named "
"arguments and explicit [register operands](#register-operands)."
msgstr ""
"포맷 문자열과 마찬가지로, 위치 기반 인자(positional arguments)는 명명된 인자나 "
"명시적 [레지스터 피연산자](#register-operands)보다 먼저 나타나야 합니다."

#: src/inline-assembly.md:176
msgid "// Named operands need to come after positional ones\n"
msgstr "// 명명된 피연산자는 위치 기반 피연산자 뒤에 와야 합니다.\n"

#: src/inline-assembly.md:178
msgid "\"/* {x} {} */\""
msgstr "\"/* {x} {} */\""

#: src/inline-assembly.md:178 src/inline-assembly.md:188
msgid ""
"// ERROR: positional arguments cannot follow named arguments or explicit "
"register arguments\n"
msgstr "// 오류: 위치 기반 인자는 명명된 인자나 명시적 레지스터 인자 뒤에 올 수 없습니다.\n"

#: src/inline-assembly.md:186
msgid "// We also can't put explicit registers before positional operands\n"
msgstr "// 또한 위치 기반 피연산자 앞에 명시적 레지스터를 둘 수 없습니다.\n"

#: src/inline-assembly.md:188 src/inline-assembly.md:202
#: src/inline-assembly.md:438 src/inline-assembly.md:454
#: src/inline-assembly.md:1377
msgid "\"eax\""
msgstr "\"eax\""

#: src/inline-assembly.md:196
msgid ""
"Explicit register operands cannot be used by placeholders in the template "
"string."
msgstr "명시적 레지스터 피연산자는 템플릿 문자열의 플레이스홀더에서 사용될 수 없습니다."

#: src/inline-assembly.md:200
msgid ""
"// Explicit register operands don't get substituted, use `eax` explicitly in "
"the string\n"
msgstr "// 명시적 레지스터 피연산자는 치환되지 않으므로, 문자열에서 `eax`를 명시적으로 사용하십시오.\n"

#: src/inline-assembly.md:202
msgid "// ERROR: invalid reference to argument at index 0\n"
msgstr "// 오류: 인덱스 0의 인자에 대한 잘못된 참조\n"

#: src/inline-assembly.md:210
msgid ""
"All other named and positional operands must appear at least once in the "
"template string, otherwise a compiler error is generated."
msgstr ""
"다른 모든 명명된 및 위치 기반 피연산자는 템플릿 문자열에 최소 한 번 이상 나타나야 하며, "
"그렇지 않으면 컴파일러 오류가 발생합니다."

#: src/inline-assembly.md:214
msgid "// We have to name all of the operands in the format string\n"
msgstr "// 포맷 문자열에서 모든 피연산자의 이름을 지정해야 합니다.\n"

#: src/inline-assembly.md:216
msgid "// ERROR: multiple unused asm arguments\n"
msgstr "// 오류: 사용되지 않은 여러 개의 asm 인자가 있습니다.\n"

#: src/inline-assembly.md:224
msgid ""
"The exact assembly code syntax is target-specific and opaque to the compiler "
"except for the way operands are substituted into the template string to form "
"the code passed to the assembler."
msgstr ""
"정확한 어셈블리 코드 구문은 타겟에 따라 다르며, 피연산자가 템플릿 문자열에 치환되어 "
"어셈블러에 전달될 코드를 형성하는 방식을 제외하고는 컴파일러에게 불투명(opaque)합니다."

#: src/inline-assembly.md:228
msgid ""
"Currently, all supported targets follow the assembly code syntax used by "
"LLVM's internal assembler which usually corresponds to that of the GNU "
"assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by "
"default. On ARM, the `.syntax unified` mode is used. These targets impose an "
"additional restriction on the assembly code: any assembler state (e.g. the "
"current section which can be changed with `.section`) must be restored to "
"its original value at the end of the asm string. Assembly code that does not "
"conform to the GAS syntax will result in assembler-specific behavior. "
"Further constraints on the directives used by inline assembly are indicated "
"by [Directives Support](#directives-support)."
msgstr ""
"현재 모든 지원되는 타겟은 LLVM 내부 어셈블러에서 사용하는 어셈블리 코드 구문을 따르며, "
"이는 대개 GNU 어셈블러(GAS)의 구문과 일치합니다. x86에서는 기본적으로 GAS의 "
"`.intel_syntax noprefix` 모드가 사용됩니다. ARM에서는 `.syntax unified` 모드가 사용됩니다. "
"이러한 타겟들은 어셈블리 코드에 추가적인 제약을 가합니다. 즉, 모든 어셈블러 상태"
"(예: `.section`으로 변경될 수 있는 현재 섹션)는 asm 문자열의 끝에서 원래 값으로 "
"복구되어야 합니다. GAS 구문을 따르지 않는 어셈블리 코드는 어셈블러에 따라 다른 동작을 유발할 수 있습니다. "
"인라인 어셈블리에서 사용되는 지시어(directives)에 대한 추가적인 제약 조건은 "
"[지시어 지원](#directives-support) 섹션에 명시되어 있습니다."

#: src/inline-assembly.md:240
msgid "Operand type"
msgstr "피연산자 타입"

#: src/inline-assembly.md:244
msgid "Several types of operands are supported:"
msgstr "여러 종류의 피연산자가 지원됩니다:"

#: src/inline-assembly.md:248
msgid "`in(<reg>) <expr>`"
msgstr "`in(<reg>) <expr>`"

#: src/inline-assembly.md:249 src/inline-assembly.md:264
#: src/inline-assembly.md:298
msgid ""
"`<reg>` can refer to a register class or an explicit register. The allocated "
"register name is substituted into the asm template string."
msgstr ""
"`<reg>`는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 "
"레지스터 이름이 asm 템플릿 문자열에 치환됩니다."

#: src/inline-assembly.md:251 src/inline-assembly.md:300
msgid ""
"The allocated register will contain the value of `<expr>` at the start of "
"the asm code."
msgstr "할당된 레지스터는 asm 코드의 시작 시점에 `<expr>`의 값을 갖게 됩니다."

#: src/inline-assembly.md:252
msgid ""
"The allocated register must contain the same value at the end of the asm "
"code (except if a `lateout` is allocated to the same register)."
msgstr ""
"할당된 레지스터는 asm 코드의 끝에서도 동일한 값을 유지해야 합니다"
"(동일한 레지스터에 `lateout`이 할당된 경우는 제외)."

#: src/inline-assembly.md:255
msgid "// ``in` can be used to pass values into inline assembly...\n"
msgstr "// `in`은 인라인 어셈블리에 값을 전달하는 데 사용될 수 있습니다...\n"

#: src/inline-assembly.md:263
msgid "`out(<reg>) <expr>`"
msgstr "`out(<reg>) <expr>`"

#: src/inline-assembly.md:266
msgid ""
"The allocated register will contain an undefined value at the start of the "
"asm code."
msgstr "할당된 레지스터는 asm 코드 시작 시점에 정의되지 않은(undefined) 값을 갖게 됩니다."

#: src/inline-assembly.md:267
msgid ""
"`<expr>` must be a (possibly uninitialized) place expression, to which the "
"contents of the allocated register are written at the end of the asm code."
msgstr ""
"`<expr>`은 (초기화되지 않았을 수도 있는) 장소 표현식(place expression)이어야 하며, "
"asm 코드의 끝에서 할당된 레지스터의 내용이 여기에 기록됩니다."

#: src/inline-assembly.md:268
msgid ""
"An underscore (`_`) may be specified instead of an expression, which will "
"cause the contents of the register to be discarded at the end of the asm "
"code (effectively acting as a clobber)."
msgstr ""
"표현식 대신 밑줄(`_`)을 지정할 수 있으며, 이 경우 asm 코드 끝에서 레지스터의 "
"내용이 버려집니다(실질적으로 클로버(clobber)로 작동함)."

#: src/inline-assembly.md:272
msgid "// and `out` can be used to pass values back to rust.\n"
msgstr "// 그리고 `out`은 값을 다시 러스트로 전달하는 데 사용될 수 있습니다.\n"

#: src/inline-assembly.md:280
msgid "`lateout(<reg>) <expr>`"
msgstr "`lateout(<reg>) <expr>`"

#: src/inline-assembly.md:281
msgid ""
"Identical to `out` except that the register allocator can reuse a register "
"allocated to an `in`."
msgstr "`out`과 동일하지만, 레지스터 할당기가 `in`에 할당된 레지스터를 재사용할 수 있습니다."

#: src/inline-assembly.md:282 src/inline-assembly.md:333
msgid ""
"You should only write to the register after all inputs are read, otherwise "
"you may clobber an input."
msgstr ""
"모든 입력이 읽힌 후에만 레지스터에 기록해야 합니다. 그렇지 않으면 입력을 "
"덮어쓸(clobber) 수 있습니다."

#: src/inline-assembly.md:286
msgid ""
"// `lateout` is the same as `out`\n"
"// but the compiler knows we don't care about the value of any inputs by "
"the\n"
"// time we overwrite it.\n"
msgstr ""
"// `lateout`은 `out`과 동일하지만,\n"
"// 우리가 값을 덮어쓸 시점에 입력값들에 대해 더 이상 신경 쓰지 않는다는 것을\n"
"// 컴파일러가 알고 있습니다.\n"

#: src/inline-assembly.md:290
msgid "\"mov {}, 5\""
msgstr "\"mov {}, 5\""

#: src/inline-assembly.md:297
msgid "`inout(<reg>) <expr>`"
msgstr "`inout(<reg>) <expr>`"

#: src/inline-assembly.md:301
msgid ""
"`<expr>` must be a mutable initialized place expression, to which the "
"contents of the allocated register are written at the end of the asm code."
msgstr ""
"`<expr>`은 가변적이고 초기화된 장소 표현식이어야 하며, asm 코드의 끝에서 "
"할당된 레지스터의 내용이 여기에 기록됩니다."

#: src/inline-assembly.md:305
msgid "// `inout` can be used to modify values in-register\n"
msgstr "// `inout`은 레지스터 내에서 값을 수정하는 데 사용될 수 있습니다.\n"

#: src/inline-assembly.md:307 src/inline-assembly.md:324
#: src/inline-assembly.md:339 src/inline-assembly.md:1024
#: src/inline-assembly.md:1035
msgid "\"inc {}\""
msgstr "\"inc {}\""

#: src/inline-assembly.md:314
msgid "`inout(<reg>) <in expr> => <out expr>`"
msgstr "`inout(<reg>) <in expr> => <out expr>`"

#: src/inline-assembly.md:315
msgid ""
"Same as `inout` except that the initial value of the register is taken from "
"the value of `<in expr>`."
msgstr "`inout`과 동일하지만, 레지스터의 초기값이 `<in expr>`의 값에서 취해집니다."

#: src/inline-assembly.md:316
msgid ""
"`<out expr>` must be a (possibly uninitialized) place expression, to which "
"the contents of the allocated register are written at the end of the asm "
"code."
msgstr ""
"`<out expr>`은 (초기화되지 않았을 수도 있는) 장소 표현식이어야 하며, "
"asm 코드의 끝에서 할당된 레지스터의 내용이 여기에 기록됩니다."

#: src/inline-assembly.md:317
msgid ""
"An underscore (`_`) may be specified instead of an expression for `<out "
"expr>`, which will cause the contents of the register to be discarded at the "
"end of the asm code (effectively acting as a clobber)."
msgstr ""
"`<out expr>` 대신 밑줄(`_`)을 지정할 수 있으며, 이 경우 asm 코드 끝에서 "
"레지스터의 내용이 버려집니다(실질적으로 클로버로 작동함)."

#: src/inline-assembly.md:318
msgid "`<in expr>` and `<out expr>` may have different types."
msgstr "`<in expr>`과 `<out expr>`은 서로 다른 타입을 가질 수 있습니다."

#: src/inline-assembly.md:322
msgid "// `inout` can also move values to different places\n"
msgstr "// `inout`은 또한 값을 다른 장소로 이동시킬 수 있습니다.\n"

#: src/inline-assembly.md:331
msgid "`inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`"
msgstr "`inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`"

#: src/inline-assembly.md:332
msgid ""
"Identical to `inout` except that the register allocator can reuse a register "
"allocated to an `in` (this can happen if the compiler knows the `in` has the "
"same initial value as the `inlateout`)."
msgstr ""
"`inout`과 동일하지만, 레지스터 할당기가 `in`에 할당된 레지스터를 재사용할 수 있습니다"
"(이는 컴파일러가 `in`이 `inlateout`과 동일한 초기값을 갖는다는 것을 아는 경우 발생할 수 있습니다)."

#: src/inline-assembly.md:337
msgid "// `inlateout` is `inout` using `lateout`\n"
msgstr "// `inlateout`은 `lateout`을 사용하는 `inout`입니다.\n"

#: src/inline-assembly.md:346
msgid "`sym <path>`"
msgstr "`sym <path>`"

#: src/inline-assembly.md:347
msgid "`<path>` must refer to a `fn` or `static`."
msgstr "`<path>`는 `fn` 또는 `static`을 참조해야 합니다."

#: src/inline-assembly.md:348
msgid ""
"A mangled symbol name referring to the item is substituted into the asm "
"template string."
msgstr "해당 아이템을 참조하는 맹글링된(mangled) 심볼 이름이 asm 템플릿 문자열에 치환됩니다."

#: src/inline-assembly.md:349
msgid ""
"The substituted string does not include any modifiers (e.g. GOT, PLT, "
"relocations, etc)."
msgstr "치환된 문자열에는 어떠한 수식어(예: GOT, PLT, 재배치(relocations) 등)도 포함되지 않습니다."

#: src/inline-assembly.md:350
msgid ""
"`<path>` is allowed to point to a `#[thread_local]` static, in which case "
"the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) "
"to read from thread-local data."
msgstr ""
"`<path>`는 `#[thread_local]` 정적 변수를 가리킬 수 있으며, 이 경우 asm 코드는 "
"심볼을 재배치(relocations, 예: `@plt`, `@TPOFF`)와 결합하여 스레드 로컬 데이터를 "
"읽을 수 있습니다."

#: src/inline-assembly.md:355
msgid "\"Hello from inline assembly\""
msgstr "\"Hello from inline assembly\""

#: src/inline-assembly.md:356
msgid ""
"// `sym` can be used to refer to a function (even if it doesn't have an\n"
"// external name we can directly write)\n"
msgstr "// `sym`은 (직접 쓸 수 있는 외부 이름이 없는 경우에도) 함수를 참조하는 데 사용될 수 있습니다.\n"

#: src/inline-assembly.md:359 src/inline-assembly.md:921
#: src/inline-assembly.md:940 src/inline-assembly.md:942
#: src/inline-assembly.md:966
msgid "\"call {}\""
msgstr "\"call {}\""

#: src/inline-assembly.md:363
msgid "`const <expr>`"
msgstr "`const <expr>`"

#: src/inline-assembly.md:364
msgid ""
"`<expr>` must be an integer constant expression. This expression follows the "
"same rules as inline `const` blocks."
msgstr ""
"`<expr>`은 정수 상수 표현식이어야 합니다. 이 표현식은 인라인 `const` 블록과 동일한 "
"규칙을 따릅니다."

#: src/inline-assembly.md:365
msgid ""
"The type of the expression may be any integer type, but defaults to `i32` "
"just like integer literals."
msgstr ""
"표현식의 타입은 모든 정수 타입이 될 수 있지만, 정수 리터럴과 마찬가지로 기본값은 `i32`입니다."

#: src/inline-assembly.md:366
msgid ""
"The value of the expression is formatted as a string and substituted "
"directly into the asm template string."
msgstr "표현식의 값은 문자열로 포맷되어 asm 템플릿 문자열에 직접 치환됩니다."

#: src/inline-assembly.md:369
msgid "// swizzle [0, 1, 2, 3] => [3, 2, 0, 1]\n"
msgstr "// swizzle [0, 1, 2, 3] => [3, 2, 0, 1]\n"

#: src/inline-assembly.md:373
msgid ""
"// Pass a constant value into an instruction that expects an immediate like "
"`pshufd`\n"
msgstr "// `pshufd`와 같이 즉시값(immediate)을 기대하는 명령어에 상수 값을 전달합니다.\n"

#: src/inline-assembly.md:376
msgid "\"pshufd {xmm}, {xmm}, {shuffle}\""
msgstr "\"pshufd {xmm}, {xmm}, {shuffle}\""

#: src/inline-assembly.md:388
msgid ""
"Operand expressions are evaluated from left to right, just like function "
"call arguments. After the `asm!` has executed, outputs are written to in "
"left to right order. This is significant if two outputs point to the same "
"place: that place will contain the value of the rightmost output."
msgstr ""
"피연산자 표현식은 함수 호출 인자와 마찬가지로 왼쪽에서 오른쪽으로 평가됩니다. "
"`asm!`이 실행된 후, 출력값들은 왼쪽에서 오른쪽 순서로 기록됩니다. 이는 두 개의 출력이 "
"동일한 장소를 가리킬 때 중요합니다. 해당 장소는 가장 오른쪽에 있는 출력값을 갖게 됩니다."

#: src/inline-assembly.md:394
msgid "// y gets its value from the second output, rather than the first\n"
msgstr "// y는 첫 번째 출력이 아니라 두 번째 출력에서 값을 가져옵니다.\n"

#: src/inline-assembly.md:396
msgid "\"mov {}, 0\""
msgstr "\"mov {}, 0\""

#: src/inline-assembly.md:396
msgid "\"mov {}, 1\""
msgstr "\"mov {}, 1\""

#: src/inline-assembly.md:403
msgid ""
"Since `global_asm!` exists outside a function, it can only use `sym` and "
"`const` operands."
msgstr ""
"`global_asm!`은 함수 외부에 존재하므로, `sym` 및 `const` 피연산자만 사용할 수 있습니다."

#: src/inline-assembly.md:407
msgid "// register operands aren't allowed, since we aren't in a function\n"
msgstr "// 함수 내부에 있지 않으므로 레지스터 피연산자는 허용되지 않습니다.\n"

#: src/inline-assembly.md:410
msgid "// ERROR: the `in` operand cannot be used with `global_asm!`\n"
msgstr "// 오류: `in` 피연산자는 `global_asm!`과 함께 사용될 수 없습니다.\n"

#: src/inline-assembly.md:419
msgid "// `const` and `sym` are both allowed, however\n"
msgstr "// 하지만 `const`와 `sym`은 모두 허용됩니다.\n"

#: src/inline-assembly.md:421
msgid "\"/* {} {} */\""
msgstr "\"/* {} {} */\""

#: src/inline-assembly.md:426
msgid "Register operands"
msgstr "레지스터 피연산자"

#: src/inline-assembly.md:430
msgid ""
"Input and output operands can be specified either as an explicit register or "
"as a register class from which the register allocator can select a register. "
"Explicit registers are specified as string literals (e.g. `\"eax\"`) while "
"register classes are specified as identifiers (e.g. `reg`)."
msgstr ""
"입력 및 출력 피연산자는 명시적 레지스터로 지정하거나, 레지스터 할당기가 레지스터를 "
"선택할 수 있는 레지스터 클래스로 지정할 수 있습니다. 명시적 레지스터는 문자열 "
"리터럴(예: `\"eax\"`)로 지정되며, 레지스터 클래스는 식별자(예: `reg`)로 지정됩니다."

#: src/inline-assembly.md:435
msgid ""
"// We can name both `reg`, or an explicit register like `eax` to get an\n"
"// integer register\n"
msgstr "// `reg` 또는 `eax`와 같은 명시적 레지스터를 지정하여 정수 레지스터를 얻을 수 있습니다.\n"

#: src/inline-assembly.md:438 src/inline-assembly.md:965
msgid "\"mov eax, {:e}\""
msgstr "\"mov eax, {:e}\""

#: src/inline-assembly.md:445
msgid ""
"Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on "
"ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to "
"the base register."
msgstr ""
"명시적 레지스터는 레지스터 별칭(예: ARM의 `r14` 대 `lr`) 및 레지스터의 더 작은 뷰"
"(예: `eax` 대 `rax`)를 베이스 레지스터와 동일하게 취급함에 유의하십시오."

#: src/inline-assembly.md:449
msgid ""
"It is a compile-time error to use the same explicit register for two input "
"operands or two output operands."
msgstr ""
"두 개의 입력 피연산자 또는 두 개의 출력 피연산자에 동일한 명시적 레지스터를 "
"사용하는 것은 컴파일 타임 오류입니다."

#: src/inline-assembly.md:452
msgid "// We can't name eax twice\n"
msgstr "// eax를 두 번 지정할 수 없습니다.\n"

#: src/inline-assembly.md:454
msgid "// ERROR: register `eax` conflicts with register `eax`\n"
msgstr "// 오류: `eax` 레지스터가 `eax` 레지스터와 충돌합니다.\n"

#: src/inline-assembly.md:460
msgid "// ... even using different aliases\n"
msgstr "// ... 서로 다른 별칭을 사용하더라도 마찬가지입니다.\n"

#: src/inline-assembly.md:462 src/inline-assembly.md:476
msgid "\"ax\""
msgstr "\"ax\""

#: src/inline-assembly.md:462
msgid "// ERROR: register `rax` conflicts with register `ax`\n"
msgstr "// 오류: `rax` 레지스터가 `ax` 레지스터와 충돌합니다.\n"

#: src/inline-assembly.md:470
msgid ""
"Additionally, it is also a compile-time error to use overlapping registers "
"(e.g. ARM VFP) in input operands or in output operands."
msgstr ""
"또한, 입력 피연산자 또는 출력 피연산자에서 겹치는 레지스터(예: ARM VFP)를 "
"사용하는 것도 컴파일 타임 오류입니다."

#: src/inline-assembly.md:474
msgid "// al overlaps with ax, so we can't name both of them.\n"
msgstr "// al은 ax와 겹치므로 둘 다 지정할 수 없습니다.\n"

#: src/inline-assembly.md:476
msgid "\"al\""
msgstr "\"al\""

#: src/inline-assembly.md:476
msgid "// ERROR: register `al` conflicts with register `ax`\n"
msgstr "// 오류: `al` 레지스터가 `ax` 레지스터와 충돌합니다.\n"

#: src/inline-assembly.md:484
msgid "Only the following types are allowed as operands for inline assembly:"
msgstr "인라인 어셈블리의 피연산자로는 다음 타입들만 허용됩니다:"

#: src/inline-assembly.md:485
msgid "Integers (signed and unsigned)"
msgstr "정수 (부호 있는 것과 부호 없는 것)"

#: src/inline-assembly.md:486
msgid "Floating-point numbers"
msgstr "부동 소수점 숫자"

#: src/inline-assembly.md:487
msgid "Pointers (thin only)"
msgstr "포인터 (thin 포인터만)"

#: src/inline-assembly.md:488
msgid "Function pointers"
msgstr "함수 포인터"

#: src/inline-assembly.md:489
msgid ""
"SIMD vectors (structs defined with `#[repr(simd)]` and which implement "
"`Copy`). This includes architecture-specific vector types defined in "
"`std::arch` such as `__m128` (x86) or `int8x16_t` (ARM)."
msgstr ""
"SIMD 벡터 (`#[repr(simd)]`로 정의되고 `Copy`를 구현하는 구조체). "
"이는 `std::arch`에 정의된 아키텍처별 벡터 타입(예: x86의 `__m128` 또는 "
"ARM의 `int8x16_t`)을 포함합니다."

#: src/inline-assembly.md:495
msgid "// Integers are allowed...\n"
msgstr "// 정수는 허용됩니다...\n"

#: src/inline-assembly.md:499
msgid "// and pointers...\n"
msgstr "// 포인터도 허용되며...\n"

#: src/inline-assembly.md:503
msgid "// floats as well...\n"
msgstr "// 부동 소수점 역시 허용됩니다...\n"

#: src/inline-assembly.md:507
msgid "// even function pointers and simd vectors.\n"
msgstr "// 함수 포인터와 simd 벡터까지도 허용됩니다.\n"

#: src/inline-assembly.md:520
msgid "// Complex types like structs are not allowed\n"
msgstr "// 구조체와 같은 복합 타입은 허용되지 않습니다.\n"

#: src/inline-assembly.md:522
msgid "// ERROR: cannot use value of type `Foo` for inline assembly\n"
msgstr "// 오류: 인라인 어셈블리에 `Foo` 타입의 값을 사용할 수 없습니다.\n"

#: src/inline-assembly.md:530
msgid "Here is the list of currently supported register classes:"
msgstr "현재 지원되는 레지스터 클래스 목록입니다:"

#: src/inline-assembly.md:532 src/inline-assembly.md:586
#: src/inline-assembly.md:701 src/inline-assembly.md:777
#: src/inline-assembly.md:838 src/inline-assembly.md:986
msgid "Architecture"
msgstr "아키텍처"

#: src/inline-assembly.md:532 src/inline-assembly.md:586
#: src/inline-assembly.md:838
msgid "Register class"
msgstr "레지스터 클래스"

#: src/inline-assembly.md:532
msgid "Registers"
msgstr "레지스터"

#: src/inline-assembly.md:532
msgid "LLVM constraint code"
msgstr "LLVM 제약 코드"

#: src/inline-assembly.md:534 src/inline-assembly.md:535
#: src/inline-assembly.md:538 src/inline-assembly.md:539
#: src/inline-assembly.md:540 src/inline-assembly.md:541
#: src/inline-assembly.md:542 src/inline-assembly.md:543
#: src/inline-assembly.md:544 src/inline-assembly.md:590
#: src/inline-assembly.md:591 src/inline-assembly.md:592
#: src/inline-assembly.md:593 src/inline-assembly.md:594
#: src/inline-assembly.md:595 src/inline-assembly.md:596
#: src/inline-assembly.md:597 src/inline-assembly.md:598
#: src/inline-assembly.md:703 src/inline-assembly.md:704
#: src/inline-assembly.md:705 src/inline-assembly.md:706
#: src/inline-assembly.md:707 src/inline-assembly.md:708
#: src/inline-assembly.md:709 src/inline-assembly.md:710
#: src/inline-assembly.md:711 src/inline-assembly.md:712
#: src/inline-assembly.md:713 src/inline-assembly.md:714
#: src/inline-assembly.md:783 src/inline-assembly.md:844
#: src/inline-assembly.md:845 src/inline-assembly.md:846
#: src/inline-assembly.md:848 src/inline-assembly.md:849
#: src/inline-assembly.md:850 src/inline-assembly.md:851
#: src/inline-assembly.md:852 src/inline-assembly.md:853
#: src/inline-assembly.md:854 src/inline-assembly.md:855
#: src/inline-assembly.md:1326
msgid "x86"
msgstr "x86"

#: src/inline-assembly.md:534 src/inline-assembly.md:546
#: src/inline-assembly.md:550 src/inline-assembly.md:553
#: src/inline-assembly.md:554 src/inline-assembly.md:563
#: src/inline-assembly.md:566 src/inline-assembly.md:568
#: src/inline-assembly.md:588 src/inline-assembly.md:589
#: src/inline-assembly.md:599 src/inline-assembly.md:602
#: src/inline-assembly.md:604 src/inline-assembly.md:608
#: src/inline-assembly.md:609 src/inline-assembly.md:613
#: src/inline-assembly.md:840 src/inline-assembly.md:841
#: src/inline-assembly.md:843 src/inline-assembly.md:845
#: src/inline-assembly.md:846 src/inline-assembly.md:847
#: src/inline-assembly.md:856 src/inline-assembly.md:857
#: src/inline-assembly.md:858 src/inline-assembly.md:866
#: src/inline-assembly.md:871 src/inline-assembly.md:873
#: src/inline-assembly.md:875
msgid "`reg`"
msgstr "`reg`"

#: src/inline-assembly.md:534
msgid "`ax`, `bx`, `cx`, `dx`, `si`, `di`, `bp`, `r[8-15]` (x86-64 only)"
msgstr "`ax`, `bx`, `cx`, `dx`, `si`, `di`, `bp`, `r[8-15]` (x86-64 전용)"

#: src/inline-assembly.md:534 src/inline-assembly.md:546
#: src/inline-assembly.md:550 src/inline-assembly.md:553
#: src/inline-assembly.md:554 src/inline-assembly.md:563
#: src/inline-assembly.md:566 src/inline-assembly.md:568
#: src/inline-assembly.md:847
msgid "`r`"
msgstr "`r`"

#: src/inline-assembly.md:535 src/inline-assembly.md:842
#: src/inline-assembly.md:844
msgid "`reg_abcd`"
msgstr "`reg_abcd`"

#: src/inline-assembly.md:535
msgid "`ax`, `bx`, `cx`, `dx`"
msgstr "`ax`, `bx`, `cx`, `dx`"

#: src/inline-assembly.md:535
msgid "`Q`"
msgstr "`Q`"

#: src/inline-assembly.md:536 src/inline-assembly.md:588
#: src/inline-assembly.md:840 src/inline-assembly.md:842
#: src/inline-assembly.md:988
msgid "x86-32"
msgstr "x86-32"

#: src/inline-assembly.md:536 src/inline-assembly.md:590
#: src/inline-assembly.md:848
msgid "`reg_byte`"
msgstr "`reg_byte`"

#: src/inline-assembly.md:536
msgid "`al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh`"
msgstr "`al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh`"

#: src/inline-assembly.md:536 src/inline-assembly.md:537
#: src/inline-assembly.md:841 src/inline-assembly.md:847
#: src/inline-assembly.md:865 src/inline-assembly.md:869
msgid "`q`"
msgstr "`q`"

#: src/inline-assembly.md:537 src/inline-assembly.md:545
#: src/inline-assembly.md:589 src/inline-assembly.md:841
#: src/inline-assembly.md:843 src/inline-assembly.md:847
#: src/inline-assembly.md:989 src/inline-assembly.md:990
msgid "x86-64"
msgstr "x86-64"

#: src/inline-assembly.md:537
msgid "`reg_byte`\\*"
msgstr "`reg_byte`*"

#: src/inline-assembly.md:537
msgid "`al`, `bl`, `cl`, `dl`, `sil`, `dil`, `bpl`, `r[8-15]b`"
msgstr "`al`, `bl`, `cl`, `dl`, `sil`, `dil`, `bpl`, `r[8-15]b`"

#: src/inline-assembly.md:538 src/inline-assembly.md:591
#: src/inline-assembly.md:849
msgid "`xmm_reg`"
msgstr "`xmm_reg`"

#: src/inline-assembly.md:538
msgid "`xmm[0-7]` (x86) `xmm[0-15]` (x86-64)"
msgstr "`xmm[0-7]` (x86) `xmm[0-15]` (x86-64)"

#: src/inline-assembly.md:538 src/inline-assembly.md:539
#: src/inline-assembly.md:548 src/inline-assembly.md:552
#: src/inline-assembly.md:556 src/inline-assembly.md:559
#: src/inline-assembly.md:562 src/inline-assembly.md:845
#: src/inline-assembly.md:849 src/inline-assembly.md:852
#: src/inline-assembly.md:856 src/inline-assembly.md:858
msgid "`x`"
msgstr "`x`"

#: src/inline-assembly.md:539 src/inline-assembly.md:592
#: src/inline-assembly.md:850
msgid "`ymm_reg`"
msgstr "`ymm_reg`"

#: src/inline-assembly.md:539
msgid "`ymm[0-7]` (x86) `ymm[0-15]` (x86-64)"
msgstr "`ymm[0-7]` (x86) `ymm[0-15]` (x86-64)"

#: src/inline-assembly.md:540 src/inline-assembly.md:593
#: src/inline-assembly.md:851
msgid "`zmm_reg`"
msgstr "`zmm_reg`"

#: src/inline-assembly.md:540
msgid "`zmm[0-7]` (x86) `zmm[0-31]` (x86-64)"
msgstr "`zmm[0-7]` (x86) `zmm[0-31]` (x86-64)"

#: src/inline-assembly.md:540 src/inline-assembly.md:860
msgid "`v`"
msgstr "`v`"

#: src/inline-assembly.md:541 src/inline-assembly.md:594
#: src/inline-assembly.md:595 src/inline-assembly.md:855
msgid "`kreg`"
msgstr "`kreg`"

#: src/inline-assembly.md:541
msgid "`k[1-7]`"
msgstr "`k[1-7]`"

#: src/inline-assembly.md:541
msgid "`Yk`"
msgstr "`Yk`"

#: src/inline-assembly.md:542
msgid "`kreg0`"
msgstr "`kreg0`"

#: src/inline-assembly.md:542
msgid "`k0`"
msgstr "`k0`"

#: src/inline-assembly.md:542 src/inline-assembly.md:543
#: src/inline-assembly.md:544 src/inline-assembly.md:545
#: src/inline-assembly.md:549 src/inline-assembly.md:565
#: src/inline-assembly.md:571 src/inline-assembly.md:572
#: src/inline-assembly.md:596 src/inline-assembly.md:597
#: src/inline-assembly.md:598 src/inline-assembly.md:601
#: src/inline-assembly.md:612 src/inline-assembly.md:618
#: src/inline-assembly.md:619
msgid "Only clobbers"
msgstr "클로버(clobbers) 전용"

#: src/inline-assembly.md:543 src/inline-assembly.md:597
msgid "`x87_reg`"
msgstr "`x87_reg`"

#: src/inline-assembly.md:543
msgid "`st([0-7])`"
msgstr "`st([0-7])`"

#: src/inline-assembly.md:544 src/inline-assembly.md:596
msgid "`mmx_reg`"
msgstr "`mmx_reg`"

#: src/inline-assembly.md:544
msgid "`mm[0-7]`"
msgstr "`mm[0-7]`"

#: src/inline-assembly.md:545 src/inline-assembly.md:598
msgid "`tmm_reg`"
msgstr "`tmm_reg`"

#: src/inline-assembly.md:545
msgid "`tmm[0-7]`"
msgstr "`tmm[0-7]`"

#: src/inline-assembly.md:546 src/inline-assembly.md:547
#: src/inline-assembly.md:548 src/inline-assembly.md:549
#: src/inline-assembly.md:599 src/inline-assembly.md:600
#: src/inline-assembly.md:601 src/inline-assembly.md:715
#: src/inline-assembly.md:716 src/inline-assembly.md:717
#: src/inline-assembly.md:718 src/inline-assembly.md:719
#: src/inline-assembly.md:720 src/inline-assembly.md:784
#: src/inline-assembly.md:785 src/inline-assembly.md:991
msgid "AArch64"
msgstr "AArch64"

#: src/inline-assembly.md:546 src/inline-assembly.md:715
#: src/inline-assembly.md:721
msgid "`x[0-30]`"
msgstr "`x[0-30]`"

#: src/inline-assembly.md:547 src/inline-assembly.md:551
#: src/inline-assembly.md:565 src/inline-assembly.md:571
#: src/inline-assembly.md:600 src/inline-assembly.md:603
#: src/inline-assembly.md:612 src/inline-assembly.md:618
#: src/inline-assembly.md:859 src/inline-assembly.md:860
#: src/inline-assembly.md:861 src/inline-assembly.md:862
#: src/inline-assembly.md:863 src/inline-assembly.md:864
#: src/inline-assembly.md:865
msgid "`vreg`"
msgstr "`vreg`"

#: src/inline-assembly.md:547 src/inline-assembly.md:565
#: src/inline-assembly.md:571 src/inline-assembly.md:720
msgid "`v[0-31]`"
msgstr "`v[0-31]`"

#: src/inline-assembly.md:547 src/inline-assembly.md:551
#: src/inline-assembly.md:557 src/inline-assembly.md:560
#: src/inline-assembly.md:845 src/inline-assembly.md:857
msgid "`w`"
msgstr "`w`"

#: src/inline-assembly.md:548 src/inline-assembly.md:552
msgid "`vreg_low16`"
msgstr "`vreg_low16`"

#: src/inline-assembly.md:548 src/inline-assembly.md:551
#: src/inline-assembly.md:552 src/inline-assembly.md:726
msgid "`v[0-15]`"
msgstr "`v[0-15]`"

#: src/inline-assembly.md:549 src/inline-assembly.md:601
msgid "`preg`"
msgstr "`preg`"

#: src/inline-assembly.md:549
msgid "`p[0-15]`, `ffr`"
msgstr "`p[0-15]`, `ffr`"

#: src/inline-assembly.md:550 src/inline-assembly.md:551
#: src/inline-assembly.md:552 src/inline-assembly.md:602
#: src/inline-assembly.md:603 src/inline-assembly.md:721
#: src/inline-assembly.md:722 src/inline-assembly.md:723
#: src/inline-assembly.md:724 src/inline-assembly.md:725
#: src/inline-assembly.md:726 src/inline-assembly.md:786
#: src/inline-assembly.md:787 src/inline-assembly.md:788
#: src/inline-assembly.md:992
msgid "Arm64EC"
msgstr "Arm64EC"

#: src/inline-assembly.md:550
msgid "`x[0-12]`, `x[15-22]`, `x[25-27]`, `x30`"
msgstr "`x[0-12]`, `x[15-22]`, `x[25-27]`, `x30`"

#: src/inline-assembly.md:553
msgid "ARM (ARM/Thumb2)"
msgstr "ARM (ARM/Thumb2)"

#: src/inline-assembly.md:553
msgid "`r[0-12]`, `r14`"
msgstr "`r[0-12]`, `r14`"

#: src/inline-assembly.md:554
msgid "ARM (Thumb1)"
msgstr "ARM (Thumb1)"

#: src/inline-assembly.md:554
msgid "`r[0-7]`"
msgstr "`r[0-7]`"

#: src/inline-assembly.md:555 src/inline-assembly.md:605
#: src/inline-assembly.md:867
msgid "`sreg`"
msgstr "`sreg`"

#: src/inline-assembly.md:555
msgid "`s[0-31]`"
msgstr "`s[0-31]`"

#: src/inline-assembly.md:555 src/inline-assembly.md:558
#: src/inline-assembly.md:561 src/inline-assembly.md:850
#: src/inline-assembly.md:853
msgid "`t`"
msgstr "`t`"

#: src/inline-assembly.md:556
msgid "`sreg_low16`"
msgstr "`sreg_low16`"

#: src/inline-assembly.md:556
msgid "`s[0-15]`"
msgstr "`s[0-15]`"

#: src/inline-assembly.md:557 src/inline-assembly.md:606
#: src/inline-assembly.md:868
msgid "`dreg`"
msgstr "`dreg`"

#: src/inline-assembly.md:557
msgid "`d[0-31]`"
msgstr "`d[0-31]`"

#: src/inline-assembly.md:558
msgid "`dreg_low16`"
msgstr "`dreg_low16`"

#: src/inline-assembly.md:558
msgid "`d[0-15]`"
msgstr "`d[0-15]`"

#: src/inline-assembly.md:559
msgid "`dreg_low8`"
msgstr "`dreg_low8`"

#: src/inline-assembly.md:559
msgid "`d[0-8]`"
msgstr "`d[0-8]`"

#: src/inline-assembly.md:560 src/inline-assembly.md:607
#: src/inline-assembly.md:869 src/inline-assembly.md:870
msgid "`qreg`"
msgstr "`qreg`"

#: src/inline-assembly.md:560
msgid "`q[0-15]`"
msgstr "`q[0-15]`"

#: src/inline-assembly.md:561
msgid "`qreg_low8`"
msgstr "`qreg_low8`"

#: src/inline-assembly.md:561
msgid "`q[0-7]`"
msgstr "`q[0-7]`"

#: src/inline-assembly.md:562
msgid "`qreg_low4`"
msgstr "`qreg_low4`"

#: src/inline-assembly.md:562
msgid "`q[0-3]`"
msgstr "`q[0-3]`"

#: src/inline-assembly.md:563
msgid "`x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E)"
msgstr "`x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E)"

#: src/inline-assembly.md:564 src/inline-assembly.md:567
#: src/inline-assembly.md:570 src/inline-assembly.md:610
#: src/inline-assembly.md:611 src/inline-assembly.md:614
#: src/inline-assembly.md:615 src/inline-assembly.md:617
#: src/inline-assembly.md:872 src/inline-assembly.md:874
#: src/inline-assembly.md:877
msgid "`freg`"
msgstr "`freg`"

#: src/inline-assembly.md:564
msgid "`f[0-31]`"
msgstr "`f[0-31]`"

#: src/inline-assembly.md:564 src/inline-assembly.md:567
#: src/inline-assembly.md:570 src/inline-assembly.md:610
#: src/inline-assembly.md:614
msgid "`f`"
msgstr "`f`"

#: src/inline-assembly.md:566
msgid "`$r1`, `$r[4-20]`, `$r[23,30]`"
msgstr "`$r1`, `$r[4-20]`, `$r[23,30]`"

#: src/inline-assembly.md:567
msgid "`$f[0-31]`"
msgstr "`$f[0-31]`"

#: src/inline-assembly.md:568
msgid "`r[0-10]`, `r[12-14]`"
msgstr "`r[0-10]`, `r[12-14]`"

#: src/inline-assembly.md:569 src/inline-assembly.md:876
msgid "`reg_addr`"
msgstr "`reg_addr`"

#: src/inline-assembly.md:569
msgid "`r[1-10]`, `r[12-14]`"
msgstr "`r[1-10]`, `r[12-14]`"

#: src/inline-assembly.md:570
msgid "`f[0-15]`"
msgstr "`f[0-15]`"

#: src/inline-assembly.md:572 src/inline-assembly.md:619
msgid "`areg`"
msgstr "`areg`"

#: src/inline-assembly.md:572
msgid "`a[2-15]`"
msgstr "`a[2-15]`"

#: src/inline-assembly.md:575
msgid ""
"On x86 we treat `reg_byte` differently from `reg` because the compiler can "
"allocate `al` and `ah` separately whereas `reg` reserves the whole register."
msgstr ""
"x86에서 `reg_byte`는 `reg`와 다르게 취급됩니다. 그 이유는 컴파일러가 "
"`al`과 `ah`를 별도로 할당할 수 있는 반면, `reg`는 레지스터 전체를 예약하기 때문입니다."

#: src/inline-assembly.md:576
msgid ""
"On x86-64 the high byte registers (e.g. `ah`) are not available in the "
"`reg_byte` register class."
msgstr "x86-64에서 고위 바이트 레지스터(예: `ah`)는 `reg_byte` 레지스터 클래스에서 사용할 수 없습니다."

#: src/inline-assembly.md:577
msgid ""
"Some register classes are marked as \"Only clobbers\" which means that "
"registers in these classes cannot be used for inputs or outputs, only "
"clobbers of the form `out(<explicit register>) _` or `lateout(<explicit "
"register>) _`."
msgstr ""
"일부 레지스터 클래스는 \"클로버 전용(Only clobbers)\"으로 표시되어 있습니다. "
"이는 해당 클래스의 레지스터를 입력이나 출력에 사용할 수 없으며, 오직 "
"`out(<explicit register>) _` 또는 `lateout(<explicit register>) _` 형식의 "
"클로버로만 사용할 수 있음을 의미합니다."

#: src/inline-assembly.md:581
msgid ""
"Each register class has constraints on which value types they can be used "
"with. This is necessary because the way a value is loaded into a register "
"depends on its type. For example, on big-endian systems, loading a `i32x4` "
"and a `i8x16` into a SIMD register may result in different register contents "
"even if the byte-wise memory representation of both values is identical. The "
"availability of supported types for a particular register class may depend "
"on what target features are currently enabled."
msgstr ""
"각 레지스터 클래스는 사용할 수 있는 값의 타입에 대한 제약 조건을 가집니다. "
"이는 값이 레지스터에 로드되는 방식이 타입에 따라 다르기 때문에 필요합니다. "
"예를 들어, 빅 엔디안(big-endian) 시스템에서 `i32x4`와 `i8x16`을 SIMD 레지스터에 "
"로드하면, 두 값의 바이트 단위 메모리 표현이 동일하더라도 레지스터의 내용은 "
"서로 다를 수 있습니다. 특정 레지스터 클래스에서 지원되는 타입의 가용 여부는 "
"현재 활성화된 타겟 기능(target features)에 따라 달라질 수 있습니다."

#: src/inline-assembly.md:586
msgid "Target feature"
msgstr "타겟 기능"

#: src/inline-assembly.md:586
msgid "Allowed types"
msgstr "허용되는 타입"

#: src/inline-assembly.md:588 src/inline-assembly.md:589
#: src/inline-assembly.md:590 src/inline-assembly.md:599
#: src/inline-assembly.md:602 src/inline-assembly.md:604
#: src/inline-assembly.md:608 src/inline-assembly.md:609
#: src/inline-assembly.md:613 src/inline-assembly.md:616
#: src/inline-assembly.md:617 src/inline-assembly.md:840
#: src/inline-assembly.md:841 src/inline-assembly.md:848
#: src/inline-assembly.md:849 src/inline-assembly.md:850
#: src/inline-assembly.md:851 src/inline-assembly.md:855
#: src/inline-assembly.md:856 src/inline-assembly.md:859
#: src/inline-assembly.md:860 src/inline-assembly.md:866
#: src/inline-assembly.md:867 src/inline-assembly.md:868
#: src/inline-assembly.md:869 src/inline-assembly.md:871
#: src/inline-assembly.md:872 src/inline-assembly.md:873
#: src/inline-assembly.md:874 src/inline-assembly.md:875
#: src/inline-assembly.md:876 src/inline-assembly.md:877
msgid "None"
msgstr "없음"

#: src/inline-assembly.md:588
msgid "`i16`, `i32`, `f32`"
msgstr "`i16`, `i32`, `f32`"

#: src/inline-assembly.md:589
msgid "`i16`, `i32`, `f32`, `i64`, `f64`"
msgstr "`i16`, `i32`, `f32`, `i64`, `f64`"

#: src/inline-assembly.md:591
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2`"
msgstr ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2`"

#: src/inline-assembly.md:592
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4`"
msgstr ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4`"

#: src/inline-assembly.md:593 src/inline-assembly.md:594
msgid "`avx512f`"
msgstr "`avx512f`"

#: src/inline-assembly.md:593
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` "
"<br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8`"
msgstr ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` "
"<br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8`"

#: src/inline-assembly.md:594
msgid "`i8`, `i16`"
msgstr "`i8`, `i16`"

#: src/inline-assembly.md:595
msgid "`avx512bw`"
msgstr "`avx512bw`"

#: src/inline-assembly.md:595
msgid "`i32`, `i64`"
msgstr "`i32`, `i64`"

#: src/inline-assembly.md:596 src/inline-assembly.md:597
#: src/inline-assembly.md:598 src/inline-assembly.md:601
#: src/inline-assembly.md:612 src/inline-assembly.md:618
#: src/inline-assembly.md:619
msgid "N/A"
msgstr "해당 없음 (N/A)"

#: src/inline-assembly.md:599 src/inline-assembly.md:602
#: src/inline-assembly.md:609
msgid "`i8`, `i16`, `i32`, `f32`, `i64`, `f64`"
msgstr "`i8`, `i16`, `i32`, `f32`, `i64`, `f64`"

#: src/inline-assembly.md:600 src/inline-assembly.md:603
msgid ""
"`i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, "
"`i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, "
"`f64x2`"
msgstr ""
"`i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, "
"`i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, "
"`f64x2`"

#: src/inline-assembly.md:604 src/inline-assembly.md:608
msgid "`i8`, `i16`, `i32`, `f32`"
msgstr "`i8`, `i16`, `i32`, `f32`"

#: src/inline-assembly.md:605 src/inline-assembly.md:606
msgid "`vfp2`"
msgstr "`vfp2`"

#: src/inline-assembly.md:605
msgid "`i32`, `f32`"
msgstr "`i32`, `f32`"

#: src/inline-assembly.md:606
msgid "`i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`"
msgstr "`i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`"

#: src/inline-assembly.md:607
msgid "`i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`"
msgstr "`i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`"

#: src/inline-assembly.md:608
msgid "RISC-V32"
msgstr "RISC-V32"

#: src/inline-assembly.md:609
msgid "RISC-V64"
msgstr "RISC-V64"

#: src/inline-assembly.md:611 src/inline-assembly.md:615
#: src/inline-assembly.md:864
msgid "`d`"
msgstr "`d`"

#: src/inline-assembly.md:613 src/inline-assembly.md:614
#: src/inline-assembly.md:615
msgid "LoongArch64"
msgstr "LoongArch64"

#: src/inline-assembly.md:613
msgid "`i8`, `i16`, `i32`, `i64`, `f32`, `f64`"
msgstr "`i8`, `i16`, `i32`, `i64`, `f32`, `f64`"

#: src/inline-assembly.md:616
msgid "`reg`, `reg_addr`"
msgstr "`reg`, `reg_addr`"

#: src/inline-assembly.md:616
msgid "`i8`, `i16`, `i32`, `i64`"
msgstr "`i8`, `i16`, `i32`, `i64`"

#: src/inline-assembly.md:621
msgid ""
"**Note**: For the purposes of the above table pointers, function pointers "
"and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/"
"`i64` depending on the target)."
msgstr ""
"**참고**: 위 표의 목적상 포인터, 함수 포인터 및 `isize`/`usize`는 타겟에 따라 "
"해당하는 정수 타입(`i16`/`i32`/`i64`)과 동일하게 취급됩니다."

#: src/inline-assembly.md:628
msgid ""
"// reg is valid for `i32`, `reg_byte` is valid for `i8`, and xmm_reg is "
"valid for `__m128i`\n"
"// We can't use `tmm0` as an input or output, but we can clobber it.\n"
msgstr ""
"// `reg`는 `i32`에 유효하고, `reg_byte`는 `i8`에 유효하며, `xmm_reg`는 `__m128i`에 유효합니다.\n"
"// `tmm0`는 입력이나 출력으로 사용할 수 없지만, 클로버(clobber)할 수는 있습니다.\n"

#: src/inline-assembly.md:631
msgid "\"/* {} {} {} */\""
msgstr "\"/* {} {} {} */\""

#: src/inline-assembly.md:631
msgid "\"tmm0\""
msgstr "\"tmm0\""

#: src/inline-assembly.md:637
msgid "// We can't pass an `__m128i` to a `reg` input\n"
msgstr "// `__m128i`를 `reg` 입력으로 전달할 수 없습니다.\n"

#: src/inline-assembly.md:639
msgid "// ERROR: type `__m128i` cannot be used with this register class\n"
msgstr "// 오류: `__m128i` 타입은 이 레지스터 클래스에 사용할 수 없습니다.\n"

#: src/inline-assembly.md:647
msgid ""
"If a value is of a smaller size than the register it is allocated in then "
"the upper bits of that register will have an undefined value for inputs and "
"will be ignored for outputs. The only exception is the `freg` register class "
"on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the "
"RISC-V architecture."
msgstr ""
"만약 할당된 레지스터보다 값의 크기가 작다면, 해당 레지스터의 상위 비트들은 "
"입력 시 정의되지 않은(undefined) 값을 갖게 되며 출력 시에는 무시됩니다. "
"유일한 예외는 RISC-V의 `freg` 레지스터 클래스로, RISC-V 아키텍처의 요구 사항에 따라 "
"`f32` 값은 `f64` 내에 NaN-boxed 됩니다."

#: src/inline-assembly.md:653
msgid "// Moving a 32-bit value into a 64-bit value, oops.\n"
msgstr "// 32비트 값을 64비트 값으로 옮기기, 이런.\n"

#: src/inline-assembly.md:655
msgid "// rustc warns about this behavior\n"
msgstr "// rustc는 이 동작에 대해 경고합니다.\n"

#: src/inline-assembly.md:656
msgid "// top 32-bits are indeterminate\n"
msgstr "// 상위 32비트는 불확정적입니다.\n"

#: src/inline-assembly.md:658
msgid "// This assertion is not guaranteed to succeed\n"
msgstr "// 이 단언(assertion)은 성공이 보장되지 않습니다.\n"

#: src/inline-assembly.md:659
msgid "// However, this one will succeed\n"
msgstr "// 하지만 이것은 성공할 것입니다.\n"

#: src/inline-assembly.md:665
msgid ""
"When separate input and output expressions are specified for an `inout` "
"operand, both expressions must have the same type. The only exception is if "
"both operands are pointers or integers, in which case they are only required "
"to have the same size. This restriction exists because the register "
"allocators in LLVM and GCC sometimes cannot handle tied operands with "
"different types."
msgstr ""
"`inout` 피연산자에 대해 별도의 입력 및 출력 표현식이 지정된 경우, 두 표현식은 "
"반드시 동일한 타입을 가져야 합니다. 유일한 예외는 두 피연산자가 모두 포인터이거나 "
"정수인 경우로, 이 경우에는 크기만 같으면 됩니다. 이 제한은 LLVM 및 GCC의 "
"레지스터 할당기가 서로 다른 타입을 가진 묶인(tied) 피연산자를 처리하지 못하는 "
"경우가 있기 때문에 존재합니다."

#: src/inline-assembly.md:670
msgid "// Pointers and integers can mix (as long as they are the same size)\n"
msgstr "// 포인터와 정수는 (크기가 같다면) 혼용될 수 있습니다.\n"

#: src/inline-assembly.md:673
msgid "// Transmute an `isize` to a `*mut ()`, using inline assembly magic\n"
msgstr "// 인라인 어셈블리의 마법을 사용하여 `isize`를 `*mut ()`로 변환(transmute)합니다.\n"

#: src/inline-assembly.md:675
msgid "\"/*{}*/\""
msgstr "\"/*{}*/\""

#: src/inline-assembly.md:676
msgid "// Extremely roundabout way to make a null pointer\n"
msgstr "// 널 포인터를 만드는 지극히 우회적인 방법\n"

#: src/inline-assembly.md:683
msgid "// But we can't reinterpret an `i32` to an `f32` like this\n"
msgstr "// 하지만 이런 식으로 `i32`를 `f32`로 재해석할 수는 없습니다.\n"

#: src/inline-assembly.md:685
msgid "// ERROR: incompatible types for asm inout argument\n"
msgstr "// 오류: asm inout 인자의 타입이 호환되지 않습니다.\n"

#: src/inline-assembly.md:693
msgid "Register names"
msgstr "레지스터 이름"

#: src/inline-assembly.md:697
msgid ""
"Some registers have multiple names. These are all treated by the compiler as "
"identical to the base register name. Here is the list of all supported "
"register aliases:"
msgstr ""
"일부 레지스터는 여러 개의 이름을 가집니다. 이들은 모두 컴파일러에 의해 "
"기본 레지스터 이름과 동일하게 취급됩니다. 다음은 지원되는 모든 레지스터 별칭 목록입니다."

#: src/inline-assembly.md:701
msgid "Base register"
msgstr "기본 레지스터"

#: src/inline-assembly.md:701
msgid "Aliases"
msgstr "별칭"

#: src/inline-assembly.md:703 src/inline-assembly.md:845
msgid "`ax`"
msgstr "`ax`"

#: src/inline-assembly.md:703
msgid "`eax`, `rax`"
msgstr "`eax`, `rax`"

#: src/inline-assembly.md:704
msgid "`bx`"
msgstr "`bx`"

#: src/inline-assembly.md:704
msgid "`ebx`, `rbx`"
msgstr "`ebx`, `rbx`"

#: src/inline-assembly.md:705
msgid "`cx`"
msgstr "`cx`"

#: src/inline-assembly.md:705
msgid "`ecx`, `rcx`"
msgstr "`ecx`, `rcx`"

#: src/inline-assembly.md:706
msgid "`dx`"
msgstr "`dx`"

#: src/inline-assembly.md:706
msgid "`edx`, `rdx`"
msgstr "`edx`, `rdx`"

#: src/inline-assembly.md:707
msgid "`si`"
msgstr "`si`"

#: src/inline-assembly.md:707
msgid "`esi`, `rsi`"
msgstr "`esi`, `rsi`"

#: src/inline-assembly.md:708
msgid "`di`"
msgstr "`di`"

#: src/inline-assembly.md:708
msgid "`edi`, `rdi`"
msgstr "`edi`, `rdi`"

#: src/inline-assembly.md:709
msgid "`bp`"
msgstr "`bp`"

#: src/inline-assembly.md:709
msgid "`bpl`, `ebp`, `rbp`"
msgstr "`bpl`, `ebp`, `rbp`"

#: src/inline-assembly.md:710 src/inline-assembly.md:718
#: src/inline-assembly.md:724 src/inline-assembly.md:733
#: src/inline-assembly.md:738
msgid "`sp`"
msgstr "`sp`"

#: src/inline-assembly.md:710
msgid "`spl`, `esp`, `rsp`"
msgstr "`spl`, `esp`, `rsp`"

#: src/inline-assembly.md:711 src/inline-assembly.md:732
#: src/inline-assembly.md:783
msgid "`ip`"
msgstr "`ip`"

#: src/inline-assembly.md:711
msgid "`eip`, `rip`"
msgstr "`eip`, `rip`"

#: src/inline-assembly.md:712
msgid "`st(0)`"
msgstr "`st(0)`"

#: src/inline-assembly.md:712
msgid "`st`"
msgstr "`st`"

#: src/inline-assembly.md:713
msgid "`r[8-15]`"
msgstr "`r[8-15]`"

#: src/inline-assembly.md:713
msgid "`r[8-15]b`, `r[8-15]w`, `r[8-15]d`"
msgstr "`r[8-15]b`, `r[8-15]w`, `r[8-15]d`"

#: src/inline-assembly.md:714
msgid "`xmm[0-31]`"
msgstr "`xmm[0-31]`"

#: src/inline-assembly.md:714
msgid "`ymm[0-31]`, `zmm[0-31]`"
msgstr "`ymm[0-31]`, `zmm[0-31]`"

#: src/inline-assembly.md:715 src/inline-assembly.md:721
msgid "`w[0-30]`"
msgstr "`w[0-30]`"

#: src/inline-assembly.md:716 src/inline-assembly.md:722
msgid "`x29`"
msgstr "`x29`"

#: src/inline-assembly.md:716 src/inline-assembly.md:722
#: src/inline-assembly.md:731
msgid "`fp`"
msgstr "`fp`"

#: src/inline-assembly.md:717 src/inline-assembly.md:723
msgid "`x30`"
msgstr "`x30`"

#: src/inline-assembly.md:717 src/inline-assembly.md:723
#: src/inline-assembly.md:734
msgid "`lr`"
msgstr "`lr`"

#: src/inline-assembly.md:718 src/inline-assembly.md:724
msgid "`wsp`"
msgstr "`wsp`"

#: src/inline-assembly.md:719 src/inline-assembly.md:725
#: src/inline-assembly.md:784 src/inline-assembly.md:786
msgid "`xzr`"
msgstr "`xzr`"

#: src/inline-assembly.md:719 src/inline-assembly.md:725
msgid "`wzr`"
msgstr "`wzr`"

#: src/inline-assembly.md:720
msgid "`b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]`"
msgstr "`b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]`"

#: src/inline-assembly.md:726
msgid "`b[0-15]`, `h[0-15]`, `s[0-15]`, `d[0-15]`, `q[0-15]`"
msgstr "`b[0-15]`, `h[0-15]`, `s[0-15]`, `d[0-15]`, `q[0-15]`"

#: src/inline-assembly.md:727
msgid "`r[0-3]`"
msgstr "`r[0-3]`"

#: src/inline-assembly.md:727
msgid "`a[1-4]`"
msgstr "`a[1-4]`"

#: src/inline-assembly.md:728
msgid "`r[4-9]`"
msgstr "`r[4-9]`"

#: src/inline-assembly.md:728
msgid "`v[1-6]`"
msgstr "`v[1-6]`"

#: src/inline-assembly.md:729 src/inline-assembly.md:790
msgid "`r9`"
msgstr "`r9`"

#: src/inline-assembly.md:729
msgid "`rfp`"
msgstr "`rfp`"

#: src/inline-assembly.md:730
msgid "`r10`"
msgstr "`r10`"

#: src/inline-assembly.md:730
msgid "`sl`"
msgstr "`sl`"

#: src/inline-assembly.md:731
msgid "`r11`"
msgstr "`r11`"

#: src/inline-assembly.md:732
msgid "`r12`"
msgstr "`r12`"

#: src/inline-assembly.md:733
msgid "`r13`"
msgstr "`r13`"

#: src/inline-assembly.md:734
msgid "`r14`"
msgstr "`r14`"

#: src/inline-assembly.md:735
msgid "`r15`"
msgstr "`r15`"

#: src/inline-assembly.md:735 src/inline-assembly.md:789
msgid "`pc`"
msgstr "`pc`"

#: src/inline-assembly.md:736 src/inline-assembly.md:791
#: src/inline-assembly.md:856 src/inline-assembly.md:858
msgid "`x0`"
msgstr "`x0`"

#: src/inline-assembly.md:736
msgid "`zero`"
msgstr "`zero`"

#: src/inline-assembly.md:737 src/inline-assembly.md:871
msgid "`x1`"
msgstr "`x1`"

#: src/inline-assembly.md:737
msgid "`ra`"
msgstr "`ra`"

#: src/inline-assembly.md:738
msgid "`x2`"
msgstr "`x2`"

#: src/inline-assembly.md:739
msgid "`x3`"
msgstr "`x3`"

#: src/inline-assembly.md:739
msgid "`gp`"
msgstr "`gp`"

#: src/inline-assembly.md:740
msgid "`x4`"
msgstr "`x4`"

#: src/inline-assembly.md:740
msgid "`tp`"
msgstr "`tp`"

#: src/inline-assembly.md:741
msgid "`x[5-7]`"
msgstr "`x[5-7]`"

#: src/inline-assembly.md:741
msgid "`t[0-2]`"
msgstr "`t[0-2]`"

#: src/inline-assembly.md:742
msgid "`x8`"
msgstr "`x8`"

#: src/inline-assembly.md:742
msgid "`fp`, `s0`"
msgstr "`fp`, `s0`"

#: src/inline-assembly.md:743
msgid "`x9`"
msgstr "`x9`"

#: src/inline-assembly.md:743
msgid "`s1`"
msgstr "`s1`"

#: src/inline-assembly.md:744
msgid "`x[10-17]`"
msgstr "`x[10-17]`"

#: src/inline-assembly.md:744
msgid "`a[0-7]`"
msgstr "`a[0-7]`"

#: src/inline-assembly.md:745
msgid "`x[18-27]`"
msgstr "`x[18-27]`"

#: src/inline-assembly.md:745
msgid "`s[2-11]`"
msgstr "`s[2-11]`"

#: src/inline-assembly.md:746
msgid "`x[28-31]`"
msgstr "`x[28-31]`"

#: src/inline-assembly.md:746
msgid "`t[3-6]`"
msgstr "`t[3-6]`"

#: src/inline-assembly.md:747
msgid "`f[0-7]`"
msgstr "`f[0-7]`"

#: src/inline-assembly.md:747
msgid "`ft[0-7]`"
msgstr "`ft[0-7]`"

#: src/inline-assembly.md:748
msgid "`f[8-9]`"
msgstr "`f[8-9]`"

#: src/inline-assembly.md:748
msgid "`fs[0-1]`"
msgstr "`fs[0-1]`"

#: src/inline-assembly.md:749
msgid "`f[10-17]`"
msgstr "`f[10-17]`"

#: src/inline-assembly.md:749
msgid "`fa[0-7]`"
msgstr "`fa[0-7]`"

#: src/inline-assembly.md:750
msgid "`f[18-27]`"
msgstr "`f[18-27]`"

#: src/inline-assembly.md:750
msgid "`fs[2-11]`"
msgstr "`fs[2-11]`"

#: src/inline-assembly.md:751
msgid "`f[28-31]`"
msgstr "`f[28-31]`"

#: src/inline-assembly.md:751
msgid "`ft[8-11]`"
msgstr "`ft[8-11]`"

#: src/inline-assembly.md:752
msgid "`$r0`"
msgstr "`$r0`"

#: src/inline-assembly.md:752
msgid "`$zero`"
msgstr "`$zero`"

#: src/inline-assembly.md:753 src/inline-assembly.md:873
msgid "`$r1`"
msgstr "`$r1`"

#: src/inline-assembly.md:753
msgid "`$ra`"
msgstr "`$ra`"

#: src/inline-assembly.md:754
msgid "`$r2`"
msgstr "`$r2`"

#: src/inline-assembly.md:754
msgid "`$tp`"
msgstr "`$tp`"

#: src/inline-assembly.md:755
msgid "`$r3`"
msgstr "`$r3`"

#: src/inline-assembly.md:755
msgid "`$sp`"
msgstr "`$sp`"

#: src/inline-assembly.md:756
msgid "`$r[4-11]`"
msgstr "`$r[4-11]`"

#: src/inline-assembly.md:756
msgid "`$a[0-7]`"
msgstr "`$a[0-7]`"

#: src/inline-assembly.md:757
msgid "`$r[12-20]`"
msgstr "`$r[12-20]`"

#: src/inline-assembly.md:757
msgid "`$t[0-8]`"
msgstr "`$t[0-8]`"

#: src/inline-assembly.md:758 src/inline-assembly.md:795
msgid "`$r21`"
msgstr "`$r21`"

#: src/inline-assembly.md:759
msgid "`$r22`"
msgstr "`$r22`"

#: src/inline-assembly.md:759
msgid "`$fp`, `$s9`"
msgstr "`$fp`, `$s9`"

#: src/inline-assembly.md:760
msgid "`$r[23-31]`"
msgstr "`$r[23-31]`"

#: src/inline-assembly.md:760
msgid "`$s[0-8]`"
msgstr "`$s[0-8]`"

#: src/inline-assembly.md:761
msgid "`$f[0-7]`"
msgstr "`$f[0-7]`"

#: src/inline-assembly.md:761
msgid "`$fa[0-7]`"
msgstr "`$fa[0-7]`"

#: src/inline-assembly.md:762
msgid "`$f[8-23]`"
msgstr "`$f[8-23]`"

#: src/inline-assembly.md:762
msgid "`$ft[0-15]`"
msgstr "`$ft[0-15]`"

#: src/inline-assembly.md:763
msgid "`$f[24-31]`"
msgstr "`$f[24-31]`"

#: src/inline-assembly.md:763
msgid "`$fs[0-7]`"
msgstr "`$fs[0-7]`"

#: src/inline-assembly.md:767
msgid "// rax is an alias for eax and ax\n"
msgstr "// rax는 eax 및 ax의 별칭입니다.\n"

#: src/inline-assembly.md:775
msgid "Some registers cannot be used for input or output operands:"
msgstr "일부 레지스터는 입력 또는 출력 피연산자로 사용할 수 없습니다."

#: src/inline-assembly.md:777
msgid "Unsupported register"
msgstr "지원되지 않는 레지스터"

#: src/inline-assembly.md:777
msgid "Reason"
msgstr "이유"

#: src/inline-assembly.md:779 src/inline-assembly.md:780
#: src/inline-assembly.md:782
msgid "All"
msgstr "모두"

#: src/inline-assembly.md:779
msgid "`sp`, `r15` (s390x)"
msgstr "`sp`, `r15` (s390x)"

#: src/inline-assembly.md:779
msgid ""
"The stack pointer must be restored to its original value at the end of an "
"asm code block."
msgstr "스택 포인터(sp)는 asm 코드 블록의 끝에서 원래 값으로 복구되어야 합니다."

#: src/inline-assembly.md:780
msgid ""
"`bp` (x86), `x29` (AArch64 and Arm64EC), `x8` (RISC-V), `$fp` (LoongArch), "
"`r11` (s390x)"
msgstr ""
"`bp` (x86), `x29` (AArch64 및 Arm64EC), `x8` (RISC-V), `$fp` (LoongArch), "
"`r11` (s390x)"

#: src/inline-assembly.md:780
msgid "The frame pointer cannot be used as an input or output."
msgstr "프레임 포인터(fp)는 입력 또는 출력으로 사용할 수 없습니다."

#: src/inline-assembly.md:781
msgid "`r7` or `r11`"
msgstr "`r7` 또는 `r11`"

#: src/inline-assembly.md:781
msgid ""
"On ARM the frame pointer can be either `r7` or `r11` depending on the "
"target. The frame pointer cannot be used as an input or output."
msgstr ""
"ARM에서 프레임 포인터는 타겟에 따라 `r7` 또는 `r11`이 될 수 있습니다. "
"프레임 포인터는 입력 또는 출력으로 사용할 수 없습니다."

#: src/inline-assembly.md:782
msgid ""
"`si` (x86-32), `bx` (x86-64), `r6` (ARM), `x19` (AArch64 and Arm64EC), `x9` "
"(RISC-V), `$s8` (LoongArch)"
msgstr ""
"`si` (x86-32), `bx` (x86-64), `r6` (ARM), `x19` (AArch64 및 Arm64EC), `x9` "
"(RISC-V), `$s8` (LoongArch)"

#: src/inline-assembly.md:782
msgid ""
"This is used internally by LLVM as a \"base pointer\" for functions with "
"complex stack frames."
msgstr ""
"이는 복잡한 스택 프레임을 가진 함수를 위해 LLVM에서 내부적으로 \"베이스 포인터\"로 사용됩니다."

#: src/inline-assembly.md:783 src/inline-assembly.md:789
msgid "This is the program counter, not a real register."
msgstr "이것은 프로그램 카운터(pc)이며, 실제 레지스터가 아닙니다."

#: src/inline-assembly.md:784 src/inline-assembly.md:786
#: src/inline-assembly.md:791 src/inline-assembly.md:793
msgid "This is a constant zero register which can't be modified."
msgstr "이것은 수정할 수 없는 상수 제로 레지스터입니다."

#: src/inline-assembly.md:785 src/inline-assembly.md:787
msgid "`x18`"
msgstr "`x18`"

#: src/inline-assembly.md:785
msgid "This is an OS-reserved register on some AArch64 targets."
msgstr "이는 일부 AArch64 타겟에서 OS가 예약한 레지스터입니다."

#: src/inline-assembly.md:787
msgid "This is an OS-reserved register."
msgstr "이것은 OS가 예약한 레지스터입니다."

#: src/inline-assembly.md:788
msgid "`x13`, `x14`, `x23`, `x24`, `x28`, `v[16-31]`, `p[0-15]`, `ffr`"
msgstr "`x13`, `x14`, `x23`, `x24`, `x28`, `v[16-31]`, `p[0-15]`, `ffr`"

#: src/inline-assembly.md:788
msgid "These are AArch64 registers that are not supported for Arm64EC."
msgstr "이들은 Arm64EC에서 지원되지 않는 AArch64 레지스터들입니다."

#: src/inline-assembly.md:790
msgid "This is an OS-reserved register on some ARM targets."
msgstr "이는 일부 ARM 타겟에서 OS가 예약한 레지스터입니다."

#: src/inline-assembly.md:792
msgid "`gp`, `tp`"
msgstr "`gp`, `tp`"

#: src/inline-assembly.md:792
msgid "These registers are reserved and cannot be used as inputs or outputs."
msgstr "이 레지스터들은 예약되어 있으며 입력이나 출력으로 사용할 수 없습니다."

#: src/inline-assembly.md:793
msgid "`$r0` or `$zero`"
msgstr "`$r0` 또는 `$zero`"

#: src/inline-assembly.md:794
msgid "`$r2` or `$tp`"
msgstr "`$r2` 또는 `$tp`"

#: src/inline-assembly.md:794
msgid "This is reserved for TLS."
msgstr "이는 TLS를 위해 예약되어 있습니다."

#: src/inline-assembly.md:795
msgid "This is reserved by the ABI."
msgstr "이는 ABI에 의해 예약되어 있습니다."

#: src/inline-assembly.md:796
msgid "`c[0-15]`"
msgstr "`c[0-15]`"

#: src/inline-assembly.md:796
msgid "Reserved by the kernel."
msgstr "커널에 의해 예약되어 있습니다."

#: src/inline-assembly.md:797
msgid "`a[0-1]`"
msgstr "`a[0-1]`"

#: src/inline-assembly.md:797
msgid "Reserved for system use."
msgstr "시스템 사용을 위해 예약되어 있습니다."

#: src/inline-assembly.md:800
msgid "// bp is reserved\n"
msgstr "// bp는 예약되어 있습니다.\n"

#: src/inline-assembly.md:802
msgid "\"bp\""
msgstr "\"bp\""

#: src/inline-assembly.md:802
msgid ""
"// ERROR: invalid register `bp`: the frame pointer cannot be used as an "
"operand for inline asm\n"
msgstr "// 오류: 잘못된 레지스터 `bp`: 프레임 포인터는 인라인 asm의 피연산자로 사용할 수 없습니다.\n"

#: src/inline-assembly.md:810
msgid ""
"The frame pointer and base pointer registers are reserved for internal use "
"by LLVM. While `asm!` statements cannot explicitly specify the use of "
"reserved registers, in some cases LLVM will allocate one of these reserved "
"registers for `reg` operands. Assembly code making use of reserved registers "
"should be careful since `reg` operands may use the same registers."
msgstr ""
"프레임 포인터와 베이스 포인터 레지스터는 LLVM 내부 사용을 위해 예약되어 있습니다. "
"`asm!` 구문에서 예약된 레지스터 사용을 명시적으로 지정할 수는 없지만, 일부 경우 "
"LLVM이 `reg` 피연산자를 위해 이러한 예약된 레지스터 중 하나를 할당할 수 있습니다. "
"예약된 레지스터를 사용하는 어셈블리 코드는 `reg` 피연산자가 동일한 레지스터를 "
"사용할 수 있으므로 주의해야 합니다."

#: src/inline-assembly.md:814
msgid "Template modifiers"
msgstr "템플릿 수식어"

#: src/inline-assembly.md:818
msgid ""
"The placeholders can be augmented by modifiers which are specified after the "
"`:` in the curly braces. These modifiers do not affect register allocation, "
"but change the way operands are formatted when inserted into the template "
"string."
msgstr ""
"플레이스홀더는 중괄호 안의 `:` 뒤에 수식어를 지정하여 기능을 확장할 수 있습니다. "
"이러한 수식어는 레지스터 할당에는 영향을 주지 않지만, 피연산자가 템플릿 문자열에 "
"삽입될 때 포맷팅되는 방식을 변경합니다."

#: src/inline-assembly.md:823
msgid "Only one modifier is allowed per template placeholder."
msgstr "템플릿 플레이스홀더당 하나의 수식어만 허용됩니다."

#: src/inline-assembly.md:826
msgid "// We can't specify both `r` and `e` at the same time.\n"
msgstr "// `r`과 `e`를 동시에 지정할 수는 없습니다.\n"

#: src/inline-assembly.md:828
msgid "\"/* {:er}\""
msgstr "\"/* {:er}\""

#: src/inline-assembly.md:828
msgid "// ERROR: asm template modifier must be a single character\n"
msgstr "// 오류: asm 템플릿 수식어는 단일 문자여야 합니다.\n"

#: src/inline-assembly.md:836
msgid ""
"The supported modifiers are a subset of LLVM's (and GCC's) [asm template "
"argument modifiers](http://llvm.org/docs/LangRef.html#asm-template-argument-"
"modifiers), but do not use the same letter codes."
msgstr ""
"지원되는 수식어는 LLVM(및 GCC)의 [asm 템플릿 인자 수식어](http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers)의 "
"하위 집합이지만, 동일한 문자 코드를 사용하지는 않습니다."

#: src/inline-assembly.md:838
msgid "Modifier"
msgstr "수식어"

#: src/inline-assembly.md:838
msgid "Example output"
msgstr "출력 예시"

#: src/inline-assembly.md:838
msgid "LLVM modifier"
msgstr "LLVM 수식어"

#: src/inline-assembly.md:840 src/inline-assembly.md:846
msgid "`eax`"
msgstr "`eax`"

#: src/inline-assembly.md:840 src/inline-assembly.md:846
msgid "`k`"
msgstr "`k`"

#: src/inline-assembly.md:841 src/inline-assembly.md:847
msgid "`rax`"
msgstr "`rax`"

#: src/inline-assembly.md:842 src/inline-assembly.md:843
msgid "`l`"
msgstr "`l`"

#: src/inline-assembly.md:842 src/inline-assembly.md:843
msgid "`al`"
msgstr "`al`"

#: src/inline-assembly.md:844 src/inline-assembly.md:862
msgid "`h`"
msgstr "`h`"

#: src/inline-assembly.md:844
msgid "`ah`"
msgstr "`ah`"

#: src/inline-assembly.md:846
msgid "`e`"
msgstr "`e`"

#: src/inline-assembly.md:848
msgid "`al` / `ah`"
msgstr "`al` / `ah`"

#: src/inline-assembly.md:849 src/inline-assembly.md:852
msgid "`xmm0`"
msgstr "`xmm0`"

#: src/inline-assembly.md:850 src/inline-assembly.md:853
msgid "`ymm0`"
msgstr "`ymm0`"

#: src/inline-assembly.md:851 src/inline-assembly.md:854
msgid "`zmm0`"
msgstr "`zmm0`"

#: src/inline-assembly.md:851 src/inline-assembly.md:854
msgid "`g`"
msgstr "`g`"

#: src/inline-assembly.md:852 src/inline-assembly.md:853
#: src/inline-assembly.md:854
msgid "`*mm_reg`"
msgstr "`*mm_reg`"

#: src/inline-assembly.md:853
msgid "`y`"
msgstr "`y`"

#: src/inline-assembly.md:854
msgid "`z`"
msgstr "`z`"

#: src/inline-assembly.md:855
msgid "`k1`"
msgstr "`k1`"

#: src/inline-assembly.md:856 src/inline-assembly.md:857
#: src/inline-assembly.md:858 src/inline-assembly.md:859
#: src/inline-assembly.md:860 src/inline-assembly.md:861
#: src/inline-assembly.md:862 src/inline-assembly.md:863
#: src/inline-assembly.md:864 src/inline-assembly.md:865
msgid "AArch64/Arm64EC"
msgstr "AArch64/Arm64EC"

#: src/inline-assembly.md:857
msgid "`w0`"
msgstr "`w0`"

#: src/inline-assembly.md:859 src/inline-assembly.md:860
msgid "`v0`"
msgstr "`v0`"

#: src/inline-assembly.md:861
msgid "`b0`"
msgstr "`b0`"

#: src/inline-assembly.md:862
msgid "`h0`"
msgstr "`h0`"

#: src/inline-assembly.md:863
msgid "`s`"
msgstr "`s`"

#: src/inline-assembly.md:863 src/inline-assembly.md:867
msgid "`s0`"
msgstr "`s0`"

#: src/inline-assembly.md:864 src/inline-assembly.md:868
msgid "`d0`"
msgstr "`d0`"

#: src/inline-assembly.md:865 src/inline-assembly.md:869
msgid "`q0`"
msgstr "`q0`"

#: src/inline-assembly.md:866
msgid "`r0`"
msgstr "`r0`"

#: src/inline-assembly.md:868
msgid "`P`"
msgstr "`P`"

#: src/inline-assembly.md:870
msgid "`e` / `f`"
msgstr "`e` / `f`"

#: src/inline-assembly.md:870
msgid "`d0` / `d1`"
msgstr "`d0` / `d1`"

#: src/inline-assembly.md:872
msgid "`f0`"
msgstr "`f0`"

#: src/inline-assembly.md:874
msgid "`$f0`"
msgstr "`$f0`"

#: src/inline-assembly.md:875
msgid "`%r0`"
msgstr "`%r0`"

#: src/inline-assembly.md:876
msgid "`%r1`"
msgstr "`%r1`"

#: src/inline-assembly.md:877
msgid "`%f0`"
msgstr "`%f0`"

#: src/inline-assembly.md:880
msgid ""
"on ARM `e` / `f`: this prints the low or high doubleword register name of a "
"NEON quad (128-bit) register."
msgstr ""
"ARM의 `e` / `f`: 이는 NEON 쿼드(128비트) 레지스터의 하위 또는 상위 더블워드(doubleword) "
"레지스터 이름을 출력합니다."

#: src/inline-assembly.md:881
msgid ""
"on x86: our behavior for `reg` with no modifiers differs from what GCC does. "
"GCC will infer the modifier based on the operand value type, while we "
"default to the full register size."
msgstr ""
"x86: 수식어가 없는 `reg`에 대한 우리의 동작은 GCC와 다릅니다. GCC는 피연산자 값 타입을 "
"기반으로 수식어를 추론하지만, 우리는 기본적으로 전체 레지스터 크기를 사용합니다."

#: src/inline-assembly.md:883
msgid ""
"on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet "
"implemented in LLVM (they are supported by GCC only), but this should be a "
"simple change."
msgstr ""
"x86 `xmm_reg`: `x`, `t` 및 `g` LLVM 수식어는 아직 LLVM에 구현되지 않았지만"
"(이들은 GCC에서만 지원됨), 이는 간단한 변경사항일 것입니다."

#: src/inline-assembly.md:888
msgid ""
"// u16::swap_bytes using `xchg`\n"
"// low half of `{x}` is referred to by `{x:l}`, and the high half by `{x:h}"
"`\n"
msgstr ""
"// `xchg`를 사용한 u16::swap_bytes\n"
"// `{x}`의 하위 절반은 `{x:l}`로, 상위 절반은 `{x:h}`로 참조됩니다.\n"

#: src/inline-assembly.md:891
msgid "\"xchg {x:l}, {x:h}\""
msgstr "\"xchg {x:l}, {x:h}\""

#: src/inline-assembly.md:898
msgid ""
"As stated in the previous section, passing an input value smaller than the "
"register width will result in the upper bits of the register containing "
"undefined values. This is not a problem if the inline asm only accesses the "
"lower bits of the register, which can be done by using a template modifier "
"to use a subregister name in the asm code (e.g. `ax` instead of `rax`). "
"Since this an easy pitfall, the compiler will suggest a template modifier to "
"use where appropriate given the input type. If all references to an operand "
"already have modifiers then the warning is suppressed for that operand."
msgstr ""
"이전 섹션에서 언급했듯이, 레지스터 너비보다 작은 입력값을 전달하면 레지스터의 "
"상위 비트들이 정의되지 않은 값을 갖게 됩니다. 인라인 asm이 레지스터의 하위 "
"비트들만 접근한다면 이는 문제가 되지 않으며, 이는 asm 코드에서 서브레지스터 이름을 "
"사용하기 위해 템플릿 수식어를 사용함으로써 가능합니다(예: `rax` 대신 `ax`). "
"이는 빠지기 쉬운 함정이므로, 컴파일러는 입력 타입에 따라 적절한 템플릿 수식어 사용을 "
"제안할 것입니다. 피연산자에 대한 모든 참조에 이미 수식어가 있다면 해당 피연산자에 "
"대한 경고는 억제됩니다."

#: src/inline-assembly.md:907
msgid "ABI clobbers"
msgstr "ABI 클로버(Clobbers)"

#: src/inline-assembly.md:911
msgid ""
"The `clobber_abi` keyword can be used to apply a default set of clobbers to "
"an `asm!` block. This will automatically insert the necessary clobber "
"constraints as needed for calling a function with a particular calling "
"convention: if the calling convention does not fully preserve the value of a "
"register across a call then `lateout(\"...\") _` is implicitly added to the "
"operands list (where the `...` is replaced by the register's name)."
msgstr ""
"`clobber_abi` 키워드는 `asm!` 블록에 기본 클로버 세트를 적용하는 데 사용될 수 있습니다. "
"이는 특정 호출 규약(calling convention)으로 함수를 호출할 때 필요한 클로버 제약 조건을 "
"자동으로 삽입합니다. 만약 호출 규약이 호출 간에 레지스터의 값을 완전히 보존하지 않는 경우, "
"`lateout(\"...\") _`가 피연산자 목록에 암시적으로 추가됩니다(여기서 `...`은 "
"해당 레지스터의 이름으로 대체됩니다)."

#: src/inline-assembly.md:918
msgid ""
"// To call a function, we have to inform the compiler that we're clobbering\n"
"// callee saved registers\n"
msgstr "// 함수를 호출하려면, 피호출자 저장(callee saved) 레지스터를 클로버하고 있음을 컴파일러에 알려야 합니다.\n"

#: src/inline-assembly.md:928
msgid ""
"`clobber_abi` may be specified any number of times. It will insert a clobber "
"for all unique registers in the union of all specified calling conventions."
msgstr ""
"`clobber_abi`는 횟수 제한 없이 지정될 수 있습니다. 지정된 모든 호출 규약의 합집합에 속하는 "
"모든 고유 레지스터에 대해 클로버를 삽입합니다."

#: src/inline-assembly.md:932
msgid "\"sysv64\""
msgstr "\"sysv64\""

#: src/inline-assembly.md:933
msgid "\"win64\""
msgstr "\"win64\""

#: src/inline-assembly.md:935
msgid ""
"// We can even call multiple functions with different conventions and\n"
"// different saved registers\n"
msgstr "// 심지어 서로 다른 규약과 서로 다른 저장된 레지스터를 가진 여러 함수를 호출할 수도 있습니다.\n"

#: src/inline-assembly.md:955
msgid ""
"Generic register class outputs are disallowed by the compiler when "
"`clobber_abi` is used: all outputs must specify an explicit register."
msgstr ""
"`clobber_abi`가 사용될 때 컴파일러는 제네릭 레지스터 클래스 출력을 허용하지 않습니다. "
"모든 출력은 명시적 레지스터를 지정해야 합니다."

#: src/inline-assembly.md:961
msgid "// explicit registers must be used to not accidentally overlap.\n"
msgstr "// 실수로 겹치지 않도록 명시적 레지스터를 사용해야 합니다.\n"

#: src/inline-assembly.md:971
msgid ""
"// ERROR: asm with `clobber_abi` must specify explicit registers for "
"outputs\n"
msgstr "// 오류: `clobber_abi`를 사용하는 asm은 출력에 대해 명시적 레지스터를 지정해야 합니다.\n"

#: src/inline-assembly.md:980
msgid ""
"Explicit register outputs have precedence over the implicit clobbers "
"inserted by `clobber_abi`: a clobber will only be inserted for a register if "
"that register is not used as an output."
msgstr ""
"명시적 레지스터 출력은 `clobber_abi`에 의해 삽입된 암시적 클로버보다 우선순위를 갖습니다. "
"레지스터가 출력으로 사용되지 않는 경우에만 해당 레지스터에 대한 클로버가 삽입됩니다."

#: src/inline-assembly.md:984
msgid "The following ABIs can be used with `clobber_abi`:"
msgstr "다음 ABI들은 `clobber_abi`와 함께 사용될 수 있습니다:"

#: src/inline-assembly.md:986
msgid "ABI name"
msgstr "ABI 이름"

#: src/inline-assembly.md:986
msgid "Clobbered registers"
msgstr "클로버된 레지스터"

#: src/inline-assembly.md:988
msgid ""
"`\"C\"`, `\"system\"`, `\"efiapi\"`, `\"cdecl\"`, `\"stdcall\"`, "
"`\"fastcall\"`"
msgstr ""
"`\"C\"`, `\"system\"`, `\"efiapi\"`, `\"cdecl\"`, `\"stdcall\"`, "
"`\"fastcall\"`"

#: src/inline-assembly.md:988
msgid "`ax`, `cx`, `dx`, `xmm[0-7]`, `mm[0-7]`, `k[0-7]`, `st([0-7])`"
msgstr "`ax`, `cx`, `dx`, `xmm[0-7]`, `mm[0-7]`, `k[0-7]`, `st([0-7])`"

#: src/inline-assembly.md:989
msgid "`\"C\"`, `\"system\"` (on Windows), `\"efiapi\"`, `\"win64\"`"
msgstr "`\"C\"`, `\"system\"` (윈도우 전용), `\"efiapi\"`, `\"win64\"`"

#: src/inline-assembly.md:989
msgid ""
"`ax`, `cx`, `dx`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[0-7]`, `st([0-7])`, "
"`tmm[0-7]`"
msgstr ""
"`ax`, `cx`, `dx`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[0-7]`, `st([0-7])`, "
"`tmm[0-7]`"

#: src/inline-assembly.md:990
msgid "`\"C\"`, `\"system\"` (on non-Windows), `\"sysv64\"`"
msgstr "`\"C\"`, `\"system\"` (윈도우 제외), `\"sysv64\"`"

#: src/inline-assembly.md:990
msgid ""
"`ax`, `cx`, `dx`, `si`, `di`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[0-7]`, "
"`st([0-7])`, `tmm[0-7]`"
msgstr ""
"`ax`, `cx`, `dx`, `si`, `di`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[0-7]`, "
"`st([0-7])`, `tmm[0-7]`"

#: src/inline-assembly.md:991 src/inline-assembly.md:994
msgid "`\"C\"`, `\"system\"`, `\"efiapi\"`"
msgstr "`\"C\"`, `\"system\"`, `\"efiapi\"`"

#: src/inline-assembly.md:991
msgid "`x[0-17]`, `x18`\\*, `x30`, `v[0-31]`, `p[0-15]`, `ffr`"
msgstr "`x[0-17]`, `x18`*, `x30`, `v[0-31]`, `p[0-15]`, `ffr`"

#: src/inline-assembly.md:992 src/inline-assembly.md:995
#: src/inline-assembly.md:996
msgid "`\"C\"`, `\"system\"`"
msgstr "`\"C\"`, `\"system\"`"

#: src/inline-assembly.md:992
msgid "`x[0-12]`, `x[15-17]`, `x30`, `v[0-15]`"
msgstr "`x[0-12]`, `x[15-17]`, `x30`, `v[0-15]`"

#: src/inline-assembly.md:993
msgid "`\"C\"`, `\"system\"`, `\"efiapi\"`, `\"aapcs\"`"
msgstr "`\"C\"`, `\"system\"`, `\"efiapi\"`, `\"aapcs\"`"

#: src/inline-assembly.md:993
msgid "`r[0-3]`, `r12`, `r14`, `s[0-15]`, `d[0-7]`, `d[16-31]`"
msgstr "`r[0-3]`, `r12`, `r14`, `s[0-15]`, `d[0-7]`, `d[16-31]`"

#: src/inline-assembly.md:994
msgid ""
"`x1`, `x[5-7]`, `x[10-17]`\\*, `x[28-31]`\\*, `f[0-7]`, `f[10-17]`, "
"`f[28-31]`, `v[0-31]`"
msgstr ""
"`x1`, `x[5-7]`, `x[10-17]`*, `x[28-31]`*, `f[0-7]`, `f[10-17]`, "
"`f[28-31]`, `v[0-31]`"

#: src/inline-assembly.md:995
msgid "`$r1`, `$r[4-20]`, `$f[0-23]`"
msgstr "`$r1`, `$r[4-20]`, `$f[0-23]`"

#: src/inline-assembly.md:996
msgid "`r[0-5]`, `r14`, `f[0-7]`, `v[0-31]`, `a[2-15]`"
msgstr "`r[0-5]`, `r14`, `f[0-7]`, `v[0-31]`, `a[2-15]`"

#: src/inline-assembly.md:998
msgid "Notes:"
msgstr "참고:"

#: src/inline-assembly.md:999
msgid ""
"On AArch64 `x18` only included in the clobber list if it is not considered "
"as a reserved register on the target."
msgstr ""
"AArch64에서 `x18`은 타겟에서 예약된 레지스터로 간주되지 않는 경우에만 "
"클로버 목록에 포함됩니다."

#: src/inline-assembly.md:1000
msgid ""
"On RISC-V `x[16-17]` and `x[28-31]` only included in the clobber list if "
"they are not considered as reserved registers on the target."
msgstr ""
"RISC-V에서 `x[16-17]` 및 `x[28-31]`은 타겟에서 예약된 레지스터로 간주되지 "
"않는 경우에만 클로버 목록에 포함됩니다."

#: src/inline-assembly.md:1002
msgid ""
"The list of clobbered registers for each ABI is updated in rustc as "
"architectures gain new registers: this ensures that `asm!` clobbers will "
"continue to be correct when LLVM starts using these new registers in its "
"generated code."
msgstr ""
"각 ABI에 대한 클로버된 레지스터 목록은 아키텍처에 새로운 레지스터가 추가됨에 따라 "
"rustc에서 업데이트됩니다. 이는 LLVM이 생성된 코드에서 이러한 새로운 레지스터를 "
"사용하기 시작할 때 `asm!` 클로버가 계속해서 올바르게 작동하도록 보장합니다."

#: src/inline-assembly.md:1006
msgid "Options"
msgstr "옵션"

#: src/inline-assembly.md:1010
msgid ""
"Flags are used to further influence the behavior of the inline assembly "
"block. Currently the following options are defined:"
msgstr ""
"플래그는 인라인 어셈블리 블록의 동작에 더 많은 영향을 주는 데 사용됩니다. "
"현재 정의된 옵션은 다음과 같습니다."

#: src/inline-assembly.md:1015
msgid ""
"`pure`: The `asm!` block has no side effects, must eventually return, and "
"its outputs depend only on its direct inputs (i.e. the values themselves, "
"not what they point to) or values read from memory (unless the `nomem` "
"options is also set). This allows the compiler to execute the `asm!` block "
"fewer times than specified in the program (e.g. by hoisting it out of a "
"loop) or even eliminate it entirely if the outputs are not used. The `pure` "
"option must be combined with either the `nomem` or `readonly` options, "
"otherwise a compile-time error is emitted."
msgstr ""
"`pure`: `asm!` 블록은 부작용(side effects)이 없어야 하며, 반드시 반환되어야 하고, "
"출력은 오직 직접적인 입력(즉, 포인터가 가리키는 대상이 아닌 값 자체) 또는 "
"메모리에서 읽은 값(`nomem` 옵션이 설정되지 않은 경우)에만 의존해야 합니다. "
"이를 통해 컴파일러는 프로그램에 명시된 것보다 더 적은 횟수로 `asm!` 블록을 실행하거나"
"(예: 루프 외부로 이동), 출력이 사용되지 않는 경우 완전히 제거할 수 있습니다. "
"`pure` 옵션은 `nomem` 또는 `readonly` 옵션 중 하나와 반드시 결합되어야 하며, "
"그렇지 않으면 컴파일 타임 오류가 발생합니다."

#: src/inline-assembly.md:1022
msgid ""
"// pure can be used to optimize by assuming the assembly has no side "
"effects\n"
msgstr "// `pure`는 어셈블리에 부작용이 없다고 가정하여 최적화하는 데 사용될 수 있습니다.\n"

#: src/inline-assembly.md:1032
msgid ""
"// Either nomem or readonly must be satisfied, to indicate whether or not\n"
"// memory is allowed to be read\n"
msgstr "// 메모리 읽기 허용 여부를 나타내기 위해 nomem 또는 readonly 중 하나를 만족해야 합니다.\n"

#: src/inline-assembly.md:1035
msgid ""
"// ERROR: the `pure` option must be combined with either `nomem` or "
"`readonly`\n"
msgstr "// 오류: `pure` 옵션은 `nomem` 또는 `readonly` 중 하나와 결합되어야 합니다.\n"

#: src/inline-assembly.md:1044
msgid ""
"`nomem`: The `asm!` block does not read from or write to any memory "
"accessible outside of the `asm!` block. This allows the compiler to cache "
"the values of modified global variables in registers across the `asm!` block "
"since it knows that they are not read or written to by the `asm!`. The "
"compiler also assumes that this `asm!` block does not perform any kind of "
"synchronization with other threads, e.g. via fences."
msgstr ""
"`nomem`: `asm!` 블록이 `asm!` 블록 외부에서 접근 가능한 어떠한 메모리도 읽거나 쓰지 않습니다. "
"이를 통해 컴파일러는 `asm!`에 의해 메모리가 읽히거나 쓰이지 않는다는 것을 알기 때문에, "
"수정된 전역 변수의 값을 `asm!` 블록 너머까지 레지스터에 캐싱할 수 있습니다. "
"또한 컴파일러는 이 `asm!` 블록이 펜스(fences) 등을 통한 다른 스레드와의 어떠한 동기화도 "
"수행하지 않는다고 가정합니다."

#: src/inline-assembly.md:1052
msgid "// Accessing memory from a nomem asm block is disallowed\n"
msgstr "// nomem asm 블록에서 메모리에 접근하는 것은 허용되지 않습니다.\n"

#: src/inline-assembly.md:1055
msgid "\"mov {val:e}, dword ptr [{ptr}]\""
msgstr "\"mov {val:e}, dword ptr [{ptr}]\""

#: src/inline-assembly.md:1061
msgid "// Writing to memory is also undefined behaviour\n"
msgstr "// 메모리에 쓰는 것 또한 정의되지 않은 동작입니다.\n"

#: src/inline-assembly.md:1064
msgid "\"mov  dword ptr [{ptr}], {val:e}\""
msgstr "\"mov  dword ptr [{ptr}], {val:e}\""

#: src/inline-assembly.md:1076
msgid ""
"// If we allocate our own memory, such as via `push`, however.\n"
"// we can still use it\n"
msgstr ""
"// 하지만 `push` 등을 통해 우리만의 메모리를 할당한다면\n"
"// 여전히 그것을 사용할 수 있습니다.\n"

#: src/inline-assembly.md:1080 src/inline-assembly.md:1127
msgid "\"push {x}\""
msgstr "\"push {x}\""

#: src/inline-assembly.md:1080 src/inline-assembly.md:1127
msgid "\"add qword ptr [rsp], 1\""
msgstr "\"add qword ptr [rsp], 1\""

#: src/inline-assembly.md:1080 src/inline-assembly.md:1127
msgid "\"pop {x}\""
msgstr "\"pop {x}\""

#: src/inline-assembly.md:1091
msgid ""
"`readonly`: The `asm!` block does not write to any memory accessible outside "
"of the `asm!` block. This allows the compiler to cache the values of "
"unmodified global variables in registers across the `asm!` block since it "
"knows that they are not written to by the `asm!`. The compiler also assumes "
"that this `asm!` block does not perform any kind of synchronization with "
"other threads, e.g. via fences."
msgstr ""
"`readonly`: `asm!` 블록이 `asm!` 블록 외부에서 접근 가능한 어떠한 메모리에도 쓰지 않습니다. "
"이를 통해 컴파일러는 변하지 않은 전역 변수의 값이 `asm!`에 의해 쓰이지 않는다는 것을 알기 때문에, "
"그 값을 `asm!` 블록 너머까지 레지스터에 캐싱할 수 있습니다. 또한 컴파일러는 이 "
"`asm!` 블록이 펜스 등을 통한 다른 스레드와의 어떠한 동기화도 수행하지 않는다고 가정합니다."

#: src/inline-assembly.md:1098
msgid "// We cannot modify memory in readonly\n"
msgstr "// readonly에서 메모리를 수정할 수 없습니다.\n"

#: src/inline-assembly.md:1101
msgid "\"mov dword ptr[{}], 1\""
msgstr "\"mov dword ptr[{}], 1\""

#: src/inline-assembly.md:1109
msgid "// We can still read from it, though\n"
msgstr "// 하지만 여전히 읽을 수는 있습니다.\n"

#: src/inline-assembly.md:1112
msgid "\"mov {x}, qword ptr [{x}]\""
msgstr "\"mov {x}, qword ptr [{x}]\""

#: src/inline-assembly.md:1124
msgid "// Same exception applies as with nomem.\n"
msgstr "// nomem과 동일한 예외가 적용됩니다.\n"

#: src/inline-assembly.md:1138
msgid ""
"`preserves_flags`: The `asm!` block does not modify the flags register "
"(defined in the rules below). This allows the compiler to avoid recomputing "
"the condition flags after the `asm!` block."
msgstr ""
"`preserves_flags`: `asm!` 블록이 플래그 레지스터(아래 규칙에 정의됨)를 수정하지 않습니다. "
"이를 통해 컴파일러는 `asm!` 블록 이후에 조건 플래그를 다시 계산하는 것을 피할 수 있습니다."

#: src/inline-assembly.md:1143
msgid ""
"`noreturn`: The `asm!` block never returns, and its return type is defined "
"as `!` (never). Behavior is undefined if execution falls through past the "
"end of the asm code. A `noreturn` asm block behaves just like a function "
"which doesn't return; notably, local variables in scope are not dropped "
"before it is invoked."
msgstr ""
"`noreturn`: `asm!` 블록이 절대 반환되지 않으며, 반환 타입은 `!` (never)로 정의됩니다. "
"어셈블리 코드의 끝을 지나 실행이 계속되면 동작은 정의되지 않습니다. `noreturn` asm 블록은 "
"반환하지 않는 함수와 똑같이 동작합니다. 특히, 스코프 내의 지역 변수들은 블록이 호출되기 전에 "
"드롭(drop)되지 않습니다."

#: src/inline-assembly.md:1151
msgid ""
"// We can use an instruction to trap execution inside of a noreturn block\n"
msgstr "// noreturn 블록 내부에서 실행을 트랩(trap)하기 위해 명령어를 사용할 수 있습니다.\n"

#: src/inline-assembly.md:1154
msgid "\"no return\""
msgstr "\"no return\""

#: src/inline-assembly.md:1160
msgid ""
"// You are responsible for not falling past the end of a noreturn asm block\n"
msgstr "// noreturn asm 블록의 끝을 지나치지 않도록 할 책임은 사용자에게 있습니다.\n"

#: src/inline-assembly.md:1168
msgid ""
"`nostack`: The `asm!` block does not push data to the stack, or write to the "
"stack red-zone (if supported by the target). If this option is _not_ used "
"then the stack pointer is guaranteed to be suitably aligned (according to "
"the target ABI) for a function call."
msgstr ""
"`nostack`: `asm!` 블록이 스택에 데이터를 푸시하거나 스택 레드존(red-zone, 타겟에서 지원하는 경우)에 "
"쓰지 않습니다. 이 옵션을 사용하지 _않으면_ 스택 포인터는 함수 호출을 위해 (타겟 ABI에 따라) "
"적절하게 정렬됨이 보장됩니다."

#: src/inline-assembly.md:1173
msgid "// `push` and `pop` are UB when used with nostack\n"
msgstr "// nostack과 함께 `push` 및 `pop`을 사용하는 것은 정의되지 않은 동작(UB)입니다.\n"

#: src/inline-assembly.md:1175
msgid "\"push rax\""
msgstr "\"push rax\""

#: src/inline-assembly.md:1175
msgid "\"pop rax\""
msgstr "\"pop rax\""

#: src/inline-assembly.md:1181
msgid ""
"`att_syntax`: This option is only valid on x86, and causes the assembler to "
"use the `.att_syntax prefix` mode of the GNU assembler. Register operands "
"are substituted in with a leading `%`."
msgstr ""
"`att_syntax`: 이 옵션은 x86에서만 유효하며, 어셈블러가 GNU 어셈블러의 "
"`.att_syntax prefix` 모드를 사용하도록 합니다. 레지스터 피연산자는 앞에 `%`가 붙은 상태로 "
"치환됩니다."

#: src/inline-assembly.md:1187
msgid "// We need to use AT&T Syntax here. src, dest order for operands\n"
msgstr "// 여기서는 AT&T 구문을 사용해야 합니다. 피연산자 순서는 src, dest입니다.\n"

#: src/inline-assembly.md:1190
msgid "\"mov {y:e}, {x:e}\""
msgstr "\"mov {y:e}, {x:e}\""

#: src/inline-assembly.md:1202
msgid ""
"`raw`: This causes the template string to be parsed as a raw assembly "
"string, with no special handling for `{` and `}`. This is primarily useful "
"when including raw assembly code from an external file using `include_str!`."
msgstr ""
"`raw`: 템플릿 문자열을 원시 어셈블리 문자열로 파싱하게 하며, `{` 및 `}`에 대한 "
"특별한 처리를 하지 않습니다. 이는 주로 `include_str!`을 사용하여 외부 파일에서 "
"원시 어셈블리 코드를 포함할 때 유용합니다."

#: src/inline-assembly.md:1207
msgid "The compiler performs some additional checks on options:"
msgstr "컴파일러는 옵션에 대해 몇 가지 추가 검사를 수행합니다."

#: src/inline-assembly.md:1211
msgid ""
"The `nomem` and `readonly` options are mutually exclusive: it is a compile-"
"time error to specify both."
msgstr ""
"`nomem`과 `readonly` 옵션은 상호 배타적입니다. 두 옵션을 모두 지정하는 것은 "
"컴파일 타임 오류입니다."

#: src/inline-assembly.md:1214
msgid ""
"// nomem is strictly stronger than readonly, they can't be specified "
"together\n"
msgstr "// nomem은 readonly보다 엄격하게 강력하므로 함께 지정할 수 없습니다.\n"

#: src/inline-assembly.md:1216
msgid "// ERROR: the `nomem` and `readonly` options are mutually exclusive\n"
msgstr "// 오류: `nomem`과 `readonly` 옵션은 상호 배타적입니다.\n"

#: src/inline-assembly.md:1224
msgid ""
"It is a compile-time error to specify `pure` on an asm block with no outputs "
"or only discarded outputs (`_`)."
msgstr ""
"`pure`를 출력이 없거나 버려지는 출력(`_`)만 있는 asm 블록에 지정하는 것은 "
"컴파일 타임 오류입니다."

#: src/inline-assembly.md:1227
msgid "// pure blocks need at least one output\n"
msgstr "// pure 블록은 최소 하나 이상의 출력이 필요합니다.\n"

#: src/inline-assembly.md:1229
msgid "// ERROR: asm with the `pure` option must have at least one output\n"
msgstr "// 오류: `pure` 옵션을 사용하는 asm은 최소 하나 이상의 출력이 있어야 합니다.\n"

#: src/inline-assembly.md:1237
msgid ""
"It is a compile-time error to specify `noreturn` on an asm block with "
"outputs."
msgstr "`noreturn`을 출력이 있는 asm 블록에 지정하는 것은 컴파일 타임 오류입니다."

#: src/inline-assembly.md:1241
msgid "// noreturn can't have outputs\n"
msgstr "// noreturn은 출력을 가질 수 없습니다.\n"

#: src/inline-assembly.md:1243
msgid "\"mov {:e}, 1\""
msgstr "\"mov {:e}, 1\""

#: src/inline-assembly.md:1243
msgid "// ERROR: asm outputs are not allowed with the `noreturn` option\n"
msgstr "// 오류: `noreturn` 옵션에서는 asm 출력이 허용되지 않습니다.\n"

#: src/inline-assembly.md:1251
msgid ""
"`global_asm!` only supports the `att_syntax` and `raw` options. The "
"remaining options are not meaningful for global-scope inline assembly"
msgstr ""
"`global_asm!`은 오직 `att_syntax`와 `raw` 옵션만 지원합니다. 나머지 옵션들은 "
"전역 스코프 인라인 어셈블리에서는 의미가 없습니다."

#: src/inline-assembly.md:1256
msgid "// nomem is useless on global_asm!\n"
msgstr "// global_asm!에서 nomem은 무의미합니다.\n"

#: src/inline-assembly.md:1264
msgid "Rules for inline assembly"
msgstr "인라인 어셈블리 규칙"

#: src/inline-assembly.md:1268
msgid ""
"To avoid undefined behavior, these rules must be followed when using "
"function-scope inline assembly (`asm!`):"
msgstr ""
"정의되지 않은 동작을 피하기 위해, 함수 스코프 인라인 어셈블리(`asm!`)를 사용할 때는 "
"다음 규칙들을 따라야 합니다."

#: src/inline-assembly.md:1272
msgid ""
"Any registers not specified as inputs will contain an undefined value on "
"entry to the asm block."
msgstr ""
"입력으로 지정되지 않은 모든 레지스터는 asm 블록 진입 시 정의되지 않은 값을 갖게 됩니다."

#: src/inline-assembly.md:1273
msgid ""
"An \"undefined value\" in the context of inline assembly means that the "
"register can (non-deterministically) have any one of the possible values "
"allowed by the architecture. Notably it is not the same as an LLVM `undef` "
"which can have a different value every time you read it (since such a "
"concept does not exist in assembly code)."
msgstr ""
"인라인 어셈블리 문맥에서 \"정의되지 않은 값\"이란, 해당 레지스터가 아키텍처에서 허용하는 "
"가능한 값들 중 하나를 (비결정적으로) 가질 수 있음을 의미합니다. 특히 이는 읽을 때마다 "
"값이 달라질 수 있는 LLVM의 `undef`와는 다릅니다(어셈블리 코드에는 그러한 개념이 존재하지 않기 때문입니다)."

#: src/inline-assembly.md:1278
msgid ""
"Any registers not specified as outputs must have the same value upon exiting "
"the asm block as they had on entry, otherwise behavior is undefined."
msgstr ""
"출력으로 지정되지 않은 모든 레지스터는 asm 블록을 나갈 때 진입 시와 동일한 값을 "
"유지해야 합니다. 그렇지 않으면 동작은 정의되지 않습니다."

#: src/inline-assembly.md:1279
msgid ""
"This only applies to registers which can be specified as an input or output. "
"Other registers follow target-specific rules."
msgstr ""
"이는 입력 또는 출력으로 지정될 수 있는 레지스터에만 적용됩니다. "
"다른 레지스터들은 타겟별 규칙을 따릅니다."

#: src/inline-assembly.md:1281
msgid ""
"Note that a `lateout` may be allocated to the same register as an `in`, in "
"which case this rule does not apply. Code should not rely on this however "
"since it depends on the results of register allocation."
msgstr ""
"`lateout`이 `in`과 동일한 레지스터에 할당될 수 있으며, 이 경우 이 규칙은 적용되지 "
"않음에 유의하십시오. 하지만 이는 레지스터 할당 결과에 의존하므로 코드가 이에 "
"의존해서는 안 됩니다."

#: src/inline-assembly.md:1286
msgid "Behavior is undefined if execution unwinds out of an asm block."
msgstr "실행이 asm 블록 밖으로 언와인드(unwind)되는 경우 동작은 정의되지 않습니다."

#: src/inline-assembly.md:1287
msgid ""
"This also applies if the assembly code calls a function which then unwinds."
msgstr "어셈블리 코드가 호출한 함수가 언와인드되는 경우에도 마찬가지로 적용됩니다."

#: src/inline-assembly.md:1291
msgid ""
"The set of memory locations that assembly code is allowed to read and write "
"are the same as those allowed for an FFI function."
msgstr "어셈블리 코드가 읽고 쓸 수 있도록 허용된 메모리 위치의 집합은 FFI 함수에 허용된 것과 동일합니다."

#: src/inline-assembly.md:1292
msgid "Refer to the unsafe code guidelines for the exact rules."
msgstr "정확한 규칙은 안전하지 않은 코드 지침(unsafe code guidelines)을 참조하십시오."

#: src/inline-assembly.md:1293
msgid "If the `readonly` option is set, then only memory reads are allowed."
msgstr "만약 `readonly` 옵션이 설정되어 있다면, 메모리 읽기만 허용됩니다."

#: src/inline-assembly.md:1294
msgid ""
"If the `nomem` option is set then no reads or writes to memory are allowed."
msgstr "만약 `nomem` 옵션이 설정되어 있다면, 메모리에 대한 어떠한 읽기나 쓰기도 허용되지 않습니다."

#: src/inline-assembly.md:1295
msgid ""
"These rules do not apply to memory which is private to the asm code, such as "
"stack space allocated within the asm block."
msgstr "이 규칙들은 asm 블록 내에서 할당된 스택 공간과 같이 어셈블리 코드에 비공개인 메모리에는 적용되지 않습니다."

#: src/inline-assembly.md:1299
msgid ""
"The compiler cannot assume that the instructions in the asm are the ones "
"that will actually end up executed."
msgstr "컴파일러는 asm 내의 명령어가 실제로 실행될 명령어라고 가정할 수 없습니다."

#: src/inline-assembly.md:1300
msgid ""
"This effectively means that the compiler must treat the `asm!` as a black "
"box and only take the interface specification into account, not the "
"instructions themselves."
msgstr "이는 실질적으로 컴파일러가 `asm!`을 블랙박스로 취급해야 하며, 명령어 자체가 아닌 인터페이스 명세만을 고려해야 함을 의미합니다."

#: src/inline-assembly.md:1301
msgid "Runtime code patching is allowed, via target-specific mechanisms."
msgstr "런타임 코드 패칭(patching)은 타겟별 메커니즘을 통해 허용됩니다."

#: src/inline-assembly.md:1302
msgid ""
"However there is no guarantee that each `asm!` directly corresponds to a "
"single instance of instructions in the object file: the compiler is free to "
"duplicate or deduplicate `asm!` blocks."
msgstr ""
"하지만 각 `asm!`이 목적 파일(object file)의 단일 명령어 인스턴스에 직접 대응한다는 보장은 없습니다. "
"컴파일러는 `asm!` 블록을 자유롭게 복제하거나 중복 제거할 수 있습니다."

#: src/inline-assembly.md:1306
msgid ""
"Unless the `nostack` option is set, asm code is allowed to use stack space "
"below the stack pointer."
msgstr ""
"`nostack` 옵션이 설정되지 않은 한, asm 코드는 스택 포인터 아래의 스택 공간을 "
"사용할 수 있습니다."

#: src/inline-assembly.md:1307
msgid ""
"On entry to the asm block the stack pointer is guaranteed to be suitably "
"aligned (according to the target ABI) for a function call."
msgstr ""
"asm 블록 진입 시 스택 포인터는 함수 호출을 위해 (타겟 ABI에 따라) 적절하게 "
"정렬됨이 보장됩니다."

#: src/inline-assembly.md:1308
msgid ""
"You are responsible for making sure you don't overflow the stack (e.g. use "
"stack probing to ensure you hit a guard page)."
msgstr ""
"스택 오버플로가 발생하지 않도록 할 책임은 사용자에게 있습니다(예: 가드 페이지에 "
"도달하도록 스택 프로빙(stack probing) 사용)."

#: src/inline-assembly.md:1309
msgid ""
"You should adjust the stack pointer when allocating stack memory as required "
"by the target ABI."
msgstr ""
"타겟 ABI의 요구에 따라 스택 메모리를 할당할 때는 스택 포인터를 조정해야 합니다."

#: src/inline-assembly.md:1310
msgid ""
"The stack pointer must be restored to its original value before leaving the "
"asm block."
msgstr "asm 블록을 나가기 전에 스택 포인터는 원래 값으로 복구되어야 합니다."

#: src/inline-assembly.md:1314
msgid ""
"If the `noreturn` option is set then behavior is undefined if execution "
"falls through to the end of the asm block."
msgstr ""
"`noreturn` 옵션이 설정된 경우, 실행이 asm 블록의 끝에 도달하면 동작은 정의되지 않습니다."

#: src/inline-assembly.md:1318
msgid ""
"If the `pure` option is set then behavior is undefined if the `asm!` has "
"side-effects other than its direct outputs. Behavior is also undefined if "
"two executions of the `asm!` code with the same inputs result in different "
"outputs."
msgstr ""
"`pure` 옵션이 설정된 경우, `asm!`이 직접적인 출력 이외의 부작용을 가지면 동작은 "
"정의되지 않습니다. 또한 동일한 입력에 대해 두 번의 `asm!` 실행이 서로 다른 출력을 "
"내는 경우에도 동작은 정의되지 않습니다."

#: src/inline-assembly.md:1320
msgid ""
"When used with the `nomem` option, \"inputs\" are just the direct inputs of "
"the `asm!`."
msgstr "`nomem` 옵션과 함께 사용될 때, \"입력\"은 오직 `asm!`의 직접적인 입력만을 의미합니다."

#: src/inline-assembly.md:1321
msgid ""
"When used with the `readonly` option, \"inputs\" comprise the direct inputs "
"of the `asm!` and any memory that the `asm!` block is allowed to read."
msgstr ""
"`readonly` 옵션과 함께 사용될 때, \"입력\"은 `asm!`의 직접적인 입력과 `asm!` 블록이 "
"읽을 수 있도록 허용된 모든 메모리를 포함합니다."

#: src/inline-assembly.md:1325
msgid ""
"These flags registers must be restored upon exiting the asm block if the "
"`preserves_flags` option is set:"
msgstr ""
"`preserves_flags` 옵션이 설정된 경우, 다음 플래그 레지스터들은 asm 블록을 나갈 때 "
"반드시 복구되어야 합니다."

#: src/inline-assembly.md:1327
msgid "Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF)."
msgstr "`EFLAGS`의 상태 플래그 (CF, PF, AF, ZF, SF, OF)."

#: src/inline-assembly.md:1328
msgid "Floating-point status word (all)."
msgstr "부동 소수점 상태 워드 (전체)."

#: src/inline-assembly.md:1329
msgid "Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE)."
msgstr "`MXCSR`의 부동 소수점 예외 플래그 (PE, UE, OE, ZE, DE, IE)."

#: src/inline-assembly.md:1331
msgid "Condition flags in `CPSR` (N, Z, C, V)"
msgstr "`CPSR`의 조건 플래그 (N, Z, C, V)"

#: src/inline-assembly.md:1332
msgid "Saturation flag in `CPSR` (Q)"
msgstr "`CPSR`의 포화(Saturation) 플래그 (Q)"

#: src/inline-assembly.md:1333
msgid "Greater than or equal flags in `CPSR` (GE)."
msgstr "`CPSR`의 크거나 같음(Greater than or equal) 플래그 (GE)."

#: src/inline-assembly.md:1334
msgid "Condition flags in `FPSCR` (N, Z, C, V)"
msgstr "`FPSCR`의 조건 플래그 (N, Z, C, V)"

#: src/inline-assembly.md:1335
msgid "Saturation flag in `FPSCR` (QC)"
msgstr "`FPSCR`의 포화(Saturation) 플래그 (QC)"

#: src/inline-assembly.md:1336
msgid ""
"Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC)."
msgstr "`FPSCR`의 부동 소수점 예외 플래그 (IDC, IXC, UFC, OFC, DZC, IOC)."

#: src/inline-assembly.md:1338
msgid "Condition flags (`NZCV` register)."
msgstr "조건 플래그 (`NZCV` 레지스터)."

#: src/inline-assembly.md:1339
msgid "Floating-point status (`FPSR` register)."
msgstr "부동 소수점 상태 (`FPSR` 레지스터)."

#: src/inline-assembly.md:1341
msgid "Floating-point exception flags in `fcsr` (`fflags`)."
msgstr "`fcsr`의 부동 소수점 예외 플래그 (`fflags`)."

#: src/inline-assembly.md:1342
msgid "Vector extension state (`vtype`, `vl`, `vcsr`)."
msgstr "벡터 확장 상태 (`vtype`, `vl`, `vcsr`)."

#: src/inline-assembly.md:1344
msgid "Floating-point condition flags in `$fcc[0-7]`."
msgstr "`$fcc[0-7]`의 부동 소수점 조건 플래그."

#: src/inline-assembly.md:1346
msgid "The condition code register `cc`."
msgstr "조건 코드 레지스터 `cc`."

#: src/inline-assembly.md:1350
msgid ""
"On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm "
"block and must be clear on exit."
msgstr "x86에서, 방향 플래그(`EFLAGS`의 DF)는 asm 블록 진입 시 해제(clear)되어 있으며, 나갈 때도 반드시 해제되어야 합니다."

#: src/inline-assembly.md:1351
msgid ""
"Behavior is undefined if the direction flag is set on exiting an asm block."
msgstr "asm 블록을 나갈 때 방향 플래그가 설정되어 있으면 동작은 정의되지 않습니다."

#: src/inline-assembly.md:1355
msgid ""
"On x86, the x87 floating-point register stack must remain unchanged unless "
"all of the `st([0-7])` registers have been marked as clobbered with "
"`out(\"st(0)\") _, out(\"st(1)\") _, ...`."
msgstr ""
"x86에서, 모든 `st([0-7])` 레지스터들이 `out(\"st(0)\") _, out(\"st(1)\") _, ...`와 같이 "
"클로버된 것으로 표시되지 않는 한, x87 부동 소수점 레지스터 스택은 변경되지 않은 상태로 "
"유지되어야 합니다."

#: src/inline-assembly.md:1356
msgid ""
"If all x87 registers are clobbered then the x87 register stack is guaranteed "
"to be empty upon entering an `asm` block. Assembly code must ensure that the "
"x87 register stack is also empty when exiting the asm block."
msgstr ""
"모든 x87 레지스터가 클로버(clobber)된 경우, `asm` 블록에 진입할 때 x87 레지스터 스택이 "
"비어 있음이 보장됩니다. 어셈블리 코드는 asm 블록을 나갈 때도 x87 레지스터 스택이 "
"비어 있도록 보장해야 합니다."

#: src/inline-assembly.md:1363
msgid ""
"// we can do complex stuff with x87 if we clobber the entire x87 stack\n"
msgstr "// 전체 x87 스택을 클로버하면 x87로 복잡한 작업을 수행할 수 있습니다.\n"

#: src/inline-assembly.md:1365
msgid "\"fld qword ptr [{x}]\""
msgstr "\"fld qword ptr [{x}]\""

#: src/inline-assembly.md:1366
msgid "\"fld qword ptr [{y}])\""
msgstr "\"fld qword ptr [{y}])\""

#: src/inline-assembly.md:1367
msgid "\"faddp\""
msgstr "\"faddp\""

#: src/inline-assembly.md:1368
msgid "\"fstp qword ptr [{out}]\""
msgstr "\"fstp qword ptr [{out}]\""

#: src/inline-assembly.md:1369
msgid "\"xor eax, eax\""
msgstr "\"xor eax, eax\""

#: src/inline-assembly.md:1370
msgid "\"fstsw ax\""
msgstr "\"fstsw ax\""

#: src/inline-assembly.md:1371
msgid "\"shl eax, 11\""
msgstr "\"shl eax, 11\""

#: src/inline-assembly.md:1375
msgid "\"st(0)\""
msgstr "\"st(0)\""

#: src/inline-assembly.md:1375
msgid "\"st(1)\""
msgstr "\"st(1)\""

#: src/inline-assembly.md:1375
msgid "\"st(2)\""
msgstr "\"st(2)\""

#: src/inline-assembly.md:1375
msgid "\"st(3)\""
msgstr "\"st(3)\""

#: src/inline-assembly.md:1376
msgid "\"st(4)\""
msgstr "\"st(4)\""

#: src/inline-assembly.md:1376
msgid "\"st(5)\""
msgstr "\"st(5)\""

#: src/inline-assembly.md:1376
msgid "\"st(6)\""
msgstr "\"st(6)\""

#: src/inline-assembly.md:1376
msgid "\"st(7)\""
msgstr "\"st(7)\""

#: src/inline-assembly.md:1393
msgid ""
"On arm64ec, [call checkers with appropriate thunks](https://"
"learn.microsoft.com/en-us/windows/arm/arm64ec-abi#authoring-arm64ec-in-"
"assembly) are mandatory when calling functions."
msgstr ""
"arm64ec에서는 함수를 호출할 때 [적절한 펑크(thunks)가 있는 호출 검사기(call checkers)](https://learn.microsoft.com/en-us/windows/arm/arm64ec-abi#authoring-arm64ec-in-assembly)가 "
"필수입니다."

#: src/inline-assembly.md:1397
msgid ""
"The requirement of restoring the stack pointer and non-output registers to "
"their original value only applies when exiting an `asm!` block."
msgstr ""
"스택 포인터와 출력이 아닌 레지스터를 원래 값으로 복구해야 한다는 요구 사항은 "
"`asm!` 블록을 나갈 때만 적용됩니다."

#: src/inline-assembly.md:1398
msgid ""
"This means that `asm!` blocks that never return (even if not marked "
"`noreturn`) don't need to preserve these registers."
msgstr ""
"즉, 절대 반환되지 않는 `asm!` 블록은(`noreturn`으로 표시되지 않았더라도) "
"이러한 레지스터를 보존할 필요가 없습니다."

#: src/inline-assembly.md:1399
msgid ""
"When returning to a different `asm!` block than you entered (e.g. for "
"context switching), these registers must contain the value they had upon "
"entering the `asm!` block that you are _exiting_."
msgstr ""
"(예를 들어 문맥 전환을 위해) 진입했을 때와 다른 `asm!` 블록으로 반환할 때, "
"해당 레지스터들은 현재 _나가고 있는_ `asm!` 블록에 진입했을 때 가졌던 값을 "
"포함해야 합니다."

#: src/inline-assembly.md:1400
msgid ""
"You cannot exit an `asm!` block that has not been entered. Neither can you "
"exit an `asm!` block that has already been exited (without first entering it "
"again)."
msgstr ""
"진입하지 않은 `asm!` 블록을 나갈 수는 없습니다. 또한 이미 나간 `asm!` 블록을 "
"(다시 진입하지 않고) 또 나갈 수도 없습니다."

#: src/inline-assembly.md:1402
msgid ""
"You are responsible for switching any target-specific state (e.g. thread-"
"local storage, stack bounds)."
msgstr ""
"모든 타겟별 상태(예: 스레드 로컬 저장소, 스택 바운드)를 전환할 책임은 사용자에게 있습니다."

#: src/inline-assembly.md:1403
msgid ""
"You cannot jump from an address in one `asm!` block to an address in "
"another, even within the same function or block, without treating their "
"contexts as potentially different and requiring context switching. You "
"cannot assume that any particular value in those contexts (e.g. current "
"stack pointer or temporary values below the stack pointer) will remain "
"unchanged between the two `asm!` blocks."
msgstr ""
"동일한 함수나 블록 내일지라도, 서로 다른 두 `asm!` 블록 사이를 점프할 때는 "
"그 문맥(context)이 잠재적으로 다를 수 있음을 고려하고 문맥 전환(context switching)을 "
"수행해야 합니다. 두 `asm!` 블록 사이에서 특정 문맥 값(예: 현재 스택 포인터 또는 "
"스택 포인터 아래의 임시 값)이 변하지 않은 상태로 유지될 것이라고 가정할 수 없습니다."

#: src/inline-assembly.md:1404
msgid ""
"The set of memory locations that you may access is the intersection of those "
"allowed by the `asm!` blocks you entered and exited."
msgstr ""
"접근할 수 있는 메모리 위치의 집합은 진입한 `asm!` 블록과 나가는 `asm!` 블록에서 "
"허용된 위치들의 교집합입니다."

#: src/inline-assembly.md:1408
msgid ""
"You cannot assume that two `asm!` blocks adjacent in source code, even "
"without any other code between them, will end up in successive addresses in "
"the binary without any other instructions between them."
msgstr ""
"소스 코드상에서 인접한 두 `asm!` 블록이 사이에 다른 코드가 없더라도, "
"바이너리 상에서 사이에 다른 명령어 없이 연속된 주소에 위치할 것이라고 가정할 수 없습니다."

#: src/inline-assembly.md:1412
msgid ""
"You cannot assume that an `asm!` block will appear exactly once in the "
"output binary. The compiler is allowed to instantiate multiple copies of the "
"`asm!` block, for example when the function containing it is inlined in "
"multiple places."
msgstr ""
"`asm!` 블록이 출력 바이너리에 정확히 한 번 나타날 것이라고 가정할 수 없습니다. "
"컴파일러는 `asm!` 블록을 포함하는 함수가 여러 곳에 인라인되는 경우와 같이 "
"`asm!` 블록의 여러 복사본을 인스턴스화할 수 있습니다."

#: src/inline-assembly.md:1417
msgid ""
"On x86, inline assembly must not end with an instruction prefix (such as "
"`LOCK`) that would apply to instructions generated by the compiler."
msgstr ""
"x86에서, 인라인 어셈블리는 컴파일러가 생성한 명령어에 적용될 수 있는 "
"명령어 접두사(예: `LOCK`)로 끝나서는 안 됩니다."

#: src/inline-assembly.md:1418
msgid ""
"The compiler is currently unable to detect this due to the way inline "
"assembly is compiled, but may catch and reject this in the future."
msgstr ""
"현재 컴파일러는 인라인 어셈블리가 컴파일되는 방식 때문에 이를 감지할 수 없지만, "
"향후에는 이를 포착하여 거부할 수 있습니다."

#: src/inline-assembly.md:1422
msgid ""
"**Note**: As a general rule, the flags covered by `preserves_flags` are "
"those which are _not_ preserved when performing a function call."
msgstr ""
"**참고**: 일반적으로 `preserves_flags`에 포함되는 플래그들은 "
"함수 호출 시 보존되지 _않는_ 플래그들입니다."

#: src/inline-assembly.md:1426
msgid "Correctness and Validity"
msgstr "정확성 및 유효성"

#: src/inline-assembly.md:1430
msgid ""
"In addition to all of the previous rules, the string argument to `asm!` must "
"ultimately become--- after all other arguments are evaluated, formatting is "
"performed, and operands are translated--- assembly that is both "
"syntactically correct and semantically valid for the target architecture. "
"The formatting rules allow the compiler to generate assembly with correct "
"syntax. Rules concerning operands permit valid translation of Rust operands "
"into and out of `asm!`. Adherence to these rules is necessary, but not "
"sufficient, for the final expanded assembly to be both correct and valid. "
"For instance:"
msgstr ""
"앞서 언급한 모든 규칙과 더불어, `asm!`의 문자열 인자는 모든 다른 인자가 평가되고 "
"포맷팅이 수행되며 피연산자가 번역된 후 최종적으로 타겟 아키텍처에 대해 "
"구문적으로 올바르고 의미론적으로 유효한 어셈블리가 되어야 합니다. "
"포맷팅 규칙을 통해 컴파일러는 올바른 구문을 가진 어셈블리를 생성할 수 있습니다. "
"피연산자에 관한 규칙은 러스트 피연산자를 `asm!` 내부 및 외부로 유효하게 번역할 수 있게 합니다. "
"이러한 규칙들을 준수하는 것은 최종적으로 확장된 어셈블리가 정확하고 유효하기 위해 "
"필요하지만 충분하지는 않습니다. 예를 들면 다음과 같습니다."

#: src/inline-assembly.md:1438
msgid ""
"arguments may be placed in positions which are syntactically incorrect after "
"formatting"
msgstr "인자들이 포맷팅된 후 구문적으로 잘못된 위치에 배치될 수 있습니다."

#: src/inline-assembly.md:1439
msgid ""
"an instruction may be correctly written, but given architecturally invalid "
"operands"
msgstr "명령어는 올바르게 작성되었으나 아키텍처적으로 유효하지 않은 피연산자가 제공될 수 있습니다."

#: src/inline-assembly.md:1440
msgid ""
"an architecturally unspecified instruction may be assembled into unspecified "
"code"
msgstr "아키텍처적으로 명시되지 않은 명령어가 명시되지 않은 코드로 어셈블될 수 있습니다."

#: src/inline-assembly.md:1441
msgid ""
"a set of instructions, each correct and valid, may cause undefined behavior "
"if placed in immediate succession"
msgstr "각각은 정확하고 유효한 명령어 집합일지라도, 연달아 배치될 경우 정의되지 않은 동작을 초래할 수 있습니다."

#: src/inline-assembly.md:1445
msgid ""
"As a result, these rules are _non-exhaustive_. The compiler is not required "
"to check the correctness and validity of the initial string nor the final "
"assembly that is generated. The assembler may check for correctness and "
"validity but is not required to do so. When using `asm!`, a typographical "
"error may be sufficient to make a program unsound, and the rules for "
"assembly may include thousands of pages of architectural reference manuals. "
"Programmers should exercise appropriate care, as invoking this `unsafe` "
"capability comes with assuming the responsibility of not violating rules of "
"both the compiler or the architecture."
msgstr ""
"결과적으로, 이러한 규칙들은 _비포괄적(non-exhaustive)_입니다. 컴파일러는 초기 문자열이나 "
"최종적으로 생성된 어셈블리의 정확성과 유효성을 검사할 의무가 없습니다. 어셈블러는 "
"정확성과 유효성을 검사할 수도 있지만 반드시 그래야 하는 것은 아닙니다. `asm!`을 "
"사용할 때, 오타 하나만으로도 프로그램이 불안정해질 수 있으며, 어셈블리 규칙에는 "
"수천 페이지 분량의 아키텍처 참조 매뉴얼이 포함될 수 있습니다. 프로그래머는 이 "
"`unsafe` 기능을 호출하는 것이 컴파일러와 아키텍처 양쪽의 규칙을 위반하지 않을 "
"책임을 지는 것임을 인지하고 적절한 주의를 기울여야 합니다."

#: src/inline-assembly.md:1455
msgid "Directives Support"
msgstr "지시어 지원"

#: src/inline-assembly.md:1459
msgid ""
"Inline assembly supports a subset of the directives supported by both GNU AS "
"and LLVM's internal assembler, given as follows. The result of using other "
"directives is assembler-specific (and may cause an error, or may be accepted "
"as-is)."
msgstr ""
"인라인 어셈블리는 다음과 같이 GNU AS와 LLVM 내부 어셈블러 양쪽에서 지원하는 "
"지시어의 하위 집합을 지원합니다. 다른 지시어를 사용한 결과는 어셈블러에 따라 다르며"
"(오류를 발생시키거나 그대로 수용될 수 있음)."

#: src/inline-assembly.md:1464
msgid ""
"If inline assembly includes any \"stateful\" directive that modifies how "
"subsequent assembly is processed, the block must undo the effects of any "
"such directives before the inline assembly ends."
msgstr ""
"만약 인라인 어셈블리에 후속 어셈블리 처리 방식을 변경하는 \"상태 유지(stateful)\" 지시어가 "
"포함된 경우, 해당 블록은 인라인 어셈블리가 끝나기 전에 그러한 지시어의 효과를 "
"되돌려야(undo) 합니다."

#: src/inline-assembly.md:1468
msgid ""
"The following directives are guaranteed to be supported by the assembler:"
msgstr "다음 지시어들은 어셈블러에 의해 지원됨이 보장됩니다:"

#: src/inline-assembly.md:1470
msgid "`.2byte`"
msgstr "`.2byte`"

#: src/inline-assembly.md:1471
msgid "`.4byte`"
msgstr "`.4byte`"

#: src/inline-assembly.md:1472
msgid "`.8byte`"
msgstr "`.8byte`"

#: src/inline-assembly.md:1473
msgid "`.align`"
msgstr "`.align`"

#: src/inline-assembly.md:1474
msgid "`.alt_entry`"
msgstr "`.alt_entry`"

#: src/inline-assembly.md:1475
msgid "`.ascii`"
msgstr "`.ascii`"

#: src/inline-assembly.md:1476
msgid "`.asciz`"
msgstr "`.asciz`"

#: src/inline-assembly.md:1477
msgid "`.balign`"
msgstr "`.balign`"

#: src/inline-assembly.md:1478
msgid "`.balignl`"
msgstr "`.balignl`"

#: src/inline-assembly.md:1479
msgid "`.balignw`"
msgstr "`.balignw`"

#: src/inline-assembly.md:1480
msgid "`.bss`"
msgstr "`.bss`"

#: src/inline-assembly.md:1481
msgid "`.byte`"
msgstr "`.byte`"

#: src/inline-assembly.md:1482
msgid "`.comm`"
msgstr "`.comm`"

#: src/inline-assembly.md:1483
msgid "`.data`"
msgstr "`.data`"

#: src/inline-assembly.md:1484
msgid "`.def`"
msgstr "`.def`"

#: src/inline-assembly.md:1485
msgid "`.double`"
msgstr "`.double`"

#: src/inline-assembly.md:1486
msgid "`.endef`"
msgstr "`.endef`"

#: src/inline-assembly.md:1487
msgid "`.equ`"
msgstr "`.equ`"

#: src/inline-assembly.md:1488
msgid "`.equiv`"
msgstr "`.equiv`"

#: src/inline-assembly.md:1489
msgid "`.eqv`"
msgstr "`.eqv`"

#: src/inline-assembly.md:1490
msgid "`.fill`"
msgstr "`.fill`"

#: src/inline-assembly.md:1491
msgid "`.float`"
msgstr "`.float`"

#: src/inline-assembly.md:1492
msgid "`.global`"
msgstr "`.global`"

#: src/inline-assembly.md:1493
msgid "`.globl`"
msgstr "`.globl`"

#: src/inline-assembly.md:1494
msgid "`.inst`"
msgstr "`.inst`"

#: src/inline-assembly.md:1495
msgid "`.insn`"
msgstr "`.insn`"

#: src/inline-assembly.md:1496
msgid "`.lcomm`"
msgstr "`.lcomm`"

#: src/inline-assembly.md:1497
msgid "`.long`"
msgstr "`.long`"

#: src/inline-assembly.md:1498
msgid "`.octa`"
msgstr "`.octa`"

#: src/inline-assembly.md:1499
msgid "`.option`"
msgstr "`.option`"

#: src/inline-assembly.md:1500
msgid "`.p2align`"
msgstr "`.p2align`"

#: src/inline-assembly.md:1501
msgid "`.popsection`"
msgstr "`.popsection`"

#: src/inline-assembly.md:1502
msgid "`.private_extern`"
msgstr "`.private_extern`"

#: src/inline-assembly.md:1503
msgid "`.pushsection`"
msgstr "`.pushsection`"

#: src/inline-assembly.md:1504
msgid "`.quad`"
msgstr "`.quad`"

#: src/inline-assembly.md:1505
msgid "`.scl`"
msgstr "`.scl`"

#: src/inline-assembly.md:1506
msgid "`.section`"
msgstr "`.section`"

#: src/inline-assembly.md:1507
msgid "`.set`"
msgstr "`.set`"

#: src/inline-assembly.md:1508
msgid "`.short`"
msgstr "`.short`"

#: src/inline-assembly.md:1509
msgid "`.size`"
msgstr "`.size`"

#: src/inline-assembly.md:1510
msgid "`.skip`"
msgstr "`.skip`"

#: src/inline-assembly.md:1511
msgid "`.sleb128`"
msgstr "`.sleb128`"

#: src/inline-assembly.md:1512
msgid "`.space`"
msgstr "`.space`"

#: src/inline-assembly.md:1513
msgid "`.string`"
msgstr "`.string`"

#: src/inline-assembly.md:1514
msgid "`.text`"
msgstr "`.text`"

#: src/inline-assembly.md:1515
msgid "`.type`"
msgstr "`.type`"

#: src/inline-assembly.md:1516
msgid "`.uleb128`"
msgstr "`.uleb128`"

#: src/inline-assembly.md:1517
msgid "`.word`"
msgstr "`.word`"

#: src/inline-assembly.md:1525
msgid "\"jmp 3f\""
msgstr "\"jmp 3f\""

#: src/inline-assembly.md:1525
msgid "\"2: .ascii \\\"Hello World!\\\"\""
msgstr "\"2: .ascii \\\"Hello World!\\\"\""

#: src/inline-assembly.md:1526
msgid "\"3: lea {bytes}, [2b+rip]\""
msgstr "\"3: lea {bytes}, [2b+rip]\""

#: src/inline-assembly.md:1527
msgid "\"mov {len}, 12\""
msgstr "\"mov {len}, 12\""

#: src/inline-assembly.md:1541
msgid "Target Specific Directive Support"
msgstr "타겟별 지시어 지원"

#: src/inline-assembly.md:1546
msgid "Dwarf Unwinding"
msgstr "Dwarf 언와인딩(Unwinding)"

#: src/inline-assembly.md:1548
msgid ""
"The following directives are supported on ELF targets that support DWARF "
"unwind info:"
msgstr "DWARF 언와인딩 정보를 지원하는 ELF 타겟에서 다음 지시어들이 지원됩니다:"

#: src/inline-assembly.md:1550
msgid "`.cfi_adjust_cfa_offset`"
msgstr "`.cfi_adjust_cfa_offset`"

#: src/inline-assembly.md:1551
msgid "`.cfi_def_cfa`"
msgstr "`.cfi_def_cfa`"

#: src/inline-assembly.md:1552
msgid "`.cfi_def_cfa_offset`"
msgstr "`.cfi_def_cfa_offset`"

#: src/inline-assembly.md:1553
msgid "`.cfi_def_cfa_register`"
msgstr "`.cfi_def_cfa_register`"

#: src/inline-assembly.md:1554
msgid "`.cfi_endproc`"
msgstr "`.cfi_endproc`"

#: src/inline-assembly.md:1555
msgid "`.cfi_escape`"
msgstr "`.cfi_escape`"

#: src/inline-assembly.md:1556
msgid "`.cfi_lsda`"
msgstr "`.cfi_lsda`"

#: src/inline-assembly.md:1557
msgid "`.cfi_offset`"
msgstr "`.cfi_offset`"

#: src/inline-assembly.md:1558
msgid "`.cfi_personality`"
msgstr "`.cfi_personality`"

#: src/inline-assembly.md:1559
msgid "`.cfi_register`"
msgstr "`.cfi_register`"

#: src/inline-assembly.md:1560
msgid "`.cfi_rel_offset`"
msgstr "`.cfi_rel_offset`"

#: src/inline-assembly.md:1561
msgid "`.cfi_remember_state`"
msgstr "`.cfi_remember_state`"

#: src/inline-assembly.md:1562
msgid "`.cfi_restore`"
msgstr "`.cfi_restore`"

#: src/inline-assembly.md:1563
msgid "`.cfi_restore_state`"
msgstr "`.cfi_restore_state`"

#: src/inline-assembly.md:1564
msgid "`.cfi_return_column`"
msgstr "`.cfi_return_column`"

#: src/inline-assembly.md:1565
msgid "`.cfi_same_value`"
msgstr "`.cfi_same_value`"

#: src/inline-assembly.md:1566
msgid "`.cfi_sections`"
msgstr "`.cfi_sections`"

#: src/inline-assembly.md:1567
msgid "`.cfi_signal_frame`"
msgstr "`.cfi_signal_frame`"

#: src/inline-assembly.md:1568
msgid "`.cfi_startproc`"
msgstr "`.cfi_startproc`"

#: src/inline-assembly.md:1569
msgid "`.cfi_undefined`"
msgstr "`.cfi_undefined`"

#: src/inline-assembly.md:1570
msgid "`.cfi_window_save`"
msgstr "`.cfi_window_save`"

#: src/inline-assembly.md:1574
msgid "Structured Exception Handling"
msgstr "구조화된 예외 처리 (Structured Exception Handling)"

#: src/inline-assembly.md:1576
msgid ""
"On targets with structured exception Handling, the following additional "
"directives are guaranteed to be supported:"
msgstr "구조화된 예외 처리를 사용하는 타겟에서는 다음의 추가 지시어들이 지원됨이 보장됩니다:"

#: src/inline-assembly.md:1578
msgid "`.seh_endproc`"
msgstr "`.seh_endproc`"

#: src/inline-assembly.md:1579
msgid "`.seh_endprologue`"
msgstr "`.seh_endprologue`"

#: src/inline-assembly.md:1580
msgid "`.seh_proc`"
msgstr "`.seh_proc`"

#: src/inline-assembly.md:1581
msgid "`.seh_pushreg`"
msgstr "`.seh_pushreg`"

#: src/inline-assembly.md:1582
msgid "`.seh_savereg`"
msgstr "`.seh_savereg`"

#: src/inline-assembly.md:1583
msgid "`.seh_setframe`"
msgstr "`.seh_setframe`"

#: src/inline-assembly.md:1584
msgid "`.seh_stackalloc`"
msgstr "`.seh_stackalloc`"

#: src/inline-assembly.md:1588
msgid "x86 (32-bit and 64-bit)"
msgstr "x86 (32비트 및 64비트)"

#: src/inline-assembly.md:1590
msgid ""
"On x86 targets, both 32-bit and 64-bit, the following additional directives "
"are guaranteed to be supported:"
msgstr "32비트 및 64비트 x86 타겟 모두에서 다음의 추가 지시어들이 지원됨이 보장됩니다:"

#: src/inline-assembly.md:1591
msgid "`.nops`"
msgstr "`.nops`"

#: src/inline-assembly.md:1592
msgid "`.code16`"
msgstr "`.code16`"

#: src/inline-assembly.md:1593
msgid "`.code32`"
msgstr "`.code32`"

#: src/inline-assembly.md:1594
msgid "`.code64`"
msgstr "`.code64`"

#: src/inline-assembly.md:1596
msgid ""
"Use of `.code16`, `.code32`, and `.code64` directives are only supported if "
"the state is reset to the default before exiting the assembly block. 32-bit "
"x86 uses `.code32` by default, and x86_64 uses `.code64` by default."
msgstr ""
"`.code16`, `.code32`, `.code64` 지시어의 사용은 어셈블리 블록을 나가기 전에 "
"상태가 기본값으로 복구되는 경우에만 지원됩니다. 32비트 x86은 기본적으로 `.code32`를 "
"사용하고, x86_64는 기본적으로 `.code64`를 사용합니다."

#: src/inline-assembly.md:1601
msgid "ARM (32-bit)"
msgstr "ARM (32비트)"

#: src/inline-assembly.md:1603
msgid ""
"On ARM, the following additional directives are guaranteed to be supported:"
msgstr "ARM에서 다음의 추가 지시어들이 지원됨이 보장됩니다:"

#: src/inline-assembly.md:1605
msgid "`.even`"
msgstr "`.even`"

#: src/inline-assembly.md:1606
msgid "`.fnstart`"
msgstr "`.fnstart`"

#: src/inline-assembly.md:1607
msgid "`.fnend`"
msgstr "`.fnend`"

#: src/inline-assembly.md:1608
msgid "`.save`"
msgstr "`.save`"

#: src/inline-assembly.md:1609
msgid "`.movsp`"
msgstr "`.movsp`"

#: src/inline-assembly.md:1610
msgid "`.code`"
msgstr "`.code`"

#: src/inline-assembly.md:1611
msgid "`.thumb`"
msgstr "`.thumb`"

#: src/inline-assembly.md:1612
msgid "`.thumb_func`"
msgstr "`.thumb_func`"

#: src/unsafety.md:7
msgid ""
"Unsafe operations are those that can potentially violate the memory-safety "
"guarantees of Rust's static semantics."
msgstr ""
"안전하지 않은(unsafe) 연산은 러스트의 정적 세만틱(static semantics)이 보장하는 "
"메모리 안전성을 잠재적으로 위반할 수 있는 연산들입니다."

#: src/unsafety.md:12
msgid ""
"The following language level features cannot be used in the safe subset of "
"Rust:"
msgstr "다음의 언어 레벨 기능들은 러스트의 안전한 하위 집합(safe subset)에서 사용될 수 없습니다:"

#: src/unsafety.md:17
msgid "Dereferencing a [raw pointer](types/pointer.md)."
msgstr "[원시 포인터(raw pointer)](types/pointer.md)를 역참조하는 것."

#: src/unsafety.md:21
msgid ""
"Reading or writing a [mutable](items/static-items.md#mutable-statics) or "
"[external](items/external-blocks.md) static variable."
msgstr ""
"[가변(mutable)](items/static-items.md#mutable-statics) 또는 [외부(external)](items/external-blocks.md) "
"정적 변수를 읽거나 쓰는 것."

#: src/unsafety.md:25
msgid ""
"Accessing a field of a [`union`](items/unions.md), other than to assign to "
"it."
msgstr "값을 할당하는 경우를 제외하고 [`유니온(union)`](items/unions.md)의 필드에 접근하는 것."

#: src/unsafety.md:29
msgid ""
"Calling an unsafe function (including an intrinsic or foreign function)."
msgstr "안전하지 않은 함수(내장 함수(intrinsic)나 외래 함수(foreign function) 포함)를 호출하는 것."

#: src/unsafety.md:33
msgid ""
"Calling a safe function marked with a [`target_feature`](attributes/"
"codegen.md#r-attributes.codegen.target_feature) from a function that does "
"not have a `target_feature` attribute enabling the same features (see "
"[attributes.codegen.target_feature.safety-restrictions](attributes/"
"codegen.md#r-attributes.codegen.target_feature.safety-restrictions))."
msgstr ""
"동일한 기능을 활성화하는 `target_feature` 속성이 없는 함수에서 [`target_feature`](attributes/codegen.md#r-attributes.codegen.target_feature)가 "
"지정된 안전한 함수를 호출하는 것([attributes.codegen.target_feature.safety-restrictions](attributes/codegen.md#r-attributes.codegen.target_feature.safety-restrictions) 참조)."

#: src/unsafety.md:37
msgid "Implementing an [unsafe trait](items/traits.md#unsafe-traits)."
msgstr "[안전하지 않은 트레잇(unsafe trait)](items/traits.md#unsafe-traits)을 구현하는 것."

#: src/unsafety.md:41
msgid "Declaring an [`extern`](items/external-blocks.md) block[^extern-2024]."
msgstr "[`extern`](items/external-blocks.md) 블록을 선언하는 것[^extern-2024]."

#: src/unsafety.md:45
msgid "Applying an [unsafe attribute](attributes.md) to an item."
msgstr "아이템에 [안전하지 않은 속성(unsafe attribute)](attributes.md)을 적용하는 것."

#: src/unsafety.md:47
msgid ""
"Prior to the 2024 edition, extern blocks were allowed to be declared without "
"`unsafe`."
msgstr "2024 에디션 이전에는 extern 블록을 `unsafe` 없이 선언할 수 있었습니다."

#: src/unsafe-keyword.md:7
msgid ""
"The `unsafe` keyword can occur in several different contexts: unsafe "
"functions (`unsafe fn`), unsafe blocks (`unsafe {}`), unsafe traits (`unsafe "
"trait`), unsafe trait implementations (`unsafe impl`), unsafe external "
"blocks (`unsafe extern`), and unsafe attributes (`#[unsafe(attr)]`). It "
"plays several different roles, depending on where it is used and whether the "
"`unsafe_op_in_unsafe_fn` lint is enabled:"
msgstr ""
"`unsafe` 키워드는 안전하지 않은 함수(`unsafe fn`), 안전하지 않은 블록(`unsafe {}`), "
"안전하지 않은 트레잇(`unsafe trait`), 안전하지 않은 트레잇 구현(`unsafe impl`), "
"안전하지 않은 외부 블록(`unsafe extern`), 그리고 안전하지 않은 속성(`#[unsafe(attr)]`)과 "
"같이 여러 다른 문맥에서 나타날 수 있습니다. 이는 사용되는 위치와 `unsafe_op_in_unsafe_fn` "
"린트(lint)의 활성화 여부에 따라 여러 다른 역할을 수행합니다."

#: src/unsafe-keyword.md:10
msgid ""
"it is used to mark code that _defines_ extra safety conditions (`unsafe fn`, "
"`unsafe trait`)"
msgstr ""
"추가적인 안전 조건을 _정의_하는 코드를 표시하는 데 사용됩니다(`unsafe fn`, `unsafe trait`)."

#: src/unsafe-keyword.md:11
msgid ""
"it is used to mark code that needs to _satisfy_ extra safety conditions "
"(`unsafe {}`, `unsafe impl`, `unsafe fn` without [`unsafe_op_in_unsafe_fn`]"
"(../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn), "
"`unsafe extern`, `#[unsafe(attr)]`)"
msgstr ""
"추가적인 안전 조건을 _만족_시켜야 하는 코드를 표시하는 데 사용됩니다"
"(`unsafe {}`, `unsafe impl`, [`unsafe_op_in_unsafe_fn`](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn)이 "
"설정되지 않은 `unsafe fn`, `unsafe extern`, `#[unsafe(attr)]`)."

#: src/unsafe-keyword.md:13
msgid ""
"The following discusses each of these cases. See the [keyword documentation]"
"(../std/keyword.unsafe.html) for some illustrative examples."
msgstr ""
"다음은 각 경우에 대해 설명합니다. 몇 가지 예시는 [키워드 문서](../std/keyword.unsafe.html)를 참조하십시오."

#: src/unsafe-keyword.md:18
msgid "Unsafe functions (`unsafe fn`)"
msgstr "안전하지 않은 함수 (`unsafe fn`)"

#: src/unsafe-keyword.md:22
msgid ""
"Unsafe functions are functions that are not safe in all contexts and/or for "
"all possible inputs. We say they have _extra safety conditions_, which are "
"requirements that must be upheld by all callers and that the compiler does "
"not check. For example, [`get_unchecked`](../std/"
"primitive.slice.html#method.get_unchecked) has the extra safety condition "
"that the index must be in-bounds. The unsafe function should come with "
"documentation explaining what those extra safety conditions are."
msgstr ""
"안전하지 않은 함수는 모든 문맥에서 그리고/또는 모든 가능한 입력에 대해 안전하지 않은 함수입니다. "
"이러한 함수들은 모든 호출자가 준수해야 하지만 컴파일러가 확인하지 않는 요구 사항인 "
"_추가 안전 조건_을 갖는다고 말합니다. 예를 들어, [`get_unchecked`](../std/primitive.slice.html#method.get_unchecked)는 "
"인덱스가 범위를 벗어나지 않아야 한다는 추가 안전 조건을 가집니다. 안전하지 않은 함수는 "
"그러한 추가 안전 조건이 무엇인지 설명하는 문서를 동반해야 합니다."

#: src/unsafe-keyword.md:29
msgid ""
"Such a function must be prefixed with the keyword `unsafe` and can only be "
"called from inside an `unsafe` block, or inside `unsafe fn` without the "
"[`unsafe_op_in_unsafe_fn`](../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint."
msgstr ""
"이러한 함수는 `unsafe` 키워드를 앞에 붙여야 하며, `unsafe` 블록 내부 또는 "
"[`unsafe_op_in_unsafe_fn`](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) "
"린트가 없는 `unsafe fn` 내부에서만 호출될 수 있습니다."

#: src/unsafe-keyword.md:33
msgid "Unsafe blocks (`unsafe {}`)"
msgstr "안전하지 않은 블록 (`unsafe {}`)"

#: src/unsafe-keyword.md:37
msgid ""
"A block of code can be prefixed with the `unsafe` keyword to permit using "
"the unsafe actions as defined in the [Unsafety](unsafety.md) chapter, such "
"as calling other unsafe functions or dereferencing raw pointers."
msgstr ""
"코드 블록 앞에 `unsafe` 키워드를 붙여 [안전하지 않음(Unsafety)](unsafety.md) 장에 "
"정의된 안전하지 않은 동작들(예: 다른 안전하지 않은 함수 호출 또는 원시 포인터 역참조)의 "
"사용을 허용할 수 있습니다."

#: src/unsafe-keyword.md:41
msgid ""
"By default, the body of an unsafe function is also considered to be an "
"unsafe block; this can be changed by enabling the [`unsafe_op_in_unsafe_fn`]"
"(../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint."
msgstr ""
"기본적으로 안전하지 않은 함수의 본문은 안전하지 않은 블록으로 간주됩니다. "
"이는 [`unsafe_op_in_unsafe_fn`](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) "
"린트를 활성화하여 변경할 수 있습니다."

#: src/unsafe-keyword.md:44
msgid ""
"By putting operations into an unsafe block, the programmer states that they "
"have taken care of satisfying the extra safety conditions of all operations "
"inside that block."
msgstr ""
"연산들을 `unsafe` 블록 안에 넣음으로써, 프로그래머는 해당 블록 내부의 모든 "
"연산에 대한 추가 안전 조건을 충족하도록 조치를 취했음을 선언합니다."

#: src/unsafe-keyword.md:46
msgid ""
"Unsafe blocks are the logical dual to unsafe functions: where unsafe "
"functions define a proof obligation that callers must uphold, unsafe blocks "
"state that all relevant proof obligations of functions or operations called "
"inside the block have been discharged. There are many ways to discharge "
"proof obligations; for example, there could be run-time checks or data "
"structure invariants that guarantee that certain properties are definitely "
"true, or the unsafe block could be inside an `unsafe fn`, in which case the "
"block can use the proof obligations of that function to discharge the proof "
"obligations arising inside the block."
msgstr ""
"안전하지 않은 블록은 안전하지 않은 함수와 논리적으로 대칭을 이룹니다. "
"안전하지 않은 함수가 호출자가 준수해야 하는 증명 책임(proof obligation)을 정의한다면, "
"안전하지 않은 블록은 블록 내부에서 호출된 함수나 연산의 모든 관련 증명 책임이 "
"완료되었음을 나타냅니다. 증명 책임을 완료하는 방법은 많습니다. 예를 들어, "
"특정 속성이 확실히 참임을 보장하는 런타임 검사나 데이터 구조의 불변성(invariants)이 "
"있을 수 있습니다. 또는 안전하지 않은 블록이 `unsafe fn` 내부에 있는 경우, "
"해당 블록은 그 함수의 증명 책임을 사용하여 블록 내부에서 발생하는 증명 책임을 "
"완료할 수 있습니다."

#: src/unsafe-keyword.md:51
msgid ""
"Unsafe blocks are used to wrap foreign libraries, make direct use of "
"hardware or implement features not directly present in the language. For "
"example, Rust provides the language features necessary to implement memory-"
"safe concurrency in the language but the implementation of threads and "
"message passing in the standard library uses unsafe blocks."
msgstr ""
"안전하지 않은 블록은 외부 라이브러리를 래핑하거나, 하드웨어를 직접 사용하거나, "
"언어에 직접 존재하지 않는 기능을 구현할 때 사용됩니다. 예를 들어, 러스트는 "
"메모리 안전한 동시성을 구현하는 데 필요한 언어적 기능을 제공하지만, 표준 라이브러리의 "
"스레드 및 메시지 패싱 구현은 안전하지 않은 블록을 사용합니다."

#: src/unsafe-keyword.md:54
msgid ""
"Rust's type system is a conservative approximation of the dynamic safety "
"requirements, so in some cases there is a performance cost to using safe "
"code. For example, a doubly-linked list is not a tree structure and can only "
"be represented with reference-counted pointers in safe code. By using "
"`unsafe` blocks to represent the reverse links as raw pointers, it can be "
"implemented without reference counting. (See [\"Learn Rust With Entirely Too "
"Many Linked Lists\"](https://rust-unofficial.github.io/too-many-lists/) for "
"a more in-depth exploration of this particular example.)"
msgstr ""
"러스트의 타입 시스템은 동적 안전성 요구 사항에 대한 보수적인 근사치이므로, "
"어떤 경우에는 안전한 코드를 사용하는 데 성능 비용이 발생합니다. 예를 들어, "
"이중 연결 리스트는 트리 구조가 아니며 안전한 코드에서는 참조 횟수 계산(RC) 포인터로만 "
"표현될 수 있습니다. `unsafe` 블록을 사용하여 역방향 링크를 원시 포인터로 표현하면 "
"참조 횟수 계산 없이 구현할 수 있습니다. (이 예제에 대한 더 심도 있는 탐구는 "
"[\"Learn Rust With Entirely Too Many Linked Lists\"](https://rust-unofficial.github.io/too-many-lists/)를 "
"참조하십시오.)"

#: src/unsafe-keyword.md:63
msgid "Unsafe traits (`unsafe trait`)"
msgstr "안전하지 않은 트레잇 (`unsafe trait`)"

#: src/unsafe-keyword.md:67
msgid ""
"An unsafe trait is a trait that comes with extra safety conditions that must "
"be upheld by _implementations_ of the trait. The unsafe trait should come "
"with documentation explaining what those extra safety conditions are."
msgstr ""
"안전하지 않은 트레잇은 트레잇의 _구현체_가 준수해야 하는 추가 안전 조건이 "
"함께 제공되는 트레잇입니다. 안전하지 않은 트레잇은 그러한 추가 안전 조건이 "
"무엇인지 설명하는 문서를 동반해야 합니다."

#: src/unsafe-keyword.md:72
msgid ""
"Such a trait must be prefixed with the keyword `unsafe` and can only be "
"implemented by `unsafe impl` blocks."
msgstr ""
"그러한 트레잇은 `unsafe` 키워드를 앞에 붙여야 하며, 오직 `unsafe impl` 블록을 "
"통해서만 구현될 수 있습니다."

#: src/unsafe-keyword.md:76
msgid "Unsafe trait implementations (`unsafe impl`)"
msgstr "안전하지 않은 트레잇 구현 (`unsafe impl`)"

#: src/unsafe-keyword.md:79
msgid ""
"When implementing an unsafe trait, the implementation needs to be prefixed "
"with the `unsafe` keyword. By writing `unsafe impl`, the programmer states "
"that they have taken care of satisfying the extra safety conditions required "
"by the trait."
msgstr ""
"안전하지 않은 트레잇을 구현할 때, 구현체 앞에 `unsafe` 키워드를 붙여야 합니다. "
"`unsafe impl`을 작성함으로써, 프로그래머는 트레잇에서 요구하는 추가 안전 조건을 "
"충족하도록 조치를 취했음을 선언합니다."

#: src/unsafe-keyword.md:82
msgid ""
"Unsafe trait implementations are the logical dual to unsafe traits: where "
"unsafe traits define a proof obligation that implementations must uphold, "
"unsafe implementations state that all relevant proof obligations have been "
"discharged."
msgstr ""
"안전하지 않은 트레잇 구현은 안전하지 않은 트레잇과 논리적으로 대칭을 이룹니다. "
"안전하지 않은 트레잇이 구현체가 준수해야 하는 증명 책임을 정의한다면, "
"안전하지 않은 구현은 모든 관련 증명 책임이 완료되었음을 나타냅니다."

#: src/unsafe-keyword.md:90
msgid "Unsafe external blocks (`unsafe extern`)"
msgstr "안전하지 않은 외부 블록 (`unsafe extern`)"

#: src/unsafe-keyword.md:93
msgid ""
"The programmer who declares an [external block](items/external-blocks.md) "
"must assure that the signatures of the items contained within are correct. "
"Failing to do so may lead to undefined behavior.  That this obligation has "
"been met is indicated by writing `unsafe extern`."
msgstr ""
"[외부 블록](items/external-blocks.md)을 선언하는 프로그래머는 내부에 포함된 "
"아이템의 시그니처가 정확함을 보장해야 합니다. 그렇지 않으면 정의되지 않은 동작으로 "
"이어질 수 있습니다. 이러한 의무가 충족되었음을 `unsafe extern`을 작성하여 나타냅니다."

#: src/unsafe-keyword.md:97
msgid ""
"**Edition differences**: Prior to edition 2024, `extern` blocks were allowed "
"without being qualified as `unsafe`."
msgstr "**에디션 차이**: 2024 에디션 이전에는 `extern` 블록에 `unsafe`를 붙이지 않아도 되었습니다."

#: src/unsafe-keyword.md:103
msgid "Unsafe attributes (`#[unsafe(attr)]`)"
msgstr "안전하지 않은 속성 (`#[unsafe(attr)]`)"

#: src/unsafe-keyword.md:106
msgid ""
"An [unsafe attribute](attributes.md) is one that has extra safety conditions "
"that must be upheld when using the attribute. The compiler cannot check "
"whether these conditions have been upheld.  To assert that they have been, "
"these attributes must be wrapped in `unsafe(..)`, e.g. "
"`#[unsafe(no_mangle)]`."
msgstr ""
"[안전하지 않은 속성](attributes.md)은 속성을 사용할 때 준수해야 하는 추가 안전 조건이 "
"있는 속성입니다. 컴파일러는 이러한 조건이 준수되었는지 확인할 수 없습니다. "
"조건이 충족되었음을 단언하기 위해, 이러한 속성들은 `unsafe(..)`로 감싸야 합니다. "
"예를 들어, `#[unsafe(no_mangle)]`과 같습니다."

#: src/behavior-considered-undefined.md:7
msgid ""
"Rust code is incorrect if it exhibits any of the behaviors in the following "
"list. This includes code within `unsafe` blocks and `unsafe` functions. "
"`unsafe` only means that avoiding undefined behavior is on the programmer; "
"it does not change anything about the fact that Rust programs must never "
"cause undefined behavior."
msgstr ""
"러스트 코드가 다음 목록의 동작 중 어느 하나라도 보인다면 잘못된 것입니다. "
"이는 `unsafe` 블록과 `unsafe` 함수 내부의 코드를 포함합니다. `unsafe`는 "
"단지 정의되지 않은 동작을 피하는 책임이 프로그래머에게 있음을 의미할 뿐이며, "
"러스트 프로그램이 정의되지 않은 동작을 결코 일으켜서는 안 된다는 사실을 바꾸지는 않습니다."

#: src/behavior-considered-undefined.md:15
msgid ""
"It is the programmer's responsibility when writing `unsafe` code to ensure "
"that any safe code interacting with the `unsafe` code cannot trigger these "
"behaviors. `unsafe` code that satisfies this property for any safe client is "
"called _sound_; if `unsafe` code can be misused by safe code to exhibit "
"undefined behavior, it is _unsound_."
msgstr ""
"안전하지 않은 코드를 작성할 때, 그 코드와 상호 작용하는 모든 안전한 코드가 "
"이러한 동작들을 유발할 수 없도록 보장하는 것은 프로그래머의 책임입니다. "
"모든 안전한 클라이언트에 대해 이 속성을 만족하는 안전하지 않은 코드를 "
"_건전하다(sound)_고 하며, 안전한 코드에 의해 오용되어 정의되지 않은 동작을 "
"보일 수 있는 안전하지 않은 코드는 _불건전하다(unsound)_고 합니다."

#: src/behavior-considered-undefined.md:23
msgid ""
"_**Warning:**_ The following list is not exhaustive; it may grow or shrink. "
"There is no formal model of Rust's semantics for what is and is not allowed "
"in unsafe code, so there may be more behavior considered unsafe. We also "
"reserve the right to make some of the behavior in that list defined in the "
"future. In other words, this list does not say that anything will "
"_definitely_ always be undefined in all future Rust version (but we might "
"make such commitments for some list items in the future)."
msgstr ""
"_**경고:**_ 다음 목록은 포괄적이지 않으며, 늘어나거나 줄어들 수 있습니다. "
"안전하지 않은 코드에서 무엇이 허용되고 허용되지 않는지에 대한 러스트 세만틱의 "
"공식적인 모델은 아직 없으므로, 안전하지 않다고 간주되는 동작이 더 있을 수 있습니다. "
"또한 우리는 목록의 일부 동작을 미래에 정의된(defined) 동작으로 만들 권리를 가집니다. "
"즉, 이 목록은 어떤 것이 모든 미래 러스트 버전에서 _반드시_ 항상 정의되지 않은 "
"상태로 남을 것임을 말하는 것은 아닙니다(하지만 미래에 일부 항목에 대해 그러한 "
"약속을 할 수도 있습니다)."

#: src/behavior-considered-undefined.md:31
msgid ""
"Please read the [Rustonomicon](../nomicon/index.html) before writing unsafe "
"code."
msgstr ""
"안전하지 않은 코드를 작성하기 전에 [러스트노미콘(Rustonomicon)](../nomicon/index.html)을 "
"읽어보시기 바랍니다."

#: src/behavior-considered-undefined.md:37
msgid "Data races."
msgstr "데이터 경합 (Data races)."

#: src/behavior-considered-undefined.md:41
msgid ""
"Accessing (loading from or storing to) a place that is [dangling](#dangling-"
"pointers) or [based on a misaligned pointer](#places-based-on-misaligned-"
"pointers)."
msgstr ""
"[매달린 포인터(dangling pointer)](#dangling-pointers)이거나 "
"[정렬되지 않은 포인터에 기반한](#places-based-on-misaligned-pointers) 위치에 "
"접근(로드 또는 스토어)하는 것."

#: src/behavior-considered-undefined.md:46
msgid ""
"Performing a place projection that violates the requirements of [in-bounds "
"pointer arithmetic](../std/primitive.pointer.html#method.offset). A place "
"projection is a [field expression](expressions/field-expr.md), a [tuple "
"index expression](expressions/tuple-expr.md#tuple-indexing-expressions), or "
"an [array/slice index expression](expressions/array-expr.md#array-and-slice-"
"indexing-expressions)."
msgstr ""
"[범위 내 포인터 산술 연산(in-bounds pointer arithmetic)](../std/primitive.pointer.html#method.offset)의 "
"요구 사항을 위반하는 위치 투영(place projection)을 수행하는 것. 위치 투영이란 "
"[필드 표현식](expressions/field-expr.md), [튜플 인덱스 표현식](expressions/tuple-expr.md#tuple-indexing-expressions), "
"또는 [배열/슬라이스 인덱스 표현식](expressions/array-expr.md#array-and-slice-indexing-expressions)을 "
"의미합니다."

#: src/behavior-considered-undefined.md:53
msgid ""
"Breaking the [pointer aliasing rules](http://llvm.org/docs/"
"LangRef.html#pointer-aliasing-rules). `Box<T>`, `&mut T` and `&T` follow "
"LLVM’s scoped [noalias](http://llvm.org/docs/LangRef.html#noalias) model, "
"except if the `&T` contains an [`UnsafeCell<U>`](../core/cell/"
"struct.UnsafeCell.html). References and boxes must not be [dangling]"
"(#dangling-pointers) while they are live. The exact liveness duration is not "
"specified, but some bounds exist:"
msgstr ""
"[포인터 별칭 규칙(pointer aliasing rules)](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)을 "
"위반하는 것. `Box<T>`, `&mut T`, `&T`는 LLVM의 스코프 기반 "
"[noalias](http://llvm.org/docs/LangRef.html#noalias) 모델을 따릅니다. "
"단, `&T`가 [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)를 포함하는 경우는 예외입니다. "
"참조와 박스는 살아있는(live) 동안 [매달린 포인터](#dangling-pointers)가 되어서는 안 됩니다. "
"정확한 생존 기간은 명시되지 않았으나, 몇 가지 한계가 존재합니다:"

#: src/behavior-considered-undefined.md:57
msgid ""
"For references, the liveness duration is upper-bounded by the syntactic "
"lifetime assigned by the borrow checker; it cannot be live any _longer_ than "
"that lifetime."
msgstr ""
"참조의 경우, 생존 기간의 상한선은 대여 검사기(borrow checker)가 할당한 구문상 "
"라이프타임입니다. 즉, 그 라이프타임보다 _더 길게_ 살아있을 수 없습니다."

#: src/behavior-considered-undefined.md:60
msgid ""
"Each time a reference or box is passed to or returned from a function, it is "
"considered live."
msgstr ""
"참조나 박스가 함수로 전달되거나 함수에서 반환될 때마다, 그것은 살아있는 것으로 간주됩니다."

#: src/behavior-considered-undefined.md:62
msgid ""
"When a reference (but not a `Box`!) is passed to a function, it is live at "
"least as long as that function call, again except if the `&T` contains an "
"[`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)."
msgstr ""
"참조가(`Box`가 아닌!) 함수로 전달될 때, 그것은 최소한 해당 함수 호출 동안은 살아있습니다. "
"이 역시 `&T`가 [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)를 포함하는 경우는 예외입니다."

#: src/behavior-considered-undefined.md:66
msgid ""
"All this also applies when values of these types are passed in a (nested) "
"field of a compound type, but not behind pointer indirections."
msgstr ""
"이 모든 사항은 이러한 타입의 값들이 복합 타입의 (중첩된) 필드로 전달될 때도 적용되지만, "
"포인터 간접 참조(indirections) 뒤에 있는 경우는 제외됩니다."

#: src/behavior-considered-undefined.md:72
msgid ""
"Mutating immutable bytes. All bytes reachable through a [const-promoted]"
"(destructors.md#constant-promotion) expression are immutable, as well as "
"bytes reachable through borrows in `static` and `const` initializers that "
"have been [lifetime-extended](destructors.md#temporary-lifetime-extension) "
"to `'static`. The bytes owned by an immutable binding or immutable `static` "
"are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/"
"cell/struct.UnsafeCell.html)."
msgstr ""
"불변(immutable) 바이트를 수정하는 것. [상수 승격(const-promoted)](destructors.md#constant-promotion) "
"표현식을 통해 도달 가능한 모든 바이트는 불변이며, `'static`으로 "
"[수명 연장(lifetime-extended)](destructors.md#temporary-lifetime-extension)된 `static` 및 "
"`const` 초기화 식의 대여를 통해 도달 가능한 바이트들도 불변입니다. 불변 바인딩이나 "
"불변 `static`에 의해 소유된 바이트들은, 해당 바이트들이 [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)의 "
"일부가 아닌 한 불변입니다."

#: src/behavior-considered-undefined.md:76
msgid ""
"Moreover, the bytes [pointed to](#pointed-to-bytes) by a shared reference, "
"including transitively through other references (both shared and mutable) "
"and `Box`es, are immutable; transitivity includes those references stored in "
"fields of compound types."
msgstr ""
"게다가, 공유 참조가 [가리키는](#pointed-to-bytes) 바이트들은 다른 참조(공유 및 가변 모두)와 "
"`Box`를 통한 전이적 참조를 포함하여 모두 불변입니다. 전이성에는 복합 타입의 필드에 "
"저장된 참조들도 포함됩니다."

#: src/behavior-considered-undefined.md:78
msgid ""
"A mutation is any write of more than 0 bytes which overlaps with any of the "
"relevant bytes (even if that write does not change the memory contents)."
msgstr ""
"수정이란 관련 바이트 중 어느 하나라도 겹치는 0바이트 이상의 모든 쓰기 연산을 의미합니다"
"(해당 쓰기가 메모리 내용을 변경하지 않더라도 마찬가지입니다)."

#: src/behavior-considered-undefined.md:82
msgid "Invoking undefined behavior via compiler intrinsics."
msgstr "컴파일러 내장 함수(intrinsics)를 통해 정의되지 않은 동작을 유발하는 것."

#: src/behavior-considered-undefined.md:86
msgid ""
"Executing code compiled with platform features that the current platform "
"does not support (see [`target_feature`](attributes/codegen.md#the-"
"target_feature-attribute)), _except_ if the platform explicitly documents "
"this to be safe."
msgstr ""
"현재 플랫폼이 지원하지 않는 플랫폼 기능을 사용하여 컴파일된 코드를 실행하는 것"
"([`target_feature`](attributes/codegen.md#the-target_feature-attribute) 참조). "
"단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 제외합니다."

#: src/behavior-considered-undefined.md:91
msgid ""
"Calling a function with the wrong call ABI or unwinding from a function with "
"the wrong unwind ABI."
msgstr ""
"잘못된 호출 ABI로 함수를 호출하거나, 잘못된 언와인드(unwind) ABI를 가진 함수에서 "
"언와인딩을 수행하는 것."

#: src/behavior-considered-undefined.md:95
msgid ""
"Producing an [invalid value](#invalid-values). \"Producing\" a value happens "
"any time a value is assigned to or read from a place, passed to a function/"
"primitive operation or returned from a function/primitive operation."
msgstr ""
"[유효하지 않은 값](#invalid-values)을 생성하는 것. 값을 \"생성\"한다는 것은 "
"값이 장소(place)에 할당되거나 장소로부터 읽힐 때, 함수/기본 연산으로 전달되거나 "
"함수/기본 연산으로부터 반환될 때마다 발생합니다."

#: src/behavior-considered-undefined.md:102
msgid ""
"Incorrect use of inline assembly. For more details, refer to the [rules]"
"(inline-assembly.md#rules-for-inline-assembly) to follow when writing code "
"that uses inline assembly."
msgstr ""
"인라인 어셈블리의 잘못된 사용. 자세한 내용은 인라인 어셈블리를 사용하는 코드를 "
"작성할 때 따라야 할 [규칙](inline-assembly.md#rules-for-inline-assembly)을 참조하십시오."

#: src/behavior-considered-undefined.md:107
msgid ""
"**In [const context](const_eval.md#const-context)**: transmuting or "
"otherwise reinterpreting a pointer (reference, raw pointer, or function "
"pointer) into some allocated object as a non-pointer type (such as "
"integers). 'Reinterpreting' refers to loading the pointer value at integer "
"type without a cast, e.g. by doing raw pointer casts or using a union."
msgstr ""
"**[상수 컨텍스트(const context)](const_eval.md#const-context)에서**: 할당된 객체에 대한 포인터"
"(참조, 원시 포인터, 또는 함수 포인터)를 정수와 같은 비포인터 타입으로 변환(transmute)하거나 "
"재해석하는 것. '재해석'이란 캐스트 없이 포인터 값을 정수 타입으로 로드하는 것을 말하며, "
"예를 들어 원시 포인터 캐스트를 수행하거나 유니온을 사용하는 경우가 해당됩니다."

#: src/behavior-considered-undefined.md:113
msgid ""
"**Note**: Undefined behavior affects the entire program. For example, "
"calling a function in C that exhibits undefined behavior of C means your "
"entire program contains undefined behaviour that can also affect the Rust "
"code. And vice versa, undefined behavior in Rust can cause adverse affects "
"on code executed by any FFI calls to other languages."
msgstr ""
"**참고**: 정의되지 않은 동작은 프로그램 전체에 영향을 미칩니다. 예를 들어, C의 정의되지 않은 동작을 "
"보이는 C 함수를 호출하면 프로그램 전체에 정의되지 않은 동작이 포함되어 러스트 코드에도 "
"영향을 줄 수 있습니다. 반대의 경우도 마찬가지로, 러스트에서의 정의되지 않은 동작은 다른 언어로의 "
"모든 FFI 호출에 의해 실행되는 코드에 악영향을 줄 수 있습니다."

#: src/behavior-considered-undefined.md:121
msgid "Pointed-to bytes"
msgstr "가리키는 바이트 (Pointed-to bytes)"

#: src/behavior-considered-undefined.md:123
msgid ""
"The span of bytes a pointer or reference \"points to\" is determined by the "
"pointer value and the size of the pointee type (using `size_of_val`)."
msgstr ""
"포인터나 참조가 \"가리키는\" 바이트 범위는 포인터 값과 피지시체(pointee) 타입의 크기"
"(`size_of_val` 사용)에 의해 결정됩니다."

#: src/behavior-considered-undefined.md:125
msgid "Places based on misaligned pointers"
msgstr "잘못 정렬된 포인터에 기반한 장소 (Places based on misaligned pointers)"

#: src/behavior-considered-undefined.md:133
msgid ""
"A place is said to be \"based on a misaligned pointer\" if the last `*` "
"projection during place computation was performed on a pointer that was not "
"aligned for its type. (If there is no `*` projection in the place "
"expression, then this is accessing the field of a local or `static` and "
"rustc will guarantee proper alignment. If there are multiple `*` projection, "
"then each of them incurs a load of the pointer-to-be-dereferenced itself "
"from memory, and each of these loads is subject to the alignment constraint. "
"Note that some `*` projections can be omitted in surface Rust syntax due to "
"automatic dereferencing; we are considering the fully expanded place "
"expression here.)"
msgstr ""
"장소 계산 중 마지막 `*` 투영(projection)이 해당 타입에 맞게 정렬되지 않은 "
"포인터에 대해 수행된 경우, 해당 장소는 \"잘못 정렬된 포인터에 기반한다\"고 합니다. "
"(장소 표현식에 `*` 투영이 없다면 이는 지역 변수나 `static`의 필드에 접근하는 것이며, "
"rustc가 적절한 정렬을 보장합니다. `*` 투영이 여러 개인 경우, 각각의 투영은 메모리로부터 "
"역참조될 포인터 자체를 로드하며, 이러한 각 로드는 정렬 제약 조건을 따릅니다. "
"러스트의 겉보기 구문에서는 자동 역참조로 인해 일부 `*` 투영이 생략될 수 있음에 유의하십시오. "
"여기서는 완전히 확장된 장소 표현식을 고려합니다.)"

#: src/behavior-considered-undefined.md:143
msgid ""
"For instance, if `ptr` has type `*const S` where `S` has an alignment of 8, "
"then `ptr` must be 8-aligned or else `(*ptr).f` is \"based on an misaligned "
"pointer\". This is true even if the type of the field `f` is `u8` (i.e., a "
"type with alignment 1). In other words, the alignment requirement derives "
"from the type of the pointer that was dereferenced, _not_ the type of the "
"field that is being accessed."
msgstr ""
"예를 들어, `ptr`의 타입이 `*const S`이고 `S`의 정렬(alignment)이 8이라면, "
"`ptr`은 반드시 8로 정렬되어야 합니다. 그렇지 않으면 `(*ptr).f`는 \"잘못 정렬된 "
"포인터에 기반한\" 것이 됩니다. 이는 필드 `f`의 타입이 `u8`(즉, 정렬이 1인 타입)인 "
"경우에도 마찬가지입니다. 다시 말해, 정렬 요구 사항은 접근하려는 필드의 타입이 아니라 "
"역참조된 포인터의 타입에서 비롯됩니다."

#: src/behavior-considered-undefined.md:152
msgid ""
"Note that a place based on a misaligned pointer only leads to Undefined "
"Behavior when it is loaded from or stored to."
msgstr ""
"잘못 정렬된 포인터에 기반한 장소는 해당 장소로부터 로드하거나 해당 장소에 "
"스토어할 때만 정의되지 않은 동작을 유발함에 유의하십시오."

#: src/behavior-considered-undefined.md:157
msgid "`&raw const`/`&raw mut` on such a place is allowed."
msgstr "그러한 장소에 대한 `&raw const`/`&raw mut`는 허용됩니다."

#: src/behavior-considered-undefined.md:161
msgid ""
"`&`/`&mut` on a place requires the alignment of the field type (or else the "
"program would be \"producing an invalid value\"), which generally is a less "
"restrictive requirement than being based on an aligned pointer."
msgstr ""
"장소에 대한 `&`/`&mut`는 필드 타입의 정렬을 요구하며(그렇지 않으면 프로그램이 "
"\"유효하지 않은 값을 생성\"하게 됨), 이는 일반적으로 정렬된 포인터에 기반해야 한다는 "
"요구 사항보다 덜 제한적입니다."

#: src/behavior-considered-undefined.md:167
msgid ""
"Taking a reference will lead to a compiler error in cases where the field "
"type might be more aligned than the type that contains it, i.e., "
"`repr(packed)`. This means that being based on an aligned pointer is always "
"sufficient to ensure that the new reference is aligned, but it is not always "
"necessary."
msgstr ""
"필드 타입이 자신을 포함하는 타입보다 더 엄격하게 정렬되어 있을 수 있는 경우"
"(예: `repr(packed)`), 참조를 취하면 컴파일러 오류가 발생합니다. 이는 정렬된 "
"포인터에 기반하는 것이 새로운 참조가 정렬되도록 보장하는 데 항상 충분하지만, "
"항상 필수적인 것은 아님을 의미합니다."

#: src/behavior-considered-undefined.md:172
msgid "Dangling pointers"
msgstr "매달린 포인터 (Dangling pointers)"

#: src/behavior-considered-undefined.md:180
msgid ""
"A reference/pointer is \"dangling\" if not all of the bytes it [points to]"
"(#pointed-to-bytes) are part of the same live allocation (so in particular "
"they all have to be part of _some_ allocation)."
msgstr ""
"참조/포인터가 [가리키는](#pointed-to-bytes) 모든 바이트가 동일한 살아있는(live) 할당의 "
"일부가 아닌 경우(특히 모든 바이트는 _어떤_ 할당의 일부여야 함), 해당 참조/포인터는 "
"\"매달려(dangling)\" 있다고 합니다."

#: src/behavior-considered-undefined.md:186
msgid ""
"If the size is 0, then the pointer is trivially never \"dangling\" (even if "
"it is a null pointer)."
msgstr ""
"크기가 0인 경우, 포인터는 (비록 널 포인터일지라도) 결코 \"매달려\" 있지 않은 것으로 "
"간주됩니다."

#: src/behavior-considered-undefined.md:191
msgid ""
"Note that dynamically sized types (such as slices and strings) point to "
"their entire range, so it is important that the length metadata is never too "
"large."
msgstr ""
"동적 크기 타입(슬라이스 및 문자열 등)은 전체 범위를 가리키므로, 길이 메타데이터가 "
"결코 너무 크지 않도록 하는 것이 중요합니다."

#: src/behavior-considered-undefined.md:196
msgid ""
"In particular, the dynamic size of a Rust value (as determined by "
"`size_of_val`) must never exceed `isize::MAX`, since it is impossible for a "
"single allocation to be larger than `isize::MAX`."
msgstr ""
"특히, 러스트 값의 동적 크기(`size_of_val`에 의해 결정됨)는 결코 `isize::MAX`를 "
"초과해서는 안 됩니다. 단일 할당이 `isize::MAX`보다 큰 것은 불가능하기 때문입니다."

#: src/behavior-considered-undefined.md:200
msgid "Invalid values"
msgstr "유효하지 않은 값 (Invalid values)"

#: src/behavior-considered-undefined.md:208
msgid ""
"The Rust compiler assumes that all values produced during program execution "
"are \"valid\", and producing an invalid value is hence immediate UB."
msgstr ""
"러스트 컴파일러는 프로그램 실행 중에 생성된 모든 값이 \"유효하다\"고 가정합니다. "
"따라서 유효하지 않은 값을 생성하는 것은 즉시 정의되지 않은 동작(UB)으로 이어집니다."

#: src/behavior-considered-undefined.md:211
msgid "Whether a value is valid depends on the type:"
msgstr "값이 유효한지 여부는 타입에 따라 다릅니다:"

#: src/behavior-considered-undefined.md:215
msgid ""
"A [`bool`](types/boolean.md) value must be `false` (`0`) or `true` (`1`)."
msgstr "[`bool`](types/boolean.md) 값은 `false` (`0`) 또는 `true` (`1`)여야 합니다."

#: src/behavior-considered-undefined.md:219
msgid "A `fn` pointer value must be non-null."
msgstr "`fn` 포인터 값은 널(null)이 아니어야 합니다."

#: src/behavior-considered-undefined.md:223
msgid ""
"A `char` value must not be a surrogate (i.e., must not be in the range "
"`0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`."
msgstr ""
"`char` 값은 써로게이트(surrogate, 즉 `0xD800..=0xDFFF` 범위 내의 값)가 아니어야 하며, "
"`char::MAX`보다 작거나 같아야 합니다."

#: src/behavior-considered-undefined.md:227
msgid "A `!` value must never exist."
msgstr "`!` 값은 결코 존재해서는 안 됩니다."

#: src/behavior-considered-undefined.md:231
msgid ""
"An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be "
"initialized, i.e., must not be obtained from [uninitialized memory](http://"
"llvm.org/docs/LangRef.html#undefined-values)."
msgstr ""
"정수(`i*`/`u*`), 부동 소수점 값(`f*`), 또는 원시 포인터는 반드시 초기화되어야 합니다. "
"즉, [초기화되지 않은 메모리](http://llvm.org/docs/LangRef.html#undefined-values)로부터 "
"얻어서는 안 됩니다."

#: src/behavior-considered-undefined.md:236
msgid "A `str` value is treated like `[u8]`, i.e. it must be initialized."
msgstr "`str` 값은 `[u8]`과 같이 취급됩니다. 즉, 반드시 초기화되어야 합니다."

#: src/behavior-considered-undefined.md:240
msgid ""
"An `enum` must have a valid discriminant, and all fields of the variant "
"indicated by that discriminant must be valid at their respective type."
msgstr ""
"열거형(`enum`)은 유효한 판별자(discriminant)를 가져야 하며, 해당 판별자가 나타내는 "
"변형(variant)의 모든 필드는 각각의 타입에 대해 유효해야 합니다."

#: src/behavior-considered-undefined.md:244
msgid ""
"A `struct`, tuple, and array requires all fields/elements to be valid at "
"their respective type."
msgstr ""
"구조체(`struct`), 튜플, 배열은 모든 필드/요소가 각각의 타입에 대해 유효할 것을 요구합니다."

#: src/behavior-considered-undefined.md:248
msgid ""
"For a `union`, the exact validity requirements are not decided yet. "
"Obviously, all values that can be created entirely in safe code are valid. "
"If the union has a zero-sized field, then every possible value is valid. "
"Further details are [still being debated](https://github.com/rust-lang/"
"unsafe-code-guidelines/issues/438)."
msgstr ""
"유니온(`union`)의 경우, 정확한 유효성 요구 사항은 아직 결정되지 않았습니다. "
"분명히, 안전한 코드만으로 생성할 수 있는 모든 값은 유효합니다. 만약 유니온이 "
"크기가 0인 필드를 가지고 있다면, 가능한 모든 값이 유효합니다. 더 자세한 내용은 "
"[여전히 논의 중](https://github.com/rust-lang/unsafe-code-guidelines/issues/438)입니다."

#: src/behavior-considered-undefined.md:255
msgid ""
"A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned "
"and non-null, it cannot be [dangling](#dangling-pointers), and it must point "
"to a valid value (in case of dynamically sized types, using the actual "
"dynamic type of the pointee as determined by the metadata). Note that the "
"last point (about pointing to a valid value) remains a subject of some "
"debate."
msgstr ""
"참조 또는 [`Box<T>`](../alloc/boxed/struct.Box.html)는 정렬되어 있어야 하고 널이 아니어야 하며, "
"[매달려](#dangling-pointers) 있어서도 안 됩니다. 또한 유효한 값을 가리켜야 합니다"
"(동적 크기 타입의 경우, 메타데이터에 의해 결정된 피지시체의 실제 동적 타입을 사용). "
"마지막 지점(유효한 값을 가리켜야 한다는 것)은 여전히 논의의 여지가 있음에 유의하십시오."

#: src/behavior-considered-undefined.md:262
msgid ""
"The metadata of a wide reference, [`Box<T>`](../alloc/boxed/"
"struct.Box.html), or raw pointer must match the type of the unsized tail:"
msgstr ""
"와이드 참조(wide reference), [`Box<T>`](../alloc/boxed/struct.Box.html), 또는 "
"원시 포인터의 메타데이터는 크기가 정해지지 않은 꼬리(unsized tail)의 타입과 일치해야 합니다:"

#: src/behavior-considered-undefined.md:264
msgid ""
"`dyn Trait` metadata must be a pointer to a compiler-generated vtable for "
"`Trait`. (For raw pointers, this requirement remains a subject of some "
"debate.)"
msgstr ""
"`dyn Trait` 메타데이터는 컴파일러가 생성한 `Trait`용 vtable에 대한 포인터여야 합니다. "
"(원시 포인터의 경우, 이 요구 사항은 여전히 논의 중입니다.)"

#: src/behavior-considered-undefined.md:266
msgid ""
"Slice (`[T]`) metadata must be a valid `usize`. Furthermore, for wide "
"references and [`Box<T>`](../alloc/boxed/struct.Box.html), slice metadata is "
"invalid if it makes the total size of the pointed-to value bigger than "
"`isize::MAX`."
msgstr ""
"슬라이스(`[T]`) 메타데이터는 유효한 `usize`여야 합니다. 더 나아가, 와이드 참조 및 "
"[`Box<T>`](../alloc/boxed/struct.Box.html)의 경우, 슬라이스 메타데이터가 가리키는 값의 "
"전체 크기를 `isize::MAX`보다 크게 만든다면 유효하지 않습니다."

#: src/behavior-considered-undefined.md:272
msgid ""
"If a type has a custom range of a valid values, then a valid value must be "
"in that range. In the standard library, this affects [`NonNull<T>`](../core/"
"ptr/non_null/struct.NonNull.html) and [`NonZero<T>`](../core/num/nonzero/"
"struct.NonZero.html)."
msgstr ""
"만약 타입이 유효한 값의 커스텀 범위를 가지고 있다면, 유효한 값은 반드시 그 범위 내에 "
"있어야 합니다. 표준 라이브러리에서는 [`NonNull<T>`](../core/ptr/non_null/struct.NonNull.html)와 "
"[`NonZero<T>`](../core/num/nonzero/struct.NonZero.html)가 이에 해당합니다."

#: src/behavior-considered-undefined.md:275
msgid ""
"**Note**: `rustc` achieves this with the unstable "
"`rustc_layout_scalar_valid_range_*` attributes."
msgstr ""
"**참고**: `rustc`는 불안정한 `rustc_layout_scalar_valid_range_*` 속성들을 사용하여 "
"이를 수행합니다."

#: src/behavior-considered-undefined.md:280
msgid ""
"**Note:** Uninitialized memory is also implicitly invalid for any type that "
"has a restricted set of valid values. In other words, the only cases in "
"which reading uninitialized memory is permitted are inside `union`s and in "
"\"padding\" (the gaps between the fields of a type)."
msgstr ""
"**참고:** 초기화되지 않은 메모리는 제한된 유효 값 집합을 가진 모든 타입에 대해 "
"암시적으로 유효하지 않습니다. 다시 말해, 초기화되지 않은 메모리를 읽는 것이 허용되는 유일한 "
"경우는 `union` 내부와 \"패딩(padding)\"(타입의 필드 사이의 간격)뿐입니다."

#: src/behavior-not-considered-unsafe.md:1
msgid "Behavior not considered `unsafe`"
msgstr "`unsafe`로 간주되지 않는 동작"

#: src/behavior-not-considered-unsafe.md:3
msgid ""
"The Rust compiler does not consider the following behaviors _unsafe_, though "
"a programmer may (should) find them undesirable, unexpected, or erroneous."
msgstr ""
"러스트 컴파일러는 다음의 동작들을 _안전하지 않다(unsafe)_고 간주하지 않습니다. "
"비록 프로그래머가 이를 바람직하지 않거나, 예상치 못했거나, 잘못된 것으로 "
"생각할지라도 말입니다."

#: src/behavior-not-considered-unsafe.md:7
msgid "Deadlocks"
msgstr "데드락 (Deadlocks)"

#: src/behavior-not-considered-unsafe.md:8
msgid "Leaks of memory and other resources"
msgstr "메모리 및 기타 리소스 누수 (Leaks)"

#: src/behavior-not-considered-unsafe.md:9
msgid "Exiting without calling destructors"
msgstr "소멸자(destructor)를 호출하지 않고 종료하는 것"

#: src/behavior-not-considered-unsafe.md:10
msgid "Exposing randomized base addresses through pointer leaks"
msgstr "포인터 누수를 통해 무작위화된 베이스 주소를 노출하는 것"

#: src/behavior-not-considered-unsafe.md:11
msgid "Integer overflow"
msgstr "정수 오버플로 (Integer overflow)"

#: src/behavior-not-considered-unsafe.md:13
msgid ""
"If a program contains arithmetic overflow, the programmer has made an error. "
"In the following discussion, we maintain a distinction between arithmetic "
"overflow and wrapping arithmetic. The first is erroneous, while the second "
"is intentional."
msgstr ""
"프로그램에 산술 오버플로가 포함되어 있다면, 이는 프로그래머의 실수입니다. "
"이어지는 논의에서, 우리는 산술 오버플로와 래핑(wrapping) 산술 연산을 구분합니다. "
"전자는 잘못된 것이고, 후자는 의도된 것입니다."

#: src/behavior-not-considered-unsafe.md:18
msgid ""
"When the programmer has enabled `debug_assert!` assertions (for example, by "
"enabling a non-optimized build), implementations must insert dynamic checks "
"that `panic` on overflow. Other kinds of builds may result in `panics` or "
"silently wrapped values on overflow, at the implementation's discretion."
msgstr ""
"프로그래머가 `debug_assert!` 단언을 활성화한 경우(예: 최적화되지 않은 빌드), "
"구현체는 오버플로 시 `panic`을 일으키는 동적 검사를 삽입해야 합니다. "
"다른 종류의 빌드에서는 구현체의 재량에 따라 오버플로 시 `panic`이 발생하거나 "
"조용히 값이 래핑될 수 있습니다."

#: src/behavior-not-considered-unsafe.md:24
msgid ""
"In the case of implicitly-wrapped overflow, implementations must provide "
"well-defined (even if still considered erroneous) results by using two's "
"complement overflow conventions."
msgstr ""
"암시적으로 래핑되는 오버플로의 경우, 구현체는 2의 보수 오버플로 관례를 사용하여 "
"잘 정의된(여전히 오류로 간주될지라도) 결과를 제공해야 합니다."

#: src/behavior-not-considered-unsafe.md:28
msgid ""
"The integral types provide inherent methods to allow programmers explicitly "
"to perform wrapping arithmetic. For example, `i32::wrapping_add` provides "
"two's complement, wrapping addition."
msgstr ""
"정수 타입들은 프로그래머가 명시적으로 래핑 산술 연산을 수행할 수 있도록 "
"내재적 메서드들을 제공합니다. 예를 들어, `i32::wrapping_add`는 2의 보수 "
"래핑 덧셈을 제공합니다."

#: src/behavior-not-considered-unsafe.md:32
msgid ""
"The standard library also provides a `Wrapping<T>` newtype which ensures all "
"standard arithmetic operations for `T` have wrapping semantics."
msgstr ""
"표준 라이브러리는 또한 `T`에 대한 모든 표준 산술 연산이 래핑 세만틱을 갖도록 보장하는 "
"`Wrapping<T>` 뉴타입(newtype)을 제공합니다."

#: src/behavior-not-considered-unsafe.md:36
msgid ""
"See [RFC 560](https://github.com/rust-lang/rfcs/blob/master/text/0560-"
"integer-overflow.md) for error conditions, rationale, and more details about "
"integer overflow."
msgstr ""
"오류 조건, 근거, 그리고 정수 오버플로에 대한 더 자세한 내용은 [RFC 560](https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md)을 "
"참조하십시오."

#: src/behavior-not-considered-unsafe.md:39
msgid "Logic errors"
msgstr "논리 오류 (Logic errors)"

#: src/behavior-not-considered-unsafe.md:41
msgid ""
"Safe code may impose extra logical constraints that can be checked at "
"neither compile-time nor runtime. If a program breaks such a constraint, the "
"behavior may be unspecified but will not result in undefined behavior. This "
"could include panics, incorrect results, aborts, and non-termination. The "
"behavior may also differ between runs, builds, or kinds of build."
msgstr ""
"안전한 코드는 컴파일 타임이나 런타임에 확인할 수 없는 추가적인 논리적 제약을 "
"부과할 수 있습니다. 프로그램이 이러한 제약을 위반할 경우, 동작은 명시되지 "
"않을 수 있으나 정의되지 않은 동작으로 이어지지는 않습니다. 여기에는 패닉, "
"잘못된 결과, 중단(abort), 그리고 종료되지 않음(non-termination) 등이 포함될 수 있습니다. "
"동작은 실행, 빌드, 또는 빌드 종류에 따라 달라질 수도 있습니다."

#: src/behavior-not-considered-unsafe.md:48
msgid ""
"For example, implementing both `Hash` and `Eq` requires that values "
"considered equal have equal hashes. Another example are data structures like "
"`BinaryHeap`, `BTreeMap`, `BTreeSet`, `HashMap` and `HashSet` which describe "
"constraints on the modification of their keys while they are in the data "
"structure. Violating such constraints is not considered unsafe, yet the "
"program is considered erroneous and its behavior unpredictable."
msgstr ""
"예를 들어, `Hash`와 `Eq`를 모두 구현할 때는 동일하다고 간주되는 값들이 동일한 "
"해시 값을 가져야 한다는 요구 사항이 있습니다. 또 다른 예로 `BinaryHeap`, `BTreeMap`, "
"`BTreeSet`, `HashMap`, `HashSet`과 같은 데이터 구조들은 데이터 구조에 포함된 "
"동안 키(key)의 수정에 대한 제약 조건을 기술합니다. 이러한 제약 조건을 위반하는 것은 "
"안전하지 않은(unsafe) 것으로 간주되지는 않지만, 프로그램은 오류가 있는 것으로 간주되며 "
"그 동작은 예측할 수 없게 됩니다."

#: src/const_eval.md:3
msgid "Constant evaluation"
msgstr "상수 평가 (Constant evaluation)"

#: src/const_eval.md:7
msgid ""
"Constant evaluation is the process of computing the result of [expressions]"
"(expressions.md) during compilation. Only a subset of all expressions can be "
"evaluated at compile-time."
msgstr ""
"상수 평가는 컴파일 중에 [표현식](expressions.md)의 결과를 계산하는 과정입니다. "
"모든 표현식 중 일부 하위 집합만이 컴파일 타임에 평가될 수 있습니다."

#: src/const_eval.md:13
msgid "Constant expressions"
msgstr "상수 표현식"

#: src/const_eval.md:17
msgid ""
"Certain forms of expressions, called constant expressions, can be evaluated "
"at compile time."
msgstr "상수 표현식이라고 불리는 특정 형태의 표현식들은 컴파일 타임에 평가될 수 있습니다."

#: src/const_eval.md:22
msgid ""
"In [const contexts](#const-context), these are the only allowed expressions, "
"and are always evaluated at compile time."
msgstr ""
"[상수 컨텍스트(const context)](#const-context)에서는 이러한 표현식들만이 허용되며, "
"항상 컴파일 타임에 평가됩니다."

#: src/const_eval.md:27
msgid ""
"In other places, such as [let statements](statements.md#let-statements), "
"constant expressions _may_ be, but are not guaranteed to be, evaluated at "
"compile time."
msgstr ""
"[let 문](statements.md#let-statements)과 같은 다른 곳에서는, 상수 표현식이 컴파일 타임에 "
"평가될 _수도_ 있지만, 그것이 보장되지는 않습니다."

#: src/const_eval.md:31
msgid ""
"Behaviors such as out of bounds [array indexing](expressions/array-"
"expr.md#array-and-slice-indexing-expressions) or [overflow](expressions/"
"operator-expr.md#overflow) are compiler errors if the value must be "
"evaluated at compile time (i.e. in const contexts). Otherwise, these "
"behaviors are warnings, but will likely panic at run-time."
msgstr ""
"범위를 벗어난 [배열 인덱싱](expressions/array-expr.md#array-and-slice-indexing-expressions)이나 "
"[오버플로](expressions/operator-expr.md#overflow)와 같은 동작들은, 값이 컴파일 타임에 "
"평가되어야 하는 경우(즉, 상수 컨텍스트인 경우) 컴파일러 오류가 됩니다. "
"그렇지 않으면 이러한 동작들은 경고로 처리되지만, 런타임에 패닉이 발생할 가능성이 높습니다."

#: src/const_eval.md:37
msgid ""
"The following expressions are constant expressions, so long as any operands "
"are also constant expressions and do not cause any [`Drop::drop`]"
"(destructors.md) calls to be run."
msgstr ""
"다음 표현식들은 피연산자 또한 상수 표현식이고 어떠한 [`Drop::drop`](destructors.md) "
"호출도 일으키지 않는 한 상수 표현식입니다."

#: src/const_eval.md:43
msgid "[Literals](expressions/literal-expr.md)."
msgstr "[리터럴](expressions/literal-expr.md)."

#: src/const_eval.md:47
msgid "[Const parameters](items/generics.md)."
msgstr "[상수 파라미터](items/generics.md)."

#: src/const_eval.md:51
msgid ""
"[Paths](expressions/path-expr.md) to [functions](items/functions.md) and "
"[constants](items/constant-items.md). Recursively defining constants is not "
"allowed."
msgstr ""
"[함수](items/functions.md) 및 [상수](items/constant-items.md)에 대한 [경로](expressions/path-expr.md). "
"상수를 재귀적으로 정의하는 것은 허용되지 않습니다."

#: src/const_eval.md:56
msgid "Paths to [statics](items/static-items.md) with these restrictions:"
msgstr "다음 제약 사항이 있는 [정적 변수(statics)](items/static-items.md)에 대한 경로:"

#: src/const_eval.md:57
msgid ""
"Writes to `static` items are not allowed in any constant evaluation context."
msgstr "`static` 아이템에 쓰는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다."

#: src/const_eval.md:58
msgid ""
"Reads from `extern` statics are not allowed in any constant evaluation "
"context."
msgstr "`extern` 정적 변수로부터 읽는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다."

#: src/const_eval.md:59
msgid ""
"If the evaluation is _not_ carried out in an initializer of a `static` item, "
"then reads from any mutable `static` are not allowed. A mutable `static` is "
"a `static mut` item, or a `static` item with an interior-mutable type."
msgstr ""
"평가가 `static` 아이템의 초기화 식 내에서 수행되는 것이 _아니라면_, 가변 `static`으로부터 "
"읽는 것은 허용되지 않습니다. 가변 `static`은 `static mut` 아이템이거나, "
"내부 가변성(interior-mutable) 타입을 가진 `static` 아이템을 의미합니다."

#: src/const_eval.md:61
msgid ""
"These requirements are checked only when the constant is evaluated. In other "
"words, having such accesses syntactically occur in const contexts is allowed "
"as long as they never get executed."
msgstr ""
"이러한 요구 사항들은 상수가 평가될 때만 확인됩니다. 다시 말해, 이러한 접근이 "
"상수 컨텍스트에서 구문상으로 나타나는 것은 실제로 실행되지 않는 한 허용됩니다."

#: src/const_eval.md:65
msgid "[Tuple expressions](expressions/tuple-expr.md)."
msgstr "[튜플 표현식](expressions/tuple-expr.md)."

#: src/const_eval.md:69
msgid "[Array expressions](expressions/array-expr.md)."
msgstr "[배열 표현식](expressions/array-expr.md)."

#: src/const_eval.md:73
msgid "[Struct](expressions/struct-expr.md) expressions."
msgstr "[구조체](expressions/struct-expr.md) 표현식."

#: src/const_eval.md:77
msgid ""
"[Block expressions](expressions/block-expr.md), including `unsafe` and "
"`const` blocks."
msgstr "`unsafe` 및 `const` 블록을 포함한 [블록 표현식](expressions/block-expr.md)."

#: src/const_eval.md:78
msgid ""
"[let statements](statements.md#let-statements) and thus irrefutable "
"[patterns](patterns.md), including mutable bindings"
msgstr ""
"[let 문](statements.md#let-statements) 및 그에 따른 가변 바인딩을 포함한 "
"반박 불가능한(irrefutable) [패턴](patterns.md)"

#: src/const_eval.md:79
msgid ""
"[assignment expressions](expressions/operator-expr.md#assignment-expressions)"
msgstr "[대입 표현식](expressions/operator-expr.md#assignment-expressions)"

#: src/const_eval.md:80
msgid ""
"[compound assignment expressions](expressions/operator-expr.md#compound-"
"assignment-expressions)"
msgstr "[복합 대입 표현식](expressions/operator-expr.md#compound-assignment-expressions)"

#: src/const_eval.md:81
msgid "[expression statements](statements.md#expression-statements)"
msgstr "[표현식 구문](statements.md#expression-statements)"

#: src/const_eval.md:85
msgid "[Field](expressions/field-expr.md) expressions."
msgstr "[필드](expressions/field-expr.md) 표현식."

#: src/const_eval.md:89
msgid ""
"Index expressions, [array indexing](expressions/array-expr.md#array-and-"
"slice-indexing-expressions) or [slice](types/slice.md) with a `usize`."
msgstr ""
"인덱스 표현식, `usize`를 사용한 [배열 인덱싱](expressions/array-expr.md#array-and-slice-indexing-expressions) "
"또는 [슬라이스](types/slice.md)."

#: src/const_eval.md:93
msgid "[Range expressions](expressions/range-expr.md)."
msgstr "[범위 표현식](expressions/range-expr.md)."

#: src/const_eval.md:97
msgid ""
"[Closure expressions](expressions/closure-expr.md) which don't capture "
"variables from the environment."
msgstr "환경으로부터 변수를 캡처하지 않는 [클로저 표현식](expressions/closure-expr.md)."

#: src/const_eval.md:101
msgid ""
"Built-in [negation](expressions/operator-expr.md#negation-operators), "
"[arithmetic](expressions/operator-expr.md#arithmetic-and-logical-binary-"
"operators), [logical](expressions/operator-expr.md#arithmetic-and-logical-"
"binary-operators), [comparison](expressions/operator-expr.md#comparison-"
"operators) or [lazy boolean](expressions/operator-expr.md#lazy-boolean-"
"operators) operators used on integer and floating point types, `bool`, and "
"`char`."
msgstr ""
"정수 및 부동 소수점 타입, `bool`, `char`에 사용되는 내장 [부정](expressions/operator-expr.md#negation-operators), "
"[산술](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), "
"[논리](expressions/operator-expr.md#arithmetic-and-logical-binary-operators), "
"[비교](expressions/operator-expr.md#comparison-operators) 또는 "
"[지연 평가 불리언(lazy boolean)](expressions/operator-expr.md#lazy-boolean-operators) 연산자."

#: src/const_eval.md:106
msgid ""
"All forms of [borrow](expressions/operator-expr.md#borrow-operators)s, "
"including raw borrows, with one limitation: mutable borrows and shared "
"borrows to values with interior mutability are only allowed to refer to "
"_transient_ places. A place is _transient_ if its lifetime is strictly "
"contained inside the current [const context](#const-context)."
msgstr ""
"원시 대여를 포함한 모든 형태의 [대여(borrow)](expressions/operator-expr.md#borrow-operators). "
"단, 한 가지 제한 사항이 있습니다: 가변 대여 및 내부 가변성을 가진 값에 대한 "
"공유 대여는 오직 _일시적인(transient)_ 장소만을 참조할 수 있습니다. 장소의 수명이 "
"현재의 [상수 컨텍스트](#const-context) 내부에 엄격하게 포함되는 경우, 그 장소를 "
"_일시적_이라고 합니다."

#: src/const_eval.md:113
msgid ""
"The [dereference operator](expressions/operator-expr.md#the-dereference-"
"operator) except for raw pointers."
msgstr "원시 포인터를 제외한 [역참조 연산자](expressions/operator-expr.md#the-dereference-operator)."

#: src/const_eval.md:118
msgid "[Grouped](expressions/grouped-expr.md) expressions."
msgstr "[그룹화된(Grouped)](expressions/grouped-expr.md) 표현식."

#: src/const_eval.md:122
msgid ""
"[Cast](expressions/operator-expr.md#type-cast-expressions) expressions, "
"except"
msgstr "다음 경우를 제외한 [캐스트](expressions/operator-expr.md#type-cast-expressions) 표현식:"

#: src/const_eval.md:123
msgid "pointer to address casts and"
msgstr "포인터를 주소로 변환하는 캐스트 및"

#: src/const_eval.md:124
msgid "function pointer to address casts."
msgstr "함수 포인터를 주소로 변환하는 캐스트."

#: src/const_eval.md:128
msgid ""
"Calls of [const functions](items/functions.md#const-functions) and const "
"methods."
msgstr "[상수 함수(const functions)](items/functions.md#const-functions) 및 상수 메서드 호출."

#: src/const_eval.md:132
msgid ""
"[loop](expressions/loop-expr.md#infinite-loops), [while](expressions/loop-"
"expr.md#predicate-loops) and [`while let`](expressions/loop-"
"expr.md#predicate-pattern-loops) expressions."
msgstr ""
"[loop](expressions/loop-expr.md#infinite-loops), [while](expressions/loop-expr.md#predicate-loops) "
"및 [`while let`](expressions/loop-expr.md#predicate-pattern-loops) 표현식."

#: src/const_eval.md:136
msgid ""
"[if](expressions/if-expr.md#if-expressions), [`if let`](expressions/if-"
"expr.md#if-let-expressions) and [match](expressions/match-expr.md) "
"expressions."
msgstr ""
"[if](expressions/if-expr.md#if-expressions), [`if let`](expressions/if-expr.md#if-let-expressions) "
"및 [match](expressions/match-expr.md) 표현식."

#: src/const_eval.md:138
msgid "Const context"
msgstr "상수 컨텍스트 (Const context)"

#: src/const_eval.md:146
msgid "A _const context_ is one of the following:"
msgstr "_상수 컨텍스트_는 다음 중 하나를 의미합니다:"

#: src/const_eval.md:150
msgid "[Array type length expressions](types/array.md)"
msgstr "[배열 타입 길이 표현식](types/array.md)"

#: src/const_eval.md:154
msgid "[Array repeat length expressions](expressions/array-expr.md)"
msgstr "[배열 반복 길이 표현식](expressions/array-expr.md)"

#: src/const_eval.md:158
msgid "The initializer of"
msgstr "다음의 초기화 식:"

#: src/const_eval.md:159
msgid "[constants](items/constant-items.md)"
msgstr "[상수(constants)](items/constant-items.md)"

#: src/const_eval.md:160
msgid "[statics](items/static-items.md)"
msgstr "[정적 변수(statics)](items/static-items.md)"

#: src/const_eval.md:161
msgid "[enum discriminants](items/enumerations.md#discriminants)"
msgstr "[열거형 판별자(enum discriminants)](items/enumerations.md#discriminants)"

#: src/const_eval.md:165
msgid "A [const generic argument](items/generics.md#const-generics)"
msgstr "[상수 제네릭 인자(const generic argument)](items/generics.md#const-generics)"

#: src/const_eval.md:169
msgid "A [const block](expressions/block-expr.md#const-blocks)"
msgstr "[상수 블록(const block)](expressions/block-expr.md#const-blocks)"

#: src/const_eval.md:171
msgid ""
"Const contexts that are used as parts of types (array type and repeat length "
"expressions as well as const generic arguments) can only make restricted use "
"of surrounding generic parameters: such an expression must either be a "
"single bare const generic parameter, or an arbitrary expression not making "
"use of any generics."
msgstr ""
"타입의 일부로 사용되는 상수 컨텍스트(배열 타입 및 반복 길이 표현식, 그리고 상수 제네릭 인자)는 "
"주변의 제네릭 파라미터를 제한적으로만 사용할 수 있습니다. 그러한 표현식은 "
"단일의 순수한 상수 제네릭 파라미터이거나, 어떠한 제네릭도 사용하지 않는 임의의 표현식이어야 합니다."

#: src/const_eval.md:179
msgid "Const Functions"
msgstr "상수 함수 (Const Functions)"

#: src/const_eval.md:183
msgid ""
"A _const fn_ is a function that one is permitted to call from a const "
"context."
msgstr "_상수 함수(const fn)_는 상수 컨텍스트에서 호출이 허용되는 함수입니다."

#: src/const_eval.md:187
msgid ""
"Declaring a function `const` has no effect on any existing uses, it only "
"restricts the types that arguments and the return type may use, and "
"restricts the function body to constant expressions."
msgstr ""
"함수를 `const`로 선언하는 것은 기존의 사용처에는 아무런 영향을 주지 않으며, "
"단지 인자와 반환 타입이 사용할 수 있는 타입을 제한하고, 함수의 본문을 "
"상수 표현식으로 제한할 뿐입니다."

#: src/const_eval.md:193
msgid ""
"When called from a const context, the function is interpreted by the "
"compiler at compile time. The interpretation happens in the environment of "
"the compilation target and not the host. So `usize` is `32` bits if you are "
"compiling against a `32` bit system, irrelevant of whether you are building "
"on a `64` bit or a `32` bit system."
msgstr ""
"상수 컨텍스트에서 호출될 때, 함수는 컴파일 타임에 컴파일러에 의해 해석됩니다. "
"이 해석은 호스트가 아닌 컴파일 타겟의 환경에서 이루어집니다. 따라서 만약 "
"32비트 시스템을 대상으로 컴파일하고 있다면, 빌드하는 시스템이 64비트인지 "
"32비트인지와 관계없이 `usize`는 32비트가 됩니다."

#: src/abi.md:1
msgid "Application Binary Interface (ABI)"
msgstr "애플리케이션 바이너리 인터페이스 (ABI)"

#: src/abi.md:3
msgid ""
"This section documents features that affect the ABI of the compiled output "
"of a crate."
msgstr "이 섹션은 크레이트의 컴파일된 출력물의 ABI에 영향을 주는 기능들을 설명합니다."

#: src/abi.md:6
msgid ""
"See _[extern functions](items/functions.md#extern-function-qualifier)_ for "
"information on specifying the ABI for exporting functions. See _[external "
"blocks](items/external-blocks.md)_ for information on specifying the ABI for "
"linking external libraries."
msgstr ""
"함수를 내보내기 위해 ABI를 지정하는 방법에 대한 정보는 _[외부 함수(extern functions)]"
"(items/functions.md#extern-function-qualifier)_를 참조하십시오. 외부 라이브러리를 "
"링크하기 위해 ABI를 지정하는 방법에 대한 정보는 _[외부 블록(external blocks)]"
"(items/external-blocks.md)_을 참조하십시오."

#: src/abi.md:10
msgid "The `used` attribute"
msgstr "`used` 속성"

#: src/abi.md:12
msgid ""
"The _`used` attribute_ can only be applied to [`static` items](items/static-"
"items.md). This [attribute](attributes.md) forces the compiler to keep the "
"variable in the output object file (.o, .rlib, etc. excluding final "
"binaries) even if the variable is not used, or referenced, by any other item "
"in the crate. However, the linker is still free to remove such an item."
msgstr ""
"_`used` 속성_은 오직 [`static` 아이템](items/static-items.md)에만 적용될 수 있습니다. "
"이 [속성](attributes.md)은 해당 변수가 크레이트의 다른 아이템에 의해 사용되거나 "
"참조되지 않더라도, 출력 목적 파일(.o, .rlib 등, 최종 바이너리 제외)에 변수를 "
"강제로 유지하도록 컴파일러에 명령합니다. 하지만 링커는 여전히 이러한 아이템을 "
"제거할 수 있습니다."

#: src/abi.md:17
msgid ""
"Below is an example that shows under what conditions the compiler keeps a "
"`static` item in the output object file."
msgstr ""
"아래는 컴파일러가 어떤 조건 하에서 `static` 아이템을 출력 목적 파일에 유지하는지 "
"보여주는 예제입니다."

#: src/abi.md:21
msgid "// foo.rs\n"
msgstr "// foo.rs\n"

#: src/abi.md:22
msgid "// This is kept because of `#[used]`:\n"
msgstr "// 이는 `#[used]` 때문에 유지됩니다:\n"

#: src/abi.md:26
msgid "// This is removable because it is unused:\n"
msgstr "// 이는 사용되지 않으므로 제거 가능합니다:\n"

#: src/abi.md:30
msgid "// This is kept because it is publicly reachable:\n"
msgstr "// 이는 공개적으로 도달 가능하므로 유지됩니다:\n"

#: src/abi.md:33
msgid ""
"// This is kept because it is referenced by a public, reachable function:\n"
msgstr "// 이는 공개적으로 도달 가능한 함수에 의해 참조되므로 유지됩니다:\n"

#: src/abi.md:40
msgid ""
"// This is removable because it is referenced by a private, unused (dead) "
"function:\n"
msgstr "// 이는 비공개이며 사용되지 않는(dead) 함수에 의해 참조되므로 제거 가능합니다:\n"

#: src/abi.md:60
msgid "The `no_mangle` attribute"
msgstr "`no_mangle` 속성"

#: src/abi.md:62
msgid ""
"The _`no_mangle` attribute_ may be used on any [item](items.md) to disable "
"standard symbol name mangling. The symbol for the item will be the "
"identifier of the item's name."
msgstr ""
"_`no_mangle` 속성_은 표준 심볼 이름 맹글링(mangling)을 비활성화하기 위해 모든 "
"[아이템](items.md)에 사용될 수 있습니다. 해당 아이템의 심볼은 아이템의 이름과 "
"동일한 식별자가 됩니다."

#: src/abi.md:66
msgid ""
"Additionally, the item will be publicly exported from the produced library "
"or object file, similar to the [`used` attribute](#the-used-attribute)."
msgstr ""
"또한, [`used` 속성](#the-used-attribute)과 유사하게, 해당 아이템은 생성된 라이브러리나 "
"목적 파일로부터 공개적으로 내보내집니다."

#: src/abi.md:69
msgid ""
"This attribute is unsafe as an unmangled symbol may collide with another "
"symbol with the same name (or with a well-known symbol), leading to "
"undefined behavior."
msgstr ""
"맹글링되지 않은 심볼은 동일한 이름을 가진 다른 심볼(또는 잘 알려진 심볼)과 "
"충돌하여 정의되지 않은 동작을 초래할 수 있으므로, 이 속성은 안전하지 않습니다(unsafe)."

#: src/abi.md:77
msgid ""
"**Edition differences**: Before the 2024 edition it is allowed to use the "
"`no_mangle` attribute without the `unsafe` qualification."
msgstr "**에디션 차이**: 2024 에디션 이전에는 `unsafe` 수식 없이 `no_mangle` 속성을 사용할 수 있었습니다."

#: src/abi.md:79
msgid "The `link_section` attribute"
msgstr "`link_section` 속성"

#: src/abi.md:81
msgid ""
"The _`link_section` attribute_ specifies the section of the object file that "
"a [function](items/functions.md) or [static](items/static-items.md)'s "
"content will be placed into. It uses the [_MetaNameValueStr_]"
"(attributes.md#meta-item-attribute-syntax) syntax to specify the section "
"name."
msgstr ""
"_`link_section` 속성_은 [함수](items/functions.md) 또는 [정적 변수](items/static-items.md)의 "
"내용이 배치될 목적 파일의 섹션을 지정합니다. 섹션 이름을 지정하기 위해 "
"[_MetaNameValueStr_](attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/abi.md:85
msgid ""
"This attribute is unsafe as it allows users to place data and code into "
"sections of memory not expecting them, such as mutable data into read-only "
"areas."
msgstr ""
"이 속성은 가변 데이터를 읽기 전용 영역에 배치하는 것과 같이, 데이터와 코드를 "
"의도하지 않은 메모리 섹션에 배치할 수 있게 하므로 안전하지 않습니다(unsafe)."

#: src/abi.md:91
msgid "\".example_section\""
msgstr "\".example_section\""

#: src/abi.md:95
msgid ""
"**Edition differences**: Before the 2024 edition it is allowed to use the "
"`link_section` attribute without the `unsafe` qualification."
msgstr "**에디션 차이**: 2024 에디션 이전에는 `unsafe` 수식 없이 `link_section` 속성을 사용할 수 있었습니다."

#: src/abi.md:97
msgid "The `export_name` attribute"
msgstr "`export_name` 속성"

#: src/abi.md:99
msgid ""
"The _`export_name` attribute_ specifies the name of the symbol that will be "
"exported on a [function](items/functions.md) or [static](items/static-"
"items.md). It uses the [_MetaNameValueStr_](attributes.md#meta-item-"
"attribute-syntax) syntax to specify the symbol name."
msgstr ""
"_`export_name` 속성_은 [함수](items/functions.md) 또는 [정적 변수](items/static-items.md)에서 "
"내보내질 심볼의 이름을 지정합니다. 심볼 이름을 지정하기 위해 "
"[_MetaNameValueStr_](attributes.md#meta-item-attribute-syntax) 구문을 사용합니다."

#: src/abi.md:103
msgid ""
"This attribute is unsafe as a symbol with a custom name may collide with "
"another symbol with the same name (or with a well-known symbol), leading to "
"undefined behavior."
msgstr ""
"커스텀 이름을 가진 심볼은 동일한 이름을 가진 다른 심볼(또는 잘 알려진 심볼)과 "
"충돌하여 정의되지 않은 동작을 초래할 수 있으므로, 이 속성은 안전하지 않습니다(unsafe)."

#: src/abi.md:108
msgid "\"exported_symbol_name\""
msgstr "\"exported_symbol_name\""

#: src/abi.md:112
msgid ""
"**Edition differences**: Before the 2024 edition it is allowed to use the "
"`export_name` attribute without the `unsafe` qualification."
msgstr "**에디션 차이**: 2024 에디션 이전에는 `unsafe` 수식 없이 `export_name` 속성을 사용할 수 있었습니다."

#: src/runtime.md:5
msgid ""
"This section documents features that define some aspects of the Rust runtime."
msgstr "이 섹션은 러스트 런타임의 일부 측면을 정의하는 기능들을 설명합니다."

#: src/runtime.md:9
msgid "The `panic_handler` attribute"
msgstr "`panic_handler` 속성"

#: src/runtime.md:13
msgid ""
"The _`panic_handler` attribute_ can only be applied to a function with "
"signature `fn(&PanicInfo) -> !`."
msgstr ""
"_`panic_handler` 속성_은 오직 시그니처가 `fn(&PanicInfo) -> !`인 함수에만 "
"적용될 수 있습니다."

#: src/runtime.md:18
msgid ""
"The function marked with this [attribute](attributes.md) defines the "
"behavior of panics."
msgstr "이 [속성](attributes.md)이 표시된 함수는 패닉(panic) 시의 동작을 정의합니다."

#: src/runtime.md:22
msgid ""
"The [`PanicInfo`](../core/panic/panic_info/struct.PanicInfo.html) struct "
"contains information about the location of the panic."
msgstr ""
"[`PanicInfo`](../core/panic/panic_info/struct.PanicInfo.html) 구조체는 패닉이 발생한 "
"위치에 대한 정보를 포함합니다."

#: src/runtime.md:26
msgid ""
"There must be a single `panic_handler` function in the dependency graph of a "
"binary, dylib or cdylib crate."
msgstr ""
"binary, dylib, 또는 cdylib 크레이트의 의존성 그래프에는 단 하나의 `panic_handler` "
"함수가 존재해야 합니다."

#: src/runtime.md:28
msgid ""
"Below is shown a `panic_handler` function that logs the panic message and "
"then halts the thread."
msgstr ""
"아래는 패닉 메시지를 기록한 다음 스레드를 중단시키는 `panic_handler` 함수의 "
"예시입니다."

#: src/runtime.md:39
msgid "// ..\n"
msgstr "// ..\n"

#: src/runtime.md:55
msgid "// logs \"panicked at '$reason', src/main.rs:27:4\" to some `sink`\n"
msgstr "// \"panicked at '$reason', src/main.rs:27:4\"를 어떤 `sink`에 기록함\n"

#: src/runtime.md:64
msgid "Standard behavior"
msgstr "표준 동작"

#: src/runtime.md:66
msgid ""
"The standard library provides an implementation of `panic_handler` that "
"defaults to unwinding the stack but that can be [changed to abort the "
"process](../book/ch09-01-unrecoverable-errors-with-panic.html). The standard "
"library's panic behavior can be modified at runtime with the [set_hook](../"
"std/panicking/fn.set_hook.html) function."
msgstr ""
"표준 라이브러리는 기본적으로 스택을 언와인딩(unwinding)하는 `panic_handler` 구현을 "
"제공하지만, 이를 [프로세스를 중단(abort)하도록 변경](../book/ch09-01-unrecoverable-errors-with-panic.html)할 수 있습니다. "
"표준 라이브러리의 패닉 동작은 런타임에 [set_hook](../std/panicking/fn.set_hook.html) "
"함수를 사용하여 수정될 수 있습니다."

#: src/runtime.md:73
msgid "The `global_allocator` attribute"
msgstr "`global_allocator` 속성"

#: src/runtime.md:75
msgid ""
"The _`global_allocator` attribute_ is used on a [static item](items/static-"
"items.md) implementing the [`GlobalAlloc`](../core/alloc/global/"
"trait.GlobalAlloc.html) trait to set the global allocator."
msgstr ""
"_`global_allocator` 속성_은 [`GlobalAlloc`](../core/alloc/global/trait.GlobalAlloc.html) 트레잇을 "
"구현하는 [정적 아이템(static item)](items/static-items.md)에 사용되어 전역 할당자(global allocator)를 "
"설정합니다."

#: src/runtime.md:80
msgid "The `windows_subsystem` attribute"
msgstr "`windows_subsystem` 속성"

#: src/runtime.md:84
msgid ""
"The _`windows_subsystem` attribute_ may be applied at the crate level to set "
"the [subsystem](https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx) when "
"linking on a Windows target."
msgstr ""
"_`windows_subsystem` 속성_은 윈도우 타겟에서 링크할 때 [서브시스템(subsystem)]"
"(https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx)을 설정하기 위해 크레이트 "
"레벨에서 적용될 수 있습니다."

#: src/runtime.md:89
msgid ""
"It uses the [_MetaNameValueStr_](attributes.md#meta-item-attribute-syntax) "
"syntax to specify the subsystem with a value of either `console` or "
"`windows`."
msgstr ""
"이 속성은 [_MetaNameValueStr_](attributes.md#meta-item-attribute-syntax) 구문을 "
"사용하여 `console` 또는 `windows` 중 하나의 값으로 서브시스템을 지정합니다."

#: src/runtime.md:94
msgid ""
"This attribute is ignored on non-Windows targets, and for non-`bin` [crate "
"types](linkage.md)."
msgstr ""
"이 속성은 윈도우가 아닌 타겟이나 `bin`이 아닌 [크레이트 타입](linkage.md)에서는 무시됩니다."

#: src/runtime.md:98
msgid ""
"The \"console\" subsystem is the default. If a console process is run from "
"an existing console then it will be attached to that console, otherwise a "
"new console window will be created."
msgstr ""
"\"console\" 서브시스템이 기본값입니다. 만약 콘솔 프로세스가 기존 콘솔에서 "
"실행된다면 해당 콘솔에 부착되고, 그렇지 않으면 새로운 콘솔 창이 생성됩니다."

#: src/runtime.md:104
msgid ""
"The \"windows\" subsystem is commonly used by GUI applications that do not "
"want to display a console window on startup. It will run detached from any "
"existing console."
msgstr ""
"\"windows\" 서브시스템은 시작 시 콘솔 창을 표시하고 싶지 않은 GUI 애플리케이션에서 "
"주로 사용됩니다. 이는 기존의 어떤 콘솔과도 분리되어 실행됩니다."

#: src/macro-ambiguity.md:3
msgid "Appendix: Macro Follow-Set Ambiguity Formal Specification"
msgstr "부록: 매크로 Follow-Set 모호성 공식 명세"

#: src/macro-ambiguity.md:6
msgid ""
"This page documents the formal specification of the follow rules for [Macros "
"By Example](macros-by-example.md). They were originally specified in [RFC "
"550](https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-"
"proofing.md), from which the bulk of this text is copied, and expanded upon "
"in subsequent RFCs."
msgstr ""
"이 페이지는 [예제를 통한 매크로](macros-by-example.md)를 위한 follow 규칙의 "
"공식 명세를 문서화합니다. 이 규칙들은 원래 [RFC 550]"
"(https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md)에서 "
"명시되었으며, 이 텍스트의 대부분은 해당 RFC에서 복사되고 이후의 RFC들에서 확장된 것입니다."

#: src/macro-ambiguity.md:12
msgid "Definitions & Conventions"
msgstr "정의 및 규약"

#: src/macro-ambiguity.md:16
msgid "`macro`: anything invocable as `foo!(...)` in source code."
msgstr "`macro`: 소스 코드에서 `foo!(...)`와 같이 호출 가능한 모든 것."

#: src/macro-ambiguity.md:17
msgid "`MBE`: macro-by-example, a macro defined by `macro_rules`."
msgstr "`MBE`: 예제를 통한 매크로(macro-by-example), `macro_rules`에 의해 정의된 매크로."

#: src/macro-ambiguity.md:18
msgid ""
"`matcher`: the left-hand-side of a rule in a `macro_rules` invocation, or a "
"subportion thereof."
msgstr ""
"`matcher`: `macro_rules` 호출 내 규칙의 왼쪽 부분(LHS), 또는 그 일부분."

#: src/macro-ambiguity.md:20
msgid ""
"`macro parser`: the bit of code in the Rust parser that will parse the input "
"using a grammar derived from all of the matchers."
msgstr ""
"`macro parser`: 모든 매처(matchers)로부터 파생된 문법을 사용하여 입력을 파싱하는 "
"러스트 파서 내의 코드 조각."

#: src/macro-ambiguity.md:22
msgid ""
"`fragment`: The class of Rust syntax that a given matcher will accept (or "
"\"match\")."
msgstr "`fragment`: 주어진 매처가 수용할(또는 \"일치시킬\") 러스트 구문 클래스."

#: src/macro-ambiguity.md:24
msgid "`repetition` : a fragment that follows a regular repeating pattern"
msgstr "`repetition`: 규칙적인 반복 패턴을 따르는 프래그먼트."

#: src/macro-ambiguity.md:25
msgid ""
"`NT`: non-terminal, the various \"meta-variables\" or repetition matchers "
"that can appear in a matcher, specified in MBE syntax with a leading `$` "
"character."
msgstr ""
"`NT`: 비단말(non-terminal), 매처에 나타날 수 있는 다양한 \"메타 변수\" 또는 반복 매처. "
"MBE 구문에서 시작 부분의 `$` 문자로 지정됩니다."

#: src/macro-ambiguity.md:28
msgid ""
"`simple NT`: a \"meta-variable\" non-terminal (further discussion below)."
msgstr "`simple NT`: \"메타 변수\" 비단말 (아래에서 더 자세히 논의됨)."

#: src/macro-ambiguity.md:29
msgid ""
"`complex NT`: a repetition matching non-terminal, specified via repetition "
"operators (`*`, `+`, `?`)."
msgstr ""
"`complex NT`: 반복 연산자(`*`, `+`, `?`)를 통해 지정된, 반복 일치 비단말."

#: src/macro-ambiguity.md:31
msgid ""
"`token`: an atomic element of a matcher; i.e. identifiers, operators, open/"
"close delimiters, _and_ simple NT's."
msgstr ""
"`token`: 매처의 원자적 요소. 즉, 식별자, 연산자, 여는/닫는 구분자, _그리고_ "
"단순 NT(simple NT)."

#: src/macro-ambiguity.md:33
msgid ""
"`token tree`: a tree structure formed from tokens (the leaves), complex "
"NT's, and finite sequences of token trees."
msgstr ""
"`token tree`: 토큰(리프), 복합 NT(complex NT), 그리고 토큰 트리의 유한 시퀀스로 "
"형성된 트리 구조."

#: src/macro-ambiguity.md:35
msgid ""
"`delimiter token`: a token that is meant to divide the end of one fragment "
"and the start of the next fragment."
msgstr "`delimiter token`: 한 프래그먼트의 끝과 다음 프래그먼트의 시작을 나누기 위한 토큰."

#: src/macro-ambiguity.md:37
msgid ""
"`separator token`: an optional delimiter token in an complex NT that "
"separates each pair of elements in the matched repetition."
msgstr ""
"`separator token`: 복합 NT에서 일치된 반복의 각 요소 쌍을 구분하는 "
"선택적인 구분자 토큰."

#: src/macro-ambiguity.md:39
msgid "`separated complex NT`: a complex NT that has its own separator token."
msgstr "`separated complex NT`: 자체 구분자 토큰을 가진 복합 NT."

#: src/macro-ambiguity.md:40
msgid ""
"`delimited sequence`: a sequence of token trees with appropriate open- and "
"close-delimiters at the start and end of the sequence."
msgstr ""
"`delimited sequence`: 시퀀스의 시작과 끝에 적절한 여는 구분자와 닫는 구분자가 있는 "
"토큰 트리 시퀀스."

#: src/macro-ambiguity.md:42
msgid ""
"`empty fragment`: The class of invisible Rust syntax that separates tokens, "
"i.e. whitespace, or (in some lexical contexts), the empty token sequence."
msgstr ""
"`empty fragment`: 토큰을 구분하는 보이지 않는 러스트 구문 클래스. "
"즉, 공백(whitespace) 또는 (일부 어휘 문맥에서) 빈 토큰 시퀀스."

#: src/macro-ambiguity.md:44
msgid ""
"`fragment specifier`: The identifier in a simple NT that specifies which "
"fragment the NT accepts."
msgstr "`fragment specifier`: 단순 NT(simple NT)에서 해당 NT가 수용하는 프래그먼트를 지정하는 식별자."

#: src/macro-ambiguity.md:46
msgid "`language`: a context-free language."
msgstr "`language`: 문맥 자유 언어(context-free language)."

#: src/macro-ambiguity.md:58
msgid ""
"`(start $foo:expr $($i:ident),* end)` is a matcher. The whole matcher is a "
"delimited sequence (with open- and close-delimiters `(` and `)`), and `$foo` "
"and `$i` are simple NT's with `expr` and `ident` as their respective "
"fragment specifiers."
msgstr ""
"`(start $foo:expr $($i:ident),* end)`는 매처(matcher)입니다. 전체 매처는 "
"구분된 시퀀스(여는 구분자 `(`와 닫는 구분자 `)`가 있는)이며, `$foo`와 `$i`는 "
"각각 `expr`과 `ident`를 프래그먼트 지정자로 가진 단순 NT입니다."

#: src/macro-ambiguity.md:65
msgid ""
"`$(i:ident),*` is _also_ an NT; it is a complex NT that matches a comma-"
"separated repetition of identifiers. The `,` is the separator token for the "
"complex NT; it occurs in between each pair of elements (if any) of the "
"matched fragment."
msgstr ""
"`$(i:ident),*` 또한 하나의 NT입니다. 이는 쉼표로 구분된 식별자들의 반복과 일치하는 "
"복합 NT(complex NT)입니다. `,`는 이 복합 NT의 구분자 토큰(separator token)입니다. "
"이는 일치된 프래그먼트의 각 요소 쌍(있는 경우) 사이에 나타납니다."

#: src/macro-ambiguity.md:70
msgid ""
"Another example of a complex NT is `$(hi $e:expr ;)+`, which matches any "
"fragment of the form `hi <expr>; hi <expr>; ...` where `hi <expr>;` occurs "
"at least once. Note that this complex NT does not have a dedicated separator "
"token."
msgstr ""
복합 NT의 또 다른 예는 `$(hi $e:expr ;)+`입니다. 이는 `hi <expr>; hi <expr>; ...`와 같은 "
"형태의 프래그먼트 중 `hi <expr>;`가 최소 한 번 이상 나타나는 것과 일치합니다. "
"이 복합 NT는 전용 구분자 토큰을 가지고 있지 않음에 유의하십시오."

#: src/macro-ambiguity.md:75
msgid ""
"(Note that Rust's parser ensures that delimited sequences always occur with "
"proper nesting of token tree structure and correct matching of open- and "
"close-delimiters.)"
msgstr ""
"(러스트의 파서는 구분된 시퀀스가 항상 토큰 트리 구조의 적절한 중첩과 "
"여는/닫는 구분자의 올바른 일치와 함께 발생하도록 보장함에 유의하십시오.)"

#: src/macro-ambiguity.md:81
msgid ""
"We will tend to use the variable \"M\" to stand for a matcher, variables "
"\"t\" and \"u\" for arbitrary individual tokens, and the variables \"tt\" "
"and \"uu\" for arbitrary token trees. (The use of \"tt\" does present "
"potential ambiguity with its additional role as a fragment specifier; but it "
"will be clear from context which interpretation is meant.)"
msgstr ""
"우리는 매처를 나타내기 위해 변수 \"M\"을, 임의의 개별 토큰을 위해 변수 \"t\"와 \"u\"를, "
"임의의 토큰 트리를 위해 변수 \"tt\"와 \"uu\"를 사용하는 경향이 있습니다. "
"(\"tt\"의 사용은 프래그먼트 지정자로서의 추가적인 역할 때문에 잠재적인 모호성을 "
"제시하지만, 문맥상 어떤 해석을 의미하는지 명확할 것입니다.)"

#: src/macro-ambiguity.md:89
msgid ""
"\"SEP\" will range over separator tokens, \"OP\" over the repetition "
"operators `*`, `+`, and `?`, \"OPEN\"/\"CLOSE\" over matching token pairs "
"surrounding a delimited sequence (e.g. `[` and `]`)."
msgstr ""
"\"SEP\"는 구분자 토큰을, \"OP\"는 반복 연산자 `*`, `+`, `?`를, "
"\"OPEN\"/\"CLOSE\"는 구분된 시퀀스를 둘러싼 일치하는 토큰 쌍(예: `[` 및 `]`)을 나타냅니다."

#: src/macro-ambiguity.md:95
msgid ""
"Greek letters \"α\" \"β\" \"γ\" \"δ\"  stand for potentially empty token-"
"tree sequences. (However, the Greek letter \"ε\" (epsilon) has a special "
"role in the presentation and does not stand for a token-tree sequence.)"
msgstr ""
"그리스 문자 \"α\", \"β\", \"γ\", \"δ\"는 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스를 "
"나타냅니다. (단, 그리스 문자 \"ε\"(입실론)은 이 설명에서 특별한 역할을 수행하며 "
"토큰 트리 시퀀스를 나타내지 않습니다.)"

#: src/macro-ambiguity.md:99
msgid ""
"This Greek letter convention is usually just employed when the presence of a "
"sequence is a technical detail; in particular, when we wish to _emphasize_ "
"that we are operating on a sequence of token-trees, we will use the notation "
"\"tt ...\" for the sequence, not a Greek letter."
msgstr ""
"이 그리스 문자 관례는 대개 시퀀스의 존재가 기술적인 세부 사항일 때만 채택됩니다. "
"특히, 우리가 토큰 트리 시퀀스에 대해 작업하고 있음을 _강조_하고자 할 때는 "
"그리스 문자가 아닌 \"tt ...\"라는 표기법을 사용합니다."

#: src/macro-ambiguity.md:104
msgid ""
"Note that a matcher is merely a token tree. A \"simple NT\", as mentioned "
"above, is an meta-variable NT; thus it is a non-repetition. For example, "
"`$foo:ty` is a simple NT but `$($foo:ty)+` is a complex NT."
msgstr ""
"매처는 단지 하나의 토큰 트리라는 점에 유의하십시오. 위에서 언급했듯이 \"단순 NT\"는 "
"메타 변수 NT이며, 따라서 반복이 아닙니다. 예를 들어 `$foo:ty`는 단순 NT이지만 "
"`$($foo:ty)+`는 복합 NT입니다."

#: src/macro-ambiguity.md:108
msgid ""
"Note also that in the context of this formalism, the term \"token\" "
"generally _includes_ simple NTs."
msgstr ""
"또한 이 형식화된 체계(formalism)의 문맥에서 \"토큰\"이라는 용어는 "
"일반적으로 단순 NT를 _포함_함에 유의하십시오."

#: src/macro-ambiguity.md:111
msgid ""
"Finally, it is useful for the reader to keep in mind that according to the "
"definitions of this formalism, no simple NT matches the empty fragment, and "
"likewise no token matches the empty fragment of Rust syntax. (Thus, the "
"_only_ NT that can match the empty fragment is a complex NT.) This is not "
"actually true, because the `vis` matcher can match an empty fragment. Thus, "
"for the purposes of the formalism, we will treat `$v:vis` as actually being "
"`$($v:vis)?`, with a requirement that the matcher match an empty fragment."
msgstr ""
"마지막으로, 독자 여러분은 이 형식화된 체계의 정의에 따라 어떤 단순 NT도 빈 프래그먼트와 "
"일치하지 않으며, 마찬가지로 어떤 토큰도 러스트 구문의 빈 프래그먼트와 일치하지 않는다는 점을 "
"기억하는 것이 유용합니다. (따라서 빈 프래그먼트와 일치할 수 있는 _유일한_ NT는 "
"복합 NT뿐입니다.) 이는 실제로 사실이 아닌데, 왜냐하면 `vis` 매처는 빈 프래그먼트와 "
"일치할 수 있기 때문입니다. 따라서 이 체계의 목적을 위해 우리는 `$v:vis`를 "
"실제로는 `$($v:vis)?`인 것처럼 취급할 것이며, 매처가 빈 프래그먼트와 일치해야 한다는 "
"요구 사항을 둘 것입니다."

#: src/macro-ambiguity.md:121
msgid "The Matcher Invariants"
msgstr "매처 불변성 (The Matcher Invariants)"

#: src/macro-ambiguity.md:125
msgid ""
"To be valid, a matcher must meet the following three invariants. The "
"definitions of FIRST and FOLLOW are described later."
msgstr ""
"유효한 매처가 되려면 다음 세 가지 불변성을 충족해야 합니다. FIRST 및 FOLLOW의 "
"정의는 나중에 설명됩니다."

#: src/macro-ambiguity.md:128
msgid ""
"For any two successive token tree sequences in a matcher `M` (i.e. `M = ... "
"tt uu ...`) with `uu ...` nonempty, we must have FOLLOW(`... tt`) ∪ {ε} ⊇ "
"FIRST(`uu ...`)."
msgstr ""
"매처 `M` 내의 임의의 두 연속된 토큰 트리 시퀀스(`M = ... tt uu ...`)에 대해 "
"`uu ...`가 비어 있지 않다면, FOLLOW(`... tt`) ∪ {ε} ⊇ FIRST(`uu ...`)를 "
"만족해야 합니다."

#: src/macro-ambiguity.md:131
msgid ""
"For any separated complex NT in a matcher, `M = ... $(tt ...) SEP OP ...`, "
"we must have `SEP` ∈ FOLLOW(`tt ...`)."
msgstr ""
"매처 내의 임의의 구분된 복합 NT `M = ... $(tt ...) SEP OP ...`에 대해, "
"`SEP` ∈ FOLLOW(`tt ...`)여야 합니다."

#: src/macro-ambiguity.md:133
msgid ""
"For an unseparated complex NT in a matcher, `M = ... $(tt ...) OP ...`, if "
"OP = `*` or `+`, we must have FOLLOW(`tt ...`) ⊇ FIRST(`tt ...`)."
msgstr ""
"매처 내의 구분되지 않은 복합 NT `M = ... $(tt ...) OP ...`에 대해, "
"OP = `*` 또는 `+`인 경우, FOLLOW(`tt ...`) ⊇ FIRST(`tt ...`)여야 합니다."

#: src/macro-ambiguity.md:138
msgid ""
"The first invariant says that whatever actual token that comes after a "
"matcher, if any, must be somewhere in the predetermined follow set.  This "
"ensure that a legal macro definition will continue to assign the same "
"determination as to where `... tt` ends and `uu ...` begins, even as new "
"syntactic forms are added to the language."
msgstr ""
"첫 번째 불변성은 매처 뒤에 오는 실제 토큰이 무엇이든 간에(있는 경우), 그것은 반드시 "
"미리 결정된 follow 집합 어딘가에 있어야 함을 의미합니다. 이는 새로운 구문 형태가 "
"언어에 추가되더라도, 적법한 매크로 정의가 `... tt`가 어디서 끝나고 `uu ...`가 "
"어디서 시작되는지에 대해 계속해서 동일한 결정을 내리도록 보장합니다."

#: src/macro-ambiguity.md:146
msgid ""
"The second invariant says that a separated complex NT must use a separator "
"token that is part of the predetermined follow set for the internal contents "
"of the NT. This ensures that a legal macro definition will continue to parse "
"an input fragment into the same delimited sequence of `tt ...`'s, even as "
"new syntactic forms are added to the language."
msgstr ""
"두 번째 불변성은 구분된 복합 NT가 해당 NT 내부 콘텐츠에 대해 미리 결정된 "
"follow 집합의 일부인 구분자 토큰을 사용해야 함을 의미합니다. 이는 새로운 구문 형태가 "
"언어에 추가되더라도, 적법한 매크로 정의가 입력 프래그먼트를 동일한 `tt ...`들의 "
"구분된 시퀀스로 계속 파싱하도록 보장합니다."

#: src/macro-ambiguity.md:154
msgid ""
"The third invariant says that when we have a complex NT that can match two "
"or more copies of the same thing with no separation in between, it must be "
"permissible for them to be placed next to each other as per the first "
"invariant. This invariant also requires they be nonempty, which eliminates a "
"possible ambiguity."
msgstr ""
"세 번째 불변성은 사이에 구분이 없이 동일한 것의 두 개 이상의 사본과 일치할 수 있는 "
"복합 NT가 있을 때, 첫 번째 불변성에 따라 이들이 서로 옆에 놓이는 것이 허용되어야 함을 "
"의미합니다. 이 불변성은 또한 이들이 비어 있지 않을 것을 요구하며, 이는 발생 가능한 "
"모호성을 제거합니다."

#: src/macro-ambiguity.md:160
msgid ""
"**NOTE: The third invariant is currently unenforced due to historical "
"oversight and significant reliance on the behaviour. It is currently "
"undecided what to do about this going forward. Macros that do not respect "
"the behaviour may become invalid in a future edition of Rust. See the "
"[tracking issue](https://github.com/rust-lang/rust/issues/56575).**"
msgstr ""
"**참고: 세 번째 불변성은 과거의 실수와 해당 동작에 대한 상당한 의존성 때문에 "
"현재 강제되지 않고 있습니다. 앞으로 이에 대해 어떻게 할지는 현재 결정되지 않았습니다. "
"이 동작을 준수하지 않는 매크로는 미래의 러스트 에디션에서 유효하지 않게 될 수 있습니다. "
"[트래킹 이슈](https://github.com/rust-lang/rust/issues/56575)를 참조하십시오.**"

#: src/macro-ambiguity.md:167
msgid "FIRST and FOLLOW, informally"
msgstr "비공식적인 FIRST 및 FOLLOW"

#: src/macro-ambiguity.md:171
msgid "A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M)."
msgstr "주어진 매처 M은 세 가지 집합 FIRST(M), LAST(M), FOLLOW(M)에 매핑됩니다."

#: src/macro-ambiguity.md:173
msgid ""
"Each of the three sets is made up of tokens. FIRST(M) and LAST(M) may also "
"contain a distinguished non-token element ε (\"epsilon\"), which indicates "
"that M can match the empty fragment. (But FOLLOW(M) is always just a set of "
"tokens.)"
msgstr ""
"이 세 가지 집합은 각각 토큰들로 구성됩니다. FIRST(M)과 LAST(M)은 또한 M이 "
"빈 프래그먼트와 일치할 수 있음을 나타내는 구별된 비토큰 요소 ε(\"입실론\")을 "
"포함할 수 있습니다. (단, FOLLOW(M)은 항상 토큰들의 집합입니다.)"

#: src/macro-ambiguity.md:177
msgid "Informally:"
msgstr "비공식적으로는 다음과 같습니다:"

#: src/macro-ambiguity.md:181
msgid ""
"FIRST(M): collects the tokens potentially used first when matching a "
"fragment to M."
msgstr ""
"FIRST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 먼저 사용되는 토큰들을 수집합니다."

#: src/macro-ambiguity.md:186
msgid ""
"LAST(M): collects the tokens potentially used last when matching a fragment "
"to M."
msgstr "LAST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 마지막에 사용되는 토큰들을 수집합니다."

#: src/macro-ambiguity.md:191
msgid ""
"FOLLOW(M): the set of tokens allowed to follow immediately after some "
"fragment matched by M."
msgstr "FOLLOW(M): M과 일치하는 어떤 프래그먼트 직후에 올 수 있도록 허용된 토큰들의 집합입니다."

#: src/macro-ambiguity.md:194
msgid ""
"In other words: t ∈ FOLLOW(M) if and only if there exists (potentially "
"empty) token sequences α, β, γ, δ where:"
msgstr "다시 말해, t ∈ FOLLOW(M)일 필요충분조건은 다음을 만족하는 (잠재적으로 비어 있을 수 있는) 토큰 시퀀스 α, β, γ, δ가 존재하는 것입니다."

#: src/macro-ambiguity.md:197
msgid "M matches β,"
msgstr "M이 β와 일치하고,"

#: src/macro-ambiguity.md:199
msgid "t matches γ, and"
msgstr "t가 γ와 일치하며,"

#: src/macro-ambiguity.md:201
msgid "The concatenation α β γ δ is a parseable Rust program."
msgstr "α β γ δ를 연결한 결과가 파싱 가능한 러스트 프로그램인 경우."

#: src/macro-ambiguity.md:205
msgid ""
"We use the shorthand ANYTOKEN to denote the set of all tokens (including "
"simple NTs). For example, if any token is legal after a matcher M, then "
"FOLLOW(M) = ANYTOKEN."
msgstr ""
"우리는 모든 토큰(단순 NT 포함)의 집합을 나타내기 위해 ANYTOKEN이라는 약어를 사용합니다. "
"예를 들어, 매처 M 뒤에 어떤 토큰이 와도 적법하다면, FOLLOW(M) = ANYTOKEN입니다."

#: src/macro-ambiguity.md:209
msgid ""
"(To review one's understanding of the above informal descriptions, the "
"reader at this point may want to jump ahead to the [examples of FIRST/LAST]"
"(#examples-of-first-and-last) before reading their formal definitions.)"
msgstr ""
"(위의 비공식적인 설명에 대한 이해를 점검하기 위해, 독자 여러분은 공식 정의를 "
"읽기 전에 [FIRST/LAST의 예시](#examples-of-first-and-last)로 건너뛰어 확인해 볼 수 있습니다.)"

#: src/macro-ambiguity.md:216
msgid "FIRST, LAST"
msgstr "FIRST, LAST"

#: src/macro-ambiguity.md:220
msgid "Below are formal inductive definitions for FIRST and LAST."
msgstr "다음은 FIRST와 LAST에 대한 공식적인 귀납적 정의입니다."

#: src/macro-ambiguity.md:224
msgid ""
"\"A ∪ B\" denotes set union, \"A ∩ B\" denotes set intersection, and \"A \\ "
"B\" denotes set difference (i.e. all elements of A that are not present in "
"B)."
msgstr ""
"\"A ∪ B\"는 합집합을, \"A ∩ B\"는 교집합을, \"A \\ B\"는 차집합(즉, A에는 존재하지만 "
"B에는 존재하지 않는 모든 요소)을 나타냅니다."

#: src/macro-ambiguity.md:229
msgid "FIRST"
msgstr "FIRST"

#: src/macro-ambiguity.md:233
msgid ""
"FIRST(M) is defined by case analysis on the sequence M and the structure of "
"its first token-tree (if any):"
msgstr ""
"FIRST(M)은 시퀀스 M과 그 첫 번째 토큰 트리(있는 경우)의 구조에 따른 "
"케이스 분석을 통해 정의됩니다."

#: src/macro-ambiguity.md:238
msgid "if M is the empty sequence, then FIRST(M) = { ε },"
msgstr "M이 빈 시퀀스라면, FIRST(M) = { ε }입니다."

#: src/macro-ambiguity.md:242
msgid "if M starts with a token t, then FIRST(M) = { t },"
msgstr "M이 토큰 t로 시작한다면, FIRST(M) = { t }입니다."

#: src/macro-ambiguity.md:244
msgid ""
"(Note: this covers the case where M starts with a delimited token-tree "
"sequence, `M = OPEN tt ... CLOSE ...`, in which case `t = OPEN` and thus "
"FIRST(M) = { `OPEN` }.)"
msgstr ""
"(참고: 이는 M이 구분된 토큰 트리 시퀀스로 시작하는 경우 `M = OPEN tt ... CLOSE ...`를 포함하며, "
"이 경우 `t = OPEN`이므로 FIRST(M) = { `OPEN` }이 됩니다.)"

#: src/macro-ambiguity.md:248
msgid ""
"(Note: this critically relies on the property that no simple NT matches the "
"empty fragment.)"
msgstr "(참고: 이는 어떤 단순 NT도 빈 프래그먼트와 일치하지 않는다는 속성에 결정적으로 의존합니다.)"

#: src/macro-ambiguity.md:253
msgid ""
"Otherwise, M is a token-tree sequence starting with a complex NT: `M = $"
"( tt ... ) OP α`, or `M = $( tt ... ) SEP OP α`, (where `α` is the "
"(potentially empty) sequence of token trees for the rest of the matcher)."
msgstr ""
"그 외의 경우, M은 복합 NT로 시작하는 토큰 트리 시퀀스입니다: `M = $( tt ... ) OP α`, "
"또는 `M = $( tt ... ) SEP OP α` (여기서 `α`는 매처의 나머지 부분인, "
"잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스입니다)."

#: src/macro-ambiguity.md:257
msgid ""
"Let SEP\\_SET(M) = { SEP } if SEP is present and ε ∈ FIRST(`tt ...`); "
"otherwise SEP\\_SET(M) = {}."
msgstr ""
"SEP가 존재하고 ε ∈ FIRST(`tt ...`)라면 SEP\\_SET(M) = { SEP }이고, "
"그렇지 않으면 SEP\\_SET(M) = {}라고 합시다."

#: src/macro-ambiguity.md:260
msgid ""
"Let ALPHA\\_SET(M) = FIRST(`α`) if OP = `*` or `?` and ALPHA\\_SET(M) = {} "
"if OP = `+`."
msgstr ""
"OP가 `*` 또는 `?`라면 ALPHA\\_SET(M) = FIRST(`α`)이고, "
"OP가 `+`라면 ALPHA\\_SET(M) = {}라고 합시다."

#: src/macro-ambiguity.md:262
msgid "FIRST(M) = (FIRST(`tt ...`) \\\\ {ε}) ∪ SEP\\_SET(M) ∪ ALPHA\\_SET(M)."
msgstr "FIRST(M) = (FIRST(`tt ...`) \\\\ {ε}) ∪ SEP\\_SET(M) ∪ ALPHA\\_SET(M)입니다."

#: src/macro-ambiguity.md:264
msgid ""
"The definition for complex NTs deserves some justification. SEP\\_SET(M) "
"defines the possibility that the separator could be a valid first token for "
"M, which happens when there is a separator defined and the repeated fragment "
"could be empty. ALPHA\\_SET(M) defines the possibility that the complex NT "
"could be empty, meaning that M's valid first tokens are those of the "
"following token-tree sequences `α`. This occurs when either `*` or `?` is "
"used, in which case there could be zero repetitions. In theory, this could "
"also occur if `+` was used with a potentially-empty repeating fragment, but "
"this is forbidden by the third invariant."
msgstr ""
"복합 NT에 대한 정의는 정당화될 필요가 있습니다. SEP\\_SET(M)은 구분자가 정의되어 있고 "
"반복되는 프래그먼트가 비어 있을 수 있는 경우, 구분자가 M의 유효한 첫 번째 토큰이 "
"될 수 있는 가능성을 정의합니다. ALPHA\\_SET(M)은 복합 NT가 비어 있을 수 있는 "
"가능성을 정의하며, 이는 M의 유효한 첫 번째 토큰들이 뒤따르는 토큰 트리 시퀀스 `α`의 "
"토큰들임을 의미합니다. 이는 `*` 또는 `?`가 사용되어 반복 횟수가 0일 수 있는 경우에 "
"발생합니다. 이론적으로는 잠재적으로 비어 있을 수 있는 반복 프래그먼트와 함께 `+`가 "
"사용된 경우에도 발생할 수 있으나, 이는 세 번째 불변성에 의해 금지됩니다."

#: src/macro-ambiguity.md:274
msgid ""
"From there, clearly FIRST(M) can include any token from SEP\\_SET(M) or "
"ALPHA\\_SET(M), and if the complex NT match is nonempty, then any token "
"starting FIRST(`tt ...`) could work too. The last piece to consider is ε. "
"SEP\\_SET(M) and FIRST(`tt ...`) \\ {ε} cannot contain ε, but ALPHA\\_SET(M) "
"could. Hence, this definition allows M to accept ε if and only if ε ∈ "
"ALPHA\\_SET(M) does. This is correct because for M to accept ε in the "
"complex NT case, both the complex NT and α must accept it. If OP = `+`, "
"meaning that the complex NT cannot be empty, then by definition ε ∉ "
"ALPHA\\_SET(M). Otherwise, the complex NT can accept zero repetitions, and "
"then ALPHA\\_SET(M) = FOLLOW(`α`). So this definition is correct with "
"respect to \\varepsilon as well."
msgstr ""
"그 지점으로부터, FIRST(M)은 SEP\\_SET(M) 또는 ALPHA\\_SET(M)의 모든 토큰을 포함할 수 "
"있으며, 복합 NT 일치가 비어 있지 않다면 FIRST(`tt ...`)로 시작하는 모든 토큰 또한 "
"가능합니다. 마지막으로 고려할 부분은 ε입니다. SEP\\_SET(M)과 FIRST(`tt ...`) \\ {ε}은 "
"ε을 포함할 수 없지만, ALPHA\\_SET(M)은 포함할 수 있습니다. 따라서 이 정의는 "
"ε ∈ ALPHA\\_SET(M)인 경우에만 M이 ε을 수용하도록 허용합니다. 이는 복합 NT 사례에서 "
"M이 ε을 수용하려면 복합 NT와 α가 모두 이를 수용해야 하기 때문에 정확합니다. "
"만약 OP = `+`라면, 복합 NT가 비어 있을 수 없음을 의미하므로 정의에 따라 ε ∉ ALPHA\\_SET(M)입니다. "
"그 외의 경우 복합 NT는 0번의 반복을 수용할 수 있으며, 이때 ALPHA\\_SET(M) = FOLLOW(`α`)가 "
"됩니다. 따라서 이 정의는 ε에 대해서도 정확합니다."

#: src/macro-ambiguity.md:287
msgid "LAST"
msgstr "LAST"

#: src/macro-ambiguity.md:291
msgid ""
"LAST(M), defined by case analysis on M itself (a sequence of token-trees):"
msgstr ""
"LAST(M)은 M 자체(토큰 트리 시퀀스)에 대한 케이스 분석을 통해 정의됩니다."

#: src/macro-ambiguity.md:295
msgid "if M is the empty sequence, then LAST(M) = { ε }"
msgstr "M이 빈 시퀀스라면, LAST(M) = { ε }입니다."

#: src/macro-ambiguity.md:299
msgid "if M is a singleton token t, then LAST(M) = { t }"
msgstr "M이 단일 토큰 t라면, LAST(M) = { t }입니다."

#: src/macro-ambiguity.md:303
msgid ""
"if M is the singleton complex NT repeating zero or more times, `M = $"
"( tt ... ) *`, or `M = $( tt ... ) SEP *`"
msgstr ""
"M이 0번 이상 반복되는 단일 복합 NT인 경우, `M = $( tt ... ) *` 또는 "
"`M = $( tt ... ) SEP *`입니다."

#: src/macro-ambiguity.md:306 src/macro-ambiguity.md:318
msgid "Let sep_set = { SEP } if SEP present; otherwise sep_set = {}."
msgstr "SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다."

#: src/macro-ambiguity.md:308 src/macro-ambiguity.md:320
msgid "if ε ∈ LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) ∪ sep_set"
msgstr "ε ∈ LAST(`tt ...`)라면 LAST(M) = LAST(`tt ...`) ∪ sep_set입니다."

#: src/macro-ambiguity.md:310
msgid ""
"otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt ...`) "
"∪ {ε}."
msgstr ""
"그 외의 경우, 시퀀스 `tt ...`는 반드시 비어 있지 않아야 합니다. "
"LAST(M) = LAST(`tt ...`) ∪ {ε}입니다."

#: src/macro-ambiguity.md:315
msgid ""
"if M is the singleton complex NT repeating one or more times, `M = $"
"( tt ... ) +`, or `M = $( tt ... ) SEP +`"
msgstr ""
"M이 1번 이상 반복되는 단일 복합 NT인 경우, `M = $( tt ... ) +` 또는 "
"`M = $( tt ... ) SEP +`입니다."

#: src/macro-ambiguity.md:322
msgid ""
"otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt ...`)"
msgstr "그 외의 경우, 시퀀스 `tt ...`는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(`tt ...`)입니다."

#: src/macro-ambiguity.md:327
msgid ""
"if M is the singleton complex NT repeating zero or one time, `M = $"
"( tt ...) ?`, then LAST(M) = LAST(`tt ...`) ∪ {ε}."
msgstr ""
"M이 0번 또는 1번 반복되는 단일 복합 NT인 경우(`M = $( tt ...) ?`), "
"LAST(M) = LAST(`tt ...`) ∪ {ε}입니다."

#: src/macro-ambiguity.md:332
msgid ""
"if M is a delimited token-tree sequence `OPEN tt ... CLOSE`, then LAST(M) = "
"{ `CLOSE` }."
msgstr ""
"M이 구분된 토큰 트리 시퀀스 `OPEN tt ... CLOSE`인 경우, LAST(M) = { `CLOSE` }입니다."

#: src/macro-ambiguity.md:337
msgid "if M is a non-empty sequence of token-trees `tt uu ...`,"
msgstr "M이 비어 있지 않은 토큰 트리 시퀀스 `tt uu ...`인 경우,"

#: src/macro-ambiguity.md:339
msgid ""
"If ε ∈ LAST(`uu ...`), then LAST(M) = LAST(`tt`) ∪ (LAST(`uu ...`) \\ { ε })."
msgstr "ε ∈ LAST(`uu ...`)라면, LAST(M) = LAST(`tt`) ∪ (LAST(`uu ...`) \\ { ε })입니다."

#: src/macro-ambiguity.md:341
msgid ""
"Otherwise, the sequence `uu ...` must be non-empty; then LAST(M) = "
"LAST(`uu ...`)."
msgstr "그 외의 경우, 시퀀스 `uu ...`는 반드시 비어 있지 않아야 하며, LAST(M) = LAST(`uu ...`)입니다."

#: src/macro-ambiguity.md:344
msgid "Examples of FIRST and LAST"
msgstr "FIRST 및 LAST의 예시"

#: src/macro-ambiguity.md:346
msgid ""
"Below are some examples of FIRST and LAST. (Note in particular how the "
"special ε element is introduced and eliminated based on the interaction "
"between the pieces of the input.)"
msgstr ""
"다음은 FIRST와 LAST의 몇 가지 예시입니다. (특히 입력 조각들 사이의 상호 작용에 따라 "
"특별한 ε 요소가 어떻게 도입되고 제거되는지 유의하십시오.)"

#: src/macro-ambiguity.md:350
msgid ""
"Our first example is presented in a tree structure to elaborate on how the "
"analysis of the matcher composes. (Some of the simpler subtrees have been "
"elided.)"
msgstr ""
"첫 번째 예시는 매처 분석이 어떻게 구성되는지 상세히 설명하기 위해 트리 구조로 제시됩니다. "
"(일부 단순한 서브트리들은 생략되었습니다.)"

#: src/macro-ambiguity.md:378
msgid "Thus:"
msgstr "따라서:"

#: src/macro-ambiguity.md:380
msgid ""
"FIRST(`$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g`) = { `$d:ident`, `h`, "
"`;`, `f` }"
msgstr ""
"FIRST(`$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g`) = { `$d:ident`, `h`, "
"`;`, `f` }"

#: src/macro-ambiguity.md:382
msgid "Note however that:"
msgstr "하지만 다음 사항에 유의하십시오:"

#: src/macro-ambiguity.md:384
msgid ""
"FIRST(`$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*`) = { `$d:ident`, "
"`h`, `;`, `f`, ε }"
msgstr ""
"FIRST(`$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*`) = { `$d:ident`, "
"`h`, `;`, `f`, ε }"

#: src/macro-ambiguity.md:386
msgid "Here are similar examples but now for LAST."
msgstr "다음은 LAST에 대한 유사한 예시들입니다."

#: src/macro-ambiguity.md:388
msgid "LAST(`$d:ident $e:expr`) = { `$e:expr` }"
msgstr "LAST(`$d:ident $e:expr`) = { `$e:expr` }"

#: src/macro-ambiguity.md:389
msgid "LAST(`$( $d:ident $e:expr );*`) = { `$e:expr`, ε }"
msgstr "LAST(`$( $d:ident $e:expr );*`) = { `$e:expr`, ε }"

#: src/macro-ambiguity.md:390
msgid "LAST(`$( $d:ident $e:expr );* $(h)*`) = { `$e:expr`, ε, `h` }"
msgstr "LAST(`$( $d:ident $e:expr );* $(h)*`) = { `$e:expr`, ε, `h` }"

#: src/macro-ambiguity.md:391
msgid "LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+`) = { `;` }"
msgstr "LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+`) = { `;` }"

#: src/macro-ambiguity.md:392
msgid "LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+ g`) = { `g` }"
msgstr "LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+ g`) = { `g` }"

#: src/macro-ambiguity.md:396
msgid "FOLLOW(M)"
msgstr "FOLLOW(M)"

#: src/macro-ambiguity.md:400
msgid ""
"Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, "
"etc. represent simple nonterminals with the given fragment specifier."
msgstr ""
"마지막으로, FOLLOW(M)의 정의는 다음과 같이 구성됩니다. pat, expr 등은 "
"주어진 프래그먼트 지정자를 가진 단순 비단말(nonterminals)을 나타냅니다."

#: src/macro-ambiguity.md:405
msgid "FOLLOW(pat) = {`=>`, `,`, `=`, `|`, `if`, `in`}\\`."
msgstr "FOLLOW(pat) = {`=>`, `,`, `=`, `|`, `if`, `in`}입니다."

#: src/macro-ambiguity.md:409
msgid "FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {`=>`, `,`, `;`}\\`."
msgstr "FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {`=>`, `,`, `;`}입니다."

#: src/macro-ambiguity.md:413
msgid ""
"FOLLOW(ty) = FOLLOW(path) = {`{`, `[`, `,`, `=>`, `:`, `=`, `>`, `>>`, `;`, "
"`|`, `as`, `where`, block nonterminals}."
msgstr ""
"FOLLOW(ty) = FOLLOW(path) = {`{`, `[`, `,`, `=>`, `:`, `=`, `>`, `>>`, `;`, "
"`|`, `as`, `where`, block 비단말}입니다."

#: src/macro-ambiguity.md:418
msgid ""
"FOLLOW(vis) = {`,`l any keyword or identifier except a non-raw `priv`; any "
"token that can begin a type; ident, ty, and path nonterminals}."
msgstr ""
"FOLLOW(vis) = {`,`l 원시(raw)가 아닌 `priv`를 제외한 모든 키워드 또는 식별자; "
"타입을 시작할 수 있는 모든 토큰; ident, ty, 그리고 path 비단말}입니다."

#: src/macro-ambiguity.md:423
msgid ""
"FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident, tt, "
"item, lifetime, literal and meta simple nonterminals, and all terminals."
msgstr ""
"FOLLOW(t) = ANYTOKEN (block, ident, tt, item, lifetime, literal, meta "
"단순 비단말 및 모든 단말(terminals)을 포함한 다른 모든 단순 토큰의 경우)."

#: src/macro-ambiguity.md:428
msgid ""
"FOLLOW(M), for any other M, is defined as the intersection, as t ranges over "
"(LAST(M) \\ {ε}), of FOLLOW(t)."
msgstr ""
"다른 모든 M에 대해 FOLLOW(M)은, t가 (LAST(M) \\ {ε})의 범위에 있을 때 "
"FOLLOW(t)의 교집합으로 정의됩니다."

#: src/macro-ambiguity.md:433
msgid ""
"The tokens that can begin a type are, as of this writing, {`(`, `[`, `!`, "
"`*`, `&`, `&&`, `?`, lifetimes, `>`, `>>`, `::`, any non-keyword identifier, "
"`super`, `self`, `Self`, `extern`, `crate`, `$crate`, `_`, `for`, `impl`, "
"`fn`, `unsafe`, `typeof`, `dyn`}, although this list may not be complete "
"because people won't always remember to update the appendix when new ones "
"are added."
msgstr ""
"타입을 시작할 수 있는 토큰은 이 글을 쓰는 시점을 기준으로 {`(`, `[`, `!`, "
"`*`, `&`, `&&`, `?`, 라이프타임, `>`, `>>`, `::`, 키워드가 아닌 모든 식별자, "
"`super`, `self`, `Self`, `extern`, `crate`, `$crate`, `_`, `for`, `impl`, "
"`fn`, `unsafe`, `typeof`, `dyn`}입니다. 새로운 토큰이 추가될 때 부록을 업데이트하는 "
"것을 잊을 수 있으므로 이 목록이 완전하지 않을 수 있습니다."

#: src/macro-ambiguity.md:439
msgid "Examples of FOLLOW for complex M:"
msgstr "복합 M에 대한 FOLLOW의 예시:"

#: src/macro-ambiguity.md:441
msgid "FOLLOW(`$( $d:ident $e:expr )*`) = FOLLOW(`$e:expr`)"
msgstr "FOLLOW(`$( $d:ident $e:expr )*`) = FOLLOW(`$e:expr`)"

#: src/macro-ambiguity.md:442
msgid ""
"FOLLOW(`$( $d:ident $e:expr )* $(;)*`) = FOLLOW(`$e:expr`) ∩ ANYTOKEN = "
"FOLLOW(`$e:expr`)"
msgstr ""
"FOLLOW(`$( $d:ident $e:expr )* $(;)*`) = FOLLOW(`$e:expr`) ∩ ANYTOKEN = "
"FOLLOW(`$e:expr`)"

#: src/macro-ambiguity.md:443
msgid "FOLLOW(`$( $d:ident $e:expr )* $(;)* $( f |)+`) = ANYTOKEN"
msgstr "FOLLOW(`$( $d:ident $e:expr )* $(;)* $( f |)+`) = ANYTOKEN"

#: src/macro-ambiguity.md:445
msgid "Examples of valid and invalid matchers"
msgstr "유효하거나 유효하지 않은 매처의 예시"

#: src/macro-ambiguity.md:447
msgid ""
"With the above specification in hand, we can present arguments for why "
"particular matchers are legal and others are not."
msgstr ""
"위의 명세를 바탕으로, 특정 매처가 왜 적법하고 다른 것들은 그렇지 않은지에 대한 "
"논거를 제시할 수 있습니다."

#: src/macro-ambiguity.md:450
msgid ""
"`($ty:ty < foo ,)` : illegal, because FIRST(`< foo ,`) = { `<` } ⊈ "
"FOLLOW(`ty`)"
msgstr ""
"`($ty:ty < foo ,)` : 부적법. FIRST(`< foo ,`) = { `<` } ⊈ FOLLOW(`ty`)이기 때문입니다."

#: src/macro-ambiguity.md:452
msgid ""
"`($ty:ty , foo <)` : legal, because FIRST(`, foo <`) = { `,` }  is ⊆ "
"FOLLOW(`ty`)."
msgstr ""
"`($ty:ty , foo <)` : 적법. FIRST(`, foo <`) = { `,` } ⊆ FOLLOW(`ty`)이기 때문입니다."

#: src/macro-ambiguity.md:454
msgid ""
"`($pa:pat $pb:pat $ty:ty ,)` : illegal, because FIRST(`$pb:pat $ty:ty ,`) = "
"{ `$pb:pat` } ⊈ FOLLOW(`pat`), and also FIRST(`$ty:ty ,`) = { `$ty:ty` } ⊈ "
"FOLLOW(`pat`)."
msgstr ""
"`($pa:pat $pb:pat $ty:ty ,)` : 부적법. FIRST(`$pb:pat $ty:ty ,`) = { `$pb:pat` } ⊈ FOLLOW(`pat`)이고, "
"또한 FIRST(`$ty:ty ,`) = { `$ty:ty` } ⊈ FOLLOW(`pat`)이기 때문입니다."

#: src/macro-ambiguity.md:456
msgid ""
"`( $($a:tt $b:tt)* ; )` : legal, because FIRST(`$b:tt`) = { `$b:tt` } is ⊆ "
"FOLLOW(`tt`) = ANYTOKEN, as is FIRST(`;`) = { `;` }."
msgstr ""
"`( $($a:tt $b:tt)* ; )` : 적법. FIRST(`$b:tt`) = { `$b:tt` } ⊆ FOLLOW(`tt`) = ANYTOKEN이고, "
"FIRST(`;`) = { `;` } 또한 ⊆ ANYTOKEN이기 때문입니다."

#: src/macro-ambiguity.md:458
msgid ""
"`( $($t:tt),* , $(t:tt),* )` : legal,  (though any attempt to actually use "
"this macro will signal a local ambiguity error during expansion)."
msgstr ""
"`( $($t:tt),* , $(t:tt),* )` : 적법. (단, 실제로 이 매크로를 사용하려고 시도하면 "
"확장 과정에서 지역적 모호성 오류가 발생합니다.)"

#: src/macro-ambiguity.md:460
msgid ""
"`($ty:ty $(; not sep)* -)` : illegal, because FIRST(`$(; not sep)* -`) = "
"{ `;`, `-` } is not in FOLLOW(`ty`)."
msgstr ""
"`($ty:ty $(; not sep)* -)` : 부적법. FIRST(`$(; not sep)* -`) = { `;`, `-` }가 "
"FOLLOW(`ty`)에 없기 때문입니다."

#: src/macro-ambiguity.md:462
msgid ""
"`($($ty:ty)-+)` : illegal, because separator `-` is not in FOLLOW(`ty`)."
msgstr "`($($ty:ty)-+)` : 부적법. 구분자 `-`가 FOLLOW(`ty`)에 없기 때문입니다."

#: src/macro-ambiguity.md:464
msgid "`($($e:expr)*)` : illegal, because expr NTs are not in FOLLOW(expr NT)."
msgstr "`($($e:expr)*)` : 부적법. expr NT들이 FOLLOW(expr NT)에 없기 때문입니다."

#: src/influences.md:3
msgid ""
"Rust is not a particularly original language, with design elements coming "
"from a wide range of sources. Some of these are listed below (including "
"elements that have since been removed):"
msgstr ""
"러스트는 특별히 독창적인 언어는 아니며, 광범위한 소스에서 유래한 설계 요소들을 "
"가지고 있습니다. 그중 일부는 다음과 같습니다(이후에 제거된 요소 포함):"

#: src/influences.md:7
msgid ""
"SML, OCaml: algebraic data types, pattern matching, type inference, "
"semicolon statement separation"
msgstr "SML, OCaml: 대수적 데이터 타입, 패턴 매칭, 타입 추론, 세미콜론을 이용한 구문 분리"

#: src/influences.md:9
msgid ""
"C++: references, RAII, smart pointers, move semantics, monomorphization, "
"memory model"
msgstr "C++: 참조, RAII, 스마트 포인터, 이동 세만틱, 단일화(monomorphization), 메모리 모델"

#: src/influences.md:11
msgid "ML Kit, Cyclone: region based memory management"
msgstr "ML Kit, Cyclone: 리전(region) 기반 메모리 관리"

#: src/influences.md:12
msgid "Haskell (GHC): typeclasses, type families"
msgstr "Haskell (GHC): 타입 클래스, 타입 패밀리"

#: src/influences.md:13
msgid "Newsqueak, Alef, Limbo: channels, concurrency"
msgstr "Newsqueak, Alef, Limbo: 채널, 동시성"

#: src/influences.md:14
msgid ""
"Erlang: message passing, thread failure, <strike>linked thread failure</"
"strike>, <strike>lightweight concurrency</strike>"
msgstr "Erlang: 메시지 패싱, 스레드 실패, <strike>연결된 스레드 실패</strike>, <strike>경량 동시성</strike>"

#: src/influences.md:16
msgid "Swift: optional bindings"
msgstr "Swift: 옵셔널 바인딩"

#: src/influences.md:17
msgid "Scheme: hygienic macros"
msgstr "Scheme: 위생적(hygienic) 매크로"

#: src/influences.md:18
msgid "C#: attributes"
msgstr "C#: 속성 (attributes)"

#: src/influences.md:19
msgid "Ruby: closure syntax, <strike>block syntax</strike>"
msgstr "Ruby: 클로저 구문, <strike>블록 구문</strike>"

#: src/influences.md:20
msgid "NIL, Hermes: <strike>typestate</strike>"
msgstr "NIL, Hermes: <strike>타입 상태 (typestate)</strike>"

#: src/influences.md:21
msgid ""
"[Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and "
"pattern syntax"
msgstr "[Unicode Annex #31](http://www.unicode.org/reports/tr31/): 식별자 및 패턴 구문"

#: src/test-summary.md:3
msgid ""
"The following is a summary of the total tests that are linked to individual "
"rule identifiers within the reference."
msgstr "다음은 레퍼런스 내의 개별 규칙 식별자에 연결된 총 테스트 요약입니다."

#: src/glossary.md:3
msgid "Abstract syntax tree"
msgstr "추상 구문 트리 (Abstract syntax tree)"

#: src/glossary.md:5
msgid ""
"An ‘abstract syntax tree’, or ‘AST’, is an intermediate representation of "
"the structure of the program when the compiler is compiling it."
msgstr "‘추상 구문 트리’ 또는 ‘AST’는 컴파일러가 프로그램을 컴파일할 때 사용하는 프로그램 구조의 중간 표현입니다."

#: src/glossary.md:8
msgid "Alignment"
msgstr "정렬 (Alignment)"

#: src/glossary.md:10
msgid ""
"The alignment of a value specifies what addresses values are preferred to "
"start at. Always a power of two. References to a value must be aligned. "
"[More](type-layout.md#size-and-alignment)."
msgstr ""
"값의 정렬은 값이 시작되는 선호되는 주소를 지정합니다. 항상 2의 거듭제곱입니다. "
"값에 대한 참조는 반드시 정렬되어야 합니다. [자세히](type-layout.md#size-and-alignment)."

#: src/glossary.md:14
msgid "Arity"
msgstr "항수 (Arity)"

#: src/glossary.md:16
msgid ""
"Arity refers to the number of arguments a function or operator takes. For "
"some examples, `f(2, 3)` and `g(4, 6)` have arity 2, while `h(8, 2, 6)` has "
"arity 3. The `!` operator has arity 1."
msgstr ""
"항수는 함수나 연산자가 취하는 인자의 개수를 의미합니다. 예를 들어, `f(2, 3)`와 `g(4, 6)`는 "
"항수가 2이고, `h(8, 2, 6)`는 항수가 3입니다. `!` 연산자는 항수가 1입니다."

#: src/glossary.md:20
msgid "Array"
msgstr "배열 (Array)"

#: src/glossary.md:22
msgid ""
"An array, sometimes also called a fixed-size array or an inline array, is a "
"value describing a collection of elements, each selected by an index that "
"can be computed at run time by the program. It occupies a contiguous region "
"of memory."
msgstr ""
"배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 "
"계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. "
"메모리의 연속적인 영역을 차지합니다."
"배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. 메모리의 연속적인 영역을 차지합니다."

#: src/glossary.md:26
msgid "Associated item"
msgstr "연관 아이템"

#: src/glossary.md:28
msgid ""
"An associated item is an item that is associated with another item. "
"Associated items are defined in [implementations](items/implementations.md) "
"and declared in [traits](items/traits.md). Only functions, constants, and "
"type aliases can be associated. Contrast to a [free item](#free-item)."
msgstr ""
"연관 아이템은 다른 아이템과 연관된 아이템입니다. 연관 아이템은 [구현](items/"
"implementations.md)에 정의되고 [트레잇](items/traits.md)에 선언됩니다. 함"
"수, 상수, 타입 별칭만 연관될 수 있습니다. [자유 아이템](#free-item)과 대조"
"됩니다."

#: src/glossary.md:33
msgid "Blanket implementation"
msgstr "블랭킷 구현"

#: src/glossary.md:35
msgid ""
"Any implementation where a type appears [uncovered](#uncovered-type). "
"`impl<T> Foo for T`, `impl<T> Bar<T> for T`, `impl<T> Bar<Vec<T>> for T`, "
"and `impl<T> Bar<T> for Vec<T>` are considered blanket impls. However, "
"`impl<T> Bar<Vec<T>> for Vec<T>` is not a blanket impl, as all instances of "
"`T` which appear in this `impl` are covered by `Vec`."
msgstr ""
"타입이 [커버되지 않은](#uncovered-type) 상태로 나타나는 모든 구현. `impl<T> "
"Foo for T`, `impl<T> Bar<T> for T`, `impl<T> Bar<Vec<T>> for T`, 그리고 "
"`impl<T> Bar<T> for Vec<T>`는 블랭킷 구현으로 간주됩니다. 하지만 `impl<T> "
"Bar<Vec<T>> for Vec<T>`는 이 `impl`에 나타나는 모든 `T` 인스턴스가 `Vec`에 "
"의해 커버되므로 블랭킷 구현이 아닙니다."

#: src/glossary.md:41
msgid "Bound"
msgstr "바운드"

#: src/glossary.md:43
msgid ""
"Bounds are constraints on a type or trait. For example, if a bound is placed "
"on the argument a function takes, types passed to that function must abide "
"by that constraint."
msgstr ""
"바운드는 타입이나 트레잇에 대한 제약 조건입니다. 예를 들어, 함수가 받는 인"
"자에 바운드가 지정되면 해당 함수에 전달되는 타입은 해당 제약 조건을 준수해"
"야 합니다."

#: src/glossary.md:47
msgid "Combinator"
msgstr "컴비네이터"

#: src/glossary.md:49
msgid ""
"Combinators are higher-order functions that apply only functions and earlier "
"defined combinators to provide a result from its arguments. They can be used "
"to manage control flow in a modular fashion."
msgstr ""
"컴비네이터는 함수와 이전에 정의된 컴비네이터만을 적용하여 인자로부터 결과"
"를 제공하는 고차 함수입니다. 모듈식으로 제어 흐름을 관리하는 데 사용할 수 "
"있습니다."

#: src/glossary.md:53
msgid "Crate"
msgstr "크레이트"

#: src/glossary.md:55
msgid ""
"A crate is the unit of compilation and linking. There are different [types "
"of crates](linkage.md), such as libraries or executables. Crates may link "
"and refer to other library crates, called external crates. A crate has a "
"self-contained tree of [modules](items/modules.md), starting from an unnamed "
"root module called the crate root. [Items](items.md) may be made visible to "
"other crates by marking them as public in the crate root, including through "
"[paths](paths.md) of public modules. [More](crates-and-source-files.md)."
msgstr ""
"크레이트는 컴파일 및 링크의 단위입니다. 라이브러리나 실행 파일과 같은 다양"
"한 [크레이트 종류](linkage.md)가 있습니다. 크레이트는 외부 크레이트라고 하"
"는 다른 라이브러리 크레이트를 링크하고 참조할 수 있습니다. 크레이트는 크레"
"이트 루트라고 하는 이름 없는 루트 모듈에서 시작하는 자체 포함된 [모듈](items/modules.md) "
"트리를 가집니다. [아이템](items.md)은 공개 모듈의 [경로](paths.md)를 포함하"
"여 크레이트 루트에서 공개로 표시하여 다른 크레이트에서 볼 수 있도록 할 수 "
"있습니다. [더 보기](crates-and-source-files.md)."

#: src/glossary.md:63
msgid "Dispatch"
msgstr "디스패치"

#: src/glossary.md:65
msgid ""
"Dispatch is the mechanism to determine which specific version of code is "
"actually run when it involves polymorphism. Two major forms of dispatch are "
"static dispatch and dynamic dispatch. While Rust favors static dispatch, it "
"also supports dynamic dispatch through a mechanism called ‘trait objects’."
msgstr ""
"디스패치는 다형성과 관련될 때 실제로 실행되는 코드의 특정 버전을 결정하는 "
"메커니즘입니다. 디스패치의 두 가지 주요 형태는 정적 디스패치와 동적 디스패"
"치입니다. Rust는 정적 디스패치를 선호하지만 '트레잇 객체'라는 메커니즘을 통"
"해 동적 디스패치도 지원합니다."

#: src/glossary.md:70
msgid "Dynamically sized type"
msgstr "동적 크기 타입"

#: src/glossary.md:72
msgid ""
"A dynamically sized type (DST) is a type without a statically known size or "
"alignment."
msgstr "동적 크기 타입(DST)은 정적으로 알려진 크기나 정렬이 없는 타입입니다."

#: src/glossary.md:74
msgid "Entity"
msgstr "엔티티"

#: src/glossary.md:76
msgid ""
"An [_entity_](names.md) is a language construct that can be referred to in "
"some way within the source program, usually via a [path](paths.md). Entities "
"include [types](types.md), [items](items.md), [generic parameters](items/"
"generics.md), [variable bindings](patterns.md), [loop labels]"
"(tokens.md#lifetimes-and-loop-labels), [lifetimes](tokens.md#lifetimes-and-"
"loop-labels), [fields](expressions/field-expr.md), [attributes]"
"(attributes.md), and [lints](attributes/diagnostics.md#lint-check-"
"attributes)."
msgstr ""
"[_엔티티_](names.md)는 소스 프로그램 내에서 어떤 방식으로든, 보통 [경로]"
"(paths.md)를 통해 참조될 수 있는 언어 구성 요소입니다. 엔티티에는 [타입]"
"(types.md), [아이템](items.md), [제네릭 파라미터](items/generics.md), [변수 "
"바인딩](patterns.md), [루프 레이블](tokens.md#lifetimes-and-loop-labels), "
"[라이프타임](tokens.md#lifetimes-and-loop-labels), [필드](expressions/field-"
"expr.md), [속성](attributes.md), [린트](attributes/diagnostics.md#lint-"
"check-attributes)가 포함됩니다."

#: src/glossary.md:83
msgid ""
"An expression is a combination of values, constants, variables, operators "
"and functions that evaluate to a single value, with or without side-effects."
msgstr ""
"표현식은 값, 상수, 변수, 연산자 및 함수의 조합으로, 부수 효과가 있거나 없"
"을 수 있으며 단일 값으로 평가됩니다."

#: src/glossary.md:86
msgid "For example, `2 + (3 * 4)` is an expression that returns the value 14."
msgstr "예를 들어, `2 + (3 * 4)`는 값 14를 반환하는 표현식입니다."

#: src/glossary.md:88
msgid "Free item"
msgstr "자유 아이템"

#: src/glossary.md:90
msgid ""
"An [item](items.md) that is not a member of an [implementation](items/"
"implementations.md), such as a _free function_ or a _free const_. Contrast "
"to an [associated item](#associated-item)."
msgstr ""
"[구현](items/implementations.md)의 멤버가 아닌 [아이템](items.md)으로, _자"
"유 함수_ 또는 _자유 상수_와 같은 것입니다. [연관 아이템](#associated-item)과 "
"대조됩니다."

#: src/glossary.md:93
msgid "Fundamental traits"
msgstr "기본 트레잇"

#: src/glossary.md:95
msgid ""
"A fundamental trait is one where adding an impl of it for an existing type "
"is a breaking change. The `Fn` traits and `Sized` are fundamental."
msgstr ""
"기본 트레잇은 기존 타입에 대해 구현을 추가하는 것이 파괴적인 변경이 되는 "
"트레잇입니다. `Fn` 트레잇과 `Sized`가 기본 트레잇입니다."

#: src/glossary.md:98
msgid "Fundamental type constructors"
msgstr "기본 타입 생성자"

#: src/glossary.md:100
msgid ""
"A fundamental type constructor is a type where implementing a [blanket "
"implementation](#blanket-implementation) over it is a breaking change. `&`, "
"`&mut`, `Box`, and `Pin`  are fundamental."
msgstr ""
"기본 타입 생성자는 그 위에 [블랭킷 구현](#blanket-implementation)을 구현하"
"는 것이 파괴적인 변경이 되는 타입입니다. `&`, `&mut`, `Box`, `Pin`이 기본 타"
"입 생성자입니다."

#: src/glossary.md:103
msgid ""
"Any time a type `T` is considered [local](#local-type), `&T`, `&mut T`, "
"`Box<T>`, and `Pin<T>` are also considered local. Fundamental type "
"constructors cannot [cover](#uncovered-type) other types. Any time the term "
"\"covered type\" is used, the `T` in `&T`, `&mut T`, `Box<T>`, and `Pin<T>` "
"is not considered covered."
msgstr ""
"타입 `T`가 [로컬](#local-type)로 간주될 때마다 `&T`, `&mut T`, `Box<T>`, "
"`Pin<T>`도 로컬로 간주됩니다. 기본 타입 생성자는 다른 타입을 [커버](#uncovered-"
"type)할 수 없습니다. \"커버된 타입\"이라는 용어가 사용될 때마다 `&T`, `&mut "
"T`, `Box<T>`, `Pin<T>`의 `T`는 커버된 것으로 간주되지 않습니다."

#: src/glossary.md:108
msgid "Inhabited"
msgstr "인해비티드"

#: src/glossary.md:110
msgid ""
"A type is inhabited if it has constructors and therefore can be "
"instantiated. An inhabited type is not \"empty\" in the sense that there can "
"be values of the type. Opposite of [Uninhabited](#uninhabited)."
msgstr ""
"타입은 생성자가 있어 인스턴스화할 수 있는 경우 인해비티드(inhabited)됩니다. "
"인해비티드 타입은 해당 타입의 값이 있을 수 있다는 의미에서 \"비어 있지\" 않"
"습니다. [언인해비티드](#uninhabited)의 반대입니다."

#: src/glossary.md:114
msgid "Inherent implementation"
msgstr "고유 구현"

#: src/glossary.md:116
msgid ""
"An [implementation](items/implementations.md) that applies to a nominal "
"type, not to a trait-type pair. [More](items/implementations.md#inherent-"
"implementations)."
msgstr ""
"트레잇-타입 쌍이 아닌 명목 타입에 적용되는 [구현](items/implementations.md)입"
"니다. [더 보기](items/implementations.md#inherent-implementations)."

#: src/glossary.md:119
msgid "Inherent method"
msgstr "고유 메서드"

#: src/glossary.md:121
msgid ""
"A [method](items/associated-items.md#methods) defined in an [inherent "
"implementation](items/implementations.md#inherent-implementations), not in a "
"trait implementation."
msgstr ""
"트레잇 구현이 아닌 [고유 구현](items/implementations.md#inherent-"
"implementations)에 정의된 [메서드](items/associated-items.md#methods)입니다."

#: src/glossary.md:124
msgid "Initialized"
msgstr "초기화됨"

#: src/glossary.md:126
msgid ""
"A variable is initialized if it has been assigned a value and hasn't since "
"been moved from. All other memory locations are assumed to be uninitialized. "
"Only unsafe Rust can create a memory location without initializing it."
msgstr ""
"변수는 값이 할당되고 그 이후로 이동되지 않은 경우 초기화됩니다. 다른 모든 "
"메모리 위치는 초기화되지 않은 것으로 간주됩니다. 안전하지 않은 Rust만이 초"
"기화하지 않고 메모리 위치를 생성할 수 있습니다."

#: src/glossary.md:130
msgid "Local trait"
msgstr "로컬 트레잇"

#: src/glossary.md:132
msgid ""
"A `trait` which was defined in the current crate. A trait definition is "
"local or not independent of applied type arguments. Given `trait Foo<T, U>`, "
"`Foo` is always local, regardless of the types substituted for `T` and `U`."
msgstr ""
"현재 크레이트에서 정의된 `trait`입니다. 트레잇 정의는 적용된 타입 인자와 "
"독립적으로 로컬이거나 로컬이 아닐 수 있습니다. `trait Foo<T, U>`가 주어졌을 "
"때, `T`와 `U`에 대해 대체된 타입에 관계없이 `Foo`는 항상 로컬입니다."

#: src/glossary.md:136
msgid "Local type"
msgstr "로컬 타입"

#: src/glossary.md:138
msgid ""
"A `struct`, `enum`, or `union` which was defined in the current crate. This "
"is not affected by applied type arguments. `struct Foo` is considered local, "
"but `Vec<Foo>` is not. `LocalType<ForeignType>` is local. Type aliases do "
"not affect locality."
msgstr ""
"현재 크레이트에서 정의된 `struct`, `enum` 또는 `union`입니다. 이것은 적용된 "
"타입 인자에 영향을 받지 않습니다. `struct Foo`는 로컬로 간주되지만 `Vec<Foo>`"
"는 그렇지 않습니다. `LocalType<ForeignType>`은 로컬입니다. 타입 별칭은 지"
"역성에 영향을 주지 않습니다."

#: src/glossary.md:143
msgid "Module"
msgstr "모듈"

#: src/glossary.md:145
msgid ""
"A module is a container for zero or more [items](items.md). Modules are "
"organized in a tree, starting from an unnamed module at the root called the "
"crate root or the root module. [Paths](paths.md) may be used to refer to "
"items from other modules, which may be restricted by [visibility rules]"
"(visibility-and-privacy.md). [More](items/modules.md)"
msgstr ""
"모듈은 0개 이상의 [아이템](items.md)을 담는 컨테이너입니다. 모듈은 크레이트 "
"루트 또는 루트 모듈이라고 하는 루트의 이름 없는 모듈에서 시작하는 트리로 "
"구성됩니다. [경로](paths.md)는 다른 모듈의 아이템을 참조하는 데 사용될 수 "
"있으며, 이는 [가시성 규칙](visibility-and-privacy.md)에 의해 제한될 수 있습"
"니다. [더 보기](items/modules.md)"

#: src/glossary.md:153
msgid ""
"A [_name_](names.md) is an [identifier](identifiers.md) or [lifetime or loop "
"label](tokens.md#lifetimes-and-loop-labels) that refers to an [entity]"
"(#entity). A _name binding_ is when an entity declaration introduces an "
"identifier or label associated with that entity. [Paths](paths.md), "
"identifiers, and labels are used to refer to an entity."
msgstr ""
"[_이름_](names.md)은 [엔티티](#entity)를 참조하는 [식별자](identifiers.md) "
"또는 [라이프타임 또는 루프 레이블](tokens.md#lifetimes-and-loop-labels)입니"
"다. _이름 바인딩_은 엔티티 선언이 해당 엔티티와 연관된 식별자 또는 레이블"
"을 도입할 때입니다. [경로](paths.md), 식별자 및 레이블은 엔티티를 참조하는 "
"데 사용됩니다."

#: src/glossary.md:160
msgid ""
"[_Name resolution_](names/name-resolution.md) is the compile-time process of "
"tying [paths](paths.md), [identifiers](identifiers.md), and [labels]"
"(tokens.md#lifetimes-and-loop-labels) to [entity](#entity) declarations."
msgstr ""
"[_이름 확인(Name resolution)_](names/name-resolution.md)은 컴파일 타임에 [경로](paths.md), "
"[식별자](identifiers.md), [레이블](tokens.md#lifetimes-and-loop-labels)을 "
"[엔티티](#entity) 선언에 연결하는 프로세스입니다."

#: src/glossary.md:163
msgid "Namespace"
msgstr "네임스페이스 (Namespace)"

#: src/glossary.md:165
msgid ""
"A _namespace_ is a logical grouping of declared [names](#name) based on the "
"kind of [entity](#entity) the name refers to. Namespaces allow the "
"occurrence of a name in one namespace to not conflict with the same name in "
"another namespace."
msgstr ""
"_네임스페이스_는 이름이 참조하는 [엔티티](#entity)의 종류에 따른 선언된 [이름](#name)들의 "
"논리적 그룹화입니다. 네임스페이스를 통해 한 네임스페이스에 있는 이름이 다른 "
"네임스페이스에 있는 동일한 이름과 충돌하지 않도록 할 수 있습니다."

#: src/glossary.md:170
msgid ""
"Within a namespace, names are organized in a hierarchy, where each level of "
"the hierarchy has its own collection of named entities."
msgstr ""
"네임스페이스 내에서 이름은 계층 구조로 조직되며, 계층 구조의 각 레벨은 "
"자신만의 명명된 엔티티 컬렉션을 가집니다."

#: src/glossary.md:173
msgid "Nominal types"
msgstr "공칭 타입 (Nominal types)"

#: src/glossary.md:175
msgid ""
"Types that can be referred to by a path directly. Specifically [enums](items/"
"enumerations.md), [structs](items/structs.md), [unions](items/unions.md), "
"and [trait object types](types/trait-object.md)."
msgstr ""
"경로를 통해 직접 참조할 수 있는 타입입니다. 구체적으로는 [열거형](items/enumerations.md), "
"[구조체](items/structs.md), [유니온](items/unions.md), "
"그리고 [트레잇 객체 타입](types/trait-object.md)을 의미합니다."

#: src/glossary.md:178
msgid "Dyn-compatible traits"
msgstr "Dyn 호환 트레잇 (Dyn-compatible traits)"

#: src/glossary.md:180
msgid ""
"[Traits](items/traits.md) that can be used in [trait object types](types/"
"trait-object.md) (`dyn Trait`). Only traits that follow specific [rules]"
"(items/traits.md#dyn-compatibility) are _dyn compatible_."
msgstr ""
"[트레잇 객체 타입](types/trait-object.md) (`dyn Trait`)에서 사용될 수 있는 [트레잇](items/traits.md)입니다. "
"특정한 [규칙](items/traits.md#dyn-compatibility)을 따르는 트레잇만이 _dyn 호환_됩니다."

#: src/glossary.md:183
msgid "These were formerly known as _object safe_ traits."
msgstr "이들은 이전에 _객체 안전한(object safe)_ 트레잇으로 알려져 있었습니다."

#: src/glossary.md:185
msgid "Path"
msgstr "경로 (Path)"

#: src/glossary.md:187
msgid ""
"A [_path_](paths.md) is a sequence of one or more path segments used to "
"refer to an [entity](#entity) in the current scope or other levels of a "
"[namespace](#namespace) hierarchy."
msgstr ""
"[_경로_](paths.md)는 현재 스코프나 다른 레벨의 [네임스페이스](#namespace) 계층 구조에 있는 "
"[엔티티](#entity)를 참조하기 위해 사용되는 하나 이상의 경로 세그먼트 시퀀스입니다."

#: src/glossary.md:191
msgid "Prelude"
msgstr "프렐류드 (Prelude)"

#: src/glossary.md:193
msgid ""
"Prelude, or The Rust Prelude, is a small collection of items - mostly traits "
"- that are imported into every module of every crate. The traits in the "
"prelude are pervasive."
msgstr ""
"프렐류드(또는 러스트 프렐류드)는 모든 크레이트의 모든 모듈로 임포트되는 "
"아이템들(주로 트레잇)의 작은 모음입니다. 프렐류드에 포함된 트레잇들은 어디에서나 사용됩니다."

#: src/glossary.md:198
msgid ""
"A [_scope_](names/scopes.md) is the region of source text where a named "
"[entity](#entity) may be referenced with that name."
msgstr ""
"[_스코프_](names/scopes.md)는 명명된 [엔티티](#entity)가 해당 이름으로 참조될 수 있는 "
"소스 텍스트의 영역입니다."

#: src/glossary.md:201
msgid "Scrutinee"
msgstr "검사 대상 (Scrutinee)"

#: src/glossary.md:203
msgid ""
"A scrutinee is the expression that is matched on in `match` expressions and "
"similar pattern matching constructs. For example, in `match x { A => 1, B => "
"2 }`, the expression `x` is the scrutinee."
msgstr ""
"검사 대상(scrutinee)은 `match` 표현식이나 유사한 패턴 매칭 구문에서 "
"매칭의 대상이 되는 표현식입니다. 예를 들어, `match x { A => 1, B => 2 }`에서 "
"표현식 `x`가 검사 대상입니다."

#: src/glossary.md:207
msgid "Size"
msgstr "크기 (Size)"

#: src/glossary.md:209
msgid "The size of a value has two definitions."
msgstr "값의 크기에는 두 가지 정의가 있습니다."

#: src/glossary.md:211
msgid ""
"The first is that it is how much memory must be allocated to store that "
"value."
msgstr "첫 번째는 해당 값을 저장하기 위해 얼마나 많은 메모리가 할당되어야 하는가입니다."

#: src/glossary.md:213
msgid ""
"The second is that it is the offset in bytes between successive elements in "
"an array with that item type."
msgstr "두 번째는 해당 아이템 타입을 가진 배열에서 연속된 요소들 사이의 바이트 단위 오프셋입니다."

#: src/glossary.md:216
msgid ""
"It is a multiple of the alignment, including zero. The size can change "
"depending on compiler version (as new optimizations are made) and target "
"platform (similar to how `usize` varies per-platform)."
msgstr ""
"이는 0을 포함하여 정렬의 배수입니다. 크기는 컴파일러 버전(새로운 최적화가 도입됨에 따라)이나 "
"타겟 플랫폼(`usize`가 플랫폼마다 다른 것과 마찬가지)에 따라 달라질 수 있습니다."

#: src/glossary.md:220
msgid "[More](type-layout.md#size-and-alignment)."
msgstr "[자세히](type-layout.md#size-and-alignment)."

#: src/glossary.md:222
msgid "Slice"
msgstr "슬라이스 (Slice)"

#: src/glossary.md:224
msgid ""
"A slice is dynamically-sized view into a contiguous sequence, written as "
"`[T]`."
msgstr "슬라이스는 연속된 시퀀스에 대한 동적 크기 뷰(view)이며, `[T]`로 작성됩니다."

#: src/glossary.md:226
msgid ""
"It is often seen in its borrowed forms, either mutable or shared. The shared "
"slice type is `&[T]`, while the mutable slice type is `&mut [T]`, where `T` "
"represents the element type."
msgstr ""
"주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 슬라이스 타입은 `&[T]`이며, "
"가변 슬라이스 타입은 `&mut [T]`입니다. 여기서 `T`는 요소의 타입을 나타냅니다."

#: src/glossary.md:230
msgid "Statement"
msgstr "구문 (Statement)"

#: src/glossary.md:232
msgid ""
"A statement is the smallest standalone element of a programming language "
"that commands a computer to perform an action."
msgstr "구문은 컴퓨터에 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립 요소입니다."

#: src/glossary.md:235
msgid "String literal"
msgstr "문자열 리터럴 (String literal)"

#: src/glossary.md:237
msgid ""
"A string literal is a string stored directly in the final binary, and so "
"will be valid for the `'static` duration."
msgstr "문자열 리터럴은 최종 바이너리에 직접 저장되는 문자열이며, 따라서 `'static` 기간 동안 유효합니다."

#: src/glossary.md:240
msgid "Its type is `'static` duration borrowed string slice, `&'static str`."
msgstr "그 타입은 `'static` 기간의 차용된 문자열 슬라이스인 `&'static str`입니다."

#: src/glossary.md:242
msgid "String slice"
msgstr "문자열 슬라이스 (String slice)"

#: src/glossary.md:244
msgid ""
"A string slice is the most primitive string type in Rust, written as `str`. "
"It is often seen in its borrowed forms, either mutable or shared. The shared "
"string slice type is `&str`, while the mutable string slice type is `&mut "
"str`."
msgstr ""
"문자열 슬라이스는 러스트에서 가장 기본적인 문자열 타입으로, `str`로 작성됩니다. "
"주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 문자열 슬라이스 타입은 `&str`이며, "
"가변 문자열 슬라이스 타입은 `&mut str`입니다."

#: src/glossary.md:248
msgid "Strings slices are always valid UTF-8."
msgstr "문자열 슬라이스는 항상 유효한 UTF-8입니다."

#: src/glossary.md:250
msgid "Trait"
msgstr "트레잇 (Trait)"

#: src/glossary.md:252
msgid ""
"A trait is a language item that is used for describing the functionalities a "
"type must provide. It allows a type to make certain promises about its "
"behavior."
msgstr ""
"트레잇은 타입이 제공해야 하는 기능을 설명하는 데 사용되는 언어 아이템입니다. "
"이를 통해 타입은 자신의 동작에 대해 특정한 약속을 할 수 있습니다."

#: src/glossary.md:255
msgid ""
"Generic functions and generic structs can use traits to constrain, or bound, "
"the types they accept."
msgstr ""
"제네릭 함수와 제네릭 구조체는 트레잇을 사용하여 받아들이는 타입을 제한하거나 바인딩(bound)할 수 있습니다."

#: src/glossary.md:257
msgid "Turbofish"
msgstr "터보피쉬 (Turbofish)"

#: src/glossary.md:259
msgid ""
"Paths with generic parameters in expressions must prefix the opening "
"brackets with a `::`. Combined with the angular brackets for generics, this "
"looks like a fish `::<>`. As such, this syntax is colloquially referred to "
"as turbofish syntax."
msgstr ""
"표현식에서 제네릭 파라미터를 포함하는 경로는 여는 괄호 앞에 `::`를 붙여야 합니다. "
"제네릭을 위한 화살괄호와 결합하면 `::<>`와 같이 물고기처럼 보입니다. "
"이 때문에 이 구문은 구어체로 터보피쉬 구문이라고 불립니다."

#: src/glossary.md:270
msgid ""
"This `::` prefix is required to disambiguate generic paths with multiple "
"comparisons in a comma-separate list. See [the bastion of the turbofish]"
"(https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-"
"the-turbofish.rs) for an example where not having the prefix would be "
"ambiguous."
msgstr ""
"이 `::` 접두사는 쉼표로 구분된 목록에서 여러 비교 연산이 포함된 제네릭 경로의 "
"모호성을 해결하기 위해 필요합니다. 접두사가 없을 때 모호해질 수 있는 예시는 "
"[the bastion of the turbofish](https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs)를 "
"참조하십시오."

#: src/glossary.md:273
msgid "Uncovered type"
msgstr "비피복 타입 (Uncovered type)"

#: src/glossary.md:275
msgid ""
"A type which does not appear as an argument to another type. For example, "
"`T` is uncovered, but the `T` in `Vec<T>` is covered. This is only relevant "
"for type arguments."
msgstr ""
"다른 타입의 인자로 나타나지 않는 타입입니다. 예를 들어, `T`는 피복되지 않았지만(uncovered), "
"`Vec<T>`에서의 `T`는 피복되었습니다(covered). 이는 타입 인자에서만 의미가 있습니다."

#: src/glossary.md:279
msgid "Undefined behavior"
msgstr "정의되지 않은 동작 (Undefined behavior)"

#: src/glossary.md:281
msgid ""
"Compile-time or run-time behavior that is not specified. This may result in, "
"but is not limited to: process termination or corruption; improper, "
"incorrect, or unintended computation; or platform-specific results. [More]"
"(behavior-considered-undefined.md)."
msgstr ""
"명시되지 않은 컴파일 타임 또는 런타임 동작입니다. 이는 프로세스 종료나 손상, "
"부적절하거나 부정확하거나 의도하지 않은 계산, 또는 플랫폼별 결과 등을 초래할 수 있으나 "
"이에 국한되지 않습니다. [자세히](behavior-considered-undefined.md)."

#: src/glossary.md:286
msgid "Uninhabited"
msgstr "비거주 (Uninhabited)"

#: src/glossary.md:288
msgid ""
"A type is uninhabited if it has no constructors and therefore can never be "
"instantiated. An uninhabited type is \"empty\" in the sense that there are "
"no values of the type. The canonical example of an uninhabited type is the "
"[never type](types/never.md) `!`, or an enum with no variants `enum Never { }"
"`. Opposite of [Inhabited](#inhabited)."
msgstr ""
"생성자가 없어서 인스턴스화할 수 없는 타입입니다. 비거주 타입은 해당 타입의 값이 없다는 "
"의미에서 \"비어 있음\"을 뜻합니다. 비거주 타입의 대표적인 예로는 [never 타입](types/never.md) `!` "
"또는 변형이 없는 열거형인 `enum Never { }`가 있습니다. [거주(Inhabited)](#inhabited)의 반대말입니다."
