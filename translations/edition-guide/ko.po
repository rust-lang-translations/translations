msgid ""
msgstr ""
"Project-Id-Version: The Rust Edition Guide\n"
"POT-Creation-Date: 2025-10-17T17:47:24+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-17T17:47:24+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "The Rust Edition Guide"
msgstr "Rust 에디션 가이드"

#: src/SUMMARY.md:3 src/introduction.md:1
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:5 src/SUMMARY.md:7
msgid "What are editions?"
msgstr "에디션이란 무엇인가요?"

#: src/SUMMARY.md:8 src/editions/creating-a-new-project.md:1
msgid "Creating a new project"
msgstr "새 프로젝트 생성하기"

#: src/SUMMARY.md:9
#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:1
msgid "Transitioning an existing project to a new edition"
msgstr "기존 프로젝트를 새 에디션으로 전환하기"

#: src/SUMMARY.md:10
msgid "Advanced migrations"
msgstr "고급 마이그레이션"

#: src/SUMMARY.md:12 src/SUMMARY.md:14 src/rust-2015/index.md:1
msgid "Rust 2015"
msgstr "Rust 2015"

#: src/SUMMARY.md:16 src/SUMMARY.md:18 src/rust-2018/index.md:1
msgid "Rust 2018"
msgstr "Rust 2018"

#: src/SUMMARY.md:19 src/rust-2018/path-changes.md:1
msgid "Path and module system changes"
msgstr "경로 및 모듈 시스템 변경사항"

#: src/SUMMARY.md:20 src/rust-2018/trait-fn-parameters.md:1
msgid "Anonymous trait function parameters deprecated"
msgstr "익명 트레이트 함수 매개변수 사용 중단"

#: src/SUMMARY.md:21 src/rust-2018/new-keywords.md:1
msgid "New keywords"
msgstr "새로운 키워드"

#: src/SUMMARY.md:22 src/rust-2018/tyvar-behind-raw-pointer.md:1
msgid "Method dispatch for raw pointers to inference variables"
msgstr "추론 변수에 대한 원시 포인터의 메서드 디스패치"

#: src/SUMMARY.md:23 src/rust-2018/cargo.md:1
msgid "Cargo changes"
msgstr "Cargo 변경사항"

#: src/SUMMARY.md:25 src/SUMMARY.md:27 src/rust-2021/index.md:1
msgid "Rust 2021"
msgstr "Rust 2021"

#: src/SUMMARY.md:28 src/rust-2021/prelude.md:1
msgid "Additions to the prelude"
msgstr "프렐루드에 추가된 항목"

#: src/SUMMARY.md:29 src/rust-2021/default-cargo-resolver.md:1
msgid "Default Cargo feature resolver"
msgstr "기본 Cargo 기능 해결자"

#: src/SUMMARY.md:30 src/rust-2021/IntoIterator-for-arrays.md:1
msgid "IntoIterator for arrays"
msgstr "배열을 위한 IntoIterator"

#: src/SUMMARY.md:31 src/rust-2021/disjoint-capture-in-closures.md:1
msgid "Disjoint capture in closures"
msgstr "클로저에서의 분리된 캡처"

#: src/SUMMARY.md:32 src/rust-2021/panic-macro-consistency.md:1
msgid "Panic macro consistency"
msgstr "Panic 매크로 일관성"

#: src/SUMMARY.md:33 src/SUMMARY.md:55 src/rust-2021/reserved-syntax.md:1
#: src/rust-2024/reserved-syntax.md:1
msgid "Reserved syntax"
msgstr "예약된 구문"

#: src/SUMMARY.md:34 src/rust-2021/raw-lifetimes.md:1
msgid "Raw lifetimes"
msgstr "원시 라이프타임"

#: src/SUMMARY.md:35 src/rust-2021/warnings-promoted-to-error.md:1
msgid "Warnings promoted to errors"
msgstr "오류로 승격된 경고"

#: src/SUMMARY.md:36 src/rust-2021/or-patterns-macro-rules.md:1
msgid "Or patterns in macro-rules"
msgstr "매크로 규칙에서의 OR 패턴"

#: src/SUMMARY.md:37 src/rust-2021/c-string-literals.md:1
msgid "C-string literals"
msgstr "C 문자열 리터럴"

#: src/SUMMARY.md:39 src/SUMMARY.md:41 src/rust-2024/index.md:1
msgid "Rust 2024"
msgstr "Rust 2024"

#: src/SUMMARY.md:42 src/rust-2024/language.md:1
msgid "Language"
msgstr "언어"

#: src/SUMMARY.md:43 src/rust-2024/rpit-lifetime-capture.md:1
msgid "RPIT lifetime capture rules"
msgstr "RPIT 라이프타임 캡처 규칙"

#: src/SUMMARY.md:44 src/rust-2024/temporary-if-let-scope.md:1
msgid "`if let` temporary scope"
msgstr "`if let` 임시 스코프"

#: src/SUMMARY.md:45 src/rust-2024/temporary-tail-expr-scope.md:1
msgid "Tail expression temporary scope"
msgstr "꼬리 표현식 임시 스코프"

#: src/SUMMARY.md:46 src/rust-2024/match-ergonomics.md:1
msgid "Match ergonomics reservations"
msgstr "매치 인체공학 예약"

#: src/SUMMARY.md:47 src/rust-2024/unsafe-extern.md:1
msgid "Unsafe `extern` blocks"
msgstr "안전하지 않은 `extern` 블록"

#: src/SUMMARY.md:48 src/rust-2024/unsafe-attributes.md:1
msgid "Unsafe attributes"
msgstr "안전하지 않은 속성"

#: src/SUMMARY.md:49
msgid "`unsafe_op_in_unsafe_fn` warning"
msgstr "`unsafe_op_in_unsafe_fn` 경고"

#: src/SUMMARY.md:50
msgid "Disallow references to `static mut`"
msgstr "`static mut`에 대한 참조 금지"

#: src/SUMMARY.md:51 src/rust-2024/never-type-fallback.md:1
msgid "Never type fallback change"
msgstr "Never 타입 폴백 변경"

#: src/SUMMARY.md:52
msgid "Macro fragment specifiers"
msgstr "매크로 프래그먼트 지정자"

#: src/SUMMARY.md:53 src/rust-2024/missing-macro-fragment-specifiers.md:1
msgid "Missing macro fragment specifiers"
msgstr "누락된 매크로 프래그먼트 지정자"

#: src/SUMMARY.md:54 src/rust-2024/gen-keyword.md:1
msgid "`gen` keyword"
msgstr "`gen` 키워드"

#: src/SUMMARY.md:56 src/rust-2024/standard-library.md:1
msgid "Standard library"
msgstr "표준 라이브러리"

#: src/SUMMARY.md:57 src/rust-2024/prelude.md:1
msgid "Changes to the prelude"
msgstr "프렐루드 변경사항"

#: src/SUMMARY.md:58 src/rust-2024/intoiterator-box-slice.md:1
msgid "Add `IntoIterator` for `Box<[T]>`"
msgstr "`Box<[T]>`에 대한 `IntoIterator` 추가"

#: src/SUMMARY.md:59
msgid "Newly unsafe functions"
msgstr "새로 안전하지 않은 함수"

#: src/SUMMARY.md:60 src/rust-2024/cargo.md:1
msgid "Cargo"
msgstr "Cargo"

#: src/SUMMARY.md:61 src/rust-2024/cargo-resolver.md:1
msgid "Cargo: Rust-version aware resolver"
msgstr "Cargo: Rust 버전 인식 해결자"

#: src/SUMMARY.md:62 src/rust-2024/cargo-table-key-names.md:1
msgid "Cargo: Table and key name consistency"
msgstr "Cargo: 테이블 및 키 이름 일관성"

#: src/SUMMARY.md:63 src/rust-2024/cargo-inherited-default-features.md:1
msgid "Cargo: Reject unused inherited default-features"
msgstr "Cargo: 사용되지 않는 상속된 기본 기능 거부"

#: src/SUMMARY.md:64 src/rust-2024/rustdoc.md:1
msgid "Rustdoc"
msgstr "Rustdoc"

#: src/SUMMARY.md:65 src/rust-2024/rustdoc-doctests.md:1
msgid "Rustdoc combined tests"
msgstr "Rustdoc 통합 테스트"

#: src/SUMMARY.md:66 src/rust-2024/rustdoc-nested-includes.md:1
msgid "Rustdoc nested `include!` change"
msgstr "Rustdoc 중첩 `include!` 변경"

#: src/SUMMARY.md:67 src/rust-2024/rustfmt.md:1
msgid "Rustfmt"
msgstr "Rustfmt"

#: src/SUMMARY.md:68 src/rust-2024/rustfmt-style-edition.md:1
msgid "Rustfmt: Style edition"
msgstr "Rustfmt: 스타일 에디션"

#: src/SUMMARY.md:69 src/rust-2024/rustfmt-formatting-fixes.md:1
msgid "Rustfmt: Formatting fixes"
msgstr "Rustfmt: 포매팅 수정"

#: src/SUMMARY.md:70 src/rust-2024/rustfmt-raw-identifier-sorting.md:1
msgid "Rustfmt: Raw identifier sorting"
msgstr "Rustfmt: 원시 식별자 정렬"

#: src/SUMMARY.md:71 src/rust-2024/rustfmt-version-sorting.md:1
msgid "Rustfmt: Version sorting"
msgstr "Rustfmt: 버전 정렬"

#: src/introduction.md:3
msgid ""
"Welcome to The Rust Edition Guide! \"Editions\" are Rust's way of "
"introducing changes into the language that would not otherwise be backwards "
"compatible."
msgstr "Rust 에디션 가이드에 오신 것을 환영합니다! \"에디션\"은 하위 호환성을 깨뜨릴 수 있는 변경 사항을 언어에 도입하는 Rust의 방식입니다."

#: src/introduction.md:7
msgid "In this guide, we'll discuss:"
msgstr "이 가이드에서는 다음에 대해 설명합니다."

#: src/introduction.md:9
msgid "What editions are"
msgstr "에디션이란 무엇인가"

#: src/introduction.md:10
msgid "Which changes are contained in each edition"
msgstr "각 에디션에 포함된 변경 사항"

#: src/introduction.md:11
msgid "How to migrate your code from one edition to another"
msgstr "한 에디션에서 다른 에디션으로 코드를 마이그레이션하는 방법"

#: src/editions/index.md:1
msgid "What are Editions?"
msgstr "에디션이란 무엇인가요?"

#: src/editions/index.md:3
msgid ""
"In May 2015, the [release of Rust 1.0](https://blog.rust-lang.org/2015/05/15/"
"Rust-1.0.html) established \"[stability without stagnation](https://"
"blog.rust-lang.org/2014/10/30/Stability.html)\" as a core Rust axiom. Since "
"then, Rust has committed to a pivotal rule: once a feature is [released "
"through stable](https://doc.rust-lang.org/book/appendix-07-nightly-"
"rust.html), contributors will continue to support that feature for all "
"future releases."
msgstr "2015년 5월, [Rust 1.0 릴리스](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html)는 \"[정체 없는 안정성](https://blog.rust-lang.org/2014/10/30/Stability.html)\"을 핵심 Rust 원칙으로 확립했습니다. 그 이후로 Rust는 중요한 규칙을 약속했습니다. 기능이 [안정 버전을 통해 릴리스되면](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html) 기여자는 향후 모든 릴리스에서 해당 기능을 계속 지원할 것입니다."

#: src/editions/index.md:5
msgid ""
"However, there are times when it's useful to make backwards-incompatible "
"changes to the language. A common example is the introduction of a new "
"keyword. For instance, early versions of Rust didn't feature the `async` and "
"`await` keywords."
msgstr "그러나 언어에 하위 호환되지 않는 변경을 하는 것이 유용할 때가 있습니다. 일반적인 예는 새 키워드를 도입하는 것입니다. 예를 들어, 초기 버전의 Rust에는 `async` 및 `await` 키워드가 없었습니다."

#: src/editions/index.md:7
msgid ""
"If Rust had suddenly introduced these new keywords, some code would have "
"broken: `let async = 1;` would no longer work."
msgstr "만약 Rust가 갑자기 이러한 새 키워드를 도입했다면 일부 코드가 깨졌을 것입니다. `let async = 1;`은 더 이상 작동하지 않을 것입니다."

#: src/editions/index.md:9
msgid ""
"Rust uses **editions** to solve this problem. When there are backwards-"
"incompatible changes, they are pushed into the next edition. Since editions "
"are opt-in, existing crates won't use the changes unless they explicitly "
"migrate into the new edition. For example, the latest version of Rust "
"doesn't treat `async` as a keyword unless edition 2018 or later is chosen."
msgstr "Rust는 이 문제를 해결하기 위해 **에디션**을 사용합니다. 하위 호환되지 않는 변경 사항이 있을 때, 다음 에디션으로 푸시됩니다. 에디션은 옵트인이므로, 기존 크레이트는 명시적으로 새 에디션으로 마이그레이션하지 않는 한 변경 사항을 사용하지 않습니다. 예를 들어, 최신 버전의 Rust는 2018 에디션 이상을 선택하지 않는 한 `async`를 키워드로 취급하지 않습니다."

#: src/editions/index.md:11
msgid ""
"Each crate chooses its edition [within its `Cargo.toml` file](https://"
"doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field). When "
"creating a new crate with Cargo, it will automatically select the newest "
"stable edition."
msgstr "각 크레이트는 [`Cargo.toml` 파일 내에서](https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field) 에디션을 선택합니다. Cargo로 새 크레이트를 만들 때, 자동으로 최신 안정 에디션을 선택합니다."

#: src/editions/index.md:13
msgid "Editions do not split the ecosystem"
msgstr "에디션은 생태계를 분할하지 않습니다"

#: src/editions/index.md:15
msgid ""
"When creating editions, there is one most consequential rule: crates in one "
"edition **must** seamlessly interoperate with those compiled with other "
"editions."
msgstr "에디션을 만들 때 가장 중요한 규칙이 하나 있습니다. 한 에디션의 크레이트는 다른 에디션으로 컴파일된 크레이트와 **반드시** 원활하게 상호 운용되어야 합니다."

#: src/editions/index.md:17
msgid ""
"In other words, each crate can decide when to migrate to a new edition "
"independently. This decision is 'private' - it won't affect other crates in "
"the ecosystem."
msgstr "즉, 각 크레이트는 독립적으로 새 에디션으로 마이그레이션할 시기를 결정할 수 있습니다. 이 결정은 '비공개'이며 생태계의 다른 크레이트에 영향을 미치지 않습니다."

#: src/editions/index.md:19
msgid ""
"For Rust, this required compatibility implies some limits on the kinds of "
"changes that can be featured in an edition. As a result, changes found in "
"new Rust editions tend to be 'skin deep'. All Rust code - regardless of "
"edition - will ultimately compile down to the same internal representation "
"within the compiler."
msgstr "Rust의 경우, 이러한 필수 호환성은 에디션에 포함될 수 있는 변경 종류에 몇 가지 제한을 의미합니다. 결과적으로, 새로운 Rust 에디션에서 발견되는 변경 사항은 '피상적인' 경향이 있습니다. 에디션에 관계없이 모든 Rust 코드는 궁극적으로 컴파일러 내에서 동일한 내부 표현으로 컴파일됩니다."

#: src/editions/index.md:21
msgid "Edition migration is easy and largely automated"
msgstr "에디션 마이그레이션은 쉽고 대부분 자동화됩니다"

#: src/editions/index.md:23
msgid ""
"Rust aims to make upgrading to a new edition an easy process. When a new "
"edition releases, crate authors may use [automatic migration tooling within "
"`cargo`](https://doc.rust-lang.org/cargo/commands/cargo-fix.html) to "
"migrate. Cargo will then make minor changes to the code to make it "
"compatible with the new version."
msgstr "Rust는 새 에디션으로의 업그레이드를 쉬운 프로세스로 만드는 것을 목표로 합니다. 새 에디션이 출시되면 크레이트 작성자는 [`cargo` 내의 자동 마이그레이션 도구](https://doc.rust-lang.org/cargo/commands/cargo-fix.html)를 사용하여 마이그레이션할 수 있습니다. 그러면 Cargo는 새 버전과 호환되도록 코드에 사소한 변경을 합니다."

#: src/editions/index.md:25
msgid ""
"For example, when migrating to Rust 2018, anything named `async` will now "
"use the equivalent [raw identifier syntax](https://doc.rust-lang.org/rust-by-"
"example/compatibility/raw_identifiers.html): `r#async`."
msgstr "예를 들어, Rust 2018로 마이그레이션할 때 `async`라는 이름의 모든 것은 이제 동등한 [원시 식별자 구문](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html)인 `r#async`를 사용합니다."

#: src/editions/index.md:27
msgid ""
"Cargo's automatic migrations aren't perfect: there may still be corner cases "
"where manual changes are required. It aims to avoid changes to semantics "
"that could affect the correctness or performance of the code."
msgstr "Cargo의 자동 마이그레이션은 완벽하지 않습니다. 수동 변경이 필요한 예외적인 경우가 여전히 있을 수 있습니다. 코드의 정확성이나 성능에 영향을 줄 수 있는 의미 체계 변경을 피하는 것을 목표로 합니다."

#: src/editions/index.md:29
msgid "What this guide covers"
msgstr "이 가이드에서 다루는 내용"

#: src/editions/index.md:31
msgid ""
"In addition to tooling, this Rust Edition Guide also covers the changes that "
"are part of each edition. It describes each change and links to additional "
"details, if available. It also covers corner cases or tricky details crate "
"authors should be aware of."
msgstr "도구 외에도 이 Rust 에디션 가이드는 각 에디션의 일부인 변경 사항도 다룹니다. 각 변경 사항을 설명하고 가능한 경우 추가 세부 정보에 대한 링크를 제공합니다. 또한 크레이트 작성자가 알아야 할 예외적인 경우나 까다로운 세부 정보도 다룹니다."

#: src/editions/index.md:33
msgid "Crate authors should find:"
msgstr "크레이트 작성자는 다음을 찾아야 합니다."

#: src/editions/index.md:35
msgid "An overview of editions"
msgstr "에디션 개요"

#: src/editions/index.md:36
msgid "A migration guide for specific editions"
msgstr "특정 에디션에 대한 마이그레이션 가이드"

#: src/editions/index.md:37
msgid "A quick troubleshooting reference when automated tooling isn't working."
msgstr "자동화된 도구가 작동하지 않을 때를 위한 빠른 문제 해결 참조."

#: src/editions/creating-a-new-project.md:3
msgid ""
"A new project created with Cargo is configured to use the latest edition by "
"default:"
msgstr "Cargo로 생성된 새 프로젝트는 기본적으로 최신 에디션을 사용하도록 구성됩니다."

#: src/editions/creating-a-new-project.md:6
msgid ""
"```console\n"
"$ cargo new foo\n"
"    Creating binary (application) `foo` package\n"
"note: see more `Cargo.toml` keys and their definitions at https://doc.rust-"
"lang.org/cargo/reference/manifest.html\n"
"$ cat foo/Cargo.toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2024\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr "```console
$ cargo new foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2024"

[dependencies]
```"

#: src/editions/creating-a-new-project.md:19
msgid ""
"That `edition = \"2024\"` setting configures your package to be built using "
"the Rust 2024 edition. No further configuration needed!"
msgstr "`edition = "2024"` 설정은 패키지가 Rust 2024 에디션을 사용하여 빌드되도록 구성합니다. 추가 구성이 필요하지 않습니다!"

#: src/editions/creating-a-new-project.md:22
msgid ""
"You can use the `--edition <YEAR>` option of `cargo new` to create the "
"project using some specific edition. For example, creating a new project to "
"use the Rust 2018 edition could be done like this:"
msgstr "`cargo new`의 `--edition <YEAR>` 옵션을 사용하여 특정 에디션을 사용하는 프로젝트를 만들 수 있습니다. 예를 들어, Rust 2018 에디션을 사용하는 새 프로젝트를 만드는 것은 다음과 같이 할 수 있습니다."

#: src/editions/creating-a-new-project.md:26
msgid ""
"```console\n"
"$ cargo new --edition 2018 foo\n"
"    Creating binary (application) `foo` package\n"
"note: see more `Cargo.toml` keys and their definitions at https://doc.rust-"
"lang.org/cargo/reference/manifest.html\n"
"$ cat foo/Cargo.toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr "```console
$ cargo new --edition 2018 foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2018"

[dependencies]
```"

#: src/editions/creating-a-new-project.md:39
msgid ""
"Don't worry about accidentally using an invalid year for the edition; the "
"`cargo new` invocation will not accept an invalid edition year value:"
msgstr "실수로 에디션에 유효하지 않은 연도를 사용하는 것에 대해 걱정하지 마십시오. `cargo new` 호출은 유효하지 않은 에디션 연도 값을 허용하지 않습니다."

#: src/editions/creating-a-new-project.md:52
msgid ""
"You can change the value of the `edition` key by simply editing the "
"`Cargo.toml` file. For example, to cause your package to be built using the "
"Rust 2015 edition, you would set the key as in the following example:"
msgstr "`Cargo.toml` 파일을 편집하여 `edition` 키의 값을 변경할 수 있습니다. 예를 들어, 패키지가 Rust 2015 에디션을 사용하여 빌드되도록 하려면 다음 예와 같이 키를 설정합니다."

#: src/editions/creating-a-new-project.md:56
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2015\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr "```toml
[package]
name = "foo"
version = "0.1.0"
edition = "2015"

[dependencies]
```"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:3
msgid ""
"Rust includes tooling to automatically transition a project from one edition "
"to the next. It will update your source code so that it is compatible with "
"the next edition. Briefly, the steps to update to the next edition are:"
msgstr "Rust에는 프로젝트를 한 에디션에서 다음 에디션으로 자동으로 전환하는 도구가 포함되어 있습니다. 소스 코드를 다음 에디션과 호환되도록 업데이트합니다. 간단히 말해, 다음 에디션으로 업데이트하는 단계는 다음과 같습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:7
msgid "Run `cargo update` to update your dependencies to the latest versions."
msgstr "`cargo update`를 실행하여 종속성을 최신 버전으로 업데이트하십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:8
msgid "Run `cargo fix --edition`"
msgstr "`cargo fix --edition` 실행"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:9
msgid ""
"Edit `Cargo.toml` and set the `edition` field to the next edition, for "
"example `edition = \"2024\"`"
msgstr "`Cargo.toml`을 편집하고 `edition` 필드를 다음 에디션으로 설정합니다(예: `edition = "2024"`)."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:10
msgid "Run `cargo build` or `cargo test` to verify the fixes worked."
msgstr "`cargo build` 또는 `cargo test`를 실행하여 수정 사항이 작동하는지 확인합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:11
msgid "Run `cargo fmt` to reformat your project."
msgstr "`cargo fmt`를 실행하여 프로젝트를 다시 포맷합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:13
msgid ""
"The following sections dig into the details of these steps, and some of the "
"issues you may encounter along the way."
msgstr "다음 섹션에서는 이러한 단계의 세부 정보와 그 과정에서 발생할 수 있는 몇 가지 문제에 대해 자세히 설명합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:15
msgid ""
"It's our intention that the migration to new editions is as smooth an "
"experience as possible. If it's difficult for you to upgrade to the latest "
"edition, we consider that a bug. If you run into problems with this process, "
"please [file a bug report](https://github.com/rust-lang/rust/issues/new/"
"choose). Thank you!"
msgstr "새 에디션으로의 마이그레이션이 가능한 한 순조로운 경험이 되도록 하는 것이 저희의 의도입니다. 최신 에디션으로 업그레이드하기 어려운 경우 버그로 간주합니다. 이 프로세스에 문제가 발생하면 [버그 보고서를 제출](https://github.com/rust-lang/rust/issues/new/choose)해 주십시오. 감사합니다!"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:20
msgid "Starting the migration"
msgstr "마이그레이션 시작"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:22
msgid ""
"As an example, let's take a look at transitioning from the 2015 edition to "
"the 2018 edition. The steps are essentially the same when transitioning to "
"other editions like 2021."
msgstr "예를 들어, 2015 에디션에서 2018 에디션으로 전환하는 것을 살펴보겠습니다. 2021과 같은 다른 에디션으로 전환할 때도 단계는 기본적으로 동일합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:25
msgid "Imagine we have a crate that has this code in `src/lib.rs`:"
msgstr "`src/lib.rs`에 이 코드가 있는 크레이트가 있다고 상상해 보십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:33
msgid ""
"This code uses an anonymous parameter, that `i32`. This is [not supported in "
"Rust 2018](../rust-2018/trait-system/no-anon-params.md), and so this would "
"fail to compile. Let's get this code up to date!"
msgstr "이 코드는 익명 매개변수인 `i32`를 사용합니다. 이것은 [Rust 2018에서 지원되지 않으므로](../rust-2018/trait-system/no-anon-params.md) 컴파일에 실패합니다. 이 코드를 최신 상태로 만들어 봅시다!"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:37
msgid "Updating your dependencies"
msgstr "종속성 업데이트"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:39
msgid ""
"Before we get started, it is recommended to update your dependencies. Some "
"dependencies, particularly some proc-macros or dependencies that do build-"
"time code generation, may have compatibility issues with newer editions. New "
"releases may have been made since you last updated which may fix these "
"issues. Run the following:"
msgstr "시작하기 전에 종속성을 업데이트하는 것이 좋습니다. 일부 종속성, 특히 일부 proc-매크로 또는 빌드 타임 코드 생성을 수행하는 종속성은 최신 에디션과 호환성 문제가 있을 수 있습니다. 마지막으로 업데이트한 이후에 이러한 문제를 해결할 수 있는 새 릴리스가 만들어졌을 수 있습니다. 다음을 실행하십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:45
msgid ""
"After updating, you may want to run your tests to verify everything is "
"working. If you are using a source control tool such as `git`, you may want "
"to commit these changes separately to keep a logical separation of commits."
msgstr "업데이트 후 테스트를 실행하여 모든 것이 작동하는지 확인하는 것이 좋습니다. `git`과 같은 소스 제어 도구를 사용하는 경우 커밋의 논리적 분리를 유지하기 위해 이러한 변경 사항을 별도로 커밋할 수 있습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:47
msgid "Updating your code to be compatible with the new edition"
msgstr "새 에디션과 호환되도록 코드 업데이트"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:49
msgid ""
"Your code may or may not use features that are incompatible with the new "
"edition. In order to help transition to the next edition, Cargo includes the "
"[`cargo fix`](../../cargo/commands/cargo-fix.html) subcommand to "
"automatically update your source code. To start, let's run it:"
msgstr "코드가 새 에디션과 호환되지 않는 기능을 사용할 수도 있고 사용하지 않을 수도 있습니다. 다음 에디션으로의 전환을 돕기 위해 Cargo에는 소스 코드를 자동으로 업데이트하는 [`cargo fix`](../../cargo/commands/cargo-fix.html) 하위 명령이 포함되어 있습니다. 시작하려면 실행해 봅시다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:57
msgid ""
"This will check your code, and automatically fix any issues that it can. "
"Let's look at `src/lib.rs` again:"
msgstr "이렇게 하면 코드를 확인하고 가능한 모든 문제를 자동으로 수정합니다. `src/lib.rs`를 다시 살펴보겠습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:66
msgid ""
"It's re-written our code to introduce a parameter name for that `i32` value. "
"In this case, since it had no name, `cargo fix` will replace it with `_`, "
"which is conventional for unused variables."
msgstr "코드를 다시 작성하여 `i32` 값에 대한 매개변수 이름을 도입했습니다. 이 경우 이름이 없었기 때문에 `cargo fix`는 사용되지 않는 변수에 대한 관례인 `_`로 바꿉니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:70
msgid ""
"`cargo fix` can't always fix your code automatically. If `cargo fix` can't "
"fix something, it will print the warning that it cannot fix to the console. "
"If you see one of these warnings, you'll have to update your code manually. "
"See the [Advanced migration strategies](advanced-migrations.md) chapter for "
"more on working with the migration process, and read the chapters in this "
"guide which explain which changes are needed. If you have problems, please "
"seek help at the [user's forums](https://users.rust-lang.org/)."
msgstr "`cargo fix`가 항상 코드를 자동으로 수정할 수 있는 것은 아닙니다. `cargo fix`가 무언가를 수정할 수 없는 경우 수정할 수 없다는 경고를 콘솔에 인쇄합니다. 이러한 경고 중 하나가 표시되면 코드를 수동으로 업데이트해야 합니다. 마이그레이션 프로세스 작업에 대한 자세한 내용은 [고급 마이그레이션 전략](advanced-migrations.md) 장을 참조하고 필요한 변경 사항을 설명하는 이 가이드의 장을 읽으십시오. 문제가 있는 경우 [사용자 포럼](https://users.rust-lang.org/)에서 도움을 요청하십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:76
msgid "Enabling the new edition to use new features"
msgstr "새 기능을 사용하기 위해 새 에디션 활성화"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:78
msgid ""
"In order to use some new features, you must explicitly opt in to the new "
"edition. Once you're ready to continue, change your `Cargo.toml` to add the "
"new `edition` key/value pair. For example:"
msgstr "일부 새로운 기능을 사용하려면 새 에디션을 명시적으로 선택해야 합니다. 계속할 준비가 되면 `Cargo.toml`을 변경하여 새 `edition` 키/값 쌍을 추가하십시오. 예를 들어:"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:82
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"```"
msgstr "```toml
[package]
name = "foo"
version = "0.1.0"
edition = "2018"
```"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:89
msgid ""
"If there's no `edition` key, Cargo will default to Rust 2015. But in this "
"case, we've chosen `2018`, and so our code will compile with Rust 2018!"
msgstr "`edition` 키가 없으면 Cargo는 기본적으로 Rust 2015를 사용합니다. 하지만 이 경우 `2018`을 선택했으므로 코드가 Rust 2018로 컴파일됩니다!"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:92
msgid "Testing your code in the new edition"
msgstr "새 에디션에서 코드 테스트"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:94
msgid ""
"The next step is to test your project on the new edition. Run your project "
"tests to verify that everything still works, such as running [`cargo test`]("
"../../cargo/commands/cargo-test.html). If new warnings are issued, you may "
"want to consider running `cargo fix` again (without the `--edition` flag) to "
"apply any suggestions given by the compiler."
msgstr "다음 단계는 새 에디션에서 프로젝트를 테스트하는 것입니다. `cargo test`를 실행하는 것과 같이 프로젝트 테스트를 실행하여 모든 것이 여전히 작동하는지 확인하십시오. 새 경고가 발행되면 컴파일러에서 제공하는 제안을 적용하기 위해 `cargo fix`를 다시 실행( `--edition` 플래그 없이)하는 것을 고려할 수 있습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:98
msgid ""
"At this point, you may still need to do some manual changes. For example, "
"the automatic migration does not update doctests, and build-time code "
"generation or macros may need manual updating. See the [advanced migrations "
"chapter](advanced-migrations.md) for more information."
msgstr "이 시점에서 여전히 일부 수동 변경이 필요할 수 있습니다. 예를 들어, 자동 마이그레이션은 doctest를 업데이트하지 않으며 빌드 타임 코드 생성 또는 매크로는 수동 업데이트가 필요할 수 있습니다. 자세한 내용은 [고급 마이그레이션 장](advanced-migrations.md)을 참조하십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:100
msgid "Congrats! Your code is now valid in both Rust 2015 and Rust 2018!"
msgstr "축하합니다! 이제 코드가 Rust 2015와 Rust 2018 모두에서 유효합니다!"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:104
msgid "Reformatting with rustfmt"
msgstr "rustfmt로 다시 포맷하기"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:106
msgid ""
"If you use [rustfmt](https://github.com/rust-lang/rustfmt) to automatically "
"maintain formatting within your project, then you should consider "
"reformatting using the new formatting rules of the new edition."
msgstr "프로젝트 내에서 포맷을 자동으로 유지하기 위해 [rustfmt](https://github.com/rust-lang/rustfmt)를 사용하는 경우 새 에디션의 새 포맷 규칙을 사용하여 다시 포맷하는 것을 고려해야 합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:108
msgid ""
"Before reformatting, if you are using a source control tool such as `git`, "
"you may want to commit all the changes you have made up to this point before "
"taking this step. It can be useful to put formatting changes in a separate "
"commit, because then you can see which changes are just formatting versus "
"other code changes, and also possibly ignore the formatting changes in `git "
"blame`."
msgstr "다시 포맷하기 전에 `git`과 같은 소스 제어 도구를 사용하는 경우 이 단계를 수행하기 전에 지금까지 변경한 모든 내용을 커밋하는 것이 좋습니다. 포맷 변경 사항을 별도의 커밋에 넣는 것이 유용할 수 있습니다. 그러면 어떤 변경 사항이 단지 포맷인지 다른 코드 변경 사항인지 확인할 수 있고 `git blame`에서 포맷 변경 사항을 무시할 수도 있습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:114
msgid ""
"See the [style editions chapter](../rust-2024/rustfmt-style-edition.md) for "
"more information."
msgstr "자세한 내용은 [스타일 에디션 장](../rust-2024/rustfmt-style-edition.md)을 참조하십시오."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:119
msgid "Migrating to an unstable edition"
msgstr "불안정한 에디션으로 마이그레이션"

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:121
msgid ""
"After an edition is released, there is roughly a three year window before "
"the next edition. During that window, new features may be added to the next "
"edition, which will only be available on the [nightly channel](../../book/"
"appendix-07-nightly-rust.html). If you want to help test those new features "
"before they are stabilized, you can use the nightly channel to try them out."
msgstr "에디션이 출시된 후 다음 에디션까지는 대략 3년의 기간이 있습니다. 그 기간 동안 다음 에디션에 새로운 기능이 추가될 수 있으며, 이는 [nightly 채널](../../book/appendix-07-nightly-rust.html)에서만 사용할 수 있습니다. 안정화되기 전에 이러한 새로운 기능을 테스트하는 데 도움을 주고 싶다면 nightly 채널을 사용하여 사용해 볼 수 있습니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:125
msgid "The steps are roughly similar to the stable channel:"
msgstr "단계는 안정 채널과 거의 유사합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:127
msgid "Install the most recent nightly: `rustup update nightly`."
msgstr "최신 nightly 설치: `rustup update nightly`."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:128
msgid "Run `cargo +nightly fix --edition`."
msgstr "`cargo +nightly fix --edition` 실행."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:129
msgid ""
"Edit `Cargo.toml` and place `cargo-features = [\"edition20xx\"]` at the top "
"(above `[package]`), and change the edition field to say `edition = ""
"\"20xx\"` where `20xx` is the edition you are upgrading to."
msgstr "`Cargo.toml`을 편집하고 맨 위에( `[package]` 위) `cargo-features = ["edition20xx"]`를 배치하고 edition 필드를 `edition = "20xx"`로 변경합니다. 여기서 `20xx`는 업그레이드하는 에디션입니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:130
msgid "Run `cargo +nightly check` to verify it now works in the new edition."
msgstr "`cargo +nightly check`를 실행하여 새 에디션에서 작동하는지 확인합니다."

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:132
msgid ""
"**⚠ Caution**: Features implemented in the next edition may not have "
"automatic migrations implemented with `cargo fix`, and the features "
"themselves may not be finished. When possible, this guide should contain "
"information about which features are implemented on nightly along with more "
"information about their status. A few months before the edition is "
"stabilized, all of the new features should be fully implemented, and the "
"[Rust Blog](https://blog.rust-lang.org/) will announce a call for testing."
msgstr "**⚠ 주의**: 다음 에디션에 구현된 기능에는 `cargo fix`로 구현된 자동 마이그레이션이 없을 수 있으며 기능 자체가 완료되지 않았을 수 있습니다. 가능하면 이 가이드에는 상태에 대한 자세한 정보와 함께 nightly에 구현된 기능에 대한 정보가 포함되어야 합니다. 에디션이 안정화되기 몇 달 전에 모든 새로운 기능이 완전히 구현되어야 하며 [Rust 블로그](https://blog.rust-lang.org/)에서 테스트 요청을 발표할 것입니다."

#: src/editions/advanced-migrations.md:1
msgid "Advanced migration strategies"
msgstr "고급 마이그레이션 전략"

#: src/editions/advanced-migrations.md:3
msgid "How migrations work"
msgstr "마이그레이션 작동 방식"

#: src/editions/advanced-migrations.md:5
msgid ""
"[`cargo fix --edition`](../../cargo/commands/cargo-fix.html) works by "
"running the equivalent of [`cargo check`](../../cargo/commands/cargo-"
"check.html) on your project with special [lints](../../rustc/lints/"
"index.html) enabled which will detect code that may not compile in the next "
"edition. These lints include instructions on how to modify the code to make "
"it compatible on both the current and the next edition. `cargo fix` applies "
"these changes to the source code, and then runs `cargo check` again to "
"verify that the fixes work. If the fixes fail, then it will back out the "
"changes and display a warning."
msgstr "[`cargo fix --edition`](../../cargo/commands/cargo-fix.html)은 다음 에디션에서 컴파일되지 않을 수 있는 코드를 감지하는 특수 [lints](../../rustc/lints/index.html)가 활성화된 상태에서 프로젝트에서 [`cargo check`](../../cargo/commands/cargo-check.html)와 동등한 것을 실행하여 작동합니다. 이러한 린트에는 현재 및 다음 에디션 모두에서 호환되도록 코드를 수정하는 방법에 대한 지침이 포함되어 있습니다. `cargo fix`는 이러한 변경 사항을 소스 코드에 적용한 다음 `cargo check`를 다시 실행하여 수정 사항이 작동하는지 확인합니다. 수정 사항이 실패하면 변경 사항을 되돌리고 경고를 표시합니다."

#: src/editions/advanced-migrations.md:10
msgid ""
"Changing the code to be simultaneously compatible with both the current and "
"next edition makes it easier to incrementally migrate the code. If the "
"automated migration does not completely succeed, or requires manual help, "
"you can iterate while staying on the original edition before changing "
"`Cargo.toml` to use the next edition."
msgstr "코드를 현재 및 다음 에디션 모두와 동시에 호환되도록 변경하면 코드를 점진적으로 마이그레이션하기가 더 쉬워집니다. 자동화된 마이그레이션이 완전히 성공하지 못하거나 수동 도움이 필요한 경우 `Cargo.toml`을 다음 에디션을 사용하도록 변경하기 전에 원래 에디션에 머무르면서 반복할 수 있습니다."

#: src/editions/advanced-migrations.md:13
msgid ""
"The lints that `cargo fix --edition` apply are part of a [lint group](../../"
"rustc/lints/groups.html). For example, when migrating from 2018 to 2021, "
"Cargo uses the `rust-2021-compatibility` group of lints to fix the code. "
"Check the [Partial migration](#partial-migration-with-broken-code) section "
"below for tips on using individual lints to help with migration."
msgstr "`cargo fix --edition`이 적용하는 린트는 [린트 그룹](../../rustc/lints/groups.html)의 일부입니다. 예를 들어, 2018에서 2021로 마이그레이션할 때 Cargo는 `rust-2021-compatibility` 린트 그룹을 사용하여 코드를 수정합니다. 마이그레이션에 도움이 되는 개별 린트 사용에 대한 팁은 아래 [부분 마이그레이션](#partial-migration-with-broken-code) 섹션을 확인하십시오."

#: src/editions/advanced-migrations.md:17
msgid ""
"`cargo fix` may run `cargo check` multiple times. For example, after "
"applying one set of fixes, this may trigger new warnings which require "
"further fixes. Cargo repeats this until no new warnings are generated."
msgstr "`cargo fix`는 `cargo check`를 여러 번 실행할 수 있습니다. 예를 들어, 한 세트의 수정 사항을 적용한 후 추가 수정이 필요한 새 경고가 트리거될 수 있습니다. Cargo는 새 경고가 생성되지 않을 때까지 이 작업을 반복합니다."

#: src/editions/advanced-migrations.md:21
msgid "Migrating multiple configurations"
msgstr "여러 구성 마이그레이션"

#: src/editions/advanced-migrations.md:23
msgid ""
"`cargo fix` can only work with a single configuration at a time. If you use "
"[Cargo features](../../cargo/reference/features.html) or [conditional "
"compilation](../../reference/conditional-compilation.html), then you may "
"need to run `cargo fix` multiple times with different flags."
msgstr "`cargo fix`는 한 번에 하나의 구성으로만 작동할 수 있습니다. [Cargo 기능](../../cargo/reference/features.html) 또는 [조건부 컴파일](../../reference/conditional-compilation.html)을 사용하는 경우 다른 플래그로 `cargo fix`를 여러 번 실행해야 할 수 있습니다."

#: src/editions/advanced-migrations.md:26
msgid ""
"For example, if you have code that uses `#[cfg]` attributes to include "
"different code for different platforms, you may need to run `cargo fix` with "
"the `--target` option to fix for different targets. This may require moving "
"your code between machines if you don't have cross-compiling available."
msgstr "예를 들어, `#[cfg]` 속성을 사용하여 다른 플랫폼에 대해 다른 코드를 포함하는 코드가 있는 경우 다른 대상에 대해 수정하기 위해 `--target` 옵션으로 `cargo fix`를 실행해야 할 수 있습니다. 교차 컴파일을 사용할 수 없는 경우 시스템 간에 코드를 이동해야 할 수 있습니다."

#: src/editions/advanced-migrations.md:29
msgid ""
"Similarly, if you have conditions on Cargo features, like `#[cfg(feature = \""
"\"my-optional-thing\")]`, it is recommended to use the `--all-features` flag "
"to allow `cargo fix` to migrate all the code behind those feature gates. If "
"you want to migrate feature code individually, you can use the `--features` "
"flag to migrate one at a time."
msgstr "마찬가지로, `#[cfg(feature = "my-optional-thing")]`과 같이 Cargo 기능에 조건이 있는 경우 `--all-features` 플래그를 사용하여 `cargo fix`가 해당 기능 게이트 뒤의 모든 코드를 마이그레이션하도록 허용하는 것이 좋습니다. 기능 코드를 개별적으로 마이그레이션하려면 `--features` 플래그를 사용하여 한 번에 하나씩 마이그레이션할 수 있습니다."

#: src/editions/advanced-migrations.md:32
msgid "Migrating a large project or workspace"
msgstr "대규모 프로젝트 또는 작업 공간 마이그레이션"

#: src/editions/advanced-migrations.md:34
msgid ""
"You can migrate a large project incrementally to make the process easier if "
"you run into problems."
msgstr "문제가 발생하면 대규모 프로젝트를 점진적으로 마이그레이션하여 프로세스를 더 쉽게 만들 수 있습니다."

#: src/editions/advanced-migrations.md:36
msgid ""
"In a [Cargo workspace](../../cargo/reference/workspaces.html), each package "
"defines its own edition, so the process naturally involves migrating one "
"package at a time."
msgstr "[Cargo 작업 공간](../../cargo/reference/workspaces.html)에서 각 패키지는 자체 에디션을 정의하므로 프로세스는 자연스럽게 한 번에 하나의 패키지를 마이그레이션하는 것을 포함합니다."

#: src/editions/advanced-migrations.md:38
msgid ""
"Within a [Cargo package](../../cargo/reference/manifest.html#the-package-"
"section), you can either migrate the entire package at once, or migrate "
"individual [Cargo targets](../../cargo/reference/cargo-targets.html) one at "
"a time. For example, if you have multiple binaries, tests, and examples, you "
"can use specific target selection flags with `cargo fix --edition` to "
"migrate just that one target. By default, `cargo fix` uses `--all-targets`."
msgstr "[Cargo 패키지](../../cargo/reference/manifest.html#the-package-section) 내에서 전체 패키지를 한 번에 마이그레이션하거나 개별 [Cargo 대상](../../cargo/reference/cargo-targets.html)을 한 번에 하나씩 마이그레이션할 수 있습니다. 예를 들어, 여러 바이너리, 테스트 및 예제가 있는 경우 `cargo fix --edition`과 함께 특정 대상 선택 플래그를 사용하여 해당 대상 하나만 마이그레이션할 수 있습니다. 기본적으로 `cargo fix`는 `--all-targets`를 사용합니다."

#: src/editions/advanced-migrations.md:42
msgid ""
"For even more advanced cases, you can specify the edition for each "
"individual target in `Cargo.toml` like this:"
msgstr "더 고급 사례의 경우 `Cargo.toml`에서 각 개별 대상에 대한 에디션을 다음과 같이 지정할 수 있습니다."

#: src/editions/advanced-migrations.md:44
msgid ""
"```toml\n"
"[[bin]]\n"
"name = \"my-binary\"\n"
"edition = \"2018\"\n"
"```"
msgstr "```toml
[[bin]]
name = "my-binary"
edition = "2018"
```"

#: src/editions/advanced-migrations.md:50
msgid ""
"This usually should not be required, but is an option if you have a lot of "
"targets and are having difficulty migrating them all together."
msgstr "이것은 일반적으로 필요하지 않지만 대상이 많고 모두 함께 마이그레이션하는 데 어려움이 있는 경우 옵션입니다."

#: src/editions/advanced-migrations.md:52
msgid "Partial migration with broken code"
msgstr "손상된 코드로 부분 마이그레이션"

#: src/editions/advanced-migrations.md:54
msgid ""
"Sometimes the fixes suggested by the compiler may fail to work. When this "
"happens, Cargo will report a warning indicating what happened and what the "
"error was. However, by default it will automatically back out the changes it "
"made. It can be helpful to keep the code in the broken state and manually "
"resolve the issue. Some of the fixes may have been correct, and the broken "
"fix may be _mostly_ correct, but just need minor tweaking."
msgstr "때때로 컴파일러에서 제안한 수정 사항이 작동하지 않을 수 있습니다. 이런 일이 발생하면 Cargo는 무슨 일이 일어났는지와 오류가 무엇인지 나타내는 경고를 보고합니다. 그러나 기본적으로 변경 사항을 자동으로 되돌립니다. 코드를 손상된 상태로 유지하고 문제를 수동으로 해결하는 것이 도움이 될 수 있습니다. 일부 수정 사항은 정확했을 수 있으며 손상된 수정 사항은 _대부분_ 정확하지만 약간의 조정만 필요할 수 있습니다."

#: src/editions/advanced-migrations.md:60
msgid ""
"In this situation, use the `--broken-code` option with `cargo fix` to tell "
"Cargo not to back out the changes. Then, you can go manually inspect the "
"error and investigate what is needed to fix it."
msgstr "이 상황에서는 `cargo fix`와 함께 `--broken-code` 옵션을 사용하여 Cargo에 변경 사항을 되돌리지 않도록 지시하십시오. 그런 다음 수동으로 오류를 검사하고 수정하는 데 필요한 사항을 조사할 수 있습니다."

#: src/editions/advanced-migrations.md:63
msgid ""
"Another option to incrementally migrate a project is to apply individual "
"fixes separately, one at a time. You can do this by adding the individual "
"lints as warnings, and then either running `cargo fix` (without the `--"
"edition` flag) or using your editor or IDE to apply its suggestions if it "
"supports \"Quick Fixes\"."
msgstr "프로젝트를 점진적으로 마이그레이션하는 또 다른 옵션은 개별 수정 사항을 한 번에 하나씩 별도로 적용하는 것입니다. 개별 린트를 경고로 추가한 다음 `cargo fix`(`--edition` 플래그 없이)를 실행하거나 편집기 또는 IDE가 "빠른 수정"을 지원하는 경우 해당 제안을 적용하여 이 작업을 수행할 수 있습니다."

#: src/editions/advanced-migrations.md:66
msgid ""
"For example, the 2018 edition uses the [`keyword-idents`](../../rustc/lints/"
"listing/allowed-by-default.html#keyword-idents) lint to fix any conflicting "
"keywords. You can add `#![warn(keyword_idents)]` to the top of each crate "
"(like at the top of `src/lib.rs` or `src/main.rs`). Then, running `cargo "
"fix` will apply just the suggestions for that lint."
msgstr "예를 들어, 2018 에디션은 [`keyword-idents`](../../rustc/lints/listing/allowed-by-default.html#keyword-idents) 린트를 사용하여 충돌하는 키워드를 수정합니다. 각 크레이트의 맨 위에(예: `src/lib.rs` 또는 `src/main.rs`의 맨 위) `#![warn(keyword_idents)]`를 추가할 수 있습니다. 그런 다음 `cargo fix`를 실행하면 해당 린트에 대한 제안만 적용됩니다."

#: src/editions/advanced-migrations.md:70
msgid ""
"You can see the list of lints enabled for each edition in the [lint group]("
"../../rustc/lints/groups.html) page, or run the `rustc -Whelp` command."
msgstr "[린트 그룹](../../rustc/lints/groups.html) 페이지에서 각 에디션에 대해 활성화된 린트 목록을 보거나 `rustc -Whelp` 명령을 실행할 수 있습니다."

#: src/editions/advanced-migrations.md:72
msgid "Migrating macros"
msgstr "매크로 마이그레이션"

#: src/editions/advanced-migrations.md:74
msgid ""
"Some macros may require manual work to fix them for the next edition. For "
"example, `cargo fix --edition` may not be able to automatically fix a macro "
"that generates syntax that does not work in the next edition."
msgstr "일부 매크로는 다음 에디션을 위해 수정하기 위해 수동 작업이 필요할 수 있습니다. 예를 들어, `cargo fix --edition`은 다음 에디션에서 작동하지 않는 구문을 생성하는 매크로를 자동으로 수정하지 못할 수 있습니다."

#: src/editions/advanced-migrations.md:77
msgid ""
"This may be a problem for both [proc macros](../../reference/procedural-"
"macros.html) and `macro_rules`\\-style macros. `macro_rules` macros can "
"sometimes be automatically updated if the macro is used within the same "
"crate, but there are several situations where it cannot. Proc macros in "
"general cannot be automatically fixed at all."
msgstr "이것은 [proc 매크로](../../reference/procedural-macros.html)와 `macro_rules` 스타일 매크로 모두에 문제가 될 수 있습니다. `macro_rules` 매크로는 동일한 크레이트 내에서 매크로가 사용되는 경우 때때로 자동으로 업데이트될 수 있지만, 그렇지 않은 경우도 여러 있습니다. 일반적으로 Proc 매크로는 자동으로 수정할 수 없습니다."

#: src/editions/advanced-migrations.md:81
msgid ""
"For example, if we migrate a crate containing this (contrived) macro `foo` "
"from 2015 to 2018, `foo` would not be automatically fixed."
msgstr "예를 들어, 2015년에서 2018년으로 이 (억지로 만든) 매크로 `foo`를 포함하는 크레이트를 마이그레이션하면 `foo`는 자동으로 수정되지 않습니다."

#: src/editions/advanced-migrations.md:88
msgid "\"it is {}\""
msgstr ""it is {}""

#: src/editions/advanced-migrations.md:93
msgid ""
"When this macro is defined in a 2015 crate, it can be used from a crate of "
"any other edition due to macro hygiene (discussed below). In 2015, `dyn` is "
"a normal identifier and can be used without restriction."
msgstr "이 매크로가 2015 크레이트에 정의된 경우 매크로 위생(아래에서 설명)으로 인해 다른 에디션의 크레이트에서 사용할 수 있습니다. 2015년에는 `dyn`이 일반 식별자이며 제한 없이 사용할 수 있습니다."

#: src/editions/advanced-migrations.md:96
msgid ""
"However, in 2018, `dyn` is no longer a valid identifier. When using `cargo "
"fix --edition` to migrate to 2018, Cargo won't display any warnings or "
"errors at all. However, `foo` won't work when called from any crate."
msgstr "그러나 2018년에는 `dyn`이 더 이상 유효한 식별자가 아닙니다. `cargo fix --edition`을 사용하여 2018로 마이그레이션할 때 Cargo는 경고나 오류를 전혀 표시하지 않습니다. 그러나 `foo`는 어떤 크레이트에서 호출해도 작동하지 않습니다."

#: src/editions/advanced-migrations.md:100
msgid ""
"If you have macros, you are encouraged to make sure you have tests that "
"fully cover the macro's syntax. You may also want to test the macros by "
"importing and using them in crates from multiple editions, just to ensure it "
"works correctly everywhere. If you run into issues, you'll need to read "
"through the chapters of this guide to understand how the code can be changed "
"to work across all editions."
msgstr "매크로가 있는 경우 매크로의 구문을 완전히 다루는 테스트가 있는지 확인하는 것이 좋습니다. 또한 여러 에디션의 크레이트에서 매크로를 가져와 사용하여 모든 곳에서 올바르게 작동하는지 확인하는 것이 좋습니다. 문제가 발생하면 이 가이드의 장을 읽고 모든 에디션에서 작동하도록 코드를 변경하는 방법을 이해해야 합니다."

#: src/editions/advanced-migrations.md:104
msgid "Macro hygiene"
msgstr "매크로 위생"

#: src/editions/advanced-migrations.md:106
msgid ""
"Macros use a system called \"edition hygiene\" where the tokens within a "
"macro are marked with which edition they come from. This allows external "
"macros to be called from crates of varying editions without needing to worry "
"about which edition it is called from."
msgstr "매크로는 매크로 내의 토큰이 어떤 에디션에서 왔는지 표시되는 "에디션 위생"이라는 시스템을 사용합니다. 이를 통해 외부 매크로를 호출하는 에디션에 대해 걱정할 필요 없이 다양한 에디션의 크레이트에서 호출할 수 있습니다."

#: src/editions/advanced-migrations.md:109
msgid ""
"Let's take a closer look at the example above that defines a `macro_rules` "
"macro using `dyn` as an identifier. If that macro was defined in a crate "
"using the 2015 edition, then that macro works fine, even if it were called "
"from a 2018 crate where `dyn` is a keyword and that would normally be a "
"syntax error. The `let dyn = 1;` tokens are marked as being from 2015, and "
"the compiler will remember that wherever that code gets expanded. The parser "
"looks at the edition of the tokens to know how to interpret it."
msgstr "`dyn`을 식별자로 사용하는 `macro_rules` 매크로를 정의하는 위의 예를 자세히 살펴보겠습니다. 해당 매크로가 2015 에디션을 사용하는 크레이트에 정의된 경우 `dyn`이 키워드이고 일반적으로 구문 오류가 발생하는 2018 크레이트에서 호출되더라도 해당 매크로는 잘 작동합니다. `let dyn = 1;` 토큰은 2015년산으로 표시되며 컴파일러는 해당 코드가 확장되는 모든 곳에서 이를 기억합니다. 파서는 토큰의 에디션을 보고 해석 방법을 알 수 있습니다."

#: src/editions/advanced-migrations.md:114
msgid ""
"The problem arises when changing the edition to 2018 in the crate where it "
"is defined. Now, those tokens are tagged with the 2018 edition, and those "
"will fail to parse. However, since we never called the macro from our crate, "
"`cargo fix --edition` never had a chance to inspect the macro and fix it."
msgstr "문제는 정의된 크레이트에서 에디션을 2018로 변경할 때 발생합니다. 이제 해당 토큰은 2018 에디션으로 태그가 지정되며 구문 분석에 실패합니다. 그러나 크레이트에서 매크로를 호출한 적이 없기 때문에 `cargo fix --edition`은 매크로를 검사하고 수정할 기회가 없었습니다."

#: src/editions/advanced-migrations.md:120
msgid "Documentation tests"
msgstr "문서 테스트"

#: src/editions/advanced-migrations.md:122
msgid ""
"At this time, `cargo fix` is not able to update [documentation tests](../../"
"rustdoc/documentation-tests.html). After updating the edition in "
"`Cargo.toml`, you should run `cargo test` to ensure everything still passes. "
"If your documentation tests use syntax that is not supported in the new "
"edition, you will need to update them manually."
msgstr "현재 `cargo fix`는 [문서 테스트](https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html)를 업데이트할 수 없습니다. `Cargo.toml`에서 에디션을 업데이트한 후 `cargo test`를 실행하여 모든 것이 여전히 통과하는지 확인해야 합니다. 문서 테스트가 새 에디션에서 지원되지 않는 구문을 사용하는 경우 수동으로 업데이트해야 합니다."

#: src/editions/advanced-migrations.md:126
msgid ""
"In rare cases, you can manually set the edition for each test. For example, "
"you can use the [`edition2018` annotation](../../rustdoc/documentation-"
"tests.html#attributes) on the triple backticks to tell `rustdoc` which "
"edition to use."
msgstr "드문 경우지만 각 테스트에 대해 에디션을 수동으로 설정할 수 있습니다. 예를 들어, 삼중 백틱에 [`edition2018` 주석](https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes)을 사용하여 `rustdoc`에 사용할 에디션을 알릴 수 있습니다."

#: src/editions/advanced-migrations.md:129
msgid "Generated code"
msgstr "생성된 코드"

#: src/editions/advanced-migrations.md:131
msgid ""
"Another area where the automated fixes cannot apply is if you have a build "
"script which generates Rust code at compile time (see [Code generation]("
"../../cargo/reference/build-script-examples.html#code-generation) for an "
"example). In this situation, if you end up with code that doesn't work in "
"the next edition, you will need to manually change the build script to "
"generate code that is compatible."
msgstr "자동 수정이 적용될 수 없는 또 다른 영역은 컴파일 타임에 Rust 코드를 생성하는 빌드 스크립트가 있는 경우입니다(예는 [코드 생성](https://doc.rust-lang.org/cargo/reference/build-script-examples.html#code-generation) 참조). 이 상황에서 다음 에디션에서 작동하지 않는 코드가 생기면 호환되는 코드를 생성하도록 빌드 스크립트를 수동으로 변경해야 합니다."

#: src/editions/advanced-migrations.md:134
msgid "Migrating non-Cargo projects"
msgstr "비-Cargo 프로젝트 마이그레이션"

#: src/editions/advanced-migrations.md:136
msgid ""
"If your project is not using Cargo as a build system, it may still be "
"possible to make use of the automated lints to assist migrating to the next "
"edition. You can enable the migration lints as described above by enabling "
"the appropriate [lint group](../../rustc/lints/groups.html). For example, "
"you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-"
"Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI "
"flag](../../rustc/lints/levels.html#via-compiler-flag)."
msgstr "프로젝트가 빌드 시스템으로 Cargo를 사용하지 않는 경우에도 자동화된 린트를 사용하여 다음 에디션으로 마이그레이션하는 데 도움을 받을 수 있습니다. 적절한 [린트 그룹](https://doc.rust-lang.org/rustc/lints/groups.html)을 활성화하여 위에서 설명한 대로 마이그레이션 린트를 활성화할 수 있습니다. 예를 들어, `#![warn(rust_2021_compatibility)]` 속성 또는 `-Wrust-2021-compatibility` 또는 `--force-warns=rust-2021-compatibility` [CLI 플래그](https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag)를 사용할 수 있습니다."

#: src/editions/advanced-migrations.md:140
msgid ""
"The next step is to apply those lints to your code. There are several "
"options here:"
msgstr "다음 단계는 해당 린트를 코드에 적용하는 것입니다. 여기에는 몇 가지 옵션이 있습니다."

#: src/editions/advanced-migrations.md:143
msgid ""
"Manually read the warnings and apply the suggestions recommended by the "
"compiler."
msgstr "경고를 수동으로 읽고 컴파일러에서 권장하는 제안을 적용합니다."

#: src/editions/advanced-migrations.md:144
msgid ""
"Use an editor or IDE that supports automatically applying suggestions. For "
"example, [Visual Studio Code](https://code.visualstudio.com/) with the [Rust "
"Analyzer extension](https://marketplace.visualstudio.com/items?"
"itemName=matklad.rust-analyzer) has the ability to use the \"Quick Fix\" "
"links to automatically apply suggestions. Many other editors and IDEs have "
"similar functionality."
msgstr "제안을 자동으로 적용하는 것을 지원하는 편집기나 IDE를 사용하십시오. 예를 들어, [Rust Analyzer 확장](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)이 포함된 [Visual Studio Code](https://code.visualstudio.com/)는 "빠른 수정" 링크를 사용하여 제안을 자동으로 적용하는 기능이 있습니다. 다른 많은 편집기와 IDE에도 유사한 기능이 있습니다."

#: src/editions/advanced-migrations.md:147
msgid ""
"Write a migration tool using the [`rustfix`](https://crates.io/crates/"
"rustfix) library. This is the library that Cargo uses internally to take the "
"[JSON messages](../../rustc/json.html) from the compiler and modify the "
"source code. Check the [`examples` directory](https://github.com/rust-lang/"
"cargo/tree/master/crates/rustfix/examples) for examples of how to use the "
"library."
msgstr "[`rustfix`](https://crates.io/crates/rustfix) 라이브러리를 사용하여 마이그레이션 도구를 작성하십시오. 이것은 Cargo가 내부적으로 컴파일러에서 [JSON 메시지](https://doc.rust-lang.org/rustc/json.html)를 가져와 소스 코드를 수정하는 데 사용하는 라이브러리입니다. 라이브러리 사용 방법에 대한 예는 [`examples` 디렉토리](https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples)를 확인하십시오."

#: src/editions/advanced-migrations.md:151
msgid "Writing idiomatic code in a new edition"
msgstr "새 에디션에서 관용적인 코드 작성"

#: src/editions/advanced-migrations.md:153
msgid ""
"Editions are not only about new features and removing old ones. In any "
"programming language, idioms change over time, and Rust is no exception. "
"While old code will continue to compile, it might be written with different "
"idioms today."
msgstr "에디션은 새로운 기능을 추가하고 오래된 기능을 제거하는 것만이 아닙니다. 모든 프로그래밍 언어에서 관용구는 시간이 지남에 따라 변하며 Rust도 예외는 아닙니다. 이전 코드는 계속 컴파일되지만 오늘날에는 다른 관용구로 작성될 수 있습니다."

#: src/editions/advanced-migrations.md:157
msgid ""
"For example, in Rust 2015, external crates must be listed with `extern "
"crate` like this:"
msgstr "예를 들어, Rust 2015에서는 외부 크레이트를 다음과 같이 `extern crate`로 나열해야 합니다."

#: src/editions/advanced-migrations.md:160
msgid "// src/lib.rs\n"
msgstr "// src/lib.rs
"

#: src/editions/advanced-migrations.md:164
msgid ""
"In Rust 2018, it is [no longer necessary](../rust-2018/path-changes.md#no-"
"more-extern-crate) to include these items."
msgstr "Rust 2018에서는 [더 이상 포함할 필요가 없습니다](../rust-2018/path-changes.md#no-more-extern-crate)."

#: src/editions/advanced-migrations.md:166
msgid ""
"`cargo fix` has the `--edition-idioms` option to automatically transition "
"some of these idioms to the new syntax."
msgstr "`cargo fix`에는 이러한 관용구 중 일부를 새 구문으로 자동 전환하는 `--edition-idioms` 옵션이 있습니다."

#: src/editions/advanced-migrations.md:168
msgid ""
"**Warning**: The current _\"idiom lints\"_ are known to have some problems. "
"They may make incorrect suggestions which may fail to compile. The current "
"lints are:"
msgstr "**경고**: 현재 _"관용구 린트"_에는 몇 가지 문제가 있는 것으로 알려져 있습니다. 컴파일에 실패할 수 있는 잘못된 제안을 할 수 있습니다. 현재 린트는 다음과 같습니다."

#: src/editions/advanced-migrations.md:171
msgid "Edition 2018:"
msgstr "2018 에디션:"

#: src/editions/advanced-migrations.md:172
msgid ""
"[`unused-extern-crates`](../../rustc/lints/listing/allowed-by-"
"default.html#unused-extern-crates)"
msgstr "[`unused-extern-crates`](../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates)"

#: src/editions/advanced-migrations.md:173
msgid ""
"[`explicit-outlives-requirements`](../../rustc/lints/listing/allowed-by-"
"default.html#explicit-outlives-requirements)"
msgstr "[`explicit-outlives-requirements`](../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements)"

#: src/editions/advanced-migrations.md:174
msgid "Edition 2021 does not have any idiom lints."
msgstr "2021 에디션에는 관용구 린트가 없습니다."

#: src/editions/advanced-migrations.md:176
msgid ""
"The following instructions are recommended only for the intrepid who are "
"willing to work through a few compiler/Cargo bugs! If you run into problems, "
"you can try the `--broken-code` option [described above](#partial-migration-"
"with-broken-code) to make as much progress as possible, and then resolve the "
"remaining issues manually."
msgstr "다음 지침은 몇 가지 컴파일러/Cargo 버그를 해결하려는 용감한 사람들에게만 권장됩니다! 문제가 발생하면 [위에서 설명한](#partial-migration-with-broken-code) `--broken-code` 옵션을 사용하여 가능한 한 많은 진전을 이룬 다음 나머지 문제를 수동으로 해결할 수 있습니다."

#: src/editions/advanced-migrations.md:179
msgid ""
"With that out of the way, we can instruct Cargo to fix our code snippet with:"
msgstr "이제 Cargo에 코드 스니펫을 수정하도록 지시할 수 있습니다."

#: src/editions/advanced-migrations.md:185
msgid ""
"Afterwards, the line with `extern crate rand;` in `src/lib.rs` will be "
"removed."
msgstr "그런 다음 `src/lib.rs`의 `extern crate rand;` 줄이 제거됩니다."

#: src/editions/advanced-migrations.md:187
msgid "We're now more idiomatic, and we didn't have to fix our code manually!"
msgstr "이제 더 관용적이 되었고 코드를 수동으로 수정할 필요가 없었습니다!"

#: src/rust-2015/index.md:3
msgid ""
"Rust 2015 has a theme of \"stability\". It commenced with the release of "
"1.0, and is the \"default edition\". The edition system was conceived in "
"late 2017, but Rust 1.0 was released in May of 2015. As such, 2015 is the "
"edition that you get when you don't specify any particular edition, for "
"backwards compatibility reasons."
msgstr "Rust 2015의 주제는 "안정성"입니다. 1.0 릴리스와 함께 시작되었으며 "기본 에디션"입니다. 에디션 시스템은 2017년 후반에 고안되었지만 Rust 1.0은 2015년 5월에 출시되었습니다. 따라서 2015는 하위 호환성을 위해 특정 에디션을 지정하지 않을 때 얻는 에디션입니다."

#: src/rust-2015/index.md:9
msgid ""
"\"Stability\" is the theme of Rust 2015 because 1.0 marked a huge change in "
"Rust development. Previous to Rust 1.0, Rust was changing on a daily basis. "
"This made it very difficult to write large software in Rust, and made it "
"difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed "
"to backwards compatibility, ensuring a solid foundation for people to build "
"projects on top of."
msgstr ""안정성"은 Rust 2015의 주제입니다. 왜냐하면 1.0은 Rust 개발에 큰 변화를 가져왔기 때문입니다. Rust 1.0 이전에는 Rust가 매일 바뀌었습니다. 이로 인해 Rust로 대규모 소프트웨어를 작성하기가 매우 어려웠고 배우기도 어려웠습니다. Rust 1.0 및 Rust 2015 릴리스를 통해 우리는 하위 호환성을 약속하여 사람들이 프로젝트를 구축할 수 있는 견고한 기반을 보장했습니다."

#: src/rust-2015/index.md:16
msgid ""
"Since it's the default edition, there's no way to port your code to Rust "
"2015; it just _is_. You'll be transitioning _away_ from 2015, but never "
"really _to_ 2015. As such, there's not much else to say about it!"
msgstr "기본 에디션이므로 코드를 Rust 2015로 포팅할 방법이 없습니다. 그냥 _그렇습니다_. 2015에서 _벗어나_ 전환하게 되지만 실제로 2015로 _전환_하지는 않습니다. 따라서 그것에 대해 더 이상 할 말이 없습니다!"

#: src/rust-2018/index.md:3 src/rust-2021/index.md:3 src/rust-2024/index.md:3
msgid "Info"
msgstr "정보"

#: src/rust-2018/index.md:5 src/rust-2021/index.md:5 src/rust-2024/index.md:5
msgid "RFC"
msgstr "RFC"

#: src/rust-2018/index.md:5
msgid ""
"[\\#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), which also "
"proposed the Edition system"
msgstr "[\#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), 에디션 시스템도 제안함"

#: src/rust-2018/index.md:6 src/rust-2021/index.md:6 src/rust-2024/index.md:6
msgid "Release version"
msgstr "릴리스 버전"

#: src/rust-2018/index.md:6
msgid ""
"[1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)"
msgstr "[1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)"

#: src/rust-2018/index.md:8
msgid ""
"The edition system was created for the release of Rust 2018. The release of "
"the Rust 2018 edition coincided with a number of other features all "
"coordinated around the theme of _productivity_. The majority of those "
"features were backwards compatible and are now available on all editions; "
"however, some of those changes required the edition mechanism (most notably "
"the [module system changes](path-changes.md))."
msgstr "에디션 시스템은 Rust 2018 릴리스를 위해 만들어졌습니다. Rust 2018 에디션 릴리스는 _생산성_이라는 주제를 중심으로 조정된 여러 다른 기능과 동시에 이루어졌습니다. 이러한 기능의 대부분은 하위 호환이 가능하며 이제 모든 에디션에서 사용할 수 있습니다. 그러나 이러한 변경 사항 중 일부는 에디션 메커니즘이 필요했습니다(가장 주목할 만한 것은 [모듈 시스템 변경](path-changes.md)입니다)."

#: src/rust-2018/path-changes.md:3 src/rust-2018/trait-fn-parameters.md:3
msgid ""
"![Minimum Rust version: 1.31](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.31-brightgreen.svg)"
msgstr "![최소 Rust 버전: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)"

#: src/rust-2018/path-changes.md:5 src/rust-2018/trait-fn-parameters.md:5
#: src/rust-2018/new-keywords.md:5 src/rust-2018/tyvar-behind-raw-pointer.md:3
#: src/rust-2018/cargo.md:3 src/rust-2021/prelude.md:3
#: src/rust-2021/default-cargo-resolver.md:3
#: src/rust-2021/IntoIterator-for-arrays.md:3
#: src/rust-2021/disjoint-capture-in-closures.md:3
#: src/rust-2021/panic-macro-consistency.md:3
#: src/rust-2021/reserved-syntax.md:3 src/rust-2021/raw-lifetimes.md:3
#: src/rust-2021/warnings-promoted-to-error.md:3
#: src/rust-2021/or-patterns-macro-rules.md:3
#: src/rust-2021/c-string-literals.md:3
#: src/rust-2024/rpit-lifetime-capture.md:8
#: src/rust-2024/temporary-if-let-scope.md:3
#: src/rust-2024/temporary-tail-expr-scope.md:3
#: src/rust-2024/match-ergonomics.md:3 src/rust-2024/unsafe-extern.md:3
#: src/rust-2024/unsafe-attributes.md:3
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:3
#: src/rust-2024/static-mut-references.md:3
#: src/rust-2024/never-type-fallback.md:3
#: src/rust-2024/macro-fragment-specifiers.md:3
#: src/rust-2024/missing-macro-fragment-specifiers.md:3
#: src/rust-2024/gen-keyword.md:3 src/rust-2024/reserved-syntax.md:3
#: src/rust-2024/prelude.md:3 src/rust-2024/intoiterator-box-slice.md:3
#: src/rust-2024/newly-unsafe-functions.md:3 src/rust-2024/cargo-resolver.md:3
#: src/rust-2024/cargo-table-key-names.md:3
#: src/rust-2024/cargo-inherited-default-features.md:3
#: src/rust-2024/rustdoc-doctests.md:3
#: src/rust-2024/rustdoc-nested-includes.md:3
#: src/rust-2024/rustfmt-style-edition.md:3
#: src/rust-2024/rustfmt-formatting-fixes.md:3
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:3
#: src/rust-2024/rustfmt-version-sorting.md:3
msgid "Summary"
msgstr "요약"

#: src/rust-2018/path-changes.md:7
msgid "Paths in `use` declarations now work the same as other paths."
msgstr "`use` 선언의 경로는 이제 다른 경로와 동일하게 작동합니다."

#: src/rust-2018/path-changes.md:8
msgid "Paths starting with `::` must now be followed with an external crate."
msgstr "`::`로 시작하는 경로는 이제 외부 크레이트가 뒤따라야 합니다."

#: src/rust-2018/path-changes.md:9
msgid ""
"Paths in `pub(in path)` visibility modifiers must now start with `crate`, "
"`self`, or `super`."
msgstr "`pub(in path)` 가시성 한정자의 경로는 이제 `crate`, `self` 또는 `super`로 시작해야 합니다."

#: src/rust-2018/path-changes.md:11 src/rust-2018/new-keywords.md:15
msgid "Motivation"
msgstr "동기"

#: src/rust-2018/path-changes.md:13
msgid ""
"The module system is often one of the hardest things for people new to Rust. "
"Everyone has their own things that take time to master, of course, but "
"there's a root cause for why it's so confusing to many: while there are "
"simple and consistent rules defining the module system, their consequences "
"can feel inconsistent, counterintuitive and mysterious."
msgstr "모듈 시스템은 종종 Rust를 처음 접하는 사람들에게 가장 어려운 것 중 하나입니다. 물론 모든 사람이 마스터하는 데 시간이 걸리는 자신만의 것이 있지만, 많은 사람들에게 혼란스러운 근본적인 원인이 있습니다. 모듈 시스템을 정의하는 간단하고 일관된 규칙이 있지만 그 결과는 일관성이 없고 직관에 반하며 신비롭게 느껴질 수 있습니다."

#: src/rust-2018/path-changes.md:19
msgid ""
"As such, the 2018 edition of Rust introduces a few new module system "
"features, but they end up _simplifying_ the module system, to make it more "
"clear as to what is going on."
msgstr "따라서 2018 에디션의 Rust는 몇 가지 새로운 모듈 시스템 기능을 도입하지만, 결국 모듈 시스템을 _단순화_하여 무슨 일이 일어나고 있는지 더 명확하게 만듭니다."

#: src/rust-2018/path-changes.md:23
msgid "Here's a brief summary:"
msgstr "간단한 요약은 다음과 같습니다."

#: src/rust-2018/path-changes.md:25
msgid "`extern crate` is no longer needed in 99% of circumstances."
msgstr "`extern crate`는 99%의 경우에 더 이상 필요하지 않습니다."

#: src/rust-2018/path-changes.md:26
msgid "The `crate` keyword refers to the current crate."
msgstr "`crate` 키워드는 현재 크레이트를 나타냅니다."

#: src/rust-2018/path-changes.md:27
msgid "Paths may start with a crate name, even within submodules."
msgstr "경로는 하위 모듈 내에서도 크레이트 이름으로 시작할 수 있습니다."

#: src/rust-2018/path-changes.md:28
msgid "Paths starting with `::` must reference an external crate."
msgstr "`::`로 시작하는 경로는 외부 크레이트를 참조해야 합니다."

#: src/rust-2018/path-changes.md:29
msgid ""
"A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed "
"when placing submodules in a subdirectory."
msgstr "`foo.rs`와 `foo/` 하위 디렉토리가 공존할 수 있습니다. 하위 모듈을 하위 디렉토리에 배치할 때 `mod.rs`는 더 이상 필요하지 않습니다."

#: src/rust-2018/path-changes.md:31
msgid "Paths in `use` declarations work the same as other paths."
msgstr "`use` 선언의 경로는 다른 경로와 동일하게 작동합니다."

#: src/rust-2018/path-changes.md:33
msgid ""
"These may seem like arbitrary new rules when put this way, but the mental "
"model is now significantly simplified overall. Read on for more details!"
msgstr "이렇게 말하면 임의의 새로운 규칙처럼 보일 수 있지만, 이제 정신 모델이 전반적으로 크게 단순화되었습니다. 자세한 내용은 계속 읽어보십시오!"

#: src/rust-2018/path-changes.md:36
msgid "More details"
msgstr "자세한 내용"

#: src/rust-2018/path-changes.md:38
msgid "Let's talk about each new feature in turn."
msgstr "각 새로운 기능에 대해 차례로 이야기해 봅시다."

#: src/rust-2018/path-changes.md:40
msgid "No more `extern crate`"
msgstr "`extern crate` 더 이상 없음"

#: src/rust-2018/path-changes.md:42
msgid ""
"This one is quite straightforward: you no longer need to write `extern "
"crate` to import a crate into your project. Before:"
msgstr "이것은 매우 간단합니다. 더 이상 프로젝트에 크레이트를 가져오기 위해 `extern crate`를 작성할 필요가 없습니다. 이전:"

#: src/rust-2018/path-changes.md:46 src/rust-2018/path-changes.md:170
#: src/rust-2018/path-changes.md:282
msgid "// Rust 2015\n"
msgstr "// Rust 2015
"

#: src/rust-2018/path-changes.md:55
msgid "After:"
msgstr "이후:"

#: src/rust-2018/path-changes.md:58 src/rust-2018/path-changes.md:191
#: src/rust-2018/path-changes.md:315 src/rust-2018/path-changes.md:345
#: src/rust-2021/panic-macro-consistency.md:19
#: src/rust-2021/panic-macro-consistency.md:28
msgid "// Rust 2018\n"
msgstr "// Rust 2018
"

#: src/rust-2018/path-changes.md:65
msgid ""
"Now, to add a new crate to your project, you can add it to your "
"`Cargo.toml`, and then there is no step two. If you're not using Cargo, you "
"already had to pass `--extern` flags to give `rustc` the location of "
"external crates, so you'd just keep doing what you were doing there as well."
msgstr "이제 프로젝트에 새 크레이트를 추가하려면 `Cargo.toml`에 추가하면 두 번째 단계가 없습니다. Cargo를 사용하지 않는 경우 이미 `--extern` 플래그를 전달하여 `rustc`에 외부 크레이트의 위치를 제공해야 했으므로 거기서 하던 일을 계속하면 됩니다."

#: src/rust-2018/path-changes.md:70
msgid "An exception"
msgstr "예외"

#: src/rust-2018/path-changes.md:72
msgid ""
"There's one exception to this rule, and that's the \"sysroot\" crates. These "
"are the crates distributed with Rust itself."
msgstr "이 규칙에는 한 가지 예외가 있는데, 바로 "sysroot" 크레이트입니다. 이것들은 Rust 자체와 함께 배포되는 크레이트입니다."

#: src/rust-2018/path-changes.md:75
msgid ""
"Usually these are only needed in very specialized situations. Starting in "
"1.41, `rustc` accepts the `--extern=CRATE_NAME` flag which automatically "
"adds the given crate name in a way similar to `extern crate`. Build tools "
"may use this to inject sysroot crates into the crate's prelude. Cargo does "
"not have a general way to express this, though it uses it for `proc_macro` "
"crates."
msgstr "일반적으로 이것들은 매우 특수한 상황에서만 필요합니다. 1.41부터 `rustc`는 `extern crate`와 유사한 방식으로 주어진 크레이트 이름을 자동으로 추가하는 `--extern=CRATE_NAME` 플래그를 허용합니다. 빌드 도구는 이를 사용하여 sysroot 크레이트를 크레이트의 프렐루드에 주입할 수 있습니다. Cargo는 `proc_macro` 크레이트에 사용하지만 이를 표현하는 일반적인 방법이 없습니다."

#: src/rust-2018/path-changes.md:81
msgid "Some examples of needing to explicitly import sysroot crates are:"
msgstr "sysroot 크레이트를 명시적으로 가져와야 하는 몇 가지 예는 다음과 같습니다."

#: src/rust-2018/path-changes.md:83
msgid ""
"[`std`](../../std/index.html): Usually this is not necessary, because `std` "
"is automatically imported unless the crate is marked with [`#![no_std]`]("
"../../reference/names/preludes.html#the-no_std-attribute)."
msgstr "[`std`](../../std/index.html): 일반적으로 이것은 필요하지 않습니다. 왜냐하면 `std`는 크레이트가 [`#![no_std]`](../../reference/names/preludes.html#the-no_std-attribute)로 표시되지 않는 한 자동으로 가져오기 때문입니다."

#: src/rust-2018/path-changes.md:85
msgid ""
"[`core`](../../core/index.html): Usually this is not necessary, because "
"`core` is automatically imported, unless the crate is marked with [`#!""
"[no_core]`](https://github.com/rust-lang/rust/issues/29639). For example, "
"some of the internal crates used by the standard library itself need this."
msgstr "[`core`](../../core/index.html): 일반적으로 이것은 필요하지 않습니다. 왜냐하면 `core`는 크레이트가 [`#![no_core]`](https://github.com/rust-lang/rust/issues/29639)로 표시되지 않는 한 자동으로 가져오기 때문입니다. 예를 들어, 표준 라이브러리 자체에서 사용하는 일부 내부 크레이트에는 이것이 필요합니다."

#: src/rust-2018/path-changes.md:89
msgid ""
"[`proc_macro`](../../proc_macro/index.html): This is automatically imported "
"by Cargo if it is a proc-macro crate starting in 1.42. `extern crate ""
"proc_macro;` would be needed if you want to support older releases, or if "
"using another build tool that does not pass the appropriate `--extern` flags "
"to `rustc`."
msgstr "[`proc_macro`](../../proc_macro/index.html): 1.42부터 proc-macro 크레이트인 경우 Cargo에서 자동으로 가져옵니다. 이전 릴리스를 지원하거나 `rustc`에 적절한 `--extern` 플래그를 전달하지 않는 다른 빌드 도구를 사용하는 경우 `extern crate proc_macro;`가 필요합니다."

#: src/rust-2018/path-changes.md:93
msgid ""
"[`alloc`](../../alloc/index.html): Items in the `alloc` crate are usually "
"accessed via re-exports in the `std` crate. If you are working with a "
"`no_std` crate that supports allocation, then you may need to explicitly "
"import `alloc`."
msgstr "[`alloc`](../../alloc/index.html): `alloc` 크레이트의 항목은 일반적으로 `std` 크레이트의 재내보내기를 통해 액세스됩니다. 할당을 지원하는 `no_std` 크레이트로 작업하는 경우 `alloc`을 명시적으로 가져와야 할 수 있습니다."

#: src/rust-2018/path-changes.md:96
msgid ""
"[`test`](../../test/index.html): This is only available on the [nightly "
"channel](../../book/appendix-07-nightly-rust.html), and is usually only used "
"for the unstable benchmark support."
msgstr "[`test`](../../test/index.html): 이것은 [nightly 채널](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)에서만 사용할 수 있으며 일반적으로 불안정한 벤치마크 지원에만 사용됩니다."

#: src/rust-2018/path-changes.md:108
msgid "Macros"
msgstr "매크로"

#: src/rust-2018/path-changes.md:110
msgid ""
"One other use for `extern crate` was to import macros; that's no longer "
"needed. Macros may be imported with `use` like any other item. For example, "
"the following use of `extern crate`:"
msgstr "`extern crate`의 또 다른 용도는 매크로를 가져오는 것이었습니다. 더 이상 필요하지 않습니다. 매크로는 다른 항목과 마찬가지로 `use`로 가져올 수 있습니다. 예를 들어, 다음과 같은 `extern crate` 사용:"

#: src/rust-2018/path-changes.md:123
msgid "Can be changed to something like the following:"
msgstr "다음과 같이 변경할 수 있습니다."

#: src/rust-2018/path-changes.md:133
msgid "Renaming crates"
msgstr "크레이트 이름 바꾸기"

#: src/rust-2018/path-changes.md:135
msgid "If you've been using `as` to rename your crate like this:"
msgstr "다음과 같이 `as`를 사용하여 크레이트 이름을 바꾸고 있었다면:"

#: src/rust-2018/path-changes.md:143
msgid ""
"then removing the `extern crate` line on its own won't work. You'll need to "
"do this:"
msgstr "`extern crate` 줄을 자체적으로 제거하는 것은 작동하지 않습니다. 다음과 같이 해야 합니다."

#: src/rust-2018/path-changes.md:151
msgid "This change will need to happen in any module that uses `f`."
msgstr "이 변경은 `f`를 사용하는 모든 모듈에서 발생해야 합니다."

#: src/rust-2018/path-changes.md:153
msgid "The `crate` keyword refers to the current crate"
msgstr "`crate` 키워드는 현재 크레이트를 나타냅니다."

#: src/rust-2018/path-changes.md:155
msgid ""
"In `use` declarations and in other code, you can refer to the root of the "
"current crate with the `crate::` prefix. For instance, `crate::foo::bar` "
"will always refer to the name `bar` inside the module `foo`, from anywhere "
"else in the same crate."
msgstr "`use` 선언 및 기타 코드에서 `crate::` 접두사를 사용하여 현재 크레이트의 루트를 참조할 수 있습니다. 예를 들어, `crate::foo::bar`는 동일한 크레이트의 다른 곳에서 항상 `foo` 모듈 내의 `bar` 이름을 참조합니다."

#: src/rust-2018/path-changes.md:160
msgid ""
"The prefix `::` previously referred to either the crate root or an external "
"crate; it now unambiguously refers to an external crate. For instance, "
"`::foo::bar` always refers to the name `bar` inside the external crate `foo`."
msgstr "이전에는 접두사 `::`가 크레이트 루트 또는 외부 크레이트를 참조했지만 이제는 명확하게 외부 크레이트를 참조합니다. 예를 들어, `::foo::bar`는 항상 외부 크레이트 `foo` 내의 `bar` 이름을 참조합니다."

#: src/rust-2018/path-changes.md:164
msgid "Extern crate paths"
msgstr "외부 크레이트 경로"

#: src/rust-2018/path-changes.md:166
msgid ""
"Previously, using an external crate in a module without a `use` import "
"required a leading `::` on the path."
msgstr "이전에는 `use` 가져오기 없이 모듈에서 외부 크레이트를 사용하려면 경로에 선행 `::`가 필요했습니다."

#: src/rust-2018/path-changes.md:175 src/rust-2018/path-changes.md:194
msgid "// this works in the crate root\n"
msgstr "// 이것은 크레이트 루트에서 작동합니다
"

#: src/rust-2018/path-changes.md:181
msgid ""
"// but in a submodule it requires a leading :: if not imported with `use`\n"
msgstr "// 그러나 하위 모듈에서는 `use`로 가져오지 않으면 선행 ::가 필요합니다
"

#: src/rust-2018/path-changes.md:187
msgid ""
"Now, extern crate names are in scope in the entire crate, including "
"submodules."
msgstr "이제 외부 크레이트 이름은 하위 모듈을 포함하여 전체 크레이트의 범위에 있습니다."

#: src/rust-2018/path-changes.md:200
msgid "// crates may be referenced directly, even in submodules\n"
msgstr "// 크레이트는 하위 모듈에서도 직접 참조할 수 있습니다
"

#: src/rust-2018/path-changes.md:206
msgid ""
"If you have a local module or item with the same name as an external crate, "
"a path beginning with that name will be taken to refer to the local module "
"or item. To explicitly refer to the external crate, use the `::name` form."
msgstr "외부 크레이트와 이름이 같은 로컬 모듈이나 항목이 있는 경우 해당 이름으로 시작하는 경로는 로컬 모듈이나 항목을 참조하는 것으로 간주됩니다. 외부 크레이트를 명시적으로 참조하려면 `::name` 형식을 사용하십시오."

#: src/rust-2018/path-changes.md:211
msgid "No more `mod.rs`"
msgstr "`mod.rs` 더 이상 없음"

#: src/rust-2018/path-changes.md:213
msgid "In Rust 2015, if you have a submodule:"
msgstr "Rust 2015에서 하위 모듈이 있는 경우:"

#: src/rust-2018/path-changes.md:216
msgid ""
"// This `mod` declaration looks for the `foo` module in\n"
"// `foo.rs` or `foo/mod.rs`.\n"
msgstr "// 이 `mod` 선언은 `foo` 모듈을
// `foo.rs` 또는 `foo/mod.rs`에서 찾습니다.
"

#: src/rust-2018/path-changes.md:221
msgid ""
"It can live in `foo.rs` or `foo/mod.rs`. If it has submodules of its own, it "
"_must_ be `foo/mod.rs`. So a `bar` submodule of `foo` would live at `foo/"
"bar.rs`."
msgstr "`foo.rs` 또는 `foo/mod.rs`에 있을 수 있습니다. 자체 하위 모듈이 있는 경우 _반드시_ `foo/mod.rs`여야 합니다. 따라서 `foo`의 `bar` 하위 모듈은 `foo/bar.rs`에 있습니다."

#: src/rust-2018/path-changes.md:225
msgid ""
"In Rust 2018 the restriction that a module with submodules must be named "
"`mod.rs` is lifted. `foo.rs` can just be `foo.rs`, and the submodule is "
"still `foo/bar.rs`. This eliminates the special name, and if you have a "
"bunch of files open in your editor, you can clearly see their names, instead "
"of having a bunch of tabs named `mod.rs`."
msgstr "Rust 2018에서는 하위 모듈이 있는 모듈의 이름이 `mod.rs`여야 한다는 제한이 해제되었습니다. `foo.rs`는 그냥 `foo.rs`일 수 있으며 하위 모듈은 여전히 `foo/bar.rs`입니다. 이렇게 하면 특수 이름이 제거되고 편집기에서 여러 파일을 열어두면 `mod.rs`라는 이름의 여러 탭 대신 이름을 명확하게 볼 수 있습니다."

#: src/rust-2018/path-changes.md:262
msgid "`use` paths"
msgstr "`use` 경로"

#: src/rust-2018/path-changes.md:264
msgid ""
"![Minimum Rust version: 1.32](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.32-brightgreen.svg)"
msgstr "![최소 Rust 버전: 1.32](https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg)"

#: src/rust-2018/path-changes.md:266
msgid ""
"Rust 2018 simplifies and unifies path handling compared to Rust 2015. In "
"Rust 2015, paths work differently in `use` declarations than they do "
"elsewhere. In particular, paths in `use` declarations would always start "
"from the crate root, while paths in other code implicitly started from the "
"current scope. Those differences didn't have any effect in the top-level "
"module, which meant that everything would seem straightforward until working "
"on a project large enough to have submodules."
msgstr "Rust 2018은 Rust 2015에 비해 경로 처리를 단순화하고 통합합니다. Rust 2015에서는 `use` 선언의 경로가 다른 곳과 다르게 작동합니다. 특히 `use` 선언의 경로는 항상 크레이트 루트에서 시작하는 반면 다른 코드의 경로는 암시적으로 현재 범위에서 시작했습니다. 이러한 차이점은 최상위 모듈에 영향을 미치지 않았으므로 하위 모듈이 있는 충분히 큰 프로젝트에서 작업할 때까지 모든 것이 간단해 보였습니다."

#: src/rust-2018/path-changes.md:274
msgid ""
"In Rust 2018, paths in `use` declarations and in other code work the same "
"way, both in the top-level module and in any submodule. You can use a "
"relative path from the current scope, a path starting from an external crate "
"name, or a path starting with `::`, `crate`, `super`, or `self`."
msgstr "Rust 2018에서는 `use` 선언 및 기타 코드의 경로가 최상위 모듈과 모든 하위 모듈에서 동일하게 작동합니다. 현재 범위의 상대 경로, 외부 크레이트 이름으로 시작하는 경로 또는 `::`, `crate`, `super` 또는 `self`로 시작하는 경로를 사용할 수 있습니다."

#: src/rust-2018/path-changes.md:279
msgid "Code that looked like this:"
msgstr "다음과 같이 보이는 코드:"

#: src/rust-2018/path-changes.md:311
msgid ""
"will look exactly the same in Rust 2018, except that you can delete the "
"`extern crate` line:"
msgstr "`extern crate` 줄을 삭제할 수 있다는 점을 제외하고 Rust 2018에서도 똑같이 보일 것입니다."

#: src/rust-2018/path-changes.md:342
msgid "The same code will also work completely unmodified in a submodule:"
msgstr "동일한 코드는 하위 모듈에서도 완전히 수정되지 않은 상태로 작동합니다."

#: src/rust-2018/path-changes.md:374
msgid ""
"This makes it easy to move code around in a project, and avoids introducing "
"additional complexity to multi-module projects."
msgstr "이렇게 하면 프로젝트에서 코드를 쉽게 이동할 수 있고 다중 모듈 프로젝트에 추가적인 복잡성을 도입하는 것을 방지할 수 있습니다."

#: src/rust-2018/trait-fn-parameters.md:7
msgid ""
"[Trait function parameters](https://doc.rust-lang.org/stable/reference/items/"
"traits.html#parameter-patterns) may use any irrefutable pattern when the "
"function has a body."
msgstr "[트레이트 함수 매개변수](https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns)는 함수에 본문이 있을 때 모든 반박할 수 없는 패턴을 사용할 수 있습니다."

#: src/rust-2018/trait-fn-parameters.md:12
#: src/rust-2018/tyvar-behind-raw-pointer.md:9 src/rust-2021/prelude.md:8
#: src/rust-2021/default-cargo-resolver.md:7
#: src/rust-2021/IntoIterator-for-arrays.md:11
#: src/rust-2021/disjoint-capture-in-closures.md:9
#: src/rust-2021/panic-macro-consistency.md:12
#: src/rust-2021/reserved-syntax.md:12 src/rust-2021/raw-lifetimes.md:7
#: src/rust-2021/warnings-promoted-to-error.md:7
#: src/rust-2021/or-patterns-macro-rules.md:10
#: src/rust-2021/c-string-literals.md:9
#: src/rust-2024/rpit-lifetime-capture.md:13
#: src/rust-2024/temporary-if-let-scope.md:7
#: src/rust-2024/temporary-tail-expr-scope.md:10
#: src/rust-2024/match-ergonomics.md:10 src/rust-2024/unsafe-extern.md:9
#: src/rust-2024/unsafe-attributes.md:14
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:10
#: src/rust-2024/static-mut-references.md:10
#: src/rust-2024/never-type-fallback.md:10
#: src/rust-2024/macro-fragment-specifiers.md:10
#: src/rust-2024/missing-macro-fragment-specifiers.md:9
#: src/rust-2024/gen-keyword.md:9 src/rust-2024/reserved-syntax.md:8
#: src/rust-2024/prelude.md:11 src/rust-2024/intoiterator-box-slice.md:12
#: src/rust-2024/newly-unsafe-functions.md:15 src/rust-2024/cargo-resolver.md:7
#: src/rust-2024/cargo-table-key-names.md:13
#: src/rust-2024/cargo-inherited-default-features.md:7
#: src/rust-2024/rustdoc-doctests.md:7
#: src/rust-2024/rustdoc-nested-includes.md:7
#: src/rust-2024/rustfmt-style-edition.md:7
#: src/rust-2024/rustfmt-formatting-fixes.md:7
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:9
#: src/rust-2024/rustfmt-version-sorting.md:7
msgid "Details"
msgstr "세부 정보"

#: src/rust-2018/trait-fn-parameters.md:14
msgid ""
"In accordance with RFC [\\#1685](https://github.com/rust-lang/rfcs/pull/"
"1685), parameters in trait method declarations are no longer allowed to be "
"anonymous."
msgstr "RFC [\#1685](https://github.com/rust-lang/rfcs/pull/1685)에 따라 트레이트 메서드 선언의 매개변수는 더 이상 익명으로 허용되지 않습니다."

#: src/rust-2018/trait-fn-parameters.md:17
msgid "For example, in the 2015 edition, this was allowed:"
msgstr "예를 들어, 2015 에디션에서는 이것이 허용되었습니다."

#: src/rust-2018/trait-fn-parameters.md:25
msgid ""
"In the 2018 edition, all parameters must be given an argument name  (even if "
"it's just `_`):"
msgstr "2018 에디션에서는 모든 매개변수에 인수 이름이 지정되어야 합니다(단지 `_`인 경우에도)."

#: src/rust-2018/new-keywords.md:3
msgid ""
"![Minimum Rust version: 1.27](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.27-brightgreen.svg)"
msgstr "![최소 Rust 버전: 1.27](https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg)"

#: src/rust-2018/new-keywords.md:7
msgid ""
"`dyn` is a [strict keyword](https://doc.rust-lang.org/reference/"
"keywords.html#strict-keywords), in 2015 it is a [weak keyword](https://"
"doc.rust-lang.org/reference/keywords.html#weak-keywords)."
msgstr "`dyn`은 [엄격한 키워드](https://doc.rust-lang.org/reference/keywords.html#strict-keywords)이며, 2015년에는 [약한 키워드](https://doc.rust-lang.org/reference/keywords.html#weak-keywords)입니다."

#: src/rust-2018/new-keywords.md:8
msgid ""
"`async` and `await` are [strict keywords](https://doc.rust-lang.org/"
"reference/keywords.html#strict-keywords)."
msgstr "`async` 및 `await`는 [엄격한 키워드](https://doc.rust-lang.org/reference/keywords.html#strict-keywords)입니다."

#: src/rust-2018/new-keywords.md:9
msgid ""
"`try` is a [reserved keyword](https://doc.rust-lang.org/reference/"
"keywords.html#reserved-keywords)."
msgstr "`try`는 [예약된 키워드](https://doc.rust-lang.org/reference/keywords.html#reserved-keywords)입니다."

#: src/rust-2018/new-keywords.md:17
msgid "`dyn Trait` for trait objects"
msgstr "트레이트 객체를 위한 `dyn Trait`"

#: src/rust-2018/new-keywords.md:19
msgid ""
"The `dyn Trait` feature is the new syntax for using trait objects. In short:"
msgstr "`dyn Trait` 기능은 트레이트 객체를 사용하기 위한 새로운 구문입니다. 간단히 말해서:"

#: src/rust-2018/new-keywords.md:21
msgid "`Box<Trait>` becomes `Box<dyn Trait>`"
msgstr "`Box<Trait>`는 `Box<dyn Trait>`가 됩니다."

#: src/rust-2018/new-keywords.md:22
msgid "`&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`"
msgstr "`&Trait` 및 `&mut Trait`는 `&dyn Trait` 및 `&mut dyn Trait`가 됩니다."

#: src/rust-2018/new-keywords.md:24
msgid "And so on. In code:"
msgstr "등등. 코드에서:"

#: src/rust-2018/new-keywords.md:30
msgid "// old\n"
msgstr "// 이전
"

#: src/rust-2018/new-keywords.md:35
msgid "// new\n"
msgstr "// 새로운
"

#: src/rust-2018/new-keywords.md:42
msgid "That's it!"
msgstr "그게 다입니다!"

#: src/rust-2018/new-keywords.md:44
msgid "Why?"
msgstr "왜?"

#: src/rust-2018/new-keywords.md:46
msgid ""
"Using just the trait name for trait objects turned out to be a bad decision. "
"The current syntax is often ambiguous and confusing, even to veterans, and "
"favors a feature that is not more frequently used than its alternatives, is "
"sometimes slower, and often cannot be used at all when its alternatives can."
msgstr "트레이트 객체에 트레이트 이름만 사용하는 것은 잘못된 결정으로 판명되었습니다. 현재 구문은 베테랑에게도 종종 모호하고 혼란스러우며, 대안보다 더 자주 사용되지 않고, 때로는 더 느리며, 대안을 사용할 수 있을 때 전혀 사용할 수 없는 기능을 선호합니다."

#: src/rust-2018/new-keywords.md:51
msgid ""
"Furthermore, with `impl Trait` arriving, \"`impl Trait` vs `dyn Trait`\" is "
"much more symmetric, and therefore a bit nicer, than \"`impl Trait` vs "
"`Trait`\". `impl Trait` is explained [here](../../rust-by-example/trait/"
"impl_trait.html)."
msgstr "또한 `impl Trait`가 등장하면서 "`impl Trait` 대 `dyn Trait`"는 "`impl Trait` 대 `Trait`"보다 훨씬 대칭적이므로 조금 더 좋습니다. `impl Trait`는 [여기](https://doc.rust-lang.org/rust-by-example/trait/impl_trait.html)에서 설명합니다."

#: src/rust-2018/new-keywords.md:55
msgid ""
"In the new edition, you should therefore prefer `dyn Trait` to just `Trait` "
"where you need a trait object."
msgstr "따라서 새 에디션에서는 트레이트 객체가 필요한 경우 `Trait` 대신 `dyn Trait`를 선호해야 합니다."

#: src/rust-2018/new-keywords.md:60
msgid "`async` and `await`"
msgstr "`async` 및 `await`"

#: src/rust-2018/new-keywords.md:62
msgid ""
"These keywords are reserved to implement the async-await feature of Rust, "
"which was ultimately [released to stable in 1.39.0](https://blog.rust-"
"lang.org/2019/11/07/Async-await-stable.html)."
msgstr "이러한 키워드는 Rust의 async-await 기능을 구현하기 위해 예약되었으며, 궁극적으로 [1.39.0에서 안정 버전으로 출시되었습니다](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html)."

#: src/rust-2018/new-keywords.md:64
msgid "`try` keyword"
msgstr "`try` 키워드"

#: src/rust-2018/new-keywords.md:66
msgid ""
"The `try` keyword is reserved for use in `try` blocks, which have not (as of "
"this writing) been stabilized ([tracking issue](https://github.com/rust-lang/"
"rust/issues/31436))"
msgstr "`try` 키워드는 `try` 블록에서 사용하기 위해 예약되었으며, (이 글을 쓰는 시점에는) 안정화되지 않았습니다([추적 문제](https://github.com/rust-lang/rust/issues/31436))."

#: src/rust-2018/tyvar-behind-raw-pointer.md:5
msgid ""
"The [`tyvar_behind_raw_pointer`](https://github.com/rust-lang/rust/issues/"
"46906) lint is now a hard error."
msgstr "[`tyvar_behind_raw_pointer`](https://github.com/rust-lang/rust/issues/46906) 린트는 이제 하드 오류입니다."

#: src/rust-2018/tyvar-behind-raw-pointer.md:11
msgid ""
"See Rust issue [\\#46906](https://github.com/rust-lang/rust/issues/46906) "
"for details."
msgstr "자세한 내용은 Rust 문제 [\#46906](https://github.com/rust-lang/rust/issues/46906)을 참조하십시오."

#: src/rust-2018/cargo.md:5
msgid ""
"If there is a target definition in a `Cargo.toml` manifest, it no longer "
"automatically disables automatic discovery of other targets."
msgstr "`Cargo.toml` 매니페스트에 대상 정의가 있는 경우 더 이상 다른 대상의 자동 검색을 자동으로 비활성화하지 않습니다."

#: src/rust-2018/cargo.md:7
msgid ""
"Target paths of the form `src/{target_name}.rs` are no longer inferred for "
"targets where the `path` field is not set."
msgstr "`path` 필드가 설정되지 않은 대상에 대해 `src/{target_name}.rs` 형식의 대상 경로는 더 이상 유추되지 않습니다."

#: src/rust-2018/cargo.md:9
msgid ""
"`cargo install` for the current directory is no longer allowed, you must "
"specify `cargo install --path .` to install the current package."
msgstr "현재 디렉토리에 대한 `cargo install`은 더 이상 허용되지 않으며, 현재 패키지를 설치하려면 `cargo install --path .`를 지정해야 합니다."

#: src/rust-2021/index.md:5
msgid "[\\#3085](https://github.com/rust-lang/rfcs/pull/3085)"
msgstr "[\#3085](https://github.com/rust-lang/rfcs/pull/3085)"

#: src/rust-2021/index.md:6
msgid "1.56.0"
msgstr "1.56.0"

#: src/rust-2021/index.md:8
msgid ""
"The Rust 2021 Edition contains several changes that bring new capabilities "
"and more consistency to the language, and opens up room for expansion in the "
"future. The following chapters dive into the details of each change, and "
"they include guidance on migrating your existing code."
msgstr "Rust 2021 에디션에는 언어에 새로운 기능과 일관성을 더하고 향후 확장을 위한 공간을 여는 몇 가지 변경 사항이 포함되어 있습니다. 다음 장에서는 각 변경 사항의 세부 정보를 자세히 살펴보고 기존 코드를 마이그레이션하는 방법에 대한 지침을 포함합니다."

#: src/rust-2021/prelude.md:5
msgid ""
"The `TryInto`, `TryFrom` and `FromIterator` traits are now part of the "
"prelude."
msgstr "`TryInto`, `TryFrom` 및 `FromIterator` 트레이트는 이제 프렐루드의 일부입니다."

#: src/rust-2021/prelude.md:6 src/rust-2024/prelude.md:6
msgid ""
"This might make calls to trait methods ambiguous which could make some code "
"fail to compile."
msgstr "이로 인해 트레이트 메서드 호출이 모호해져 일부 코드가 컴파일되지 않을 수 있습니다."

#: src/rust-2021/prelude.md:10
msgid ""
"The [prelude of the standard library](https://doc.rust-lang.org/stable/std/"
"prelude/index.html) is the module containing everything that is "
"automatically imported in every module. It contains commonly used items such "
"as `Option`, `Vec`, `drop`, and `Clone`."
msgstr "표준 라이브러리의 [프렐루드](https://doc.rust-lang.org/stable/std/prelude/index.html)는 모든 모듈에서 자동으로 가져오는 모든 것을 포함하는 모듈입니다. `Option`, `Vec`, `drop` 및 `Clone`과 같이 일반적으로 사용되는 항목을 포함합니다."

#: src/rust-2021/prelude.md:14 src/rust-2024/prelude.md:16
msgid ""
"The Rust compiler prioritizes any manually imported items over those from "
"the prelude, to make sure additions to the prelude will not break any "
"existing code. For example, if you have a crate or module called `example` "
"containing a `pub struct Option;`, then `use example::*;` will make `Option` "
"unambiguously refer to the one from `example`; not the one from the standard "
"library."
msgstr "Rust 컴파일러는 프렐루드에 추가된 항목이 기존 코드를 깨뜨리지 않도록 하기 위해 프렐루드의 항목보다 수동으로 가져온 항목을 우선시합니다. 예를 들어, `pub struct Option;`을 포함하는 `example`이라는 크레이트나 모듈이 있는 경우 `use example::*;`은 `Option`이 표준 라이브러리의 것이 아니라 `example`의 것을 명확하게 참조하도록 합니다."

#: src/rust-2021/prelude.md:20
msgid ""
"However, adding a _trait_ to the prelude can break existing code in a subtle "
"way. For example, a call to `x.try_into()` which comes from a `MyTryInto` "
"trait might fail to compile if `std`'s `TryInto` is also imported, because "
"the call to `try_into` is now ambiguous and could come from either trait. "
"This is the reason we haven't added `TryInto` to the prelude yet, since "
"there is a lot of code that would break this way."
msgstr "그러나 프렐루드에 _트레이트_를 추가하면 미묘한 방식으로 기존 코드가 깨질 수 있습니다. 예를 들어, `MyTryInto` 트레이트에서 오는 `x.try_into()` 호출은 `std`의 `TryInto`도 가져온 경우 컴파일에 실패할 수 있습니다. `try_into` 호출이 이제 모호하고 어느 트레이트에서든 올 수 있기 때문입니다. 이것이 우리가 아직 `TryInto`를 프렐루드에 추가하지 않은 이유입니다. 이런 식으로 깨질 코드가 많기 때문입니다."

#: src/rust-2021/prelude.md:26
msgid ""
"As a solution, Rust 2021 will use a new prelude. It's identical to the "
"current one, except for three new additions:"
msgstr "해결책으로 Rust 2021은 새로운 프렐루드를 사용합니다. 세 가지 새로운 추가 사항을 제외하고는 현재 것과 동일합니다."

#: src/rust-2021/prelude.md:29
msgid ""
"[`std::convert::TryInto`](https://doc.rust-lang.org/stable/std/convert/"
"trait.TryInto.html)"
msgstr "[`std::convert::TryInto`](https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html)"

#: src/rust-2021/prelude.md:30
msgid ""
"[`std::convert::TryFrom`](https://doc.rust-lang.org/stable/std/convert/"
"trait.TryFrom.html)"
msgstr "[`std::convert::TryFrom`](https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html)"

#: src/rust-2021/prelude.md:31
msgid ""
"[`std::iter::FromIterator`](https://doc.rust-lang.org/stable/std/iter/"
"trait.FromIterator.html)"
msgstr "[`std::iter::FromIterator`](https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html)"

#: src/rust-2021/prelude.md:33
msgid ""
"The tracking issue [can be found here](https://github.com/rust-lang/rust/"
"issues/85684)."
msgstr "추적 문제는 [여기](https://github.com/rust-lang/rust/issues/85684)에서 찾을 수 있습니다."

#: src/rust-2021/prelude.md:35 src/rust-2021/default-cargo-resolver.md:30
#: src/rust-2021/IntoIterator-for-arrays.md:53
#: src/rust-2021/disjoint-capture-in-closures.md:31
#: src/rust-2021/panic-macro-consistency.md:62
#: src/rust-2021/reserved-syntax.md:52 src/rust-2021/raw-lifetimes.md:15
#: src/rust-2021/or-patterns-macro-rules.md:37
#: src/rust-2021/c-string-literals.md:65
#: src/rust-2024/rpit-lifetime-capture.md:135
#: src/rust-2024/temporary-if-let-scope.md:61
#: src/rust-2024/temporary-tail-expr-scope.md:88
#: src/rust-2024/match-ergonomics.md:102 src/rust-2024/unsafe-extern.md:37
#: src/rust-2024/unsafe-attributes.md:60
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:42
#: src/rust-2024/static-mut-references.md:353
#: src/rust-2024/never-type-fallback.md:62
#: src/rust-2024/macro-fragment-specifiers.md:34
#: src/rust-2024/missing-macro-fragment-specifiers.md:32
#: src/rust-2024/gen-keyword.md:15 src/rust-2024/reserved-syntax.md:46
#: src/rust-2024/prelude.md:32 src/rust-2024/intoiterator-box-slice.md:48
#: src/rust-2024/newly-unsafe-functions.md:38
#: src/rust-2024/cargo-resolver.md:30 src/rust-2024/cargo-table-key-names.md:37
#: src/rust-2024/cargo-inherited-default-features.md:37
#: src/rust-2024/rustdoc-doctests.md:73
#: src/rust-2024/rustdoc-nested-includes.md:43
#: src/rust-2024/rustfmt-style-edition.md:70
#: src/rust-2024/rustfmt-formatting-fixes.md:640
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:32
#: src/rust-2024/rustfmt-version-sorting.md:37
msgid "Migration"
msgstr "마이그레이션"

#: src/rust-2021/prelude.md:37
msgid ""
"As a part of the 2021 edition a migration lint, "
"`rust_2021_prelude_collisions`, has been added in order to aid in automatic "
"migration of Rust 2018 codebases to Rust 2021."
msgstr "2021 에디션의 일부로 Rust 2018 코드베이스를 Rust 2021로 자동 마이그레이션하는 데 도움이 되도록 마이그레이션 린트인 `rust_2021_prelude_collisions`가 추가되었습니다."

#: src/rust-2021/prelude.md:39 src/rust-2021/disjoint-capture-in-closures.md:35
#: src/rust-2021/reserved-syntax.md:56 src/rust-2021/raw-lifetimes.md:19
msgid "In order to migrate your code to be Rust 2021 Edition compatible, run:"
msgstr "코드를 Rust 2021 에디션과 호환되도록 마이그레이션하려면 다음을 실행하십시오."

#: src/rust-2021/prelude.md:45
msgid ""
"The lint detects cases where functions or methods are called that have the "
"same name as the methods defined in one of the new prelude traits. In some "
"cases, it may rewrite your calls in various ways to ensure that you continue "
"to call the same function you did before."
msgstr "린트는 새 프렐루드 트레이트 중 하나에 정의된 메서드와 이름이 같은 함수나 메서드가 호출되는 경우를 감지합니다. 경우에 따라 이전에 호출했던 것과 동일한 함수를 계속 호출하도록 호출을 다양한 방식으로 다시 작성할 수 있습니다."

#: src/rust-2021/prelude.md:47
msgid ""
"If you'd like to migrate your code manually or better understand what `cargo "
"fix` is doing, below we've outlined the situations where a migration is "
"needed along with a counter example of when it's not needed."
msgstr "코드를 수동으로 마이그레이션하거나 `cargo fix`가 수행하는 작업을 더 잘 이해하고 싶다면 아래에 마이그레이션이 필요한 상황과 필요하지 않은 경우의 반대 예를 간략하게 설명했습니다."

#: src/rust-2021/prelude.md:49
msgid "Migration needed"
msgstr "마이그레이션 필요"

#: src/rust-2021/prelude.md:51 src/rust-2024/prelude.md:34
msgid "Conflicting trait methods"
msgstr "충돌하는 트레이트 메서드"

#: src/rust-2021/prelude.md:53 src/rust-2024/prelude.md:36
msgid ""
"When two traits that are in scope have the same method name, it is ambiguous "
"which trait method should be used. For example:"
msgstr "범위에 있는 두 트레이트의 메서드 이름이 같으면 어떤 트레이트 메서드를 사용해야 할지 모호합니다. 예를 들어:"

#: src/rust-2021/prelude.md:57
msgid ""
"// This name is the same as the `from_iter` method on the `FromIterator` "
"trait from `std`.  \n"
msgstr "// 이 이름은 `std`의 `FromIterator` 트레이트에 있는 `from_iter` 메서드와 같습니다.  
"

#: src/rust-2021/prelude.md:66
msgid ""
"// Vec<T> implements both `std::iter::FromIterator` and `MyTrait` \n"
"  // If both traits are in scope (as would be the case in Rust 2021),\n"
"  // then it becomes ambiguous which `from_iter` method to call\n"
msgstr "// Vec<T>는 `std::iter::FromIterator`와 `MyTrait`를 모두 구현합니다
  // 두 트레이트가 모두 범위에 있는 경우(Rust 2021의 경우와 같음),
  // 그러면 어떤 `from_iter` 메서드를 호출해야 할지 모호해집니다
"

#: src/rust-2021/prelude.md:73
msgid "We can fix this by using fully qualified syntax:"
msgstr "완전 정규화된 구문을 사용하여 이 문제를 해결할 수 있습니다."

#: src/rust-2021/prelude.md:77 src/rust-2024/prelude.md:60
msgid "// Now it is clear which trait method we're referring to\n"
msgstr "// 이제 어떤 트레이트 메서드를 참조하는지 명확합니다
"

#: src/rust-2021/prelude.md:82
msgid "Inherent methods on `dyn Trait` objects"
msgstr "`dyn Trait` 객체의 고유 메서드"

#: src/rust-2021/prelude.md:84
msgid ""
"Some users invoke methods on a `dyn Trait` value where the method name "
"overlaps with a new prelude trait:"
msgstr ""
"일부 사용자는 `dyn Trait` 값에 대해 메서드를 호출하는데, 이 메서드 이름이 새로운 prelude 특성과 겹칩니다."

#: src/rust-2021/prelude.md:89
msgid "// This has the same name as `TryInto::try_into`\n"
msgstr "// 이것은 `TryInto::try_into`와 같은 이름을 갖습니다.\n"

#: src/rust-2021/prelude.md:93
msgid ""
"// `MyTrait` isn't in scope here and can only be referred to through the "
"path `submodule::MyTrait`\n"
msgstr ""
"// `MyTrait`는 여기 범위에 포함되지 않으며 "
"경로 `submodule::MyTrait`\n"을 통해서만 참조될 수 있습니다.

#: src/rust-2021/prelude.md:96
msgid ""
"// If `std::convert::TryInto` is in scope (as would be the case in Rust "
"2021),\n"
"  // then it becomes ambiguous which `try_into` method to call\n"
msgstr ""
"// `std::convert::TryInto`가 범위 내에 있는 경우(Rust의 경우처럼)\n"
"2021",\n"
" // 어떤 `try_into` 메서드를 호출해야 할지 모호해집니다\n"

#: src/rust-2021/prelude.md:102
msgid ""
"Unlike with static dispatch methods, calling a trait method on a trait "
"object does not require that the trait be in scope. The code above works as "
"long as there is no trait in scope with a conflicting method name. When the "
"`TryInto` trait is in scope (which is the case in Rust 2021), this causes an "
"ambiguity. Should the call be to `MyTrait::try_into` or "
"`std::convert::TryInto::try_into`?"
msgstr ""
정적 디스패치 메서드와 달리, 트레이트 객체에서 트레이트 메서드를 호출할 때 해당 트레이트가 범위 내에 있어야 할 필요는 없습니다. 위 코드는 범위 내에 메서드 이름이 충돌하는 트레이트가 없는 한 정상적으로 작동합니다. `TryInto` 트레이트가 범위 내에 있는 경우(Rust 2021의 경우), 이는 모호성을 발생시킵니다. `MyTrait::try_into`를 호출해야 할까요, 아니면 `std::convert::TryInto::try_into`를 호출해야 할까요?

#: src/rust-2021/prelude.md:106
msgid ""
"In these cases, we can fix this by adding an additional dereferences or "
"otherwise clarify the type of the method receiver. This ensures that the "
"`dyn Trait` method is chosen, versus the methods from the prelude trait. For "
"example, turning `f.try_into()` above into `(&*f).try_into()` ensures that "
"we're calling `try_into` on the `dyn MyTrait` which can only refer to the "
"`MyTrait::try_into` method."
msgstr ""
"이런 경우에는 추가적인 역참조를 추가하거나, "
"메서드 수신자의 타입을 명확히 하여 이 문제를 해결할 수 있습니다. 이렇게 하면 "
"prelude 특성의 메서드 대신 "
"`dyn Trait` 메서드가 선택됩니다. "
"예를 들어, 위의 "f.try_into()`를 "(&*f).try_into()`로 변환하면 "
"`dyn MyTrait`에서 "
"`MyTrait::try_into` 메서드만 참조할 수 있는 "
"`try_into`를 호출하게 됩니다."

#: src/rust-2021/prelude.md:110
msgid "No migration needed"
msgstr "마이그레이션이 필요 없습니다"

#: src/rust-2021/prelude.md:112
msgid "Inherent methods"
msgstr "고유한 방법"

#: src/rust-2021/prelude.md:114
msgid ""
"Many types define their own inherent methods with the same name as a trait "
"method. For instance, below the struct `MyStruct` implements `from_iter` "
"which shares the same name with the method from the trait `FromIterator` "
"found in the standard library:"
msgstr ""
"많은 타입이 특성과 동일한 이름을 가진 자체 내장 메서드를 정의합니다."
"메서드입니다. 예를 들어, 아래 구조체 `MyStruct`는 `from_iter`를 구현합니다."
"이 메서드는 표준 라이브러리에 있는 특성 `FromIterator`의 메서드와 동일한 이름을 공유합니다."


#: src/rust-2021/prelude.md:124
msgid "// This has the same name as `std::iter::FromIterator::from_iter`\n"
msgstr "// 이것은 `std::iter::FromIterator::from_iter`와 이름이 같습니다\n"

#: src/rust-2021/prelude.md:141
msgid ""
"Inherent methods always take precedent over trait methods so there's no need "
"for any migration."
msgstr "고유 메서드는 항상 트레이트 메서드보다 우선하므로 마이그레이션이 필요하지 않습니다."

#: src/rust-2021/prelude.md:143
msgid "Implementation Reference"
msgstr "구현 참조"

#: src/rust-2021/prelude.md:145
msgid ""
"The lint needs to take a couple of factors into account when determining "
"whether or not introducing 2021 Edition to a codebase will cause a name "
"resolution collision (thus breaking the code after changing edition). These "
"factors include:"
msgstr "린트는 2021 에디션을 코드베이스에 도입하는 것이 이름 확인 충돌을 일으킬지(따라서 에디션 변경 후 코드가 깨지는지) 여부를 결정할 때 몇 가지 요소를 고려해야 합니다. 이러한 요소는 다음과 같습니다."

#: src/rust-2021/prelude.md:147
msgid ""
"Is the call a [fully-qualified call](https://doc.rust-lang.org/reference/"
"expressions/call-expr.html#disambiguating-function-calls) or does it use "
"[dot-call method syntax](https://doc.rust-lang.org/reference/expressions/"
"method-call-expr.html)?"
msgstr "호출이 [완전 정규화된 호출](https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls)입니까, 아니면 [점-호출 메서드 구문](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)을 사용합니까?"

#: src/rust-2021/prelude.md:148
msgid ""
"This will affect how the name is resolved due to auto-reference and auto-"
"dereferencing on method call syntax. Manually dereferencing/referencing will "
"allow specifying priority in the case of dot-call method syntax, while fully-"
"qualified call requires specification of the type and the trait name in the "
"method path (e.g. `<Type as Trait>::method`)"
msgstr "이것은 메서드 호출 구문에서 자동 참조 및 자동 역참조로 인해 이름이 확인되는 방식에 영향을 줍니다. 수동으로 역참조/참조하면 점-호출 메서드 구문의 경우 우선순위를 지정할 수 있지만, 완전 정규화된 호출은 메서드 경로에서 유형과 트레이트 이름을 지정해야 합니다(예: `<Type as Trait>::method`)."

#: src/rust-2021/prelude.md:149
msgid ""
"Is this an [inherent method](https://doc.rust-lang.org/reference/items/"
"implementations.html#inherent-implementations) or [a trait method](https://"
"doc.rust-lang.org/reference/items/implementations.html#trait-"
"implementations)?"
msgstr "이것은 [고유 메서드](https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations)입니까, 아니면 [트레이트 메서드](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations)입니까?"

#: src/rust-2021/prelude.md:150
msgid ""
"Inherent methods that take `self` will take priority over "
"`TryInto::try_into` as inherent methods take priority over trait methods, "
"but inherent methods that take `&self` or `&mut self` won't take priority "
"due to requiring a auto-reference (while `TryInto::try_into` does not, as it "
"takes `self`)"
msgstr "`self`를 사용하는 고유 메서드는 `TryInto::try_into`보다 우선합니다. 고유 메서드가 트레이트 메서드보다 우선하기 때문입니다. 그러나 `&self` 또는 `&mut self`를 사용하는 고유 메서드는 자동 참조가 필요하기 때문에 우선하지 않습니다(`TryInto::try_into`는 `self`를 사용하므로 그렇지 않습니다)."

#: src/rust-2021/prelude.md:151
msgid ""
"Is the origin of this method from `core`/`std`? (As the traits can't have a "
"collision with themselves)"
msgstr "이 메서드의 출처는 `core`/`std`입니까? (트레이트는 자신과 충돌할 수 없으므로)"

#: src/rust-2021/prelude.md:152
msgid ""
"Does the given type implement the trait it could have a collision against?"
msgstr "주어진 유형이 충돌할 수 있는 트레이트를 구현합니까?"

#: src/rust-2021/prelude.md:153
msgid ""
"Is the method being called via dynamic dispatch? (i.e. is the `self` type "
"`dyn Trait`)"
msgstr "메서드가 동적 디스패치를 통해 호출됩니까? (즉, `self` 유형이 `dyn Trait`입니까)"

#: src/rust-2021/prelude.md:154
msgid ""
"If so, trait imports don't affect resolution, and no migration lint needs to "
"occur"
msgstr "그렇다면 트레이트 가져오기는 확인에 영향을 미치지 않으며 마이그레이션 린트가 발생할 필요가 없습니다."

#: src/rust-2021/default-cargo-resolver.md:5
msgid "`edition = \"2021\"` implies `resolver = \"2\"` in `Cargo.toml`."
msgstr "`edition = \"2021\"`은 `Cargo.toml`에서 `resolver = \"2\"`를 의미합니다."

#: src/rust-2021/default-cargo-resolver.md:9
msgid ""
"Since Rust 1.51.0, Cargo has opt-in support for a [new feature resolver]"
"(../../cargo/reference/resolver.html#feature-resolver-version-2) which can "
"be activated with `resolver = \"2\"` in `Cargo.toml`."
msgstr "Rust 1.51.0부터 Cargo는 `Cargo.toml`에서 `resolver = \"2\"`로 활성화할 수 있는 [새로운 기능 해석기](.../../cargo/reference/resolver.html#feature-resolver-version-2)에 대한 옵트인 지원을 제공합니다."

#: src/rust-2021/default-cargo-resolver.md:12
msgid ""
"Starting in Rust 2021, this will be the default. That is, writing `edition = "
"\"2021\"` in `Cargo.toml` will imply `resolver = \"2\"`."
msgstr "Rust 2021부터 이것이 기본값이 됩니다. 즉, `Cargo.toml`에 `edition = \"2021\"`을 작성하면 `resolver = \"2\"`를 의미합니다."

#: src/rust-2021/default-cargo-resolver.md:15
#: src/rust-2024/cargo-resolver.md:17
msgid ""
"The resolver is a global setting for a [workspace](../../cargo/reference/"
"workspaces.html), and the setting is ignored in dependencies. The setting is "
"only honored for the top-level package of the workspace. If you are using a "
"[virtual workspace](../../cargo/reference/workspaces.html#virtual-"
"workspace), you will still need to explicitly set the [`resolver` field]"
"(../../cargo/reference/resolver.html#resolver-versions) in the `[workspace]` "
"definition if you want to opt-in to the new resolver."
msgstr "해석기는 [작업 공간](../../cargo/reference/workspaces.html)에 대한 전역 설정이며 종속성에서는 설정이 무시됩니다. 이 설정은 작업 공간의 최상위 패키지에만 적용됩니다. [가상 작업 공간](../../cargo/reference/workspaces.html#virtual-workspace)을 사용하는 경우 새 해석기를 옵트인하려면 `[workspace]` 정의에서 [`resolver` 필드](../../cargo/reference/resolver.html#resolver-versions)를 명시적으로 설정해야 합니다."

#: src/rust-2021/default-cargo-resolver.md:20
msgid ""
"The new feature resolver no longer merges all requested features for crates "
"that are depended on in multiple ways. See [the announcement of Rust 1.51]"
"(https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-"
"resolver) for details."
msgstr "새로운 기능 해석기는 더 이상 여러 방식으로 종속된 크레이트에 대해 요청된 모든 기능을 병합하지 않습니다. 자세한 내용은 [Rust 1.51 발표](https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver)를 참조하십시오."

#: src/rust-2021/default-cargo-resolver.md:32
msgid ""
"There are no automated migration tools for updating for the new resolver. "
"For most projects, there are usually few or no changes as a result of "
"updating."
msgstr "새 해석기로 업데이트하기 위한 자동화된 마이그레이션 도구는 없습니다. 대부분의 프로젝트에서는 업데이트로 인해 변경 사항이 거의 또는 전혀 없습니다."

#: src/rust-2021/default-cargo-resolver.md:35
msgid ""
"When updating with `cargo fix --edition`, Cargo will display a report if the "
"new resolver will build dependencies with different features. It may look "
"something like this:"
msgstr "`cargo fix --edition`으로 업데이트할 때 새 해석기가 다른 기능으로 종속성을 빌드하는 경우 Cargo는 보고서를 표시합니다. 다음과 같이 보일 수 있습니다."

#: src/rust-2021/default-cargo-resolver.md:38
msgid ""
"note: Switching to Edition 2021 will enable the use of the version 2 feature "
"resolver in Cargo. This may cause some dependencies to be built with fewer "
"features enabled than previously. More information about the resolver "
"changes may be found at <https://doc.rust-lang.org/nightly/edition-guide/"
"rust-2021/default-cargo-resolver.html><br> When building the following "
"dependencies, the given features will no longer be used:"
msgstr "참고: 2021 에디션으로 전환하면 Cargo에서 버전 2 기능 해석기를 사용할 수 있습니다. 이로 인해 일부 종속성이 이전보다 더 적은 기능으로 빌드될 수 있습니다. 해석기 변경에 대한 자세한 내용은 <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html>에서 확인할 수 있습니다.<br> 다음 종속성을 빌드할 때 주어진 기능은 더 이상 사용되지 않습니다."

#: src/rust-2021/default-cargo-resolver.md:48
msgid ""
"This lets you know that certain dependencies will no longer be built with "
"the given features."
msgstr "이를 통해 특정 종속성이 더 이상 주어진 기능으로 빌드되지 않음을 알 수 있습니다."

#: src/rust-2021/default-cargo-resolver.md:50
msgid "Build failures"
msgstr "빌드 실패"

#: src/rust-2021/default-cargo-resolver.md:52
msgid ""
"There may be some circumstances where your project may not build correctly "
"after the change. If a dependency declaration in one package assumes that "
"certain features are enabled in another, and those features are now "
"disabled, it may fail to compile."
msgstr "변경 후 프로젝트가 올바르게 빌드되지 않는 경우가 있을 수 있습니다. 한 패키지의 종속성 선언이 다른 패키지에서 특정 기능이 활성화되어 있다고 가정하고 해당 기능이 이제 비활성화된 경우 컴파일에 실패할 수 있습니다."

#: src/rust-2021/default-cargo-resolver.md:55
msgid "For example, let's say we have a dependency like this:"
msgstr "예를 들어, 다음과 같은 종속성이 있다고 가정해 보겠습니다."

#: src/rust-2021/default-cargo-resolver.md:57
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[dependencies]\n"
"bstr = { version = \"0.2.16\", default-features = false }\n"
"# ...\n"
"```"
msgstr "```toml\n# Cargo.toml\n\n[dependencies]\nbstr = { version = \"0.2.16\", default-features = false }\n# ...\n```"

#: src/rust-2021/default-cargo-resolver.md:65
msgid "And somewhere in our dependency tree, another package has this:"
msgstr "그리고 종속성 트리의 어딘가에 다른 패키지에 다음이 있습니다."

#: src/rust-2021/default-cargo-resolver.md:67
msgid ""
"```toml\n"
"# Another package's Cargo.toml\n"
"\n"
"[build-dependencies]\n"
"bstr = \"0.2.16\"\n"
"```"
msgstr "```toml\n# Another package\'s Cargo.toml\n\n[build-dependencies]\nbstr = \"0.2.16\"\n```"

#: src/rust-2021/default-cargo-resolver.md:74
msgid ""
"In our package, we've been using the [`words_with_breaks`](https://docs.rs/"
"bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks) method from "
"`bstr`, which requires `bstr`'s  \"unicode\" feature to be enabled. This has "
"historically worked because Cargo unified the features of `bstr` between the "
"two packages. However, after updating to Rust 2021, the new resolver will "
"build `bstr` twice, once with the default features (as a build dependency), "
"and once with no features (as our normal dependency). Since `bstr` is now "
"being built without the \"unicode\" feature, the `words_with_breaks` method "
"doesn't exist, and the build will fail with an error that the method is "
"missing."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:79
msgid ""
"The solution here is to ensure that the dependency is declared with the "
"features you are actually using. For example:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:82
msgid ""
"```toml\n"
"[dependencies]\n"
"bstr = { version = \"0.2.16\", default-features = false, features = "
"[\"unicode\"] }\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:87
msgid ""
"In some cases, this may be a problem with a third-party dependency that you "
"don't have direct control over. You can consider submitting a patch to that "
"project to try to declare the correct set of features for the problematic "
"dependency. Alternatively, you can add features to any dependency from "
"within your own `Cargo.toml` file. For example, if the `bstr` example given "
"above was declared in some third-party dependency, you can just copy the "
"correct dependency declaration into your own project. The features will be "
"unified, as long as they match the unification rules of the new resolver. "
"Those are:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:93
msgid ""
"Features enabled on platform-specific dependencies for targets not currently "
"being built are ignored."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:94
msgid ""
"Build-dependencies and proc-macros do not share features with normal "
"dependencies."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:95
msgid ""
"Dev-dependencies do not activate features unless building a target that "
"needs them (like tests or examples)."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:97
msgid ""
"A real-world example is using [`diesel`](https://crates.io/crates/diesel) "
"and [`diesel_migrations`](https://crates.io/crates/diesel_migrations). These "
"packages provide database support, and the database is selected using a "
"feature, like this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:100
msgid ""
"```toml\n"
"[dependencies]\n"
"diesel = { version = \"1.4.7\", features = [\"postgres\"] }\n"
"diesel_migrations = \"1.4.0\"\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:106
msgid ""
"The problem is that `diesel_migrations` has an internal proc-macro which "
"itself depends on `diesel`, and the proc-macro assumes its own copy of "
"`diesel` has the same features enabled as the rest of the dependency graph. "
"After updating to the new resolver, it fails to build because now there are "
"two copies of `diesel`, and the one built for the proc-macro is missing the "
"\"postgres\" feature."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:109
msgid ""
"A solution here is to add `diesel` as a build-dependency with the required "
"features, for example:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:111
msgid ""
"```toml\n"
"[build-dependencies]\n"
"diesel = { version = \"1.4.7\", features = [\"postgres\"] }\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:116
msgid ""
"This causes Cargo to add \"postgres\" as a feature for host dependencies "
"(proc-macros and build-dependencies). Now, the `diesel_migrations` proc-"
"macro will get the \"postgres\" feature enabled, and it will build correctly."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:119
msgid ""
"The 2.0 release of `diesel` (currently in development) does not have this "
"problem as it has been restructured to not have this dependency requirement."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:121
msgid "Exploring features"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:123
msgid ""
"The [`cargo tree`](../../cargo/commands/cargo-tree.html) command has had "
"substantial improvements to help with the migration to the new resolver. "
"`cargo tree` can be used to explore the dependency graph, and to see which "
"features are being enabled, and importantly _why_ they are being enabled."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:126
msgid ""
"One option is to use the `--duplicates` flag (`-d` for short), which will "
"tell you when a package is being built multiple times. Taking the `bstr` "
"example from earlier, we might see:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:141
msgid ""
"This output tells us that `bstr` is built twice, and shows the chain of "
"dependencies that led to its inclusion in both cases."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:143
msgid ""
"You can print which features each package is using with the `-f` flag, like "
"this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:149
msgid ""
"This tells Cargo to change the \"format\" of the output, where it will print "
"both the package and the enabled features."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:151
msgid ""
"You can also use the `-e` flag to tell it which \"edges\" to display. For "
"example, `cargo tree -e features` will show in-between each dependency which "
"features are being added by each dependency. This option becomes more useful "
"with the `-i` flag which can be used to \"invert\" the tree. This allows you "
"to see how features _flow_ into a given dependency. For example, let's say "
"the dependency graph is large, and we're not quite sure who is depending on "
"`bstr`, the following command will show that:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:157
msgid ""
"```console\n"
"> cargo tree -e features -i bstr\n"
"bstr v0.2.16\n"
"├── bstr feature \"default\"\n"
"│   [build-dependencies]\n"
"│   └── bar v0.1.0\n"
"│       └── bar feature \"default\"\n"
"│           └── foo v0.1.0 (/MyProjects/foo)\n"
"├── bstr feature \"lazy_static\"\n"
"│   └── bstr feature \"unicode\"\n"
"│       └── bstr feature \"default\" (*)\n"
"├── bstr feature \"regex-automata\"\n"
"│   └── bstr feature \"unicode\" (*)\n"
"├── bstr feature \"std\"\n"
"│   └── bstr feature \"default\" (*)\n"
"└── bstr feature \"unicode\" (*)\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:175
msgid ""
"This snippet of output shows that the project `foo` depends on `bar` with "
"the \"default\" feature. Then, `bar` depends on `bstr` as a build-dependency "
"with the \"default\" feature. We can further see that `bstr`'s  \"default\" "
"feature enables \"unicode\" (among other features)."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:5
msgid "Arrays implement `IntoIterator` in _all_ editions."
msgstr "배열은 _모든_ 에디션에서 `IntoIterator`를 구현합니다."

#: src/rust-2021/IntoIterator-for-arrays.md:6
msgid ""
"Calls to `IntoIterator::into_iter` are _hidden_ in Rust 2015 and Rust 2018 "
"when using method call syntax (i.e., `array.into_iter()`). So, "
"`array.into_iter()` still resolves to `(&array).into_iter()` as it has "
"before."
msgstr "`IntoIterator::into_iter` 호출은 메서드 호출 구문(예: `array.into_iter()`)을 사용할 때 Rust 2015 및 Rust 2018에서 _숨겨져_ 있습니다. 따라서 `array.into_iter()`는 이전과 같이 여전히 `(&array).into_iter()`로 확인됩니다."

#: src/rust-2021/IntoIterator-for-arrays.md:9
msgid ""
"`array.into_iter()` changes meaning to be the call to "
"`IntoIterator::into_iter` in Rust 2021."
msgstr "`array.into_iter()`는 Rust 2021에서 `IntoIterator::into_iter` 호출을 의미하도록 변경됩니다."

#: src/rust-2021/IntoIterator-for-arrays.md:13
msgid ""
"Until Rust 1.53, only _references_ to arrays implement `IntoIterator`. This "
"means you can iterate over `&[1, 2, 3]` and `&mut [1, 2, 3]`, but not over "
"`[1, 2, 3]` directly."
msgstr "Rust 1.53까지는 배열에 대한 _참조_만 `IntoIterator`를 구현합니다. 즉, `&[1, 2, 3]` 및 `&mut [1, 2, 3]`에 대해 반복할 수 있지만 `[1, 2, 3]`에 대해서는 직접 반복할 수 없습니다."

#: src/rust-2021/IntoIterator-for-arrays.md:18
msgid "// Ok :)\n"
msgstr "// 정상 :)\n"

#: src/rust-2021/IntoIterator-for-arrays.md:20
msgid "// Error :(\n"
msgstr "// 오류 :(\n"

#: src/rust-2021/IntoIterator-for-arrays.md:23
msgid ""
"This has been [a long-standing issue](https://github.com/rust-lang/rust/"
"issues/25725), but the solution is not as simple as it seems. Just [adding "
"the trait implementation](https://github.com/rust-lang/rust/pull/65819) "
"would break existing code. `array.into_iter()` already compiles today "
"because that implicitly calls `(&array).into_iter()` due to [how method call "
"syntax works](https://doc.rust-lang.org/book/ch05-03-method-"
"syntax.html#wheres-the---operator). Adding the trait implementation would "
"change the meaning."
msgstr "이것은 [오래된 문제](https://github.com/rust-lang/rust/issues/25725)였지만 해결책은 보이는 것처럼 간단하지 않습니다. 단순히 [트레이트 구현을 추가](https://github.com/rust-lang/rust/pull/65819)하면 기존 코드가 깨질 것입니다. `array.into_iter()`는 [메서드 호출 구문이 작동하는 방식](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator) 때문에 암시적으로 `(&array).into_iter()`를 호출하므로 오늘날 이미 컴파일됩니다. 트레이트 구현을 추가하면 의미가 변경됩니다."

#: src/rust-2021/IntoIterator-for-arrays.md:29
msgid ""
"Usually this type of breakage (adding a trait implementation) is categorized "
"as 'minor' and acceptable. But in this case there is too much code that "
"would be broken by it."
msgstr "일반적으로 이러한 유형의 손상(트레이트 구현 추가)은 '사소한' 것으로 분류되어 허용됩니다. 그러나 이 경우에는 너무 많은 코드가 깨질 것입니다."

#: src/rust-2021/IntoIterator-for-arrays.md:32
msgid ""
"It has been suggested many times to \\\"only implement `IntoIterator` for "
"arrays in Rust 2021\\\". However, this is simply not possible. You can't have "
"a trait implementation exist in one edition and not in another, since "
"editions can be mixed."
msgstr "Rust 2021에서만 배열에 대해 `IntoIterator`를 구현하자는 제안이 여러 번 있었습니다. 그러나 이것은 단순히 불가능합니다. 에디션이 혼합될 수 있으므로 한 에디션에는 존재하고 다른 에디션에는 존재하지 않는 트레이트 구현을 가질 수 없습니다."

#: src/rust-2021/IntoIterator-for-arrays.md:37
msgid ""
"Instead, the trait implementation was added in _all_ editions (starting in "
"Rust 1.53.0) but with a small hack to avoid breakage until Rust 2021. In "
"Rust 2015 and 2018 code, the compiler will still resolve `array.into_iter()` "
"to `(&array).into_iter()` like before, as if the trait implementation does "
"not exist. This _only_ applies to the `.into_iter()` method call syntax. It "
"does not affect any other syntax such as `for e in [1, 2, 3]`, `iter.zip([1, "
"2, 3])` or `IntoIterator::into_iter([1, 2, 3])`. Those will start to work in "
"_all_ editions."
msgstr "대신, 트레이트 구현은 _모든_ 에디션(Rust 1.53.0부터 시작)에 추가되었지만 Rust 2021까지 손상을 피하기 위한 작은 핵이 있습니다. Rust 2015 및 2018 코드에서 컴파일러는 이전과 같이 트레이트 구현이 존재하지 않는 것처럼 `array.into_iter()`를 `(&array).into_iter()`로 계속 확인합니다. 이것은 `.into_iter()` 메서드 호출 구문에만 _적용_됩니다. `for e in [1, 2, 3]`, `iter.zip([1, 2, 3])` 또는 `IntoIterator::into_iter([1, 2, 3])`와 같은 다른 구문에는 영향을 미치지 않습니다. 이것들은 _모든_ 에디션에서 작동하기 시작할 것입니다."

#: src/rust-2021/IntoIterator-for-arrays.md:46
msgid ""
"While it's a shame that this required a small hack to avoid breakage, this "
"solution keeps the difference between the editions to an absolute minimum."
msgstr "이것이 파손을 피하기 위해 작은 해킹이 필요했다는 것은 안타까운 일이지만, 이 솔루션은 에디션 간의 차이를 절대적인 최소값으로 유지합니다."

#: src/rust-2021/IntoIterator-for-arrays.md:55
msgid ""
"A lint, `array_into_iter`, gets triggered whenever there is some call to "
"`into_iter()` that will change meaning in Rust 2021. The `array_into_iter` "
"lint has already been a warning by default on all editions since the 1.41 "
"release (with several enhancements made in 1.55). If your code is already "
"warning free, then it should already be ready to go for Rust 2021!"
msgstr "`array_into_iter` 린트는 Rust 2021에서 의미가 변경될 `into_iter()`에 대한 일부 호출이 있을 때마다 트리거됩니다. `array_into_iter` 린트는 1.41 릴리스 이후 모든 에디션에서 기본적으로 경고였습니다(1.55에서 몇 가지 개선 사항이 적용됨). 코드가 이미 경고가 없다면 Rust 2021을 사용할 준비가 된 것입니다!"

#: src/rust-2021/IntoIterator-for-arrays.md:60
#: src/rust-2021/panic-macro-consistency.md:69
#: src/rust-2021/or-patterns-macro-rules.md:42
msgid ""
"You can automatically migrate your code to be Rust 2021 Edition compatible "
"or ensure it is already compatible by running:"
msgstr "코드를 Rust 2021 에디션과 호환되도록 자동으로 마이그레이션하거나 다음을 실행하여 이미 호환되는지 확인할 수 있습니다."

#: src/rust-2021/IntoIterator-for-arrays.md:67
msgid ""
"Because the difference between editions is small, the migration to Rust 2021 "
"is fairly straight-forward."
msgstr "에디션 간의 차이가 작기 때문에 Rust 2021로의 마이그레이션은 매우 간단합니다."

#: src/rust-2021/IntoIterator-for-arrays.md:69
msgid ""
"For method calls of `into_iter` on arrays, the elements being implemented "
"will change from references to owned values."
msgstr "배열에서 `into_iter`의 메서드 호출의 경우 구현되는 요소가 참조에서 소유 값으로 변경됩니다."

#: src/rust-2021/IntoIterator-for-arrays.md:71
#: src/rust-2021/or-patterns-macro-rules.md:52
#: src/rust-2024/cargo-table-key-names.md:21
msgid "For example:"
msgstr "예를 들어:"

#: src/rust-2021/IntoIterator-for-arrays.md:77
msgid ""
"// x is a `&u8` in Rust 2015 and Rust 2018\\n"
"    // x is a `u8` in Rust 2021\\n"
msgstr "// x는 Rust 2015 및 Rust 2018에서 `&u8`입니다\\n// x는 Rust 2021에서 `u8`입니다\\n"

#: src/rust-2021/IntoIterator-for-arrays.md:83
msgid ""
"The most straightforward way to migrate in Rust 2021, is by keeping the "
"exact behavior from previous editions by calling `iter()` which also "
"iterates over owned arrays by reference:"
msgstr "Rust 2021에서 마이그레이션하는 가장 간단한 방법은 이전 에디션의 정확한 동작을 유지하기 위해 `iter()`를 호출하는 것입니다. 이 함수는 참조로 소유된 배열을 반복합니다."

#: src/rust-2021/IntoIterator-for-arrays.md:89
msgid ""
"// <- This line changed\\n"
"    // x is a `&u8` in all editions\\n"
msgstr "// <- 이 줄이 변경되었습니다\\n// x는 모든 에디션에서 `&u8`입니다\\n"

#: src/rust-2021/IntoIterator-for-arrays.md:95
msgid "Optional migration"
msgstr "선택적 마이그레이션"

#: src/rust-2021/IntoIterator-for-arrays.md:97
msgid ""
"If you are using fully qualified method syntax (i.e., "
"`IntoIterator::into_iter(array)`) in a previous edition, this can be "
"upgraded to method call syntax (i.e., `array.into_iter()`)."
msgstr "이전 에디션에서 완전 정규화된 메서드 구문(예: `IntoIterator::into_iter(array)`)을 사용하는 경우 메서드 호출 구문(예: `array.into_iter()`)으로 업그레이드할 수 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:5
msgid "`|| a.x + 1` now captures only `a.x` instead of `a`."
msgstr "`|| a.x + 1`은 이제 `a` 대신 `a.x`만 캡처합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:6
msgid ""
"This can cause things to be dropped at different times or affect whether "
"closures implement traits like `Send` or `Clone`."
msgstr "이로 인해 다른 시간에 항목이 삭제되거나 클로저가 `Send` 또는 `Clone`과 같은 트레이트를 구현하는지 여부에 영향을 줄 수 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:7
msgid ""
"If possible changes are detected, `cargo fix` will insert statements like "
"`let _ = &a` to force a closure to capture the entire variable."
msgstr "가능한 변경 사항이 감지되면 `cargo fix`는 클로저가 전체 변수를 캡처하도록 강제하기 위해 `let _ = &a`와 같은 문을 삽입합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:11
msgid ""
"[Closures](https://doc.rust-lang.org/book/ch13-01-closures.html) "
"automatically capture anything that you refer to from within their body. For "
"example, `|| a + 1` automatically captures a reference to `a` from the "
"surrounding context."
msgstr "[클로저](https://doc.rust-lang.org/book/ch13-01-closures.html)는 본문 내에서 참조하는 모든 것을 자동으로 캡처합니다. 예를 들어 `|| a + 1`은 주변 컨텍스트에서 `a`에 대한 참조를 자동으로 캡처합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:15
msgid ""
"In Rust 2018 and before, closures capture entire variables, even if the "
"closure only uses one field. For example, `|| a.x + 1` captures a reference "
"to `a` and not just `a.x`. Capturing `a` in its entirety prevents mutation "
"or moves from other fields of `a`, so that code like this does not compile:"
msgstr "Rust 2018 및 이전 버전에서 클로저는 클로저가 하나의 필드만 사용하더라도 전체 변수를 캡처합니다. 예를 들어 `|| a.x + 1`은 `a.x`뿐만 아니라 `a`에 대한 참조를 캡처합니다. `a` 전체를 캡처하면 `a`의 다른 필드에서 변경 또는 이동이 방지되므로 다음과 같은 코드는 컴파일되지 않습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:21
msgid "// Move out of one field of the struct\n"
msgstr "// 구조체의 한 필드에서 이동\n"
#: src/rust-2021/disjoint-capture-in-closures.md:22
#: src/rust-2021/disjoint-capture-in-closures.md:23
#: src/rust-2021/panic-macro-consistency.md:20
#: src/rust-2021/panic-macro-consistency.md:21
#: src/rust-2021/panic-macro-consistency.md:53
#: src/rust-2021/panic-macro-consistency.md:54
msgid "\"{}\""
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:22
msgid "// Ok: Still use another field of the struct\n"
msgstr "// Ok: 구조체의 다른 필드를 계속 사용\n"

#: src/rust-2021/disjoint-capture-in-closures.md:23
msgid "// Error: Tries to capture all of `a`\\n"
msgstr "// 오류: `a`의 전체를 캡처하려고 시도\\n"

#: src/rust-2021/disjoint-capture-in-closures.md:27
msgid ""
"Starting in Rust 2021, closures captures are more precise. Typically they "
"will only capture the fields they use (in some cases, they might capture "
"more than just what they use, see the Rust reference for full details). "
"Therefore, the above example will compile fine in Rust 2021."
msgstr "Rust 2021부터 클로저 캡처는 더 정확해집니다. 일반적으로 사용하는 필드만 캡처합니다(경우에 따라 사용하는 것 이상을 캡처할 수 있으며 자세한 내용은 Rust 참조를 참조하십시오). 따라서 위의 예는 Rust 2021에서 잘 컴파일됩니다."

#: src/rust-2021/disjoint-capture-in-closures.md:29
msgid ""
"Disjoint capture was proposed as part of [RFC 2229](https://github.com/rust-"
"lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC "
"contains details about the motivation."
msgstr "분리된 캡처는 [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md)의 일부로 제안되었으며 RFC에는 동기에 대한 자세한 내용이 포함되어 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:33
msgid ""
"As a part of the 2021 edition a migration lint, "
"`rust_2021_incompatible_closure_captures`, has been added in order to aid in "
"automatic migration of Rust 2018 codebases to Rust 2021."
msgstr "2021 에디션의 일부로 Rust 2018 코드베이스를 Rust 2021로 자동 마이그레이션하는 데 도움이 되도록 마이그레이션 린트인 `rust_2021_incompatible_closure_captures`가 추가되었습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:41
msgid ""
"Below is an examination of how to manually migrate code to use closure "
"captures that are compatible with Rust 2021 should the automatic migration "
"fail or you would like to better understand how the migration works."
msgstr "아래에서는 자동 마이그레이션이 실패하거나 마이그레이션 작동 방식을 더 잘 이해하고 싶은 경우 Rust 2021과 호환되는 클로저 캡처를 사용하도록 코드를 수동으로 마이그레이션하는 방법을 살펴봅니다."

#: src/rust-2021/disjoint-capture-in-closures.md:44
msgid ""
"Changing the variables captured by a closure can cause programs to change "
"behavior or to stop compiling in two cases:"
msgstr "클로저에 의해 캡처된 변수를 변경하면 두 가지 경우에 프로그램 동작이 변경되거나 컴파일이 중지될 수 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:46
msgid ""
"changes to drop order, or when destructors run ([details](#drop-order));"
msgstr "삭제 순서 변경 또는 소멸자가 실행될 때([세부 정보](#drop-order));"

#: src/rust-2021/disjoint-capture-in-closures.md:47
msgid ""
"changes to which traits a closure implements ([details](#trait-"
"implementations))."
msgstr "클로저가 구현하는 트레이트 변경([세부 정보](#trait-implementations))."

#: src/rust-2021/disjoint-capture-in-closures.md:49
msgid ""
"Whenever any of the scenarios below are detected, `cargo fix` will insert a "
"\"dummy let\" into your closure to force it to capture the entire variable:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:54
msgid "// \\\"Dummy let\\\" that forces `x` to be captured in its entirety\\n"
msgstr "// `x`가 전체적으로 캡처되도록 강제하는 \\\"더미 let\\\"\\n"

#: src/rust-2021/disjoint-capture-in-closures.md:57
msgid "// Otherwise, only `x.0` would be captured here\n"
msgstr "// 그렇지 않으면 여기에서 `x.0`만 캡처됩니다\n"

#: src/rust-2021/disjoint-capture-in-closures.md:58
msgid "\"{:?}\""
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:62
msgid ""
"This is a conservative analysis: in many cases, these dummy lets can be "
"safely removed and your program will work fine."
msgstr "이것은 보수적인 분석입니다. 많은 경우 이러한 더미 let은 안전하게 제거할 수 있으며 프로그램은 정상적으로 작동합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:64
msgid "Wild Card Patterns"
msgstr "와일드카드 패턴"

#: src/rust-2021/disjoint-capture-in-closures.md:66
msgid ""
"Closures now only capture data that needs to be read, which means the "
"following closures will not capture `x`:"
msgstr "이제 클로저는 읽어야 할 데이터만 캡처하므로 다음 클로저는 `x`를 캡처하지 않습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:71
msgid "// no-op\n"
msgstr "// 아무 작업도 안 함\n"

#: src/rust-2021/disjoint-capture-in-closures.md:75
msgid "\"Hello World!\""
msgstr "\"Hello World!\""

#: src/rust-2021/disjoint-capture-in-closures.md:79
msgid ""
"The `let _ = x` statement here is a no-op, since the `_` pattern completely "
"ignores the right-hand side, and `x` is a reference to a place in memory (in "
"this case, a variable)."
msgstr "여기서 `let _ = x` 문은 `_` 패턴이 오른쪽을 완전히 무시하고 `x`가 메모리의 한 위치(이 경우 변수)에 대한 참조이므로 아무 작업도 수행하지 않습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:81
msgid ""
"This change by itself (capturing fewer values) doesn't trigger any "
"suggestions, but it may do so in conjunction with the \"drop order\" change "
"below."
msgstr "이 변경 자체(더 적은 값 캡처)는 제안을 트리거하지 않지만 아래의 \"삭제 순서\" 변경과 함께 트리거할 수 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:83
msgid ""
"**Subtle:** There are other similar expressions, such as the \"dummy lets\" "
"`let _ = &x` that we insert, which are not no-ops. This is because the right-"
"hand side (`&x`) is not a reference to a place in memory, but rather an "
"expression that must first be evaluated (and whose result is then discarded)."
msgstr "**미묘함:** 우리가 삽입하는 \"더미 let\" `let _ = &x`와 같이 no-op이 아닌 다른 유사한 표현식이 있습니다. 이것은 오른쪽(`&x`)이 메모리의 한 위치에 대한 참조가 아니라 먼저 평가되어야 하는 표현식이기 때문입니다(그리고 그 결과는 버려집니다)."

#: src/rust-2021/disjoint-capture-in-closures.md:85
msgid "Drop Order"
msgstr "삭제 순서"

#: src/rust-2021/disjoint-capture-in-closures.md:87
msgid ""
"When a closure takes ownership of a value from a variable `t`, that value is "
"then dropped when the closure is dropped, and not when the variable `t` goes "
"out of scope:"
msgstr "클로저가 변수 `t`에서 값의 소유권을 가져오면 해당 값은 변수 `t`가 범위를 벗어날 때가 아니라 클로저가 삭제될 때 삭제됩니다."

#: src/rust-2021/disjoint-capture-in-closures.md:95
msgid "// t is moved here\n"
msgstr "// t가 여기로 이동됩니다\n"

#: src/rust-2021/disjoint-capture-in-closures.md:96
msgid "// c is dropped, which drops the tuple `t` as well\n"
msgstr "// c가 삭제되면 튜플 `t`도 삭제됩니다\n"#: src/rust-2021/disjoint-capture-in-closures.md:97
msgid "// t goes out of scope here\n"
msgstr "// t는 여기서 범위를 벗어납니다\n"

#: src/rust-2021/disjoint-capture-in-closures.md:100
msgid ""
"The above code will run the same in both Rust 2018 and Rust 2021. However, "
"in cases where the closure only takes ownership of _part_ of a variable, "
"there can be differences:"
msgstr "위의 코드는 Rust 2018과 Rust 2021 모두에서 동일하게 실행됩니다. 그러나 클로저가 변수의 _일부_에 대한 소유권만 갖는 경우에는 차이가 있을 수 있습니다."

#: src/rust-2021/disjoint-capture-in-closures.md:109
msgid ""
"// In Rust 2018, captures all of `t`.\n"
"            // In Rust 2021, captures only `t.0`\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:114
msgid ""
"// In Rust 2018, `c` (and `t`) are both dropped when we\n"
"        // exit this block.\n"
"        //\n"
"        // In Rust 2021, `c` and `t.0` are both dropped when we\n"
"        // exit this block.\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:120
msgid ""
"// In Rust 2018, the value from `t` has been moved and is\n"
"// not dropped.\n"
"//\n"
"// In Rust 2021, the value from `t.0` has been moved, but `t.1`\n"
"// remains, so it will be dropped here.\n"
msgstr "// Rust 2018에서는 `t`의 값이 이동되어 삭제되지 않습니다.\n//\n// Rust 2021에서는 `t.0`의 값이 이동되었지만 `t.1`은 남아 있으므로 여기서 삭제됩니다.\n"

#: src/rust-2021/disjoint-capture-in-closures.md:129
msgid ""
"In most cases, dropping values at different times just affects when memory "
"is freed and is not important. However, some `Drop` impls (aka, destructors) "
"have side-effects, and changing the drop order in those cases can alter the "
"semantics of your program. In such cases, the compiler will suggest "
"inserting a dummy `let` to force the entire variable to be captured."
msgstr "대부분의 경우 다른 시간에 값을 삭제하는 것은 메모리가 해제되는 시점에만 영향을 미치며 중요하지 않습니다. 그러나 일부 `Drop` 구현(일명 소멸자)에는 부작용이 있으며 이러한 경우 삭제 순서를 변경하면 프로그램의 의미 체계가 변경될 수 있습니다. 이러한 경우 컴파일러는 전체 변수를 캡처하도록 강제하기 위해 더미 `let`을 삽입하도록 제안합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:131
msgid "Trait implementations"
msgstr "트레이트 구현"

#: src/rust-2021/disjoint-capture-in-closures.md:133
msgid ""
"Closures automatically implement the following traits based on what values "
"they capture:"
msgstr "클로저는 캡처하는 값에 따라 다음 트레이트를 자동으로 구현합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:135
msgid ""
"[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html): if all "
"captured values are `Clone`."
msgstr "[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html): 모든 캡처된 값이 `Clone`인 경우."

#: src/rust-2021/disjoint-capture-in-closures.md:136
msgid ""
"[Auto traits](https://doc.rust-lang.org/nightly/reference/special-types-and-"
"traits.html#auto-traits) like [`Send`](https://doc.rust-lang.org/std/marker/"
"trait.Send.html), [`Sync`](https://doc.rust-lang.org/std/marker/"
"trait.Sync.html), and [`UnwindSafe`](https://doc.rust-lang.org/std/panic/"
"trait.UnwindSafe.html): if all captured values implement the given trait."
msgstr "[자동 트레이트](https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits)와 같은 [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) 및 [`UnwindSafe`](https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html): 모든 캡처된 값이 주어진 트레이트를 구현하는 경우."

#: src/rust-2021/disjoint-capture-in-closures.md:144
msgid ""
"In Rust 2021, since different values are being captured, this can affect "
"what traits a closure will implement. The migration lints test each closure "
"to see whether it would have implemented a given trait before and whether it "
"still implements it now; if they find that a trait used to be implemented "
"but no longer is, then \"dummy lets\" are inserted."
msgstr "Rust 2021에서는 다른 값이 캡처되므로 클로저가 구현할 트레이트에 영향을 줄 수 있습니다. 마이그레이션 린트는 각 클로저를 테스트하여 이전에 주어진 트레이트를 구현했는지 여부와 지금도 구현하는지 여부를 확인합니다. 이전에 구현되었지만 더 이상 구현되지 않는 트레이트를 발견하면 \"더미 let\"이 삽입됩니다."

#: src/rust-2021/disjoint-capture-in-closures.md:146
msgid ""
"For instance, a common way to allow passing around raw pointers between "
"threads is to wrap them in a struct and then implement `Send`/`Sync` auto "
"trait for the wrapper. The closure that is passed to `thread::spawn` uses "
"the specific fields within the wrapper but the entire wrapper is captured "
"regardless. Since the wrapper is `Send`/`Sync`, the code is considered safe "
"and therefore compiles successfully."
msgstr "예를 들어, 스레드 간에 원시 포인터를 전달할 수 있도록 허용하는 일반적인 방법은 이를 구조체로 래핑한 다음 래퍼에 대해 `Send`/`Sync` 자동 트레이트를 구현하는 것입니다. `thread::spawn`에 전달되는 클로저는 래퍼 내의 특정 필드를 사용하지만 전체 래퍼는 관계없이 캡처됩니다. 래퍼가 `Send`/`Sync`이므로 코드는 안전한 것으로 간주되어 성공적으로 컴파일됩니다."

#: src/rust-2021/disjoint-capture-in-closures.md:148
msgid ""
"With disjoint captures, only the specific field mentioned in the closure "
"gets captured, which wasn't originally `Send`/`Sync` defeating the purpose "
"of the wrapper."
msgstr "분리된 캡처를 사용하면 클로저에 언급된 특정 필드만 캡처되므로 원래 `Send`/`Sync`가 아니었던 래퍼의 목적을 무효화합니다."

#: src/rust-2021/disjoint-capture-in-closures.md:164
msgid "// Closure captured px.0 which is not Send\n"
msgstr "// 클로저가 Send가 아닌 px.0을 캡처했습니다\n"

#: src/rust-2021/panic-macro-consistency.md:5
msgid ""
"`panic!(..)` now always uses `format_args!(..)`, just like `println!()`."
msgstr "`panic!(..)`은 이제 `println!()`처럼 항상 `format_args!(..)`를 사용합니다."

#: src/rust-2021/panic-macro-consistency.md:6
msgid ""
"`panic!(\"{\")` is no longer accepted, without escaping the `{` as `{{`."
msgstr "`panic!(\"{\")`은 `{`를 `{{`로 이스케이프하지 않으면 더 이상 허용되지 않습니다."

#: src/rust-2021/panic-macro-consistency.md:7
msgid "`panic!(x)` is no longer accepted if `x` is not a string literal."
msgstr "`x`가 문자열 리터럴이 아니면 `panic!(x)`는 더 이상 허용되지 않습니다."

#: src/rust-2021/panic-macro-consistency.md:8
msgid "Use `std::panic::panic_any(x)` to panic with a non-string payload."
msgstr "문자열이 아닌 페이로드로 패닉하려면 `std::panic::panic_any(x)`를 사용하십시오."

#: src/rust-2021/panic-macro-consistency.md:9
msgid "Or use `panic!(\"{}\", x)` to use `x`'s `Display` implementation."
msgstr "또는 `panic!(\"{}\", x)`를 사용하여 `x`의 `Display` 구현을 사용하십시오."

#: src/rust-2021/panic-macro-consistency.md:10
msgid "The same applies to `assert!(expr, ..)`."
msgstr "`assert!(expr, ..)`에도 동일하게 적용됩니다."

#: src/rust-2021/panic-macro-consistency.md:14
msgid ""
"The `panic!()` macro is one of Rust's most well known macros. However, it "
"has [some subtle surprises](https://github.com/rust-lang/rfcs/blob/master/"
"text/3007-panic-plan.md) that we can't just change due to backwards "
"compatibility."
msgstr "`panic!()` 매크로는 Rust에서 가장 잘 알려진 매크로 중 하나입니다. 그러나 하위 호환성으로 인해 변경할 수 없는 [몇 가지 미묘한 놀라움](https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md)이 있습니다."

#: src/rust-2021/panic-macro-consistency.md:20
#: src/rust-2021/panic-macro-consistency.md:53
msgid "// Ok, panics with the message \"1\"\n"
msgstr "// Ok, 메시지 \"1\"로 패닉\n"

#: src/rust-2021/panic-macro-consistency.md:21
msgid "// Ok, panics with the message \\\"{}\\\"\\n"
msgstr "// Ok, 메시지 \\\"{}\\\"로 패닉\\n"

#: src/rust-2021/panic-macro-consistency.md:24
msgid ""
"The `panic!()` macro only uses string formatting when it's invoked with more "
"than one argument. When invoked with a single argument, it doesn't even look "
"at that argument."
msgstr "`panic!()` 매크로는 두 개 이상의 인수로 호출될 때만 문자열 서식을 사용합니다. 단일 인수로 호출될 때는 해당 인수를 보지도 않습니다."

#: src/rust-2021/panic-macro-consistency.md:29
msgid "\"{\""
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:30
msgid "// Error: First argument must be a format string literal\n"
msgstr "// 오류: 첫 번째 인수는 형식 문자열 리터럴이어야 합니다\n"

#: src/rust-2021/panic-macro-consistency.md:31

msgid "// Ok: The panic macro doesn't care\n"

msgstr "// Ok: 패닉 매크로는 신경 쓰지 않습니다\n"

#: src/rust-2021/panic-macro-consistency.md:34

msgid ""

"It even accepts non-strings such as `panic!(123)`, which is uncommon and "

"rarely useful since it produces a surprisingly unhelpful message: `panicked "

"at 'Box<Any>'`. "

msgstr "심지어 `panic!(123)`과 같이 문자열이 아닌 것도 허용하는데, 이는 드물고 거의 유용하지 않습니다. 왜냐하면 놀라울 정도로 도움이 되지 않는 메시지인 `panicked at 'Box<Any>'`를 생성하기 때문입니다."

#: src/rust-2021/panic-macro-consistency.md:37
msgid ""
"This will especially be a problem once [implicit format arguments](https://"
"rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html) are "
"stabilized. That feature will make `println!(\\\"hello {name}\\\")` a short-hand "
"for `println!(\\\"hello {}\\\", name)`. However, `panic!(\\\"hello {name}\\\")` "
"would not work as expected, since `panic!()` doesn't process a single "
"argument as format string."
msgstr "이것은 [암시적 형식 인수](https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html)가 안정화되면 특히 문제가 될 것입니다. 이 기능은 `println!(\\\"hello {name}\\\")`을 `println!(\\\"hello {}\\\", name)`의 약식으로 만듭니다. 그러나 `panic!()`은 단일 인수를 형식 문자열로 처리하지 않기 때문에 `panic!(\\\"hello {name}\\\")`은 예상대로 작동하지 않습니다."

#: src/rust-2021/panic-macro-consistency.md:44
msgid ""
"To avoid that confusing situation, Rust 2021 features a more consistent "
"`panic!()` macro. The new `panic!()` macro will no longer accept arbitrary "
"expressions as the only argument. It will, just like `println!()`, always "
"process the first argument as format string. Since `panic!()` will no longer "
"accept arbitrary payloads, [`panic_any()`](https://doc.rust-lang.org/stable/"
"std/panic/fn.panic_any.html) will be the only way to panic with something "
"other than a formatted string."
msgstr "이러한 혼란스러운 상황을 피하기 위해 Rust 2021에는 더 일관된 `panic!()` 매크로가 있습니다. 새 `panic!()` 매크로는 더 이상 임의의 표현식을 유일한 인수로 허용하지 않습니다. `println!()`과 마찬가지로 항상 첫 번째 인수를 형식 문자열로 처리합니다. `panic!()`이 더 이상 임의의 페이로드를 허용하지 않으므로 [`panic_any()`](https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html)가 서식이 지정된 문자열 이외의 것으로 패닉하는 유일한 방법이 될 것입니다."

#: src/rust-2021/panic-macro-consistency.md:52
msgid "// Rust 2021\n"
msgstr "// Rust 2021\n"

#: src/rust-2021/panic-macro-consistency.md:54
msgid "// Error, missing argument\n"
msgstr "// 오류, 인수 누락\n"

#: src/rust-2021/panic-macro-consistency.md:55
msgid "// Error, must be a string literal\\n"
msgstr "// 오류, 문자열 리터럴이어야 합니다\\n"

#: src/rust-2021/panic-macro-consistency.md:58
msgid ""
"In addition, `core::panic!()` and `std::panic!()` will be identical in Rust "
"2021. Currently, there are some historical differences between those two, "
"which can be noticeable when switching `#![no_std]` on or off."
msgstr "또한 `core::panic!()`과 `std::panic!()`은 Rust 2021에서 동일합니다. 현재 이 둘 사이에는 몇 가지 역사적 차이점이 있으며, 이는 `#![no_std]`를 켜거나 끌 때 눈에 띌 수 있습니다."

#: src/rust-2021/panic-macro-consistency.md:64
msgid ""
"A lint, `non_fmt_panics`, gets triggered whenever there is some call to "
"`panic` that uses some deprecated behavior that will error in Rust 2021. The "
"`non_fmt_panics` lint has already been a warning by default on all editions "
"since the 1.50 release (with several enhancements made in later releases). "
"If your code is already warning free, then it should already be ready to go "
"for Rust 2021!"
msgstr "`non_fmt_panics` 린트는 Rust 2021에서 오류가 발생할 일부 사용되지 않는 동작을 사용하는 `panic`에 대한 일부 호출이 있을 때마다 트리거됩니다. `non_fmt_panics` 린트는 1.50 릴리스 이후 모든 에디션에서 기본적으로 경고였습니다(이후 릴리스에서 몇 가지 개선 사항이 적용됨). 코드가 이미 경고가 없다면 Rust 2021을 사용할 준비가 된 것입니다!"

#: src/rust-2021/panic-macro-consistency.md:76
msgid ""
"Should you choose or need to manually migrate, you'll need to update all "
"panic invocations to either use the same formatting as `println` or use "
"`std::panic::panic_any` to panic with non-string data."
msgstr "수동으로 마이그레이션하도록 선택하거나 필요하다면 모든 패닉 호출을 `println`과 동일한 서식을 사용하거나 `std::panic::panic_any`를 사용하여 문자열이 아닌 데이터로 패닉하도록 업데이트해야 합니다."

#: src/rust-2021/panic-macro-consistency.md:79
msgid ""
"For example, in the case of `panic!(MyStruct)`, you'll need to convert to "
"using `std::panic::panic_any` (note that this is a function not a macro): "
"`std::panic::panic_any(MyStruct)`."
msgstr "예를 들어, `panic!(MyStruct)`의 경우 `std::panic::panic_any`를 사용하도록 변환해야 합니다(이것은 매크로가 아닌 함수임에 유의하십시오). `std::panic::panic_any(MyStruct)`."

#: src/rust-2021/panic-macro-consistency.md:82
msgid ""
"In the case of panic messages that include curly braces but the wrong number "
"of arguments (e.g., `panic!(\\\"Some curlies: {}\\\")`), you can panic with the "
"string literal by either using the same syntax as `println!` (i.e., `panic!\""
"(\\\"{}\\\", \\\"Some curlies: {}\\\")`) or by escaping the curly braces (i.e., "
"`panic!(\\\"Some curlies: {{}}\\\")`)."
msgstr "중괄호를 포함하지만 인수 수가 잘못된 패닉 메시지(예: `panic!(\\\"Some curlies: {}\\\")`)의 경우 `println!`과 동일한 구문을 사용하거나(예: `panic!(\\\"{}\\\", \\\"Some curlies: {}\\\")`) 중괄호를 이스케이프하여(예: `panic!(\\\"Some curlies: {{}}\\\")`) 문자열 리터럴로 패닉할 수 있습니다."

#: src/rust-2021/reserved-syntax.md:5
msgid ""
"`any_identifier#`, `any_identifier\"...\"`, `any_identifier'...'`, and "
"`'any_identifier#` are now reserved syntax, and no longer tokenize."
msgstr "`any_identifier#`, `any_identifier\"...\"`, `any_identifier'...'`, and "
"`'any_identifier#`는 이제 예약된 구문이며 더 이상 토큰화되지 않습니다."

#: src/rust-2021/reserved-syntax.md:6
msgid ""
"This is mostly relevant to macros. E.g. `quote!{ #a#b }` is no longer "
"accepted."
msgstr "이것은 주로 매크로와 관련이 있습니다. 예를 들어 `quote!{ #a#b }`는 더 이상 허용되지 않습니다."

#: src/rust-2021/reserved-syntax.md:7
msgid ""
"It doesn't treat keywords specially, so e.g. `match\"...\" {}` is no longer "
"accepted."
msgstr "키워드를 특별하게 취급하지 않으므로 예를 들어 `match\"...\" {}`는 더 이상 허용되지 않습니다."

#: src/rust-2021/reserved-syntax.md:8
msgid ""
"Insert whitespace between the identifier and the subsequent `#`, `\"`, or "
"`'` to avoid errors."
msgstr ""

#: src/rust-2021/reserved-syntax.md:10
msgid "Edition migrations will help you insert whitespace in such cases."
msgstr "에디션 마이그레이션은 이러한 경우에 공백을 삽입하는 데 도움이 됩니다."

#: src/rust-2021/reserved-syntax.md:14
msgid ""
"To make space for new syntax in the future, we've decided to reserve syntax "
"for prefixed identifiers, literals, and lifetimes: `prefix#identifier`, "
"`prefix\\\"string\\\"`, `prefix\'c\'`, `prefix#123`, and `\'prefix#`, where "
"`prefix` can be any identifier. (Except those prefixes that already have a "
"meaning, such as `b\'...'\'` (byte chars) and `r\\\"...\\\"` (raw strings).)"
msgstr "향후 새로운 구문을 위한 공간을 만들기 위해 접두사가 붙은 식별자, 리터럴 및 라이프타임에 대한 구문을 예약하기로 결정했습니다: `prefix#identifier`, `prefix\\\"string\\\"`, `prefix\'c\'`, `prefix#123` 및 `\'prefix#`. 여기서 `prefix`는 모든 식별자가 될 수 있습니다. (이미 의미가 있는 접두사, 예를 들어 `b\'...'\'`(바이트 문자) 및 `r\\\"...\\\"`(원시 문자열)는 제외)."

#: src/rust-2021/reserved-syntax.md:21
msgid ""
"This provides syntax we can expand into in the future without requiring an "
"edition boundary. We may use this for temporary syntax until the next "
"edition, or for permanent syntax if appropriate."
msgstr "이것은 에디션 경계 없이 향후 확장할 수 있는 구문을 제공합니다. 다음 에디션까지 임시 구문으로 사용하거나 적절한 경우 영구 구문으로 사용할 수 있습니다."

#: src/rust-2021/reserved-syntax.md:25
msgid ""
"Without an edition, this would be a breaking change, since macros can "
"currently accept syntax such as `hello\\\"world\\\"`, which they will see as two "
"separate tokens: `hello` and `\\\"world\\\"`. The (automatic) fix is simple "
"though: just insert a space: `hello \\\"world\\\"`. Likewise, `prefix#ident` "
"should become `prefix #ident`. Edition migrations will help with this fix."
msgstr "에디션이 없으면 매크로가 현재 `hello\\\"world\\\"`와 같은 구문을 허용할 수 있으므로 이것은 주요 변경 사항이 될 것입니다. 매크로는 이를 `hello`와 `\\\"world\\\"`라는 두 개의 개별 토큰으로 봅니다. (자동) 수정은 간단합니다. 공백을 삽입하면 됩니다: `hello \\\"world\\\"`. 마찬가지로 `prefix#ident`는 `prefix #ident`가 되어야 합니다. 에디션 마이그레이션이 이 수정에 도움이 될 것입니다."

#: src/rust-2021/reserved-syntax.md:31
msgid ""
"Other than turning these into a tokenization error, [the RFC](https://"
"github.com/rust-lang/rfcs/pull/3101) does not attach a meaning to any prefix "
"yet. Assigning meaning to specific prefixes is left to future proposals, "
"which will now—thanks to reserving these prefixes—not be breaking changes."
msgstr "이것들을 토큰화 오류로 바꾸는 것 외에, [RFC](https://github.com/rust-lang/rfcs/pull/3101)는 아직 어떤 접두사에도 의미를 부여하지 않습니다. 특정 접두사에 의미를 할당하는 것은 향후 제안에 맡겨지며, 이제 이러한 접두사를 예약한 덕분에 주요 변경 사항이 되지 않을 것입니다."

#: src/rust-2021/reserved-syntax.md:36
msgid ""
"Some new prefixes you might potentially see in the future (though we haven't "
"committed to any of them yet):"
msgstr "향후에 볼 수 있는 몇 가지 새로운 접두사(아직 어떤 것도 약속하지 않았지만):"

#: src/rust-2021/reserved-syntax.md:39
msgid ""
"`k#keyword` to allow writing keywords that don't exist yet in the current "
"edition. For example, while `async` is not a keyword in edition 2015, this "
"prefix would've allowed us to accept `k#async` in edition 2015 without "
"having to wait for edition 2018 to reserve `async` as a keyword."
msgstr "`k#keyword`는 현재 에디션에 아직 존재하지 않는 키워드를 작성할 수 있도록 허용합니다. 예를 들어, `async`가 2015 에디션에서 키워드가 아니었지만 이 접두사를 사용하면 2018 에디션에서 `async`를 키워드로 예약할 때까지 기다릴 필요 없이 2015 에디션에서 `k#async`를 허용할 수 있었습니다."

#: src/rust-2021/reserved-syntax.md:44
msgid ""
"`f\\\"\\\"` as a short-hand for a format string. For example, `f\\\"hello {name}""
"\\\"` as a short-hand for the equivalent `format!()` invocation."
msgstr "`f\\\"\\\"`는 형식 문자열의 약식입니다. 예를 들어, `f\\\"hello {name}\\\" `는 동등한 `format!()` 호출의 약식입니다."

#: src/rust-2021/reserved-syntax.md:47
msgid "`s\"\"` for `String` literals."
msgstr "`String` 리터럴에 대한 `s\"\"`."

#: src/rust-2021/reserved-syntax.md:54 src/rust-2021/raw-lifetimes.md:17
msgid ""
"As a part of the 2021 edition a migration lint, "
"[`rust_2021_prefixes_incompatible_syntax`](../../rustc/lints/listing/allowed-"
"by-default.html#rust-2021-prefixes-incompatible-syntax), has been added in "
"order to aid in automatic migration of Rust 2018 codebases to Rust 2021."
msgstr "2021 에디션의 일부로 Rust 2018 코드베이스를 Rust 2021로 자동 마이그레이션하는 데 도움이 되도록 마이그레이션 린트인 [`rust_2021_prefixes_incompatible_syntax`](../../rustc/lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax)가 추가되었습니다."

#: src/rust-2021/reserved-syntax.md:62 src/rust-2021/raw-lifetimes.md:25
msgid ""
"Should you want or need to manually migrate your code, migration is fairly "
"straight-forward."
msgstr "코드를 수동으로 마이그레이션하려는 경우 마이그레이션은 매우 간단합니다."

#: src/rust-2021/reserved-syntax.md:64 src/rust-2021/raw-lifetimes.md:27
msgid "Let's say you have a macro that is defined like so:"
msgstr "다음과 같이 정의된 매크로가 있다고 가정해 보겠습니다."

#: src/rust-2021/reserved-syntax.md:72
msgid ""
"In Rust 2015 and 2018 it's legal for this macro to be called like so with no "
"space between the first token tree and the second:"
msgstr "Rust 2015 및 2018에서는 첫 번째 토큰 트리와 두 번째 토큰 트리 사이에 공백 없이 이 매크로를 호출하는 것이 합법적입니다."

#: src/rust-2021/reserved-syntax.md:75 src/rust-2021/reserved-syntax.md:81
msgid \"hey\"
msgstr \"hey\"

#: src/rust-2021/reserved-syntax.md:78
msgid ""
"This `z` prefix is no longer allowed in Rust 2021, so in order to call this "
"macro, you must add a space after the prefix like so:"
msgstr "이 `z` 접두사는 Rust 2021에서 더 이상 허용되지 않으므로 이 매크로를 호출하려면 접두사 뒤에 공백을 추가해야 합니다."

#: src/rust-2021/raw-lifetimes.md:5
msgid ""
"`'r#ident_or_keyword` is now allowed as a lifetime, which allows using "
"keywords such as `'r#fn`."
msgstr "`'r#ident_or_keyword`는 이제 라이프타임으로 허용되며, 이를 통해 `\'r#fn`과 같은 키워드를 사용할 수 있습니다."

#: src/rust-2021/raw-lifetimes.md:9
msgid ""
"Raw lifetimes are introduced in the 2021 edition to support the ability to "
"migrate to newer editions that introduce new keywords. This is analogous to "
"[raw identifiers](../../reference/identifiers.html#raw-identifiers) which "
"provide the same functionality for identifiers. For example, the 2024 "
"edition introduced the `gen` keyword. Since lifetimes cannot be keywords, "
"this would cause code that use a lifetime `'gen` to fail to compile. Raw "
"lifetimes allow the migration lint to modify those lifetimes to `'r#gen` "
"which do allow keywords."
msgstr ""

#: src/rust-2021/raw-lifetimes.md:11
msgid ""
"In editions prior to 2021, raw lifetimes are parsed as separate tokens. For "
"example `'r#foo` is parsed as three tokens: `'r`, `#`, and `foo`."
msgstr "2021 이전 에디션에서는 원시 라이프타임이 별도의 토큰으로 구문 분석됩니다. 예를 들어 `'r#foo`는 `'r`, `#` 및 `foo`의 세 가지 토큰으로 구문 분석됩니다."

#: src/rust-2021/raw-lifetimes.md:35
msgid ""
"In Rust 2015 and 2018 it's legal for this macro to be called like so with no "
"space between the tokens:"
msgstr "Rust 2015 및 2018에서는 토큰 사이에 공백 없이 이 매크로를 호출하는 것이 합법적입니다."

#: src/rust-2021/raw-lifetimes.md:41
msgid ""
"In the 2021 edition, this is now parsed as a single token. In order to call "
"this macro, you must add a space before the identifier like so:"
msgstr "2021 에디션에서는 이것이 이제 단일 토큰으로 구문 분석됩니다. 이 매크로를 호출하려면 다음과 같이 식별자 앞에 공백을 추가해야 합니다."

#: src/rust-2021/warnings-promoted-to-error.md:5
msgid ""
"Code that triggered the `bare_trait_objects` and "
"`ellipsis_inclusive_range_patterns` lints will error in Rust 2021."
msgstr "`bare_trait_objects` 및 `ellipsis_inclusive_range_patterns` 린트를 트리거한 코드는 Rust 2021에서 오류가 발생합니다."

#: src/rust-2021/warnings-promoted-to-error.md:9
msgid ""
"Two existing lints are becoming hard errors in Rust 2021, but these lints "
"will remain warnings in older editions."
msgstr "두 개의 기존 린트는 Rust 2021에서 하드 오류가 되지만 이러한 린트는 이전 에디션에서는 경고로 유지됩니다."

#: src/rust-2021/warnings-promoted-to-error.md:11
msgid "`bare_trait_objects`:"
msgstr "`bare_trait_objects`:"

#: src/rust-2021/warnings-promoted-to-error.md:13
msgid ""
"The use of the `dyn` keyword to identify [trait objects](https://doc.rust-"
"lang.org/book/ch17-02-trait-objects.html) will be mandatory in Rust 2021."
msgstr "[트레이트 객체](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)를 식별하기 위해 `dyn` 키워드를 사용하는 것은 Rust 2021에서 필수가 됩니다."

#: src/rust-2021/warnings-promoted-to-error.md:16
msgid ""
"For example, the following code which does not include the `dyn` keyword in "
"`&MyTrait` will produce an error instead of just a lint in Rust 2021:"
msgstr "예를 들어, `&MyTrait`에 `dyn` 키워드를 포함하지 않는 다음 코드는 Rust 2021에서 단순한 린트 대신 오류를 생성합니다."

#: src/rust-2021/warnings-promoted-to-error.md:22
msgid "// should be `&dyn MyTrait`\n"
msgstr "// `&dyn MyTrait`여야 합니다\n"

#: src/rust-2021/warnings-promoted-to-error.md:27
msgid "`ellipsis_inclusive_range_patterns`:"
msgstr "`ellipsis_inclusive_range_patterns`:"

#: src/rust-2021/warnings-promoted-to-error.md:29
msgid ""
"The [deprecated `...` syntax](https://doc.rust-lang.org/stable/reference/"
"patterns.html#range-patterns) for inclusive range patterns (i.e., ranges "
"where the end value is _included_ in the range) is no longer accepted in "
"Rust 2021. It has been superseded by `..=`, which is consistent with "
"expressions."
msgstr "포괄적 범위 패턴(즉, 끝 값이 범위에 _포함_되는 범위)에 대한 [사용되지 않는 `...` 구문](https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns)은 Rust 2021에서 더 이상 허용되지 않습니다. 표현식과 일치하는 `..=`로 대체되었습니다."

#: src/rust-2021/warnings-promoted-to-error.md:33
msgid ""
"For example, the following code which uses `...` in a pattern will produce "
"an error instead of just a lint in Rust 2021:"
msgstr "예를 들어, 패턴에서 `...`를 사용하는 다음 코드는 Rust 2021에서 단순한 린트 대신 오류를 생성합니다."

#: src/rust-2021/warnings-promoted-to-error.md:38
msgid "// should be `0..=100`\n"
msgstr "// `0..=100`이어야 합니다\n"

#: src/rust-2021/warnings-promoted-to-error.md:42
msgid "Migrations"
msgstr "마이그레이션"

#: src/rust-2021/warnings-promoted-to-error.md:44
msgid ""
"If your Rust 2015 or 2018 code does not produce any warnings for "
"`bare_trait_objects` or `ellipsis_inclusive_range_patterns` and you've not "
"allowed these lints through the use of `#![allow()]` or some other "
"mechanism, then there's no need to migrate."
msgstr "Rust 2015 또는 2018 코드가 `bare_trait_objects` 또는 `ellipsis_inclusive_range_patterns`에 대한 경고를 생성하지 않고 `#![allow()]` 또는 다른 메커니즘을 사용하여 이러한 린트를 허용하지 않은 경우 마이그레이션할 필요가 없습니다."

#: src/rust-2021/warnings-promoted-to-error.md:48
msgid ""
"To automatically migrate any crate that uses `...` in patterns or does not "
"use `dyn` with trait objects, you can run `cargo fix --edition`."
msgstr "패턴에서 `...`를 사용하거나 트레이트 객체와 함께 `dyn`을 사용하지 않는 모든 크레이트를 자동으로 마이그레이션하려면 `cargo fix --edition`을 실행할 수 있습니다."

#: src/rust-2021/or-patterns-macro-rules.md:5
msgid "How patterns work in `macro_rules` macros changes slightly:"
msgstr "`macro_rules` 매크로에서 패턴이 작동하는 방식이 약간 변경됩니다."

#: src/rust-2021/or-patterns-macro-rules.md:6
msgid "`$_:pat` in `macro_rules` now matches usage of `|` too: e.g. `A | B`."
msgstr "`macro_rules`의 `$_:pat`는 이제 `|`의 사용법과도 일치합니다(예: `A | B`)."

#: src/rust-2021/or-patterns-macro-rules.md:7
msgid ""
"The new `$_:pat_param` behaves like `$_:pat` did before; it does not match "
"(top level) `|`."
msgstr "새로운 `$_:pat_param`은 이전의 `$_:pat`처럼 동작합니다. (최상위 수준) `|`와 일치하지 않습니다."

#: src/rust-2021/or-patterns-macro-rules.md:8
msgid "`$_:pat_param` is available in all editions."
msgstr "`$_:pat_param`은 모든 에디션에서 사용할 수 있습니다."

#: src/rust-2021/or-patterns-macro-rules.md:12
msgid ""
"Starting in Rust 1.53.0, [patterns](https://doc.rust-lang.org/stable/"
"reference/patterns.html) are extended to support `|` nested anywhere in the "
"pattern. This enables you to write `Some(1 | 2)` instead of `Some(1) | "
"Some(2)`. Since this was simply not allowed before, this is not a breaking "
"change."
msgstr "Rust 1.53.0부터 [패턴](https://doc.rust-lang.org/stable/reference/patterns.html)은 패턴의 어느 곳에나 중첩된 `|`를 지원하도록 확장되었습니다. 이를 통해 `Some(1) | Some(2)` 대신 `Some(1 | 2)`를 작성할 수 있습니다. 이전에는 이것이 허용되지 않았기 때문에 이것은 주요 변경 사항이 아닙니다."

#: src/rust-2021/or-patterns-macro-rules.md:17
msgid ""
"However, this change also affects [`macro_rules` macros](https://doc.rust-"
"lang.org/stable/reference/macros-by-example.html). Such macros can accept "
"patterns using the `:pat` fragment specifier. Currently, `:pat` does _not_ "
"match top level `|`, since before Rust 1.53, not all patterns (at all nested "
"levels) could contain a `|`. Macros that accept patterns like `A | B`, such "
"as [`matches!()`](https://doc.rust-lang.org/1.51.0/std/macro.matches.html) "
"use something like `$($_:pat)|+`."
msgstr "그러나 이 변경 사항은 [`macro_rules` 매크로](https://doc.rust-lang.org/stable/reference/macros-by-example.html)에도 영향을 줍니다. 이러한 매크로는 `:pat` 프래그먼트 지정자를 사용하여 패턴을 허용할 수 있습니다. 현재 `:pat`는 최상위 수준 `|`와 일치하지 않습니다. Rust 1.53 이전에는 모든 패턴(모든 중첩 수준에서)에 `|`가 포함될 수 없었기 때문입니다. `A | B`와 같은 패턴을 허용하는 매크로(예: [`matches!()`](https://doc.rust-lang.org/1.51.0/std/macro.matches.html))는 `$($_:pat)|+`와 같은 것을 사용합니다."

#: src/rust-2021/or-patterns-macro-rules.md:25
msgid ""
"Because this would potentially break existing macros, the meaning of `:pat` "
"did not change in Rust 1.53.0 to include `|`. Instead, that change happens "
"in Rust 2021. In the new edition, the `:pat` fragment specifier _will_ match "
"`A | B`."
msgstr "이것이 기존 매크로를 잠재적으로 깨뜨릴 수 있기 때문에 `:pat`의 의미는 Rust 1.53.0에서 `|`를 포함하도록 변경되지 않았습니다. 대신 해당 변경은 Rust 2021에서 발생합니다. 새 에디션에서 `:pat` 프래그먼트 지정자는 `A | B`와 _일치_합니다."

#: src/rust-2021/or-patterns-macro-rules.md:29
msgid ""
"`$_:pat` fragments in Rust 2021 cannot be followed by an explicit `|`. Since "
"there are times that one still wishes to match pattern fragments followed by "
"a `|`, the fragment specified `:pat_param` has been added to retain the "
"older behavior."
msgstr "Rust 2021의 `$_:pat` 프래그먼트 뒤에는 명시적인 `|`가 올 수 없습니다. 여전히 `|`가 뒤따르는 패턴 프래그먼트와 일치시키고 싶을 때가 있으므로 이전 동작을 유지하기 위해 `:pat_param`으로 지정된 프래그먼트가 추가되었습니다."

#: src/rust-2021/or-patterns-macro-rules.md:33
msgid ""
"It's important to remember that editions are _per crate_, so the only "
"relevant edition is the edition of the crate where the macro is defined. The "
"edition of the crate where the macro is used does not change how the macro "
"works."
msgstr "에디션은 _크레이트별_이므로 매크로가 정의된 크레이트의 에디션만 관련이 있다는 것을 기억하는 것이 중요합니다. 매크로가 사용되는 크레이트의 에디션은 매크로 작동 방식을 변경하지 않습니다."

#: src/rust-2021/or-patterns-macro-rules.md:39
msgid ""
"A lint, `rust_2021_incompatible_or_patterns`, gets triggered whenever there "
"is a use `$_:pat` which will change meaning in Rust 2021."
msgstr "`rust_2021_incompatible_or_patterns` 린트는 Rust 2021에서 의미가 변경될 `$_:pat` 사용이 있을 때마다 트리거됩니다."

#: src/rust-2021/or-patterns-macro-rules.md:49
msgid ""
"If you have a macro which relies on `$_:pat` not matching the top level use "
"of `|` in patterns, you'll need to change each occurrence of `$_:pat` to "
"`$_:pat_param`."
msgstr "패턴에서 최상위 수준의 `|` 사용과 일치하지 않는 `$_:pat`에 의존하는 매크로가 있는 경우 각 `$_:pat` 발생을 `$_:pat_param`으로 변경해야 합니다."

#: src/rust-2021/or-patterns-macro-rules.md:57
msgid "// TODO: implementation\n"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:60
msgid ""
"// This macro works in Rust 2018 since `$x:pat` does not match against `|`:\n"
msgstr "// 이 매크로는 `$x:pat`가 `|`와 일치하지 않기 때문에 Rust 2018에서 작동합니다:\n"

#: src/rust-2021/or-patterns-macro-rules.md:63
msgid ""
"// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not "
"allowed\n"
"// to be followed by a `|`. To make sure this macro still works in Rust "
"2021\n"
"// change the macro to the following:\n"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:68
msgid ""
"// <- this line is different\n"
"\t\t// TODO: implementation\n"
msgstr "// <- 이 줄은 다릅니다\n\t\t// TODO: 구현\n"

#: src/rust-2021/c-string-literals.md:5
msgid ""
"Literals of the form `c\\\"foo\\\"` or `cr\\\"foo\\\"` represent a string of type "
"[`&core::ffi::CStr`](../../core/ffi/struct.CStr.html)."
msgstr "`c\\\"foo\\\"` 또는 `cr\\\"foo\\\"` 형식의 리터럴은 [`&core::ffi::CStr`](../../core/ffi/struct.CStr.html) 유형의 문자열을 나타냅니다."

#: src/rust-2021/c-string-literals.md:11
msgid ""
"Starting with Rust 1.77, C-strings can be written using C-string literal "
"syntax with the `c` or `cr` prefix."
msgstr "Rust 1.77부터 C-문자열은 `c` 또는 `cr` 접두사와 함께 C-문자열 리터럴 구문을 사용하여 작성할 수 있습니다."

#: src/rust-2021/c-string-literals.md:13
msgid ""
"Previously, it was challenging to properly produce a valid string literal "
"that could interoperate with C APIs which terminate with a NUL byte. The "
"[`cstr`](https://crates.io/crates/cstr) crate was a popular solution, but "
"that required compiling a proc-macro which was quite expensive. Now, C-"
"strings can be written directly using literal syntax notation, which will "
"generate a value of type [`&core::ffi::CStr`](../../core/ffi/"
"struct.CStr.html) which is automatically terminated with a NUL byte."
msgstr "이전에는 NUL 바이트로 끝나는 C API와 상호 운용할 수 있는 유효한 문자열 리터럴을 올바르게 생성하기가 어려웠습니다. [`cstr`](https://crates.io/crates/cstr) 크레이트가 널리 사용되는 해결책이었지만, 이는 매우 비싼 proc-매크로를 컴파일해야 했습니다. 이제 C-문자열은 리터럴 구문 표기법을 사용하여 직접 작성할 수 있으며, 이는 자동으로 NUL 바이트로 끝나는 [`&core::ffi::CStr`](../../core/ffi/struct.CStr.html) 유형의 값을 생성합니다."

#: src/rust-2021/c-string-literals.md:20
msgid "\"hello\""
msgstr "\"hello\""

#: src/rust-2021/c-string-literals.md:20
msgid "b\"hello\\0\""
msgstr "b\\\"hello\\0\\\""

#: src/rust-2021/c-string-literals.md:22
msgid "\"byte escapes \\xff work\""
msgstr "\"byte escapes \\xff work\""

#: src/rust-2021/c-string-literals.md:23
msgid "b\\\"byte escapes \\\\xff work\\0\\\""
msgstr "b\\\"byte escapes \\\\xff work\\0\\\""

#: src/rust-2021/c-string-literals.md:26
msgid "\"unicode escapes \\u{00E6} work\""
msgstr "\"unicode escapes \\u{00E6} work\""

#: src/rust-2021/c-string-literals.md:27
msgid "b\"unicode escapes \\xc3\\xa6 work\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:30
msgid "\"unicode characters αβγ encoded as UTF-8\""
msgstr ""

#: src/rust-2021/c-string-literals.md:32
msgid ""
"b\"unicode characters \\xce\\xb1\\xce\\xb2\\xce\\xb3 encoded as UTF-8\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:37
msgid ""
"\"strings can continue \\\n"
"        on multiple lines\""
msgstr ""

#: src/rust-2021/c-string-literals.md:39
msgid "b\"strings can continue on multiple lines\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:43
msgid ""
"C-strings do not allow interior NUL bytes (such as with a `\\0` escape)."
msgstr ""

#: src/rust-2021/c-string-literals.md:45
msgid ""
"Similar to regular strings, C-strings also support \"raw\" syntax with the "
"`cr` prefix. These raw C-strings do not process backslash escapes which can "
"make it easier to write strings that contain backslashes. Double-quotes can "
"be included by surrounding the quotes with the `#` character. Multiple `#` "
"characters can be used to avoid ambiguity with internal `\"#` sequences."
msgstr ""

#: src/rust-2021/c-string-literals.md:51
msgid "r\"foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:51 src/rust-2024/reserved-syntax.md:25
#: src/rust-2024/reserved-syntax.md:27
msgid "\"foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:51
msgid "// Number signs can be used to embed interior double quotes.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "r#\"\"foo\"\"#"
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "\"\\\"foo\\\"\""
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "// This requires two #.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "r##\"\"foo\"#\"##"
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "\"\\\"foo\\\"#\""
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "// Escapes are not processed.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:57
msgid "r\"C:\\foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:57
msgid "\"C:\\\\foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:60
msgid ""
"See [The Reference](../../reference/tokens.html#c-string-and-raw-c-string-"
"literals) for more details."
msgstr ""

#: src/rust-2021/c-string-literals.md:67
msgid ""
"Migration is only necessary for macros which may have been assuming a "
"sequence of tokens that looks similar to `c\"…\"` or `cr\"…\"`, which "
"previous to the 2021 edition would tokenize as two separate tokens, but in "
"2021 appears as a single token."
msgstr ""

#: src/rust-2021/c-string-literals.md:69
msgid ""
"As part of the [syntax reservation](reserved-syntax.md) for the 2021 "
"edition, any macro input which may run into this issue should issue a "
"warning from the `rust_2021_prefixes_incompatible_syntax` migration lint. "
"See that chapter for more detail."
msgstr ""

#: src/rust-2024/index.md:5
msgid "[\\#3501](https://rust-lang.github.io/rfcs/3501-edition-2024.html)"
msgstr ""

#: src/rust-2024/index.md:6
msgid "1.85.0"
msgstr ""

#: src/rust-2024/language.md:3
msgid ""
"The following chapters detail changes to the language in the 2024 Edition."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:3
msgid ""
"This chapter describes changes related to the **Lifetime Capture Rules "
"2024** introduced in [RFC 3498](https://github.com/rust-lang/rfcs/pull/"
"3498), including how to use opaque type _precise capturing_ (introduced in "
"[RFC 3617](https://github.com/rust-lang/rfcs/pull/3617)) to migrate your "
"code."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:10
msgid ""
"In Rust 2024, _all_ in-scope generic parameters, including lifetime "
"parameters, are implicitly captured when the `use<..>` bound is not present."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:11
msgid ""
"Uses of the `Captures` trick (`Captures<..>` bounds) and of the outlives "
"trick (e.g. `'_` bounds) can be replaced by `use<..>` bounds (in all "
"editions) or removed entirely (in Rust 2024)."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:15
msgid "Capturing"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:17
msgid ""
"_Capturing_ a generic parameter in an RPIT (return-position impl Trait) "
"opaque type allows for that parameter to be used in the corresponding hidden "
"type.  In Rust 1.82, we added `use<..>` bounds that allow specifying "
"explicitly which generic parameters to capture.  Those will be helpful for "
"migrating your code to Rust 2024, and will be helpful in this chapter for "
"explaining how the edition-specific implicit capturing rules work.  These "
"`use<..>` bounds look like this:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:21
msgid ""
"//                                ~~~~~~~~~~~~~~~~~~~~~~~\n"
"    //                             This is the RPIT opaque type.\n"
"    //\n"
"    //                                It captures `'a` and `T`.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:26
msgid ""
"//~~~~~~\n"
"  // The hidden type is: `(&'a (), T)`.\n"
"  //\n"
"  // This type can use `'a` and `T` because they were captured.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:33
msgid ""
"The generic parameters that are captured affect how the opaque type can be "
"used.  E.g., this is an error because the lifetime is captured despite the "
"fact that the hidden type does not use the lifetime:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:40
msgid "//~^ ERROR lifetime may not live long enough\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:44
msgid "Conversely, this is OK:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:50
msgid "//~ OK\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:54
msgid "Edition-specific rules when no `use<..>` bound is present"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:56
msgid ""
"If the `use<..>` bound is not present, then the compiler uses edition-"
"specific rules to decide which in-scope generic parameters to capture "
"implicitly."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:58
msgid ""
"In all editions, all in-scope type and const generic parameters are captured "
"implicitly when the `use<..>` bound is not present.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:61
msgid ""
"//                                    ~~~~~~~~~~\n"
"//                         No `use<..>` bound is present here.\n"
"//\n"
"// In all editions, the above is equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:69
msgid ""
"In Rust 2021 and earlier editions, when the `use<..>` bound is not present, "
"generic lifetime parameters are only captured when they appear syntactically "
"within a bound in RPIT opaque types in the signature of bare functions and "
"associated functions and methods within inherent impls.  However, starting "
"in Rust 2024, these in-scope generic lifetime parameters are unconditionally "
"captured.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:72
#: src/rust-2024/rpit-lifetime-capture.md:110
msgid "// In Rust 2021 and earlier, the above is equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:74
msgid "// In Rust 2024 and later, it's equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:79
msgid ""
"This makes the behavior consistent with RPIT opaque types in the signature "
"of associated functions and methods within trait impls, uses of RPIT within "
"trait definitions (RPITIT), and opaque `Future` types created by `async fn`, "
"all of which implicitly capture all in-scope generic lifetime parameters in "
"all editions when the `use<..>` bound is not present."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:81
msgid "Outer generic parameters"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:83
msgid ""
"Generic parameters from an outer impl are considered to be in scope when "
"deciding what is implicitly captured.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:87
msgid ""
"//   ~~~~~~~~~~~~~~~~~\n"
"// These generic parameters are in scope.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:91
msgid ""
"//            ~       ~~~~~~~~~~\n"
"    //            ^ This generic is in scope too.\n"
"    //                    ^\n"
"    //                    |\n"
"    //     No `use<..>` bound is present here.\n"
"    //\n"
"    // In all editions, it's equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:102
msgid "Lifetimes from higher-ranked binders"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:104
msgid ""
"Similarly, generic lifetime parameters introduced into scope by a higher-"
"ranked `for<..>` binder are considered to be in scope.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:112
msgid ""
"// In Rust 2024 and later, it's equivalent to:\n"
"//fn f_2024() -> impl for<'a> Tr<'a, Ty = impl Copy + use<'a>> {}\n"
"//                                        ~~~~~~~~~~~~~~~~~~~~\n"
"// However, note that the capturing of higher-ranked lifetimes in\n"
"// nested opaque types is not yet supported.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:120
msgid "Argument position impl Trait (APIT)"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:122
msgid ""
"Anonymous (i.e. unnamed) generic parameters created by the use of APIT "
"(argument position impl Trait) are considered to be in scope.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:125
msgid ""
"//               ~~~~~~~~~~\n"
"//           This is called APIT.\n"
"//\n"
"// The above is *roughly* equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:133
msgid ""
"Note that the former is not _exactly_ equivalent to the latter because, by "
"naming the generic parameter, turbofish syntax can now be used to provide an "
"argument for it.  There is no way to explicitly include an anonymous generic "
"parameter in a `use<..>` bound other than by converting it to a named "
"generic parameter."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:137
msgid "Migrating while avoiding overcapturing"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:139
msgid ""
"The `impl_trait_overcaptures` lint flags RPIT opaque types that will capture "
"additional lifetimes in Rust 2024.  This lint is part of the `rust-2024-"
"compatibility` lint group which is automatically applied when running `cargo "
"fix --edition`.  In most cases, the lint can automatically insert `use<..>` "
"bounds where needed such that no additional lifetimes are captured in Rust "
"2024."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:141
#: src/rust-2024/match-ergonomics.md:106
msgid "To migrate your code to be compatible with Rust 2024, run:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:147 src/rust-2024/gen-keyword.md:25
#: src/rust-2024/intoiterator-box-slice.md:56
#: src/rust-2024/newly-unsafe-functions.md:50
msgid "For example, this will change:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:153
msgid "...into:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:159
msgid ""
"Without this `use<>` bound, in Rust 2024, the opaque type would capture the "
"`'a` lifetime parameter.  By adding this bound, the migration lint preserves "
"the existing semantics."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:161
msgid "Migrating cases involving APIT"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:163
msgid ""
"In some cases, the lint cannot make the change automatically because a "
"generic parameter needs to be given a name so that it can appear within a "
"`use<..>` bound.  In these cases, the lint will alert you that a change may "
"need to be made manually.  E.g., given:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:166
msgid ""
"//   ^^                ~~~~~~~~~~\n"
"//               This is a use of APIT.\n"
"//\n"
"//~^ WARN `impl Sized` will capture more lifetimes than possibly intended in "
"edition 2024\n"
"//~| NOTE specifically, this lifetime is in scope but not mentioned in the "
"type's bounds\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:178
msgid ""
"The code cannot be converted automatically because of the use of APIT and "
"the fact that the generic type parameter must be named in the `use<..>` "
"bound.  To convert this code to Rust 2024 without capturing the lifetime, "
"you must name that type parameter.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:182
msgid ""
"//       ~~~~~~~~\n"
"// The type parameter has been named here.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:191
msgid ""
"Note that this changes the API of the function slightly as a type argument "
"can now be explicitly provided for this parameter using turbofish syntax.  "
"If this is undesired, you might consider instead whether you can simply "
"continue to omit the `use<..>` bound and allow the lifetime to be captured.  "
"This might be particularly desirable if you might in the future want to use "
"that lifetime in the hidden type and would like to save space for that."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:193
msgid "Migrating away from the `Captures` trick"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:195
msgid ""
"Prior to the introduction of precise capturing `use<..>` bounds in Rust "
"1.82, correctly capturing a lifetime in an RPIT opaque type often required "
"using the `Captures` trick.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:202
msgid ""
"//                                           ~~~~~~~~~~~~~~~~~~~~~\n"
"//                            This is called the `Captures` trick.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:213
msgid ""
"With the `use<..>` bound syntax, the `Captures` trick is no longer needed "
"and can be replaced with the following in all editions:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:225
#: src/rust-2024/rpit-lifetime-capture.md:269
msgid ""
"In Rust 2024, the `use<..>` bound can often be omitted entirely, and the "
"above can be written simply as:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:237
msgid ""
"There is no automatic migration for this, and the `Captures` trick still "
"works in Rust 2024, but you might want to consider migrating code manually "
"away from using this old trick."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:239
msgid "Migrating away from the outlives trick"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:241
msgid ""
"Prior to the introduction of precise capturing `use<..>` bounds in Rust "
"1.82, it was common to use the \"outlives trick\" when a lifetime needed to "
"be used in the hidden type of some opaque.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:245
msgid ""
"//    ~~~~                                 ~~~~\n"
"    //    ^                     This is the outlives trick.\n"
"    //    |\n"
"    // This bound is needed only for the trick.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:249
msgid ""
"//  ~~~~~~\n"
"// The hidden type is `(&'a (), T)`.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:255
msgid ""
"This trick was less baroque than the `Captures` trick, but also less "
"correct.  As we can see in the example above, even though any lifetime "
"components within `T` are independent from the lifetime `'a`, we're required "
"to add a `T: 'a` bound in order to make the trick work.  This created undue "
"and surprising restrictions on callers."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:257
msgid ""
"Using precise capturing, you can write the above instead, in all editions, "
"as:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:281
msgid ""
"There is no automatic migration for this, and the outlives trick still works "
"in Rust 2024, but you might want to consider migrating code manually away "
"from using this old trick."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:5
msgid ""
"In an `if let $pat = $expr { .. } else { .. }` expression, the temporary "
"values generated from evaluating `$expr` will be dropped before the program "
"enters the `else` branch instead of after."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:9
msgid ""
"The 2024 Edition changes the drop scope of [temporary values](../../"
"reference/expressions.html#temporaries) in the scrutinee[^scrutinee] of an "
"`if let` expression. This is intended to help reduce the potentially "
"unexpected behavior involved with the temporary living for too long."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:11
msgid ""
"Before 2024, the temporaries could be extended beyond the `if let` "
"expression itself. For example:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:14
#: src/rust-2024/temporary-tail-expr-scope.md:17
msgid "// Before 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:19
#: src/rust-2024/temporary-if-let-scope.md:40
#: src/rust-2024/temporary-if-let-scope.md:72
msgid "\"value is {x}\""
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:26
msgid "// <--- Read lock is dropped here in 2021\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:30
msgid ""
"In this example, the temporary read lock generated by the call to "
"`value.read()` will not be dropped until after the `if let` expression (that "
"is, after the `else` block). In the case where the `else` block is executed, "
"this causes a deadlock when it attempts to acquire a write lock."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:32
msgid ""
"The 2024 Edition shortens the lifetime of the temporaries to the point where "
"the then-block is completely evaluated or the program control enters the "
"`else` block."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:35
msgid "// Starting with 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:42
msgid "// <--- Read lock is dropped here in 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:52
msgid ""
"See the [temporary scope rules](../../reference/destructors.html#temporary-"
"scopes) for more information about how temporary scopes are extended. See "
"the [tail expression temporary scope](temporary-tail-expr-scope.md) chapter "
"for a similar change made to tail expressions."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:54
msgid ""
"The [scrutinee](../../reference/glossary.html#scrutinee) is the expression "
"being matched on in the `if let` expression."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:63
msgid ""
"It is always safe to rewrite `if let` with a `match`. The temporaries of the "
"`match` scrutinee are extended past the end of the `match` expression "
"(typically to the end of the statement), which is the same as the 2021 "
"behavior of `if let`."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:65
msgid ""
"The [`if_let_rescope`](../../rustc/lints/listing/allowed-by-default.html#if-"
"let-rescope) lint suggests a fix when a lifetime issue arises due to this "
"change or the lint detects that a temporary value with a custom, non-trivial "
"`Drop` destructor is generated from the scrutinee of the `if let`. For "
"instance, the earlier example may be rewritten into the following when the "
"suggestion from `cargo fix` is accepted:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:81
msgid "// <--- Read lock is dropped here in both 2021 and 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:85
msgid ""
"In this particular example, that's probably not what you want due to the "
"aforementioned deadlock! However, some scenarios may be assuming that the "
"temporaries are held past the `else` clause, in which case you may want to "
"retain the old behavior."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:87
msgid ""
"The [`if_let_rescope`](../../rustc/lints/listing/allowed-by-default.html#if-"
"let-rescope) lint is part of the `rust-2024-compatibility` lint group which "
"is included in the automatic edition migration. In order to migrate your "
"code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:93
msgid ""
"After the migration, it is recommended that you review all of the changes of "
"`if let` to `match` and decide what is the behavior that you need with "
"respect to when temporaries are dropped. If you determine that the change is "
"unnecessary, then you can revert the change back to `if let`."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:95
#: src/rust-2024/temporary-tail-expr-scope.md:92
msgid ""
"If you want to manually inspect these warnings without performing the "
"edition migration, you can enable the lint with:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:98
#: src/rust-2024/temporary-tail-expr-scope.md:95
#: src/rust-2024/match-ergonomics.md:131 src/rust-2024/unsafe-extern.md:50
#: src/rust-2024/unsafe-attributes.md:73
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:54
#: src/rust-2024/macro-fragment-specifiers.md:47
#: src/rust-2024/gen-keyword.md:52 src/rust-2024/reserved-syntax.md:59
#: src/rust-2024/prelude.md:74 src/rust-2024/newly-unsafe-functions.md:72
msgid "// Add this to the root of your crate to do a manual migration.\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:5
msgid ""
"Temporary values generated in evaluation of the tail expression of a "
"[function](../../reference/items/functions.html) or closure body, or a "
"[block](../../reference/expressions/block-expr.html) may now be dropped "
"before local variables, and are sometimes not extended to the next larger "
"temporary scope."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:12
msgid ""
"The 2024 Edition changes the drop order of [temporary values](../../"
"reference/expressions.html#temporaries) in tail expressions. It often comes "
"as a surprise that, before the 2024 Edition, temporary values in tail "
"expressions can live longer than the block itself, and are dropped later "
"than the local variable bindings, as in the following example:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:20
msgid "\"..\""
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:21
msgid "// error[E0597]: `c` does not live long enough\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:25
msgid "This yields the following error with the 2021 Edition:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:27
msgid ""
"```text\n"
"error[E0597]: `c` does not live long enough\n"
" --> src/lib.rs:4:5\n"
"  |\n"
"3 |     let c = RefCell::new(\"..\");\n"
"  |         - binding `c` declared here\n"
"4 |     c.borrow().len() // error[E0597]: `c` does not live long enough\n"
"  |     ^---------\n"
"  |     |\n"
"  |     borrowed value does not live long enough\n"
"  |     a temporary with access to the borrow is created here ...\n"
"5 | }\n"
"  | -\n"
"  | |\n"
"  | `c` dropped here while still borrowed\n"
"  | ... and the borrow might be used here, when that temporary is dropped "
"and runs the destructor for type `Ref<'_, &str>`\n"
"  |\n"
"  = note: the temporary is part of an expression at the end of a block;\n"
"          consider forcing this temporary to be dropped sooner, before the "
"block's local variables are dropped\n"
"help: for example, you could save the expression's value in a new local "
"variable `x` and then make `x` be the expression at the end of the block\n"
"  |\n"
"4 |     let x = c.borrow().len(); x // error[E0597]: `c` does not live long "
"enough\n"
"  |     +++++++                 +++\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"```"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:54
msgid ""
"In 2021 the local variable `c` is dropped before the temporary created by "
"`c.borrow()`. The 2024 Edition changes this so that the temporary value "
"`c.borrow()` is dropped first, followed by dropping the local variable `c`, "
"allowing the code to compile as expected."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:56
msgid "Temporary scope may be narrowed"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:58
msgid ""
"When a temporary is created in order to evaluate an expression, the "
"temporary is dropped based on the [temporary scope rules](../../reference/"
"destructors.html#temporary-scopes). Those rules define how long the "
"temporary will be kept alive. Before 2024, temporaries from tail expressions "
"of a block would be extended outside of the block to the next temporary "
"scope boundary. In many cases this would be the end of a statement or "
"function body. In 2024, the temporaries of the tail expression may now be "
"dropped immediately at the end of the block (before any local variables in "
"the block)."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:60
msgid ""
"This narrowing of the temporary scope may cause programs to fail to compile "
"in 2024. For example:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:63
msgid "// This example works in 2021, but fails to compile in 2024.\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:65
#: src/rust-2024/temporary-tail-expr-scope.md:75
msgid "\"1234\""
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:69
msgid ""
"In this example, in 2021, the temporary `String` is extended outside of the "
"block, past the call to `len()`, and is dropped at the end of the statement. "
"In 2024, it is dropped immediately at the end of the block, causing a "
"compile error about the temporary being dropped while borrowed."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:71
msgid ""
"The solution for these kinds of situations is to lift the block expression "
"out to a local variable so that the temporary lives long enough:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:80
msgid ""
"This particular example takes advantage of [temporary lifetime extension]"
"(../../reference/destructors.html#temporary-lifetime-extension). Temporary "
"lifetime extension is a set of specific rules which allow temporaries to "
"live longer than they normally would. Because the `String` temporary is "
"behind a reference, the `String` temporary is extended long enough for the "
"next statement to call `len()` on it."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:82
msgid ""
"See the [`if let` temporary scope](temporary-if-let-scope.md) chapter for a "
"similar change made to temporary scopes of `if let` expressions."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:90
msgid ""
"Unfortunately, there are no semantics-preserving rewrites to shorten the "
"lifetime for temporary values in tail expressions[^RFC3606]. The "
"[`tail_expr_drop_order`](../../rustc/lints/listing/allowed-by-"
"default.html#tail-expr-drop-order) lint detects if a temporary value with a "
"custom, non-trivial `Drop` destructor is generated in a tail expression. "
"Warnings from this lint will appear when running `cargo fix --edition`, but "
"will otherwise not automatically make any changes. It is recommended to "
"manually inspect the warnings and determine whether or not you need to make "
"any adjustments."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:99
msgid ""
"Details are documented at [RFC 3606](https://github.com/rust-lang/rfcs/pull/"
"3606)"
msgstr ""

#: src/rust-2024/match-ergonomics.md:5
msgid ""
"Writing `mut`, `ref`, or `ref mut` on a binding is only allowed within a "
"pattern when the pattern leading up to that binding is fully explicit (i.e. "
"when it does not use match ergonomics)."
msgstr ""

#: src/rust-2024/match-ergonomics.md:6
msgid ""
"Put differently, when the default binding mode is not `move`, writing `mut`, "
"`ref`, or `ref mut` on a binding is an error."
msgstr ""

#: src/rust-2024/match-ergonomics.md:7
msgid ""
"Reference patterns (`&` or `&mut`) are only allowed within the fully-"
"explicit prefix of a pattern."
msgstr ""

#: src/rust-2024/match-ergonomics.md:8
msgid ""
"Put differently, reference patterns can only match against references in the "
"scrutinee when the default binding mode is `move`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:12
msgid "Background"
msgstr ""

#: src/rust-2024/match-ergonomics.md:14
msgid ""
"Within `match`, `let`, and other constructs, we match a _pattern_ against a "
"_scrutinee_.  E.g.:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:17
msgid ""
"// x: &()\n"
"//  ~~~~~~~~~~~~~~~   ~~~~~~~~~~~~\n"
"//      Pattern        Scrutinee\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:22
msgid ""
"Such a pattern is called fully explicit because it does not elide (i.e. "
"\"skip\" or \"pass\") any references within the scrutinee.  By contrast, "
"this otherwise-equivalent pattern is not fully explicit:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:25 src/rust-2024/match-ergonomics.md:73
#: src/rust-2024/match-ergonomics.md:81
msgid "// x: &()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:28
msgid ""
"Patterns such as this are said to be using match ergonomics, originally "
"introduced in [RFC 2005](https://github.com/rust-lang/rfcs/pull/2005)."
msgstr ""

#: src/rust-2024/match-ergonomics.md:30
msgid ""
"Under match ergonomics, as we incrementally match a pattern against a "
"scrutinee, we keep track of the default binding mode.  This mode can be one "
"of `move`, `ref mut`, or `ref`, and it starts as `move`.  When we reach a "
"binding, unless an explicit binding mode is provided, the default binding "
"mode is used to decide the binding's type."
msgstr ""

#: src/rust-2024/match-ergonomics.md:32
msgid ""
"For example, here we provide an explicit binding mode, causing `x` to be "
"bound by reference:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:35 src/rust-2024/match-ergonomics.md:41
msgid "// &()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:38
msgid "By contrast:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:44
msgid ""
"Here, in the pattern, we pass the outer shared reference in the scrutinee.  "
"This causes the default binding mode to switch from `move` to `ref`.  Since "
"there is no explicit binding mode specified, the `ref` binding mode is used "
"when binding `x`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:48
msgid "`mut` restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:50 src/rust-2024/match-ergonomics.md:86
msgid "In Rust 2021 and earlier editions, we allow this oddity:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:53 src/rust-2024/match-ergonomics.md:65
msgid "// x: &(), mut y: ()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:56
msgid ""
"Here, because we pass the shared reference in the pattern, the default "
"binding mode switches to `ref`.  But then, in these editions, writing `mut` "
"on the binding resets the default binding mode to `move`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:58
msgid ""
"This can be surprising as it's not intuitive that mutability should affect "
"the type."
msgstr ""

#: src/rust-2024/match-ergonomics.md:60
msgid ""
"To leave space to fix this, in Rust 2024 it's an error to write `mut` on a "
"binding when the default binding mode is not `move`.  That is, `mut` can "
"only be written on a binding when the pattern (leading up to that binding) "
"is fully explicit."
msgstr ""

#: src/rust-2024/match-ergonomics.md:62 src/rust-2024/match-ergonomics.md:96
msgid "In Rust 2024, we can write the above example as:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:68
msgid "`ref` / `ref mut` restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:70
msgid "In Rust 2021 and earlier editions, we allow:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:76
msgid ""
"Here, the `ref` explicit binding mode is redundant, as by passing the shared "
"reference (i.e. not mentioning it in the pattern), the binding mode switches "
"to `ref`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:78
msgid ""
"To leave space for other language possibilities, we are disallowing explicit "
"binding modes where they are redundant in Rust 2024.  We can rewrite the "
"above example as simply:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:84
msgid "Reference patterns restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:89
msgid "// x: (), y: &&()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:92
msgid ""
"Here, the `&` in the pattern both matches against the reference on `&()` and "
"resets the default binding mode to `move`.  This can be surprising because "
"the single `&` in the pattern causes a larger than expected change in the "
"type by removing both layers of references."
msgstr ""

#: src/rust-2024/match-ergonomics.md:94
msgid ""
"To leave space to fix this, in Rust 2024 it's an error to write `&` or "
"`&mut` in the pattern when the default binding mode is not `move`.  That is, "
"`&` or `&mut` can only be written when the pattern (leading up to that "
"point) is fully explicit."
msgstr ""

#: src/rust-2024/match-ergonomics.md:104
msgid ""
"The [`rust_2024_incompatible_pat`](../../rustc/lints/listing/allowed-by-"
"default.html#rust-2024-incompatible-pat) lint flags patterns that are not "
"allowed in Rust 2024.  This lint is part of the `rust-2024-compatibility` "
"lint group which is automatically applied when running `cargo fix --"
"edition`.  This lint will automatically convert affected patterns to fully "
"explicit patterns that work correctly in Rust 2024 and in all prior editions."
msgstr ""

#: src/rust-2024/match-ergonomics.md:112
msgid "For example, this will convert this..."
msgstr ""

#: src/rust-2024/match-ergonomics.md:120
msgid "...into this:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:128
msgid ""
"Alternatively, you can manually enable the lint to find patterns that will "
"need to be migrated:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:5
msgid ""
"[`extern` blocks](../../reference/items/external-blocks.html) must now be "
"marked with the `unsafe` keyword."
msgstr ""

#: src/rust-2024/unsafe-extern.md:11
msgid ""
"Rust 1.82 added the ability in all editions to mark [`extern` blocks](../../"
"reference/items/external-blocks.html) with the `unsafe` keyword.[^RFC3484] "
"Adding the `unsafe` keyword helps to emphasize that it is the responsibility "
"of the author of the `extern` block to ensure that the signatures are "
"correct. If the signatures are not correct, then it may result in undefined "
"behavior."
msgstr ""

#: src/rust-2024/unsafe-extern.md:13
msgid "The syntax for an unsafe `extern` block looks like this:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:16 src/rust-2024/static-mut-references.md:270
msgid "\"C\""
msgstr ""

#: src/rust-2024/unsafe-extern.md:17
msgid "// sqrt (from libm) may be called with any `f64`\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:20
msgid ""
"// strlen (from libc) requires a valid pointer,\n"
"    // so we mark it as being an unsafe fn\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:24
msgid "// this function doesn't say safe or unsafe, so it defaults to unsafe\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:31
msgid ""
"In addition to being able to mark an `extern` block as `unsafe`, you can "
"also specify if individual items in the `extern` block are `safe` or "
"`unsafe`. Items marked as `safe` can be used without an `unsafe` block."
msgstr ""

#: src/rust-2024/unsafe-extern.md:33
msgid ""
"Starting with the 2024 Edition, it is now required to include the `unsafe` "
"keyword on an `extern` block. This is intended to make it very clear that "
"there are safety requirements that must be upheld by the extern definitions."
msgstr ""

#: src/rust-2024/unsafe-extern.md:35
msgid ""
"See [RFC 3484](https://github.com/rust-lang/rfcs/blob/master/text/3484-"
"unsafe-extern-blocks.md) for the original proposal."
msgstr ""

#: src/rust-2024/unsafe-extern.md:39
msgid ""
"The [`missing_unsafe_on_extern`](../../rustc/lints/listing/allowed-by-"
"default.html#missing-unsafe-on-extern) lint can update `extern` blocks to "
"add the `unsafe` keyword. The lint is part of the `rust-2024-compatibility` "
"lint group which is included in the automatic edition migration. In order to "
"migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:45
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"the signatures in the `extern` block are correct. It is still your "
"responsibility to manually review their definition."
msgstr ""

#: src/rust-2024/unsafe-extern.md:47
msgid ""
"Alternatively, you can manually enable the lint to find places where there "
"are `unsafe` blocks that need to be updated."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:5
msgid "The following attributes must now be marked as `unsafe`:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:6
msgid "[`export_name`](../../reference/abi.html#the-export_name-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:7
msgid "[`link_section`](../../reference/abi.html#the-link_section-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:8
msgid "[`no_mangle`](../../reference/abi.html#the-no_mangle-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:16
msgid ""
"Rust 1.82 added the ability in all editions to mark certain attributes as "
"`unsafe` to indicate that they have soundness requirements that must be "
"upheld.[^RFC3325] The syntax for an unsafe attribute looks like this:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:19
msgid "// SAFETY: there is no other global function of this name\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:24
msgid ""
"Marking the attribute with `unsafe` highlights that there are safety "
"requirements that must be upheld that the compiler cannot verify on its own."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:26
msgid ""
"Starting with the 2024 Edition, it is now required to mark these attributes "
"as `unsafe`. The following section describes the safety requirements for "
"these attributes."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:28
msgid ""
"See [RFC 3325](https://rust-lang.github.io/rfcs/3325-unsafe-attributes.html) "
"for the original proposal."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:30
msgid "Safety requirements"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:32
msgid ""
"The [`no_mangle`](../../reference/abi.html#the-no_mangle-attribute), "
"[`export_name`](../../reference/abi.html#the-export_name-attribute), and "
"[`link_section`](../../reference/abi.html#the-link_section-attribute) "
"attributes influence the symbol names and linking behavior of items. Care "
"must be taken to ensure that these attributes are used correctly."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:34
msgid ""
"Because the set of symbols across all linked libraries is a global "
"namespace, there can be issues if there is a symbol name collision between "
"libraries. Typically this isn't an issue for normally defined functions "
"because [symbol mangling](../../rustc/symbol-mangling/index.html) helps "
"ensure that the symbol name is unique. However, attributes like "
"`export_name` can upset that assumption of uniqueness."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:36
msgid ""
"For example, in previous editions the following crashes on most Unix-like "
"platforms despite containing only safe code:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:40
msgid "\"Hello, world!\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:43
msgid "\"malloc\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:47
msgid ""
"In the 2024 Edition, it is now required to mark these attributes as unsafe "
"to emphasize that it is required to ensure that the symbol is defined "
"correctly:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:50
msgid ""
"// SAFETY: There should only be a single definition of the loop symbol.\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:51
msgid "\"loop\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:53
#: src/rust-2024/static-mut-references.md:161
#: src/rust-2024/static-mut-references.md:238
msgid "// ...\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:62
msgid ""
"The [`unsafe_attr_outside_unsafe`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-attr-outside-unsafe) lint can update these attributes to "
"use the `unsafe(...)` format. The lint is part of the `rust-2024-"
"compatibility` lint group which is included in the automatic edition "
"migration. In order to migrate your code to be Rust 2024 Edition compatible, "
"run:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:68
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"these attributes are being used correctly. It is still your responsibility "
"to manually review their usage."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:70
msgid ""
"Alternatively, you can manually enable the lint to find places where these "
"attributes need to be updated."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:1
msgid "unsafe_op_in_unsafe_fn warning"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:5
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint now warns by default. This warning "
"detects calls to unsafe operations in unsafe functions without an explicit "
"unsafe block."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:12
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint will fire if there are [unsafe "
"operations](../../reference/unsafety.html) in an unsafe function without an "
"explicit [`unsafe {}` block](../../reference/expressions/block-"
"expr.html#unsafe-blocks)."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:17
msgid "// WARNING: requires unsafe block\n"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:21
msgid "The solution is to wrap any unsafe operations in an `unsafe` block:"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:30
msgid ""
"This change is intended to help protect against accidental use of unsafe "
"operations in an unsafe function. The `unsafe` function keyword was "
"performing two roles. One was to declare that _calling_ the function "
"requires unsafe, and that the caller is responsible to uphold additional "
"safety requirements. The other role was to allow the use of unsafe "
"operations inside of the function. This second role was determined to be too "
"risky without explicit `unsafe` blocks."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:36
msgid ""
"More information and motivation may be found in [RFC #2585](https://rust-"
"lang.github.io/rfcs/2585-unsafe-block-in-unsafe-fn.html)."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:44
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint is part of the `rust-2024-"
"compatibility` lint group. In order to migrate your code to be Rust 2024 "
"Edition compatible, run:"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:51
msgid ""
"Alternatively, you can manually enable the lint to find places where unsafe "
"blocks need to be added, or switch it to `allow` to silence the lint "
"completely."
msgstr ""

#: src/rust-2024/static-mut-references.md:1
msgid "Disallow references to static mut"
msgstr ""

#: src/rust-2024/static-mut-references.md:5
msgid ""
"The [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint level is now `deny` by default. This "
"checks for taking a shared or mutable reference to a `static mut`."
msgstr ""

#: src/rust-2024/static-mut-references.md:12
msgid ""
"The [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint detects taking a reference to a [`static "
"mut`](../../reference/items/static-items.html#mutable-statics). In the 2024 "
"Edition, this lint is now `deny` by default to emphasize that you should "
"avoid making these references."
msgstr ""

#: src/rust-2024/static-mut-references.md:20
#: src/rust-2024/static-mut-references.md:21
#: src/rust-2024/static-mut-references.md:22
#: src/rust-2024/static-mut-references.md:35
#: src/rust-2024/static-mut-references.md:36
msgid "// ERROR: shared reference to mutable static\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:26
msgid ""
"Merely taking such a reference in violation of Rust's mutability XOR "
"aliasing requirement has always been _instantaneous_ [undefined behavior]"
"(../../reference/behavior-considered-undefined.html), **even if the "
"reference is never read from or written to**.  Furthermore, upholding "
"mutability XOR aliasing for a `static mut` requires _reasoning about your "
"code globally_, which can be particularly difficult in the face of "
"reentrancy and/or multithreading."
msgstr ""

#: src/rust-2024/static-mut-references.md:28
msgid ""
"Note that there are some cases where implicit references are automatically "
"created without a visible `&` operator. For example, these situations will "
"also trigger the lint:"
msgstr ""

#: src/rust-2024/static-mut-references.md:35
msgid "\"{NUMS:?}\""
msgstr ""

#: src/rust-2024/static-mut-references.md:40
msgid "Alternatives"
msgstr ""

#: src/rust-2024/static-mut-references.md:42
msgid ""
"Wherever possible, it is **strongly recommended** to use instead an "
"_immutable_ `static` of a type that provides _interior mutability_ behind "
"some _locally-reasoned abstraction_ (which greatly reduces the complexity of "
"ensuring that Rust's mutability XOR aliasing requirement is upheld)."
msgstr ""

#: src/rust-2024/static-mut-references.md:44
msgid ""
"In situations where no locally-reasoned abstraction is possible and you are "
"therefore compelled still to reason globally about accesses to your `static` "
"variable, you must now use raw pointers such as can be obtained via the "
"[`&raw const` or `&raw mut` operators](../../reference/expressions/operator-"
"expr.html#raw-borrow-operators).  By first obtaining a raw pointer rather "
"than directly taking a reference, (the safety requirements of) accesses "
"through that pointer will be more familiar to `unsafe` developers and can be "
"deferred until/limited to smaller regions of code."
msgstr ""

#: src/rust-2024/static-mut-references.md:51
msgid ""
"Note that the following examples are just illustrations and are not intended "
"as full-fledged implementations. Do not copy these as-is. There are details "
"for your specific situation that may require alterations to fit your needs. "
"These are intended to help you see different ways to approach your problem."
msgstr ""

#: src/rust-2024/static-mut-references.md:53
msgid ""
"It is recommended to read the documentation for the specific types in the "
"standard library, the reference on [undefined behavior](../../reference/"
"behavior-considered-undefined.html), the [Rustonomicon](../../nomicon/"
"index.html), and if you are having questions to reach out on one of the Rust "
"forums such as the [Users Forum](https://users.rust-lang.org/)."
msgstr ""

#: src/rust-2024/static-mut-references.md:59
msgid "Don't use globals"
msgstr ""

#: src/rust-2024/static-mut-references.md:61
msgid ""
"This is probably something you already know, but if possible it is best to "
"avoid mutable global state. Of course this can be a little more awkward or "
"difficult at times, particularly if you need to pass a mutable reference "
"around between many functions."
msgstr ""

#: src/rust-2024/static-mut-references.md:63
msgid "Atomics"
msgstr ""

#: src/rust-2024/static-mut-references.md:65
msgid ""
"The [atomic types](../../std/sync/atomic/index.html) provide integers, "
"pointers, and booleans that can be used in a `static` (without `mut`)."
msgstr ""

#: src/rust-2024/static-mut-references.md:70
msgid ""
"// Change from this:\n"
"//   static mut COUNTER: u64 = 0;\n"
"// to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:77
msgid ""
"// Be sure to analyze your use case to determine the correct Ordering to "
"use.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:84
msgid "Mutex or RwLock"
msgstr ""

#: src/rust-2024/static-mut-references.md:86
msgid ""
"When your type is more complex than an atomic, consider using a [`Mutex`]"
"(../../std/sync/struct.Mutex.html) or [`RwLock`](../../std/sync/"
"struct.RwLock.html) to ensure proper access to the global value."
msgstr ""

#: src/rust-2024/static-mut-references.md:91
msgid ""
"// Change from this:\n"
"//     static mut QUEUE: VecDeque<String> = VecDeque::new();\n"
"// to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:98
msgid "\"abc\""
msgstr ""

#: src/rust-2024/static-mut-references.md:106
msgid "OnceLock or LazyLock"
msgstr ""

#: src/rust-2024/static-mut-references.md:108
msgid ""
"If you are using a `static mut` because you need to do some one-time "
"initialization that can't be `const`, you can instead reach for [`OnceLock`]"
"(../../std/sync/struct.OnceLock.html) or [`LazyLock`](../../std/sync/"
"struct.LazyLock.html) instead."
msgstr ""

#: src/rust-2024/static-mut-references.md:121
msgid ""
"// Instead of some temporary or uninitialized type like:\n"
"//     static mut STATE: Option<GlobalState> = None;\n"
"// use this instead:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:134
msgid ""
"[`OnceLock`](../../std/sync/struct.OnceLock.html) is similar to [`LazyLock`]"
"(../../std/sync/struct.LazyLock.html), but can be used if you need to pass "
"information into the constructor, which can work well with single "
"initialization points (like `main`), or if the inputs are available wherever "
"you access the global."
msgstr ""

#: src/rust-2024/static-mut-references.md:169
msgid "`no_std` one-time initialization"
msgstr ""

#: src/rust-2024/static-mut-references.md:171
msgid ""
"This example is similar to [`OnceLock`](../../std/sync/struct.OnceLock.html) "
"in that it provides one-time initialization of a global, but it does not "
"require `std` which is useful in a `no_std` context. Assuming your target "
"supports atomics, then you can use an atomic to check for the initialization "
"of the global. The pattern might look something like this:"
msgstr ""

#: src/rust-2024/static-mut-references.md:215
msgid ""
"// SAFETY: The reads and writes to STATE are guarded with the INITIALIZED "
"guard.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:221
msgid "\"already initialized, or concurrent initialization\""
msgstr ""

#: src/rust-2024/static-mut-references.md:227
msgid "\"not initialized\""
msgstr ""

#: src/rust-2024/static-mut-references.md:229
msgid ""
"// SAFETY: Mutable access is not possible after state has been initialized.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:244
msgid ""
"This example assumes you can put some default value in the static before it "
"is initialized (the const `default` constructor in this example). If that is "
"not possible, consider using either [`MaybeUninit`](../../core/mem/"
"union.MaybeUninit.html), or dynamic trait dispatch (with a dummy type that "
"implements a trait), or some other approach to have a default placeholder."
msgstr ""

#: src/rust-2024/static-mut-references.md:246
msgid ""
"There are community-provided crates that can provide similar one-time "
"initialization, such as the [`static-cell`](https://crates.io/crates/"
"static_cell) crate (which supports targets that do not have atomics by using "
"[`portable-atomic`](https://crates.io/crates/portable-atomic))."
msgstr ""

#: src/rust-2024/static-mut-references.md:252
msgid "Raw pointers"
msgstr ""

#: src/rust-2024/static-mut-references.md:254
msgid ""
"In some cases you can continue to use `static mut`, but avoid creating "
"references. For example, if you just need to pass [raw pointers](../../"
"reference/types/pointer.html#raw-pointers-const-and-mut) into a C library, "
"don't create an intermediate reference. Instead you can use [raw borrow "
"operators](../../reference/expressions/operator-expr.html#raw-borrow-"
"operators), like in the following example:"
msgstr ""

#: src/rust-2024/static-mut-references.md:276
msgid ""
"// Change from this:\n"
"        //     example_ffi(&mut STATE as *mut GlobalState);\n"
"        // to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:284
msgid ""
"Just beware that you still need to uphold the aliasing constraints around "
"mutable pointers. This may require some internal or external synchronization "
"or proofs about how it is used across threads, interrupt handlers, and "
"reentrancy."
msgstr ""

#: src/rust-2024/static-mut-references.md:289
msgid "`UnsafeCell` with `Sync`"
msgstr ""

#: src/rust-2024/static-mut-references.md:291
msgid ""
"[`UnsafeCell`](../../std/cell/struct.UnsafeCell.html) does not impl `Sync`, "
"so it cannot be used in a `static`. You can create your own wrapper around "
"[`UnsafeCell`](../../std/cell/struct.UnsafeCell.html) to add a `Sync` impl "
"so that it can be used in a `static` to implement interior mutability. This "
"approach can be useful if you have external locks or other guarantees that "
"uphold the safety invariants required for mutable pointers."
msgstr ""

#: src/rust-2024/static-mut-references.md:293
msgid ""
"Note that this is largely the same as the [raw pointers](#raw-pointers) "
"example. The wrapper helps to emphasize how you are using the type, and "
"focus on which safety requirements you should be careful of. But otherwise "
"they are roughly the same."
msgstr ""

#: src/rust-2024/static-mut-references.md:299
msgid "// A real example would disable interrupts.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:325
msgid ""
"// SAFETY: This value is only ever read in our interrupt handler,\n"
"            // and interrupts are disabled, and we only use this in one "
"thread.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:333
msgid ""
"The standard library has a nightly-only (unstable) variant of [`UnsafeCell`]"
"(../../std/cell/struct.UnsafeCell.html) called [`SyncUnsafeCell`](../../std/"
"cell/struct.SyncUnsafeCell.html). This example above shows a very simplified "
"version of the standard library type, but would be used roughly the same "
"way. It can provide even better isolation, so do check out its "
"implementation for more details."
msgstr ""

#: src/rust-2024/static-mut-references.md:335
msgid ""
"This example includes a fictional `with_interrupts_disabled` function which "
"is the type of thing you might see in an embedded environment. For example, "
"the [`critical-section`](https://crates.io/crates/critical-section) crate "
"provides a similar kind of functionality that could be used for an embedded "
"environment."
msgstr ""

#: src/rust-2024/static-mut-references.md:341
msgid "Safe references"
msgstr ""

#: src/rust-2024/static-mut-references.md:343
msgid ""
"In some cases it may be safe to create a reference of a `static mut`. The "
"whole point of the [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint is that this is very hard to do "
"correctly! However, that's not to say it is _impossible_. If you have a "
"situation where you can guarantee that the aliasing requirements are upheld, "
"such as guaranteeing the static is narrowly scoped (only used in a small "
"module or function), has some internal or external synchronization, accounts "
"for interrupt handlers and reentrancy, panic safety, drop handlers, etc., "
"then taking a reference may be fine."
msgstr ""

#: src/rust-2024/static-mut-references.md:345
msgid ""
"There are two approaches you can take for this. You can either allow the "
"[`static_mut_refs`](../../rustc/lints/listing/warn-by-default.html#static-"
"mut-refs) lint (preferably as narrowly as you can), or convert raw pointers "
"to a reference, as with `&mut *&raw mut MY_STATIC`."
msgstr ""

#: src/rust-2024/static-mut-references.md:349
msgid "Short-lived references"
msgstr ""

#: src/rust-2024/static-mut-references.md:351
msgid ""
"If you must create a reference to a `static mut`, then it is recommended to "
"minimize the scope of how long that reference exists. Avoid squirreling the "
"reference away somewhere, or keeping it alive through a large section of "
"code. Keeping it short-lived helps with auditing, and verifying that "
"exclusive access is maintained for the duration. Using pointers should be "
"your default unit, and only convert the pointer to a reference on demand "
"when absolutely required."
msgstr ""

#: src/rust-2024/static-mut-references.md:355
msgid ""
"There is no automatic migration to fix these references to `static mut`. To "
"avoid undefined behavior you must rewrite your code to use a different "
"approach as recommended in the [Alternatives](#alternatives) section."
msgstr ""

#: src/rust-2024/never-type-fallback.md:5
msgid ""
"Never type (`!`) to any type (\"never-to-any\") coercions fall back to never "
"type (`!`) rather than to unit type (`()`)."
msgstr ""

#: src/rust-2024/never-type-fallback.md:6
msgid ""
"The [`never_type_fallback_flowing_into_unsafe`](../../rustc/lints/listing/"
"warn-by-default.html#never-type-fallback-flowing-into-unsafe) lint is now "
"`deny` by default."
msgstr ""

#: src/rust-2024/never-type-fallback.md:12
msgid ""
"When the compiler sees a value of type `!` (never) in a [coercion site]"
"(../../reference/type-coercions.html#coercion-sites), it implicitly inserts "
"a coercion to allow the type checker to infer any type:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:15
#: src/rust-2024/never-type-fallback.md:31
msgid "// This:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:18
msgid "// ...is (essentially) turned by the compiler into:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:21
msgid ""
"// ...where `absurd` is the following function\n"
"// (it's sound because `!` always marks unreachable code):\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:27
msgid "This can lead to compilation errors if the type cannot be inferred:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:34
msgid "// ...gets turned into this:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:36
msgid "//~ ERROR can't infer the type of `absurd`\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:39
msgid ""
"To prevent such errors, the compiler remembers where it inserted `absurd` "
"calls, and if it can't infer the type, it uses the fallback type instead:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:44
msgid "/* An arbitrarily selected type! */"
msgstr ""

#: src/rust-2024/never-type-fallback.md:48
msgid "This is what is known as \"never type fallback\"."
msgstr ""

#: src/rust-2024/never-type-fallback.md:50
msgid ""
"Historically, the fallback type has been `()` (unit).  This caused `!` to "
"spontaneously coerce to `()` even when the compiler would not infer `()` "
"without the fallback.  That was confusing and has prevented the "
"stabilization of the `!` type."
msgstr ""

#: src/rust-2024/never-type-fallback.md:52
msgid ""
"In the 2024 edition, the fallback type is now `!`.  (We plan to make this "
"change across all editions at a later date.)  This makes things work more "
"intuitively.  Now when you pass `!` and there is no reason to coerce it to "
"something else, it is kept as `!`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:54
msgid ""
"In some cases your code might depend on the fallback type being `()`, so "
"this can cause compilation errors or changes in behavior."
msgstr ""

#: src/rust-2024/never-type-fallback.md:58
msgid "`never_type_fallback_flowing_into_unsafe`"
msgstr ""

#: src/rust-2024/never-type-fallback.md:60
msgid ""
"The default level of the [`never_type_fallback_flowing_into_unsafe`](../../"
"rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-"
"unsafe) lint has been raised from `warn` to `deny` in the 2024 Edition. This "
"lint helps detect a particular interaction with the fallback to `!` and "
"`unsafe` code which may lead to undefined behavior. See the link for a "
"complete description."
msgstr ""

#: src/rust-2024/never-type-fallback.md:64
msgid ""
"There is no automatic fix, but there is automatic detection of code that "
"will be broken by the edition change.  While still on a previous edition you "
"will see warnings if your code will be broken."
msgstr ""

#: src/rust-2024/never-type-fallback.md:66
msgid ""
"The fix is to specify the type explicitly so that the fallback type is not "
"used.  Unfortunately, it might not be trivial to see which type needs to be "
"specified."
msgstr ""

#: src/rust-2024/never-type-fallback.md:68
msgid ""
"One of the most common patterns broken by this change is using `f()?;` where "
"`f` is generic over the `Ok`\\-part of the return type:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:82
msgid ""
"You might think that, in this example, type `T` can't be inferred.  However, "
"due to the current desugaring of the `?` operator, it was inferred as `()`, "
"and it will now be inferred as `!`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:84
msgid "To fix the issue you need to specify the `T` type explicitly:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:92
#: src/rust-2024/never-type-fallback.md:148
msgid "// ...or:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:99
msgid "Another relatively common case is panicking in a closure:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:113
msgid ""
"Previously `!` from the `panic!` coerced to `()` which implements `Unit`.  "
"However now the `!` is kept as `!` so this code fails because `!` doesn't "
"implement `Unit`.  To fix this you can specify the return type of the "
"closure:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:126
msgid ""
"A similar case to that of `f()?` can be seen when using a `!`\\-typed "
"expression in one branch and a function with an unconstrained return type in "
"the other:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:137
msgid ""
"Previously `()` was inferred as the return type of `Default::default()` "
"because `!` from `return` was spuriously coerced to `()`.  Now, `!` will be "
"inferred instead causing this code to not compile because `!` does not "
"implement `Default`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:139
msgid "Again, this can be fixed by specifying the type explicitly:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:1
msgid "Macro Fragment Specifiers"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:5
msgid ""
"The `expr` [fragment specifier](../../reference/macros-by-"
"example.html#metavariables) now also supports `const` and `_` expressions."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:6
msgid ""
"The `expr_2021` fragment specifier has been added for backwards "
"compatibility."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:12
msgid ""
"As new syntax is added to Rust, existing `macro_rules` fragment specifiers "
"are sometimes not allowed to match on the new syntax in order to retain "
"backwards compatibility. Supporting the new syntax in the old fragment "
"specifiers is sometimes deferred until the next edition, which provides an "
"opportunity to update them."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:14
msgid ""
"Indeed this happened with [`const` expressions](../../reference/expressions/"
"block-expr.html#const-blocks) added in 1.79 and [`_` expressions](../../"
"reference/expressions/underscore-expr.html) added in 1.59. In the 2021 "
"Edition and earlier, the `expr` fragment specifier does _not_ match those "
"expressions. This is because you may have a scenario like:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:18
msgid "\"first rule\""
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:19
msgid "\"second rule\""
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:27
msgid ""
"Here, in the 2021 Edition, the macro will match the _second_ rule. If "
"earlier editions had changed `expr` to match the newly introduced `const` "
"expressions, then it would match the _first_ rule, which would be a breaking "
"change."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:29
msgid ""
"In the 2024 Edition, `expr` specifiers now also match `const` and `_` "
"expressions. To support the old behavior, the `expr_2021` fragment specifier "
"has been added which does _not_ match the new expressions."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:36
msgid ""
"The [`edition_2024_expr_fragment_specifier`](../../rustc/lints/listing/"
"allowed-by-default.html#edition-2024-expr-fragment-specifier) lint will "
"change all uses of the `expr` specifier to `expr_2021` to ensure that the "
"behavior of existing macros does not change. The lint is part of the "
"`rust-2024-compatibility` lint group which is included in the automatic "
"edition migration. In order to migrate your code to be Rust 2024 Edition "
"compatible, run:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:42
msgid ""
"In _most_ cases, you will likely want to keep the `expr` specifier instead, "
"in order to support the new expressions. You will need to review your macro "
"to determine if there are other rules that would otherwise match with "
"`const` or `_` and determine if there is a conflict. If you want the new "
"behavior, just revert any changes made by the lint."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:44
msgid ""
"Alternatively, you can manually enable the lint to find macros where you may "
"need to update the `expr` specifier."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:5
msgid ""
"The [`missing_fragment_specifier`](../../rustc/lints/listing/deny-by-"
"default.html#missing-fragment-specifier) lint is now a hard error."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:11
msgid ""
"The [`missing_fragment_specifier`](../../rustc/lints/listing/deny-by-"
"default.html#missing-fragment-specifier) lint detects a situation when an "
"**unused** pattern in a `macro_rules!` macro definition has a meta-variable "
"(e.g. `$e`) that is not followed by a fragment specifier (e.g. `:expr`). "
"This is now a hard error in the 2024 Edition."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:16
msgid "// ERROR: missing fragment specifier\n"
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:24
msgid ""
"Calling the macro with arguments that would match a rule with a missing "
"specifier (e.g., `foo!($name)`) is a hard error in all editions. However, "
"simply defining a macro with missing fragment specifiers is not, though we "
"did add a lint in Rust 1.17."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:26
msgid ""
"We'd like to make this a hard error in all editions, but there would be too "
"much breakage right now. So we're starting by making this a hard error in "
"Rust 2024.[^future-incompat]"
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:28
msgid ""
"The lint is marked as a \"future-incompatible\" warning to indicate that it "
"may become a hard error in all editions in a future release. See [\\#40107]"
"(https://github.com/rust-lang/rust/issues/40107) for more information."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:34
msgid ""
"To migrate your code to the 2024 Edition, remove the unused matcher rule "
"from the macro. The [`missing_fragment_specifier`](../../rustc/lints/listing/"
"deny-by-default.html#missing-fragment-specifier) lint is on by default in "
"all editions, and should alert you to macros with this issue."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:36
msgid ""
"There is no automatic migration for this change. We expect that this style "
"of macro is extremely rare. The lint has been a future-incompatibility lint "
"since Rust 1.17, a deny-by-default lint since Rust 1.20, and since Rust "
"1.82, it has warned about dependencies that are using this pattern."
msgstr ""

#: src/rust-2024/gen-keyword.md:5
msgid ""
"`gen` is a [reserved keyword](../../reference/keywords.html#reserved-"
"keywords)."
msgstr ""

#: src/rust-2024/gen-keyword.md:11
msgid ""
"The `gen` keyword has been reserved as part of [RFC #3513](https://rust-"
"lang.github.io/rfcs/3513-gen-blocks.html) to introduce \"gen blocks\" in a "
"future release of Rust. `gen` blocks will provide a way to make it easier to "
"write certain kinds of iterators. Reserving the keyword now will make it "
"easier to stabilize `gen` blocks before the next edition."
msgstr ""

#: src/rust-2024/gen-keyword.md:17
msgid ""
"Introducing the `gen` keyword can cause a problem for any identifiers that "
"are already called `gen`. For example, any variable or function name called "
"`gen` would clash with the new keyword. To overcome this, Rust supports the "
"`r#` prefix for a [raw identifier](../../reference/identifiers.html#raw-"
"identifiers), which allows identifiers to overlap with keywords."
msgstr ""

#: src/rust-2024/gen-keyword.md:19
msgid ""
"The [`keyword_idents_2024`](../../rustc/lints/listing/allowed-by-"
"default.html#keyword-idents-2024) lint will automatically modify any "
"identifier named `gen` to be `r#gen` so that code continues to work on both "
"editions. This lint is part of the `rust-2024-compatibility` lint group, "
"which will automatically be applied when running `cargo fix --edition`. To "
"migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/gen-keyword.md:29 src/rust-2024/gen-keyword.md:41
msgid "\"generating!\""
msgstr ""

#: src/rust-2024/gen-keyword.md:37 src/rust-2024/intoiterator-box-slice.md:67
#: src/rust-2024/newly-unsafe-functions.md:58
msgid "to be:"
msgstr ""

#: src/rust-2024/gen-keyword.md:49
msgid ""
"Alternatively, you can manually enable the lint to find places where `gen` "
"identifiers need to be modified to `r#gen`:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:5
msgid ""
"Unprefixed guarded strings of the form `#\"foo\"#` are reserved for future "
"use."
msgstr ""

#: src/rust-2024/reserved-syntax.md:6
msgid "Two or more `#` characters are reserved for future use."
msgstr ""

#: src/rust-2024/reserved-syntax.md:10
msgid ""
"[RFC 3593](https://rust-lang.github.io/rfcs/3593-unprefixed-guarded-"
"strings.html) reserved syntax in the 2024 Edition for guarded string "
"literals that do not have a prefix to make room for possible future language "
"changes. The 2021 Edition [reserved syntax](../rust-2021/reserved-syntax.md) "
"for guarded strings with a prefix, such as `ident##\"foo\"##`. The 2024 "
"Edition extends that to also reserve strings without the `ident` prefix."
msgstr ""

#: src/rust-2024/reserved-syntax.md:12
msgid "There are two reserved syntaxes:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:14
msgid ""
"One or more `#` characters immediately followed by a [string literal](../../"
"reference/tokens.html#string-literals)."
msgstr ""

#: src/rust-2024/reserved-syntax.md:15
msgid "Two or more `#` characters in a row (not separated by whitespace)."
msgstr ""

#: src/rust-2024/reserved-syntax.md:17
msgid ""
"This reservation is done across an edition boundary because of interactions "
"with tokenization and macros. For example, consider this macro:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:21
msgid "\"one token\""
msgstr ""

#: src/rust-2024/reserved-syntax.md:22
msgid "\"three tokens\""
msgstr ""

#: src/rust-2024/reserved-syntax.md:26
msgid "r#\"foo\"#"
msgstr ""

#: src/rust-2024/reserved-syntax.md:31
msgid "Prior to the 2024 Edition, this produces:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:40
msgid ""
"Starting in the 2024 Edition, the `#\"foo\"#` line and the `###` line now "
"generates a compile error because those forms are now reserved."
msgstr ""

#: src/rust-2024/reserved-syntax.md:48
msgid ""
"The [`rust_2024_guarded_string_incompatible_syntax`](../../rustc/lints/"
"listing/allowed-by-default.html#rust-2024-guarded-string-incompatible-"
"syntax) lint will identify any tokens that match the reserved syntax, and "
"will suggest a modification to insert spaces where necessary to ensure the "
"tokens continue to be parsed separately."
msgstr ""

#: src/rust-2024/reserved-syntax.md:50
msgid ""
"The lint is part of the `rust-2024-compatibility` lint group which is "
"included in the automatic edition migration. In order to migrate your code "
"to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:56
msgid ""
"Alternatively, you can manually enable the lint to find macro calls where "
"you may need to update the tokens:"
msgstr ""

#: src/rust-2024/standard-library.md:3
msgid ""
"The following chapters detail changes to the standard library in the 2024 "
"Edition."
msgstr ""

#: src/rust-2024/prelude.md:5
msgid ""
"The [`Future`](../../std/future/trait.Future.html) and [`IntoFuture`](../../"
"std/future/trait.IntoFuture.html) traits are now part of the prelude."
msgstr ""

#: src/rust-2024/prelude.md:13
msgid ""
"The [prelude of the standard library](../../std/prelude/index.html) is the "
"module containing everything that is automatically imported in every module. "
"It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`."
msgstr ""

#: src/rust-2024/prelude.md:22
msgid ""
"However, adding a _trait_ to the prelude can break existing code in a subtle "
"way. For example, a call to `x.poll()` which comes from a `MyPoller` trait "
"might fail to compile if `std`'s `Future` is also imported, because the call "
"to `poll` is now ambiguous and could come from either trait."
msgstr ""

#: src/rust-2024/prelude.md:25
msgid ""
"As a solution, Rust 2024 will use a new prelude. It's identical to the "
"current one, except for the following changes:"
msgstr ""

#: src/rust-2024/prelude.md:28
msgid "Added:"
msgstr ""

#: src/rust-2024/prelude.md:29
msgid "[`std::future::Future`](../../std/future/trait.Future.html)"
msgstr ""

#: src/rust-2024/prelude.md:30
msgid "[`std::future::IntoFuture`](../../std/future/trait.IntoFuture.html)"
msgstr ""

#: src/rust-2024/prelude.md:40
msgid ""
"// This name is the same as the `poll` method on the `Future` trait from "
"`std`.\n"
msgstr ""

#: src/rust-2024/prelude.md:42
msgid "\"polling\""
msgstr ""

#: src/rust-2024/prelude.md:49
msgid ""
"// Pin<&mut async {}> implements both `std::future::Future` and `MyPoller`.\n"
"    // If both traits are in scope (as would be the case in Rust 2024),\n"
"    // then it becomes ambiguous which `poll` method to call\n"
msgstr ""

#: src/rust-2024/prelude.md:56
msgid ""
"We can fix this so that it works on all editions by using fully qualified "
"syntax:"
msgstr ""

#: src/rust-2024/prelude.md:65
msgid ""
"The [`rust_2024_prelude_collisions`](../../rustc/lints/listing/allowed-by-"
"default.html#rust-2024-prelude-collisions) lint will automatically modify "
"any ambiguous method calls to use fully qualified syntax. This lint is part "
"of the `rust-2024-compatibility` lint group, which will automatically be "
"applied when running `cargo fix --edition`. To migrate your code to be Rust "
"2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/prelude.md:71
msgid ""
"Alternatively, you can manually enable the lint to find places where these "
"qualifications need to be added:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:5
msgid ""
"Boxed slices implement [`IntoIterator`](../../std/iter/"
"trait.IntoIterator.html) in _all_ editions."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:6
msgid ""
"Calls to [`IntoIterator::into_iter`](../../std/iter/"
"trait.IntoIterator.html#tymethod.into_iter) are _hidden_ in editions prior "
"to 2024 when using method call syntax (i.e., `boxed_slice.into_iter()`). So, "
"`boxed_slice.into_iter()` still resolves to `(&(*boxed_slice)).into_iter()` "
"as it has before."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:7
msgid ""
"`boxed_slice.into_iter()` changes meaning to call [`IntoIterator::into_iter`]"
"(../../std/iter/trait.IntoIterator.html#tymethod.into_iter) in Rust 2024."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:14
msgid ""
"Until Rust 1.80, `IntoIterator` was not implemented for boxed slices. In "
"prior versions, if you called `.into_iter()` on a boxed slice, the method "
"call would automatically dereference from `Box<[T]>` to `&[T]`, and return "
"an iterator that yielded references of `&T`. For example, the following "
"worked in prior versions:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:17
msgid "// Example of behavior in previous editions.\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:18
msgid "// Note: .into_iter() was required in versions older than 1.80\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:21
msgid "// x is of type &u32 in editions prior to 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:25
msgid ""
"In Rust 1.80, implementations of `IntoIterator` were added for boxed slices. "
"This allows iterating over elements of the slice by-value instead of by-"
"reference:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:28
msgid "// NEW as of 1.80, all editions\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:30
msgid ""
"// notice no need for calling .into_iter()\n"
"    // x is of type u32\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:35
msgid ""
"This example is allowed on all editions because previously this was an error "
"since `for` loops do not automatically dereference like the `.into_iter()` "
"method call does."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:37
msgid ""
"However, this would normally be a breaking change because existing code that "
"manually called `.into_iter()` on a boxed slice would change from having an "
"iterator over references to an iterator over values. To resolve this "
"problem, method calls of `.into_iter()` on boxed slices have edition-"
"dependent behavior. In editions before 2024, it continues to return an "
"iterator over references, and starting in Edition 2024 it returns an "
"iterator over values."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:40
msgid "// Example of changed behavior in Edition 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:41
msgid "// Example of old code that still manually calls .into_iter()\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:44
msgid "// x is now type u32 in Edition 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:50
msgid ""
"The [`boxed_slice_into_iter`](../../rustc/lints/listing/warn-by-"
"default.html#boxed-slice-into-iter) lint will automatically modify any calls "
"to `.into_iter()` on boxed slices to call `.iter()` instead to retain the "
"old behavior of yielding references. This lint is part of the `rust-2024-"
"compatibility` lint group, which will automatically be applied when running "
"`cargo fix --edition`. To migrate your code to be Rust 2024 Edition "
"compatible, run:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:62
#: src/rust-2024/intoiterator-box-slice.md:73
msgid "// x is of type &u32\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:78
msgid ""
"The [`boxed_slice_into_iter`](../../rustc/lints/listing/warn-by-"
"default.html#boxed-slice-into-iter) lint is defaulted to warn on all "
"editions, so unless you have manually silenced the lint, you should already "
"see it before you migrate."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:1
msgid "Unsafe functions"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:5
msgid ""
"The following functions are now marked [`unsafe`](../../reference/unsafe-"
"keyword.html#unsafe-functions-unsafe-fn):"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:6
msgid "[`std::env::set_var`](../../std/env/fn.set_var.html)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:7
msgid "[`std::env::remove_var`](../../std/env/fn.remove_var.html)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:8
msgid ""
"[`std::os::unix::process::CommandExt::before_exec`](../../std/os/unix/"
"process/trait.CommandExt.html#method.before_exec)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:17
msgid ""
"Over time it has become evident that certain functions in the standard "
"library should have been marked as `unsafe`. However, adding `unsafe` to a "
"function can be a breaking change since it requires existing code to be "
"placed in an `unsafe` block. To avoid the breaking change, these functions "
"are marked as `unsafe` starting in the 2024 Edition, while not requiring "
"`unsafe` in previous editions."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:19
msgid "`std::env::{set_var, remove_var}`"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:21
msgid ""
"It can be unsound to call [`std::env::set_var`](../../std/env/"
"fn.set_var.html) or [`std::env::remove_var`](../../std/env/"
"fn.remove_var.html) in a multi-threaded program due to safety limitations of "
"the way the process environment is handled on some platforms. The standard "
"library originally defined these as safe functions, but it was later "
"determined that was not correct."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:23
msgid ""
"It is important to ensure that these functions are not called when any other "
"thread might be running. See the [Safety](../../std/env/"
"fn.set_var.html#safety) section of the function documentation for more "
"details."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:27
msgid "`std::os::unix::process::CommandExt::before_exec`"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:29
msgid ""
"The [`std::os::unix::process::CommandExt::before_exec`](../../std/os/unix/"
"process/trait.CommandExt.html#method.before_exec) function is a unix-"
"specific function which provides a way to run a closure before calling "
"`exec`. This function was deprecated in the 1.37 release, and replaced with "
"[`pre_exec`](../../std/os/unix/process/"
"trait.CommandExt.html#tymethod.pre_exec) which does the same thing, but is "
"marked as `unsafe`."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:31
msgid ""
"Even though `before_exec` is deprecated, it is now correctly marked as "
"`unsafe` starting in the 2024 Edition. This should help ensure that any "
"legacy code which has not already migrated to `pre_exec` to require an "
"`unsafe` block."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:33
msgid ""
"There are very strict safety requirements for the `before_exec` closure to "
"satisfy. See the [Safety section](../../std/os/unix/process/"
"trait.CommandExt.html#notes-and-safety) for more details."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:40
msgid ""
"To make your code compile in both the 2021 and 2024 editions, you will need "
"to make sure that these functions are called only from within `unsafe` "
"blocks."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:42
msgid ""
"**⚠ Caution**: It is important that you manually inspect the calls to these "
"functions and possibly rewrite your code to satisfy the preconditions of "
"those functions. In particular, `set_var` and `remove_var` should not be "
"called if there might be multiple threads running. You may need to elect to "
"use a different mechanism other than environment variables to manage your "
"use case."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:44
msgid ""
"The [`deprecated_safe_2024`](../../rustc/lints/listing/allowed-by-"
"default.html#deprecated-safe-2024) lint will automatically modify any use of "
"these functions to be wrapped in an `unsafe` block so that it can compile on "
"both editions. This lint is part of the `rust-2024-compatibility` lint "
"group, which will automatically be applied when running `cargo fix --"
"edition`. To migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:54
#: src/rust-2024/newly-unsafe-functions.md:63
msgid "\"FOO\""
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:54
#: src/rust-2024/newly-unsafe-functions.md:63
msgid "\"123\""
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:62
msgid ""
"// TODO: Audit that the environment access only happens in single-threaded "
"code.\n"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:67
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"these functions are being used correctly. It is still your responsibility to "
"manually review their usage."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:69
msgid ""
"Alternatively, you can manually enable the lint to find places these "
"functions are called:"
msgstr ""

#: src/rust-2024/cargo.md:3
msgid "The following chapters detail changes to Cargo in the 2024 Edition."
msgstr ""

#: src/rust-2024/cargo-resolver.md:5
msgid ""
"`edition = \"2024\"` implies `resolver = \"3\"` in `Cargo.toml` which "
"enables a Rust-version aware dependency resolver."
msgstr ""

#: src/rust-2024/cargo-resolver.md:9
msgid ""
"Since Rust 1.84.0, Cargo has opt-in support for compatibility with "
"[`package.rust-version`](../../cargo/reference/rust-version.html) to be "
"considered when selecting dependency versions by setting "
"[`resolver.incompatible-rust-version = \"fallback\"`](../../cargo/reference/"
"config.html#resolverincompatible-rust-versions) in `.cargo/config.toml`."
msgstr ""

#: src/rust-2024/cargo-resolver.md:13
msgid ""
"Starting in Rust 2024, this will be the default. That is, writing `edition = "
"\"2024\"` in `Cargo.toml` will imply `resolver = \"3\"` which will imply "
"[`resolver.incompatible-rust-version = \"fallback\"`](../../cargo/reference/"
"config.html#resolverincompatible-rust-versions)."
msgstr ""

#: src/rust-2024/cargo-resolver.md:22
msgid ""
"For more details on how Rust-version aware dependency resolution works, see "
"[the Cargo book](../../cargo/reference/resolver.html#rust-version)."
msgstr ""

#: src/rust-2024/cargo-resolver.md:32
msgid ""
"There are no automated migration tools for updating for the new resolver."
msgstr ""

#: src/rust-2024/cargo-resolver.md:34
msgid ""
"We recommend projects [verify against the latest dependencies in CI](../../"
"cargo/guide/continuous-integration.html#verifying-latest-dependencies) to "
"catch bugs in dependencies as soon as possible."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:5
msgid ""
"Several table and key names in `Cargo.toml` have been removed where there "
"were previously two ways to specify the same thing."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:6
msgid "Removed `[project]`; use `[package]` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:7
msgid "Removed `default_features`; use `default-features` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:8
msgid "Removed `crate_type`; use `crate-type` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:9
msgid "Removed `proc_macro`; use `proc-macro` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:10
msgid "Removed `dev_dependencies`; use `dev-dependencies` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:11
msgid "Removed `build_dependencies`; use `build-dependencies` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:15
msgid ""
"Several table and keys names are no longer allowed in the 2024 Edition. "
"There were two ways to specify these tables or keys, and this helps ensure "
"there is only one way to specify them."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:18
msgid ""
"Some were due to a change in decisions over time, and some were inadvertent "
"implementation artifacts. In order to avoid confusion, and to enforce a "
"single style for specifying these tables and keys, only one variant is now "
"allowed."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:23
msgid ""
"```toml\n"
"[dev_dependencies]\n"
"rand = { version = \"0.8.5\", default_features = false }\n"
"```"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:28
msgid "Should be changed to:"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:30
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"rand = { version = \"0.8.5\", default-features = false }\n"
"```"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:35
msgid ""
"Notice that the underscores were changed to dashes for `dev_dependencies` "
"and `default_features`."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:39
msgid ""
"When using `cargo fix --edition`, Cargo will automatically update your "
"`Cargo.toml` file to use the preferred table and key names."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:41
msgid ""
"If you would prefer to update your `Cargo.toml` manually, be sure to go "
"through the list above and make sure only the new forms are used."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:5
msgid ""
"`default-features = false` is no longer allowed in an inherited workspace "
"dependency if the workspace dependency specifies `default-features = true` "
"(or does not specify `default-features`)."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:9
msgid ""
"[Workspace inheritance](../../cargo/reference/specifying-"
"dependencies.html#inheriting-a-dependency-from-a-workspace) allows you to "
"specify dependencies in one place (the workspace), and then to refer to "
"those workspace dependencies from within a package. There was an inadvertent "
"interaction with how `default-features` is specified that is no longer "
"allowed in the 2024 Edition."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:12
msgid ""
"Unless the workspace specifies `default-features = false`, it is no longer "
"allowed to specify `default-features = false` in an inherited package "
"dependency. For example, with a workspace that specifies:"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:15
msgid ""
"```toml\n"
"[workspace.dependencies]\n"
"regex = \"1.10.4\"\n"
"```"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:20
msgid "The following is now an error:"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:22
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"1.0.0\"\n"
"edition = \"2024\"\n"
"\n"
"[dependencies]\n"
"regex = { workspace = true, default-features = false }  # ERROR\n"
"```"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:32
msgid ""
"The reason for this change is to avoid confusion when specifying `default-"
"features = false` when the default feature is already enabled, since it has "
"no effect."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:34
msgid ""
"If you want the flexibility of deciding whether or not a dependency enables "
"the default-features of a dependency, be sure to set `default-features = "
"false` in the workspace definition. Just beware that if you build multiple "
"workspace members at the same time, the features will be unified so that if "
"one member sets `default-features = true` (which is the default if not "
"explicitly set), the default-features will be enabled for all members using "
"that dependency."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:39
msgid ""
"When using `cargo fix --edition`, Cargo will automatically update your "
"`Cargo.toml` file to remove `default-features = false` in this situation."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:41
msgid ""
"If you would prefer to update your `Cargo.toml` manually, check for any "
"warnings when running a build and remove the corresponding entries. Previous "
"editions should display something like:"
msgstr ""

#: src/rust-2024/rustdoc.md:3
msgid "The following chapters detail changes to Rustdoc in the 2024 Edition."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:5
msgid ""
"[Doctests](../../rustdoc/write-documentation/documentation-tests.html) are "
"now combined into a single binary which should result in a significant "
"performance improvement."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:9
msgid ""
"Prior the the 2024 Edition, rustdoc's \"test\" mode would compile each code "
"block in your documentation as a separate executable. Although this was "
"relatively simple to implement, it resulted in a significant performance "
"burden when there were a large number of documentation tests. Starting with "
"the 2024 Edition, rustdoc will attempt to combine documentation tests into a "
"single binary, significantly reducing the overhead for compiling doctests."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:12
msgid ""
"/// Adds two numbers\n"
"///\n"
"/// ```\n"
"/// assert_eq!(add(1, 1), 2);\n"
"/// ```\n"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:20
msgid ""
"/// Subtracts two numbers\n"
"///\n"
"/// ```\n"
"/// assert_eq!(subtract(2, 1), 1);\n"
"/// ```\n"
msgstr "/// 두 숫자를 뺍니다\n///\n/// ```\n/// assert_eq!(subtract(2, 1), 1);\n/// ```\n"

#: src/rust-2024/rustdoc-doctests.md:31
msgid ""
"In this example, the two doctests will now be compiled into a single "
"executable. Rustdoc will essentially place each example in a separate "
"function within a single binary. The tests still run in independent "
"processes as they did before, so any global state (like global statics) "
"should still continue to work correctly.[^implementation]"
msgstr "이 예제에서는 두 개의 doctest가 이제 단일 실행 파일로 컴파일됩니다. Rustdoc은 본질적으로 각 예제를 단일 바이너리 내의 별도 함수에 배치합니다. 테스트는 이전과 마찬가지로 독립적인 프로세스에서 계속 실행되므로 전역 상태(전역 정적과 같은)는 여전히 올바르게 작동해야 합니다.[^implementation]"

#: src/rust-2024/rustdoc-doctests.md:33
msgid ""
"This change is only available in the 2024 Edition to avoid potential "
"incompatibilities with existing doctests which may not work in a combined "
"executable. However, these incompatibilities are expected to be extremely "
"rare."
msgstr "이 변경 사항은 결합된 실행 파일에서 작동하지 않을 수 있는 기존 doctest와의 잠재적인 비호환성을 피하기 위해 2024 에디션에서만 사용할 수 있습니다. 그러나 이러한 비호환성은 극히 드물 것으로 예상됩니다."

#: src/rust-2024/rustdoc-doctests.md:38
msgid ""
"For more information on the details of how this work, see [\"Doctests - How "
"were they improved?\"](https://blog.guillaume-gomez.fr/articles/"
"2024-08-17+Doctests+-+How+were+they+improved%3F)."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:40
msgid "`standalone_crate` tag"
msgstr "`standalone_crate` 태그"

#: src/rust-2024/rustdoc-doctests.md:42
msgid ""
"In some situations it is not possible for rustdoc to combine examples into a "
"single executable. Rustdoc will attempt to automatically detect if this is "
"not possible. For example, a test will not be combined with others if it:"
msgstr "어떤 상황에서는 rustdoc이 예제를 단일 실행 파일로 결합할 수 없습니다. rustdoc은 이것이 불가능한지 자동으로 감지하려고 시도합니다. 예를 들어, 테스트는 다음과 같은 경우 다른 테스트와 결합되지 않습니다."

#: src/rust-2024/rustdoc-doctests.md:44
msgid ""
"Uses the [`compile_fail`](../../rustdoc/write-documentation/documentation-"
"tests.html#attributes) tag, which indicates that the example should fail to "
"compile."
msgstr "[`compile_fail`](../../rustdoc/write-documentation/documentation-tests.html#attributes) 태그를 사용합니다. 이 태그는 예제가 컴파일에 실패해야 함을 나타냅니다."

#: src/rust-2024/rustdoc-doctests.md:45
msgid ""
"Uses an [`edition`](../../rustdoc/write-documentation/documentation-"
"tests.html#attributes) tag, which indicates the edition of the example."
"[^edition-tag]"
msgstr "예제의 에디션을 나타내는 [`edition`](../../rustdoc/write-documentation/documentation-tests.html#attributes) 태그를 사용합니다.[^edition-tag]"

#: src/rust-2024/rustdoc-doctests.md:46
msgid ""
"Uses global attributes, like the [`global_allocator`](../../std/alloc/"
"trait.GlobalAlloc.html) attribute, which could potentially interfere with "
"other tests."
msgstr "다른 테스트와 잠재적으로 충돌할 수 있는 [`global_allocator`](../../std/alloc/trait.GlobalAlloc.html) 속성과 같은 전역 속성을 사용합니다."

#: src/rust-2024/rustdoc-doctests.md:47
msgid "Defines any crate-wide attributes (like `#![feature(...)]`)."
msgstr "크레이트 전체 속성(예: `#![feature(...)]`)을 정의합니다."

#: src/rust-2024/rustdoc-doctests.md:48
msgid ""
"Defines a macro that uses `$crate`, because the `$crate` path will not work "
"correctly."
msgstr "`$crate` 경로가 올바르게 작동하지 않으므로 `$crate`를 사용하는 매크로를 정의합니다."

#: src/rust-2024/rustdoc-doctests.md:50
msgid ""
"However, rustdoc is not able to automatically determine _all_ situations "
"where an example cannot be combined with other examples. In these "
"situations, you can add the `standalone_crate` language tag to indicate that "
"the example should be built as a separate executable. For example:"
msgstr "그러나 rustdoc은 예제를 다른 예제와 결합할 수 없는 _모든_ 상황을 자동으로 결정할 수 없습니다. 이러한 상황에서는 `standalone_crate` 언어 태그를 추가하여 예제가 별도의 실행 파일로 빌드되어야 함을 나타낼 수 있습니다. 예를 들어:"

#: src/rust-2024/rustdoc-doctests.md:53
msgid ""
"//! ```\n"
"//! let location = std::panic::Location::caller();\n"
"//! assert_eq!(location.line(), 5);\n"
"//! ```\n"
msgstr "//! ```\n//! let location = std::panic::Location::caller();\n//! assert_eq!(location.line(), 5);\n//! ```\n"

#: src/rust-2024/rustdoc-doctests.md:59
msgid ""
"This is sensitive to the code structure of how the example is compiled and "
"won't work with the \"combined\" approach because the line numbers will "
"shift depending on how the doctests are combined. In these situations, you "
"can add the `standalone_crate` tag to force the example to be built "
"separately just as it was in previous editions. E.g.:"
msgstr "이것은 예제가 컴파일되는 코드 구조에 민감하며, doctest가 결합되는 방식에 따라 줄 번호가 변경되므로 \"결합된\" 접근 방식으로는 작동하지 않습니다. 이러한 상황에서는 `standalone_crate` 태그를 추가하여 이전 에디션과 마찬가지로 예제가 별도로 빌드되도록 강제할 수 있습니다. 예:"

#: src/rust-2024/rustdoc-doctests.md:62
msgid ""
"//! ```standalone_crate\n"
"//! let location = std::panic::Location::caller();\n"
"//! assert_eq!(location.line(), 5);\n"
"//! ```\n"
msgstr "//! ```standalone_crate\n//! let location = std::panic::Location::caller();\n//! assert_eq!(location.line(), 5);\n//! ```\n"

#: src/rust-2024/rustdoc-doctests.md:71
msgid ""
"Note that rustdoc will only combine tests if the entire crate is Edition "
"2024 or greater. Using the `edition2024` tag in older editions will not "
"result in those tests being combined."
msgstr "rustdoc은 전체 크레이트가 2024 에디션 이상인 경우에만 테스트를 결합합니다. 이전 에디션에서 `edition2024` 태그를 사용해도 해당 테스트가 결합되지 않습니다."

#: src/rust-2024/rustdoc-doctests.md:75
msgid ""
"There is no automatic migration to determine which doctests need to be "
"annotated with the `standalone_crate` tag. It's very unlikely that any given "
"doctest will not work correctly when migrated. We suggest that you update "
"your crate to the 2024 Edition and then run your documentation tests and see "
"if any fail. If one does, you will need to analyze whether it can be "
"rewritten to be compatible with the combined approach, or alternatively, add "
"the `standalone_crate` tag to retain the previous behavior."
msgstr "`standalone_crate` 태그로 주석을 달아야 하는 doctest를 결정하는 자동 마이그레이션은 없습니다. 마이그레이션할 때 주어진 doctest가 올바르게 작동하지 않을 가능성은 매우 낮습니다. 크레이트를 2024 에디션으로 업데이트한 다음 문서 테스트를 실행하여 실패하는 것이 있는지 확인하는 것이 좋습니다. 실패하는 것이 있다면 결합된 접근 방식과 호환되도록 다시 작성할 수 있는지 분석하거나, 또는 이전 동작을 유지하기 위해 `standalone_crate` 태그를 추가해야 합니다."

#: src/rust-2024/rustdoc-doctests.md:77
msgid "Some things to watch out for and avoid are:"
msgstr "주의하고 피해야 할 몇 가지 사항은 다음과 같습니다."

#: src/rust-2024/rustdoc-doctests.md:79
msgid ""
"Checking the values of [`std::panic::Location`](https://doc.rust-lang.org/"
"std/panic/struct.Location.html) or things that make use of `Location`. The "
"location of the code is now different since multiple tests are now located "
"in the same test crate."
msgstr "[`std::panic::Location`](https://doc.rust-lang.org/std/panic/struct.Location.html)의 값 또는 `Location`을 사용하는 것들을 확인합니다. 여러 테스트가 이제 동일한 테스트 크레이트에 위치하므로 코드의 위치가 달라졌습니다."

#: src/rust-2024/rustdoc-doctests.md:80
msgid ""
"Checking the value of [`std::any::type_name`](https://doc.rust-lang.org/std/"
"any/fn.type_name.html), which now has a different module path."
msgstr "이제 다른 모듈 경로를 갖는 [`std::any::type_name`](https://doc.rust-lang.org/std/any/fn.type_name.html)의 값을 확인합니다."

#: src/rust-2024/rustdoc-nested-includes.md:5
msgid ""
"When a doctest is included with `include_str!`, if that doctest itself also "
"uses `include!`, `include_str!`, or `include_bytes!`, the path is resolved "
"relative to the Markdown file, rather than to the Rust source file."
msgstr "`include_str!`로 doctest가 포함될 때, 해당 doctest 자체도 `include!`, `include_str!`, 또는 `include_bytes!`를 사용하는 경우 경로는 Rust 소스 파일이 아닌 Markdown 파일에 상대적으로 해결됩니다."

#: src/rust-2024/rustdoc-nested-includes.md:9
msgid ""
"Prior to the 2024 edition, adding documentation with `#[doc=include_str!"
"(\"path/file.md\")]` didn't carry span information into any doctests in that "
"file. As a result, if the Markdown file was in a different directory than "
"the source, any paths included had to be specified relative to the source "
"file."
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:11
msgid "For example, consider a library crate with these files:"
msgstr "예를 들어, 다음과 같은 파일이 있는 라이브러리 크레이트를 고려해 보십시오."

#: src/rust-2024/rustdoc-nested-includes.md:13
msgid "`Cargo.toml`"
msgstr "`Cargo.toml`"

#: src/rust-2024/rustdoc-nested-includes.md:14
msgid "`README.md`"
msgstr "`README.md`"

#: src/rust-2024/rustdoc-nested-includes.md:15
msgid "`src/`"
msgstr "`src/`"

#: src/rust-2024/rustdoc-nested-includes.md:16
msgid "`lib.rs`"
msgstr "`lib.rs`"

#: src/rust-2024/rustdoc-nested-includes.md:17
msgid "`examples/`"
msgstr "`examples/`"

#: src/rust-2024/rustdoc-nested-includes.md:18
msgid "`data.bin`"
msgstr "`data.bin`"

#: src/rust-2024/rustdoc-nested-includes.md:20
msgid "Let's say that `lib.rs` contains this:"
msgstr "`lib.rs`에 다음이 포함되어 있다고 가정해 보겠습니다."

#: src/rust-2024/rustdoc-nested-includes.md:23
msgid \"../README.md\"\nmsgstr \"../README.md\"

#: src/rust-2024/rustdoc-nested-includes.md:26
msgid "And assume this `README.md` file:"
msgstr "그리고 이 `README.md` 파일을 가정해 보겠습니다."

#: src/rust-2024/rustdoc-nested-includes.md:35
msgid ""
"Prior to the 2024 edition, the path in `README.md` needed to be relative to "
"the `lib.rs` file. In 2024 and later, it is now relative to `README.md` "
"itself, so we would update `README.md` to:"
msgstr "2024 에디션 이전에는 `README.md`의 경로가 `lib.rs` 파일에 상대적이어야 했습니다. 2024년 이후에는 `README.md` 자체에 상대적이므로 `README.md`를 다음과 같이 업데이트합니다."

#: src/rust-2024/rustdoc-nested-includes.md:45
msgid ""
"There is no automatic migration to convert the paths in affected doctests. "
"If one of your doctests is affected, you'll see an error like this after "
"migrating to the new edition when building your tests:"
msgstr "영향을 받는 doctest의 경로를 변환하는 자동 마이그레이션은 없습니다. doctest 중 하나가 영향을 받는 경우 새 에디션으로 마이그레이션한 후 테스트를 빌드할 때 다음과 같은 오류가 표시됩니다."

#: src/rust-2024/rustdoc-nested-includes.md:47
msgid ""
"````````````````````text\n"
"error: couldn't read `../examples/data.bin`: No such file or directory (os "
"error 2)\n"
" --> src/../README.md:2:24\n"
"  |\n"
"2 | let _ = include_bytes!(\"../examples/data.bin\");\n"
"  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  = note: this error originates in the macro `include_bytes` (in Nightly "
"builds, run with -Z macro-backtrace for more info)\n"
"help: there is a file with the same name in a different directory\n"
"  |\n"
"2 | let _ = include_bytes!(\"examples/data.bin\");\n"
"  |                        ~~~~~~~~~~~~~~~~~~~\n"
"````````````````````"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:60
msgid ""
"To migrate your doctests to Rust 2024, update any affected paths to be "
"relative to the file containing the doctests."
msgstr "doctest를 Rust 2024로 마이그레이션하려면 영향을 받는 모든 경로를 doctest를 포함하는 파일에 상대적으로 업데이트하십시오."

#: src/rust-2024/rustfmt.md:3
msgid "The following chapters detail changes to Rustfmt in the 2024 Edition."
msgstr "다음 장에서는 2024 에디션의 Rustfmt 변경 사항을 자세히 설명합니다."

#: src/rust-2024/rustfmt-style-edition.md:5
msgid "User can now control which style edition to use with `rustfmt`."
msgstr "이제 사용자는 `rustfmt`와 함께 사용할 스타일 에디션을 제어할 수 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:9
msgid ""
"The default formatting produced by Rustfmt is governed by the rules in the "
"[Rust Style Guide](../../style-guide/index.html)."
msgstr "Rustfmt가 생성하는 기본 형식은 [Rust 스타일 가이드](../../style-guide/index.html)의 규칙에 따라 결정됩니다."

#: src/rust-2024/rustfmt-style-edition.md:12
msgid ""
"Additionally, Rustfmt has a formatting stability guarantee that aims to "
"avoid causing noisy formatting churn for users when updating a Rust "
"toolchain. This stability guarantee essentially means that a newer version "
"of Rustfmt cannot modify the _successfully formatted_ output that was "
"produced by a previous version of Rustfmt."
msgstr "또한 Rustfmt는 Rust 툴체인을 업데이트할 때 사용자에게 시끄러운 형식 변경을 유발하지 않도록 하는 형식 안정성 보장을 제공합니다. 이 안정성 보장은 본질적으로 최신 버전의 Rustfmt가 이전 버전의 Rustfmt가 생성한 _성공적으로 형식화된_ 출력을 수정할 수 없음을 의미합니다."

#: src/rust-2024/rustfmt-style-edition.md:18
msgid ""
"The combination of those two constraints had historically locked both the "
"Style Guide and the default formatting behavior in Rustfmt. This impasse "
"caused various challenges, such as preventing the ability to iterate on "
"style improvements, and requiring Rustfmt to maintain legacy formatting "
"quirks that were obviated long ago (e.g. nested tuple access)."
msgstr "이 두 가지 제약 조건의 조합은 역사적으로 스타일 가이드와 Rustfmt의 기본 형식 지정 동작을 모두 고정시켰습니다. 이러한 교착 상태는 스타일 개선을 반복할 수 없게 하고, Rustfmt가 오래 전에 폐기된 레거시 형식 지정 특성(예: 중첩 튜플 액세스)을 유지하도록 요구하는 등 다양한 문제를 야기했습니다."

#: src/rust-2024/rustfmt-style-edition.md:24
msgid ""
"[RFC 3338](https://rust-lang.github.io/rfcs/3338-style-evolution.html) "
"resolved this impasse by establishing a mechanism for the Rust Style Guide "
"to be aligned to Rust's Edition model wherein the Style Guide could evolve "
"across Editions, and `rustfmt` would allow users to specify their desired "
"Edition of the Style Guide, referred to as the Style Edition."
msgstr "[RFC 3338](https://rust-lang.github.io/rfcs/3338-style-evolution.html)은 Rust 스타일 가이드가 에디션 전반에 걸쳐 발전할 수 있도록 Rust의 에디션 모델에 맞춰 정렬되는 메커니즘을 구축하여 이 교착 상태를 해결했으며, `rustfmt`는 사용자가 원하는 스타일 가이드 에디션(스타일 에디션이라고 함)을 지정할 수 있도록 했습니다."

#: src/rust-2024/rustfmt-style-edition.md:29
msgid ""
"In the 2024 Edition, `rustfmt` now supports the ability for users to control "
"the Style Edition used for formatting. The 2024 Edition of the Style Guide "
"also includes enhancements to the Style Guide which are detailed elsewhere "
"in this Edition Guide."
msgstr "2024 에디션에서 `rustfmt`는 이제 사용자가 형식 지정에 사용되는 스타일 에디션을 제어할 수 있는 기능을 지원합니다. 2024 에디션의 스타일 가이드에는 이 에디션 가이드의 다른 곳에 자세히 설명된 스타일 가이드 개선 사항도 포함되어 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:33
msgid ""
"By default `rustfmt` will use the same Style Edition as the standard Rust "
"Edition used for parsing, but the Style Edition can also be overridden and "
"configured separately."
msgstr "기본적으로 `rustfmt`는 구문 분석에 사용되는 표준 Rust 에디션과 동일한 스타일 에디션을 사용하지만, 스타일 에디션은 재정의하고 별도로 구성할 수도 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:36
msgid "There are multiple ways to run `rustfmt` with the 2024 Style Edition:"
msgstr "2024 스타일 에디션으로 `rustfmt`를 실행하는 방법은 여러 가지가 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:38
msgid "With a `Cargo.toml` file that has `edition` set to `2024`, run:"
msgstr "`edition`이 `2024`로 설정된 `Cargo.toml` 파일로 다음을 실행하십시오."

#: src/rust-2024/rustfmt-style-edition.md:44
msgid ""
"Or run `rustfmt` directly with `2024` for the edition to use the 2024 "
"edition for both parsing and the 2024 edition of the Style Guide:"
msgstr "또는 `rustfmt`를 에디션 `2024`로 직접 실행하여 구문 분석과 스타일 가이드의 2024 에디션 모두에 2024 에디션을 사용하십시오."

#: src/rust-2024/rustfmt-style-edition.md:51
msgid ""
"The style edition can also be set in a `rustfmt.toml` configuration file:"
msgstr "스타일 에디션은 `rustfmt.toml` 구성 파일에서도 설정할 수 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:52
msgid ""
"```toml\n"
"style_edition = \"2024\"\n"
"```"
msgstr "```toml\nstyle_edition = \"2024\"\n```"

#: src/rust-2024/rustfmt-style-edition.md:56
msgid "Which is then used when running `rustfmt` directly:"
msgstr "그런 다음 `rustfmt`를 직접 실행할 때 사용됩니다."

#: src/rust-2024/rustfmt-style-edition.md:61
msgid ""
"Alternatively, the style edition can be specified directly from `rustfmt` "
"options:"
msgstr "또는 `rustfmt` 옵션에서 직접 스타일 에디션을 지정할 수 있습니다."

#: src/rust-2024/rustfmt-style-edition.md:72
msgid ""
"Running `cargo fmt` or `rustfmt` with the 2024 edition or style edition will "
"automatically migrate formatting over to the 2024 style edition formatting."
msgstr "2024 에디션 또는 스타일 에디션으로 `cargo fmt` 또는 `rustfmt`를 실행하면 형식이 2024 스타일 에디션 형식으로 자동 마이그레이션됩니다."

#: src/rust-2024/rustfmt-style-edition.md:75
msgid ""
"Projects who have contributors that may utilize their editor's format-on-"
"save features are also strongly encouraged to add a `.rustfmt.toml` file to "
"their project that includes the corresponding `style_edition` utilized "
"within their project, or to encourage their users to ensure their local "
"editor format-on-save feature is configured to use that same `style_edition`."
msgstr "편집기의 저장 시 형식 지정 기능을 활용할 수 있는 기여자가 있는 프로젝트는 해당 프로젝트 내에서 사용되는 해당 `style_edition`을 포함하는 `.rustfmt.toml` 파일을 프로젝트에 추가하거나, 사용자가 로컬 편집기의 저장 시 형식 지정 기능이 동일한 `style_edition`을 사용하도록 구성되었는지 확인하도록 권장합니다."

#: src/rust-2024/rustfmt-style-edition.md:81
msgid ""
"This is to ensure that the editor format-on-save output is consistent with "
"the output when `cargo fmt` is manually executed by the developer, or the "
"project's CI process (many editors will run `rustfmt` directly which by "
"default uses the 2015 edition, whereas `cargo fmt` uses the edition "
"specified in the `Cargo.toml` file)"
msgstr "이는 편집기의 저장 시 형식 지정 출력이 개발자가 수동으로 `cargo fmt`를 실행하거나 프로젝트의 CI 프로세스(많은 편집기는 기본적으로 2015 에디션을 사용하는 `rustfmt`를 직접 실행하는 반면, `cargo fmt`는 `Cargo.toml` 파일에 지정된 에디션을 사용함)의 출력과 일치하도록 보장하기 위함입니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:5
msgid "Fixes to various formatting scenarios."
msgstr "다양한 형식 지정 시나리오에 대한 수정 사항."

#: src/rust-2024/rustfmt-formatting-fixes.md:9
msgid ""
"The 2024 style edition introduces several fixes to various formatting "
"scenarios."
msgstr "2024 스타일 에디션은 다양한 형식 지정 시나리오에 대한 여러 수정 사항을 도입합니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:11
msgid ""
"Don't align unrelated trailing comments after items or at the end of blocks"
msgstr "항목 뒤 또는 블록 끝에 관련 없는 후행 주석을 정렬하지 마십시오."

#: src/rust-2024/rustfmt-formatting-fixes.md:17
msgid ""
"Previously rustfmt would assume that a comment on a line following an item "
"with a trailing comment should be indented to match the trailing comment. "
"This has been changed so that those comments are not indented."
msgstr "이전에는 rustfmt가 후행 주석이 있는 항목 뒤의 줄에 있는 주석이 후행 주석과 일치하도록 들여쓰기되어야 한다고 가정했습니다. 이것은 해당 주석이 들여쓰기되지 않도록 변경되었습니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:19
#: src/rust-2024/rustfmt-formatting-fixes.md:94
#: src/rust-2024/rustfmt-formatting-fixes.md:120
#: src/rust-2024/rustfmt-formatting-fixes.md:160
#: src/rust-2024/rustfmt-formatting-fixes.md:198
#: src/rust-2024/rustfmt-formatting-fixes.md:238
#: src/rust-2024/rustfmt-formatting-fixes.md:263
#: src/rust-2024/rustfmt-formatting-fixes.md:297
#: src/rust-2024/rustfmt-formatting-fixes.md:328
#: src/rust-2024/rustfmt-formatting-fixes.md:366
#: src/rust-2024/rustfmt-formatting-fixes.md:412
#: src/rust-2024/rustfmt-formatting-fixes.md:442
#: src/rust-2024/rustfmt-formatting-fixes.md:473
#: src/rust-2024/rustfmt-formatting-fixes.md:519
#: src/rust-2024/rustfmt-formatting-fixes.md:550
#: src/rust-2024/rustfmt-formatting-fixes.md:580
#: src/rust-2024/rustfmt-formatting-fixes.md:616
msgid "**Style edition 2021:**"
msgstr "**스타일 에디션 2021:**"

#: src/rust-2024/rustfmt-formatting-fixes.md:22
msgid ""
"// Supports multicast\n"
"                                                 // Multicast using "
"broadcst. add.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:25
#: src/rust-2024/rustfmt-formatting-fixes.md:50
msgid "// CREATE TABLE\n"
msgstr "// 테이블 생성\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:26
#: src/rust-2024/rustfmt-formatting-fixes.md:51
msgid "// DROP TABLE\n"
msgstr "// 테이블 삭제\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:27
msgid ""
"// CREATE INDEX\n"
"                                   //const SQ_DRPIDX: u16 = 0x0011; // DROP "
"INDEX\n"
"                                   //const SQ_GRANT: u16 = 0x0012;  // "
"GRANT\n"
"                                   //const SQ_REVOKE: u16 = 0x0013; // "
"REVOKE\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:33
msgid ""
"// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id "
"nulla. Lorem.\n"
"                   // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor "
"orci, sagittis\n"
"                   // malesuada, rhoncus quis, hendrerit eget, libero. "
"Quisque commodo nulla at\n"
msgstr "// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id nulla. Lorem.\n// Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, sagittis\n// malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo nulla at\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:38
msgid ""
"// [-1.0, 1.0]\n"
"                                                                   // "
"TODO(emilio): It may make sense to make this range [.01, 10.0], to align\n"
"                                                                   // with "
"css-fonts-4's range of [1, 1000].\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:44
#: src/rust-2024/rustfmt-formatting-fixes.md:107
#: src/rust-2024/rustfmt-formatting-fixes.md:133
#: src/rust-2024/rustfmt-formatting-fixes.md:175
#: src/rust-2024/rustfmt-formatting-fixes.md:213
#: src/rust-2024/rustfmt-formatting-fixes.md:246
#: src/rust-2024/rustfmt-formatting-fixes.md:276
#: src/rust-2024/rustfmt-formatting-fixes.md:306
#: src/rust-2024/rustfmt-formatting-fixes.md:346
#: src/rust-2024/rustfmt-formatting-fixes.md:384
#: src/rust-2024/rustfmt-formatting-fixes.md:422
#: src/rust-2024/rustfmt-formatting-fixes.md:454
#: src/rust-2024/rustfmt-formatting-fixes.md:488
#: src/rust-2024/rustfmt-formatting-fixes.md:531
#: src/rust-2024/rustfmt-formatting-fixes.md:560
#: src/rust-2024/rustfmt-formatting-fixes.md:594
#: src/rust-2024/rustfmt-formatting-fixes.md:628
msgid "**Style edition 2024:**"
msgstr "**스타일 에디션 2024:**"

#: src/rust-2024/rustfmt-formatting-fixes.md:47
msgid ""
"// Supports multicast\\n"
"// Multicast using broadcst. add.\\n"
msgstr "// 멀티캐스트 지원\\n// broadcst. add를 사용한 멀티캐스트.\\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:52
msgid ""
"// CREATE INDEX\n"
"//const SQ_DRPIDX: u16 = 0x0011; // DROP INDEX\n"
"//const SQ_GRANT: u16 = 0x0012;  // GRANT\n"
"//const SQ_REVOKE: u16 = 0x0013; // REVOKE\n"
msgstr "// 인덱스 생성\n//const SQ_DRPIDX: u16 = 0x0011; // 인덱스 삭제\n//const SQ_GRANT: u16 = 0x0012; // 권한 부여\n//const SQ_REVOKE: u16 = 0x0013; // 권한 취소\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:58
msgid ""
"// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id "
"nulla. Lorem.\n"
"    // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, "
"sagittis\n"
"    // malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo "
"nulla at\n"
msgstr "// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id nulla. Lorem.\n// Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, sagittis\n// malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo nulla at\n"

#: src/rust-2024/rustfmt-formatting-fixes.md:63
msgid ""
"// [-1.0, 1.0]\n"
"    // TODO(emilio): It may make sense to make this range [.01, 10.0], to "
"align\n"
"    // with css-fonts-4's range of [1, 1000].\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:69
msgid "Don't indent strings in comments"
msgstr "주석의 문자열을 들여쓰기하지 마십시오."

#: src/rust-2024/rustfmt-formatting-fixes.md:79
msgid ""
"Previously rustfmt would incorrectly attempt to format strings in comments."
msgstr "이전에는 rustfmt가 주석의 문자열을 잘못 형식화하려고 시도했습니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:81
#: src/rust-2024/rustfmt-formatting-fixes.md:508
msgid "**Original:**"
msgstr "**원본:**"

#: src/rust-2024/rustfmt-formatting-fixes.md:85
msgid ""
"/*   let s = String::from(\n"
"        \"\n"
"hello\n"
"world\n"
"\",\n"
"    ); */"
msgstr "/*   let s = String::from(\n        \"\nhello\nworld\n\",\n    ); */"

#: src/rust-2024/rustfmt-formatting-fixes.md:98
msgid ""
"/*   let s = String::from(\n"
"            \"\n"
"    hello\n"
"    world\n"
"    \",\n"
"        ); */"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:109
msgid "No change from original."
msgstr "원본과 동일합니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:111
msgid "Long strings don't prevent formatting expressions"
msgstr "긴 문자열은 표현식 형식 지정을 방해하지 않습니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:118
msgid ""
"In some situations, long strings would previously prevent the expression "
"from being formatted."
msgstr "일부 상황에서는 긴 문자열이 이전에 표현식의 형식 지정을 방해했습니다."

#: src/rust-2024/rustfmt-formatting-fixes.md:124
#: src/rust-2024/rustfmt-formatting-fixes.md:138
msgid ""
"\"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia "
"deserunt mollit anim id est laborum.\""
msgstr "\"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\""

#: src/rust-2024/rustfmt-formatting-fixes.md:127
#: src/rust-2024/rustfmt-formatting-fixes.md:146
msgid "\"long_long_long_long_long_long_long_lo_long_long_long_long_long_long__long_long_long_long_long_long_\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:128
#: src/rust-2024/rustfmt-formatting-fixes.md:147
msgid "\"long_long_long_long_long_long_long_long_long_long_lo_long_long_lolong_long_long_lo_long_long_lolong_long_long_lo_long_long_lo\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:152
msgid "Fixed indentation of generics in impl blocks"
msgstr "impl 블록에서 제네릭의 들여쓰기 수정"

#: src/rust-2024/rustfmt-formatting-fixes.md:158
msgid "Generics in `impl` items had excessive indentation."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:190
msgid "Use correct indentation when formatting a complex `fn`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:196
msgid ""
"In some cases, a complex `fn` signature could end up with an unusual "
"indentation that is now fixed."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:230
msgid "Avoid extra space in nested tuple indexing expression"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:236
msgid ""
"Nested tuple indexing expressions would incorrectly include an extra space."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:254
msgid "End return/break/continue inside a block in a match with a semicolon"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:261
msgid ""
"A `return`, `break`, or `continue` inside a block in a match arm was "
"incorrectly missing a semicolon."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:271
#: src/rust-2024/rustfmt-formatting-fixes.md:284
msgid "\"\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:289
msgid "Long array and slice patterns are now wrapped"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:295
msgid "Long array and slice patterns were not getting wrapped properly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:319
msgid "Format the last expression-statement as an expression"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:326
msgid ""
"The last statement in a block which is an expression is now formatted as an "
"expression."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:358
msgid "Same formatting between function and macro calls"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:364
msgid ""
"Some formatting is now the same in a macro invocation as it is in a function "
"call."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:404
msgid "Force block closures for closures with a single loop body"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:410
msgid "Closures with a single loop are now formatted as a block expression."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:417
#: src/rust-2024/rustfmt-formatting-fixes.md:428
msgid "\"iteration\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:434
msgid "Empty lines in where clauses are now removed"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:440
msgid "Empty lines in a `where` clause are now removed."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:465
msgid "Fixed formatting of a let-else statement with an attribute"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:471
msgid ""
"If a let-else statement had an attribute, then it would cause the `else` "
"clause to incorrectly wrap the `else` part separately."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:477
#: src/rust-2024/rustfmt-formatting-fixes.md:492
msgid "\"linux\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:483
#: src/rust-2024/rustfmt-formatting-fixes.md:495
msgid "// This is the same without an attribute.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:500
msgid "Off-by-one error for wrapping enum variant doc comments"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:506
msgid ""
"When using the `wrap_comments` feature, the comments were being wrapped at a "
"column width off-by-one."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:512
#: src/rust-2024/rustfmt-formatting-fixes.md:535
msgid ""
"/// But here, this comment is 120 columns wide and the formatter wants to "
"split it up onto two separate lines still.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:514
#: src/rust-2024/rustfmt-formatting-fixes.md:526
#: src/rust-2024/rustfmt-formatting-fixes.md:537
msgid ""
"/// This comment is 119 columns wide and works perfectly. Lorem ipsum. lorem "
"ipsum. lorem ipsum. lorem ipsum lorem.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:523
msgid ""
"/// But here, this comment is 120 columns wide and the formatter wants to "
"split it up onto two separate lines\n"
"    /// still.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:542
msgid "Off-by-one error for `format_macro_matchers`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:548
msgid ""
"When using the `format_macro_matchers` feature, the matcher was being "
"wrapped at a column width off-by-one."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:572
msgid "Fixed failure with `=>` in comment after match `=>`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:578
msgid ""
"In certain circumstances if a comment contained a `=>` after the `=>` in a "
"match expression, this would cause a failure to format correctly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:586
#: src/rust-2024/rustfmt-formatting-fixes.md:600
msgid "// comment with =>\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:588
#: src/rust-2024/rustfmt-formatting-fixes.md:602
msgid "\"A\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:608
msgid "Multiple inner attributes in a match expression indented incorrectly"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:614
msgid ""
"Multiple inner attributes in a match expression were being indented "
"incorrectly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:642
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:34
#: src/rust-2024/rustfmt-version-sorting.md:39
msgid ""
"The change can be applied automatically by running `cargo fmt` or `rustfmt` "
"with the 2024 Edition. See the [Style edition](rustfmt-style-edition.md) "
"chapter for more information on migrating and how style editions work."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:5
msgid ""
"`rustfmt` now properly sorts [raw identifiers](../../reference/"
"identifiers.html#raw-identifiers)."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:11
#: src/rust-2024/rustfmt-version-sorting.md:9
msgid ""
"The [Rust Style Guide](../../style-guide/index.html) includes [rules for "
"sorting](../../style-guide/index.html#sorting) that `rustfmt` applies in "
"various contexts, such as on imports."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:13
msgid ""
"Prior to the 2024 Edition, when sorting rustfmt would use the leading `r#` "
"token instead of the ident which led to unwanted results. For example:"
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:21
#: src/rust-2024/rustfmt-version-sorting.md:27
msgid "In the 2024 Edition, `rustfmt` now produces:"
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:5
msgid "`rustfmt` utilizes a new sorting algorithm."
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:11
msgid ""
"Previous versions of the Style Guide and Rustfmt generally used an "
"\"ASCIIbetical\" based approach. In the 2024 Edition this is changed to use "
"a version-sort like algorithm that compares Unicode characters "
"lexicographically and provides better results in ASCII digit comparisons."
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:13
msgid "For example with a given (unsorted) input:"
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:20
msgid "In the prior Editions, `rustfmt` would have produced:"
msgstr ""