msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-10-15T16:19:26+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:19:26+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1 src/intro/no-std.md:36
msgid "Summary"
msgstr "ìš”ì•½"

#: src/SUMMARY.md:12 src/intro/index.md:1
msgid "Introduction"
msgstr "ì†Œê°œ"

#: src/SUMMARY.md:13 src/SUMMARY.md:23 src/start/hardware.md:1
msgid "Hardware"
msgstr "í•˜ë“œì›¨ì–´"

#: src/SUMMARY.md:14
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:15 src/intro/tooling.md:1
msgid "Tooling"
msgstr "ë„êµ¬"

#: src/SUMMARY.md:16
msgid "Installation"
msgstr "ì„¤ì¹˜"

#: src/SUMMARY.md:17 src/intro/install/linux.md:1
msgid "Linux"
msgstr "ë¦¬ëˆ…ìŠ¤"

#: src/SUMMARY.md:18
msgid "MacOS"
msgstr "ë§¥OS"

#: src/SUMMARY.md:19 src/intro/install/windows.md:1
msgid "Windows"
msgstr "ìœˆë„ìš°"

#: src/SUMMARY.md:20 src/intro/install/verify.md:1
msgid "Verify Installation"
msgstr "ì„¤ì¹˜ í™•ì¸"

#: src/SUMMARY.md:21
msgid "Getting started"
msgstr "ì‹œì‘í•˜ê¸°"

#: src/SUMMARY.md:22 src/intro/install/windows.md:35 src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/SUMMARY.md:24
msgid "Memory-mapped Registers"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°"

#: src/SUMMARY.md:25 src/start/semihosting.md:1
msgid "Semihosting"
msgstr "ì„¸ë¯¸í˜¸ìŠ¤íŒ…"

#: src/SUMMARY.md:26 src/start/panicking.md:1
msgid "Panicking"
msgstr "íŒ¨ë‹‰"

#: src/SUMMARY.md:27 src/start/exceptions.md:1
msgid "Exceptions"
msgstr "ì˜ˆì™¸"

#: src/SUMMARY.md:28 src/intro/index.md:50 src/intro/index.md:64
#: src/start/interrupts.md:1
msgid "Interrupts"
msgstr "ì¸í„°ëŸ½íŠ¸"

#: src/SUMMARY.md:29 src/start/io.md:1
msgid "IO"
msgstr "ì…ì¶œë ¥"

#: src/SUMMARY.md:30 src/peripherals/index.md:1
msgid "Peripherals"
msgstr "ì£¼ë³€ì¥ì¹˜"

#: src/SUMMARY.md:31
msgid "A first attempt in Rust"
msgstr "Rustë¡œ ì²« ë²ˆì§¸ ì‹œë„"

#: src/SUMMARY.md:32 src/peripherals/borrowck.md:13
msgid "The Borrow Checker"
msgstr "ë¹Œë¦¼ ê²€ì‚¬ê¸°"

#: src/SUMMARY.md:33 src/peripherals/singletons.md:1
msgid "Singletons"
msgstr "ì‹±ê¸€í†¤"

#: src/SUMMARY.md:34 src/static-guarantees/index.md:1
msgid "Static Guarantees"
msgstr "ì •ì  ë³´ì¥"

#: src/SUMMARY.md:35 src/static-guarantees/typestate-programming.md:1
msgid "Typestate Programming"
msgstr "íƒ€ì… ìƒíƒœ í”„ë¡œê·¸ë˜ë°"

#: src/SUMMARY.md:36 src/static-guarantees/state-machines.md:1
msgid "Peripherals as State Machines"
msgstr "ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œì„œì˜ ì£¼ë³€ì¥ì¹˜"

#: src/SUMMARY.md:37 src/static-guarantees/design-contracts.md:1
msgid "Design Contracts"
msgstr "ì„¤ê³„ ê³„ì•½"

#: src/SUMMARY.md:38 src/static-guarantees/zero-cost-abstractions.md:1
msgid "Zero Cost Abstractions"
msgstr "ì œë¡œ ë¹„ìš© ì¶”ìƒí™”"

#: src/SUMMARY.md:39 src/portability/index.md:1
msgid "Portability"
msgstr "ì´ì‹ì„±"

#: src/SUMMARY.md:40 src/concurrency/index.md:1
msgid "Concurrency"
msgstr "ë™ì‹œì„±"

#: src/SUMMARY.md:41 src/collections/index.md:1
msgid "Collections"
msgstr "ì»¬ë ‰ì…˜"

#: src/SUMMARY.md:42 src/design-patterns/index.md:1
msgid "Design Patterns"
msgstr "ë””ìì¸ íŒ¨í„´"

#: src/SUMMARY.md:43
msgid "HALs"
msgstr "HAL"

#: src/SUMMARY.md:44
msgid "Checklist"
msgstr "ì²´í¬ë¦¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:45 src/design-patterns/hal/naming.md:1
msgid "Naming"
msgstr "ëª…ëª…"

#: src/SUMMARY.md:46 src/SUMMARY.md:51
#: src/design-patterns/hal/interoperability.md:1
#: src/interoperability/index.md:1
msgid "Interoperability"
msgstr "ìƒí˜¸ ìš´ìš©ì„±"

#: src/SUMMARY.md:47 src/design-patterns/hal/predictability.md:1
msgid "Predictability"
msgstr "ì˜ˆì¸¡ ê°€ëŠ¥ì„±"

#: src/SUMMARY.md:48
msgid "GPIO"
msgstr "GPIO"

#: src/SUMMARY.md:49 src/c-tips/index.md:1
msgid "Tips for embedded C developers"
msgstr "ì„ë² ë””ë“œ C ê°œë°œìë¥¼ ìœ„í•œ íŒ"

#: src/SUMMARY.md:52 src/interoperability/c-with-rust.md:1
msgid "A little C with your Rust"
msgstr "Rustì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ C"

#: src/SUMMARY.md:53 src/interoperability/rust-with-c.md:1
msgid "A little Rust with your C"
msgstr "Cì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ Rust"

#: src/SUMMARY.md:54 src/unsorted/index.md:1
msgid "Unsorted topics"
msgstr "ë¯¸ë¶„ë¥˜ ì£¼ì œ"

#: src/SUMMARY.md:55
msgid "Optimizations: The speed size tradeoff"
msgstr "ìµœì í™”: ì†ë„ì™€ í¬ê¸°ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„"

#: src/SUMMARY.md:56
msgid "Performing Math Functionality"
msgstr "ìˆ˜í•™ ê¸°ëŠ¥ ìˆ˜í–‰"

#: src/SUMMARY.md:60 src/appendix/glossary.md:1
msgid "Appendix A: Glossary"
msgstr "ë¶€ë¡ A: ìš©ì–´ì§‘"

#: src/intro/index.md:3
msgid ""
"Welcome to The Embedded Rust Book: An introductory book about using the Rust "
"Programming Language on \"Bare Metal\" embedded systems, such as "
"Microcontrollers."
msgstr ""
"ì„ë² ë””ë“œ Rust ë¶ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê°™ì€ \"ë² ì–´ ë©”íƒˆ\" "
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì—ì„œ Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ì…ë¬¸ì„œì…ë‹ˆë‹¤."

#: src/intro/index.md:6
msgid "Who Embedded Rust is For"
msgstr "ì„ë² ë””ë“œ RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€"

#: src/intro/index.md:7
msgid ""
"Embedded Rust is for everyone who wants to do embedded programming while "
"taking advantage of the higher-level concepts and safety guarantees the Rust "
"language provides. (See also [Who Rust Is For](https://doc.rust-lang.org/"
"book/ch00-00-introduction.html))"
msgstr ""
"ì„ë² ë””ë“œ RustëŠ” Rust ì–¸ì–´ê°€ ì œê³µí•˜ëŠ” ê³ ìˆ˜ì¤€ ê°œë…ê³¼ ì•ˆì „ì„± ë³´ì¥ì„ í™œìš©í•˜ë©´ì„œ "
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê³ ì í•˜ëŠ” ëª¨ë“  ì‚¬ëŒì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. ([RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)ë„ ì°¸ì¡°í•˜ì„¸ìš”)"

#: src/intro/index.md:10
msgid "Scope"
msgstr "ë²”ìœ„"

#: src/intro/index.md:12
msgid "The goals of this book are:"
msgstr "ì´ ì±…ì˜ ëª©í‘œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/intro/index.md:14
msgid ""
"Get developers up to speed with embedded Rust development. i.e. How to set "
"up a development environment."
msgstr ""
"ê°œë°œìë“¤ì´ ì„ë² ë””ë“œ Rust ê°œë°œì— ë¹ ë¥´ê²Œ ì ì‘í•  ìˆ˜ ìˆë„ë¡ ë•ìŠµë‹ˆë‹¤. ì¦‰, ê°œë°œ í™˜ê²½ì„ "
"ì„¤ì •í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/index.md:17
msgid ""
"Share _current_ best practices about using Rust for embedded development. "
"i.e. How to best use Rust language features to write more correct embedded "
"software."
msgstr ""
"ì„ë² ë””ë“œ ê°œë°œì—ì„œ Rustë¥¼ ì‚¬ìš©í•˜ëŠ” _í˜„ì¬ì˜_ ëª¨ë²” ì‚¬ë¡€ë¥¼ ê³µìœ í•©ë‹ˆë‹¤. ì¦‰, Rust ì–¸ì–´ "
"ê¸°ëŠ¥ì„ ìµœëŒ€í•œ í™œìš©í•˜ì—¬ ë” ì •í™•í•œ ì„ë² ë””ë“œ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/index.md:21
msgid ""
"Serve as a cookbook in some cases. e.g. How do I mix C and Rust in a single "
"project?"
msgstr ""
"ê²½ìš°ì— ë”°ë¼ì„œëŠ” ìš”ë¦¬ì±… ì—­í• ì„ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•˜ë‚˜ì˜ í”„ë¡œì íŠ¸ì—ì„œ Cì™€ Rustë¥¼ "
"ì–´ë–»ê²Œ í˜¼í•©í•  ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/intro/index.md:24
msgid ""
"This book tries to be as general as possible but to make things easier for "
"both the readers and the writers it uses the ARM Cortex-M architecture in "
"all its examples. However, the book doesn't assume that the reader is "
"familiar with this particular architecture and explains details particular "
"to this architecture where required."
msgstr ""
"ì´ ì±…ì€ ê°€ëŠ¥í•œ í•œ ì¼ë°˜ì ì´ë ¤ê³  í•˜ì§€ë§Œ ë…ìì™€ ì €ì ëª¨ë‘ì—ê²Œ í¸ì˜ë¥¼ ìœ„í•´ ëª¨ë“  ì˜ˆì œì—ì„œ "
"ARM Cortex-M ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ì±…ì€ ë…ìê°€ ì´ íŠ¹ì • ì•„í‚¤í…ì²˜ì— "
"ìµìˆ™í•˜ë‹¤ê³  ê°€ì •í•˜ì§€ ì•Šìœ¼ë©°, í•„ìš”í•œ ê²½ìš° ì´ ì•„í‚¤í…ì²˜ì— íŠ¹ì •í•œ ì„¸ë¶€ì‚¬í•­ì„ ì„¤ëª…í•©ë‹ˆë‹¤."

#: src/intro/index.md:30
msgid "Who This Book is For"
msgstr "ì´ ì±…ì€ ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€"

#: src/intro/index.md:31
msgid ""
"This book caters towards people with either some embedded background or some "
"Rust background, however we believe everybody curious about embedded Rust "
"programming can get something out of this book. For those without any prior "
"knowledge we suggest you read the \"Assumptions and Prerequisites\" section "
"and catch up on missing knowledge to get more out of the book and improve "
"your reading experience. You can check out the \"Other Resources\" section "
"to find resources on topics you might want to catch up on."
msgstr ""
"ì´ ì±…ì€ ì„ë² ë””ë“œ ë°°ê²½ì´ë‚˜ Rust ë°°ê²½ì„ ê°€ì§„ ì‚¬ëŒë“¤ì„ ëŒ€ìƒìœ¼ë¡œ í•˜ì§€ë§Œ, ì„ë² ë””ë“œ Rust "
"í”„ë¡œê·¸ë˜ë°ì— ê´€ì‹¬ì´ ìˆëŠ” ëª¨ë“  ì‚¬ëŒì´ ì´ ì±…ì—ì„œ ë¬´ì–¸ê°€ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤ê³  ë¯¿ìŠµë‹ˆë‹¤. "
"ì‚¬ì „ ì§€ì‹ì´ ì—†ëŠ” ë¶„ë“¤ì€ \"ê°€ì • ë° ì „ì œ ì¡°ê±´\" ì„¹ì…˜ì„ ì½ê³  ë¶€ì¡±í•œ ì§€ì‹ì„ ë³´ì¶©í•˜ì—¬ "
"ì±…ì„ ë” ì˜ í™œìš©í•˜ê³  ì½ê¸° ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ê¸°ë¥¼ ê¶Œí•©ë‹ˆë‹¤. \"ê¸°íƒ€ ìë£Œ\" ì„¹ì…˜ì—ì„œ "
"ë³´ì¶©í•˜ê³  ì‹¶ì€ ì£¼ì œì— ëŒ€í•œ ìë£Œë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:37
msgid "Assumptions and Prerequisites"
msgstr "ê°€ì • ë° ì „ì œ ì¡°ê±´"

#: src/intro/index.md:39
msgid ""
"You are comfortable using the Rust Programming Language, and have written, "
"run, and debugged Rust applications on a desktop environment. You should "
"also be familiar with the idioms of the [2018 edition](https://doc.rust-"
"lang.org/edition-guide/) as this book targets Rust 2018."
msgstr ""
"Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ í¸ì•ˆí•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê³ , ë°ìŠ¤í¬í†± í™˜ê²½ì—ì„œ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ "
"ì‘ì„±, ì‹¤í–‰, ë””ë²„ê¹…í•´ë³¸ ê²½í—˜ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ë˜í•œ ì´ ì±…ì€ Rust 2018ì„ ëŒ€ìƒìœ¼ë¡œ í•˜ë¯€ë¡œ "
"[2018 ì—ë””ì…˜](https://doc.rust-lang.org/edition-guide/)ì˜ ê´€ìš©êµ¬ì—ë„ ìµìˆ™í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/index.md:46
msgid ""
"You are comfortable developing and debugging embedded systems in another "
"language such as C, C++, or Ada, and are familiar with concepts such as:"
msgstr ""
"C, C++, Adaì™€ ê°™ì€ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ê°œë°œí•˜ê³  ë””ë²„ê¹…í•˜ëŠ” ë° ìµìˆ™í•˜ë©°, "
"ë‹¤ìŒê³¼ ê°™ì€ ê°œë…ë“¤ì— ì¹œìˆ™í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/intro/index.md:48
msgid "Cross Compilation"
msgstr "í¬ë¡œìŠ¤ ì»´íŒŒì¼"

#: src/intro/index.md:49 src/peripherals/index.md:32
msgid "Memory Mapped Peripherals"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ì£¼ë³€ì¥ì¹˜"

#: src/intro/index.md:51
msgid "Common interfaces such as I2C, SPI, Serial, etc."
msgstr "I2C, SPI, ì‹œë¦¬ì–¼ ë“±ê³¼ ê°™ì€ ì¼ë°˜ì ì¸ ì¸í„°í˜ì´ìŠ¤"

#: src/intro/index.md:53 src/c-tips/index.md:410
msgid "Other Resources"
msgstr "ê¸°íƒ€ ìë£Œ"

#: src/intro/index.md:54
msgid ""
"If you are unfamiliar with anything mentioned above or if you want more "
"information about a specific topic mentioned in this book you might find "
"some of these resources helpful."
msgstr ""
"ìœ„ì—ì„œ ì–¸ê¸‰í•œ ë‚´ìš© ì¤‘ ìµìˆ™í•˜ì§€ ì•Šì€ ê²ƒì´ ìˆê±°ë‚˜ ì´ ì±…ì—ì„œ ì–¸ê¸‰ëœ íŠ¹ì • ì£¼ì œì— ëŒ€í•œ "
"ë” ë§ì€ ì •ë³´ë¥¼ ì›í•œë‹¤ë©´ ë‹¤ìŒ ìë£Œë“¤ì´ ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/intro/index.md:56
msgid "Topic"
msgstr "ì£¼ì œ"

#: src/intro/index.md:56
msgid "Resource"
msgstr "ìë£Œ"

#: src/intro/index.md:56 src/peripherals/a-first-attempt.md:9
msgid "Description"
msgstr "ì„¤ëª…"

#: src/intro/index.md:58
msgid "Rust"
msgstr "Rust"

#: src/intro/index.md:58
msgid "[Rust Book](https://doc.rust-lang.org/book/)"
msgstr "[Rust ì±…](https://doc.rust-lang.org/book/)"

#: src/intro/index.md:58
msgid ""
"If you are not yet comfortable with Rust, we highly suggest reading this "
"book."
msgstr ""
"ì•„ì§ Rustì— ìµìˆ™í•˜ì§€ ì•Šë‹¤ë©´, ì´ ì±…ì„ ì½ì–´ë³´ì‹œê¸°ë¥¼ ê°•ë ¥íˆ ê¶Œí•©ë‹ˆë‹¤."

#: src/intro/index.md:59 src/intro/index.md:60 src/intro/index.md:61
#: src/intro/index.md:62 src/intro/index.md:63
msgid "Rust, Embedded"
msgstr "Rust, ì„ë² ë””ë“œ"

#: src/intro/index.md:59
msgid "[Discovery Book](https://docs.rust-embedded.org/discovery/)"
msgstr "[Discovery ì±…](https://docs.rust-embedded.org/discovery/)"

#: src/intro/index.md:59
msgid ""
"If you have never done any embedded programming, this book might be a better "
"start"
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•œ ë²ˆë„ í•´ë³¸ ì ì´ ì—†ë‹¤ë©´, ì´ ì±…ì´ ë” ë‚˜ì€ ì‹œì‘ì ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/intro/index.md:60
msgid "[Embedded Rust Bookshelf](https://docs.rust-embedded.org)"
msgstr "[ì„ë² ë””ë“œ Rust ì„œì¬](https://docs.rust-embedded.org)"

#: src/intro/index.md:60
msgid ""
"Here you can find several other resources provided by Rust's Embedded "
"Working Group."
msgstr ""
"ì—¬ê¸°ì„œ Rust ì„ë² ë””ë“œ ì›Œí‚¹ ê·¸ë£¹ì—ì„œ ì œê³µí•˜ëŠ” ì—¬ëŸ¬ ë‹¤ë¥¸ ìë£Œë“¤ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:61
msgid "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"
msgstr "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"

#: src/intro/index.md:61
msgid "The nitty gritty details when doing embedded programming in Rust."
msgstr "Rustë¡œ ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•  ë•Œì˜ ì„¸ë¶€ì ì¸ ë‚´ìš©ë“¤."

#: src/intro/index.md:62
msgid "[embedded FAQ](https://docs.rust-embedded.org/faq.html)"
msgstr "[ì„ë² ë””ë“œ FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/intro/index.md:62
msgid "Frequently asked questions about Rust in an embedded context."
msgstr "ì„ë² ë””ë“œ í™˜ê²½ì—ì„œ Rustì— ëŒ€í•œ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸ë“¤."

#: src/intro/index.md:63
msgid ""
"[Comprehensive Rust ğŸ¦€: Bare Metal](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"
msgstr ""
"[í¬ê´„ì ì¸ Rust ğŸ¦€: ë² ì–´ ë©”íƒˆ](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"

#: src/intro/index.md:63
msgid "Teaching material for a 1-day class on bare-metal Rust development"
msgstr "ë² ì–´ ë©”íƒˆ Rust ê°œë°œì— ëŒ€í•œ 1ì¼ ìˆ˜ì—…ìš© êµìœ¡ ìë£Œ"

#: src/intro/index.md:64
msgid "[Interrupt](https://en.wikipedia.org/wiki/Interrupt)"
msgstr "[ì¸í„°ëŸ½íŠ¸](https://en.wikipedia.org/wiki/Interrupt)"

#: src/intro/index.md:64 src/intro/index.md:65 src/intro/index.md:66
msgid "\\-"
msgstr "\\-"

#: src/intro/index.md:65
msgid "Memory-mapped IO/Peripherals"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ì…ì¶œë ¥/ì£¼ë³€ì¥ì¹˜"

#: src/intro/index.md:65
msgid "[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"
msgstr "[ë©”ëª¨ë¦¬ ë§¤í•‘ ì…ì¶œë ¥](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"

#: src/intro/index.md:66
msgid "SPI, UART, RS232, USB, I2C, TTL"
msgstr "SPI, UART, RS232, USB, I2C, TTL"

#: src/intro/index.md:66
msgid ""
"[Stack Exchange about SPI, UART, and other interfaces](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"
msgstr ""
"[SPI, UART ë° ê¸°íƒ€ ì¸í„°í˜ì´ìŠ¤ì— ëŒ€í•œ Stack Exchange](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"

#: src/intro/index.md:68
msgid "Translations"
msgstr "ë²ˆì—­"

#: src/intro/index.md:70
msgid ""
"This book has been translated by generous volunteers. If you would like your "
"translation listed here, please open a PR to add it."
msgstr ""
"ì´ ì±…ì€ ê´€ëŒ€í•œ ìì›ë´‰ì‚¬ìë“¤ì— ì˜í•´ ë²ˆì—­ë˜ì—ˆìŠµë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ ë²ˆì—­ì„ ì—¬ê¸°ì— "
"ë‚˜ì—´í•˜ê³  ì‹¶ë‹¤ë©´ PRì„ ì—´ì–´ ì¶”ê°€í•´ ì£¼ì„¸ìš”."

#: src/intro/index.md:73
msgid ""
"[Japanese](https://tomoyuki-nakabayashi.github.io/book/) ([repository]"
"(https://github.com/tomoyuki-nakabayashi/book))"
msgstr ""
"[ì¼ë³¸ì–´](https://tomoyuki-nakabayashi.github.io/book/) ([ì €ì¥ì†Œ]"
"(https://github.com/tomoyuki-nakabayashi/book))"

#: src/intro/index.md:76
msgid ""
"[Chinese](https://xxchang.github.io/book/) ([repository](https://github.com/"
"XxChang/book))"
msgstr ""
"[ì¤‘êµ­ì–´](https://xxchang.github.io/book/) ([ì €ì¥ì†Œ](https://github.com/"
"XxChang/book))"

#: src/intro/index.md:79
msgid "How to Use This Book"
msgstr "ì´ ì±…ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•"

#: src/intro/index.md:81
msgid ""
"This book generally assumes that youâ€™re reading it front-to-back. Later "
"chapters build on concepts in earlier chapters, and earlier chapters may not "
"dig into details on a topic, revisiting the topic in a later chapter."
msgstr ""
"ì´ ì±…ì€ ì¼ë°˜ì ìœ¼ë¡œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ìˆœì„œëŒ€ë¡œ ì½ëŠ”ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. í›„ë°˜ "
"ì¥ë“¤ì€ ì´ì „ ì¥ì˜ ê°œë…ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ì´ì „ ì¥ì—ì„œëŠ” ì£¼ì œì— ëŒ€í•œ ì„¸ë¶€ì‚¬í•­ì„ "
"ê¹Šì´ ë‹¤ë£¨ì§€ ì•Šê³  í›„ë°˜ ì¥ì—ì„œ ë‹¤ì‹œ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:85
msgid ""
"This book will be using the [STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) development board from "
"STMicroelectronics for the majority of the examples contained within. This "
"board is based on the ARM Cortex-M architecture, and while basic "
"functionality is the same across most CPUs based on this architecture, "
"peripherals and other implementation details of Microcontrollers are "
"different between different vendors, and often even different between "
"Microcontroller families from the same vendor."
msgstr ""
"ì´ ì±…ì€ í¬í•¨ëœ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œì—ì„œ STMicroelectronicsì˜ "
"[STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) ê°œë°œ ë³´ë“œë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. "
"ì´ ë³´ë“œëŠ” ARM Cortex-M ì•„í‚¤í…ì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ì´ ì•„í‚¤í…ì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ "
"ëŒ€ë¶€ë¶„ì˜ CPUì—ì„œ ê¸°ë³¸ ê¸°ëŠ¥ì€ ë™ì¼í•˜ì§€ë§Œ, ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì£¼ë³€ì¥ì¹˜ì™€ ê¸°íƒ€ "
"êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì€ ë²¤ë”ë§ˆë‹¤ ë‹¤ë¥´ê³ , ì¢…ì¢… ê°™ì€ ë²¤ë”ì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ íŒ¨ë°€ë¦¬ ê°„ì—ë„ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/intro/index.md:93
msgid ""
"For this reason, we suggest purchasing the [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html) development board for "
"the purpose of following the examples in this book."
msgstr ""
"ì´ëŸ¬í•œ ì´ìœ ë¡œ, ì´ ì±…ì˜ ì˜ˆì œë¥¼ ë”°ë¼í•˜ê¸° ìœ„í•´ "
"[STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html) "
"ê°œë°œ ë³´ë“œë¥¼ êµ¬ì…í•˜ì‹œê¸°ë¥¼ ê¶Œí•©ë‹ˆë‹¤."

#: src/intro/index.md:98
msgid "Contributing to This Book"
msgstr "ì´ ì±…ì— ê¸°ì—¬í•˜ê¸°"

#: src/intro/index.md:100
msgid ""
"The work on this book is coordinated in [this repository](https://github.com/"
"rust-embedded/book) and is mainly developed by the [resources team](https://"
"github.com/rust-embedded/wg#the-resources-team)."
msgstr ""
"ì´ ì±…ì˜ ì‘ì—…ì€ [ì´ ì €ì¥ì†Œ](https://github.com/"
"rust-embedded/book)ì—ì„œ ì¡°ì •ë˜ë©° ì£¼ë¡œ [ë¦¬ì†ŒìŠ¤ íŒ€](https://"
"github.com/rust-embedded/wg#the-resources-team)ì—ì„œ ê°œë°œë©ë‹ˆë‹¤."

#: src/intro/index.md:106
msgid ""
"If you have trouble following the instructions in this book or find that "
"some section of the book is not clear enough or hard to follow then that's a "
"bug and it should be reported in [the issue tracker](https://github.com/rust-"
"embedded/book/issues/) of this book."
msgstr ""
"ì´ ì±…ì˜ ì§€ì¹¨ì„ ë”°ë¥´ëŠ” ë° ë¬¸ì œê°€ ìˆê±°ë‚˜ ì±…ì˜ ì¼ë¶€ ì„¹ì…˜ì´ ì¶©ë¶„íˆ ëª…í™•í•˜ì§€ ì•Šê±°ë‚˜ "
"ë”°ë¼í•˜ê¸° ì–´ë µë‹¤ë©´ ê·¸ê²ƒì€ ë²„ê·¸ì´ë©° ì´ ì±…ì˜ [ì´ìŠˆ íŠ¸ë˜ì»¤](https://github.com/rust-"
"embedded/book/issues/)ì— ë³´ê³ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/index.md:112
msgid "Pull requests fixing typos and adding new content are very welcome!"
msgstr "ì˜¤íƒ€ë¥¼ ìˆ˜ì •í•˜ê³  ìƒˆë¡œìš´ ë‚´ìš©ì„ ì¶”ê°€í•˜ëŠ” í’€ ë¦¬í€˜ìŠ¤íŠ¸ëŠ” ë§¤ìš° í™˜ì˜í•©ë‹ˆë‹¤!"

#: src/intro/index.md:114
msgid "Re-using this material"
msgstr "ì´ ìë£Œ ì¬ì‚¬ìš©í•˜ê¸°"

#: src/intro/index.md:116
msgid "This book is distributed under the following licenses:"
msgstr "ì´ ì±…ì€ ë‹¤ìŒ ë¼ì´ì„ ìŠ¤ í•˜ì— ë°°í¬ë©ë‹ˆë‹¤:"

#: src/intro/index.md:118
msgid ""
"The code samples and free-standing Cargo projects contained within this book "
"are licensed under the terms of both the [MIT License](https://"
"opensource.org/licenses/MIT) and the [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0)."
msgstr ""
"ì´ ì±…ì— í¬í•¨ëœ ì½”ë“œ ìƒ˜í”Œê³¼ ë…ë¦½ì ì¸ Cargo í”„ë¡œì íŠ¸ëŠ” [MIT ë¼ì´ì„ ìŠ¤](https://"
"opensource.org/licenses/MIT)ì™€ [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0) ì¡°ê±´ í•˜ì— ë¼ì´ì„ ìŠ¤ë©ë‹ˆë‹¤."

#: src/intro/index.md:119
msgid ""
"The written prose, pictures and diagrams contained within this book are "
"licensed under the terms of the Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) license."
msgstr ""
"ì´ ì±…ì— í¬í•¨ëœ ê¸€, ê·¸ë¦¼, ë‹¤ì´ì–´ê·¸ë¨ì€ í¬ë¦¬ì—ì´í‹°ë¸Œ ì»¤ë¨¼ì¦ˆ [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) ë¼ì´ì„ ìŠ¤ì˜ ì¡°ê±´ í•˜ì— ë¼ì´ì„ ìŠ¤ë©ë‹ˆë‹¤."

#: src/intro/index.md:125
msgid "TL;DR: If you want to use our text or images in your work, you need to:"
msgstr "ìš”ì•½: ì‘ì—…ì—ì„œ ìš°ë¦¬ì˜ í…ìŠ¤íŠ¸ë‚˜ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë‹¤ìŒì´ í•„ìš”í•©ë‹ˆë‹¤:"

#: src/intro/index.md:127
msgid ""
"Give the appropriate credit (i.e. mention this book on your slide, and "
"provide a link to the relevant page)"
msgstr ""
"ì ì ˆí•œ í¬ë ˆë”§ì„ ì œê³µí•˜ì„¸ìš” (ì¦‰, ìŠ¬ë¼ì´ë“œì— ì´ ì±…ì„ ì–¸ê¸‰í•˜ê³  ê´€ë ¨ í˜ì´ì§€ì— ëŒ€í•œ "
"ë§í¬ë¥¼ ì œê³µí•˜ì„¸ìš”)"

#: src/intro/index.md:128
msgid ""
"Provide a link to the [CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) licence"
msgstr ""
"[CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) ë¼ì´ì„ ìŠ¤ì— ëŒ€í•œ ë§í¬ë¥¼ ì œê³µí•˜ì„¸ìš”"

#: src/intro/index.md:129
msgid ""
"Indicate if you have changed the material in any way, and make any changes "
"to our material available under the same licence"
msgstr ""
"ìë£Œë¥¼ ì–´ë–¤ ë°©ì‹ìœ¼ë¡œë“  ë³€ê²½í–ˆëŠ”ì§€ í‘œì‹œí•˜ê³ , ìš°ë¦¬ ìë£Œì— ëŒ€í•œ ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ "
"ë™ì¼í•œ ë¼ì´ì„ ìŠ¤ í•˜ì— ì œê³µí•˜ì„¸ìš”"

#: src/intro/index.md:131
msgid "Also, please do let us know if you find this book useful!"
msgstr "ë˜í•œ ì´ ì±…ì´ ìœ ìš©í•˜ë‹¤ê³  ìƒê°í•˜ì‹œë©´ ì•Œë ¤ì£¼ì„¸ìš”!"

#: src/intro/hardware.md:1
msgid "Meet Your Hardware"
msgstr "í•˜ë“œì›¨ì–´ ì†Œê°œ"

#: src/intro/hardware.md:3
msgid "Let's get familiar with the hardware we'll be working with."
msgstr "ìš°ë¦¬ê°€ ì‘ì—…í•  í•˜ë“œì›¨ì–´ì— ìµìˆ™í•´ì ¸ ë´…ì‹œë‹¤."

#: src/intro/hardware.md:5
msgid "STM32F3DISCOVERY (the \"F3\")"
msgstr "STM32F3DISCOVERY (\"F3\")"

#: src/intro/hardware.md:11
msgid "What does this board contain?"
msgstr "ì´ ë³´ë“œì—ëŠ” ë¬´ì—‡ì´ í¬í•¨ë˜ì–´ ìˆë‚˜ìš”?"

#: src/intro/hardware.md:13
msgid ""
"A [STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"microcontroller. This microcontroller has"
msgstr ""
"[STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬. ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ë‹¤ìŒì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤"

#: src/intro/hardware.md:14
msgid ""
"A single-core ARM Cortex-M4F processor with hardware support for single-"
"precision floating point operations and a maximum clock frequency of 72 MHz."
msgstr ""
"ë‹¨ì •ë°€ë„ ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚°ì„ ìœ„í•œ í•˜ë“œì›¨ì–´ ì§€ì›ê³¼ ìµœëŒ€ 72MHzì˜ í´ë¡ ì£¼íŒŒìˆ˜ë¥¼ ê°€ì§„ "
"ë‹¨ì¼ ì½”ì–´ ARM Cortex-M4F í”„ë¡œì„¸ì„œ."

#: src/intro/hardware.md:17
msgid "256 KiB of \"Flash\" memory. (1 KiB = 10**24** bytes)"
msgstr "256 KiBì˜ \"í”Œë˜ì‹œ\" ë©”ëª¨ë¦¬. (1 KiB = 10**24** ë°”ì´íŠ¸)"

#: src/intro/hardware.md:19
msgid "48 KiB of RAM."
msgstr "48 KiBì˜ RAM."

#: src/intro/hardware.md:21
msgid "A variety of integrated peripherals such as timers, I2C, SPI and USART."
msgstr "íƒ€ì´ë¨¸, I2C, SPI, USARTì™€ ê°™ì€ ë‹¤ì–‘í•œ í†µí•© ì£¼ë³€ì¥ì¹˜."

#: src/intro/hardware.md:23
msgid ""
"General purpose Input Output (GPIO) and other types of pins accessible "
"through the two rows of headers along side the board."
msgstr ""
"ë³´ë“œ ì–‘ìª½ì˜ ë‘ ì¤„ì˜ í—¤ë”ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë²”ìš© ì…ì¶œë ¥(GPIO) ë° ê¸°íƒ€ ìœ í˜•ì˜ í•€."

#: src/intro/hardware.md:25
msgid "A USB interface accessible through the USB port labeled \"USB USER\"."
msgstr "\"USB USER\"ë¼ê³  í‘œì‹œëœ USB í¬íŠ¸ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” USB ì¸í„°í˜ì´ìŠ¤."

#: src/intro/hardware.md:27
msgid ""
"An [accelerometer](https://en.wikipedia.org/wiki/Accelerometer) as part of "
"the [LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ê°€ì†ë„ê³„](https://en.wikipedia.org/wiki/Accelerometer)."

#: src/intro/hardware.md:29
msgid ""
"A [magnetometer](https://en.wikipedia.org/wiki/Magnetometer) as part of the "
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ìë ¥ê³„](https://en.wikipedia.org/wiki/Magnetometer)."

#: src/intro/hardware.md:31
msgid ""
"A [gyroscope](https://en.wikipedia.org/wiki/Gyroscope) as part of the "
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) chip."
msgstr ""
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ìì´ë¡œìŠ¤ì½”í”„](https://en.wikipedia.org/wiki/Gyroscope)."

#: src/intro/hardware.md:33
msgid "8 user LEDs arranged in the shape of a compass."
msgstr "ë‚˜ì¹¨ë°˜ ëª¨ì–‘ìœ¼ë¡œ ë°°ì—´ëœ 8ê°œì˜ ì‚¬ìš©ì LED."

#: src/intro/hardware.md:35
msgid ""
"A second microcontroller: a [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). This microcontroller is actually part of "
"an on-board programmer / debugger and is connected to the USB port named "
"\"USB ST-LINK\"."
msgstr ""
"ë‘ ë²ˆì§¸ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬: [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ì‹¤ì œë¡œ "
"ì˜¨ë³´ë“œ í”„ë¡œê·¸ë˜ë¨¸/ë””ë²„ê±°ì˜ ì¼ë¶€ì´ë©° \"USB ST-LINK\"ë¼ëŠ” ì´ë¦„ì˜ USB í¬íŠ¸ì— ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/intro/hardware.md:37
msgid ""
"For a more detailed list of features and further specifications of the board "
"take a look at the [STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) website."
msgstr ""
"ë³´ë“œì˜ ë” ìì„¸í•œ ê¸°ëŠ¥ ëª©ë¡ê³¼ ì¶”ê°€ ì‚¬ì–‘ì€ "
"[STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) ì›¹ì‚¬ì´íŠ¸ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/intro/hardware.md:39
msgid ""
"A word of caution: be careful if you want to apply external signals to the "
"board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 "
"volts. For further information consult the [6.2 Absolute maximum ratings "
"section in the manual](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)"
msgstr ""
"ì£¼ì˜ì‚¬í•­: ë³´ë“œì— ì™¸ë¶€ ì‹ í˜¸ë¥¼ ì ìš©í•˜ë ¤ëŠ” ê²½ìš° ì£¼ì˜í•˜ì„¸ìš”. "
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ STM32F303VCT6 í•€ì€ 3.3ë³¼íŠ¸ì˜ ì •ê²© ì „ì••ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. "
"ìì„¸í•œ ì •ë³´ëŠ” [ë§¤ë‰´ì–¼ì˜ 6.2 ì ˆëŒ€ ìµœëŒ€ ì •ê²© ì„¹ì…˜](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)ì„ ì°¸ì¡°í•˜ì„¸ìš”"

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr "`no_std` Rust í™˜ê²½"

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://"
"en.wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì´ë¼ëŠ” ìš©ì–´ëŠ” ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ í”„ë¡œê·¸ë˜ë° í´ë˜ìŠ¤ì— ì‚¬ìš©ë©ë‹ˆë‹¤. "
"ëª‡ KBì˜ RAMê³¼ ROMë§Œì„ ê°€ì§„ 8ë¹„íŠ¸ MCU([ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)ì™€ ê°™ì€) í”„ë¡œê·¸ë˜ë°ë¶€í„° "
"32/64ë¹„íŠ¸ 4ì½”ì–´ Cortex-A53 @ 1.4 GHzì™€ 1GB RAMì„ ê°€ì§„ ë¼ì¦ˆë² ë¦¬ íŒŒì´([Model B 3+]"
"(https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications))ì™€ ê°™ì€ ì‹œìŠ¤í…œê¹Œì§€ ë‹¤ì–‘í•©ë‹ˆë‹¤. "
"ì–´ë–¤ ì¢…ë¥˜ì˜ ëŒ€ìƒê³¼ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€ì— ë”°ë¼ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ ë‹¤ë¥¸ ì œí•œì‚¬í•­/í•œê³„ê°€ ì ìš©ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr "ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì—ëŠ” ë‘ ê°€ì§€ ì¼ë°˜ì ì¸ ë¶„ë¥˜ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr "í˜¸ìŠ¤íŠ¸ í™˜ê²½"

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""
"ì´ëŸ° ì¢…ë¥˜ì˜ í™˜ê²½ì€ ì¼ë°˜ì ì¸ PC í™˜ê²½ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤. ì´ëŠ” íŒŒì¼ ì‹œìŠ¤í…œ, ë„¤íŠ¸ì›Œí‚¹, "
"ë©”ëª¨ë¦¬ ê´€ë¦¬, ìŠ¤ë ˆë“œ ë“±ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ì‹œìŠ¤í…œê³¼ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ë³¸ ìš”ì†Œë¥¼ ì œê³µí•˜ëŠ” "
"ì‹œìŠ¤í…œ ì¸í„°í˜ì´ìŠ¤ [ì˜ˆ: POSIX](https://en.wikipedia.org/wiki/POSIX)ê°€ ì œê³µëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. "
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì´ëŸ¬í•œ ê¸°ë³¸ ìš”ì†Œì— ì˜ì¡´í•˜ì—¬ ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤. "
"ë˜í•œ ì–´ë–¤ ì¢…ë¥˜ì˜ sysrootì™€ RAM/ROM ì‚¬ìš©ëŸ‰ ì œí•œ, ê·¸ë¦¬ê³  ì•„ë§ˆë„ ì¼ë¶€ íŠ¹ìˆ˜ HWë‚˜ I/Oê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ì „ë°˜ì ìœ¼ë¡œ íŠ¹ìˆ˜ ëª©ì  PC í™˜ê²½ì—ì„œ ì½”ë”©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§‘ë‹ˆë‹¤."

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr "ë² ì–´ ë©”íƒˆ í™˜ê²½"

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""
"ë² ì–´ ë©”íƒˆ í™˜ê²½ì—ì„œëŠ” í”„ë¡œê·¸ë¨ ì´ì „ì— ë¡œë“œëœ ì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤. "
"OSì—ì„œ ì œê³µí•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ì—†ì´ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. "
"ëŒ€ì‹  í”„ë¡œê·¸ë¨ì€ ì‚¬ìš©í•˜ëŠ” í¬ë ˆì´íŠ¸ì™€ í•¨ê»˜ í•˜ë“œì›¨ì–´(ë² ì–´ ë©”íƒˆ)ë§Œì„ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"Rustê°€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ë ¤ë©´ `no_std`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. "
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ í”Œë«í¼ ë…ë¦½ì ì¸ ë¶€ë¶„ì€ [libcore](https://doc.rust-lang.org/core/)ë¥¼ í†µí•´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"libcoreëŠ” ë˜í•œ ì„ë² ë””ë“œ í™˜ê²½ì—ì„œ í•­ìƒ ë°”ëŒì§í•˜ì§€ ì•Šì€ ê²ƒë“¤ì„ ì œì™¸í•©ë‹ˆë‹¤. "
"ì´ëŸ¬í•œ ê²ƒë“¤ ì¤‘ í•˜ë‚˜ëŠ” ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ìœ„í•œ ë©”ëª¨ë¦¬ í• ë‹¹ìì…ë‹ˆë‹¤. "
"ì´ê²ƒì´ë‚˜ ë‹¤ë¥¸ ê¸°ëŠ¥ì´ í•„ìš”í•œ ê²½ìš° ì´ë¥¼ ì œê³µí•˜ëŠ” í¬ë ˆì´íŠ¸ê°€ ì¢…ì¢… ìˆìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr "libstd ëŸ°íƒ€ì„"

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""
"ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´ [libstd](https://doc.rust-lang.org/std/)ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ "
"ì–´ë–¤ ì¢…ë¥˜ì˜ ì‹œìŠ¤í…œ í†µí•©ì´ í•„ìš”í•˜ì§€ë§Œ, ì´ëŠ” [libstd](https://doc.rust-lang.org/std/)ê°€ "
"ë‹¨ìˆœíˆ OS ì¶”ìƒí™”ì— ì ‘ê·¼í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì„ ì œê³µí•˜ê¸° ë•Œë¬¸ë§Œì´ ì•„ë‹ˆë¼ ëŸ°íƒ€ì„ë„ ì œê³µí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. "
"ì´ ëŸ°íƒ€ì„ì€ ë¬´ì—‡ë³´ë‹¤ë„ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œ ë³´í˜¸ ì„¤ì •, ëª…ë ¹ì¤„ ì¸ìˆ˜ ì²˜ë¦¬, "
"í”„ë¡œê·¸ë¨ì˜ main í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê¸° ì „ì— ë©”ì¸ ìŠ¤ë ˆë“œ ìƒì„±ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. "
"ì´ ëŸ°íƒ€ì„ì€ `no_std` í™˜ê²½ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://"
"doc.rust-lang.org/core/) crate in turn is a platform-agnostic subset of the "
"std crate which makes no assumptions about the system the program will run "
"on. As such, it provides APIs for language primitives like floats, strings "
"and slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr "`#![no_std]`ëŠ” í¬ë ˆì´íŠ¸ê°€ std-í¬ë ˆì´íŠ¸ ëŒ€ì‹  core-í¬ë ˆì´íŠ¸ì— ë§í¬ë  ê²ƒì„ì„ ë‚˜íƒ€ë‚´ëŠ” í¬ë ˆì´íŠ¸ ìˆ˜ì¤€ ì†ì„±ì…ë‹ˆë‹¤. [libcore](https://doc.rust-lang.org/core/) í¬ë ˆì´íŠ¸ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë  ì‹œìŠ¤í…œì— ëŒ€í•´ ì–´ë– í•œ ê°€ì •ë„ í•˜ì§€ ì•ŠëŠ” std í¬ë ˆì´íŠ¸ì˜ í”Œë«í¼ ë…ë¦½ì ì¸ í•˜ìœ„ ì§‘í•©ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ë¶€ë™ ì†Œìˆ˜ì , ë¬¸ìì—´ ë° ìŠ¬ë¼ì´ìŠ¤ì™€ ê°™ì€ ì–¸ì–´ ê¸°ë³¸ ìš”ì†Œì— ëŒ€í•œ APIì™€ ì›ìì  ì—°ì‚° ë° SIMD ëª…ë ¹ì–´ì™€ ê°™ì€ í”„ë¡œì„¸ì„œ ê¸°ëŠ¥ì„ ë…¸ì¶œí•˜ëŠ” APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ í”Œë«í¼ í†µí•©ê³¼ ê´€ë ¨ëœ ëª¨ë“  ê²ƒì— ëŒ€í•œ APIëŠ” ë¶€ì¡±í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì†ì„± ë•Œë¬¸ì— no_std ë° [libcore](https://doc.rust-lang.org/core/) ì½”ë“œëŠ” ë¶€íŠ¸ë¡œë”, íŒì›¨ì–´ ë˜ëŠ” ì»¤ë„ê³¼ ê°™ì€ ëª¨ë“  ì¢…ë¥˜ì˜ ë¶€íŠ¸ìŠ¤íŠ¸ë˜í•‘(ë‹¨ê³„ 0) ì½”ë“œì— ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:45 src/intro/tooling.md:58
msgid "Overview"
msgstr "ê°œìš”"

#: src/intro/no-std.md:47
msgid "feature"
msgstr "ê¸°ëŠ¥"

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr "no_std"

#: src/intro/no-std.md:47
msgid "std"
msgstr "std"

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr "í™ (ë™ì  ë©”ëª¨ë¦¬)"

#: src/intro/no-std.md:49
msgid "\\*"
msgstr "\\*"

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "âœ“"
msgstr "âœ“"

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr "ì»¬ë ‰ì…˜ (Vec, BTreeMap ë“±)"

#: src/intro/no-std.md:50
msgid "\\**"
msgstr "\\**"

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr "ìŠ¤íƒ ì˜¤ë²„í”Œë¡œ ë³´í˜¸"

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "âœ˜"
msgstr "âœ˜"

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr "main ì´ì „ì— ì´ˆê¸°í™” ì½”ë“œ ì‹¤í–‰"

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr "libstd ì‚¬ìš© ê°€ëŠ¥"

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr "libcore ì‚¬ìš© ê°€ëŠ¥"

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr "íŒì›¨ì–´, ì»¤ë„ ë˜ëŠ” ë¶€íŠ¸ë¡œë” ì½”ë“œ ì‘ì„±"

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr "* `alloc` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  [alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)ê³¼ ê°™ì€ ì ì ˆí•œ í• ë‹¹ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ë§Œ í•´ë‹¹ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr "** `collections` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  ì „ì—­ ê¸°ë³¸ í• ë‹¹ìë¥¼ êµ¬ì„±í•˜ëŠ” ê²½ìš°ì—ë§Œ í•´ë‹¹ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr "** ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ê¸°ê°€ ë¶€ì¡±í•˜ì—¬ HashMap ë° HashSetì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:65
msgid "See Also"
msgstr "ì°¸ì¡°"

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr "[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)"

#: src/intro/tooling.md:3
msgid ""
"Dealing with microcontrollers involves using several different tools as "
"we'll be dealing with an architecture different than your laptop's and we'll "
"have to run and debug programs on a _remote_ device."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë‹¤ë£¨ëŠ” ê²ƒì€ ì—¬ëŸ¬ ê°€ì§€ ë‹¤ë¥¸ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ í¬í•¨í•©ë‹ˆë‹¤. ì´ëŠ” ë…¸íŠ¸ë¶ê³¼ëŠ” ë‹¤ë¥¸ ì•„í‚¤í…ì²˜ë¥¼ ë‹¤ë£¨ê³  _ì›ê²©_ ì¥ì¹˜ì—ì„œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ê³  ë””ë²„ê¹…í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:7
msgid ""
"We'll use all the tools listed below. Any recent version should work when a "
"minimum version is not specified, but we have listed the versions we have "
"tested."
msgstr "ì•„ë˜ ë‚˜ì—´ëœ ëª¨ë“  ë„êµ¬ë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. ìµœì†Œ ë²„ì „ì´ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš° ìµœì‹  ë²„ì „ì€ ëª¨ë‘ ì‘ë™í•´ì•¼ í•˜ì§€ë§Œ, ì €í¬ê°€ í…ŒìŠ¤íŠ¸í•œ ë²„ì „ì„ ë‚˜ì—´í–ˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:11
msgid ""
"Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation "
"support."
msgstr "Rust 1.31, 1.31-beta ë˜ëŠ” ë” ìƒˆë¡œìš´ íˆ´ì²´ì¸ + ARM Cortex-M ì»´íŒŒì¼ ì§€ì›."

#: src/intro/tooling.md:13
msgid ""
"[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"
msgstr "[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"

#: src/intro/tooling.md:14
msgid "[`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0"
msgstr "[`qemu-system-arm`](https://www.qemu.org/). í…ŒìŠ¤íŠ¸ ë²„ì „: 3.0.0"

#: src/intro/tooling.md:15
msgid "OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0"
msgstr "OpenOCD >=0.8. í…ŒìŠ¤íŠ¸ ë²„ì „: v0.9.0 ë° v0.10.0"

#: src/intro/tooling.md:16
msgid ""
"GDB with ARM support. Version 7.12 or newer highly recommended. Tested "
"versions: 7.10, 7.11, 7.12 and 8.1"
msgstr "ARM ì§€ì› GDB. ë²„ì „ 7.12 ì´ìƒì„ ê°•ë ¥íˆ ê¶Œì¥í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ ë²„ì „: 7.10, 7.11, 7.12 ë° 8.1"

#: src/intro/tooling.md:18
msgid ""
"[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) or "
"`git`. These tools are optional but will make it easier to follow along with "
"the book."
msgstr "[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) ë˜ëŠ” `git`. ì´ ë„êµ¬ë“¤ì€ ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ ì±…ì„ ë”°ë¼í•˜ê¸° ì‰½ê²Œ í•´ì¤„ ê²ƒì…ë‹ˆë‹¤."

#: src/intro/tooling.md:21
msgid ""
"The text below explains why we are using these tools. Installation "
"instructions can be found on the next page."
msgstr "ì•„ë˜ í…ìŠ¤íŠ¸ëŠ” ì´ëŸ¬í•œ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤. ì„¤ì¹˜ ì§€ì¹¨ì€ ë‹¤ìŒ í˜ì´ì§€ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:24
msgid "`cargo-generate` OR `git`"
msgstr "`cargo-generate` ë˜ëŠ” `git`"

#: src/intro/tooling.md:26
msgid ""
"Bare metal programs are non-standard (`no_std`) Rust programs that require "
"some adjustments to the linking process in order to get the memory layout of "
"the program right. This requires some additional files (like linker scripts) "
"and settings (like linker flags). We have packaged those for you in a "
"template such that you only need to fill in the missing information (such as "
"the project name and the characteristics of your target hardware)."
msgstr "ë² ì–´ ë©”íƒˆ í”„ë¡œê·¸ë¨ì€ í”„ë¡œê·¸ë¨ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ì˜¬ë°”ë¥´ê²Œ ì–»ê¸° ìœ„í•´ ë§í¬ í”„ë¡œì„¸ìŠ¤ì— ì¼ë¶€ ì¡°ì •ì´ í•„ìš”í•œ ë¹„í‘œì¤€(`no_std`) Rust í”„ë¡œê·¸ë¨ì…ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ì„œëŠ” ì¼ë¶€ ì¶”ê°€ íŒŒì¼(ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ ë“±) ë° ì„¤ì •(ë§ì»¤ í”Œë˜ê·¸ ë“±)ì´ í•„ìš”í•©ë‹ˆë‹¤. ì €í¬ëŠ” ì´ëŸ¬í•œ ê²ƒë“¤ì„ í…œí”Œë¦¿ìœ¼ë¡œ íŒ¨í‚¤ì§•í•˜ì—¬ í”„ë¡œì íŠ¸ ì´ë¦„ ë° ëŒ€ìƒ í•˜ë“œì›¨ì–´ì˜ íŠ¹ì„±ê³¼ ê°™ì€ ëˆ„ë½ëœ ì •ë³´ë§Œ ì±„ìš°ë©´ ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:33
msgid ""
"Our template is compatible with `cargo-generate`: a Cargo subcommand for "
"creating new Cargo projects from templates. You can also download the "
"template using `git`, `curl`, `wget`, or your web browser."
msgstr "ì €í¬ í…œí”Œë¦¿ì€ í…œí”Œë¦¿ì—ì„œ ìƒˆ Cargo í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ Cargo í•˜ìœ„ ëª…ë ¹ì¸ `cargo-generate`ì™€ í˜¸í™˜ë©ë‹ˆë‹¤. `git`, `curl`, `wget` ë˜ëŠ” ì›¹ ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì—¬ í…œí”Œë¦¿ì„ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:37 src/intro/install.md:59
msgid "`cargo-binutils`"
msgstr "`cargo-binutils`"

#: src/intro/tooling.md:39
msgid ""
"`cargo-binutils` is a collection of Cargo subcommands that make it easy to "
"use the LLVM tools that are shipped with the Rust toolchain. These tools "
"include the LLVM versions of `objdump`, `nm` and `size` and are used for "
"inspecting binaries."
msgstr "`cargo-binutils`ëŠ” Rust íˆ´ì²´ì¸ê³¼ í•¨ê»˜ ì œê³µë˜ëŠ” LLVM ë„êµ¬ë¥¼ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” Cargo í•˜ìœ„ ëª…ë ¹ ëª¨ìŒì…ë‹ˆë‹¤. ì´ ë„êµ¬ì—ëŠ” `objdump`, `nm`, `size`ì˜ LLVM ë²„ì „ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©° ë°”ì´ë„ˆë¦¬ë¥¼ ê²€ì‚¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:44
msgid ""
"The advantage of using these tools over GNU binutils is that (a) installing "
"the LLVM tools is the same one-command installation (`rustup component add "
"llvm-tools`) regardless of your OS and (b) tools like `objdump` support all "
"the architectures that `rustc` supports -- from ARM to x86_64 -- because "
"they both share the same LLVM backend."
msgstr "GNU binutils ëŒ€ì‹  ì´ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¥ì ì€ (a) LLVM ë„êµ¬ ì„¤ì¹˜ê°€ OSì— ê´€ê³„ì—†ì´ ë™ì¼í•œ ë‹¨ì¼ ëª…ë ¹ ì„¤ì¹˜(`rustup component add llvm-tools`)ì´ë©° (b) `objdump`ì™€ ê°™ì€ ë„êµ¬ëŠ” ARMì—ì„œ x86_64ê¹Œì§€ `rustc`ê°€ ì§€ì›í•˜ëŠ” ëª¨ë“  ì•„í‚¤í…ì²˜ë¥¼ ì§€ì›í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” ë‘˜ ë‹¤ ë™ì¼í•œ LLVM ë°±ì—”ë“œë¥¼ ê³µìœ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:50
msgid "`qemu-system-arm`"
msgstr "`qemu-system-arm`"

#: src/intro/tooling.md:52
msgid ""
"QEMU is an emulator. In this case we use the variant that can fully emulate "
"ARM systems. We use QEMU to run embedded programs on the host. Thanks to "
"this you can follow some parts of this book even if you don't have any "
"hardware with you!"
msgstr "QEMUëŠ” ì—ë®¬ë ˆì´í„°ì…ë‹ˆë‹¤. ì´ ê²½ìš° ARM ì‹œìŠ¤í…œì„ ì™„ì „íˆ ì—ë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆëŠ” ë³€í˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ í˜¸ìŠ¤íŠ¸ì—ì„œ ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•©ë‹ˆë‹¤. ë•ë¶„ì— í•˜ë“œì›¨ì–´ê°€ ì—†ì–´ë„ ì´ ì±…ì˜ ì¼ë¶€ë¥¼ ë”°ë¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/intro/tooling.md:56
msgid "Tooling for Embedded Rust Debugging"
msgstr "ì„ë² ë””ë“œ Rust ë””ë²„ê¹…ì„ ìœ„í•œ ë„êµ¬"

#: src/intro/tooling.md:60
msgid ""
"Debugging embedded systems in Rust requires specialized tools including "
"software to manage the debugging process, debuggers to inspect and control "
"program execution, and hardware probes to facilitate interaction between the "
"host and the embedded device. This document outlines essential software "
"tools like Probe-rs and OpenOCD, which simplify and support the debugging "
"process, alongside prominent debuggers such as GDB and the Probe-rs Visual "
"Studio Code extension. Additionally, it covers key hardware probes such as "
"Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective "
"debugging and programming of embedded devices."
msgstr "Rustì—ì„œ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ë””ë²„ê¹…í•˜ë ¤ë©´ ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´, í”„ë¡œê·¸ë¨ ì‹¤í–‰ì„ ê²€ì‚¬í•˜ê³  ì œì–´í•˜ëŠ” ë””ë²„ê±°, í˜¸ìŠ¤íŠ¸ì™€ ì„ë² ë””ë“œ ì¥ì¹˜ ê°„ì˜ ìƒí˜¸ ì‘ìš©ì„ ìš©ì´í•˜ê²Œ í•˜ëŠ” í•˜ë“œì›¨ì–´ í”„ë¡œë¸Œë¥¼ í¬í•¨í•œ ì „ë¬¸ ë„êµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì´ ë¬¸ì„œëŠ” ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¨ìˆœí™”í•˜ê³  ì§€ì›í•˜ëŠ” Probe-rs ë° OpenOCDì™€ ê°™ì€ í•„ìˆ˜ ì†Œí”„íŠ¸ì›¨ì–´ ë„êµ¬ì™€ GDB ë° Probe-rs Visual Studio Code í™•ì¥ê³¼ ê°™ì€ ì£¼ìš” ë””ë²„ê±°ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤. ë˜í•œ Rusty-probe, ST-Link, J-Link ë° MCU-Linkì™€ ê°™ì€ ì£¼ìš” í•˜ë“œì›¨ì–´ í”„ë¡œë¸Œë¥¼ ë‹¤ë£¨ë©°, ì´ëŠ” ì„ë² ë””ë“œ ì¥ì¹˜ì˜ íš¨ê³¼ì ì¸ ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë°ì— í•„ìˆ˜ì ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:62
msgid "Software that drives debugging tools"
msgstr "ë””ë²„ê¹… ë„êµ¬ë¥¼ êµ¬ë™í•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´"

#: src/intro/tooling.md:64
msgid "Probe-rs"
msgstr "Probe-rs"

#: src/intro/tooling.md:66
msgid ""
"Probe-rs is a modern, Rust-focused software designed to work with debuggers "
"in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in "
"mind and aims to reduce the configuration burden often found in other "
"debugging solutions. It supports various probes and targets, providing a "
"high-level interface for interacting with embedded hardware. Probe-rs "
"integrates directly with Rust tooling, and integrates with Visual Studio "
"Code through its extension, allowing developers to streamline their "
"debugging workflow."
msgstr "Probe-rsëŠ” ì„ë² ë””ë“œ ì‹œìŠ¤í…œì˜ ë””ë²„ê±°ì™€ í•¨ê»˜ ì‘ë™í•˜ë„ë¡ ì„¤ê³„ëœ í˜„ëŒ€ì ì¸ Rust ì¤‘ì‹¬ ì†Œí”„íŠ¸ì›¨ì–´ì…ë‹ˆë‹¤. OpenOCDì™€ ë‹¬ë¦¬ Probe-rsëŠ” ë‹¨ìˆœì„±ì„ ì—¼ë‘ì— ë‘ê³  êµ¬ì¶•ë˜ì—ˆìœ¼ë©° ë‹¤ë¥¸ ë””ë²„ê¹… ì†”ë£¨ì…˜ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” êµ¬ì„± ë¶€ë‹´ì„ ì¤„ì´ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤. ë‹¤ì–‘í•œ í”„ë¡œë¸Œì™€ íƒ€ê²Ÿì„ ì§€ì›í•˜ë©° ì„ë² ë””ë“œ í•˜ë“œì›¨ì–´ì™€ ìƒí˜¸ ì‘ìš©í•˜ê¸° ìœ„í•œ ê³ ìˆ˜ì¤€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. Probe-rsëŠ” Rust íˆ´ë§ê³¼ ì§ì ‘ í†µí•©ë˜ë©° í™•ì¥ì„ í†µí•´ Visual Studio Codeì™€ í†µí•©ë˜ì–´ ê°œë°œìê°€ ë””ë²„ê¹… ì›Œí¬í”Œë¡œë¥¼ ê°„ì†Œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:69
msgid "OpenOCD (Open On-Chip Debugger)"
msgstr "OpenOCD (ì˜¤í”ˆ ì˜¨ì¹© ë””ë²„ê±°)"

#: src/intro/tooling.md:71
msgid ""
"OpenOCD is an open-source software tool used for debugging, testing, and "
"programming embedded systems. It provides an interface between the host "
"system and embedded hardware, supporting various transport layers like JTAG "
"and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a "
"debugger. OpenOCD is widely supported, with extensive documentation and a "
"large community, but may require complex configuration, especially for "
"custom embedded setups."
msgstr "OpenOCDëŠ” ì„ë² ë””ë“œ ì‹œìŠ¤í…œ ë””ë²„ê¹…, í…ŒìŠ¤íŠ¸ ë° í”„ë¡œê·¸ë˜ë°ì— ì‚¬ìš©ë˜ëŠ” ì˜¤í”ˆ ì†ŒìŠ¤ ì†Œí”„íŠ¸ì›¨ì–´ ë„êµ¬ì…ë‹ˆë‹¤. í˜¸ìŠ¤íŠ¸ ì‹œìŠ¤í…œê³¼ ì„ë² ë””ë“œ í•˜ë“œì›¨ì–´ ê°„ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ë©° JTAG ë° SWD(Serial Wire Debug)ì™€ ê°™ì€ ë‹¤ì–‘í•œ ì „ì†¡ ê³„ì¸µì„ ì§€ì›í•©ë‹ˆë‹¤. OpenOCDëŠ” ë””ë²„ê±°ì¸ GDBì™€ í†µí•©ë©ë‹ˆë‹¤. OpenOCDëŠ” ê´‘ë²”ìœ„í•œ ë¬¸ì„œì™€ ëŒ€ê·œëª¨ ì»¤ë®¤ë‹ˆí‹°ë¥¼ í†µí•´ ë„ë¦¬ ì§€ì›ë˜ì§€ë§Œ, íŠ¹íˆ ì‚¬ìš©ì ì •ì˜ ì„ë² ë””ë“œ ì„¤ì •ì˜ ê²½ìš° ë³µì¡í•œ êµ¬ì„±ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:73
msgid "Debuggers"
msgstr "ë””ë²„ê±°"

#: src/intro/tooling.md:75
msgid ""
"A debugger allows developers to inspect and control the execution of a "
"program in order to identify and correct errors or bugs. It provides "
"functionalities such as setting breakpoints, stepping through code line by "
"line, and examining the values of variables and memory states. Debuggers are "
"essential for thorough software development and maintenance, enabling "
"developers to ensure that their code behaves as intended under various "
"conditions."
msgstr "ë””ë²„ê±°ëŠ” ê°œë°œìê°€ ì˜¤ë¥˜ë‚˜ ë²„ê·¸ë¥¼ ì‹ë³„í•˜ê³  ìˆ˜ì •í•˜ê¸° ìœ„í•´ í”„ë¡œê·¸ë¨ ì‹¤í–‰ì„ ê²€ì‚¬í•˜ê³  ì œì–´í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ì¤‘ë‹¨ì  ì„¤ì •, ì½”ë“œ í•œ ì¤„ì”© ì‹¤í–‰, ë³€ìˆ˜ ê°’ ë° ë©”ëª¨ë¦¬ ìƒíƒœ ê²€ì‚¬ì™€ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ë””ë²„ê±°ëŠ” ì² ì €í•œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë° ìœ ì§€ ê´€ë¦¬ì— í•„ìˆ˜ì ì´ë©°, ê°œë°œìê°€ ë‹¤ì–‘í•œ ì¡°ê±´ì—ì„œ ì½”ë“œê°€ ì˜ë„í•œ ëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:77
msgid "Debuggers know how to:"
msgstr "ë””ë²„ê±°ëŠ” ë‹¤ìŒì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì„ ì•Œê³  ìˆìŠµë‹ˆë‹¤:"

#: src/intro/tooling.md:78
msgid "Interact with the memory mapped registers."
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°ì™€ ìƒí˜¸ ì‘ìš©í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:79
msgid "Set Breakpoints/Watchpoints."
msgstr "ì¤‘ë‹¨ì /ê°ì‹œì  ì„¤ì •."

#: src/intro/tooling.md:80
msgid "Read and write to the memory mapped registers."
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°ë¥¼ ì½ê³  ì”ë‹ˆë‹¤."

#: src/intro/tooling.md:81
msgid "Detect when the MCU has been halted for a debug event."
msgstr "ë””ë²„ê·¸ ì´ë²¤íŠ¸ë¡œ ì¸í•´ MCUê°€ ì¤‘ë‹¨ë˜ì—ˆì„ ë•Œ ê°ì§€í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:82
msgid "Continue MCU execution after a debug event has been encountered."
msgstr "ë””ë²„ê·¸ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ í›„ MCU ì‹¤í–‰ì„ ê³„ì†í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:83
msgid "Erase and write to the microcontroller's FLASH."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ FLASHë¥¼ ì§€ìš°ê³  ì”ë‹ˆë‹¤."

#: src/intro/tooling.md:85
msgid "Probe-rs Visual Studio Code Extension"
msgstr "Probe-rs Visual Studio Code í™•ì¥"

#: src/intro/tooling.md:87
msgid ""
"Probe-rs has a Visual Studio Code extension, providing a seamless debugging "
"experience without extensive setup. Through this connection, developers can "
"use Rust-specific features like pretty printing and detailed error messages, "
"ensuring that their debugging process aligns with the Rust ecosystem."
msgstr "Probe-rsëŠ” Visual Studio Code í™•ì¥ì„ ì œê³µí•˜ì—¬ ê´‘ë²”ìœ„í•œ ì„¤ì • ì—†ì´ ì›í™œí•œ ë””ë²„ê¹… ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ ì—°ê²°ì„ í†µí•´ ê°œë°œìëŠ” ì˜ˆìœ ì¶œë ¥ ë° ìì„¸í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ ê°™ì€ Rust íŠ¹ì • ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ê°€ Rust ìƒíƒœê³„ì™€ ì¼ì¹˜í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:89
msgid "GDB (GNU Debugger)"
msgstr "GDB (GNU ë””ë²„ê±°)"

#: src/intro/tooling.md:91
msgid ""
"GDB is a versatile debugging tool that allows developers to examine the "
"state of programs while they run or after they crash. For embedded Rust, GDB "
"connects to the target system via OpenOCD or other debugging servers to "
"interact with the embedded code. GDB is highly configurable and supports "
"features like remote debugging, variable inspection, and conditional "
"breakpoints. It can be used on a variety of platforms, and has extensive "
"support for Rust-specific debugging needs, such as pretty printing and "
"integration with IDEs."
msgstr "GDBëŠ” ê°œë°œìê°€ í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ë˜ëŠ” ì¶©ëŒ í›„ í”„ë¡œê·¸ë¨ ìƒíƒœë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë‹¤ëª©ì  ë””ë²„ê¹… ë„êµ¬ì…ë‹ˆë‹¤. ì„ë² ë””ë“œ Rustì˜ ê²½ìš° GDBëŠ” OpenOCD ë˜ëŠ” ë‹¤ë¥¸ ë””ë²„ê¹… ì„œë²„ë¥¼ í†µí•´ ëŒ€ìƒ ì‹œìŠ¤í…œì— ì—°ê²°í•˜ì—¬ ì„ë² ë””ë“œ ì½”ë“œì™€ ìƒí˜¸ ì‘ìš©í•©ë‹ˆë‹¤. GDBëŠ” ê³ ë„ë¡œ êµ¬ì„± ê°€ëŠ¥í•˜ë©° ì›ê²© ë””ë²„ê¹…, ë³€ìˆ˜ ê²€ì‚¬ ë° ì¡°ê±´ë¶€ ì¤‘ë‹¨ì ê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì§€ì›í•©ë‹ˆë‹¤. ë‹¤ì–‘í•œ í”Œë«í¼ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©° ì˜ˆìœ ì¶œë ¥ ë° IDE í†µí•©ê³¼ ê°™ì€ Rust íŠ¹ì • ë””ë²„ê¹… ìš”êµ¬ ì‚¬í•­ì— ëŒ€í•œ ê´‘ë²”ìœ„í•œ ì§€ì›ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/intro/tooling.md:94
msgid "Probes"
msgstr "í”„ë¡œë¸Œ"

#: src/intro/tooling.md:96
msgid ""
"A hardware probe is a device used in the development and debugging of "
"embedded systems to facilitate communication between a host computer and the "
"target embedded device. It typically supports protocols like JTAG or SWD, "
"enabling it to program, debug, and analyze the microcontroller or "
"microprocessor on the embedded system. Hardware probes are crucial for "
"developers to set breakpoints, step through code, and inspect memory and "
"processor registers, effectively allowing them to diagnose and fix issues in "
"real-time."
msgstr "í•˜ë“œì›¨ì–´ í”„ë¡œë¸ŒëŠ” í˜¸ìŠ¤íŠ¸ ì»´í“¨í„°ì™€ ëŒ€ìƒ ì„ë² ë””ë“œ ì¥ì¹˜ ê°„ì˜ í†µì‹ ì„ ìš©ì´í•˜ê²Œ í•˜ê¸° ìœ„í•´ ì„ë² ë””ë“œ ì‹œìŠ¤í…œ ê°œë°œ ë° ë””ë²„ê¹…ì— ì‚¬ìš©ë˜ëŠ” ì¥ì¹˜ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ JTAG ë˜ëŠ” SWDì™€ ê°™ì€ í”„ë¡œí† ì½œì„ ì§€ì›í•˜ì—¬ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ë˜ëŠ” ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œë¥¼ í”„ë¡œê·¸ë˜ë°, ë””ë²„ê¹… ë° ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ í”„ë¡œë¸ŒëŠ” ê°œë°œìê°€ ì¤‘ë‹¨ì ì„ ì„¤ì •í•˜ê³ , ì½”ë“œë¥¼ ë‹¨ê³„ë³„ë¡œ ì‹¤í–‰í•˜ê³ , ë©”ëª¨ë¦¬ ë° í”„ë¡œì„¸ì„œ ë ˆì§€ìŠ¤í„°ë¥¼ ê²€ì‚¬í•˜ì—¬ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¬¸ì œë¥¼ ì§„ë‹¨í•˜ê³  í•´ê²°í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë° ì¤‘ìš”í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:98
msgid "Rusty-probe"
msgstr "Rusty-probe"

#: src/intro/tooling.md:100
msgid ""
"Rusty-probe is an open-sourced USB-based hardware debugging probe designed "
"to work with probe-rs. The combination of Rusty-Probe and probe-rs provides "
"an easy-to-use, cost-effective solution for developers working with embedded "
"Rust applications."
msgstr "Rusty-probeëŠ” probe-rsì™€ í•¨ê»˜ ì‘ë™í•˜ë„ë¡ ì„¤ê³„ëœ ì˜¤í”ˆ ì†ŒìŠ¤ USB ê¸°ë°˜ í•˜ë“œì›¨ì–´ ë””ë²„ê¹… í”„ë¡œë¸Œì…ë‹ˆë‹¤. Rusty-Probeì™€ probe-rsì˜ ì¡°í•©ì€ ì„ë² ë””ë“œ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•˜ëŠ” ê°œë°œìë¥¼ ìœ„í•œ ì‚¬ìš©í•˜ê¸° ì‰½ê³  ë¹„ìš© íš¨ìœ¨ì ì¸ ì†”ë£¨ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/intro/tooling.md:102
msgid "ST-Link"
msgstr "ST-Link"

#: src/intro/tooling.md:104
msgid ""
"The ST-Link is a popular debugging and programming probe developed by "
"STMicroelectronics primarily for their STM32 and STM8 microcontroller "
"series. It supports both debugging and programming via JTAG or SWD (Serial "
"Wire Debug) interfaces. ST-Link is widely used due to its direct support "
"from STMicroelectronics' extensive range of development boards and its "
"integration into major IDEs, making it a convenient choice for developers "
"working with STM microcontrollers."
msgstr "ST-LinkëŠ” STMicroelectronicsì—ì„œ ì£¼ë¡œ STM32 ë° STM8 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ì‹œë¦¬ì¦ˆë¥¼ ìœ„í•´ ê°œë°œí•œ ì¸ê¸° ìˆëŠ” ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë° í”„ë¡œë¸Œì…ë‹ˆë‹¤. JTAG ë˜ëŠ” SWD(Serial Wire Debug) ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë°ì„ ëª¨ë‘ ì§€ì›í•©ë‹ˆë‹¤. ST-LinkëŠ” STMicroelectronicsì˜ ê´‘ë²”ìœ„í•œ ê°œë°œ ë³´ë“œì—ì„œ ì§ì ‘ ì§€ì›í•˜ê³  ì£¼ìš” IDEì— í†µí•©ë˜ì–´ STM ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê°œë°œìì—ê²Œ í¸ë¦¬í•œ ì„ íƒì´ë¯€ë¡œ ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:106
msgid "J-Link"
msgstr "J-Link"

#: src/intro/tooling.md:108
msgid ""
"J-Link, developed by SEGGER Microcontroller, is a robust and versatile "
"debugger supporting a wide range of CPU cores and devices beyond just ARM, "
"such as RISC-V. Known for its high performance and reliability, J-Link "
"supports various communication interfaces, including JTAG, SWD, and fine-"
"pitch JTAG interfaces. It is favored for its advanced features like "
"unlimited breakpoints in flash memory and its compatibility with a multitude "
"of development environments."
msgstr "SEGGER Microcontrollerì—ì„œ ê°œë°œí•œ J-LinkëŠ” RISC-Vì™€ ê°™ì€ ARM ì™¸ì—ë„ ê´‘ë²”ìœ„í•œ CPU ì½”ì–´ ë° ì¥ì¹˜ë¥¼ ì§€ì›í•˜ëŠ” ê°•ë ¥í•˜ê³  ë‹¤ì¬ë‹¤ëŠ¥í•œ ë””ë²„ê±°ì…ë‹ˆë‹¤. ê³ ì„±ëŠ¥ê³¼ ì‹ ë¢°ì„±ìœ¼ë¡œ ìœ ëª…í•œ J-LinkëŠ” JTAG, SWD ë° ë¯¸ì„¸ í”¼ì¹˜ JTAG ì¸í„°í˜ì´ìŠ¤ë¥¼ í¬í•¨í•œ ë‹¤ì–‘í•œ í†µì‹  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. í”Œë˜ì‹œ ë©”ëª¨ë¦¬ì˜ ë¬´ì œí•œ ì¤‘ë‹¨ì ê³¼ ë‹¤ì–‘í•œ ê°œë°œ í™˜ê²½ê³¼ì˜ í˜¸í™˜ì„±ê³¼ ê°™ì€ ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ ì„ í˜¸ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:110
msgid "MCU-Link"
msgstr "MCU-Link"

#: src/intro/tooling.md:112
msgid ""
"MCU-Link is a debugging probe that also functions as a programmer, provided "
"by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers "
"and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-"
"Link is particularly notable for its versatility and affordability, making "
"it an accessible option for hobbyists, educators, and professional "
"developers alike."
msgstr "MCU-LinkëŠ” NXP Semiconductorsì—ì„œ ì œê³µí•˜ëŠ” í”„ë¡œê·¸ë˜ë¨¸ ì—­í• ë„ í•˜ëŠ” ë””ë²„ê¹… í”„ë¡œë¸Œì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ ARM Cortex ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì§€ì›í•˜ë©° MCUXpresso IDEì™€ ê°™ì€ ê°œë°œ ë„êµ¬ì™€ ì›í™œí•˜ê²Œ ì¸í„°í˜ì´ìŠ¤í•©ë‹ˆë‹¤. MCU-LinkëŠ” íŠ¹íˆ ë‹¤ìš©ë„ì„±ê³¼ ê²½ì œì„±ìœ¼ë¡œ ìœ ëª…í•˜ì—¬ ì·¨ë¯¸ ê°œë°œì, êµìœ¡ì ë° ì „ë¬¸ ê°œë°œì ëª¨ë‘ì—ê²Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì˜µì…˜ì…ë‹ˆë‹¤."

#: src/intro/install.md:1
msgid "Installing the tools"
msgstr "ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install.md:3
msgid ""
"This page contains OS-agnostic installation instructions for a few of the "
"tools:"
msgstr "ì´ í˜ì´ì§€ì—ëŠ” ëª‡ ê°€ì§€ ë„êµ¬ì— ëŒ€í•œ OS ë…ë¦½ì ì¸ ì„¤ì¹˜ ì§€ì¹¨ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install.md:5
msgid "Rust Toolchain"
msgstr "Rust íˆ´ì²´ì¸"

#: src/intro/install.md:7
msgid ""
"Install rustup by following the instructions at [https://rustup.rs](https://"
"rustup.rs)."
msgstr "[https://rustup.rs](https://rustup.rs)ì˜ ì§€ì¹¨ì— ë”°ë¼ rustupì„ ì„¤ì¹˜í•˜ì„¸ìš”."

#: src/intro/install.md:9
msgid ""
"**NOTE** Make sure you have a compiler version equal to or newer than "
"`1.31`. `rustc -V` should return a date newer than the one shown below."
msgstr "**ì°¸ê³ ** ì»´íŒŒì¼ëŸ¬ ë²„ì „ì´ `1.31` ì´ìƒì¸ì§€ í™•ì¸í•˜ì„¸ìš”. `rustc -V`ëŠ” ì•„ë˜ í‘œì‹œëœ ë‚ ì§œë³´ë‹¤ ìµœì‹  ë‚ ì§œë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/install.md:17
msgid ""
"For bandwidth and disk usage concerns the default installation only supports "
"native compilation. To add cross compilation support for the ARM Cortex-M "
"architectures choose one of the following compilation targets. For the "
"STM32F3DISCOVERY board used for the examples in this book, use the "
"`thumbv7em-none-eabihf` target. [Find the best Cortex-M for you.](https://"
"developer.arm.com/ip-products/processors/cortex-"
"m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"
msgstr "ëŒ€ì—­í­ ë° ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ ë¬¸ì œë¡œ ì¸í•´ ê¸°ë³¸ ì„¤ì¹˜ëŠ” ë„¤ì´í‹°ë¸Œ ì»´íŒŒì¼ë§Œ ì§€ì›í•©ë‹ˆë‹¤. ARM Cortex-M ì•„í‚¤í…ì²˜ì— ëŒ€í•œ í¬ë¡œìŠ¤ ì»´íŒŒì¼ ì§€ì›ì„ ì¶”ê°€í•˜ë ¤ë©´ ë‹¤ìŒ ì»´íŒŒì¼ ëŒ€ìƒ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”. ì´ ì±…ì˜ ì˜ˆì œì— ì‚¬ìš©ëœ STM32F3DISCOVERY ë³´ë“œì˜ ê²½ìš° `thumbv7em-none-eabihf` ëŒ€ìƒì„ ì‚¬ìš©í•˜ì„¸ìš”. [ìì‹ ì—ê²Œ ê°€ì¥ ì í•©í•œ Cortex-Mì„ ì°¾ìœ¼ì„¸ìš”.](https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"

#: src/intro/install.md:23
msgid "Cortex-M0, M0+, and M1 (ARMv6-M architecture):"
msgstr "Cortex-M0, M0+, M1 (ARMv6-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:28
msgid "Cortex-M3 (ARMv7-M architecture):"
msgstr "Cortex-M3 (ARMv7-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:33
msgid ""
"Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ì—†ëŠ” Cortex-M4 ë° M7 (ARMv7E-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:38
msgid ""
"Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ìˆëŠ” Cortex-M4F ë° M7F (ARMv7E-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:43
msgid "Cortex-M23 (ARMv8-M architecture):"
msgstr "Cortex-M23 (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:48
msgid "Cortex-M33 and M35P (ARMv8-M architecture):"
msgstr "Cortex-M33 ë° M35P (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:53
msgid ""
"Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ìˆëŠ” Cortex-M33F ë° M35PF (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:66
msgid ""
"WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. "
"https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=16"
msgstr "WINDOWS: Visual Studio 2019ìš© C++ ë¹Œë“œ ë„êµ¬ í•„ìˆ˜ êµ¬ì„± ìš”ì†Œê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16"

#: src/intro/install.md:67
msgid "`cargo-generate`"
msgstr "`cargo-generate`"

#: src/intro/install.md:69
msgid "We'll use this later to generate a project from a template."
msgstr "ë‚˜ì¤‘ì— í…œí”Œë¦¿ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤."

#: src/intro/install.md:75
msgid ""
"Note: on some Linux distros (e.g. Ubuntu) you may need to install the "
"packages `libssl-dev` and `pkg-config` prior to installing cargo-generate."
msgstr "ì°¸ê³ : ì¼ë¶€ Linux ë°°í¬íŒ(ì˜ˆ: Ubuntu)ì—ì„œëŠ” cargo-generateë¥¼ ì„¤ì¹˜í•˜ê¸° ì „ì— `libssl-dev` ë° `pkg-config` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install.md:77
msgid "OS-Specific Instructions"
msgstr "OSë³„ ì§€ì¹¨"

#: src/intro/install.md:79
msgid "Now follow the instructions specific to the OS you are using:"
msgstr "ì´ì œ ì‚¬ìš© ì¤‘ì¸ OSì— íŠ¹ì •í•œ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”:"

#: src/intro/install.md:81
msgid "[Linux](install/linux.md)"
msgstr "[ë¦¬ëˆ…ìŠ¤](install/linux.md)"

#: src/intro/install.md:82
msgid "[Windows](install/windows.md)"
msgstr "[ìœˆë„ìš°](install/windows.md)"

#: src/intro/install.md:83
msgid "[macOS](install/macos.md)"
msgstr "[macOS](install/macos.md)"

#: src/intro/install/linux.md:3
msgid "Here are the installation commands for a few Linux distributions."
msgstr "ë‹¤ìŒì€ ëª‡ ê°€ì§€ Linux ë°°í¬íŒì— ëŒ€í•œ ì„¤ì¹˜ ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:5
msgid "Packages"
msgstr "íŒ¨í‚¤ì§€"

#: src/intro/install/linux.md:7
msgid "Ubuntu 18.04 or newer / Debian stretch or newer"
msgstr "Ubuntu 18.04 ì´ìƒ / Debian stretch ì´ìƒ"

#: src/intro/install/linux.md:9
msgid ""
"**NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `gdb-multiarch`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:26
msgid "Ubuntu 14.04 and 16.04"
msgstr "Ubuntu 14.04 ë° 16.04"

#: src/intro/install/linux.md:28
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `arm-none-eabi-gdb`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:40
msgid "Fedora 27 or newer"
msgstr "Fedora 27 ì´ìƒ"

#: src/intro/install/linux.md:51
msgid "Arch Linux"
msgstr "Arch Linux"

#: src/intro/install/linux.md:53
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `arm-none-eabi-gdb`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:60
msgid "udev rules"
msgstr "udev ê·œì¹™"

#: src/intro/install/linux.md:62
msgid ""
"This rule lets you use OpenOCD with the Discovery board without root "
"privilege."
msgstr "ì´ ê·œì¹™ì„ ì‚¬ìš©í•˜ë©´ ë£¨íŠ¸ ê¶Œí•œ ì—†ì´ Discovery ë³´ë“œì™€ í•¨ê»˜ OpenOCDë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/linux.md:64
msgid ""
"Create the file `/etc/udev/rules.d/70-st-link.rules` with the contents shown "
"below."
msgstr "ì•„ë˜ì— í‘œì‹œëœ ë‚´ìš©ìœ¼ë¡œ `/etc/udev/rules.d/70-st-link.rules` íŒŒì¼ì„ ìƒì„±í•˜ì„¸ìš”."

#: src/intro/install/linux.md:66
msgid ""
"```text\n"
"# STM32F3DISCOVERY rev A/B - ST-LINK/V2\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n"
"\n"
"# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n"
"```"
msgstr "```text\n# STM32F3DISCOVERY rev A/B - ST-LINK/V2\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n\n# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n```"

#: src/intro/install/linux.md:74
msgid "Then reload all the udev rules with:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ ëª¨ë“  udev ê·œì¹™ì„ ë‹¤ì‹œ ë¡œë“œí•˜ì„¸ìš”:"

#: src/intro/install/linux.md:80
msgid ""
"If you had the board plugged to your laptop, unplug it and then plug it "
"again."
msgstr "ë³´ë“œê°€ ë…¸íŠ¸ë¶ì— ì—°ê²°ë˜ì–´ ìˆì—ˆë‹¤ë©´, í”ŒëŸ¬ê·¸ë¥¼ ë½‘ì•˜ë‹¤ê°€ ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”."

#: src/intro/install/linux.md:82
msgid "You can check the permissions by running this command:"
msgstr "ì´ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì—¬ ê¶Œí•œì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/linux.md:88
msgid "Which should show something like"
msgstr "ë‹¤ìŒê³¼ ê°™ì´ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/install/linux.md:96
msgid ""
"Take note of the bus and device numbers. Use those numbers to create a path "
"like `/dev/bus/usb/<bus>/<device>`. Then use this path like so:"
msgstr "ë²„ìŠ¤ ë° ì¥ì¹˜ ë²ˆí˜¸ë¥¼ ê¸°ë¡í•´ ë‘ì„¸ìš”. ì´ ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ `/dev/bus/usb/<bus>/<device>`ì™€ ê°™ì€ ê²½ë¡œë¥¼ ìƒì„±í•˜ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ì´ ê²½ë¡œë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•˜ì„¸ìš”:"

#: src/intro/install/linux.md:116
msgid ""
"The `+` appended to permissions indicates the existence of an extended "
"permission. The `getfacl` command tells the user `you` can make use of this "
"device."
msgstr "ê¶Œí•œì— ì¶”ê°€ëœ `+`ëŠ” í™•ì¥ ê¶Œí•œì˜ ì¡´ì¬ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. `getfacl` ëª…ë ¹ì€ ì‚¬ìš©ì `ë‹¹ì‹ `ì´ ì´ ì¥ì¹˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/install/linux.md:120
msgid "Now, go to the [next section](verify.md)."
msgstr "ì´ì œ [ë‹¤ìŒ ì„¹ì…˜](verify.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/macos.md:1
msgid "macOS"
msgstr "macOS"

#: src/intro/install/macos.md:3
msgid ""
"All the tools can be installed using [Homebrew](http://brew.sh/) or "
"[MacPorts](https://www.macports.org/):"
msgstr "ëª¨ë“  ë„êµ¬ëŠ” [Homebrew](http://brew.sh/) ë˜ëŠ” [MacPorts](https://www.macports.org/)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/macos.md:8
msgid "Install tools with [Homebrew](http://brew.sh/)"
msgstr "[Homebrew](http://brew.sh/)ë¡œ ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install/macos.md:21
msgid ""
"**NOTE** If OpenOCD crashes you may need to install the latest version using:"
msgstr "**ì°¸ê³ ** OpenOCDê°€ ì¶©ëŒí•˜ë©´ ë‹¤ìŒì„ ì‚¬ìš©í•˜ì—¬ ìµœì‹  ë²„ì „ì„ ì„¤ì¹˜í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/macos.md:26
msgid "Install tools with [MacPorts](https://www.macports.org/)"
msgstr "[MacPorts](https://www.macports.org/)ë¡œ ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install/macos.md:41 src/intro/install/windows.md:48
msgid "That's all! Go to the [next section](verify.md)."
msgstr "ê·¸ê²Œ ë‹¤ì…ë‹ˆë‹¤! [ë‹¤ìŒ ì„¹ì…˜](verify.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/windows.md:3
msgid "`arm-none-eabi-gdb`"
msgstr "`arm-none-eabi-gdb`"

#: src/intro/install/windows.md:5
msgid ""
"ARM provides `.exe` installers for Windows. Grab one from [here](https://"
"developer.arm.com/downloads/-/arm-gnu-toolchain-downloads), and follow the "
"instructions. Just before the installation process finishes tick/select the "
"\"Add path to environment variable\" option. Then verify that the tools are "
"in your `%PATH%`:"
msgstr "ARMì€ Windowsìš© `.exe` ì„¤ì¹˜ í”„ë¡œê·¸ë¨ì„ ì œê³µí•©ë‹ˆë‹¤. [ì—¬ê¸°](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)ì—ì„œ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”. ì„¤ì¹˜ í”„ë¡œì„¸ìŠ¤ê°€ ëë‚˜ê¸° ì§ì „ì— "í™˜ê²½ ë³€ìˆ˜ì— ê²½ë¡œ ì¶”ê°€" ì˜µì…˜ì„ ì„ íƒ/ì²´í¬í•˜ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ë„êµ¬ê°€ `%PATH%`ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"

#: src/intro/install/windows.md:17
msgid "OpenOCD"
msgstr "OpenOCD"

#: src/intro/install/windows.md:19
msgid ""
"There's no official binary release of OpenOCD for Windows but if you're not "
"in the mood to compile it yourself, the xPack project provides a binary "
"distribution, [here](https://xpack.github.io/openocd/). Follow the provided "
"installation instructions. Then update your `%PATH%` environment variable to "
"include the path where the binaries were installed. (`C:"
"\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-"
"tools\\openocd\\0.10.0-13.1\\.content\\bin\\`, if you've been using the easy "
"install)"
msgstr "Windowsìš© OpenOCD ê³µì‹ ë°”ì´ë„ˆë¦¬ ë¦´ë¦¬ìŠ¤ëŠ” ì—†ì§€ë§Œ ì§ì ‘ ì»´íŒŒì¼í•  ì˜í–¥ì´ ì—†ë‹¤ë©´ xPack í”„ë¡œì íŠ¸ì—ì„œ [ì—¬ê¸°](https://xpack.github.io/openocd/)ì—ì„œ ë°”ì´ë„ˆë¦¬ ë°°í¬íŒì„ ì œê³µí•©ë‹ˆë‹¤. ì œê³µëœ ì„¤ì¹˜ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ë°”ì´ë„ˆë¦¬ê°€ ì„¤ì¹˜ëœ ê²½ë¡œë¥¼ í¬í•¨í•˜ë„ë¡ `%PATH%` í™˜ê²½ ë³€ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”. (ì‰¬ìš´ ì„¤ì¹˜ë¥¼ ì‚¬ìš©í–ˆë‹¤ë©´ `C:\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-tools\\openocd\\0.10.0-13.1\\.content\\bin\\`)"

#: src/intro/install/windows.md:27
msgid "Verify that OpenOCD is in your `%PATH%` with:"
msgstr "ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ OpenOCDê°€ `%PATH%`ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"

#: src/intro/install/windows.md:37
msgid ""
"Grab QEMU from [the official website](https://www.qemu.org/download/"
"#windows)."
msgstr "[ê³µì‹ ì›¹ì‚¬ì´íŠ¸](https://www.qemu.org/download/#windows)ì—ì„œ QEMUë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”."

#: src/intro/install/windows.md:41
msgid "ST-LINK USB driver"
msgstr "ST-LINK USB ë“œë¼ì´ë²„"

#: src/intro/install/windows.md:43
msgid ""
"You'll also need to install [this USB driver](http://www.st.com/en/embedded-"
"software/stsw-link009.html) or OpenOCD won't work. Follow the installer "
"instructions and make sure you install the right version (32-bit or 64-bit) "
"of the driver."
msgstr "ë˜í•œ [ì´ USB ë“œë¼ì´ë²„](http://www.st.com/en/embedded-software/stsw-link009.html)ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ OpenOCDê°€ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì„¤ì¹˜ í”„ë¡œê·¸ë¨ ì§€ì¹¨ì„ ë”°ë¥´ê³  ì˜¬ë°”ë¥¸ ë²„ì „(32ë¹„íŠ¸ ë˜ëŠ” 64ë¹„íŠ¸)ì˜ ë“œë¼ì´ë²„ë¥¼ ì„¤ì¹˜í–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/intro/install/verify.md:3
msgid ""
"In this section we check that some of the required tools / drivers have been "
"correctly installed and configured."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” í•„ìš”í•œ ë„êµ¬/ë“œë¼ì´ë²„ ì¤‘ ì¼ë¶€ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì¹˜ ë° êµ¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."

#: src/intro/install/verify.md:6
msgid ""
"Connect your laptop / PC to the discovery board using a Mini-USB USB cable. "
"The discovery board has two USB connectors; use the one labeled \"USB ST-"
"LINK\" that sits on the center of the edge of the board."
msgstr "ë¯¸ë‹ˆ USB ì¼€ì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ ë…¸íŠ¸ë¶/PCë¥¼ ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì— ì—°ê²°í•˜ì„¸ìš”. ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì—ëŠ” ë‘ ê°œì˜ USB ì»¤ë„¥í„°ê°€ ìˆìŠµë‹ˆë‹¤. ë³´ë“œ ê°€ì¥ìë¦¬ ì¤‘ì•™ì— ìˆëŠ” \"USB ST-LINK\"ë¼ê³  í‘œì‹œëœ ì»¤ë„¥í„°ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/intro/install/verify.md:10
msgid ""
"Also check that the ST-LINK header is populated. See the picture below; the "
"ST-LINK header is highlighted."
msgstr "ë˜í•œ ST-LINK í—¤ë”ê°€ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. ì•„ë˜ ê·¸ë¦¼ì„ ì°¸ì¡°í•˜ì„¸ìš”. ST-LINK í—¤ë”ê°€ ê°•ì¡° í‘œì‹œë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:17
msgid "Now run the following command:"
msgstr "ì´ì œ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"

#: src/intro/install/verify.md:23
msgid ""
"**NOTE**: Old versions of openocd, including the 0.10.0 release from 2017, "
"do not contain the new (and preferable) `interface/stlink.cfg` file; instead "
"you may need to use `interface/stlink-v2.cfg` or `interface/stlink-v2-1.cfg`."
msgstr "**ì°¸ê³ **: 2017ë…„ 0.10.0 ë¦´ë¦¬ìŠ¤ë¥¼ í¬í•¨í•œ ì´ì „ ë²„ì „ì˜ OpenOCDì—ëŠ” ìƒˆë¡­ê³  ì„ í˜¸ë˜ëŠ” `interface/stlink.cfg` íŒŒì¼ì´ í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  `interface/stlink-v2.cfg` ë˜ëŠ” `interface/stlink-v2-1.cfg`ë¥¼ ì‚¬ìš©í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:27
msgid ""
"You should get the following output and the program should block the console:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ì´ í‘œì‹œë˜ê³  í”„ë¡œê·¸ë¨ì´ ì½˜ì†”ì„ ì°¨ë‹¨í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/intro/install/verify.md:29
msgid ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr "```text\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nInfo : auto-selecting first available session transport \"hla_swd\". To override use 'transport select <transport>'.\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\nInfo : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD\nnone separate\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : clock speed 950 kHz\nInfo : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\nInfo : using stlink api v2\nInfo : Target voltage: 2.919881\nInfo : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n```"

#: src/intro/install/verify.md:48
msgid ""
"The contents may not match exactly but you should get the last line about "
"breakpoints and watchpoints. If you got it then terminate the OpenOCD "
"process and move to the [next section](../../start/index.md)."
msgstr "ë‚´ìš©ì´ ì •í™•íˆ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ ì¤‘ë‹¨ì  ë° ê°ì‹œì ì— ëŒ€í•œ ë§ˆì§€ë§‰ ì¤„ì´ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ì¤„ì´ í‘œì‹œë˜ë©´ OpenOCD í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ê³  [ë‹¤ìŒ ì„¹ì…˜](../../start/index.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/verify.md:54
msgid ""
"If you didn't get the "breakpoints" line then try one of the following "
"commands."
msgstr "breakpoints" ì¤„ì´ í‘œì‹œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ìŒ ëª…ë ¹ ì¤‘ í•˜ë‚˜ë¥¼ ì‹œë„í•´ ë³´ì„¸ìš”."

#: src/intro/install/verify.md:64
msgid ""
"If one of those commands works it means you got an old hardware revision of "
"the discovery board. That won't be a problem but commit that fact to memory "
"as you'll need to configure things a bit differently later on. You can move "
"to the [next section](../../start/index.md)."
msgstr "ì´ ëª…ë ¹ ì¤‘ í•˜ë‚˜ê°€ ì‘ë™í•œë‹¤ë©´ Discovery ë³´ë“œì˜ ì´ì „ í•˜ë“œì›¨ì–´ ê°œì •íŒì„ ì‚¬ìš©í•˜ê³  ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ì´ëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ ë‚˜ì¤‘ì— ì„¤ì •ì„ ì•½ê°„ ë‹¤ë¥´ê²Œ êµ¬ì„±í•´ì•¼ í•˜ë¯€ë¡œ ì´ ì‚¬ì‹¤ì„ ê¸°ì–µí•´ ë‘ì„¸ìš”. [ë‹¤ìŒ ì„¹ì…˜](../../start/index.md)ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:69
msgid ""
"If none of the commands work as a normal user then try to run them with root "
"permission (e.g. `sudo openocd ..`). If the commands do work with root "
"permission then check that the [udev rules](linux.md#udev-rules) have been "
"correctly set."
msgstr "ì¼ë°˜ ì‚¬ìš©ìë¡œëŠ” ì–´ë–¤ ëª…ë ¹ë„ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë£¨íŠ¸ ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•´ ë³´ì„¸ìš”(ì˜ˆ: `sudo openocd ..`). ëª…ë ¹ì´ ë£¨íŠ¸ ê¶Œí•œìœ¼ë¡œ ì‘ë™í•œë‹¤ë©´ [udev ê·œì¹™](linux.md#udev-rules)ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/intro/install/verify.md:75
msgid ""
"If you have reached this point and OpenOCD is not working please open [an "
"issue](https://github.com/rust-embedded/book/issues) and we'll help you out!"
msgstr "ì´ ì‹œì ê¹Œì§€ OpenOCDê°€ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ [ì´ìŠˆ](https://github.com/rust-embedded/book/issues)ë¥¼ ì—´ì–´ì£¼ì„¸ìš”. ì €í¬ê°€ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!"

#: src/start/index.md:1
msgid "Getting Started"
msgstr "ì‹œì‘í•˜ê¸°"

#: src/start/index.md:3
msgid ""
"In this section we'll walk you through the process of writing, building, "
"flashing and debugging embedded programs. You will be able to try most of "
"the examples without any special hardware as we will show you the basics "
"using QEMU, a popular open-source hardware emulator. The only section where "
"hardware is required is, naturally enough, the [Hardware](./hardware.md) "
"section, where we use OpenOCD to program an [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html)."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±, ë¹Œë“œ, í”Œë˜ì‹± ë° ë””ë²„ê¹…í•˜ëŠ” ê³¼ì •ì„ ì•ˆë‚´í•©ë‹ˆë‹¤. ì¸ê¸° ìˆëŠ” ì˜¤í”ˆ ì†ŒìŠ¤ í•˜ë“œì›¨ì–´ ì—ë®¬ë ˆì´í„°ì¸ QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ ì‚¬í•­ì„ ë³´ì—¬ì£¼ë¯€ë¡œ íŠ¹ë³„í•œ í•˜ë“œì›¨ì–´ ì—†ì´ë„ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œë¥¼ ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ê°€ í•„ìš”í•œ ìœ ì¼í•œ ì„¹ì…˜ì€ ë‹¹ì—°íˆ OpenOCDë¥¼ ì‚¬ìš©í•˜ì—¬ [STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html)ë¥¼ í”„ë¡œê·¸ë˜ë°í•˜ëŠ” [í•˜ë“œì›¨ì–´](./hardware.md) ì„¹ì…˜ì…ë‹ˆë‹¤."

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""
"[LM3S6965](http://www.ti.com/product/"
"LM3S6965), Cortex-M3 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ìœ„í•œ í”„ë¡œê·¸ë¨ ì‘ì„±ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤. "
"ì´ë¥¼ ì´ˆê¸° íƒ€ê²Ÿìœ¼ë¡œ ì„ íƒí•œ ì´ìœ ëŠ” QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ [ì—ë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆê¸°](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) ë•Œë¬¸ì— ì´ ì„¹ì…˜ì—ì„œëŠ” "
"í•˜ë“œì›¨ì–´ë¥¼ ë§Œì§ˆ í•„ìš”ê°€ ì—†ê³  íˆ´ë§ê³¼ "
"ê°œë°œ ê³¼ì •ì— ì§‘ì¤‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""
"**ì¤‘ìš”** ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” í”„ë¡œì íŠ¸ ì´ë¦„ìœ¼ë¡œ \"app\"ì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤. "
"\"app\"ì´ë¼ëŠ” ë‹¨ì–´ë¥¼ ë³¼ ë•Œë§ˆë‹¤ í”„ë¡œì íŠ¸ì— ëŒ€í•´ ì„ íƒí•œ "
"ì´ë¦„ìœ¼ë¡œ ë°”ê¿”ì•¼ í•©ë‹ˆë‹¤. ë˜ëŠ” í”„ë¡œì íŠ¸ ì´ë¦„ì„ "
"\"app\"ìœ¼ë¡œ ì§€ì •í•˜ì—¬ ì¹˜í™˜ì„ í”¼í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr "ë¹„í‘œì¤€ Rust í”„ë¡œê·¸ë¨ ë§Œë“¤ê¸°"

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""
"[`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) í”„ë¡œì íŠ¸ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê² ìŠµë‹ˆë‹¤. "
"ìƒì„±ëœ í”„ë¡œì íŠ¸ëŠ” ê¸°ë³¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ í¬í•¨í•  ê²ƒì…ë‹ˆë‹¤: ìƒˆë¡œìš´ ì„ë² ë””ë“œ rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ìœ„í•œ "
"ì¢‹ì€ ì‹œì‘ì ì…ë‹ˆë‹¤. ë˜í•œ í”„ë¡œì íŠ¸ì—ëŠ” "
"í•µì‹¬ ì„ë² ë””ë“œ rust ê¸°ëŠ¥ì„ ê°•ì¡°í•˜ëŠ” ì—¬ëŸ¬ ê°œë³„ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìˆëŠ” "
"`examples` ë””ë ‰í† ë¦¬ê°€ í¬í•¨ë©ë‹ˆë‹¤."

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "`cargo-generate` ì‚¬ìš©í•˜ê¸°"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "ë¨¼ì € cargo-generateë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "`git` ì‚¬ìš©í•˜ê¸°"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr "ì €ì¥ì†Œë¥¼ í´ë¡ í•˜ì„¸ìš”"

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr "ê·¸ëŸ° ë‹¤ìŒ `Cargo.toml` íŒŒì¼ì˜ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì±„ìš°ì„¸ìš”"

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"

#: src/start/qemu.md:72
msgid "Using neither"
msgstr "ë‘˜ ë‹¤ ì‚¬ìš©í•˜ì§€ ì•Šê¸°"

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""
"`cortex-m-quickstart` í…œí”Œë¦¿ì˜ ìµœì‹  ìŠ¤ëƒ…ìƒ·ì„ ê°€ì ¸ì™€ì„œ "
"ì••ì¶•ì„ í•´ì œí•˜ì„¸ìš”."

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""
"ë˜ëŠ” [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart)ë¡œ ì´ë™í•˜ì—¬ ë…¹ìƒ‰ \"Clone or download\" ë²„íŠ¼ì„ í´ë¦­í•œ ë‹¤ìŒ "
"\"Download ZIP\"ì„ í´ë¦­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr "ê·¸ëŸ° ë‹¤ìŒ "`git` ì‚¬ìš©í•˜ê¸°" ë²„ì „ì˜ ë‘ ë²ˆì§¸ ë¶€ë¶„ì—ì„œ ìˆ˜í–‰í•œ ëŒ€ë¡œ `Cargo.toml` íŒŒì¼ì˜ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì±„ìš°ì„¸ìš”."

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr "í”„ë¡œê·¸ë¨ ê°œìš”"

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr "í¸ì˜ë¥¼ ìœ„í•´ `src/main.rs`ì˜ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ì†Œê°œí•©ë‹ˆë‹¤:"

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr "// ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”\n"

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr "ì´ í”„ë¡œê·¸ë¨ì€ í‘œì¤€ Rust í”„ë¡œê·¸ë¨ê³¼ ì•½ê°„ ë‹¤ë¥´ë¯€ë¡œ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr "`#![no_std]`ëŠ” ì´ í”„ë¡œê·¸ë¨ì´ í‘œì¤€ í¬ë ˆì´íŠ¸ì¸ `std`ì— ë§í¬ë˜ì§€ ì•Šì„ ê²ƒì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ëŒ€ì‹  ê·¸ í•˜ìœ„ ì§‘í•©ì¸ `core` í¬ë ˆì´íŠ¸ì— ë§í¬ë  ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr "`#![no_main]`ì€ ì´ í”„ë¡œê·¸ë¨ì´ ëŒ€ë¶€ë¶„ì˜ Rust í”„ë¡œê·¸ë¨ì´ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²ƒì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. `no_main`ì„ ì‚¬ìš©í•˜ëŠ” ì£¼ëœ ì´ìœ ëŠ” `no_std` ì»¨í…ìŠ¤íŠ¸ì—ì„œ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ nightlyê°€ í•„ìš”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr "`use panic_halt as _;`. ì´ í¬ë ˆì´íŠ¸ëŠ” í”„ë¡œê·¸ë¨ì˜ íŒ¨ë‹‰ ë™ì‘ì„ ì •ì˜í•˜ëŠ” `panic_handler`ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” ì±…ì˜ [íŒ¨ë‹‰](panicking.md) ì¥ì—ì„œ ë” ìì„¸íˆ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr "[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html)ëŠ” í”„ë¡œê·¸ë¨ì˜ ì§„ì…ì ì„ í‘œì‹œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” [`cortex-m-rt`](https://crates.io/crates/cortex-m-rt) í¬ë ˆì´íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ì†ì„±ì…ë‹ˆë‹¤. í‘œì¤€ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í”„ë¡œê·¸ë¨ì˜ ì§„ì…ì ì„ ë‚˜íƒ€ë‚´ëŠ” ë‹¤ë¥¸ ë°©ë²•ì´ í•„ìš”í•˜ë©°, ê·¸ê²ƒì´ `#[entry]`ì…ë‹ˆë‹¤."

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr "`fn main() -> !`. ìš°ë¦¬ í”„ë¡œê·¸ë¨ì€ ëŒ€ìƒ í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰ë˜ëŠ” _ìœ ì¼í•œ_ í”„ë¡œì„¸ìŠ¤ì´ë¯€ë¡œ ì¢…ë£Œë˜ê¸°ë¥¼ ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤! ì»´íŒŒì¼ ì‹œì ì— ê·¸ë ‡ê²Œ ë  ê²ƒì„ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ [ë°œì‚° í•¨ìˆ˜](https://doc.rust-lang.org/rust-by-example/fn/diverging.html)(í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì˜ `-> !` ë¶€ë¶„)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "í¬ë¡œìŠ¤ ì»´íŒŒì¼"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the "
"`.cargo/config.toml` in the template has the answer:"
msgstr "ë‹¤ìŒ ë‹¨ê³„ëŠ” Cortex-M3 ì•„í‚¤í…ì²˜ìš© í”„ë¡œê·¸ë¨ì„ _í¬ë¡œìŠ¤_ ì»´íŒŒì¼í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì»´íŒŒì¼ ëŒ€ìƒ(`$TRIPLE`)ì´ ë¬´ì—‡ì¸ì§€ ì•ˆë‹¤ë©´ `cargo build --target $TRIPLE`ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒë§Œí¼ ê°„ë‹¨í•©ë‹ˆë‹¤. ë‹¤í–‰íˆ í…œí”Œë¦¿ì˜ `.cargo/config.toml`ì— ë‹µì´ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr "Cortex-M3 ì•„í‚¤í…ì²˜ìš©ìœ¼ë¡œ í¬ë¡œìŠ¤ ì»´íŒŒì¼í•˜ë ¤ë©´ `thumbv7m-none-eabi`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ëŒ€ìƒì€ Rust íˆ´ì²´ì¸ì„ ì„¤ì¹˜í•  ë•Œ ìë™ìœ¼ë¡œ ì„¤ì¹˜ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì•„ì§ ì¶”ê°€í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì§€ê¸ˆ íˆ´ì²´ì¸ì— ì´ ëŒ€ìƒì„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr "`.cargo/config.toml` íŒŒì¼ì— `thumbv7m-none-eabi` ì»´íŒŒì¼ ëŒ€ìƒì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì•„ë˜ ë‘ ëª…ë ¹ì€ ë™ì¼í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤:"

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr "ê²€ì‚¬"

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr "ì´ì œ `target/thumbv7m-none-eabihf/debug/app`ì— ë¹„ë„¤ì´í‹°ë¸Œ ELF ë°”ì´ë„ˆë¦¬ê°€ ìˆìŠµë‹ˆë‹¤. `cargo-binutils`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr "`cargo-readobj`ë¥¼ ì‚¬ìš©í•˜ì—¬ ELF í—¤ë”ë¥¼ ì¶œë ¥í•˜ì—¬ ì´ê²ƒì´ ARM ë°”ì´ë„ˆë¦¬ì„ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:183
msgid "Note that:"
msgstr "ì°¸ê³ :"

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr "`--bin app`ì€ `target/$TRIPLE/debug/app`ì˜ ë°”ì´ë„ˆë¦¬ë¥¼ ê²€ì‚¬í•˜ëŠ” ê°„í¸í•œ ë°©ë²•ì…ë‹ˆë‹¤."

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr "`--bin app`ì€ í•„ìš”í•œ ê²½ìš° ë°”ì´ë„ˆë¦¬ë¥¼ (ì¬)ì»´íŒŒì¼í•©ë‹ˆë‹¤."

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr "`cargo-size`ëŠ” ë°”ì´ë„ˆë¦¬ì˜ ë§ì»¤ ì„¹ì…˜ í¬ê¸°ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr "ìµœì í™”ëœ ë²„ì „ì„ ê²€ì‚¬í•˜ê¸° ìœ„í•´ `--release`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr "ELF ë§ì»¤ ì„¹ì…˜ì— ëŒ€í•œ ë³µìŠµ"

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr "`.text`ëŠ” í”„ë¡œê·¸ë¨ ëª…ë ¹ì–´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr "`.rodata`ëŠ” ë¬¸ìì—´ê³¼ ê°™ì€ ìƒìˆ˜ ê°’ì„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr "`.data`ëŠ” ì´ˆê¸° ê°’ì´ 0ì´ _ì•„ë‹Œ_ ì •ì ìœ¼ë¡œ í• ë‹¹ëœ ë³€ìˆ˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr "`.bss`ëŠ” ì´ˆê¸° ê°’ì´ 0ì¸ ì •ì ìœ¼ë¡œ í• ë‹¹ëœ ë³€ìˆ˜ë„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr "`.vector_table`ì€ ë²¡í„°(ì¸í„°ëŸ½íŠ¸) í…Œì´ë¸”ì„ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” _ë¹„_í‘œì¤€ ì„¹ì…˜ì…ë‹ˆë‹¤."

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr "`.ARM.attributes` ë° `.debug_*` ì„¹ì…˜ì€ ë©”íƒ€ë°ì´í„°ë¥¼ í¬í•¨í•˜ë©° ë°”ì´ë„ˆë¦¬ë¥¼ í”Œë˜ì‹±í•  ë•Œ ëŒ€ìƒì— ë¡œë“œë˜ì§€ _ì•ŠìŠµë‹ˆë‹¤_."

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr "**ì¤‘ìš”**: ELF íŒŒì¼ì€ ë””ë²„ê·¸ ì •ë³´ì™€ ê°™ì€ ë©”íƒ€ë°ì´í„°ë¥¼ í¬í•¨í•˜ë¯€ë¡œ ë””ìŠ¤í¬ìƒì˜ _í¬ê¸°_ëŠ” ì¥ì¹˜ì— í”Œë˜ì‹±ë  ë•Œ í”„ë¡œê·¸ë¨ì´ ì°¨ì§€í•  ê³µê°„ì„ ì •í™•í•˜ê²Œ ë°˜ì˜í•˜ì§€ _ì•ŠìŠµë‹ˆë‹¤_. ë°”ì´ë„ˆë¦¬ì˜ ì‹¤ì œ í¬ê¸°ë¥¼ í™•ì¸í•˜ë ¤ë©´ _í•­ìƒ_ `cargo-size`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr "`cargo-objdump`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°”ì´ë„ˆë¦¬ë¥¼ ì—­ì–´ì…ˆë¸”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr "**ì°¸ê³ ** ìœ„ ëª…ë ¹ì´ `Unknown command line argument`ì— ëŒ€í•´ ë¶ˆí‰í•˜ë©´ ë‹¤ìŒ ë²„ê·¸ ë³´ê³ ì„œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”: https://github.com/rust-embedded/book/issues/269"

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr "**ì°¸ê³ ** ì´ ì¶œë ¥ì€ ì‹œìŠ¤í…œì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. rustc, LLVM ë° ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ìƒˆ ë²„ì „ì€ ë‹¤ë¥¸ ì–´ì…ˆë¸”ë¦¬ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¤ë‹ˆí«ì„ ì‘ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ ì¼ë¶€ ëª…ë ¹ì–´ë¥¼ ì˜ë¼ëƒˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:311
msgid "Running"
msgstr "ì‹¤í–‰ ì¤‘"

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""
"ë‹¤ìŒìœ¼ë¡œ, QEMUì—ì„œ ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤! ì´ë²ˆì—ëŠ” "
"ì‹¤ì œë¡œ ë¬´ì–¸ê°€ë¥¼ í•˜ëŠ” `hello` ì˜ˆì œë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr "í¸ì˜ë¥¼ ìœ„í•´ `examples/hello.rs`ì˜ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì†Œê°œí•©ë‹ˆë‹¤:"

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr "//! ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ ì‚¬ìš©í•˜ì—¬ í˜¸ìŠ¤íŠ¸ ì½˜ì†”ì— \"Hello, world!\"ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤\n"

#: src/start/qemu.md:331 src/start/hardware.md:97 src/start/semihosting.md:26
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""
"// QEMU ì¢…ë£Œ\n"
"    // ì°¸ê³ : í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. OpenOCD ìƒíƒœë¥¼ ì†ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""
"ì´ í”„ë¡œê·¸ë¨ì€ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì´ë¼ëŠ” ê²ƒì„ ì‚¬ìš©í•˜ì—¬ _í˜¸ìŠ¤íŠ¸_ ì½˜ì†”ì— í…ìŠ¤íŠ¸ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤. "
"ì‹¤ì œ í•˜ë“œì›¨ì–´ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ë””ë²„ê·¸ ì„¸ì…˜ì´ í•„ìš”í•˜ì§€ë§Œ QEMUë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ê·¸ëƒ¥ ì‘ë™í•©ë‹ˆë‹¤."

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr "ì˜ˆì œë¥¼ ì»´íŒŒì¼í•˜ì—¬ ì‹œì‘í•´ ë´…ì‹œë‹¤:"

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""
"ì¶œë ¥ ë°”ì´ë„ˆë¦¬ëŠ” `target/thumbv7m-none-eabi/debug/examples/hello`ì— ìœ„ì¹˜í•©ë‹ˆë‹¤."

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr "QEMUì—ì„œ ì´ ë°”ì´ë„ˆë¦¬ë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""
"ëª…ë ¹ì€ í…ìŠ¤íŠ¸ë¥¼ ì¶œë ¥í•œ í›„ ì„±ê³µì ìœ¼ë¡œ ì¢…ë£Œë˜ì–´ì•¼ í•©ë‹ˆë‹¤ (ì¢…ë£Œ ì½”ë“œ = 0). "
"\\*nixì—ì„œëŠ” ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr "QEMU ëª…ë ¹ì„ ë¶„ì„í•´ ë´…ì‹œë‹¤:"

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""
"`qemu-system-arm`. ì´ê²ƒì€ QEMU ì—ë®¬ë ˆì´í„°ì…ë‹ˆë‹¤. ì´ QEMU ë°”ì´ë„ˆë¦¬ì—ëŠ” ëª‡ ê°€ì§€ "
"ë³€í˜•ì´ ìˆìŠµë‹ˆë‹¤. ì´ ë³€í˜•ì€ ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ _ARM_ ë¨¸ì‹ ì˜ ì „ì²´ _ì‹œìŠ¤í…œ_ "
"ì—ë®¬ë ˆì´ì…˜ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""
"`-cpu cortex-m3`. ì´ê²ƒì€ QEMUì—ê²Œ Cortex-M3 CPUë¥¼ ì—ë®¬ë ˆì´íŠ¸í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤. "
"CPU ëª¨ë¸ì„ ì§€ì •í•˜ë©´ ì¼ë¶€ ì˜ëª»ëœ ì»´íŒŒì¼ ì˜¤ë¥˜ë¥¼ ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, "
"í•˜ë“œì›¨ì–´ FPUê°€ ìˆëŠ” Cortex-M4Fìš©ìœ¼ë¡œ ì»´íŒŒì¼ëœ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ QEMUê°€ ì‹¤í–‰ "
"ì¤‘ì— ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""
"`-machine lm3s6965evb`. ì´ê²ƒì€ QEMUì—ê²Œ LM3S6965 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ í¬í•¨í•˜ëŠ” "
"í‰ê°€ ë³´ë“œì¸ LM3S6965EVBë¥¼ ì—ë®¬ë ˆì´íŠ¸í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤."

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr "`-nographic`. ì´ê²ƒì€ QEMUì—ê²Œ GUIë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤."

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""
"`-semihosting-config (..)`. ì´ê²ƒì€ QEMUì—ê²Œ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ í™œì„±í™”í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤. "
"ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ í†µí•´ ì—ë®¬ë ˆì´íŠ¸ëœ ì¥ì¹˜ëŠ” í˜¸ìŠ¤íŠ¸ì˜ stdout, stderr, stdinì„ ì‚¬ìš©í•˜ê³  "
"í˜¸ìŠ¤íŠ¸ì— íŒŒì¼ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""
"`-kernel $file`. ì´ê²ƒì€ QEMUì—ê²Œ ì—ë®¬ë ˆì´íŠ¸ëœ ë¨¸ì‹ ì— ë¡œë“œí•˜ê³  ì‹¤í–‰í•  ë°”ì´ë„ˆë¦¬ë¥¼ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""
"ê¸´ QEMU ëª…ë ¹ì„ ì¼ì¼ì´ ì…ë ¥í•˜ëŠ” ê²ƒì€ ë„ˆë¬´ ë§ì€ ì‘ì—…ì…ë‹ˆë‹¤! ì‚¬ìš©ì ì§€ì • ëŸ¬ë„ˆë¥¼ "
"ì„¤ì •í•˜ì—¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¨ìˆœí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `.cargo/config.toml`ì—ëŠ” QEMUë¥¼ "
"í˜¸ì¶œí•˜ëŠ” ì£¼ì„ ì²˜ë¦¬ëœ ëŸ¬ë„ˆê°€ ìˆìŠµë‹ˆë‹¤. ì£¼ì„ì„ í•´ì œí•´ ë´…ì‹œë‹¤:"

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""
"ì´ ëŸ¬ë„ˆëŠ” ê¸°ë³¸ ì»´íŒŒì¼ ëŒ€ìƒì¸ `thumbv7m-none-eabi` ëŒ€ìƒì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. ì´ì œ "
"`cargo run`ì€ í”„ë¡œê·¸ë¨ì„ ì»´íŒŒì¼í•˜ê³  QEMUì—ì„œ ì‹¤í–‰í•  ê²ƒì…ë‹ˆë‹¤:"

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"

#: src/start/qemu.md:432 src/start/hardware.md:116
msgid "Debugging"
msgstr "ë””ë²„ê¹…"

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr "ë””ë²„ê¹…ì€ ì„ë² ë””ë“œ ê°œë°œì— ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ì–´ë–»ê²Œ í•˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤."

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""
"ì„ë² ë””ë“œ ì¥ì¹˜ ë””ë²„ê¹…ì€ ë””ë²„ê·¸í•˜ë ¤ëŠ” í”„ë¡œê·¸ë¨ì´ ë””ë²„ê±° í”„ë¡œê·¸ë¨(GDB ë˜ëŠ” LLDB)ì„ "
"ì‹¤í–‰í•˜ëŠ” ë¨¸ì‹ ì—ì„œ ì‹¤í–‰ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ _ì›ê²©_ ë””ë²„ê¹…ì„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""
"ì›ê²© ë””ë²„ê¹…ì€ í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ë¥¼ í¬í•¨í•©ë‹ˆë‹¤. QEMU ì„¤ì •ì—ì„œ í´ë¼ì´ì–¸íŠ¸ëŠ” GDB("
"ë˜ëŠ” LLDB) í”„ë¡œì„¸ìŠ¤ê°€ ë˜ê³  ì„œë²„ëŠ” ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” QEMU í”„ë¡œì„¸ìŠ¤ê°€ "
"ë©ë‹ˆë‹¤."

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” ì´ë¯¸ ì»´íŒŒì¼í•œ `hello` ì˜ˆì œë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr "ì²« ë²ˆì§¸ ë””ë²„ê¹… ë‹¨ê³„ëŠ” QEMUë¥¼ ë””ë²„ê¹… ëª¨ë“œë¡œ ì‹¤í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:"

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""
"ì´ ëª…ë ¹ì€ ì½˜ì†”ì— ì•„ë¬´ê²ƒë„ ì¶œë ¥í•˜ì§€ ì•Šìœ¼ë©° í„°ë¯¸ë„ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤. ì´ë²ˆì—ëŠ” ë‘ ê°€ì§€ "
"ì¶”ê°€ í”Œë˜ê·¸ë¥¼ ì „ë‹¬í–ˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""
"`-gdb tcp::3333`. ì´ê²ƒì€ QEMUì—ê²Œ TCP í¬íŠ¸ 3333ì—ì„œ GDB ì—°ê²°ì„ ê¸°ë‹¤ë¦¬ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤."

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""
"`-S`. ì´ê²ƒì€ QEMUì—ê²Œ ì‹œì‘ ì‹œ ë¨¸ì‹ ì„ ì •ì§€í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤. ì´ê²ƒì´ ì—†ìœ¼ë©´ "
"ë””ë²„ê±°ë¥¼ ì‹¤í–‰í•  ê¸°íšŒë¥¼ ì–»ê¸° ì „ì— í”„ë¡œê·¸ë¨ì´ mainì˜ ëì— ë„ë‹¬í–ˆì„ ê²ƒì…ë‹ˆë‹¤!"

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""
"ë‹¤ìŒìœ¼ë¡œ ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ GDBë¥¼ ì‹¤í–‰í•˜ê³  ì˜ˆì œì˜ ë””ë²„ê·¸ ì‹¬ë³¼ì„ ë¡œë“œí•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤:"

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""
"**ì°¸ê³ **: ì„¤ì¹˜ ì±•í„°ì—ì„œ ì„¤ì¹˜í•œ GDB ë²„ì „ì— ë”°ë¼ `gdb-multiarch` ëŒ€ì‹  ë‹¤ë¥¸ ë²„ì „ì˜ "
"GDBê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `arm-none-eabi-gdb` ë˜ëŠ” ë‹¨ìˆœíˆ `gdb`ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""
"ê·¸ëŸ° ë‹¤ìŒ GDB ì…¸ ë‚´ì—ì„œ TCP í¬íŠ¸ 3333ì—ì„œ ì—°ê²°ì„ ê¸°ë‹¤ë¦¬ëŠ” QEMUì— ì—°ê²°í•©ë‹ˆë‹¤."

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""
"í”„ë¡œì„¸ìŠ¤ê°€ ì¤‘ë‹¨ë˜ê³  í”„ë¡œê·¸ë¨ ì¹´ìš´í„°ê°€ `Reset`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²ƒì„ ë³¼ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ë¦¬ì…‹ í•¸ë“¤ëŸ¬ì…ë‹ˆë‹¤. Cortex-M ì½”ì–´ê°€ ë¶€íŒ… ì‹œ ì‹¤í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""
"ì¼ë¶€ ì„¤ì •ì—ì„œëŠ” ìœ„ì— í‘œì‹œëœ `Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/"
"lib.rs:473` ì¤„ ëŒ€ì‹  gdbê°€ ë‹¤ìŒê³¼ ê°™ì€ ê²½ê³ ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""
"ê·¸ê²ƒì€ ì•Œë ¤ì§„ ê²°í•¨ì…ë‹ˆë‹¤. í•´ë‹¹ ê²½ê³ ëŠ” ì•ˆì „í•˜ê²Œ ë¬´ì‹œí•´ë„ ë©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ Reset()ì— "
"ìˆì„ ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""
"ì´ ë¦¬ì…‹ í•¸ë“¤ëŸ¬ëŠ” ê²°êµ­ ìš°ë¦¬ì˜ main í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ê²ƒì…ë‹ˆë‹¤. ì¤‘ë‹¨ì ê³¼ `continue` "
"ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ ê·¸ê³³ê¹Œì§€ ê±´ë„ˆë›°ì–´ ë´…ì‹œë‹¤. ì¤‘ë‹¨ì ì„ ì„¤ì •í•˜ë ¤ë©´ ë¨¼ì € `list` ëª…ë ¹ìœ¼ë¡œ "
"ì½”ë“œì—ì„œ ì¤‘ë‹¨í•˜ê³  ì‹¶ì€ ìœ„ì¹˜ë¥¼ ì‚´í´ë´…ì‹œë‹¤."

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr "ì´ê²ƒì€ examples/hello.rs íŒŒì¼ì˜ ì†ŒìŠ¤ ì½”ë“œë¥¼ ë³´ì—¬ì¤„ ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""
"\"Hello, world!\" ë°”ë¡œ ì•ì¸ 13í–‰ì— ì¤‘ë‹¨ì ì„ ì¶”ê°€í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤. `break` ëª…ë ¹ìœ¼ë¡œ "
"ê·¸ë ‡ê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""
"ì´ì œ `continue` ëª…ë ¹ìœ¼ë¡œ gdbì—ê²Œ main í•¨ìˆ˜ê¹Œì§€ ì‹¤í–‰í•˜ë„ë¡ ì§€ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""
"ì´ì œ \"Hello, world!\"ë¥¼ ì¶œë ¥í•˜ëŠ” ì½”ë“œì— ê°€ê¹Œì›Œì¡ŒìŠµë‹ˆë‹¤. `next` ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ "
"ê³„ì† ì§„í–‰í•´ ë´…ì‹œë‹¤."

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""
"ì´ ì‹œì ì—ì„œ `qemu-system-arm`ì„ ì‹¤í–‰í•˜ëŠ” í„°ë¯¸ë„ì— \"Hello, world!\"ê°€ ì¶œë ¥ë˜ëŠ” "
"ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr "`next`ë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•˜ë©´ QEMU í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë©ë‹ˆë‹¤."

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr "ì´ì œ GDB ì„¸ì…˜ì„ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""
"ì´ì œ íˆ´ë§ê³¼ ê°œë°œ í”„ë¡œì„¸ìŠ¤ì— ì–´ëŠ ì •ë„ ìµìˆ™í•´ì¡Œì„ ê²ƒì…ë‹ˆë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” ì‹¤ì œ "
"í•˜ë“œì›¨ì–´ë¡œ ì „í™˜í•  ê²ƒì…ë‹ˆë‹¤. í”„ë¡œì„¸ìŠ¤ëŠ” ëŒ€ì²´ë¡œ ë™ì¼í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤. ì‹œì‘í•´ ë´…ì‹œë‹¤."

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr "í•˜ë“œì›¨ì–´ ì•Œì•„ë³´ê¸°"

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""
"ì‹œì‘í•˜ê¸° ì „ì— ëŒ€ìƒ ì¥ì¹˜ì˜ ëª‡ ê°€ì§€ íŠ¹ì„±ì„ ì‹ë³„í•´ì•¼ í•©ë‹ˆë‹¤. ì´ íŠ¹ì„±ë“¤ì€ í”„ë¡œì íŠ¸ë¥¼ "
"êµ¬ì„±í•˜ëŠ” ë° ì‚¬ìš©ë  ê²ƒì…ë‹ˆë‹¤:"

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr "ARM ì½”ì–´. ì˜ˆ: Cortex-M3."

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""
"ARM ì½”ì–´ì— FPUê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆê¹Œ? Cortex-M4**F** ë° Cortex-M7**F** ì½”ì–´ì—ëŠ” "
"í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""
"ëŒ€ìƒ ì¥ì¹˜ì—ëŠ” í”Œë˜ì‹œ ë©”ëª¨ë¦¬ì™€ RAMì´ ì–¼ë§ˆë‚˜ ìˆìŠµë‹ˆê¹Œ? ì˜ˆ: 256 KiB í”Œë˜ì‹œ ë° 32 KiB RAM."

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""
"ì£¼ì†Œ ê³µê°„ì—ì„œ í”Œë˜ì‹œ ë©”ëª¨ë¦¬ì™€ RAMì€ ì–´ë””ì— ë§¤í•‘ë˜ì–´ ìˆìŠµë‹ˆê¹Œ? ì˜ˆ: RAMì€ ì¼ë°˜ì ìœ¼ë¡œ "
"`0x2000_0000` ì£¼ì†Œì— ìœ„ì¹˜í•©ë‹ˆë‹¤."

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""
"ì´ ì •ë³´ëŠ” ì¥ì¹˜ì˜ ë°ì´í„° ì‹œíŠ¸ ë˜ëŠ” ì°¸ì¡° ì„¤ëª…ì„œì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""
"ì´ ì„¹ì…˜ì—ì„œëŠ” ì°¸ì¡° í•˜ë“œì›¨ì–´ì¸ STM32F3DISCOVERYë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. ì´ ë³´ë“œì—ëŠ” "
"STM32F303VCT6 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ë‹¤ìŒì„ "
"ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:"

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr "ë‹¨ì •ë°€ë„ FPUë¥¼ í¬í•¨í•˜ëŠ” Cortex-M4F ì½”ì–´"

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr "0x0800_0000 ì£¼ì†Œì— ìœ„ì¹˜í•œ 256 KiB í”Œë˜ì‹œ."

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""
"0x2000_0000 ì£¼ì†Œì— ìœ„ì¹˜í•œ 40 KiB RAM. (ë‹¤ë¥¸ RAM ì˜ì—­ì´ ìˆì§€ë§Œ ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ "
"ë¬´ì‹œí•©ë‹ˆë‹¤)."

#: src/start/hardware.md:35
msgid "Configuring"
msgstr "êµ¬ì„±"

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""
"ìƒˆë¡œìš´ í…œí”Œë¦¿ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì²˜ìŒë¶€í„° ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤. `cargo-generate` ì—†ì´ ì´ "
"ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [QEMUì— ëŒ€í•œ ì´ì „ ì„¹ì…˜](qemu.md)ì„ "
"ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/"
"config.toml`."
msgstr ""
"ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” `.cargo/config.toml`ì— ê¸°ë³¸ ì»´íŒŒì¼ ëŒ€ìƒì„ ì„¤ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr "Cortex-M4F ì½”ì–´ë¥¼ í¬í•¨í•˜ë¯€ë¡œ `thumbv7em-none-eabihf`ë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""
"**ì°¸ê³ **: ì´ì „ ì±•í„°ì—ì„œ ê¸°ì–µí•˜ì‹œê² ì§€ë§Œ, ëª¨ë“  ëŒ€ìƒì„ ì„¤ì¹˜í•´ì•¼ í•˜ë©° ì´ê²ƒì€ ìƒˆë¡œìš´ "
"ëŒ€ìƒì…ë‹ˆë‹¤. ë”°ë¼ì„œ ì´ ëŒ€ìƒì„ ìœ„í•´ `rustup target add thumbv7em-none-eabihf` "
"ì„¤ì¹˜ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒì„ ìŠì§€ ë§ˆì‹­ì‹œì˜¤."

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the "
"`memory.x` file."
msgstr ""
"ë‘ ë²ˆì§¸ ë‹¨ê³„ëŠ” `memory.x` íŒŒì¼ì— ë©”ëª¨ë¦¬ ì˜ì—­ ì •ë³´ë¥¼ ì…ë ¥í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of "
"`memory.x`."
msgstr ""
"**ì°¸ê³ **: ì–´ë–¤ ì´ìœ ë¡œë“  íŠ¹ì • ë¹Œë“œ ëŒ€ìƒì˜ ì²« ë²ˆì§¸ ë¹Œë“œë¥¼ ìˆ˜í–‰í•œ í›„ `memory.x` "
"íŒŒì¼ì„ ë³€ê²½í–ˆë‹¤ë©´, `cargo build`ê°€ `memory.x`ì˜ ì—…ë°ì´íŠ¸ë¥¼ ì¶”ì í•˜ì§€ ì•Šì„ ìˆ˜ "
"ìˆìœ¼ë¯€ë¡œ `cargo build` ì „ì— `cargo clean`ì„ ìˆ˜í–‰í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""
"hello ì˜ˆì œë¡œ ë‹¤ì‹œ ì‹œì‘í•  ê²ƒì´ì§€ë§Œ, ë¨¼ì € ì‘ì€ ë³€ê²½ ì‚¬í•­ì„ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""
"`examples/hello.rs`ì—ì„œ `debug::exit()` í˜¸ì¶œì´ ì£¼ì„ ì²˜ë¦¬ë˜ê±°ë‚˜ ì œê±°ë˜ì—ˆëŠ”ì§€ "
"í™•ì¸í•˜ì‹­ì‹œì˜¤. ì´ í˜¸ì¶œì€ QEMUì—ì„œ ì‹¤í–‰í•  ë•Œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/start/hardware.md:99 src/unsorted/math.md:61
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""
"// QEMU ì¢…ë£Œ\n"
"    // ì°¸ê³ : í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. OpenOCD ìƒíƒœë¥¼ ì†ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""
"ì´ì œ ì´ì „ê³¼ ê°™ì´ `cargo build`ë¥¼ ì‚¬ìš©í•˜ì—¬ í”„ë¡œê·¸ë¨ì„ í¬ë¡œìŠ¤ ì»´íŒŒì¼í•˜ê³  "
"`cargo-binutils`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°”ì´ë„ˆë¦¬ë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cortex-m-rt` í¬ë ˆì´íŠ¸ëŠ” "
"ì¹©ì„ ì‹¤í–‰í•˜ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ë§ˆë²•ì„ ì²˜ë¦¬í•˜ë©°, ë‹¤í–‰íˆ ê±°ì˜ ëª¨ë“  Cortex-M CPUëŠ” "
"ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë¶€íŒ…ë©ë‹ˆë‹¤."

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""
"ë””ë²„ê¹…ì€ ì•½ê°„ ë‹¤ë¥´ê²Œ ë³´ì¼ ê²ƒì…ë‹ˆë‹¤. ì‚¬ì‹¤, ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ëŒ€ìƒ ì¥ì¹˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ "
"ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” STM32F3DISCOVERYì—ì„œ ì‹¤í–‰ë˜ëŠ” í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” "
"ë° í•„ìš”í•œ ë‹¨ê³„ë¥¼ ë³´ì—¬ì¤„ ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì€ ì°¸ì¡°ìš©ì´ë©°, ë””ë²„ê¹…ì— ëŒ€í•œ ì¥ì¹˜ë³„ ì •ë³´ëŠ” "
"[Debugonomicon](https://github.com/rust-embedded/debugonomicon)ì„ í™•ì¸í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""
"ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì›ê²© ë””ë²„ê¹…ì„ ìˆ˜í–‰í•  ê²ƒì´ë©° í´ë¼ì´ì–¸íŠ¸ëŠ” GDB í”„ë¡œì„¸ìŠ¤ê°€ ë  "
"ê²ƒì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ë²ˆì—ëŠ” ì„œë²„ê°€ OpenOCDê°€ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""
"[í™•ì¸](../intro/install/verify.md) ì„¹ì…˜ì—ì„œ í–ˆë˜ ê²ƒì²˜ëŸ¼ ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œë¥¼ "
"ë…¸íŠ¸ë¶/PCì— ì—°ê²°í•˜ê³  ST-LINK í—¤ë”ê°€ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""
"í„°ë¯¸ë„ì—ì„œ `openocd`ë¥¼ ì‹¤í–‰í•˜ì—¬ ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì˜ ST-LINKì— ì—°ê²°í•˜ì‹­ì‹œì˜¤. í…œí”Œë¦¿ì˜ "
"ë£¨íŠ¸ì—ì„œ ì´ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì‹­ì‹œì˜¤. `openocd`ëŠ” ì‚¬ìš©í•  ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ê³¼ íƒ€ê²Ÿ íŒŒì¼ì„ "
"ë‚˜íƒ€ë‚´ëŠ” `openocd.cfg` íŒŒì¼ì„ ì„ íƒí•  ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""
"**ì°¸ê³ ** [í™•ì¸](../intro/install/verify.md) ì„¹ì…˜ì—ì„œ ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì˜ ì´ì „ ê°œì •íŒì„ "
"ê°€ì§€ê³  ìˆìŒì„ ì•Œê²Œ ë˜ì—ˆë‹¤ë©´, ì´ ì‹œì ì—ì„œ `openocd.cfg` íŒŒì¼ì„ ìˆ˜ì •í•˜ì—¬ "
"`interface/stlink-v2.cfg`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr "ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ GDBë¥¼ ì‹¤í–‰í•˜ì‹­ì‹œì˜¤. ì—­ì‹œ í…œí”Œë¦¿ì˜ ë£¨íŠ¸ì—ì„œ ì‹¤í–‰í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""
"**ì°¸ê³ **: ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì„¤ì¹˜ ì±•í„°ì—ì„œ ì„¤ì¹˜í•œ GDB ë²„ì „ì— ë”°ë¼ `gdb-"
"multiarch` ëŒ€ì‹  ë‹¤ë¥¸ ë²„ì „ì˜ GDBê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `arm-none-eabi-gdb` "
"ë˜ëŠ” ë‹¨ìˆœíˆ `gdb`ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""
"ë‹¤ìŒìœ¼ë¡œ GDBë¥¼ OpenOCDì— ì—°ê²°í•©ë‹ˆë‹¤. OpenOCDëŠ” í¬íŠ¸ 3333ì—ì„œ TCP ì—°ê²°ì„ ê¸°ë‹¤ë¦¬ê³  "
"ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""
"ì´ì œ `load` ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œê·¸ë¨ì„ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— _í”Œë˜ì‹œ_ (ë¡œë“œ)í•˜ì‹­ì‹œì˜¤."

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""
"í”„ë¡œê·¸ë¨ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ í”„ë¡œê·¸ë¨ì€ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ì„¸ë¯¸í˜¸ìŠ¤íŒ… í˜¸ì¶œì„ "
"í•˜ê¸° ì „ì— OpenOCDì—ê²Œ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ í™œì„±í™”í•˜ë„ë¡ ì•Œë ¤ì•¼ í•©ë‹ˆë‹¤. `monitor` ëª…ë ¹ì„ "
"ì‚¬ìš©í•˜ì—¬ OpenOCDì— ëª…ë ¹ì„ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr "`monitor help` ëª…ë ¹ì„ í˜¸ì¶œí•˜ì—¬ ëª¨ë“  OpenOCD ëª…ë ¹ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""
"ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì¤‘ë‹¨ì ê³¼ `continue` ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ `main`ê¹Œì§€ ê±´ë„ˆë›¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""
"**ì°¸ê³ ** ìœ„ì—ì„œ `continue` ëª…ë ¹ì„ ì‹¤í–‰í•œ í›„ GDBê°€ ì¤‘ë‹¨ì ì„ ë§ì¶”ëŠ” ëŒ€ì‹  í„°ë¯¸ë„ì„ "
"ì°¨ë‹¨í•œë‹¤ë©´, `memory.x` íŒŒì¼ì˜ ë©”ëª¨ë¦¬ ì˜ì—­ ì •ë³´ê°€ ì¥ì¹˜ì— ëŒ€í•´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€("
"ì‹œì‘ ë° ê¸¸ì´ ëª¨ë‘) ë‹¤ì‹œ í™•ì¸í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr "`step`ìœ¼ë¡œ main í•¨ìˆ˜ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤."

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""
"`next`ë¡œ í”„ë¡œê·¸ë¨ì„ ì§„í–‰í•˜ë©´ OpenOCD ì½˜ì†”ì— \"Hello, world!\"ê°€ ë‹¤ë¥¸ ë‚´ìš©ê³¼ "
"í•¨ê»˜ ì¶œë ¥ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""
"ë©”ì‹œì§€ëŠ” í”„ë¡œê·¸ë¨ì´ 19í–‰ì— ì •ì˜ëœ ë¬´í•œ ë£¨í”„: `loop {}`ì— ì§„ì…í•˜ê¸° ì§ì „ì— í•œ ë²ˆë§Œ "
"í‘œì‹œë©ë‹ˆë‹¤."

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr "ì´ì œ `quit` ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ GDBë¥¼ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""
"ì´ì œ ë””ë²„ê¹…ì—ëŠ” ëª‡ ê°€ì§€ ë‹¨ê³„ê°€ ë” í•„ìš”í•˜ë¯€ë¡œ, ì´ ëª¨ë“  ë‹¨ê³„ë¥¼ `openocd.gdb`ë¼ëŠ” "
"ë‹¨ì¼ GDB ìŠ¤í¬ë¦½íŠ¸ì— ë‹´ì•˜ìŠµë‹ˆë‹¤. ì´ íŒŒì¼ì€ `cargo generate` ë‹¨ê³„ì—ì„œ ìƒì„±ë˜ì—ˆìœ¼ë©°, "
"ìˆ˜ì • ì—†ì´ ì‘ë™í•´ì•¼ í•©ë‹ˆë‹¤. í•œë²ˆ ì‚´í´ë´…ì‹œë‹¤:"

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""
"ì´ì œ `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/examples/hello`"
"ë¥¼ ì‹¤í–‰í•˜ë©´ GDBê°€ ì¦‰ì‹œ OpenOCDì— ì—°ê²°ë˜ê³ , ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ í™œì„±í™”í•˜ë©°, í”„ë¡œê·¸ë¨ì„ "
"ë¡œë“œí•˜ê³  í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œì‘í•  ê²ƒì…ë‹ˆë‹¤."

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""
"ëŒ€ì•ˆìœ¼ë¡œ, `<gdb> -x openocd.gdb`ë¥¼ ì‚¬ìš©ì ì§€ì • ëŸ¬ë„ˆë¡œ ë§Œë“¤ì–´ `cargo run`ì´ "
"í”„ë¡œê·¸ë¨ì„ ë¹Œë“œí•˜ê³  GDB ì„¸ì…˜ì„ ì‹œì‘í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ëŸ¬ë„ˆëŠ” "
"`.cargo/config.toml`ì— í¬í•¨ë˜ì–´ ìˆì§€ë§Œ ì£¼ì„ ì²˜ë¦¬ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"

#: src/start/registers.md:1
msgid "Memory Mapped Registers"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°"

#: src/start/registers.md:3
msgid ""
"Embedded systems can only get so far by executing normal Rust code and "
"moving data around in RAM. If we want to get any information into or out of "
"our system (be that blinking an LED, detecting a button press or "
"communicating with an off-chip peripheral on some sort of bus) we're going "
"to have to dip into the world of Peripherals and their 'memory mapped "
"registers'."
msgstr ""
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì€ ì¼ë°˜ Rust ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  RAMì—ì„œ ë°ì´í„°ë¥¼ ì´ë™í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œëŠ” "
"í•œê³„ê°€ ìˆìŠµë‹ˆë‹¤. ì‹œìŠ¤í…œìœ¼ë¡œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ì‹œìŠ¤í…œì—ì„œ ì •ë³´ë¥¼ ë‚´ë³´ë‚´ë ¤ë©´(LED "
"ê¹œë°•ì„, ë²„íŠ¼ ëˆ„ë¦„ ê°ì§€ ë˜ëŠ” íŠ¹ì • ë²„ìŠ¤ë¥¼ í†µí•´ ì˜¤í”„ì¹© ì£¼ë³€ ì¥ì¹˜ì™€ í†µì‹  ë“±) ì£¼ë³€ "
"ì¥ì¹˜ì™€ í•´ë‹¹ 'ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°'ì˜ ì„¸ê³„ë¡œ ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤."

#: src/start/registers.md:5
msgid ""
"You may well find that the code you need to access the peripherals in your "
"micro-controller has already been written, at one of the following levels:"
msgstr ""
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì£¼ë³€ ì¥ì¹˜ì— ì ‘ê·¼í•˜ëŠ” ë° í•„ìš”í•œ ì½”ë“œê°€ ë‹¤ìŒ ìˆ˜ì¤€ ì¤‘ í•˜ë‚˜ë¡œ "
"ì´ë¯¸ ì‘ì„±ë˜ì–´ ìˆìŒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/start/registers.md:10
msgid ""
"Micro-architecture Crate - This sort of crate handles any useful routines "
"common to the processor core your microcontroller is using, as well as any "
"peripherals that are common to all micro-controllers that use that "
"particular type of processor core. For example the [cortex-m](https://"
"crates.io/crates/cortex-m) crate gives you functions to enable and disable "
"interrupts, which are the same for all Cortex-M based micro-controllers. It "
"also gives you access to the 'SysTick' peripheral included with all Cortex-M "
"based micro-controllers."
msgstr ""
"ë§ˆì´í¬ë¡œì•„í‚¤í…ì²˜ í¬ë ˆì´íŠ¸ - ì´ ì¢…ë¥˜ì˜ í¬ë ˆì´íŠ¸ëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì‚¬ìš©í•˜ëŠ” "
"í”„ë¡œì„¸ì„œ ì½”ì–´ì— ê³µí†µì ì¸ ìœ ìš©í•œ ë£¨í‹´ê³¼ í•´ë‹¹ íŠ¹ì • ìœ í˜•ì˜ í”„ë¡œì„¸ì„œ ì½”ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” "
"ëª¨ë“  ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ê³µí†µì ì¸ ì£¼ë³€ ì¥ì¹˜ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, [cortex-m]("
"https://crates.io/crates/cortex-m) í¬ë ˆì´íŠ¸ëŠ” ëª¨ë“  Cortex-M ê¸°ë°˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— "
"ë™ì¼í•œ ì¸í„°ëŸ½íŠ¸ í™œì„±í™” ë° ë¹„í™œì„±í™” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ë˜í•œ ëª¨ë“  Cortex-M ê¸°ë°˜ "
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— í¬í•¨ëœ 'SysTick' ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì ‘ê·¼ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/start/registers.md:11
msgid ""
"Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over "
"the various memory-wrapper registers defined for your particular part-number "
"of micro-controller you are using. For example, [tm4c123x](https://crates.io/"
"crates/tm4c123x) for the Texas Instruments Tiva-C TM4C123 series, or "
"[stm32f30x](https://crates.io/crates/stm32f30x) for the ST-Micro STM32F30x "
"series. Here, you'll be interacting with the registers directly, following "
"each peripheral's operating instructions given in your micro-controller's "
"Technical Reference Manual."
msgstr "ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ í¬ë ˆì´íŠ¸(PAC) - ì´ ì¢…ë¥˜ì˜ í¬ë ˆì´íŠ¸ëŠ” ì‚¬ìš© ì¤‘ì¸ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ íŠ¹ì • ë¶€í’ˆ ë²ˆí˜¸ì— ëŒ€í•´ ì •ì˜ëœ ë‹¤ì–‘í•œ ë©”ëª¨ë¦¬ ë˜í¼ ë ˆì§€ìŠ¤í„°ì— ëŒ€í•œ ì–‡ì€ ë˜í¼ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í…ì‚¬ìŠ¤ ì¸ìŠ¤íŠ¸ë£¨ë¨¼íŠ¸ Tiva-C TM4C123 ì‹œë¦¬ì¦ˆìš© [tm4c123x](https://crates.io/crates/tm4c123x) ë˜ëŠ” ST-Micro STM32F30x ì‹œë¦¬ì¦ˆìš© [stm32f30x](https://crates.io/crates/stm32f30x)ê°€ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ê¸°ìˆ  ì°¸ì¡° ì„¤ëª…ì„œì— ì œê³µëœ ê° ì£¼ë³€ ì¥ì¹˜ì˜ ì‘ë™ ì§€ì¹¨ì— ë”°ë¼ ë ˆì§€ìŠ¤í„°ì™€ ì§ì ‘ ìƒí˜¸ ì‘ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/start/registers.md:12
msgid ""
"HAL Crate - These crates offer a more user-friendly API for your particular "
"processor, often by implementing some common traits defined in [embedded-hal]"
"(https://crates.io/crates/embedded-hal). For example, this crate might offer "
"a `Serial` struct, with a constructor that takes an appropriate set of GPIO "
"pins and a baud rate, and offers some sort of `write_byte` function for "
"sending data. See the chapter on [Portability](../portability/index.md) for "
"more information on [embedded-hal](https://crates.io/crates/embedded-hal)."
msgstr "HAL í¬ë ˆì´íŠ¸ - ì´ëŸ¬í•œ í¬ë ˆì´íŠ¸ëŠ” [embedded-hal](https://crates.io/crates/embedded-hal)ì— ì •ì˜ëœ ì¼ë¶€ ê³µí†µ íŠ¹ì„±ì„ êµ¬í˜„í•˜ì—¬ íŠ¹ì • í”„ë¡œì„¸ì„œì— ëŒ€í•´ ë” ì‚¬ìš©ì ì¹œí™”ì ì¸ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì´ í¬ë ˆì´íŠ¸ëŠ” ì ì ˆí•œ GPIO í•€ ì„¸íŠ¸ì™€ ì „ì†¡ ì†ë„ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒì„±ìê°€ ìˆëŠ” `Serial` êµ¬ì¡°ì²´ë¥¼ ì œê³µí•˜ê³  ë°ì´í„°ë¥¼ ë³´ë‚´ê¸° ìœ„í•œ ì¼ì¢…ì˜ `write_byte` í•¨ìˆ˜ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. [embedded-hal](https://crates.io/crates/embedded-hal)ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ì´ì‹ì„±](../portability/index.md) ì¥ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/start/registers.md:13
msgid ""
"Board Crate - These crates go one step further than a HAL Crate by pre-"
"configuring various peripherals and GPIO pins to suit the specific developer "
"kit or board you are using, such as [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) for the STM32F3DISCOVERY board."
msgstr "ë³´ë“œ í¬ë ˆì´íŠ¸ - ì´ëŸ¬í•œ í¬ë ˆì´íŠ¸ëŠ” STM32F3DISCOVERY ë³´ë“œìš© [stm32f3-discovery](https://crates.io/crates/stm32f3-discovery)ì™€ ê°™ì´ ì‚¬ìš© ì¤‘ì¸ íŠ¹ì • ê°œë°œì í‚¤íŠ¸ ë˜ëŠ” ë³´ë“œì— ë§ê²Œ ë‹¤ì–‘í•œ ì£¼ë³€ ì¥ì¹˜ ë° GPIO í•€ì„ ë¯¸ë¦¬ êµ¬ì„±í•˜ì—¬ HAL í¬ë ˆì´íŠ¸ë³´ë‹¤ í•œ ë‹¨ê³„ ë” ë‚˜ì•„ê°‘ë‹ˆë‹¤."

#: src/start/registers.md:23
msgid "Board Crate"
msgstr "ë³´ë“œ í¬ë ˆì´íŠ¸"

#: src/start/registers.md:25
msgid ""
"A board crate is the perfect starting point, if you're new to embedded Rust. "
"They nicely abstract the HW details that might be overwhelming when starting "
"studying this subject, and makes standard tasks easy, like turning a LED on "
"or off. The functionality it exposes varies a lot between boards. Since this "
"book aims at staying hardware agnostic, the board crates won't be covered by "
"this book."
msgstr "ë³´ë“œ í¬ë ˆì´íŠ¸ëŠ” ì„ë² ë””ë“œ Rustë¥¼ ì²˜ìŒ ì ‘í•˜ëŠ” ê²½ìš° ì™„ë²½í•œ ì‹œì‘ì ì…ë‹ˆë‹¤. ì´ ì£¼ì œë¥¼ ê³µë¶€í•˜ê¸° ì‹œì‘í•  ë•Œ ì••ë„ì ì¼ ìˆ˜ ìˆëŠ” HW ì„¸ë¶€ ì •ë³´ë¥¼ ë©‹ì§€ê²Œ ì¶”ìƒí™”í•˜ê³  LEDë¥¼ ì¼œê±°ë‚˜ ë„ëŠ” ê²ƒê³¼ ê°™ì€ í‘œì¤€ ì‘ì—…ì„ ì‰½ê²Œ ë§Œë“­ë‹ˆë‹¤. ë…¸ì¶œí•˜ëŠ” ê¸°ëŠ¥ì€ ë³´ë“œë§ˆë‹¤ ë§ì´ ë‹¤ë¦…ë‹ˆë‹¤. ì´ ì±…ì€ í•˜ë“œì›¨ì–´ì— êµ¬ì• ë°›ì§€ ì•ŠëŠ” ê²ƒì„ ëª©í‘œë¡œ í•˜ë¯€ë¡œ ë³´ë“œ í¬ë ˆì´íŠ¸ëŠ” ì´ ì±…ì—ì„œ ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/start/registers.md:27
msgid ""
"If you want to experiment with the STM32F3DISCOVERY board, it is highly "
"recommended to take a look at the [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) board crate, which provides functionality to blink "
"the board LEDs, access its compass, bluetooth and more. The [Discovery]"
"(https://rust-embedded.github.io/discovery/) book offers a great "
"introduction to the use of a board crate."
msgstr "STM32F3DISCOVERY ë³´ë“œë¡œ ì‹¤í—˜í•˜ê³  ì‹¶ë‹¤ë©´ ë³´ë“œ LEDë¥¼ ê¹œë°•ì´ê³  ë‚˜ì¹¨ë°˜, ë¸”ë£¨íˆ¬ìŠ¤ ë“±ì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” [stm32f3-discovery](https://crates.io/crates/stm32f3-discovery) ë³´ë“œ í¬ë ˆì´íŠ¸ë¥¼ ì‚´í´ë³´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. [Discovery](https://rust-embedded.github.io/discovery/) ì±…ì€ ë³´ë“œ í¬ë ˆì´íŠ¸ ì‚¬ìš©ì— ëŒ€í•œ í›Œë¥­í•œ ì†Œê°œë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/start/registers.md:29
msgid ""
"But if you're working on a system that doesn't yet have dedicated board "
"crate, or you need functionality not provided by existing crates, read on as "
"we start from the bottom, with the micro-architecture crates."
msgstr "í•˜ì§€ë§Œ ì•„ì§ ì „ìš© ë³´ë“œ í¬ë ˆì´íŠ¸ê°€ ì—†ëŠ” ì‹œìŠ¤í…œì—ì„œ ì‘ì—… ì¤‘ì´ê±°ë‚˜ ê¸°ì¡´ í¬ë ˆì´íŠ¸ì—ì„œ ì œê³µí•˜ì§€ ì•ŠëŠ” ê¸°ëŠ¥ì´ í•„ìš”í•œ ê²½ìš° ë§ˆì´í¬ë¡œ ì•„í‚¤í…ì²˜ í¬ë ˆì´íŠ¸ë¶€í„° ì‹œì‘í•˜ì—¬ ê³„ì† ì½ìœ¼ì‹­ì‹œì˜¤."

#: src/start/registers.md:31
msgid "Micro-architecture crate"
msgstr "ë§ˆì´í¬ë¡œ ì•„í‚¤í…ì²˜ í¬ë ˆì´íŠ¸"

#: src/start/registers.md:33
msgid ""
"Let's look at the SysTick peripheral that's common to all Cortex-M based "
"micro-controllers. We can find a pretty low-level API in the [cortex-m]"
"(https://crates.io/crates/cortex-m) crate, and we can use it like this:"
msgstr "ëª¨ë“  Cortex-M ê¸°ë°˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ê³µí†µì ì¸ SysTick ì£¼ë³€ ì¥ì¹˜ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. [cortex-m](https://crates.io/crates/cortex-m) í¬ë ˆì´íŠ¸ì—ì„œ ë§¤ìš° ë‚®ì€ ìˆ˜ì¤€ì˜ APIë¥¼ ì°¾ì„ ìˆ˜ ìˆìœ¼ë©° ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/registers.md:51
msgid "// Loop\n"
msgstr "// ë£¨í”„\n"

#: src/start/registers.md:57
msgid ""
"The functions on the `SYST` struct map pretty closely to the functionality "
"defined by the ARM Technical Reference Manual for this peripheral. There's "
"nothing in this API about 'delaying for X milliseconds' - we have to crudely "
"implement that ourselves using a `while` loop. Note that we can't access our "
"`SYST` struct until we have called `Peripherals::take()` - this is a special "
"routine that guarantees that there is only one `SYST` structure in our "
"entire program. For more on that, see the [Peripherals](../peripherals/"
"index.md) section."
msgstr "`SYST` êµ¬ì¡°ì²´ì˜ í•¨ìˆ˜ëŠ” ì´ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ARM ê¸°ìˆ  ì°¸ì¡° ì„¤ëª…ì„œì— ì •ì˜ëœ ê¸°ëŠ¥ê³¼ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. ì´ APIì—ëŠ” 'Xë°€ë¦¬ì´ˆ ì§€ì—°'ì— ëŒ€í•œ ë‚´ìš©ì´ ì—†ìœ¼ë¯€ë¡œ `while` ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§ì ‘ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. `Peripherals::take()`ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ê¹Œì§€ëŠ” `SYST` êµ¬ì¡°ì²´ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ëŠ” ì „ì²´ í”„ë¡œê·¸ë¨ì— `SYST` êµ¬ì¡°ì²´ê°€ í•˜ë‚˜ë§Œ ìˆë„ë¡ ë³´ì¥í•˜ëŠ” íŠ¹ìˆ˜ ë£¨í‹´ì…ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ì£¼ë³€ ì¥ì¹˜](../peripherals/index.md) ì„¹ì…˜ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/start/registers.md:61
msgid "Using a Peripheral Access Crate (PAC)"
msgstr "ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ í¬ë ˆì´íŠ¸(PAC) ì‚¬ìš©"

#: src/start/registers.md:63
msgid ""
"We won't get very far with our embedded software development if we restrict "
"ourselves to only the basic peripherals included with every Cortex-M. At "
"some point, we're going to need to write some code that's specific to the "
"particular micro-controller we're using. In this example, let's assume we "
"have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB "
"of Flash. We're going to pull in the [tm4c123x](https://crates.io/crates/"
"tm4c123x) crate to make use of this chip."
msgstr "ëª¨ë“  Cortex-Mì— í¬í•¨ëœ ê¸°ë³¸ ì£¼ë³€ ì¥ì¹˜ì—ë§Œ êµ­í•œí•œë‹¤ë©´ ì„ë² ë””ë“œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì— í° ì§„ì „ì„ ì´ë£¨ì§€ ëª»í•  ê²ƒì…ë‹ˆë‹¤. ì–´ëŠ ì‹œì ì—ëŠ” ì‚¬ìš© ì¤‘ì¸ íŠ¹ì • ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— íŠ¹ì •í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ì˜ˆì—ì„œëŠ” 256KiBì˜ í”Œë˜ì‹œê°€ ìˆëŠ” ì¤‘ê°„ê¸‰ 80MHz Cortex-M4ì¸ Texas Instruments TM4C123ì´ ìˆë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ ì¹©ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ [tm4c123x](https://crates.io/crates/tm4c123x) í¬ë ˆì´íŠ¸ë¥¼ ê°€ì ¸ì˜¬ ê²ƒì…ë‹ˆë‹¤."

#: src/start/registers.md:69 src/start/registers.md:145
msgid "// panic handler\n"
msgstr "// íŒ¨ë‹‰ í•¸ë“¤ëŸ¬\n"

#: src/start/registers.md:81
msgid "// Mode = 1 => Count up/down mode\n"
msgstr "// ëª¨ë“œ = 1 => ì¹´ìš´íŠ¸ ì—…/ë‹¤ìš´ ëª¨ë“œ\n"

#: src/start/registers.md:84
msgid "// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)\n"
msgstr "// 528 ì‚¬ì´í´ (264 ì—… ë° ë‹¤ìš´) = ë¹„ë””ì˜¤ ë¼ì¸ë‹¹ 4 ë£¨í”„ (2112 ì‚¬ì´í´)\n"

#: src/start/registers.md:92
msgid ""
"We've accessed the `PWM0` peripheral in exactly the same way as we accessed "
"the `SYST` peripheral earlier, except we called "
"`tm4c123x::Peripherals::take()`. As this crate was auto-generated using "
"[svd2rust](https://crates.io/crates/svd2rust), the access functions for our "
"register fields take a closure, rather than a numeric argument. While this "
"looks like a lot of code, the Rust compiler can use it to perform a bunch of "
"checks for us, but then generate machine-code which is pretty close to hand-"
"written assembler! Where the auto-generated code isn't able to determine "
"that all possible arguments to a particular accessor function are valid (for "
"example, if the SVD defines the register as 32-bit but doesn't say if some "
"of those 32-bit values have a special meaning), then the function is marked "
"as `unsafe`. We can see this in the example above when setting the `load` "
"and `compa` sub-fields using the `bits()` function."
msgstr "`SYST` ì£¼ë³€ ì¥ì¹˜ì— ì•¡ì„¸ìŠ¤í•œ ê²ƒê³¼ ë˜‘ê°™ì€ ë°©ì‹ìœ¼ë¡œ `PWM0` ì£¼ë³€ ì¥ì¹˜ì— ì•¡ì„¸ìŠ¤í–ˆì§€ë§Œ `tm4c123x::Peripherals::take()`ë¥¼ í˜¸ì¶œí–ˆìŠµë‹ˆë‹¤. ì´ í¬ë ˆì´íŠ¸ëŠ” [svd2rust](https://crates.io/crates/svd2rust)ë¥¼ ì‚¬ìš©í•˜ì—¬ ìë™ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ ë ˆì§€ìŠ¤í„° í•„ë“œì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ í•¨ìˆ˜ëŠ” ìˆ«ì ì¸ìˆ˜ê°€ ì•„ë‹Œ í´ë¡œì €ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ê²ƒì€ ë§ì€ ì½”ë“œì²˜ëŸ¼ ë³´ì´ì§€ë§Œ Rust ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•œ ë‹¤ìŒ ì†ìœ¼ë¡œ ì‘ì„±í•œ ì–´ì…ˆë¸”ëŸ¬ì— ë§¤ìš° ê°€ê¹Œìš´ ê¸°ê³„ ì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ìë™ ìƒì„±ëœ ì½”ë“œê°€ íŠ¹ì • ì ‘ê·¼ì í•¨ìˆ˜ì— ëŒ€í•œ ëª¨ë“  ê°€ëŠ¥í•œ ì¸ìˆ˜ê°€ ìœ íš¨í•œì§€ í™•ì¸í•  ìˆ˜ ì—†ëŠ” ê²½ìš°(ì˜ˆ: SVDê°€ ë ˆì§€ìŠ¤í„°ë¥¼ 32ë¹„íŠ¸ë¡œ ì •ì˜í•˜ì§€ë§Œ í•´ë‹¹ 32ë¹„íŠ¸ ê°’ ì¤‘ ì¼ë¶€ì— íŠ¹ë³„í•œ ì˜ë¯¸ê°€ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ëª…ì‹œí•˜ì§€ ì•Šì€ ê²½ìš°) í•¨ìˆ˜ëŠ” `unsafe`ë¡œ í‘œì‹œë©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œ `bits()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ `load` ë° `compa` í•˜ìœ„ í•„ë“œë¥¼ ì„¤ì •í•  ë•Œ ì´ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/registers.md:94
msgid "Reading"
msgstr "ì½ê¸°"

#: src/start/registers.md:96
msgid ""
"The `read()` function returns an object which gives read-only access to the "
"various sub-fields within this register, as defined by the manufacturer's "
"SVD file for this chip. You can find all the functions available on special "
"`R` return type for this particular register, in this particular peripheral, "
"on this particular chip, in the [tm4c123x documentation](https://docs.rs/"
"tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)."
msgstr "`read()` í•¨ìˆ˜ëŠ” ì´ ì¹©ì— ëŒ€í•œ ì œì¡°ì—…ì²´ì˜ SVD íŒŒì¼ì— ì •ì˜ëœ ëŒ€ë¡œ ì´ ë ˆì§€ìŠ¤í„° ë‚´ì˜ ë‹¤ì–‘í•œ í•˜ìœ„ í•„ë“œì— ëŒ€í•œ ì½ê¸° ì „ìš© ì•¡ì„¸ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ íŠ¹ì • ì¹©ì˜ ì´ íŠ¹ì • ì£¼ë³€ ì¥ì¹˜ì— ìˆëŠ” ì´ íŠ¹ì • ë ˆì§€ìŠ¤í„°ì— ëŒ€í•œ íŠ¹ìˆ˜ `R` ë°˜í™˜ ìœ í˜•ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  í•¨ìˆ˜ëŠ” [tm4c123x ì„¤ëª…ì„œ](https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/registers.md:100
msgid "// Do a thing\n"
msgstr "// ë¬´ì–¸ê°€ í•˜ê¸°\n"

#: src/start/registers.md:104
msgid "Writing"
msgstr "ì“°ê¸°"

#: src/start/registers.md:106
msgid ""
"The `write()` function takes a closure with a single argument. Typically we "
"call this `w`. This argument then gives read-write access to the various sub-"
"fields within this register, as defined by the manufacturer's SVD file for "
"this chip. Again, you can find all the functions available on the 'w' for "
"this particular register, in this particular peripheral, on this particular "
"chip, in the [tm4c123x documentation](https://docs.rs/tm4c123x/0.7.0/"
"tm4c123x/pwm0/ctl/struct.W.html). Note that all of the sub-fields that we do "
"not set will be set to a default value for us - any existing content in the "
"register will be lost."
msgstr "`write()` í•¨ìˆ˜ëŠ” ë‹¨ì¼ ì¸ìˆ˜ë¥¼ ê°€ì§„ í´ë¡œì €ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì´ë¥¼ `w`ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤. ì´ ì¸ìˆ˜ëŠ” ì´ ì¹©ì— ëŒ€í•œ ì œì¡°ì—…ì²´ì˜ SVD íŒŒì¼ì— ì •ì˜ëœ ëŒ€ë¡œ ì´ ë ˆì§€ìŠ¤í„° ë‚´ì˜ ë‹¤ì–‘í•œ í•˜ìœ„ í•„ë“œì— ëŒ€í•œ ì½ê¸°-ì“°ê¸° ì•¡ì„¸ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ë‹¤ì‹œ ë§í•˜ì§€ë§Œ, ì´ íŠ¹ì • ì¹©ì˜ ì´ íŠ¹ì • ì£¼ë³€ ì¥ì¹˜ì— ìˆëŠ” ì´ íŠ¹ì • ë ˆì§€ìŠ¤í„°ì— ëŒ€í•œ 'w'ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  í•¨ìˆ˜ëŠ” [tm4c123x ì„¤ëª…ì„œ](https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html)ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„¤ì •í•˜ì§€ ì•Šì€ ëª¨ë“  í•˜ìœ„ í•„ë“œëŠ” ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •ë˜ë©° ë ˆì§€ìŠ¤í„°ì˜ ê¸°ì¡´ ë‚´ìš©ì€ ì†ì‹¤ë©ë‹ˆë‹¤."

#: src/start/registers.md:112
msgid "Modifying"
msgstr "ìˆ˜ì •"

#: src/start/registers.md:114
msgid ""
"If we wish to change only one particular sub-field in this register and "
"leave the other sub-fields unchanged, we can use the `modify` function. This "
"function takes a closure with two arguments - one for reading and one for "
"writing. Typically we call these `r` and `w` respectively. The `r` argument "
"can be used to inspect the current contents of the register, and the `w` "
"argument can be used to modify the register contents."
msgstr "ì´ ë ˆì§€ìŠ¤í„°ì—ì„œ íŠ¹ì • í•˜ìœ„ í•„ë“œ í•˜ë‚˜ë§Œ ë³€ê²½í•˜ê³  ë‹¤ë¥¸ í•˜ìœ„ í•„ë“œëŠ” ë³€ê²½í•˜ì§€ ì•Šìœ¼ë ¤ë©´ `modify` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ì½ê¸°ìš©ê³¼ ì“°ê¸°ìš© ë‘ ê°œì˜ ì¸ìˆ˜ë¥¼ ê°€ì§„ í´ë¡œì €ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ê°ê° `r`ê³¼ `w`ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤. `r` ì¸ìˆ˜ëŠ” ë ˆì§€ìŠ¤í„°ì˜ í˜„ì¬ ë‚´ìš©ì„ ê²€ì‚¬í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆê³  `w` ì¸ìˆ˜ëŠ” ë ˆì§€ìŠ¤í„° ë‚´ìš©ì„ ìˆ˜ì •í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/registers.md:120
msgid ""
"The `modify` function really shows the power of closures here. In C, we'd "
"have to read into some temporary value, modify the correct bits and then "
"write the value back. This means there's considerable scope for error:"
msgstr "`modify` í•¨ìˆ˜ëŠ” ì—¬ê¸°ì„œ í´ë¡œì €ì˜ í˜ì„ ì‹¤ì œë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤. Cì—ì„œëŠ” ì„ì‹œ ê°’ìœ¼ë¡œ ì½ê³  ì˜¬ë°”ë¥¸ ë¹„íŠ¸ë¥¼ ìˆ˜ì •í•œ ë‹¤ìŒ ê°’ì„ ë‹¤ì‹œ ì¨ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ì˜¤ë¥˜ì˜ ì—¬ì§€ê°€ ìƒë‹¹íˆ ë§ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/start/registers.md:128
msgid "// Uh oh! Wrong variable!\n"
msgstr "// ì–´ãŠ! ì˜ëª»ëœ ë³€ìˆ˜!\n"

#: src/start/registers.md:135
msgid "Using a HAL crate"
msgstr "HAL í¬ë ˆì´íŠ¸ ì‚¬ìš©"

#: src/start/registers.md:137
msgid ""
"The HAL crate for a chip typically works by implementing a custom Trait for "
"the raw structures exposed by the PAC. Often this trait will define a "
"function called `constrain()` for single peripherals or `split()` for things "
"like GPIO ports with multiple pins. This function will consume the "
"underlying raw peripheral structure and return a new object with a higher-"
"level API. This API may also do things like have the Serial port `new` "
"function require a borrow on some `Clock` structure, which can only be "
"generated by calling the function which configures the PLLs and sets up all "
"the clock frequencies. In this way, it is statically impossible to create a "
"Serial port object without first having configured the clock rates, or for "
"the Serial port object to misconvert the baud rate into clock ticks. Some "
"crates even define special traits for the states each GPIO pin can be in, "
"requiring the user to put a pin into the correct state (say, by selecting "
"the appropriate Alternate Function Mode) before passing the pin into "
"Peripheral. All with no run-time cost!"
msgstr "ì¹©ìš© HAL í¬ë ˆì´íŠ¸ëŠ” ì¼ë°˜ì ìœ¼ë¡œ PACì—ì„œ ë…¸ì¶œí•˜ëŠ” ì›ì‹œ êµ¬ì¡°ì²´ì— ëŒ€í•œ ì‚¬ìš©ì ì§€ì • Traitë¥¼ êµ¬í˜„í•˜ì—¬ ì‘ë™í•©ë‹ˆë‹¤. ì¢…ì¢… ì´ íŠ¸ë ˆì´íŠ¸ëŠ” ë‹¨ì¼ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•´ `constrain()`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ê±°ë‚˜ ì—¬ëŸ¬ í•€ì´ ìˆëŠ” GPIO í¬íŠ¸ì™€ ê°™ì€ ê²ƒì— ëŒ€í•´ `split()`ì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ê¸°ë³¸ ì›ì‹œ ì£¼ë³€ ì¥ì¹˜ êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ê³  ë” ë†’ì€ ìˆ˜ì¤€ì˜ APIë¥¼ ê°€ì§„ ìƒˆ ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ APIëŠ” ë˜í•œ ì§ë ¬ í¬íŠ¸ `new` í•¨ìˆ˜ê°€ PLLì„ êµ¬ì„±í•˜ê³  ëª¨ë“  í´ë¡ ì£¼íŒŒìˆ˜ë¥¼ ì„¤ì •í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼ë§Œ ìƒì„±í•  ìˆ˜ ìˆëŠ” ì¼ë¶€ `Clock` êµ¬ì¡°ì²´ì— ëŒ€í•œ ë¹Œë¦¼ì„ ìš”êµ¬í•˜ëŠ” ê²ƒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ í´ë¡ ì†ë„ë¥¼ ë¨¼ì € êµ¬ì„±í•˜ì§€ ì•Šê³  ì§ë ¬ í¬íŠ¸ ê°ì²´ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì§ë ¬ í¬íŠ¸ ê°ì²´ê°€ ì „ì†¡ ì†ë„ë¥¼ í´ë¡ í‹±ìœ¼ë¡œ ì˜ëª» ë³€í™˜í•˜ëŠ” ê²ƒì€ ì •ì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ì¼ë¶€ í¬ë ˆì´íŠ¸ëŠ” ê° GPIO í•€ì´ ìˆì„ ìˆ˜ ìˆëŠ” ìƒíƒœì— ëŒ€í•œ íŠ¹ìˆ˜ íŠ¸ë ˆì´íŠ¸ë¥¼ ì •ì˜í•˜ê¸°ë„ í•˜ì—¬ ì‚¬ìš©ìê°€ í•€ì„ ì£¼ë³€ ì¥ì¹˜ë¡œ ì „ë‹¬í•˜ê¸° ì „ì— í•€ì„ ì˜¬ë°”ë¥¸ ìƒíƒœ(ì˜ˆ: ì ì ˆí•œ ëŒ€ì²´ ê¸°ëŠ¥ ëª¨ë“œ ì„ íƒ)ë¡œ ì„¤ì •í•˜ë„ë¡ ìš”êµ¬í•©ë‹ˆë‹¤. ëª¨ë‘ ëŸ°íƒ€ì„ ë¹„ìš© ì—†ì´!"

#: src/start/registers.md:139
msgid "Let's see an example:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/start/registers.md:158
msgid "// Wrap up the SYSCTL struct into an object with a higher-layer API\n"
msgstr "// SYSCTL êµ¬ì¡°ì²´ë¥¼ ë” ë†’ì€ ìˆ˜ì¤€ì˜ APIë¥¼ ê°€ì§„ ê°ì²´ë¡œ ë˜í•‘\n"

#: src/start/registers.md:160
msgid "// Pick our oscillation settings\n"
msgstr "// ì§„ë™ ì„¤ì • ì„ íƒ\n"

#: src/start/registers.md:165
msgid "// Configure the PLL with those settings\n"
msgstr "// í•´ë‹¹ ì„¤ì •ìœ¼ë¡œ PLL êµ¬ì„±\n"

#: src/start/registers.md:168
msgid ""
"// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.\n"
"    // Note it needs to borrow `sc.power_control` so it can power up the "
"GPIO\n"
"    // peripheral automatically.\n"
msgstr ""
"// GPIO_PORTA êµ¬ì¡°ì²´ë¥¼ ë” ë†’ì€ ìˆ˜ì¤€ì˜ APIë¥¼ ê°€ì§„ ê°ì²´ë¡œ ë˜í•‘í•©ë‹ˆë‹¤.\n"
"    // GPIO ì£¼ë³€ ì¥ì¹˜ë¥¼ ìë™ìœ¼ë¡œ ì¼¤ ìˆ˜ ìˆë„ë¡ `sc.power_control`ì„ ë¹Œë ¤ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/start/registers.md:173
msgid "// Activate the UART.\n"
msgstr "// UART í™œì„±í™”.\n"

#: src/start/registers.md:176
msgid "// The transmit pin\n"
msgstr "// ì „ì†¡ í•€\n"

#: src/start/registers.md:180
msgid "// The receive pin\n"
msgstr "// ìˆ˜ì‹  í•€\n"

#: src/start/registers.md:184
msgid "// No RTS or CTS required\n"
msgstr "// RTS ë˜ëŠ” CTS í•„ìš” ì—†ìŒ\n"

#: src/start/registers.md:187
msgid "// The baud rate\n"
msgstr "// ì „ì†¡ ì†ë„\n"

#: src/start/registers.md:189
msgid "// Output handling\n"
msgstr "// ì¶œë ¥ ì²˜ë¦¬\n"

#: src/start/registers.md:191
msgid "// We need the clock rates to calculate the baud rate divisors\n"
msgstr "// ì „ì†¡ ì†ë„ ì œìˆ˜ë¥¼ ê³„ì‚°í•˜ë ¤ë©´ í´ë¡ ì†ë„ê°€ í•„ìš”í•©ë‹ˆë‹¤\n"

#: src/start/registers.md:193
msgid "// We need this to power up the UART peripheral\n"
msgstr "// UART ì£¼ë³€ ì¥ì¹˜ë¥¼ ì¼œë ¤ë©´ ì´ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤\n"

#: src/start/registers.md:198
msgid "\"Hello, World!\\r\\n\""
msgstr "\"Hello, World!\\r\\n\""

#: src/start/semihosting.md:3
msgid ""
"Semihosting is a mechanism that lets embedded devices do I/O on the host and "
"is mainly used to log messages to the host console. Semihosting requires a "
"debug session and pretty much nothing else (no extra wires!) so it's super "
"convenient to use. The downside is that it's super slow: each write "
"operation can take several milliseconds depending on the hardware debugger "
"(e.g. ST-Link) you use."
msgstr "ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì€ ì„ë² ë””ë“œ ì¥ì¹˜ê°€ í˜¸ìŠ¤íŠ¸ì—ì„œ I/Oë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë©° ì£¼ë¡œ í˜¸ìŠ¤íŠ¸ ì½˜ì†”ì— ë©”ì‹œì§€ë¥¼ ê¸°ë¡í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì€ ë””ë²„ê·¸ ì„¸ì…˜ì´ í•„ìš”í•˜ë©° ê·¸ ì™¸ì—ëŠ” ê±°ì˜ ì•„ë¬´ê²ƒë„ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ(ì¶”ê°€ ì „ì„  ì—†ìŒ!) ì‚¬ìš©í•˜ê¸° ë§¤ìš° í¸ë¦¬í•©ë‹ˆë‹¤. ë‹¨ì ì€ ë§¤ìš° ëŠë¦¬ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ê° ì“°ê¸° ì‘ì—…ì€ ì‚¬ìš©í•˜ëŠ” í•˜ë“œì›¨ì–´ ë””ë²„ê±°(ì˜ˆ: ST-Link)ì— ë”°ë¼ ìˆ˜ ë°€ë¦¬ì´ˆê°€ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/semihosting.md:9
msgid ""
"The [`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) "
"crate provides an API to do semihosting operations on Cortex-M devices. The "
"program below is the semihosting version of \"Hello, world!\":"
msgstr "[`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) í¬ë ˆì´íŠ¸ëŠ” Cortex-M ì¥ì¹˜ì—ì„œ ì„¸ë¯¸í˜¸ìŠ¤íŒ… ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì•„ë˜ í”„ë¡œê·¸ë¨ì€ \"Hello, world!\"ì˜ ì„¸ë¯¸í˜¸ìŠ¤íŒ… ë²„ì „ì…ë‹ˆë‹¤."

#: src/start/semihosting.md:32
msgid ""
"If you run this program on hardware you'll see the \"Hello, world!\" message "
"within the OpenOCD logs."
msgstr "ì´ í”„ë¡œê·¸ë¨ì„ í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰í•˜ë©´ OpenOCD ë¡œê·¸ ë‚´ì— \"Hello, world!\" ë©”ì‹œì§€ê°€ í‘œì‹œë©ë‹ˆë‹¤."

#: src/start/semihosting.md:42
msgid "You do need to enable semihosting in OpenOCD from GDB first:"
msgstr "ë¨¼ì € GDBì—ì„œ OpenOCDì˜ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ í™œì„±í™”í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/start/semihosting.md:48
msgid ""
"QEMU understands semihosting operations so the above program will also work "
"with `qemu-system-arm` without having to start a debug session. Note that "
"you'll need to pass the `-semihosting-config` flag to QEMU to enable "
"semihosting support; these flags are already included in the `.cargo/"
"config.toml` file of the template."
msgstr "QEMUëŠ” ì„¸ë¯¸í˜¸ìŠ¤íŒ… ì‘ì—…ì„ ì´í•´í•˜ë¯€ë¡œ ìœ„ í”„ë¡œê·¸ë¨ì€ ë””ë²„ê·¸ ì„¸ì…˜ì„ ì‹œì‘í•˜ì§€ ì•Šê³ ë„ `qemu-system-arm`ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤. ì„¸ë¯¸í˜¸ìŠ¤íŒ… ì§€ì›ì„ í™œì„±í™”í•˜ë ¤ë©´ QEMUì— `-semihosting-config` í”Œë˜ê·¸ë¥¼ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ í”Œë˜ê·¸ëŠ” í…œí”Œë¦¿ì˜ `.cargo/config.toml` íŒŒì¼ì— ì´ë¯¸ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/start/semihosting.md:61
msgid ""
"There's also an `exit` semihosting operation that can be used to terminate "
"the QEMU process. Important: do **not** use `debug::exit` on hardware; this "
"function can corrupt your OpenOCD session and you will not be able to debug "
"more programs until you restart it."
msgstr "QEMU í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” `exit` ì„¸ë¯¸í˜¸ìŠ¤íŒ… ì‘ì—…ë„ ìˆìŠµë‹ˆë‹¤. ì¤‘ìš”: í•˜ë“œì›¨ì–´ì—ì„œ `debug::exit`ë¥¼ ì‚¬ìš©í•˜ì§€ **ë§ˆì‹­ì‹œì˜¤**. ì´ í•¨ìˆ˜ëŠ” OpenOCD ì„¸ì…˜ì„ ì†ìƒì‹œí‚¬ ìˆ˜ ìˆìœ¼ë©° ë‹¤ì‹œ ì‹œì‘í•  ë•Œê¹Œì§€ ë” ì´ìƒ í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/start/semihosting.md:77 src/start/semihosting.md:115
msgid "\"blue\""
msgstr "\"íŒŒë€ìƒ‰\""

#: src/start/semihosting.md:79 src/start/semihosting.md:117
msgid "\"red\""
msgstr "\"ë¹¨ê°„ìƒ‰\""

#: src/start/semihosting.md:97
msgid ""
"One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. "
"This will let you write `no_std` run-pass tests that you can run on QEMU."
msgstr "ë§ˆì§€ë§‰ íŒ: íŒ¨ë‹‰ ë™ì‘ì„ `exit(EXIT_FAILURE)`ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ QEMUì—ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” `no_std` ì‹¤í–‰ í†µê³¼ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/semihosting.md:100
msgid ""
"For convenience, the `panic-semihosting` crate has an \"exit\" feature that "
"when enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to "
"the host stderr."
msgstr "í¸ì˜ë¥¼ ìœ„í•´ `panic-semihosting` í¬ë ˆì´íŠ¸ì—ëŠ” í™œì„±í™”ë˜ë©´ íŒ¨ë‹‰ ë©”ì‹œì§€ë¥¼ í˜¸ìŠ¤íŠ¸ stderrì— ê¸°ë¡í•œ í›„ `exit(EXIT_FAILURE)`ë¥¼ í˜¸ì¶œí•˜ëŠ” \"exit\" ê¸°ëŠ¥ì´ ìˆìŠµë‹ˆë‹¤."

#: src/start/semihosting.md:108
msgid "// features = [\"exit\"]\n"
msgstr "// ê¸°ëŠ¥ = [\"ì¢…ë£Œ\"]\n"

#: src/start/semihosting.md:123
msgid ""
"```text\n"
"$ cargo run\n"
"     Running `qemu-system-arm (..)\n"
"panicked at 'assertion failed: `(left == right)`\n"
"  left: `\"blue\"`,\n"
" right: `\"red\"`', examples/hello.rs:15:5\n"
"\n"
"$ echo $?\n"
"1\n"
"```"
msgstr "`bash\n$ cargo run\n     Running `qemu-system-arm (..)\npanicked at 'assertion failed: `(left == right)`\n  left: `\"blue\"`,\n right: `\"red\"`', examples/hello.rs:15:5\n\n$ echo $?\n1\n```"

#: src/start/semihosting.md:134
msgid ""
"**NOTE**: To enable this feature on `panic-semihosting`, edit your "
"`Cargo.toml` dependencies section where `panic-semihosting` is specified "
"with:"
msgstr "**ì°¸ê³ **: `panic-semihosting`ì—ì„œ ì´ ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ë ¤ë©´ `Cargo.toml` ì¢…ì†ì„± ì„¹ì…˜ì—ì„œ `panic-semihosting`ì´ ì§€ì •ëœ ë¶€ë¶„ì„ ë‹¤ìŒê³¼ ê°™ì´ í¸ì§‘í•˜ì‹­ì‹œì˜¤."

#: src/start/semihosting.md:137
msgid ""
"```toml\n"
"panic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n"
"```"
msgstr "`toml\npanic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n```"

#: src/start/semihosting.md:141
msgid ""
"where `VERSION` is the version desired. For more information on dependencies "
"features check the [`specifying dependencies`](https://doc.rust-lang.org/"
"cargo/reference/specifying-dependencies.html) section of the Cargo book."
msgstr "`VERSION`ì€ ì›í•˜ëŠ” ë²„ì „ì…ë‹ˆë‹¤. ì¢…ì†ì„± ê¸°ëŠ¥ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ Cargo ì±…ì˜ [`ì¢…ì†ì„± ì§€ì •`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) ì„¹ì…˜ì„ í™•ì¸í•˜ì‹­ì‹œì˜¤."


#: src/start/panicking.md:3
msgid ""
"Panicking is a core part of the Rust language. Built-in operations like "
"indexing are runtime checked for memory safety. When out of bounds indexing "
"is attempted this results in a panic."
msgstr "íŒ¨ë‹‰ì€ Rust ì–¸ì–´ì˜ í•µì‹¬ ë¶€ë¶„ì…ë‹ˆë‹¤. ì¸ë±ì‹±ê³¼ ê°™ì€ ë‚´ì¥ ì‘ì—…ì€ ë©”ëª¨ë¦¬ ì•ˆì „ì„ ìœ„í•´ ëŸ°íƒ€ì„ì— í™•ì¸ë©ë‹ˆë‹¤. ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì¸ë±ì‹±ì´ ì‹œë„ë˜ë©´ íŒ¨ë‹‰ì´ ë°œìƒí•©ë‹ˆë‹¤."

#: src/start/panicking.md:7
msgid ""
"In the standard library panicking has a defined behavior: it unwinds the "
"stack of the panicking thread, unless the user opted for aborting the "
"program on panics."
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ íŒ¨ë‹‰ì€ ì •ì˜ëœ ë™ì‘ì„ ê°€ì§‘ë‹ˆë‹¤. ì‚¬ìš©ìê°€ íŒ¨ë‹‰ ì‹œ í”„ë¡œê·¸ë¨ ì¤‘ë‹¨ì„ ì„ íƒí•˜ì§€ ì•ŠëŠ” í•œ íŒ¨ë‹‰ ìŠ¤ë ˆë“œì˜ ìŠ¤íƒì„ í•´ì œí•©ë‹ˆë‹¤."

#: src/start/panicking.md:11
msgid ""
"In programs without standard library, however, the panicking behavior is "
"left undefined. A behavior can be chosen by declaring a `#[panic_handler]` "
"function. This function must appear exactly _once_ in the dependency graph "
"of a program, and must have the following signature: `fn(&PanicInfo) -> !`, "
"where [`PanicInfo`](https://doc.rust-lang.org/core/panic/"
"struct.PanicInfo.html) is a struct containing information about the location "
"of the panic."
msgstr "ê·¸ëŸ¬ë‚˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì—†ëŠ” í”„ë¡œê·¸ë¨ì—ì„œëŠ” íŒ¨ë‹‰ ë™ì‘ì´ ì •ì˜ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ë‚¨ì•„ ìˆìŠµë‹ˆë‹¤. `#[panic_handler]` í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ì—¬ ë™ì‘ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ì˜ ì¢…ì†ì„± ê·¸ë˜í”„ì— ì •í™•íˆ _í•œ ë²ˆ_ ë‚˜íƒ€ë‚˜ì•¼ í•˜ë©° `fn(&PanicInfo) -> !` ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html)ëŠ” íŒ¨ë‹‰ ìœ„ì¹˜ì— ëŒ€í•œ ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ” êµ¬ì¡°ì²´ì…ë‹ˆë‹¤."

#: src/start/panicking.md:19
msgid ""
"Given that embedded systems range from user facing to safety critical "
"(cannot crash) there's no one size fits all panicking behavior but there are "
"plenty of commonly used behaviors. These common behaviors have been packaged "
"into crates that define the `#[panic_handler]` function. Some examples "
"include:"
msgstr "ì„ë² ë””ë“œ ì‹œìŠ¤í…œì€ ì‚¬ìš©ì ëŒ€ë©´ì—ì„œ ì•ˆì „ì— ì¤‘ìš”í•œ(ì¶©ëŒí•  ìˆ˜ ì—†ëŠ”) ì‹œìŠ¤í…œì— ì´ë¥´ê¸°ê¹Œì§€ ë‹¤ì–‘í•˜ë¯€ë¡œ ëª¨ë“  ê²½ìš°ì— ì ìš©ë˜ëŠ” ë‹¨ì¼ íŒ¨ë‹‰ ë™ì‘ì€ ì—†ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë™ì‘ì´ ë§ì´ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ì¼ë°˜ì ì¸ ë™ì‘ì€ `#[panic_handler]` í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” í¬ë ˆì´íŠ¸ë¡œ íŒ¨í‚¤ì§€í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ëª‡ ê°€ì§€ ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/start/panicking.md:24
msgid ""
"[`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the "
"abort instruction to be executed."
msgstr "[`panic-abort`](https://crates.io/crates/panic-abort). íŒ¨ë‹‰ì€ ì¤‘ë‹¨ ëª…ë ¹ì„ ì‹¤í–‰í•˜ê²Œ í•©ë‹ˆë‹¤."

#: src/start/panicking.md:25
msgid ""
"[`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the "
"program, or the current thread, to halt by entering an infinite loop."
msgstr "[`panic-halt`](https://crates.io/crates/panic-halt). íŒ¨ë‹‰ì€ í”„ë¡œê·¸ë¨ ë˜ëŠ” í˜„ì¬ ìŠ¤ë ˆë“œê°€ ë¬´í•œ ë£¨í”„ì— ì§„ì…í•˜ì—¬ ì¤‘ë‹¨ë˜ë„ë¡ í•©ë‹ˆë‹¤."

#: src/start/panicking.md:27
msgid ""
"[`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is "
"logged using the ITM, an ARM Cortex-M specific peripheral."
msgstr "[`panic-itm`](https://crates.io/crates/panic-itm). íŒ¨ë‹‰ ë©”ì‹œì§€ëŠ” ARM Cortex-M íŠ¹ì • ì£¼ë³€ ì¥ì¹˜ì¸ ITMì„ ì‚¬ìš©í•˜ì—¬ ê¸°ë¡ë©ë‹ˆë‹¤."

#: src/start/panicking.md:29
msgid ""
"[`panic-semihosting`](https://crates.io/crates/panic-semihosting). The "
"panicking message is logged to the host using the semihosting technique."
msgstr "[`panic-semihosting`](https://crates.io/crates/panic-semihosting). íŒ¨ë‹‰ ë©”ì‹œì§€ëŠ” ì„¸ë¯¸í˜¸ìŠ¤íŒ… ê¸°ìˆ ì„ ì‚¬ìš©í•˜ì—¬ í˜¸ìŠ¤íŠ¸ì— ê¸°ë¡ë©ë‹ˆë‹¤."

#: src/start/panicking.md:37
msgid ""
"You may be able to find even more crates searching for the [`panic-handler`]"
"(https://crates.io/keywords/panic-handler) keyword on crates.io."
msgstr "crates.ioì—ì„œ [`panic-handler`](https://crates.io/keywords/panic-handler) í‚¤ì›Œë“œë¥¼ ê²€ìƒ‰í•˜ì—¬ ë” ë§ì€ í¬ë ˆì´íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/panicking.md:42
msgid ""
"A program can pick one of these behaviors simply by linking to the "
"corresponding crate. The fact that the panicking behavior is expressed in "
"the source of an application as a single line of code is not only useful as "
"documentation but can also be used to change the panicking behavior "
"according to the compilation profile. For example:"
msgstr "í”„ë¡œê·¸ë¨ì€ í•´ë‹¹ í¬ë ˆì´íŠ¸ì— ë§í¬í•˜ê¸°ë§Œ í•˜ë©´ ì´ëŸ¬í•œ ë™ì‘ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŒ¨ë‹‰ ë™ì‘ì´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì†ŒìŠ¤ì— í•œ ì¤„ì˜ ì½”ë“œë¡œ í‘œí˜„ëœë‹¤ëŠ” ì‚¬ì‹¤ì€ ë¬¸ì„œí™”ì— ìœ ìš©í•  ë¿ë§Œ ì•„ë‹ˆë¼ ì»´íŒŒì¼ í”„ë¡œí•„ì— ë”°ë¼ íŒ¨ë‹‰ ë™ì‘ì„ ë³€ê²½í•˜ëŠ” ë°ì—ë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/start/panicking.md:51
msgid ""
"// dev profile: easier to debug panics; can put a breakpoint on "
"`rust_begin_unwind`\n"
msgstr "// ê°œë°œ í”„ë¡œí•„: íŒ¨ë‹‰ ë””ë²„ê¹…ì´ ë” ì‰¬ì›€; `rust_begin_unwind`ì— ì¤‘ë‹¨ì ì„ ì„¤ì •í•  ìˆ˜ ìˆìŒ\n"

#: src/start/panicking.md:55
msgid "// release profile: minimize the binary size of the application\n"
msgstr "// ë¦´ë¦¬ìŠ¤ í”„ë¡œí•„: ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë°”ì´ë„ˆë¦¬ í¬ê¸° ìµœì†Œí™”\n"

#: src/start/panicking.md:59 src/start/exceptions.md:17
#: src/collections/index.md:132
msgid "// ..\n"
msgstr "// ..\n"

#: src/start/panicking.md:63
msgid ""
"In this example the crate links to the `panic-halt` crate when built with "
"the dev profile (`cargo build`), but links to the `panic-abort` crate when "
"built with the release profile (`cargo build --release`)."
msgstr "ì´ ì˜ˆì—ì„œ í¬ë ˆì´íŠ¸ëŠ” ê°œë°œ í”„ë¡œí•„(`cargo build`)ë¡œ ë¹Œë“œë  ë•Œ `panic-halt` í¬ë ˆì´íŠ¸ì— ë§í¬ë˜ì§€ë§Œ ë¦´ë¦¬ìŠ¤ í”„ë¡œí•„(`cargo build --release`)ë¡œ ë¹Œë“œë  ë•ŒëŠ” `panic-abort` í¬ë ˆì´íŠ¸ì— ë§í¬ë©ë‹ˆë‹¤."

#: src/start/panicking.md:67
msgid ""
"The `use panic_abort as _;` form of the `use` statement is used to ensure "
"the `panic_abort` panic handler is included in our final executable while "
"making it clear to the compiler that we won't explicitly use anything from "
"the crate. Without the `as _` rename, the compiler would warn that we have "
"an unused import. Sometimes you might see `extern crate panic_abort` "
"instead, which is an older style used before the 2018 edition of Rust, and "
"should now only be used for \"sysroot\" crates (those distributed with Rust "
"itself) such as `proc_macro`, `alloc`, `std`, and `test`."
msgstr "`use panic_abort as _;` í˜•ì‹ì˜ `use` ë¬¸ì€ `panic_abort` íŒ¨ë‹‰ í•¸ë“¤ëŸ¬ê°€ ìµœì¢… ì‹¤í–‰ íŒŒì¼ì— í¬í•¨ë˜ë„ë¡ í•˜ëŠ” ë™ì‹œì— ì»´íŒŒì¼ëŸ¬ì—ê²Œ í¬ë ˆì´íŠ¸ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ì•„ë¬´ê²ƒë„ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²ƒì„ì„ ëª…í™•íˆ í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. `as _` ì´ë¦„ ë°”ê¾¸ê¸°ê°€ ì—†ìœ¼ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê°€ì ¸ì˜¤ê¸°ê°€ ìˆë‹¤ëŠ” ê²½ê³ ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤. ë•Œë¡œëŠ” ëŒ€ì‹  `extern crate panic_abort`ë¥¼ ë³¼ ìˆ˜ ìˆëŠ”ë°, ì´ëŠ” Rust 2018 ì—ë””ì…˜ ì´ì „ì— ì‚¬ìš©ëœ ì´ì „ ìŠ¤íƒ€ì¼ì´ë©° ì´ì œëŠ” `proc_macro`, `alloc`, `std` ë° `test`ì™€ ê°™ì´ Rust ìì²´ì™€ í•¨ê»˜ ë°°í¬ë˜ëŠ” \"sysroot\" í¬ë ˆì´íŠ¸ì—ë§Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/start/panicking.md:74
msgid "An example"
msgstr "ì˜ˆì‹œ"

#: src/start/panicking.md:76
msgid ""
"Here's an example that tries to index an array beyond its length. The "
"operation results in a panic."
msgstr "ë‹¤ìŒì€ ë°°ì—´ ê¸¸ì´ë¥¼ ì´ˆê³¼í•˜ì—¬ ì¸ë±ì‹±ì„ ì‹œë„í•˜ëŠ” ì˜ˆì…ë‹ˆë‹¤. ì´ ì‘ì—…ì€ íŒ¨ë‹‰ì„ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/start/panicking.md:91
msgid "// out of bounds access\n"
msgstr "// ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì ‘ê·¼\n"

#: src/start/panicking.md:97
msgid ""
"This example chose the `panic-semihosting` behavior which prints the panic "
"message to the host console using semihosting."
msgstr "ì´ ì˜ˆì—ì„œëŠ” ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ ì‚¬ìš©í•˜ì—¬ í˜¸ìŠ¤íŠ¸ ì½˜ì†”ì— íŒ¨ë‹‰ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ëŠ” `panic-semihosting` ë™ì‘ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤."

#: src/start/panicking.md:106
msgid ""
"You can try changing the behavior to `panic-halt` and confirm that no "
"message is printed in that case."
msgstr "ë™ì‘ì„ `panic-halt`ë¡œ ë³€ê²½í•˜ê³  ì´ ê²½ìš° ë©”ì‹œì§€ê°€ ì¶œë ¥ë˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."


#: src/start/exceptions.md:3
msgid ""
"Exceptions, and interrupts, are a hardware mechanism by which the processor "
"handles asynchronous events and fatal errors (e.g. executing an invalid "
"instruction). Exceptions imply preemption and involve exception handlers, "
"subroutines executed in response to the signal that triggered the event."
msgstr "ì˜ˆì™¸ ë° ì¸í„°ëŸ½íŠ¸ëŠ” í”„ë¡œì„¸ì„œê°€ ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë° ì¹˜ëª…ì ì¸ ì˜¤ë¥˜(ì˜ˆ: ì˜ëª»ëœ ëª…ë ¹ì–´ ì‹¤í–‰)ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•˜ë“œì›¨ì–´ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤. ì˜ˆì™¸ëŠ” ì„ ì ì„ ì˜ë¯¸í•˜ë©° ì´ë²¤íŠ¸ë¥¼ íŠ¸ë¦¬ê±°í•œ ì‹ í˜¸ì— ëŒ€í•œ ì‘ë‹µìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì„œë¸Œë£¨í‹´ì¸ ì˜ˆì™¸ ì²˜ë¦¬ê¸°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/exceptions.md:8
msgid ""
"The `cortex-m-rt` crate provides an [`exception`](https://docs.rs/cortex-m-"
"rt-macros/latest/cortex_m_rt_macros/attr.exception.html) attribute to "
"declare exception handlers."
msgstr "`cortex-m-rt` í¬ë ˆì´íŠ¸ëŠ” ì˜ˆì™¸ ì²˜ë¦¬ê¸°ë¥¼ ì„ ì–¸í•˜ëŠ” [`exception`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html) ì†ì„±ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/start/exceptions.md:14
msgid "// Exception handler for the SysTick (System Timer) exception\n"
msgstr "// SysTick(ì‹œìŠ¤í…œ íƒ€ì´ë¨¸) ì˜ˆì™¸ì— ëŒ€í•œ ì˜ˆì™¸ ì²˜ë¦¬ê¸°\n"

#: src/start/exceptions.md:21
msgid ""
"Other than the `exception` attribute exception handlers look like plain "
"functions but there's one more difference: `exception` handlers can _not_ be "
"called by software. Following the previous example, the statement "
"`SysTick();` would result in a compilation error."
msgstr "`exception` ì†ì„± ì™¸ì— ì˜ˆì™¸ ì²˜ë¦¬ê¸°ëŠ” ì¼ë°˜ í•¨ìˆ˜ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ í•œ ê°€ì§€ ì°¨ì´ì ì´ ë” ìˆìŠµë‹ˆë‹¤. `exception` ì²˜ë¦¬ê¸°ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ í˜¸ì¶œí•  ìˆ˜ _ì—†ìŠµë‹ˆë‹¤_. ì´ì „ ì˜ˆì— ë”°ë¼ `SysTick();` ë¬¸ì€ ì»´íŒŒì¼ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/start/exceptions.md:26
msgid ""
"This behavior is pretty much intended and it's required to provide a "
"feature: `static mut` variables declared _inside_ `exception` handlers are "
"_safe_ to use."
msgstr "ì´ ë™ì‘ì€ ê±°ì˜ ì˜ë„ëœ ê²ƒì´ë©° ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ë° í•„ìš”í•©ë‹ˆë‹¤. `exception` ì²˜ë¦¬ê¸° _ë‚´ë¶€_ì— ì„ ì–¸ëœ `static mut` ë³€ìˆ˜ëŠ” _ì•ˆì „í•˜ê²Œ_ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:34
msgid "// `COUNT` has transformed to type `&mut u32` and it's safe to use\n"
msgstr "// `COUNT`ëŠ” `&mut u32` ìœ í˜•ìœ¼ë¡œ ë³€í™˜ë˜ì—ˆìœ¼ë©° ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/start/exceptions.md:39
msgid ""
"As you may know, using `static mut` variables in a function makes it [_non-"
"reentrant_](https://en.wikipedia.org/wiki/Reentrancy_(computing)). It's "
"undefined behavior to call a non-reentrant function, directly or indirectly, "
"from more than one exception / interrupt handler or from `main` and one or "
"more exception / interrupt handlers."
msgstr "ì•„ì‹œë‹¤ì‹œí”¼ í•¨ìˆ˜ì—ì„œ `static mut` ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ [_ë¹„ì¬ì§„ì…_](https://en.wikipedia.org/wiki/Reentrancy_(computing))ì´ ë©ë‹ˆë‹¤. ë‘˜ ì´ìƒì˜ ì˜ˆì™¸/ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸° ë˜ëŠ” `main` ë° í•˜ë‚˜ ì´ìƒì˜ ì˜ˆì™¸/ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ì—ì„œ ì§ì ‘ ë˜ëŠ” ê°„ì ‘ì ìœ¼ë¡œ ë¹„ì¬ì§„ì… í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì…ë‹ˆë‹¤."

#: src/start/exceptions.md:44
msgid ""
"Safe Rust must never result in undefined behavior so non-reentrant functions "
"must be marked as `unsafe`. Yet I just told that `exception` handlers can "
"safely use `static mut` variables. How is this possible? This is possible "
"because `exception` handlers can _not_ be called by software thus reentrancy "
"is not possible. These handlers are called by the hardware itself which is "
"assumed to be physically non-concurrent."
msgstr "ì•ˆì „í•œ RustëŠ” ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ ì´ˆë˜í•´ì„œëŠ” ì•ˆ ë˜ë¯€ë¡œ ë¹„ì¬ì§„ì… í•¨ìˆ˜ëŠ” `unsafe`ë¡œ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ë°©ê¸ˆ `exception` ì²˜ë¦¬ê¸°ê°€ `static mut` ë³€ìˆ˜ë¥¼ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ê³  ë§í–ˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ ì´ê²ƒì´ ê°€ëŠ¥í• ê¹Œìš”? `exception` ì²˜ë¦¬ê¸°ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ í˜¸ì¶œí•  ìˆ˜ _ì—†ìœ¼ë¯€ë¡œ_ ì¬ì§„ì…ì´ ë¶ˆê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ì²˜ë¦¬ê¸°ëŠ” ë¬¼ë¦¬ì ìœ¼ë¡œ ë¹„ë™ì‹œì ì´ë¼ê³  ê°€ì •ë˜ëŠ” í•˜ë“œì›¨ì–´ ìì²´ì—ì„œ í˜¸ì¶œë©ë‹ˆë‹¤."

#: src/start/exceptions.md:50
msgid ""
"As a result, in the context of exception handlers in embedded systems, the "
"absence of concurrent invocations of the same handler ensures that there are "
"no reentrancy issues, even if the handler uses static mutable variables."
msgstr "ê²°ê³¼ì ìœ¼ë¡œ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì˜ ì˜ˆì™¸ ì²˜ë¦¬ê¸° ì»¨í…ìŠ¤íŠ¸ì—ì„œ ë™ì¼í•œ ì²˜ë¦¬ê¸°ì˜ ë™ì‹œ í˜¸ì¶œì´ ì—†ìœ¼ë©´ ì²˜ë¦¬ê¸°ê°€ ì •ì  ê°€ë³€ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„ ì¬ì§„ì… ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:52
msgid ""
"In a multicore system, where multiple processor cores are executing code "
"concurrently, the potential for reentrancy issues becomes relevant again, "
"even within exception handlers. While each core may have its own set of "
"exception handlers, there can still be scenarios where multiple cores "
"attempt to execute the same exception handler simultaneously.  \n"
"To address this concern in a multicore environment, proper synchronization "
"mechanisms need to be employed within the exception handlers to ensure that "
"access to shared resources is properly coordinated among the cores. This "
"typically involves the use of techniques such as locks, semaphores, or "
"atomic operations to prevent data races and maintain data integrity"
msgstr "ì—¬ëŸ¬ í”„ë¡œì„¸ì„œ ì½”ì–´ê°€ ì½”ë“œë¥¼ ë™ì‹œì— ì‹¤í–‰í•˜ëŠ” ë©€í‹°ì½”ì–´ ì‹œìŠ¤í…œì—ì„œëŠ” ì˜ˆì™¸ ì²˜ë¦¬ê¸° ë‚´ì—ì„œë„ ì¬ì§„ì… ë¬¸ì œì˜ ê°€ëŠ¥ì„±ì´ ë‹¤ì‹œ ê´€ë ¨ë©ë‹ˆë‹¤. ê° ì½”ì–´ì— ìì²´ ì˜ˆì™¸ ì²˜ë¦¬ê¸° ì„¸íŠ¸ê°€ ìˆì„ ìˆ˜ ìˆì§€ë§Œ ì—¬ëŸ¬ ì½”ì–´ê°€ ë™ì‹œì— ë™ì¼í•œ ì˜ˆì™¸ ì²˜ë¦¬ê¸°ë¥¼ ì‹¤í–‰í•˜ë ¤ê³  ì‹œë„í•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ê°€ ì—¬ì „íˆ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. \në©€í‹°ì½”ì–´ í™˜ê²½ì—ì„œ ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ì˜ˆì™¸ ì²˜ë¦¬ê¸° ë‚´ì—ì„œ ì ì ˆí•œ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì½”ì–´ ê°„ì— ê³µìœ  ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ê°€ ì ì ˆí•˜ê²Œ ì¡°ì •ë˜ë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì ê¸ˆ, ì„¸ë§ˆí¬ì–´ ë˜ëŠ” ì›ìì  ì—°ì‚°ê³¼ ê°™ì€ ê¸°ìˆ ì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ê²½ìŸì„ ë°©ì§€í•˜ê³  ë°ì´í„° ë¬´ê²°ì„±ì„ ìœ ì§€í•˜ëŠ” ê²ƒì´ í¬í•¨ë©ë‹ˆë‹¤."

#: src/start/exceptions.md:55
msgid ""
"Note that the `exception` attribute transforms definitions of static "
"variables inside the function by wrapping them into `unsafe` blocks and "
"providing us with new appropriate variables of type `&mut` of the same name. "
"Thus we can dereference the reference via `*` to access the values of the "
"variables without needing to wrap them in an `unsafe` block."
msgstr "`exception` ì†ì„±ì€ í•¨ìˆ˜ ë‚´ì˜ ì •ì  ë³€ìˆ˜ ì •ì˜ë¥¼ `unsafe` ë¸”ë¡ìœ¼ë¡œ ë˜í•‘í•˜ê³  ë™ì¼í•œ ì´ë¦„ì˜ `&mut` ìœ í˜•ì˜ ìƒˆ ì ì ˆí•œ ë³€ìˆ˜ë¥¼ ì œê³µí•˜ì—¬ ë³€í™˜í•©ë‹ˆë‹¤. ë”°ë¼ì„œ `unsafe` ë¸”ë¡ìœ¼ë¡œ ë˜í•‘í•  í•„ìš” ì—†ì´ `*`ë¥¼ í†µí•´ ì°¸ì¡°ë¥¼ ì—­ì°¸ì¡°í•˜ì—¬ ë³€ìˆ˜ ê°’ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:61
msgid "A complete example"
msgstr "ì™„ì „í•œ ì˜ˆì‹œ"

#: src/start/exceptions.md:63
msgid ""
"Here's an example that uses the system timer to raise a `SysTick` exception "
"roughly every second. The `SysTick` exception handler keeps track of how "
"many times it has been called in the `COUNT` variable and then prints the "
"value of `COUNT` to the host console using semihosting."
msgstr "ë‹¤ìŒì€ ì‹œìŠ¤í…œ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•½ 1ì´ˆë§ˆë‹¤ `SysTick` ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì˜ˆì…ë‹ˆë‹¤. `SysTick` ì˜ˆì™¸ ì²˜ë¦¬ê¸°ëŠ” `COUNT` ë³€ìˆ˜ì—ì„œ í˜¸ì¶œëœ íšŸìˆ˜ë¥¼ ì¶”ì í•œ ë‹¤ìŒ ì„¸ë¯¸í˜¸ìŠ¤íŒ…ì„ ì‚¬ìš©í•˜ì—¬ `COUNT` ê°’ì„ í˜¸ìŠ¤íŠ¸ ì½˜ì†”ì— ì¶œë ¥í•©ë‹ˆë‹¤."

#: src/start/exceptions.md:68
msgid ""
"**NOTE**: You can run this example on any Cortex-M device; you can also run "
"it on QEMU"
msgstr "**ì°¸ê³ **: ì´ ì˜ˆì œëŠ” ëª¨ë“  Cortex-M ì¥ì¹˜ì—ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆìœ¼ë©° QEMUì—ì„œë„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:92
msgid ""
"// configures the system timer to trigger a SysTick exception every second\n"
msgstr "// ì‹œìŠ¤í…œ íƒ€ì´ë¨¸ë¥¼ 1ì´ˆë§ˆë‹¤ SysTick ì˜ˆì™¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ë„ë¡ êµ¬ì„±í•©ë‹ˆë‹¤\n"

#: src/start/exceptions.md:94
msgid ""
"// this is configured for the LM3S6965 which has a default CPU clock of 12 "
"MHz\n"
msgstr "// ì´ê²ƒì€ ê¸°ë³¸ CPU í´ë¡ì´ 12MHzì¸ LM3S6965ìš©ìœ¼ë¡œ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤\n"

#: src/start/exceptions.md:110
msgid "// Lazy initialization\n"
msgstr "// ì§€ì—° ì´ˆê¸°í™”\n"

#: src/start/exceptions.md:116
msgid "\"{}\""
msgstr "\"{}\""

#: src/start/exceptions.md:119
msgid ""
"// IMPORTANT omit this `if` block if running on real hardware or your\n"
"    // debugger will end in an inconsistent state\n"
msgstr "// ì¤‘ìš”: ì‹¤ì œ í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜ ë””ë²„ê±°ê°€ ì¼ê´€ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì¢…ë£Œë  ê²½ìš° ì´ `if` ë¸”ë¡ì„ ìƒëµí•˜ì‹­ì‹œì˜¤\n"

#: src/start/exceptions.md:122
msgid "// This will terminate the QEMU process\n"
msgstr "// QEMU í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤\n"

#: src/start/exceptions.md:132
msgid ""
"```toml\n"
"[dependencies]\n"
"cortex-m = \"0.5.7\"\n"
"cortex-m-rt = \"0.6.3\"\n"
"panic-halt = \"0.2.0\"\n"
"cortex-m-semihosting = \"0.3.1\"\n"
"```"
msgstr "`toml\n[dependencies]\ncortex-m = \"0.5.7\"\ncortex-m-rt = \"0.6.3\"\npanic-halt = \"0.2.0\"\ncortex-m-semihosting = \"0.3.1\"\n```"

#: src/start/exceptions.md:146
msgid ""
"If you run this on the Discovery board you'll see the output on the OpenOCD "
"console. Also, the program will _not_ stop when the count reaches 9."
msgstr "Discovery ë³´ë“œì—ì„œ ì‹¤í–‰í•˜ë©´ OpenOCD ì½˜ì†”ì— ì¶œë ¥ì´ í‘œì‹œë©ë‹ˆë‹¤. ë˜í•œ ì¹´ìš´íŠ¸ê°€ 9ì— ë„ë‹¬í•´ë„ í”„ë¡œê·¸ë¨ì´ ì¤‘ì§€ë˜ì§€ _ì•ŠìŠµë‹ˆë‹¤_."

#: src/start/exceptions.md:149
msgid "The default exception handler"
msgstr "ê¸°ë³¸ ì˜ˆì™¸ ì²˜ë¦¬ê¸°"

#: src/start/exceptions.md:151
msgid ""
"What the `exception` attribute actually does is _override_ the default "
"exception handler for a specific exception. If you don't override the "
"handler for a particular exception it will be handled by the "
"`DefaultHandler` function, which defaults to:"
msgstr "`exception` ì†ì„±ì´ ì‹¤ì œë¡œ í•˜ëŠ” ì¼ì€ íŠ¹ì • ì˜ˆì™¸ì— ëŒ€í•œ ê¸°ë³¸ ì˜ˆì™¸ ì²˜ë¦¬ê¸°ë¥¼ _ì¬ì •ì˜_í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. íŠ¹ì • ì˜ˆì™¸ì— ëŒ€í•œ ì²˜ë¦¬ê¸°ë¥¼ ì¬ì •ì˜í•˜ì§€ ì•Šìœ¼ë©´ `DefaultHandler` í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬ë˜ë©° ê¸°ë³¸ê°’ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:162
msgid ""
"This function is provided by the `cortex-m-rt` crate and marked as "
"`#[no_mangle]` so you can put a breakpoint on \"DefaultHandler\" and catch "
"_unhandled_ exceptions."
msgstr "ì´ í•¨ìˆ˜ëŠ” `cortex-m-rt` í¬ë ˆì´íŠ¸ì—ì„œ ì œê³µí•˜ë©° `#[no_mangle]`ë¡œ í‘œì‹œë˜ì–´ ìˆìœ¼ë¯€ë¡œ \"DefaultHandler\"ì— ì¤‘ë‹¨ì ì„ ì„¤ì •í•˜ê³  _ì²˜ë¦¬ë˜ì§€ ì•Šì€_ ì˜ˆì™¸ë¥¼ ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:166
msgid ""
"It's possible to override this `DefaultHandler` using the `exception` "
"attribute:"
msgstr "`exception` ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ ì´ `DefaultHandler`ë¥¼ ì¬ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:171
msgid "// custom default handler\n"
msgstr "// ì‚¬ìš©ì ì§€ì • ê¸°ë³¸ ì²˜ë¦¬ê¸°\n"

#: src/start/exceptions.md:175
msgid ""
"The `irqn` argument indicates which exception is being serviced. A negative "
"value indicates that a Cortex-M exception is being serviced; and zero or a "
"positive value indicate that a device specific exception, AKA interrupt, is "
"being serviced."
msgstr "`irqn` ì¸ìˆ˜ëŠ” ì„œë¹„ìŠ¤ ì¤‘ì¸ ì˜ˆì™¸ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ìŒìˆ˜ ê°’ì€ Cortex-M ì˜ˆì™¸ê°€ ì„œë¹„ìŠ¤ ì¤‘ì„ì„ ë‚˜íƒ€ë‚´ê³  0 ë˜ëŠ” ì–‘ìˆ˜ ê°’ì€ ì¥ì¹˜ë³„ ì˜ˆì™¸(ì¼ëª… ì¸í„°ëŸ½íŠ¸)ê°€ ì„œë¹„ìŠ¤ ì¤‘ì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/start/exceptions.md:180
msgid "The hard fault handler"
msgstr "í•˜ë“œ í´íŠ¸ ì²˜ë¦¬ê¸°"

#: src/start/exceptions.md:182
msgid ""
"The `HardFault` exception is a bit special. This exception is fired when the "
"program enters an invalid state so its handler can _not_ return as that "
"could result in undefined behavior. Also, the runtime crate does a bit of "
"work before the user defined `HardFault` handler is invoked to improve "
"debuggability."
msgstr "`HardFault` ì˜ˆì™¸ëŠ” ì•½ê°„ íŠ¹ë³„í•©ë‹ˆë‹¤. ì´ ì˜ˆì™¸ëŠ” í”„ë¡œê·¸ë¨ì´ ì˜ëª»ëœ ìƒíƒœì— ë“¤ì–´ê°ˆ ë•Œ ë°œìƒí•˜ë¯€ë¡œ ì²˜ë¦¬ê¸°ê°€ ë°˜í™˜í•  ìˆ˜ _ì—†ìŠµë‹ˆë‹¤_. ê·¸ë ‡ê²Œ í•˜ë©´ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì´ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë˜í•œ ëŸ°íƒ€ì„ í¬ë ˆì´íŠ¸ëŠ” ì‚¬ìš©ì ì •ì˜ `HardFault` ì²˜ë¦¬ê¸°ê°€ í˜¸ì¶œë˜ê¸° ì „ì— ë””ë²„ê¹… ê°€ëŠ¥ì„±ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•´ ì•½ê°„ì˜ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/start/exceptions.md:187
msgid ""
"The result is that the `HardFault` handler must have the following "
"signature: `fn(&ExceptionFrame) -> !`. The argument of the handler is a "
"pointer to registers that were pushed into the stack by the exception. These "
"registers are a snapshot of the processor state at the moment the exception "
"was triggered and are useful to diagnose a hard fault."
msgstr "ê²°ê³¼ì ìœ¼ë¡œ `HardFault` ì²˜ë¦¬ê¸°ëŠ” `fn(&ExceptionFrame) -> !` ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤. ì²˜ë¦¬ê¸°ì˜ ì¸ìˆ˜ëŠ” ì˜ˆì™¸ì— ì˜í•´ ìŠ¤íƒì— í‘¸ì‹œëœ ë ˆì§€ìŠ¤í„°ì— ëŒ€í•œ í¬ì¸í„°ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë ˆì§€ìŠ¤í„°ëŠ” ì˜ˆì™¸ê°€ íŠ¸ë¦¬ê±°ëœ ìˆœê°„ì˜ í”„ë¡œì„¸ì„œ ìƒíƒœ ìŠ¤ëƒ…ìƒ·ì´ë©° í•˜ë“œ í´íŠ¸ë¥¼ ì§„ë‹¨í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤."

#: src/start/exceptions.md:193
msgid ""
"Here's an example that performs an illegal operation: a read to a "
"nonexistent memory location."
msgstr "ë‹¤ìŒì€ ì˜ëª»ëœ ì‘ì—…(ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ ìœ„ì¹˜ ì½ê¸°)ì„ ìˆ˜í–‰í•˜ëŠ” ì˜ˆì…ë‹ˆë‹¤."

#: src/start/exceptions.md:196
msgid ""
"**NOTE**: This program won't work, i.e. it won't crash, on QEMU because "
"`qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will "
"happily return `0 `on reads to invalid memory."
msgstr "**ì°¸ê³ **: ì´ í”„ë¡œê·¸ë¨ì€ QEMUì—ì„œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¦‰, ì¶©ëŒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `qemu-system-arm -machine lm3s6965evb`ëŠ” ë©”ëª¨ë¦¬ ë¡œë“œë¥¼ í™•ì¸í•˜ì§€ ì•Šê³  ì˜ëª»ëœ ë©”ëª¨ë¦¬ ì½ê¸° ì‹œ `0`ì„ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/start/exceptions.md:214
msgid "// read a nonexistent memory location\n"
msgstr "// ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ ìœ„ì¹˜ ì½ê¸°\n"

#: src/start/exceptions.md:225
#: src/static-guarantees/typestate-programming.md:48
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/start/exceptions.md:232
msgid ""
"The `HardFault` handler prints the `ExceptionFrame` value. If you run this "
"you'll see something like this on the OpenOCD console."
msgstr "`HardFault` ì²˜ë¦¬ê¸°ëŠ” `ExceptionFrame` ê°’ì„ ì¶œë ¥í•©ë‹ˆë‹¤. ì´ê²ƒì„ ì‹¤í–‰í•˜ë©´ OpenOCD ì½˜ì†”ì— ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤."

#: src/start/exceptions.md:250
msgid ""
"The `pc` value is the value of the Program Counter at the time of the "
"exception and it points to the instruction that triggered the exception."
msgstr "`pc` ê°’ì€ ì˜ˆì™¸ ë°œìƒ ì‹œì ì˜ í”„ë¡œê·¸ë¨ ì¹´ìš´í„° ê°’ì´ë©° ì˜ˆì™¸ë¥¼ íŠ¸ë¦¬ê±°í•œ ëª…ë ¹ì–´ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#: src/start/exceptions.md:253
msgid "If you look at the disassembly of the program:"
msgstr "í”„ë¡œê·¸ë¨ì˜ ë””ìŠ¤ì–´ì…ˆë¸”ë¦¬ë¥¼ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/start/exceptions.md:266
msgid ""
"You can lookup the value of the program counter `0x0800094a` in the "
"disassembly. You'll see that a load operation (`ldr r0, [r0]` ) caused the "
"exception. The `r0` field of `ExceptionFrame` will tell you the value of "
"register `r0` was `0x3fff_fffe` at that time."
msgstr "ë””ìŠ¤ì–´ì…ˆë¸”ë¦¬ì—ì„œ í”„ë¡œê·¸ë¨ ì¹´ìš´í„° `0x0800094a`ì˜ ê°’ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¡œë“œ ì‘ì—…(`ldr r0, [r0]`)ì´ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œì¼°ìŒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `ExceptionFrame`ì˜ `r0` í•„ë“œëŠ” ë‹¹ì‹œ ë ˆì§€ìŠ¤í„° `r0`ì˜ ê°’ì´ `0x3fff_fffe`ì˜€ìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤."


#: src/start/interrupts.md:3
msgid ""
"Interrupts differ from exceptions in a variety of ways but their operation "
"and use is largely similar and they are also handled by the same interrupt "
"controller. Whereas exceptions are defined by the Cortex-M architecture, "
"interrupts are always vendor (and often even chip) specific implementations, "
"both in naming and functionality."
msgstr "ì¸í„°ëŸ½íŠ¸ëŠ” ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ì˜ˆì™¸ì™€ ë‹¤ë¥´ì§€ë§Œ ì‘ë™ ë° ì‚¬ìš©ì€ ëŒ€ì²´ë¡œ ìœ ì‚¬í•˜ë©° ë™ì¼í•œ ì¸í„°ëŸ½íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ì˜ˆì™¸ëŠ” Cortex-M ì•„í‚¤í…ì²˜ì— ì˜í•´ ì •ì˜ë˜ëŠ” ë°˜ë©´, ì¸í„°ëŸ½íŠ¸ëŠ” í•­ìƒ ê³µê¸‰ì—…ì²´(ê·¸ë¦¬ê³  ì¢…ì¢… ì¹©)ë³„ êµ¬í˜„ì´ë©° ì´ë¦„ê³¼ ê¸°ëŠ¥ ëª¨ë‘ì—ì„œ ê·¸ë ‡ìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:9
msgid ""
"Interrupts do allow for a lot of flexibility which needs to be accounted for "
"when attempting to use them in an advanced way. We will not cover those uses "
"in this book, however it is a good idea to keep the following in mind:"
msgstr "ì¸í„°ëŸ½íŠ¸ëŠ” ê³ ê¸‰ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ë ¤ê³  í•  ë•Œ ê³ ë ¤í•´ì•¼ í•  ë§ì€ ìœ ì—°ì„±ì„ í—ˆìš©í•©ë‹ˆë‹¤. ì´ ì±…ì—ì„œëŠ” ì´ëŸ¬í•œ ì‚¬ìš©ë²•ì„ ë‹¤ë£¨ì§€ ì•Šì§€ë§Œ ë‹¤ìŒ ì‚¬í•­ì„ ì—¼ë‘ì— ë‘ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:13
msgid ""
"Interrupts have programmable priorities which determine their handlers' "
"execution order"
msgstr "ì¸í„°ëŸ½íŠ¸ì—ëŠ” ì²˜ë¦¬ê¸°ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ê²°ì •í•˜ëŠ” í”„ë¡œê·¸ë˜ë° ê°€ëŠ¥í•œ ìš°ì„ ìˆœìœ„ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:14
msgid ""
"Interrupts can nest and preempt, i.e. execution of an interrupt handler "
"might be interrupted by another higher-priority interrupt"
msgstr "ì¸í„°ëŸ½íŠ¸ëŠ” ì¤‘ì²© ë° ì„ ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¦‰, ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸° ì‹¤í–‰ì´ ë‹¤ë¥¸ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì¸í„°ëŸ½íŠ¸ì— ì˜í•´ ì¤‘ë‹¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:15
msgid ""
"In general the reason causing the interrupt to trigger needs to be cleared "
"to prevent re-entering the interrupt handler endlessly"
msgstr "ì¼ë°˜ì ìœ¼ë¡œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ì— ëì—†ì´ ë‹¤ì‹œ ë“¤ì–´ê°€ëŠ” ê²ƒì„ ë°©ì§€í•˜ë ¤ë©´ ì¸í„°ëŸ½íŠ¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” ì›ì¸ì„ ì§€ì›Œì•¼ í•©ë‹ˆë‹¤."

#: src/start/interrupts.md:17
msgid "The general initialization steps at runtime are always the same:"
msgstr "ëŸ°íƒ€ì„ì˜ ì¼ë°˜ì ì¸ ì´ˆê¸°í™” ë‹¨ê³„ëŠ” í•­ìƒ ë™ì¼í•©ë‹ˆë‹¤."

#: src/start/interrupts.md:18
msgid ""
"Setup the peripheral(s) to generate interrupts requests at the desired "
"occasions"
msgstr "ì›í•˜ëŠ” ê²½ìš°ì— ì¸í„°ëŸ½íŠ¸ ìš”ì²­ì„ ìƒì„±í•˜ë„ë¡ ì£¼ë³€ ì¥ì¹˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤."

#: src/start/interrupts.md:19
msgid ""
"Set the desired priority of the interrupt handler in the interrupt controller"
msgstr "ì¸í„°ëŸ½íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ì˜ ì›í•˜ëŠ” ìš°ì„ ìˆœìœ„ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤."

#: src/start/interrupts.md:20
msgid "Enable the interrupt handler in the interrupt controller"
msgstr "ì¸í„°ëŸ½íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ë¥¼ í™œì„±í™”í•©ë‹ˆë‹¤."

#: src/start/interrupts.md:22
msgid ""
"Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`]"
"(https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/"
"attr.interrupt.html) attribute to declare interrupt handlers. The available "
"interrupts (and their position in the interrupt handler table) are usually "
"automatically generated via `svd2rust` from a SVD description."
msgstr "ì˜ˆì™¸ì™€ ìœ ì‚¬í•˜ê²Œ `cortex-m-rt` í¬ë ˆì´íŠ¸ëŠ” ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ë¥¼ ì„ ì–¸í•˜ëŠ” [`interrupt`](https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html) ì†ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. ì‚¬ìš© ê°€ëŠ¥í•œ ì¸í„°ëŸ½íŠ¸(ë° ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸° í…Œì´ë¸”ì—ì„œì˜ ìœ„ì¹˜)ëŠ” ì¼ë°˜ì ìœ¼ë¡œ SVD ì„¤ëª…ì—ì„œ `svd2rust`ë¥¼ í†µí•´ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤."

#: src/start/interrupts.md:30
msgid "// Interrupt handler for the Timer2 interrupt\n"
msgstr "// Timer2 ì¸í„°ëŸ½íŠ¸ì— ëŒ€í•œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°\n"

#: src/start/interrupts.md:33
msgid ""
"// ..\n"
"    // Clear reason for the generated interrupt request\n"
msgstr ""
"// ..\n"
"    // ìƒì„±ëœ ì¸í„°ëŸ½íŠ¸ ìš”ì²­ì˜ ì›ì¸ ì§€ìš°ê¸°\n"

#: src/start/interrupts.md:38
msgid ""
"Interrupt handlers look like plain functions (except for the lack of "
"arguments) similar to exception handlers. However they can not be called "
"directly by other parts of the firmware due to the special calling "
"conventions. It is however possible to generate interrupt requests in "
"software to trigger a diversion to the interrupt handler."
msgstr "ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ëŠ” ì˜ˆì™¸ ì²˜ë¦¬ê¸°ì™€ ìœ ì‚¬í•˜ê²Œ ì¼ë°˜ í•¨ìˆ˜ì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤(ì¸ìˆ˜ê°€ ì—†ë‹¤ëŠ” ì  ì œì™¸). ê·¸ëŸ¬ë‚˜ íŠ¹ìˆ˜ í˜¸ì¶œ ê·œì¹™ìœ¼ë¡œ ì¸í•´ íŒì›¨ì–´ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œ ì§ì ‘ í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ì¸í„°ëŸ½íŠ¸ ìš”ì²­ì„ ìƒì„±í•˜ì—¬ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸°ë¡œ ì „í™˜ì„ íŠ¸ë¦¬ê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:44
msgid ""
"Similar to exception handlers it is also possible to declare `static mut` "
"variables inside the interrupt handlers for _safe_ state keeping."
msgstr "ì˜ˆì™¸ ì²˜ë¦¬ê¸°ì™€ ìœ ì‚¬í•˜ê²Œ _ì•ˆì „í•œ_ ìƒíƒœ ìœ ì§€ë¥¼ ìœ„í•´ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ê¸° ë‚´ì— `static mut` ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/start/interrupts.md:52
msgid "// `COUNT` has type `&mut u32` and it's safe to use\n"
msgstr "// `COUNT`ëŠ” `&mut u32` ìœ í˜•ì´ë©° ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/start/interrupts.md:57
msgid ""
"For a more detailed description about the mechanisms demonstrated here "
"please refer to the [exceptions section](./exceptions.md)."
msgstr "ì—¬ê¸°ì„œ ì„¤ëª…ëœ ë©”ì»¤ë‹ˆì¦˜ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ì˜ˆì™¸ ì„¹ì…˜](./exceptions.md)ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."


#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr "ì£¼ë³€ ì¥ì¹˜ë€ ë¬´ì—‡ì¸ê°€ìš”?"

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr "ëŒ€ë¶€ë¶„ì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ëŠ” CPU, RAM ë˜ëŠ” í”Œë˜ì‹œ ë©”ëª¨ë¦¬ ì™¸ì— ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ì‹¤ë¦¬ì½˜ ì„¹ì…˜ê³¼ ì„¼ì„œ, ëª¨í„° ì»¨íŠ¸ë¡¤ëŸ¬ ë˜ëŠ” ë””ìŠ¤í”Œë ˆì´ë‚˜ í‚¤ë³´ë“œì™€ ê°™ì€ ì¸ê°„ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ì£¼ë³€ í™˜ê²½ê³¼ ì§ì ‘ ë° ê°„ì ‘ì ìœ¼ë¡œ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ì‹¤ë¦¬ì½˜ ì„¹ì…˜ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬ì„± ìš”ì†Œë¥¼ ì´ì¹­í•˜ì—¬ ì£¼ë³€ ì¥ì¹˜ë¼ê³  í•©ë‹ˆë‹¤."

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr "ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ëŠ” ê°œë°œìê°€ ì²˜ë¦¬ë¥¼ ì˜¤í”„ë¡œë“œí•˜ì—¬ ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ëª¨ë“  ê²ƒì„ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ë„ë¡ í•´ì£¼ê¸° ë•Œë¬¸ì— ìœ ìš©í•©ë‹ˆë‹¤. ë°ìŠ¤í¬í†± ê°œë°œìê°€ ê·¸ë˜í”½ ì²˜ë¦¬ë¥¼ ë¹„ë””ì˜¤ ì¹´ë“œë¡œ ì˜¤í”„ë¡œë“œí•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ê²Œ ì„ë² ë””ë“œ ê°œë°œìëŠ” ì¼ë¶€ ì‘ì—…ì„ ì£¼ë³€ ì¥ì¹˜ë¡œ ì˜¤í”„ë¡œë“œí•˜ì—¬ CPUê°€ ë‹¤ë¥¸ ì¤‘ìš”í•œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê±°ë‚˜ ì „ë ¥ì„ ì ˆì•½í•˜ê¸° ìœ„í•´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr "1970ë…„ëŒ€ë‚˜ 1980ë…„ëŒ€ì˜ êµ¬ì‹ ê°€ì •ìš© ì»´í“¨í„°ì˜ ì£¼ íšŒë¡œ ê¸°íŒì„ ë³´ë©´(ê·¸ë¦¬ê³  ì‹¤ì œë¡œ ì–´ì œì˜ ë°ìŠ¤í¬í†± PCëŠ” ì˜¤ëŠ˜ë‚ ì˜ ì„ë² ë””ë“œ ì‹œìŠ¤í…œê³¼ ê·¸ë¦¬ ë©€ì§€ ì•ŠìŠµë‹ˆë‹¤) ë‹¤ìŒê³¼ ê°™ì€ ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/index.md:11
msgid "A processor"
msgstr "í”„ë¡œì„¸ì„œ"

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr "RAM ì¹©"

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr "ROM ì¹©"

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr "I/O ì»¨íŠ¸ë¡¤ëŸ¬"

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr "RAM ì¹©, ROM ì¹© ë° I/O ì»¨íŠ¸ë¡¤ëŸ¬(ì´ ì‹œìŠ¤í…œì˜ ì£¼ë³€ ì¥ì¹˜)ëŠ” 'ë²„ìŠ¤'ë¼ê³  í•˜ëŠ” ì¼ë ¨ì˜ ë³‘ë ¬ íŠ¸ë ˆì´ìŠ¤ë¥¼ í†µí•´ í”„ë¡œì„¸ì„œì— ì—°ê²°ë©ë‹ˆë‹¤. ì´ ë²„ìŠ¤ëŠ” í”„ë¡œì„¸ì„œê°€ í†µì‹ í•˜ë ¤ëŠ” ë²„ìŠ¤ì˜ ì¥ì¹˜ë¥¼ ì„ íƒí•˜ëŠ” ì£¼ì†Œ ì •ë³´ì™€ ì‹¤ì œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ëŠ” ë°ì´í„° ë²„ìŠ¤ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤. ì„ë² ë””ë“œ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œë„ ë™ì¼í•œ ì›ì¹™ì´ ì ìš©ë©ë‹ˆë‹¤. ë‹¨ì§€ ëª¨ë“  ê²ƒì´ ë‹¨ì¼ ì‹¤ë¦¬ì½˜ ì¡°ê°ì— íŒ¨í‚¤ì§•ë˜ì–´ ìˆë‹¤ëŠ” ì ë§Œ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr "ê·¸ëŸ¬ë‚˜ ì¼ë°˜ì ìœ¼ë¡œ Vulkan, Metal ë˜ëŠ” OpenGLê³¼ ê°™ì€ ì†Œí”„íŠ¸ì›¨ì–´ APIê°€ ìˆëŠ” ê·¸ë˜í”½ ì¹´ë“œì™€ ë‹¬ë¦¬ ì£¼ë³€ ì¥ì¹˜ëŠ” ë©”ëª¨ë¦¬ ì²­í¬ì— ë§¤í•‘ëœ í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ë…¸ì¶œë©ë‹ˆë‹¤."

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr "ì„ í˜• ë° ì‹¤ì œ ë©”ëª¨ë¦¬ ê³µê°„"

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ `0x4000_0000` ë˜ëŠ” `0x0000_0000`ê³¼ ê°™ì€ ë‹¤ë¥¸ ì„ì˜ì˜ ì£¼ì†Œì— ì¼ë¶€ ë°ì´í„°ë¥¼ ì“°ëŠ” ê²ƒë„ ì™„ì „íˆ ìœ íš¨í•œ ì‘ì—…ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr "ë°ìŠ¤í¬í†± ì‹œìŠ¤í…œì—ì„œ ë©”ëª¨ë¦¬ ì•¡ì„¸ìŠ¤ëŠ” MMU ë˜ëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ ì¥ì¹˜ì— ì˜í•´ ì—„ê²©í•˜ê²Œ ì œì–´ë©ë‹ˆë‹¤. ì´ êµ¬ì„± ìš”ì†ŒëŠ” ë©”ëª¨ë¦¬ ì„¹ì…˜ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ ê¶Œí•œì„ ì ìš©í•˜ê³ (í•œ í”„ë¡œì„¸ìŠ¤ê°€ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ë¥¼ ì½ê±°ë‚˜ ìˆ˜ì •í•˜ëŠ” ê²ƒì„ ë°©ì§€) ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ì˜ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê°€ìƒ ë©”ëª¨ë¦¬ ë²”ìœ„ë¡œ ë‹¤ì‹œ ë§¤í•‘í•˜ëŠ” ë‘ ê°€ì§€ ì£¼ìš” ì±…ì„ì„ ê°€ì§‘ë‹ˆë‹¤. ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ MMUê°€ ì—†ìœ¼ë©° ëŒ€ì‹  ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ì‹¤ì œ ë¬¼ë¦¬ì  ì£¼ì†Œë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr "32ë¹„íŠ¸ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” `0x0000_0000`ì—ì„œ `0xFFFF_FFFF`ê¹Œì§€ì˜ ì‹¤ì œ ë° ì„ í˜• ì£¼ì†Œ ê³µê°„ì„ ê°€ì§€ê³  ìˆì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ì‹¤ì œ ë©”ëª¨ë¦¬ì— ëŒ€í•´ í•´ë‹¹ ë²”ìœ„ì˜ ìˆ˜ë°± í‚¬ë¡œë°”ì´íŠ¸ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë¡œ ì¸í•´ ìƒë‹¹í•œ ì–‘ì˜ ì£¼ì†Œ ê³µê°„ì´ ë‚¨ê²Œ ë©ë‹ˆë‹¤. ì´ì „ ì¥ì—ì„œëŠ” RAMì´ `0x2000_0000` ì£¼ì†Œì— ìœ„ì¹˜í•œë‹¤ê³  ì´ì•¼ê¸°í–ˆìŠµë‹ˆë‹¤. RAMì´ 64KiB ê¸¸ì´(ì¦‰, ìµœëŒ€ ì£¼ì†Œê°€ 0xFFFF)ë¼ë©´ `0x2000_0000`ì—ì„œ `0x2000_FFFF`ê¹Œì§€ì˜ ì£¼ì†ŒëŠ” RAMì— í•´ë‹¹í•©ë‹ˆë‹¤. `0x2000_1234` ì£¼ì†Œì— ìˆëŠ” ë³€ìˆ˜ì— ì“¸ ë•Œ ë‚´ë¶€ì ìœ¼ë¡œ ë°œìƒí•˜ëŠ” ì¼ì€ ì¼ë¶€ ë…¼ë¦¬ê°€ ì£¼ì†Œì˜ ìƒìœ„ ë¶€ë¶„(ì´ ì˜ˆì—ì„œëŠ” 0x2000)ì„ ê°ì§€í•œ ë‹¤ìŒ RAMì„ í™œì„±í™”í•˜ì—¬ ì£¼ì†Œì˜ í•˜ìœ„ ë¶€ë¶„(ì´ ê²½ìš° 0x1234)ì— ëŒ€í•´ ì‘ë™í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. Cortex-Mì—ì„œëŠ” í”Œë˜ì‹œ ROMì´ `0x0000_0000` ì£¼ì†Œì—ì„œ ìµœëŒ€ `0x0007_FFFF` ì£¼ì†Œ(512KiB í”Œë˜ì‹œ ROMì´ ìˆëŠ” ê²½ìš°)ê¹Œì§€ ë§¤í•‘ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ ë‘ ì˜ì—­ ì‚¬ì´ì˜ ëª¨ë“  ë‚˜ë¨¸ì§€ ê³µê°„ì„ ë¬´ì‹œí•˜ëŠ” ëŒ€ì‹  ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ì„¤ê³„ìëŠ” íŠ¹ì • ë©”ëª¨ë¦¬ ìœ„ì¹˜ì— ì£¼ë³€ ì¥ì¹˜ìš© ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§¤í•‘í–ˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ë‹¤ìŒê³¼ ê°™ì´ ë³´ì…ë‹ˆë‹¤."

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr "![](../assets/nrf52-memory-map.png)"

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr "[Nordic nRF52832 ë°ì´í„°ì‹œíŠ¸ (pdf)](http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf)"

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr "ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ì™€ì˜ ìƒí˜¸ ì‘ìš©ì€ ì–¸ëœ» ë³´ê¸°ì—ëŠ” ê°„ë‹¨í•©ë‹ˆë‹¤. ì˜¬ë°”ë¥¸ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥¸ ì£¼ì†Œì— ì“°ëŠ” ê²ƒì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì§ë ¬ í¬íŠ¸ë¥¼ í†µí•´ 32ë¹„íŠ¸ ì›Œë“œë¥¼ ë³´ë‚´ëŠ” ê²ƒì€ íŠ¹ì • ë©”ëª¨ë¦¬ ì£¼ì†Œì— í•´ë‹¹ 32ë¹„íŠ¸ ì›Œë“œë¥¼ ì“°ëŠ” ê²ƒë§Œí¼ ì§ì ‘ì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì§ë ¬ í¬íŠ¸ ì£¼ë³€ ì¥ì¹˜ê°€ ì¸ê³„ë°›ì•„ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ë³´ëƒ…ë‹ˆë‹¤."

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr "ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ì˜ êµ¬ì„±ë„ ë¹„ìŠ·í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤. ì£¼ë³€ ì¥ì¹˜ë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ëŒ€ì‹  í•˜ë“œì›¨ì–´ API ì—­í• ì„ í•˜ëŠ” ë©”ëª¨ë¦¬ ì²­í¬ê°€ ë…¸ì¶œë©ë‹ˆë‹¤. SPI ì£¼íŒŒìˆ˜ êµ¬ì„± ë ˆì§€ìŠ¤í„°ì— `0x8000_0000`ì„ ì“°ë©´ SPI í¬íŠ¸ëŠ” ì´ˆë‹¹ 8ë©”ê°€ë¹„íŠ¸ë¡œ ë°ì´í„°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤. ë™ì¼í•œ ì£¼ì†Œì— `0x0200_0000`ì„ ì“°ë©´ SPI í¬íŠ¸ëŠ” ì´ˆë‹¹ 125í‚¬ë¡œë¹„íŠ¸ë¡œ ë°ì´í„°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬ì„± ë ˆì§€ìŠ¤í„°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë³´ì…ë‹ˆë‹¤."

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr "![](../assets/nrf52-spi-frequency-register.png)"

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr "ì´ ì¸í„°í˜ì´ìŠ¤ëŠ” ì–´ì…ˆë¸”ë¦¬, C ë˜ëŠ” Rust ë“± ì–´ë–¤ ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ë“  í•˜ë“œì›¨ì–´ì™€ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:1
msgid "A First Attempt"
msgstr "ì²« ë²ˆì§¸ ì‹œë„"

#: src/peripherals/a-first-attempt.md:3
msgid "The Registers"
msgstr "ë ˆì§€ìŠ¤í„°"

#: src/peripherals/a-first-attempt.md:5
msgid ""
"Let's look at the 'SysTick' peripheral - a simple timer which comes with "
"every Cortex-M processor core. Typically you'll be looking these up in the "
"chip manufacturer's data sheet or _Technical Reference Manual_, but this "
"example is common to all ARM Cortex-M cores, let's look in the [ARM "
"reference manual](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/"
"Babieigh.html). We see there are four registers:"
msgstr "'SysTick' ì£¼ë³€ ì¥ì¹˜ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ëª¨ë“  Cortex-M í”„ë¡œì„¸ì„œ ì½”ì–´ì— í¬í•¨ëœ ê°„ë‹¨í•œ íƒ€ì´ë¨¸ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì¹© ì œì¡°ì—…ì²´ì˜ ë°ì´í„° ì‹œíŠ¸ë‚˜ _ê¸°ìˆ  ì°¸ì¡° ì„¤ëª…ì„œ_ì—ì„œ ì´ëŸ¬í•œ ë‚´ìš©ì„ ì°¾ì•„ë³´ê² ì§€ë§Œ, ì´ ì˜ˆëŠ” ëª¨ë“  ARM Cortex-M ì½”ì–´ì— ê³µí†µì ì´ë¯€ë¡œ [ARM ì°¸ì¡° ì„¤ëª…ì„œ](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/Babieigh.html)ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ë„¤ ê°œì˜ ë ˆì§€ìŠ¤í„°ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:9
msgid "Offset"
msgstr "ì˜¤í”„ì…‹"

#: src/peripherals/a-first-attempt.md:9
#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Name"
msgstr "ì´ë¦„"

#: src/peripherals/a-first-attempt.md:9
msgid "Width"
msgstr "ë„ˆë¹„"


#: src/peripherals/a-first-attempt.md:11
msgid "0x00"
msgstr "0x00"

#: src/peripherals/a-first-attempt.md:11
msgid "SYST_CSR"
msgstr "SYST_CSR"

#: src/peripherals/a-first-attempt.md:11
msgid "Control and Status Register"
msgstr "ì œì–´ ë° ìƒíƒœ ë ˆì§€ìŠ¤í„°"

#: src/peripherals/a-first-attempt.md:11 src/peripherals/a-first-attempt.md:12
#: src/peripherals/a-first-attempt.md:13 src/peripherals/a-first-attempt.md:14
msgid "32 bits"
msgstr "32ë¹„íŠ¸"

#: src/peripherals/a-first-attempt.md:12
msgid "0x04"
msgstr "0x04"

#: src/peripherals/a-first-attempt.md:12
msgid "SYST_RVR"
msgstr "SYST_RVR"

#: src/peripherals/a-first-attempt.md:12
msgid "Reload Value Register"
msgstr "ì¬ë¡œë“œ ê°’ ë ˆì§€ìŠ¤í„°"

#: src/peripherals/a-first-attempt.md:13
msgid "0x08"
msgstr "0x08"

#: src/peripherals/a-first-attempt.md:13
msgid "SYST_CVR"
msgstr "SYST_CVR"

#: src/peripherals/a-first-attempt.md:13
msgid "Current Value Register"
msgstr "í˜„ì¬ ê°’ ë ˆì§€ìŠ¤í„°"

#: src/peripherals/a-first-attempt.md:14
msgid "0x0C"
msgstr "0x0C"

#: src/peripherals/a-first-attempt.md:14
msgid "SYST_CALIB"
msgstr "SYST_CALIB"

#: src/peripherals/a-first-attempt.md:14
msgid "Calibration Value Register"
msgstr "êµì • ê°’ ë ˆì§€ìŠ¤í„°"

#: src/peripherals/a-first-attempt.md:16
msgid "The C Approach"
msgstr "C ì ‘ê·¼ ë°©ì‹"

#: src/peripherals/a-first-attempt.md:18
msgid ""
"In Rust, we can represent a collection of registers in exactly the same way "
"as we do in C - with a `struct`."
msgstr ""
"Rustì—ì„œëŠ” Cì—ì„œì™€ ë˜‘ê°™ì€ ë°©ì‹ìœ¼ë¡œ `struct`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë ˆì§€ìŠ¤í„° ì»¬ë ‰ì…˜ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:30
msgid ""
"The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out "
"like a C compiler would. That's very important, as Rust allows structure "
"fields to be re-ordered, while C does not. You can imagine the debugging "
"we'd have to do if these fields were silently re-arranged by the compiler! "
"With this qualifier in place, we have our four 32-bit fields which "
"correspond to the table above. But of course, this `struct` is of no use by "
"itself - we need a variable."
msgstr ""
"í•œì •ì `#[repr(C)]`ëŠ” Rust ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì´ êµ¬ì¡°ì²´ë¥¼ C ì»´íŒŒì¼ëŸ¬ê°€ í•˜ëŠ” ê²ƒì²˜ëŸ¼ "
"ë°°ì¹˜í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤. RustëŠ” êµ¬ì¡°ì²´ í•„ë“œë¥¼ ì¬ì •ë ¬í•  ìˆ˜ ìˆì§€ë§Œ CëŠ” ê·¸ë ‡ì§€ ì•Šìœ¼ë¯€ë¡œ "
"ì´ëŠ” ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì´ í•„ë“œë¥¼ ìë™ìœ¼ë¡œ ì¬ì •ë ¬í•œë‹¤ë©´ ìš°ë¦¬ê°€ í•´ì•¼ í•  "
"ë””ë²„ê¹…ì„ ìƒìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ì´ í•œì •ìë¥¼ ì‚¬ìš©í•˜ë©´ ìœ„ í‘œì— í•´ë‹¹í•˜ëŠ” 4ê°œì˜ 32ë¹„íŠ¸ "
"í•„ë“œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë¬¼ë¡  ì´ `struct` ìì²´ëŠ” ì“¸ëª¨ê°€ ì—†ìŠµë‹ˆë‹¤. ë³€ìˆ˜ê°€ "
"í•„ìš”í•©ë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:37
msgid "Volatile Accesses"
msgstr "íœ˜ë°œì„± ì ‘ê·¼"

#: src/peripherals/a-first-attempt.md:39
msgid "Now, there are a couple of problems with the approach above."
msgstr "ì´ì œ ìœ„ ì ‘ê·¼ ë°©ì‹ì—ëŠ” ëª‡ ê°€ì§€ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:41
msgid "We have to use unsafe every time we want to access our Peripheral."
msgstr "ì£¼ë³€ ì¥ì¹˜ì— ì ‘ê·¼í•  ë•Œë§ˆë‹¤ `unsafe`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:42
msgid ""
"We've got no way of specifying which registers are read-only or read-write."
msgstr ""
"ì–´ë–¤ ë ˆì§€ìŠ¤í„°ê°€ ì½ê¸° ì „ìš©ì´ê³  ì–´ë–¤ ë ˆì§€ìŠ¤í„°ê°€ ì½ê¸°-ì“°ê¸°ì¸ì§€ ì§€ì •í•  ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:43
msgid ""
"Any piece of code anywhere in your program could access the hardware through "
"this structure."
msgstr ""
"í”„ë¡œê·¸ë¨ì˜ ì–´ëŠ ê³³ì— ìˆëŠ” ì–´ë–¤ ì½”ë“œë¼ë„ ì´ êµ¬ì¡°ì²´ë¥¼ í†µí•´ í•˜ë“œì›¨ì–´ì— ì ‘ê·¼í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:45
msgid "Most importantly, it doesn't actually work..."
msgstr "ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€, ì‹¤ì œë¡œëŠ” ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤..."

#: src/peripherals/a-first-attempt.md:47
msgid ""
"Now, the problem is that compilers are clever. If you make two writes to the "
"same piece of RAM, one after the other, the compiler can notice this and "
"just skip the first write entirely. In C, we can mark variables as "
"`volatile` to ensure that every read or write occurs as intended. In Rust, "
"we instead mark the _accesses_ as volatile, not the variable."
msgstr ""
"ì´ì œ ë¬¸ì œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì˜ë¦¬í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë™ì¼í•œ RAM ì˜ì—­ì— ë‘ ë²ˆ ì—°ì†ìœ¼ë¡œ "
"ì“°ê¸°ë¥¼ í•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ê°ì§€í•˜ê³  ì²« ë²ˆì§¸ ì“°ê¸°ë¥¼ ì™„ì „íˆ ê±´ë„ˆë›¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"Cì—ì„œëŠ” ëª¨ë“  ì½ê¸° ë˜ëŠ” ì“°ê¸°ê°€ ì˜ë„í•œ ëŒ€ë¡œ ë°œìƒí•˜ë„ë¡ ë³€ìˆ˜ë¥¼ `volatile`ë¡œ í‘œì‹œí•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. Rustì—ì„œëŠ” ë³€ìˆ˜ê°€ ì•„ë‹Œ _ì ‘ê·¼_ì„ íœ˜ë°œì„±ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:54
msgid ""
"So, we've fixed one of our four problems, but now we have even more `unsafe` "
"code! Fortunately, there's a third party crate which can help - "
"[`volatile_register`](https://crates.io/crates/volatile_register)."
msgstr ""
"ê·¸ë˜ì„œ ë„¤ ê°€ì§€ ë¬¸ì œ ì¤‘ í•˜ë‚˜ë¥¼ í•´ê²°í–ˆì§€ë§Œ, ì´ì œ `unsafe` ì½”ë“œê°€ í›¨ì”¬ ë” ë§ì•„ì¡ŒìŠµë‹ˆë‹¤! "
"ë‹¤í–‰íˆë„ ë„ì›€ì´ ë  ìˆ˜ ìˆëŠ” íƒ€ì‚¬ í¬ë ˆì´íŠ¸ì¸ [`volatile_register`](https://crates.io/"
"crates/volatile_register)ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:79
msgid ""
"Now, the volatile accesses are performed automatically through the `read` "
"and `write` methods. It's still `unsafe` to perform writes, but to be fair, "
"hardware is a bunch of mutable state and there's no way for the compiler to "
"know whether these writes are actually safe, so this is a good default "
"position."
msgstr ""
"ì´ì œ `read` ë° `write` ë©”ì„œë“œë¥¼ í†µí•´ íœ˜ë°œì„± ì ‘ê·¼ì´ ìë™ìœ¼ë¡œ ìˆ˜í–‰ë©ë‹ˆë‹¤. ì“°ê¸°ë¥¼ "
"ìˆ˜í–‰í•˜ëŠ” ê²ƒì€ ì—¬ì „íˆ `unsafe`í•˜ì§€ë§Œ, ê³µì •í•˜ê²Œ ë§í•˜ë©´ í•˜ë“œì›¨ì–´ëŠ” ë³€ê²½ ê°€ëŠ¥í•œ "
"ìƒíƒœì˜ ë¬¶ìŒì´ë©° ì»´íŒŒì¼ëŸ¬ê°€ ì´ëŸ¬í•œ ì“°ê¸°ê°€ ì‹¤ì œë¡œ ì•ˆì „í•œì§€ ì•Œ ë°©ë²•ì´ ì—†ìœ¼ë¯€ë¡œ ì´ëŠ” "
"ì¢‹ì€ ê¸°ë³¸ ì…ì¥ì…ë‹ˆë‹¤."

#: src/peripherals/a-first-attempt.md:81
msgid "The Rusty Wrapper"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë˜í¼"

#: src/peripherals/a-first-attempt.md:83
msgid ""
"We need to wrap this `struct` up into a higher-layer API that is safe for "
"our users to call. As the driver author, we manually verify the unsafe code "
"is correct, and then present a safe API for our users so they don't have to "
"worry about it (provided they trust us to get it right!)."
msgstr ""
"ìš°ë¦¬ëŠ” ì´ `struct`ë¥¼ ì‚¬ìš©ìê°€ ì•ˆì „í•˜ê²Œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ìƒìœ„ ê³„ì¸µ APIë¡œ ë˜í•‘í•´ì•¼ "
"í•©ë‹ˆë‹¤. ë“œë¼ì´ë²„ ì‘ì„±ìë¡œì„œ ìš°ë¦¬ëŠ” unsafe ì½”ë“œê°€ ì˜¬ë°”ë¥¸ì§€ ìˆ˜ë™ìœ¼ë¡œ í™•ì¸í•œ ë‹¤ìŒ, "
"ì‚¬ìš©ìê°€ ê±±ì •í•  í•„ìš”ê°€ ì—†ë„ë¡ ì•ˆì „í•œ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤(ìš°ë¦¬ê°€ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í–ˆë‹¤ê³  "
"ì‹ ë¢°í•˜ëŠ” ê²½ìš°)."

#: src/peripherals/a-first-attempt.md:85
msgid "One example might be:"
msgstr "í•œ ê°€ì§€ ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/peripherals/a-first-attempt.md:121
msgid "\"Time is now 0x{:08x}\""
msgstr "\"í˜„ì¬ ì‹œê°„ì€ 0x{:08x}ì…ë‹ˆë‹¤\""

#: src/peripherals/a-first-attempt.md:125
msgid ""
"Now, the problem with this approach is that the following code is perfectly "
"acceptable to the compiler:"
msgstr ""
"ì´ì œ ì´ ì ‘ê·¼ ë°©ì‹ì˜ ë¬¸ì œëŠ” ë‹¤ìŒ ì½”ë“œê°€ ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì™„ë²½í•˜ê²Œ í—ˆìš©ëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤:"

#: src/peripherals/a-first-attempt.md:139
msgid ""
"Our `&mut self` argument to the `set_reload` function checks that there are "
"no other references to _that_ particular `SystemTimer` struct, but they "
"don't stop the user creating a second `SystemTimer` which points to the "
"exact same peripheral! Code written in this fashion will work if the author "
"is diligent enough to spot all of these 'duplicate' driver instances, but "
"once the code is spread out over multiple modules, drivers, developers, and "
"days, it gets easier and easier to make these kinds of mistakes."
msgstr ""
"ìš°ë¦¬ì˜ `&mut self` ì¸ìˆ˜ëŠ” `set_reload` í•¨ìˆ˜ì— ëŒ€í•œ ì¸ìˆ˜ë¡œ, í•´ë‹¹ íŠ¹ì • "
"`SystemTimer` êµ¬ì¡°ì²´ì— ëŒ€í•œ ë‹¤ë¥¸ ì°¸ì¡°ê°€ ì—†ëŠ”ì§€ í™•ì¸í•˜ì§€ë§Œ, ë™ì¼í•œ ì£¼ë³€ ì¥ì¹˜ë¥¼ "
"ê°€ë¦¬í‚¤ëŠ” ë‘ ë²ˆì§¸ `SystemTimer`ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì„ ë§‰ì§€ëŠ” ëª»í•©ë‹ˆë‹¤! ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ "
"ì‘ì„±ëœ ì½”ë“œëŠ” ì‘ì„±ìê°€ ì´ëŸ¬í•œ 'ì¤‘ë³µ' ë“œë¼ì´ë²„ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ëª¨ë‘ ì°¾ì•„ë‚¼ ë§Œí¼ "
"ë¶€ì§€ëŸ°í•˜ë‹¤ë©´ ì‘ë™í•˜ê² ì§€ë§Œ, ì½”ë“œê°€ ì—¬ëŸ¬ ëª¨ë“ˆ, ë“œë¼ì´ë²„, ê°œë°œì ë° ì—¬ëŸ¬ ë‚ ì— ê±¸ì³ "
"ë¶„ì‚°ë˜ë©´ ì´ëŸ¬í•œ ì¢…ë¥˜ì˜ ì‹¤ìˆ˜ë¥¼ ì €ì§€ë¥´ê¸° ì ì  ë” ì‰¬ì›Œì§‘ë‹ˆë‹¤."

#: src/peripherals/borrowck.md:1
msgid "Mutable Global State"
msgstr "ê°€ë³€ ì „ì—­ ìƒíƒœ"

#: src/peripherals/borrowck.md:3
msgid ""
"Unfortunately, hardware is basically nothing but mutable global state, which "
"can feel very frightening for a Rust developer. Hardware exists "
"independently from the structures of the code we write, and can be modified "
"at any time by the real world."
msgstr ""
"ë¶ˆí–‰íˆë„ í•˜ë“œì›¨ì–´ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ê°€ë³€ ì „ì—­ ìƒíƒœì— ë¶ˆê³¼í•˜ë©°, ì´ëŠ” Rust ê°œë°œìì—ê²Œ "
"ë§¤ìš° ë‘ë ¤ìš´ ëŠë‚Œì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ëŠ” ìš°ë¦¬ê°€ ì‘ì„±í•˜ëŠ” ì½”ë“œì˜ êµ¬ì¡°ì™€ "
"ë…ë¦½ì ìœ¼ë¡œ ì¡´ì¬í•˜ë©°, ì‹¤ì œ ì„¸ê³„ì— ì˜í•´ ì–¸ì œë“ ì§€ ìˆ˜ì •ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/borrowck.md:5
msgid "What should our rules be?"
msgstr "ìš°ë¦¬ì˜ ê·œì¹™ì€ ë¬´ì—‡ì´ì–´ì•¼ í• ê¹Œìš”?"

#: src/peripherals/borrowck.md:7
msgid "How can we reliably interact with these peripherals?"
msgstr "ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ì™€ ì–´ë–»ê²Œ ì•ˆì •ì ìœ¼ë¡œ ìƒí˜¸ ì‘ìš©í•  ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/peripherals/borrowck.md:9
msgid ""
"Always use `volatile` methods to read or write to peripheral memory, as it "
"can change at any time"
msgstr ""
"ì£¼ë³€ ì¥ì¹˜ ë©”ëª¨ë¦¬ì— ì½ê¸° ë˜ëŠ” ì“°ê¸°ë¥¼ í•  ë•ŒëŠ” í•­ìƒ `volatile` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. "
"ì–¸ì œë“ ì§€ ë³€ê²½ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/peripherals/borrowck.md:10
msgid ""
"In software, we should be able to share any number of read-only accesses to "
"these peripherals"
msgstr ""
"ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œëŠ” ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì½ê¸° ì „ìš© ì ‘ê·¼ì„ ì–¼ë§ˆë“ ì§€ ê³µìœ í•  ìˆ˜ "
"ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/peripherals/borrowck.md:11
msgid ""
"If some software should have read-write access to a peripheral, it should "
"hold the only reference to that peripheral"
msgstr ""
"ì–´ë–¤ ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì½ê¸°-ì“°ê¸° ì ‘ê·¼ ê¶Œí•œì„ ê°€ì ¸ì•¼ í•œë‹¤ë©´, í•´ë‹¹ "
"ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ìœ ì¼í•œ ì°¸ì¡°ë¥¼ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/peripherals/borrowck.md:15
msgid ""
"The last two of these rules sound suspiciously similar to what the Borrow "
"Checker does already!"
msgstr ""
"ì´ ê·œì¹™ ì¤‘ ë§ˆì§€ë§‰ ë‘ ê°€ì§€ëŠ” Borrow Checkerê°€ ì´ë¯¸ í•˜ëŠ” ì¼ê³¼ ì˜ì‹¬ìŠ¤ëŸ¬ìš¸ ì •ë„ë¡œ "
"ë¹„ìŠ·í•˜ê²Œ ë“¤ë¦½ë‹ˆë‹¤!"

#: src/peripherals/borrowck.md:17
msgid ""
"Imagine if we could pass around ownership of these peripherals, or offer "
"immutable or mutable references to them?"
msgstr ""
"ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ì˜ ì†Œìœ ê¶Œì„ ì „ë‹¬í•˜ê±°ë‚˜, ë¶ˆë³€ ë˜ëŠ” ê°€ë³€ ì°¸ì¡°ë¥¼ ì œê³µí•  ìˆ˜ ìˆë‹¤ë©´ "
"ì–´ë–¨ê¹Œìš”?"

#: src/peripherals/borrowck.md:19
msgid ""
"Well, we can, but for the Borrow Checker, we need to have exactly one "
"instance of each peripheral, so Rust can handle this correctly. Well, "
"luckily in the hardware, there is only one instance of any given peripheral, "
"but how can we expose that in the structure of our code?"
msgstr ""
"ìŒ, ê°€ëŠ¥í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ Borrow Checkerë¥¼ ìœ„í•´ì„œëŠ” ê° ì£¼ë³€ ì¥ì¹˜ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ "
"ì •í™•íˆ í•˜ë‚˜ë§Œ ìˆì–´ì•¼ Rustê°€ ì´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤í–‰íˆ í•˜ë“œì›¨ì–´ì—ëŠ” "
"ì£¼ì–´ì§„ ì£¼ë³€ ì¥ì¹˜ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ í•˜ë‚˜ë§Œ ìˆì§€ë§Œ, ì½”ë“œ êµ¬ì¡°ì—ì„œ ì´ë¥¼ ì–´ë–»ê²Œ ë…¸ì¶œí•  ìˆ˜ "
"ìˆì„ê¹Œìš”?"

#: src/peripherals/singletons.md:3
msgid ""
"In software engineering, the singleton pattern is a software design pattern "
"that restricts the instantiation of a class to one object."
msgstr ""
"ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ì—ì„œ ì‹±ê¸€í†¤ íŒ¨í„´ì€ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤í™”ë¥¼ í•˜ë‚˜ì˜ ê°ì²´ë¡œ ì œí•œí•˜ëŠ” "
"ì†Œí”„íŠ¸ì›¨ì–´ ë””ìì¸ íŒ¨í„´ì…ë‹ˆë‹¤."

#: src/peripherals/singletons.md:5
msgid ""
"_Wikipedia: [Singleton Pattern](https://en.wikipedia.org/wiki/"
"Singleton_pattern)_"
msgstr ""
"_ìœ„í‚¤ë°±ê³¼: [ì‹±ê¸€í†¤ íŒ¨í„´](https://en.wikipedia.org/wiki/Singleton_pattern)_"

#: src/peripherals/singletons.md:10
msgid "But why can't we just use global variable(s)?"
msgstr "í•˜ì§€ë§Œ ì „ì—­ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆ ë˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/peripherals/singletons.md:12
msgid "We could make everything a public static, like this"
msgstr "ëª¨ë“  ê²ƒì„ ë‹¤ìŒê³¼ ê°™ì´ ê³µê°œ ì •ì ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:24
msgid ""
"But this has a few problems. It is a mutable global variable, and in Rust, "
"these are always unsafe to interact with. These variables are also visible "
"across your whole program, which means the borrow checker is unable to help "
"you track references and ownership of these variables."
msgstr ""
"í•˜ì§€ë§Œ ì—¬ê¸°ì—ëŠ” ëª‡ ê°€ì§€ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ê°€ë³€ ì „ì—­ ë³€ìˆ˜ì´ë©°, Rustì—ì„œëŠ” "
"í•­ìƒ ì•ˆì „í•˜ì§€ ì•Šê²Œ ìƒí˜¸ ì‘ìš©í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë³€ìˆ˜ë“¤ì€ í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ ë³¼ ìˆ˜ "
"ìˆìœ¼ë¯€ë¡œ, borrow checkerê°€ ì´ëŸ¬í•œ ë³€ìˆ˜ì˜ ì°¸ì¡° ë° ì†Œìœ ê¶Œì„ ì¶”ì í•˜ëŠ” ë° ë„ì›€ì„ ì¤„ "
"ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:26
msgid "How do we do this in Rust?"
msgstr "Rustì—ì„œëŠ” ì–´ë–»ê²Œ í• ê¹Œìš”?"

#: src/peripherals/singletons.md:28
msgid ""
"Instead of just making our peripheral a global variable, we might instead "
"decide to make a structure, in this case called `PERIPHERALS`, which "
"contains an `Option<T>` for each of our peripherals."
msgstr ""
"ì£¼ë³€ ì¥ì¹˜ë¥¼ ë‹¨ìˆœíˆ ì „ì—­ ë³€ìˆ˜ë¡œ ë§Œë“œëŠ” ëŒ€ì‹ , ì´ ê²½ìš° `PERIPHERALS`ë¼ê³  ë¶ˆë¦¬ëŠ” "
"êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ê³ , ì´ êµ¬ì¡°ì²´ê°€ ê° ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ `Option<T>`ë¥¼ í¬í•¨í•˜ë„ë¡ ê²°ì •í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:45
msgid ""
"This structure allows us to obtain a single instance of our peripheral. If "
"we try to call `take_serial()` more than once, our code will panic!"
msgstr ""
"ì´ êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ë©´ ì£¼ë³€ ì¥ì¹˜ì˜ ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `take_serial()`"
"ì„ ë‘ ë²ˆ ì´ìƒ í˜¸ì¶œí•˜ë ¤ê³  í•˜ë©´ ì½”ë“œê°€ íŒ¨ë‹‰ ìƒíƒœê°€ ë©ë‹ˆë‹¤!"

#: src/peripherals/singletons.md:50
msgid ""
"// This panics!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"
msgstr ""
"// ì´ê²ƒì€ íŒ¨ë‹‰ì„ ì¼ìœ¼í‚µë‹ˆë‹¤!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"

#: src/peripherals/singletons.md:55
msgid ""
"Although interacting with this structure is `unsafe`, once we have the "
"`SerialPort` it contained, we no longer need to use `unsafe`, or the "
"`PERIPHERALS` structure at all."
msgstr ""
"ì´ êµ¬ì¡°ì²´ì™€ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ê²ƒì€ `unsafe`í•˜ì§€ë§Œ, ì¼ë‹¨ í¬í•¨ëœ `SerialPort`ë¥¼ ì–»ìœ¼ë©´ "
"ë” ì´ìƒ `unsafe`ë‚˜ `PERIPHERALS` êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:57
msgid ""
"This has a small runtime overhead because we must wrap the `SerialPort` "
"structure in an option, and we'll need to call `take_serial()` once, however "
"this small up-front cost allows us to leverage the borrow checker throughout "
"the rest of our program."
msgstr ""
"ì´ê²ƒì€ `SerialPort` êµ¬ì¡°ì²´ë¥¼ ì˜µì…˜ìœ¼ë¡œ ë˜í•‘í•´ì•¼ í•˜ê³  `take_serial()`ì„ í•œ ë²ˆ "
"í˜¸ì¶œí•´ì•¼ í•˜ë¯€ë¡œ ì‘ì€ ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ì‘ì€ ì´ˆê¸° ë¹„ìš©ìœ¼ë¡œ "
"í”„ë¡œê·¸ë¨ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œ borrow checkerë¥¼ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:59
msgid "Existing library support"
msgstr "ê¸°ì¡´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§€ì›"

#: src/peripherals/singletons.md:61
msgid ""
"Although we created our own `Peripherals` structure above, it is not "
"necessary to do this for your code. the `cortex_m` crate contains a macro "
"called `singleton!()` that will perform this action for you."
msgstr ""
"ìœ„ì— ìš°ë¦¬ë§Œì˜ `Peripherals` êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì—ˆì§€ë§Œ, ì½”ë“œì— ëŒ€í•´ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•  "
"í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤. `cortex_m` í¬ë ˆì´íŠ¸ì—ëŠ” ì´ ì‘ì—…ì„ ìˆ˜í–‰í•´ ì¤„ `singleton!()`ì´ë¼ëŠ” "
"ë§¤í¬ë¡œê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/peripherals/singletons.md:67
msgid "// OK if `main` is executed only once\n"
msgstr "// `main`ì´ í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë©´ OK\n"

#: src/peripherals/singletons.md:73
msgid ""
"[cortex_m docs](https://docs.rs/cortex-m/latest/cortex_m/"
"macro.singleton.html)"
msgstr ""
"[cortex_m ë¬¸ì„œ](https://docs.rs/cortex-m/latest/cortex_m/macro.singleton.html)"

#: src/peripherals/singletons.md:75
msgid ""
"Additionally, if you use [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-"
"m-rtic), the entire process of defining and obtaining these peripherals are "
"abstracted for you, and you are instead handed a `Peripherals` structure "
"that contains a non-`Option<T>` version of all of the items you define."
msgstr ""
"ë˜í•œ, [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-m-rtic)ë¥¼ ì‚¬ìš©í•˜ë©´ "
"ì´ëŸ¬í•œ ì£¼ë³€ ì¥ì¹˜ë¥¼ ì •ì˜í•˜ê³  ì–»ëŠ” ì „ì²´ í”„ë¡œì„¸ìŠ¤ê°€ ì¶”ìƒí™”ë˜ì–´, ì •ì˜í•œ ëª¨ë“  í•­ëª©ì˜ "
"`Option<T>`ê°€ ì•„ë‹Œ ë²„ì „ì´ í¬í•¨ëœ `Peripherals` êµ¬ì¡°ì²´ë¥¼ ë°›ê²Œ ë©ë‹ˆë‹¤."

#: src/peripherals/singletons.md:78
msgid "// cortex-m-rtic v0.5.x\n"
msgstr "// cortex-m-rtic v0.5.x\n"

#: src/peripherals/singletons.md:85
msgid "// Cortex-M peripherals\n"
msgstr "// Cortex-M ì£¼ë³€ ì¥ì¹˜\n"

#: src/peripherals/singletons.md:88
msgid "// Device specific peripherals\n"
msgstr "// ì¥ì¹˜ë³„ ì£¼ë³€ ì¥ì¹˜\n"

#: src/peripherals/singletons.md:94
msgid "But why?"
msgstr "í•˜ì§€ë§Œ ì™œ?"

#: src/peripherals/singletons.md:96
msgid ""
"But how do these Singletons make a noticeable difference in how our Rust "
"code works?"
msgstr ""
"í•˜ì§€ë§Œ ì´ëŸ¬í•œ ì‹±ê¸€í†¤ì´ Rust ì½”ë“œ ì‘ë™ ë°©ì‹ì— ì–´ë–»ê²Œ ëˆˆì— ë„ëŠ” ì°¨ì´ë¥¼ ë§Œë“¤ê¹Œìš”?"

#: src/peripherals/singletons.md:103
msgid "// <------ This is really, really important\n"
msgstr "// <------ ì´ê²ƒì€ ì •ë§, ì •ë§ ì¤‘ìš”í•©ë‹ˆë‹¤\n"

#: src/peripherals/singletons.md:112
msgid "There are two important factors in play here:"
msgstr "ì—¬ê¸°ì—ëŠ” ë‘ ê°€ì§€ ì¤‘ìš”í•œ ìš”ì†Œê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/peripherals/singletons.md:114
msgid ""
"Because we are using a singleton, there is only one way or place to obtain a "
"`SerialPort` structure"
msgstr ""
"ì‹±ê¸€í†¤ì„ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì— `SerialPort` êµ¬ì¡°ì²´ë¥¼ ì–»ëŠ” ë°©ë²•ì´ë‚˜ ì¥ì†ŒëŠ” í•˜ë‚˜ë¿ì…ë‹ˆë‹¤."

#: src/peripherals/singletons.md:115
msgid ""
"To call the `read_speed()` method, we must have ownership or a reference to "
"a `SerialPort` structure"
msgstr ""
"`read_speed()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë ¤ë©´ `SerialPort` êµ¬ì¡°ì²´ì˜ ì†Œìœ ê¶Œ ë˜ëŠ” ì°¸ì¡°ë¥¼ "
"ê°€ì§€ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/peripherals/singletons.md:117
msgid ""
"These two factors put together means that it is only possible to access the "
"hardware if we have appropriately satisfied the borrow checker, meaning that "
"at no point do we have multiple mutable references to the same hardware!"
msgstr ""
"ì´ ë‘ ê°€ì§€ ìš”ì†Œë¥¼ ì¢…í•©í•˜ë©´, borrow checkerë¥¼ ì ì ˆí•˜ê²Œ ë§Œì¡±ì‹œí‚¨ ê²½ìš°ì—ë§Œ í•˜ë“œì›¨ì–´ì— "
"ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ì¦‰, ë™ì¼í•œ í•˜ë“œì›¨ì–´ì— ëŒ€í•œ ì—¬ëŸ¬ ê°œì˜ ê°€ë³€ ì°¸ì¡°ë¥¼ "
"ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!"

#: src/peripherals/singletons.md:121
msgid ""
"// missing reference to `self`! Won't work.\n"
"    // SerialPort::read_speed();\n"
msgstr ""
"// `self` ì°¸ì¡° ëˆ„ë½! ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"    // SerialPort::read_speed();\n"

#: src/peripherals/singletons.md:126
msgid "// you can only read what you have access to\n"
msgstr "// ì ‘ê·¼ ê¶Œí•œì´ ìˆëŠ” ê²ƒë§Œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/peripherals/singletons.md:131
msgid "Treat your hardware like data"
msgstr "í•˜ë“œì›¨ì–´ë¥¼ ë°ì´í„°ì²˜ëŸ¼ ë‹¤ë£¨ì„¸ìš”"

#: src/peripherals/singletons.md:133
msgid ""
"Additionally, because some references are mutable, and some are immutable, "
"it becomes possible to see whether a function or method could potentially "
"modify the state of the hardware. For example,"
msgstr ""
"ë˜í•œ, ì¼ë¶€ ì°¸ì¡°ëŠ” ê°€ë³€ì´ê³  ì¼ë¶€ëŠ” ë¶ˆë³€ì´ê¸° ë•Œë¬¸ì— í•¨ìˆ˜ë‚˜ ë©”ì„œë“œê°€ í•˜ë“œì›¨ì–´ì˜ "
"ìƒíƒœë¥¼ ì ì¬ì ìœ¼ë¡œ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´,"

#: src/peripherals/singletons.md:135
msgid "This is allowed to change hardware settings:"
msgstr "ì´ê²ƒì€ í•˜ë“œì›¨ì–´ ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/peripherals/singletons.md:142 src/peripherals/singletons.md:150
#: src/design-patterns/hal/gpio.md:17 src/design-patterns/hal/gpio.md:27
#: src/design-patterns/hal/gpio.md:35 src/design-patterns/hal/gpio.md:138
msgid "// ...\n"
msgstr "// ...\n"

#: src/peripherals/singletons.md:146
msgid "This isn't:"
msgstr "ì´ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤:"

#: src/peripherals/singletons.md:154
msgid ""
"This allows us to enforce whether code should or should not make changes to "
"hardware at **compile time**, rather than at runtime. As a note, this "
"generally only works across one application, but for bare metal systems, our "
"software will be compiled into a single application, so this is not usually "
"a restriction."
msgstr ""
"ì´ë¥¼ í†µí•´ ì½”ë“œê°€ ëŸ°íƒ€ì„ì´ ì•„ë‹Œ **ì»´íŒŒì¼ íƒ€ì„**ì— í•˜ë“œì›¨ì–´ ë³€ê²½ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ”ì§€ "
"ì—¬ë¶€ë¥¼ ê°•ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì°¸ê³ ë¡œ, ì´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í•˜ë‚˜ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œë§Œ "
"ì‘ë™í•˜ì§€ë§Œ, ë² ì–´ ë©”íƒˆ ì‹œìŠ¤í…œì˜ ê²½ìš° ì†Œí”„íŠ¸ì›¨ì–´ê°€ ë‹¨ì¼ ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ì»´íŒŒì¼ë˜ë¯€ë¡œ "
"ì¼ë°˜ì ìœ¼ë¡œ ì œí•œ ì‚¬í•­ì´ ì•„ë‹™ë‹ˆë‹¤."

#: src/static-guarantees/index.md:3
msgid ""
"Rust's type system prevents data races at compile time (see [`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) and [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) traits). The type system can also be "
"used to check other properties at compile time; reducing the need for "
"runtime checks in some cases."
msgstr ""
"Rustì˜ íƒ€ì… ì‹œìŠ¤í…œì€ ì»´íŒŒì¼ íƒ€ì„ì— ë°ì´í„° ê²½ìŸì„ ë°©ì§€í•©ë‹ˆë‹¤([`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) ë° [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) íŠ¸ë ˆì´íŠ¸ ì°¸ì¡°). íƒ€ì… ì‹œìŠ¤í…œì€ ì»´íŒŒì¼ "
"íƒ€ì„ì— ë‹¤ë¥¸ ì†ì„±ë„ í™•ì¸í•  ìˆ˜ ìˆì–´ ì¼ë¶€ ê²½ìš° ëŸ°íƒ€ì„ ê²€ì‚¬ì˜ í•„ìš”ì„±ì„ ì¤„ì—¬ì¤ë‹ˆë‹¤."

#: src/static-guarantees/index.md:10
msgid ""
"When applied to embedded programs these _static checks_ can be used, for "
"example, to enforce that configuration of I/O interfaces is done properly. "
"For instance, one can design an API where it is only possible to initialize "
"a serial interface by first configuring the pins that will be used by the "
"interface."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì— ì ìš©ë  ë•Œ ì´ëŸ¬í•œ _ì •ì  ê²€ì‚¬_ëŠ” ì˜ˆë¥¼ ë“¤ì–´ I/O ì¸í„°í˜ì´ìŠ¤ "
"êµ¬ì„±ì´ ì˜¬ë°”ë¥´ê²Œ ìˆ˜í–‰ë˜ë„ë¡ ê°•ì œí•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì¸í„°í˜ì´ìŠ¤ì—ì„œ "
"ì‚¬ìš©ë  í•€ì„ ë¨¼ì € êµ¬ì„±í•´ì•¼ë§Œ ì§ë ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ìˆëŠ” APIë¥¼ ì„¤ê³„í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/static-guarantees/index.md:15
msgid ""
"One can also statically check that operations, like setting a pin low, can "
"only be performed on correctly configured peripherals. For example, trying "
"to change the output state of a pin configured in floating input mode would "
"raise a compile error."
msgstr ""
"ë˜í•œ í•€ì„ ë‚®ê²Œ ì„¤ì •í•˜ëŠ” ê²ƒê³¼ ê°™ì€ ì‘ì—…ì´ ì˜¬ë°”ë¥´ê²Œ êµ¬ì„±ëœ ì£¼ë³€ ì¥ì¹˜ì—ì„œë§Œ ìˆ˜í–‰ë  "
"ìˆ˜ ìˆë„ë¡ ì •ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í”Œë¡œíŒ… ì…ë ¥ ëª¨ë“œë¡œ êµ¬ì„±ëœ í•€ì˜ "
"ì¶œë ¥ ìƒíƒœë¥¼ ë³€ê²½í•˜ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤."

#: src/static-guarantees/index.md:20
msgid ""
"And, as seen in the previous chapter, the concept of ownership can be "
"applied to peripherals to ensure that only certain parts of a program can "
"modify a peripheral. This _access control_ makes software easier to reason "
"about compared to the alternative of treating peripherals as global mutable "
"state."
msgstr ""
"ê·¸ë¦¬ê³  ì´ì „ ì±•í„°ì—ì„œ ë³´ì•˜ë“¯ì´, ì†Œìœ ê¶Œ ê°œë…ì€ ì£¼ë³€ ì¥ì¹˜ì— ì ìš©ë˜ì–´ í”„ë¡œê·¸ë¨ì˜ "
"íŠ¹ì • ë¶€ë¶„ë§Œ ì£¼ë³€ ì¥ì¹˜ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ _ì ‘ê·¼ ì œì–´_ëŠ” "
"ì£¼ë³€ ì¥ì¹˜ë¥¼ ì „ì—­ ê°€ë³€ ìƒíƒœë¡œ ì·¨ê¸‰í•˜ëŠ” ëŒ€ì•ˆê³¼ ë¹„êµí•˜ì—¬ ì†Œí”„íŠ¸ì›¨ì–´ì— ëŒ€í•´ ì¶”ë¡ í•˜ê¸° "
"ì‰½ê²Œ ë§Œë“­ë‹ˆë‹¤."

#: src/static-guarantees/typestate-programming.md:3
msgid ""
"The concept of [typestates](https://en.wikipedia.org/wiki/"
"Typestate_analysis) describes the encoding of information about the current "
"state of an object into the type of that object. Although this can sound a "
"little arcane, if you have used the [Builder Pattern](https://doc.rust-"
"lang.org/1.0.0/style/ownership/builders.html) in Rust, you have already "
"started using Typestate Programming!"
msgstr ""
"[íƒ€ì… ìƒíƒœ](https://en.wikipedia.org/wiki/Typestate_analysis) ê°œë…ì€ ê°ì²´ì˜ "
"í˜„ì¬ ìƒíƒœì— ëŒ€í•œ ì •ë³´ë¥¼ í•´ë‹¹ ê°ì²´ì˜ íƒ€ì…ìœ¼ë¡œ ì¸ì½”ë”©í•˜ëŠ” ê²ƒì„ ì„¤ëª…í•©ë‹ˆë‹¤. ì´ê²ƒì´ "
"ë‹¤ì†Œ ë‚œí•´í•˜ê²Œ ë“¤ë¦´ ìˆ˜ ìˆì§€ë§Œ, Rustì—ì„œ [ë¹Œë” íŒ¨í„´](https://doc.rust-lang.org/1.0.0/"
"style/ownership/builders.html)ì„ ì‚¬ìš©í•´ ë³¸ ì ì´ ìˆë‹¤ë©´ ì´ë¯¸ íƒ€ì… ìƒíƒœ í”„ë¡œê·¸ë˜ë°ì„ "
"ì‚¬ìš©í•˜ê³  ìˆëŠ” ê²ƒì…ë‹ˆë‹¤!"

#: src/static-guarantees/typestate-programming.md:52
msgid ""
"In this example, there is no direct way to create a `Foo` object. We must "
"create a `FooBuilder`, and properly initialize it before we can obtain the "
"`Foo` object we want."
msgstr ""
"ì´ ì˜ˆì œì—ì„œëŠ” `Foo` ê°ì²´ë¥¼ ì§ì ‘ ìƒì„±í•  ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤. ì›í•˜ëŠ” `Foo` ê°ì²´ë¥¼ "
"ì–»ìœ¼ë ¤ë©´ `FooBuilder`ë¥¼ ìƒì„±í•˜ê³  ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/static-guarantees/typestate-programming.md:54
msgid "This minimal example encodes two states:"
msgstr "ì´ ìµœì†Œ ì˜ˆì œëŠ” ë‘ ê°€ì§€ ìƒíƒœë¥¼ ì¸ì½”ë”©í•©ë‹ˆë‹¤:"

#: src/static-guarantees/typestate-programming.md:56
msgid ""
"`FooBuilder`, which represents an \"unconfigured\", or \"configuration in "
"process\" state"
msgstr ""
"`FooBuilder`, ì´ëŠ” \"êµ¬ì„±ë˜ì§€ ì•ŠìŒ\" ë˜ëŠ” \"êµ¬ì„± ì§„í–‰ ì¤‘\" ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/static-guarantees/typestate-programming.md:57
msgid "`Foo`, which represents a \"configured\", or \"ready to use\" state."
msgstr "`Foo`, ì´ëŠ” \"êµ¬ì„±ë¨\" ë˜ëŠ” \"ì‚¬ìš© ì¤€ë¹„ ì™„ë£Œ\" ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/static-guarantees/typestate-programming.md:59
msgid "Strong Types"
msgstr "ê°•ë ¥í•œ íƒ€ì…"

#: src/static-guarantees/typestate-programming.md:61
msgid ""
"Because Rust has a [Strong Type System](https://en.wikipedia.org/wiki/"
"Strong_and_weak_typing), there is no easy way to magically create an "
"instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling "
"the `into_foo()` method. Additionally, calling the `into_foo()` method "
"consumes the original `FooBuilder` structure, meaning it can not be reused "
"without the creation of a new instance."
msgstr ""
"RustëŠ” [ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œ](https://en.wikipedia.org/wiki/Strong_and_weak_typing)ì„ "
"ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— `Foo` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§ˆë²•ì²˜ëŸ¼ ìƒì„±í•˜ê±°ë‚˜ `into_foo()` ë©”ì„œë“œë¥¼ "
"í˜¸ì¶œí•˜ì§€ ì•Šê³  `FooBuilder`ë¥¼ `Foo`ë¡œ ë°”ê¾¸ëŠ” ì‰¬ìš´ ë°©ë²•ì€ ì—†ìŠµë‹ˆë‹¤. ë˜í•œ `into_foo()` "
"ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ì›ë˜ `FooBuilder` êµ¬ì¡°ì²´ê°€ ì†Œëª¨ë˜ë¯€ë¡œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ "
"ì•Šê³ ëŠ” ì¬ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/static-guarantees/typestate-programming.md:65
msgid ""
"This allows us to represent the states of our system as types, and to "
"include the necessary actions for state transitions into the methods that "
"exchange one type for another. By creating a `FooBuilder`, and exchanging it "
"for a `Foo` object, we have walked through the steps of a basic state "
"machine."
msgstr ""
"ì´ë¥¼ í†µí•´ ì‹œìŠ¤í…œì˜ ìƒíƒœë¥¼ íƒ€ì…ìœ¼ë¡œ ë‚˜íƒ€ë‚´ê³ , í•œ íƒ€ì…ì„ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ êµí™˜í•˜ëŠ” "
"ë©”ì„œë“œì— ìƒíƒœ ì „í™˜ì— í•„ìš”í•œ ì‘ì—…ì„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `FooBuilder`ë¥¼ ìƒì„±í•˜ê³  "
"ì´ë¥¼ `Foo` ê°ì²´ë¡œ êµí™˜í•¨ìœ¼ë¡œì¨ ê¸°ë³¸ì ì¸ ìƒíƒœ ë¨¸ì‹ ì˜ ë‹¨ê³„ë¥¼ ê±°ì³¤ìŠµë‹ˆë‹¤."

#: src/static-guarantees/state-machines.md:3
msgid ""
"The peripherals of a microcontroller can be thought of as set of state "
"machines. For example, the configuration of a simplified [GPIO pin](https://"
"en.wikipedia.org/wiki/General-purpose_input/output) could be represented as "
"the following tree of states:"
msgstr ""
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì£¼ë³€ ì¥ì¹˜ëŠ” ìƒíƒœ ë¨¸ì‹ ì˜ ì§‘í•©ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, "
"ë‹¨ìˆœí™”ëœ [GPIO í•€](https://en.wikipedia.org/wiki/General-purpose_input/output)ì˜ "
"êµ¬ì„±ì€ ë‹¤ìŒ ìƒíƒœ íŠ¸ë¦¬ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/static-guarantees/state-machines.md:7
#: src/static-guarantees/state-machines.md:19
msgid "Disabled"
msgstr "ë¹„í™œì„±í™”ë¨"

#: src/static-guarantees/state-machines.md:8
#: src/static-guarantees/state-machines.md:20
msgid "Enabled"
msgstr "í™œì„±í™”ë¨"

#: src/static-guarantees/state-machines.md:9
#: src/static-guarantees/state-machines.md:33
msgid "Configured as Output"
msgstr "ì¶œë ¥ìœ¼ë¡œ êµ¬ì„±ë¨"

#: src/static-guarantees/state-machines.md:10
#: src/static-guarantees/state-machines.md:34
msgid "Output: High"
msgstr "ì¶œë ¥: ë†’ìŒ"

#: src/static-guarantees/state-machines.md:11
msgid "Output: Low"
msgstr "ì¶œë ¥: ë‚®ìŒ"

#: src/static-guarantees/state-machines.md:12
#: src/static-guarantees/state-machines.md:21
#: src/static-guarantees/state-machines.md:32
msgid "Configured as Input"
msgstr "ì…ë ¥ìœ¼ë¡œ êµ¬ì„±ë¨"

#: src/static-guarantees/state-machines.md:13
#: src/static-guarantees/state-machines.md:22
#: src/static-guarantees/state-machines.md:26
msgid "Input: High Resistance"
msgstr "ì…ë ¥: ê³ ì €í•­"

#: src/static-guarantees/state-machines.md:14
#: src/static-guarantees/state-machines.md:27
#: src/static-guarantees/state-machines.md:31
msgid "Input: Pulled Low"
msgstr "ì…ë ¥: í’€ë‹¤ìš´"

#: src/static-guarantees/state-machines.md:15
msgid "Input: Pulled High"
msgstr "ì…ë ¥: í’€ì—…"

#: src/static-guarantees/state-machines.md:17
msgid ""
"If the peripheral starts in the `Disabled` mode, to move to the `Input: High "
"Resistance` mode, we must perform the following steps:"
msgstr ""
"ì£¼ë³€ ì¥ì¹˜ê°€ `Disabled` ëª¨ë“œì—ì„œ ì‹œì‘í•˜ëŠ” ê²½ìš°, `Input: High Resistance` ëª¨ë“œë¡œ "
"ì´ë™í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/static-guarantees/state-machines.md:24
msgid ""
"If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, "
"we must perform the following steps:"
msgstr ""
"`Input: High Resistance`ì—ì„œ `Input: Pulled Low`ë¡œ ì´ë™í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ "
"ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/static-guarantees/state-machines.md:29
msgid ""
"Similarly, if we want to move a GPIO pin from configured as `Input: Pulled "
"Low` to `Output: High`, we must perform the following steps:"
msgstr ""
"ë§ˆì°¬ê°€ì§€ë¡œ, GPIO í•€ì„ `Input: Pulled Low`ë¡œ êµ¬ì„±ëœ ìƒíƒœì—ì„œ `Output: High`ë¡œ "
"ì´ë™í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/static-guarantees/state-machines.md:36
msgid "Hardware Representation"
msgstr "í•˜ë“œì›¨ì–´ í‘œí˜„"

#: src/static-guarantees/state-machines.md:38
msgid ""
"Typically the states listed above are set by writing values to given "
"registers mapped to a GPIO peripheral. Let's define an imaginary GPIO "
"Configuration Register to illustrate this:"
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ìœ„ì— ë‚˜ì—´ëœ ìƒíƒœëŠ” GPIO ì£¼ë³€ ì¥ì¹˜ì— ë§¤í•‘ëœ ì£¼ì–´ì§„ ë ˆì§€ìŠ¤í„°ì— ê°’ì„ "
"ì¨ì„œ ì„¤ì •ë©ë‹ˆë‹¤. ì´ë¥¼ ì„¤ëª…í•˜ê¸° ìœ„í•´ ê°€ìƒì˜ GPIO êµ¬ì„± ë ˆì§€ìŠ¤í„°ë¥¼ ì •ì˜í•´ ë´…ì‹œë‹¤:"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Bit Number(s)"
msgstr "ë¹„íŠ¸ ë²ˆí˜¸"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Value"
msgstr "ê°’"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Meaning"
msgstr "ì˜ë¯¸"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Notes"
msgstr "ì°¸ê³ "

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "enable"
msgstr "í™œì„±í™”"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:7
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:15
msgid "0"
msgstr "0"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "disabled"
msgstr "ë¹„í™œì„±í™”ë¨"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "Disables the GPIO"
msgstr "GPIO ë¹„í™œì„±í™”"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:8
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:10
#: src/static-guarantees/design-contracts.md:16
msgid "1"
msgstr "1"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "enabled"
msgstr "í™œì„±í™”ë¨"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "Enables the GPIO"
msgstr "GPIO í™œì„±í™”"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "direction"
msgstr "ë°©í–¥"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "input"
msgstr "ì…ë ¥"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "Sets the direction to Input"
msgstr "ë°©í–¥ì„ ì…ë ¥ìœ¼ë¡œ ì„¤ì •"

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "output"
msgstr "ì¶œë ¥"

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "Sets the direction to Output"
msgstr "ë°©í–¥ì„ ì¶œë ¥ìœ¼ë¡œ ì„¤ì •"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "input_mode"
msgstr "ì…ë ¥ ëª¨ë“œ"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "2..3"
msgstr "2..3"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "00"
msgstr "00"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "hi-z"
msgstr "í•˜ì´-Z"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "Sets the input as high resistance"
msgstr "ì…ë ¥ì„ ê³ ì €í•­ìœ¼ë¡œ ì„¤ì •"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "01"
msgstr "01"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "pull-low"
msgstr "í’€ë‹¤ìš´"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "Input pin is pulled low"
msgstr "ì…ë ¥ í•€ì´ í’€ë‹¤ìš´ë¨"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "10"
msgstr "10"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "pull-high"
msgstr "í’€ì—…"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "Input pin is pulled high"
msgstr "ì…ë ¥ í•€ì´ í’€ì—…ë¨"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "11"
msgstr "11"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "n/a"
msgstr "í•´ë‹¹ ì—†ìŒ"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "Invalid state. Do not set"
msgstr "ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœ. ì„¤ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤."

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "output_mode"
msgstr "ì¶œë ¥ ëª¨ë“œ"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "4"
msgstr "4"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "set-low"
msgstr "ë‚®ê²Œ ì„¤ì •"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "Output pin is driven low"
msgstr "ì¶œë ¥ í•€ì´ ë‚®ê²Œ êµ¬ë™ë¨"

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "set-high"
msgstr "ë†’ê²Œ ì„¤ì •"

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "Output pin is driven high"
msgstr "ì¶œë ¥ í•€ì´ ë†’ê²Œ êµ¬ë™ë¨"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "input_status"
msgstr "ì…ë ¥ ìƒíƒœ"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "5"
msgstr "5"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "x"
msgstr "x"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "in-val"
msgstr "ì…ë ¥ ê°’"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "0 if input is \\< 1.5v, 1 if input >= 1.5v"
msgstr "ì…ë ¥ì´ 1.5v ë¯¸ë§Œì´ë©´ 0, 1.5v ì´ìƒì´ë©´ 1"

#: src/static-guarantees/state-machines.md:54
msgid "We _could_ expose the following structure in Rust to control this GPIO:"
msgstr "ì´ GPIOë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ Rustì—ì„œ ë‹¤ìŒ êµ¬ì¡°ì²´ë¥¼ ë…¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/static-guarantees/state-machines.md:57
#: src/static-guarantees/design-contracts.md:22
#: src/static-guarantees/design-contracts.md:107
msgid "/// GPIO interface\n"
msgstr "/// GPIO ì¸í„°í˜ì´ìŠ¤\n"

#: src/static-guarantees/state-machines.md:59
#: src/static-guarantees/design-contracts.md:24
#: src/static-guarantees/design-contracts.md:109
msgid "/// GPIO Configuration structure generated by svd2rust\n"
msgstr "/// svd2rustì— ì˜í•´ ìƒì„±ëœ GPIO êµ¬ì„± êµ¬ì¡°ì²´\n"

#: src/static-guarantees/state-machines.md:94
msgid ""
"However, this would allow us to modify certain registers that do not make "
"sense. For example, what happens if we set the `output_mode` field when our "
"GPIO is configured as an input?"
msgstr ""
"í•˜ì§€ë§Œ ì´ë ‡ê²Œ í•˜ë©´ ì˜ë¯¸ ì—†ëŠ” íŠ¹ì • ë ˆì§€ìŠ¤í„°ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, "
"GPIOê°€ ì…ë ¥ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆì„ ë•Œ `output_mode` í•„ë“œë¥¼ ì„¤ì •í•˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?"

#: src/static-guarantees/state-machines.md:96
msgid ""
"In general, use of this structure would allow us to reach states not defined "
"by our state machine above: e.g. an output that is pulled low, or an input "
"that is set high. For some hardware, this may not matter. On other hardware, "
"it could cause unexpected or undefined behavior!"
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ì´ êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ë©´ ìœ„ì— ì •ì˜ëœ ìƒíƒœ ë¨¸ì‹ ì—ì„œ ì •ì˜ë˜ì§€ ì•Šì€ ìƒíƒœì— "
"ë„ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‚®ê²Œ í’€ë§ëœ ì¶œë ¥ ë˜ëŠ” ë†’ê²Œ ì„¤ì •ëœ ì…ë ¥ê³¼ ê°™ì€ "
"ê²½ìš°ì…ë‹ˆë‹¤. ì¼ë¶€ í•˜ë“œì›¨ì–´ì—ì„œëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ, ë‹¤ë¥¸ í•˜ë“œì›¨ì–´ì—ì„œëŠ” "
"ì˜ˆê¸°ì¹˜ ì•Šê±°ë‚˜ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/static-guarantees/state-machines.md:98
msgid ""
"Although this interface is convenient to write, it doesn't enforce the "
"design contracts set out by our hardware implementation."
msgstr ""
"ì´ ì¸í„°í˜ì´ìŠ¤ëŠ” ì‘ì„±í•˜ê¸° í¸ë¦¬í•˜ì§€ë§Œ, í•˜ë“œì›¨ì–´ êµ¬í˜„ì—ì„œ ì„¤ì •í•œ ì„¤ê³„ ê³„ì•½ì„ "
"ê°•ì œí•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤."

#: src/static-guarantees/design-contracts.md:3
msgid ""
"In our last chapter, we wrote an interface that _didn't_ enforce design "
"contracts. Let's take another look at our imaginary GPIO configuration "
"register:"
msgstr ""
"ì§€ë‚œ ì±•í„°ì—ì„œ ìš°ë¦¬ëŠ” ì„¤ê³„ ê³„ì•½ì„ _ê°•ì œí•˜ì§€ ì•ŠëŠ”_ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ê°€ìƒì˜ "
"GPIO êµ¬ì„± ë ˆì§€ìŠ¤í„°ë¥¼ ë‹¤ì‹œ ì‚´í´ë´…ì‹œë‹¤:"

#: src/static-guarantees/design-contracts.md:19
msgid ""
"If we instead checked the state before making use of the underlying "
"hardware, enforcing our design contracts at runtime, we might write code "
"that looks like this instead:"
msgstr ""
"ëŒ€ì‹ , ê¸°ë³¸ í•˜ë“œì›¨ì–´ë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì— ìƒíƒœë¥¼ í™•ì¸í•˜ì—¬ ëŸ°íƒ€ì„ì— ì„¤ê³„ ê³„ì•½ì„ "
"ê°•ì œí•œë‹¤ë©´, ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/static-guarantees/design-contracts.md:37
msgid "// Must be enabled to set direction\n"
msgstr "// ë°©í–¥ì„ ì„¤ì •í•˜ë ¤ë©´ í™œì„±í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:50
msgid "// Must be enabled to set input mode\n"
msgstr "// ì…ë ¥ ëª¨ë“œë¥¼ ì„¤ì •í•˜ë ¤ë©´ í™œì„±í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:55
#: src/static-guarantees/design-contracts.md:91
msgid "// Direction must be input\n"
msgstr "// ë°©í–¥ì€ ì…ë ¥ì´ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:68
msgid "// Must be enabled to set output status\n"
msgstr "// ì¶œë ¥ ìƒíƒœë¥¼ ì„¤ì •í•˜ë ¤ë©´ í™œì„±í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:73
msgid "// Direction must be output\n"
msgstr "// ë°©í–¥ì€ ì¶œë ¥ì´ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:86
msgid "// Must be enabled to get status\n"
msgstr "// ìƒíƒœë¥¼ ì–»ìœ¼ë ¤ë©´ í™œì„±í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:100
msgid ""
"Because we need to enforce the restrictions on the hardware, we end up doing "
"a lot of runtime checking which wastes time and resources, and this code "
"will be much less pleasant for the developer to use."
msgstr ""
"í•˜ë“œì›¨ì–´ì— ëŒ€í•œ ì œì•½ì„ ê°•ì œí•´ì•¼ í•˜ë¯€ë¡œ, ë§ì€ ëŸ°íƒ€ì„ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ê²Œ ë˜ì–´ ì‹œê°„ê³¼ "
"ìì›ì„ ë‚­ë¹„í•˜ê³ , ì´ ì½”ë“œëŠ” ê°œë°œìê°€ ì‚¬ìš©í•˜ê¸°ì— í›¨ì”¬ ëœ ì¦ê±°ìš¸ ê²ƒì…ë‹ˆë‹¤."

#: src/static-guarantees/design-contracts.md:102
msgid "Type States"
msgstr "íƒ€ì… ìƒíƒœ"

#: src/static-guarantees/design-contracts.md:104
msgid ""
"But what if instead, we used Rust's type system to enforce the state "
"transition rules? Take this example:"
msgstr ""
"í•˜ì§€ë§Œ ëŒ€ì‹  Rustì˜ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬ ìƒíƒœ ì „í™˜ ê·œì¹™ì„ ê°•ì œí•œë‹¤ë©´ ì–´ë–¨ê¹Œìš”? "
"ì´ ì˜ˆì œë¥¼ ì‚´í´ë³´ì„¸ìš”:"

#: src/static-guarantees/design-contracts.md:115
msgid "// Type states for MODE in GpioConfig\n"
msgstr "// GpioConfigì˜ MODEì— ëŒ€í•œ íƒ€ì… ìƒíƒœ\n"

#: src/static-guarantees/design-contracts.md:125
msgid "/// These functions may be used on any GPIO Pin\n"
msgstr "/// ì´ í•¨ìˆ˜ë“¤ì€ ëª¨ë“  GPIO í•€ì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:166
msgid "/// This function may be used on an Output Pin\n"
msgstr "/// ì´ í•¨ìˆ˜ëŠ” ì¶œë ¥ í•€ì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:173
msgid "/// These methods may be used on any enabled input GPIO\n"
msgstr "/// ì´ ë©”ì„œë“œë“¤ì€ í™œì„±í™”ëœ ëª¨ë“  ì…ë ¥ GPIOì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:212
msgid "Now let's see what the code using this would look like:"
msgstr "ì´ì œ ì´ê²ƒì„ ì‚¬ìš©í•˜ëŠ” ì½”ë“œê°€ ì–´ë–»ê²Œ ìƒê²¼ëŠ”ì§€ ë´…ì‹œë‹¤:"

#: src/static-guarantees/design-contracts.md:215
msgid ""
"/*\n"
" * Example 1: Unconfigured to High-Z input\n"
" */"
msgstr ""
"/*\n"
" * ì˜ˆì œ 1: êµ¬ì„±ë˜ì§€ ì•ŠìŒì—ì„œ High-Z ì…ë ¥ìœ¼ë¡œ\n"
" */"

#: src/static-guarantees/design-contracts.md:219
msgid ""
"// Can't do this, pin isn't enabled!\n"
"// pin.into_input_pull_down();\n"
msgstr ""
"// ì´ë ‡ê²Œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í•€ì´ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!\n"
"// pin.into_input_pull_down();\n"

#: src/static-guarantees/design-contracts.md:222
msgid "// Now turn the pin from unconfigured to a high-z input\n"
msgstr "// ì´ì œ í•€ì„ êµ¬ì„±ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ high-z ì…ë ¥ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤\n"

#: src/static-guarantees/design-contracts.md:225
msgid "// Read from the pin\n"
msgstr "// í•€ì—ì„œ ì½ê¸°\n"

#: src/static-guarantees/design-contracts.md:228
msgid ""
"// Can't do this, input pins don't have this interface!\n"
"// input_pin.set_bit(true);\n"
msgstr ""
"// ì´ë ‡ê²Œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì…ë ¥ í•€ì—ëŠ” ì´ ì¸í„°í˜ì´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!\n"
"// input_pin.set_bit(true);\n"

#: src/static-guarantees/design-contracts.md:231
msgid ""
"/*\n"
" * Example 2: High-Z input to Pulled Low input\n"
" */"
msgstr ""
"/*\n"
" * ì˜ˆì œ 2: High-Z ì…ë ¥ì—ì„œ í’€ë‹¤ìš´ ì…ë ¥ìœ¼ë¡œ\n"
" */"

#: src/static-guarantees/design-contracts.md:237
msgid ""
"/*\n"
" * Example 3: Pulled Low input to Output, set high\n"
" */"
msgstr ""
"/*\n"
" * ì˜ˆì œ 3: í’€ë‹¤ìš´ ì…ë ¥ì—ì„œ ì¶œë ¥ìœ¼ë¡œ, ë†’ê²Œ ì„¤ì •\n"
" */"

#: src/static-guarantees/design-contracts.md:243
msgid ""
"// Can't do this, output pins don't have this interface!\n"
"// output_pin.into_input_pull_down();\n"
msgstr ""
"// ì´ë ‡ê²Œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¶œë ¥ í•€ì—ëŠ” ì´ ì¸í„°í˜ì´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!\n"
"// output_pin.into_input_pull_down();\n"

#: src/static-guarantees/design-contracts.md:248
msgid ""
"This is definitely a convenient way to store the state of the pin, but why "
"do it this way? Why is this better than storing the state as an `enum` "
"inside of our `GpioConfig` structure?"
msgstr ""
"ì´ê²ƒì€ í•€ì˜ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” í¸ë¦¬í•œ ë°©ë²•ì´ì§€ë§Œ, ì™œ ì´ëŸ° ì‹ìœ¼ë¡œ í•´ì•¼ í• ê¹Œìš”? "
"`GpioConfig` êµ¬ì¡°ì²´ ë‚´ë¶€ì— `enum`ìœ¼ë¡œ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ê²ƒë³´ë‹¤ ì™œ ì´ê²ƒì´ ë” "
"ë‚˜ì„ê¹Œìš”?"

#: src/static-guarantees/design-contracts.md:250
msgid "Compile Time Functional Safety"
msgstr "ì»´íŒŒì¼ íƒ€ì„ ê¸°ëŠ¥ ì•ˆì „"

#: src/static-guarantees/design-contracts.md:252
msgid ""
"Because we are enforcing our design constraints entirely at compile time, "
"this incurs no runtime cost. It is impossible to set an output mode when you "
"have a pin in an input mode. Instead, you must walk through the states by "
"converting it to an output pin, and then setting the output mode. Because of "
"this, there is no runtime penalty due to checking the current state before "
"executing a function."
msgstr ""
"ì„¤ê³„ ì œì•½ì„ ì „ì ìœ¼ë¡œ ì»´íŒŒì¼ íƒ€ì„ì— ê°•ì œí•˜ê¸° ë•Œë¬¸ì— ëŸ°íƒ€ì„ ë¹„ìš©ì´ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "
"ì…ë ¥ ëª¨ë“œì˜ í•€ì´ ìˆì„ ë•Œ ì¶œë ¥ ëª¨ë“œë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ëŒ€ì‹ , í•€ì„ ì¶œë ¥ "
"í•€ìœ¼ë¡œ ë³€í™˜í•œ ë‹¤ìŒ ì¶œë ¥ ëª¨ë“œë¥¼ ì„¤ì •í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìƒíƒœë¥¼ ì „í™˜í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¡œ ì¸í•´ "
"í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— í˜„ì¬ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë° ë”°ë¥¸ ëŸ°íƒ€ì„ í˜ë„í‹°ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/static-guarantees/design-contracts.md:254
msgid ""
"Also, because these states are enforced by the type system, there is no "
"longer room for errors by consumers of this interface. If they try to "
"perform an illegal state transition, the code will not compile!"
msgstr ""
"ë˜í•œ, ì´ëŸ¬í•œ ìƒíƒœëŠ” íƒ€ì… ì‹œìŠ¤í…œì— ì˜í•´ ê°•ì œë˜ë¯€ë¡œ, ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” "
"ì†Œë¹„ìê°€ ì˜¤ë¥˜ë¥¼ ë²”í•  ì—¬ì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ë§Œì•½ ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœ ì „í™˜ì„ ì‹œë„í•˜ë©´ "
"ì½”ë“œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤!"

#: src/static-guarantees/zero-cost-abstractions.md:3
msgid ""
"Type states are also an excellent example of Zero Cost Abstractions - the "
"ability to move certain behaviors to compile time execution or analysis. "
"These type states contain no actual data, and are instead used as markers. "
"Since they contain no data, they have no actual representation in memory at "
"runtime:"
msgstr ""
"íƒ€ì… ìƒíƒœëŠ” ì œë¡œ ë¹„ìš© ì¶”ìƒí™”ì˜ í›Œë¥­í•œ ì˜ˆì‹œì´ê¸°ë„ í•©ë‹ˆë‹¤. ì¦‰, íŠ¹ì • ë™ì‘ì„ ì»´íŒŒì¼ "
"íƒ€ì„ ì‹¤í–‰ ë˜ëŠ” ë¶„ì„ìœ¼ë¡œ ì˜®ê¸°ëŠ” ëŠ¥ë ¥ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ íƒ€ì… ìƒíƒœëŠ” ì‹¤ì œ ë°ì´í„°ë¥¼ "
"í¬í•¨í•˜ì§€ ì•Šìœ¼ë©°, ëŒ€ì‹  ë§ˆì»¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ë°ì´í„°ë¥¼ í¬í•¨í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ëŸ°íƒ€ì„ì— "
"ë©”ëª¨ë¦¬ì— ì‹¤ì œ í‘œí˜„ì´ ì—†ìŠµë‹ˆë‹¤:"

#: src/static-guarantees/zero-cost-abstractions.md:8
#: src/static-guarantees/zero-cost-abstractions.md:9
#: src/static-guarantees/zero-cost-abstractions.md:10
#: src/static-guarantees/zero-cost-abstractions.md:11
msgid "// == 0\n"
msgstr "// == 0\n"

#: src/static-guarantees/zero-cost-abstractions.md:14
msgid "Zero Sized Types"
msgstr "ì œë¡œ í¬ê¸° íƒ€ì…"

#: src/static-guarantees/zero-cost-abstractions.md:20
msgid ""
"Structures defined like this are called Zero Sized Types, as they contain no "
"actual data. Although these types act \"real\" at compile time - you can "
"copy them, move them, take references to them, etc., however the optimizer "
"will completely strip them away."
msgstr ""
"ì´ì™€ ê°™ì´ ì •ì˜ëœ êµ¬ì¡°ì²´ëŠ” ì‹¤ì œ ë°ì´í„°ë¥¼ í¬í•¨í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì œë¡œ í¬ê¸° íƒ€ì…ì´ë¼ê³  "
"í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ íƒ€ì…ì€ ì»´íŒŒì¼ íƒ€ì„ì—ëŠ” \"ì‹¤ì œ\"ì²˜ëŸ¼ ì‘ë™í•˜ì§€ë§Œ(ë³µì‚¬, ì´ë™, ì°¸ì¡° "
"ê°€ì ¸ì˜¤ê¸° ë“±), ì˜µí‹°ë§ˆì´ì €ëŠ” ì´ë¥¼ ì™„ì „íˆ ì œê±°í•©ë‹ˆë‹¤."

#: src/static-guarantees/zero-cost-abstractions.md:22
msgid "In this snippet of code:"
msgstr "ì´ ì½”ë“œ ìŠ¤ë‹ˆí«ì—ì„œ:"

#: src/static-guarantees/zero-cost-abstractions.md:36
msgid ""
"The GpioConfig we return never exists at runtime. Calling this function will "
"generally boil down to a single assembly instruction - storing a constant "
"register value to a register location. This means that the type state "
"interface we've developed is a zero cost abstraction - it uses no more CPU, "
"RAM, or code space tracking the state of `GpioConfig`, and renders to the "
"same machine code as a direct register access."
msgstr ""
"ìš°ë¦¬ê°€ ë°˜í™˜í•˜ëŠ” GpioConfigëŠ” ëŸ°íƒ€ì„ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” "
"ê²ƒì€ ì¼ë°˜ì ìœ¼ë¡œ ë‹¨ì¼ ì–´ì…ˆë¸”ë¦¬ ëª…ë ¹ìœ¼ë¡œ ê·€ê²°ë©ë‹ˆë‹¤. ì¦‰, ìƒìˆ˜ ë ˆì§€ìŠ¤í„° ê°’ì„ "
"ë ˆì§€ìŠ¤í„° ìœ„ì¹˜ì— ì €ì¥í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” ìš°ë¦¬ê°€ ê°œë°œí•œ íƒ€ì… ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ê°€ "
"ì œë¡œ ë¹„ìš© ì¶”ìƒí™”ì„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. `GpioConfig`ì˜ ìƒíƒœë¥¼ ì¶”ì í•˜ëŠ” ë° CPU, RAM "
"ë˜ëŠ” ì½”ë“œ ê³µê°„ì„ ë” ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©°, ì§ì ‘ ë ˆì§€ìŠ¤í„° ì ‘ê·¼ê³¼ ë™ì¼í•œ ë¨¸ì‹  ì½”ë“œë¡œ "
"ë Œë”ë§ë©ë‹ˆë‹¤."

#: src/static-guarantees/zero-cost-abstractions.md:38
msgid "Nesting"
msgstr "ì¤‘ì²©"

#: src/static-guarantees/zero-cost-abstractions.md:40
msgid ""
"In general, these abstractions may be nested as deeply as you would like. As "
"long as all components used are zero sized types, the whole structure will "
"not exist at runtime."
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ì´ëŸ¬í•œ ì¶”ìƒí™”ëŠ” ì›í•˜ëŠ” ë§Œí¼ ê¹Šê²Œ ì¤‘ì²©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‚¬ìš©ëœ ëª¨ë“  "
"êµ¬ì„± ìš”ì†Œê°€ ì œë¡œ í¬ê¸° íƒ€ì…ì¸ í•œ, ì „ì²´ êµ¬ì¡°ëŠ” ëŸ°íƒ€ì„ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/static-guarantees/zero-cost-abstractions.md:42
msgid ""
"For complex or deeply nested structures, it may be tedious to define all "
"possible combinations of state. In these cases, macros may be used to "
"generate all implementations."
msgstr ""
"ë³µì¡í•˜ê±°ë‚˜ ê¹Šê²Œ ì¤‘ì²©ëœ êµ¬ì¡°ì²´ì˜ ê²½ìš°, ëª¨ë“  ê°€ëŠ¥í•œ ìƒíƒœ ì¡°í•©ì„ ì •ì˜í•˜ëŠ” ê²ƒì´ "
"ì§€ë£¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ê²½ìš°, ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  êµ¬í˜„ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/portability/index.md:3
msgid ""
"In embedded environments portability is a very important topic: Every vendor "
"and even each family from a single manufacturer offers different peripherals "
"and capabilities and similarly the ways to interact with the peripherals "
"will vary."
msgstr ""
"ì„ë² ë””ë“œ í™˜ê²½ì—ì„œ ì´ì‹ì„±ì€ ë§¤ìš° ì¤‘ìš”í•œ ì£¼ì œì…ë‹ˆë‹¤. ëª¨ë“  ë²¤ë”ì™€ ì‹¬ì§€ì–´ ë‹¨ì¼ "
"ì œì¡°ì—…ì²´ì˜ ê° ì œí’ˆêµ°ë„ ë‹¤ë¥¸ ì£¼ë³€ ì¥ì¹˜ì™€ ê¸°ëŠ¥ì„ ì œê³µí•˜ë©°, ì£¼ë³€ ì¥ì¹˜ì™€ ìƒí˜¸ "
"ì‘ìš©í•˜ëŠ” ë°©ì‹ë„ ìœ ì‚¬í•˜ê²Œ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/portability/index.md:5
msgid ""
"A common way to equalize such differences is via a layer called Hardware "
"Abstraction layer or **HAL**."
msgstr ""
"ì´ëŸ¬í•œ ì°¨ì´ë¥¼ í•´ì†Œí•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì€ í•˜ë“œì›¨ì–´ ì¶”ìƒí™” ê³„ì¸µ ë˜ëŠ” **HAL**ì´ë¼ëŠ” "
"ê³„ì¸µì„ í†µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/portability/index.md:7
msgid ""
"Hardware abstractions are sets of routines in software that emulate some "
"platform-specific details, giving programs direct access to the hardware "
"resources."
msgstr ""
"í•˜ë“œì›¨ì–´ ì¶”ìƒí™”ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ì¼ë¶€ í”Œë«í¼ë³„ ì„¸ë¶€ ì‚¬í•­ì„ ì—ë®¬ë ˆì´íŠ¸í•˜ì—¬ "
"í”„ë¡œê·¸ë¨ì— í•˜ë“œì›¨ì–´ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì§ì ‘ ì ‘ê·¼ì„ ì œê³µí•˜ëŠ” ë£¨í‹´ ì§‘í•©ì…ë‹ˆë‹¤."

#: src/portability/index.md:9
msgid ""
"They often allow programmers to write device-independent, high performance "
"applications by providing standard operating system (OS) calls to hardware."
msgstr ""
"ì´ë“¤ì€ ì¢…ì¢… í‘œì¤€ ìš´ì˜ ì²´ì œ(OS) í˜¸ì¶œì„ í•˜ë“œì›¨ì–´ì— ì œê³µí•¨ìœ¼ë¡œì¨ í”„ë¡œê·¸ë˜ë¨¸ê°€ ì¥ì¹˜ "
"ë…ë¦½ì ì¸ ê³ ì„±ëŠ¥ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤."

#: src/portability/index.md:11
msgid ""
"_Wikipedia: [Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"
msgstr ""
"_ìœ„í‚¤ë°±ê³¼: [í•˜ë“œì›¨ì–´ ì¶”ìƒí™” ê³„ì¸µ](https://en.wikipedia.org/wiki/Hardware_abstraction)_"

#: src/portability/index.md:15
msgid ""
"Embedded systems are a bit special in this regard since we typically do not "
"have operating systems and user installable software but firmware images "
"which are compiled as a whole as well as a number of other constraints. So "
"while the traditional approach as defined by Wikipedia could potentially "
"work it is likely not the most productive approach to ensure portability."
msgstr ""
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì€ ì¼ë°˜ì ìœ¼ë¡œ ìš´ì˜ ì²´ì œì™€ ì‚¬ìš©ì ì„¤ì¹˜ ê°€ëŠ¥ ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì•„ë‹Œ "
"ì „ì²´ì ìœ¼ë¡œ ì»´íŒŒì¼ëœ íŒì›¨ì–´ ì´ë¯¸ì§€ì™€ ì—¬ëŸ¬ ë‹¤ë¥¸ ì œì•½ ì¡°ê±´ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— ì´ "
"ì ì—ì„œ ë‹¤ì†Œ íŠ¹ë³„í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ìœ„í‚¤ë°±ê³¼ì—ì„œ ì •ì˜í•œ ì „í†µì ì¸ ì ‘ê·¼ ë°©ì‹ì´ ì ì¬ì ìœ¼ë¡œ "
"ì‘ë™í•  ìˆ˜ ìˆì§€ë§Œ, ì´ì‹ì„±ì„ ë³´ì¥í•˜ëŠ” ê°€ì¥ ìƒì‚°ì ì¸ ì ‘ê·¼ ë°©ì‹ì€ ì•„ë‹ ê²ƒì…ë‹ˆë‹¤."

#: src/portability/index.md:17
msgid "How do we do this in Rust? Enter **embedded-hal**..."
msgstr "Rustì—ì„œëŠ” ì–´ë–»ê²Œ í• ê¹Œìš”? **embedded-hal**ì„ ì†Œê°œí•©ë‹ˆë‹¤..."

#: src/portability/index.md:19
msgid "What is embedded-hal?"
msgstr "embedded-halì´ë€ ë¬´ì—‡ì¸ê°€ìš”?"

#: src/portability/index.md:21
msgid ""
"In a nutshell it is a set of traits which define implementation contracts "
"between **HAL implementations**, **drivers** and **applications (or "
"firmwares)**. Those contracts include both capabilities (i.e. if a trait is "
"implemented for a certain type, the **HAL implementation** provides a "
"certain capability) and methods (i.e. if you can construct a type "
"implementing a trait it is guaranteed that you have the methods specified in "
"the trait available)."
msgstr ""
"ê°„ë‹¨íˆ ë§í•´, **HAL êµ¬í˜„**, **ë“œë¼ì´ë²„** ë° **ì• í”Œë¦¬ì¼€ì´ì…˜(ë˜ëŠ” íŒì›¨ì–´)** ê°„ì˜ "
"êµ¬í˜„ ê³„ì•½ì„ ì •ì˜í•˜ëŠ” íŠ¸ë ˆì´íŠ¸ ì§‘í•©ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ê³„ì•½ì—ëŠ” ê¸°ëŠ¥(ì¦‰, íŠ¹ì • íƒ€ì…ì— "
"ëŒ€í•´ íŠ¸ë ˆì´íŠ¸ê°€ êµ¬í˜„ë˜ë©´ **HAL êµ¬í˜„**ì´ íŠ¹ì • ê¸°ëŠ¥ì„ ì œê³µí•¨)ê³¼ ë©”ì„œë“œ(ì¦‰, íŠ¸ë ˆì´íŠ¸ë¥¼ "
"êµ¬í˜„í•˜ëŠ” íƒ€ì…ì„ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤ë©´ íŠ¸ë ˆì´íŠ¸ì— ì§€ì •ëœ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì´ "
"ë³´ì¥ë¨)ê°€ ëª¨ë‘ í¬í•¨ë©ë‹ˆë‹¤."

#: src/portability/index.md:23
msgid "A typical layering might look like this:"
msgstr "ì¼ë°˜ì ì¸ ê³„ì¸µí™”ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/portability/index.md:25
msgid "![](../assets/rust_layers.svg)"
msgstr "![](../assets/rust_layers.svg)"

#: src/portability/index.md:27
msgid "Some of the defined traits in **embedded-hal** are:"
msgstr "**embedded-hal**ì— ì •ì˜ëœ íŠ¸ë ˆì´íŠ¸ ì¤‘ ì¼ë¶€ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/portability/index.md:28
msgid "GPIO (input and output pins)"
msgstr "GPIO (ì…ë ¥ ë° ì¶œë ¥ í•€)"

#: src/portability/index.md:29
msgid "Serial communication"
msgstr "ì§ë ¬ í†µì‹ "

#: src/portability/index.md:30 src/appendix/glossary.md:26
msgid "I2C"
msgstr "I2C"

#: src/portability/index.md:31 src/appendix/glossary.md:42
msgid "SPI"
msgstr "SPI"

#: src/portability/index.md:32
msgid "Timers/Countdowns"
msgstr "íƒ€ì´ë¨¸/ì¹´ìš´íŠ¸ë‹¤ìš´"

#: src/portability/index.md:33
msgid "Analog Digital Conversion"
msgstr "ì•„ë‚ ë¡œê·¸ ë””ì§€í„¸ ë³€í™˜"

#: src/portability/index.md:35
msgid ""
"The main reason for having the **embedded-hal** traits and crates "
"implementing and using them is to keep complexity in check. If you consider "
"that an application might have to implement the use of the peripheral in the "
"hardware as well as the application and potentially drivers for additional "
"hardware components, then it should be easy to see that the re-usability is "
"very limited. Expressed mathematically, if **M** is the number of peripheral "
"HAL implementations and **N** the number of drivers then if we were to "
"reinvent the wheel for every application then we would end up with **M\\*N** "
"implementations while by using the _API_ provided by the **embedded-hal** "
"traits will make the implementation complexity approach **M+N**. Of course "
"there're additional benefits to be had, such as less trial-and-error due to "
"a well-defined and ready-to-use APIs."
msgstr ""
"**embedded-hal** íŠ¸ë ˆì´íŠ¸ì™€ ì´ë¥¼ êµ¬í˜„í•˜ê³  ì‚¬ìš©í•˜ëŠ” í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ì£¼ëœ "
"ì´ìœ ëŠ” ë³µì¡ì„±ì„ ì œì–´í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. ì• í”Œë¦¬ì¼€ì´ì…˜ì´ í•˜ë“œì›¨ì–´ì—ì„œ ì£¼ë³€ ì¥ì¹˜ ì‚¬ìš©ì„ "
"êµ¬í˜„í•´ì•¼ í•  ë¿ë§Œ ì•„ë‹ˆë¼ ì• í”Œë¦¬ì¼€ì´ì…˜ ë° ì¶”ê°€ í•˜ë“œì›¨ì–´ êµ¬ì„± ìš”ì†Œìš© ë“œë¼ì´ë²„ë„ "
"êµ¬í˜„í•´ì•¼ í•œë‹¤ê³  ìƒê°í•˜ë©´ ì¬ì‚¬ìš©ì„±ì´ ë§¤ìš° ì œí•œì ì´ë¼ëŠ” ê²ƒì„ ì‰½ê²Œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ìˆ˜í•™ì ìœ¼ë¡œ í‘œí˜„í•˜ë©´, **M** ì´ ì£¼ë³€ ì¥ì¹˜ HAL êµ¬í˜„ì˜ ìˆ˜ì´ê³  **N** ì´ ë“œë¼ì´ë²„ì˜ "
"ìˆ˜ë¼ë©´, ëª¨ë“  ì• í”Œë¦¬ì¼€ì´ì…˜ì— ëŒ€í•´ ë°”í€´ë¥¼ ì¬ë°œëª…í•œë‹¤ë©´ **M*N** êµ¬í˜„ìœ¼ë¡œ ëë‚˜ê²Œ ë  "
"ê²ƒì…ë‹ˆë‹¤. ë°˜ë©´ **embedded-hal** íŠ¸ë ˆì´íŠ¸ê°€ ì œê³µí•˜ëŠ” _API_ë¥¼ ì‚¬ìš©í•˜ë©´ êµ¬í˜„ "
"ë³µì¡ì„±ì´ **M+N**ì— ê°€ê¹Œì›Œì§ˆ ê²ƒì…ë‹ˆë‹¤. ë¬¼ë¡  ì˜ ì •ì˜ë˜ê³  ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” APIë¡œ "
"ì¸í•´ ì‹œí–‰ì°©ì˜¤ê°€ ì¤„ì–´ë“œëŠ” ë“± ì¶”ê°€ì ì¸ ì´ì ë„ ìˆìŠµë‹ˆë‹¤."

#: src/portability/index.md:37
msgid "Users of the embedded-hal"
msgstr "embedded-hal ì‚¬ìš©ì"

#: src/portability/index.md:39
msgid "As said above there are three main users of the HAL:"
msgstr "ìœ„ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ HALì˜ ì£¼ìš” ì‚¬ìš©ìëŠ” ì„¸ ê°€ì§€ì…ë‹ˆë‹¤:"

#: src/portability/index.md:41
msgid "HAL implementation"
msgstr "HAL êµ¬í˜„"

#: src/portability/index.md:43
msgid ""
"A HAL implementation provides the interfacing between the hardware and the "
"users of the HAL traits. Typical implementations consist of three parts:"
msgstr ""
"HAL êµ¬í˜„ì€ í•˜ë“œì›¨ì–´ì™€ HAL íŠ¸ë ˆì´íŠ¸ ì‚¬ìš©ì ê°„ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì¼ë°˜ì ì¸ "
"êµ¬í˜„ì€ ì„¸ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:"

#: src/portability/index.md:44
msgid "One or more hardware specific types"
msgstr "í•˜ë‚˜ ì´ìƒì˜ í•˜ë“œì›¨ì–´ íŠ¹ì • íƒ€ì…"

#: src/portability/index.md:45
msgid ""
"Functions to create and initialize such a type, often providing various "
"configuration options (speed, operation mode, use pins, etc.)"
msgstr ""
"ì´ëŸ¬í•œ íƒ€ì…ì„ ìƒì„±í•˜ê³  ì´ˆê¸°í™”í•˜ëŠ” í•¨ìˆ˜, ì¢…ì¢… ë‹¤ì–‘í•œ êµ¬ì„± ì˜µì…˜(ì†ë„, ì‘ë™ ëª¨ë“œ, "
"í•€ ì‚¬ìš© ë“±)ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/portability/index.md:46
msgid "one or more `trait` `impl` of **embedded-hal** traits for that type"
msgstr "í•´ë‹¹ íƒ€ì…ì— ëŒ€í•œ **embedded-hal** íŠ¸ë ˆì´íŠ¸ì˜ í•˜ë‚˜ ì´ìƒì˜ `trait` `impl`"

#: src/portability/index.md:48
msgid "Such a **HAL implementation** can come in various flavours:"
msgstr "ì´ëŸ¬í•œ **HAL êµ¬í˜„**ì€ ë‹¤ì–‘í•œ í˜•íƒœë¡œ ì œê³µë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/portability/index.md:49
msgid "Via low-level hardware access, e.g. via registers"
msgstr "ì €ìˆ˜ì¤€ í•˜ë“œì›¨ì–´ ì ‘ê·¼ì„ í†µí•´, ì˜ˆ: ë ˆì§€ìŠ¤í„°ë¥¼ í†µí•´"

#: src/portability/index.md:50
msgid "Via operating system, e.g. by using the `sysfs` under Linux"
msgstr "ìš´ì˜ ì²´ì œë¥¼ í†µí•´, ì˜ˆ: Linuxì—ì„œ `sysfs`ë¥¼ ì‚¬ìš©í•˜ì—¬"

#: src/portability/index.md:51
msgid "Via adapter, e.g. a mock of types for unit testing"
msgstr "ì–´ëŒ‘í„°ë¥¼ í†µí•´, ì˜ˆ: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ íƒ€ì… ëª¨ì˜"

#: src/portability/index.md:52
msgid "Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander"
msgstr "í•˜ë“œì›¨ì–´ ì–´ëŒ‘í„°ìš© ë“œë¼ì´ë²„ë¥¼ í†µí•´, ì˜ˆ: I2C ë©€í‹°í”Œë ‰ì„œ ë˜ëŠ” GPIO í™•ì¥ê¸°"

#: src/portability/index.md:54
msgid "Driver"
msgstr "ë“œë¼ì´ë²„"

#: src/portability/index.md:56
msgid ""
"A driver implements a set of custom functionality for an internal or "
"external component, connected to a peripheral implementing the embedded-hal "
"traits. Typical examples for such drivers include various sensors "
"(temperature, magnetometer, accelerometer, light), display devices (LED "
"arrays, LCD displays) and actuators (motors, transmitters)."
msgstr ""
"ë“œë¼ì´ë²„ëŠ” embedded-hal íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ì£¼ë³€ ì¥ì¹˜ì— ì—°ê²°ëœ ë‚´ë¶€ ë˜ëŠ” ì™¸ë¶€ "
"êµ¬ì„± ìš”ì†Œì— ëŒ€í•œ ì‚¬ìš©ì ì§€ì • ê¸°ëŠ¥ ì§‘í•©ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë“œë¼ì´ë²„ì˜ ì¼ë°˜ì ì¸ "
"ì˜ˆë¡œëŠ” ë‹¤ì–‘í•œ ì„¼ì„œ(ì˜¨ë„, ìë ¥ê³„, ê°€ì†ë„ê³„, ì¡°ëª…), ë””ìŠ¤í”Œë ˆì´ ì¥ì¹˜(LED ë°°ì—´, LCD "
"ë””ìŠ¤í”Œë ˆì´) ë° ì•¡ì¶”ì—ì´í„°(ëª¨í„°, ì†¡ì‹ ê¸°)ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/portability/index.md:58
msgid ""
"A driver has to be initialized with an instance of type that implements a "
"certain `trait` of the embedded-hal which is ensured via trait bound and "
"provides its own type instance with a custom set of methods allowing to "
"interact with the driven device."
msgstr ""
"ë“œë¼ì´ë²„ëŠ” íŠ¸ë ˆì´íŠ¸ ë°”ìš´ë“œë¥¼ í†µí•´ ë³´ì¥ë˜ëŠ” embedded-halì˜ íŠ¹ì • `trait`ë¥¼ êµ¬í˜„í•˜ëŠ” "
"íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì´ˆê¸°í™”ë˜ì–´ì•¼ í•˜ë©°, êµ¬ë™ë˜ëŠ” ì¥ì¹˜ì™€ ìƒí˜¸ ì‘ìš©í•  ìˆ˜ ìˆëŠ” ì‚¬ìš©ì "
"ì§€ì • ë©”ì„œë“œ ì§‘í•©ì„ ê°€ì§„ ìì²´ íƒ€ì… ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/portability/index.md:60
msgid "Application"
msgstr "ì• í”Œë¦¬ì¼€ì´ì…˜"

#: src/portability/index.md:62
msgid ""
"The application binds the various parts together and ensures that the "
"desired functionality is achieved. When porting between different systems, "
"this is the part which requires the most adaptation efforts, since the "
"application needs to correctly initialize the real hardware via the HAL "
"implementation and the initialisation of different hardware differs, "
"sometimes drastically so. Also the user choice often plays a big role, since "
"components can be physically connected to different terminals, hardware "
"buses sometimes need external hardware to match the configuration or there "
"are different trade-offs to be made in the use of internal peripherals (e.g. "
"multiple timers with different capabilities are available or peripherals "
"conflict with others)."
msgstr ""
"ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ë‹¤ì–‘í•œ ë¶€ë¶„ì„ í•¨ê»˜ ë¬¶ê³  ì›í•˜ëŠ” ê¸°ëŠ¥ì´ ë‹¬ì„±ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤. ë‹¤ë¥¸ "
"ì‹œìŠ¤í…œ ê°„ì— í¬íŒ…í•  ë•Œ, ì´ ë¶€ë¶„ì€ ê°€ì¥ ë§ì€ ì ì‘ ë…¸ë ¥ì´ í•„ìš”í•œë°, ì• í”Œë¦¬ì¼€ì´ì…˜ì´ "
"HAL êµ¬í˜„ì„ í†µí•´ ì‹¤ì œ í•˜ë“œì›¨ì–´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”í•´ì•¼ í•˜ê³ , ë‹¤ë¥¸ í•˜ë“œì›¨ì–´ì˜ ì´ˆê¸°í™”ëŠ” "
"ë•Œë•Œë¡œ í¬ê²Œ ë‹¤ë¥´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë˜í•œ êµ¬ì„± ìš”ì†Œê°€ ë¬¼ë¦¬ì ìœ¼ë¡œ ë‹¤ë¥¸ í„°ë¯¸ë„ì— ì—°ê²°ë  "
"ìˆ˜ ìˆê³ , í•˜ë“œì›¨ì–´ ë²„ìŠ¤ê°€ ë•Œë•Œë¡œ êµ¬ì„±ê³¼ ì¼ì¹˜í•˜ë„ë¡ ì™¸ë¶€ í•˜ë“œì›¨ì–´ê°€ í•„ìš”í•˜ê±°ë‚˜, "
"ë‚´ë¶€ ì£¼ë³€ ì¥ì¹˜ ì‚¬ìš©ì— ìˆì–´ ë‹¤ë¥¸ íŠ¸ë ˆì´ë“œì˜¤í”„ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ(ì˜ˆ: ë‹¤ë¥¸ ê¸°ëŠ¥ì„ "
"ê°€ì§„ ì—¬ëŸ¬ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê±°ë‚˜ ì£¼ë³€ ì¥ì¹˜ê°€ ì„œë¡œ ì¶©ëŒí•˜ëŠ” ê²½ìš°) ì‚¬ìš©ì ì„ íƒë„ "
"í° ì—­í• ì„ í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:3
msgid ""
"Concurrency happens whenever different parts of your program might execute "
"at different times or out of order. In an embedded context, this includes:"
msgstr ""
"ë™ì‹œì„±ì€ í”„ë¡œê·¸ë¨ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì´ ë‹¤ë¥¸ ì‹œê°„ì— ë˜ëŠ” ìˆœì„œì— ê´€ê³„ì—†ì´ ì‹¤í–‰ë  ìˆ˜ ìˆì„ "
"ë•Œ ë°œìƒí•©ë‹ˆë‹¤. ì„ë² ë””ë“œ ì»¨í…ìŠ¤íŠ¸ì—ì„œëŠ” ë‹¤ìŒì„ í¬í•¨í•©ë‹ˆë‹¤:"

#: src/concurrency/index.md:6
msgid ""
"interrupt handlers, which run whenever the associated interrupt happens,"
msgstr ""
"ê´€ë ¨ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ ì‹¤í–‰ë˜ëŠ” ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬,"

#: src/concurrency/index.md:7
msgid ""
"various forms of multithreading, where your microprocessor regularly swaps "
"between parts of your program,"
msgstr ""
"ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œê°€ í”„ë¡œê·¸ë¨ì˜ ì—¬ëŸ¬ ë¶€ë¶„ ì‚¬ì´ë¥¼ ì •ê¸°ì ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ë‹¤ì–‘í•œ í˜•íƒœì˜ "
"ë©€í‹°ìŠ¤ë ˆë”©,"

#: src/concurrency/index.md:9
msgid ""
"and in some systems, multiple-core microprocessors, where each core can be "
"independently running a different part of your program at the same time."
msgstr ""
"ì¼ë¶€ ì‹œìŠ¤í…œì—ì„œëŠ” ê° ì½”ì–´ê°€ ë™ì‹œì— í”„ë¡œê·¸ë¨ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì„ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰í•  ìˆ˜ "
"ìˆëŠ” ë‹¤ì¤‘ ì½”ì–´ ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œ."

#: src/concurrency/index.md:12
msgid ""
"Since many embedded programs need to deal with interrupts, concurrency will "
"usually come up sooner or later, and it's also where many subtle and "
"difficult bugs can occur. Luckily, Rust provides a number of abstractions "
"and safety guarantees to help us write correct code."
msgstr ""
"ë§ì€ ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì´ ì¸í„°ëŸ½íŠ¸ë¥¼ ì²˜ë¦¬í•´ì•¼ í•˜ë¯€ë¡œ ë™ì‹œì„±ì€ ì¡°ë§Œê°„ ë°œìƒí•  "
"ê²ƒì´ë©°, ë¯¸ë¬˜í•˜ê³  ì–´ë ¤ìš´ ë²„ê·¸ê°€ ë§ì´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ê³³ì´ê¸°ë„ í•©ë‹ˆë‹¤. ë‹¤í–‰íˆ "
"RustëŠ” ì˜¬ë°”ë¥¸ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ì—¬ëŸ¬ ì¶”ìƒí™”ì™€ ì•ˆì „ ë³´ì¥ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/concurrency/index.md:17
msgid "No Concurrency"
msgstr "ë™ì‹œì„± ì—†ìŒ"

#: src/concurrency/index.md:19
msgid ""
"The simplest concurrency for an embedded program is no concurrency: your "
"software consists of a single main loop which just keeps running, and there "
"are no interrupts at all. Sometimes this is perfectly suited to the problem "
"at hand! Typically your loop will read some inputs, perform some processing, "
"and write some outputs."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì—ì„œ ê°€ì¥ ê°„ë‹¨í•œ ë™ì‹œì„±ì€ ë™ì‹œì„±ì´ ì—†ëŠ” ê²ƒì…ë‹ˆë‹¤. ì†Œí”„íŠ¸ì›¨ì–´ëŠ” "
"ë‹¨ì¼ ë©”ì¸ ë£¨í”„ë¡œ êµ¬ì„±ë˜ì–´ ê³„ì† ì‹¤í–‰ë˜ë©°, ì¸í„°ëŸ½íŠ¸ëŠ” ì „í˜€ ì—†ìŠµë‹ˆë‹¤. ë•Œë¡œëŠ” ì´ê²ƒì´ "
"ë‹¹ë©´í•œ ë¬¸ì œì— ì™„ë²½í•˜ê²Œ ì í•©í•©ë‹ˆë‹¤! ì¼ë°˜ì ìœ¼ë¡œ ë£¨í”„ëŠ” ì¼ë¶€ ì…ë ¥ì„ ì½ê³ , ì¼ë¶€ ì²˜ë¦¬ë¥¼ "
"ìˆ˜í–‰í•˜ë©°, ì¼ë¶€ ì¶œë ¥ì„ ì‘ì„±í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:37
msgid ""
"Since there's no concurrency, there's no need to worry about sharing data "
"between parts of your program or synchronising access to peripherals. If you "
"can get away with such a simple approach this can be a great solution."
msgstr ""
"ë™ì‹œì„±ì´ ì—†ìœ¼ë¯€ë¡œ í”„ë¡œê·¸ë¨ì˜ ì—¬ëŸ¬ ë¶€ë¶„ ê°„ì— ë°ì´í„°ë¥¼ ê³µìœ í•˜ê±°ë‚˜ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ "
"ì ‘ê·¼ì„ ë™ê¸°í™”í•˜ëŠ” ê²ƒì— ëŒ€í•´ ê±±ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ê°„ë‹¨í•œ ì ‘ê·¼ ë°©ì‹ìœ¼ë¡œ "
"í•´ê²°í•  ìˆ˜ ìˆë‹¤ë©´ í›Œë¥­í•œ í•´ê²°ì±…ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:41
msgid "Global Mutable Data"
msgstr "ì „ì—­ ê°€ë³€ ë°ì´í„°"

#: src/concurrency/index.md:43
msgid ""
"Unlike non-embedded Rust, we will not usually have the luxury of creating "
"heap allocations and passing references to that data into a newly-created "
"thread. Instead, our interrupt handlers might be called at any time and must "
"know how to access whatever shared memory we are using. At the lowest level, "
"this means we must have _statically allocated_ mutable memory, which both "
"the interrupt handler and the main code can refer to."
msgstr ""
"ë¹„ì„ë² ë””ë“œ Rustì™€ ë‹¬ë¦¬, ì¼ë°˜ì ìœ¼ë¡œ í™ í• ë‹¹ì„ ìƒì„±í•˜ê³  ìƒˆë¡œ ìƒì„±ëœ ìŠ¤ë ˆë“œì— í•´ë‹¹ "
"ë°ì´í„°ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ì „ë‹¬í•˜ëŠ” ì‚¬ì¹˜ë¥¼ ëˆ„ë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì‹ , ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ëŠ” "
"ì–¸ì œë“ ì§€ í˜¸ì¶œë  ìˆ˜ ìˆìœ¼ë©° ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ê³µìœ  ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ì•¼ "
"í•©ë‹ˆë‹¤. ê°€ì¥ ë‚®ì€ ìˆ˜ì¤€ì—ì„œëŠ” ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì™€ ë©”ì¸ ì½”ë“œ ëª¨ë‘ ì°¸ì¡°í•  ìˆ˜ ìˆëŠ” "
"_ì •ì ìœ¼ë¡œ í• ë‹¹ëœ_ ê°€ë³€ ë©”ëª¨ë¦¬ê°€ ìˆì–´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:50
msgid ""
"In Rust, such [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) variables are "
"always unsafe to read or write, because without taking special care, you "
"might trigger a race condition, where your access to the variable is "
"interrupted halfway through by an interrupt which also accesses that "
"variable."
msgstr ""
"Rustì—ì„œ ì´ëŸ¬í•œ [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) ë³€ìˆ˜ëŠ” ì½ê±°ë‚˜ "
"ì“°ê¸°ì—ëŠ” í•­ìƒ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŠ¹ë³„í•œ ì£¼ì˜ë¥¼ ê¸°ìš¸ì´ì§€ ì•Šìœ¼ë©´ ë³€ìˆ˜ì— ëŒ€í•œ "
"ì ‘ê·¼ì´ í•´ë‹¹ ë³€ìˆ˜ì— ì ‘ê·¼í•˜ëŠ” ì¸í„°ëŸ½íŠ¸ì— ì˜í•´ ì¤‘ê°„ì— ì¤‘ë‹¨ë˜ëŠ” ê²½ìŸ ì¡°ê±´ì„ ìœ ë°œí•  "
"ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/concurrency/index.md:57
msgid ""
"For an example of how this behaviour can cause subtle errors in your code, "
"consider an embedded program which counts rising edges of some input signal "
"in each one-second period (a frequency counter):"
msgstr ""
"ì´ëŸ¬í•œ ë™ì‘ì´ ì½”ë“œì—ì„œ ë¯¸ë¬˜í•œ ì˜¤ë¥˜ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆëŠ” ì˜ˆì‹œë¡œ, ë§¤ 1ì´ˆë§ˆë‹¤ ì¼ë¶€ "
"ì…ë ¥ ì‹ í˜¸ì˜ ìƒìŠ¹ ì—ì§€ë¥¼ ì„¸ëŠ” ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨(ì£¼íŒŒìˆ˜ ì¹´ìš´í„°)ì„ ê³ ë ¤í•´ ë³´ì‹­ì‹œì˜¤:"

#: src/concurrency/index.md:71
msgid "// DANGER - Not actually safe! Could cause data races.\n"
msgstr "// ìœ„í—˜ - ì‹¤ì œë¡œëŠ” ì•ˆì „í•˜ì§€ ì•ŠìŒ! ë°ì´í„° ê²½ìŸì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/concurrency/index.md:84
msgid ""
"Each second, the timer interrupt sets the counter back to 0. Meanwhile, the "
"main loop continually measures the signal, and incremements the counter when "
"it sees a change from low to high. We've had to use `unsafe` to access "
"`COUNTER`, as it's `static mut`, and that means we're promising the compiler "
"we won't cause any undefined behaviour. Can you spot the race condition? The "
"increment on `COUNTER` is _not_ guaranteed to be atomic â€” in fact, on most "
"embedded platforms, it will be split into a load, then the increment, then a "
"store. If the interrupt fired after the load but before the store, the reset "
"back to 0 would be ignored after the interrupt returns â€” and we would count "
"twice as many transitions for that period."
msgstr ""
"ë§¤ì´ˆ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ëŠ” ì¹´ìš´í„°ë¥¼ 0ìœ¼ë¡œ ì¬ì„¤ì •í•©ë‹ˆë‹¤. í•œí¸, ë©”ì¸ ë£¨í”„ëŠ” ì§€ì†ì ìœ¼ë¡œ "
"ì‹ í˜¸ë¥¼ ì¸¡ì •í•˜ê³  ë‚®ìŒì—ì„œ ë†’ìŒìœ¼ë¡œì˜ ë³€ê²½ì„ ê°ì§€í•˜ë©´ ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤. "
"`COUNTER`ëŠ” `static mut`ì´ë¯€ë¡œ `unsafe`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•´ì•¼ í–ˆìœ¼ë©°, ì´ëŠ” "
"ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ ìœ ë°œí•˜ì§€ ì•Šê² ë‹¤ê³  ì•½ì†í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. "
"ê²½ìŸ ì¡°ê±´ì„ ë°œê²¬í•  ìˆ˜ ìˆìŠµë‹ˆê¹Œ? `COUNTER`ì˜ ì¦ê°€ëŠ” ì›ìì ì´ë¼ê³  ë³´ì¥ë˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. ì‹¤ì œë¡œ ëŒ€ë¶€ë¶„ì˜ ì„ë² ë””ë“œ í”Œë«í¼ì—ì„œëŠ” ë¡œë“œ, ì¦ê°€, ì €ì¥ìœ¼ë¡œ "
"ë¶„í• ë©ë‹ˆë‹¤. ë¡œë“œ í›„ ì €ì¥ ì „ì— ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ë©´ ì¸í„°ëŸ½íŠ¸ê°€ ë°˜í™˜ëœ í›„ 0ìœ¼ë¡œ "
"ì¬ì„¤ì •í•˜ëŠ” ê²ƒì´ ë¬´ì‹œë˜ê³  í•´ë‹¹ ê¸°ê°„ ë™ì•ˆ ë‘ ë°° ë§ì€ ì „í™˜ì„ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/concurrency/index.md:95
msgid "Critical Sections"
msgstr "ì„ê³„ ì˜ì—­"

#: src/concurrency/index.md:97
msgid ""
"So, what can we do about data races? A simple approach is to use _critical "
"sections_, a context where interrupts are disabled. By wrapping the access "
"to `COUNTER` in `main` in a critical section, we can be sure the timer "
"interrupt will not fire until we're finished incrementing `COUNTER`:"
msgstr ""
"ê·¸ë ‡ë‹¤ë©´ ë°ì´í„° ê²½ìŸì— ëŒ€í•´ ë¬´ì—‡ì„ í•  ìˆ˜ ìˆì„ê¹Œìš”? ê°„ë‹¨í•œ ì ‘ê·¼ ë°©ì‹ì€ ì¸í„°ëŸ½íŠ¸ê°€ "
"ë¹„í™œì„±í™”ëœ ì»¨í…ìŠ¤íŠ¸ì¸ _ì„ê³„ ì˜ì—­_ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. `main`ì—ì„œ `COUNTER`ì— ëŒ€í•œ "
"ì ‘ê·¼ì„ ì„ê³„ ì˜ì—­ìœ¼ë¡œ ë˜í•‘í•˜ë©´ `COUNTER` ì¦ê°€ê°€ ëë‚  ë•Œê¹Œì§€ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ê°€ "
"ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/concurrency/index.md:112
msgid "// New critical section ensures synchronised access to COUNTER\n"
msgstr "// ìƒˆ ì„ê³„ ì˜ì—­ì€ COUNTERì— ëŒ€í•œ ë™ê¸°í™”ëœ ì ‘ê·¼ì„ ë³´ì¥í•©ë‹ˆë‹¤\n"

#: src/concurrency/index.md:127
msgid ""
"In this example, we use `cortex_m::interrupt::free`, but other platforms "
"will have similar mechanisms for executing code in a critical section. This "
"is also the same as disabling interrupts, running some code, and then re-"
"enabling interrupts."
msgstr ""
"ì´ ì˜ˆì—ì„œëŠ” `cortex_m::interrupt::free`ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ ë‹¤ë¥¸ í”Œë«í¼ì—ëŠ” ì„ê³„ ì˜ì—­ì—ì„œ "
"ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ìœ ì‚¬í•œ ë©”ì»¤ë‹ˆì¦˜ì´ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ë˜í•œ ì¸í„°ëŸ½íŠ¸ë¥¼ "
"ë¹„í™œì„±í™”í•˜ê³  ì¼ë¶€ ì½”ë“œë¥¼ ì‹¤í–‰í•œ ë‹¤ìŒ ì¸í„°ëŸ½íŠ¸ë¥¼ ë‹¤ì‹œ í™œì„±í™”í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:132
msgid ""
"Note we didn't need to put a critical section inside the timer interrupt, "
"for two reasons:"
msgstr ""
"ë‘ ê°€ì§€ ì´ìœ ë¡œ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ ë‚´ë¶€ì— ì„ê³„ ì˜ì—­ì„ ë„£ì„ í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤:"

#: src/concurrency/index.md:135
msgid ""
"Writing 0 to `COUNTER` can't be affected by a race since we don't read it"
msgstr "`COUNTER`ì— 0ì„ ì“°ëŠ” ê²ƒì€ ì½ì§€ ì•Šê¸° ë•Œë¬¸ì— ê²½ìŸì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:136
msgid "It will never be interrupted by the `main` thread anyway"
msgstr "ì–´ì¨Œë“  `main` ìŠ¤ë ˆë“œì— ì˜í•´ ì¤‘ë‹¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:138
msgid ""
"If `COUNTER` was being shared by multiple interrupt handlers that might "
"_preempt_ each other, then each one might require a critical section as well."
msgstr ""
"`COUNTER`ê°€ ì„œë¡œë¥¼ _ì„ ì _í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì— ì˜í•´ ê³µìœ ë˜ê³  ìˆì—ˆë‹¤ë©´ "
"ê°ê° ì„ê³„ ì˜ì—­ì´ í•„ìš”í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."
"`COUNTER`ê°€ ì„œë¡œë¥¼ _ì„ ì _í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì— ì˜í•´ ê³µìœ ë˜ê³  ìˆì—ˆë‹¤ë©´ "
"ê°ê° ì„ê³„ ì˜ì—­ì´ í•„ìš”í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:141
msgid ""
"This solves our immediate problem, but we're still left writing a lot of "
"unsafe code which we need to carefully reason about, and we might be using "
"critical sections needlessly. Since each critical section temporarily pauses "
"interrupt processing, there is an associated cost of some extra code size "
"and higher interrupt latency and jitter (interrupts may take longer to be "
"processed, and the time until they are processed will be more variable). "
"Whether this is a problem depends on your system, but in general, we'd like "
"to avoid it."
msgstr ""
"ì´ê²ƒì€ ì¦‰ê°ì ì¸ ë¬¸ì œë¥¼ í•´ê²°í•˜ì§€ë§Œ, ì—¬ì „íˆ ì‹ ì¤‘í•˜ê²Œ ì¶”ë¡ í•´ì•¼ í•˜ëŠ” ë§ì€ ì•ˆì „í•˜ì§€ "
"ì•Šì€ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•˜ë©°, ë¶ˆí•„ìš”í•˜ê²Œ ì„ê³„ ì˜ì—­ì„ ì‚¬ìš©í•˜ê³  ìˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ê° "
"ì„ê³„ ì˜ì—­ì€ ì¼ì‹œì ìœ¼ë¡œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ë¥¼ ì¼ì‹œ ì¤‘ì§€í•˜ë¯€ë¡œ ì¶”ê°€ ì½”ë“œ í¬ê¸° ë° ë” ë†’ì€ "
"ì¸í„°ëŸ½íŠ¸ ëŒ€ê¸° ì‹œê°„ ë° ì§€í„°(ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ì— ë” ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìœ¼ë©° ì²˜ë¦¬ë  ë•Œê¹Œì§€ì˜ "
"ì‹œê°„ì´ ë” ê°€ë³€ì ì„)ì™€ ê´€ë ¨ëœ ë¹„ìš©ì´ ë°œìƒí•©ë‹ˆë‹¤. ì´ê²ƒì´ ë¬¸ì œì¸ì§€ëŠ” ì‹œìŠ¤í…œì— ë”°ë¼ "
"ë‹¤ë¥´ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ í”¼í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."
"ì´ê²ƒì€ ì¦‰ê°ì ì¸ ë¬¸ì œë¥¼ í•´ê²°í•˜ì§€ë§Œ, ì—¬ì „íˆ ì‹ ì¤‘í•˜ê²Œ ì¶”ë¡ í•´ì•¼ í•˜ëŠ” ë§ì€ ì•ˆì „í•˜ì§€ "
"ì•Šì€ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•˜ë©°, ë¶ˆí•„ìš”í•˜ê²Œ ì„ê³„ ì˜ì—­ì„ ì‚¬ìš©í•˜ê³  ìˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ê° "
"ì„ê³„ ì˜ì—­ì€ ì¼ì‹œì ìœ¼ë¡œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ë¥¼ ì¼ì‹œ ì¤‘ì§€í•˜ë¯€ë¡œ ì¶”ê°€ ì½”ë“œ í¬ê¸° ë° ë” ë†’ì€ "
"ì¸í„°ëŸ½íŠ¸ ëŒ€ê¸° ì‹œê°„ ë° ì§€í„°(ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ì— ë” ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìœ¼ë©° ì²˜ë¦¬ë  ë•Œê¹Œì§€ì˜ "
"ì‹œê°„ì´ ë” ê°€ë³€ì ì„)ì™€ ê´€ë ¨ëœ ë¹„ìš©ì´ ë°œìƒí•©ë‹ˆë‹¤. ì´ê²ƒì´ ë¬¸ì œì¸ì§€ëŠ” ì‹œìŠ¤í…œì— ë”°ë¼ "
"ë‹¤ë¥´ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ í”¼í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:143
msgid ""
"It's worth noting that while a critical section guarantees no interrupts "
"will fire, it does not provide an exclusivity guarantee on multi-core "
"systems!  The other core could be happily accessing the same memory as your "
"core, even without interrupts. You will need stronger synchronisation "
"primitives if you are using multiple cores."
msgstr ""
"ì„ê³„ ì˜ì—­ì´ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ë³´ì¥í•˜ì§€ë§Œ ë‹¤ì¤‘ ì½”ì–´ ì‹œìŠ¤í…œì—ì„œëŠ” ë…ì ì„±ì„ "
"ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì€ ì£¼ëª©í•  ê°€ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤! ë‹¤ë¥¸ ì½”ì–´ëŠ” ì¸í„°ëŸ½íŠ¸ ì—†ì´ë„ ì½”ì–´ì™€ "
"ë™ì¼í•œ ë©”ëª¨ë¦¬ì— í–‰ë³µí•˜ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ì¤‘ ì½”ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë” ê°•ë ¥í•œ "
"ë™ê¸°í™” ê¸°ë³¸ ìš”ì†Œê°€ í•„ìš”í•©ë‹ˆë‹¤."
"ì„ê³„ ì˜ì—­ì´ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ë³´ì¥í•˜ì§€ë§Œ ë‹¤ì¤‘ ì½”ì–´ ì‹œìŠ¤í…œì—ì„œëŠ” ë…ì ì„±ì„ "
"ë³´ì¥í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì€ ì£¼ëª©í•  ê°€ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤! ë‹¤ë¥¸ ì½”ì–´ëŠ” ì¸í„°ëŸ½íŠ¸ ì—†ì´ë„ ì½”ì–´ì™€ "
"ë™ì¼í•œ ë©”ëª¨ë¦¬ì— í–‰ë³µí•˜ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ì¤‘ ì½”ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë” ê°•ë ¥í•œ "
"ë™ê¸°í™” ê¸°ë³¸ ìš”ì†Œê°€ í•„ìš”í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:149
msgid "Atomic Access"
msgstr "ì›ìì  ì ‘ê·¼"

#: src/concurrency/index.md:151
msgid ""
"On some platforms, special atomic instructions are available, which provide "
"guarantees about read-modify-write operations. Specifically for Cortex-M: "
"`thumbv6` (Cortex-M0, Cortex-M0+) only provide atomic load and store "
"instructions, while `thumbv7` (Cortex-M3 and above) provide full Compare and "
"Swap (CAS) instructions. These CAS instructions give an alternative to the "
"heavy-handed disabling of all interrupts: we can attempt the increment, it "
"will succeed most of the time, but if it was interrupted it will "
"automatically retry the entire increment operation. These atomic operations "
"are safe even across multiple cores."
msgstr ""
"ì¼ë¶€ í”Œë«í¼ì—ì„œëŠ” ì½ê¸°-ìˆ˜ì •-ì“°ê¸° ì‘ì—…ì— ëŒ€í•œ ë³´ì¥ì„ ì œê³µí•˜ëŠ” íŠ¹ìˆ˜ ì›ìì  "
"ëª…ë ¹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ Cortex-Mì˜ ê²½ìš°: `thumbv6`(Cortex-M0, Cortex-M0+)ëŠ” "
"ì›ìì  ë¡œë“œ ë° ì €ì¥ ëª…ë ¹ë§Œ ì œê³µí•˜ëŠ” ë°˜ë©´, `thumbv7`(Cortex-M3 ì´ìƒ)ì€ ì „ì²´ ë¹„êµ ë° "
"êµí™˜(CAS) ëª…ë ¹ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ CAS ëª…ë ¹ì€ ëª¨ë“  ì¸í„°ëŸ½íŠ¸ë¥¼ ë¹„í™œì„±í™”í•˜ëŠ” ê°•ë ¥í•œ "
"ë°©ë²•ì— ëŒ€í•œ ëŒ€ì•ˆì„ ì œê³µí•©ë‹ˆë‹¤. ì¦ê°€ë¥¼ ì‹œë„í•  ìˆ˜ ìˆìœ¼ë©° ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì„±ê³µí•˜ì§€ë§Œ "
"ì¤‘ë‹¨ëœ ê²½ìš° ì „ì²´ ì¦ê°€ ì‘ì—…ì„ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì›ìì  ì‘ì—…ì€ ë‹¤ì¤‘ "
"ì½”ì–´ì—ì„œë„ ì•ˆì „í•©ë‹ˆë‹¤."
"ì¼ë¶€ í”Œë«í¼ì—ì„œëŠ” ì½ê¸°-ìˆ˜ì •-ì“°ê¸° ì‘ì—…ì— ëŒ€í•œ ë³´ì¥ì„ ì œê³µí•˜ëŠ” íŠ¹ìˆ˜ ì›ìì  "
"ëª…ë ¹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ Cortex-Mì˜ ê²½ìš°: `thumbv6`(Cortex-M0, Cortex-M0+)ëŠ” "
"ì›ìì  ë¡œë“œ ë° ì €ì¥ ëª…ë ¹ë§Œ ì œê³µí•˜ëŠ” ë°˜ë©´, `thumbv7`(Cortex-M3 ì´ìƒ)ì€ ì „ì²´ ë¹„êµ ë° "
"êµí™˜(CAS) ëª…ë ¹ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ CAS ëª…ë ¹ì€ ëª¨ë“  ì¸í„°ëŸ½íŠ¸ë¥¼ ë¹„í™œì„±í™”í•˜ëŠ” ê°•ë ¥í•œ "
"ë°©ë²•ì— ëŒ€í•œ ëŒ€ì•ˆì„ ì œê³µí•©ë‹ˆë‹¤. ì¦ê°€ë¥¼ ì‹œë„í•  ìˆ˜ ìˆìœ¼ë©° ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì„±ê³µí•˜ì§€ë§Œ "
"ì¤‘ë‹¨ëœ ê²½ìš° ì „ì²´ ì¦ê°€ ì‘ì—…ì„ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì›ìì  ì‘ì—…ì€ ë‹¤ì¤‘ "
"ì½”ì–´ì—ì„œë„ ì•ˆì „í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:173
msgid "// Use `fetch_add` to atomically add 1 to COUNTER\n"
msgstr "// `fetch_add`ë¥¼ ì‚¬ìš©í•˜ì—¬ COUNTERì— ì›ìì ìœ¼ë¡œ 1ì„ ë”í•©ë‹ˆë‹¤\n"

#: src/concurrency/index.md:182
msgid "// Use `store` to write 0 directly to COUNTER\n"
msgstr "// `store`ë¥¼ ì‚¬ìš©í•˜ì—¬ COUNTERì— ì§ì ‘ 0ì„ ì”ë‹ˆë‹¤\n"

#: src/concurrency/index.md:187
msgid ""
"This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize` "
"type `COUNTER` can be safely modified from both the interrupt handler and "
"the main thread without disabling interrupts. When possible, this is a "
"better solution â€” but it may not be supported on your platform."
msgstr ""
"ì´ë²ˆì—ëŠ” `COUNTER`ê°€ ì•ˆì „í•œ `static` ë³€ìˆ˜ì…ë‹ˆë‹¤. `AtomicUsize` íƒ€ì… ë•ë¶„ì— `COUNTER`ëŠ” "
"ì¸í„°ëŸ½íŠ¸ë¥¼ ë¹„í™œì„±í™”í•˜ì§€ ì•Šê³ ë„ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì™€ ë©”ì¸ ìŠ¤ë ˆë“œ ëª¨ë‘ì—ì„œ ì•ˆì „í•˜ê²Œ "
"ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ëŠ¥í•˜ë©´ ì´ê²ƒì´ ë” ë‚˜ì€ í•´ê²°ì±…ì´ì§€ë§Œ í”Œë«í¼ì—ì„œ ì§€ì›ë˜ì§€ ì•Šì„ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."
"ì´ë²ˆì—ëŠ” `COUNTER`ê°€ ì•ˆì „í•œ `static` ë³€ìˆ˜ì…ë‹ˆë‹¤. `AtomicUsize` íƒ€ì… ë•ë¶„ì— `COUNTER`ëŠ” "
"ì¸í„°ëŸ½íŠ¸ë¥¼ ë¹„í™œì„±í™”í•˜ì§€ ì•Šê³ ë„ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì™€ ë©”ì¸ ìŠ¤ë ˆë“œ ëª¨ë‘ì—ì„œ ì•ˆì „í•˜ê²Œ "
"ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ëŠ¥í•˜ë©´ ì´ê²ƒì´ ë” ë‚˜ì€ í•´ê²°ì±…ì´ì§€ë§Œ í”Œë«í¼ì—ì„œ ì§€ì›ë˜ì§€ ì•Šì„ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:192
msgid ""
"A note on [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/"
"enum.Ordering.html): this affects how the compiler and hardware may reorder "
"instructions, and also has consequences on cache visibility. Assuming that "
"the target is a single core platform `Relaxed` is sufficient and the most "
"efficient choice in this particular case. Stricter ordering will cause the "
"compiler to emit memory barriers around the atomic operations; depending on "
"what you're using atomics for you may or may not need this! The precise "
"details of the atomic model are complicated and best described elsewhere."
msgstr ""
"[`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)ì— "
"ëŒ€í•œ ì°¸ê³  ì‚¬í•­: ì´ê²ƒì€ ì»´íŒŒì¼ëŸ¬ì™€ í•˜ë“œì›¨ì–´ê°€ ëª…ë ¹ì„ ì¬ì •ë ¬í•˜ëŠ” ë°©ì‹ì— ì˜í–¥ì„ "
"ë¯¸ì¹˜ë©° ìºì‹œ ê°€ì‹œì„±ì—ë„ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤. ëŒ€ìƒì´ ë‹¨ì¼ ì½”ì–´ í”Œë«í¼ì´ë¼ê³  ê°€ì •í•˜ë©´ ì´ "
"íŠ¹ì • ê²½ìš°ì— `Relaxed`ê°€ ì¶©ë¶„í•˜ê³  ê°€ì¥ íš¨ìœ¨ì ì¸ ì„ íƒì…ë‹ˆë‹¤. ë” ì—„ê²©í•œ ìˆœì„œëŠ” "
"ì»´íŒŒì¼ëŸ¬ê°€ ì›ìì  ì‘ì—… ì£¼ìœ„ì— ë©”ëª¨ë¦¬ ì¥ë²½ì„ ë‚´ë³´ë‚´ë„ë¡ í•©ë‹ˆë‹¤. ì›ìì  ì‘ì—…ì„ "
"ì‚¬ìš©í•˜ëŠ” ëª©ì ì— ë”°ë¼ ì´ê²ƒì´ í•„ìš”í•  ìˆ˜ë„ ìˆê³  í•„ìš”í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤! ì›ìì  "
"ëª¨ë¸ì˜ ì •í™•í•œ ì„¸ë¶€ ì‚¬í•­ì€ ë³µì¡í•˜ë©° ë‹¤ë¥¸ ê³³ì—ì„œ ê°€ì¥ ì˜ ì„¤ëª…ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
"[`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)ì— "
"ëŒ€í•œ ì°¸ê³  ì‚¬í•­: ì´ê²ƒì€ ì»´íŒŒì¼ëŸ¬ì™€ í•˜ë“œì›¨ì–´ê°€ ëª…ë ¹ì„ ì¬ì •ë ¬í•˜ëŠ” ë°©ì‹ì— ì˜í–¥ì„ "
"ë¯¸ì¹˜ë©° ìºì‹œ ê°€ì‹œì„±ì—ë„ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤. ëŒ€ìƒì´ ë‹¨ì¼ ì½”ì–´ í”Œë«í¼ì´ë¼ê³  ê°€ì •í•˜ë©´ ì´ "
"íŠ¹ì • ê²½ìš°ì— `Relaxed`ê°€ ì¶©ë¶„í•˜ê³  ê°€ì¥ íš¨ìœ¨ì ì¸ ì„ íƒì…ë‹ˆë‹¤. ë” ì—„ê²©í•œ ìˆœì„œëŠ” "
"ì»´íŒŒì¼ëŸ¬ê°€ ì›ìì  ì‘ì—… ì£¼ìœ„ì— ë©”ëª¨ë¦¬ ì¥ë²½ì„ ë‚´ë³´ë‚´ë„ë¡ í•©ë‹ˆë‹¤. ì›ìì  ì‘ì—…ì„ "
"ì‚¬ìš©í•˜ëŠ” ëª©ì ì— ë”°ë¼ ì´ê²ƒì´ í•„ìš”í•  ìˆ˜ë„ ìˆê³  í•„ìš”í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤! ì›ìì  "
"ëª¨ë¸ì˜ ì •í™•í•œ ì„¸ë¶€ ì‚¬í•­ì€ ë³µì¡í•˜ë©° ë‹¤ë¥¸ ê³³ì—ì„œ ê°€ì¥ ì˜ ì„¤ëª…ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:200
msgid ""
"For more details on atomics and ordering, see the [nomicon](https://doc.rust-"
"lang.org/nomicon/atomics.html)."
msgstr "ì›ìì„±ê³¼ ìˆœì„œì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [ë…¸ë¯¸ì½˜](https://doc.rust-lang.org/nomicon/atomics.html)ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/concurrency/index.md:206
msgid "Abstractions, Send, and Sync"
msgstr "ì¶”ìƒí™”, ë³´ë‚´ê¸° ë° ë™ê¸°í™”"

#: src/concurrency/index.md:208
msgid ""
"None of the above solutions are especially satisfactory. They require "
"`unsafe` blocks which must be very carefully checked and are not ergonomic. "
"Surely we can do better in Rust!"
msgstr ""
"ìœ„ì˜ í•´ê²°ì±… ì¤‘ ì–´ëŠ ê²ƒë„ íŠ¹ë³„íˆ ë§Œì¡±ìŠ¤ëŸ½ì§€ ì•ŠìŠµë‹ˆë‹¤. ë§¤ìš° ì‹ ì¤‘í•˜ê²Œ í™•ì¸í•´ì•¼ í•˜ëŠ” "
"`unsafe` ë¸”ë¡ì´ í•„ìš”í•˜ë©° ì¸ì²´ê³µí•™ì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¶„ëª…íˆ Rustì—ì„œëŠ” ë” ì˜í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤!"

#: src/concurrency/index.md:212
msgid ""
"We can abstract our counter into a safe interface which can be safely used "
"anywhere else in our code. For this example, we'll use the critical-section "
"counter, but you could do something very similar with atomics."
msgstr ""
"ì¹´ìš´í„°ë¥¼ ì½”ë“œì˜ ë‹¤ë¥¸ ê³³ì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì•ˆì „í•œ ì¸í„°í˜ì´ìŠ¤ë¡œ ì¶”ìƒí™”í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì˜ˆì—ì„œëŠ” ì„ê³„ ì˜ì—­ ì¹´ìš´í„°ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ ì›ìì  ì—°ì‚°ìœ¼ë¡œ ë§¤ìš° ìœ ì‚¬í•œ "
"ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:219
msgid ""
"// Our counter is just a wrapper around UnsafeCell<u32>, which is the heart\n"
"// of interior mutability in Rust. By using interior mutability, we can "
"have\n"
"// COUNTER be `static` instead of `static mut`, but still able to mutate\n"
"// its counter value.\n"
msgstr ""
"// ìš°ë¦¬ ì¹´ìš´í„°ëŠ” Rustì˜ ë‚´ë¶€ ê°€ë³€ì„±ì˜ í•µì‹¬ì¸ UnsafeCell<u32>ë¥¼ ê°ì‹¸ëŠ” ë˜í¼ì¼ "
"ë¿ì…ë‹ˆë‹¤. ë‚´ë¶€ ê°€ë³€ì„±ì„ ì‚¬ìš©í•˜ë©´ COUNTERë¥¼ 'static mut' ëŒ€ì‹  'static'ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ "
"ìˆì§€ë§Œ ì—¬ì „íˆ ì¹´ìš´í„° ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/concurrency/index.md:230
msgid ""
"// By requiring a CriticalSection be passed in, we know we must\n"
"        // be operating inside a CriticalSection, and so can confidently\n"
"        // use this unsafe block (required to call UnsafeCell::get).\n"
msgstr ""
"// CriticalSectionì„ ì „ë‹¬í•˜ë„ë¡ ìš”êµ¬í•¨ìœ¼ë¡œì¨, ìš°ë¦¬ëŠ” CriticalSection ë‚´ì—ì„œ "
"ì‘ë™í•´ì•¼ í•¨ì„ ì•Œê³  ìˆìœ¼ë¯€ë¡œ ì´ ì•ˆì „í•˜ì§€ ì•Šì€ ë¸”ë¡(UnsafeCell::getì„ í˜¸ì¶œí•˜ëŠ” ë° "
"í•„ìš”)ì„ ìì‹  ìˆê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/concurrency/index.md:240
msgid "// Required to allow static CSCounter. See explanation below.\n"
msgstr "// ì •ì  CSCounterë¥¼ í—ˆìš©í•˜ëŠ” ë° í•„ìš”í•©ë‹ˆë‹¤. ì•„ë˜ ì„¤ëª…ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤.\n"

#: src/concurrency/index.md:243
msgid ""
"// COUNTER is no longer `mut` as it uses interior mutability;\n"
"// therefore it also no longer requires unsafe blocks to access.\n"
msgstr ""
"// COUNTERëŠ” ë‚´ë¶€ ê°€ë³€ì„±ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ë” ì´ìƒ 'mut'ê°€ ì•„ë‹™ë‹ˆë‹¤. ë”°ë¼ì„œ ë” ì´ìƒ "
"ì ‘ê·¼í•˜ê¸° ìœ„í•´ ì•ˆì „í•˜ì§€ ì•Šì€ ë¸”ë¡ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"

#: src/concurrency/index.md:255
msgid "// No unsafe here!\n"
msgstr "// ì—¬ê¸°ì—ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ ê²ƒì´ ì—†ìŠµë‹ˆë‹¤!\n"

#: src/concurrency/index.md:264
msgid ""
"// We do need to enter a critical section here just to obtain a valid\n"
"    // cs token, even though we know no other interrupt could pre-empt\n"
"    // this one.\n"
msgstr ""
"// ë‹¤ë¥¸ ì¸í„°ëŸ½íŠ¸ê°€ ì´ ì¸í„°ëŸ½íŠ¸ë¥¼ ì„ ì í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ì•Œê³  ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  ìœ íš¨í•œ "
"cs í† í°ì„ ì–»ê¸° ìœ„í•´ ì—¬ê¸°ì— ì„ê³„ ì˜ì—­ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:269
msgid ""
"// We could use unsafe code to generate a fake CriticalSection if we\n"
"    // really wanted to, avoiding the overhead:\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"
msgstr ""
"// ì •ë§ ì›í•œë‹¤ë©´ ì˜¤ë²„í—¤ë“œë¥¼ í”¼í•˜ê¸° ìœ„í•´ ì•ˆì „í•˜ì§€ ì•Šì€ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ì§œ "
"CriticalSectionì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"

#: src/concurrency/index.md:275
msgid ""
"We've moved our `unsafe` code to inside our carefully-planned abstraction, "
"and now our application code does not contain any `unsafe` blocks."
msgstr ""
"ìš°ë¦¬ëŠ” `unsafe` ì½”ë“œë¥¼ ì‹ ì¤‘í•˜ê²Œ ê³„íšëœ ì¶”ìƒí™” ë‚´ë¶€ë¡œ ì˜®ê²¼ê³ , ì´ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ "
"ì½”ë“œì—ëŠ” `unsafe` ë¸”ë¡ì´ í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:278
msgid ""
"This design requires that the application pass a `CriticalSection` token in: "
"these tokens are only safely generated by `interrupt::free`, so by requiring "
"one be passed in, we ensure we are operating inside a critical section, "
"without having to actually do the lock ourselves. This guarantee is provided "
"statically by the compiler: there won't be any runtime overhead associated "
"with `cs`. If we had multiple counters, they could all be given the same "
"`cs`, without requiring multiple nested critical sections."
msgstr ""
"ì´ ì„¤ê³„ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì´ `CriticalSection` í† í°ì„ ì „ë‹¬í•˜ë„ë¡ ìš”êµ¬í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ "
"í† í°ì€ `interrupt::free`ì— ì˜í•´ì„œë§Œ ì•ˆì „í•˜ê²Œ ìƒì„±ë˜ë¯€ë¡œ, í•˜ë‚˜ë¥¼ ì „ë‹¬í•˜ë„ë¡ "
"ìš”êµ¬í•¨ìœ¼ë¡œì¨ ì‹¤ì œë¡œ ì ê¸ˆì„ ìˆ˜í–‰í•˜ì§€ ì•Šê³ ë„ ì„ê³„ ì˜ì—­ ë‚´ì—ì„œ ì‘ë™í•˜ê³  ìˆìŒì„ "
"ë³´ì¥í•©ë‹ˆë‹¤. ì´ ë³´ì¥ì€ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ì •ì ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤. `cs`ì™€ ê´€ë ¨ëœ ëŸ°íƒ€ì„ "
"ì˜¤ë²„í—¤ë“œëŠ” ì—†ìŠµë‹ˆë‹¤. ì—¬ëŸ¬ ì¹´ìš´í„°ê°€ ìˆëŠ” ê²½ìš° ì—¬ëŸ¬ ì¤‘ì²©ëœ ì„ê³„ ì˜ì—­ì„ ìš”êµ¬í•˜ì§€ "
"ì•Šê³ ë„ ëª¨ë‘ ë™ì¼í•œ `cs`ë¥¼ ë¶€ì—¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:286
msgid ""
"This also brings up an important topic for concurrency in Rust: the [`Send` "
"and `Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) traits. To "
"summarise the Rust book, a type is Send when it can safely be moved to "
"another thread, while it is Sync when it can be safely shared between "
"multiple threads. In an embedded context, we consider interrupts to be "
"executing in a separate thread to the application code, so variables "
"accessed by both an interrupt and the main code must be Sync."
msgstr ""
"ì´ê²ƒì€ ë˜í•œ Rustì˜ ë™ì‹œì„±ì— ëŒ€í•œ ì¤‘ìš”í•œ ì£¼ì œì¸ [`Send` ë° "
"`Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) íŠ¹ì„±ì„ ì œê¸°í•©ë‹ˆë‹¤. "
"Rust ì±…ì„ ìš”ì•½í•˜ë©´, íƒ€ì…ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì•ˆì „í•˜ê²Œ ì´ë™í•  ìˆ˜ ìˆì„ ë•Œ Sendì´ê³ , ì—¬ëŸ¬ "
"ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ ê³µìœ í•  ìˆ˜ ìˆì„ ë•Œ Syncì…ë‹ˆë‹¤. ì„ë² ë””ë“œ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ìš°ë¦¬ëŠ” "
"ì¸í„°ëŸ½íŠ¸ê°€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œì™€ ë³„ë„ì˜ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼í•˜ë¯€ë¡œ, "
"ì¸í„°ëŸ½íŠ¸ì™€ ë©”ì¸ ì½”ë“œ ëª¨ë‘ì—ì„œ ì ‘ê·¼í•˜ëŠ” ë³€ìˆ˜ëŠ” Syncì—¬ì•¼ í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:296
msgid ""
"For most types in Rust, both of these traits are automatically derived for "
"you by the compiler. However, because `CSCounter` contains an [`UnsafeCell`]"
"(https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html), it is not "
"Sync, and therefore we could not make a `static CSCounter`: `static` "
"variables _must_ be Sync, since they can be accessed by multiple threads."
msgstr ""
"Rustì˜ ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì— ëŒ€í•´ ì´ ë‘ íŠ¹ì„±ì€ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìë™ìœ¼ë¡œ íŒŒìƒë©ë‹ˆë‹¤. "
"ê·¸ëŸ¬ë‚˜ `CSCounter`ëŠ” [`UnsafeCell`](https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html)ì„ "
"í¬í•¨í•˜ë¯€ë¡œ Syncê°€ ì•„ë‹ˆë¯€ë¡œ `static CSCounter`ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `static` ë³€ìˆ˜ëŠ” "
"ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ _ë°˜ë“œì‹œ_ Syncì—¬ì•¼ í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:303
msgid ""
"To tell the compiler we have taken care that the `CSCounter` is in fact safe "
"to share between threads, we implement the Sync trait explicitly. As with "
"the previous use of critical sections, this is only safe on single-core "
"platforms: with multiple cores, you would need to go to greater lengths to "
"ensure safety."
msgstr ""
"`CSCounter`ê°€ ì‹¤ì œë¡œ ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ ê³µìœ ë˜ë„ë¡ ì²˜ë¦¬í–ˆìŒì„ ì»´íŒŒì¼ëŸ¬ì— "
"ì•Œë¦¬ê¸° ìœ„í•´ Sync íŠ¹ì„±ì„ ëª…ì‹œì ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ì „ì˜ ì„ê³„ ì˜ì—­ ì‚¬ìš©ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ "
"ì´ê²ƒì€ ë‹¨ì¼ ì½”ì–´ í”Œë«í¼ì—ì„œë§Œ ì•ˆì „í•©ë‹ˆë‹¤. ë‹¤ì¤‘ ì½”ì–´ì˜ ê²½ìš° ì•ˆì „ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ë” "
"ë§ì€ ë…¸ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:308
msgid "Mutexes"
msgstr "ë®¤í…ìŠ¤"

#: src/concurrency/index.md:310
msgid ""
"We've created a useful abstraction specific to our counter problem, but "
"there are many common abstractions used for concurrency."
msgstr ""
"ì¹´ìš´í„° ë¬¸ì œì— íŠ¹ì •í•œ ìœ ìš©í•œ ì¶”ìƒí™”ë¥¼ ë§Œë“¤ì—ˆì§€ë§Œ ë™ì‹œì„±ì— ì‚¬ìš©ë˜ëŠ” ì¼ë°˜ì ì¸ "
"ì¶”ìƒí™”ê°€ ë§ì´ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:313
msgid ""
"One such _synchronisation primitive_ is a mutex, short for mutual exclusion. "
"A thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds "
"immediately, or blocks waiting for the lock to be acquired, or returns an "
"error that the mutex could not be locked. While that thread holds the lock, "
"it is granted access to the protected data. When the thread is done, it "
"_unlocks_ (or _releases_) the mutex, allowing another thread to lock it. In "
"Rust, we would usually implement the unlock using the [`Drop`](https://"
"doc.rust-lang.org/core/ops/trait.Drop.html) trait to ensure it is always "
"released when the mutex goes out of scope."
msgstr ""
"ê·¸ëŸ¬í•œ _ë™ê¸°í™” ê¸°ë³¸ ìš”ì†Œ_ ì¤‘ í•˜ë‚˜ëŠ” ìƒí˜¸ ë°°ì œë¥¼ ì˜ë¯¸í•˜ëŠ” ë®¤í…ìŠ¤ì…ë‹ˆë‹¤. ìŠ¤ë ˆë“œëŠ” "
"ë®¤í…ìŠ¤ë¥¼ _ì ê·¸ë ¤ê³ _ (ë˜ëŠ” _íšë“í•˜ë ¤ê³ _) ì‹œë„í•  ìˆ˜ ìˆìœ¼ë©°, ì¦‰ì‹œ ì„±ê³µí•˜ê±°ë‚˜ ì ê¸ˆì´ "
"íšë“ë  ë•Œê¹Œì§€ ì°¨ë‹¨ë˜ê±°ë‚˜ ë®¤í…ìŠ¤ë¥¼ ì ê¸€ ìˆ˜ ì—†ë‹¤ëŠ” ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. í•´ë‹¹ ìŠ¤ë ˆë“œê°€ "
"ì ê¸ˆì„ ë³´ìœ í•˜ëŠ” ë™ì•ˆ ë³´í˜¸ëœ ë°ì´í„°ì— ëŒ€í•œ ì ‘ê·¼ì´ í—ˆìš©ë©ë‹ˆë‹¤. ìŠ¤ë ˆë“œê°€ ì™„ë£Œë˜ë©´ "
"ë®¤í…ìŠ¤ë¥¼ _ì ê¸ˆ í•´ì œ_ (ë˜ëŠ” _í•´ì œ_)í•˜ì—¬ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ê¸€ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. Rustì—ì„œëŠ” "
"ì¼ë°˜ì ìœ¼ë¡œ ë®¤í…ìŠ¤ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ë•Œ í•­ìƒ í•´ì œë˜ë„ë¡ [`Drop`](https://doc.rust-lang.org/core/ops/trait.Drop.html) "
"íŠ¹ì„±ì„ ì‚¬ìš©í•˜ì—¬ ì ê¸ˆ í•´ì œë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:325
msgid ""
"Using a mutex with interrupt handlers can be tricky: it is not normally "
"acceptable for the interrupt handler to block, and it would be especially "
"disastrous for it to block waiting for the main thread to release a lock, "
"since we would then _deadlock_ (the main thread will never release the lock "
"because execution stays in the interrupt handler). Deadlocking is not "
"considered unsafe: it is possible even in safe Rust."
msgstr ""
"ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì™€ í•¨ê»˜ ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ê¹Œë‹¤ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¸í„°ëŸ½íŠ¸ "
"í•¸ë“¤ëŸ¬ê°€ ì°¨ë‹¨ë˜ëŠ” ê²ƒì€ ì¼ë°˜ì ìœ¼ë¡œ í—ˆìš©ë˜ì§€ ì•Šìœ¼ë©°, ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì ê¸ˆì„ í•´ì œí•˜ê¸°ë¥¼ "
"ê¸°ë‹¤ë¦¬ë©° ì°¨ë‹¨ë˜ëŠ” ê²ƒì€ íŠ¹íˆ ì¬ì•™ì ì¼ ê²ƒì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ _êµì°© ìƒíƒœ_ê°€ ë°œìƒí•˜ê¸° "
"ë•Œë¬¸ì…ë‹ˆë‹¤(ì‹¤í–‰ì´ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì— ë¨¸ë¬¼ê¸° ë•Œë¬¸ì— ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì ê¸ˆì„ ì ˆëŒ€ "
"í•´ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤). êµì°© ìƒíƒœëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ ê²ƒìœ¼ë¡œ ê°„ì£¼ë˜ì§€ ì•Šìœ¼ë©°, ì•ˆì „í•œ "
"Rustì—ì„œë„ ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:332
msgid ""
"To avoid this behaviour entirely, we could implement a mutex which requires "
"a critical section to lock, just like our counter example. So long as the "
"critical section must last as long as the lock, we can be sure we have "
"exclusive access to the wrapped variable without even needing to track the "
"lock/unlock state of the mutex."
msgstr ""
"ì´ëŸ¬í•œ ë™ì‘ì„ ì™„ì „íˆ í”¼í•˜ê¸° ìœ„í•´, ì¹´ìš´í„° ì˜ˆì œì™€ ê°™ì´ ì ê·¸ê¸° ìœ„í•´ ì„ê³„ ì˜ì—­ì´ "
"í•„ìš”í•œ ë®¤í…ìŠ¤ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„ê³„ ì˜ì—­ì´ ì ê¸ˆë§Œí¼ ì˜¤ë˜ ì§€ì†ë˜ì–´ì•¼ í•˜ëŠ” í•œ, "
"ë®¤í…ìŠ¤ì˜ ì ê¸ˆ/ì ê¸ˆ í•´ì œ ìƒíƒœë¥¼ ì¶”ì í•  í•„ìš” ì—†ì´ ë˜í•‘ëœ ë³€ìˆ˜ì— ëŒ€í•œ ë…ì ì ì¸ ì ‘ê·¼ "
"ê¶Œí•œì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:338
msgid ""
"This is in fact done for us in the `cortex_m` crate! We could have written "
"our counter using it:"
msgstr ""
"ì‚¬ì‹¤ ì´ê²ƒì€ `cortex_m` í¬ë ˆì´íŠ¸ì—ì„œ ìš°ë¦¬ë¥¼ ìœ„í•´ ìˆ˜í–‰ë©ë‹ˆë‹¤! ìš°ë¦¬ëŠ” ê·¸ê²ƒì„ ì‚¬ìš©í•˜ì—¬ "
"ì¹´ìš´í„°ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤:"

#: src/concurrency/index.md:363
msgid ""
"// We still need to enter a critical section here to satisfy the Mutex.\n"
msgstr "// ë®¤í…ìŠ¤ë¥¼ ë§Œì¡±ì‹œí‚¤ê¸° ìœ„í•´ ì—¬ê¸°ì— ì„ê³„ ì˜ì—­ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:368
msgid ""
"We're now using [`Cell`](https://doc.rust-lang.org/core/cell/"
"struct.Cell.html), which along with its sibling `RefCell` is used to provide "
"safe interior mutability. We've already seen `UnsafeCell` which is the "
"bottom layer of interior mutability in Rust: it allows you to obtain "
"multiple mutable references to its value, but only with unsafe code. A "
"`Cell` is like an `UnsafeCell` but it provides a safe interface: it only "
"permits taking a copy of the current value or replacing it, not taking a "
"reference, and since it is not Sync, it cannot be shared between threads. "
"These constraints mean it's safe to use, but we couldn't use it directly in "
"a `static` variable as a `static` must be Sync."
msgstr ""
"ì´ì œ ìš°ë¦¬ëŠ” [`Cell`](https://doc.rust-lang.org/core/cell/struct.Cell.html)ì„ "
"ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ í˜•ì œì¸ `RefCell`ê³¼ í•¨ê»˜ ì•ˆì „í•œ ë‚´ë¶€ ê°€ë³€ì„±ì„ ì œê³µí•˜ëŠ” ë° "
"ì‚¬ìš©ë©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ë¯¸ Rustì˜ ë‚´ë¶€ ê°€ë³€ì„±ì˜ ê°€ì¥ ë‚®ì€ ê³„ì¸µì¸ `UnsafeCell`ì„ "
"ë³´ì•˜ìŠµë‹ˆë‹¤. ì´ê²ƒì€ ê°’ì— ëŒ€í•œ ì—¬ëŸ¬ ê°œì˜ ê°€ë³€ ì°¸ì¡°ë¥¼ ì–»ì„ ìˆ˜ ìˆì§€ë§Œ ì•ˆì „í•˜ì§€ ì•Šì€ "
"ì½”ë“œë¡œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤. `Cell`ì€ `UnsafeCell`ê³¼ ê°™ì§€ë§Œ ì•ˆì „í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ "
"ì œê³µí•©ë‹ˆë‹¤. í˜„ì¬ ê°’ì˜ ë³µì‚¬ë³¸ì„ ê°€ì ¸ì˜¤ê±°ë‚˜ êµì²´í•˜ëŠ” ê²ƒë§Œ í—ˆìš©í•˜ê³  ì°¸ì¡°ë¥¼ ê°€ì ¸ì˜¤ëŠ” "
"ê²ƒì€ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©°, Syncê°€ ì•„ë‹ˆë¯€ë¡œ ìŠ¤ë ˆë“œ ê°„ì— ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ì œì•½ "
"ì¡°ê±´ì€ ì‚¬ìš©í•˜ê¸°ì— ì•ˆì „í•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ì§€ë§Œ, `static`ì€ Syncì—¬ì•¼ í•˜ë¯€ë¡œ `static` "
"ë³€ìˆ˜ì—ì„œ ì§ì ‘ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:380
msgid ""
"So why does the example above work? The `Mutex<T>` implements Sync for any "
"`T` which is Send â€” such as a `Cell`. It can do this safely because it only "
"gives access to its contents during a critical section. We're therefore able "
"to get a safe counter with no unsafe code at all!"
msgstr ""
"ê·¸ë ‡ë‹¤ë©´ ìœ„ì˜ ì˜ˆì œëŠ” ì™œ ì‘ë™í• ê¹Œìš”? `Mutex<T>`ëŠ” `Cell`ê³¼ ê°™ì´ Sendì¸ ëª¨ë“  `T`ì— "
"ëŒ€í•´ Syncë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì„ê³„ ì˜ì—­ ë™ì•ˆì—ë§Œ ë‚´ìš©ì— ëŒ€í•œ ì ‘ê·¼ì„ í—ˆìš©í•˜ê¸° ë•Œë¬¸ì— "
"ì•ˆì „í•˜ê²Œ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ ì½”ë“œ ì—†ì´ ì•ˆì „í•œ "
"ì¹´ìš´í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/concurrency/index.md:385
msgid ""
"This is great for simple types like the `u32` of our counter, but what about "
"more complex types which are not Copy? An extremely common example in an "
"embedded context is a peripheral struct, which generally is not Copy. For "
"that, we can turn to `RefCell`."
msgstr ""
"ì´ê²ƒì€ ìš°ë¦¬ ì¹´ìš´í„°ì˜ `u32`ì™€ ê°™ì€ ê°„ë‹¨í•œ íƒ€ì…ì—ëŠ” ì¢‹ì§€ë§Œ, ë³µì‚¬ê°€ ì•„ë‹Œ ë” ë³µì¡í•œ "
"íƒ€ì…ì€ ì–´ë–»ìŠµë‹ˆê¹Œ? ì„ë² ë””ë“œ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ë§¤ìš° ì¼ë°˜ì ì¸ ì˜ˆëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë³µì‚¬ê°€ ì•„ë‹Œ "
"ì£¼ë³€ ì¥ì¹˜ êµ¬ì¡°ì²´ì…ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ `RefCell`ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:390
msgid "Sharing Peripherals"
msgstr "ì£¼ë³€ ì¥ì¹˜ ê³µìœ "

#: src/concurrency/index.md:392
msgid ""
"Device crates generated using `svd2rust` and similar abstractions provide "
"safe access to peripherals by enforcing that only one instance of the "
"peripheral struct can exist at a time. This ensures safety, but makes it "
"difficult to access a peripheral from both the main thread and an interrupt "
"handler."
msgstr ""
"`svd2rust` ë° ìœ ì‚¬í•œ ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±ëœ ì¥ì¹˜ í¬ë ˆì´íŠ¸ëŠ” í•œ ë²ˆì— ì£¼ë³€ ì¥ì¹˜ "
"êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ë„ë¡ ê°•ì œí•˜ì—¬ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì•ˆì „í•œ ì ‘ê·¼ì„ "
"ì œê³µí•©ë‹ˆë‹¤. ì´ê²ƒì€ ì•ˆì „ì„ ë³´ì¥í•˜ì§€ë§Œ ë©”ì¸ ìŠ¤ë ˆë“œì™€ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ ëª¨ë‘ì—ì„œ ì£¼ë³€ "
"ì¥ì¹˜ì— ì ‘ê·¼í•˜ê¸° ì–´ë µê²Œ ë§Œë“­ë‹ˆë‹¤."

#: src/concurrency/index.md:398
msgid ""
"To safely share peripheral access, we can use the `Mutex` we saw before. "
"We'll also need to use [`RefCell`](https://doc.rust-lang.org/core/cell/"
"struct.RefCell.html), which uses a runtime check to ensure only one "
"reference to a peripheral is given out at a time. This has more overhead "
"than the plain `Cell`, but since we are giving out references rather than "
"copies, we must be sure only one exists at a time."
msgstr ""
"ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ì„ ì•ˆì „í•˜ê²Œ ê³µìœ í•˜ê¸° ìœ„í•´ ì´ì „ì— ë³¸ `Mutex`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ë˜í•œ í•œ ë²ˆì— ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì°¸ì¡°ê°€ í•˜ë‚˜ë§Œ ì œê³µë˜ë„ë¡ ëŸ°íƒ€ì„ ê²€ì‚¬ë¥¼ ì‚¬ìš©í•˜ëŠ” "
"[`RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html)ì„ ì‚¬ìš©í•´ì•¼ "
"í•©ë‹ˆë‹¤. ì´ê²ƒì€ ì¼ë°˜ `Cell`ë³´ë‹¤ ì˜¤ë²„í—¤ë“œê°€ ë” ë§ì§€ë§Œ, ë³µì‚¬ë³¸ì´ ì•„ë‹Œ ì°¸ì¡°ë¥¼ "
"ì œê³µí•˜ë¯€ë¡œ í•œ ë²ˆì— í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:406
msgid ""
"Finally, we'll also have to account for somehow moving the peripheral into "
"the shared variable after it has been initialised in the main code. To do "
"this we can use the `Option` type, initialised to `None` and later set to "
"the instance of the peripheral."
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, ë©”ì¸ ì½”ë“œì—ì„œ ì´ˆê¸°í™”ëœ í›„ ì£¼ë³€ ì¥ì¹˜ë¥¼ ê³µìœ  ë³€ìˆ˜ë¡œ ì´ë™í•˜ëŠ” ë°©ë²•ì„ "
"ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ `Option` íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, `None`ìœ¼ë¡œ ì´ˆê¸°í™”í•œ ë‹¤ìŒ "
"ë‚˜ì¤‘ì— ì£¼ë³€ ì¥ì¹˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì„¤ì •í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:421
msgid ""
"// Obtain the peripheral singletons and configure it.\n"
"    // This example is from an svd2rust-generated crate, but\n"
"    // most embedded device crates will be similar.\n"
msgstr ""
"// ì£¼ë³€ ì¥ì¹˜ ì‹±ê¸€í†¤ì„ ì–»ê³  êµ¬ì„±í•©ë‹ˆë‹¤.\n"
"    // ì´ ì˜ˆì œëŠ” svd2rustì—ì„œ ìƒì„±ëœ í¬ë ˆì´íŠ¸ì—ì„œ ê°€ì ¸ì™”ì§€ë§Œ\n"
"    // ëŒ€ë¶€ë¶„ì˜ ì„ë² ë””ë“œ ì¥ì¹˜ í¬ë ˆì´íŠ¸ëŠ” ìœ ì‚¬í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:427
msgid ""
"// Some sort of configuration function.\n"
"    // Assume it sets PA0 to an input and PA1 to an output.\n"
msgstr ""

#: src/concurrency/index.md:431
msgid "// Store the GPIOA in the mutex, moving it.\n"
msgstr "// GPIOAë¥¼ ë®¤í…ìŠ¤ì— ì €ì¥í•˜ê³  ì´ë™í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:433
msgid ""
"// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to\n"
"    // access it via the mutex.\n"
msgstr ""
"// ë” ì´ìƒ 'gpioa' ë˜ëŠ” 'dp.GPIOA'ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìœ¼ë©°, ëŒ€ì‹  ë®¤í…ìŠ¤ë¥¼ í†µí•´ ì ‘ê·¼í•´ì•¼ "
"í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:436
msgid ""
"// Be careful to enable the interrupt only after setting MY_GPIO:\n"
"    // otherwise the interrupt might fire while it still contains None,\n"
"    // and as-written (with `unwrap()`), it would panic.\n"
msgstr ""
"// MY_GPIOë¥¼ ì„¤ì •í•œ í›„ì—ë§Œ ì¸í„°ëŸ½íŠ¸ë¥¼ í™œì„±í™”í•˜ë„ë¡ ì£¼ì˜í•˜ì‹­ì‹œì˜¤.\n"
"    // ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì¸í„°ëŸ½íŠ¸ê°€ ì—¬ì „íˆ Noneì„ í¬í•¨í•˜ëŠ” ë™ì•ˆ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë©°,\n"
"    // ì‘ì„±ëœ ëŒ€ë¡œ('unwrap()' í¬í•¨) íŒ¨ë‹‰ì´ ë°œìƒí•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:442
msgid "// We'll now read state as a digital input, via the mutex\n"
msgstr "// ì´ì œ ë®¤í…ìŠ¤ë¥¼ í†µí•´ ìƒíƒœë¥¼ ë””ì§€í„¸ ì…ë ¥ìœ¼ë¡œ ì½ìŠµë‹ˆë‹¤\n"

#: src/concurrency/index.md:449
msgid "// Set PA1 high if we've seen a rising edge on PA0.\n"
msgstr "// PA0ì—ì„œ ìƒìŠ¹ ì—ì§€ë¥¼ ê°ì§€í•˜ë©´ PA1ì„ ë†’ê²Œ ì„¤ì •í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:461
msgid "// This time in the interrupt we'll just clear PA0.\n"
msgstr "// ì´ë²ˆì—ëŠ” ì¸í„°ëŸ½íŠ¸ì—ì„œ PA0ì„ ì§€ìš°ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:463
msgid ""
"// We can use `unwrap()` because we know the interrupt wasn't enabled\n"
"        // until after MY_GPIO was set; otherwise we should handle the "
"potential\n"
"        // for a None value.\n"
msgstr ""
"// ì¸í„°ëŸ½íŠ¸ê°€ MY_GPIOê°€ ì„¤ì •ëœ í›„ì— í™œì„±í™”ë˜ì§€ ì•Šì•˜ë‹¤ëŠ” ê²ƒì„ ì•Œê³  ìˆìœ¼ë¯€ë¡œ `unwrap()`ì„ "
"ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ None ê°’ì˜ ê°€ëŠ¥ì„±ì„ ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:472
msgid "That's quite a lot to take in, so let's break down the important lines."
msgstr "ìƒë‹¹íˆ ë§ì€ ë‚´ìš©ì´ë¯€ë¡œ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ë¶„ì„í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:479
msgid ""
"Our shared variable is now a `Mutex` around a `RefCell` which contains an "
"`Option`. The `Mutex` ensures we only have access during a critical section, "
"and therefore makes the variable Sync, even though a plain `RefCell` would "
"not be Sync. The `RefCell` gives us interior mutability with references, "
"which we'll need to use our `GPIOA`. The `Option` lets us initialise this "
"variable to something empty, and only later actually move the variable in. "
"We cannot access the peripheral singleton statically, only at runtime, so "
"this is required."
msgstr ""
"ì´ì œ ê³µìœ  ë³€ìˆ˜ëŠ” `Option`ì„ í¬í•¨í•˜ëŠ” `RefCell` ì£¼ìœ„ì˜ `Mutex`ì…ë‹ˆë‹¤. `Mutex`ëŠ” "
"ì„ê³„ ì˜ì—­ ë™ì•ˆì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ë³´ì¥í•˜ë¯€ë¡œ ì¼ë°˜ `RefCell`ì´ Syncê°€ ì•„ë‹ˆë”ë¼ë„ "
"ë³€ìˆ˜ë¥¼ Syncë¡œ ë§Œë“­ë‹ˆë‹¤. `RefCell`ì€ `GPIOA`ë¥¼ ì‚¬ìš©í•˜ëŠ” ë° í•„ìš”í•œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ì—¬ "
"ë‚´ë¶€ ê°€ë³€ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. `Option`ì„ ì‚¬ìš©í•˜ë©´ ì´ ë³€ìˆ˜ë¥¼ ë¹ˆ ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  "
"ë‚˜ì¤‘ì— ì‹¤ì œë¡œ ë³€ìˆ˜ë¥¼ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ë³€ ì¥ì¹˜ ì‹±ê¸€í†¤ì— ì •ì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ "
"ì—†ìœ¼ë©° ëŸ°íƒ€ì„ì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì´ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:492
msgid ""
"Inside a critical section we can call `borrow()` on the mutex, which gives "
"us a reference to the `RefCell`. We then call `replace()` to move our new "
"value into the `RefCell`."
msgstr ""
"ì„ê³„ ì˜ì—­ ë‚´ì—ì„œ ë®¤í…ìŠ¤ì— ëŒ€í•´ `borrow()`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” `RefCell`ì— ëŒ€í•œ "
"ì°¸ì¡°ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ `replace()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìƒˆ ê°’ì„ `RefCell`ë¡œ ì´ë™í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:503
msgid ""
"Finally, we use `MY_GPIO` in a safe and concurrent fashion. The critical "
"section prevents the interrupt firing as usual, and lets us borrow the "
"mutex.  The `RefCell` then gives us an `&Option<GPIOA>`, and tracks how long "
"it remains borrowed - once that reference goes out of scope, the `RefCell` "
"will be updated to indicate it is no longer borrowed."
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, `MY_GPIO`ë¥¼ ì•ˆì „í•˜ê³  ë™ì‹œì ì¸ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì„ê³„ ì˜ì—­ì€ í‰ì†Œì™€ "
"ê°™ì´ ì¸í„°ëŸ½íŠ¸ ë°œìƒì„ ë°©ì§€í•˜ê³  ë®¤í…ìŠ¤ë¥¼ ë¹Œë¦´ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ `RefCell`ì€ "
"`&Option<GPIOA>`ë¥¼ ì œê³µí•˜ê³  ë¹Œë¦° ìƒíƒœë¡œ ìœ ì§€ë˜ëŠ” ê¸°ê°„ì„ ì¶”ì í•©ë‹ˆë‹¤. í•´ë‹¹ ì°¸ì¡°ê°€ "
"ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ `RefCell`ì€ ë” ì´ìƒ ë¹Œë¦¬ì§€ ì•Šì•˜ìŒì„ ë‚˜íƒ€ë‚´ë„ë¡ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤."

#: src/concurrency/index.md:509
msgid ""
"Since we can't move the `GPIOA` out of the `&Option`, we need to convert it "
"to an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to "
"obtain the `&GPIOA` which lets us modify the peripheral."
msgstr ""
"`GPIOA`ë¥¼ `&Option` ë°–ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `as_ref()`ë¥¼ ì‚¬ìš©í•˜ì—¬ `&Option<&GPIOA>`ë¡œ "
"ë³€í™˜í•´ì•¼ í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ `unwrap()`í•˜ì—¬ ì£¼ë³€ ì¥ì¹˜ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ” `&GPIOA`ë¥¼ "
"ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:513
msgid ""
"If we need a mutable reference to a shared resource, then `borrow_mut` and "
"`deref_mut` should be used instead. The following code shows an example "
"using the TIM2 timer."
msgstr ""
"ê³µìœ  ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ê°€ë³€ ì°¸ì¡°ê°€ í•„ìš”í•œ ê²½ìš° `borrow_mut` ë° `deref_mut`ë¥¼ ëŒ€ì‹  "
"ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œëŠ” TIM2 íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/concurrency/index.md:531
msgid ""
"// Some sort of timer configuration function.\n"
"    // Assume it configures the TIM2 timer, its NVIC interrupt,\n"
"    // and finally starts the timer.\n"
msgstr ""
"// ì–´ë–¤ ì¢…ë¥˜ì˜ íƒ€ì´ë¨¸ êµ¬ì„± í•¨ìˆ˜ì…ë‹ˆë‹¤.\n"
"    // TIM2 íƒ€ì´ë¨¸, í•´ë‹¹ NVIC ì¸í„°ëŸ½íŠ¸ë¥¼ êµ¬ì„±í•˜ê³ \n"
"    // ë§ˆì§€ë§‰ìœ¼ë¡œ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•œë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.\n"
"// ì–´ë–¤ ì¢…ë¥˜ì˜ íƒ€ì´ë¨¸ êµ¬ì„± í•¨ìˆ˜ì…ë‹ˆë‹¤.\n"
"    // TIM2 íƒ€ì´ë¨¸, í•´ë‹¹ NVIC ì¸í„°ëŸ½íŠ¸ë¥¼ êµ¬ì„±í•˜ê³ \n"
"    // ë§ˆì§€ë§‰ìœ¼ë¡œ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•œë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.\n"

#: src/concurrency/index.md:556
msgid ""
"Whew! This is safe, but it is also a little unwieldy. Is there anything else "
"we can do?"
msgstr "íœ´! ì´ê²ƒì€ ì•ˆì „í•˜ì§€ë§Œ ë‹¤ë£¨ê¸°ì—ëŠ” ì•½ê°„ ë²ˆê±°ë¡­ìŠµë‹ˆë‹¤. ìš°ë¦¬ê°€ í•  ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ì¼ì´ ìˆì„ê¹Œìš”?"

#: src/concurrency/index.md:559
msgid "RTIC"
msgstr "RTIC"

#: src/concurrency/index.md:561
msgid ""
"One alternative is the [RTIC framework](https://github.com/rtic-rs/cortex-m-"
"rtic), short for Real Time Interrupt-driven Concurrency. It enforces static "
"priorities and tracks accesses to `static mut` variables (\"resources\") to "
"statically ensure that shared resources are always accessed safely, without "
"requiring the overhead of always entering critical sections and using "
"reference counting (as in `RefCell`). This has a number of advantages such "
"as guaranteeing no deadlocks and giving extremely low time and memory "
"overhead."
msgstr ""
"RTIC í”„ë ˆì„ì›Œí¬(ì‹¤ì‹œê°„ ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ë™ì‹œì„±ì˜ ì•½ì)ëŠ” í•œ ê°€ì§€ ëŒ€ì•ˆì…ë‹ˆë‹¤. ì •ì  "
"ìš°ì„ ìˆœìœ„ë¥¼ ì ìš©í•˜ê³  'static mut' ë³€ìˆ˜(\"ë¦¬ì†ŒìŠ¤\")ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ë¥¼ ì¶”ì í•˜ì—¬ ê³µìœ  "
"ë¦¬ì†ŒìŠ¤ì— í•­ìƒ ì•ˆì „í•˜ê²Œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ ì •ì ìœ¼ë¡œ ë³´ì¥í•˜ë©°, í•­ìƒ ì„ê³„ ì˜ì—­ì— "
"ë“¤ì–´ê°€ê³  ì°¸ì¡° ê³„ì‚°(ì˜ˆ: 'RefCell')ì„ ì‚¬ìš©í•˜ëŠ” ì˜¤ë²„í—¤ë“œê°€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ëŠ” "
"êµì°© ìƒíƒœê°€ ì—†ìŒì„ ë³´ì¥í•˜ê³  ë§¤ìš° ë‚®ì€ ì‹œê°„ ë° ë©”ëª¨ë¦¬ ì˜¤ë²„í—¤ë“œë¥¼ ì œê³µí•˜ëŠ” ë“± ì—¬ëŸ¬ "
"ê°€ì§€ ì´ì ì´ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/index.md:570
msgid ""
"The framework also includes other features like message passing, which "
"reduces the need for explicit shared state, and the ability to schedule "
"tasks to run at a given time, which can be used to implement periodic tasks. "
"Check out [the documentation](https://rtic.rs) for more information!"
msgstr ""
"ì´ í”„ë ˆì„ì›Œí¬ì—ëŠ” ëª…ì‹œì ì¸ ê³µìœ  ìƒíƒœì˜ í•„ìš”ì„±ì„ ì¤„ì—¬ì£¼ëŠ” ë©”ì‹œì§€ ì „ë‹¬ê³¼ ê°™ì€ ë‹¤ë¥¸ "
"ê¸°ëŠ¥ê³¼ ì£¼ì–´ì§„ ì‹œê°„ì— ì‹¤í–‰ë˜ë„ë¡ ì‘ì—…ì„ ì˜ˆì•½í•˜ëŠ” ê¸°ëŠ¥ì´ í¬í•¨ë˜ì–´ ìˆì–´ ì£¼ê¸°ì ì¸ "
"ì‘ì—…ì„ êµ¬í˜„í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ì„¤ëª…ì„œ](https://rtic.rs)ë¥¼ "
"í™•ì¸í•˜ì‹­ì‹œì˜¤!"

#: src/concurrency/index.md:577
msgid "Real Time Operating Systems"
msgstr "ì‹¤ì‹œê°„ ìš´ì˜ ì²´ì œ"

#: src/concurrency/index.md:579
msgid ""
"Another common model for embedded concurrency is the real-time operating "
"system (RTOS). While currently less well explored in Rust, they are widely "
"used in traditional embedded development. Open source examples include "
"[FreeRTOS](https://freertos.org/) and [ChibiOS](http://chibios.org/). These "
"RTOSs provide support for running multiple application threads which the CPU "
"swaps between, either when the threads yield control (called cooperative "
"multitasking) or based on a regular timer or interrupts (preemptive "
"multitasking). The RTOS typically provide mutexes and other synchronisation "
"primitives, and often interoperate with hardware features such as DMA "
"engines."
msgstr ""
"ì„ë² ë””ë“œ ë™ì‹œì„±ì„ ìœ„í•œ ë˜ ë‹¤ë¥¸ ì¼ë°˜ì ì¸ ëª¨ë¸ì€ ì‹¤ì‹œê°„ ìš´ì˜ ì²´ì œ(RTOS)ì…ë‹ˆë‹¤. "
"í˜„ì¬ Rustì—ì„œëŠ” ì˜ ì—°êµ¬ë˜ì§€ ì•Šì•˜ì§€ë§Œ ê¸°ì¡´ ì„ë² ë””ë“œ ê°œë°œì—ì„œëŠ” ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤. "
"ì˜¤í”ˆ ì†ŒìŠ¤ ì˜ˆë¡œëŠ” [FreeRTOS](https://freertos.org/) ë° [ChibiOS](http://chibios.org/)ê°€ "
"ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ RTOSëŠ” ìŠ¤ë ˆë“œê°€ ì œì–´ë¥¼ ì–‘ë³´í•  ë•Œ(í˜‘ë ¥ì  ë©€í‹°íƒœìŠ¤í‚¹ì´ë¼ê³  í•¨) "
"ë˜ëŠ” ì¼ë°˜ íƒ€ì´ë¨¸ ë˜ëŠ” ì¸í„°ëŸ½íŠ¸(ì„ ì í˜• ë©€í‹°íƒœìŠ¤í‚¹)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ CPUê°€ ì „í™˜í•˜ëŠ” "
"ì—¬ëŸ¬ ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì§€ì›ì„ ì œê³µí•©ë‹ˆë‹¤. RTOSëŠ” ì¼ë°˜ì ìœ¼ë¡œ "
"ë®¤í…ìŠ¤ ë° ê¸°íƒ€ ë™ê¸°í™” ê¸°ë³¸ ìš”ì†Œë¥¼ ì œê³µí•˜ë©° ì¢…ì¢… DMA ì—”ì§„ê³¼ ê°™ì€ í•˜ë“œì›¨ì–´ "
"ê¸°ëŠ¥ê³¼ ìƒí˜¸ ìš´ìš©ë©ë‹ˆë‹¤."

#: src/concurrency/index.md:591
msgid ""
"At the time of writing, there are not many Rust RTOS examples to point to, "
"but it's an interesting area so watch this space!"
msgstr "ì´ ê¸€ì„ ì“°ëŠ” ì‹œì ì—ëŠ” ì°¸ê³ í•  ë§Œí•œ Rust RTOS ì˜ˆì œê°€ ë§ì§€ ì•Šì§€ë§Œ í¥ë¯¸ë¡œìš´ ë¶„ì•¼ì´ë¯€ë¡œ ì´ ê³µê°„ì„ ì£¼ëª©í•˜ì‹­ì‹œì˜¤!"

#: src/concurrency/index.md:594
msgid "Multiple Cores"
msgstr "ë‹¤ì¤‘ ì½”ì–´"

#: src/concurrency/index.md:596
msgid ""
"It is becoming more common to have two or more cores in embedded processors, "
"which adds an extra layer of complexity to concurrency. All the examples "
"using a critical section (including the `cortex_m::interrupt::Mutex`) assume "
"the only other execution thread is the interrupt thread, but on a multi-core "
"system that's no longer true. Instead, we'll need synchronisation primitives "
"designed for multiple cores (also called SMP, for symmetric multi-"
"processing)."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œì„¸ì„œì— ë‘ ê°œ ì´ìƒì˜ ì½”ì–´ê°€ ìˆëŠ” ê²ƒì´ ë” ì¼ë°˜ì ì´ ë˜ì–´ ë™ì‹œì„±ì— "
"ë³µì¡ì„±ì„ í•œì¸µ ë” ë”í•©ë‹ˆë‹¤. ì„ê³„ ì˜ì—­ì„ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì˜ˆì œ(`cortex_m::interrupt::Mutex` "
"í¬í•¨)ëŠ” ìœ ì¼í•œ ë‹¤ë¥¸ ì‹¤í–‰ ìŠ¤ë ˆë“œê°€ ì¸í„°ëŸ½íŠ¸ ìŠ¤ë ˆë“œë¼ê³  ê°€ì •í•˜ì§€ë§Œ ë‹¤ì¤‘ ì½”ì–´ "
"ì‹œìŠ¤í…œì—ì„œëŠ” ë” ì´ìƒ ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  ë‹¤ì¤‘ ì½”ì–´ìš©ìœ¼ë¡œ ì„¤ê³„ëœ ë™ê¸°í™” ê¸°ë³¸ "
"ìš”ì†Œ(ëŒ€ì¹­ ë‹¤ì¤‘ ì²˜ë¦¬ë¥¼ ìœ„í•´ SMPë¼ê³ ë„ í•¨)ê°€ í•„ìš”í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:603
msgid ""
"These typically use the atomic instructions we saw earlier, since the "
"processing system will ensure that atomicity is maintained over all cores."
msgstr "ì²˜ë¦¬ ì‹œìŠ¤í…œì´ ëª¨ë“  ì½”ì–´ì—ì„œ ì›ìì„±ì´ ìœ ì§€ë˜ë„ë¡ ë³´ì¥í•˜ë¯€ë¡œ ì¼ë°˜ì ìœ¼ë¡œ ì´ì „ì— ë³¸ ì›ìì  ëª…ë ¹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/concurrency/index.md:606
msgid ""
"Covering these topics in detail is currently beyond the scope of this book, "
"but the general patterns are the same as for the single-core case."
msgstr "ì´ëŸ¬í•œ ì£¼ì œë¥¼ ìì„¸íˆ ë‹¤ë£¨ëŠ” ê²ƒì€ í˜„ì¬ ì´ ì±…ì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ë§Œ ì¼ë°˜ì ì¸ íŒ¨í„´ì€ ë‹¨ì¼ ì½”ì–´ì˜ ê²½ìš°ì™€ ë™ì¼í•©ë‹ˆë‹¤."

#: src/collections/index.md:3
msgid ""
"Eventually you'll want to use dynamic data structures (AKA collections) in "
"your program. `std` provides a set of common collections: [`Vec`](https://"
"doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html), etc. All the collections "
"implemented in `std` use a global dynamic memory allocator (AKA the heap)."
msgstr ""
"ê²°êµ­ í”„ë¡œê·¸ë¨ì—ì„œ ë™ì  ë°ì´í„° êµ¬ì¡°(ì¼ëª… ì»¬ë ‰ì…˜)ë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ì„ ê²ƒì…ë‹ˆë‹¤. `std`ëŠ” "
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html) ë“±ê³¼ ê°™ì€ ì¼ë°˜ì ì¸ ì»¬ë ‰ì…˜ ì§‘í•©ì„ "
"ì œê³µí•©ë‹ˆë‹¤. `std`ì— êµ¬í˜„ëœ ëª¨ë“  ì»¬ë ‰ì…˜ì€ ì „ì—­ ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹ì(ì¼ëª… í™)ë¥¼ "
"ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/collections/index.md:12
msgid ""
"As `core` is, by definition, free of memory allocations these "
"implementations are not available there, but they can be found in the "
"`alloc` crate that's shipped with the compiler."
msgstr "'core'ëŠ” ì •ì˜ìƒ ë©”ëª¨ë¦¬ í• ë‹¹ì´ ì—†ìœ¼ë¯€ë¡œ ì´ëŸ¬í•œ êµ¬í˜„ì€ ê±°ê¸°ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ì™€ í•¨ê»˜ ì œê³µë˜ëŠ” 'alloc' í¬ë ˆì´íŠ¸ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:16
msgid ""
"If you need collections, a heap allocated implementation is not your only "
"option. You can also use _fixed capacity_ collections; one such "
"implementation can be found in the [`heapless`](https://crates.io/crates/"
"heapless) crate."
msgstr ""
"ì»¬ë ‰ì…˜ì´ í•„ìš”í•œ ê²½ìš° í™ í• ë‹¹ êµ¬í˜„ì´ ìœ ì¼í•œ ì˜µì…˜ì€ ì•„ë‹™ë‹ˆë‹¤. _ê³ ì • ìš©ëŸ‰_ "
"ì»¬ë ‰ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬í˜„ ì¤‘ í•˜ë‚˜ëŠ” [`heapless`](https://crates.io/crates/"
"heapless) í¬ë ˆì´íŠ¸ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:22
msgid "In this section, we'll explore and compare these two implementations."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” ì´ ë‘ ê°€ì§€ êµ¬í˜„ì„ ì‚´í´ë³´ê³  ë¹„êµí•©ë‹ˆë‹¤."

#: src/collections/index.md:24
msgid "Using `alloc`"
msgstr "`alloc` ì‚¬ìš©"

#: src/collections/index.md:26
msgid ""
"The `alloc` crate is shipped with the standard Rust distribution. To import "
"the crate you can directly `use` it _without_ declaring it as a dependency "
"in your `Cargo.toml` file."
msgstr ""
"`alloc` í¬ë ˆì´íŠ¸ëŠ” í‘œì¤€ Rust ë°°í¬íŒê³¼ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤. í¬ë ˆì´íŠ¸ë¥¼ ê°€ì ¸ì˜¤ë ¤ë©´ "
"`Cargo.toml` íŒŒì¼ì—ì„œ ì¢…ì†ì„±ìœ¼ë¡œ ì„ ì–¸í•˜ì§€ ì•Šê³  ì§ì ‘ `use`í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:38
msgid ""
"To be able to use any collection you'll first need use the "
"`global_allocator` attribute to declare the global allocator your program "
"will use. It's required that the allocator you select implements the "
"[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"trait."
msgstr ""
"ì»¬ë ‰ì…˜ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¨¼ì € `global_allocator` ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš©í•  "
"ì „ì—­ í• ë‹¹ìë¥¼ ì„ ì–¸í•´ì•¼ í•©ë‹ˆë‹¤. ì„ íƒí•œ í• ë‹¹ìëŠ” [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/collections/index.md:44
msgid ""
"For completeness and to keep this section as self-contained as possible "
"we'll implement a simple bump pointer allocator and use that as the global "
"allocator. However, we _strongly_ suggest you use a battle tested allocator "
"from crates.io in your program instead of this allocator."
msgstr ""
"ì™„ì „ì„±ì„ ê¸°í•˜ê³  ì´ ì„¹ì…˜ì„ ìµœëŒ€í•œ ë…ë¦½ì ìœ¼ë¡œ ìœ ì§€í•˜ê¸° ìœ„í•´ ê°„ë‹¨í•œ ë²”í”„ í¬ì¸í„° "
"í• ë‹¹ìë¥¼ êµ¬í˜„í•˜ê³  ì´ë¥¼ ì „ì—­ í• ë‹¹ìë¡œ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ í• ë‹¹ì ëŒ€ì‹  "
"í”„ë¡œê·¸ë¨ì—ì„œ crates.ioì˜ ê²€ì¦ëœ í• ë‹¹ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/collections/index.md:50
msgid "// Bump pointer allocator implementation\n"
msgstr "// ë²”í”„ í¬ì¸í„° í• ë‹¹ì êµ¬í˜„\n"

#: src/collections/index.md:57
msgid "// Bump pointer allocator for *single* core systems\n"
msgstr "// *ë‹¨ì¼* ì½”ì–´ ì‹œìŠ¤í…œìš© ë²”í”„ í¬ì¸í„° í• ë‹¹ì\n"

#: src/collections/index.md:68
msgid ""
"// `interrupt::free` is a critical section that makes our allocator safe\n"
"        // to use from within interrupts\n"
msgstr "// `interrupt::free`ëŠ” ì¸í„°ëŸ½íŠ¸ ë‚´ì—ì„œ í• ë‹¹ìë¥¼ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì„ê³„ ì˜ì—­ì…ë‹ˆë‹¤\n"

#: src/collections/index.md:76
msgid "// move start up to the next alignment boundary\n"
msgstr "// ì‹œì‘ì„ ë‹¤ìŒ ì •ë ¬ ê²½ê³„ë¡œ ì´ë™\n"

#: src/collections/index.md:80
msgid "// a null pointer signal an Out Of Memory condition\n"
msgstr "// null í¬ì¸í„°ëŠ” ë©”ëª¨ë¦¬ ë¶€ì¡± ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤\n"

#: src/collections/index.md:90
msgid "// this allocator never deallocates memory\n"
msgstr "// ì´ í• ë‹¹ìëŠ” ë©”ëª¨ë¦¬ë¥¼ ì ˆëŒ€ í•´ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤\n"

#: src/collections/index.md:93
msgid ""
"// Declaration of the global memory allocator\n"
"// NOTE the user must ensure that the memory region `[0x2000_0100, "
"0x2000_0200]`\n"
"// is not used by other parts of the program\n"
msgstr ""
"// ì „ì—­ ë©”ëª¨ë¦¬ í• ë‹¹ì ì„ ì–¸\n"
"// ì°¸ê³ : ì‚¬ìš©ìëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ `[0x2000_0100, 0x2000_0200]`ì´\n"
"// í”„ë¡œê·¸ë¨ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œ ì‚¬ìš©ë˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤\n"

#: src/collections/index.md:104
msgid ""
"Apart from selecting a global allocator the user will also have to define "
"how Out Of Memory (OOM) errors are handled using the _unstable_ "
"`alloc_error_handler` attribute."
msgstr ""
"ì „ì—­ í• ë‹¹ìë¥¼ ì„ íƒí•˜ëŠ” ê²ƒ ì™¸ì—ë„ ì‚¬ìš©ìëŠ” _ë¶ˆì•ˆì •í•œ_ `alloc_error_handler` "
"ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ë¶€ì¡±(OOM) ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/collections/index.md:121
msgid ""
"Once all that is in place, the user can finally use the collections in "
"`alloc`."
msgstr "ì´ ëª¨ë“  ê²ƒì´ ì¤€ë¹„ë˜ë©´ ì‚¬ìš©ìëŠ” ë§ˆì¹¨ë‚´ `alloc`ì˜ ì»¬ë ‰ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:137
msgid ""
"If you have used the collections in the `std` crate then these will be "
"familiar as they are exact same implementation."
msgstr "`std` í¬ë ˆì´íŠ¸ì˜ ì»¬ë ‰ì…˜ì„ ì‚¬ìš©í•´ ë³¸ ì ì´ ìˆë‹¤ë©´ ì´ê²ƒë“¤ì€ ì •í™•íˆ ë™ì¼í•œ êµ¬í˜„ì´ë¯€ë¡œ ìµìˆ™í•  ê²ƒì…ë‹ˆë‹¤."

#: src/collections/index.md:140
msgid "Using `heapless`"
msgstr "`heapless` ì‚¬ìš©"

#: src/collections/index.md:142
msgid ""
"`heapless` requires no setup as its collections don't depend on a global "
"memory allocator. Just `use` its collections and proceed to instantiate them:"
msgstr ""
"`heapless`ëŠ” ì»¬ë ‰ì…˜ì´ ì „ì—­ ë©”ëª¨ë¦¬ í• ë‹¹ìì— ì˜ì¡´í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì„¤ì •ì´ í•„ìš”í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. ì»¬ë ‰ì…˜ì„ `use`í•˜ê³  ì¸ìŠ¤í„´ìŠ¤í™”í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/collections/index.md:146
msgid "// heapless version: v0.4.x\n"
msgstr "// heapless ë²„ì „: v0.4.x\n"

#: src/collections/index.md:160
msgid ""
"You'll note two differences between these collections and the ones in "
"`alloc`."
msgstr "ì´ ì»¬ë ‰ì…˜ê³¼ `alloc`ì˜ ì»¬ë ‰ì…˜ ì‚¬ì´ì—ëŠ” ë‘ ê°€ì§€ ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:162
msgid ""
"First, you have to declare upfront the capacity of the collection. "
"`heapless` collections never reallocate and have fixed capacities; this "
"capacity is part of the type signature of the collection. In this case we "
"have declared that `xs` has a capacity of 8 elements that is the vector can, "
"at most, hold 8 elements. This is indicated by the `U8` (see [`typenum`]"
"(https://crates.io/crates/typenum)) in the type signature."
msgstr ""
"ë¨¼ì € ì»¬ë ‰ì…˜ì˜ ìš©ëŸ‰ì„ ë¯¸ë¦¬ ì„ ì–¸í•´ì•¼ í•©ë‹ˆë‹¤. `heapless` ì»¬ë ‰ì…˜ì€ ì ˆëŒ€ "
"ì¬í• ë‹¹ë˜ì§€ ì•Šìœ¼ë©° ê³ ì • ìš©ëŸ‰ì„ ê°€ì§‘ë‹ˆë‹¤. ì´ ìš©ëŸ‰ì€ ì»¬ë ‰ì…˜ì˜ ìœ í˜• ì„œëª…ì˜ "
"ì¼ë¶€ì…ë‹ˆë‹¤. ì´ ê²½ìš° `xs`ì˜ ìš©ëŸ‰ì´ 8ê°œ ìš”ì†Œë¼ê³  ì„ ì–¸í–ˆìŠµë‹ˆë‹¤. ì¦‰, ë²¡í„°ëŠ” "
"ìµœëŒ€ 8ê°œì˜ ìš”ì†Œë¥¼ ë³´ìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ìœ í˜• ì„œëª…ì˜ `U8`([`typenum`])"
"(https://crates.io/crates/typenum) ì°¸ì¡°)ë¡œ í‘œì‹œë©ë‹ˆë‹¤."

#: src/collections/index.md:170
msgid ""
"Second, the `push` method, and many other methods, return a `Result`. Since "
"the `heapless` collections have fixed capacity all operations that insert "
"elements into the collection can potentially fail. The API reflects this "
"problem by returning a `Result` indicating whether the operation succeeded "
"or not. In contrast, `alloc` collections will reallocate themselves on the "
"heap to increase their capacity."
msgstr ""
"ë‘ ë²ˆì§¸ë¡œ, `push` ë©”ì„œë“œì™€ ë‹¤ë¥¸ ë§ì€ ë©”ì„œë“œëŠ” `Result`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. "
"`heapless` ì»¬ë ‰ì…˜ì€ ê³ ì • ìš©ëŸ‰ì„ ê°€ì§€ë¯€ë¡œ ì»¬ë ‰ì…˜ì— ìš”ì†Œë¥¼ ì‚½ì…í•˜ëŠ” ëª¨ë“  "
"ì‘ì—…ì€ ì ì¬ì ìœ¼ë¡œ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. APIëŠ” ì‘ì—… ì„±ê³µ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” "
"`Result`ë¥¼ ë°˜í™˜í•˜ì—¬ ì´ ë¬¸ì œë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤. ë°˜ë©´ `alloc` ì»¬ë ‰ì…˜ì€ ìš©ëŸ‰ì„ "
"ëŠ˜ë¦¬ê¸° ìœ„í•´ í™ì—ì„œ ìì²´ì ìœ¼ë¡œ ì¬í• ë‹¹ë©ë‹ˆë‹¤."

#: src/collections/index.md:177
msgid ""
"As of version v0.4.x all `heapless` collections store all their elements "
"inline. This means that an operation like `let x = heapless::Vec::new();` "
"will allocate the collection on the stack, but it's also possible to "
"allocate the collection on a `static` variable, or even on the heap "
"(`Box<Vec<_, _>>`)."
msgstr ""
"v0.4.x ë²„ì „ë¶€í„° ëª¨ë“  `heapless` ì»¬ë ‰ì…˜ì€ ëª¨ë“  ìš”ì†Œë¥¼ ì¸ë¼ì¸ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤. "
"ì¦‰, `let x = heapless::Vec::new();`ì™€ ê°™ì€ ì‘ì—…ì€ ìŠ¤íƒì— ì»¬ë ‰ì…˜ì„ í• ë‹¹í•˜ì§€ë§Œ "
"`static` ë³€ìˆ˜ë‚˜ í™(`Box<Vec<_, _>>`)ì— ì»¬ë ‰ì…˜ì„ í• ë‹¹í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:182
msgid "Trade-offs"
msgstr "ì ˆì¶©ì "

#: src/collections/index.md:184
msgid ""
"Keep these in mind when choosing between heap allocated, relocatable "
"collections and fixed capacity collections."
msgstr "í™ í• ë‹¹, ì¬ë°°ì¹˜ ê°€ëŠ¥ ì»¬ë ‰ì…˜ê³¼ ê³ ì • ìš©ëŸ‰ ì»¬ë ‰ì…˜ ì¤‘ì—ì„œ ì„ íƒí•  ë•Œ ë‹¤ìŒ ì‚¬í•­ì„ ì—¼ë‘ì— ë‘ì‹­ì‹œì˜¤."

#: src/collections/index.md:187
msgid "Out Of Memory and error handling"
msgstr "ë©”ëª¨ë¦¬ ë¶€ì¡± ë° ì˜¤ë¥˜ ì²˜ë¦¬"

#: src/collections/index.md:189
msgid ""
"With heap allocations Out Of Memory is always a possibility and can occur in "
"any place where a collection may need to grow: for example, all "
"`alloc::Vec.push` invocations can potentially generate an OOM condition. "
"Thus some operations can _implicitly_ fail. Some `alloc` collections expose "
"`try_reserve` methods that let you check for potential OOM conditions when "
"growing the collection but you need be proactive about using them."
msgstr ""
"í™ í• ë‹¹ì„ ì‚¬ìš©í•˜ë©´ í•­ìƒ ë©”ëª¨ë¦¬ ë¶€ì¡±ì´ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë©° ì»¬ë ‰ì…˜ì´ ì»¤ì ¸ì•¼ í•˜ëŠ” "
"ëª¨ë“  ê³³ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ëª¨ë“  `alloc::Vec.push` í˜¸ì¶œì€ "
"ì ì¬ì ìœ¼ë¡œ OOM ì¡°ê±´ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì¼ë¶€ ì‘ì—…ì€ _ì•”ì‹œì ìœ¼ë¡œ_ "
"ì‹¤íŒ¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¼ë¶€ `alloc` ì»¬ë ‰ì…˜ì€ ì»¬ë ‰ì…˜ì„ ëŠ˜ë¦´ ë•Œ ì ì¬ì ì¸ OOM "
"ì¡°ê±´ì„ í™•ì¸í•  ìˆ˜ ìˆëŠ” `try_reserve` ë©”ì„œë“œë¥¼ ë…¸ì¶œí•˜ì§€ë§Œ ì´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë° "
"ì ê·¹ì ì´ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/collections/index.md:196
msgid ""
"If you exclusively use `heapless` collections and you don't use a memory "
"allocator for anything else then an OOM condition is impossible. Instead, "
"you'll have to deal with collections running out of capacity on a case by "
"case basis. That is you'll have deal with _all_ the `Result`s returned by "
"methods like `Vec.push`."
msgstr ""
"`heapless` ì»¬ë ‰ì…˜ë§Œ ë…ì ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ë‹¤ë¥¸ ìš©ë„ë¡œ ë©”ëª¨ë¦¬ í• ë‹¹ìë¥¼ ì‚¬ìš©í•˜ì§€ "
"ì•Šìœ¼ë©´ OOM ì¡°ê±´ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ëŒ€ì‹  ì»¬ë ‰ì…˜ ìš©ëŸ‰ ë¶€ì¡± ë¬¸ì œë¥¼ ì‚¬ë¡€ë³„ë¡œ "
"ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤. ì¦‰, `Vec.push`ì™€ ê°™ì€ ë©”ì„œë“œì—ì„œ ë°˜í™˜ë˜ëŠ” ëª¨ë“  `Result`ë¥¼ "
"ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/collections/index.md:202
msgid ""
"OOM failures can be harder to debug than say `unwrap`\\-ing on all `Result`s "
"returned by `heapless::Vec.push` because the observed location of failure "
"may _not_ match with the location of the cause of the problem. For example, "
"even `vec.reserve(1)` can trigger an OOM if the allocator is nearly "
"exhausted because some other collection was leaking memory (memory leaks are "
"possible in safe Rust)."
msgstr ""
"OOM ì˜¤ë¥˜ëŠ” `heapless::Vec.push`ì—ì„œ ë°˜í™˜ëœ ëª¨ë“  `Result`ì— ëŒ€í•´ `unwrap`í•˜ëŠ” "
"ê²ƒë³´ë‹¤ ë””ë²„ê¹…í•˜ê¸° ë” ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ ê´€ì°°ëœ ì˜¤ë¥˜ ìœ„ì¹˜ê°€ ë¬¸ì œì˜ "
"ì›ì¸ ìœ„ì¹˜ì™€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ë¥¸ ì»¬ë ‰ì…˜ì—ì„œ "
"ë©”ëª¨ë¦¬ê°€ ëˆ„ìˆ˜ë˜ì–´ í• ë‹¹ìê°€ ê±°ì˜ ì†Œì§„ëœ ê²½ìš° `vec.reserve(1)`ì¡°ì°¨ë„ OOMì„ "
"ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì•ˆì „í•œ Rustì—ì„œëŠ” ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤)."

#: src/collections/index.md:209
msgid "Memory usage"
msgstr "ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰"

#: src/collections/index.md:211
msgid ""
"Reasoning about memory usage of heap allocated collections is hard because "
"the capacity of long lived collections can change at runtime. Some "
"operations may implicitly reallocate the collection increasing its memory "
"usage, and some collections expose methods like `shrink_to_fit` that can "
"potentially reduce the memory used by the collection -- ultimately, it's up "
"to the allocator to decide whether to actually shrink the memory allocation "
"or not. Additionally, the allocator may have to deal with memory "
"fragmentation which can increase the _apparent_ memory usage."
msgstr ""
"í™ í• ë‹¹ ì»¬ë ‰ì…˜ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¶”ë¡ í•˜ëŠ” ê²ƒì€ ì–´ë µìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ ì˜¤ë˜ "
"ì§€ì†ë˜ëŠ” ì»¬ë ‰ì…˜ì˜ ìš©ëŸ‰ì´ ëŸ°íƒ€ì„ì— ë³€ê²½ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì¼ë¶€ ì‘ì—…ì€ "
"ì»¬ë ‰ì…˜ì„ ì•”ì‹œì ìœ¼ë¡œ ì¬í• ë‹¹í•˜ì—¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ëŠ˜ë¦´ ìˆ˜ ìˆìœ¼ë©°, ì¼ë¶€ ì»¬ë ‰ì…˜ì€ "
"`shrink_to_fit`ê³¼ ê°™ì€ ë©”ì„œë“œë¥¼ ë…¸ì¶œí•˜ì—¬ ì»¬ë ‰ì…˜ì´ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ ì ì¬ì ìœ¼ë¡œ "
"ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê¶ê·¹ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ í• ë‹¹ì„ ì‹¤ì œë¡œ ì¤„ì¼ì§€ ì—¬ë¶€ëŠ” í• ë‹¹ìê°€ "
"ê²°ì •í•©ë‹ˆë‹¤. ë˜í•œ í• ë‹¹ìëŠ” ë©”ëª¨ë¦¬ ë‹¨í¸í™”ë¥¼ ì²˜ë¦¬í•´ì•¼ í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” "
"_ê²‰ë³´ê¸°_ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¦ê°€ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:220
msgid ""
"On the other hand if you exclusively use fixed capacity collections, store "
"most of them in `static` variables and set a maximum size for the call stack "
"then the linker will detect if you try to use more memory than what's "
"physically available."
msgstr ""
"ë°˜ë©´ì— ê³ ì • ìš©ëŸ‰ ì»¬ë ‰ì…˜ë§Œ ë…ì ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ëŒ€ë¶€ë¶„ì„ `static` ë³€ìˆ˜ì— ì €ì¥í•˜ë©° "
"í˜¸ì¶œ ìŠ¤íƒì˜ ìµœëŒ€ í¬ê¸°ë¥¼ ì„¤ì •í•˜ë©´ ë§ì»¤ëŠ” ë¬¼ë¦¬ì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ë³´ë‹¤ ë” "
"ë§ì€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í•˜ëŠ”ì§€ ê°ì§€í•©ë‹ˆë‹¤."

#: src/collections/index.md:225
msgid ""
"Furthermore, fixed capacity collections allocated on the stack will be "
"reported by [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) flag which means that tools that "
"analyze stack usage (like [`stack-sizes`](https://crates.io/crates/stack-"
"sizes)) will include them in their analysis."
msgstr ""
"ë˜í•œ ìŠ¤íƒì— í• ë‹¹ëœ ê³ ì • ìš©ëŸ‰ ì»¬ë ‰ì…˜ì€ [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) í”Œë˜ê·¸ì— ì˜í•´ ë³´ê³ ë©ë‹ˆë‹¤. ì´ëŠ” ìŠ¤íƒ "
"ì‚¬ìš©ëŸ‰ì„ ë¶„ì„í•˜ëŠ” ë„êµ¬([`stack-sizes`](https://crates.io/crates/stack-"
"sizes)ì™€ ê°™ì€)ê°€ ë¶„ì„ì— ì´ë¥¼ í¬í•¨í•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/collections/index.md:232
msgid ""
"However, fixed capacity collections can _not_ be shrunk which can result in "
"lower load factors (the ratio between the size of the collection and its "
"capacity) than what relocatable collections can achieve."
msgstr ""
"ê·¸ëŸ¬ë‚˜ ê³ ì • ìš©ëŸ‰ ì»¬ë ‰ì…˜ì€ ì¶•ì†Œë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¬ë°°ì¹˜ ê°€ëŠ¥í•œ ì»¬ë ‰ì…˜ì´ ë‹¬ì„±í•  ìˆ˜ "
"ìˆëŠ” ê²ƒë³´ë‹¤ ë‚®ì€ ë¡œë“œ íŒ©í„°(ì»¬ë ‰ì…˜ í¬ê¸°ì™€ ìš©ëŸ‰ ê°„ì˜ ë¹„ìœ¨)ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/collections/index.md:236
msgid "Worst Case Execution Time (WCET)"
msgstr "ìµœì•…ì˜ ê²½ìš° ì‹¤í–‰ ì‹œê°„ (WCET)"

#: src/collections/index.md:238
msgid ""
"If you are building time sensitive applications or hard real time "
"applications then you care, maybe a lot, about the worst case execution time "
"of the different parts of your program."
msgstr ""
"ì‹œê°„ì— ë¯¼ê°í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ë˜ëŠ” í•˜ë“œ ì‹¤ì‹œê°„ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•˜ëŠ” ê²½ìš° "
"í”„ë¡œê·¸ë¨ì˜ ë‹¤ì–‘í•œ ë¶€ë¶„ì˜ ìµœì•…ì˜ ê²½ìš° ì‹¤í–‰ ì‹œê°„ì— ëŒ€í•´ ë§ì´ ì‹ ê²½ ì“¸ ê²ƒì…ë‹ˆë‹¤."

#: src/collections/index.md:242
msgid ""
"The `alloc` collections can reallocate so the WCET of operations that may "
"grow the collection will also include the time it takes to reallocate the "
"collection, which itself depends on the _runtime_ capacity of the "
"collection. This makes it hard to determine the WCET of, for example, the "
"`alloc::Vec.push` operation as it depends on both the allocator being used "
"and its runtime capacity."
msgstr ""
"`alloc` ì»¬ë ‰ì…˜ì€ ì¬í• ë‹¹ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì»¬ë ‰ì…˜ì„ ëŠ˜ë¦´ ìˆ˜ ìˆëŠ” ì‘ì—…ì˜ WCETì—ëŠ” "
"ì»¬ë ‰ì…˜ì„ ì¬í• ë‹¹í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ë„ í¬í•¨ë˜ë©°, ì´ëŠ” ì»¬ë ‰ì…˜ì˜ _ëŸ°íƒ€ì„_ ìš©ëŸ‰ì— "
"ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤. ì´ë¡œ ì¸í•´ ì˜ˆë¥¼ ë“¤ì–´ `alloc::Vec.push` ì‘ì—…ì˜ WCETë¥¼ ê²°ì •í•˜ê¸° "
"ì–´ë µìŠµë‹ˆë‹¤. ì´ëŠ” ì‚¬ìš©ë˜ëŠ” í• ë‹¹ìì™€ ëŸ°íƒ€ì„ ìš©ëŸ‰ ëª¨ë‘ì— ë”°ë¼ ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/collections/index.md:248
msgid ""
"On the other hand fixed capacity collections never reallocate so all "
"operations have a predictable execution time. For example, "
"`heapless::Vec.push` executes in constant time."
msgstr ""
"ë°˜ë©´ì— ê³ ì • ìš©ëŸ‰ ì»¬ë ‰ì…˜ì€ ì ˆëŒ€ ì¬í• ë‹¹ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ëª¨ë“  ì‘ì—…ì€ ì˜ˆì¸¡ ê°€ëŠ¥í•œ "
"ì‹¤í–‰ ì‹œê°„ì„ ê°€ì§‘ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `heapless::Vec.push`ëŠ” ìƒìˆ˜ ì‹œê°„ì— ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/collections/index.md:252
msgid "Ease of use"
msgstr "ì‚¬ìš© í¸ì˜ì„±"

#: src/collections/index.md:254
msgid ""
"`alloc` requires setting up a global allocator whereas `heapless` does not. "
"However, `heapless` requires you to pick the capacity of each collection "
"that you instantiate."
msgstr ""
"`alloc`ì€ ì „ì—­ í• ë‹¹ìë¥¼ ì„¤ì •í•´ì•¼ í•˜ì§€ë§Œ `heapless`ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ "
"`heapless`ëŠ” ì¸ìŠ¤í„´ìŠ¤í™”í•˜ëŠ” ê° ì»¬ë ‰ì…˜ì˜ ìš©ëŸ‰ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/collections/index.md:258
msgid ""
"The `alloc` API will be familiar to virtually every Rust developer. The "
"`heapless` API tries to closely mimic the `alloc` API but it will never be "
"exactly the same due to its explicit error handling -- some developers may "
"feel the explicit error handling is excessive or too cumbersome."
msgstr ""
"`alloc` APIëŠ” ê±°ì˜ ëª¨ë“  Rust ê°œë°œìì—ê²Œ ìµìˆ™í•  ê²ƒì…ë‹ˆë‹¤. `heapless` APIëŠ” "
"`alloc` APIë¥¼ ë°€ì ‘í•˜ê²Œ ëª¨ë°©í•˜ë ¤ê³  í•˜ì§€ë§Œ ëª…ì‹œì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬ë¡œ ì¸í•´ ì •í™•íˆ "
"ë™ì¼í•˜ì§€ëŠ” ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ì¼ë¶€ ê°œë°œìëŠ” ëª…ì‹œì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ê³¼ë„í•˜ê±°ë‚˜ ë„ˆë¬´ "
"ë²ˆê±°ë¡­ë‹¤ê³  ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/design-patterns/index.md:3
msgid ""
"This chapter aims to collect various useful design patterns for embedded "
"Rust."
msgstr ""
"ì´ ì¥ì€ ì„ë² ë””ë“œ Rustë¥¼ ìœ„í•œ ë‹¤ì–‘í•˜ê³  ìœ ìš©í•œ ë””ìì¸ íŒ¨í„´ì„ ìˆ˜ì§‘í•˜ëŠ” ê²ƒì„ "
"ëª©í‘œë¡œ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/index.md:1
msgid "HAL Design Patterns"
msgstr "HAL ë””ìì¸ íŒ¨í„´"

#: src/design-patterns/hal/index.md:3
msgid ""
"This is a set of common and recommended patterns for writing hardware "
"abstraction layers (HALs) for microcontrollers in Rust. These patterns are "
"intended to be used in addition to the existing [Rust API Guidelines]"
"(https://rust-lang.github.io/api-guidelines/) when writing HALs for "
"microcontrollers."
msgstr ""
"ì´ê²ƒì€ Rustì—ì„œ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ìš© í•˜ë“œì›¨ì–´ ì¶”ìƒí™” ê³„ì¸µ(HAL)ì„ ì‘ì„±í•˜ê¸° ìœ„í•œ "
"ì¼ë°˜ì ì´ê³  ê¶Œì¥ë˜ëŠ” íŒ¨í„´ ì§‘í•©ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ íŒ¨í„´ì€ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ìš© HALì„ "
"ì‘ì„±í•  ë•Œ ê¸°ì¡´ [Rust API ê°€ì´ë“œë¼ì¸](https://rust-lang.github.io/api-guidelines/) "
"ì™¸ì— ì¶”ê°€ë¡œ ì‚¬ìš©í•˜ë„ë¡ ì˜ë„ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/design-patterns/hal/index.md:10
msgid "[Checklist](checklist.md)"
msgstr "[ì²´í¬ë¦¬ìŠ¤íŠ¸](checklist.md)"

#: src/design-patterns/hal/index.md:12
msgid "[Naming](naming.md)"
msgstr "[ëª…ëª…](naming.md)"

#: src/design-patterns/hal/index.md:13
msgid "[Interoperability](interoperability.md)"
msgstr "[ìƒí˜¸ ìš´ìš©ì„±](interoperability.md)"

#: src/design-patterns/hal/index.md:14
msgid "[Predictability](predictability.md)"
msgstr "[ì˜ˆì¸¡ ê°€ëŠ¥ì„±](predictability.md)"

#: src/design-patterns/hal/index.md:15
msgid "[GPIO](gpio.md)"
msgstr "[GPIO](gpio.md)"

#: src/design-patterns/hal/checklist.md:1
msgid "HAL Design Patterns Checklist"
msgstr "HAL ë””ìì¸ íŒ¨í„´ ì²´í¬ë¦¬ìŠ¤íŠ¸"

#: src/design-patterns/hal/checklist.md:3
msgid "**Naming** _(crate aligns with Rust naming conventions)_"
msgstr "**ëª…ëª…** _(í¬ë ˆì´íŠ¸ê°€ Rust ëª…ëª… ê·œì¹™ê³¼ ì¼ì¹˜)_"

#: src/design-patterns/hal/checklist.md:4
msgid ""
"The crate is named appropriately ([C-CRATE-NAME](naming.html#c-crate-name))"
msgstr ""
"í¬ë ˆì´íŠ¸ ì´ë¦„ì´ ì ì ˆí•©ë‹ˆë‹¤ ([C-CRATE-NAME](naming.html#c-crate-name))"

#: src/design-patterns/hal/checklist.md:5
msgid ""
"**Interoperability** _(crate interacts nicely with other library "
"functionality)_"
msgstr ""
"**ìƒí˜¸ ìš´ìš©ì„±** _(í¬ë ˆì´íŠ¸ê°€ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê¸°ëŠ¥ê³¼ ì˜ ìƒí˜¸ ì‘ìš©)_"

#: src/design-patterns/hal/checklist.md:6
msgid ""
"Wrapper types provide a destructor method ([C-FREE](interoperability.html#c-"
"free))"
msgstr ""
"ë˜í¼ íƒ€ì…ì€ ì†Œë©¸ì ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤ ([C-FREE](interoperability.html#c-"
"free))"

#: src/design-patterns/hal/checklist.md:7
msgid ""
"HALs reexport their register access crate ([C-REEXPORT-PAC]"
"(interoperability.html#c-reexport-pac))"
msgstr ""
"HALì€ ë ˆì§€ìŠ¤í„° ì ‘ê·¼ í¬ë ˆì´íŠ¸ë¥¼ ë‹¤ì‹œ ë‚´ë³´ëƒ…ë‹ˆë‹¤ ([C-REEXPORT-PAC](interoperability.html#c-reexport-pac))"

#: src/design-patterns/hal/checklist.md:8
msgid ""
"Types implement the `embedded-hal` traits ([C-HAL-TRAITS]"
"(interoperability.html#c-hal-traits))"
msgstr ""
"íƒ€ì…ì€ `embedded-hal` íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤ ([C-HAL-TRAITS](interoperability.html#c-hal-traits))"
"íƒ€ì…ì€ `embedded-hal` íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤ ([C-HAL-TRAITS]"

#: src/design-patterns/hal/checklist.md:9
msgid ""
"**Predictability** _(crate enables legible code that acts how it looks)_"
msgstr ""
"**ì˜ˆì¸¡ ê°€ëŠ¥ì„±** _(í¬ë ˆì´íŠ¸ê°€ ë³´ì´ëŠ” ëŒ€ë¡œ ì‘ë™í•˜ëŠ” ì½ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ê°€ëŠ¥í•˜ê²Œ í•¨)_"

#: src/design-patterns/hal/checklist.md:10
msgid ""
"Constructors are used instead of extension traits ([C-CTOR]"
"(predictability.html#c-ctor))"
msgstr ""
"í™•ì¥ íŠ¸ë ˆì´íŠ¸ ëŒ€ì‹  ìƒì„±ìê°€ ì‚¬ìš©ë©ë‹ˆë‹¤ ([C-CTOR](predictability.html#c-ctor))"

#: src/design-patterns/hal/checklist.md:11
msgid "**GPIO Interfaces** _(GPIO Interfaces follow a common pattern)_"
msgstr "**GPIO ì¸í„°í˜ì´ìŠ¤** _(GPIO ì¸í„°í˜ì´ìŠ¤ëŠ” ê³µí†µ íŒ¨í„´ì„ ë”°ë¦„)_"

#: src/design-patterns/hal/checklist.md:12
msgid "Pin types are zero-sized by default ([C-ZST-PIN](gpio.md#c-zst-pin))"
msgstr "í•€ íƒ€ì…ì€ ê¸°ë³¸ì ìœ¼ë¡œ ì œë¡œ í¬ê¸°ì…ë‹ˆë‹¤ ([C-ZST-PIN](gpio.md#c-zst-pin))"

#: src/design-patterns/hal/checklist.md:13
msgid ""
"Pin types provide methods to erase pin and port ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"
msgstr ""
"í•€ íƒ€ì…ì€ í•€ê³¼ í¬íŠ¸ë¥¼ ì§€ìš°ëŠ” ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤ ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"

#: src/design-patterns/hal/checklist.md:14
msgid ""
"Pin state should be encoded as type parameters ([C-PIN-STATE](gpio.md#c-pin-"
"state))"
msgstr ""
"í•€ ìƒíƒœëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¡œ ì¸ì½”ë”©ë˜ì–´ì•¼ í•©ë‹ˆë‹¤ ([C-PIN-STATE](gpio.md#c-pin-"
"state))"

#: src/design-patterns/hal/naming.md:4
msgid "<a id=\"c-crate-name\"></a>"
msgstr "<a id=\"c-crate-name\"></a>"

#: src/design-patterns/hal/naming.md:5
msgid "The crate is named appropriately (C-CRATE-NAME)"
msgstr "í¬ë ˆì´íŠ¸ ì´ë¦„ì´ ì ì ˆí•©ë‹ˆë‹¤ (C-CRATE-NAME)"

#: src/design-patterns/hal/naming.md:7
msgid ""
"HAL crates should be named after the chip or family of chips they aim to "
"support. Their name should end with `-hal` to distinguish them from register "
"access crates. The name should not contain underscores (use dashes instead)."
msgstr ""
"HAL í¬ë ˆì´íŠ¸ëŠ” ì§€ì›í•˜ë ¤ëŠ” ì¹© ë˜ëŠ” ì¹© ì œí’ˆêµ°ì˜ ì´ë¦„ì„ ë”°ì•¼ í•©ë‹ˆë‹¤. ë ˆì§€ìŠ¤í„° "
"ì ‘ê·¼ í¬ë ˆì´íŠ¸ì™€ êµ¬ë³„í•˜ê¸° ìœ„í•´ ì´ë¦„ì€ `-hal`ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤. ì´ë¦„ì— ë°‘ì¤„ì„ "
"í¬í•¨í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤(ëŒ€ì‹  ëŒ€ì‹œë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤)."

#: src/design-patterns/hal/interoperability.md:4
msgid "<a id=\"c-free\"></a>"
msgstr "<a id=\"c-free\"></a>"

#: src/design-patterns/hal/interoperability.md:5
msgid "Wrapper types provide a destructor method (C-FREE)"
msgstr "ë˜í¼ íƒ€ì…ì€ ì†Œë©¸ì ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤ (C-FREE)"

#: src/design-patterns/hal/interoperability.md:7
msgid ""
"Any non-`Copy` wrapper type provided by the HAL should provide a `free` "
"method that consumes the wrapper and returns back the raw peripheral (and "
"possibly other objects) it was created from."
msgstr ""
"HALì—ì„œ ì œê³µí•˜ëŠ” ëª¨ë“  ë¹„-`Copy` ë˜í¼ íƒ€ì…ì€ ë˜í¼ë¥¼ ì†Œë¹„í•˜ê³  ìƒì„±ëœ ì›ì‹œ ì£¼ë³€ "
"ì¥ì¹˜(ë° ë‹¤ë¥¸ ê°ì²´ì¼ ìˆ˜ë„ ìˆìŒ)ë¥¼ ë°˜í™˜í•˜ëŠ” `free` ë©”ì„œë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:11
msgid ""
"The method should shut down and reset the peripheral if necessary. Calling "
"`new` with the raw peripheral returned by `free` should not fail due to an "
"unexpected state of the peripheral."
msgstr ""
"ë©”ì„œë“œëŠ” í•„ìš”í•œ ê²½ìš° ì£¼ë³€ ì¥ì¹˜ë¥¼ ì¢…ë£Œí•˜ê³  ì¬ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. `free`ê°€ ë°˜í™˜í•œ "
"ì›ì‹œ ì£¼ë³€ ì¥ì¹˜ë¡œ `new`ë¥¼ í˜¸ì¶œí•  ë•Œ ì£¼ë³€ ì¥ì¹˜ì˜ ì˜ˆê¸°ì¹˜ ì•Šì€ ìƒíƒœë¡œ ì¸í•´ "
"ì‹¤íŒ¨í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:15
msgid ""
"If the HAL type requires other non-`Copy` objects to be constructed (for "
"example I/O pins), any such object should be released and returned by `free` "
"as well. `free` should return a tuple in that case."
msgstr ""
"HAL íƒ€ì…ì´ ë‹¤ë¥¸ ë¹„-`Copy` ê°ì²´(ì˜ˆ: I/O í•€)ë¥¼ êµ¬ì„±í•´ì•¼ í•˜ëŠ” ê²½ìš°, í•´ë‹¹ ê°ì²´ë„ "
"`free`ì— ì˜í•´ í•´ì œë˜ê³  ë°˜í™˜ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ê²½ìš° `free`ëŠ” íŠœí”Œì„ ë°˜í™˜í•´ì•¼ "
"í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:19
msgid "For example:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´:"

#: src/design-patterns/hal/interoperability.md:36
msgid "<a id=\"c-reexport-pac\"></a>"
msgstr "<a id=\"c-reexport-pac\"></a>"

#: src/design-patterns/hal/interoperability.md:37
msgid "HALs reexport their register access crate (C-REEXPORT-PAC)"
msgstr "HALì€ ë ˆì§€ìŠ¤í„° ì ‘ê·¼ í¬ë ˆì´íŠ¸ë¥¼ ì¬ìˆ˜ì¶œí•©ë‹ˆë‹¤ (C-REEXPORT-PAC)"

#: src/design-patterns/hal/interoperability.md:39
msgid ""
"HALs can be written on top of [svd2rust](https://github.com/rust-embedded/"
"svd2rust)\\-generated PACs, or on top of other crates that provide raw "
"register access. HALs should always reexport the register access crate they "
"are based on in their crate root."
msgstr ""
"HALì€ [svd2rust](https://github.com/rust-embedded/svd2rust)ë¡œ ìƒì„±ëœ PAC ìœ„ì— "
"ë˜ëŠ” ì›ì‹œ ë ˆì§€ìŠ¤í„° ì ‘ê·¼ì„ ì œê³µí•˜ëŠ” ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ ìœ„ì— ì‘ì„±ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. HALì€ "
"í•­ìƒ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” ë ˆì§€ìŠ¤í„° ì ‘ê·¼ í¬ë ˆì´íŠ¸ë¥¼ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì— ì¬ìˆ˜ì¶œí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:43
msgid ""
"A PAC should be reexported under the name `pac`, regardless of the actual "
"name of the crate, as the name of the HAL should already make it clear what "
"PAC is being accessed."
msgstr ""
"PACëŠ” í¬ë ˆì´íŠ¸ì˜ ì‹¤ì œ ì´ë¦„ê³¼ ê´€ê³„ì—†ì´ `pac`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì¬ìˆ˜ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤. "
"HALì˜ ì´ë¦„ì´ ì–´ë–¤ PACì— ì ‘ê·¼í•˜ëŠ”ì§€ ì´ë¯¸ ëª…í™•í•˜ê²Œ í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:49
msgid "<a id=\"c-hal-traits\"></a>"
msgstr "<a id=\"c-hal-traits\"></a>"

#: src/design-patterns/hal/interoperability.md:50
msgid "Types implement the `embedded-hal` traits (C-HAL-TRAITS)"
msgstr "íƒ€ì…ì€ `embedded-hal` íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤ (C-HAL-TRAITS)"

#: src/design-patterns/hal/interoperability.md:52
msgid ""
"Types provided by the HAL should implement all applicable traits provided by "
"the [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) crate."
msgstr ""
"HALì—ì„œ ì œê³µí•˜ëŠ” íƒ€ì…ì€ [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) "
"í¬ë ˆì´íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ëª¨ë“  í•´ë‹¹ íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/interoperability.md:55
msgid "Multiple traits may be implemented for the same type."
msgstr "ë™ì¼í•œ íƒ€ì…ì— ëŒ€í•´ ì—¬ëŸ¬ íŠ¸ë ˆì´íŠ¸ê°€ êµ¬í˜„ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/design-patterns/hal/predictability.md:4
msgid "<a id=\"c-ctor\"></a>"
msgstr "<a id=\"c-ctor\"></a>"

#: src/design-patterns/hal/predictability.md:5
msgid "Constructors are used instead of extension traits (C-CTOR)"
msgstr "í™•ì¥ íŠ¸ë ˆì´íŠ¸ ëŒ€ì‹  ìƒì„±ìê°€ ì‚¬ìš©ë©ë‹ˆë‹¤ (C-CTOR)"

#: src/design-patterns/hal/predictability.md:7
msgid ""
"All peripherals to which the HAL adds functionality should be wrapped in a "
"new type, even if no additional fields are required for that functionality."
msgstr ""
"HALì´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ëª¨ë“  ì£¼ë³€ ì¥ì¹˜ëŠ” ì¶”ê°€ í•„ë“œê°€ í•„ìš”í•˜ì§€ ì•Šë”ë¼ë„ ìƒˆ íƒ€ì…ìœ¼ë¡œ "
"ë˜í•‘ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/predictability.md:10
msgid "Extension traits implemented for the raw peripheral should be avoided."
msgstr "ì›ì‹œ ì£¼ë³€ ì¥ì¹˜ì— êµ¬í˜„ëœ í™•ì¥ íŠ¸ë ˆì´íŠ¸ëŠ” í”¼í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/predictability.md:12
msgid "<a id=\"c-inline\"></a>"
msgstr "<a id=\"c-inline\"></a>"

#: src/design-patterns/hal/predictability.md:13
msgid "Methods are decorated with `#[inline]` where appropriate (C-INLINE)"
msgstr "ë©”ì„œë“œëŠ” ì ì ˆí•œ ê²½ìš° `#[inline]`ìœ¼ë¡œ ì¥ì‹ë©ë‹ˆë‹¤ (C-INLINE)"

#: src/design-patterns/hal/predictability.md:15
msgid ""
"The Rust compiler does not by default perform full inlining across crate "
"boundaries. As embedded applications are sensitive to unexpected code size "
"increases, `#[inline]` should be used to guide the compiler as follows:"
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í¬ë ˆì´íŠ¸ ê²½ê³„ë¥¼ ë„˜ì–´ ì „ì²´ ì¸ë¼ì´ë‹ì„ ìˆ˜í–‰í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. ì„ë² ë””ë“œ ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ì˜ˆê¸°ì¹˜ ì•Šì€ ì½”ë“œ í¬ê¸° ì¦ê°€ì— ë¯¼ê°í•˜ë¯€ë¡œ, "
"`#[inline]`ì€ ë‹¤ìŒê³¼ ê°™ì´ ì»´íŒŒì¼ëŸ¬ë¥¼ ì•ˆë‚´í•˜ëŠ” ë° ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/design-patterns/hal/predictability.md:19
msgid ""
"All \"small\" functions should be marked `#[inline]`. What qualifies as "
"\"small\" is subjective, but generally all functions that are expected to "
"compile down to single-digit instruction sequences qualify as small."
msgstr ""
"ëª¨ë“  \"ì‘ì€\" í•¨ìˆ˜ëŠ” `#[inline]`ìœ¼ë¡œ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤. \"ì‘ì€\" ê²ƒìœ¼ë¡œ "
"ê°„ì£¼ë˜ëŠ” ê¸°ì¤€ì€ ì£¼ê´€ì ì´ì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ í•œ ìë¦¿ìˆ˜ ëª…ë ¹ì–´ ì‹œí€€ìŠ¤ë¡œ ì»´íŒŒì¼ë  "
"ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ëŠ” ëª¨ë“  í•¨ìˆ˜ëŠ” ì‘ì€ ê²ƒìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤."

#: src/design-patterns/hal/predictability.md:22
msgid ""
"Functions that are very likely to take constant values as parameters should "
"be marked as `#[inline]`. This enables the compiler to compute even "
"complicated initialization logic at compile time, provided the function "
"inputs are known."
msgstr ""
"ìƒìˆ˜ ê°’ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì„ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ì€ í•¨ìˆ˜ëŠ” `#[inline]`ìœ¼ë¡œ í‘œì‹œí•´ì•¼ "
"í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ í•¨ìˆ˜ ì…ë ¥ì´ ì•Œë ¤ì§„ ê²½ìš° ì»´íŒŒì¼ëŸ¬ê°€ ë³µì¡í•œ ì´ˆê¸°í™” ë¡œì§ë„ "
"ì»´íŒŒì¼ ì‹œê°„ì— ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:1
msgid "Recommendations for GPIO Interfaces"
msgstr "GPIO ì¸í„°í˜ì´ìŠ¤ ê¶Œì¥ ì‚¬í•­"

#: src/design-patterns/hal/gpio.md:3
msgid "<a id=\"c-zst-pin\"></a>"
msgstr "<a id=\"c-zst-pin\"></a>"

#: src/design-patterns/hal/gpio.md:4
msgid "Pin types are zero-sized by default (C-ZST-PIN)"
msgstr "í•€ íƒ€ì…ì€ ê¸°ë³¸ì ìœ¼ë¡œ ì œë¡œ í¬ê¸°ì…ë‹ˆë‹¤ (C-ZST-PIN)"

#: src/design-patterns/hal/gpio.md:6
msgid ""
"GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types "
"for each pin on every interface or port, resulting in a zero-cost GPIO "
"abstraction when all pin assignments are statically known."
msgstr ""
"HALì´ ë…¸ì¶œí•˜ëŠ” GPIO ì¸í„°í˜ì´ìŠ¤ëŠ” ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ ë˜ëŠ” í¬íŠ¸ì˜ ê° í•€ì— ëŒ€í•´ "
"ì „ìš© ì œë¡œ í¬ê¸° íƒ€ì…ì„ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ëª¨ë“  í•€ í• ë‹¹ì´ ì •ì ìœ¼ë¡œ ì•Œë ¤ì§„ "
"ê²½ìš° ì œë¡œ ë¹„ìš© GPIO ì¶”ìƒí™”ë¥¼ ì´ˆë˜í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:10
msgid ""
"Each GPIO Interface or Port should implement a `split` method returning a "
"struct with every pin."
msgstr ""
"ê° GPIO ì¸í„°í˜ì´ìŠ¤ ë˜ëŠ” í¬íŠ¸ëŠ” ëª¨ë“  í•€ì„ í¬í•¨í•˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ë°˜í™˜í•˜ëŠ” `split` "
"ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:13
msgid "Example:"
msgstr "ì˜ˆì‹œ:"

#: src/design-patterns/hal/gpio.md:39
msgid "<a id=\"c-erased-pin\"></a>"
msgstr "<a id=\"c-erased-pin\"></a>"

#: src/design-patterns/hal/gpio.md:40
msgid "Pin types provide methods to erase pin and port (C-ERASED-PIN)"
msgstr "í•€ íƒ€ì…ì€ í•€ê³¼ í¬íŠ¸ë¥¼ ì§€ìš°ëŠ” ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤ (C-ERASED-PIN)"

#: src/design-patterns/hal/gpio.md:42
msgid ""
"Pins should provide type erasure methods that move their properties from "
"compile time to runtime, and allow more flexibility in applications."
msgstr ""
"í•€ì€ ì»´íŒŒì¼ íƒ€ì„ì—ì„œ ëŸ°íƒ€ì„ìœ¼ë¡œ ì†ì„±ì„ ì´ë™í•˜ê³  ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë” ë§ì€ "
"ìœ ì—°ì„±ì„ í—ˆìš©í•˜ëŠ” íƒ€ì… ì†Œê±° ë©”ì„œë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:48
msgid "/// Port A, pin 0.\n"
msgstr "/// í¬íŠ¸ A, í•€ 0.\n"

#: src/design-patterns/hal/gpio.md:56
msgid "/// A pin on port A.\n"
msgstr "/// í¬íŠ¸ Aì˜ í•€.\n"

#: src/design-patterns/hal/gpio.md:59
msgid "/// The pin number.\n"
msgstr "/// í•€ ë²ˆí˜¸.\n"

#: src/design-patterns/hal/gpio.md:75
msgid "// (these fields can be packed to reduce the memory footprint)\n"
msgstr "// (ì´ í•„ë“œë“¤ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê¸° ìœ„í•´ ì••ì¶•ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤)\n"

#: src/design-patterns/hal/gpio.md:86
msgid "<a id=\"c-pin-state\"></a>"
msgstr "<a id=\"c-pin-state\"></a>"

#: src/design-patterns/hal/gpio.md:87
msgid "Pin state should be encoded as type parameters (C-PIN-STATE)"
msgstr "í•€ ìƒíƒœëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¡œ ì¸ì½”ë”©ë˜ì–´ì•¼ í•©ë‹ˆë‹¤ (C-PIN-STATE)"

#: src/design-patterns/hal/gpio.md:89
msgid ""
"Pins may be configured as input or output with different characteristics "
"depending on the chip or family. This state should be encoded in the type "
"system to prevent use of pins in incorrect states."
msgstr ""
"í•€ì€ ì¹© ë˜ëŠ” ì œí’ˆêµ°ì— ë”°ë¼ ë‹¤ë¥¸ íŠ¹ì„±ì„ ê°€ì§„ ì…ë ¥ ë˜ëŠ” ì¶œë ¥ìœ¼ë¡œ êµ¬ì„±ë  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ ìƒíƒœëŠ” ì˜ëª»ëœ ìƒíƒœì˜ í•€ ì‚¬ìš©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ íƒ€ì… ì‹œìŠ¤í…œì— "
"ì¸ì½”ë”©ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:93
msgid ""
"Additional, chip-specific state (eg. drive strength) may also be encoded in "
"this way, using additional type parameters."
msgstr ""
"ì¶”ê°€ì ì¸ ì¹©ë³„ ìƒíƒœ(ì˜ˆ: êµ¬ë™ ê°•ë„)ë„ ì¶”ê°€ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ëŸ¬í•œ "
"ë°©ì‹ìœ¼ë¡œ ì¸ì½”ë”©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:96
msgid ""
"Methods for changing the pin state should be provided as `into_input` and "
"`into_output` methods."
msgstr ""
"í•€ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ë©”ì„œë“œëŠ” `into_input` ë° `into_output` ë©”ì„œë“œë¡œ "
"ì œê³µë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:99
msgid ""
"Additionally, `with_{input,output}_state` methods should be provided that "
"temporarily reconfigure a pin in a different state without moving it."
msgstr ""
"ë˜í•œ í•€ì„ ì´ë™í•˜ì§€ ì•Šê³  ë‹¤ë¥¸ ìƒíƒœë¡œ ì¼ì‹œì ìœ¼ë¡œ ì¬êµ¬ì„±í•˜ëŠ” `with_{input,output}_state` "
"ë©”ì„œë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:102
msgid ""
"The following methods should be provided for every pin type (that is, both "
"erased and non-erased pin types should provide the same API):"
msgstr ""
"ëª¨ë“  í•€ íƒ€ì…ì— ëŒ€í•´ ë‹¤ìŒ ë©”ì„œë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤ (ì¦‰, ì‚­ì œëœ í•€ íƒ€ì…ê³¼ "
"ì‚­ì œë˜ì§€ ì•Šì€ í•€ íƒ€ì… ëª¨ë‘ ë™ì¼í•œ APIë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤):"

#: src/design-patterns/hal/gpio.md:105
msgid "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"
msgstr "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"

#: src/design-patterns/hal/gpio.md:106
msgid "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"
msgstr "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"

#: src/design-patterns/hal/gpio.md:123
msgid ""
"Pin state should be bounded by sealed traits. Users of the HAL should have "
"no need to add their own state. The traits can provide HAL-specific methods "
"required to implement the pin state API."
msgstr ""
"í•€ ìƒíƒœëŠ” ë´‰ì¸ëœ íŠ¸ë ˆì´íŠ¸ë¡œ ì œí•œë˜ì–´ì•¼ í•©ë‹ˆë‹¤. HAL ì‚¬ìš©ìëŠ” ìì‹ ì˜ ìƒíƒœë¥¼ "
"ì¶”ê°€í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. íŠ¸ë ˆì´íŠ¸ëŠ” í•€ ìƒíƒœ APIë¥¼ êµ¬í˜„í•˜ëŠ” ë° í•„ìš”í•œ HAL ê´€ë ¨ "
"ë©”ì„œë“œë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/design-patterns/hal/gpio.md:203
msgid "// Same for `PA` and `Pin`, and other pin types.\n"
msgstr "// `PA`ì™€ `Pin` ë° ê¸°íƒ€ í•€ íƒ€ì…ì— ëŒ€í•´ì„œë„ ë™ì¼í•©ë‹ˆë‹¤.\n"

#: src/c-tips/index.md:3
msgid ""
"This chapter collects a variety of tips that might be useful to experienced "
"embedded C developers looking to start writing Rust. It will especially "
"highlight how things you might already be used to in C are different in Rust."
msgstr ""
"ì´ ì¥ì—ì„œëŠ” Rust ì‘ì„±ì„ ì‹œì‘í•˜ë ¤ëŠ” ìˆ™ë ¨ëœ ì„ë² ë””ë“œ C ê°œë°œìì—ê²Œ ìœ ìš©í•  ìˆ˜ "
"ìˆëŠ” ë‹¤ì–‘í•œ íŒì„ ìˆ˜ì§‘í•©ë‹ˆë‹¤. íŠ¹íˆ Cì—ì„œ ì´ë¯¸ ìµìˆ™í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤ì´ Rustì—ì„œ "
"ì–´ë–»ê²Œ ë‹¤ë¥¸ì§€ ê°•ì¡°í•  ê²ƒì…ë‹ˆë‹¤."

#: src/c-tips/index.md:7
msgid "Preprocessor"
msgstr "ì „ì²˜ë¦¬ê¸°"

#: src/c-tips/index.md:9
msgid ""
"In embedded C it is very common to use the preprocessor for a variety of "
"purposes, such as:"
msgstr "ì„ë² ë””ë“œ Cì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¤ì–‘í•œ ëª©ì ìœ¼ë¡œ ì „ì²˜ë¦¬ê¸°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¼ë°˜ì ì…ë‹ˆë‹¤."

#: src/c-tips/index.md:12
msgid "Compile-time selection of code blocks with `#ifdef`"
msgstr "`#ifdef`ë¥¼ ì‚¬ìš©í•œ ì»´íŒŒì¼ íƒ€ì„ ì½”ë“œ ë¸”ë¡ ì„ íƒ"

#: src/c-tips/index.md:13
msgid "Compile-time array sizes and computations"
msgstr "ì»´íŒŒì¼ íƒ€ì„ ë°°ì—´ í¬ê¸° ë° ê³„ì‚°"

#: src/c-tips/index.md:14
msgid "Macros to simplify common patterns (to avoid function call overhead)"
msgstr "ì¼ë°˜ì ì¸ íŒ¨í„´ì„ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•œ ë§¤í¬ë¡œ (í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œë¥¼ í”¼í•˜ê¸° ìœ„í•´)"

#: src/c-tips/index.md:16
msgid ""
"In Rust there is no preprocessor, and so many of these use cases are "
"addressed differently. In the rest of this section we cover various "
"alternatives to using the preprocessor."
msgstr ""
"Rustì—ëŠ” ì „ì²˜ë¦¬ê¸°ê°€ ì—†ìœ¼ë¯€ë¡œ ì´ëŸ¬í•œ ë§ì€ ì‚¬ìš© ì‚¬ë¡€ê°€ ë‹¤ë¥´ê²Œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ì´ "
"ì„¹ì…˜ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œëŠ” ì „ì²˜ë¦¬ê¸° ì‚¬ìš©ì— ëŒ€í•œ ë‹¤ì–‘í•œ ëŒ€ì•ˆì„ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/c-tips/index.md:20
msgid "Compile-Time Code Selection"
msgstr "ì»´íŒŒì¼ íƒ€ì„ ì½”ë“œ ì„ íƒ"

#: src/c-tips/index.md:22
msgid ""
"The closest match to `#ifdef ... #endif` in Rust are [Cargo features]"
"(https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-"
"section). These are a little more formal than the C preprocessor: all "
"possible features are explicitly listed per crate, and can only be either on "
"or off. Features are turned on when you list a crate as a dependency, and "
"are additive: if any crate in your dependency tree enables a feature for "
"another crate, that feature will be enabled for all users of that crate."
msgstr ""
"Rustì—ì„œ `#ifdef ... #endif`ì™€ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒì€ [Cargo ê¸°ëŠ¥](https://doc.rust-"
"lang.org/cargo/reference/manifest.html#the-features-section)ì…ë‹ˆë‹¤. ì´ê²ƒë“¤ì€ C "
"ì „ì²˜ë¦¬ê¸°ë³´ë‹¤ ì•½ê°„ ë” í˜•ì‹ì ì…ë‹ˆë‹¤. ëª¨ë“  ê°€ëŠ¥í•œ ê¸°ëŠ¥ì€ í¬ë ˆì´íŠ¸ë³„ë¡œ ëª…ì‹œì ìœ¼ë¡œ "
"ë‚˜ì—´ë˜ë©° ì¼œê±°ë‚˜ ëŒ ìˆ˜ë§Œ ìˆìŠµë‹ˆë‹¤. ê¸°ëŠ¥ì€ í¬ë ˆì´íŠ¸ë¥¼ ì¢…ì†ì„±ìœ¼ë¡œ ë‚˜ì—´í•  ë•Œ "
"ì¼œì§€ë©° ì¶”ê°€ì ì…ë‹ˆë‹¤. ì¢…ì†ì„± íŠ¸ë¦¬ì˜ ëª¨ë“  í¬ë ˆì´íŠ¸ê°€ ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ì— ëŒ€í•œ ê¸°ëŠ¥ì„ "
"í™œì„±í™”í•˜ë©´ í•´ë‹¹ ê¸°ëŠ¥ì€ í•´ë‹¹ í¬ë ˆì´íŠ¸ì˜ ëª¨ë“  ì‚¬ìš©ìì—ê²Œ í™œì„±í™”ë©ë‹ˆë‹¤."

#: src/c-tips/index.md:31
msgid ""
"For example, you might have a crate which provides a library of signal "
"processing primitives. Each one might take some extra time to compile or "
"declare some large table of constants which you'd like to avoid. You could "
"declare a Cargo feature for each component in your `Cargo.toml`:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, ì‹ í˜¸ ì²˜ë¦¬ ê¸°ë³¸ ìš”ì†Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•˜ëŠ” í¬ë ˆì´íŠ¸ê°€ ìˆì„ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ê° ê¸°ë³¸ ìš”ì†ŒëŠ” ì»´íŒŒì¼í•˜ëŠ” ë° ì¶”ê°€ ì‹œê°„ì´ ê±¸ë¦¬ê±°ë‚˜ í”¼í•˜ê³  ì‹¶ì€ í° "
"ìƒìˆ˜ í…Œì´ë¸”ì„ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `Cargo.toml`ì—ì„œ ê° êµ¬ì„± ìš”ì†Œì— ëŒ€í•œ Cargo "
"ê¸°ëŠ¥ì„ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:42
msgid ""
"Then, in your code, use `#[cfg(feature=\"FIR\")]` to control what is "
"included."
msgstr "ê·¸ëŸ° ë‹¤ìŒ ì½”ë“œì—ì„œ `#[cfg(feature=\"FIR\")]`ì„ ì‚¬ìš©í•˜ì—¬ í¬í•¨í•  ë‚´ìš©ì„ ì œì–´í•©ë‹ˆë‹¤."

#: src/c-tips/index.md:45
msgid "/// In your top-level lib.rs\n"
msgstr "/// ìµœìƒìœ„ lib.rsì—ì„œ\n"

#: src/c-tips/index.md:47
msgid "\"FIR\""
msgstr "\"FIR\""

#: src/c-tips/index.md:50
msgid "\"IIR\""
msgstr "\"IIR\""

#: src/c-tips/index.md:54
msgid ""
"You can similarly include code blocks only if a feature is _not_ enabled, or "
"if any combination of features are or are not enabled."
msgstr ""
"ë§ˆì°¬ê°€ì§€ë¡œ ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì§€ _ì•Šì€_ ê²½ìš°ì—ë§Œ ì½”ë“œ ë¸”ë¡ì„ í¬í•¨í•˜ê±°ë‚˜ ê¸°ëŠ¥ì˜ "
"ì¡°í•©ì´ í™œì„±í™”ë˜ê±°ë‚˜ í™œì„±í™”ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:57
msgid ""
"Additionally, Rust provides a number of automatically-set conditions you can "
"use, such as `target_arch` to select different code based on architecture. "
"For full details of the conditional compilation support, refer to the "
"[conditional compilation](https://doc.rust-lang.org/reference/conditional-"
"compilation.html) chapter of the Rust reference."
msgstr ""
"ë˜í•œ RustëŠ” ì•„í‚¤í…ì²˜ì— ë”°ë¼ ë‹¤ë¥¸ ì½”ë“œë¥¼ ì„ íƒí•˜ê¸° ìœ„í•´ `target_arch`ì™€ ê°™ì´ "
"ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ ê°€ì§€ ìë™ìœ¼ë¡œ ì„¤ì •ëœ ì¡°ê±´ì„ ì œê³µí•©ë‹ˆë‹¤. ì¡°ê±´ë¶€ ì»´íŒŒì¼ "
"ì§€ì›ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ Rust ì°¸ì¡°ì˜ [ì¡°ê±´ë¶€ ì»´íŒŒì¼](https://doc.rust-"
"lang.org/reference/conditional-compilation.html) ì¥ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/c-tips/index.md:64
msgid ""
"The conditional compilation will only apply to the next statement or block. "
"If a block can not be used in the current scope then the `cfg` attribute "
"will need to be used multiple times.  It's worth noting that most of the "
"time it is better to simply include all the code and allow the compiler to "
"remove dead code when optimising: it's simpler for you and your users, and "
"in general the compiler will do a good job of removing unused code."
msgstr ""
"ì¡°ê±´ë¶€ ì»´íŒŒì¼ì€ ë‹¤ìŒ ë¬¸ì¥ì´ë‚˜ ë¸”ë¡ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. í˜„ì¬ ë²”ìœ„ì—ì„œ ë¸”ë¡ì„ "
"ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° `cfg` ì†ì„±ì„ ì—¬ëŸ¬ ë²ˆ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ëª¨ë“  "
"ì½”ë“œë¥¼ í¬í•¨í•˜ê³  ì»´íŒŒì¼ëŸ¬ê°€ ìµœì í™”í•  ë•Œ ì£½ì€ ì½”ë“œë¥¼ ì œê±°í•˜ë„ë¡ í—ˆìš©í•˜ëŠ” ê²ƒì´ ë” "
"ë‚«ë‹¤ëŠ” ì ì€ ì£¼ëª©í•  ê°€ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì‚¬ìš©ìì™€ ì‚¬ìš©ìì—ê²Œ ë” ê°„ë‹¨í•˜ë©° "
"ì¼ë°˜ì ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì½”ë“œë¥¼ ì œê±°í•˜ëŠ” ë° ì¢‹ì€ ì—­í• ì„ í•©ë‹ˆë‹¤."

#: src/c-tips/index.md:71
msgid "Compile-Time Sizes and Computation"
msgstr "ì»´íŒŒì¼ íƒ€ì„ í¬ê¸° ë° ê³„ì‚°"

#: src/c-tips/index.md:73
msgid ""
"Rust supports `const fn`, functions which are guaranteed to be evaluable at "
"compile-time and can therefore be used where constants are required, such as "
"in the size of arrays. This can be used alongside features mentioned above, "
"for example:"
msgstr ""
"RustëŠ” ì»´íŒŒì¼ íƒ€ì„ì— í‰ê°€ë  ìˆ˜ ìˆìŒì´ ë³´ì¥ë˜ëŠ” í•¨ìˆ˜ì¸ `const fn`ì„ "
"ì§€ì›í•˜ë¯€ë¡œ ë°°ì—´ í¬ê¸°ì™€ ê°™ì´ ìƒìˆ˜ê°€ í•„ìš”í•œ ê³³ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ "
"ìœ„ì—ì„œ ì–¸ê¸‰í•œ ê¸°ëŠ¥ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/c-tips/index.md:80 src/c-tips/index.md:82
msgid "\"use_more_ram\""
msgstr "\"use_more_ram\""

#: src/c-tips/index.md:89
msgid ""
"These are new to stable Rust as of 1.31, so documentation is still sparse. "
"The functionality available to `const fn` is also very limited at the time "
"of writing; in future Rust releases it is expected to expand on what is "
"permitted in a `const fn`."
msgstr ""
"ì´ê²ƒë“¤ì€ 1.31ë¶€í„° ì•ˆì •ì ì¸ Rustì— ìƒˆë¡œ ì¶”ê°€ë˜ì—ˆìœ¼ë¯€ë¡œ ë¬¸ì„œëŠ” ì•„ì§ "
"ë¶€ì¡±í•©ë‹ˆë‹¤. ì´ ê¸€ì„ ì“°ëŠ” ì‹œì ì—ì„œ `const fn`ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ë„ ë§¤ìš° "
"ì œí•œì ì…ë‹ˆë‹¤. í–¥í›„ Rust ë¦´ë¦¬ìŠ¤ì—ì„œëŠ” `const fn`ì—ì„œ í—ˆìš©ë˜ëŠ” ë‚´ìš©ì´ í™•ì¥ë  "
"ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤."

#: src/c-tips/index.md:94
msgid "Macros"
msgstr "ë§¤í¬ë¡œ"

#: src/c-tips/index.md:96
msgid ""
"Rust provides an extremely powerful [macro system](https://doc.rust-lang.org/"
"book/ch19-06-macros.html). While the C preprocessor operates almost directly "
"on the text of your source code, the Rust macro system operates at a higher "
"level. There are two varieties of Rust macro: _macros by example_ and "
"_procedural macros_. The former are simpler and most common; they look like "
"function calls and can expand to a complete expression, statement, item, or "
"pattern. Procedural macros are more complex but permit extremely powerful "
"additions to the Rust language: they can transform arbitrary Rust syntax "
"into new Rust syntax."
msgstr ""
"RustëŠ” ë§¤ìš° ê°•ë ¥í•œ [ë§¤í¬ë¡œ ì‹œìŠ¤í…œ](https://doc.rust-lang.org/book/ch19-06-"
"macros.html)ì„ ì œê³µí•©ë‹ˆë‹¤. C ì „ì²˜ë¦¬ê¸°ëŠ” ì†ŒìŠ¤ ì½”ë“œì˜ í…ìŠ¤íŠ¸ì— ê±°ì˜ ì§ì ‘ì ìœ¼ë¡œ "
"ì‘ë™í•˜ëŠ” ë°˜ë©´, Rust ë§¤í¬ë¡œ ì‹œìŠ¤í…œì€ ë” ë†’ì€ ìˆ˜ì¤€ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤. Rust "
"ë§¤í¬ë¡œì—ëŠ” _ì˜ˆì œë³„ ë§¤í¬ë¡œ_ì™€ _ì ˆì°¨ì  ë§¤í¬ë¡œ_ì˜ ë‘ ê°€ì§€ ì¢…ë¥˜ê°€ ìˆìŠµë‹ˆë‹¤. "
"ì „ìëŠ” ë” ê°„ë‹¨í•˜ê³  ê°€ì¥ ì¼ë°˜ì ì…ë‹ˆë‹¤. í•¨ìˆ˜ í˜¸ì¶œì²˜ëŸ¼ ë³´ì´ë©° ì™„ì „í•œ í‘œí˜„ì‹, "
"ë¬¸ì¥, í•­ëª© ë˜ëŠ” íŒ¨í„´ìœ¼ë¡œ í™•ì¥ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì ˆì°¨ì  ë§¤í¬ë¡œëŠ” ë” ë³µì¡í•˜ì§€ë§Œ "
"Rust ì–¸ì–´ì— ë§¤ìš° ê°•ë ¥í•œ ì¶”ê°€ ê¸°ëŠ¥ì„ í—ˆìš©í•©ë‹ˆë‹¤. ì„ì˜ì˜ Rust êµ¬ë¬¸ì„ ìƒˆë¡œìš´ "
"Rust êµ¬ë¬¸ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:107
msgid ""
"In general, where you might have used a C preprocessor macro, you probably "
"want to see if a macro-by-example can do the job instead. They can be "
"defined in your crate and easily used by your own crate or exported for "
"other users. Be aware that since they must expand to complete expressions, "
"statements, items, or patterns, some use cases of C preprocessor macros will "
"not work, for example a macro that expands to part of a variable name or an "
"incomplete set of items in a list."
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ C ì „ì²˜ë¦¬ê¸° ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í–ˆì„ ìˆ˜ ìˆëŠ” ê³³ì—ì„œëŠ” ëŒ€ì‹  ì˜ˆì œë³„ "
"ë§¤í¬ë¡œê°€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. í¬ë ˆì´íŠ¸ì—ì„œ "
"ì •ì˜í•˜ê³  ìì‹ ì˜ í¬ë ˆì´íŠ¸ì—ì„œ ì‰½ê²Œ ì‚¬ìš©í•˜ê±°ë‚˜ ë‹¤ë¥¸ ì‚¬ìš©ìë¥¼ ìœ„í•´ ë‚´ë³´ë‚¼ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì™„ì „í•œ í‘œí˜„ì‹, ë¬¸ì¥, í•­ëª© ë˜ëŠ” íŒ¨í„´ìœ¼ë¡œ í™•ì¥ë˜ì–´ì•¼ í•˜ë¯€ë¡œ ë³€ìˆ˜ "
"ì´ë¦„ì˜ ì¼ë¶€ë‚˜ ëª©ë¡ì˜ ë¶ˆì™„ì „í•œ í•­ëª© ì§‘í•©ìœ¼ë¡œ í™•ì¥ë˜ëŠ” ë§¤í¬ë¡œì™€ ê°™ì€ C "
"ì „ì²˜ë¦¬ê¸° ë§¤í¬ë¡œì˜ ì¼ë¶€ ì‚¬ìš© ì‚¬ë¡€ëŠ” ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì‹­ì‹œì˜¤."

#: src/c-tips/index.md:115
msgid ""
"As with Cargo features, it is worth considering if you even need the macro. "
"In many cases a regular function is easier to understand and will be inlined "
"to the same code as a macro. The `#[inline]` and `#[inline(always)]` "
"[attributes](https://doc.rust-lang.org/reference/attributes.html#inline-"
"attribute) give you further control over this process, although care should "
"be taken here as well â€” the compiler will automatically inline functions "
"from the same crate where appropriate, so forcing it to do so "
"inappropriately might actually lead to decreased performance."
msgstr ""
"Cargo ê¸°ëŠ¥ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë§¤í¬ë¡œê°€ í•„ìš”í•œì§€ ì—¬ë¶€ë¥¼ ê³ ë ¤í•´ ë³¼ ê°€ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤. "
"ë§ì€ ê²½ìš° ì¼ë°˜ í•¨ìˆ˜ê°€ ë” ì´í•´í•˜ê¸° ì‰½ê³  ë§¤í¬ë¡œì™€ ë™ì¼í•œ ì½”ë“œë¡œ ì¸ë¼ì¸ë©ë‹ˆë‹¤. "
"`#[inline]` ë° `#[inline(always)]` [ì†ì„±](https://doc.rust-lang.org/reference/"
"attributes.html#inline-attribute)ì€ ì´ í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•œ ì¶”ê°€ ì œì–´ë¥¼ "
"ì œê³µí•˜ì§€ë§Œ ì—¬ê¸°ì—ì„œë„ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì ì ˆí•œ ê²½ìš° ë™ì¼í•œ "
"í¬ë ˆì´íŠ¸ì˜ í•¨ìˆ˜ë¥¼ ìë™ìœ¼ë¡œ ì¸ë¼ì¸í•˜ë¯€ë¡œ ë¶€ì ì ˆí•˜ê²Œ ê°•ì œí•˜ë©´ ì‹¤ì œë¡œ ì„±ëŠ¥ì´ "
"ì €í•˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:125
msgid ""
"Explaining the entire Rust macro system is out of scope for this tips page, "
"so you are encouraged to consult the Rust documentation for full details."
msgstr ""
"ì „ì²´ Rust ë§¤í¬ë¡œ ì‹œìŠ¤í…œì„ ì„¤ëª…í•˜ëŠ” ê²ƒì€ ì´ íŒ í˜ì´ì§€ì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë¯€ë¡œ "
"ìì„¸í•œ ë‚´ìš©ì€ Rust ì„¤ëª…ì„œë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:128
msgid "Build System"
msgstr "ë¹Œë“œ ì‹œìŠ¤í…œ"

#: src/c-tips/index.md:130
msgid ""
"Most Rust crates are built using Cargo (although it is not required). This "
"takes care of many difficult problems with traditional build systems. "
"However, you may wish to customise the build process. Cargo provides "
"[`build.rs` scripts](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html) for this purpose. They are Rust scripts which can interact "
"with the Cargo build system as required."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ Rust í¬ë ˆì´íŠ¸ëŠ” Cargoë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹Œë“œë©ë‹ˆë‹¤(í•„ìˆ˜ëŠ” ì•„ë‹˜). ì´ê²ƒì€ "
"ì „í†µì ì¸ ë¹Œë“œ ì‹œìŠ¤í…œì˜ ë§ì€ ì–´ë ¤ìš´ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë¹Œë“œ í”„ë¡œì„¸ìŠ¤ë¥¼ "
"ì‚¬ìš©ì ì •ì˜í•˜ê³  ì‹¶ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. CargoëŠ” ì´ ëª©ì ì„ ìœ„í•´ [`build.rs` "
"ìŠ¤í¬ë¦½íŠ¸](https://doc.rust-lang.org/cargo/reference/build-scripts.html)ë¥¼ "
"ì œê³µí•©ë‹ˆë‹¤. ì´ë“¤ì€ í•„ìš”ì— ë”°ë¼ Cargo ë¹Œë“œ ì‹œìŠ¤í…œê³¼ ìƒí˜¸ ì‘ìš©í•  ìˆ˜ ìˆëŠ” Rust "
"ìŠ¤í¬ë¦½íŠ¸ì…ë‹ˆë‹¤."

#: src/c-tips/index.md:138
msgid "Common use cases for build scripts include:"
msgstr "ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸ì˜ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:140
msgid ""
"provide build-time information, for example statically embedding the build "
"date or Git commit hash into your executable"
msgstr ""
"ë¹Œë“œ ì‹œê°„ ì •ë³´ ì œê³µ, ì˜ˆë¥¼ ë“¤ì–´ ë¹Œë“œ ë‚ ì§œ ë˜ëŠ” Git ì»¤ë°‹ í•´ì‹œë¥¼ ì‹¤í–‰ íŒŒì¼ì— "
"ì •ì ìœ¼ë¡œ í¬í•¨"

#: src/c-tips/index.md:142
msgid ""
"generate linker scripts at build time depending on selected features or "
"other logic"
msgstr "ì„ íƒëœ ê¸°ëŠ¥ ë˜ëŠ” ê¸°íƒ€ ë¡œì§ì— ë”°ë¼ ë¹Œë“œ ì‹œ ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"

#: src/c-tips/index.md:144
msgid "change the Cargo build configuration"
msgstr "Cargo ë¹Œë“œ êµ¬ì„± ë³€ê²½"

#: src/c-tips/index.md:145
msgid "add extra static libraries to link against"
msgstr "ë§í¬í•  ì¶”ê°€ ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€"

#: src/c-tips/index.md:147
msgid ""
"At present there is no support for post-build scripts, which you might "
"traditionally have used for tasks like automatic generation of binaries from "
"the build objects or printing build information."
msgstr ""
"í˜„ì¬ ë¹Œë“œ í›„ ìŠ¤í¬ë¦½íŠ¸ì— ëŒ€í•œ ì§€ì›ì€ ì—†ìŠµë‹ˆë‹¤. ì´ëŠ” ë¹Œë“œ ê°ì²´ì—ì„œ ë°”ì´ë„ˆë¦¬ë¥¼ "
"ìë™ìœ¼ë¡œ ìƒì„±í•˜ê±°ë‚˜ ë¹Œë“œ ì •ë³´ë¥¼ ì¸ì‡„í•˜ëŠ” ê²ƒê³¼ ê°™ì€ ì‘ì—…ì— ì „í†µì ìœ¼ë¡œ ì‚¬ìš©í–ˆì„ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:151
msgid "Cross-Compiling"
msgstr "í¬ë¡œìŠ¤ ì»´íŒŒì¼"

#: src/c-tips/index.md:153
msgid ""
"Using Cargo for your build system also simplifies cross-compiling. In most "
"cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a "
"suitable executable in `target/thumbv6m-none-eabi/debug/myapp`."
msgstr ""
"ë¹Œë“œ ì‹œìŠ¤í…œìœ¼ë¡œ Cargoë¥¼ ì‚¬ìš©í•˜ë©´ í¬ë¡œìŠ¤ ì»´íŒŒì¼ë„ ë‹¨ìˆœí™”ë©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ê²½ìš° "
"Cargoì— `--target thumbv6m-none-eabi`ë¥¼ ì•Œë ¤ì£¼ê³  `target/thumbv6m-none-eabi/"
"debug/myapp`ì—ì„œ ì ì ˆí•œ ì‹¤í–‰ íŒŒì¼ì„ ì°¾ìœ¼ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤."

#: src/c-tips/index.md:157
msgid ""
"For platforms not natively supported by Rust, you will need to build "
"`libcore` for that target yourself. On such platforms, [Xargo](https://"
"github.com/japaric/xargo) can be used as a stand-in for Cargo which "
"automatically builds `libcore` for you."
msgstr ""
"Rustì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ì§€ì›í•˜ì§€ ì•ŠëŠ” í”Œë«í¼ì˜ ê²½ìš° í•´ë‹¹ ëŒ€ìƒì— ëŒ€í•´ `libcore`ë¥¼ "
"ì§ì ‘ ë¹Œë“œí•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ í”Œë«í¼ì—ì„œëŠ” Cargoë¥¼ ëŒ€ì‹ í•˜ì—¬ `libcore`ë¥¼ "
"ìë™ìœ¼ë¡œ ë¹Œë“œí•´ ì£¼ëŠ” [Xargo](https://github.com/japaric/xargo)ë¥¼ ì‚¬ìš©í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:163
msgid "Iterators vs Array Access"
msgstr "ì´í„°ë ˆì´í„° vs ë°°ì—´ ì ‘ê·¼"

#: src/c-tips/index.md:165
msgid "In C you are probably used to accessing arrays directly by their index:"
msgstr "Cì—ì„œëŠ” ì•„ë§ˆë„ ì¸ë±ìŠ¤ë¥¼ í†µí•´ ë°°ì—´ì— ì§ì ‘ ì ‘ê·¼í•˜ëŠ” ë° ìµìˆ™í•  ê²ƒì…ë‹ˆë‹¤."

#: src/c-tips/index.md:175
msgid ""
"In Rust this is an anti-pattern: indexed access can be slower (as it needs "
"to be bounds checked) and may prevent various compiler optimisations. This "
"is an important distinction and worth repeating: Rust will check for out-of-"
"bounds access on manual array indexing to guarantee memory safety, while C "
"will happily index outside the array."
msgstr ""
"Rustì—ì„œëŠ” ì´ê²ƒì´ ì•ˆí‹°íŒ¨í„´ì…ë‹ˆë‹¤. ì¸ë±ìŠ¤ ì ‘ê·¼ì€ ë” ëŠë¦´ ìˆ˜ ìˆê³ (ê²½ê³„ ê²€ì‚¬ê°€ "
"í•„ìš”í•˜ë¯€ë¡œ) ë‹¤ì–‘í•œ ì»´íŒŒì¼ëŸ¬ ìµœì í™”ë¥¼ ë°©í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ì¤‘ìš”í•œ "
"ì°¨ì´ì ì´ë©° ë°˜ë³µí•  ê°€ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤. RustëŠ” ë©”ëª¨ë¦¬ ì•ˆì „ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ìˆ˜ë™ "
"ë°°ì—´ ì¸ë±ì‹±ì—ì„œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì ‘ê·¼ì„ í™•ì¸í•˜ëŠ” ë°˜ë©´, CëŠ” ë°°ì—´ ì™¸ë¶€ë¥¼ ê¸°êº¼ì´ "
"ì¸ë±ì‹±í•©ë‹ˆë‹¤."

#: src/c-tips/index.md:181
msgid "Instead, use iterators:"
msgstr "ëŒ€ì‹  ì´í„°ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:"

#: src/c-tips/index.md:190
msgid ""
"Iterators provide a powerful array of functionality you would have to "
"implement manually in C, such as chaining, zipping, enumerating, finding the "
"min or max, summing, and more. Iterator methods can also be chained, giving "
"very readable data processing code."
msgstr ""
"ì´í„°ë ˆì´í„°ëŠ” Cì—ì„œ ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì—°ê²°, ì••ì¶•, ì—´ê±°, ìµœì†Œ ë˜ëŠ” ìµœëŒ€ "
"ì°¾ê¸°, í•©ê³„ ë“±ê³¼ ê°™ì€ ê°•ë ¥í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ì´í„°ë ˆì´í„° ë©”ì„œë“œëŠ” ë˜í•œ "
"ì—°ê²°ë  ìˆ˜ ìˆì–´ ë§¤ìš° ì½ê¸° ì‰¬ìš´ ë°ì´í„° ì²˜ë¦¬ ì½”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/c-tips/index.md:195
msgid ""
"See the [Iterators in the Book](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html) and [Iterator documentation](https://doc.rust-lang.org/core/"
"iter/trait.Iterator.html) for more details."
msgstr ""

#: src/c-tips/index.md:200
msgid "References vs Pointers"
msgstr "ì°¸ì¡° vs í¬ì¸í„°"

#: src/c-tips/index.md:202
msgid ""
"In Rust, pointers (called [_raw pointers_](https://doc.rust-lang.org/book/"
"ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer)) exist but are only "
"used in specific circumstances, as dereferencing them is always considered "
"`unsafe` -- Rust cannot provide its usual guarantees about what might be "
"behind the pointer."
msgstr ""
"Rustì—ì„œ í¬ì¸í„°([_ì›ì‹œ í¬ì¸í„°_](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#dereferencing-a-raw-pointer)ë¼ê³  ë¶ˆë¦¼)ëŠ” ì¡´ì¬í•˜ì§€ë§Œ, ì—­ì°¸ì¡°í•˜ëŠ” "
"ê²ƒì´ í•­ìƒ `unsafe`ë¡œ ê°„ì£¼ë˜ë¯€ë¡œ íŠ¹ì • ìƒí™©ì—ì„œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤. RustëŠ” í¬ì¸í„° "
"ë’¤ì— ë¬´ì—‡ì´ ìˆì„ì§€ì— ëŒ€í•œ ì¼ë°˜ì ì¸ ë³´ì¥ì„ ì œê³µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:208
msgid ""
"In most cases, we instead use _references_, indicated by the `&` symbol, or "
"_mutable references_, indicated by `&mut`. References behave similarly to "
"pointers, in that they can be dereferenced to access the underlying values, "
"but they are a key part of Rust's ownership system: Rust will strictly "
"enforce that you may only have one mutable reference _or_ multiple non-"
"mutable references to the same value at any given time."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš°, ìš°ë¦¬ëŠ” ëŒ€ì‹  `&` ê¸°í˜¸ë¡œ í‘œì‹œë˜ëŠ” _ì°¸ì¡°_ ë˜ëŠ” `&mut`ë¡œ í‘œì‹œë˜ëŠ” "
"_ê°€ë³€ ì°¸ì¡°_ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì°¸ì¡°ëŠ” ê¸°ë³¸ ê°’ì— ì ‘ê·¼í•˜ê¸° ìœ„í•´ ì—­ì°¸ì¡°ë  ìˆ˜ ìˆë‹¤ëŠ” "
"ì ì—ì„œ í¬ì¸í„°ì™€ ìœ ì‚¬í•˜ê²Œ ë™ì‘í•˜ì§€ë§Œ, Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¶€ë¶„ì…ë‹ˆë‹¤. "
"RustëŠ” ì£¼ì–´ì§„ ì‹œê°„ì— ë™ì¼í•œ ê°’ì— ëŒ€í•´ í•˜ë‚˜ì˜ ê°€ë³€ ì°¸ì¡° _ë˜ëŠ”_ ì—¬ëŸ¬ ê°œì˜ "
"ë¹„ê°€ë³€ ì°¸ì¡°ë§Œ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ ì—„ê²©í•˜ê²Œ ê°•ì œí•©ë‹ˆë‹¤."

#: src/c-tips/index.md:215
msgid ""
"In practice this means you have to be more careful about whether you need "
"mutable access to data: where in C the default is mutable and you must be "
"explicit about `const`, in Rust the opposite is true."
msgstr ""
"ì‹¤ì œë¡œ ì´ëŠ” ë°ì´í„°ì— ëŒ€í•œ ê°€ë³€ ì ‘ê·¼ì´ í•„ìš”í•œì§€ ì—¬ë¶€ì— ëŒ€í•´ ë” ì‹ ì¤‘í•´ì•¼ í•¨ì„ "
"ì˜ë¯¸í•©ë‹ˆë‹¤. Cì—ì„œëŠ” ê¸°ë³¸ê°’ì´ ê°€ë³€ì´ë©° `const`ì— ëŒ€í•´ ëª…ì‹œí•´ì•¼ í•˜ì§€ë§Œ, "
"Rustì—ì„œëŠ” ê·¸ ë°˜ëŒ€ì…ë‹ˆë‹¤."

#: src/c-tips/index.md:219
msgid ""
"One situation where you might still use raw pointers is interacting directly "
"with hardware (for example, writing a pointer to a buffer into a DMA "
"peripheral register), and they are also used under the hood for all "
"peripheral access crates to allow you to read and write memory-mapped "
"registers."
msgstr ""
"ì›ì‹œ í¬ì¸í„°ë¥¼ ì—¬ì „íˆ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í•œ ê°€ì§€ ìƒí™©ì€ í•˜ë“œì›¨ì–´ì™€ ì§ì ‘ ìƒí˜¸ "
"ì‘ìš©í•˜ëŠ” ê²½ìš°(ì˜ˆ: ë²„í¼ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ DMA ì£¼ë³€ ì¥ì¹˜ ë ˆì§€ìŠ¤í„°ì— ì“°ëŠ” ê²½ìš°)ì´ë©°, "
"ëª¨ë“  ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ í¬ë ˆì´íŠ¸ì—ì„œ ë©”ëª¨ë¦¬ ë§¤í•‘ëœ ë ˆì§€ìŠ¤í„°ë¥¼ ì½ê³  ì“¸ ìˆ˜ ìˆë„ë¡ "
"ë‚´ë¶€ì ìœ¼ë¡œë„ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/c-tips/index.md:224
msgid "Volatile Access"
msgstr "íœ˜ë°œì„± ì ‘ê·¼"

#: src/c-tips/index.md:226
msgid ""
"In C, individual variables may be marked `volatile`, indicating to the "
"compiler that the value in the variable may change between accesses. "
"Volatile variables are commonly used in an embedded context for memory-"
"mapped registers."
msgstr ""
"Cì—ì„œëŠ” ê°œë³„ ë³€ìˆ˜ì— `volatile`ì„ í‘œì‹œí•˜ì—¬ ì»´íŒŒì¼ëŸ¬ì—ê²Œ ë³€ìˆ˜ ê°’ì´ ì ‘ê·¼ ì‚¬ì´ì— "
"ë³€ê²½ë  ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. íœ˜ë°œì„± ë³€ìˆ˜ëŠ” ì„ë² ë””ë“œ ì»¨í…ìŠ¤íŠ¸ì—ì„œ "
"ë©”ëª¨ë¦¬ ë§¤í•‘ëœ ë ˆì§€ìŠ¤í„°ì— ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/c-tips/index.md:230
msgid ""
"In Rust, instead of marking a variable as `volatile`, we use specific "
"methods to perform volatile access: [`core::ptr::read_volatile`](https://"
"doc.rust-lang.org/core/ptr/fn.read_volatile.html) and "
"[`core::ptr::write_volatile`](https://doc.rust-lang.org/core/ptr/"
"fn.write_volatile.html). These methods take a `*const T` or a `*mut T` (_raw "
"pointers_, as discussed above) and perform a volatile read or write."
msgstr ""
"Rustì—ì„œëŠ” ë³€ìˆ˜ë¥¼ `volatile`ë¡œ í‘œì‹œí•˜ëŠ” ëŒ€ì‹ , íœ˜ë°œì„± ì ‘ê·¼ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ "
"íŠ¹ì • ë©”ì„œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤: [`core::ptr::read_volatile`](https://doc.rust-lang.org/"
"core/ptr/fn.read_volatile.html) ë° [`core::ptr::write_volatile`](https://doc."
"rust-lang.org/core/ptr/fn.write_volatile.html). ì´ ë©”ì„œë“œë“¤ì€ `*const T` "
"ë˜ëŠ” `*mut T`(_ì›ì‹œ í¬ì¸í„°_, ìœ„ì—ì„œ ë…¼ì˜ë¨)ë¥¼ ë°›ì•„ íœ˜ë°œì„± ì½ê¸° ë˜ëŠ” ì“°ê¸°ë¥¼ "
"ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/c-tips/index.md:238
msgid "For example, in C you might write:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´, Cì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:244
msgid "// Signal that the interrupt has occurred\n"
msgstr "// ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí–ˆìŒì„ ì•Œë¦½ë‹ˆë‹¤\n"

#: src/c-tips/index.md:250 src/c-tips/index.md:275
msgid "// Sleep until signalled\n"
msgstr "// ì‹ í˜¸ê°€ ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸°\n"

#: src/c-tips/index.md:252 src/c-tips/index.md:277
msgid "// Reset signalled indicator\n"
msgstr "// ì‹ í˜¸ í‘œì‹œê¸° ì¬ì„¤ì •\n"

#: src/c-tips/index.md:254 src/c-tips/index.md:279
msgid "// Perform some task that was waiting for the interrupt\n"
msgstr "// ì¸í„°ëŸ½íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ë˜ ì‘ì—…ì„ ìˆ˜í–‰\n"

#: src/c-tips/index.md:260
msgid "The equivalent in Rust would use volatile methods on each access:"
msgstr "Rustì—ì„œ ì´ì— ìƒì‘í•˜ëŠ” ê²ƒì€ ê° ì ‘ê·¼ì— íœ˜ë°œì„± ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/c-tips/index.md:267
msgid ""
"// Signal that the interrupt has occurred\n"
"    // (In real code, you should consider a higher level primitive,\n"
"    //  such as an atomic type).\n"
msgstr ""
"// ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí–ˆìŒì„ ì•Œë¦½ë‹ˆë‹¤\n"
"    // (ì‹¤ì œ ì½”ë“œì—ì„œëŠ” ì›ìì  íƒ€ì…ê³¼ ê°™ì€ ë” ë†’ì€ ìˆ˜ì¤€ì˜ ê¸°ë³¸ ìš”ì†Œë¥¼ ê³ ë ¤í•´ì•¼ "
"í•©ë‹ˆë‹¤).\n"

#: src/c-tips/index.md:285
msgid "A few things are worth noting in the code sample:"
msgstr "ì½”ë“œ ìƒ˜í”Œì—ì„œ ëª‡ ê°€ì§€ ì£¼ëª©í•  ì ì´ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:286
msgid ""
"We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since "
"`&mut T` automatically converts to a `*mut T` (and the same for `*const T`)"
msgstr ""
"`&mut SIGNALLED`ë¥¼ `*mut T`ë¥¼ ìš”êµ¬í•˜ëŠ” í•¨ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `&mut T`ëŠ” "
"ìë™ìœ¼ë¡œ `*mut T`ë¡œ ë³€í™˜ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤(`*const T`ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤)."

#: src/c-tips/index.md:288
msgid ""
"We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods, "
"since they are `unsafe` functions. It is the programmer's responsibility to "
"ensure safe use: see the methods' documentation for further details."
msgstr ""
"`read_volatile`/`write_volatile` ë©”ì„œë“œëŠ” `unsafe` í•¨ìˆ˜ì´ë¯€ë¡œ `unsafe` "
"ë¸”ë¡ì´ í•„ìš”í•©ë‹ˆë‹¤. ì•ˆì „í•œ ì‚¬ìš©ì„ ë³´ì¥í•˜ëŠ” ê²ƒì€ í”„ë¡œê·¸ë˜ë¨¸ì˜ ì±…ì„ì…ë‹ˆë‹¤. "
"ìì„¸í•œ ë‚´ìš©ì€ ë©”ì„œë“œ ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/c-tips/index.md:292
msgid ""
"It is rare to require these functions directly in your code, as they will "
"usually be taken care of for you by higher-level libraries. For memory "
"mapped peripherals, the peripheral access crates will implement volatile "
"access automatically, while for concurrency primitives there are better "
"abstractions available (see the [Concurrency chapter](../concurrency/"
"index.md))."
msgstr ""
"ì´ëŸ¬í•œ í•¨ìˆ˜ë¥¼ ì½”ë“œì—ì„œ ì§ì ‘ ìš”êµ¬í•˜ëŠ” ê²½ìš°ëŠ” ë“œë­…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ìƒìœ„ ìˆ˜ì¤€ "
"ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì²˜ë¦¬í•´ ì£¼ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë©”ëª¨ë¦¬ ë§¤í•‘ëœ ì£¼ë³€ ì¥ì¹˜ì˜ ê²½ìš° ì£¼ë³€ "
"ì¥ì¹˜ ì ‘ê·¼ í¬ë ˆì´íŠ¸ê°€ íœ˜ë°œì„± ì ‘ê·¼ì„ ìë™ìœ¼ë¡œ êµ¬í˜„í•˜ë©°, ë™ì‹œì„± ê¸°ë³¸ ìš”ì†Œì˜ ê²½ìš° "
"ë” ë‚˜ì€ ì¶”ìƒí™”ê°€ ì œê³µë©ë‹ˆë‹¤([ë™ì‹œì„± ì¥](../concurrency/index.md) ì°¸ì¡°)."

#: src/c-tips/index.md:300
msgid "Packed and Aligned Types"
msgstr "íŒ© ë° ì •ë ¬ëœ íƒ€ì…"

#: src/c-tips/index.md:302
msgid ""
"In embedded C it is common to tell the compiler a variable must have a "
"certain alignment or a struct must be packed rather than aligned, usually to "
"meet specific hardware or protocol requirements."
msgstr ""
"ì„ë² ë””ë“œ Cì—ì„œëŠ” íŠ¹ì • í•˜ë“œì›¨ì–´ ë˜ëŠ” í”„ë¡œí† ì½œ ìš”êµ¬ ì‚¬í•­ì„ ì¶©ì¡±í•˜ê¸° ìœ„í•´ ë³€ìˆ˜ê°€ "
"íŠ¹ì • ì •ë ¬ì„ ê°€ì ¸ì•¼ í•˜ê±°ë‚˜ êµ¬ì¡°ì²´ê°€ ì •ë ¬ë˜ì§€ ì•Šê³  íŒ©ë˜ì–´ì•¼ í•œë‹¤ê³  ì»´íŒŒì¼ëŸ¬ì— "
"ì•Œë¦¬ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤."

#: src/c-tips/index.md:306
msgid ""
"In Rust this is controlled by the `repr` attribute on a struct or union. The "
"default representation provides no guarantees of layout, so should not be "
"used for code that interoperates with hardware or C. The compiler may re-"
"order struct members or insert padding and the behaviour may change with "
"future versions of Rust."
msgstr ""
"Rustì—ì„œëŠ” ì´ê²ƒì´ êµ¬ì¡°ì²´ ë˜ëŠ” ìœ ë‹ˆì˜¨ì˜ `repr` ì†ì„±ì— ì˜í•´ ì œì–´ë©ë‹ˆë‹¤. ê¸°ë³¸ "
"í‘œí˜„ì€ ë ˆì´ì•„ì›ƒì„ ë³´ì¥í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í•˜ë“œì›¨ì–´ ë˜ëŠ” Cì™€ ìƒí˜¸ ìš´ìš©ë˜ëŠ” ì½”ë“œì—ëŠ” "
"ì‚¬ìš©í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” êµ¬ì¡°ì²´ ë©¤ë²„ë¥¼ ì¬ì •ë ¬í•˜ê±°ë‚˜ íŒ¨ë”©ì„ ì‚½ì…í•  ìˆ˜ "
"ìˆìœ¼ë©°, ë™ì‘ì€ Rustì˜ í–¥í›„ ë²„ì „ì—ì„œ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:321 src/c-tips/index.md:340 src/c-tips/index.md:366
#: src/c-tips/index.md:390 src/c-tips/index.md:391
msgid "\"{:p} {:p} {:p}\""
msgstr "\"{:p} {:p} {:p}\""

#: src/c-tips/index.md:323
msgid ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// Note ordering has been changed to x, z, y to improve packing.\n"
msgstr ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// íŒ¨í‚¹ ê°œì„ ì„ ìœ„í•´ ìˆœì„œê°€ x, z, yë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n"

#: src/c-tips/index.md:328
msgid "To ensure layouts that are interoperable with C, use `repr(C)`:"
msgstr "Cì™€ ìƒí˜¸ ìš´ìš© ê°€ëŠ¥í•œ ë ˆì´ì•„ì›ƒì„ ë³´ì¥í•˜ë ¤ë©´ `repr(C)`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/c-tips/index.md:342
msgid ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// Ordering is preserved and the layout will not change over time.\n"
"// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.\n"
msgstr ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// ìˆœì„œëŠ” ìœ ì§€ë˜ë©° ë ˆì´ì•„ì›ƒì€ ì‹œê°„ì´ ì§€ë‚˜ë„ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"// `z`ëŠ” 2ë°”ì´íŠ¸ ì •ë ¬ë˜ì–´ ìˆìœ¼ë¯€ë¡œ `y`ì™€ `z` ì‚¬ì´ì— 1ë°”ì´íŠ¸ íŒ¨ë”©ì´ ì¡´ì¬í•©ë‹ˆë‹¤.\n"

#: src/c-tips/index.md:348
msgid "To ensure a packed representation, use `repr(packed)`:"
msgstr "íŒ©ëœ í‘œí˜„ì„ ë³´ì¥í•˜ë ¤ë©´ `repr(packed)`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/c-tips/index.md:360
msgid ""
"// References must always be aligned, so to check the addresses of the\n"
"    // struct's fields, we use `std::ptr::addr_of!()` to get a raw pointer\n"
"    // instead of just printing `&v.x`.\n"
msgstr ""
"// ì°¸ì¡°ëŠ” í•­ìƒ ì •ë ¬ë˜ì–´ì•¼ í•˜ë¯€ë¡œ, êµ¬ì¡°ì²´ í•„ë“œì˜ ì£¼ì†Œë¥¼ í™•ì¸í•˜ë ¤ë©´\n"
"    // `&v.x`ë¥¼ ë‹¨ìˆœíˆ ì¶œë ¥í•˜ëŠ” ëŒ€ì‹  `std::ptr::addr_of!()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ì‹œ "
"í¬ì¸í„°ë¥¼ ì–»ìŠµë‹ˆë‹¤.\n"

#: src/c-tips/index.md:368
msgid ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// No padding has been inserted between `y` and `z`, so now `z` is "
"unaligned.\n"
msgstr ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// `y`ì™€ `z` ì‚¬ì´ì— íŒ¨ë”©ì´ ì‚½ì…ë˜ì§€ ì•Šì•„ `z`ê°€ ì •ë ¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"

#: src/c-tips/index.md:373
msgid ""
"Note that using `repr(packed)` also sets the alignment of the type to `1`."
msgstr "`repr(packed)`ë¥¼ ì‚¬ìš©í•˜ë©´ íƒ€ì…ì˜ ì •ë ¬ë„ `1`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤."

#: src/c-tips/index.md:375
msgid ""
"Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is "
"the number of bytes to align to (and must be a power of two):"
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, íŠ¹ì • ì •ë ¬ì„ ì§€ì •í•˜ë ¤ë©´ `repr(align(n))`ì„ ì‚¬ìš©í•˜ì„¸ìš”. ì—¬ê¸°ì„œ `n`ì€ "
"ì •ë ¬í•  ë°”ì´íŠ¸ ìˆ˜ì´ë©° (2ì˜ ê±°ë“­ì œê³±ì´ì–´ì•¼ í•©ë‹ˆë‹¤):"

#: src/c-tips/index.md:393
msgid ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// The two instances `u` and `v` have been placed on 4096-byte alignments,\n"
"// evidenced by the `000` at the end of their addresses.\n"
msgstr ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// ë‘ ì¸ìŠ¤í„´ìŠ¤ `u`ì™€ `v`ëŠ” 4096ë°”ì´íŠ¸ ì •ë ¬ì— ë°°ì¹˜ë˜ì—ˆìœ¼ë©°,\n"
"// ì£¼ì†Œ ëì˜ `000`ìœ¼ë¡œ ì¦ëª…ë©ë‹ˆë‹¤.\n"

#: src/c-tips/index.md:400
msgid ""
"Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and "
"C-compatible layout. It is not permissible to combine `repr(align(n))` with "
"`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also "
"not permissible for a `repr(packed)` type to contain a `repr(align(n))` type."
msgstr ""
"`repr(C)`ì™€ `repr(align(n))`ì„ ê²°í•©í•˜ì—¬ ì •ë ¬ë˜ê³  C í˜¸í™˜ ê°€ëŠ¥í•œ ë ˆì´ì•„ì›ƒì„ "
"ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `repr(packed)`ëŠ” ì •ë ¬ì„ `1`ë¡œ ì„¤ì •í•˜ë¯€ë¡œ `repr(align(n))`ê³¼ "
"`repr(packed)`ë¥¼ ê²°í•©í•˜ëŠ” ê²ƒì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë˜í•œ `repr(packed)` íƒ€ì…ì´ "
"`repr(align(n))` íƒ€ì…ì„ í¬í•¨í•˜ëŠ” ê²ƒë„ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/c-tips/index.md:405
msgid ""
"For further details on type layouts, refer to the [type layout](https://"
"doc.rust-lang.org/reference/type-layout.html) chapter of the Rust Reference."
msgstr ""
"íƒ€ì… ë ˆì´ì•„ì›ƒì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ Rust ì°¸ì¡°ì˜ [íƒ€ì… ë ˆì´ì•„ì›ƒ](https://doc.rust-"
"lang.org/reference/type-layout.html) ì¥ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/c-tips/index.md:412
msgid "In this book:"
msgstr "ì´ ì±…ì—ì„œ:"

#: src/c-tips/index.md:413
msgid "[A little C with your Rust](../interoperability/c-with-rust.md)"
msgstr "[Rustì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ C](../interoperability/c-with-rust.md)"

#: src/c-tips/index.md:414
msgid "[A little Rust with your C](../interoperability/rust-with-c.md)"
msgstr "[Cì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ Rust](../interoperability/rust-with-c.md)"

#: src/c-tips/index.md:415
msgid "[The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)"
msgstr "[Rust ì„ë² ë””ë“œ FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/c-tips/index.md:416
msgid "[Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)"
msgstr "[C í”„ë¡œê·¸ë˜ë¨¸ë¥¼ ìœ„í•œ Rust í¬ì¸í„°](http://blahg.josefsipek.net/?p=580)"

#: src/c-tips/index.md:417
msgid ""
"[I used to use pointers - now what?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"
msgstr ""
"[í¬ì¸í„°ë¥¼ ì‚¬ìš©í–ˆì—ˆëŠ”ë° - ì´ì œ ë¬´ì—‡ì„?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"

#: src/interoperability/index.md:3
msgid ""
"Interoperability between Rust and C code is always dependent on transforming "
"data between the two languages. For this purpose, there is a dedicated "
"module in the `stdlib` called [`std::ffi`](https://doc.rust-lang.org/std/ffi/"
"index.html)."
msgstr ""
"Rustì™€ C ì½”ë“œ ê°„ì˜ ìƒí˜¸ ìš´ìš©ì„±ì€ í•­ìƒ ë‘ ì–¸ì–´ ê°„ì˜ ë°ì´í„° ë³€í™˜ì— ë‹¬ë ¤ "
"ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ `stdlib`ì—ëŠ” [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/index.html)ë¼ëŠ” ì „ìš© ëª¨ë“ˆì´ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/index.md:9
msgid ""
"`std::ffi` provides type definitions for C primitive types, such as `char`, "
"`int`, and `long`. It also provides some utility for converting more complex "
"types such as strings, mapping both `&str` and `String` to C types that are "
"easier and safer to handle."
msgstr ""
"`std::ffi`ëŠ” `char`, `int`, `long`ê³¼ ê°™ì€ C ê¸°ë³¸ íƒ€ì…ì— ëŒ€í•œ íƒ€ì… ì •ì˜ë¥¼ "
"ì œê³µí•©ë‹ˆë‹¤. ë˜í•œ ë¬¸ìì—´ê³¼ ê°™ì€ ë” ë³µì¡í•œ íƒ€ì…ì„ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹°ë„ ì œê³µí•˜ì—¬ "
"`&str`ê³¼ `String`ì„ ëª¨ë‘ ë” ì‰½ê³  ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” C íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤."

#: src/interoperability/index.md:15
msgid ""
"As of Rust 1.30, functionalities of `std::ffi` are available in either "
"`core::ffi` or `alloc::ffi` depending on whether or not memory allocation is "
"involved. The [`cty`](https://crates.io/crates/cty) crate and the "
"[`cstr_core`](https://crates.io/crates/cstr_core) crate also offer similar "
"functionalities."
msgstr ""
"Rust 1.30ë¶€í„° `std::ffi`ì˜ ê¸°ëŠ¥ì€ ë©”ëª¨ë¦¬ í• ë‹¹ ì—¬ë¶€ì— ë”°ë¼ `core::ffi` ë˜ëŠ” "
"`alloc::ffi`ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. [`cty`](https://crates.io/crates/cty) "
"í¬ë ˆì´íŠ¸ì™€ [`cstr_core`](https://crates.io/crates/cstr_core) í¬ë ˆì´íŠ¸ë„ ìœ ì‚¬í•œ "
"ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/interoperability/index.md:25
msgid "Rust type"
msgstr "Rust íƒ€ì…"

#: src/interoperability/index.md:25
msgid "Intermediate"
msgstr "ì¤‘ê°„"

#: src/interoperability/index.md:25
msgid "C type"
msgstr "C íƒ€ì…"

#: src/interoperability/index.md:27
msgid "`String`"
msgstr "`String`"

#: src/interoperability/index.md:27
msgid "`CString`"
msgstr "`CString`"

#: src/interoperability/index.md:27
msgid "`char *`"
msgstr "`char *`"

#: src/interoperability/index.md:28
msgid "`&str`"
msgstr "`&str`"

#: src/interoperability/index.md:28
msgid "`CStr`"
msgstr "`CStr`"

#: src/interoperability/index.md:28
msgid "`const char *`"
msgstr "`const char *`"

#: src/interoperability/index.md:29
msgid "`()`"
msgstr "`()`"

#: src/interoperability/index.md:29
msgid "`c_void`"
msgstr "`c_void`"

#: src/interoperability/index.md:29
msgid "`void`"
msgstr "`void`"

#: src/interoperability/index.md:30
msgid "`u32` or `u64`"
msgstr "`u32` ë˜ëŠ” `u64`"

#: src/interoperability/index.md:30
msgid "`c_uint`"
msgstr "`c_uint`"

#: src/interoperability/index.md:30
msgid "`unsigned int`"
msgstr "`unsigned int`"

#: src/interoperability/index.md:31
msgid "etc"
msgstr "ë“±"

#: src/interoperability/index.md:31
msgid "..."
msgstr "..."

#: src/interoperability/index.md:33
msgid ""
"A value of a C primitive type can be used as one of the corresponding Rust "
"type and vice versa, since the former is simply a type alias of the latter. "
"For example, the following code compiles on platforms where `unsigned int` "
"is 32-bit long."
msgstr ""
"C ê¸°ë³¸ íƒ€ì…ì˜ ê°’ì€ í•´ë‹¹ Rust íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆìœ¼ë©° ê·¸ ë°˜ëŒ€ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. "
"ì „ìê°€ í›„ìì˜ íƒ€ì… ë³„ì¹­ì— ë¶ˆê³¼í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒ ì½”ë“œëŠ” "
"`unsigned int`ê°€ 32ë¹„íŠ¸ ê¸¸ì´ì¸ í”Œë«í¼ì—ì„œ ì»´íŒŒì¼ë©ë‹ˆë‹¤."

#: src/interoperability/index.md:46
msgid "Interoperability with other build systems"
msgstr "ë‹¤ë¥¸ ë¹Œë“œ ì‹œìŠ¤í…œê³¼ì˜ ìƒí˜¸ ìš´ìš©ì„±"

#: src/interoperability/index.md:48
msgid ""
"A common requirement for including Rust in your embedded project is "
"combining Cargo with your existing build system, such as make or cmake."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œì íŠ¸ì— Rustë¥¼ í¬í•¨í•˜ê¸° ìœ„í•œ ì¼ë°˜ì ì¸ ìš”êµ¬ ì‚¬í•­ì€ Cargoë¥¼ make "
"ë˜ëŠ” cmakeì™€ ê°™ì€ ê¸°ì¡´ ë¹Œë“œ ì‹œìŠ¤í…œê³¼ ê²°í•©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/interoperability/index.md:51
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #61](https://github.com/rust-embedded/book/issues/61)."
msgstr ""
"ìš°ë¦¬ëŠ” [ì´ìŠˆ #61](https://github.com/rust-embedded/book/issues/61)ì˜ ì´ìŠˆ "
"íŠ¸ë˜ì»¤ì—ì„œ ì´ì— ëŒ€í•œ ì˜ˆì‹œì™€ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ìˆ˜ì§‘í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/index.md:56
msgid "Interoperability with RTOSs"
msgstr "RTOSì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±"

#: src/interoperability/index.md:58
msgid ""
"Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in "
"progress; especially calling RTOS functions from Rust can be tricky."
msgstr ""
"FreeRTOS ë˜ëŠ” ChibiOSì™€ ê°™ì€ RTOSì™€ Rustë¥¼ í†µí•©í•˜ëŠ” ì‘ì—…ì€ ì•„ì§ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. "
"íŠ¹íˆ Rustì—ì„œ RTOS í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ê¹Œë‹¤ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/index.md:61
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #62](https://github.com/rust-embedded/book/issues/62)."
msgstr ""
"ìš°ë¦¬ëŠ” [ì´ìŠˆ #62](https://github.com/rust-embedded/book/issues/62)ì˜ ì´ìŠˆ "
"íŠ¸ë˜ì»¤ì—ì„œ ì´ì— ëŒ€í•œ ì˜ˆì‹œì™€ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ìˆ˜ì§‘í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:3
msgid "Using C or C++ inside of a Rust project consists of two major parts:"
msgstr "Rust í”„ë¡œì íŠ¸ ë‚´ì—ì„œ C ë˜ëŠ” C++ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ë‘ ê°€ì§€ ì£¼ìš” ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:5
msgid "Wrapping the exposed C API for use with Rust"
msgstr "ë…¸ì¶œëœ C APIë¥¼ Rustì—ì„œ ì‚¬ìš©í•˜ë„ë¡ ë˜í•‘"

#: src/interoperability/c-with-rust.md:6
msgid "Building your C or C++ code to be integrated with the Rust code"
msgstr "Rust ì½”ë“œì™€ í†µí•©ë  C ë˜ëŠ” C++ ì½”ë“œ ë¹Œë“œ"

#: src/interoperability/c-with-rust.md:8
msgid ""
"As C++ does not have a stable ABI for the Rust compiler to target, it is "
"recommended to use the `C` ABI when combining Rust with C or C++."
msgstr ""
"C++ëŠ” Rust ì»´íŒŒì¼ëŸ¬ê°€ ëŒ€ìƒìœ¼ë¡œ í•  ì•ˆì •ì ì¸ ABIë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šìœ¼ë¯€ë¡œ, Rustì™€ "
"C ë˜ëŠ” C++ë¥¼ ê²°í•©í•  ë•Œ `C` ABIë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:10
msgid "Defining the interface"
msgstr "ì¸í„°í˜ì´ìŠ¤ ì •ì˜"

#: src/interoperability/c-with-rust.md:12
msgid ""
"Before consuming C or C++ code from Rust, it is necessary to define (in "
"Rust) what data types and function signatures exist in the linked code. In C "
"or C++, you would include a header (`.h` or `.hpp`) file which defines this "
"data. In Rust, it is necessary to either manually translate these "
"definitions to Rust, or use a tool to generate these definitions."
msgstr ""
"Rustì—ì„œ C ë˜ëŠ” C++ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì—, ë§í¬ëœ ì½”ë“œì— ì–´ë–¤ ë°ì´í„° íƒ€ì…ê³¼ "
"í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ê°€ ì¡´ì¬í•˜ëŠ”ì§€ (Rustì—ì„œ) ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤. C ë˜ëŠ” C++ì—ì„œëŠ” ì´ "
"ë°ì´í„°ë¥¼ ì •ì˜í•˜ëŠ” í—¤ë”(`.h` ë˜ëŠ” `.hpp`) íŒŒì¼ì„ í¬í•¨í•©ë‹ˆë‹¤. Rustì—ì„œëŠ” ì´ëŸ¬í•œ "
"ì •ì˜ë¥¼ ìˆ˜ë™ìœ¼ë¡œ Rustë¡œ ë²ˆì—­í•˜ê±°ë‚˜, ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ëŸ¬í•œ ì •ì˜ë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:14
msgid ""
"First, we will cover manually translating these definitions from C/C++ to "
"Rust."
msgstr ""
"ë¨¼ì €, C/C++ì—ì„œ Rustë¡œ ì´ëŸ¬í•œ ì •ì˜ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ë²ˆì—­í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:16
msgid "Wrapping C functions and Datatypes"
msgstr "C í•¨ìˆ˜ ë° ë°ì´í„° íƒ€ì… ë˜í•‘"

#: src/interoperability/c-with-rust.md:18
msgid ""
"Typically, libraries written in C or C++ will provide a header file defining "
"all types and functions used in public interfaces. An example file may look "
"like this:"
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ C ë˜ëŠ” C++ë¡œ ì‘ì„±ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ê³µê°œ ì¸í„°í˜ì´ìŠ¤ì—ì„œ ì‚¬ìš©ë˜ëŠ” ëª¨ë“  "
"íƒ€ì…ê³¼ í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” í—¤ë” íŒŒì¼ì„ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆì‹œ íŒŒì¼ì€ ë‹¤ìŒê³¼ ê°™ì„ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:21
msgid "/* File: cool.h */"
msgstr "/* íŒŒì¼: cool.h */"

#: src/interoperability/c-with-rust.md:30
msgid "When translated to Rust, this interface would look as such:"
msgstr "Rustë¡œ ë²ˆì—­í•˜ë©´ ì´ ì¸í„°í˜ì´ìŠ¤ëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:33
msgid "/* File: cool_bindings.rs */"
msgstr "/* íŒŒì¼: cool_bindings.rs */"

#: src/interoperability/c-with-rust.md:40
#: src/interoperability/c-with-rust.md:66
#: src/interoperability/rust-with-c.md:56
#: src/interoperability/rust-with-c.md:82
msgid "\"C\""
msgstr "\"C\""

#: src/interoperability/c-with-rust.md:49
msgid ""
"Let's take a look at this definition one piece at a time, to explain each of "
"the parts."
msgstr ""
"ì´ ì •ì˜ë¥¼ í•œ ë²ˆì— í•œ ë¶€ë¶„ì”© ì‚´í´ë³´ë©´ì„œ ê° ë¶€ë¶„ì„ ì„¤ëª…í•´ ë´…ì‹œë‹¤."

#: src/interoperability/c-with-rust.md:56
msgid ""
"By default, Rust does not guarantee order, padding, or the size of data "
"included in a `struct`. In order to guarantee compatibility with C code, we "
"include the `#[repr(C)]` attribute, which instructs the Rust compiler to "
"always use the same rules C does for organizing data within a struct."
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ RustëŠ” `struct`ì— í¬í•¨ëœ ë°ì´í„°ì˜ ìˆœì„œ, íŒ¨ë”© ë˜ëŠ” í¬ê¸°ë¥¼ ë³´ì¥í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. C ì½”ë“œì™€ì˜ í˜¸í™˜ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ `#[repr(C)]` ì†ì„±ì„ í¬í•¨í•˜ëŠ”ë°, "
"ì´ëŠ” Rust ì»´íŒŒì¼ëŸ¬ì—ê²Œ êµ¬ì¡°ì²´ ë‚´ì—ì„œ ë°ì´í„°ë¥¼ êµ¬ì„±í•  ë•Œ Cì™€ ë™ì¼í•œ ê·œì¹™ì„ "
"í•­ìƒ ì‚¬ìš©í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:63
msgid ""
"Due to the flexibility of how C or C++ defines an `int` or `char`, it is "
"recommended to use primitive data types defined in `cty`, which will map "
"types from C to types in Rust."
msgstr ""
"C ë˜ëŠ” C++ê°€ `int` ë˜ëŠ” `char`ë¥¼ ì •ì˜í•˜ëŠ” ë°©ì‹ì˜ ìœ ì—°ì„± ë•Œë¬¸ì—, Cì˜ íƒ€ì…ì„ "
"Rustì˜ íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” `cty`ì— ì •ì˜ëœ ê¸°ë³¸ ë°ì´í„° íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ "
"ì¢‹ìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:69
msgid ""
"This statement defines the signature of a function that uses the C ABI, "
"called `cool_function`. By defining the signature without defining the body "
"of the function, the definition of this function will need to be provided "
"elsewhere, or linked into the final library or binary from a static library."
msgstr ""
"ì´ ë¬¸ì¥ì€ C ABIë¥¼ ì‚¬ìš©í•˜ëŠ” `cool_function`ì´ë¼ëŠ” í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. "
"í•¨ìˆ˜ì˜ ë³¸ë¬¸ì„ ì •ì˜í•˜ì§€ ì•Šê³  ì‹œê·¸ë‹ˆì²˜ë§Œ ì •ì˜í•¨ìœ¼ë¡œì¨, ì´ í•¨ìˆ˜ì˜ ì •ì˜ëŠ” ë‹¤ë¥¸ "
"ê³³ì—ì„œ ì œê³µë˜ê±°ë‚˜ ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ìµœì¢… ë¼ì´ë¸ŒëŸ¬ë¦¬ ë˜ëŠ” ë°”ì´ë„ˆë¦¬ë¡œ "
"ë§í¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:77
msgid ""
"Similar to our datatype above, we define the datatypes of the function "
"arguments using C-compatible definitions. We also retain the same argument "
"names, for clarity."
msgstr ""
"ìœ„ì˜ ë°ì´í„° íƒ€ì…ê³¼ ìœ ì‚¬í•˜ê²Œ, ìš°ë¦¬ëŠ” C í˜¸í™˜ ì •ì˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í•¨ìˆ˜ ì¸ìˆ˜ì˜ "
"ë°ì´í„° íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤. ëª…í™•ì„±ì„ ìœ„í•´ ë™ì¼í•œ ì¸ìˆ˜ ì´ë¦„ë„ ìœ ì§€í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:79
msgid ""
"We have one new type here, `*mut CoolStruct`. As C does not have a concept "
"of Rust's references, which would look like this: `&mut CoolStruct`, we "
"instead have a raw pointer. As dereferencing this pointer is `unsafe`, and "
"the pointer may in fact be a `null` pointer, care must be taken to ensure "
"the guarantees typical of Rust when interacting with C or C++ code."
msgstr ""
"ì—¬ê¸°ì—ëŠ” ìƒˆë¡œìš´ íƒ€ì…ì¸ `*mut CoolStruct`ê°€ ìˆìŠµë‹ˆë‹¤. CëŠ” Rustì˜ ì°¸ì¡°(ì˜ˆ: "
"`&mut CoolStruct`) ê°œë…ì´ ì—†ìœ¼ë¯€ë¡œ, ëŒ€ì‹  ì›ì‹œ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ "
"í¬ì¸í„°ë¥¼ ì—­ì°¸ì¡°í•˜ëŠ” ê²ƒì€ `unsafe`ì´ë©°, í¬ì¸í„°ê°€ ì‹¤ì œë¡œ `null` í¬ì¸í„°ì¼ ìˆ˜ "
"ìˆìœ¼ë¯€ë¡œ C ë˜ëŠ” C++ ì½”ë“œì™€ ìƒí˜¸ ì‘ìš©í•  ë•Œ Rustì˜ ì¼ë°˜ì ì¸ ë³´ì¥ì„ ìœ ì§€í•˜ë„ë¡ "
"ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:81
msgid "Automatically generating the interface"
msgstr "ì¸í„°í˜ì´ìŠ¤ ìë™ ìƒì„±"

#: src/interoperability/c-with-rust.md:83
msgid ""
"Rather than manually generating these interfaces, which may be tedious and "
"error prone, there is a tool called [bindgen](https://github.com/rust-lang/"
"rust-bindgen) which will perform these conversions automatically. For "
"instructions of the usage of [bindgen](https://github.com/rust-lang/rust-"
"bindgen), please refer to the [bindgen user's manual](https://rust-"
"lang.github.io/rust-bindgen/), however the typical process consists of the "
"following:"
msgstr ""
"ì§€ë£¨í•˜ê³  ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê¸° ì‰¬ìš´ ì´ëŸ¬í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ëŒ€ì‹ , "
"ì´ëŸ¬í•œ ë³€í™˜ì„ ìë™ìœ¼ë¡œ ìˆ˜í–‰í•˜ëŠ” [bindgen](https://github.com/rust-lang/rust-"
"bindgen)ì´ë¼ëŠ” ë„êµ¬ê°€ ìˆìŠµë‹ˆë‹¤. [bindgen](https://github.com/rust-lang/rust-"
"bindgen) ì‚¬ìš© ë°©ë²•ì— ëŒ€í•œ ì§€ì¹¨ì€ [bindgen ì‚¬ìš©ì ë§¤ë‰´ì–¼](https://rust-lang."
"github.io/rust-bindgen/)ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤. ì¼ë°˜ì ì¸ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:85
msgid ""
"Gather all C or C++ headers defining interfaces or datatypes you would like "
"to use with Rust."
msgstr ""
"Rustì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ ë˜ëŠ” ë°ì´í„° íƒ€ì…ì„ ì •ì˜í•˜ëŠ” ëª¨ë“  C ë˜ëŠ” C++ "
"í—¤ë”ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:86
msgid ""
"Write a `bindings.h` file, which `#include \"...\"`'s each of the files you "
"gathered in step one."
msgstr ""
"1ë‹¨ê³„ì—ì„œ ìˆ˜ì§‘í•œ ê° íŒŒì¼ì„ `#include \"...\"`í•˜ëŠ” `bindings.h` íŒŒì¼ì„ ì‘ì„±í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:87
msgid ""
"Feed this `bindings.h` file, along with any compilation flags used to "
"compile your code into `bindgen`. Tip: use "
"`Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and "
"`Builder.use_core()` / `--use-core` to make the generated code `#![no_std]` "
"compatible."
msgstr ""
"ì´ `bindings.h` íŒŒì¼ì„ ì½”ë“œ ì»´íŒŒì¼ì— ì‚¬ìš©ëœ ëª¨ë“  ì»´íŒŒì¼ í”Œë˜ê·¸ì™€ í•¨ê»˜ "
"`bindgen`ì— ê³µê¸‰í•©ë‹ˆë‹¤. íŒ: ìƒì„±ëœ ì½”ë“œë¥¼ `#![no_std]` í˜¸í™˜ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ë ¤ë©´ "
"`Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` ë° "
"`Builder.use_core()` / `--use-core`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/interoperability/c-with-rust.md:90
msgid ""
"`bindgen` will produce the generated Rust code to the output of the terminal "
"window. This output may be piped to a file in your project, such as "
"`bindings.rs`. You may use this file in your Rust project to interact with C/"
"C++ code compiled and linked as an external library. Tip: don't forget to "
"use the [`cty`](https://crates.io/crates/cty) crate if your types in the "
"generated bindings are prefixed with `cty`."
msgstr ""
"`bindgen`ì€ ìƒì„±ëœ Rust ì½”ë“œë¥¼ í„°ë¯¸ë„ ì°½ì˜ ì¶œë ¥ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤. ì´ ì¶œë ¥ì€ "
"`bindings.rs`ì™€ ê°™ì´ í”„ë¡œì íŠ¸ì˜ íŒŒì¼ë¡œ íŒŒì´í”„ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ íŒŒì¼ì„ Rust "
"í”„ë¡œì íŠ¸ì—ì„œ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ì»´íŒŒì¼ ë° ë§í¬ëœ C/C++ ì½”ë“œì™€ ìƒí˜¸ ì‘ìš©í•˜ëŠ” "
"ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŒ: ìƒì„±ëœ ë°”ì¸ë”©ì˜ íƒ€ì…ì— `cty` ì ‘ë‘ì‚¬ê°€ ë¶™ì–´ ìˆë‹¤ë©´ "
"[`cty`](https://crates.io/crates/cty) í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ìŠì§€ ë§ˆì„¸ìš”."

#: src/interoperability/c-with-rust.md:95
msgid "Building your C/C++ code"
msgstr "C/C++ ì½”ë“œ ë¹Œë“œ"

#: src/interoperability/c-with-rust.md:97
msgid ""
"As the Rust compiler does not directly know how to compile C or C++ code (or "
"code from any other language, which presents a C interface), it is necessary "
"to compile your non-Rust code ahead of time."
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” C ë˜ëŠ” C++ ì½”ë“œ(ë˜ëŠ” C ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ ì½”ë“œ)ë¥¼ "
"ì§ì ‘ ì»´íŒŒì¼í•˜ëŠ” ë°©ë²•ì„ ëª¨ë¥´ê¸° ë•Œë¬¸ì—, ë¹„ Rust ì½”ë“œë¥¼ ë¯¸ë¦¬ ì»´íŒŒì¼í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:99
msgid ""
"For embedded projects, this most commonly means compiling the C/C++ code to "
"a static archive (such as `cool-library.a`), which can then be combined with "
"your Rust code at the final linking step."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œì íŠ¸ì˜ ê²½ìš°, ì´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ C/C++ ì½”ë“œë¥¼ ì •ì  ì•„ì¹´ì´ë¸Œ(ì˜ˆ: "
"`cool-library.a`)ë¡œ ì»´íŒŒì¼í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì´ëŠ” ìµœì¢… ë§í¬ ë‹¨ê³„ì—ì„œ Rust "
"ì½”ë“œì™€ ê²°í•©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:101
msgid ""
"If the library you would like to use is already distributed as a static "
"archive, it is not necessary to rebuild your code. Just convert the provided "
"interface header file as described above, and include the static archive at "
"compile/link time."
msgstr ""
"ì‚¬ìš©í•˜ë ¤ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ë¯¸ ì •ì  ì•„ì¹´ì´ë¸Œë¡œ ë°°í¬ë˜ì–´ ìˆë‹¤ë©´ ì½”ë“œë¥¼ ë‹¤ì‹œ "
"ë¹Œë“œí•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ìœ„ì—ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ ì œê³µëœ ì¸í„°í˜ì´ìŠ¤ í—¤ë” íŒŒì¼ì„ "
"ë³€í™˜í•˜ê³ , ì»´íŒŒì¼/ë§í¬ ì‹œì ì— ì •ì  ì•„ì¹´ì´ë¸Œë¥¼ í¬í•¨í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:103
msgid ""
"If your code exists as a source project, it will be necessary to compile "
"your C/C++ code to a static library, either by triggering your existing "
"build system (such as `make`, `CMake`, etc.), or by porting the necessary "
"compilation steps to use a tool called the `cc` crate. For both of these "
"steps, it is necessary to use a `build.rs` script."
msgstr ""
"ì½”ë“œê°€ ì†ŒìŠ¤ í”„ë¡œì íŠ¸ë¡œ ì¡´ì¬í•˜ëŠ” ê²½ìš°, ê¸°ì¡´ ë¹Œë“œ ì‹œìŠ¤í…œ(`make`, `CMake` ë“±)ì„ "
"íŠ¸ë¦¬ê±°í•˜ê±°ë‚˜ í•„ìš”í•œ ì»´íŒŒì¼ ë‹¨ê³„ë¥¼ `cc` í¬ë ˆì´íŠ¸ë¼ëŠ” ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í¬íŒ…í•˜ì—¬ "
"C/C++ ì½”ë“œë¥¼ ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ì»´íŒŒì¼í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ë‘ ë‹¨ê³„ ëª¨ë‘ `build.rs` "
"ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:105
msgid "Rust `build.rs` build scripts"
msgstr "Rust `build.rs` ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸"

#: src/interoperability/c-with-rust.md:107
msgid ""
"A `build.rs` script is a file written in Rust syntax, that is executed on "
"your compilation machine, AFTER dependencies of your project have been "
"built, but BEFORE your project is built."
msgstr ""
"A `build.rs` ìŠ¤í¬ë¦½íŠ¸ëŠ” Rust ë¬¸ë²•ìœ¼ë¡œ ì‘ì„±ëœ íŒŒì¼ë¡œ, í”„ë¡œì íŠ¸ì˜ ì¢…ì†ì„±ì´ "
"ë¹Œë“œëœ í›„, í”„ë¡œì íŠ¸ê°€ ë¹Œë“œë˜ê¸° ì „ì— ì»´íŒŒì¼ ë¨¸ì‹ ì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:109
msgid ""
"The full reference may be found [here](https://doc.rust-lang.org/cargo/"
"reference/build-scripts.html). `build.rs` scripts are useful for generating "
"code (such as via [bindgen](https://github.com/rust-lang/rust-bindgen)), "
"calling out to external build systems such as `Make`, or directly compiling "
"C/C++ through use of the `cc` crate."
msgstr ""
"ì „ì²´ ì°¸ì¡°ëŠ” [ì—¬ê¸°](https://doc.rust-lang.org/cargo/reference/build-scripts.html)"
"ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `build.rs` ìŠ¤í¬ë¦½íŠ¸ëŠ” ì½”ë“œ ìƒì„±([bindgen](https://github."
"com/rust-lang/rust-bindgen)ì„ í†µí•´), `Make`ì™€ ê°™ì€ ì™¸ë¶€ ë¹Œë“œ ì‹œìŠ¤í…œ í˜¸ì¶œ, ë˜ëŠ” "
"`cc` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ C/C++ë¥¼ ì§ì ‘ ì»´íŒŒì¼í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:111
msgid "Triggering external build systems"
msgstr "ì™¸ë¶€ ë¹Œë“œ ì‹œìŠ¤í…œ íŠ¸ë¦¬ê±°ë§"

#: src/interoperability/c-with-rust.md:113
msgid ""
"For projects with complex external projects or build systems, it may be "
"easiest to use [`std::process::Command`](https://doc.rust-lang.org/std/"
"process/struct.Command.html) to \"shell out\" to your other build systems by "
"traversing relative paths, calling a fixed command (such as `make library`), "
"and then copying the resulting static library to the proper location in the "
"`target` build directory."
msgstr ""
"ë³µì¡í•œ ì™¸ë¶€ í”„ë¡œì íŠ¸ ë˜ëŠ” ë¹Œë“œ ì‹œìŠ¤í…œì„ ê°€ì§„ í”„ë¡œì íŠ¸ì˜ ê²½ìš°, ìƒëŒ€ ê²½ë¡œë¥¼ "
"íƒìƒ‰í•˜ê³  ê³ ì •ëœ ëª…ë ¹(`make library` ë“±)ì„ í˜¸ì¶œí•œ ë‹¤ìŒ ê²°ê³¼ ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ "
"`target` ë¹Œë“œ ë””ë ‰í† ë¦¬ì˜ ì ì ˆí•œ ìœ„ì¹˜ë¡œ ë³µì‚¬í•˜ì—¬ [`std::process::Command`]"
"(https://doc.rust-lang.org/std/process/struct.Command.html)ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ë¥¸ "
"ë¹Œë“œ ì‹œìŠ¤í…œìœ¼ë¡œ \"ì…¸ ì•„ì›ƒ\"í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì‰¬ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:115
msgid ""
"While your crate may be targeting a `no_std` embedded platform, your "
"`build.rs` executes only on machines compiling your crate. This means you "
"may use any Rust crates which will run on your compilation host."
msgstr ""
"í¬ë ˆì´íŠ¸ê°€ `no_std` ì„ë² ë””ë“œ í”Œë«í¼ì„ ëŒ€ìƒìœ¼ë¡œ í•  ìˆ˜ ìˆì§€ë§Œ, `build.rs`ëŠ” "
"í¬ë ˆì´íŠ¸ë¥¼ ì»´íŒŒì¼í•˜ëŠ” ë¨¸ì‹ ì—ì„œë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ í˜¸ìŠ¤íŠ¸ì—ì„œ ì‹¤í–‰ë  ìˆ˜ "
"ìˆëŠ” ëª¨ë“  Rust í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:119
msgid "Building C/C++ code with the `cc` crate"
msgstr "`cc` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ C/C++ ì½”ë“œ ë¹Œë“œ"

#: src/interoperability/c-with-rust.md:121
msgid ""
"For projects with limited dependencies or complexity, or for projects where "
"it is difficult to modify the build system to produce a static library "
"(rather than a final binary or executable), it may be easier to instead "
"utilize the [`cc` crate](https://github.com/alexcrichton/cc-rs), which "
"provides an idiomatic Rust interface to the compiler provided by the host."
msgstr ""
"ì œí•œëœ ì¢…ì†ì„± ë˜ëŠ” ë³µì¡ì„±ì„ ê°€ì§„ í”„ë¡œì íŠ¸, ë˜ëŠ” ë¹Œë“œ ì‹œìŠ¤í…œì„ ìˆ˜ì •í•˜ì—¬ ì •ì  "
"ë¼ì´ë¸ŒëŸ¬ë¦¬(ìµœì¢… ë°”ì´ë„ˆë¦¬ ë˜ëŠ” ì‹¤í–‰ íŒŒì¼ ëŒ€ì‹ )ë¥¼ ìƒì„±í•˜ê¸° ì–´ë ¤ìš´ í”„ë¡œì íŠ¸ì˜ "
"ê²½ìš°, í˜¸ìŠ¤íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ì»´íŒŒì¼ëŸ¬ì— ëŒ€í•œ ê´€ìš©ì ì¸ Rust ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” "
"[`cc` í¬ë ˆì´íŠ¸](https://github.com/alexcrichton/cc-rs)ë¥¼ í™œìš©í•˜ëŠ” ê²ƒì´ ë” "
"ì‰¬ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:125
msgid ""
"In the simplest case of compiling a single C file as a dependency to a "
"static library, an example `build.rs` script using the [`cc` crate](https://"
"github.com/alexcrichton/cc-rs) would look like this:"
msgstr ""
"ë‹¨ì¼ C íŒŒì¼ì„ ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì¢…ì†ì„±ìœ¼ë¡œ ì»´íŒŒì¼í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ê²½ìš°, "
"[`cc` í¬ë ˆì´íŠ¸](https://github.com/alexcrichton/cc-rs)ë¥¼ ì‚¬ìš©í•˜ëŠ” `build.rs` "
"ìŠ¤í¬ë¦½íŠ¸ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/interoperability/c-with-rust.md:130
msgid "\"src/foo.c\""
msgstr "\"src/foo.c\""

#: src/interoperability/c-with-rust.md:131
msgid "\"foo\""
msgstr "\"foo\""

#: src/interoperability/c-with-rust.md:135
msgid ""
"The `build.rs` is placed at the root of the package. Then `cargo build` will "
"compile and execute it before the build of the package. A static archive "
"named `libfoo.a` is generated and placed in the `target` directory."
msgstr ""
"The `build.rs`ëŠ” íŒ¨í‚¤ì§€ ë£¨íŠ¸ì— ë°°ì¹˜ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ `cargo build`ëŠ” íŒ¨í‚¤ì§€ "
"ë¹Œë“œ ì „ì— ì´ë¥¼ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•©ë‹ˆë‹¤. `libfoo.a`ë¼ëŠ” ì´ë¦„ì˜ ì •ì  ì•„ì¹´ì´ë¸Œê°€ "
"ìƒì„±ë˜ì–´ `target` ë””ë ‰í† ë¦¬ì— ë°°ì¹˜ë©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:3
msgid "Using Rust code inside a C or C++ project mostly consists of two parts."
msgstr "C ë˜ëŠ” C++ í”„ë¡œì íŠ¸ ë‚´ì—ì„œ Rust ì½”ë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì£¼ë¡œ ë‘ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:5
msgid "Creating a C-friendly API in Rust"
msgstr "Rustì—ì„œ C ì¹œí™”ì ì¸ API ìƒì„±"

#: src/interoperability/rust-with-c.md:6
msgid "Embedding your Rust project into an external build system"
msgstr "Rust í”„ë¡œì íŠ¸ë¥¼ ì™¸ë¶€ ë¹Œë“œ ì‹œìŠ¤í…œì— ì„ë² ë”©"

#: src/interoperability/rust-with-c.md:8
msgid ""
"Apart from `cargo` and `meson`, most build systems don't have native Rust "
"support. So you're most likely best off just using `cargo` for compiling "
"your crate and any dependencies."
msgstr ""
"`cargo`ì™€ `meson`ì„ ì œì™¸í•˜ê³  ëŒ€ë¶€ë¶„ì˜ ë¹Œë“œ ì‹œìŠ¤í…œì€ ë„¤ì´í‹°ë¸Œ Rust ì§€ì›ì´ "
"ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í¬ë ˆì´íŠ¸ì™€ ëª¨ë“  ì¢…ì†ì„±ì„ ì»´íŒŒì¼í•˜ëŠ” ë° `cargo`ë¥¼ ì‚¬ìš©í•˜ëŠ” "
"ê²ƒì´ ê°€ì¥ ì¢‹ìŠµë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:12
msgid "Setting up a project"
msgstr "í”„ë¡œì íŠ¸ ì„¤ì •"

#: src/interoperability/rust-with-c.md:14
msgid "Create a new `cargo` project as usual."
msgstr "í‰ì†Œì²˜ëŸ¼ ìƒˆë¡œìš´ `cargo` í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”."

#: src/interoperability/rust-with-c.md:16
msgid ""
"There are flags to tell `cargo` to emit a systems library, instead of its "
"regular rust target. This also allows you to set a different output name for "
"your library, if you want it to differ from the rest of your crate."
msgstr ""
"`cargo`ì—ê²Œ ì¼ë°˜ì ì¸ Rust íƒ€ê²Ÿ ëŒ€ì‹  ì‹œìŠ¤í…œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•˜ë„ë¡ ì§€ì‹œí•˜ëŠ” "
"í”Œë˜ê·¸ê°€ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë˜í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì¶œë ¥ ì´ë¦„ì„ í¬ë ˆì´íŠ¸ì˜ ë‚˜ë¨¸ì§€ "
"ë¶€ë¶„ê³¼ ë‹¤ë¥´ê²Œ ì„¤ì •í•˜ë ¤ëŠ” ê²½ìš° ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì„¤ì •í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:21
msgid ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # Creates dynamic lib\n"
"# crate-type = [\"staticlib\"] # Creates static lib\n"
"```"
msgstr ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # ë™ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒì„±\n"
"# crate-type = [\"staticlib\"] # ì •ì  ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒì„±\n"
"```"

#: src/interoperability/rust-with-c.md:28
msgid "Building a `C` API"
msgstr "`C` API ë¹Œë“œ"

#: src/interoperability/rust-with-c.md:30
msgid ""
"Because C++ has no stable ABI for the Rust compiler to target, we use `C` "
"for any interoperability between different languages. This is no exception "
"when using Rust inside of C and C++ code."
msgstr ""
"C++ëŠ” Rust ì»´íŒŒì¼ëŸ¬ê°€ ëŒ€ìƒìœ¼ë¡œ í•  ì•ˆì •ì ì¸ ABIë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šìœ¼ë¯€ë¡œ, ë‹¤ë¥¸ "
"ì–¸ì–´ ê°„ì˜ ëª¨ë“  ìƒí˜¸ ìš´ìš©ì„±ì„ ìœ„í•´ `C`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ëŠ” C ë° C++ ì½”ë“œ "
"ë‚´ì—ì„œ Rustë¥¼ ì‚¬ìš©í•  ë•Œë„ ì˜ˆì™¸ëŠ” ì•„ë‹™ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:34
msgid "`#[no_mangle]`"
msgstr "`#[no_mangle]`"

#: src/interoperability/rust-with-c.md:36
msgid ""
"The Rust compiler mangles symbol names differently than native code linkers "
"expect. As such, any function that Rust exports to be used outside of Rust "
"needs to be told not to be mangled by the compiler."
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” ë„¤ì´í‹°ë¸Œ ì½”ë“œ ë§ì»¤ê°€ ì˜ˆìƒí•˜ëŠ” ê²ƒê³¼ ë‹¤ë¥´ê²Œ ì‹¬ë³¼ ì´ë¦„ì„ "
"ë§¹ê¸€ë§í•©ë‹ˆë‹¤. ë”°ë¼ì„œ Rust ì™¸ë¶€ì—ì„œ ì‚¬ìš©ë  Rustê°€ ë‚´ë³´ë‚´ëŠ” ëª¨ë“  í•¨ìˆ˜ëŠ” "
"ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ë§¹ê¸€ë§ë˜ì§€ ì•Šë„ë¡ ì§€ì‹œí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:40
msgid "`extern \"C\"`"
msgstr "`extern \"C\"`"

#: src/interoperability/rust-with-c.md:42
msgid ""
"By default, any function you write in Rust will use the Rust ABI (which is "
"also not stabilized). Instead, when building outwards facing FFI APIs we "
"need to tell the compiler to use the system ABI."
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ Rustë¡œ ì‘ì„±í•˜ëŠ” ëª¨ë“  í•¨ìˆ˜ëŠ” Rust ABIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤(ì´ ë˜í•œ "
"ì•ˆì •í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤). ëŒ€ì‹ , ì™¸ë¶€ë¥¼ í–¥í•˜ëŠ” FFI APIë¥¼ ë¹Œë“œí•  ë•ŒëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ "
"ì‹œìŠ¤í…œ ABIë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì§€ì‹œí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:47
msgid ""
"Depending on your platform, you might want to target a specific ABI version, "
"which are documented [here](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""
"í”Œë«í¼ì— ë”°ë¼ íŠ¹ì • ABI ë²„ì „ì„ ëŒ€ìƒìœ¼ë¡œ ì§€ì •í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” [ì—¬ê¸°](https://"
"doc.rust-lang.org/reference/items/external-blocks.html)ì— ë¬¸ì„œí™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:52
msgid ""
"Putting these parts together, you get a function that looks roughly like "
"this."
msgstr ""
"ì´ëŸ¬í•œ ë¶€ë¶„ë“¤ì„ ì¢…í•©í•˜ë©´ ëŒ€ëµ ë‹¤ìŒê³¼ ê°™ì€ í•¨ìˆ˜ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:61
msgid ""
"Just as when using `C` code in your Rust project you now need to transform "
"data from and to a form that the rest of the application will understand."
msgstr ""
"Rust í”„ë¡œì íŠ¸ì—ì„œ `C` ì½”ë“œë¥¼ ì‚¬ìš©í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ì´ì œ ë‚˜ë¨¸ì§€ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ "
"ì´í•´í•  ìˆ˜ ìˆëŠ” í˜•ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë³€í™˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:64
msgid "Linking and greater project context."
msgstr "ë§í¬ ë° ë” ë„“ì€ í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸."

#: src/interoperability/rust-with-c.md:66
msgid ""
"So then, that's one half of the problem solved. How do you use this now?"
msgstr "ê·¸ë ‡ë‹¤ë©´ ë¬¸ì œì˜ ì ˆë°˜ì€ í•´ê²°ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì´ê²ƒì„ ì–´ë–»ê²Œ ì‚¬ìš©í•©ë‹ˆê¹Œ?"

#: src/interoperability/rust-with-c.md:69
msgid "**This very much depends on your project and/or build system**"
msgstr "**ì´ëŠ” í”„ë¡œì íŠ¸ ë°/ë˜ëŠ” ë¹Œë“œ ì‹œìŠ¤í…œì— ë”°ë¼ í¬ê²Œ ë‹¬ë¼ì§‘ë‹ˆë‹¤**"

#: src/interoperability/rust-with-c.md:71
msgid ""
"`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file, depending "
"on your platform and settings. This library can simply be linked by your "
"build system."
msgstr ""
"`cargo`ëŠ” í”Œë«í¼ ë° ì„¤ì •ì— ë”°ë¼ `my_lib.so`/`my_lib.dll` ë˜ëŠ” `my_lib.a` "
"íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤. ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë¹Œë“œ ì‹œìŠ¤í…œì— ì˜í•´ ê°„ë‹¨íˆ ë§í¬ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:75
msgid ""
"However, calling a Rust function from C requires a header file to declare "
"the function signatures."
msgstr ""
"ê·¸ëŸ¬ë‚˜ Cì—ì„œ Rust í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë ¤ë©´ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì„ ì–¸í•˜ëŠ” í—¤ë” íŒŒì¼ì´ "
"í•„ìš”í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:78
msgid ""
"Every function in your Rust-ffi API needs to have a corresponding header "
"function."
msgstr ""
"Rust-ffi APIì˜ ëª¨ë“  í•¨ìˆ˜ëŠ” í•´ë‹¹ í—¤ë” í•¨ìˆ˜ë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:85
msgid "would then become"
msgstr "ê·¸ëŸ¬ë©´ ~ê°€ ë©ë‹ˆë‹¤"

#: src/interoperability/rust-with-c.md:91
msgid "etc."
msgstr "ë“±."

#: src/interoperability/rust-with-c.md:93
msgid ""
"There is a tool to automate this process, called [cbindgen](https://"
"github.com/eqrion/cbindgen) which analyses your Rust code and then generates "
"headers for your C and C++ projects from it."
msgstr ""
"ì´ ê³¼ì •ì„ ìë™í™”í•˜ëŠ” ë„êµ¬ì¸ [cbindgen](https://github.com/eqrion/cbindgen)ì´ "
"ìˆìŠµë‹ˆë‹¤. ì´ ë„êµ¬ëŠ” Rust ì½”ë“œë¥¼ ë¶„ì„í•œ ë‹¤ìŒ C ë° C++ í”„ë¡œì íŠ¸ìš© í—¤ë”ë¥¼ "
"ìƒì„±í•©ë‹ˆë‹¤."

#: src/interoperability/rust-with-c.md:99
msgid ""
"At this point, using the Rust functions from C is as simple as including the "
"header and calling them!"
msgstr ""
"ì´ ì‹œì ì—ì„œ Cì—ì„œ Rust í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ í—¤ë”ë¥¼ í¬í•¨í•˜ê³  í˜¸ì¶œí•˜ëŠ” ê²ƒë§Œí¼ "
"ê°„ë‹¨í•©ë‹ˆë‹¤!"

#: src/interoperability/rust-with-c.md:103
msgid "\\\"my-rust-project.h\\\""
msgstr "\"my-rust-project.h\""

#: src/unsorted/speed-vs-size.md:1
msgid "Optimizations: the speed size tradeoff"
msgstr "ìµœì í™”: ì†ë„ì™€ í¬ê¸°ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„"

#: src/unsorted/speed-vs-size.md:3
msgid ""
"Everyone wants their program to be super fast and super small but it's "
"usually not possible to have both characteristics. This section discusses "
"the different optimization levels that `rustc` provides and how they affect "
"the execution time and binary size of a program."
msgstr ""
"ëª¨ë“  ì‚¬ëŒì€ ìì‹ ì˜ í”„ë¡œê·¸ë¨ì´ ë§¤ìš° ë¹ ë¥´ê³  ë§¤ìš° ì‘ê¸°ë¥¼ ì›í•˜ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë‘ "
"ê°€ì§€ íŠ¹ì„±ì„ ëª¨ë‘ ê°–ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” `rustc`ê°€ ì œê³µí•˜ëŠ” "
"ë‹¤ì–‘í•œ ìµœì í™” ìˆ˜ì¤€ê³¼ ì´ëŸ¬í•œ ìˆ˜ì¤€ì´ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ ì‹œê°„ ë° ë°”ì´ë„ˆë¦¬ í¬ê¸°ì— "
"ë¯¸ì¹˜ëŠ” ì˜í–¥ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:8
msgid "No optimizations"
msgstr "ìµœì í™” ì—†ìŒ"

#: src/unsorted/speed-vs-size.md:10
msgid ""
"This is the default. When you call `cargo build` you use the development "
"(AKA `dev`) profile. This profile is optimized for debugging so it enables "
"debug information and does _not_ enable any optimizations, i.e. it uses `-C "
"opt-level = 0`."
msgstr ""
"ì´ê²ƒì´ ê¸°ë³¸ê°’ì…ë‹ˆë‹¤. `cargo build`ë¥¼ í˜¸ì¶œí•˜ë©´ ê°œë°œ(ì¼ëª… `dev`) í”„ë¡œí•„ì„ "
"ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ í”„ë¡œí•„ì€ ë””ë²„ê¹…ì— ìµœì í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë””ë²„ê·¸ ì •ë³´ë¥¼ í™œì„±í™”í•˜ê³  "
"ìµœì í™”ë¥¼ í™œì„±í™”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¦‰, `-C opt-level = 0`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:15
msgid ""
"At least for bare metal development, debuginfo is zero cost in the sense "
"that it won't occupy space in Flash / ROM so we actually recommend that you "
"enable debuginfo in the release profile -- it is disabled by default. That "
"will let you use breakpoints when debugging release builds."
msgstr ""
"ì ì–´ë„ ë² ì–´ë©”íƒˆ ê°œë°œì˜ ê²½ìš°, ë””ë²„ê·¸ ì •ë³´ëŠ” í”Œë˜ì‹œ/ROM ê³µê°„ì„ ì°¨ì§€í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” "
"ì ì—ì„œ ë¹„ìš©ì´ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë¦´ë¦¬ìŠ¤ í”„ë¡œí•„ì—ì„œ ë””ë²„ê·¸ ì •ë³´ë¥¼ í™œì„±í™”í•˜ëŠ” ê²ƒì´ "
"ì¢‹ìŠµë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë¦´ë¦¬ìŠ¤ ë¹Œë“œë¥¼ ë””ë²„ê¹…í•  ë•Œ "
"ì¤‘ë‹¨ì ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:26
msgid ""
"No optimizations is great for debugging because stepping through the code "
"feels like you are executing the program statement by statement, plus you "
"can `print` stack variables and function arguments in GDB. When the code is "
"optimized, trying to print variables results in `$0 = <value optimized out>` "
"being printed."
msgstr ""
"ìµœì í™”ê°€ ì—†ìœ¼ë©´ ì½”ë“œë¥¼ í•œ ë¬¸ì¥ì”© ì‹¤í–‰í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§€ê¸° ë•Œë¬¸ì— ë””ë²„ê¹…ì— "
"ì¢‹ìŠµë‹ˆë‹¤. ë˜í•œ GDBì—ì„œ ìŠ¤íƒ ë³€ìˆ˜ì™€ í•¨ìˆ˜ ì¸ìˆ˜ë¥¼ `print`í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì½”ë“œê°€ "
"ìµœì í™”ë˜ë©´ ë³€ìˆ˜ë¥¼ ì¸ì‡„í•˜ë ¤ê³  í•˜ë©´ `$0 = <value optimized out>`ì´ ì¸ì‡„ë©ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:31
msgid ""
"The biggest downside of the `dev` profile is that the resulting binary will "
"be huge and slow. The size is usually more of a problem because unoptimized "
"binaries can occupy dozens of KiB of Flash, which your target device may not "
"have -- the result: your unoptimized binary doesn't fit in your device!"
msgstr ""
"`dev` í”„ë¡œí•„ì˜ ê°€ì¥ í° ë‹¨ì ì€ ê²°ê³¼ ë°”ì´ë„ˆë¦¬ê°€ ê±°ëŒ€í•˜ê³  ëŠë¦¬ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. "
"ìµœì í™”ë˜ì§€ ì•Šì€ ë°”ì´ë„ˆë¦¬ëŠ” ìˆ˜ì‹­ KiBì˜ í”Œë˜ì‹œë¥¼ ì°¨ì§€í•  ìˆ˜ ìˆìœ¼ë©° ëŒ€ìƒ ì¥ì¹˜ì— "
"ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í¬ê¸°ê°€ ì¼ë°˜ì ìœ¼ë¡œ ë” í° ë¬¸ì œì…ë‹ˆë‹¤. ê²°ê³¼: ìµœì í™”ë˜ì§€ ì•Šì€ "
"ë°”ì´ë„ˆë¦¬ê°€ ì¥ì¹˜ì— ë§ì§€ ì•ŠìŠµë‹ˆë‹¤!"

#: src/unsorted/speed-vs-size.md:36
msgid "Can we have smaller, debugger friendly binaries? Yes, there's a trick."
msgstr "ë” ì‘ê³  ë””ë²„ê±° ì¹œí™”ì ì¸ ë°”ì´ë„ˆë¦¬ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆì„ê¹Œìš”? ì˜ˆ, ë¹„ê²°ì´ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:38
msgid "Optimizing dependencies"
msgstr "ì¢…ì†ì„± ìµœì í™”"

#: src/unsorted/speed-vs-size.md:40
msgid ""
"There's a Cargo feature named [`profile-overrides`](https://doc.rust-"
"lang.org/cargo/reference/profiles.html#overrides) that lets you override the "
"optimization level of dependencies. You can use that feature to optimize all "
"dependencies for size while keeping the top crate unoptimized and debugger "
"friendly."
msgstr ""
"[`profile-overrides`](https://doc.rust-lang.org/cargo/reference/profiles.html#overrides)ë¼ëŠ” "
"Cargo ê¸°ëŠ¥ì´ ìˆì–´ ì¢…ì†ì„±ì˜ ìµœì í™” ìˆ˜ì¤€ì„ ì¬ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì„ "
"ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì¢…ì†ì„±ì„ í¬ê¸°ì— ë§ê²Œ ìµœì í™”í•˜ë©´ì„œ ìµœìƒìœ„ í¬ë ˆì´íŠ¸ëŠ” ìµœì í™”ë˜ì§€ "
"ì•Šê³  ë””ë²„ê±° ì¹œí™”ì ìœ¼ë¡œ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:45
msgid ""
"Beware that generic code can sometimes be optimized alongside the crate "
"where it is instantiated, rather than the crate where it is defined. If you "
"create an instance of a generic struct in your application and find that it "
"pulls in code with a large footprint, it may be that increasing the "
"optimisation level of the relevant dependencies has no effect."
msgstr ""
"ì œë„¤ë¦­ ì½”ë“œëŠ” ì •ì˜ëœ í¬ë ˆì´íŠ¸ê°€ ì•„ë‹Œ ì¸ìŠ¤í„´ìŠ¤í™”ëœ í¬ë ˆì´íŠ¸ì™€ í•¨ê»˜ ìµœì í™”ë  "
"ìˆ˜ ìˆë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì‹­ì‹œì˜¤. ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì œë„¤ë¦­ êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ "
"ë§Œë“¤ê³  í° ê³µê°„ì„ ì°¨ì§€í•˜ëŠ” ì½”ë“œë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²½ìš° ê´€ë ¨ ì¢…ì†ì„±ì˜ ìµœì í™” ìˆ˜ì¤€ì„ "
"ë†’ì—¬ë„ íš¨ê³¼ê°€ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:53
msgid "Here's an example:"
msgstr "ë‹¤ìŒì€ ì˜ˆì‹œì…ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:55
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"
msgstr ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"

#: src/unsorted/speed-vs-size.md:65
msgid "Without the override:"
msgstr "ì¬ì •ì˜ ì—†ì´:"

#: src/unsorted/speed-vs-size.md:78
msgid "With the override:"
msgstr "ì¬ì •ì˜ í¬í•¨:"

#: src/unsorted/speed-vs-size.md:91
msgid ""
"That's a 6 KiB reduction in Flash usage without any loss in the "
"debuggability of the top crate. If you step into a dependency then you'll "
"start seeing those `<value optimized out>` messages again but it's usually "
"the case that you want to debug the top crate and not the dependencies. And "
"if you _do_ need to debug a dependency then you can use the `profile-"
"overrides` feature to exclude a particular dependency from being optimized. "
"See example below:"
msgstr ""
"ìµœìƒìœ„ í¬ë ˆì´íŠ¸ì˜ ë””ë²„ê¹… ê°€ëŠ¥ì„±ì„ ìƒì§€ ì•Šê³  í”Œë˜ì‹œ ì‚¬ìš©ëŸ‰ì´ 6KiB "
"ê°ì†Œí–ˆìŠµë‹ˆë‹¤. ì¢…ì†ì„±ìœ¼ë¡œ ë“¤ì–´ê°€ë©´ `<value optimized out>` ë©”ì‹œì§€ê°€ ë‹¤ì‹œ "
"í‘œì‹œë˜ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ì¢…ì†ì„±ì´ ì•„ë‹Œ ìµœìƒìœ„ í¬ë ˆì´íŠ¸ë¥¼ ë””ë²„ê·¸í•˜ë ¤ëŠ” ê²½ìš°ì…ë‹ˆë‹¤. "
"ê·¸ë¦¬ê³  ì¢…ì†ì„±ì„ ë””ë²„ê·¸í•´ì•¼ í•˜ëŠ” ê²½ìš° `profile-overrides` ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • "
"ì¢…ì†ì„±ì„ ìµœì í™”ì—ì„œ ì œì™¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/unsorted/speed-vs-size.md:98
msgid ""
"```toml\n"
"# ..\n"
"\n"
"# don't optimize the `cortex-m-rt` crate\n"
"[profile.dev.package.cortex-m-rt] # +\n"
"opt-level = 0 # +\n"
"\n"
"# but do optimize all the other dependencies\n"
"[profile.dev.package.\"*\"]\n"
"codegen-units = 1 # better optimizations\n"
"opt-level = \"z\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:111
msgid "Now the top crate and `cortex-m-rt` are debugger friendly!"
msgstr "ì´ì œ ìµœìƒìœ„ í¬ë ˆì´íŠ¸ì™€ `cortex-m-rt`ëŠ” ë””ë²„ê±° ì¹œí™”ì ì…ë‹ˆë‹¤!"

#: src/unsorted/speed-vs-size.md:113
msgid "Optimize for speed"
msgstr "ì†ë„ ìµœì í™”"

#: src/unsorted/speed-vs-size.md:115
msgid ""
"As of 2018-09-18 `rustc` supports three \"optimize for speed\" levels: `opt-"
"level = 1`, `2` and `3`. When you run `cargo build --release` you are using "
"the release profile which defaults to `opt-level = 3`."
msgstr ""
"2018-09-18 ê¸°ì¤€ìœ¼ë¡œ `rustc`ëŠ” ì„¸ ê°€ì§€ \"ì†ë„ ìµœì í™”\" ìˆ˜ì¤€ì„ ì§€ì›í•©ë‹ˆë‹¤: "
"`opt-level = 1`, `2` ë° `3`. `cargo build --release`ë¥¼ ì‹¤í–‰í•˜ë©´ ê¸°ë³¸ì ìœ¼ë¡œ "
"`opt-level = 3`ì¸ ë¦´ë¦¬ìŠ¤ í”„ë¡œí•„ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:119
msgid ""
"Both `opt-level = 2` and `3` optimize for speed at the expense of binary "
"size, but level `3` does more vectorization and inlining than level `2`. In "
"particular, you'll see that at `opt-level` equal to or greater than `2` LLVM "
"will unroll loops. Loop unrolling has a rather high cost in terms of Flash / "
"ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also "
"halve the execution time given the right conditions (e.g. number of "
"iterations is big enough)."
msgstr ""
"`opt-level = 2`ì™€ `3` ëª¨ë‘ ë°”ì´ë„ˆë¦¬ í¬ê¸°ë¥¼ í¬ìƒí•˜ì—¬ ì†ë„ë¥¼ ìµœì í™”í•˜ì§€ë§Œ, "
"ìˆ˜ì¤€ `3`ì€ ìˆ˜ì¤€ `2`ë³´ë‹¤ ë” ë§ì€ ë²¡í„°í™” ë° ì¸ë¼ì´ë‹ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. íŠ¹íˆ "
"`opt-level`ì´ `2` ì´ìƒì´ë©´ LLVMì´ ë£¨í”„ë¥¼ ì–¸ë¡¤ë§í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ë£¨í”„ ì–¸ë¡¤ë§ì€ í”Œë˜ì‹œ/ROM ì¸¡ë©´ì—ì„œ ë¹„ìš©ì´ ìƒë‹¹íˆ ë†’ì§€ë§Œ(ì˜ˆ: ì´ ë°°ì—´ ë£¨í”„ë¥¼ "
"0ìœ¼ë¡œ ë§Œë“œëŠ” ë° 26ë°”ì´íŠ¸ì—ì„œ 194ë°”ì´íŠ¸ë¡œ) ì˜¬ë°”ë¥¸ ì¡°ê±´(ì˜ˆ: ë°˜ë³µ íšŸìˆ˜ê°€ "
"ì¶©ë¶„íˆ í¼)ì´ ì£¼ì–´ì§€ë©´ ì‹¤í–‰ ì‹œê°„ì„ ì ˆë°˜ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:127
msgid ""
"Currently there's no way to disable loop unrolling in `opt-level = 2` and "
"`3` so if you can't afford its cost you should optimize your program for "
"size."
msgstr "í˜„ì¬ `opt-level = 2` ë° `3`ì—ì„œ ë£¨í”„ ì–¸ë¡¤ë§ì„ ë¹„í™œì„±í™”í•  ë°©ë²•ì´ ì—†ìœ¼ë¯€ë¡œ ë¹„ìš©ì„ ê°ë‹¹í•  ìˆ˜ ì—†ë‹¤ë©´ í”„ë¡œê·¸ë¨ì„ í¬ê¸°ì— ë§ê²Œ ìµœì í™”í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:130
msgid "Optimize for size"
msgstr "í¬ê¸° ìµœì í™”"

#: src/unsorted/speed-vs-size.md:132
msgid ""
"As of 2018-09-18 `rustc` supports two \"optimize for size\" levels: `opt-"
"level = \"s\"` and `\"z\"`. These names were inherited from clang / LLVM and "
"are not too descriptive but `\"z\"` is meant to give the idea that it "
"produces smaller binaries than `\"s\"`."
msgstr ""
"2018-09-18 ê¸°ì¤€ìœ¼ë¡œ `rustc`ëŠ” ë‘ ê°€ì§€ \"í¬ê¸° ìµœì í™”\" ìˆ˜ì¤€ì„ ì§€ì›í•©ë‹ˆë‹¤: "
"`opt-level = \"s\"` ë° `\"z\"`. ì´ ì´ë¦„ë“¤ì€ clang / LLVMì—ì„œ ìƒì†ë˜ì—ˆìœ¼ë©° "
"ê·¸ë‹¤ì§€ ì„¤ëª…ì ì´ì§€ëŠ” ì•Šì§€ë§Œ `\"z\"`ëŠ” `\"s\"`ë³´ë‹¤ ì‘ì€ ë°”ì´ë„ˆë¦¬ë¥¼ "
"ìƒì„±í•œë‹¤ëŠ” ì•„ì´ë””ì–´ë¥¼ ì œê³µí•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤."

#: src/unsorted/speed-vs-size.md:137
msgid ""
"If you want your release binaries to be optimized for size then change the "
"`profile.release.opt-level` setting in `Cargo.toml` as shown below."
msgstr ""
"ë¦´ë¦¬ìŠ¤ ë°”ì´ë„ˆë¦¬ë¥¼ í¬ê¸°ì— ë§ê²Œ ìµœì í™”í•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì´ `Cargo.toml`ì—ì„œ "
"`profile.release.opt-level` ì„¤ì •ì„ ë³€ê²½í•˜ì‹­ì‹œì˜¤."

#: src/unsorted/speed-vs-size.md:140
msgid ""
"```toml\n"
"[profile.release]\n"
"# or \"z\"\n"
"opt-level = \"s\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:146
msgid ""
"These two optimization levels greatly reduce LLVM's inline threshold, a "
"metric used to decide whether to inline a function or not. One of Rust "
"principles are zero cost abstractions; these abstractions tend to use a lot "
"of newtypes and small functions to hold invariants (e.g. functions that "
"borrow an inner value like `deref`, `as_ref`) so a low inline threshold can "
"make LLVM miss optimization opportunities (e.g. eliminate dead branches, "
"inline calls to closures)."
msgstr ""

#: src/unsorted/speed-vs-size.md:154
msgid ""
"When optimizing for size you may want to try increasing the inline threshold "
"to see if that has any effect on the binary size. The recommended way to "
"change the inline threshold is to append the `-C inline-threshold` flag to "
"the other rustflags in `.cargo/config.toml`."
msgstr ""

#: src/unsorted/speed-vs-size.md:159
msgid ""
"```toml\n"
"# .cargo/config.toml\n"
"# this assumes that you are using the cortex-m-quickstart template\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\n"
"  # ..\n"
"  \"-C\", \"inline-threshold=123\", # +\n"
"]\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:169
msgid ""
"What value to use? [As of 1.29.0 these are the inline thresholds that the "
"different optimization levels use](https://github.com/rust-lang/rust/blob/"
"1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122):"
msgstr ""

#: src/unsorted/speed-vs-size.md:174
msgid "`opt-level = 3` uses 275"
msgstr ""

#: src/unsorted/speed-vs-size.md:175
msgid "`opt-level = 2` uses 225"
msgstr ""

#: src/unsorted/speed-vs-size.md:176
msgid "`opt-level = \"s\"` uses 75"
msgstr ""

#: src/unsorted/speed-vs-size.md:177
msgid "`opt-level = \"z\"` uses 25"
msgstr ""

#: src/unsorted/speed-vs-size.md:179
msgid "You should try `225` and `275` when optimizing for size."
msgstr ""

#: src/unsorted/math.md:1
msgid "Performing math functionality with `#[no_std]`"
msgstr "`#[no_std]`ë¡œ ìˆ˜í•™ ê¸°ëŠ¥ ìˆ˜í–‰"

#: src/unsorted/math.md:3
msgid ""
"If you want to perform math related functionality like calculating the "
"squareroot or the exponential of a number and you have the full standard "
"library available, your code might look like this:"
msgstr ""
"ìˆ«ìì˜ ì œê³±ê·¼ ë˜ëŠ” ì§€ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” ê²ƒê³¼ ê°™ì€ ìˆ˜í•™ ê´€ë ¨ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ê³  ì‹¶ê³  "
"ì „ì²´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ë©´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/unsorted/math.md:8
msgid "//! Some mathematical functions with standard support available\n"
msgstr "//! í‘œì¤€ ì§€ì›ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì¼ë¶€ ìˆ˜í•™ í•¨ìˆ˜\n"

#: src/unsorted/math.md:19 src/unsorted/math.md:53
msgid "\"Floored test float {} to {}\""
msgstr ""

#: src/unsorted/math.md:20 src/unsorted/math.md:54
msgid "\"The square root of {} is {}\""
msgstr ""

#: src/unsorted/math.md:21 src/unsorted/math.md:55
msgid "\"The sinus of four is {}\""
msgstr ""

#: src/unsorted/math.md:23 src/unsorted/math.md:57
msgid "\"The exponential of four to the base e is {}\""
msgstr ""

#: src/unsorted/math.md:29
msgid ""
"Without standard library support, these functions are not available. An "
"external crate like [`libm`](https://crates.io/crates/libm) can be used "
"instead. The example code would then look like this:"
msgstr ""
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§€ì› ì—†ì´ëŠ” ì´ëŸ¬í•œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì‹  "
"[`libm`](https://crates.io/crates/libm)ê³¼ ê°™ì€ ì™¸ë¶€ í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì˜ˆì œ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/unsorted/math.md:69
msgid ""
"If you need to perform more complex operations like DSP signal processing or "
"advanced linear algebra on your MCU, the following crates might help you"
msgstr ""
"MCUì—ì„œ DSP ì‹ í˜¸ ì²˜ë¦¬ ë˜ëŠ” ê³ ê¸‰ ì„ í˜• ëŒ€ìˆ˜ì™€ ê°™ì€ ë” ë³µì¡í•œ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ "
"í•˜ëŠ” ê²½ìš° ë‹¤ìŒ í¬ë ˆì´íŠ¸ê°€ ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsorted/math.md:72
msgid ""
"[CMSIS DSP library binding](https://github.com/jacobrosenthal/cmsis-dsp-sys)"
msgstr "[CMSIS DSP ë¼ì´ë¸ŒëŸ¬ë¦¬ ë°”ì¸ë”©](https://github.com/jacobrosenthal/cmsis-dsp-sys)"

#: src/unsorted/math.md:73
msgid "[`constgebra`](https://crates.io/crates/constgebra)"
msgstr "[`constgebra`](https://crates.io/crates/constgebra)"

#: src/unsorted/math.md:74
msgid "[`micromath`](https://github.com/tarcieri/micromath)"
msgstr "[`micromath`](https://github.com/tarcieri/micromath)"

#: src/unsorted/math.md:75
msgid "[`microfft`](https://crates.io/crates/microfft)"
msgstr "[`microfft`](https://crates.io/crates/microfft)"

#: src/unsorted/math.md:76
msgid "[`nalgebra`](https://github.com/dimforge/nalgebra)"
msgstr "[`nalgebra`](https://github.com/dimforge/nalgebra)"

#: src/appendix/glossary.md:3
msgid ""
"The embedded ecosystem is full of different protocols, hardware components "
"and vendor-specific things that use their own terms and abbreviations. This "
"Glossary attempts to list them with pointers for understanding them better."
msgstr ""
"ì„ë² ë””ë“œ ìƒíƒœê³„ëŠ” ë‹¤ì–‘í•œ í”„ë¡œí† ì½œ, í•˜ë“œì›¨ì–´ êµ¬ì„± ìš”ì†Œ ë° ê³µê¸‰ì—…ì²´ë³„ ìš©ì–´ì™€ "
"ì•½ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë“¤ë¡œ ê°€ë“í•©ë‹ˆë‹¤. ì´ ìš©ì–´ì§‘ì€ ì´ëŸ¬í•œ ê²ƒë“¤ì„ ë” ì˜ ì´í•´í•˜ê¸° "
"ìœ„í•œ í¬ì¸í„°ì™€ í•¨ê»˜ ë‚˜ì—´í•˜ë ¤ê³  í•©ë‹ˆë‹¤."

#: src/appendix/glossary.md:7
msgid "BSP"
msgstr "BSP"

#: src/appendix/glossary.md:9
msgid ""
"A Board Support Crate provides a high level interface configured for a "
"specific board. It usually depends on a [HAL](#hal) crate. There is a more "
"detailed description on the [memory-mapped registers page](../start/"
"registers.md) or for a broader overview see [this video](https://youtu.be/"
"vLYit_HHPaY)."
msgstr ""
"ë³´ë“œ ì§€ì› í¬ë ˆì´íŠ¸ëŠ” íŠ¹ì • ë³´ë“œì— ëŒ€í•´ êµ¬ì„±ëœ ê³ ìˆ˜ì¤€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. "
"ì¼ë°˜ì ìœ¼ë¡œ [HAL](#hal) í¬ë ˆì´íŠ¸ì— ì˜ì¡´í•©ë‹ˆë‹¤. [ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„° "
"í˜ì´ì§€](../start/registers.md)ì— ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆê±°ë‚˜ ë” ë„“ì€ ê°œìš”ëŠ” "
"[ì´ ë¹„ë””ì˜¤](https://youtu.be/vLYit_HHPaY)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:14
msgid "FPU"
msgstr "FPU"

#: src/appendix/glossary.md:16
msgid ""
"Floating-point Unit. A 'math processor' running only operations on floating-"
"point numbers."
msgstr ""
"ë¶€ë™ ì†Œìˆ˜ì  ì¥ì¹˜. ë¶€ë™ ì†Œìˆ˜ì  ìˆ«ìì— ëŒ€í•œ ì—°ì‚°ë§Œ ì‹¤í–‰í•˜ëŠ” 'ìˆ˜í•™ í”„ë¡œì„¸ì„œ'."

#: src/appendix/glossary.md:18
msgid "HAL"
msgstr "HAL"

#: src/appendix/glossary.md:20
msgid ""
"A Hardware Abstraction Layer crate provides a developer friendly interface "
"to a microcontroller's features and peripherals. It is usually implemented "
"on top of a [Peripheral Access Crate (PAC)](#pac). It may also implement "
"traits from the [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"crate. There is a more detailed description on the [memory-mapped registers "
"page](../start/registers.md) or for a broader overview see [this video]"
"(https://youtu.be/vLYit_HHPaY)."
msgstr ""
"í•˜ë“œì›¨ì–´ ì¶”ìƒí™” ê³„ì¸µ í¬ë ˆì´íŠ¸ëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ê¸°ëŠ¥ê³¼ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ "
"ê°œë°œì ì¹œí™”ì ì¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ [ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ "
"í¬ë ˆì´íŠ¸(PAC)](#pac) ìœ„ì— êµ¬í˜„ë©ë‹ˆë‹¤. ë˜í•œ [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"í¬ë ˆì´íŠ¸ì˜ íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. [ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„° "
"í˜ì´ì§€](../start/registers.md)ì— ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆê±°ë‚˜ ë” ë„“ì€ ê°œìš”ëŠ” "
"[ì´ ë¹„ë””ì˜¤](https://youtu.be/vLYit_HHPaY)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:28
msgid ""
"Sometimes referred to as `IÂ²C` or Inter-IC. It is a protocol meant for "
"hardware communication within a single integrated circuit. See [here]"
"(https://en.wikipedia.org/wiki/I2c) for more details"
msgstr ""
"ë•Œë¡œëŠ” `IÂ²C` ë˜ëŠ” Inter-ICë¼ê³ ë„ í•©ë‹ˆë‹¤. ë‹¨ì¼ ì§‘ì  íšŒë¡œ ë‚´ì—ì„œ í•˜ë“œì›¨ì–´ í†µì‹ ì„ "
"ìœ„í•œ í”„ë¡œí† ì½œì…ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](https://en.wikipedia.org/wiki/I2c)ë¥¼ "
"ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:33
msgid "PAC"
msgstr "PAC"

#: src/appendix/glossary.md:35
msgid ""
"A Peripheral Access Crate provides access to a microcontroller's "
"peripherals. It is one of the lower level crates and is usually generated "
"directly from the provided [SVD](#svd), often using [svd2rust](https://"
"github.com/rust-embedded/svd2rust/). The [Hardware Abstraction Layer](#hal) "
"would usually depend on this crate. There is a more detailed description on "
"the [memory-mapped registers page](../start/registers.md) or for a broader "
"overview see [this video](https://youtu.be/vLYit_HHPaY)."
msgstr ""
"ì£¼ë³€ ì¥ì¹˜ ì ‘ê·¼ í¬ë ˆì´íŠ¸ëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ì ‘ê·¼ì„ ì œê³µí•©ë‹ˆë‹¤. "
"ì´ëŠ” ì €ìˆ˜ì¤€ í¬ë ˆì´íŠ¸ ì¤‘ í•˜ë‚˜ì´ë©° ì¼ë°˜ì ìœ¼ë¡œ ì œê³µëœ [SVD](#svd)ì—ì„œ ì§ì ‘ ìƒì„±ë˜ë©°, "
"ì¢…ì¢… [svd2rust](https://github.com/rust-embedded/svd2rust/)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. "
"[í•˜ë“œì›¨ì–´ ì¶”ìƒí™” ê³„ì¸µ](#hal)ì€ ì¼ë°˜ì ìœ¼ë¡œ ì´ í¬ë ˆì´íŠ¸ì— ì˜ì¡´í•©ë‹ˆë‹¤. [ë©”ëª¨ë¦¬ ë§¤í•‘ "
"ë ˆì§€ìŠ¤í„° í˜ì´ì§€](../start/registers.md)ì— ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆê±°ë‚˜ ë” ë„“ì€ ê°œìš”ëŠ” "
"[ì´ ë¹„ë””ì˜¤](https://youtu.be/vLYit_HHPaY)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:44
msgid ""
"Serial Peripheral Interface. See [here](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface) for more information."
msgstr ""
"ì§ë ¬ ì£¼ë³€ ì¥ì¹˜ ì¸í„°í˜ì´ìŠ¤. ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:48
msgid "SVD"
msgstr "SVD"

#: src/appendix/glossary.md:50
msgid ""
"System View Description is an XML file format used to describe the "
"programmers view of a microcontroller device. You can read more about it on "
"[the ARM CMSIS documentation site](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)."
msgstr ""
"ì‹œìŠ¤í…œ ë·° ì„¤ëª…ì€ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ì¥ì¹˜ì˜ í”„ë¡œê·¸ë˜ë¨¸ ë·°ë¥¼ ì„¤ëª…í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” "
"XML íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. [ARM CMSIS ë¬¸ì„œ ì‚¬ì´íŠ¸](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)ì—ì„œ ìì„¸í•œ ë‚´ìš©ì„ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/appendix/glossary.md:54
msgid "UART"
msgstr "UART"

#: src/appendix/glossary.md:56
msgid ""
"Universal asynchronous receiver-transmitter. See [here](https://"
"en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
"ë²”ìš© ë¹„ë™ê¸° ìˆ˜ì‹ ê¸°-ì†¡ì‹ ê¸°. ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](https://en.wikipedia.org/wiki/"
"Universal_asynchronous_receiver-transmitter)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/appendix/glossary.md:60
msgid "USART"
msgstr "USART"

#: src/appendix/glossary.md:62
msgid ""
"Universal synchronous and asynchronous receiver-transmitter. See [here]"
"(https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
"ë²”ìš© ë™ê¸° ë° ë¹„ë™ê¸° ìˆ˜ì‹ ê¸°-ì†¡ì‹ ê¸°. ìì„¸í•œ ë‚´ìš©ì€ [ì—¬ê¸°](https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter)ë¥¼ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."
