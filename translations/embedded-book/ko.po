msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-10-15T16:19:26+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:19:26+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1 src/intro/no-std.md:36
msgid "Summary"
msgstr "ìš”ì•½"

#: src/SUMMARY.md:12 src/intro/index.md:1
msgid "Introduction"
msgstr "ì†Œê°œ"

#: src/SUMMARY.md:13 src/SUMMARY.md:23 src/start/hardware.md:1
msgid "Hardware"
msgstr "í•˜ë“œì›¨ì–´"

#: src/SUMMARY.md:14
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:15 src/intro/tooling.md:1
msgid "Tooling"
msgstr "ë„êµ¬"

#: src/SUMMARY.md:16
msgid "Installation"
msgstr "ì„¤ì¹˜"

#: src/SUMMARY.md:17 src/intro/install/linux.md:1
msgid "Linux"
msgstr "ë¦¬ëˆ…ìŠ¤"

#: src/SUMMARY.md:18
msgid "MacOS"
msgstr "ë§¥OS"

#: src/SUMMARY.md:19 src/intro/install/windows.md:1
msgid "Windows"
msgstr "ìœˆë„ìš°"

#: src/SUMMARY.md:20 src/intro/install/verify.md:1
msgid "Verify Installation"
msgstr "ì„¤ì¹˜ í™•ì¸"

#: src/SUMMARY.md:21
msgid "Getting started"
msgstr "ì‹œì‘í•˜ê¸°"

#: src/SUMMARY.md:22 src/intro/install/windows.md:35 src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/SUMMARY.md:24
msgid "Memory-mapped Registers"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°"

#: src/SUMMARY.md:25 src/start/semihosting.md:1
msgid "Semihosting"
msgstr "ì„¸ë¯¸í˜¸ìŠ¤íŒ…"

#: src/SUMMARY.md:26 src/start/panicking.md:1
msgid "Panicking"
msgstr "íŒ¨ë‹‰"

#: src/SUMMARY.md:27 src/start/exceptions.md:1
msgid "Exceptions"
msgstr "ì˜ˆì™¸"

#: src/SUMMARY.md:28 src/intro/index.md:50 src/intro/index.md:64
#: src/start/interrupts.md:1
msgid "Interrupts"
msgstr "ì¸í„°ëŸ½íŠ¸"

#: src/SUMMARY.md:29 src/start/io.md:1
msgid "IO"
msgstr "ì…ì¶œë ¥"

#: src/SUMMARY.md:30 src/peripherals/index.md:1
msgid "Peripherals"
msgstr "ì£¼ë³€ì¥ì¹˜"

#: src/SUMMARY.md:31
msgid "A first attempt in Rust"
msgstr "Rustë¡œ ì²« ë²ˆì§¸ ì‹œë„"

#: src/SUMMARY.md:32 src/peripherals/borrowck.md:13
msgid "The Borrow Checker"
msgstr "ë¹Œë¦¼ ê²€ì‚¬ê¸°"

#: src/SUMMARY.md:33 src/peripherals/singletons.md:1
msgid "Singletons"
msgstr "ì‹±ê¸€í†¤"

#: src/SUMMARY.md:34 src/static-guarantees/index.md:1
msgid "Static Guarantees"
msgstr "ì •ì  ë³´ì¥"

#: src/SUMMARY.md:35 src/static-guarantees/typestate-programming.md:1
msgid "Typestate Programming"
msgstr "íƒ€ì… ìƒíƒœ í”„ë¡œê·¸ë˜ë°"

#: src/SUMMARY.md:36 src/static-guarantees/state-machines.md:1
msgid "Peripherals as State Machines"
msgstr "ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œì„œì˜ ì£¼ë³€ì¥ì¹˜"

#: src/SUMMARY.md:37 src/static-guarantees/design-contracts.md:1
msgid "Design Contracts"
msgstr "ì„¤ê³„ ê³„ì•½"

#: src/SUMMARY.md:38 src/static-guarantees/zero-cost-abstractions.md:1
msgid "Zero Cost Abstractions"
msgstr "ì œë¡œ ë¹„ìš© ì¶”ìƒí™”"

#: src/SUMMARY.md:39 src/portability/index.md:1
msgid "Portability"
msgstr "ì´ì‹ì„±"

#: src/SUMMARY.md:40 src/concurrency/index.md:1
msgid "Concurrency"
msgstr "ë™ì‹œì„±"

#: src/SUMMARY.md:41 src/collections/index.md:1
msgid "Collections"
msgstr "ì»¬ë ‰ì…˜"

#: src/SUMMARY.md:42 src/design-patterns/index.md:1
msgid "Design Patterns"
msgstr "ë””ìì¸ íŒ¨í„´"

#: src/SUMMARY.md:43
msgid "HALs"
msgstr "HAL"

#: src/SUMMARY.md:44
msgid "Checklist"
msgstr "ì²´í¬ë¦¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:45 src/design-patterns/hal/naming.md:1
msgid "Naming"
msgstr "ëª…ëª…"

#: src/SUMMARY.md:46 src/SUMMARY.md:51
#: src/design-patterns/hal/interoperability.md:1
#: src/interoperability/index.md:1
msgid "Interoperability"
msgstr "ìƒí˜¸ ìš´ìš©ì„±"

#: src/SUMMARY.md:47 src/design-patterns/hal/predictability.md:1
msgid "Predictability"
msgstr "ì˜ˆì¸¡ ê°€ëŠ¥ì„±"

#: src/SUMMARY.md:48
msgid "GPIO"
msgstr "GPIO"

#: src/SUMMARY.md:49 src/c-tips/index.md:1
msgid "Tips for embedded C developers"
msgstr "ì„ë² ë””ë“œ C ê°œë°œìë¥¼ ìœ„í•œ íŒ"

#: src/SUMMARY.md:52 src/interoperability/c-with-rust.md:1
msgid "A little C with your Rust"
msgstr "Rustì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ C"

#: src/SUMMARY.md:53 src/interoperability/rust-with-c.md:1
msgid "A little Rust with your C"
msgstr "Cì™€ í•¨ê»˜í•˜ëŠ” ì•½ê°„ì˜ Rust"

#: src/SUMMARY.md:54 src/unsorted/index.md:1
msgid "Unsorted topics"
msgstr "ë¯¸ë¶„ë¥˜ ì£¼ì œ"

#: src/SUMMARY.md:55
msgid "Optimizations: The speed size tradeoff"
msgstr "ìµœì í™”: ì†ë„ì™€ í¬ê¸°ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„"

#: src/SUMMARY.md:56
msgid "Performing Math Functionality"
msgstr "ìˆ˜í•™ ê¸°ëŠ¥ ìˆ˜í–‰"

#: src/SUMMARY.md:60 src/appendix/glossary.md:1
msgid "Appendix A: Glossary"
msgstr "ë¶€ë¡ A: ìš©ì–´ì§‘"

#: src/intro/index.md:3
msgid ""
"Welcome to The Embedded Rust Book: An introductory book about using the Rust "
"Programming Language on \"Bare Metal\" embedded systems, such as "
"Microcontrollers."
msgstr ""
"ì„ë² ë””ë“œ Rust ë¶ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê°™ì€ \"ë² ì–´ ë©”íƒˆ\" "
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì—ì„œ Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ì…ë¬¸ì„œì…ë‹ˆë‹¤."
"ì„ë² ë””ë“œ Rust ë¶ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê°™ì€ \"ë² ì–´ ë©”íƒˆ\" "
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì—ì„œ Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ì…ë¬¸ì„œì…ë‹ˆë‹¤."
"ì„ë² ë””ë“œ Rust ë¶ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê°™ì€ \"ë² ì–´ ë©”íƒˆ\" "
"ì„ë² ë””ë“œ ì‹œìŠ¤í…œì—ì„œ Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ì…ë¬¸ì„œì…ë‹ˆë‹¤."

#: src/intro/index.md:6
msgid "Who Embedded Rust is For"
msgstr "ì„ë² ë””ë“œ RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€"

#: src/intro/index.md:7
msgid ""
"Embedded Rust is for everyone who wants to do embedded programming while "
"taking advantage of the higher-level concepts and safety guarantees the Rust "
"language provides. (See also [Who Rust Is For](https://doc.rust-lang.org/"
"book/ch00-00-introduction.html))"
msgstr ""
"ì„ë² ë””ë“œ RustëŠ” Rust ì–¸ì–´ê°€ ì œê³µí•˜ëŠ” ê³ ìˆ˜ì¤€ ê°œë…ê³¼ ì•ˆì „ì„± ë³´ì¥ì„ í™œìš©í•˜ë©´ì„œ "
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê³ ì í•˜ëŠ” ëª¨ë“  ì‚¬ëŒì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. ([RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)ë„ ì°¸ì¡°í•˜ì„¸ìš”)"
"ì„ë² ë””ë“œ RustëŠ” Rust ì–¸ì–´ê°€ ì œê³µí•˜ëŠ” ê³ ìˆ˜ì¤€ ê°œë…ê³¼ ì•ˆì „ì„± ë³´ì¥ì„ í™œìš©í•˜ë©´ì„œ "
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê³ ì í•˜ëŠ” ëª¨ë“  ì‚¬ëŒì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. ([RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)ë„ ì°¸ì¡°í•˜ì„¸ìš”)"
"ì„ë² ë””ë“œ RustëŠ” Rust ì–¸ì–´ê°€ ì œê³µí•˜ëŠ” ê³ ìˆ˜ì¤€ ê°œë…ê³¼ ì•ˆì „ì„± ë³´ì¥ì„ í™œìš©í•˜ë©´ì„œ "
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê³ ì í•˜ëŠ” ëª¨ë“  ì‚¬ëŒì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. ([RustëŠ” ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)ë„ ì°¸ì¡°í•˜ì„¸ìš”)"

#: src/intro/index.md:10
msgid "Scope"
msgstr "ë²”ìœ„"

#: src/intro/index.md:12
msgid "The goals of this book are:"
msgstr "ì´ ì±…ì˜ ëª©í‘œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/intro/index.md:14
msgid ""
"Get developers up to speed with embedded Rust development. i.e. How to set "
"up a development environment."
msgstr ""
"ê°œë°œìë“¤ì´ ì„ë² ë””ë“œ Rust ê°œë°œì— ë¹ ë¥´ê²Œ ì ì‘í•  ìˆ˜ ìˆë„ë¡ ë•ìŠµë‹ˆë‹¤. ì¦‰, ê°œë°œ í™˜ê²½ì„ "
"ì„¤ì •í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/index.md:17
msgid ""
"Share _current_ best practices about using Rust for embedded development. "
"i.e. How to best use Rust language features to write more correct embedded "
"software."
msgstr ""
"ì„ë² ë””ë“œ ê°œë°œì—ì„œ Rustë¥¼ ì‚¬ìš©í•˜ëŠ” _í˜„ì¬ì˜_ ëª¨ë²” ì‚¬ë¡€ë¥¼ ê³µìœ í•©ë‹ˆë‹¤. ì¦‰, Rust ì–¸ì–´ "
"ê¸°ëŠ¥ì„ ìµœëŒ€í•œ í™œìš©í•˜ì—¬ ë” ì •í™•í•œ ì„ë² ë””ë“œ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/index.md:21
msgid ""
"Serve as a cookbook in some cases. e.g. How do I mix C and Rust in a single "
"project?"
msgstr ""
"ê²½ìš°ì— ë”°ë¼ì„œëŠ” ìš”ë¦¬ì±… ì—­í• ì„ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•˜ë‚˜ì˜ í”„ë¡œì íŠ¸ì—ì„œ Cì™€ Rustë¥¼ "
"ì–´ë–»ê²Œ í˜¼í•©í•  ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/intro/index.md:24
msgid ""
"This book tries to be as general as possible but to make things easier for "
"both the readers and the writers it uses the ARM Cortex-M architecture in "
"all its examples. However, the book doesn't assume that the reader is "
"familiar with this particular architecture and explains details particular "
"to this architecture where required."
msgstr ""
"ì´ ì±…ì€ ê°€ëŠ¥í•œ í•œ ì¼ë°˜ì ì´ë ¤ê³  í•˜ì§€ë§Œ ë…ìì™€ ì €ì ëª¨ë‘ì—ê²Œ í¸ì˜ë¥¼ ìœ„í•´ ëª¨ë“  ì˜ˆì œì—ì„œ "
"ARM Cortex-M ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ì±…ì€ ë…ìê°€ ì´ íŠ¹ì • ì•„í‚¤í…ì²˜ì— "
"ìµìˆ™í•˜ë‹¤ê³  ê°€ì •í•˜ì§€ ì•Šìœ¼ë©°, í•„ìš”í•œ ê²½ìš° ì´ ì•„í‚¤í…ì²˜ì— íŠ¹ì •í•œ ì„¸ë¶€ì‚¬í•­ì„ ì„¤ëª…í•©ë‹ˆë‹¤."

#: src/intro/index.md:30
msgid "Who This Book is For"
msgstr "ì´ ì±…ì€ ëˆ„êµ¬ë¥¼ ìœ„í•œ ê²ƒì¸ê°€"

#: src/intro/index.md:31
msgid ""
"This book caters towards people with either some embedded background or some "
"Rust background, however we believe everybody curious about embedded Rust "
"programming can get something out of this book. For those without any prior "
"knowledge we suggest you read the \"Assumptions and Prerequisites\" section "
"and catch up on missing knowledge to get more out of the book and improve "
"your reading experience. You can check out the \"Other Resources\" section "
"to find resources on topics you might want to catch up on."
msgstr ""
"ì´ ì±…ì€ ì„ë² ë””ë“œ ë°°ê²½ì´ë‚˜ Rust ë°°ê²½ì„ ê°€ì§„ ì‚¬ëŒë“¤ì„ ëŒ€ìƒìœ¼ë¡œ í•˜ì§€ë§Œ, ì„ë² ë””ë“œ Rust "
"í”„ë¡œê·¸ë˜ë°ì— ê´€ì‹¬ì´ ìˆëŠ” ëª¨ë“  ì‚¬ëŒì´ ì´ ì±…ì—ì„œ ë¬´ì–¸ê°€ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤ê³  ë¯¿ìŠµë‹ˆë‹¤. "
"ì‚¬ì „ ì§€ì‹ì´ ì—†ëŠ” ë¶„ë“¤ì€ \"ê°€ì • ë° ì „ì œ ì¡°ê±´\" ì„¹ì…˜ì„ ì½ê³  ë¶€ì¡±í•œ ì§€ì‹ì„ ë³´ì¶©í•˜ì—¬ "
"ì±…ì„ ë” ì˜ í™œìš©í•˜ê³  ì½ê¸° ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ê¸°ë¥¼ ê¶Œí•©ë‹ˆë‹¤. \"ê¸°íƒ€ ìë£Œ\" ì„¹ì…˜ì—ì„œ "
"ë³´ì¶©í•˜ê³  ì‹¶ì€ ì£¼ì œì— ëŒ€í•œ ìë£Œë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:37
msgid "Assumptions and Prerequisites"
msgstr "ê°€ì • ë° ì „ì œ ì¡°ê±´"

#: src/intro/index.md:39
msgid ""
"You are comfortable using the Rust Programming Language, and have written, "
"run, and debugged Rust applications on a desktop environment. You should "
"also be familiar with the idioms of the [2018 edition](https://doc.rust-"
"lang.org/edition-guide/) as this book targets Rust 2018."
msgstr ""
"Rust í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ í¸ì•ˆí•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê³ , ë°ìŠ¤í¬í†± í™˜ê²½ì—ì„œ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ "
"ì‘ì„±, ì‹¤í–‰, ë””ë²„ê¹…í•´ë³¸ ê²½í—˜ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ë˜í•œ ì´ ì±…ì€ Rust 2018ì„ ëŒ€ìƒìœ¼ë¡œ í•˜ë¯€ë¡œ "
"[2018 ì—ë””ì…˜](https://doc.rust-lang.org/edition-guide/)ì˜ ê´€ìš©êµ¬ì—ë„ ìµìˆ™í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/index.md:46
msgid ""
"You are comfortable developing and debugging embedded systems in another "
"language such as C, C++, or Ada, and are familiar with concepts such as:"
msgstr ""
"C, C++, Adaì™€ ê°™ì€ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ê°œë°œí•˜ê³  ë””ë²„ê¹…í•˜ëŠ” ë° ìµìˆ™í•˜ë©°, "
"ë‹¤ìŒê³¼ ê°™ì€ ê°œë…ë“¤ì— ì¹œìˆ™í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/intro/index.md:48
msgid "Cross Compilation"
msgstr "í¬ë¡œìŠ¤ ì»´íŒŒì¼"

#: src/intro/index.md:49 src/peripherals/index.md:32
msgid "Memory Mapped Peripherals"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ì£¼ë³€ì¥ì¹˜"

#: src/intro/index.md:51
msgid "Common interfaces such as I2C, SPI, Serial, etc."
msgstr "I2C, SPI, ì‹œë¦¬ì–¼ ë“±ê³¼ ê°™ì€ ì¼ë°˜ì ì¸ ì¸í„°í˜ì´ìŠ¤"

#: src/intro/index.md:53 src/c-tips/index.md:410
msgid "Other Resources"
msgstr "ê¸°íƒ€ ìë£Œ"

#: src/intro/index.md:54
msgid ""
"If you are unfamiliar with anything mentioned above or if you want more "
"information about a specific topic mentioned in this book you might find "
"some of these resources helpful."
msgstr ""
"ìœ„ì—ì„œ ì–¸ê¸‰í•œ ë‚´ìš© ì¤‘ ìµìˆ™í•˜ì§€ ì•Šì€ ê²ƒì´ ìˆê±°ë‚˜ ì´ ì±…ì—ì„œ ì–¸ê¸‰ëœ íŠ¹ì • ì£¼ì œì— ëŒ€í•œ "
"ë” ë§ì€ ì •ë³´ë¥¼ ì›í•œë‹¤ë©´ ë‹¤ìŒ ìë£Œë“¤ì´ ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/intro/index.md:56
msgid "Topic"
msgstr "ì£¼ì œ"

#: src/intro/index.md:56
msgid "Resource"
msgstr "ìë£Œ"

#: src/intro/index.md:56 src/peripherals/a-first-attempt.md:9
msgid "Description"
msgstr "ì„¤ëª…"

#: src/intro/index.md:58
msgid "Rust"
msgstr "Rust"

#: src/intro/index.md:58
msgid "[Rust Book](https://doc.rust-lang.org/book/)"
msgstr "[Rust ì±…](https://doc.rust-lang.org/book/)"

#: src/intro/index.md:58
msgid ""
"If you are not yet comfortable with Rust, we highly suggest reading this "
"book."
msgstr ""
"ì•„ì§ Rustì— ìµìˆ™í•˜ì§€ ì•Šë‹¤ë©´, ì´ ì±…ì„ ì½ì–´ë³´ì‹œê¸°ë¥¼ ê°•ë ¥íˆ ê¶Œí•©ë‹ˆë‹¤."

#: src/intro/index.md:59 src/intro/index.md:60 src/intro/index.md:61
#: src/intro/index.md:62 src/intro/index.md:63
msgid "Rust, Embedded"
msgstr "Rust, ì„ë² ë””ë“œ"

#: src/intro/index.md:59
msgid "[Discovery Book](https://docs.rust-embedded.org/discovery/)"
msgstr "[Discovery ì±…](https://docs.rust-embedded.org/discovery/)"

#: src/intro/index.md:59
msgid ""
"If you have never done any embedded programming, this book might be a better "
"start"
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•œ ë²ˆë„ í•´ë³¸ ì ì´ ì—†ë‹¤ë©´, ì´ ì±…ì´ ë” ë‚˜ì€ ì‹œì‘ì ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/intro/index.md:60
msgid "[Embedded Rust Bookshelf](https://docs.rust-embedded.org)"
msgstr "[ì„ë² ë””ë“œ Rust ì„œì¬](https://docs.rust-embedded.org)"

#: src/intro/index.md:60
msgid ""
"Here you can find several other resources provided by Rust's Embedded "
"Working Group."
msgstr ""
"ì—¬ê¸°ì„œ Rust ì„ë² ë””ë“œ ì›Œí‚¹ ê·¸ë£¹ì—ì„œ ì œê³µí•˜ëŠ” ì—¬ëŸ¬ ë‹¤ë¥¸ ìë£Œë“¤ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:61
msgid "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"
msgstr "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"

#: src/intro/index.md:61
msgid "The nitty gritty details when doing embedded programming in Rust."
msgstr "Rustë¡œ ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì„ í•  ë•Œì˜ ì„¸ë¶€ì ì¸ ë‚´ìš©ë“¤."

#: src/intro/index.md:62
msgid "[embedded FAQ](https://docs.rust-embedded.org/faq.html)"
msgstr "[ì„ë² ë””ë“œ FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/intro/index.md:62
msgid "Frequently asked questions about Rust in an embedded context."
msgstr "ì„ë² ë””ë“œ í™˜ê²½ì—ì„œ Rustì— ëŒ€í•œ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸ë“¤."

#: src/intro/index.md:63
msgid ""
"[Comprehensive Rust ğŸ¦€: Bare Metal](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"
msgstr ""
"[í¬ê´„ì ì¸ Rust ğŸ¦€: ë² ì–´ ë©”íƒˆ](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"

#: src/intro/index.md:63
msgid "Teaching material for a 1-day class on bare-metal Rust development"
msgstr "ë² ì–´ ë©”íƒˆ Rust ê°œë°œì— ëŒ€í•œ 1ì¼ ìˆ˜ì—…ìš© êµìœ¡ ìë£Œ"

#: src/intro/index.md:64
msgid "[Interrupt](https://en.wikipedia.org/wiki/Interrupt)"
msgstr "[ì¸í„°ëŸ½íŠ¸](https://en.wikipedia.org/wiki/Interrupt)"

#: src/intro/index.md:64 src/intro/index.md:65 src/intro/index.md:66
msgid "\\-"
msgstr "\\-"

#: src/intro/index.md:65
msgid "Memory-mapped IO/Peripherals"
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ì…ì¶œë ¥/ì£¼ë³€ì¥ì¹˜"

#: src/intro/index.md:65
msgid "[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"
msgstr "[ë©”ëª¨ë¦¬ ë§¤í•‘ ì…ì¶œë ¥](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"

#: src/intro/index.md:66
msgid "SPI, UART, RS232, USB, I2C, TTL"
msgstr "SPI, UART, RS232, USB, I2C, TTL"

#: src/intro/index.md:66
msgid ""
"[Stack Exchange about SPI, UART, and other interfaces](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"
msgstr ""
"[SPI, UART ë° ê¸°íƒ€ ì¸í„°í˜ì´ìŠ¤ì— ëŒ€í•œ Stack Exchange](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"

#: src/intro/index.md:68
msgid "Translations"
msgstr "ë²ˆì—­"

#: src/intro/index.md:70
msgid ""
"This book has been translated by generous volunteers. If you would like your "
"translation listed here, please open a PR to add it."
msgstr ""
"ì´ ì±…ì€ ê´€ëŒ€í•œ ìì›ë´‰ì‚¬ìë“¤ì— ì˜í•´ ë²ˆì—­ë˜ì—ˆìŠµë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ ë²ˆì—­ì„ ì—¬ê¸°ì— "
"ë‚˜ì—´í•˜ê³  ì‹¶ë‹¤ë©´ PRì„ ì—´ì–´ ì¶”ê°€í•´ ì£¼ì„¸ìš”."

#: src/intro/index.md:73
msgid ""
"[Japanese](https://tomoyuki-nakabayashi.github.io/book/) ([repository]"
"(https://github.com/tomoyuki-nakabayashi/book))"
msgstr ""
"[ì¼ë³¸ì–´](https://tomoyuki-nakabayashi.github.io/book/) ([ì €ì¥ì†Œ]"
"(https://github.com/tomoyuki-nakabayashi/book))"

#: src/intro/index.md:76
msgid ""
"[Chinese](https://xxchang.github.io/book/) ([repository](https://github.com/"
"XxChang/book))"
msgstr ""
"[ì¤‘êµ­ì–´](https://xxchang.github.io/book/) ([ì €ì¥ì†Œ](https://github.com/"
"XxChang/book))"

#: src/intro/index.md:79
msgid "How to Use This Book"
msgstr "ì´ ì±…ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•"

#: src/intro/index.md:81
msgid ""
"This book generally assumes that youâ€™re reading it front-to-back. Later "
"chapters build on concepts in earlier chapters, and earlier chapters may not "
"dig into details on a topic, revisiting the topic in a later chapter."
msgstr ""
"ì´ ì±…ì€ ì¼ë°˜ì ìœ¼ë¡œ ì²˜ìŒë¶€í„° ëê¹Œì§€ ìˆœì„œëŒ€ë¡œ ì½ëŠ”ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. í›„ë°˜ "
"ì¥ë“¤ì€ ì´ì „ ì¥ì˜ ê°œë…ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ì´ì „ ì¥ì—ì„œëŠ” ì£¼ì œì— ëŒ€í•œ ì„¸ë¶€ì‚¬í•­ì„ "
"ê¹Šì´ ë‹¤ë£¨ì§€ ì•Šê³  í›„ë°˜ ì¥ì—ì„œ ë‹¤ì‹œ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/index.md:85
msgid ""
"This book will be using the [STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) development board from "
"STMicroelectronics for the majority of the examples contained within. This "
"board is based on the ARM Cortex-M architecture, and while basic "
"functionality is the same across most CPUs based on this architecture, "
"peripherals and other implementation details of Microcontrollers are "
"different between different vendors, and often even different between "
"Microcontroller families from the same vendor."
msgstr ""
"ì´ ì±…ì€ í¬í•¨ëœ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œì—ì„œ STMicroelectronicsì˜ "
"[STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) ê°œë°œ ë³´ë“œë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. "
"ì´ ë³´ë“œëŠ” ARM Cortex-M ì•„í‚¤í…ì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ì´ ì•„í‚¤í…ì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ "
"ëŒ€ë¶€ë¶„ì˜ CPUì—ì„œ ê¸°ë³¸ ê¸°ëŠ¥ì€ ë™ì¼í•˜ì§€ë§Œ, ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì£¼ë³€ì¥ì¹˜ì™€ ê¸°íƒ€ "
"êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì€ ë²¤ë”ë§ˆë‹¤ ë‹¤ë¥´ê³ , ì¢…ì¢… ê°™ì€ ë²¤ë”ì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ íŒ¨ë°€ë¦¬ ê°„ì—ë„ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/intro/index.md:93
msgid ""
"For this reason, we suggest purchasing the [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html) development board for "
"the purpose of following the examples in this book."
msgstr ""
"ì´ëŸ¬í•œ ì´ìœ ë¡œ, ì´ ì±…ì˜ ì˜ˆì œë¥¼ ë”°ë¼í•˜ê¸° ìœ„í•´ "
"[STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html) "
"ê°œë°œ ë³´ë“œë¥¼ êµ¬ì…í•˜ì‹œê¸°ë¥¼ ê¶Œí•©ë‹ˆë‹¤."

#: src/intro/index.md:98
msgid "Contributing to This Book"
msgstr "ì´ ì±…ì— ê¸°ì—¬í•˜ê¸°"

#: src/intro/index.md:100
msgid ""
"The work on this book is coordinated in [this repository](https://github.com/"
"rust-embedded/book) and is mainly developed by the [resources team](https://"
"github.com/rust-embedded/wg#the-resources-team)."
msgstr ""
"ì´ ì±…ì˜ ì‘ì—…ì€ [ì´ ì €ì¥ì†Œ](https://github.com/"
"rust-embedded/book)ì—ì„œ ì¡°ì •ë˜ë©° ì£¼ë¡œ [ë¦¬ì†ŒìŠ¤ íŒ€](https://"
"github.com/rust-embedded/wg#the-resources-team)ì—ì„œ ê°œë°œë©ë‹ˆë‹¤."

#: src/intro/index.md:106
msgid ""
"If you have trouble following the instructions in this book or find that "
"some section of the book is not clear enough or hard to follow then that's a "
"bug and it should be reported in [the issue tracker](https://github.com/rust-"
"embedded/book/issues/) of this book."
msgstr ""
"ì´ ì±…ì˜ ì§€ì¹¨ì„ ë”°ë¥´ëŠ” ë° ë¬¸ì œê°€ ìˆê±°ë‚˜ ì±…ì˜ ì¼ë¶€ ì„¹ì…˜ì´ ì¶©ë¶„íˆ ëª…í™•í•˜ì§€ ì•Šê±°ë‚˜ "
"ë”°ë¼í•˜ê¸° ì–´ë µë‹¤ë©´ ê·¸ê²ƒì€ ë²„ê·¸ì´ë©° ì´ ì±…ì˜ [ì´ìŠˆ íŠ¸ë˜ì»¤](https://github.com/rust-"
"embedded/book/issues/)ì— ë³´ê³ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/index.md:112
msgid "Pull requests fixing typos and adding new content are very welcome!"
msgstr "ì˜¤íƒ€ë¥¼ ìˆ˜ì •í•˜ê³  ìƒˆë¡œìš´ ë‚´ìš©ì„ ì¶”ê°€í•˜ëŠ” í’€ ë¦¬í€˜ìŠ¤íŠ¸ëŠ” ë§¤ìš° í™˜ì˜í•©ë‹ˆë‹¤!"

#: src/intro/index.md:114
msgid "Re-using this material"
msgstr "ì´ ìë£Œ ì¬ì‚¬ìš©í•˜ê¸°"

#: src/intro/index.md:116
msgid "This book is distributed under the following licenses:"
msgstr "ì´ ì±…ì€ ë‹¤ìŒ ë¼ì´ì„ ìŠ¤ í•˜ì— ë°°í¬ë©ë‹ˆë‹¤:"

#: src/intro/index.md:118
msgid ""
"The code samples and free-standing Cargo projects contained within this book "
"are licensed under the terms of both the [MIT License](https://"
"opensource.org/licenses/MIT) and the [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0)."
msgstr ""
"ì´ ì±…ì— í¬í•¨ëœ ì½”ë“œ ìƒ˜í”Œê³¼ ë…ë¦½ì ì¸ Cargo í”„ë¡œì íŠ¸ëŠ” [MIT ë¼ì´ì„ ìŠ¤](https://"
"opensource.org/licenses/MIT)ì™€ [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0) ì¡°ê±´ í•˜ì— ë¼ì´ì„ ìŠ¤ë©ë‹ˆë‹¤."

#: src/intro/index.md:119
msgid ""
"The written prose, pictures and diagrams contained within this book are "
"licensed under the terms of the Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) license."
msgstr ""
"ì´ ì±…ì— í¬í•¨ëœ ê¸€, ê·¸ë¦¼, ë‹¤ì´ì–´ê·¸ë¨ì€ í¬ë¦¬ì—ì´í‹°ë¸Œ ì»¤ë¨¼ì¦ˆ [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) ë¼ì´ì„ ìŠ¤ì˜ ì¡°ê±´ í•˜ì— ë¼ì´ì„ ìŠ¤ë©ë‹ˆë‹¤."

#: src/intro/index.md:125
msgid "TL;DR: If you want to use our text or images in your work, you need to:"
msgstr "ìš”ì•½: ì‘ì—…ì—ì„œ ìš°ë¦¬ì˜ í…ìŠ¤íŠ¸ë‚˜ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë‹¤ìŒì´ í•„ìš”í•©ë‹ˆë‹¤:"

#: src/intro/index.md:127
msgid ""
"Give the appropriate credit (i.e. mention this book on your slide, and "
"provide a link to the relevant page)"
msgstr ""
"ì ì ˆí•œ í¬ë ˆë”§ì„ ì œê³µí•˜ì„¸ìš” (ì¦‰, ìŠ¬ë¼ì´ë“œì— ì´ ì±…ì„ ì–¸ê¸‰í•˜ê³  ê´€ë ¨ í˜ì´ì§€ì— ëŒ€í•œ "
"ë§í¬ë¥¼ ì œê³µí•˜ì„¸ìš”)"

#: src/intro/index.md:128
msgid ""
"Provide a link to the [CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) licence"
msgstr ""
"[CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) ë¼ì´ì„ ìŠ¤ì— ëŒ€í•œ ë§í¬ë¥¼ ì œê³µí•˜ì„¸ìš”"

#: src/intro/index.md:129
msgid ""
"Indicate if you have changed the material in any way, and make any changes "
"to our material available under the same licence"
msgstr ""
"ìë£Œë¥¼ ì–´ë–¤ ë°©ì‹ìœ¼ë¡œë“  ë³€ê²½í–ˆëŠ”ì§€ í‘œì‹œí•˜ê³ , ìš°ë¦¬ ìë£Œì— ëŒ€í•œ ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ "
"ë™ì¼í•œ ë¼ì´ì„ ìŠ¤ í•˜ì— ì œê³µí•˜ì„¸ìš”"

#: src/intro/index.md:131
msgid "Also, please do let us know if you find this book useful!"
msgstr "ë˜í•œ ì´ ì±…ì´ ìœ ìš©í•˜ë‹¤ê³  ìƒê°í•˜ì‹œë©´ ì•Œë ¤ì£¼ì„¸ìš”!"

#: src/intro/hardware.md:1
msgid "Meet Your Hardware"
msgstr "í•˜ë“œì›¨ì–´ ì†Œê°œ"

#: src/intro/hardware.md:3
msgid "Let's get familiar with the hardware we'll be working with."
msgstr "ìš°ë¦¬ê°€ ì‘ì—…í•  í•˜ë“œì›¨ì–´ì— ìµìˆ™í•´ì ¸ ë´…ì‹œë‹¤."

#: src/intro/hardware.md:5
msgid "STM32F3DISCOVERY (the \"F3\")"
msgstr "STM32F3DISCOVERY (\"F3\")"

#: src/intro/hardware.md:11
msgid "What does this board contain?"
msgstr "ì´ ë³´ë“œì—ëŠ” ë¬´ì—‡ì´ í¬í•¨ë˜ì–´ ìˆë‚˜ìš”?"

#: src/intro/hardware.md:13
msgid ""
"A [STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"microcontroller. This microcontroller has"
msgstr ""
"[STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬. ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ë‹¤ìŒì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤"

#: src/intro/hardware.md:14
msgid ""
"A single-core ARM Cortex-M4F processor with hardware support for single-"
"precision floating point operations and a maximum clock frequency of 72 MHz."
msgstr ""
"ë‹¨ì •ë°€ë„ ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚°ì„ ìœ„í•œ í•˜ë“œì›¨ì–´ ì§€ì›ê³¼ ìµœëŒ€ 72MHzì˜ í´ë¡ ì£¼íŒŒìˆ˜ë¥¼ ê°€ì§„ "
"ë‹¨ì¼ ì½”ì–´ ARM Cortex-M4F í”„ë¡œì„¸ì„œ."

#: src/intro/hardware.md:17
msgid "256 KiB of \"Flash\" memory. (1 KiB = 10**24** bytes)"
msgstr "256 KiBì˜ \"í”Œë˜ì‹œ\" ë©”ëª¨ë¦¬. (1 KiB = 10**24** ë°”ì´íŠ¸)"

#: src/intro/hardware.md:19
msgid "48 KiB of RAM."
msgstr "48 KiBì˜ RAM."

#: src/intro/hardware.md:21
msgid "A variety of integrated peripherals such as timers, I2C, SPI and USART."
msgstr "íƒ€ì´ë¨¸, I2C, SPI, USARTì™€ ê°™ì€ ë‹¤ì–‘í•œ í†µí•© ì£¼ë³€ì¥ì¹˜."

#: src/intro/hardware.md:23
msgid ""
"General purpose Input Output (GPIO) and other types of pins accessible "
"through the two rows of headers along side the board."
msgstr ""
"ë³´ë“œ ì–‘ìª½ì˜ ë‘ ì¤„ì˜ í—¤ë”ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë²”ìš© ì…ì¶œë ¥(GPIO) ë° ê¸°íƒ€ ìœ í˜•ì˜ í•€."

#: src/intro/hardware.md:25
msgid "A USB interface accessible through the USB port labeled \"USB USER\"."
msgstr "\"USB USER\"ë¼ê³  í‘œì‹œëœ USB í¬íŠ¸ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” USB ì¸í„°í˜ì´ìŠ¤."

#: src/intro/hardware.md:27
msgid ""
"An [accelerometer](https://en.wikipedia.org/wiki/Accelerometer) as part of "
"the [LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ê°€ì†ë„ê³„](https://en.wikipedia.org/wiki/Accelerometer)."

#: src/intro/hardware.md:29
msgid ""
"A [magnetometer](https://en.wikipedia.org/wiki/Magnetometer) as part of the "
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ìë ¥ê³„](https://en.wikipedia.org/wiki/Magnetometer)."

#: src/intro/hardware.md:31
msgid ""
"A [gyroscope](https://en.wikipedia.org/wiki/Gyroscope) as part of the "
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) chip."
msgstr ""
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) "
"ì¹©ì˜ ì¼ë¶€ì¸ [ìì´ë¡œìŠ¤ì½”í”„](https://en.wikipedia.org/wiki/Gyroscope)."

#: src/intro/hardware.md:33
msgid "8 user LEDs arranged in the shape of a compass."
msgstr "ë‚˜ì¹¨ë°˜ ëª¨ì–‘ìœ¼ë¡œ ë°°ì—´ëœ 8ê°œì˜ ì‚¬ìš©ì LED."

#: src/intro/hardware.md:35
msgid ""
"A second microcontroller: a [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). This microcontroller is actually part of "
"an on-board programmer / debugger and is connected to the USB port named "
"\"USB ST-LINK\"."
msgstr ""
"ë‘ ë²ˆì§¸ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬: [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ì‹¤ì œë¡œ "
"ì˜¨ë³´ë“œ í”„ë¡œê·¸ë˜ë¨¸/ë””ë²„ê±°ì˜ ì¼ë¶€ì´ë©° \"USB ST-LINK\"ë¼ëŠ” ì´ë¦„ì˜ USB í¬íŠ¸ì— ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/intro/hardware.md:37
msgid ""
"For a more detailed list of features and further specifications of the board "
"take a look at the [STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) website."
msgstr ""
"ë³´ë“œì˜ ë” ìì„¸í•œ ê¸°ëŠ¥ ëª©ë¡ê³¼ ì¶”ê°€ ì‚¬ì–‘ì€ "
"[STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) ì›¹ì‚¬ì´íŠ¸ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/intro/hardware.md:39
msgid ""
"A word of caution: be careful if you want to apply external signals to the "
"board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 "
"volts. For further information consult the [6.2 Absolute maximum ratings "
"section in the manual](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)"
msgstr ""
"ì£¼ì˜ì‚¬í•­: ë³´ë“œì— ì™¸ë¶€ ì‹ í˜¸ë¥¼ ì ìš©í•˜ë ¤ëŠ” ê²½ìš° ì£¼ì˜í•˜ì„¸ìš”. "
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ STM32F303VCT6 í•€ì€ 3.3ë³¼íŠ¸ì˜ ì •ê²© ì „ì••ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. "
"ìì„¸í•œ ì •ë³´ëŠ” [ë§¤ë‰´ì–¼ì˜ 6.2 ì ˆëŒ€ ìµœëŒ€ ì •ê²© ì„¹ì…˜](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)ì„ ì°¸ì¡°í•˜ì„¸ìš”"

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr "`no_std` Rust í™˜ê²½"

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://"
"en.wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""
"ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì´ë¼ëŠ” ìš©ì–´ëŠ” ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ í”„ë¡œê·¸ë˜ë° í´ë˜ìŠ¤ì— ì‚¬ìš©ë©ë‹ˆë‹¤. "
"ëª‡ KBì˜ RAMê³¼ ROMë§Œì„ ê°€ì§„ 8ë¹„íŠ¸ MCU([ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)ì™€ ê°™ì€) í”„ë¡œê·¸ë˜ë°ë¶€í„° "
"32/64ë¹„íŠ¸ 4ì½”ì–´ Cortex-A53 @ 1.4 GHzì™€ 1GB RAMì„ ê°€ì§„ ë¼ì¦ˆë² ë¦¬ íŒŒì´([Model B 3+]"
"(https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications))ì™€ ê°™ì€ ì‹œìŠ¤í…œê¹Œì§€ ë‹¤ì–‘í•©ë‹ˆë‹¤. "
"ì–´ë–¤ ì¢…ë¥˜ì˜ ëŒ€ìƒê³¼ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€ì— ë”°ë¼ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ ë‹¤ë¥¸ ì œí•œì‚¬í•­/í•œê³„ê°€ ì ìš©ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr "ì„ë² ë””ë“œ í”„ë¡œê·¸ë˜ë°ì—ëŠ” ë‘ ê°€ì§€ ì¼ë°˜ì ì¸ ë¶„ë¥˜ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr "í˜¸ìŠ¤íŠ¸ í™˜ê²½"

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""
"ì´ëŸ° ì¢…ë¥˜ì˜ í™˜ê²½ì€ ì¼ë°˜ì ì¸ PC í™˜ê²½ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤. ì´ëŠ” íŒŒì¼ ì‹œìŠ¤í…œ, ë„¤íŠ¸ì›Œí‚¹, "
"ë©”ëª¨ë¦¬ ê´€ë¦¬, ìŠ¤ë ˆë“œ ë“±ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ì‹œìŠ¤í…œê³¼ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ë³¸ ìš”ì†Œë¥¼ ì œê³µí•˜ëŠ” "
"ì‹œìŠ¤í…œ ì¸í„°í˜ì´ìŠ¤ [ì˜ˆ: POSIX](https://en.wikipedia.org/wiki/POSIX)ê°€ ì œê³µëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. "
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì´ëŸ¬í•œ ê¸°ë³¸ ìš”ì†Œì— ì˜ì¡´í•˜ì—¬ ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤. "
"ë˜í•œ ì–´ë–¤ ì¢…ë¥˜ì˜ sysrootì™€ RAM/ROM ì‚¬ìš©ëŸ‰ ì œí•œ, ê·¸ë¦¬ê³  ì•„ë§ˆë„ ì¼ë¶€ íŠ¹ìˆ˜ HWë‚˜ I/Oê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ì „ë°˜ì ìœ¼ë¡œ íŠ¹ìˆ˜ ëª©ì  PC í™˜ê²½ì—ì„œ ì½”ë”©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ëŠê»´ì§‘ë‹ˆë‹¤."

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr "ë² ì–´ ë©”íƒˆ í™˜ê²½"

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""
"ë² ì–´ ë©”íƒˆ í™˜ê²½ì—ì„œëŠ” í”„ë¡œê·¸ë¨ ì´ì „ì— ë¡œë“œëœ ì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤. "
"OSì—ì„œ ì œê³µí•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ì—†ì´ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. "
"ëŒ€ì‹  í”„ë¡œê·¸ë¨ì€ ì‚¬ìš©í•˜ëŠ” í¬ë ˆì´íŠ¸ì™€ í•¨ê»˜ í•˜ë“œì›¨ì–´(ë² ì–´ ë©”íƒˆ)ë§Œì„ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"Rustê°€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ë ¤ë©´ `no_std`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. "
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ í”Œë«í¼ ë…ë¦½ì ì¸ ë¶€ë¶„ì€ [libcore](https://doc.rust-lang.org/core/)ë¥¼ í†µí•´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"libcoreëŠ” ë˜í•œ ì„ë² ë””ë“œ í™˜ê²½ì—ì„œ í•­ìƒ ë°”ëŒì§í•˜ì§€ ì•Šì€ ê²ƒë“¤ì„ ì œì™¸í•©ë‹ˆë‹¤. "
"ì´ëŸ¬í•œ ê²ƒë“¤ ì¤‘ í•˜ë‚˜ëŠ” ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ìœ„í•œ ë©”ëª¨ë¦¬ í• ë‹¹ìì…ë‹ˆë‹¤. "
"ì´ê²ƒì´ë‚˜ ë‹¤ë¥¸ ê¸°ëŠ¥ì´ í•„ìš”í•œ ê²½ìš° ì´ë¥¼ ì œê³µí•˜ëŠ” í¬ë ˆì´íŠ¸ê°€ ì¢…ì¢… ìˆìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr "libstd ëŸ°íƒ€ì„"

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""
"ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´ [libstd](https://doc.rust-lang.org/std/)ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ "
"ì–´ë–¤ ì¢…ë¥˜ì˜ ì‹œìŠ¤í…œ í†µí•©ì´ í•„ìš”í•˜ì§€ë§Œ, ì´ëŠ” [libstd](https://doc.rust-lang.org/std/)ê°€ "
"ë‹¨ìˆœíˆ OS ì¶”ìƒí™”ì— ì ‘ê·¼í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì„ ì œê³µí•˜ê¸° ë•Œë¬¸ë§Œì´ ì•„ë‹ˆë¼ ëŸ°íƒ€ì„ë„ ì œê³µí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. "
"ì´ ëŸ°íƒ€ì„ì€ ë¬´ì—‡ë³´ë‹¤ë„ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œ ë³´í˜¸ ì„¤ì •, ëª…ë ¹ì¤„ ì¸ìˆ˜ ì²˜ë¦¬, "
"í”„ë¡œê·¸ë¨ì˜ main í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê¸° ì „ì— ë©”ì¸ ìŠ¤ë ˆë“œ ìƒì„±ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. "
"ì´ ëŸ°íƒ€ì„ì€ `no_std` í™˜ê²½ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://"
"doc.rust-lang.org/core/) crate in turn is a platform-agnostic subset of the "
"std crate which makes no assumptions about the system the program will run "
"on. As such, it provides APIs for language primitives like floats, strings "
"and slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr "`#![no_std]`ëŠ” í¬ë ˆì´íŠ¸ê°€ std-í¬ë ˆì´íŠ¸ ëŒ€ì‹  core-í¬ë ˆì´íŠ¸ì— ë§í¬ë  ê²ƒì„ì„ ë‚˜íƒ€ë‚´ëŠ” í¬ë ˆì´íŠ¸ ìˆ˜ì¤€ ì†ì„±ì…ë‹ˆë‹¤. [libcore](https://doc.rust-lang.org/core/) í¬ë ˆì´íŠ¸ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë  ì‹œìŠ¤í…œì— ëŒ€í•´ ì–´ë– í•œ ê°€ì •ë„ í•˜ì§€ ì•ŠëŠ” std í¬ë ˆì´íŠ¸ì˜ í”Œë«í¼ ë…ë¦½ì ì¸ í•˜ìœ„ ì§‘í•©ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ë¶€ë™ ì†Œìˆ˜ì , ë¬¸ìì—´ ë° ìŠ¬ë¼ì´ìŠ¤ì™€ ê°™ì€ ì–¸ì–´ ê¸°ë³¸ ìš”ì†Œì— ëŒ€í•œ APIì™€ ì›ìì  ì—°ì‚° ë° SIMD ëª…ë ¹ì–´ì™€ ê°™ì€ í”„ë¡œì„¸ì„œ ê¸°ëŠ¥ì„ ë…¸ì¶œí•˜ëŠ” APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ í”Œë«í¼ í†µí•©ê³¼ ê´€ë ¨ëœ ëª¨ë“  ê²ƒì— ëŒ€í•œ APIëŠ” ë¶€ì¡±í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì†ì„± ë•Œë¬¸ì— no_std ë° [libcore](https://doc.rust-lang.org/core/) ì½”ë“œëŠ” ë¶€íŠ¸ë¡œë”, íŒì›¨ì–´ ë˜ëŠ” ì»¤ë„ê³¼ ê°™ì€ ëª¨ë“  ì¢…ë¥˜ì˜ ë¶€íŠ¸ìŠ¤íŠ¸ë˜í•‘(ë‹¨ê³„ 0) ì½”ë“œì— ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."


#: src/intro/no-std.md:45 src/intro/tooling.md:58
msgid "Overview"
msgstr "ê°œìš”"

#: src/intro/no-std.md:47
msgid "feature"
msgstr "ê¸°ëŠ¥"

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr "no_std"

#: src/intro/no-std.md:47
msgid "std"
msgstr "std"

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr "í™ (ë™ì  ë©”ëª¨ë¦¬)"

#: src/intro/no-std.md:49
msgid "\\*"
msgstr "\\*"

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "âœ“"
msgstr ""

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr "ì»¬ë ‰ì…˜ (Vec, BTreeMap ë“±)"

#: src/intro/no-std.md:50
msgid "\\**"
msgstr "\\**"

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr "ìŠ¤íƒ ì˜¤ë²„í”Œë¡œ ë³´í˜¸"

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "âœ˜"
msgstr "âœ˜"

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr "main ì´ì „ì— ì´ˆê¸°í™” ì½”ë“œ ì‹¤í–‰"

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr "libstd ì‚¬ìš© ê°€ëŠ¥"

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr "libcore ì‚¬ìš© ê°€ëŠ¥"

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr "íŒì›¨ì–´, ì»¤ë„ ë˜ëŠ” ë¶€íŠ¸ë¡œë” ì½”ë“œ ì‘ì„±"

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr "* `alloc` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  [alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)ê³¼ ê°™ì€ ì ì ˆí•œ í• ë‹¹ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ë§Œ í•´ë‹¹ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr "** `collections` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  ì „ì—­ ê¸°ë³¸ í• ë‹¹ìë¥¼ êµ¬ì„±í•˜ëŠ” ê²½ìš°ì—ë§Œ í•´ë‹¹ë©ë‹ˆë‹¤."

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr "** ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ê¸°ê°€ ë¶€ì¡±í•˜ì—¬ HashMap ë° HashSetì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/intro/no-std.md:65
msgid "See Also"
msgstr "ì°¸ì¡°"

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr "[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)"

#: src/intro/tooling.md:3
msgid ""
"Dealing with microcontrollers involves using several different tools as "
"we'll be dealing with an architecture different than your laptop's and we'll "
"have to run and debug programs on a _remote_ device."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë‹¤ë£¨ëŠ” ê²ƒì€ ì—¬ëŸ¬ ê°€ì§€ ë‹¤ë¥¸ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ í¬í•¨í•©ë‹ˆë‹¤. ì´ëŠ” ë…¸íŠ¸ë¶ê³¼ëŠ” ë‹¤ë¥¸ ì•„í‚¤í…ì²˜ë¥¼ ë‹¤ë£¨ê³  _ì›ê²©_ ì¥ì¹˜ì—ì„œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ê³  ë””ë²„ê¹…í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:7
msgid ""
"We'll use all the tools listed below. Any recent version should work when a "
"minimum version is not specified, but we have listed the versions we have "
"tested."
msgstr "ì•„ë˜ ë‚˜ì—´ëœ ëª¨ë“  ë„êµ¬ë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤. ìµœì†Œ ë²„ì „ì´ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš° ìµœì‹  ë²„ì „ì€ ëª¨ë‘ ì‘ë™í•´ì•¼ í•˜ì§€ë§Œ, ì €í¬ê°€ í…ŒìŠ¤íŠ¸í•œ ë²„ì „ì„ ë‚˜ì—´í–ˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:11
msgid ""
"Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation "
"support."
msgstr "Rust 1.31, 1.31-beta ë˜ëŠ” ë” ìƒˆë¡œìš´ íˆ´ì²´ì¸ + ARM Cortex-M ì»´íŒŒì¼ ì§€ì›."

#: src/intro/tooling.md:13
msgid ""
"[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"
msgstr "[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"

#: src/intro/tooling.md:14
msgid "[`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0"
msgstr "[`qemu-system-arm`](https://www.qemu.org/). í…ŒìŠ¤íŠ¸ ë²„ì „: 3.0.0"

#: src/intro/tooling.md:15
msgid "OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0"
msgstr "OpenOCD >=0.8. í…ŒìŠ¤íŠ¸ ë²„ì „: v0.9.0 ë° v0.10.0"

#: src/intro/tooling.md:16
msgid ""
"GDB with ARM support. Version 7.12 or newer highly recommended. Tested "
"versions: 7.10, 7.11, 7.12 and 8.1"
msgstr "ARM ì§€ì› GDB. ë²„ì „ 7.12 ì´ìƒì„ ê°•ë ¥íˆ ê¶Œì¥í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ ë²„ì „: 7.10, 7.11, 7.12 ë° 8.1"

#: src/intro/tooling.md:18
msgid ""
"[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) or "
"`git`. These tools are optional but will make it easier to follow along with "
"the book."
msgstr "[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) ë˜ëŠ” `git`. ì´ ë„êµ¬ë“¤ì€ ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ ì±…ì„ ë”°ë¼í•˜ê¸° ì‰½ê²Œ í•´ì¤„ ê²ƒì…ë‹ˆë‹¤."

#: src/intro/tooling.md:21
msgid ""
"The text below explains why we are using these tools. Installation "
"instructions can be found on the next page."
msgstr "ì•„ë˜ í…ìŠ¤íŠ¸ëŠ” ì´ëŸ¬í•œ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤. ì„¤ì¹˜ ì§€ì¹¨ì€ ë‹¤ìŒ í˜ì´ì§€ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:24
msgid "`cargo-generate` OR `git`"
msgstr "`cargo-generate` ë˜ëŠ” `git`"

#: src/intro/tooling.md:26
msgid ""
"Bare metal programs are non-standard (`no_std`) Rust programs that require "
"some adjustments to the linking process in order to get the memory layout of "
"the program right. This requires some additional files (like linker scripts) "
"and settings (like linker flags). We have packaged those for you in a "
"template such that you only need to fill in the missing information (such as "
"the project name and the characteristics of your target hardware)."
msgstr "ë² ì–´ ë©”íƒˆ í”„ë¡œê·¸ë¨ì€ í”„ë¡œê·¸ë¨ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ì˜¬ë°”ë¥´ê²Œ ì–»ê¸° ìœ„í•´ ë§í¬ í”„ë¡œì„¸ìŠ¤ì— ì¼ë¶€ ì¡°ì •ì´ í•„ìš”í•œ ë¹„í‘œì¤€(`no_std`) Rust í”„ë¡œê·¸ë¨ì…ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ì„œëŠ” ì¼ë¶€ ì¶”ê°€ íŒŒì¼(ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ ë“±) ë° ì„¤ì •(ë§ì»¤ í”Œë˜ê·¸ ë“±)ì´ í•„ìš”í•©ë‹ˆë‹¤. ì €í¬ëŠ” ì´ëŸ¬í•œ ê²ƒë“¤ì„ í…œí”Œë¦¿ìœ¼ë¡œ íŒ¨í‚¤ì§•í•˜ì—¬ í”„ë¡œì íŠ¸ ì´ë¦„ ë° ëŒ€ìƒ í•˜ë“œì›¨ì–´ì˜ íŠ¹ì„±ê³¼ ê°™ì€ ëˆ„ë½ëœ ì •ë³´ë§Œ ì±„ìš°ë©´ ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:33
msgid ""
"Our template is compatible with `cargo-generate`: a Cargo subcommand for "
"creating new Cargo projects from templates. You can also download the "
"template using `git`, `curl`, `wget`, or your web browser."
msgstr "ì €í¬ í…œí”Œë¦¿ì€ í…œí”Œë¦¿ì—ì„œ ìƒˆ Cargo í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ Cargo í•˜ìœ„ ëª…ë ¹ì¸ `cargo-generate`ì™€ í˜¸í™˜ë©ë‹ˆë‹¤. `git`, `curl`, `wget` ë˜ëŠ” ì›¹ ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì—¬ í…œí”Œë¦¿ì„ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:37 src/intro/install.md:59
msgid "`cargo-binutils`"
msgstr "`cargo-binutils`"

#: src/intro/tooling.md:39
msgid ""
"`cargo-binutils` is a collection of Cargo subcommands that make it easy to "
"use the LLVM tools that are shipped with the Rust toolchain. These tools "
"include the LLVM versions of `objdump`, `nm` and `size` and are used for "
"inspecting binaries."
msgstr "`cargo-binutils`ëŠ” Rust íˆ´ì²´ì¸ê³¼ í•¨ê»˜ ì œê³µë˜ëŠ” LLVM ë„êµ¬ë¥¼ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” Cargo í•˜ìœ„ ëª…ë ¹ ëª¨ìŒì…ë‹ˆë‹¤. ì´ ë„êµ¬ì—ëŠ” `objdump`, `nm`, `size`ì˜ LLVM ë²„ì „ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©° ë°”ì´ë„ˆë¦¬ë¥¼ ê²€ì‚¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:44
msgid ""
"The advantage of using these tools over GNU binutils is that (a) installing "
"the LLVM tools is the same one-command installation (`rustup component add "
"llvm-tools`) regardless of your OS and (b) tools like `objdump` support all "
"the architectures that `rustc` supports -- from ARM to x86_64 -- because "
"they both share the same LLVM backend."
msgstr "GNU binutils ëŒ€ì‹  ì´ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¥ì ì€ (a) LLVM ë„êµ¬ ì„¤ì¹˜ê°€ OSì— ê´€ê³„ì—†ì´ ë™ì¼í•œ ë‹¨ì¼ ëª…ë ¹ ì„¤ì¹˜(`rustup component add llvm-tools`)ì´ë©° (b) `objdump`ì™€ ê°™ì€ ë„êµ¬ëŠ” ARMì—ì„œ x86_64ê¹Œì§€ `rustc`ê°€ ì§€ì›í•˜ëŠ” ëª¨ë“  ì•„í‚¤í…ì²˜ë¥¼ ì§€ì›í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” ë‘˜ ë‹¤ ë™ì¼í•œ LLVM ë°±ì—”ë“œë¥¼ ê³µìœ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:50
msgid "`qemu-system-arm`"
msgstr "`qemu-system-arm`"

#: src/intro/tooling.md:52
msgid ""
"QEMU is an emulator. In this case we use the variant that can fully emulate "
"ARM systems. We use QEMU to run embedded programs on the host. Thanks to "
"this you can follow some parts of this book even if you don't have any "
"hardware with you!"
msgstr "QEMUëŠ” ì—ë®¬ë ˆì´í„°ì…ë‹ˆë‹¤. ì´ ê²½ìš° ARM ì‹œìŠ¤í…œì„ ì™„ì „íˆ ì—ë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆëŠ” ë³€í˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ í˜¸ìŠ¤íŠ¸ì—ì„œ ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•©ë‹ˆë‹¤. ë•ë¶„ì— í•˜ë“œì›¨ì–´ê°€ ì—†ì–´ë„ ì´ ì±…ì˜ ì¼ë¶€ë¥¼ ë”°ë¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/intro/tooling.md:56
msgid "Tooling for Embedded Rust Debugging"
msgstr "ì„ë² ë””ë“œ Rust ë””ë²„ê¹…ì„ ìœ„í•œ ë„êµ¬"

#: src/intro/tooling.md:60
msgid ""
"Debugging embedded systems in Rust requires specialized tools including "
"software to manage the debugging process, debuggers to inspect and control "
"program execution, and hardware probes to facilitate interaction between the "
"host and the embedded device. This document outlines essential software "
"tools like Probe-rs and OpenOCD, which simplify and support the debugging "
"process, alongside prominent debuggers such as GDB and the Probe-rs Visual "
"Studio Code extension. Additionally, it covers key hardware probes such as "
"Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective "
"debugging and programming of embedded devices."
msgstr "Rustì—ì„œ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ë””ë²„ê¹…í•˜ë ¤ë©´ ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´, í”„ë¡œê·¸ë¨ ì‹¤í–‰ì„ ê²€ì‚¬í•˜ê³  ì œì–´í•˜ëŠ” ë””ë²„ê±°, í˜¸ìŠ¤íŠ¸ì™€ ì„ë² ë””ë“œ ì¥ì¹˜ ê°„ì˜ ìƒí˜¸ ì‘ìš©ì„ ìš©ì´í•˜ê²Œ í•˜ëŠ” í•˜ë“œì›¨ì–´ í”„ë¡œë¸Œë¥¼ í¬í•¨í•œ ì „ë¬¸ ë„êµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì´ ë¬¸ì„œëŠ” ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¨ìˆœí™”í•˜ê³  ì§€ì›í•˜ëŠ” Probe-rs ë° OpenOCDì™€ ê°™ì€ í•„ìˆ˜ ì†Œí”„íŠ¸ì›¨ì–´ ë„êµ¬ì™€ GDB ë° Probe-rs Visual Studio Code í™•ì¥ê³¼ ê°™ì€ ì£¼ìš” ë””ë²„ê±°ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤. ë˜í•œ Rusty-probe, ST-Link, J-Link ë° MCU-Linkì™€ ê°™ì€ ì£¼ìš” í•˜ë“œì›¨ì–´ í”„ë¡œë¸Œë¥¼ ë‹¤ë£¨ë©°, ì´ëŠ” ì„ë² ë””ë“œ ì¥ì¹˜ì˜ íš¨ê³¼ì ì¸ ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë°ì— í•„ìˆ˜ì ì…ë‹ˆë‹¤."

#: src/intro/tooling.md:62
msgid "Software that drives debugging tools"
msgstr "ë””ë²„ê¹… ë„êµ¬ë¥¼ êµ¬ë™í•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´"

#: src/intro/tooling.md:64
msgid "Probe-rs"
msgstr "Probe-rs"

#: src/intro/tooling.md:66
msgid ""
"Probe-rs is a modern, Rust-focused software designed to work with debuggers "
"in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in "
"mind and aims to reduce the configuration burden often found in other "
"debugging solutions. It supports various probes and targets, providing a "
"high-level interface for interacting with embedded hardware. Probe-rs "
"integrates directly with Rust tooling, and integrates with Visual Studio "
"Code through its extension, allowing developers to streamline their "
"debugging workflow."
msgstr "Probe-rsëŠ” ì„ë² ë””ë“œ ì‹œìŠ¤í…œì˜ ë””ë²„ê±°ì™€ í•¨ê»˜ ì‘ë™í•˜ë„ë¡ ì„¤ê³„ëœ í˜„ëŒ€ì ì¸ Rust ì¤‘ì‹¬ ì†Œí”„íŠ¸ì›¨ì–´ì…ë‹ˆë‹¤. OpenOCDì™€ ë‹¬ë¦¬ Probe-rsëŠ” ë‹¨ìˆœì„±ì„ ì—¼ë‘ì— ë‘ê³  êµ¬ì¶•ë˜ì—ˆìœ¼ë©° ë‹¤ë¥¸ ë””ë²„ê¹… ì†”ë£¨ì…˜ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” êµ¬ì„± ë¶€ë‹´ì„ ì¤„ì´ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤. ë‹¤ì–‘í•œ í”„ë¡œë¸Œì™€ íƒ€ê²Ÿì„ ì§€ì›í•˜ë©° ì„ë² ë””ë“œ í•˜ë“œì›¨ì–´ì™€ ìƒí˜¸ ì‘ìš©í•˜ê¸° ìœ„í•œ ê³ ìˆ˜ì¤€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. Probe-rsëŠ” Rust íˆ´ë§ê³¼ ì§ì ‘ í†µí•©ë˜ë©° í™•ì¥ì„ í†µí•´ Visual Studio Codeì™€ í†µí•©ë˜ì–´ ê°œë°œìê°€ ë””ë²„ê¹… ì›Œí¬í”Œë¡œë¥¼ ê°„ì†Œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:69
msgid "OpenOCD (Open On-Chip Debugger)"
msgstr "OpenOCD (ì˜¤í”ˆ ì˜¨ì¹© ë””ë²„ê±°)"

#: src/intro/tooling.md:71
msgid ""
"OpenOCD is an open-source software tool used for debugging, testing, and "
"programming embedded systems. It provides an interface between the host "
"system and embedded hardware, supporting various transport layers like JTAG "
"and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a "
"debugger. OpenOCD is widely supported, with extensive documentation and a "
"large community, but may require complex configuration, especially for "
"custom embedded setups."
msgstr "OpenOCDëŠ” ì„ë² ë””ë“œ ì‹œìŠ¤í…œ ë””ë²„ê¹…, í…ŒìŠ¤íŠ¸ ë° í”„ë¡œê·¸ë˜ë°ì— ì‚¬ìš©ë˜ëŠ” ì˜¤í”ˆ ì†ŒìŠ¤ ì†Œí”„íŠ¸ì›¨ì–´ ë„êµ¬ì…ë‹ˆë‹¤. í˜¸ìŠ¤íŠ¸ ì‹œìŠ¤í…œê³¼ ì„ë² ë””ë“œ í•˜ë“œì›¨ì–´ ê°„ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ë©° JTAG ë° SWD(Serial Wire Debug)ì™€ ê°™ì€ ë‹¤ì–‘í•œ ì „ì†¡ ê³„ì¸µì„ ì§€ì›í•©ë‹ˆë‹¤. OpenOCDëŠ” ë””ë²„ê±°ì¸ GDBì™€ í†µí•©ë©ë‹ˆë‹¤. OpenOCDëŠ” ê´‘ë²”ìœ„í•œ ë¬¸ì„œì™€ ëŒ€ê·œëª¨ ì»¤ë®¤ë‹ˆí‹°ë¥¼ í†µí•´ ë„ë¦¬ ì§€ì›ë˜ì§€ë§Œ, íŠ¹íˆ ì‚¬ìš©ì ì •ì˜ ì„ë² ë””ë“œ ì„¤ì •ì˜ ê²½ìš° ë³µì¡í•œ êµ¬ì„±ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:73
msgid "Debuggers"
msgstr "ë””ë²„ê±°"

#: src/intro/tooling.md:75
msgid ""
"A debugger allows developers to inspect and control the execution of a "
"program in order to identify and correct errors or bugs. It provides "
"functionalities such as setting breakpoints, stepping through code line by "
"line, and examining the values of variables and memory states. Debuggers are "
"essential for thorough software development and maintenance, enabling "
"developers to ensure that their code behaves as intended under various "
"conditions."
msgstr "ë””ë²„ê±°ëŠ” ê°œë°œìê°€ ì˜¤ë¥˜ë‚˜ ë²„ê·¸ë¥¼ ì‹ë³„í•˜ê³  ìˆ˜ì •í•˜ê¸° ìœ„í•´ í”„ë¡œê·¸ë¨ ì‹¤í–‰ì„ ê²€ì‚¬í•˜ê³  ì œì–´í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ì¤‘ë‹¨ì  ì„¤ì •, ì½”ë“œ í•œ ì¤„ì”© ì‹¤í–‰, ë³€ìˆ˜ ê°’ ë° ë©”ëª¨ë¦¬ ìƒíƒœ ê²€ì‚¬ì™€ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ë””ë²„ê±°ëŠ” ì² ì €í•œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë° ìœ ì§€ ê´€ë¦¬ì— í•„ìˆ˜ì ì´ë©°, ê°œë°œìê°€ ë‹¤ì–‘í•œ ì¡°ê±´ì—ì„œ ì½”ë“œê°€ ì˜ë„í•œ ëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:77
msgid "Debuggers know how to:"
msgstr "ë””ë²„ê±°ëŠ” ë‹¤ìŒì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì„ ì•Œê³  ìˆìŠµë‹ˆë‹¤:"

#: src/intro/tooling.md:78
msgid "Interact with the memory mapped registers."
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°ì™€ ìƒí˜¸ ì‘ìš©í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:79
msgid "Set Breakpoints/Watchpoints."
msgstr "ì¤‘ë‹¨ì /ê°ì‹œì  ì„¤ì •."

#: src/intro/tooling.md:80
msgid "Read and write to the memory mapped registers."
msgstr "ë©”ëª¨ë¦¬ ë§¤í•‘ ë ˆì§€ìŠ¤í„°ë¥¼ ì½ê³  ì”ë‹ˆë‹¤."

#: src/intro/tooling.md:81
msgid "Detect when the MCU has been halted for a debug event."
msgstr "ë””ë²„ê·¸ ì´ë²¤íŠ¸ë¡œ ì¸í•´ MCUê°€ ì¤‘ë‹¨ë˜ì—ˆì„ ë•Œ ê°ì§€í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:82
msgid "Continue MCU execution after a debug event has been encountered."
msgstr "ë””ë²„ê·¸ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ í›„ MCU ì‹¤í–‰ì„ ê³„ì†í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:83
msgid "Erase and write to the microcontroller's FLASH."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ FLASHë¥¼ ì§€ìš°ê³  ì”ë‹ˆë‹¤."

#: src/intro/tooling.md:85
msgid "Probe-rs Visual Studio Code Extension"
msgstr "Probe-rs Visual Studio Code í™•ì¥"

#: src/intro/tooling.md:87
msgid ""
"Probe-rs has a Visual Studio Code extension, providing a seamless debugging "
"experience without extensive setup. Through this connection, developers can "
"use Rust-specific features like pretty printing and detailed error messages, "
"ensuring that their debugging process aligns with the Rust ecosystem."
msgstr "Probe-rsëŠ” Visual Studio Code í™•ì¥ì„ ì œê³µí•˜ì—¬ ê´‘ë²”ìœ„í•œ ì„¤ì • ì—†ì´ ì›í™œí•œ ë””ë²„ê¹… ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ ì—°ê²°ì„ í†µí•´ ê°œë°œìëŠ” ì˜ˆìœ ì¶œë ¥ ë° ìì„¸í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ ê°™ì€ Rust íŠ¹ì • ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ ë””ë²„ê¹… í”„ë¡œì„¸ìŠ¤ê°€ Rust ìƒíƒœê³„ì™€ ì¼ì¹˜í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/tooling.md:89
msgid "GDB (GNU Debugger)"
msgstr "GDB (GNU ë””ë²„ê±°)"

#: src/intro/tooling.md:91
msgid ""
"GDB is a versatile debugging tool that allows developers to examine the "
"state of programs while they run or after they crash. For embedded Rust, GDB "
"connects to the target system via OpenOCD or other debugging servers to "
"interact with the embedded code. GDB is highly configurable and supports "
"features like remote debugging, variable inspection, and conditional "
"breakpoints. It can be used on a variety of platforms, and has extensive "
"support for Rust-specific debugging needs, such as pretty printing and "
"integration with IDEs."
msgstr "GDBëŠ” ê°œë°œìê°€ í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ë˜ëŠ” ì¶©ëŒ í›„ í”„ë¡œê·¸ë¨ ìƒíƒœë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë‹¤ëª©ì  ë””ë²„ê¹… ë„êµ¬ì…ë‹ˆë‹¤. ì„ë² ë””ë“œ Rustì˜ ê²½ìš° GDBëŠ” OpenOCD ë˜ëŠ” ë‹¤ë¥¸ ë””ë²„ê¹… ì„œë²„ë¥¼ í†µí•´ ëŒ€ìƒ ì‹œìŠ¤í…œì— ì—°ê²°í•˜ì—¬ ì„ë² ë””ë“œ ì½”ë“œì™€ ìƒí˜¸ ì‘ìš©í•©ë‹ˆë‹¤. GDBëŠ” ê³ ë„ë¡œ êµ¬ì„± ê°€ëŠ¥í•˜ë©° ì›ê²© ë””ë²„ê¹…, ë³€ìˆ˜ ê²€ì‚¬ ë° ì¡°ê±´ë¶€ ì¤‘ë‹¨ì ê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì§€ì›í•©ë‹ˆë‹¤. ë‹¤ì–‘í•œ í”Œë«í¼ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©° ì˜ˆìœ ì¶œë ¥ ë° IDE í†µí•©ê³¼ ê°™ì€ Rust íŠ¹ì • ë””ë²„ê¹… ìš”êµ¬ ì‚¬í•­ì— ëŒ€í•œ ê´‘ë²”ìœ„í•œ ì§€ì›ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/intro/tooling.md:94
msgid "Probes"
msgstr "í”„ë¡œë¸Œ"

#: src/intro/tooling.md:96
msgid ""
"A hardware probe is a device used in the development and debugging of "
"embedded systems to facilitate communication between a host computer and the "
"target embedded device. It typically supports protocols like JTAG or SWD, "
"enabling it to program, debug, and analyze the microcontroller or "
"microprocessor on the embedded system. Hardware probes are crucial for "
"developers to set breakpoints, step through code, and inspect memory and "
"processor registers, effectively allowing them to diagnose and fix issues in "
"real-time."
msgstr "í•˜ë“œì›¨ì–´ í”„ë¡œë¸ŒëŠ” í˜¸ìŠ¤íŠ¸ ì»´í“¨í„°ì™€ ëŒ€ìƒ ì„ë² ë””ë“œ ì¥ì¹˜ ê°„ì˜ í†µì‹ ì„ ìš©ì´í•˜ê²Œ í•˜ê¸° ìœ„í•´ ì„ë² ë””ë“œ ì‹œìŠ¤í…œ ê°œë°œ ë° ë””ë²„ê¹…ì— ì‚¬ìš©ë˜ëŠ” ì¥ì¹˜ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ JTAG ë˜ëŠ” SWDì™€ ê°™ì€ í”„ë¡œí† ì½œì„ ì§€ì›í•˜ì—¬ ì„ë² ë””ë“œ ì‹œìŠ¤í…œì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ë˜ëŠ” ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œë¥¼ í”„ë¡œê·¸ë˜ë°, ë””ë²„ê¹… ë° ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ í”„ë¡œë¸ŒëŠ” ê°œë°œìê°€ ì¤‘ë‹¨ì ì„ ì„¤ì •í•˜ê³ , ì½”ë“œë¥¼ ë‹¨ê³„ë³„ë¡œ ì‹¤í–‰í•˜ê³ , ë©”ëª¨ë¦¬ ë° í”„ë¡œì„¸ì„œ ë ˆì§€ìŠ¤í„°ë¥¼ ê²€ì‚¬í•˜ì—¬ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¬¸ì œë¥¼ ì§„ë‹¨í•˜ê³  í•´ê²°í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë° ì¤‘ìš”í•©ë‹ˆë‹¤."

#: src/intro/tooling.md:98
msgid "Rusty-probe"
msgstr "Rusty-probe"

#: src/intro/tooling.md:100
msgid ""
"Rusty-probe is an open-sourced USB-based hardware debugging probe designed "
"to work with probe-rs. The combination of Rusty-Probe and probe-rs provides "
"an easy-to-use, cost-effective solution for developers working with embedded "
"Rust applications."
msgstr "Rusty-probeëŠ” probe-rsì™€ í•¨ê»˜ ì‘ë™í•˜ë„ë¡ ì„¤ê³„ëœ ì˜¤í”ˆ ì†ŒìŠ¤ USB ê¸°ë°˜ í•˜ë“œì›¨ì–´ ë””ë²„ê¹… í”„ë¡œë¸Œì…ë‹ˆë‹¤. Rusty-Probeì™€ probe-rsì˜ ì¡°í•©ì€ ì„ë² ë””ë“œ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•˜ëŠ” ê°œë°œìë¥¼ ìœ„í•œ ì‚¬ìš©í•˜ê¸° ì‰½ê³  ë¹„ìš© íš¨ìœ¨ì ì¸ ì†”ë£¨ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/intro/tooling.md:102
msgid "ST-Link"
msgstr "ST-Link"

#: src/intro/tooling.md:104
msgid ""
"The ST-Link is a popular debugging and programming probe developed by "
"STMicroelectronics primarily for their STM32 and STM8 microcontroller "
"series. It supports both debugging and programming via JTAG or SWD (Serial "
"Wire Debug) interfaces. ST-Link is widely used due to its direct support "
"from STMicroelectronics' extensive range of development boards and its "
"integration into major IDEs, making it a convenient choice for developers "
"working with STM microcontrollers."
msgstr "ST-LinkëŠ” STMicroelectronicsì—ì„œ ì£¼ë¡œ STM32 ë° STM8 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ì‹œë¦¬ì¦ˆë¥¼ ìœ„í•´ ê°œë°œí•œ ì¸ê¸° ìˆëŠ” ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë° í”„ë¡œë¸Œì…ë‹ˆë‹¤. JTAG ë˜ëŠ” SWD(Serial Wire Debug) ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë””ë²„ê¹… ë° í”„ë¡œê·¸ë˜ë°ì„ ëª¨ë‘ ì§€ì›í•©ë‹ˆë‹¤. ST-LinkëŠ” STMicroelectronicsì˜ ê´‘ë²”ìœ„í•œ ê°œë°œ ë³´ë“œì—ì„œ ì§ì ‘ ì§€ì›í•˜ê³  ì£¼ìš” IDEì— í†µí•©ë˜ì–´ STM ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê°œë°œìì—ê²Œ í¸ë¦¬í•œ ì„ íƒì´ë¯€ë¡œ ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:106
msgid "J-Link"
msgstr "J-Link"

#: src/intro/tooling.md:108
msgid ""
"J-Link, developed by SEGGER Microcontroller, is a robust and versatile "
"debugger supporting a wide range of CPU cores and devices beyond just ARM, "
"such as RISC-V. Known for its high performance and reliability, J-Link "
"supports various communication interfaces, including JTAG, SWD, and fine-"
"pitch JTAG interfaces. It is favored for its advanced features like "
"unlimited breakpoints in flash memory and its compatibility with a multitude "
"of development environments."
msgstr "SEGGER Microcontrollerì—ì„œ ê°œë°œí•œ J-LinkëŠ” RISC-Vì™€ ê°™ì€ ARM ì™¸ì—ë„ ê´‘ë²”ìœ„í•œ CPU ì½”ì–´ ë° ì¥ì¹˜ë¥¼ ì§€ì›í•˜ëŠ” ê°•ë ¥í•˜ê³  ë‹¤ì¬ë‹¤ëŠ¥í•œ ë””ë²„ê±°ì…ë‹ˆë‹¤. ê³ ì„±ëŠ¥ê³¼ ì‹ ë¢°ì„±ìœ¼ë¡œ ìœ ëª…í•œ J-LinkëŠ” JTAG, SWD ë° ë¯¸ì„¸ í”¼ì¹˜ JTAG ì¸í„°í˜ì´ìŠ¤ë¥¼ í¬í•¨í•œ ë‹¤ì–‘í•œ í†µì‹  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. í”Œë˜ì‹œ ë©”ëª¨ë¦¬ì˜ ë¬´ì œí•œ ì¤‘ë‹¨ì ê³¼ ë‹¤ì–‘í•œ ê°œë°œ í™˜ê²½ê³¼ì˜ í˜¸í™˜ì„±ê³¼ ê°™ì€ ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ ì„ í˜¸ë©ë‹ˆë‹¤."

#: src/intro/tooling.md:110
msgid "MCU-Link"
msgstr "MCU-Link"

#: src/intro/tooling.md:112
msgid ""
"MCU-Link is a debugging probe that also functions as a programmer, provided "
"by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers "
"and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-"
"Link is particularly notable for its versatility and affordability, making "
"it an accessible option for hobbyists, educators, and professional "
"developers alike."
msgstr "MCU-LinkëŠ” NXP Semiconductorsì—ì„œ ì œê³µí•˜ëŠ” í”„ë¡œê·¸ë˜ë¨¸ ì—­í• ë„ í•˜ëŠ” ë””ë²„ê¹… í”„ë¡œë¸Œì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ ARM Cortex ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì§€ì›í•˜ë©° MCUXpresso IDEì™€ ê°™ì€ ê°œë°œ ë„êµ¬ì™€ ì›í™œí•˜ê²Œ ì¸í„°í˜ì´ìŠ¤í•©ë‹ˆë‹¤. MCU-LinkëŠ” íŠ¹íˆ ë‹¤ìš©ë„ì„±ê³¼ ê²½ì œì„±ìœ¼ë¡œ ìœ ëª…í•˜ì—¬ ì·¨ë¯¸ ê°œë°œì, êµìœ¡ì ë° ì „ë¬¸ ê°œë°œì ëª¨ë‘ì—ê²Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì˜µì…˜ì…ë‹ˆë‹¤."

#: src/intro/install.md:1
msgid "Installing the tools"
msgstr "ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install.md:3
msgid ""
"This page contains OS-agnostic installation instructions for a few of the "
"tools:"
msgstr "ì´ í˜ì´ì§€ì—ëŠ” ëª‡ ê°€ì§€ ë„êµ¬ì— ëŒ€í•œ OS ë…ë¦½ì ì¸ ì„¤ì¹˜ ì§€ì¹¨ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install.md:5
msgid "Rust Toolchain"
msgstr "Rust íˆ´ì²´ì¸"

#: src/intro/install.md:7
msgid ""
"Install rustup by following the instructions at [https://rustup.rs](https://"
"rustup.rs)."
msgstr "[https://rustup.rs](https://rustup.rs)ì˜ ì§€ì¹¨ì— ë”°ë¼ rustupì„ ì„¤ì¹˜í•˜ì„¸ìš”."

#: src/intro/install.md:9
msgid ""
"**NOTE** Make sure you have a compiler version equal to or newer than "
"`1.31`. `rustc -V` should return a date newer than the one shown below."
msgstr "**ì°¸ê³ ** ì»´íŒŒì¼ëŸ¬ ë²„ì „ì´ `1.31` ì´ìƒì¸ì§€ í™•ì¸í•˜ì„¸ìš”. `rustc -V`ëŠ” ì•„ë˜ í‘œì‹œëœ ë‚ ì§œë³´ë‹¤ ìµœì‹  ë‚ ì§œë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/install.md:17
msgid ""
"For bandwidth and disk usage concerns the default installation only supports "
"native compilation. To add cross compilation support for the ARM Cortex-M "
"architectures choose one of the following compilation targets. For the "
"STM32F3DISCOVERY board used for the examples in this book, use the "
"`thumbv7em-none-eabihf` target. [Find the best Cortex-M for you.](https://"
"developer.arm.com/ip-products/processors/cortex-"
"m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"
msgstr "ëŒ€ì—­í­ ë° ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ ë¬¸ì œë¡œ ì¸í•´ ê¸°ë³¸ ì„¤ì¹˜ëŠ” ë„¤ì´í‹°ë¸Œ ì»´íŒŒì¼ë§Œ ì§€ì›í•©ë‹ˆë‹¤. ARM Cortex-M ì•„í‚¤í…ì²˜ì— ëŒ€í•œ í¬ë¡œìŠ¤ ì»´íŒŒì¼ ì§€ì›ì„ ì¶”ê°€í•˜ë ¤ë©´ ë‹¤ìŒ ì»´íŒŒì¼ ëŒ€ìƒ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”. ì´ ì±…ì˜ ì˜ˆì œì— ì‚¬ìš©ëœ STM32F3DISCOVERY ë³´ë“œì˜ ê²½ìš° `thumbv7em-none-eabihf` ëŒ€ìƒì„ ì‚¬ìš©í•˜ì„¸ìš”. [ìì‹ ì—ê²Œ ê°€ì¥ ì í•©í•œ Cortex-Mì„ ì°¾ìœ¼ì„¸ìš”.](https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"

#: src/intro/install.md:23
msgid "Cortex-M0, M0+, and M1 (ARMv6-M architecture):"
msgstr "Cortex-M0, M0+, M1 (ARMv6-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:28
msgid "Cortex-M3 (ARMv7-M architecture):"
msgstr "Cortex-M3 (ARMv7-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:33
msgid ""
"Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ì—†ëŠ” Cortex-M4 ë° M7 (ARMv7E-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:38
msgid ""
"Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ìˆëŠ” Cortex-M4F ë° M7F (ARMv7E-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:43
msgid "Cortex-M23 (ARMv8-M architecture):"
msgstr "Cortex-M23 (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:48
msgid "Cortex-M33 and M35P (ARMv8-M architecture):"
msgstr "Cortex-M33 ë° M35P (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:53
msgid ""
"Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):"
msgstr "í•˜ë“œì›¨ì–´ ë¶€ë™ ì†Œìˆ˜ì  ìˆëŠ” Cortex-M33F ë° M35PF (ARMv8-M ì•„í‚¤í…ì²˜):"

#: src/intro/install.md:66
msgid ""
"WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. "
"https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=16"
msgstr "WINDOWS: Visual Studio 2019ìš© C++ ë¹Œë“œ ë„êµ¬ í•„ìˆ˜ êµ¬ì„± ìš”ì†Œê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16"

#: src/intro/install.md:67
msgid "`cargo-generate`"
msgstr "`cargo-generate`"

#: src/intro/install.md:69
msgid "We'll use this later to generate a project from a template."
msgstr "ë‚˜ì¤‘ì— í…œí”Œë¦¿ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤."

#: src/intro/install.md:75
msgid ""
"Note: on some Linux distros (e.g. Ubuntu) you may need to install the "
"packages `libssl-dev` and `pkg-config` prior to installing cargo-generate."
msgstr "ì°¸ê³ : ì¼ë¶€ Linux ë°°í¬íŒ(ì˜ˆ: Ubuntu)ì—ì„œëŠ” cargo-generateë¥¼ ì„¤ì¹˜í•˜ê¸° ì „ì— `libssl-dev` ë° `pkg-config` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install.md:77
msgid "OS-Specific Instructions"
msgstr "OSë³„ ì§€ì¹¨"

#: src/intro/install.md:79
msgid "Now follow the instructions specific to the OS you are using:"
msgstr "ì´ì œ ì‚¬ìš© ì¤‘ì¸ OSì— íŠ¹ì •í•œ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”:"

#: src/intro/install.md:81
msgid "[Linux](install/linux.md)"
msgstr "[ë¦¬ëˆ…ìŠ¤](install/linux.md)"

#: src/intro/install.md:82
msgid "[Windows](install/windows.md)"
msgstr "[ìœˆë„ìš°](install/windows.md)"

#: src/intro/install.md:83
msgid "[macOS](install/macos.md)"
msgstr "[macOS](install/macos.md)"

#: src/intro/install/linux.md:3
msgid "Here are the installation commands for a few Linux distributions."
msgstr "ë‹¤ìŒì€ ëª‡ ê°€ì§€ Linux ë°°í¬íŒì— ëŒ€í•œ ì„¤ì¹˜ ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:5
msgid "Packages"
msgstr "íŒ¨í‚¤ì§€"

#: src/intro/install/linux.md:7
msgid "Ubuntu 18.04 or newer / Debian stretch or newer"
msgstr "Ubuntu 18.04 ì´ìƒ / Debian stretch ì´ìƒ"

#: src/intro/install/linux.md:9
msgid ""
"**NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `gdb-multiarch`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:26
msgid "Ubuntu 14.04 and 16.04"
msgstr "Ubuntu 14.04 ë° 16.04"

#: src/intro/install/linux.md:28
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `arm-none-eabi-gdb`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:40
msgid "Fedora 27 or newer"
msgstr "Fedora 27 ì´ìƒ"

#: src/intro/install/linux.md:51
msgid "Arch Linux"
msgstr "Arch Linux"

#: src/intro/install/linux.md:53
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM "
"Cortex-M programs"
msgstr "**ì°¸ê³ ** `arm-none-eabi-gdb`ëŠ” ARM Cortex-M í”„ë¡œê·¸ë¨ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ì‚¬ìš©í•  GDB ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

#: src/intro/install/linux.md:60
msgid "udev rules"
msgstr "udev ê·œì¹™"

#: src/intro/install/linux.md:62
msgid ""
"This rule lets you use OpenOCD with the Discovery board without root "
"privilege."
msgstr "ì´ ê·œì¹™ì„ ì‚¬ìš©í•˜ë©´ ë£¨íŠ¸ ê¶Œí•œ ì—†ì´ Discovery ë³´ë“œì™€ í•¨ê»˜ OpenOCDë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/linux.md:64
msgid ""
"Create the file `/etc/udev/rules.d/70-st-link.rules` with the contents shown "
"below."
msgstr "ì•„ë˜ì— í‘œì‹œëœ ë‚´ìš©ìœ¼ë¡œ `/etc/udev/rules.d/70-st-link.rules` íŒŒì¼ì„ ìƒì„±í•˜ì„¸ìš”."

#: src/intro/install/linux.md:66
msgid ""
"```text\n"
"# STM32F3DISCOVERY rev A/B - ST-LINK/V2\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n"
"\n"
"# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n"
"```"
msgstr "```text\n# STM32F3DISCOVERY rev A/B - ST-LINK/V2\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n\n# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n```"

#: src/intro/install/linux.md:74
msgid "Then reload all the udev rules with:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ ëª¨ë“  udev ê·œì¹™ì„ ë‹¤ì‹œ ë¡œë“œí•˜ì„¸ìš”:"

#: src/intro/install/linux.md:80
msgid ""
"If you had the board plugged to your laptop, unplug it and then plug it "
"again."
msgstr "ë³´ë“œê°€ ë…¸íŠ¸ë¶ì— ì—°ê²°ë˜ì–´ ìˆì—ˆë‹¤ë©´, í”ŒëŸ¬ê·¸ë¥¼ ë½‘ì•˜ë‹¤ê°€ ë‹¤ì‹œ ì—°ê²°í•˜ì„¸ìš”."

#: src/intro/install/linux.md:82
msgid "You can check the permissions by running this command:"
msgstr "ì´ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì—¬ ê¶Œí•œì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/linux.md:88
msgid "Which should show something like"
msgstr "ë‹¤ìŒê³¼ ê°™ì´ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/intro/install/linux.md:96
msgid ""
"Take note of the bus and device numbers. Use those numbers to create a path "
"like `/dev/bus/usb/<bus>/<device>`. Then use this path like so:"
msgstr "ë²„ìŠ¤ ë° ì¥ì¹˜ ë²ˆí˜¸ë¥¼ ê¸°ë¡í•´ ë‘ì„¸ìš”. ì´ ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ `/dev/bus/usb/<bus>/<device>`ì™€ ê°™ì€ ê²½ë¡œë¥¼ ìƒì„±í•˜ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ì´ ê²½ë¡œë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•˜ì„¸ìš”:"

#: src/intro/install/linux.md:116
msgid ""
"The `+` appended to permissions indicates the existence of an extended "
"permission. The `getfacl` command tells the user `you` can make use of this "
"device."
msgstr "ê¶Œí•œì— ì¶”ê°€ëœ `+`ëŠ” í™•ì¥ ê¶Œí•œì˜ ì¡´ì¬ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. `getfacl` ëª…ë ¹ì€ ì‚¬ìš©ì `ë‹¹ì‹ `ì´ ì´ ì¥ì¹˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤."

#: src/intro/install/linux.md:120
msgid "Now, go to the [next section](verify.md)."
msgstr "ì´ì œ [ë‹¤ìŒ ì„¹ì…˜](verify.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/macos.md:1
msgid "macOS"
msgstr "macOS"

#: src/intro/install/macos.md:3
msgid ""
"All the tools can be installed using [Homebrew](http://brew.sh/) or "
"[MacPorts](https://www.macports.org/):"
msgstr "ëª¨ë“  ë„êµ¬ëŠ” [Homebrew](http://brew.sh/) ë˜ëŠ” [MacPorts](https://www.macports.org/)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/macos.md:8
msgid "Install tools with [Homebrew](http://brew.sh/)"
msgstr "[Homebrew](http://brew.sh/)ë¡œ ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install/macos.md:21
msgid ""
"**NOTE** If OpenOCD crashes you may need to install the latest version using:"
msgstr "**ì°¸ê³ ** OpenOCDê°€ ì¶©ëŒí•˜ë©´ ë‹¤ìŒì„ ì‚¬ìš©í•˜ì—¬ ìµœì‹  ë²„ì „ì„ ì„¤ì¹˜í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/intro/install/macos.md:26
msgid "Install tools with [MacPorts](https://www.macports.org/)"
msgstr "[MacPorts](https://www.macports.org/)ë¡œ ë„êµ¬ ì„¤ì¹˜"

#: src/intro/install/macos.md:41 src/intro/install/windows.md:48
msgid "That's all! Go to the [next section](verify.md)."
msgstr "ê·¸ê²Œ ë‹¤ì…ë‹ˆë‹¤! [ë‹¤ìŒ ì„¹ì…˜](verify.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/windows.md:3
msgid "`arm-none-eabi-gdb`"
msgstr "`arm-none-eabi-gdb`"

#: src/intro/install/windows.md:5
msgid ""
"ARM provides `.exe` installers for Windows. Grab one from [here](https://"
"developer.arm.com/downloads/-/arm-gnu-toolchain-downloads), and follow the "
"instructions. Just before the installation process finishes tick/select the "
"\"Add path to environment variable\" option. Then verify that the tools are "
"in your `%PATH%`:"
msgstr "ARMì€ Windowsìš© `.exe` ì„¤ì¹˜ í”„ë¡œê·¸ë¨ì„ ì œê³µí•©ë‹ˆë‹¤. [ì—¬ê¸°](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)ì—ì„œ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”. ì„¤ì¹˜ í”„ë¡œì„¸ìŠ¤ê°€ ëë‚˜ê¸° ì§ì „ì— "í™˜ê²½ ë³€ìˆ˜ì— ê²½ë¡œ ì¶”ê°€" ì˜µì…˜ì„ ì„ íƒ/ì²´í¬í•˜ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ë„êµ¬ê°€ `%PATH%`ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"

#: src/intro/install/windows.md:17
msgid "OpenOCD"
msgstr "OpenOCD"

#: src/intro/install/windows.md:19
msgid ""
"There's no official binary release of OpenOCD for Windows but if you're not "
"in the mood to compile it yourself, the xPack project provides a binary "
"distribution, [here](https://xpack.github.io/openocd/). Follow the provided "
"installation instructions. Then update your `%PATH%` environment variable to "
"include the path where the binaries were installed. (`C:"
"\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-"
"tools\\openocd\\0.10.0-13.1\\.content\\bin\\`, if you've been using the easy "
"install)"
msgstr "Windowsìš© OpenOCD ê³µì‹ ë°”ì´ë„ˆë¦¬ ë¦´ë¦¬ìŠ¤ëŠ” ì—†ì§€ë§Œ ì§ì ‘ ì»´íŒŒì¼í•  ì˜í–¥ì´ ì—†ë‹¤ë©´ xPack í”„ë¡œì íŠ¸ì—ì„œ [ì—¬ê¸°](https://xpack.github.io/openocd/)ì—ì„œ ë°”ì´ë„ˆë¦¬ ë°°í¬íŒì„ ì œê³µí•©ë‹ˆë‹¤. ì œê³µëœ ì„¤ì¹˜ ì§€ì¹¨ì„ ë”°ë¥´ì„¸ìš”. ê·¸ëŸ° ë‹¤ìŒ ë°”ì´ë„ˆë¦¬ê°€ ì„¤ì¹˜ëœ ê²½ë¡œë¥¼ í¬í•¨í•˜ë„ë¡ `%PATH%` í™˜ê²½ ë³€ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”. (ì‰¬ìš´ ì„¤ì¹˜ë¥¼ ì‚¬ìš©í–ˆë‹¤ë©´ `C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\`)"

#: src/intro/install/windows.md:27
msgid "Verify that OpenOCD is in your `%PATH%` with:"
msgstr "ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ OpenOCDê°€ `%PATH%`ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"

#: src/intro/install/windows.md:37
msgid ""
"Grab QEMU from [the official website](https://www.qemu.org/download/"
"#windows)."
msgstr "[ê³µì‹ ì›¹ì‚¬ì´íŠ¸](https://www.qemu.org/download/#windows)ì—ì„œ QEMUë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”."

#: src/intro/install/windows.md:41
msgid "ST-LINK USB driver"
msgstr "ST-LINK USB ë“œë¼ì´ë²„"

#: src/intro/install/windows.md:43
msgid ""
"You'll also need to install [this USB driver](http://www.st.com/en/embedded-"
"software/stsw-link009.html) or OpenOCD won't work. Follow the installer "
"instructions and make sure you install the right version (32-bit or 64-bit) "
"of the driver."
msgstr "ë˜í•œ [ì´ USB ë“œë¼ì´ë²„](http://www.st.com/en/embedded-software/stsw-link009.html)ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ OpenOCDê°€ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì„¤ì¹˜ í”„ë¡œê·¸ë¨ ì§€ì¹¨ì„ ë”°ë¥´ê³  ì˜¬ë°”ë¥¸ ë²„ì „(32ë¹„íŠ¸ ë˜ëŠ” 64ë¹„íŠ¸)ì˜ ë“œë¼ì´ë²„ë¥¼ ì„¤ì¹˜í–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/intro/install/verify.md:3
msgid ""
"In this section we check that some of the required tools / drivers have been "
"correctly installed and configured."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” í•„ìš”í•œ ë„êµ¬/ë“œë¼ì´ë²„ ì¤‘ ì¼ë¶€ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì¹˜ ë° êµ¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."

#: src/intro/install/verify.md:6
msgid ""
"Connect your laptop / PC to the discovery board using a Mini-USB USB cable. "
"The discovery board has two USB connectors; use the one labeled \"USB ST-"
"LINK\" that sits on the center of the edge of the board."
msgstr "ë¯¸ë‹ˆ USB ì¼€ì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ ë…¸íŠ¸ë¶/PCë¥¼ ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì— ì—°ê²°í•˜ì„¸ìš”. ë””ìŠ¤ì»¤ë²„ë¦¬ ë³´ë“œì—ëŠ” ë‘ ê°œì˜ USB ì»¤ë„¥í„°ê°€ ìˆìŠµë‹ˆë‹¤. ë³´ë“œ ê°€ì¥ìë¦¬ ì¤‘ì•™ì— ìˆëŠ” \"USB ST-LINK\"ë¼ê³  í‘œì‹œëœ ì»¤ë„¥í„°ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/intro/install/verify.md:10
msgid ""
"Also check that the ST-LINK header is populated. See the picture below; the "
"ST-LINK header is highlighted."
msgstr "ë˜í•œ ST-LINK í—¤ë”ê°€ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. ì•„ë˜ ê·¸ë¦¼ì„ ì°¸ì¡°í•˜ì„¸ìš”. ST-LINK í—¤ë”ê°€ ê°•ì¡° í‘œì‹œë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:17
msgid "Now run the following command:"
msgstr "ì´ì œ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"

#: src/intro/install/verify.md:23
msgid ""
"**NOTE**: Old versions of openocd, including the 0.10.0 release from 2017, "
"do not contain the new (and preferable) `interface/stlink.cfg` file; instead "
"you may need to use `interface/stlink-v2.cfg` or `interface/stlink-v2-1.cfg`."
msgstr "**ì°¸ê³ **: 2017ë…„ 0.10.0 ë¦´ë¦¬ìŠ¤ë¥¼ í¬í•¨í•œ ì´ì „ ë²„ì „ì˜ OpenOCDì—ëŠ” ìƒˆë¡­ê³  ì„ í˜¸ë˜ëŠ” `interface/stlink.cfg` íŒŒì¼ì´ í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  `interface/stlink-v2.cfg` ë˜ëŠ” `interface/stlink-v2-1.cfg`ë¥¼ ì‚¬ìš©í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:27
msgid ""
"You should get the following output and the program should block the console:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ì´ í‘œì‹œë˜ê³  í”„ë¡œê·¸ë¨ì´ ì½˜ì†”ì„ ì°¨ë‹¨í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/intro/install/verify.md:29
msgid ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr "```text\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nInfo : auto-selecting first available session transport \"hla_swd\". To override use 'transport select <transport>'.\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\nInfo : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD\nnone separate\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : clock speed 950 kHz\nInfo : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\nInfo : using stlink api v2\nInfo : Target voltage: 2.919881\nInfo : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n```"

#: src/intro/install/verify.md:48
msgid ""
"The contents may not match exactly but you should get the last line about "
"breakpoints and watchpoints. If you got it then terminate the OpenOCD "
"process and move to the [next section](../../start/index.md)."
msgstr "ë‚´ìš©ì´ ì •í™•íˆ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ ì¤‘ë‹¨ì  ë° ê°ì‹œì ì— ëŒ€í•œ ë§ˆì§€ë§‰ ì¤„ì´ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ì¤„ì´ í‘œì‹œë˜ë©´ OpenOCD í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ê³  [ë‹¤ìŒ ì„¹ì…˜](../../start/index.md)ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”."

#: src/intro/install/verify.md:54
msgid ""
"If you didn't get the "breakpoints" line then try one of the following "
"commands."
msgstr "breakpoints" ì¤„ì´ í‘œì‹œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ìŒ ëª…ë ¹ ì¤‘ í•˜ë‚˜ë¥¼ ì‹œë„í•´ ë³´ì„¸ìš”."

#: src/intro/install/verify.md:64
msgid ""
"If one of those commands works it means you got an old hardware revision of "
"the discovery board. That won't be a problem but commit that fact to memory "
"as you'll need to configure things a bit differently later on. You can move "
"to the [next section](../../start/index.md)."
msgstr "ì´ ëª…ë ¹ ì¤‘ í•˜ë‚˜ê°€ ì‘ë™í•œë‹¤ë©´ Discovery ë³´ë“œì˜ ì´ì „ í•˜ë“œì›¨ì–´ ê°œì •íŒì„ ì‚¬ìš©í•˜ê³  ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ì´ëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ ë‚˜ì¤‘ì— ì„¤ì •ì„ ì•½ê°„ ë‹¤ë¥´ê²Œ êµ¬ì„±í•´ì•¼ í•˜ë¯€ë¡œ ì´ ì‚¬ì‹¤ì„ ê¸°ì–µí•´ ë‘ì„¸ìš”. [ë‹¤ìŒ ì„¹ì…˜](../../start/index.md)ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/intro/install/verify.md:69
msgid ""
"If none of the commands work as a normal user then try to run them with root "
"permission (e.g. `sudo openocd ..`). If the commands do work with root "
"permission then check that the [udev rules](linux.md#udev-rules) have been "
"correctly set."
msgstr "ì¼ë°˜ ì‚¬ìš©ìë¡œëŠ” ì–´ë–¤ ëª…ë ¹ë„ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë£¨íŠ¸ ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•´ ë³´ì„¸ìš”(ì˜ˆ: `sudo openocd ..`). ëª…ë ¹ì´ ë£¨íŠ¸ ê¶Œí•œìœ¼ë¡œ ì‘ë™í•œë‹¤ë©´ [udev ê·œì¹™](linux.md#udev-rules)ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/intro/install/verify.md:75
msgid ""
"If you have reached this point and OpenOCD is not working please open [an "
"issue](https://github.com/rust-embedded/book/issues) and we'll help you out!"
msgstr "ì´ ì‹œì ê¹Œì§€ OpenOCDê°€ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ [ì´ìŠˆ](https://github.com/rust-embedded/book/issues)ë¥¼ ì—´ì–´ì£¼ì„¸ìš”. ì €í¬ê°€ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!"

#: src/start/index.md:1
msgid "Getting Started"
msgstr "ì‹œì‘í•˜ê¸°"

#: src/start/index.md:3
msgid ""
"In this section we'll walk you through the process of writing, building, "
"flashing and debugging embedded programs. You will be able to try most of "
"the examples without any special hardware as we will show you the basics "
"using QEMU, a popular open-source hardware emulator. The only section where "
"hardware is required is, naturally enough, the [Hardware](./hardware.md) "
"section, where we use OpenOCD to program an [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html)."
msgstr "ì´ ì„¹ì…˜ì—ì„œëŠ” ì„ë² ë””ë“œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±, ë¹Œë“œ, í”Œë˜ì‹± ë° ë””ë²„ê¹…í•˜ëŠ” ê³¼ì •ì„ ì•ˆë‚´í•©ë‹ˆë‹¤. ì¸ê¸° ìˆëŠ” ì˜¤í”ˆ ì†ŒìŠ¤ í•˜ë“œì›¨ì–´ ì—ë®¬ë ˆì´í„°ì¸ QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ ì‚¬í•­ì„ ë³´ì—¬ì£¼ë¯€ë¡œ íŠ¹ë³„í•œ í•˜ë“œì›¨ì–´ ì—†ì´ë„ ëŒ€ë¶€ë¶„ì˜ ì˜ˆì œë¥¼ ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ê°€ í•„ìš”í•œ ìœ ì¼í•œ ì„¹ì…˜ì€ ë‹¹ì—°íˆ OpenOCDë¥¼ ì‚¬ìš©í•˜ì—¬ [STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html)ë¥¼ í”„ë¡œê·¸ë˜ë°í•˜ëŠ” [í•˜ë“œì›¨ì–´](./hardware.md) ì„¹ì…˜ì…ë‹ˆë‹¤."

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""
"[LM3S6965](http://www.ti.com/product/"
"LM3S6965), Cortex-M3 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ìœ„í•œ í”„ë¡œê·¸ë¨ ì‘ì„±ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤. "
"ì´ë¥¼ ì´ˆê¸° íƒ€ê²Ÿìœ¼ë¡œ ì„ íƒí•œ ì´ìœ ëŠ” QEMUë¥¼ ì‚¬ìš©í•˜ì—¬ [ì—ë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆê¸°](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) ë•Œë¬¸ì— ì´ ì„¹ì…˜ì—ì„œëŠ” "
"í•˜ë“œì›¨ì–´ë¥¼ ë§Œì§ˆ í•„ìš”ê°€ ì—†ê³  íˆ´ë§ê³¼ "
"ê°œë°œ ê³¼ì •ì— ì§‘ì¤‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""
"**ì¤‘ìš”** ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” í”„ë¡œì íŠ¸ ì´ë¦„ìœ¼ë¡œ \"app\"ì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤. "
"\"app\"ì´ë¼ëŠ” ë‹¨ì–´ë¥¼ ë³¼ ë•Œë§ˆë‹¤ í”„ë¡œì íŠ¸ì— ëŒ€í•´ ì„ íƒí•œ "
"ì´ë¦„ìœ¼ë¡œ ë°”ê¿”ì•¼ í•©ë‹ˆë‹¤. ë˜ëŠ” í”„ë¡œì íŠ¸ ì´ë¦„ì„ "
"\"app\"ìœ¼ë¡œ ì§€ì •í•˜ì—¬ ì¹˜í™˜ì„ í”¼í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr "ë¹„í‘œì¤€ Rust í”„ë¡œê·¸ë¨ ë§Œë“¤ê¸°"

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""
"[`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) í”„ë¡œì íŠ¸ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ê² ìŠµë‹ˆë‹¤. "
"ìƒì„±ëœ í”„ë¡œì íŠ¸ëŠ” ê¸°ë³¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ í¬í•¨í•  ê²ƒì…ë‹ˆë‹¤: ìƒˆë¡œìš´ ì„ë² ë””ë“œ rust ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ìœ„í•œ "
"ì¢‹ì€ ì‹œì‘ì ì…ë‹ˆë‹¤. ë˜í•œ í”„ë¡œì íŠ¸ì—ëŠ” "
"í•µì‹¬ ì„ë² ë””ë“œ rust ê¸°ëŠ¥ì„ ê°•ì¡°í•˜ëŠ” ì—¬ëŸ¬ ê°œë³„ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìˆëŠ” "
"`examples` ë””ë ‰í† ë¦¬ê°€ í¬í•¨ë©ë‹ˆë‹¤."

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "`cargo-generate` ì‚¬ìš©í•˜ê¸°"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "ë¨¼ì € cargo-generateë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "`git` ì‚¬ìš©í•˜ê¸°"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr "ì €ì¥ì†Œë¥¼ í´ë¡ í•˜ì„¸ìš”"

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr "ê·¸ëŸ° ë‹¤ìŒ `Cargo.toml` íŒŒì¼ì˜ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì±„ìš°ì„¸ìš”"

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"

#: src/start/qemu.md:72
msgid "Using neither"
msgstr "ë‘˜ ë‹¤ ì‚¬ìš©í•˜ì§€ ì•Šê¸°"

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""
"`cortex-m-quickstart` í…œí”Œë¦¿ì˜ ìµœì‹  ìŠ¤ëƒ…ìƒ·ì„ ê°€ì ¸ì™€ì„œ "
"ì••ì¶•ì„ í•´ì œí•˜ì„¸ìš”."

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""
"ë˜ëŠ” [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart)ë¡œ ì´ë™í•˜ì—¬ ë…¹ìƒ‰ \"Clone or download\" ë²„íŠ¼ì„ í´ë¦­í•œ ë‹¤ìŒ "
"\"Download ZIP\"ì„ í´ë¦­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr "ê·¸ëŸ° ë‹¤ìŒ "`git` ì‚¬ìš©í•˜ê¸°" ë²„ì „ì˜ ë‘ ë²ˆì§¸ ë¶€ë¶„ì—ì„œ ìˆ˜í–‰í•œ ëŒ€ë¡œ `Cargo.toml` íŒŒì¼ì˜ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì±„ìš°ì„¸ìš”."

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr "í”„ë¡œê·¸ë¨ ê°œìš”"

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr "í¸ì˜ë¥¼ ìœ„í•´ `src/main.rs`ì˜ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ì†Œê°œí•©ë‹ˆë‹¤:"

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr "// ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”\n"

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr "ì´ í”„ë¡œê·¸ë¨ì€ í‘œì¤€ Rust í”„ë¡œê·¸ë¨ê³¼ ì•½ê°„ ë‹¤ë¥´ë¯€ë¡œ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr "`#![no_std]`ëŠ” ì´ í”„ë¡œê·¸ë¨ì´ í‘œì¤€ í¬ë ˆì´íŠ¸ì¸ `std`ì— ë§í¬ë˜ì§€ ì•Šì„ ê²ƒì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ëŒ€ì‹  ê·¸ í•˜ìœ„ ì§‘í•©ì¸ `core` í¬ë ˆì´íŠ¸ì— ë§í¬ë  ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr "`#![no_main]`ì€ ì´ í”„ë¡œê·¸ë¨ì´ ëŒ€ë¶€ë¶„ì˜ Rust í”„ë¡œê·¸ë¨ì´ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²ƒì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. `no_main`ì„ ì‚¬ìš©í•˜ëŠ” ì£¼ëœ ì´ìœ ëŠ” `no_std` ì»¨í…ìŠ¤íŠ¸ì—ì„œ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ nightlyê°€ í•„ìš”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr "`use panic_halt as _;`. ì´ í¬ë ˆì´íŠ¸ëŠ” í”„ë¡œê·¸ë¨ì˜ íŒ¨ë‹‰ ë™ì‘ì„ ì •ì˜í•˜ëŠ” `panic_handler`ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” ì±…ì˜ [íŒ¨ë‹‰](panicking.md) ì¥ì—ì„œ ë” ìì„¸íˆ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr "[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html)ëŠ” í”„ë¡œê·¸ë¨ì˜ ì§„ì…ì ì„ í‘œì‹œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” [`cortex-m-rt`](https://crates.io/crates/cortex-m-rt) í¬ë ˆì´íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ì†ì„±ì…ë‹ˆë‹¤. í‘œì¤€ `main` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í”„ë¡œê·¸ë¨ì˜ ì§„ì…ì ì„ ë‚˜íƒ€ë‚´ëŠ” ë‹¤ë¥¸ ë°©ë²•ì´ í•„ìš”í•˜ë©°, ê·¸ê²ƒì´ `#[entry]`ì…ë‹ˆë‹¤."

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr "`fn main() -> !`. ìš°ë¦¬ í”„ë¡œê·¸ë¨ì€ ëŒ€ìƒ í•˜ë“œì›¨ì–´ì—ì„œ ì‹¤í–‰ë˜ëŠ” _ìœ ì¼í•œ_ í”„ë¡œì„¸ìŠ¤ì´ë¯€ë¡œ ì¢…ë£Œë˜ê¸°ë¥¼ ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤! ì»´íŒŒì¼ ì‹œì ì— ê·¸ë ‡ê²Œ ë  ê²ƒì„ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ [ë°œì‚° í•¨ìˆ˜](https://doc.rust-lang.org/rust-by-example/fn/diverging.html)(í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì˜ `-> !` ë¶€ë¶„)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "í¬ë¡œìŠ¤ ì»´íŒŒì¼"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the "
"`.cargo/config.toml` in the template has the answer:"
msgstr "ë‹¤ìŒ ë‹¨ê³„ëŠ” Cortex-M3 ì•„í‚¤í…ì²˜ìš© í”„ë¡œê·¸ë¨ì„ _í¬ë¡œìŠ¤_ ì»´íŒŒì¼í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì»´íŒŒì¼ ëŒ€ìƒ(`$TRIPLE`)ì´ ë¬´ì—‡ì¸ì§€ ì•ˆë‹¤ë©´ `cargo build --target $TRIPLE`ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒë§Œí¼ ê°„ë‹¨í•©ë‹ˆë‹¤. ë‹¤í–‰íˆ í…œí”Œë¦¿ì˜ `.cargo/config.toml`ì— ë‹µì´ ìˆìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr "Cortex-M3 ì•„í‚¤í…ì²˜ìš©ìœ¼ë¡œ í¬ë¡œìŠ¤ ì»´íŒŒì¼í•˜ë ¤ë©´ `thumbv7m-none-eabi`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ëŒ€ìƒì€ Rust íˆ´ì²´ì¸ì„ ì„¤ì¹˜í•  ë•Œ ìë™ìœ¼ë¡œ ì„¤ì¹˜ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì•„ì§ ì¶”ê°€í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì§€ê¸ˆ íˆ´ì²´ì¸ì— ì´ ëŒ€ìƒì„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤:"

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr "`.cargo/config.toml` íŒŒì¼ì— `thumbv7m-none-eabi` ì»´íŒŒì¼ ëŒ€ìƒì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì•„ë˜ ë‘ ëª…ë ¹ì€ ë™ì¼í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤:"

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr "ê²€ì‚¬"

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr "ì´ì œ `target/thumbv7m-none-eabihf/debug/app`ì— ë¹„ë„¤ì´í‹°ë¸Œ ELF ë°”ì´ë„ˆë¦¬ê°€ ìˆìŠµë‹ˆë‹¤. `cargo-binutils`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr "`cargo-readobj`ë¥¼ ì‚¬ìš©í•˜ì—¬ ELF í—¤ë”ë¥¼ ì¶œë ¥í•˜ì—¬ ì´ê²ƒì´ ARM ë°”ì´ë„ˆë¦¬ì„ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:183
msgid "Note that:"
msgstr "ì°¸ê³ :"

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr "`--bin app`ì€ `target/$TRIPLE/debug/app`ì˜ ë°”ì´ë„ˆë¦¬ë¥¼ ê²€ì‚¬í•˜ëŠ” ê°„í¸í•œ ë°©ë²•ì…ë‹ˆë‹¤."

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr "`--bin app`ì€ í•„ìš”í•œ ê²½ìš° ë°”ì´ë„ˆë¦¬ë¥¼ (ì¬)ì»´íŒŒì¼í•©ë‹ˆë‹¤."

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr "`cargo-size`ëŠ” ë°”ì´ë„ˆë¦¬ì˜ ë§ì»¤ ì„¹ì…˜ í¬ê¸°ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr "ìµœì í™”ëœ ë²„ì „ì„ ê²€ì‚¬í•˜ê¸° ìœ„í•´ `--release`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr "ELF ë§ì»¤ ì„¹ì…˜ì— ëŒ€í•œ ë³µìŠµ"

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr "`.text`ëŠ” í”„ë¡œê·¸ë¨ ëª…ë ¹ì–´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr "`.rodata`ëŠ” ë¬¸ìì—´ê³¼ ê°™ì€ ìƒìˆ˜ ê°’ì„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr "`.data`ëŠ” ì´ˆê¸° ê°’ì´ 0ì´ _ì•„ë‹Œ_ ì •ì ìœ¼ë¡œ í• ë‹¹ëœ ë³€ìˆ˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr "`.bss`ëŠ” ì´ˆê¸° ê°’ì´ 0ì¸ ì •ì ìœ¼ë¡œ í• ë‹¹ëœ ë³€ìˆ˜ë„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr "`.vector_table`ì€ ë²¡í„°(ì¸í„°ëŸ½íŠ¸) í…Œì´ë¸”ì„ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” _ë¹„_í‘œì¤€ ì„¹ì…˜ì…ë‹ˆë‹¤."

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr "`.ARM.attributes` ë° `.debug_*` ì„¹ì…˜ì€ ë©”íƒ€ë°ì´í„°ë¥¼ í¬í•¨í•˜ë©° ë°”ì´ë„ˆë¦¬ë¥¼ í”Œë˜ì‹±í•  ë•Œ ëŒ€ìƒì— ë¡œë“œë˜ì§€ _ì•ŠìŠµë‹ˆë‹¤_."

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr "**ì¤‘ìš”**: ELF íŒŒì¼ì€ ë””ë²„ê·¸ ì •ë³´ì™€ ê°™ì€ ë©”íƒ€ë°ì´í„°ë¥¼ í¬í•¨í•˜ë¯€ë¡œ ë””ìŠ¤í¬ìƒì˜ _í¬ê¸°_ëŠ” ì¥ì¹˜ì— í”Œë˜ì‹±ë  ë•Œ í”„ë¡œê·¸ë¨ì´ ì°¨ì§€í•  ê³µê°„ì„ ì •í™•í•˜ê²Œ ë°˜ì˜í•˜ì§€ _ì•ŠìŠµë‹ˆë‹¤_. ë°”ì´ë„ˆë¦¬ì˜ ì‹¤ì œ í¬ê¸°ë¥¼ í™•ì¸í•˜ë ¤ë©´ _í•­ìƒ_ `cargo-size`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr "`cargo-objdump`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°”ì´ë„ˆë¦¬ë¥¼ ì—­ì–´ì…ˆë¸”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr "**ì°¸ê³ ** ìœ„ ëª…ë ¹ì´ `Unknown command line argument`ì— ëŒ€í•´ ë¶ˆí‰í•˜ë©´ ë‹¤ìŒ ë²„ê·¸ ë³´ê³ ì„œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”: https://github.com/rust-embedded/book/issues/269"

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr "**ì°¸ê³ ** ì´ ì¶œë ¥ì€ ì‹œìŠ¤í…œì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. rustc, LLVM ë° ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ìƒˆ ë²„ì „ì€ ë‹¤ë¥¸ ì–´ì…ˆë¸”ë¦¬ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¤ë‹ˆí«ì„ ì‘ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ ì¼ë¶€ ëª…ë ¹ì–´ë¥¼ ì˜ë¼ëƒˆìŠµë‹ˆë‹¤."

#: src/start/qemu.md:311
msgid "Running"
msgstr ""

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr ""

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr ""

#: src/start/qemu.md:331 src/start/hardware.md:97 src/start/semihosting.md:26
msgid "\"Hello, world!\""
msgstr ""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr ""

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr ""

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr ""

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr ""

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/start/qemu.md:432 src/start/hardware.md:116
msgid "Debugging"
msgstr ""

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr ""

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr ""

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr ""

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr ""

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr ""

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr ""

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr ""

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr ""

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr ""

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr ""

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""

#: src/start/hardware.md:35
msgid "Configuring"
msgstr ""

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/"
"config.toml`."
msgstr ""

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr ""

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the "
"`memory.x` file."
msgstr ""

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of "
"`memory.x`."
msgstr ""

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""

#: src/start/hardware.md:99 src/unsorted/math.md:61
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr ""

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr ""

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr ""

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr ""

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""

#: src/start/registers.md:1
msgid "Memory Mapped Registers"
msgstr ""

#: src/start/registers.md:3
msgid ""
"Embedded systems can only get so far by executing normal Rust code and "
"moving data around in RAM. If we want to get any information into or out of "
"our system (be that blinking an LED, detecting a button press or "
"communicating with an off-chip peripheral on some sort of bus) we're going "
"to have to dip into the world of Peripherals and their 'memory mapped "
"registers'."
msgstr ""

#: src/start/registers.md:5
msgid ""
"You may well find that the code you need to access the peripherals in your "
"micro-controller has already been written, at one of the following levels:"
msgstr ""

#: src/start/registers.md:10
msgid ""
"Micro-architecture Crate - This sort of crate handles any useful routines "
"common to the processor core your microcontroller is using, as well as any "
"peripherals that are common to all micro-controllers that use that "
"particular type of processor core. For example the [cortex-m](https://"
"crates.io/crates/cortex-m) crate gives you functions to enable and disable "
"interrupts, which are the same for all Cortex-M based micro-controllers. It "
"also gives you access to the 'SysTick' peripheral included with all Cortex-M "
"based micro-controllers."
msgstr ""

#: src/start/registers.md:11
msgid ""
"Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over "
"the various memory-wrapper registers defined for your particular part-number "
"of micro-controller you are using. For example, [tm4c123x](https://crates.io/"
"crates/tm4c123x) for the Texas Instruments Tiva-C TM4C123 series, or "
"[stm32f30x](https://crates.io/crates/stm32f30x) for the ST-Micro STM32F30x "
"series. Here, you'll be interacting with the registers directly, following "
"each peripheral's operating instructions given in your micro-controller's "
"Technical Reference Manual."
msgstr ""

#: src/start/registers.md:12
msgid ""
"HAL Crate - These crates offer a more user-friendly API for your particular "
"processor, often by implementing some common traits defined in [embedded-hal]"
"(https://crates.io/crates/embedded-hal). For example, this crate might offer "
"a `Serial` struct, with a constructor that takes an appropriate set of GPIO "
"pins and a baud rate, and offers some sort of `write_byte` function for "
"sending data. See the chapter on [Portability](../portability/index.md) for "
"more information on [embedded-hal](https://crates.io/crates/embedded-hal)."
msgstr ""

#: src/start/registers.md:13
msgid ""
"Board Crate - These crates go one step further than a HAL Crate by pre-"
"configuring various peripherals and GPIO pins to suit the specific developer "
"kit or board you are using, such as [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) for the STM32F3DISCOVERY board."
msgstr ""

#: src/start/registers.md:23
msgid "Board Crate"
msgstr ""

#: src/start/registers.md:25
msgid ""
"A board crate is the perfect starting point, if you're new to embedded Rust. "
"They nicely abstract the HW details that might be overwhelming when starting "
"studying this subject, and makes standard tasks easy, like turning a LED on "
"or off. The functionality it exposes varies a lot between boards. Since this "
"book aims at staying hardware agnostic, the board crates won't be covered by "
"this book."
msgstr ""

#: src/start/registers.md:27
msgid ""
"If you want to experiment with the STM32F3DISCOVERY board, it is highly "
"recommended to take a look at the [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) board crate, which provides functionality to blink "
"the board LEDs, access its compass, bluetooth and more. The [Discovery]"
"(https://rust-embedded.github.io/discovery/) book offers a great "
"introduction to the use of a board crate."
msgstr ""

#: src/start/registers.md:29
msgid ""
"But if you're working on a system that doesn't yet have dedicated board "
"crate, or you need functionality not provided by existing crates, read on as "
"we start from the bottom, with the micro-architecture crates."
msgstr ""

#: src/start/registers.md:31
msgid "Micro-architecture crate"
msgstr ""

#: src/start/registers.md:33
msgid ""
"Let's look at the SysTick peripheral that's common to all Cortex-M based "
"micro-controllers. We can find a pretty low-level API in the [cortex-m]"
"(https://crates.io/crates/cortex-m) crate, and we can use it like this:"
msgstr ""

#: src/start/registers.md:51
msgid "// Loop\n"
msgstr ""

#: src/start/registers.md:57
msgid ""
"The functions on the `SYST` struct map pretty closely to the functionality "
"defined by the ARM Technical Reference Manual for this peripheral. There's "
"nothing in this API about 'delaying for X milliseconds' - we have to crudely "
"implement that ourselves using a `while` loop. Note that we can't access our "
"`SYST` struct until we have called `Peripherals::take()` - this is a special "
"routine that guarantees that there is only one `SYST` structure in our "
"entire program. For more on that, see the [Peripherals](../peripherals/"
"index.md) section."
msgstr ""

#: src/start/registers.md:61
msgid "Using a Peripheral Access Crate (PAC)"
msgstr ""

#: src/start/registers.md:63
msgid ""
"We won't get very far with our embedded software development if we restrict "
"ourselves to only the basic peripherals included with every Cortex-M. At "
"some point, we're going to need to write some code that's specific to the "
"particular micro-controller we're using. In this example, let's assume we "
"have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB "
"of Flash. We're going to pull in the [tm4c123x](https://crates.io/crates/"
"tm4c123x) crate to make use of this chip."
msgstr ""

#: src/start/registers.md:69 src/start/registers.md:145
msgid "// panic handler\n"
msgstr ""

#: src/start/registers.md:81
msgid "// Mode = 1 => Count up/down mode\n"
msgstr ""

#: src/start/registers.md:84
msgid ""
"// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)\n"
msgstr ""

#: src/start/registers.md:92
msgid ""
"We've accessed the `PWM0` peripheral in exactly the same way as we accessed "
"the `SYST` peripheral earlier, except we called "
"`tm4c123x::Peripherals::take()`. As this crate was auto-generated using "
"[svd2rust](https://crates.io/crates/svd2rust), the access functions for our "
"register fields take a closure, rather than a numeric argument. While this "
"looks like a lot of code, the Rust compiler can use it to perform a bunch of "
"checks for us, but then generate machine-code which is pretty close to hand-"
"written assembler! Where the auto-generated code isn't able to determine "
"that all possible arguments to a particular accessor function are valid (for "
"example, if the SVD defines the register as 32-bit but doesn't say if some "
"of those 32-bit values have a special meaning), then the function is marked "
"as `unsafe`. We can see this in the example above when setting the `load` "
"and `compa` sub-fields using the `bits()` function."
msgstr ""

#: src/start/registers.md:94
msgid "Reading"
msgstr ""

#: src/start/registers.md:96
msgid ""
"The `read()` function returns an object which gives read-only access to the "
"various sub-fields within this register, as defined by the manufacturer's "
"SVD file for this chip. You can find all the functions available on special "
"`R` return type for this particular register, in this particular peripheral, "
"on this particular chip, in the [tm4c123x documentation](https://docs.rs/"
"tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)."
msgstr ""

#: src/start/registers.md:100
msgid "// Do a thing\n"
msgstr ""

#: src/start/registers.md:104
msgid "Writing"
msgstr ""

#: src/start/registers.md:106
msgid ""
"The `write()` function takes a closure with a single argument. Typically we "
"call this `w`. This argument then gives read-write access to the various sub-"
"fields within this register, as defined by the manufacturer's SVD file for "
"this chip. Again, you can find all the functions available on the 'w' for "
"this particular register, in this particular peripheral, on this particular "
"chip, in the [tm4c123x documentation](https://docs.rs/tm4c123x/0.7.0/"
"tm4c123x/pwm0/ctl/struct.W.html). Note that all of the sub-fields that we do "
"not set will be set to a default value for us - any existing content in the "
"register will be lost."
msgstr ""

#: src/start/registers.md:112
msgid "Modifying"
msgstr ""

#: src/start/registers.md:114
msgid ""
"If we wish to change only one particular sub-field in this register and "
"leave the other sub-fields unchanged, we can use the `modify` function. This "
"function takes a closure with two arguments - one for reading and one for "
"writing. Typically we call these `r` and `w` respectively. The `r` argument "
"can be used to inspect the current contents of the register, and the `w` "
"argument can be used to modify the register contents."
msgstr ""

#: src/start/registers.md:120
msgid ""
"The `modify` function really shows the power of closures here. In C, we'd "
"have to read into some temporary value, modify the correct bits and then "
"write the value back. This means there's considerable scope for error:"
msgstr ""

#: src/start/registers.md:128
msgid "// Uh oh! Wrong variable!\n"
msgstr ""

#: src/start/registers.md:135
msgid "Using a HAL crate"
msgstr ""

#: src/start/registers.md:137
msgid ""
"The HAL crate for a chip typically works by implementing a custom Trait for "
"the raw structures exposed by the PAC. Often this trait will define a "
"function called `constrain()` for single peripherals or `split()` for things "
"like GPIO ports with multiple pins. This function will consume the "
"underlying raw peripheral structure and return a new object with a higher-"
"level API. This API may also do things like have the Serial port `new` "
"function require a borrow on some `Clock` structure, which can only be "
"generated by calling the function which configures the PLLs and sets up all "
"the clock frequencies. In this way, it is statically impossible to create a "
"Serial port object without first having configured the clock rates, or for "
"the Serial port object to misconvert the baud rate into clock ticks. Some "
"crates even define special traits for the states each GPIO pin can be in, "
"requiring the user to put a pin into the correct state (say, by selecting "
"the appropriate Alternate Function Mode) before passing the pin into "
"Peripheral. All with no run-time cost!"
msgstr ""

#: src/start/registers.md:139
msgid "Let's see an example:"
msgstr ""

#: src/start/registers.md:158
msgid "// Wrap up the SYSCTL struct into an object with a higher-layer API\n"
msgstr ""

#: src/start/registers.md:160
msgid "// Pick our oscillation settings\n"
msgstr ""

#: src/start/registers.md:165
msgid "// Configure the PLL with those settings\n"
msgstr ""

#: src/start/registers.md:168
msgid ""
"// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.\n"
"    // Note it needs to borrow `sc.power_control` so it can power up the "
"GPIO\n"
"    // peripheral automatically.\n"
msgstr ""

#: src/start/registers.md:173
msgid "// Activate the UART.\n"
msgstr ""

#: src/start/registers.md:176
msgid "// The transmit pin\n"
msgstr ""

#: src/start/registers.md:180
msgid "// The receive pin\n"
msgstr ""

#: src/start/registers.md:184
msgid "// No RTS or CTS required\n"
msgstr ""

#: src/start/registers.md:187
msgid "// The baud rate\n"
msgstr ""

#: src/start/registers.md:189
msgid "// Output handling\n"
msgstr ""

#: src/start/registers.md:191
msgid "// We need the clock rates to calculate the baud rate divisors\n"
msgstr ""

#: src/start/registers.md:193
msgid "// We need this to power up the UART peripheral\n"
msgstr ""

#: src/start/registers.md:198
msgid "\"Hello, World!\\r\\n\""
msgstr ""

#: src/start/semihosting.md:3
msgid ""
"Semihosting is a mechanism that lets embedded devices do I/O on the host and "
"is mainly used to log messages to the host console. Semihosting requires a "
"debug session and pretty much nothing else (no extra wires!) so it's super "
"convenient to use. The downside is that it's super slow: each write "
"operation can take several milliseconds depending on the hardware debugger "
"(e.g. ST-Link) you use."
msgstr ""

#: src/start/semihosting.md:9
msgid ""
"The [`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) "
"crate provides an API to do semihosting operations on Cortex-M devices. The "
"program below is the semihosting version of \"Hello, world!\":"
msgstr ""

#: src/start/semihosting.md:32
msgid ""
"If you run this program on hardware you'll see the \"Hello, world!\" message "
"within the OpenOCD logs."
msgstr ""

#: src/start/semihosting.md:42
msgid "You do need to enable semihosting in OpenOCD from GDB first:"
msgstr ""

#: src/start/semihosting.md:48
msgid ""
"QEMU understands semihosting operations so the above program will also work "
"with `qemu-system-arm` without having to start a debug session. Note that "
"you'll need to pass the `-semihosting-config` flag to QEMU to enable "
"semihosting support; these flags are already included in the `.cargo/"
"config.toml` file of the template."
msgstr ""

#: src/start/semihosting.md:61
msgid ""
"There's also an `exit` semihosting operation that can be used to terminate "
"the QEMU process. Important: do **not** use `debug::exit` on hardware; this "
"function can corrupt your OpenOCD session and you will not be able to debug "
"more programs until you restart it."
msgstr ""

#: src/start/semihosting.md:77 src/start/semihosting.md:115
msgid "\"blue\""
msgstr ""

#: src/start/semihosting.md:79 src/start/semihosting.md:117
msgid "\"red\""
msgstr ""

#: src/start/semihosting.md:97
msgid ""
"One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. "
"This will let you write `no_std` run-pass tests that you can run on QEMU."
msgstr ""

#: src/start/semihosting.md:100
msgid ""
"For convenience, the `panic-semihosting` crate has an \"exit\" feature that "
"when enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to "
"the host stderr."
msgstr ""

#: src/start/semihosting.md:108
msgid "// features = [\"exit\"]\n"
msgstr ""

#: src/start/semihosting.md:123
msgid ""
"```text\n"
"$ cargo run\n"
"     Running `qemu-system-arm (..)\n"
"panicked at 'assertion failed: `(left == right)`\n"
"  left: `\"blue\"`,\n"
" right: `\"red\"`', examples/hello.rs:15:5\n"
"\n"
"$ echo $?\n"
"1\n"
"```"
msgstr ""

#: src/start/semihosting.md:134
msgid ""
"**NOTE**: To enable this feature on `panic-semihosting`, edit your "
"`Cargo.toml` dependencies section where `panic-semihosting` is specified "
"with:"
msgstr ""

#: src/start/semihosting.md:137
msgid ""
"```toml\n"
"panic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n"
"```"
msgstr ""

#: src/start/semihosting.md:141
msgid ""
"where `VERSION` is the version desired. For more information on dependencies "
"features check the [`specifying dependencies`](https://doc.rust-lang.org/"
"cargo/reference/specifying-dependencies.html) section of the Cargo book."
msgstr ""

#: src/start/panicking.md:3
msgid ""
"Panicking is a core part of the Rust language. Built-in operations like "
"indexing are runtime checked for memory safety. When out of bounds indexing "
"is attempted this results in a panic."
msgstr ""

#: src/start/panicking.md:7
msgid ""
"In the standard library panicking has a defined behavior: it unwinds the "
"stack of the panicking thread, unless the user opted for aborting the "
"program on panics."
msgstr ""

#: src/start/panicking.md:11
msgid ""
"In programs without standard library, however, the panicking behavior is "
"left undefined. A behavior can be chosen by declaring a `#[panic_handler]` "
"function. This function must appear exactly _once_ in the dependency graph "
"of a program, and must have the following signature: `fn(&PanicInfo) -> !`, "
"where [`PanicInfo`](https://doc.rust-lang.org/core/panic/"
"struct.PanicInfo.html) is a struct containing information about the location "
"of the panic."
msgstr ""

#: src/start/panicking.md:19
msgid ""
"Given that embedded systems range from user facing to safety critical "
"(cannot crash) there's no one size fits all panicking behavior but there are "
"plenty of commonly used behaviors. These common behaviors have been packaged "
"into crates that define the `#[panic_handler]` function. Some examples "
"include:"
msgstr ""

#: src/start/panicking.md:24
msgid ""
"[`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the "
"abort instruction to be executed."
msgstr ""

#: src/start/panicking.md:25
msgid ""
"[`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the "
"program, or the current thread, to halt by entering an infinite loop."
msgstr ""

#: src/start/panicking.md:27
msgid ""
"[`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is "
"logged using the ITM, an ARM Cortex-M specific peripheral."
msgstr ""

#: src/start/panicking.md:29
msgid ""
"[`panic-semihosting`](https://crates.io/crates/panic-semihosting). The "
"panicking message is logged to the host using the semihosting technique."
msgstr ""

#: src/start/panicking.md:37
msgid ""
"You may be able to find even more crates searching for the [`panic-handler`]"
"(https://crates.io/keywords/panic-handler) keyword on crates.io."
msgstr ""

#: src/start/panicking.md:42
msgid ""
"A program can pick one of these behaviors simply by linking to the "
"corresponding crate. The fact that the panicking behavior is expressed in "
"the source of an application as a single line of code is not only useful as "
"documentation but can also be used to change the panicking behavior "
"according to the compilation profile. For example:"
msgstr ""

#: src/start/panicking.md:51
msgid ""
"// dev profile: easier to debug panics; can put a breakpoint on "
"`rust_begin_unwind`\n"
msgstr ""

#: src/start/panicking.md:55
msgid "// release profile: minimize the binary size of the application\n"
msgstr ""

#: src/start/panicking.md:59 src/start/exceptions.md:17
#: src/collections/index.md:132
msgid "// ..\n"
msgstr ""

#: src/start/panicking.md:63
msgid ""
"In this example the crate links to the `panic-halt` crate when built with "
"the dev profile (`cargo build`), but links to the `panic-abort` crate when "
"built with the release profile (`cargo build --release`)."
msgstr ""

#: src/start/panicking.md:67
msgid ""
"The `use panic_abort as _;` form of the `use` statement is used to ensure "
"the `panic_abort` panic handler is included in our final executable while "
"making it clear to the compiler that we won't explicitly use anything from "
"the crate. Without the `as _` rename, the compiler would warn that we have "
"an unused import. Sometimes you might see `extern crate panic_abort` "
"instead, which is an older style used before the 2018 edition of Rust, and "
"should now only be used for \"sysroot\" crates (those distributed with Rust "
"itself) such as `proc_macro`, `alloc`, `std`, and `test`."
msgstr ""

#: src/start/panicking.md:74
msgid "An example"
msgstr ""

#: src/start/panicking.md:76
msgid ""
"Here's an example that tries to index an array beyond its length. The "
"operation results in a panic."
msgstr ""

#: src/start/panicking.md:91
msgid "// out of bounds access\n"
msgstr ""

#: src/start/panicking.md:97
msgid ""
"This example chose the `panic-semihosting` behavior which prints the panic "
"message to the host console using semihosting."
msgstr ""

#: src/start/panicking.md:106
msgid ""
"You can try changing the behavior to `panic-halt` and confirm that no "
"message is printed in that case."
msgstr ""

#: src/start/exceptions.md:3
msgid ""
"Exceptions, and interrupts, are a hardware mechanism by which the processor "
"handles asynchronous events and fatal errors (e.g. executing an invalid "
"instruction). Exceptions imply preemption and involve exception handlers, "
"subroutines executed in response to the signal that triggered the event."
msgstr ""

#: src/start/exceptions.md:8
msgid ""
"The `cortex-m-rt` crate provides an [`exception`](https://docs.rs/cortex-m-"
"rt-macros/latest/cortex_m_rt_macros/attr.exception.html) attribute to "
"declare exception handlers."
msgstr ""

#: src/start/exceptions.md:14
msgid "// Exception handler for the SysTick (System Timer) exception\n"
msgstr ""

#: src/start/exceptions.md:21
msgid ""
"Other than the `exception` attribute exception handlers look like plain "
"functions but there's one more difference: `exception` handlers can _not_ be "
"called by software. Following the previous example, the statement "
"`SysTick();` would result in a compilation error."
msgstr ""

#: src/start/exceptions.md:26
msgid ""
"This behavior is pretty much intended and it's required to provide a "
"feature: `static mut` variables declared _inside_ `exception` handlers are "
"_safe_ to use."
msgstr ""

#: src/start/exceptions.md:34
msgid "// `COUNT` has transformed to type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/exceptions.md:39
msgid ""
"As you may know, using `static mut` variables in a function makes it [_non-"
"reentrant_](https://en.wikipedia.org/wiki/Reentrancy_(computing)). It's "
"undefined behavior to call a non-reentrant function, directly or indirectly, "
"from more than one exception / interrupt handler or from `main` and one or "
"more exception / interrupt handlers."
msgstr ""

#: src/start/exceptions.md:44
msgid ""
"Safe Rust must never result in undefined behavior so non-reentrant functions "
"must be marked as `unsafe`. Yet I just told that `exception` handlers can "
"safely use `static mut` variables. How is this possible? This is possible "
"because `exception` handlers can _not_ be called by software thus reentrancy "
"is not possible. These handlers are called by the hardware itself which is "
"assumed to be physically non-concurrent."
msgstr ""

#: src/start/exceptions.md:50
msgid ""
"As a result, in the context of exception handlers in embedded systems, the "
"absence of concurrent invocations of the same handler ensures that there are "
"no reentrancy issues, even if the handler uses static mutable variables."
msgstr ""

#: src/start/exceptions.md:52
msgid ""
"In a multicore system, where multiple processor cores are executing code "
"concurrently, the potential for reentrancy issues becomes relevant again, "
"even within exception handlers. While each core may have its own set of "
"exception handlers, there can still be scenarios where multiple cores "
"attempt to execute the same exception handler simultaneously.  \n"
"To address this concern in a multicore environment, proper synchronization "
"mechanisms need to be employed within the exception handlers to ensure that "
"access to shared resources is properly coordinated among the cores. This "
"typically involves the use of techniques such as locks, semaphores, or "
"atomic operations to prevent data races and maintain data integrity"
msgstr ""

#: src/start/exceptions.md:55
msgid ""
"Note that the `exception` attribute transforms definitions of static "
"variables inside the function by wrapping them into `unsafe` blocks and "
"providing us with new appropriate variables of type `&mut` of the same name. "
"Thus we can dereference the reference via `*` to access the values of the "
"variables without needing to wrap them in an `unsafe` block."
msgstr ""

#: src/start/exceptions.md:61
msgid "A complete example"
msgstr ""

#: src/start/exceptions.md:63
msgid ""
"Here's an example that uses the system timer to raise a `SysTick` exception "
"roughly every second. The `SysTick` exception handler keeps track of how "
"many times it has been called in the `COUNT` variable and then prints the "
"value of `COUNT` to the host console using semihosting."
msgstr ""

#: src/start/exceptions.md:68
msgid ""
"**NOTE**: You can run this example on any Cortex-M device; you can also run "
"it on QEMU"
msgstr ""

#: src/start/exceptions.md:92
msgid ""
"// configures the system timer to trigger a SysTick exception every second\n"
msgstr ""

#: src/start/exceptions.md:94
msgid ""
"// this is configured for the LM3S6965 which has a default CPU clock of 12 "
"MHz\n"
msgstr ""

#: src/start/exceptions.md:110
msgid "// Lazy initialization\n"
msgstr ""

#: src/start/exceptions.md:116
msgid "\"{}\""
msgstr ""

#: src/start/exceptions.md:119
msgid ""
"// IMPORTANT omit this `if` block if running on real hardware or your\n"
"    // debugger will end in an inconsistent state\n"
msgstr ""

#: src/start/exceptions.md:122
msgid "// This will terminate the QEMU process\n"
msgstr ""

#: src/start/exceptions.md:132
msgid ""
"```toml\n"
"[dependencies]\n"
"cortex-m = \"0.5.7\"\n"
"cortex-m-rt = \"0.6.3\"\n"
"panic-halt = \"0.2.0\"\n"
"cortex-m-semihosting = \"0.3.1\"\n"
"```"
msgstr ""

#: src/start/exceptions.md:146
msgid ""
"If you run this on the Discovery board you'll see the output on the OpenOCD "
"console. Also, the program will _not_ stop when the count reaches 9."
msgstr ""

#: src/start/exceptions.md:149
msgid "The default exception handler"
msgstr ""

#: src/start/exceptions.md:151
msgid ""
"What the `exception` attribute actually does is _override_ the default "
"exception handler for a specific exception. If you don't override the "
"handler for a particular exception it will be handled by the "
"`DefaultHandler` function, which defaults to:"
msgstr ""

#: src/start/exceptions.md:162
msgid ""
"This function is provided by the `cortex-m-rt` crate and marked as "
"`#[no_mangle]` so you can put a breakpoint on \"DefaultHandler\" and catch "
"_unhandled_ exceptions."
msgstr ""

#: src/start/exceptions.md:166
msgid ""
"It's possible to override this `DefaultHandler` using the `exception` "
"attribute:"
msgstr ""

#: src/start/exceptions.md:171
msgid "// custom default handler\n"
msgstr ""

#: src/start/exceptions.md:175
msgid ""
"The `irqn` argument indicates which exception is being serviced. A negative "
"value indicates that a Cortex-M exception is being serviced; and zero or a "
"positive value indicate that a device specific exception, AKA interrupt, is "
"being serviced."
msgstr ""

#: src/start/exceptions.md:180
msgid "The hard fault handler"
msgstr ""

#: src/start/exceptions.md:182
msgid ""
"The `HardFault` exception is a bit special. This exception is fired when the "
"program enters an invalid state so its handler can _not_ return as that "
"could result in undefined behavior. Also, the runtime crate does a bit of "
"work before the user defined `HardFault` handler is invoked to improve "
"debuggability."
msgstr ""

#: src/start/exceptions.md:187
msgid ""
"The result is that the `HardFault` handler must have the following "
"signature: `fn(&ExceptionFrame) -> !`. The argument of the handler is a "
"pointer to registers that were pushed into the stack by the exception. These "
"registers are a snapshot of the processor state at the moment the exception "
"was triggered and are useful to diagnose a hard fault."
msgstr ""

#: src/start/exceptions.md:193
msgid ""
"Here's an example that performs an illegal operation: a read to a "
"nonexistent memory location."
msgstr ""

#: src/start/exceptions.md:196
msgid ""
"**NOTE**: This program won't work, i.e. it won't crash, on QEMU because "
"`qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will "
"happily return `0 `on reads to invalid memory."
msgstr ""

#: src/start/exceptions.md:214
msgid "// read a nonexistent memory location\n"
msgstr ""

#: src/start/exceptions.md:225
#: src/static-guarantees/typestate-programming.md:48
msgid "\"{:#?}\""
msgstr ""

#: src/start/exceptions.md:232
msgid ""
"The `HardFault` handler prints the `ExceptionFrame` value. If you run this "
"you'll see something like this on the OpenOCD console."
msgstr ""

#: src/start/exceptions.md:250
msgid ""
"The `pc` value is the value of the Program Counter at the time of the "
"exception and it points to the instruction that triggered the exception."
msgstr ""

#: src/start/exceptions.md:253
msgid "If you look at the disassembly of the program:"
msgstr ""

#: src/start/exceptions.md:266
msgid ""
"You can lookup the value of the program counter `0x0800094a` in the "
"disassembly. You'll see that a load operation (`ldr r0, [r0]` ) caused the "
"exception. The `r0` field of `ExceptionFrame` will tell you the value of "
"register `r0` was `0x3fff_fffe` at that time."
msgstr ""

#: src/start/interrupts.md:3
msgid ""
"Interrupts differ from exceptions in a variety of ways but their operation "
"and use is largely similar and they are also handled by the same interrupt "
"controller. Whereas exceptions are defined by the Cortex-M architecture, "
"interrupts are always vendor (and often even chip) specific implementations, "
"both in naming and functionality."
msgstr ""

#: src/start/interrupts.md:9
msgid ""
"Interrupts do allow for a lot of flexibility which needs to be accounted for "
"when attempting to use them in an advanced way. We will not cover those uses "
"in this book, however it is a good idea to keep the following in mind:"
msgstr ""

#: src/start/interrupts.md:13
msgid ""
"Interrupts have programmable priorities which determine their handlers' "
"execution order"
msgstr ""

#: src/start/interrupts.md:14
msgid ""
"Interrupts can nest and preempt, i.e. execution of an interrupt handler "
"might be interrupted by another higher-priority interrupt"
msgstr ""

#: src/start/interrupts.md:15
msgid ""
"In general the reason causing the interrupt to trigger needs to be cleared "
"to prevent re-entering the interrupt handler endlessly"
msgstr ""

#: src/start/interrupts.md:17
msgid "The general initialization steps at runtime are always the same:"
msgstr ""

#: src/start/interrupts.md:18
msgid ""
"Setup the peripheral(s) to generate interrupts requests at the desired "
"occasions"
msgstr ""

#: src/start/interrupts.md:19
msgid ""
"Set the desired priority of the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:20
msgid "Enable the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:22
msgid ""
"Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`]"
"(https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/"
"attr.interrupt.html) attribute to declare interrupt handlers. The available "
"interrupts (and their position in the interrupt handler table) are usually "
"automatically generated via `svd2rust` from a SVD description."
msgstr ""

#: src/start/interrupts.md:30
msgid "// Interrupt handler for the Timer2 interrupt\n"
msgstr ""

#: src/start/interrupts.md:33
msgid ""
"// ..\n"
"    // Clear reason for the generated interrupt request\n"
msgstr ""

#: src/start/interrupts.md:38
msgid ""
"Interrupt handlers look like plain functions (except for the lack of "
"arguments) similar to exception handlers. However they can not be called "
"directly by other parts of the firmware due to the special calling "
"conventions. It is however possible to generate interrupt requests in "
"software to trigger a diversion to the interrupt handler."
msgstr ""

#: src/start/interrupts.md:44
msgid ""
"Similar to exception handlers it is also possible to declare `static mut` "
"variables inside the interrupt handlers for _safe_ state keeping."
msgstr ""

#: src/start/interrupts.md:52
msgid "// `COUNT` has type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/interrupts.md:57
msgid ""
"For a more detailed description about the mechanisms demonstrated here "
"please refer to the [exceptions section](./exceptions.md)."
msgstr ""

#: src/start/io.md:3
msgid "**TODO** Cover memory mapped I/O using registers."
msgstr ""

#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr ""

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr ""

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr ""

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr ""

#: src/peripherals/index.md:11
msgid "A processor"
msgstr ""

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr ""

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr ""

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr ""

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr ""

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr ""

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr ""

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr ""

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr ""

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr ""

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr ""

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr ""

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr ""

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr ""

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr ""

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr ""

#: src/peripherals/a-first-attempt.md:1
msgid "A First Attempt"
msgstr ""

#: src/peripherals/a-first-attempt.md:3
msgid "The Registers"
msgstr ""

#: src/peripherals/a-first-attempt.md:5
msgid ""
"Let's look at the 'SysTick' peripheral - a simple timer which comes with "
"every Cortex-M processor core. Typically you'll be looking these up in the "
"chip manufacturer's data sheet or _Technical Reference Manual_, but this "
"example is common to all ARM Cortex-M cores, let's look in the [ARM "
"reference manual](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/"
"Babieigh.html). We see there are four registers:"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Offset"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Name"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Width"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "0x00"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "SYST_CSR"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "Control and Status Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:11 src/peripherals/a-first-attempt.md:12
#: src/peripherals/a-first-attempt.md:13 src/peripherals/a-first-attempt.md:14
msgid "32 bits"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "0x04"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "SYST_RVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "Reload Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "0x08"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "SYST_CVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "Current Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "0x0C"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "SYST_CALIB"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "Calibration Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:16
msgid "The C Approach"
msgstr ""

#: src/peripherals/a-first-attempt.md:18
msgid ""
"In Rust, we can represent a collection of registers in exactly the same way "
"as we do in C - with a `struct`."
msgstr ""

#: src/peripherals/a-first-attempt.md:30
msgid ""
"The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out "
"like a C compiler would. That's very important, as Rust allows structure "
"fields to be re-ordered, while C does not. You can imagine the debugging "
"we'd have to do if these fields were silently re-arranged by the compiler! "
"With this qualifier in place, we have our four 32-bit fields which "
"correspond to the table above. But of course, this `struct` is of no use by "
"itself - we need a variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:37
msgid "Volatile Accesses"
msgstr ""

#: src/peripherals/a-first-attempt.md:39
msgid "Now, there are a couple of problems with the approach above."
msgstr ""

#: src/peripherals/a-first-attempt.md:41
msgid "We have to use unsafe every time we want to access our Peripheral."
msgstr ""

#: src/peripherals/a-first-attempt.md:42
msgid ""
"We've got no way of specifying which registers are read-only or read-write."
msgstr ""

#: src/peripherals/a-first-attempt.md:43
msgid ""
"Any piece of code anywhere in your program could access the hardware through "
"this structure."
msgstr ""

#: src/peripherals/a-first-attempt.md:45
msgid "Most importantly, it doesn't actually work..."
msgstr ""

#: src/peripherals/a-first-attempt.md:47
msgid ""
"Now, the problem is that compilers are clever. If you make two writes to the "
"same piece of RAM, one after the other, the compiler can notice this and "
"just skip the first write entirely. In C, we can mark variables as "
"`volatile` to ensure that every read or write occurs as intended. In Rust, "
"we instead mark the _accesses_ as volatile, not the variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:54
msgid ""
"So, we've fixed one of our four problems, but now we have even more `unsafe` "
"code! Fortunately, there's a third party crate which can help - "
"[`volatile_register`](https://crates.io/crates/volatile_register)."
msgstr ""

#: src/peripherals/a-first-attempt.md:79
msgid ""
"Now, the volatile accesses are performed automatically through the `read` "
"and `write` methods. It's still `unsafe` to perform writes, but to be fair, "
"hardware is a bunch of mutable state and there's no way for the compiler to "
"know whether these writes are actually safe, so this is a good default "
"position."
msgstr ""

#: src/peripherals/a-first-attempt.md:81
msgid "The Rusty Wrapper"
msgstr ""

#: src/peripherals/a-first-attempt.md:83
msgid ""
"We need to wrap this `struct` up into a higher-layer API that is safe for "
"our users to call. As the driver author, we manually verify the unsafe code "
"is correct, and then present a safe API for our users so they don't have to "
"worry about it (provided they trust us to get it right!)."
msgstr ""

#: src/peripherals/a-first-attempt.md:85
msgid "One example might be:"
msgstr ""

#: src/peripherals/a-first-attempt.md:121
msgid "\"Time is now 0x{:08x}\""
msgstr ""

#: src/peripherals/a-first-attempt.md:125
msgid ""
"Now, the problem with this approach is that the following code is perfectly "
"acceptable to the compiler:"
msgstr ""

#: src/peripherals/a-first-attempt.md:139
msgid ""
"Our `&mut self` argument to the `set_reload` function checks that there are "
"no other references to _that_ particular `SystemTimer` struct, but they "
"don't stop the user creating a second `SystemTimer` which points to the "
"exact same peripheral! Code written in this fashion will work if the author "
"is diligent enough to spot all of these 'duplicate' driver instances, but "
"once the code is spread out over multiple modules, drivers, developers, and "
"days, it gets easier and easier to make these kinds of mistakes."
msgstr ""

#: src/peripherals/borrowck.md:1
msgid "Mutable Global State"
msgstr ""

#: src/peripherals/borrowck.md:3
msgid ""
"Unfortunately, hardware is basically nothing but mutable global state, which "
"can feel very frightening for a Rust developer. Hardware exists "
"independently from the structures of the code we write, and can be modified "
"at any time by the real world."
msgstr ""

#: src/peripherals/borrowck.md:5
msgid "What should our rules be?"
msgstr ""

#: src/peripherals/borrowck.md:7
msgid "How can we reliably interact with these peripherals?"
msgstr ""

#: src/peripherals/borrowck.md:9
msgid ""
"Always use `volatile` methods to read or write to peripheral memory, as it "
"can change at any time"
msgstr ""

#: src/peripherals/borrowck.md:10
msgid ""
"In software, we should be able to share any number of read-only accesses to "
"these peripherals"
msgstr ""

#: src/peripherals/borrowck.md:11
msgid ""
"If some software should have read-write access to a peripheral, it should "
"hold the only reference to that peripheral"
msgstr ""

#: src/peripherals/borrowck.md:15
msgid ""
"The last two of these rules sound suspiciously similar to what the Borrow "
"Checker does already!"
msgstr ""

#: src/peripherals/borrowck.md:17
msgid ""
"Imagine if we could pass around ownership of these peripherals, or offer "
"immutable or mutable references to them?"
msgstr ""

#: src/peripherals/borrowck.md:19
msgid ""
"Well, we can, but for the Borrow Checker, we need to have exactly one "
"instance of each peripheral, so Rust can handle this correctly. Well, "
"luckily in the hardware, there is only one instance of any given peripheral, "
"but how can we expose that in the structure of our code?"
msgstr ""

#: src/peripherals/singletons.md:3
msgid ""
"In software engineering, the singleton pattern is a software design pattern "
"that restricts the instantiation of a class to one object."
msgstr ""

#: src/peripherals/singletons.md:5
msgid ""
"_Wikipedia: [Singleton Pattern](https://en.wikipedia.org/wiki/"
"Singleton_pattern)_"
msgstr ""

#: src/peripherals/singletons.md:10
msgid "But why can't we just use global variable(s)?"
msgstr ""

#: src/peripherals/singletons.md:12
msgid "We could make everything a public static, like this"
msgstr ""

#: src/peripherals/singletons.md:24
msgid ""
"But this has a few problems. It is a mutable global variable, and in Rust, "
"these are always unsafe to interact with. These variables are also visible "
"across your whole program, which means the borrow checker is unable to help "
"you track references and ownership of these variables."
msgstr ""

#: src/peripherals/singletons.md:26
msgid "How do we do this in Rust?"
msgstr ""

#: src/peripherals/singletons.md:28
msgid ""
"Instead of just making our peripheral a global variable, we might instead "
"decide to make a structure, in this case called `PERIPHERALS`, which "
"contains an `Option<T>` for each of our peripherals."
msgstr ""

#: src/peripherals/singletons.md:45
msgid ""
"This structure allows us to obtain a single instance of our peripheral. If "
"we try to call `take_serial()` more than once, our code will panic!"
msgstr ""

#: src/peripherals/singletons.md:50
msgid ""
"// This panics!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"
msgstr ""

#: src/peripherals/singletons.md:55
msgid ""
"Although interacting with this structure is `unsafe`, once we have the "
"`SerialPort` it contained, we no longer need to use `unsafe`, or the "
"`PERIPHERALS` structure at all."
msgstr ""

#: src/peripherals/singletons.md:57
msgid ""
"This has a small runtime overhead because we must wrap the `SerialPort` "
"structure in an option, and we'll need to call `take_serial()` once, however "
"this small up-front cost allows us to leverage the borrow checker throughout "
"the rest of our program."
msgstr ""

#: src/peripherals/singletons.md:59
msgid "Existing library support"
msgstr ""

#: src/peripherals/singletons.md:61
msgid ""
"Although we created our own `Peripherals` structure above, it is not "
"necessary to do this for your code. the `cortex_m` crate contains a macro "
"called `singleton!()` that will perform this action for you."
msgstr ""

#: src/peripherals/singletons.md:67
msgid "// OK if `main` is executed only once\n"
msgstr ""

#: src/peripherals/singletons.md:73
msgid ""
"[cortex_m docs](https://docs.rs/cortex-m/latest/cortex_m/"
"macro.singleton.html)"
msgstr ""

#: src/peripherals/singletons.md:75
msgid ""
"Additionally, if you use [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-"
"m-rtic), the entire process of defining and obtaining these peripherals are "
"abstracted for you, and you are instead handed a `Peripherals` structure "
"that contains a non-`Option<T>` version of all of the items you define."
msgstr ""

#: src/peripherals/singletons.md:78
msgid "// cortex-m-rtic v0.5.x\n"
msgstr ""

#: src/peripherals/singletons.md:85
msgid "// Cortex-M peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:88
msgid "// Device specific peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:94
msgid "But why?"
msgstr ""

#: src/peripherals/singletons.md:96
msgid ""
"But how do these Singletons make a noticeable difference in how our Rust "
"code works?"
msgstr ""

#: src/peripherals/singletons.md:103
msgid "// <------ This is really, really important\n"
msgstr ""

#: src/peripherals/singletons.md:112
msgid "There are two important factors in play here:"
msgstr ""

#: src/peripherals/singletons.md:114
msgid ""
"Because we are using a singleton, there is only one way or place to obtain a "
"`SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:115
msgid ""
"To call the `read_speed()` method, we must have ownership or a reference to "
"a `SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:117
msgid ""
"These two factors put together means that it is only possible to access the "
"hardware if we have appropriately satisfied the borrow checker, meaning that "
"at no point do we have multiple mutable references to the same hardware!"
msgstr ""

#: src/peripherals/singletons.md:121
msgid ""
"// missing reference to `self`! Won't work.\n"
"    // SerialPort::read_speed();\n"
msgstr ""

#: src/peripherals/singletons.md:126
msgid "// you can only read what you have access to\n"
msgstr ""

#: src/peripherals/singletons.md:131
msgid "Treat your hardware like data"
msgstr ""

#: src/peripherals/singletons.md:133
msgid ""
"Additionally, because some references are mutable, and some are immutable, "
"it becomes possible to see whether a function or method could potentially "
"modify the state of the hardware. For example,"
msgstr ""

#: src/peripherals/singletons.md:135
msgid "This is allowed to change hardware settings:"
msgstr ""

#: src/peripherals/singletons.md:142 src/peripherals/singletons.md:150
#: src/design-patterns/hal/gpio.md:17 src/design-patterns/hal/gpio.md:27
#: src/design-patterns/hal/gpio.md:35 src/design-patterns/hal/gpio.md:138
msgid "// ...\n"
msgstr ""

#: src/peripherals/singletons.md:146
msgid "This isn't:"
msgstr ""

#: src/peripherals/singletons.md:154
msgid ""
"This allows us to enforce whether code should or should not make changes to "
"hardware at **compile time**, rather than at runtime. As a note, this "
"generally only works across one application, but for bare metal systems, our "
"software will be compiled into a single application, so this is not usually "
"a restriction."
msgstr ""

#: src/static-guarantees/index.md:3
msgid ""
"Rust's type system prevents data races at compile time (see [`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) and [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) traits). The type system can also be "
"used to check other properties at compile time; reducing the need for "
"runtime checks in some cases."
msgstr ""

#: src/static-guarantees/index.md:10
msgid ""
"When applied to embedded programs these _static checks_ can be used, for "
"example, to enforce that configuration of I/O interfaces is done properly. "
"For instance, one can design an API where it is only possible to initialize "
"a serial interface by first configuring the pins that will be used by the "
"interface."
msgstr ""

#: src/static-guarantees/index.md:15
msgid ""
"One can also statically check that operations, like setting a pin low, can "
"only be performed on correctly configured peripherals. For example, trying "
"to change the output state of a pin configured in floating input mode would "
"raise a compile error."
msgstr ""

#: src/static-guarantees/index.md:20
msgid ""
"And, as seen in the previous chapter, the concept of ownership can be "
"applied to peripherals to ensure that only certain parts of a program can "
"modify a peripheral. This _access control_ makes software easier to reason "
"about compared to the alternative of treating peripherals as global mutable "
"state."
msgstr ""

#: src/static-guarantees/typestate-programming.md:3
msgid ""
"The concept of [typestates](https://en.wikipedia.org/wiki/"
"Typestate_analysis) describes the encoding of information about the current "
"state of an object into the type of that object. Although this can sound a "
"little arcane, if you have used the [Builder Pattern](https://doc.rust-"
"lang.org/1.0.0/style/ownership/builders.html) in Rust, you have already "
"started using Typestate Programming!"
msgstr ""

#: src/static-guarantees/typestate-programming.md:52
msgid ""
"In this example, there is no direct way to create a `Foo` object. We must "
"create a `FooBuilder`, and properly initialize it before we can obtain the "
"`Foo` object we want."
msgstr ""

#: src/static-guarantees/typestate-programming.md:54
msgid "This minimal example encodes two states:"
msgstr ""

#: src/static-guarantees/typestate-programming.md:56
msgid ""
"`FooBuilder`, which represents an \"unconfigured\", or \"configuration in "
"process\" state"
msgstr ""

#: src/static-guarantees/typestate-programming.md:57
msgid "`Foo`, which represents a \"configured\", or \"ready to use\" state."
msgstr ""

#: src/static-guarantees/typestate-programming.md:59
msgid "Strong Types"
msgstr ""

#: src/static-guarantees/typestate-programming.md:61
msgid ""
"Because Rust has a [Strong Type System](https://en.wikipedia.org/wiki/"
"Strong_and_weak_typing), there is no easy way to magically create an "
"instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling "
"the `into_foo()` method. Additionally, calling the `into_foo()` method "
"consumes the original `FooBuilder` structure, meaning it can not be reused "
"without the creation of a new instance."
msgstr ""

#: src/static-guarantees/typestate-programming.md:65
msgid ""
"This allows us to represent the states of our system as types, and to "
"include the necessary actions for state transitions into the methods that "
"exchange one type for another. By creating a `FooBuilder`, and exchanging it "
"for a `Foo` object, we have walked through the steps of a basic state "
"machine."
msgstr ""

#: src/static-guarantees/state-machines.md:3
msgid ""
"The peripherals of a microcontroller can be thought of as set of state "
"machines. For example, the configuration of a simplified [GPIO pin](https://"
"en.wikipedia.org/wiki/General-purpose_input/output) could be represented as "
"the following tree of states:"
msgstr ""

#: src/static-guarantees/state-machines.md:7
#: src/static-guarantees/state-machines.md:19
msgid "Disabled"
msgstr ""

#: src/static-guarantees/state-machines.md:8
#: src/static-guarantees/state-machines.md:20
msgid "Enabled"
msgstr ""

#: src/static-guarantees/state-machines.md:9
#: src/static-guarantees/state-machines.md:33
msgid "Configured as Output"
msgstr ""

#: src/static-guarantees/state-machines.md:10
#: src/static-guarantees/state-machines.md:34
msgid "Output: High"
msgstr ""

#: src/static-guarantees/state-machines.md:11
msgid "Output: Low"
msgstr ""

#: src/static-guarantees/state-machines.md:12
#: src/static-guarantees/state-machines.md:21
#: src/static-guarantees/state-machines.md:32
msgid "Configured as Input"
msgstr ""

#: src/static-guarantees/state-machines.md:13
#: src/static-guarantees/state-machines.md:22
#: src/static-guarantees/state-machines.md:26
msgid "Input: High Resistance"
msgstr ""

#: src/static-guarantees/state-machines.md:14
#: src/static-guarantees/state-machines.md:27
#: src/static-guarantees/state-machines.md:31
msgid "Input: Pulled Low"
msgstr ""

#: src/static-guarantees/state-machines.md:15
msgid "Input: Pulled High"
msgstr ""

#: src/static-guarantees/state-machines.md:17
msgid ""
"If the peripheral starts in the `Disabled` mode, to move to the `Input: High "
"Resistance` mode, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:24
msgid ""
"If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, "
"we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:29
msgid ""
"Similarly, if we want to move a GPIO pin from configured as `Input: Pulled "
"Low` to `Output: High`, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:36
msgid "Hardware Representation"
msgstr ""

#: src/static-guarantees/state-machines.md:38
msgid ""
"Typically the states listed above are set by writing values to given "
"registers mapped to a GPIO peripheral. Let's define an imaginary GPIO "
"Configuration Register to illustrate this:"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Bit Number(s)"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Value"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Meaning"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Notes"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "enable"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:7
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:15
msgid "0"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "disabled"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "Disables the GPIO"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:8
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:10
#: src/static-guarantees/design-contracts.md:16
msgid "1"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "enabled"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "Enables the GPIO"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "direction"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "input"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "Sets the direction to Input"
msgstr ""

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "output"
msgstr ""

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "Sets the direction to Output"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "input_mode"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "2..3"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "00"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "hi-z"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "Sets the input as high resistance"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "01"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "pull-low"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "Input pin is pulled low"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "10"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "pull-high"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "Input pin is pulled high"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "11"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "n/a"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "Invalid state. Do not set"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "output_mode"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "4"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "set-low"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "Output pin is driven low"
msgstr ""

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "set-high"
msgstr ""

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "Output pin is driven high"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "input_status"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "5"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "x"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "in-val"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "0 if input is \\< 1.5v, 1 if input >= 1.5v"
msgstr ""

#: src/static-guarantees/state-machines.md:54
msgid "We _could_ expose the following structure in Rust to control this GPIO:"
msgstr ""

#: src/static-guarantees/state-machines.md:57
#: src/static-guarantees/design-contracts.md:22
#: src/static-guarantees/design-contracts.md:107
msgid "/// GPIO interface\n"
msgstr ""

#: src/static-guarantees/state-machines.md:59
#: src/static-guarantees/design-contracts.md:24
#: src/static-guarantees/design-contracts.md:109
msgid "/// GPIO Configuration structure generated by svd2rust\n"
msgstr ""

#: src/static-guarantees/state-machines.md:94
msgid ""
"However, this would allow us to modify certain registers that do not make "
"sense. For example, what happens if we set the `output_mode` field when our "
"GPIO is configured as an input?"
msgstr ""

#: src/static-guarantees/state-machines.md:96
msgid ""
"In general, use of this structure would allow us to reach states not defined "
"by our state machine above: e.g. an output that is pulled low, or an input "
"that is set high. For some hardware, this may not matter. On other hardware, "
"it could cause unexpected or undefined behavior!"
msgstr ""

#: src/static-guarantees/state-machines.md:98
msgid ""
"Although this interface is convenient to write, it doesn't enforce the "
"design contracts set out by our hardware implementation."
msgstr ""

#: src/static-guarantees/design-contracts.md:3
msgid ""
"In our last chapter, we wrote an interface that _didn't_ enforce design "
"contracts. Let's take another look at our imaginary GPIO configuration "
"register:"
msgstr ""

#: src/static-guarantees/design-contracts.md:19
msgid ""
"If we instead checked the state before making use of the underlying "
"hardware, enforcing our design contracts at runtime, we might write code "
"that looks like this instead:"
msgstr ""

#: src/static-guarantees/design-contracts.md:37
msgid "// Must be enabled to set direction\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:50
msgid "// Must be enabled to set input mode\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:55
#: src/static-guarantees/design-contracts.md:91
msgid "// Direction must be input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:68
msgid "// Must be enabled to set output status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:73
msgid "// Direction must be output\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:86
msgid "// Must be enabled to get status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:100
msgid ""
"Because we need to enforce the restrictions on the hardware, we end up doing "
"a lot of runtime checking which wastes time and resources, and this code "
"will be much less pleasant for the developer to use."
msgstr ""

#: src/static-guarantees/design-contracts.md:102
msgid "Type States"
msgstr ""

#: src/static-guarantees/design-contracts.md:104
msgid ""
"But what if instead, we used Rust's type system to enforce the state "
"transition rules? Take this example:"
msgstr ""

#: src/static-guarantees/design-contracts.md:115
msgid "// Type states for MODE in GpioConfig\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:125
msgid "/// These functions may be used on any GPIO Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:166
msgid "/// This function may be used on an Output Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:173
msgid "/// These methods may be used on any enabled input GPIO\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:212
msgid "Now let's see what the code using this would look like:"
msgstr ""

#: src/static-guarantees/design-contracts.md:215
msgid ""
"/*\n"
" * Example 1: Unconfigured to High-Z input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:219
msgid ""
"// Can't do this, pin isn't enabled!\n"
"// pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:222
msgid "// Now turn the pin from unconfigured to a high-z input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:225
msgid "// Read from the pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:228
msgid ""
"// Can't do this, input pins don't have this interface!\n"
"// input_pin.set_bit(true);\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:231
msgid ""
"/*\n"
" * Example 2: High-Z input to Pulled Low input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:237
msgid ""
"/*\n"
" * Example 3: Pulled Low input to Output, set high\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:243
msgid ""
"// Can't do this, output pins don't have this interface!\n"
"// output_pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:248
msgid ""
"This is definitely a convenient way to store the state of the pin, but why "
"do it this way? Why is this better than storing the state as an `enum` "
"inside of our `GpioConfig` structure?"
msgstr ""

#: src/static-guarantees/design-contracts.md:250
msgid "Compile Time Functional Safety"
msgstr ""

#: src/static-guarantees/design-contracts.md:252
msgid ""
"Because we are enforcing our design constraints entirely at compile time, "
"this incurs no runtime cost. It is impossible to set an output mode when you "
"have a pin in an input mode. Instead, you must walk through the states by "
"converting it to an output pin, and then setting the output mode. Because of "
"this, there is no runtime penalty due to checking the current state before "
"executing a function."
msgstr ""

#: src/static-guarantees/design-contracts.md:254
msgid ""
"Also, because these states are enforced by the type system, there is no "
"longer room for errors by consumers of this interface. If they try to "
"perform an illegal state transition, the code will not compile!"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:3
msgid ""
"Type states are also an excellent example of Zero Cost Abstractions - the "
"ability to move certain behaviors to compile time execution or analysis. "
"These type states contain no actual data, and are instead used as markers. "
"Since they contain no data, they have no actual representation in memory at "
"runtime:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:8
#: src/static-guarantees/zero-cost-abstractions.md:9
#: src/static-guarantees/zero-cost-abstractions.md:10
#: src/static-guarantees/zero-cost-abstractions.md:11
msgid "// == 0\n"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:14
msgid "Zero Sized Types"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:20
msgid ""
"Structures defined like this are called Zero Sized Types, as they contain no "
"actual data. Although these types act \"real\" at compile time - you can "
"copy them, move them, take references to them, etc., however the optimizer "
"will completely strip them away."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:22
msgid "In this snippet of code:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:36
msgid ""
"The GpioConfig we return never exists at runtime. Calling this function will "
"generally boil down to a single assembly instruction - storing a constant "
"register value to a register location. This means that the type state "
"interface we've developed is a zero cost abstraction - it uses no more CPU, "
"RAM, or code space tracking the state of `GpioConfig`, and renders to the "
"same machine code as a direct register access."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:38
msgid "Nesting"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:40
msgid ""
"In general, these abstractions may be nested as deeply as you would like. As "
"long as all components used are zero sized types, the whole structure will "
"not exist at runtime."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:42
msgid ""
"For complex or deeply nested structures, it may be tedious to define all "
"possible combinations of state. In these cases, macros may be used to "
"generate all implementations."
msgstr ""

#: src/portability/index.md:3
msgid ""
"In embedded environments portability is a very important topic: Every vendor "
"and even each family from a single manufacturer offers different peripherals "
"and capabilities and similarly the ways to interact with the peripherals "
"will vary."
msgstr ""

#: src/portability/index.md:5
msgid ""
"A common way to equalize such differences is via a layer called Hardware "
"Abstraction layer or **HAL**."
msgstr ""

#: src/portability/index.md:7
msgid ""
"Hardware abstractions are sets of routines in software that emulate some "
"platform-specific details, giving programs direct access to the hardware "
"resources."
msgstr ""

#: src/portability/index.md:9
msgid ""
"They often allow programmers to write device-independent, high performance "
"applications by providing standard operating system (OS) calls to hardware."
msgstr ""

#: src/portability/index.md:11
msgid ""
"_Wikipedia: [Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"
msgstr ""

#: src/portability/index.md:15
msgid ""
"Embedded systems are a bit special in this regard since we typically do not "
"have operating systems and user installable software but firmware images "
"which are compiled as a whole as well as a number of other constraints. So "
"while the traditional approach as defined by Wikipedia could potentially "
"work it is likely not the most productive approach to ensure portability."
msgstr ""

#: src/portability/index.md:17
msgid "How do we do this in Rust? Enter **embedded-hal**..."
msgstr ""

#: src/portability/index.md:19
msgid "What is embedded-hal?"
msgstr ""

#: src/portability/index.md:21
msgid ""
"In a nutshell it is a set of traits which define implementation contracts "
"between **HAL implementations**, **drivers** and **applications (or "
"firmwares)**. Those contracts include both capabilities (i.e. if a trait is "
"implemented for a certain type, the **HAL implementation** provides a "
"certain capability) and methods (i.e. if you can construct a type "
"implementing a trait it is guaranteed that you have the methods specified in "
"the trait available)."
msgstr ""

#: src/portability/index.md:23
msgid "A typical layering might look like this:"
msgstr ""

#: src/portability/index.md:25
msgid "![](../assets/rust_layers.svg)"
msgstr ""

#: src/portability/index.md:27
msgid "Some of the defined traits in **embedded-hal** are:"
msgstr ""

#: src/portability/index.md:28
msgid "GPIO (input and output pins)"
msgstr ""

#: src/portability/index.md:29
msgid "Serial communication"
msgstr ""

#: src/portability/index.md:30 src/appendix/glossary.md:26
msgid "I2C"
msgstr ""

#: src/portability/index.md:31 src/appendix/glossary.md:42
msgid "SPI"
msgstr ""

#: src/portability/index.md:32
msgid "Timers/Countdowns"
msgstr ""

#: src/portability/index.md:33
msgid "Analog Digital Conversion"
msgstr ""

#: src/portability/index.md:35
msgid ""
"The main reason for having the **embedded-hal** traits and crates "
"implementing and using them is to keep complexity in check. If you consider "
"that an application might have to implement the use of the peripheral in the "
"hardware as well as the application and potentially drivers for additional "
"hardware components, then it should be easy to see that the re-usability is "
"very limited. Expressed mathematically, if **M** is the number of peripheral "
"HAL implementations and **N** the number of drivers then if we were to "
"reinvent the wheel for every application then we would end up with **M\\*N** "
"implementations while by using the _API_ provided by the **embedded-hal** "
"traits will make the implementation complexity approach **M+N**. Of course "
"there're additional benefits to be had, such as less trial-and-error due to "
"a well-defined and ready-to-use APIs."
msgstr ""

#: src/portability/index.md:37
msgid "Users of the embedded-hal"
msgstr ""

#: src/portability/index.md:39
msgid "As said above there are three main users of the HAL:"
msgstr ""

#: src/portability/index.md:41
msgid "HAL implementation"
msgstr ""

#: src/portability/index.md:43
msgid ""
"A HAL implementation provides the interfacing between the hardware and the "
"users of the HAL traits. Typical implementations consist of three parts:"
msgstr ""

#: src/portability/index.md:44
msgid "One or more hardware specific types"
msgstr ""

#: src/portability/index.md:45
msgid ""
"Functions to create and initialize such a type, often providing various "
"configuration options (speed, operation mode, use pins, etc.)"
msgstr ""

#: src/portability/index.md:46
msgid "one or more `trait` `impl` of **embedded-hal** traits for that type"
msgstr ""

#: src/portability/index.md:48
msgid "Such a **HAL implementation** can come in various flavours:"
msgstr ""

#: src/portability/index.md:49
msgid "Via low-level hardware access, e.g. via registers"
msgstr ""

#: src/portability/index.md:50
msgid "Via operating system, e.g. by using the `sysfs` under Linux"
msgstr ""

#: src/portability/index.md:51
msgid "Via adapter, e.g. a mock of types for unit testing"
msgstr ""

#: src/portability/index.md:52
msgid "Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander"
msgstr ""

#: src/portability/index.md:54
msgid "Driver"
msgstr ""

#: src/portability/index.md:56
msgid ""
"A driver implements a set of custom functionality for an internal or "
"external component, connected to a peripheral implementing the embedded-hal "
"traits. Typical examples for such drivers include various sensors "
"(temperature, magnetometer, accelerometer, light), display devices (LED "
"arrays, LCD displays) and actuators (motors, transmitters)."
msgstr ""

#: src/portability/index.md:58
msgid ""
"A driver has to be initialized with an instance of type that implements a "
"certain `trait` of the embedded-hal which is ensured via trait bound and "
"provides its own type instance with a custom set of methods allowing to "
"interact with the driven device."
msgstr ""

#: src/portability/index.md:60
msgid "Application"
msgstr ""

#: src/portability/index.md:62
msgid ""
"The application binds the various parts together and ensures that the "
"desired functionality is achieved. When porting between different systems, "
"this is the part which requires the most adaptation efforts, since the "
"application needs to correctly initialize the real hardware via the HAL "
"implementation and the initialisation of different hardware differs, "
"sometimes drastically so. Also the user choice often plays a big role, since "
"components can be physically connected to different terminals, hardware "
"buses sometimes need external hardware to match the configuration or there "
"are different trade-offs to be made in the use of internal peripherals (e.g. "
"multiple timers with different capabilities are available or peripherals "
"conflict with others)."
msgstr ""

#: src/concurrency/index.md:3
msgid ""
"Concurrency happens whenever different parts of your program might execute "
"at different times or out of order. In an embedded context, this includes:"
msgstr ""

#: src/concurrency/index.md:6
msgid ""
"interrupt handlers, which run whenever the associated interrupt happens,"
msgstr ""

#: src/concurrency/index.md:7
msgid ""
"various forms of multithreading, where your microprocessor regularly swaps "
"between parts of your program,"
msgstr ""

#: src/concurrency/index.md:9
msgid ""
"and in some systems, multiple-core microprocessors, where each core can be "
"independently running a different part of your program at the same time."
msgstr ""

#: src/concurrency/index.md:12
msgid ""
"Since many embedded programs need to deal with interrupts, concurrency will "
"usually come up sooner or later, and it's also where many subtle and "
"difficult bugs can occur. Luckily, Rust provides a number of abstractions "
"and safety guarantees to help us write correct code."
msgstr ""

#: src/concurrency/index.md:17
msgid "No Concurrency"
msgstr ""

#: src/concurrency/index.md:19
msgid ""
"The simplest concurrency for an embedded program is no concurrency: your "
"software consists of a single main loop which just keeps running, and there "
"are no interrupts at all. Sometimes this is perfectly suited to the problem "
"at hand! Typically your loop will read some inputs, perform some processing, "
"and write some outputs."
msgstr ""

#: src/concurrency/index.md:37
msgid ""
"Since there's no concurrency, there's no need to worry about sharing data "
"between parts of your program or synchronising access to peripherals. If you "
"can get away with such a simple approach this can be a great solution."
msgstr ""

#: src/concurrency/index.md:41
msgid "Global Mutable Data"
msgstr ""

#: src/concurrency/index.md:43
msgid ""
"Unlike non-embedded Rust, we will not usually have the luxury of creating "
"heap allocations and passing references to that data into a newly-created "
"thread. Instead, our interrupt handlers might be called at any time and must "
"know how to access whatever shared memory we are using. At the lowest level, "
"this means we must have _statically allocated_ mutable memory, which both "
"the interrupt handler and the main code can refer to."
msgstr ""

#: src/concurrency/index.md:50
msgid ""
"In Rust, such [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) variables are "
"always unsafe to read or write, because without taking special care, you "
"might trigger a race condition, where your access to the variable is "
"interrupted halfway through by an interrupt which also accesses that "
"variable."
msgstr ""

#: src/concurrency/index.md:57
msgid ""
"For an example of how this behaviour can cause subtle errors in your code, "
"consider an embedded program which counts rising edges of some input signal "
"in each one-second period (a frequency counter):"
msgstr ""

#: src/concurrency/index.md:71
msgid "// DANGER - Not actually safe! Could cause data races.\n"
msgstr ""

#: src/concurrency/index.md:84
msgid ""
"Each second, the timer interrupt sets the counter back to 0. Meanwhile, the "
"main loop continually measures the signal, and incremements the counter when "
"it sees a change from low to high. We've had to use `unsafe` to access "
"`COUNTER`, as it's `static mut`, and that means we're promising the compiler "
"we won't cause any undefined behaviour. Can you spot the race condition? The "
"increment on `COUNTER` is _not_ guaranteed to be atomic â€” in fact, on most "
"embedded platforms, it will be split into a load, then the increment, then a "
"store. If the interrupt fired after the load but before the store, the reset "
"back to 0 would be ignored after the interrupt returns â€” and we would count "
"twice as many transitions for that period."
msgstr ""

#: src/concurrency/index.md:95
msgid "Critical Sections"
msgstr ""

#: src/concurrency/index.md:97
msgid ""
"So, what can we do about data races? A simple approach is to use _critical "
"sections_, a context where interrupts are disabled. By wrapping the access "
"to `COUNTER` in `main` in a critical section, we can be sure the timer "
"interrupt will not fire until we're finished incrementing `COUNTER`:"
msgstr ""

#: src/concurrency/index.md:112
msgid "// New critical section ensures synchronised access to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:127
msgid ""
"In this example, we use `cortex_m::interrupt::free`, but other platforms "
"will have similar mechanisms for executing code in a critical section. This "
"is also the same as disabling interrupts, running some code, and then re-"
"enabling interrupts."
msgstr ""

#: src/concurrency/index.md:132
msgid ""
"Note we didn't need to put a critical section inside the timer interrupt, "
"for two reasons:"
msgstr ""

#: src/concurrency/index.md:135
msgid ""
"Writing 0 to `COUNTER` can't be affected by a race since we don't read it"
msgstr ""

#: src/concurrency/index.md:136
msgid "It will never be interrupted by the `main` thread anyway"
msgstr ""

#: src/concurrency/index.md:138
msgid ""
"If `COUNTER` was being shared by multiple interrupt handlers that might "
"_preempt_ each other, then each one might require a critical section as well."
msgstr ""

#: src/concurrency/index.md:141
msgid ""
"This solves our immediate problem, but we're still left writing a lot of "
"unsafe code which we need to carefully reason about, and we might be using "
"critical sections needlessly. Since each critical section temporarily pauses "
"interrupt processing, there is an associated cost of some extra code size "
"and higher interrupt latency and jitter (interrupts may take longer to be "
"processed, and the time until they are processed will be more variable). "
"Whether this is a problem depends on your system, but in general, we'd like "
"to avoid it."
msgstr ""

#: src/concurrency/index.md:143
msgid ""
"It's worth noting that while a critical section guarantees no interrupts "
"will fire, it does not provide an exclusivity guarantee on multi-core "
"systems!  The other core could be happily accessing the same memory as your "
"core, even without interrupts. You will need stronger synchronisation "
"primitives if you are using multiple cores."
msgstr ""

#: src/concurrency/index.md:149
msgid "Atomic Access"
msgstr ""

#: src/concurrency/index.md:151
msgid ""
"On some platforms, special atomic instructions are available, which provide "
"guarantees about read-modify-write operations. Specifically for Cortex-M: "
"`thumbv6` (Cortex-M0, Cortex-M0+) only provide atomic load and store "
"instructions, while `thumbv7` (Cortex-M3 and above) provide full Compare and "
"Swap (CAS) instructions. These CAS instructions give an alternative to the "
"heavy-handed disabling of all interrupts: we can attempt the increment, it "
"will succeed most of the time, but if it was interrupted it will "
"automatically retry the entire increment operation. These atomic operations "
"are safe even across multiple cores."
msgstr ""

#: src/concurrency/index.md:173
msgid "// Use `fetch_add` to atomically add 1 to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:182
msgid "// Use `store` to write 0 directly to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:187
msgid ""
"This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize` "
"type `COUNTER` can be safely modified from both the interrupt handler and "
"the main thread without disabling interrupts. When possible, this is a "
"better solution â€” but it may not be supported on your platform."
msgstr ""

#: src/concurrency/index.md:192
msgid ""
"A note on [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/"
"enum.Ordering.html): this affects how the compiler and hardware may reorder "
"instructions, and also has consequences on cache visibility. Assuming that "
"the target is a single core platform `Relaxed` is sufficient and the most "
"efficient choice in this particular case. Stricter ordering will cause the "
"compiler to emit memory barriers around the atomic operations; depending on "
"what you're using atomics for you may or may not need this! The precise "
"details of the atomic model are complicated and best described elsewhere."
msgstr ""

#: src/concurrency/index.md:200
msgid ""
"For more details on atomics and ordering, see the [nomicon](https://doc.rust-"
"lang.org/nomicon/atomics.html)."
msgstr ""

#: src/concurrency/index.md:206
msgid "Abstractions, Send, and Sync"
msgstr ""

#: src/concurrency/index.md:208
msgid ""
"None of the above solutions are especially satisfactory. They require "
"`unsafe` blocks which must be very carefully checked and are not ergonomic. "
"Surely we can do better in Rust!"
msgstr ""

#: src/concurrency/index.md:212
msgid ""
"We can abstract our counter into a safe interface which can be safely used "
"anywhere else in our code. For this example, we'll use the critical-section "
"counter, but you could do something very similar with atomics."
msgstr ""

#: src/concurrency/index.md:219
msgid ""
"// Our counter is just a wrapper around UnsafeCell<u32>, which is the heart\n"
"// of interior mutability in Rust. By using interior mutability, we can "
"have\n"
"// COUNTER be `static` instead of `static mut`, but still able to mutate\n"
"// its counter value.\n"
msgstr ""

#: src/concurrency/index.md:230
msgid ""
"// By requiring a CriticalSection be passed in, we know we must\n"
"        // be operating inside a CriticalSection, and so can confidently\n"
"        // use this unsafe block (required to call UnsafeCell::get).\n"
msgstr ""

#: src/concurrency/index.md:240
msgid "// Required to allow static CSCounter. See explanation below.\n"
msgstr ""

#: src/concurrency/index.md:243
msgid ""
"// COUNTER is no longer `mut` as it uses interior mutability;\n"
"// therefore it also no longer requires unsafe blocks to access.\n"
msgstr ""

#: src/concurrency/index.md:255
msgid "// No unsafe here!\n"
msgstr ""

#: src/concurrency/index.md:264
msgid ""
"// We do need to enter a critical section here just to obtain a valid\n"
"    // cs token, even though we know no other interrupt could pre-empt\n"
"    // this one.\n"
msgstr ""

#: src/concurrency/index.md:269
msgid ""
"// We could use unsafe code to generate a fake CriticalSection if we\n"
"    // really wanted to, avoiding the overhead:\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"
msgstr ""

#: src/concurrency/index.md:275
msgid ""
"We've moved our `unsafe` code to inside our carefully-planned abstraction, "
"and now our application code does not contain any `unsafe` blocks."
msgstr ""

#: src/concurrency/index.md:278
msgid ""
"This design requires that the application pass a `CriticalSection` token in: "
"these tokens are only safely generated by `interrupt::free`, so by requiring "
"one be passed in, we ensure we are operating inside a critical section, "
"without having to actually do the lock ourselves. This guarantee is provided "
"statically by the compiler: there won't be any runtime overhead associated "
"with `cs`. If we had multiple counters, they could all be given the same "
"`cs`, without requiring multiple nested critical sections."
msgstr ""

#: src/concurrency/index.md:286
msgid ""
"This also brings up an important topic for concurrency in Rust: the [`Send` "
"and `Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) traits. To "
"summarise the Rust book, a type is Send when it can safely be moved to "
"another thread, while it is Sync when it can be safely shared between "
"multiple threads. In an embedded context, we consider interrupts to be "
"executing in a separate thread to the application code, so variables "
"accessed by both an interrupt and the main code must be Sync."
msgstr ""

#: src/concurrency/index.md:296
msgid ""
"For most types in Rust, both of these traits are automatically derived for "
"you by the compiler. However, because `CSCounter` contains an [`UnsafeCell`]"
"(https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html), it is not "
"Sync, and therefore we could not make a `static CSCounter`: `static` "
"variables _must_ be Sync, since they can be accessed by multiple threads."
msgstr ""

#: src/concurrency/index.md:303
msgid ""
"To tell the compiler we have taken care that the `CSCounter` is in fact safe "
"to share between threads, we implement the Sync trait explicitly. As with "
"the previous use of critical sections, this is only safe on single-core "
"platforms: with multiple cores, you would need to go to greater lengths to "
"ensure safety."
msgstr ""

#: src/concurrency/index.md:308
msgid "Mutexes"
msgstr ""

#: src/concurrency/index.md:310
msgid ""
"We've created a useful abstraction specific to our counter problem, but "
"there are many common abstractions used for concurrency."
msgstr ""

#: src/concurrency/index.md:313
msgid ""
"One such _synchronisation primitive_ is a mutex, short for mutual exclusion. "
"These constructs ensure exclusive access to a variable, such as our counter. "
"A thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds "
"immediately, or blocks waiting for the lock to be acquired, or returns an "
"error that the mutex could not be locked. While that thread holds the lock, "
"it is granted access to the protected data. When the thread is done, it "
"_unlocks_ (or _releases_) the mutex, allowing another thread to lock it. In "
"Rust, we would usually implement the unlock using the [`Drop`](https://"
"doc.rust-lang.org/core/ops/trait.Drop.html) trait to ensure it is always "
"released when the mutex goes out of scope."
msgstr ""

#: src/concurrency/index.md:325
msgid ""
"Using a mutex with interrupt handlers can be tricky: it is not normally "
"acceptable for the interrupt handler to block, and it would be especially "
"disastrous for it to block waiting for the main thread to release a lock, "
"since we would then _deadlock_ (the main thread will never release the lock "
"because execution stays in the interrupt handler). Deadlocking is not "
"considered unsafe: it is possible even in safe Rust."
msgstr ""

#: src/concurrency/index.md:332
msgid ""
"To avoid this behaviour entirely, we could implement a mutex which requires "
"a critical section to lock, just like our counter example. So long as the "
"critical section must last as long as the lock, we can be sure we have "
"exclusive access to the wrapped variable without even needing to track the "
"lock/unlock state of the mutex."
msgstr ""

#: src/concurrency/index.md:338
msgid ""
"This is in fact done for us in the `cortex_m` crate! We could have written "
"our counter using it:"
msgstr ""

#: src/concurrency/index.md:363
msgid ""
"// We still need to enter a critical section here to satisfy the Mutex.\n"
msgstr ""

#: src/concurrency/index.md:368
msgid ""
"We're now using [`Cell`](https://doc.rust-lang.org/core/cell/"
"struct.Cell.html), which along with its sibling `RefCell` is used to provide "
"safe interior mutability. We've already seen `UnsafeCell` which is the "
"bottom layer of interior mutability in Rust: it allows you to obtain "
"multiple mutable references to its value, but only with unsafe code. A "
"`Cell` is like an `UnsafeCell` but it provides a safe interface: it only "
"permits taking a copy of the current value or replacing it, not taking a "
"reference, and since it is not Sync, it cannot be shared between threads. "
"These constraints mean it's safe to use, but we couldn't use it directly in "
"a `static` variable as a `static` must be Sync."
msgstr ""

#: src/concurrency/index.md:380
msgid ""
"So why does the example above work? The `Mutex<T>` implements Sync for any "
"`T` which is Send â€” such as a `Cell`. It can do this safely because it only "
"gives access to its contents during a critical section. We're therefore able "
"to get a safe counter with no unsafe code at all!"
msgstr ""

#: src/concurrency/index.md:385
msgid ""
"This is great for simple types like the `u32` of our counter, but what about "
"more complex types which are not Copy? An extremely common example in an "
"embedded context is a peripheral struct, which generally is not Copy. For "
"that, we can turn to `RefCell`."
msgstr ""

#: src/concurrency/index.md:390
msgid "Sharing Peripherals"
msgstr ""

#: src/concurrency/index.md:392
msgid ""
"Device crates generated using `svd2rust` and similar abstractions provide "
"safe access to peripherals by enforcing that only one instance of the "
"peripheral struct can exist at a time. This ensures safety, but makes it "
"difficult to access a peripheral from both the main thread and an interrupt "
"handler."
msgstr ""

#: src/concurrency/index.md:398
msgid ""
"To safely share peripheral access, we can use the `Mutex` we saw before. "
"We'll also need to use [`RefCell`](https://doc.rust-lang.org/core/cell/"
"struct.RefCell.html), which uses a runtime check to ensure only one "
"reference to a peripheral is given out at a time. This has more overhead "
"than the plain `Cell`, but since we are giving out references rather than "
"copies, we must be sure only one exists at a time."
msgstr ""

#: src/concurrency/index.md:406
msgid ""
"Finally, we'll also have to account for somehow moving the peripheral into "
"the shared variable after it has been initialised in the main code. To do "
"this we can use the `Option` type, initialised to `None` and later set to "
"the instance of the peripheral."
msgstr ""

#: src/concurrency/index.md:421
msgid ""
"// Obtain the peripheral singletons and configure it.\n"
"    // This example is from an svd2rust-generated crate, but\n"
"    // most embedded device crates will be similar.\n"
msgstr ""

#: src/concurrency/index.md:427
msgid ""
"// Some sort of configuration function.\n"
"    // Assume it sets PA0 to an input and PA1 to an output.\n"
msgstr ""

#: src/concurrency/index.md:431
msgid "// Store the GPIOA in the mutex, moving it.\n"
msgstr ""

#: src/concurrency/index.md:433
msgid ""
"// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to\n"
"    // access it via the mutex.\n"
msgstr ""

#: src/concurrency/index.md:436
msgid ""
"// Be careful to enable the interrupt only after setting MY_GPIO:\n"
"    // otherwise the interrupt might fire while it still contains None,\n"
"    // and as-written (with `unwrap()`), it would panic.\n"
msgstr ""

#: src/concurrency/index.md:442
msgid "// We'll now read state as a digital input, via the mutex\n"
msgstr ""

#: src/concurrency/index.md:449
msgid "// Set PA1 high if we've seen a rising edge on PA0.\n"
msgstr ""

#: src/concurrency/index.md:461
msgid "// This time in the interrupt we'll just clear PA0.\n"
msgstr ""

#: src/concurrency/index.md:463
msgid ""
"// We can use `unwrap()` because we know the interrupt wasn't enabled\n"
"        // until after MY_GPIO was set; otherwise we should handle the "
"potential\n"
"        // for a None value.\n"
msgstr ""

#: src/concurrency/index.md:472
msgid "That's quite a lot to take in, so let's break down the important lines."
msgstr ""

#: src/concurrency/index.md:479
msgid ""
"Our shared variable is now a `Mutex` around a `RefCell` which contains an "
"`Option`. The `Mutex` ensures we only have access during a critical section, "
"and therefore makes the variable Sync, even though a plain `RefCell` would "
"not be Sync. The `RefCell` gives us interior mutability with references, "
"which we'll need to use our `GPIOA`. The `Option` lets us initialise this "
"variable to something empty, and only later actually move the variable in. "
"We cannot access the peripheral singleton statically, only at runtime, so "
"this is required."
msgstr ""

#: src/concurrency/index.md:492
msgid ""
"Inside a critical section we can call `borrow()` on the mutex, which gives "
"us a reference to the `RefCell`. We then call `replace()` to move our new "
"value into the `RefCell`."
msgstr ""

#: src/concurrency/index.md:503
msgid ""
"Finally, we use `MY_GPIO` in a safe and concurrent fashion. The critical "
"section prevents the interrupt firing as usual, and lets us borrow the "
"mutex.  The `RefCell` then gives us an `&Option<GPIOA>`, and tracks how long "
"it remains borrowed - once that reference goes out of scope, the `RefCell` "
"will be updated to indicate it is no longer borrowed."
msgstr ""

#: src/concurrency/index.md:509
msgid ""
"Since we can't move the `GPIOA` out of the `&Option`, we need to convert it "
"to an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to "
"obtain the `&GPIOA` which lets us modify the peripheral."
msgstr ""

#: src/concurrency/index.md:513
msgid ""
"If we need a mutable reference to a shared resource, then `borrow_mut` and "
"`deref_mut` should be used instead. The following code shows an example "
"using the TIM2 timer."
msgstr ""

#: src/concurrency/index.md:531
msgid ""
"// Some sort of timer configuration function.\n"
"    // Assume it configures the TIM2 timer, its NVIC interrupt,\n"
"    // and finally starts the timer.\n"
msgstr ""

#: src/concurrency/index.md:556
msgid ""
"Whew! This is safe, but it is also a little unwieldy. Is there anything else "
"we can do?"
msgstr ""

#: src/concurrency/index.md:559
msgid "RTIC"
msgstr ""

#: src/concurrency/index.md:561
msgid ""
"One alternative is the [RTIC framework](https://github.com/rtic-rs/cortex-m-"
"rtic), short for Real Time Interrupt-driven Concurrency. It enforces static "
"priorities and tracks accesses to `static mut` variables (\"resources\") to "
"statically ensure that shared resources are always accessed safely, without "
"requiring the overhead of always entering critical sections and using "
"reference counting (as in `RefCell`). This has a number of advantages such "
"as guaranteeing no deadlocks and giving extremely low time and memory "
"overhead."
msgstr ""

#: src/concurrency/index.md:570
msgid ""
"The framework also includes other features like message passing, which "
"reduces the need for explicit shared state, and the ability to schedule "
"tasks to run at a given time, which can be used to implement periodic tasks. "
"Check out [the documentation](https://rtic.rs) for more information!"
msgstr ""

#: src/concurrency/index.md:577
msgid "Real Time Operating Systems"
msgstr ""

#: src/concurrency/index.md:579
msgid ""
"Another common model for embedded concurrency is the real-time operating "
"system (RTOS). While currently less well explored in Rust, they are widely "
"used in traditional embedded development. Open source examples include "
"[FreeRTOS](https://freertos.org/) and [ChibiOS](http://chibios.org/). These "
"RTOSs provide support for running multiple application threads which the CPU "
"swaps between, either when the threads yield control (called cooperative "
"multitasking) or based on a regular timer or interrupts (preemptive "
"multitasking). The RTOS typically provide mutexes and other synchronisation "
"primitives, and often interoperate with hardware features such as DMA "
"engines."
msgstr ""

#: src/concurrency/index.md:591
msgid ""
"At the time of writing, there are not many Rust RTOS examples to point to, "
"but it's an interesting area so watch this space!"
msgstr ""

#: src/concurrency/index.md:594
msgid "Multiple Cores"
msgstr ""

#: src/concurrency/index.md:596
msgid ""
"It is becoming more common to have two or more cores in embedded processors, "
"which adds an extra layer of complexity to concurrency. All the examples "
"using a critical section (including the `cortex_m::interrupt::Mutex`) assume "
"the only other execution thread is the interrupt thread, but on a multi-core "
"system that's no longer true. Instead, we'll need synchronisation primitives "
"designed for multiple cores (also called SMP, for symmetric multi-"
"processing)."
msgstr ""

#: src/concurrency/index.md:603
msgid ""
"These typically use the atomic instructions we saw earlier, since the "
"processing system will ensure that atomicity is maintained over all cores."
msgstr ""

#: src/concurrency/index.md:606
msgid ""
"Covering these topics in detail is currently beyond the scope of this book, "
"but the general patterns are the same as for the single-core case."
msgstr ""

#: src/collections/index.md:3
msgid ""
"Eventually you'll want to use dynamic data structures (AKA collections) in "
"your program. `std` provides a set of common collections: [`Vec`](https://"
"doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html), etc. All the collections "
"implemented in `std` use a global dynamic memory allocator (AKA the heap)."
msgstr ""

#: src/collections/index.md:12
msgid ""
"As `core` is, by definition, free of memory allocations these "
"implementations are not available there, but they can be found in the "
"`alloc` crate that's shipped with the compiler."
msgstr ""

#: src/collections/index.md:16
msgid ""
"If you need collections, a heap allocated implementation is not your only "
"option. You can also use _fixed capacity_ collections; one such "
"implementation can be found in the [`heapless`](https://crates.io/crates/"
"heapless) crate."
msgstr ""

#: src/collections/index.md:22
msgid "In this section, we'll explore and compare these two implementations."
msgstr ""

#: src/collections/index.md:24
msgid "Using `alloc`"
msgstr ""

#: src/collections/index.md:26
msgid ""
"The `alloc` crate is shipped with the standard Rust distribution. To import "
"the crate you can directly `use` it _without_ declaring it as a dependency "
"in your `Cargo.toml` file."
msgstr ""

#: src/collections/index.md:38
msgid ""
"To be able to use any collection you'll first need use the "
"`global_allocator` attribute to declare the global allocator your program "
"will use. It's required that the allocator you select implements the "
"[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"trait."
msgstr ""

#: src/collections/index.md:44
msgid ""
"For completeness and to keep this section as self-contained as possible "
"we'll implement a simple bump pointer allocator and use that as the global "
"allocator. However, we _strongly_ suggest you use a battle tested allocator "
"from crates.io in your program instead of this allocator."
msgstr ""

#: src/collections/index.md:50
msgid "// Bump pointer allocator implementation\n"
msgstr ""

#: src/collections/index.md:57
msgid "// Bump pointer allocator for *single* core systems\n"
msgstr ""

#: src/collections/index.md:68
msgid ""
"// `interrupt::free` is a critical section that makes our allocator safe\n"
"        // to use from within interrupts\n"
msgstr ""

#: src/collections/index.md:76
msgid "// move start up to the next alignment boundary\n"
msgstr ""

#: src/collections/index.md:80
msgid "// a null pointer signal an Out Of Memory condition\n"
msgstr ""

#: src/collections/index.md:90
msgid "// this allocator never deallocates memory\n"
msgstr ""

#: src/collections/index.md:93
msgid ""
"// Declaration of the global memory allocator\n"
"// NOTE the user must ensure that the memory region `[0x2000_0100, "
"0x2000_0200]`\n"
"// is not used by other parts of the program\n"
msgstr ""

#: src/collections/index.md:104
msgid ""
"Apart from selecting a global allocator the user will also have to define "
"how Out Of Memory (OOM) errors are handled using the _unstable_ "
"`alloc_error_handler` attribute."
msgstr ""

#: src/collections/index.md:121
msgid ""
"Once all that is in place, the user can finally use the collections in "
"`alloc`."
msgstr ""

#: src/collections/index.md:137
msgid ""
"If you have used the collections in the `std` crate then these will be "
"familiar as they are exact same implementation."
msgstr ""

#: src/collections/index.md:140
msgid "Using `heapless`"
msgstr ""

#: src/collections/index.md:142
msgid ""
"`heapless` requires no setup as its collections don't depend on a global "
"memory allocator. Just `use` its collections and proceed to instantiate them:"
msgstr ""

#: src/collections/index.md:146
msgid "// heapless version: v0.4.x\n"
msgstr ""

#: src/collections/index.md:160
msgid ""
"You'll note two differences between these collections and the ones in "
"`alloc`."
msgstr ""

#: src/collections/index.md:162
msgid ""
"First, you have to declare upfront the capacity of the collection. "
"`heapless` collections never reallocate and have fixed capacities; this "
"capacity is part of the type signature of the collection. In this case we "
"have declared that `xs` has a capacity of 8 elements that is the vector can, "
"at most, hold 8 elements. This is indicated by the `U8` (see [`typenum`]"
"(https://crates.io/crates/typenum)) in the type signature."
msgstr ""

#: src/collections/index.md:170
msgid ""
"Second, the `push` method, and many other methods, return a `Result`. Since "
"the `heapless` collections have fixed capacity all operations that insert "
"elements into the collection can potentially fail. The API reflects this "
"problem by returning a `Result` indicating whether the operation succeeded "
"or not. In contrast, `alloc` collections will reallocate themselves on the "
"heap to increase their capacity."
msgstr ""

#: src/collections/index.md:177
msgid ""
"As of version v0.4.x all `heapless` collections store all their elements "
"inline. This means that an operation like `let x = heapless::Vec::new();` "
"will allocate the collection on the stack, but it's also possible to "
"allocate the collection on a `static` variable, or even on the heap "
"(`Box<Vec<_, _>>`)."
msgstr ""

#: src/collections/index.md:182
msgid "Trade-offs"
msgstr ""

#: src/collections/index.md:184
msgid ""
"Keep these in mind when choosing between heap allocated, relocatable "
"collections and fixed capacity collections."
msgstr ""

#: src/collections/index.md:187
msgid "Out Of Memory and error handling"
msgstr ""

#: src/collections/index.md:189
msgid ""
"With heap allocations Out Of Memory is always a possibility and can occur in "
"any place where a collection may need to grow: for example, all "
"`alloc::Vec.push` invocations can potentially generate an OOM condition. "
"Thus some operations can _implicitly_ fail. Some `alloc` collections expose "
"`try_reserve` methods that let you check for potential OOM conditions when "
"growing the collection but you need be proactive about using them."
msgstr ""

#: src/collections/index.md:196
msgid ""
"If you exclusively use `heapless` collections and you don't use a memory "
"allocator for anything else then an OOM condition is impossible. Instead, "
"you'll have to deal with collections running out of capacity on a case by "
"case basis. That is you'll have deal with _all_ the `Result`s returned by "
"methods like `Vec.push`."
msgstr ""

#: src/collections/index.md:202
msgid ""
"OOM failures can be harder to debug than say `unwrap`\\-ing on all `Result`s "
"returned by `heapless::Vec.push` because the observed location of failure "
"may _not_ match with the location of the cause of the problem. For example, "
"even `vec.reserve(1)` can trigger an OOM if the allocator is nearly "
"exhausted because some other collection was leaking memory (memory leaks are "
"possible in safe Rust)."
msgstr ""

#: src/collections/index.md:209
msgid "Memory usage"
msgstr ""

#: src/collections/index.md:211
msgid ""
"Reasoning about memory usage of heap allocated collections is hard because "
"the capacity of long lived collections can change at runtime. Some "
"operations may implicitly reallocate the collection increasing its memory "
"usage, and some collections expose methods like `shrink_to_fit` that can "
"potentially reduce the memory used by the collection -- ultimately, it's up "
"to the allocator to decide whether to actually shrink the memory allocation "
"or not. Additionally, the allocator may have to deal with memory "
"fragmentation which can increase the _apparent_ memory usage."
msgstr ""

#: src/collections/index.md:220
msgid ""
"On the other hand if you exclusively use fixed capacity collections, store "
"most of them in `static` variables and set a maximum size for the call stack "
"then the linker will detect if you try to use more memory than what's "
"physically available."
msgstr ""

#: src/collections/index.md:225
msgid ""
"Furthermore, fixed capacity collections allocated on the stack will be "
"reported by [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) flag which means that tools that "
"analyze stack usage (like [`stack-sizes`](https://crates.io/crates/stack-"
"sizes)) will include them in their analysis."
msgstr ""

#: src/collections/index.md:232
msgid ""
"However, fixed capacity collections can _not_ be shrunk which can result in "
"lower load factors (the ratio between the size of the collection and its "
"capacity) than what relocatable collections can achieve."
msgstr ""

#: src/collections/index.md:236
msgid "Worst Case Execution Time (WCET)"
msgstr ""

#: src/collections/index.md:238
msgid ""
"If you are building time sensitive applications or hard real time "
"applications then you care, maybe a lot, about the worst case execution time "
"of the different parts of your program."
msgstr ""

#: src/collections/index.md:242
msgid ""
"The `alloc` collections can reallocate so the WCET of operations that may "
"grow the collection will also include the time it takes to reallocate the "
"collection, which itself depends on the _runtime_ capacity of the "
"collection. This makes it hard to determine the WCET of, for example, the "
"`alloc::Vec.push` operation as it depends on both the allocator being used "
"and its runtime capacity."
msgstr ""

#: src/collections/index.md:248
msgid ""
"On the other hand fixed capacity collections never reallocate so all "
"operations have a predictable execution time. For example, "
"`heapless::Vec.push` executes in constant time."
msgstr ""

#: src/collections/index.md:252
msgid "Ease of use"
msgstr ""

#: src/collections/index.md:254
msgid ""
"`alloc` requires setting up a global allocator whereas `heapless` does not. "
"However, `heapless` requires you to pick the capacity of each collection "
"that you instantiate."
msgstr ""

#: src/collections/index.md:258
msgid ""
"The `alloc` API will be familiar to virtually every Rust developer. The "
"`heapless` API tries to closely mimic the `alloc` API but it will never be "
"exactly the same due to its explicit error handling -- some developers may "
"feel the explicit error handling is excessive or too cumbersome."
msgstr ""

#: src/design-patterns/index.md:3
msgid ""
"This chapter aims to collect various useful design patterns for embedded "
"Rust."
msgstr ""

#: src/design-patterns/hal/index.md:1
msgid "HAL Design Patterns"
msgstr ""

#: src/design-patterns/hal/index.md:3
msgid ""
"This is a set of common and recommended patterns for writing hardware "
"abstraction layers (HALs) for microcontrollers in Rust. These patterns are "
"intended to be used in addition to the existing [Rust API Guidelines]"
"(https://rust-lang.github.io/api-guidelines/) when writing HALs for "
"microcontrollers."
msgstr ""

#: src/design-patterns/hal/index.md:10
msgid "[Checklist](checklist.md)"
msgstr ""

#: src/design-patterns/hal/index.md:12
msgid "[Naming](naming.md)"
msgstr ""

#: src/design-patterns/hal/index.md:13
msgid "[Interoperability](interoperability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:14
msgid "[Predictability](predictability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:15
msgid "[GPIO](gpio.md)"
msgstr ""

#: src/design-patterns/hal/checklist.md:1
msgid "HAL Design Patterns Checklist"
msgstr ""

#: src/design-patterns/hal/checklist.md:3
msgid "**Naming** _(crate aligns with Rust naming conventions)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:4
msgid ""
"The crate is named appropriately ([C-CRATE-NAME](naming.html#c-crate-name))"
msgstr ""

#: src/design-patterns/hal/checklist.md:5
msgid ""
"**Interoperability** _(crate interacts nicely with other library "
"functionality)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:6
msgid ""
"Wrapper types provide a destructor method ([C-FREE](interoperability.html#c-"
"free))"
msgstr ""

#: src/design-patterns/hal/checklist.md:7
msgid ""
"HALs reexport their register access crate ([C-REEXPORT-PAC]"
"(interoperability.html#c-reexport-pac))"
msgstr ""

#: src/design-patterns/hal/checklist.md:8
msgid ""
"Types implement the `embedded-hal` traits ([C-HAL-TRAITS]"
"(interoperability.html#c-hal-traits))"
msgstr ""

#: src/design-patterns/hal/checklist.md:9
msgid ""
"**Predictability** _(crate enables legible code that acts how it looks)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:10
msgid ""
"Constructors are used instead of extension traits ([C-CTOR]"
"(predictability.html#c-ctor))"
msgstr ""

#: src/design-patterns/hal/checklist.md:11
msgid "**GPIO Interfaces** _(GPIO Interfaces follow a common pattern)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:12
msgid "Pin types are zero-sized by default ([C-ZST-PIN](gpio.md#c-zst-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:13
msgid ""
"Pin types provide methods to erase pin and port ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:14
msgid ""
"Pin state should be encoded as type parameters ([C-PIN-STATE](gpio.md#c-pin-"
"state))"
msgstr ""

#: src/design-patterns/hal/naming.md:4
msgid "<a id=\"c-crate-name\"></a>"
msgstr ""

#: src/design-patterns/hal/naming.md:5
msgid "The crate is named appropriately (C-CRATE-NAME)"
msgstr ""

#: src/design-patterns/hal/naming.md:7
msgid ""
"HAL crates should be named after the chip or family of chips they aim to "
"support. Their name should end with `-hal` to distinguish them from register "
"access crates. The name should not contain underscores (use dashes instead)."
msgstr ""

#: src/design-patterns/hal/interoperability.md:4
msgid "<a id=\"c-free\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:5
msgid "Wrapper types provide a destructor method (C-FREE)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:7
msgid ""
"Any non-`Copy` wrapper type provided by the HAL should provide a `free` "
"method that consumes the wrapper and returns back the raw peripheral (and "
"possibly other objects) it was created from."
msgstr ""

#: src/design-patterns/hal/interoperability.md:11
msgid ""
"The method should shut down and reset the peripheral if necessary. Calling "
"`new` with the raw peripheral returned by `free` should not fail due to an "
"unexpected state of the peripheral."
msgstr ""

#: src/design-patterns/hal/interoperability.md:15
msgid ""
"If the HAL type requires other non-`Copy` objects to be constructed (for "
"example I/O pins), any such object should be released and returned by `free` "
"as well. `free` should return a tuple in that case."
msgstr ""

#: src/design-patterns/hal/interoperability.md:19
msgid "For example:"
msgstr ""

#: src/design-patterns/hal/interoperability.md:36
msgid "<a id=\"c-reexport-pac\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:37
msgid "HALs reexport their register access crate (C-REEXPORT-PAC)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:39
msgid ""
"HALs can be written on top of [svd2rust](https://github.com/rust-embedded/"
"svd2rust)\\-generated PACs, or on top of other crates that provide raw "
"register access. HALs should always reexport the register access crate they "
"are based on in their crate root."
msgstr ""

#: src/design-patterns/hal/interoperability.md:43
msgid ""
"A PAC should be reexported under the name `pac`, regardless of the actual "
"name of the crate, as the name of the HAL should already make it clear what "
"PAC is being accessed."
msgstr ""

#: src/design-patterns/hal/interoperability.md:49
msgid "<a id=\"c-hal-traits\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:50
msgid "Types implement the `embedded-hal` traits (C-HAL-TRAITS)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:52
msgid ""
"Types provided by the HAL should implement all applicable traits provided by "
"the [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) crate."
msgstr ""

#: src/design-patterns/hal/interoperability.md:55
msgid "Multiple traits may be implemented for the same type."
msgstr ""

#: src/design-patterns/hal/predictability.md:4
msgid "<a id=\"c-ctor\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:5
msgid "Constructors are used instead of extension traits (C-CTOR)"
msgstr ""

#: src/design-patterns/hal/predictability.md:7
msgid ""
"All peripherals to which the HAL adds functionality should be wrapped in a "
"new type, even if no additional fields are required for that functionality."
msgstr ""

#: src/design-patterns/hal/predictability.md:10
msgid "Extension traits implemented for the raw peripheral should be avoided."
msgstr ""

#: src/design-patterns/hal/predictability.md:12
msgid "<a id=\"c-inline\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:13
msgid "Methods are decorated with `#[inline]` where appropriate (C-INLINE)"
msgstr ""

#: src/design-patterns/hal/predictability.md:15
msgid ""
"The Rust compiler does not by default perform full inlining across crate "
"boundaries. As embedded applications are sensitive to unexpected code size "
"increases, `#[inline]` should be used to guide the compiler as follows:"
msgstr ""

#: src/design-patterns/hal/predictability.md:19
msgid ""
"All \"small\" functions should be marked `#[inline]`. What qualifies as "
"\"small\" is subjective, but generally all functions that are expected to "
"compile down to single-digit instruction sequences qualify as small."
msgstr ""

#: src/design-patterns/hal/predictability.md:22
msgid ""
"Functions that are very likely to take constant values as parameters should "
"be marked as `#[inline]`. This enables the compiler to compute even "
"complicated initialization logic at compile time, provided the function "
"inputs are known."
msgstr ""

#: src/design-patterns/hal/gpio.md:1
msgid "Recommendations for GPIO Interfaces"
msgstr ""

#: src/design-patterns/hal/gpio.md:3
msgid "<a id=\"c-zst-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:4
msgid "Pin types are zero-sized by default (C-ZST-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:6
msgid ""
"GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types "
"for each pin on every interface or port, resulting in a zero-cost GPIO "
"abstraction when all pin assignments are statically known."
msgstr ""

#: src/design-patterns/hal/gpio.md:10
msgid ""
"Each GPIO Interface or Port should implement a `split` method returning a "
"struct with every pin."
msgstr ""

#: src/design-patterns/hal/gpio.md:13 src/design-patterns/hal/gpio.md:45
#: src/design-patterns/hal/gpio.md:127
msgid "Example:"
msgstr ""

#: src/design-patterns/hal/gpio.md:39
msgid "<a id=\"c-erased-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:40
msgid "Pin types provide methods to erase pin and port (C-ERASED-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:42
msgid ""
"Pins should provide type erasure methods that move their properties from "
"compile time to runtime, and allow more flexibility in applications."
msgstr ""

#: src/design-patterns/hal/gpio.md:48
msgid "/// Port A, pin 0.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:56
msgid "/// A pin on port A.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:59
msgid "/// The pin number.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:75
msgid "// (these fields can be packed to reduce the memory footprint)\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:86
msgid "<a id=\"c-pin-state\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:87
msgid "Pin state should be encoded as type parameters (C-PIN-STATE)"
msgstr ""

#: src/design-patterns/hal/gpio.md:89
msgid ""
"Pins may be configured as input or output with different characteristics "
"depending on the chip or family. This state should be encoded in the type "
"system to prevent use of pins in incorrect states."
msgstr ""

#: src/design-patterns/hal/gpio.md:93
msgid ""
"Additional, chip-specific state (eg. drive strength) may also be encoded in "
"this way, using additional type parameters."
msgstr ""

#: src/design-patterns/hal/gpio.md:96
msgid ""
"Methods for changing the pin state should be provided as `into_input` and "
"`into_output` methods."
msgstr ""

#: src/design-patterns/hal/gpio.md:99
msgid ""
"Additionally, `with_{input,output}_state` methods should be provided that "
"temporarily reconfigure a pin in a different state without moving it."
msgstr ""

#: src/design-patterns/hal/gpio.md:102
msgid ""
"The following methods should be provided for every pin type (that is, both "
"erased and non-erased pin types should provide the same API):"
msgstr ""

#: src/design-patterns/hal/gpio.md:105
msgid "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:106
msgid "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:123
msgid ""
"Pin state should be bounded by sealed traits. Users of the HAL should have "
"no need to add their own state. The traits can provide HAL-specific methods "
"required to implement the pin state API."
msgstr ""

#: src/design-patterns/hal/gpio.md:203
msgid "// Same for `PA` and `Pin`, and other pin types.\n"
msgstr ""

#: src/c-tips/index.md:3
msgid ""
"This chapter collects a variety of tips that might be useful to experienced "
"embedded C developers looking to start writing Rust. It will especially "
"highlight how things you might already be used to in C are different in Rust."
msgstr ""

#: src/c-tips/index.md:7
msgid "Preprocessor"
msgstr ""

#: src/c-tips/index.md:9
msgid ""
"In embedded C it is very common to use the preprocessor for a variety of "
"purposes, such as:"
msgstr ""

#: src/c-tips/index.md:12
msgid "Compile-time selection of code blocks with `#ifdef`"
msgstr ""

#: src/c-tips/index.md:13
msgid "Compile-time array sizes and computations"
msgstr ""

#: src/c-tips/index.md:14
msgid "Macros to simplify common patterns (to avoid function call overhead)"
msgstr ""

#: src/c-tips/index.md:16
msgid ""
"In Rust there is no preprocessor, and so many of these use cases are "
"addressed differently. In the rest of this section we cover various "
"alternatives to using the preprocessor."
msgstr ""

#: src/c-tips/index.md:20
msgid "Compile-Time Code Selection"
msgstr ""

#: src/c-tips/index.md:22
msgid ""
"The closest match to `#ifdef ... #endif` in Rust are [Cargo features]"
"(https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-"
"section). These are a little more formal than the C preprocessor: all "
"possible features are explicitly listed per crate, and can only be either on "
"or off. Features are turned on when you list a crate as a dependency, and "
"are additive: if any crate in your dependency tree enables a feature for "
"another crate, that feature will be enabled for all users of that crate."
msgstr ""

#: src/c-tips/index.md:31
msgid ""
"For example, you might have a crate which provides a library of signal "
"processing primitives. Each one might take some extra time to compile or "
"declare some large table of constants which you'd like to avoid. You could "
"declare a Cargo feature for each component in your `Cargo.toml`:"
msgstr ""

#: src/c-tips/index.md:42
msgid ""
"Then, in your code, use `#[cfg(feature=\"FIR\")]` to control what is "
"included."
msgstr ""

#: src/c-tips/index.md:45
msgid "/// In your top-level lib.rs\n"
msgstr ""

#: src/c-tips/index.md:47
msgid "\"FIR\""
msgstr ""

#: src/c-tips/index.md:50
msgid "\"IIR\""
msgstr ""

#: src/c-tips/index.md:54
msgid ""
"You can similarly include code blocks only if a feature is _not_ enabled, or "
"if any combination of features are or are not enabled."
msgstr ""

#: src/c-tips/index.md:57
msgid ""
"Additionally, Rust provides a number of automatically-set conditions you can "
"use, such as `target_arch` to select different code based on architecture. "
"For full details of the conditional compilation support, refer to the "
"[conditional compilation](https://doc.rust-lang.org/reference/conditional-"
"compilation.html) chapter of the Rust reference."
msgstr ""

#: src/c-tips/index.md:64
msgid ""
"The conditional compilation will only apply to the next statement or block. "
"If a block can not be used in the current scope then the `cfg` attribute "
"will need to be used multiple times.  It's worth noting that most of the "
"time it is better to simply include all the code and allow the compiler to "
"remove dead code when optimising: it's simpler for you and your users, and "
"in general the compiler will do a good job of removing unused code."
msgstr ""

#: src/c-tips/index.md:71
msgid "Compile-Time Sizes and Computation"
msgstr ""

#: src/c-tips/index.md:73
msgid ""
"Rust supports `const fn`, functions which are guaranteed to be evaluable at "
"compile-time and can therefore be used where constants are required, such as "
"in the size of arrays. This can be used alongside features mentioned above, "
"for example:"
msgstr ""

#: src/c-tips/index.md:80 src/c-tips/index.md:82
msgid "\"use_more_ram\""
msgstr ""

#: src/c-tips/index.md:89
msgid ""
"These are new to stable Rust as of 1.31, so documentation is still sparse. "
"The functionality available to `const fn` is also very limited at the time "
"of writing; in future Rust releases it is expected to expand on what is "
"permitted in a `const fn`."
msgstr ""

#: src/c-tips/index.md:94
msgid "Macros"
msgstr ""

#: src/c-tips/index.md:96
msgid ""
"Rust provides an extremely powerful [macro system](https://doc.rust-lang.org/"
"book/ch19-06-macros.html). While the C preprocessor operates almost directly "
"on the text of your source code, the Rust macro system operates at a higher "
"level. There are two varieties of Rust macro: _macros by example_ and "
"_procedural macros_. The former are simpler and most common; they look like "
"function calls and can expand to a complete expression, statement, item, or "
"pattern. Procedural macros are more complex but permit extremely powerful "
"additions to the Rust language: they can transform arbitrary Rust syntax "
"into new Rust syntax."
msgstr ""

#: src/c-tips/index.md:107
msgid ""
"In general, where you might have used a C preprocessor macro, you probably "
"want to see if a macro-by-example can do the job instead. They can be "
"defined in your crate and easily used by your own crate or exported for "
"other users. Be aware that since they must expand to complete expressions, "
"statements, items, or patterns, some use cases of C preprocessor macros will "
"not work, for example a macro that expands to part of a variable name or an "
"incomplete set of items in a list."
msgstr ""

#: src/c-tips/index.md:115
msgid ""
"As with Cargo features, it is worth considering if you even need the macro. "
"In many cases a regular function is easier to understand and will be inlined "
"to the same code as a macro. The `#[inline]` and `#[inline(always)]` "
"[attributes](https://doc.rust-lang.org/reference/attributes.html#inline-"
"attribute) give you further control over this process, although care should "
"be taken here as well â€” the compiler will automatically inline functions "
"from the same crate where appropriate, so forcing it to do so "
"inappropriately might actually lead to decreased performance."
msgstr ""

#: src/c-tips/index.md:125
msgid ""
"Explaining the entire Rust macro system is out of scope for this tips page, "
"so you are encouraged to consult the Rust documentation for full details."
msgstr ""

#: src/c-tips/index.md:128
msgid "Build System"
msgstr ""

#: src/c-tips/index.md:130
msgid ""
"Most Rust crates are built using Cargo (although it is not required). This "
"takes care of many difficult problems with traditional build systems. "
"However, you may wish to customise the build process. Cargo provides "
"[`build.rs` scripts](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html) for this purpose. They are Rust scripts which can interact "
"with the Cargo build system as required."
msgstr ""

#: src/c-tips/index.md:138
msgid "Common use cases for build scripts include:"
msgstr ""

#: src/c-tips/index.md:140
msgid ""
"provide build-time information, for example statically embedding the build "
"date or Git commit hash into your executable"
msgstr ""

#: src/c-tips/index.md:142
msgid ""
"generate linker scripts at build time depending on selected features or "
"other logic"
msgstr ""

#: src/c-tips/index.md:144
msgid "change the Cargo build configuration"
msgstr ""

#: src/c-tips/index.md:145
msgid "add extra static libraries to link against"
msgstr ""

#: src/c-tips/index.md:147
msgid ""
"At present there is no support for post-build scripts, which you might "
"traditionally have used for tasks like automatic generation of binaries from "
"the build objects or printing build information."
msgstr ""

#: src/c-tips/index.md:151
msgid "Cross-Compiling"
msgstr ""

#: src/c-tips/index.md:153
msgid ""
"Using Cargo for your build system also simplifies cross-compiling. In most "
"cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a "
"suitable executable in `target/thumbv6m-none-eabi/debug/myapp`."
msgstr ""

#: src/c-tips/index.md:157
msgid ""
"For platforms not natively supported by Rust, you will need to build "
"`libcore` for that target yourself. On such platforms, [Xargo](https://"
"github.com/japaric/xargo) can be used as a stand-in for Cargo which "
"automatically builds `libcore` for you."
msgstr ""

#: src/c-tips/index.md:163
msgid "Iterators vs Array Access"
msgstr ""

#: src/c-tips/index.md:165
msgid "In C you are probably used to accessing arrays directly by their index:"
msgstr ""

#: src/c-tips/index.md:175
msgid ""
"In Rust this is an anti-pattern: indexed access can be slower (as it needs "
"to be bounds checked) and may prevent various compiler optimisations. This "
"is an important distinction and worth repeating: Rust will check for out-of-"
"bounds access on manual array indexing to guarantee memory safety, while C "
"will happily index outside the array."
msgstr ""

#: src/c-tips/index.md:181
msgid "Instead, use iterators:"
msgstr ""

#: src/c-tips/index.md:190
msgid ""
"Iterators provide a powerful array of functionality you would have to "
"implement manually in C, such as chaining, zipping, enumerating, finding the "
"min or max, summing, and more. Iterator methods can also be chained, giving "
"very readable data processing code."
msgstr ""

#: src/c-tips/index.md:195
msgid ""
"See the [Iterators in the Book](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html) and [Iterator documentation](https://doc.rust-lang.org/core/"
"iter/trait.Iterator.html) for more details."
msgstr ""

#: src/c-tips/index.md:200
msgid "References vs Pointers"
msgstr ""

#: src/c-tips/index.md:202
msgid ""
"In Rust, pointers (called [_raw pointers_](https://doc.rust-lang.org/book/"
"ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer)) exist but are only "
"used in specific circumstances, as dereferencing them is always considered "
"`unsafe` -- Rust cannot provide its usual guarantees about what might be "
"behind the pointer."
msgstr ""

#: src/c-tips/index.md:208
msgid ""
"In most cases, we instead use _references_, indicated by the `&` symbol, or "
"_mutable references_, indicated by `&mut`. References behave similarly to "
"pointers, in that they can be dereferenced to access the underlying values, "
"but they are a key part of Rust's ownership system: Rust will strictly "
"enforce that you may only have one mutable reference _or_ multiple non-"
"mutable references to the same value at any given time."
msgstr ""

#: src/c-tips/index.md:215
msgid ""
"In practice this means you have to be more careful about whether you need "
"mutable access to data: where in C the default is mutable and you must be "
"explicit about `const`, in Rust the opposite is true."
msgstr ""

#: src/c-tips/index.md:219
msgid ""
"One situation where you might still use raw pointers is interacting directly "
"with hardware (for example, writing a pointer to a buffer into a DMA "
"peripheral register), and they are also used under the hood for all "
"peripheral access crates to allow you to read and write memory-mapped "
"registers."
msgstr ""

#: src/c-tips/index.md:224
msgid "Volatile Access"
msgstr ""

#: src/c-tips/index.md:226
msgid ""
"In C, individual variables may be marked `volatile`, indicating to the "
"compiler that the value in the variable may change between accesses. "
"Volatile variables are commonly used in an embedded context for memory-"
"mapped registers."
msgstr ""

#: src/c-tips/index.md:230
msgid ""
"In Rust, instead of marking a variable as `volatile`, we use specific "
"methods to perform volatile access: [`core::ptr::read_volatile`](https://"
"doc.rust-lang.org/core/ptr/fn.read_volatile.html) and "
"[`core::ptr::write_volatile`](https://doc.rust-lang.org/core/ptr/"
"fn.write_volatile.html). These methods take a `*const T` or a `*mut T` (_raw "
"pointers_, as discussed above) and perform a volatile read or write."
msgstr ""

#: src/c-tips/index.md:238
msgid "For example, in C you might write:"
msgstr ""

#: src/c-tips/index.md:244
msgid "// Signal that the interrupt has occurred\n"
msgstr ""

#: src/c-tips/index.md:250 src/c-tips/index.md:275
msgid "// Sleep until signalled\n"
msgstr ""

#: src/c-tips/index.md:252 src/c-tips/index.md:277
msgid "// Reset signalled indicator\n"
msgstr ""

#: src/c-tips/index.md:254 src/c-tips/index.md:279
msgid "// Perform some task that was waiting for the interrupt\n"
msgstr ""

#: src/c-tips/index.md:260
msgid "The equivalent in Rust would use volatile methods on each access:"
msgstr ""

#: src/c-tips/index.md:267
msgid ""
"// Signal that the interrupt has occurred\n"
"    // (In real code, you should consider a higher level primitive,\n"
"    //  such as an atomic type).\n"
msgstr ""

#: src/c-tips/index.md:285
msgid "A few things are worth noting in the code sample:"
msgstr ""

#: src/c-tips/index.md:286
msgid ""
"We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since "
"`&mut T` automatically converts to a `*mut T` (and the same for `*const T`)"
msgstr ""

#: src/c-tips/index.md:288
msgid ""
"We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods, "
"since they are `unsafe` functions. It is the programmer's responsibility to "
"ensure safe use: see the methods' documentation for further details."
msgstr ""

#: src/c-tips/index.md:292
msgid ""
"It is rare to require these functions directly in your code, as they will "
"usually be taken care of for you by higher-level libraries. For memory "
"mapped peripherals, the peripheral access crates will implement volatile "
"access automatically, while for concurrency primitives there are better "
"abstractions available (see the [Concurrency chapter](../concurrency/"
"index.md))."
msgstr ""

#: src/c-tips/index.md:300
msgid "Packed and Aligned Types"
msgstr ""

#: src/c-tips/index.md:302
msgid ""
"In embedded C it is common to tell the compiler a variable must have a "
"certain alignment or a struct must be packed rather than aligned, usually to "
"meet specific hardware or protocol requirements."
msgstr ""

#: src/c-tips/index.md:306
msgid ""
"In Rust this is controlled by the `repr` attribute on a struct or union. The "
"default representation provides no guarantees of layout, so should not be "
"used for code that interoperates with hardware or C. The compiler may re-"
"order struct members or insert padding and the behaviour may change with "
"future versions of Rust."
msgstr ""

#: src/c-tips/index.md:321 src/c-tips/index.md:340 src/c-tips/index.md:366
#: src/c-tips/index.md:390 src/c-tips/index.md:391
msgid "\"{:p} {:p} {:p}\""
msgstr ""

#: src/c-tips/index.md:323
msgid ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// Note ordering has been changed to x, z, y to improve packing.\n"
msgstr ""

#: src/c-tips/index.md:328
msgid "To ensure layouts that are interoperable with C, use `repr(C)`:"
msgstr ""

#: src/c-tips/index.md:342
msgid ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// Ordering is preserved and the layout will not change over time.\n"
"// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.\n"
msgstr ""

#: src/c-tips/index.md:348
msgid "To ensure a packed representation, use `repr(packed)`:"
msgstr ""

#: src/c-tips/index.md:360
msgid ""
"// References must always be aligned, so to check the addresses of the\n"
"    // struct's fields, we use `std::ptr::addr_of!()` to get a raw pointer\n"
"    // instead of just printing `&v.x`.\n"
msgstr ""

#: src/c-tips/index.md:368
msgid ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// No padding has been inserted between `y` and `z`, so now `z` is "
"unaligned.\n"
msgstr ""

#: src/c-tips/index.md:373
msgid ""
"Note that using `repr(packed)` also sets the alignment of the type to `1`."
msgstr ""

#: src/c-tips/index.md:375
msgid ""
"Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is "
"the number of bytes to align to (and must be a power of two):"
msgstr ""

#: src/c-tips/index.md:393
msgid ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// The two instances `u` and `v` have been placed on 4096-byte alignments,\n"
"// evidenced by the `000` at the end of their addresses.\n"
msgstr ""

#: src/c-tips/index.md:400
msgid ""
"Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and "
"C-compatible layout. It is not permissible to combine `repr(align(n))` with "
"`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also "
"not permissible for a `repr(packed)` type to contain a `repr(align(n))` type."
msgstr ""

#: src/c-tips/index.md:405
msgid ""
"For further details on type layouts, refer to the [type layout](https://"
"doc.rust-lang.org/reference/type-layout.html) chapter of the Rust Reference."
msgstr ""

#: src/c-tips/index.md:412
msgid "In this book:"
msgstr ""

#: src/c-tips/index.md:413
msgid "[A little C with your Rust](../interoperability/c-with-rust.md)"
msgstr ""

#: src/c-tips/index.md:414
msgid "[A little Rust with your C](../interoperability/rust-with-c.md)"
msgstr ""

#: src/c-tips/index.md:415
msgid "[The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)"
msgstr ""

#: src/c-tips/index.md:416
msgid "[Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)"
msgstr ""

#: src/c-tips/index.md:417
msgid ""
"[I used to use pointers - now what?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"
msgstr ""

#: src/interoperability/index.md:3
msgid ""
"Interoperability between Rust and C code is always dependent on transforming "
"data between the two languages. For this purpose, there is a dedicated "
"module in the `stdlib` called [`std::ffi`](https://doc.rust-lang.org/std/ffi/"
"index.html)."
msgstr ""

#: src/interoperability/index.md:9
msgid ""
"`std::ffi` provides type definitions for C primitive types, such as `char`, "
"`int`, and `long`. It also provides some utility for converting more complex "
"types such as strings, mapping both `&str` and `String` to C types that are "
"easier and safer to handle."
msgstr ""

#: src/interoperability/index.md:15
msgid ""
"As of Rust 1.30, functionalities of `std::ffi` are available in either "
"`core::ffi` or `alloc::ffi` depending on whether or not memory allocation is "
"involved. The [`cty`](https://crates.io/crates/cty) crate and the "
"[`cstr_core`](https://crates.io/crates/cstr_core) crate also offer similar "
"functionalities."
msgstr ""

#: src/interoperability/index.md:25
msgid "Rust type"
msgstr ""

#: src/interoperability/index.md:25
msgid "Intermediate"
msgstr ""

#: src/interoperability/index.md:25
msgid "C type"
msgstr ""

#: src/interoperability/index.md:27
msgid "`String`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`CString`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`char *`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`&str`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`CStr`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`const char *`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`()`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`c_void`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`void`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`u32` or `u64`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`c_uint`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`unsigned int`"
msgstr ""

#: src/interoperability/index.md:31
msgid "etc"
msgstr ""

#: src/interoperability/index.md:31
msgid "..."
msgstr ""

#: src/interoperability/index.md:33
msgid ""
"A value of a C primitive type can be used as one of the corresponding Rust "
"type and vice versa, since the former is simply a type alias of the latter. "
"For example, the following code compiles on platforms where `unsigned int` "
"is 32-bit long."
msgstr ""

#: src/interoperability/index.md:46
msgid "Interoperability with other build systems"
msgstr ""

#: src/interoperability/index.md:48
msgid ""
"A common requirement for including Rust in your embedded project is "
"combining Cargo with your existing build system, such as make or cmake."
msgstr ""

#: src/interoperability/index.md:51
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #61](https://github.com/rust-embedded/book/issues/61)."
msgstr ""

#: src/interoperability/index.md:56
msgid "Interoperability with RTOSs"
msgstr ""

#: src/interoperability/index.md:58
msgid ""
"Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in "
"progress; especially calling RTOS functions from Rust can be tricky."
msgstr ""

#: src/interoperability/index.md:61
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #62](https://github.com/rust-embedded/book/issues/62)."
msgstr ""

#: src/interoperability/c-with-rust.md:3
msgid "Using C or C++ inside of a Rust project consists of two major parts:"
msgstr ""

#: src/interoperability/c-with-rust.md:5
msgid "Wrapping the exposed C API for use with Rust"
msgstr ""

#: src/interoperability/c-with-rust.md:6
msgid "Building your C or C++ code to be integrated with the Rust code"
msgstr ""

#: src/interoperability/c-with-rust.md:8
msgid ""
"As C++ does not have a stable ABI for the Rust compiler to target, it is "
"recommended to use the `C` ABI when combining Rust with C or C++."
msgstr ""

#: src/interoperability/c-with-rust.md:10
msgid "Defining the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:12
msgid ""
"Before consuming C or C++ code from Rust, it is necessary to define (in "
"Rust) what data types and function signatures exist in the linked code. In C "
"or C++, you would include a header (`.h` or `.hpp`) file which defines this "
"data. In Rust, it is necessary to either manually translate these "
"definitions to Rust, or use a tool to generate these definitions."
msgstr ""

#: src/interoperability/c-with-rust.md:14
msgid ""
"First, we will cover manually translating these definitions from C/C++ to "
"Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:16
msgid "Wrapping C functions and Datatypes"
msgstr ""

#: src/interoperability/c-with-rust.md:18
msgid ""
"Typically, libraries written in C or C++ will provide a header file defining "
"all types and functions used in public interfaces. An example file may look "
"like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:21
msgid "/* File: cool.h */"
msgstr ""

#: src/interoperability/c-with-rust.md:30
msgid "When translated to Rust, this interface would look as such:"
msgstr ""

#: src/interoperability/c-with-rust.md:33
msgid "/* File: cool_bindings.rs */"
msgstr ""

#: src/interoperability/c-with-rust.md:40
#: src/interoperability/c-with-rust.md:66
#: src/interoperability/rust-with-c.md:56
#: src/interoperability/rust-with-c.md:82
msgid "\"C\""
msgstr ""

#: src/interoperability/c-with-rust.md:49
msgid ""
"Let's take a look at this definition one piece at a time, to explain each of "
"the parts."
msgstr ""

#: src/interoperability/c-with-rust.md:56
msgid ""
"By default, Rust does not guarantee order, padding, or the size of data "
"included in a `struct`. In order to guarantee compatibility with C code, we "
"include the `#[repr(C)]` attribute, which instructs the Rust compiler to "
"always use the same rules C does for organizing data within a struct."
msgstr ""

#: src/interoperability/c-with-rust.md:63
msgid ""
"Due to the flexibility of how C or C++ defines an `int` or `char`, it is "
"recommended to use primitive data types defined in `cty`, which will map "
"types from C to types in Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:69
msgid ""
"This statement defines the signature of a function that uses the C ABI, "
"called `cool_function`. By defining the signature without defining the body "
"of the function, the definition of this function will need to be provided "
"elsewhere, or linked into the final library or binary from a static library."
msgstr ""

#: src/interoperability/c-with-rust.md:77
msgid ""
"Similar to our datatype above, we define the datatypes of the function "
"arguments using C-compatible definitions. We also retain the same argument "
"names, for clarity."
msgstr ""

#: src/interoperability/c-with-rust.md:79
msgid ""
"We have one new type here, `*mut CoolStruct`. As C does not have a concept "
"of Rust's references, which would look like this: `&mut CoolStruct`, we "
"instead have a raw pointer. As dereferencing this pointer is `unsafe`, and "
"the pointer may in fact be a `null` pointer, care must be taken to ensure "
"the guarantees typical of Rust when interacting with C or C++ code."
msgstr ""

#: src/interoperability/c-with-rust.md:81
msgid "Automatically generating the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:83
msgid ""
"Rather than manually generating these interfaces, which may be tedious and "
"error prone, there is a tool called [bindgen](https://github.com/rust-lang/"
"rust-bindgen) which will perform these conversions automatically. For "
"instructions of the usage of [bindgen](https://github.com/rust-lang/rust-"
"bindgen), please refer to the [bindgen user's manual](https://rust-"
"lang.github.io/rust-bindgen/), however the typical process consists of the "
"following:"
msgstr ""

#: src/interoperability/c-with-rust.md:85
msgid ""
"Gather all C or C++ headers defining interfaces or datatypes you would like "
"to use with Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:86
msgid ""
"Write a `bindings.h` file, which `#include \"...\"`'s each of the files you "
"gathered in step one."
msgstr ""

#: src/interoperability/c-with-rust.md:87
msgid ""
"Feed this `bindings.h` file, along with any compilation flags used to "
"compile your code into `bindgen`. Tip: use "
"`Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and "
"`Builder.use_core()` / `--use-core` to make the generated code `#![no_std]` "
"compatible."
msgstr ""

#: src/interoperability/c-with-rust.md:90
msgid ""
"`bindgen` will produce the generated Rust code to the output of the terminal "
"window. This output may be piped to a file in your project, such as "
"`bindings.rs`. You may use this file in your Rust project to interact with C/"
"C++ code compiled and linked as an external library. Tip: don't forget to "
"use the [`cty`](https://crates.io/crates/cty) crate if your types in the "
"generated bindings are prefixed with `cty`."
msgstr ""

#: src/interoperability/c-with-rust.md:95
msgid "Building your C/C++ code"
msgstr ""

#: src/interoperability/c-with-rust.md:97
msgid ""
"As the Rust compiler does not directly know how to compile C or C++ code (or "
"code from any other language, which presents a C interface), it is necessary "
"to compile your non-Rust code ahead of time."
msgstr ""

#: src/interoperability/c-with-rust.md:99
msgid ""
"For embedded projects, this most commonly means compiling the C/C++ code to "
"a static archive (such as `cool-library.a`), which can then be combined with "
"your Rust code at the final linking step."
msgstr ""

#: src/interoperability/c-with-rust.md:101
msgid ""
"If the library you would like to use is already distributed as a static "
"archive, it is not necessary to rebuild your code. Just convert the provided "
"interface header file as described above, and include the static archive at "
"compile/link time."
msgstr ""

#: src/interoperability/c-with-rust.md:103
msgid ""
"If your code exists as a source project, it will be necessary to compile "
"your C/C++ code to a static library, either by triggering your existing "
"build system (such as `make`, `CMake`, etc.), or by porting the necessary "
"compilation steps to use a tool called the `cc` crate. For both of these "
"steps, it is necessary to use a `build.rs` script."
msgstr ""

#: src/interoperability/c-with-rust.md:105
msgid "Rust `build.rs` build scripts"
msgstr ""

#: src/interoperability/c-with-rust.md:107
msgid ""
"A `build.rs` script is a file written in Rust syntax, that is executed on "
"your compilation machine, AFTER dependencies of your project have been "
"built, but BEFORE your project is built."
msgstr ""

#: src/interoperability/c-with-rust.md:109
msgid ""
"The full reference may be found [here](https://doc.rust-lang.org/cargo/"
"reference/build-scripts.html). `build.rs` scripts are useful for generating "
"code (such as via [bindgen](https://github.com/rust-lang/rust-bindgen)), "
"calling out to external build systems such as `Make`, or directly compiling "
"C/C++ through use of the `cc` crate."
msgstr ""

#: src/interoperability/c-with-rust.md:111
msgid "Triggering external build systems"
msgstr ""

#: src/interoperability/c-with-rust.md:113
msgid ""
"For projects with complex external projects or build systems, it may be "
"easiest to use [`std::process::Command`](https://doc.rust-lang.org/std/"
"process/struct.Command.html) to \"shell out\" to your other build systems by "
"traversing relative paths, calling a fixed command (such as `make library`), "
"and then copying the resulting static library to the proper location in the "
"`target` build directory."
msgstr ""

#: src/interoperability/c-with-rust.md:115
msgid ""
"While your crate may be targeting a `no_std` embedded platform, your "
"`build.rs` executes only on machines compiling your crate. This means you "
"may use any Rust crates which will run on your compilation host."
msgstr ""

#: src/interoperability/c-with-rust.md:119
msgid "Building C/C++ code with the `cc` crate"
msgstr ""

#: src/interoperability/c-with-rust.md:121
msgid ""
"For projects with limited dependencies or complexity, or for projects where "
"it is difficult to modify the build system to produce a static library "
"(rather than a final binary or executable), it may be easier to instead "
"utilize the [`cc` crate](https://github.com/alexcrichton/cc-rs), which "
"provides an idiomatic Rust interface to the compiler provided by the host."
msgstr ""

#: src/interoperability/c-with-rust.md:125
msgid ""
"In the simplest case of compiling a single C file as a dependency to a "
"static library, an example `build.rs` script using the [`cc` crate](https://"
"github.com/alexcrichton/cc-rs) would look like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:130
msgid "\"src/foo.c\""
msgstr ""

#: src/interoperability/c-with-rust.md:131
msgid "\"foo\""
msgstr ""

#: src/interoperability/c-with-rust.md:135
msgid ""
"The `build.rs` is placed at the root of the package. Then `cargo build` will "
"compile and execute it before the build of the package. A static archive "
"named `libfoo.a` is generated and placed in the `target` directory."
msgstr ""

#: src/interoperability/rust-with-c.md:3
msgid "Using Rust code inside a C or C++ project mostly consists of two parts."
msgstr ""

#: src/interoperability/rust-with-c.md:5
msgid "Creating a C-friendly API in Rust"
msgstr ""

#: src/interoperability/rust-with-c.md:6
msgid "Embedding your Rust project into an external build system"
msgstr ""

#: src/interoperability/rust-with-c.md:8
msgid ""
"Apart from `cargo` and `meson`, most build systems don't have native Rust "
"support. So you're most likely best off just using `cargo` for compiling "
"your crate and any dependencies."
msgstr ""

#: src/interoperability/rust-with-c.md:12
msgid "Setting up a project"
msgstr ""

#: src/interoperability/rust-with-c.md:14
msgid "Create a new `cargo` project as usual."
msgstr ""

#: src/interoperability/rust-with-c.md:16
msgid ""
"There are flags to tell `cargo` to emit a systems library, instead of its "
"regular rust target. This also allows you to set a different output name for "
"your library, if you want it to differ from the rest of your crate."
msgstr ""

#: src/interoperability/rust-with-c.md:21
msgid ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # Creates dynamic lib\n"
"# crate-type = [\"staticlib\"] # Creates static lib\n"
"```"
msgstr ""

#: src/interoperability/rust-with-c.md:28
msgid "Building a `C` API"
msgstr ""

#: src/interoperability/rust-with-c.md:30
msgid ""
"Because C++ has no stable ABI for the Rust compiler to target, we use `C` "
"for any interoperability between different languages. This is no exception "
"when using Rust inside of C and C++ code."
msgstr ""

#: src/interoperability/rust-with-c.md:34
msgid "`#[no_mangle]`"
msgstr ""

#: src/interoperability/rust-with-c.md:36
msgid ""
"The Rust compiler mangles symbol names differently than native code linkers "
"expect. As such, any function that Rust exports to be used outside of Rust "
"needs to be told not to be mangled by the compiler."
msgstr ""

#: src/interoperability/rust-with-c.md:40
msgid "`extern \"C\"`"
msgstr ""

#: src/interoperability/rust-with-c.md:42
msgid ""
"By default, any function you write in Rust will use the Rust ABI (which is "
"also not stabilized). Instead, when building outwards facing FFI APIs we "
"need to tell the compiler to use the system ABI."
msgstr ""

#: src/interoperability/rust-with-c.md:47
msgid ""
"Depending on your platform, you might want to target a specific ABI version, "
"which are documented [here](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""

#: src/interoperability/rust-with-c.md:52
msgid ""
"Putting these parts together, you get a function that looks roughly like "
"this."
msgstr ""

#: src/interoperability/rust-with-c.md:61
msgid ""
"Just as when using `C` code in your Rust project you now need to transform "
"data from and to a form that the rest of the application will understand."
msgstr ""

#: src/interoperability/rust-with-c.md:64
msgid "Linking and greater project context."
msgstr ""

#: src/interoperability/rust-with-c.md:66
msgid ""
"So then, that's one half of the problem solved. How do you use this now?"
msgstr ""

#: src/interoperability/rust-with-c.md:69
msgid "**This very much depends on your project and/or build system**"
msgstr ""

#: src/interoperability/rust-with-c.md:71
msgid ""
"`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file, depending "
"on your platform and settings. This library can simply be linked by your "
"build system."
msgstr ""

#: src/interoperability/rust-with-c.md:75
msgid ""
"However, calling a Rust function from C requires a header file to declare "
"the function signatures."
msgstr ""

#: src/interoperability/rust-with-c.md:78
msgid ""
"Every function in your Rust-ffi API needs to have a corresponding header "
"function."
msgstr ""

#: src/interoperability/rust-with-c.md:85
msgid "would then become"
msgstr ""

#: src/interoperability/rust-with-c.md:91
msgid "etc."
msgstr ""

#: src/interoperability/rust-with-c.md:93
msgid ""
"There is a tool to automate this process, called [cbindgen](https://"
"github.com/eqrion/cbindgen) which analyses your Rust code and then generates "
"headers for your C and C++ projects from it."
msgstr ""

#: src/interoperability/rust-with-c.md:99
msgid ""
"At this point, using the Rust functions from C is as simple as including the "
"header and calling them!"
msgstr ""

#: src/interoperability/rust-with-c.md:103
msgid "\"my-rust-project.h\""
msgstr ""

#: src/unsorted/speed-vs-size.md:1
msgid "Optimizations: the speed size tradeoff"
msgstr ""

#: src/unsorted/speed-vs-size.md:3
msgid ""
"Everyone wants their program to be super fast and super small but it's "
"usually not possible to have both characteristics. This section discusses "
"the different optimization levels that `rustc` provides and how they affect "
"the execution time and binary size of a program."
msgstr ""

#: src/unsorted/speed-vs-size.md:8
msgid "No optimizations"
msgstr ""

#: src/unsorted/speed-vs-size.md:10
msgid ""
"This is the default. When you call `cargo build` you use the development "
"(AKA `dev`) profile. This profile is optimized for debugging so it enables "
"debug information and does _not_ enable any optimizations, i.e. it uses `-C "
"opt-level = 0`."
msgstr ""

#: src/unsorted/speed-vs-size.md:15
msgid ""
"At least for bare metal development, debuginfo is zero cost in the sense "
"that it won't occupy space in Flash / ROM so we actually recommend that you "
"enable debuginfo in the release profile -- it is disabled by default. That "
"will let you use breakpoints when debugging release builds."
msgstr ""

#: src/unsorted/speed-vs-size.md:26
msgid ""
"No optimizations is great for debugging because stepping through the code "
"feels like you are executing the program statement by statement, plus you "
"can `print` stack variables and function arguments in GDB. When the code is "
"optimized, trying to print variables results in `$0 = <value optimized out>` "
"being printed."
msgstr ""

#: src/unsorted/speed-vs-size.md:31
msgid ""
"The biggest downside of the `dev` profile is that the resulting binary will "
"be huge and slow. The size is usually more of a problem because unoptimized "
"binaries can occupy dozens of KiB of Flash, which your target device may not "
"have -- the result: your unoptimized binary doesn't fit in your device!"
msgstr ""

#: src/unsorted/speed-vs-size.md:36
msgid "Can we have smaller, debugger friendly binaries? Yes, there's a trick."
msgstr ""

#: src/unsorted/speed-vs-size.md:38
msgid "Optimizing dependencies"
msgstr ""

#: src/unsorted/speed-vs-size.md:40
msgid ""
"There's a Cargo feature named [`profile-overrides`](https://doc.rust-"
"lang.org/cargo/reference/profiles.html#overrides) that lets you override the "
"optimization level of dependencies. You can use that feature to optimize all "
"dependencies for size while keeping the top crate unoptimized and debugger "
"friendly."
msgstr ""

#: src/unsorted/speed-vs-size.md:45
msgid ""
"Beware that generic code can sometimes be optimized alongside the crate "
"where it is instantiated, rather than the crate where it is defined. If you "
"create an instance of a generic struct in your application and find that it "
"pulls in code with a large footprint, it may be that increasing the "
"optimisation level of the relevant dependencies has no effect."
msgstr ""

#: src/unsorted/speed-vs-size.md:53
msgid "Here's an example:"
msgstr ""

#: src/unsorted/speed-vs-size.md:55
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:65
msgid "Without the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:78
msgid "With the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:91
msgid ""
"That's a 6 KiB reduction in Flash usage without any loss in the "
"debuggability of the top crate. If you step into a dependency then you'll "
"start seeing those `<value optimized out>` messages again but it's usually "
"the case that you want to debug the top crate and not the dependencies. And "
"if you _do_ need to debug a dependency then you can use the `profile-"
"overrides` feature to exclude a particular dependency from being optimized. "
"See example below:"
msgstr ""

#: src/unsorted/speed-vs-size.md:98
msgid ""
"```toml\n"
"# ..\n"
"\n"
"# don't optimize the `cortex-m-rt` crate\n"
"[profile.dev.package.cortex-m-rt] # +\n"
"opt-level = 0 # +\n"
"\n"
"# but do optimize all the other dependencies\n"
"[profile.dev.package.\"*\"]\n"
"codegen-units = 1 # better optimizations\n"
"opt-level = \"z\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:111
msgid "Now the top crate and `cortex-m-rt` are debugger friendly!"
msgstr ""

#: src/unsorted/speed-vs-size.md:113
msgid "Optimize for speed"
msgstr ""

#: src/unsorted/speed-vs-size.md:115
msgid ""
"As of 2018-09-18 `rustc` supports three \"optimize for speed\" levels: `opt-"
"level = 1`, `2` and `3`. When you run `cargo build --release` you are using "
"the release profile which defaults to `opt-level = 3`."
msgstr ""

#: src/unsorted/speed-vs-size.md:119
msgid ""
"Both `opt-level = 2` and `3` optimize for speed at the expense of binary "
"size, but level `3` does more vectorization and inlining than level `2`. In "
"particular, you'll see that at `opt-level` equal to or greater than `2` LLVM "
"will unroll loops. Loop unrolling has a rather high cost in terms of Flash / "
"ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also "
"halve the execution time given the right conditions (e.g. number of "
"iterations is big enough)."
msgstr ""

#: src/unsorted/speed-vs-size.md:127
msgid ""
"Currently there's no way to disable loop unrolling in `opt-level = 2` and "
"`3` so if you can't afford its cost you should optimize your program for "
"size."
msgstr ""

#: src/unsorted/speed-vs-size.md:130
msgid "Optimize for size"
msgstr ""

#: src/unsorted/speed-vs-size.md:132
msgid ""
"As of 2018-09-18 `rustc` supports two \"optimize for size\" levels: `opt-"
"level = \"s\"` and `\"z\"`. These names were inherited from clang / LLVM and "
"are not too descriptive but `\"z\"` is meant to give the idea that it "
"produces smaller binaries than `\"s\"`."
msgstr ""

#: src/unsorted/speed-vs-size.md:137
msgid ""
"If you want your release binaries to be optimized for size then change the "
"`profile.release.opt-level` setting in `Cargo.toml` as shown below."
msgstr ""

#: src/unsorted/speed-vs-size.md:140
msgid ""
"```toml\n"
"[profile.release]\n"
"# or \"z\"\n"
"opt-level = \"s\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:146
msgid ""
"These two optimization levels greatly reduce LLVM's inline threshold, a "
"metric used to decide whether to inline a function or not. One of Rust "
"principles are zero cost abstractions; these abstractions tend to use a lot "
"of newtypes and small functions to hold invariants (e.g. functions that "
"borrow an inner value like `deref`, `as_ref`) so a low inline threshold can "
"make LLVM miss optimization opportunities (e.g. eliminate dead branches, "
"inline calls to closures)."
msgstr ""

#: src/unsorted/speed-vs-size.md:154
msgid ""
"When optimizing for size you may want to try increasing the inline threshold "
"to see if that has any effect on the binary size. The recommended way to "
"change the inline threshold is to append the `-C inline-threshold` flag to "
"the other rustflags in `.cargo/config.toml`."
msgstr ""

#: src/unsorted/speed-vs-size.md:159
msgid ""
"```toml\n"
"# .cargo/config.toml\n"
"# this assumes that you are using the cortex-m-quickstart template\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\n"
"  # ..\n"
"  \"-C\", \"inline-threshold=123\", # +\n"
"]\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:169
msgid ""
"What value to use? [As of 1.29.0 these are the inline thresholds that the "
"different optimization levels use](https://github.com/rust-lang/rust/blob/"
"1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122):"
msgstr ""

#: src/unsorted/speed-vs-size.md:174
msgid "`opt-level = 3` uses 275"
msgstr ""

#: src/unsorted/speed-vs-size.md:175
msgid "`opt-level = 2` uses 225"
msgstr ""

#: src/unsorted/speed-vs-size.md:176
msgid "`opt-level = \"s\"` uses 75"
msgstr ""

#: src/unsorted/speed-vs-size.md:177
msgid "`opt-level = \"z\"` uses 25"
msgstr ""

#: src/unsorted/speed-vs-size.md:179
msgid "You should try `225` and `275` when optimizing for size."
msgstr ""

#: src/unsorted/math.md:1
msgid "Performing math functionality with `#[no_std]`"
msgstr ""

#: src/unsorted/math.md:3
msgid ""
"If you want to perform math related functionality like calculating the "
"squareroot or the exponential of a number and you have the full standard "
"library available, your code might look like this:"
msgstr ""

#: src/unsorted/math.md:8
msgid "//! Some mathematical functions with standard support available\n"
msgstr ""

#: src/unsorted/math.md:19 src/unsorted/math.md:53
msgid "\"Floored test float {} to {}\""
msgstr ""

#: src/unsorted/math.md:20 src/unsorted/math.md:54
msgid "\"The square root of {} is {}\""
msgstr ""

#: src/unsorted/math.md:21 src/unsorted/math.md:55
msgid "\"The sinus of four is {}\""
msgstr ""

#: src/unsorted/math.md:23 src/unsorted/math.md:57
msgid "\"The exponential of four to the base e is {}\""
msgstr ""

#: src/unsorted/math.md:29
msgid ""
"Without standard library support, these functions are not available. An "
"external crate like [`libm`](https://crates.io/crates/libm) can be used "
"instead. The example code would then look like this:"
msgstr ""

#: src/unsorted/math.md:69
msgid ""
"If you need to perform more complex operations like DSP signal processing or "
"advanced linear algebra on your MCU, the following crates might help you"
msgstr ""

#: src/unsorted/math.md:72
msgid ""
"[CMSIS DSP library binding](https://github.com/jacobrosenthal/cmsis-dsp-sys)"
msgstr ""

#: src/unsorted/math.md:73
msgid "[`constgebra`](https://crates.io/crates/constgebra)"
msgstr ""

#: src/unsorted/math.md:74
msgid "[`micromath`](https://github.com/tarcieri/micromath)"
msgstr ""

#: src/unsorted/math.md:75
msgid "[`microfft`](https://crates.io/crates/microfft)"
msgstr ""

#: src/unsorted/math.md:76
msgid "[`nalgebra`](https://github.com/dimforge/nalgebra)"
msgstr ""

#: src/appendix/glossary.md:3
msgid ""
"The embedded ecosystem is full of different protocols, hardware components "
"and vendor-specific things that use their own terms and abbreviations. This "
"Glossary attempts to list them with pointers for understanding them better."
msgstr ""

#: src/appendix/glossary.md:7
msgid "BSP"
msgstr ""

#: src/appendix/glossary.md:9
msgid ""
"A Board Support Crate provides a high level interface configured for a "
"specific board. It usually depends on a [HAL](#hal) crate. There is a more "
"detailed description on the [memory-mapped registers page](../start/"
"registers.md) or for a broader overview see [this video](https://youtu.be/"
"vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:14
msgid "FPU"
msgstr ""

#: src/appendix/glossary.md:16
msgid ""
"Floating-point Unit. A 'math processor' running only operations on floating-"
"point numbers."
msgstr ""

#: src/appendix/glossary.md:18
msgid "HAL"
msgstr ""

#: src/appendix/glossary.md:20
msgid ""
"A Hardware Abstraction Layer crate provides a developer friendly interface "
"to a microcontroller's features and peripherals. It is usually implemented "
"on top of a [Peripheral Access Crate (PAC)](#pac). It may also implement "
"traits from the [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"crate. There is a more detailed description on the [memory-mapped registers "
"page](../start/registers.md) or for a broader overview see [this video]"
"(https://youtu.be/vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:28
msgid ""
"Sometimes referred to as `IÂ²C` or Inter-IC. It is a protocol meant for "
"hardware communication within a single integrated circuit. See [here]"
"(https://en.wikipedia.org/wiki/I2c) for more details"
msgstr ""

#: src/appendix/glossary.md:33
msgid "PAC"
msgstr ""

#: src/appendix/glossary.md:35
msgid ""
"A Peripheral Access Crate provides access to a microcontroller's "
"peripherals. It is one of the lower level crates and is usually generated "
"directly from the provided [SVD](#svd), often using [svd2rust](https://"
"github.com/rust-embedded/svd2rust/). The [Hardware Abstraction Layer](#hal) "
"would usually depend on this crate. There is a more detailed description on "
"the [memory-mapped registers page](../start/registers.md) or for a broader "
"overview see [this video](https://youtu.be/vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:44
msgid ""
"Serial Peripheral Interface. See [here](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface) for more information."
msgstr ""

#: src/appendix/glossary.md:48
msgid "SVD"
msgstr ""

#: src/appendix/glossary.md:50
msgid ""
"System View Description is an XML file format used to describe the "
"programmers view of a microcontroller device. You can read more about it on "
"[the ARM CMSIS documentation site](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)."
msgstr ""

#: src/appendix/glossary.md:54
msgid "UART"
msgstr ""

#: src/appendix/glossary.md:56
msgid ""
"Universal asynchronous receiver-transmitter. See [here](https://"
"en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""

#: src/appendix/glossary.md:60
msgid "USART"
msgstr ""

#: src/appendix/glossary.md:62
msgid ""
"Universal synchronous and asynchronous receiver-transmitter. See [here]"
"(https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
