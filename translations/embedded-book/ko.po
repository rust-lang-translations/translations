msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-10-15T16:19:26+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:19:26+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1 src/intro/no-std.md:36
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:12 src/intro/index.md:1
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:13 src/SUMMARY.md:23 src/start/hardware.md:1
msgid "Hardware"
msgstr "하드웨어"

#: src/SUMMARY.md:14
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:15 src/intro/tooling.md:1
msgid "Tooling"
msgstr "도구"

#: src/SUMMARY.md:16
msgid "Installation"
msgstr "설치"

#: src/SUMMARY.md:17 src/intro/install/linux.md:1
msgid "Linux"
msgstr "리눅스"

#: src/SUMMARY.md:18
msgid "MacOS"
msgstr "맥OS"

#: src/SUMMARY.md:19 src/intro/install/windows.md:1
msgid "Windows"
msgstr "윈도우"

#: src/SUMMARY.md:20 src/intro/install/verify.md:1
msgid "Verify Installation"
msgstr "설치 확인"

#: src/SUMMARY.md:21
msgid "Getting started"
msgstr "시작하기"

#: src/SUMMARY.md:22 src/intro/install/windows.md:35 src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/SUMMARY.md:24
msgid "Memory-mapped Registers"
msgstr "메모리 매핑 레지스터"

#: src/SUMMARY.md:25 src/start/semihosting.md:1
msgid "Semihosting"
msgstr "세미호스팅"

#: src/SUMMARY.md:26 src/start/panicking.md:1
msgid "Panicking"
msgstr "패닉"

#: src/SUMMARY.md:27 src/start/exceptions.md:1
msgid "Exceptions"
msgstr "예외"

#: src/SUMMARY.md:28 src/intro/index.md:50 src/intro/index.md:64
#: src/start/interrupts.md:1
msgid "Interrupts"
msgstr "인터럽트"

#: src/SUMMARY.md:29 src/start/io.md:1
msgid "IO"
msgstr "입출력"

#: src/SUMMARY.md:30 src/peripherals/index.md:1
msgid "Peripherals"
msgstr "주변장치"

#: src/SUMMARY.md:31
msgid "A first attempt in Rust"
msgstr "Rust로 첫 번째 시도"

#: src/SUMMARY.md:32 src/peripherals/borrowck.md:13
msgid "The Borrow Checker"
msgstr "빌림 검사기"

#: src/SUMMARY.md:33 src/peripherals/singletons.md:1
msgid "Singletons"
msgstr "싱글톤"

#: src/SUMMARY.md:34 src/static-guarantees/index.md:1
msgid "Static Guarantees"
msgstr "정적 보장"

#: src/SUMMARY.md:35 src/static-guarantees/typestate-programming.md:1
msgid "Typestate Programming"
msgstr "타입 상태 프로그래밍"

#: src/SUMMARY.md:36 src/static-guarantees/state-machines.md:1
msgid "Peripherals as State Machines"
msgstr "상태 머신으로서의 주변장치"

#: src/SUMMARY.md:37 src/static-guarantees/design-contracts.md:1
msgid "Design Contracts"
msgstr "설계 계약"

#: src/SUMMARY.md:38 src/static-guarantees/zero-cost-abstractions.md:1
msgid "Zero Cost Abstractions"
msgstr "제로 비용 추상화"

#: src/SUMMARY.md:39 src/portability/index.md:1
msgid "Portability"
msgstr "이식성"

#: src/SUMMARY.md:40 src/concurrency/index.md:1
msgid "Concurrency"
msgstr "동시성"

#: src/SUMMARY.md:41 src/collections/index.md:1
msgid "Collections"
msgstr "컬렉션"

#: src/SUMMARY.md:42 src/design-patterns/index.md:1
msgid "Design Patterns"
msgstr "디자인 패턴"

#: src/SUMMARY.md:43
msgid "HALs"
msgstr "HAL"

#: src/SUMMARY.md:44
msgid "Checklist"
msgstr "체크리스트"

#: src/SUMMARY.md:45 src/design-patterns/hal/naming.md:1
msgid "Naming"
msgstr "명명"

#: src/SUMMARY.md:46 src/SUMMARY.md:51
#: src/design-patterns/hal/interoperability.md:1
#: src/interoperability/index.md:1
msgid "Interoperability"
msgstr "상호 운용성"

#: src/SUMMARY.md:47 src/design-patterns/hal/predictability.md:1
msgid "Predictability"
msgstr "예측 가능성"

#: src/SUMMARY.md:48
msgid "GPIO"
msgstr "GPIO"

#: src/SUMMARY.md:49 src/c-tips/index.md:1
msgid "Tips for embedded C developers"
msgstr "임베디드 C 개발자를 위한 팁"

#: src/SUMMARY.md:52 src/interoperability/c-with-rust.md:1
msgid "A little C with your Rust"
msgstr "Rust와 함께하는 약간의 C"

#: src/SUMMARY.md:53 src/interoperability/rust-with-c.md:1
msgid "A little Rust with your C"
msgstr "C와 함께하는 약간의 Rust"

#: src/SUMMARY.md:54 src/unsorted/index.md:1
msgid "Unsorted topics"
msgstr "미분류 주제"

#: src/SUMMARY.md:55
msgid "Optimizations: The speed size tradeoff"
msgstr "최적화: 속도와 크기의 트레이드오프"

#: src/SUMMARY.md:56
msgid "Performing Math Functionality"
msgstr "수학 기능 수행"

#: src/SUMMARY.md:60 src/appendix/glossary.md:1
msgid "Appendix A: Glossary"
msgstr "부록 A: 용어집"

#: src/intro/index.md:3
msgid ""
"Welcome to The Embedded Rust Book: An introductory book about using the Rust "
"Programming Language on \"Bare Metal\" embedded systems, such as "
"Microcontrollers."
msgstr ""
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."

#: src/intro/index.md:6
msgid "Who Embedded Rust is For"
msgstr "임베디드 Rust는 누구를 위한 것인가"

#: src/intro/index.md:7
msgid ""
"Embedded Rust is for everyone who wants to do embedded programming while "
"taking advantage of the higher-level concepts and safety guarantees the Rust "
"language provides. (See also [Who Rust Is For](https://doc.rust-lang.org/"
"book/ch00-00-introduction.html))"
msgstr ""
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"

#: src/intro/index.md:10
msgid "Scope"
msgstr "범위"

#: src/intro/index.md:12
msgid "The goals of this book are:"
msgstr "이 책의 목표는 다음과 같습니다:"

#: src/intro/index.md:14
msgid ""
"Get developers up to speed with embedded Rust development. i.e. How to set "
"up a development environment."
msgstr ""
"개발자들이 임베디드 Rust 개발에 빠르게 적응할 수 있도록 돕습니다. 즉, 개발 환경을 "
"설정하는 방법을 알려줍니다."

#: src/intro/index.md:17
msgid ""
"Share _current_ best practices about using Rust for embedded development. "
"i.e. How to best use Rust language features to write more correct embedded "
"software."
msgstr ""
"임베디드 개발에서 Rust를 사용하는 _현재의_ 모범 사례를 공유합니다. 즉, Rust 언어 "
"기능을 최대한 활용하여 더 정확한 임베디드 소프트웨어를 작성하는 방법을 알려줍니다."

#: src/intro/index.md:21
msgid ""
"Serve as a cookbook in some cases. e.g. How do I mix C and Rust in a single "
"project?"
msgstr ""
"경우에 따라서는 요리책 역할을 합니다. 예를 들어, 하나의 프로젝트에서 C와 Rust를 "
"어떻게 혼합할 수 있을까요?"

#: src/intro/index.md:24
msgid ""
"This book tries to be as general as possible but to make things easier for "
"both the readers and the writers it uses the ARM Cortex-M architecture in "
"all its examples. However, the book doesn't assume that the reader is "
"familiar with this particular architecture and explains details particular "
"to this architecture where required."
msgstr ""
"이 책은 가능한 한 일반적이려고 하지만 독자와 저자 모두에게 편의를 위해 모든 예제에서 "
"ARM Cortex-M 아키텍처를 사용합니다. 하지만 이 책은 독자가 이 특정 아키텍처에 "
"익숙하다고 가정하지 않으며, 필요한 경우 이 아키텍처에 특정한 세부사항을 설명합니다."

#: src/intro/index.md:30
msgid "Who This Book is For"
msgstr "이 책은 누구를 위한 것인가"

#: src/intro/index.md:31
msgid ""
"This book caters towards people with either some embedded background or some "
"Rust background, however we believe everybody curious about embedded Rust "
"programming can get something out of this book. For those without any prior "
"knowledge we suggest you read the \"Assumptions and Prerequisites\" section "
"and catch up on missing knowledge to get more out of the book and improve "
"your reading experience. You can check out the \"Other Resources\" section "
"to find resources on topics you might want to catch up on."
msgstr ""
"이 책은 임베디드 배경이나 Rust 배경을 가진 사람들을 대상으로 하지만, 임베디드 Rust "
"프로그래밍에 관심이 있는 모든 사람이 이 책에서 무언가를 얻을 수 있다고 믿습니다. "
"사전 지식이 없는 분들은 \"가정 및 전제 조건\" 섹션을 읽고 부족한 지식을 보충하여 "
"책을 더 잘 활용하고 읽기 경험을 향상시키기를 권합니다. \"기타 자료\" 섹션에서 "
"보충하고 싶은 주제에 대한 자료를 찾을 수 있습니다."

#: src/intro/index.md:37
msgid "Assumptions and Prerequisites"
msgstr "가정 및 전제 조건"

#: src/intro/index.md:39
msgid ""
"You are comfortable using the Rust Programming Language, and have written, "
"run, and debugged Rust applications on a desktop environment. You should "
"also be familiar with the idioms of the [2018 edition](https://doc.rust-"
"lang.org/edition-guide/) as this book targets Rust 2018."
msgstr ""
"Rust 프로그래밍 언어를 편안하게 사용할 수 있고, 데스크톱 환경에서 Rust 애플리케이션을 "
"작성, 실행, 디버깅해본 경험이 있어야 합니다. 또한 이 책은 Rust 2018을 대상으로 하므로 "
"[2018 에디션](https://doc.rust-lang.org/edition-guide/)의 관용구에도 익숙해야 합니다."

#: src/intro/index.md:46
msgid ""
"You are comfortable developing and debugging embedded systems in another "
"language such as C, C++, or Ada, and are familiar with concepts such as:"
msgstr ""
"C, C++, Ada와 같은 다른 언어로 임베디드 시스템을 개발하고 디버깅하는 데 익숙하며, "
"다음과 같은 개념들에 친숙해야 합니다:"

#: src/intro/index.md:48
msgid "Cross Compilation"
msgstr "크로스 컴파일"

#: src/intro/index.md:49 src/peripherals/index.md:32
msgid "Memory Mapped Peripherals"
msgstr "메모리 매핑 주변장치"

#: src/intro/index.md:51
msgid "Common interfaces such as I2C, SPI, Serial, etc."
msgstr "I2C, SPI, 시리얼 등과 같은 일반적인 인터페이스"

#: src/intro/index.md:53 src/c-tips/index.md:410
msgid "Other Resources"
msgstr "기타 자료"

#: src/intro/index.md:54
msgid ""
"If you are unfamiliar with anything mentioned above or if you want more "
"information about a specific topic mentioned in this book you might find "
"some of these resources helpful."
msgstr ""
"위에서 언급한 내용 중 익숙하지 않은 것이 있거나 이 책에서 언급된 특정 주제에 대한 "
"더 많은 정보를 원한다면 다음 자료들이 도움이 될 것입니다."

#: src/intro/index.md:56
msgid "Topic"
msgstr "주제"

#: src/intro/index.md:56
msgid "Resource"
msgstr "자료"

#: src/intro/index.md:56 src/peripherals/a-first-attempt.md:9
msgid "Description"
msgstr "설명"

#: src/intro/index.md:58
msgid "Rust"
msgstr "Rust"

#: src/intro/index.md:58
msgid "[Rust Book](https://doc.rust-lang.org/book/)"
msgstr "[Rust 책](https://doc.rust-lang.org/book/)"

#: src/intro/index.md:58
msgid ""
"If you are not yet comfortable with Rust, we highly suggest reading this "
"book."
msgstr ""
"아직 Rust에 익숙하지 않다면, 이 책을 읽어보시기를 강력히 권합니다."

#: src/intro/index.md:59 src/intro/index.md:60 src/intro/index.md:61
#: src/intro/index.md:62 src/intro/index.md:63
msgid "Rust, Embedded"
msgstr "Rust, 임베디드"

#: src/intro/index.md:59
msgid "[Discovery Book](https://docs.rust-embedded.org/discovery/)"
msgstr "[Discovery 책](https://docs.rust-embedded.org/discovery/)"

#: src/intro/index.md:59
msgid ""
"If you have never done any embedded programming, this book might be a better "
"start"
msgstr ""
"임베디드 프로그래밍을 한 번도 해본 적이 없다면, 이 책이 더 나은 시작점이 될 수 있습니다"

#: src/intro/index.md:60
msgid "[Embedded Rust Bookshelf](https://docs.rust-embedded.org)"
msgstr "[임베디드 Rust 서재](https://docs.rust-embedded.org)"

#: src/intro/index.md:60
msgid ""
"Here you can find several other resources provided by Rust's Embedded "
"Working Group."
msgstr ""
"여기서 Rust 임베디드 워킹 그룹에서 제공하는 여러 다른 자료들을 찾을 수 있습니다."

#: src/intro/index.md:61
msgid "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"
msgstr "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"

#: src/intro/index.md:61
msgid "The nitty gritty details when doing embedded programming in Rust."
msgstr "Rust로 임베디드 프로그래밍을 할 때의 세부적인 내용들."

#: src/intro/index.md:62
msgid "[embedded FAQ](https://docs.rust-embedded.org/faq.html)"
msgstr "[임베디드 FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/intro/index.md:62
msgid "Frequently asked questions about Rust in an embedded context."
msgstr "임베디드 환경에서 Rust에 대한 자주 묻는 질문들."

#: src/intro/index.md:63
msgid ""
"[Comprehensive Rust 🦀: Bare Metal](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"
msgstr ""
"[포괄적인 Rust 🦀: 베어 메탈](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"

#: src/intro/index.md:63
msgid "Teaching material for a 1-day class on bare-metal Rust development"
msgstr "베어 메탈 Rust 개발에 대한 1일 수업용 교육 자료"

#: src/intro/index.md:64
msgid "[Interrupt](https://en.wikipedia.org/wiki/Interrupt)"
msgstr "[인터럽트](https://en.wikipedia.org/wiki/Interrupt)"

#: src/intro/index.md:64 src/intro/index.md:65 src/intro/index.md:66
msgid "\\-"
msgstr "\\-"

#: src/intro/index.md:65
msgid "Memory-mapped IO/Peripherals"
msgstr "메모리 매핑 입출력/주변장치"

#: src/intro/index.md:65
msgid "[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"
msgstr "[메모리 매핑 입출력](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"

#: src/intro/index.md:66
msgid "SPI, UART, RS232, USB, I2C, TTL"
msgstr "SPI, UART, RS232, USB, I2C, TTL"

#: src/intro/index.md:66
msgid ""
"[Stack Exchange about SPI, UART, and other interfaces](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"
msgstr ""
"[SPI, UART 및 기타 인터페이스에 대한 Stack Exchange](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"

#: src/intro/index.md:68
msgid "Translations"
msgstr "번역"

#: src/intro/index.md:70
msgid ""
"This book has been translated by generous volunteers. If you would like your "
"translation listed here, please open a PR to add it."
msgstr ""
"이 책은 관대한 자원봉사자들에 의해 번역되었습니다. 여러분의 번역을 여기에 "
"나열하고 싶다면 PR을 열어 추가해 주세요."

#: src/intro/index.md:73
msgid ""
"[Japanese](https://tomoyuki-nakabayashi.github.io/book/) ([repository]"
"(https://github.com/tomoyuki-nakabayashi/book))"
msgstr ""
"[일본어](https://tomoyuki-nakabayashi.github.io/book/) ([저장소]"
"(https://github.com/tomoyuki-nakabayashi/book))"

#: src/intro/index.md:76
msgid ""
"[Chinese](https://xxchang.github.io/book/) ([repository](https://github.com/"
"XxChang/book))"
msgstr ""
"[중국어](https://xxchang.github.io/book/) ([저장소](https://github.com/"
"XxChang/book))"

#: src/intro/index.md:79
msgid "How to Use This Book"
msgstr "이 책을 사용하는 방법"

#: src/intro/index.md:81
msgid ""
"This book generally assumes that you’re reading it front-to-back. Later "
"chapters build on concepts in earlier chapters, and earlier chapters may not "
"dig into details on a topic, revisiting the topic in a later chapter."
msgstr ""
"이 책은 일반적으로 처음부터 끝까지 순서대로 읽는다고 가정합니다. 후반 "
"장들은 이전 장의 개념을 기반으로 하며, 이전 장에서는 주제에 대한 세부사항을 "
"깊이 다루지 않고 후반 장에서 다시 다룰 수 있습니다."

#: src/intro/index.md:85
msgid ""
"This book will be using the [STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) development board from "
"STMicroelectronics for the majority of the examples contained within. This "
"board is based on the ARM Cortex-M architecture, and while basic "
"functionality is the same across most CPUs based on this architecture, "
"peripherals and other implementation details of Microcontrollers are "
"different between different vendors, and often even different between "
"Microcontroller families from the same vendor."
msgstr ""
"이 책은 포함된 대부분의 예제에서 STMicroelectronics의 "
"[STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) 개발 보드를 사용할 것입니다. "
"이 보드는 ARM Cortex-M 아키텍처를 기반으로 하며, 이 아키텍처를 기반으로 한 "
"대부분의 CPU에서 기본 기능은 동일하지만, 마이크로컨트롤러의 주변장치와 기타 "
"구현 세부사항은 벤더마다 다르고, 종종 같은 벤더의 마이크로컨트롤러 패밀리 간에도 다릅니다."

#: src/intro/index.md:93
msgid ""
"For this reason, we suggest purchasing the [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html) development board for "
"the purpose of following the examples in this book."
msgstr ""
"이러한 이유로, 이 책의 예제를 따라하기 위해 "
"[STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html) "
"개발 보드를 구입하시기를 권합니다."

#: src/intro/index.md:98
msgid "Contributing to This Book"
msgstr "이 책에 기여하기"

#: src/intro/index.md:100
msgid ""
"The work on this book is coordinated in [this repository](https://github.com/"
"rust-embedded/book) and is mainly developed by the [resources team](https://"
"github.com/rust-embedded/wg#the-resources-team)."
msgstr ""
"이 책의 작업은 [이 저장소](https://github.com/"
"rust-embedded/book)에서 조정되며 주로 [리소스 팀](https://"
"github.com/rust-embedded/wg#the-resources-team)에서 개발됩니다."

#: src/intro/index.md:106
msgid ""
"If you have trouble following the instructions in this book or find that "
"some section of the book is not clear enough or hard to follow then that's a "
"bug and it should be reported in [the issue tracker](https://github.com/rust-"
"embedded/book/issues/) of this book."
msgstr ""
"이 책의 지침을 따르는 데 문제가 있거나 책의 일부 섹션이 충분히 명확하지 않거나 "
"따라하기 어렵다면 그것은 버그이며 이 책의 [이슈 트래커](https://github.com/rust-"
"embedded/book/issues/)에 보고해야 합니다."

#: src/intro/index.md:112
msgid "Pull requests fixing typos and adding new content are very welcome!"
msgstr "오타를 수정하고 새로운 내용을 추가하는 풀 리퀘스트는 매우 환영합니다!"

#: src/intro/index.md:114
msgid "Re-using this material"
msgstr "이 자료 재사용하기"

#: src/intro/index.md:116
msgid "This book is distributed under the following licenses:"
msgstr "이 책은 다음 라이선스 하에 배포됩니다:"

#: src/intro/index.md:118
msgid ""
"The code samples and free-standing Cargo projects contained within this book "
"are licensed under the terms of both the [MIT License](https://"
"opensource.org/licenses/MIT) and the [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0)."
msgstr ""
"이 책에 포함된 코드 샘플과 독립적인 Cargo 프로젝트는 [MIT 라이선스](https://"
"opensource.org/licenses/MIT)와 [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0) 조건 하에 라이선스됩니다."

#: src/intro/index.md:119
msgid ""
"The written prose, pictures and diagrams contained within this book are "
"licensed under the terms of the Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) license."
msgstr ""
"이 책에 포함된 글, 그림, 다이어그램은 크리에이티브 커먼즈 [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) 라이선스의 조건 하에 라이선스됩니다."

#: src/intro/index.md:125
msgid "TL;DR: If you want to use our text or images in your work, you need to:"
msgstr "요약: 작업에서 우리의 텍스트나 이미지를 사용하려면 다음이 필요합니다:"

#: src/intro/index.md:127
msgid ""
"Give the appropriate credit (i.e. mention this book on your slide, and "
"provide a link to the relevant page)"
msgstr ""
"적절한 크레딧을 제공하세요 (즉, 슬라이드에 이 책을 언급하고 관련 페이지에 대한 "
"링크를 제공하세요)"

#: src/intro/index.md:128
msgid ""
"Provide a link to the [CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) licence"
msgstr ""
"[CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) 라이선스에 대한 링크를 제공하세요"

#: src/intro/index.md:129
msgid ""
"Indicate if you have changed the material in any way, and make any changes "
"to our material available under the same licence"
msgstr ""
"자료를 어떤 방식으로든 변경했는지 표시하고, 우리 자료에 대한 모든 변경사항을 "
"동일한 라이선스 하에 제공하세요"

#: src/intro/index.md:131
msgid "Also, please do let us know if you find this book useful!"
msgstr "또한 이 책이 유용하다고 생각하시면 알려주세요!"

#: src/intro/hardware.md:1
msgid "Meet Your Hardware"
msgstr "하드웨어 소개"

#: src/intro/hardware.md:3
msgid "Let's get familiar with the hardware we'll be working with."
msgstr "우리가 작업할 하드웨어에 익숙해져 봅시다."

#: src/intro/hardware.md:5
msgid "STM32F3DISCOVERY (the \"F3\")"
msgstr "STM32F3DISCOVERY (\"F3\")"

#: src/intro/hardware.md:11
msgid "What does this board contain?"
msgstr "이 보드에는 무엇이 포함되어 있나요?"

#: src/intro/hardware.md:13
msgid ""
"A [STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"microcontroller. This microcontroller has"
msgstr ""
"[STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"마이크로컨트롤러. 이 마이크로컨트롤러는 다음을 가지고 있습니다"

#: src/intro/hardware.md:14
msgid ""
"A single-core ARM Cortex-M4F processor with hardware support for single-"
"precision floating point operations and a maximum clock frequency of 72 MHz."
msgstr ""
"단정밀도 부동소수점 연산을 위한 하드웨어 지원과 최대 72MHz의 클록 주파수를 가진 "
"단일 코어 ARM Cortex-M4F 프로세서."

#: src/intro/hardware.md:17
msgid "256 KiB of \"Flash\" memory. (1 KiB = 10**24** bytes)"
msgstr "256 KiB의 \"플래시\" 메모리. (1 KiB = 10**24** 바이트)"

#: src/intro/hardware.md:19
msgid "48 KiB of RAM."
msgstr "48 KiB의 RAM."

#: src/intro/hardware.md:21
msgid "A variety of integrated peripherals such as timers, I2C, SPI and USART."
msgstr "타이머, I2C, SPI, USART와 같은 다양한 통합 주변장치."

#: src/intro/hardware.md:23
msgid ""
"General purpose Input Output (GPIO) and other types of pins accessible "
"through the two rows of headers along side the board."
msgstr ""
"보드 양쪽의 두 줄의 헤더를 통해 접근할 수 있는 범용 입출력(GPIO) 및 기타 유형의 핀."

#: src/intro/hardware.md:25
msgid "A USB interface accessible through the USB port labeled \"USB USER\"."
msgstr "\"USB USER\"라고 표시된 USB 포트를 통해 접근할 수 있는 USB 인터페이스."

#: src/intro/hardware.md:27
msgid ""
"An [accelerometer](https://en.wikipedia.org/wiki/Accelerometer) as part of "
"the [LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"칩의 일부인 [가속도계](https://en.wikipedia.org/wiki/Accelerometer)."

#: src/intro/hardware.md:29
msgid ""
"A [magnetometer](https://en.wikipedia.org/wiki/Magnetometer) as part of the "
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"칩의 일부인 [자력계](https://en.wikipedia.org/wiki/Magnetometer)."

#: src/intro/hardware.md:31
msgid ""
"A [gyroscope](https://en.wikipedia.org/wiki/Gyroscope) as part of the "
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) chip."
msgstr ""
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) "
"칩의 일부인 [자이로스코프](https://en.wikipedia.org/wiki/Gyroscope)."

#: src/intro/hardware.md:33
msgid "8 user LEDs arranged in the shape of a compass."
msgstr "나침반 모양으로 배열된 8개의 사용자 LED."

#: src/intro/hardware.md:35
msgid ""
"A second microcontroller: a [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). This microcontroller is actually part of "
"an on-board programmer / debugger and is connected to the USB port named "
"\"USB ST-LINK\"."
msgstr ""
"두 번째 마이크로컨트롤러: [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). 이 마이크로컨트롤러는 실제로 "
"온보드 프로그래머/디버거의 일부이며 \"USB ST-LINK\"라는 이름의 USB 포트에 연결되어 있습니다."

#: src/intro/hardware.md:37
msgid ""
"For a more detailed list of features and further specifications of the board "
"take a look at the [STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) website."
msgstr ""
"보드의 더 자세한 기능 목록과 추가 사양은 "
"[STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) 웹사이트를 참조하세요."

#: src/intro/hardware.md:39
msgid ""
"A word of caution: be careful if you want to apply external signals to the "
"board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 "
"volts. For further information consult the [6.2 Absolute maximum ratings "
"section in the manual](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)"
msgstr ""
"주의사항: 보드에 외부 신호를 적용하려는 경우 주의하세요. "
"마이크로컨트롤러 STM32F303VCT6 핀은 3.3볼트의 정격 전압을 사용합니다. "
"자세한 정보는 [매뉴얼의 6.2 절대 최대 정격 섹션](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)을 참조하세요"

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr "`no_std` Rust 환경"

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://"
"en.wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""
"임베디드 프로그래밍이라는 용어는 다양한 종류의 프로그래밍 클래스에 사용됩니다. "
"몇 KB의 RAM과 ROM만을 가진 8비트 MCU([ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)와 같은) 프로그래밍부터 "
"32/64비트 4코어 Cortex-A53 @ 1.4 GHz와 1GB RAM을 가진 라즈베리 파이([Model B 3+]"
"(https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications))와 같은 시스템까지 다양합니다. "
"어떤 종류의 대상과 사용 사례를 가지고 있는지에 따라 코드를 작성할 때 다른 제한사항/한계가 적용됩니다."

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr "임베디드 프로그래밍에는 두 가지 일반적인 분류가 있습니다:"

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr "호스트 환경"

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""
"이런 종류의 환경은 일반적인 PC 환경과 유사합니다. 이는 파일 시스템, 네트워킹, "
"메모리 관리, 스레드 등과 같은 다양한 시스템과 상호작용할 수 있는 기본 요소를 제공하는 "
"시스템 인터페이스 [예: POSIX](https://en.wikipedia.org/wiki/POSIX)가 제공된다는 의미입니다. "
"표준 라이브러리는 일반적으로 이러한 기본 요소에 의존하여 기능을 구현합니다. "
"또한 어떤 종류의 sysroot와 RAM/ROM 사용량 제한, 그리고 아마도 일부 특수 HW나 I/O가 있을 수 있습니다. "
"전반적으로 특수 목적 PC 환경에서 코딩하는 것처럼 느껴집니다."

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr "베어 메탈 환경"

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""
"베어 메탈 환경에서는 프로그램 이전에 로드된 코드가 없습니다. "
"OS에서 제공하는 소프트웨어 없이는 표준 라이브러리를 로드할 수 없습니다. "
"대신 프로그램은 사용하는 크레이트와 함께 하드웨어(베어 메탈)만을 사용하여 실행할 수 있습니다. "
"Rust가 표준 라이브러리를 로드하는 것을 방지하려면 `no_std`를 사용하세요. "
"표준 라이브러리의 플랫폼 독립적인 부분은 [libcore](https://doc.rust-lang.org/core/)를 통해 사용할 수 있습니다. "
"libcore는 또한 임베디드 환경에서 항상 바람직하지 않은 것들을 제외합니다. "
"이러한 것들 중 하나는 동적 메모리 할당을 위한 메모리 할당자입니다. "
"이것이나 다른 기능이 필요한 경우 이를 제공하는 크레이트가 종종 있습니다."

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr "libstd 런타임"

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""
"앞서 언급했듯이 [libstd](https://doc.rust-lang.org/std/)를 사용하려면 "
"어떤 종류의 시스템 통합이 필요하지만, 이는 [libstd](https://doc.rust-lang.org/std/)가 "
"단순히 OS 추상화에 접근하는 일반적인 방법을 제공하기 때문만이 아니라 런타임도 제공하기 때문입니다. "
"이 런타임은 무엇보다도 스택 오버플로 보호 설정, 명령줄 인수 처리, "
"프로그램의 main 함수가 호출되기 전에 메인 스레드 생성을 담당합니다. "
"이 런타임은 `no_std` 환경에서도 사용할 수 없습니다."

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://"
"doc.rust-lang.org/core/) crate in turn is a platform-agnostic subset of the "
"std crate which makes no assumptions about the system the program will run "
"on. As such, it provides APIs for language primitives like floats, strings "
"and slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr "`#![no_std]`는 크레이트가 std-크레이트 대신 core-크레이트에 링크될 것임을 나타내는 크레이트 수준 속성입니다. [libcore](https://doc.rust-lang.org/core/) 크레이트는 프로그램이 실행될 시스템에 대해 어떠한 가정도 하지 않는 std 크레이트의 플랫폼 독립적인 하위 집합입니다. 따라서 부동 소수점, 문자열 및 슬라이스와 같은 언어 기본 요소에 대한 API와 원자적 연산 및 SIMD 명령어와 같은 프로세서 기능을 노출하는 API를 제공합니다. 그러나 플랫폼 통합과 관련된 모든 것에 대한 API는 부족합니다. 이러한 속성 때문에 no_std 및 [libcore](https://doc.rust-lang.org/core/) 코드는 부트로더, 펌웨어 또는 커널과 같은 모든 종류의 부트스트래핑(단계 0) 코드에 사용될 수 있습니다."

#: src/intro/no-std.md:45 src/intro/tooling.md:58
msgid "Overview"
msgstr "개요"

#: src/intro/no-std.md:47
msgid "feature"
msgstr "기능"

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr "no_std"

#: src/intro/no-std.md:47
msgid "std"
msgstr "std"

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr "힙 (동적 메모리)"

#: src/intro/no-std.md:49
msgid "\\*"
msgstr "\\*"

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "✓"
msgstr "✓"

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr "컬렉션 (Vec, BTreeMap 등)"

#: src/intro/no-std.md:50
msgid "\\**"
msgstr "\\**"

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr "스택 오버플로 보호"

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "✘"
msgstr "✘"

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr "main 이전에 초기화 코드 실행"

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr "libstd 사용 가능"

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr "libcore 사용 가능"

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr "펌웨어, 커널 또는 부트로더 코드 작성"

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr "* `alloc` 크레이트를 사용하고 [alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)과 같은 적절한 할당자를 사용하는 경우에만 해당됩니다."

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr "** `collections` 크레이트를 사용하고 전역 기본 할당자를 구성하는 경우에만 해당됩니다."

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr "** 안전한 난수 생성기가 부족하여 HashMap 및 HashSet을 사용할 수 없습니다."

#: src/intro/no-std.md:65
msgid "See Also"
msgstr "참조"

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr "[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)"

#: src/intro/tooling.md:3
msgid ""
"Dealing with microcontrollers involves using several different tools as "
"we'll be dealing with an architecture different than your laptop's and we'll "
"have to run and debug programs on a _remote_ device."
msgstr "마이크로컨트롤러를 다루는 것은 여러 가지 다른 도구를 사용하는 것을 포함합니다. 이는 노트북과는 다른 아키텍처를 다루고 _원격_ 장치에서 프로그램을 실행하고 디버깅해야 하기 때문입니다."

#: src/intro/tooling.md:7
msgid ""
"We'll use all the tools listed below. Any recent version should work when a "
"minimum version is not specified, but we have listed the versions we have "
"tested."
msgstr "아래 나열된 모든 도구를 사용할 것입니다. 최소 버전이 지정되지 않은 경우 최신 버전은 모두 작동해야 하지만, 저희가 테스트한 버전을 나열했습니다."

#: src/intro/tooling.md:11
msgid ""
"Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation "
"support."
msgstr "Rust 1.31, 1.31-beta 또는 더 새로운 툴체인 + ARM Cortex-M 컴파일 지원."

#: src/intro/tooling.md:13
msgid ""
"[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"
msgstr "[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"

#: src/intro/tooling.md:14
msgid "[`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0"
msgstr "[`qemu-system-arm`](https://www.qemu.org/). 테스트 버전: 3.0.0"

#: src/intro/tooling.md:15
msgid "OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0"
msgstr "OpenOCD >=0.8. 테스트 버전: v0.9.0 및 v0.10.0"

#: src/intro/tooling.md:16
msgid ""
"GDB with ARM support. Version 7.12 or newer highly recommended. Tested "
"versions: 7.10, 7.11, 7.12 and 8.1"
msgstr "ARM 지원 GDB. 버전 7.12 이상을 강력히 권장합니다. 테스트 버전: 7.10, 7.11, 7.12 및 8.1"

#: src/intro/tooling.md:18
msgid ""
"[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) or "
"`git`. These tools are optional but will make it easier to follow along with "
"the book."
msgstr "[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) 또는 `git`. 이 도구들은 선택 사항이지만 책을 따라하기 쉽게 해줄 것입니다."

#: src/intro/tooling.md:21
msgid ""
"The text below explains why we are using these tools. Installation "
"instructions can be found on the next page."
msgstr "아래 텍스트는 이러한 도구를 사용하는 이유를 설명합니다. 설치 지침은 다음 페이지에서 찾을 수 있습니다."

#: src/intro/tooling.md:24
msgid "`cargo-generate` OR `git`"
msgstr "`cargo-generate` 또는 `git`"

#: src/intro/tooling.md:26
msgid ""
"Bare metal programs are non-standard (`no_std`) Rust programs that require "
"some adjustments to the linking process in order to get the memory layout of "
"the program right. This requires some additional files (like linker scripts) "
"and settings (like linker flags). We have packaged those for you in a "
"template such that you only need to fill in the missing information (such as "
"the project name and the characteristics of your target hardware)."
msgstr "베어 메탈 프로그램은 프로그램의 메모리 레이아웃을 올바르게 얻기 위해 링크 프로세스에 일부 조정이 필요한 비표준(`no_std`) Rust 프로그램입니다. 이를 위해서는 일부 추가 파일(링커 스크립트 등) 및 설정(링커 플래그 등)이 필요합니다. 저희는 이러한 것들을 템플릿으로 패키징하여 프로젝트 이름 및 대상 하드웨어의 특성과 같은 누락된 정보만 채우면 됩니다."

#: src/intro/tooling.md:33
msgid ""
"Our template is compatible with `cargo-generate`: a Cargo subcommand for "
"creating new Cargo projects from templates. You can also download the "
"template using `git`, `curl`, `wget`, or your web browser."
msgstr "저희 템플릿은 템플릿에서 새 Cargo 프로젝트를 생성하기 위한 Cargo 하위 명령인 `cargo-generate`와 호환됩니다. `git`, `curl`, `wget` 또는 웹 브라우저를 사용하여 템플릿을 다운로드할 수도 있습니다."

#: src/intro/tooling.md:37 src/intro/install.md:59
msgid "`cargo-binutils`"
msgstr "`cargo-binutils`"

#: src/intro/tooling.md:39
msgid ""
"`cargo-binutils` is a collection of Cargo subcommands that make it easy to "
"use the LLVM tools that are shipped with the Rust toolchain. These tools "
"include the LLVM versions of `objdump`, `nm` and `size` and are used for "
"inspecting binaries."
msgstr "`cargo-binutils`는 Rust 툴체인과 함께 제공되는 LLVM 도구를 쉽게 사용할 수 있도록 하는 Cargo 하위 명령 모음입니다. 이 도구에는 `objdump`, `nm`, `size`의 LLVM 버전이 포함되어 있으며 바이너리를 검사하는 데 사용됩니다."

#: src/intro/tooling.md:44
msgid ""
"The advantage of using these tools over GNU binutils is that (a) installing "
"the LLVM tools is the same one-command installation (`rustup component add "
"llvm-tools`) regardless of your OS and (b) tools like `objdump` support all "
"the architectures that `rustc` supports -- from ARM to x86_64 -- because "
"they both share the same LLVM backend."
msgstr "GNU binutils 대신 이 도구를 사용하는 장점은 (a) LLVM 도구 설치가 OS에 관계없이 동일한 단일 명령 설치(`rustup component add llvm-tools`)이며 (b) `objdump`와 같은 도구는 ARM에서 x86_64까지 `rustc`가 지원하는 모든 아키텍처를 지원한다는 것입니다. 이는 둘 다 동일한 LLVM 백엔드를 공유하기 때문입니다."

#: src/intro/tooling.md:50
msgid "`qemu-system-arm`"
msgstr "`qemu-system-arm`"

#: src/intro/tooling.md:52
msgid ""
"QEMU is an emulator. In this case we use the variant that can fully emulate "
"ARM systems. We use QEMU to run embedded programs on the host. Thanks to "
"this you can follow some parts of this book even if you don't have any "
"hardware with you!"
msgstr "QEMU는 에뮬레이터입니다. 이 경우 ARM 시스템을 완전히 에뮬레이션할 수 있는 변형을 사용합니다. QEMU를 사용하여 호스트에서 임베디드 프로그램을 실행합니다. 덕분에 하드웨어가 없어도 이 책의 일부를 따라할 수 있습니다!"

#: src/intro/tooling.md:56
msgid "Tooling for Embedded Rust Debugging"
msgstr "임베디드 Rust 디버깅을 위한 도구"

#: src/intro/tooling.md:60
msgid ""
"Debugging embedded systems in Rust requires specialized tools including "
"software to manage the debugging process, debuggers to inspect and control "
"program execution, and hardware probes to facilitate interaction between the "
"host and the embedded device. This document outlines essential software "
"tools like Probe-rs and OpenOCD, which simplify and support the debugging "
"process, alongside prominent debuggers such as GDB and the Probe-rs Visual "
"Studio Code extension. Additionally, it covers key hardware probes such as "
"Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective "
"debugging and programming of embedded devices."
msgstr "Rust에서 임베디드 시스템을 디버깅하려면 디버깅 프로세스를 관리하는 소프트웨어, 프로그램 실행을 검사하고 제어하는 디버거, 호스트와 임베디드 장치 간의 상호 작용을 용이하게 하는 하드웨어 프로브를 포함한 전문 도구가 필요합니다. 이 문서는 디버깅 프로세스를 단순화하고 지원하는 Probe-rs 및 OpenOCD와 같은 필수 소프트웨어 도구와 GDB 및 Probe-rs Visual Studio Code 확장과 같은 주요 디버거를 설명합니다. 또한 Rusty-probe, ST-Link, J-Link 및 MCU-Link와 같은 주요 하드웨어 프로브를 다루며, 이는 임베디드 장치의 효과적인 디버깅 및 프로그래밍에 필수적입니다."

#: src/intro/tooling.md:62
msgid "Software that drives debugging tools"
msgstr "디버깅 도구를 구동하는 소프트웨어"

#: src/intro/tooling.md:64
msgid "Probe-rs"
msgstr "Probe-rs"

#: src/intro/tooling.md:66
msgid ""
"Probe-rs is a modern, Rust-focused software designed to work with debuggers "
"in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in "
"mind and aims to reduce the configuration burden often found in other "
"debugging solutions. It supports various probes and targets, providing a "
"high-level interface for interacting with embedded hardware. Probe-rs "
"integrates directly with Rust tooling, and integrates with Visual Studio "
"Code through its extension, allowing developers to streamline their "
"debugging workflow."
msgstr "Probe-rs는 임베디드 시스템의 디버거와 함께 작동하도록 설계된 현대적인 Rust 중심 소프트웨어입니다. OpenOCD와 달리 Probe-rs는 단순성을 염두에 두고 구축되었으며 다른 디버깅 솔루션에서 흔히 볼 수 있는 구성 부담을 줄이는 것을 목표로 합니다. 다양한 프로브와 타겟을 지원하며 임베디드 하드웨어와 상호 작용하기 위한 고수준 인터페이스를 제공합니다. Probe-rs는 Rust 툴링과 직접 통합되며 확장을 통해 Visual Studio Code와 통합되어 개발자가 디버깅 워크플로를 간소화할 수 있습니다."

#: src/intro/tooling.md:69
msgid "OpenOCD (Open On-Chip Debugger)"
msgstr "OpenOCD (오픈 온칩 디버거)"

#: src/intro/tooling.md:71
msgid ""
"OpenOCD is an open-source software tool used for debugging, testing, and "
"programming embedded systems. It provides an interface between the host "
"system and embedded hardware, supporting various transport layers like JTAG "
"and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a "
"debugger. OpenOCD is widely supported, with extensive documentation and a "
"large community, but may require complex configuration, especially for "
"custom embedded setups."
msgstr "OpenOCD는 임베디드 시스템 디버깅, 테스트 및 프로그래밍에 사용되는 오픈 소스 소프트웨어 도구입니다. 호스트 시스템과 임베디드 하드웨어 간의 인터페이스를 제공하며 JTAG 및 SWD(Serial Wire Debug)와 같은 다양한 전송 계층을 지원합니다. OpenOCD는 디버거인 GDB와 통합됩니다. OpenOCD는 광범위한 문서와 대규모 커뮤니티를 통해 널리 지원되지만, 특히 사용자 정의 임베디드 설정의 경우 복잡한 구성이 필요할 수 있습니다."

#: src/intro/tooling.md:73
msgid "Debuggers"
msgstr "디버거"

#: src/intro/tooling.md:75
msgid ""
"A debugger allows developers to inspect and control the execution of a "
"program in order to identify and correct errors or bugs. It provides "
"functionalities such as setting breakpoints, stepping through code line by "
"line, and examining the values of variables and memory states. Debuggers are "
"essential for thorough software development and maintenance, enabling "
"developers to ensure that their code behaves as intended under various "
"conditions."
msgstr "디버거는 개발자가 오류나 버그를 식별하고 수정하기 위해 프로그램 실행을 검사하고 제어할 수 있도록 합니다. 중단점 설정, 코드 한 줄씩 실행, 변수 값 및 메모리 상태 검사와 같은 기능을 제공합니다. 디버거는 철저한 소프트웨어 개발 및 유지 관리에 필수적이며, 개발자가 다양한 조건에서 코드가 의도한 대로 작동하는지 확인할 수 있도록 합니다."

#: src/intro/tooling.md:77
msgid "Debuggers know how to:"
msgstr "디버거는 다음을 수행하는 방법을 알고 있습니다:"

#: src/intro/tooling.md:78
msgid "Interact with the memory mapped registers."
msgstr "메모리 매핑 레지스터와 상호 작용합니다."

#: src/intro/tooling.md:79
msgid "Set Breakpoints/Watchpoints."
msgstr "중단점/감시점 설정."

#: src/intro/tooling.md:80
msgid "Read and write to the memory mapped registers."
msgstr "메모리 매핑 레지스터를 읽고 씁니다."

#: src/intro/tooling.md:81
msgid "Detect when the MCU has been halted for a debug event."
msgstr "디버그 이벤트로 인해 MCU가 중단되었을 때 감지합니다."

#: src/intro/tooling.md:82
msgid "Continue MCU execution after a debug event has been encountered."
msgstr "디버그 이벤트가 발생한 후 MCU 실행을 계속합니다."

#: src/intro/tooling.md:83
msgid "Erase and write to the microcontroller's FLASH."
msgstr "마이크로컨트롤러의 FLASH를 지우고 씁니다."

#: src/intro/tooling.md:85
msgid "Probe-rs Visual Studio Code Extension"
msgstr "Probe-rs Visual Studio Code 확장"

#: src/intro/tooling.md:87
msgid ""
"Probe-rs has a Visual Studio Code extension, providing a seamless debugging "
"experience without extensive setup. Through this connection, developers can "
"use Rust-specific features like pretty printing and detailed error messages, "
"ensuring that their debugging process aligns with the Rust ecosystem."
msgstr "Probe-rs는 Visual Studio Code 확장을 제공하여 광범위한 설정 없이 원활한 디버깅 경험을 제공합니다. 이 연결을 통해 개발자는 예쁜 출력 및 자세한 오류 메시지와 같은 Rust 특정 기능을 사용하여 디버깅 프로세스가 Rust 생태계와 일치하도록 할 수 있습니다."

#: src/intro/tooling.md:89
msgid "GDB (GNU Debugger)"
msgstr "GDB (GNU 디버거)"

#: src/intro/tooling.md:91
msgid ""
"GDB is a versatile debugging tool that allows developers to examine the "
"state of programs while they run or after they crash. For embedded Rust, GDB "
"connects to the target system via OpenOCD or other debugging servers to "
"interact with the embedded code. GDB is highly configurable and supports "
"features like remote debugging, variable inspection, and conditional "
"breakpoints. It can be used on a variety of platforms, and has extensive "
"support for Rust-specific debugging needs, such as pretty printing and "
"integration with IDEs."
msgstr "GDB는 개발자가 프로그램 실행 중 또는 충돌 후 프로그램 상태를 검사할 수 있도록 하는 다목적 디버깅 도구입니다. 임베디드 Rust의 경우 GDB는 OpenOCD 또는 다른 디버깅 서버를 통해 대상 시스템에 연결하여 임베디드 코드와 상호 작용합니다. GDB는 고도로 구성 가능하며 원격 디버깅, 변수 검사 및 조건부 중단점과 같은 기능을 지원합니다. 다양한 플랫폼에서 사용할 수 있으며 예쁜 출력 및 IDE 통합과 같은 Rust 특정 디버깅 요구 사항에 대한 광범위한 지원을 제공합니다."

#: src/intro/tooling.md:94
msgid "Probes"
msgstr "프로브"

#: src/intro/tooling.md:96
msgid ""
"A hardware probe is a device used in the development and debugging of "
"embedded systems to facilitate communication between a host computer and the "
"target embedded device. It typically supports protocols like JTAG or SWD, "
"enabling it to program, debug, and analyze the microcontroller or "
"microprocessor on the embedded system. Hardware probes are crucial for "
"developers to set breakpoints, step through code, and inspect memory and "
"processor registers, effectively allowing them to diagnose and fix issues in "
"real-time."
msgstr "하드웨어 프로브는 호스트 컴퓨터와 대상 임베디드 장치 간의 통신을 용이하게 하기 위해 임베디드 시스템 개발 및 디버깅에 사용되는 장치입니다. 일반적으로 JTAG 또는 SWD와 같은 프로토콜을 지원하여 임베디드 시스템의 마이크로컨트롤러 또는 마이크로프로세서를 프로그래밍, 디버깅 및 분석할 수 있습니다. 하드웨어 프로브는 개발자가 중단점을 설정하고, 코드를 단계별로 실행하고, 메모리 및 프로세서 레지스터를 검사하여 실시간으로 문제를 진단하고 해결할 수 있도록 하는 데 중요합니다."

#: src/intro/tooling.md:98
msgid "Rusty-probe"
msgstr "Rusty-probe"

#: src/intro/tooling.md:100
msgid ""
"Rusty-probe is an open-sourced USB-based hardware debugging probe designed "
"to work with probe-rs. The combination of Rusty-Probe and probe-rs provides "
"an easy-to-use, cost-effective solution for developers working with embedded "
"Rust applications."
msgstr "Rusty-probe는 probe-rs와 함께 작동하도록 설계된 오픈 소스 USB 기반 하드웨어 디버깅 프로브입니다. Rusty-Probe와 probe-rs의 조합은 임베디드 Rust 애플리케이션을 개발하는 개발자를 위한 사용하기 쉽고 비용 효율적인 솔루션을 제공합니다."

#: src/intro/tooling.md:102
msgid "ST-Link"
msgstr "ST-Link"

#: src/intro/tooling.md:104
msgid ""
"The ST-Link is a popular debugging and programming probe developed by "
"STMicroelectronics primarily for their STM32 and STM8 microcontroller "
"series. It supports both debugging and programming via JTAG or SWD (Serial "
"Wire Debug) interfaces. ST-Link is widely used due to its direct support "
"from STMicroelectronics' extensive range of development boards and its "
"integration into major IDEs, making it a convenient choice for developers "
"working with STM microcontrollers."
msgstr "ST-Link는 STMicroelectronics에서 주로 STM32 및 STM8 마이크로컨트롤러 시리즈를 위해 개발한 인기 있는 디버깅 및 프로그래밍 프로브입니다. JTAG 또는 SWD(Serial Wire Debug) 인터페이스를 통해 디버깅 및 프로그래밍을 모두 지원합니다. ST-Link는 STMicroelectronics의 광범위한 개발 보드에서 직접 지원하고 주요 IDE에 통합되어 STM 마이크로컨트롤러를 사용하는 개발자에게 편리한 선택이므로 널리 사용됩니다."

#: src/intro/tooling.md:106
msgid "J-Link"
msgstr "J-Link"

#: src/intro/tooling.md:108
msgid ""
"J-Link, developed by SEGGER Microcontroller, is a robust and versatile "
"debugger supporting a wide range of CPU cores and devices beyond just ARM, "
"such as RISC-V. Known for its high performance and reliability, J-Link "
"supports various communication interfaces, including JTAG, SWD, and fine-"
"pitch JTAG interfaces. It is favored for its advanced features like "
"unlimited breakpoints in flash memory and its compatibility with a multitude "
"of development environments."
msgstr "SEGGER Microcontroller에서 개발한 J-Link는 RISC-V와 같은 ARM 외에도 광범위한 CPU 코어 및 장치를 지원하는 강력하고 다재다능한 디버거입니다. 고성능과 신뢰성으로 유명한 J-Link는 JTAG, SWD 및 미세 피치 JTAG 인터페이스를 포함한 다양한 통신 인터페이스를 지원합니다. 플래시 메모리의 무제한 중단점과 다양한 개발 환경과의 호환성과 같은 고급 기능으로 선호됩니다."

#: src/intro/tooling.md:110
msgid "MCU-Link"
msgstr "MCU-Link"

#: src/intro/tooling.md:112
msgid ""
"MCU-Link is a debugging probe that also functions as a programmer, provided "
"by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers "
"and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-"
"Link is particularly notable for its versatility and affordability, making "
"it an accessible option for hobbyists, educators, and professional "
"developers alike."
msgstr "MCU-Link는 NXP Semiconductors에서 제공하는 프로그래머 역할도 하는 디버깅 프로브입니다. 다양한 ARM Cortex 마이크로컨트롤러를 지원하며 MCUXpresso IDE와 같은 개발 도구와 원활하게 인터페이스합니다. MCU-Link는 특히 다용도성과 경제성으로 유명하여 취미 개발자, 교육자 및 전문 개발자 모두에게 접근 가능한 옵션입니다."

#: src/intro/install.md:1
msgid "Installing the tools"
msgstr "도구 설치"

#: src/intro/install.md:3
msgid ""
"This page contains OS-agnostic installation instructions for a few of the "
"tools:"
msgstr "이 페이지에는 몇 가지 도구에 대한 OS 독립적인 설치 지침이 포함되어 있습니다:"

#: src/intro/install.md:5
msgid "Rust Toolchain"
msgstr "Rust 툴체인"

#: src/intro/install.md:7
msgid ""
"Install rustup by following the instructions at [https://rustup.rs](https://"
"rustup.rs)."
msgstr "[https://rustup.rs](https://rustup.rs)의 지침에 따라 rustup을 설치하세요."

#: src/intro/install.md:9
msgid ""
"**NOTE** Make sure you have a compiler version equal to or newer than "
"`1.31`. `rustc -V` should return a date newer than the one shown below."
msgstr "**참고** 컴파일러 버전이 `1.31` 이상인지 확인하세요. `rustc -V`는 아래 표시된 날짜보다 최신 날짜를 반환해야 합니다."

#: src/intro/install.md:17
msgid ""
"For bandwidth and disk usage concerns the default installation only supports "
"native compilation. To add cross compilation support for the ARM Cortex-M "
"architectures choose one of the following compilation targets. For the "
"STM32F3DISCOVERY board used for the examples in this book, use the "
"`thumbv7em-none-eabihf` target. [Find the best Cortex-M for you.](https://"
"developer.arm.com/ip-products/processors/cortex-"
"m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"
msgstr "대역폭 및 디스크 사용량 문제로 인해 기본 설치는 네이티브 컴파일만 지원합니다. ARM Cortex-M 아키텍처에 대한 크로스 컴파일 지원을 추가하려면 다음 컴파일 대상 중 하나를 선택하세요. 이 책의 예제에 사용된 STM32F3DISCOVERY 보드의 경우 `thumbv7em-none-eabihf` 대상을 사용하세요. [자신에게 가장 적합한 Cortex-M을 찾으세요.](https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"

#: src/intro/install.md:23
msgid "Cortex-M0, M0+, and M1 (ARMv6-M architecture):"
msgstr "Cortex-M0, M0+, M1 (ARMv6-M 아키텍처):"

#: src/intro/install.md:28
msgid "Cortex-M3 (ARMv7-M architecture):"
msgstr "Cortex-M3 (ARMv7-M 아키텍처):"

#: src/intro/install.md:33
msgid ""
"Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):"
msgstr "하드웨어 부동 소수점 없는 Cortex-M4 및 M7 (ARMv7E-M 아키텍처):"

#: src/intro/install.md:38
msgid ""
"Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):"
msgstr "하드웨어 부동 소수점 있는 Cortex-M4F 및 M7F (ARMv7E-M 아키텍처):"

#: src/intro/install.md:43
msgid "Cortex-M23 (ARMv8-M architecture):"
msgstr "Cortex-M23 (ARMv8-M 아키텍처):"

#: src/intro/install.md:48
msgid "Cortex-M33 and M35P (ARMv8-M architecture):"
msgstr "Cortex-M33 및 M35P (ARMv8-M 아키텍처):"

#: src/intro/install.md:53
msgid ""
"Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):"
msgstr "하드웨어 부동 소수점 있는 Cortex-M33F 및 M35PF (ARMv8-M 아키텍처):"

#: src/intro/install.md:66
msgid ""
"WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. "
"https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=16"
msgstr "WINDOWS: Visual Studio 2019용 C++ 빌드 도구 필수 구성 요소가 설치되어 있습니다. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16"

#: src/intro/install.md:67
msgid "`cargo-generate`"
msgstr "`cargo-generate`"

#: src/intro/install.md:69
msgid "We'll use this later to generate a project from a template."
msgstr "나중에 템플릿에서 프로젝트를 생성하는 데 사용할 것입니다."

#: src/intro/install.md:75
msgid ""
"Note: on some Linux distros (e.g. Ubuntu) you may need to install the "
"packages `libssl-dev` and `pkg-config` prior to installing cargo-generate."
msgstr "참고: 일부 Linux 배포판(예: Ubuntu)에서는 cargo-generate를 설치하기 전에 `libssl-dev` 및 `pkg-config` 패키지를 설치해야 할 수 있습니다."

#: src/intro/install.md:77
msgid "OS-Specific Instructions"
msgstr "OS별 지침"

#: src/intro/install.md:79
msgid "Now follow the instructions specific to the OS you are using:"
msgstr "이제 사용 중인 OS에 특정한 지침을 따르세요:"

#: src/intro/install.md:81
msgid "[Linux](install/linux.md)"
msgstr "[리눅스](install/linux.md)"

#: src/intro/install.md:82
msgid "[Windows](install/windows.md)"
msgstr "[윈도우](install/windows.md)"

#: src/intro/install.md:83
msgid "[macOS](install/macos.md)"
msgstr "[macOS](install/macos.md)"

#: src/intro/install/linux.md:3
msgid "Here are the installation commands for a few Linux distributions."
msgstr "다음은 몇 가지 Linux 배포판에 대한 설치 명령어입니다."

#: src/intro/install/linux.md:5
msgid "Packages"
msgstr "패키지"

#: src/intro/install/linux.md:7
msgid "Ubuntu 18.04 or newer / Debian stretch or newer"
msgstr "Ubuntu 18.04 이상 / Debian stretch 이상"

#: src/intro/install/linux.md:9
msgid ""
"**NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**참고** `gdb-multiarch`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:26
msgid "Ubuntu 14.04 and 16.04"
msgstr "Ubuntu 14.04 및 16.04"

#: src/intro/install/linux.md:28
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**참고** `arm-none-eabi-gdb`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:40
msgid "Fedora 27 or newer"
msgstr "Fedora 27 이상"

#: src/intro/install/linux.md:51
msgid "Arch Linux"
msgstr "Arch Linux"

#: src/intro/install/linux.md:53
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM "
"Cortex-M programs"
msgstr "**참고** `arm-none-eabi-gdb`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:60
msgid "udev rules"
msgstr "udev 규칙"

#: src/intro/install/linux.md:62
msgid ""
"This rule lets you use OpenOCD with the Discovery board without root "
"privilege."
msgstr "이 규칙을 사용하면 루트 권한 없이 Discovery 보드와 함께 OpenOCD를 사용할 수 있습니다."

#: src/intro/install/linux.md:64
msgid ""
"Create the file `/etc/udev/rules.d/70-st-link.rules` with the contents shown "
"below."
msgstr "아래에 표시된 내용으로 `/etc/udev/rules.d/70-st-link.rules` 파일을 생성하세요."

#: src/intro/install/linux.md:66
msgid ""
"```text\n"
"# STM32F3DISCOVERY rev A/B - ST-LINK/V2\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n"
"\n"
"# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n"
"```"
msgstr "```text\n# STM32F3DISCOVERY rev A/B - ST-LINK/V2\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n\n# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n```"

#: src/intro/install/linux.md:74
msgid "Then reload all the udev rules with:"
msgstr "그런 다음 다음 명령으로 모든 udev 규칙을 다시 로드하세요:"

#: src/intro/install/linux.md:80
msgid ""
"If you had the board plugged to your laptop, unplug it and then plug it "
"again."
msgstr "보드가 노트북에 연결되어 있었다면, 플러그를 뽑았다가 다시 연결하세요."

#: src/intro/install/linux.md:82
msgid "You can check the permissions by running this command:"
msgstr "이 명령을 실행하여 권한을 확인할 수 있습니다:"

#: src/intro/install/linux.md:88
msgid "Which should show something like"
msgstr "다음과 같이 표시되어야 합니다."

#: src/intro/install/linux.md:96
msgid ""
"Take note of the bus and device numbers. Use those numbers to create a path "
"like `/dev/bus/usb/<bus>/<device>`. Then use this path like so:"
msgstr "버스 및 장치 번호를 기록해 두세요. 이 번호를 사용하여 `/dev/bus/usb/<bus>/<device>`와 같은 경로를 생성하세요. 그런 다음 이 경로를 다음과 같이 사용하세요:"

#: src/intro/install/linux.md:116
msgid ""
"The `+` appended to permissions indicates the existence of an extended "
"permission. The `getfacl` command tells the user `you` can make use of this "
"device."
msgstr "권한에 추가된 `+`는 확장 권한의 존재를 나타냅니다. `getfacl` 명령은 사용자 `당신`이 이 장치를 사용할 수 있음을 알려줍니다."

#: src/intro/install/linux.md:120
msgid "Now, go to the [next section](verify.md)."
msgstr "이제 [다음 섹션](verify.md)으로 이동하세요."

#: src/intro/install/macos.md:1
msgid "macOS"
msgstr "macOS"

#: src/intro/install/macos.md:3
msgid ""
"All the tools can be installed using [Homebrew](http://brew.sh/) or "
"[MacPorts](https://www.macports.org/):"
msgstr "모든 도구는 [Homebrew](http://brew.sh/) 또는 [MacPorts](https://www.macports.org/)를 사용하여 설치할 수 있습니다:"

#: src/intro/install/macos.md:8
msgid "Install tools with [Homebrew](http://brew.sh/)"
msgstr "[Homebrew](http://brew.sh/)로 도구 설치"

#: src/intro/install/macos.md:21
msgid ""
"**NOTE** If OpenOCD crashes you may need to install the latest version using:"
msgstr "**참고** OpenOCD가 충돌하면 다음을 사용하여 최신 버전을 설치해야 할 수 있습니다:"

#: src/intro/install/macos.md:26
msgid "Install tools with [MacPorts](https://www.macports.org/)"
msgstr "[MacPorts](https://www.macports.org/)로 도구 설치"

#: src/intro/install/macos.md:41 src/intro/install/windows.md:48
msgid "That's all! Go to the [next section](verify.md)."
msgstr "그게 다입니다! [다음 섹션](verify.md)으로 이동하세요."

#: src/intro/install/windows.md:3
msgid "`arm-none-eabi-gdb`"
msgstr "`arm-none-eabi-gdb`"

#: src/intro/install/windows.md:5
msgid ""
"ARM provides `.exe` installers for Windows. Grab one from [here](https://"
"developer.arm.com/downloads/-/arm-gnu-toolchain-downloads), and follow the "
"instructions. Just before the installation process finishes tick/select the "
"\"Add path to environment variable\" option. Then verify that the tools are "
"in your `%PATH%`:"
msgstr "ARM은 Windows용 `.exe` 설치 프로그램을 제공합니다. [여기](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)에서 다운로드하여 지침을 따르세요. 설치 프로세스가 끝나기 직전에 "환경 변수에 경로 추가" 옵션을 선택/체크하세요. 그런 다음 도구가 `%PATH%`에 있는지 확인하세요:"

#: src/intro/install/windows.md:17
msgid "OpenOCD"
msgstr "OpenOCD"

#: src/intro/install/windows.md:19
msgid ""
"There's no official binary release of OpenOCD for Windows but if you're not "
"in the mood to compile it yourself, the xPack project provides a binary "
"distribution, [here](https://xpack.github.io/openocd/). Follow the provided "
"installation instructions. Then update your `%PATH%` environment variable to "
"include the path where the binaries were installed. (`C:"
"\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-"
"tools\\openocd\\0.10.0-13.1\\.content\\bin\\`, if you've been using the easy "
"install)"
msgstr "Windows용 OpenOCD 공식 바이너리 릴리스는 없지만 직접 컴파일할 의향이 없다면 xPack 프로젝트에서 [여기](https://xpack.github.io/openocd/)에서 바이너리 배포판을 제공합니다. 제공된 설치 지침을 따르세요. 그런 다음 바이너리가 설치된 경로를 포함하도록 `%PATH%` 환경 변수를 업데이트하세요. (쉬운 설치를 사용했다면 `C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\`)"

#: src/intro/install/windows.md:27
msgid "Verify that OpenOCD is in your `%PATH%` with:"
msgstr "다음 명령으로 OpenOCD가 `%PATH%`에 있는지 확인하세요:"

#: src/intro/install/windows.md:37
msgid ""
"Grab QEMU from [the official website](https://www.qemu.org/download/"
"#windows)."
msgstr "[공식 웹사이트](https://www.qemu.org/download/#windows)에서 QEMU를 다운로드하세요."

#: src/intro/install/windows.md:41
msgid "ST-LINK USB driver"
msgstr "ST-LINK USB 드라이버"

#: src/intro/install/windows.md:43
msgid ""
"You'll also need to install [this USB driver](http://www.st.com/en/embedded-"
"software/stsw-link009.html) or OpenOCD won't work. Follow the installer "
"instructions and make sure you install the right version (32-bit or 64-bit) "
"of the driver."
msgstr "또한 [이 USB 드라이버](http://www.st.com/en/embedded-software/stsw-link009.html)를 설치해야 합니다. 그렇지 않으면 OpenOCD가 작동하지 않습니다. 설치 프로그램 지침을 따르고 올바른 버전(32비트 또는 64비트)의 드라이버를 설치했는지 확인하세요."

#: src/intro/install/verify.md:3
msgid ""
"In this section we check that some of the required tools / drivers have been "
"correctly installed and configured."
msgstr "이 섹션에서는 필요한 도구/드라이버 중 일부가 올바르게 설치 및 구성되었는지 확인합니다."

#: src/intro/install/verify.md:6
msgid ""
"Connect your laptop / PC to the discovery board using a Mini-USB USB cable. "
"The discovery board has two USB connectors; use the one labeled \"USB ST-"
"LINK\" that sits on the center of the edge of the board."
msgstr "미니 USB 케이블을 사용하여 노트북/PC를 디스커버리 보드에 연결하세요. 디스커버리 보드에는 두 개의 USB 커넥터가 있습니다. 보드 가장자리 중앙에 있는 \"USB ST-LINK\"라고 표시된 커넥터를 사용하세요."

#: src/intro/install/verify.md:10
msgid ""
"Also check that the ST-LINK header is populated. See the picture below; the "
"ST-LINK header is highlighted."
msgstr "또한 ST-LINK 헤더가 채워져 있는지 확인하세요. 아래 그림을 참조하세요. ST-LINK 헤더가 강조 표시되어 있습니다."

#: src/intro/install/verify.md:17
msgid "Now run the following command:"
msgstr "이제 다음 명령을 실행하세요:"

#: src/intro/install/verify.md:23
msgid ""
"**NOTE**: Old versions of openocd, including the 0.10.0 release from 2017, "
"do not contain the new (and preferable) `interface/stlink.cfg` file; instead "
"you may need to use `interface/stlink-v2.cfg` or `interface/stlink-v2-1.cfg`."
msgstr "**참고**: 2017년 0.10.0 릴리스를 포함한 이전 버전의 OpenOCD에는 새롭고 선호되는 `interface/stlink.cfg` 파일이 포함되어 있지 않습니다. 대신 `interface/stlink-v2.cfg` 또는 `interface/stlink-v2-1.cfg`를 사용해야 할 수 있습니다."

#: src/intro/install/verify.md:27
msgid ""
"You should get the following output and the program should block the console:"
msgstr "다음과 같은 출력이 표시되고 프로그램이 콘솔을 차단해야 합니다:"

#: src/intro/install/verify.md:29
msgid ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr "```text\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nInfo : auto-selecting first available session transport \"hla_swd\". To override use 'transport select <transport>'.\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\nInfo : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD\nnone separate\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : clock speed 950 kHz\nInfo : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\nInfo : using stlink api v2\nInfo : Target voltage: 2.919881\nInfo : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n```"

#: src/intro/install/verify.md:48
msgid ""
"The contents may not match exactly but you should get the last line about "
"breakpoints and watchpoints. If you got it then terminate the OpenOCD "
"process and move to the [next section](../../start/index.md)."
msgstr "내용이 정확히 일치하지 않을 수 있지만 중단점 및 감시점에 대한 마지막 줄이 표시되어야 합니다. 이 줄이 표시되면 OpenOCD 프로세스를 종료하고 [다음 섹션](../../start/index.md)으로 이동하세요."

#: src/intro/install/verify.md:54
msgid ""
"If you didn't get the "breakpoints" line then try one of the following "
"commands."
msgstr "breakpoints" 줄이 표시되지 않았다면 다음 명령 중 하나를 시도해 보세요."

#: src/intro/install/verify.md:64
msgid ""
"If one of those commands works it means you got an old hardware revision of "
"the discovery board. That won't be a problem but commit that fact to memory "
"as you'll need to configure things a bit differently later on. You can move "
"to the [next section](../../start/index.md)."
msgstr "이 명령 중 하나가 작동한다면 Discovery 보드의 이전 하드웨어 개정판을 사용하고 있다는 의미입니다. 이는 문제가 되지 않지만 나중에 설정을 약간 다르게 구성해야 하므로 이 사실을 기억해 두세요. [다음 섹션](../../start/index.md)으로 이동할 수 있습니다."

#: src/intro/install/verify.md:69
msgid ""
"If none of the commands work as a normal user then try to run them with root "
"permission (e.g. `sudo openocd ..`). If the commands do work with root "
"permission then check that the [udev rules](linux.md#udev-rules) have been "
"correctly set."
msgstr "일반 사용자로는 어떤 명령도 작동하지 않는다면 루트 권한으로 실행해 보세요(예: `sudo openocd ..`). 명령이 루트 권한으로 작동한다면 [udev 규칙](linux.md#udev-rules)이 올바르게 설정되었는지 확인하세요."

#: src/intro/install/verify.md:75
msgid ""
"If you have reached this point and OpenOCD is not working please open [an "
"issue](https://github.com/rust-embedded/book/issues) and we'll help you out!"
msgstr "이 시점까지 OpenOCD가 작동하지 않는다면 [이슈](https://github.com/rust-embedded/book/issues)를 열어주세요. 저희가 도와드리겠습니다!"

#: src/start/index.md:1
msgid "Getting Started"
msgstr "시작하기"

#: src/start/index.md:3
msgid ""
"In this section we'll walk you through the process of writing, building, "
"flashing and debugging embedded programs. You will be able to try most of "
"the examples without any special hardware as we will show you the basics "
"using QEMU, a popular open-source hardware emulator. The only section where "
"hardware is required is, naturally enough, the [Hardware](./hardware.md) "
"section, where we use OpenOCD to program an [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html)."
msgstr "이 섹션에서는 임베디드 프로그램을 작성, 빌드, 플래싱 및 디버깅하는 과정을 안내합니다. 인기 있는 오픈 소스 하드웨어 에뮬레이터인 QEMU를 사용하여 기본 사항을 보여주므로 특별한 하드웨어 없이도 대부분의 예제를 시도할 수 있습니다. 하드웨어가 필요한 유일한 섹션은 당연히 OpenOCD를 사용하여 [STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html)를 프로그래밍하는 [하드웨어](./hardware.md) 섹션입니다."

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""
"[LM3S6965](http://www.ti.com/product/"
"LM3S6965), Cortex-M3 마이크로컨트롤러를 위한 프로그램 작성을 시작하겠습니다. "
"이를 초기 타겟으로 선택한 이유는 QEMU를 사용하여 [에뮬레이션할 수 있기](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) 때문에 이 섹션에서는 "
"하드웨어를 만질 필요가 없고 툴링과 "
"개발 과정에 집중할 수 있습니다."

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""
"**중요** 이 튜토리얼에서는 프로젝트 이름으로 \"app\"을 사용하겠습니다. "
"\"app\"이라는 단어를 볼 때마다 프로젝트에 대해 선택한 "
"이름으로 바꿔야 합니다. 또는 프로젝트 이름을 "
"\"app\"으로 지정하여 치환을 피할 수도 있습니다."

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr "비표준 Rust 프로그램 만들기"

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""
"[`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) 프로젝트 템플릿을 사용하여 새 프로젝트를 생성하겠습니다. "
"생성된 프로젝트는 기본 애플리케이션을 포함할 것입니다: 새로운 임베디드 rust 애플리케이션을 위한 "
"좋은 시작점입니다. 또한 프로젝트에는 "
"핵심 임베디드 rust 기능을 강조하는 여러 개별 애플리케이션이 있는 "
"`examples` 디렉토리가 포함됩니다."

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "`cargo-generate` 사용하기"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "먼저 cargo-generate를 설치하세요"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "그런 다음 새 프로젝트를 생성하세요"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "`git` 사용하기"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr "저장소를 클론하세요"

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr "그런 다음 `Cargo.toml` 파일의 플레이스홀더를 채우세요"

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"

#: src/start/qemu.md:72
msgid "Using neither"
msgstr "둘 다 사용하지 않기"

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""
"`cortex-m-quickstart` 템플릿의 최신 스냅샷을 가져와서 "
"압축을 해제하세요."

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""
"또는 [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart)로 이동하여 녹색 \"Clone or download\" 버튼을 클릭한 다음 "
"\"Download ZIP\"을 클릭할 수 있습니다."

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr "그런 다음 "`git` 사용하기" 버전의 두 번째 부분에서 수행한 대로 `Cargo.toml` 파일의 플레이스홀더를 채우세요."

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr "프로그램 개요"

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr "편의를 위해 `src/main.rs`의 소스 코드에서 가장 중요한 부분을 소개합니다:"

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr "// 여기에 코드를 작성하세요\n"

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr "이 프로그램은 표준 Rust 프로그램과 약간 다르므로 자세히 살펴보겠습니다."

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr "`#![no_std]`는 이 프로그램이 표준 크레이트인 `std`에 링크되지 않을 것임을 나타냅니다. 대신 그 하위 집합인 `core` 크레이트에 링크될 것입니다."

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr "`#![no_main]`은 이 프로그램이 대부분의 Rust 프로그램이 사용하는 표준 `main` 인터페이스를 사용하지 않을 것임을 나타냅니다. `no_main`을 사용하는 주된 이유는 `no_std` 컨텍스트에서 `main` 인터페이스를 사용하려면 nightly가 필요하기 때문입니다."

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr "`use panic_halt as _;`. 이 크레이트는 프로그램의 패닉 동작을 정의하는 `panic_handler`를 제공합니다. 이에 대해서는 책의 [패닉](panicking.md) 장에서 더 자세히 다룰 것입니다."

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr "[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html)는 프로그램의 진입점을 표시하는 데 사용되는 [`cortex-m-rt`](https://crates.io/crates/cortex-m-rt) 크레이트에서 제공하는 속성입니다. 표준 `main` 인터페이스를 사용하지 않으므로 프로그램의 진입점을 나타내는 다른 방법이 필요하며, 그것이 `#[entry]`입니다."

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr "`fn main() -> !`. 우리 프로그램은 대상 하드웨어에서 실행되는 _유일한_ 프로세스이므로 종료되기를 원하지 않습니다! 컴파일 시점에 그렇게 될 것임을 보장하기 위해 [발산 함수](https://doc.rust-lang.org/rust-by-example/fn/diverging.html)(함수 시그니처의 `-> !` 부분)를 사용합니다."

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "크로스 컴파일"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the "
"`.cargo/config.toml` in the template has the answer:"
msgstr "다음 단계는 Cortex-M3 아키텍처용 프로그램을 _크로스_ 컴파일하는 것입니다. 컴파일 대상(`$TRIPLE`)이 무엇인지 안다면 `cargo build --target $TRIPLE`을 실행하는 것만큼 간단합니다. 다행히 템플릿의 `.cargo/config.toml`에 답이 있습니다:"

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr "Cortex-M3 아키텍처용으로 크로스 컴파일하려면 `thumbv7m-none-eabi`를 사용해야 합니다. 이 대상은 Rust 툴체인을 설치할 때 자동으로 설치되지 않으므로, 아직 추가하지 않았다면 지금 툴체인에 이 대상을 추가하는 것이 좋습니다:"

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr "`.cargo/config.toml` 파일에 `thumbv7m-none-eabi` 컴파일 대상이 기본값으로 설정되어 있으므로 아래 두 명령은 동일하게 작동합니다:"

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr "검사"

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr "이제 `target/thumbv7m-none-eabihf/debug/app`에 비네이티브 ELF 바이너리가 있습니다. `cargo-binutils`를 사용하여 검사할 수 있습니다."

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr "`cargo-readobj`를 사용하여 ELF 헤더를 출력하여 이것이 ARM 바이너리임을 확인할 수 있습니다."

#: src/start/qemu.md:183
msgid "Note that:"
msgstr "참고:"

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr "`--bin app`은 `target/$TRIPLE/debug/app`의 바이너리를 검사하는 간편한 방법입니다."

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr "`--bin app`은 필요한 경우 바이너리를 (재)컴파일합니다."

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr "`cargo-size`는 바이너리의 링커 섹션 크기를 출력할 수 있습니다."

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr "최적화된 버전을 검사하기 위해 `--release`를 사용합니다."

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr "ELF 링커 섹션에 대한 복습"

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr "`.text`는 프로그램 명령어를 포함합니다."

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr "`.rodata`는 문자열과 같은 상수 값을 포함합니다."

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr "`.data`는 초기 값이 0이 _아닌_ 정적으로 할당된 변수를 포함합니다."

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr "`.bss`는 초기 값이 0인 정적으로 할당된 변수도 포함합니다."

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr "`.vector_table`은 벡터(인터럽트) 테이블을 저장하는 데 사용하는 _비_표준 섹션입니다."

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr "`.ARM.attributes` 및 `.debug_*` 섹션은 메타데이터를 포함하며 바이너리를 플래싱할 때 대상에 로드되지 _않습니다_."

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr "**중요**: ELF 파일은 디버그 정보와 같은 메타데이터를 포함하므로 디스크상의 _크기_는 장치에 플래싱될 때 프로그램이 차지할 공간을 정확하게 반영하지 _않습니다_. 바이너리의 실제 크기를 확인하려면 _항상_ `cargo-size`를 사용하세요."

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr "`cargo-objdump`를 사용하여 바이너리를 역어셈블할 수 있습니다."

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr "**참고** 위 명령이 `Unknown command line argument`에 대해 불평하면 다음 버그 보고서를 참조하세요: https://github.com/rust-embedded/book/issues/269"

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr "**참고** 이 출력은 시스템에 따라 다를 수 있습니다. rustc, LLVM 및 라이브러리의 새 버전은 다른 어셈블리를 생성할 수 있습니다. 스니펫을 작게 유지하기 위해 일부 명령어를 잘라냈습니다."

#: src/start/qemu.md:311
msgid "Running"
msgstr "실행 중"

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""
"다음으로, QEMU에서 임베디드 프로그램을 실행하는 방법을 살펴보겠습니다! 이번에는 "
"실제로 무언가를 하는 `hello` 예제를 사용할 것입니다."

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr "편의를 위해 `examples/hello.rs`의 소스 코드를 소개합니다:"

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr "//! 세미호스팅을 사용하여 호스트 콘솔에 \"Hello, world!\"를 출력합니다\n"

#: src/start/qemu.md:331 src/start/hardware.md:97 src/start/semihosting.md:26
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""
"// QEMU 종료\n"
"    // 참고: 하드웨어에서 실행하지 마십시오. OpenOCD 상태를 손상시킬 수 있습니다\n"

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""
"이 프로그램은 세미호스팅이라는 것을 사용하여 _호스트_ 콘솔에 텍스트를 출력합니다. "
"실제 하드웨어를 사용할 때는 디버그 세션이 필요하지만 QEMU를 사용할 때는 그냥 작동합니다."

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr "예제를 컴파일하여 시작해 봅시다:"

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""
"출력 바이너리는 `target/thumbv7m-none-eabi/debug/examples/hello`에 위치합니다."

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr "QEMU에서 이 바이너리를 실행하려면 다음 명령을 실행하세요:"

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""
"명령은 텍스트를 출력한 후 성공적으로 종료되어야 합니다 (종료 코드 = 0). "
"\\*nix에서는 다음 명령으로 확인할 수 있습니다:"

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr "QEMU 명령을 분석해 봅시다:"

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""
"`qemu-system-arm`. 이것은 QEMU 에뮬레이터입니다. 이 QEMU 바이너리에는 몇 가지 "
"변형이 있습니다. 이 변형은 이름에서 알 수 있듯이 _ARM_ 머신의 전체 _시스템_ "
"에뮬레이션을 수행합니다."

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""
"`-cpu cortex-m3`. 이것은 QEMU에게 Cortex-M3 CPU를 에뮬레이트하도록 지시합니다. "
"CPU 모델을 지정하면 일부 잘못된 컴파일 오류를 잡을 수 있습니다. 예를 들어, "
"하드웨어 FPU가 있는 Cortex-M4F용으로 컴파일된 프로그램을 실행하면 QEMU가 실행 "
"중에 오류를 발생시킵니다."

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""
"`-machine lm3s6965evb`. 이것은 QEMU에게 LM3S6965 마이크로컨트롤러를 포함하는 "
"평가 보드인 LM3S6965EVB를 에뮬레이트하도록 지시합니다."

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr "`-nographic`. 이것은 QEMU에게 GUI를 실행하지 않도록 지시합니다."

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""
"`-semihosting-config (..)`. 이것은 QEMU에게 세미호스팅을 활성화하도록 지시합니다. "
"세미호스팅을 통해 에뮬레이트된 장치는 호스트의 stdout, stderr, stdin을 사용하고 "
"호스트에 파일을 생성할 수 있습니다."

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""
"`-kernel $file`. 이것은 QEMU에게 에뮬레이트된 머신에 로드하고 실행할 바이너리를 알려줍니다."

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""
"긴 QEMU 명령을 일일이 입력하는 것은 너무 많은 작업입니다! 사용자 지정 러너를 "
"설정하여 프로세스를 단순화할 수 있습니다. `.cargo/config.toml`에는 QEMU를 "
"호출하는 주석 처리된 러너가 있습니다. 주석을 해제해 봅시다:"

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""
"이 러너는 기본 컴파일 대상인 `thumbv7m-none-eabi` 대상에만 적용됩니다. 이제 "
"`cargo run`은 프로그램을 컴파일하고 QEMU에서 실행할 것입니다:"

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"

#: src/start/qemu.md:432 src/start/hardware.md:116
msgid "Debugging"
msgstr "디버깅"

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr "디버깅은 임베디드 개발에 매우 중요합니다. 어떻게 하는지 알아봅시다."

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""
"임베디드 장치 디버깅은 디버그하려는 프로그램이 디버거 프로그램(GDB 또는 LLDB)을 "
"실행하는 머신에서 실행되지 않으므로 _원격_ 디버깅을 포함합니다."

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""
"원격 디버깅은 클라이언트와 서버를 포함합니다. QEMU 설정에서 클라이언트는 GDB("
"또는 LLDB) 프로세스가 되고 서버는 임베디드 프로그램을 실행하는 QEMU 프로세스가 "
"됩니다."

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr "이 섹션에서는 이미 컴파일한 `hello` 예제를 사용할 것입니다."

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr "첫 번째 디버깅 단계는 QEMU를 디버깅 모드로 실행하는 것입니다:"

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""
"이 명령은 콘솔에 아무것도 출력하지 않으며 터미널을 차단합니다. 이번에는 두 가지 "
"추가 플래그를 전달했습니다:"

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""
"`-gdb tcp::3333`. 이것은 QEMU에게 TCP 포트 3333에서 GDB 연결을 기다리도록 지시합니다."

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""
"`-S`. 이것은 QEMU에게 시작 시 머신을 정지하도록 지시합니다. 이것이 없으면 "
"디버거를 실행할 기회를 얻기 전에 프로그램이 main의 끝에 도달했을 것입니다!"

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""
"다음으로 다른 터미널에서 GDB를 실행하고 예제의 디버그 심볼을 로드하도록 지시합니다:"

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""
"**참고**: 설치 챕터에서 설치한 GDB 버전에 따라 `gdb-multiarch` 대신 다른 버전의 "
"GDB가 필요할 수 있습니다. `arm-none-eabi-gdb` 또는 단순히 `gdb`일 수도 있습니다."

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""
"그런 다음 GDB 셸 내에서 TCP 포트 3333에서 연결을 기다리는 QEMU에 연결합니다."

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""
"프로세스가 중단되고 프로그램 카운터가 `Reset`이라는 함수를 가리키는 것을 볼 수 "
"있습니다. 이것은 리셋 핸들러입니다. Cortex-M 코어가 부팅 시 실행하는 것입니다."

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""
"일부 설정에서는 위에 표시된 `Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/"
"lib.rs:473` 줄 대신 gdb가 다음과 같은 경고를 출력할 수 있습니다:"

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""
"그것은 알려진 결함입니다. 해당 경고는 안전하게 무시해도 됩니다. 대부분 Reset()에 "
"있을 것입니다."

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""
"이 리셋 핸들러는 결국 우리의 main 함수를 호출할 것입니다. 중단점과 `continue` "
"명령을 사용하여 그곳까지 건너뛰어 봅시다. 중단점을 설정하려면 먼저 `list` 명령으로 "
"코드에서 중단하고 싶은 위치를 살펴봅시다."

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr "이것은 examples/hello.rs 파일의 소스 코드를 보여줄 것입니다."

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""
"\"Hello, world!\" 바로 앞인 13행에 중단점을 추가하고 싶습니다. `break` 명령으로 "
"그렇게 할 수 있습니다:"

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""
"이제 `continue` 명령으로 gdb에게 main 함수까지 실행하도록 지시할 수 있습니다:"

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""
"이제 \"Hello, world!\"를 출력하는 코드에 가까워졌습니다. `next` 명령을 사용하여 "
"계속 진행해 봅시다."

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""
"이 시점에서 `qemu-system-arm`을 실행하는 터미널에 \"Hello, world!\"가 출력되는 "
"것을 볼 수 있습니다."

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr "`next`를 다시 호출하면 QEMU 프로세스가 종료됩니다."

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr "이제 GDB 세션을 종료할 수 있습니다."

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""
"이제 툴링과 개발 프로세스에 어느 정도 익숙해졌을 것입니다. 이 섹션에서는 실제 "
"하드웨어로 전환할 것입니다. 프로세스는 대체로 동일하게 유지됩니다. 시작해 봅시다."

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr "하드웨어 알아보기"

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""
"시작하기 전에 대상 장치의 몇 가지 특성을 식별해야 합니다. 이 특성들은 프로젝트를 "
"구성하는 데 사용될 것입니다:"

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr "ARM 코어. 예: Cortex-M3."

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""
"ARM 코어에 FPU가 포함되어 있습니까? Cortex-M4**F** 및 Cortex-M7**F** 코어에는 "
"포함되어 있습니다."

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""
"대상 장치에는 플래시 메모리와 RAM이 얼마나 있습니까? 예: 256 KiB 플래시 및 32 KiB RAM."

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""
"주소 공간에서 플래시 메모리와 RAM은 어디에 매핑되어 있습니까? 예: RAM은 일반적으로 "
"`0x2000_0000` 주소에 위치합니다."

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""
"이 정보는 장치의 데이터 시트 또는 참조 설명서에서 찾을 수 있습니다."

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""
"이 섹션에서는 참조 하드웨어인 STM32F3DISCOVERY를 사용할 것입니다. 이 보드에는 "
"STM32F303VCT6 마이크로컨트롤러가 포함되어 있습니다. 이 마이크로컨트롤러는 다음을 "
"가지고 있습니다:"

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr "단정밀도 FPU를 포함하는 Cortex-M4F 코어"

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr "0x0800_0000 주소에 위치한 256 KiB 플래시."

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""
"0x2000_0000 주소에 위치한 40 KiB RAM. (다른 RAM 영역이 있지만 단순화를 위해 "
"무시합니다)."

#: src/start/hardware.md:35
msgid "Configuring"
msgstr "구성"

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""
"새로운 템플릿 인스턴스로 처음부터 시작하겠습니다. `cargo-generate` 없이 이 "
"작업을 수행하는 방법에 대한 자세한 내용은 [QEMU에 대한 이전 섹션](qemu.md)을 "
"참조하십시오."

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/"
"config.toml`."
msgstr ""
"첫 번째 단계는 `.cargo/config.toml`에 기본 컴파일 대상을 설정하는 것입니다."

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr "Cortex-M4F 코어를 포함하므로 `thumbv7em-none-eabihf`를 사용할 것입니다."

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""
"**참고**: 이전 챕터에서 기억하시겠지만, 모든 대상을 설치해야 하며 이것은 새로운 "
"대상입니다. 따라서 이 대상을 위해 `rustup target add thumbv7em-none-eabihf` "
"설치 프로세스를 실행하는 것을 잊지 마십시오."

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the "
"`memory.x` file."
msgstr ""
"두 번째 단계는 `memory.x` 파일에 메모리 영역 정보를 입력하는 것입니다."

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of "
"`memory.x`."
msgstr ""
"**참고**: 어떤 이유로든 특정 빌드 대상의 첫 번째 빌드를 수행한 후 `memory.x` "
"파일을 변경했다면, `cargo build`가 `memory.x`의 업데이트를 추적하지 않을 수 "
"있으므로 `cargo build` 전에 `cargo clean`을 수행하십시오."

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""
"hello 예제로 다시 시작할 것이지만, 먼저 작은 변경 사항을 적용해야 합니다."

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""
"`examples/hello.rs`에서 `debug::exit()` 호출이 주석 처리되거나 제거되었는지 "
"확인하십시오. 이 호출은 QEMU에서 실행할 때만 사용됩니다."

#: src/start/hardware.md:99 src/unsorted/math.md:61
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""
"// QEMU 종료\n"
"    // 참고: 하드웨어에서 실행하지 마십시오. OpenOCD 상태를 손상시킬 수 있습니다\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""
"이제 이전과 같이 `cargo build`를 사용하여 프로그램을 크로스 컴파일하고 "
"`cargo-binutils`를 사용하여 바이너리를 검사할 수 있습니다. `cortex-m-rt` 크레이트는 "
"칩을 실행하는 데 필요한 모든 마법을 처리하며, 다행히 거의 모든 Cortex-M CPU는 "
"동일한 방식으로 부팅됩니다."

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""
"디버깅은 약간 다르게 보일 것입니다. 사실, 첫 번째 단계는 대상 장치에 따라 다르게 "
"보일 수 있습니다. 이 섹션에서는 STM32F3DISCOVERY에서 실행되는 프로그램을 디버깅하는 "
"데 필요한 단계를 보여줄 것입니다. 이것은 참조용이며, 디버깅에 대한 장치별 정보는 "
"[Debugonomicon](https://github.com/rust-embedded/debugonomicon)을 확인하십시오."

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""
"이전과 마찬가지로 원격 디버깅을 수행할 것이며 클라이언트는 GDB 프로세스가 될 "
"것입니다. 하지만 이번에는 서버가 OpenOCD가 될 것입니다."

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""
"[확인](../intro/install/verify.md) 섹션에서 했던 것처럼 디스커버리 보드를 "
"노트북/PC에 연결하고 ST-LINK 헤더가 채워져 있는지 확인하십시오."

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""
"터미널에서 `openocd`를 실행하여 디스커버리 보드의 ST-LINK에 연결하십시오. 템플릿의 "
"루트에서 이 명령을 실행하십시오. `openocd`는 사용할 인터페이스 파일과 타겟 파일을 "
"나타내는 `openocd.cfg` 파일을 선택할 것입니다."

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""
"**참고** [확인](../intro/install/verify.md) 섹션에서 디스커버리 보드의 이전 개정판을 "
"가지고 있음을 알게 되었다면, 이 시점에서 `openocd.cfg` 파일을 수정하여 "
"`interface/stlink-v2.cfg`를 사용해야 합니다."

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr "다른 터미널에서 GDB를 실행하십시오. 역시 템플릿의 루트에서 실행하십시오."

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""
"**참고**: 이전과 마찬가지로 설치 챕터에서 설치한 GDB 버전에 따라 `gdb-"
"multiarch` 대신 다른 버전의 GDB가 필요할 수 있습니다. `arm-none-eabi-gdb` "
"또는 단순히 `gdb`일 수도 있습니다."

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""
"다음으로 GDB를 OpenOCD에 연결합니다. OpenOCD는 포트 3333에서 TCP 연결을 기다리고 "
"있습니다."

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""
"이제 `load` 명령을 사용하여 프로그램을 마이크로컨트롤러에 _플래시_ (로드)하십시오."

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""
"프로그램이 로드되었습니다. 이 프로그램은 세미호스팅을 사용하므로 세미호스팅 호출을 "
"하기 전에 OpenOCD에게 세미호스팅을 활성화하도록 알려야 합니다. `monitor` 명령을 "
"사용하여 OpenOCD에 명령을 보낼 수 있습니다."

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr "`monitor help` 명령을 호출하여 모든 OpenOCD 명령을 볼 수 있습니다."

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""
"이전과 마찬가지로 중단점과 `continue` 명령을 사용하여 `main`까지 건너뛸 수 있습니다."

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""
"**참고** 위에서 `continue` 명령을 실행한 후 GDB가 중단점을 맞추는 대신 터미널을 "
"차단한다면, `memory.x` 파일의 메모리 영역 정보가 장치에 대해 올바르게 설정되었는지("
"시작 및 길이 모두) 다시 확인해야 할 수 있습니다."

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr "`step`으로 main 함수로 들어갑니다."

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""
"`next`로 프로그램을 진행하면 OpenOCD 콘솔에 \"Hello, world!\"가 다른 내용과 "
"함께 출력되는 것을 볼 수 있습니다."

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""
"메시지는 프로그램이 19행에 정의된 무한 루프: `loop {}`에 진입하기 직전에 한 번만 "
"표시됩니다."

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr "이제 `quit` 명령을 사용하여 GDB를 종료할 수 있습니다."

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""
"이제 디버깅에는 몇 가지 단계가 더 필요하므로, 이 모든 단계를 `openocd.gdb`라는 "
"단일 GDB 스크립트에 담았습니다. 이 파일은 `cargo generate` 단계에서 생성되었으며, "
"수정 없이 작동해야 합니다. 한번 살펴봅시다:"

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""
"이제 `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/examples/hello`"
"를 실행하면 GDB가 즉시 OpenOCD에 연결되고, 세미호스팅을 활성화하며, 프로그램을 "
"로드하고 프로세스를 시작할 것입니다."

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""
"대안으로, `<gdb> -x openocd.gdb`를 사용자 지정 러너로 만들어 `cargo run`이 "
"프로그램을 빌드하고 GDB 세션을 시작하도록 할 수 있습니다. 이 러너는 "
"`.cargo/config.toml`에 포함되어 있지만 주석 처리되어 있습니다."

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"

#: src/start/registers.md:1
msgid "Memory Mapped Registers"
msgstr "메모리 매핑 레지스터"

#: src/start/registers.md:3
msgid ""
"Embedded systems can only get so far by executing normal Rust code and "
"moving data around in RAM. If we want to get any information into or out of "
"our system (be that blinking an LED, detecting a button press or "
"communicating with an off-chip peripheral on some sort of bus) we're going "
"to have to dip into the world of Peripherals and their 'memory mapped "
"registers'."
msgstr ""
"임베디드 시스템은 일반 Rust 코드를 실행하고 RAM에서 데이터를 이동하는 것만으로는 "
"한계가 있습니다. 시스템으로 정보를 가져오거나 시스템에서 정보를 내보내려면(LED "
"깜박임, 버튼 누름 감지 또는 특정 버스를 통해 오프칩 주변 장치와 통신 등) 주변 "
"장치와 해당 '메모리 매핑 레지스터'의 세계로 들어가야 합니다."

#: src/start/registers.md:5
msgid ""
"You may well find that the code you need to access the peripherals in your "
"micro-controller has already been written, at one of the following levels:"
msgstr ""
"마이크로컨트롤러의 주변 장치에 접근하는 데 필요한 코드가 다음 수준 중 하나로 "
"이미 작성되어 있음을 알 수 있습니다:"

#: src/start/registers.md:10
msgid ""
"Micro-architecture Crate - This sort of crate handles any useful routines "
"common to the processor core your microcontroller is using, as well as any "
"peripherals that are common to all micro-controllers that use that "
"particular type of processor core. For example the [cortex-m](https://"
"crates.io/crates/cortex-m) crate gives you functions to enable and disable "
"interrupts, which are the same for all Cortex-M based micro-controllers. It "
"also gives you access to the 'SysTick' peripheral included with all Cortex-M "
"based micro-controllers."
msgstr ""
"마이크로아키텍처 크레이트 - 이 종류의 크레이트는 마이크로컨트롤러가 사용하는 "
"프로세서 코어에 공통적인 유용한 루틴과 해당 특정 유형의 프로세서 코어를 사용하는 "
"모든 마이크로컨트롤러에 공통적인 주변 장치를 처리합니다. 예를 들어, [cortex-m]("
"https://crates.io/crates/cortex-m) 크레이트는 모든 Cortex-M 기반 마이크로컨트롤러에 "
"동일한 인터럽트 활성화 및 비활성화 기능을 제공합니다. 또한 모든 Cortex-M 기반 "
"마이크로컨트롤러에 포함된 'SysTick' 주변 장치에 대한 접근을 제공합니다."

#: src/start/registers.md:11
msgid ""
"Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over "
"the various memory-wrapper registers defined for your particular part-number "
"of micro-controller you are using. For example, [tm4c123x](https://crates.io/"
"crates/tm4c123x) for the Texas Instruments Tiva-C TM4C123 series, or "
"[stm32f30x](https://crates.io/crates/stm32f30x) for the ST-Micro STM32F30x "
"series. Here, you'll be interacting with the registers directly, following "
"each peripheral's operating instructions given in your micro-controller's "
"Technical Reference Manual."
msgstr "주변 장치 접근 크레이트(PAC) - 이 종류의 크레이트는 사용 중인 마이크로컨트롤러의 특정 부품 번호에 대해 정의된 다양한 메모리 래퍼 레지스터에 대한 얇은 래퍼입니다. 예를 들어, 텍사스 인스트루먼트 Tiva-C TM4C123 시리즈용 [tm4c123x](https://crates.io/crates/tm4c123x) 또는 ST-Micro STM32F30x 시리즈용 [stm32f30x](https://crates.io/crates/stm32f30x)가 있습니다. 여기서는 마이크로컨트롤러의 기술 참조 설명서에 제공된 각 주변 장치의 작동 지침에 따라 레지스터와 직접 상호 작용하게 됩니다."

#: src/start/registers.md:12
msgid ""
"HAL Crate - These crates offer a more user-friendly API for your particular "
"processor, often by implementing some common traits defined in [embedded-hal]"
"(https://crates.io/crates/embedded-hal). For example, this crate might offer "
"a `Serial` struct, with a constructor that takes an appropriate set of GPIO "
"pins and a baud rate, and offers some sort of `write_byte` function for "
"sending data. See the chapter on [Portability](../portability/index.md) for "
"more information on [embedded-hal](https://crates.io/crates/embedded-hal)."
msgstr "HAL 크레이트 - 이러한 크레이트는 [embedded-hal](https://crates.io/crates/embedded-hal)에 정의된 일부 공통 특성을 구현하여 특정 프로세서에 대해 더 사용자 친화적인 API를 제공합니다. 예를 들어, 이 크레이트는 적절한 GPIO 핀 세트와 전송 속도를 사용하는 생성자가 있는 `Serial` 구조체를 제공하고 데이터를 보내기 위한 일종의 `write_byte` 함수를 제공할 수 있습니다. [embedded-hal](https://crates.io/crates/embedded-hal)에 대한 자세한 내용은 [이식성](../portability/index.md) 장을 참조하십시오."

#: src/start/registers.md:13
msgid ""
"Board Crate - These crates go one step further than a HAL Crate by pre-"
"configuring various peripherals and GPIO pins to suit the specific developer "
"kit or board you are using, such as [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) for the STM32F3DISCOVERY board."
msgstr "보드 크레이트 - 이러한 크레이트는 STM32F3DISCOVERY 보드용 [stm32f3-discovery](https://crates.io/crates/stm32f3-discovery)와 같이 사용 중인 특정 개발자 키트 또는 보드에 맞게 다양한 주변 장치 및 GPIO 핀을 미리 구성하여 HAL 크레이트보다 한 단계 더 나아갑니다."

#: src/start/registers.md:23
msgid "Board Crate"
msgstr "보드 크레이트"

#: src/start/registers.md:25
msgid ""
"A board crate is the perfect starting point, if you're new to embedded Rust. "
"They nicely abstract the HW details that might be overwhelming when starting "
"studying this subject, and makes standard tasks easy, like turning a LED on "
"or off. The functionality it exposes varies a lot between boards. Since this "
"book aims at staying hardware agnostic, the board crates won't be covered by "
"this book."
msgstr "보드 크레이트는 임베디드 Rust를 처음 접하는 경우 완벽한 시작점입니다. 이 주제를 공부하기 시작할 때 압도적일 수 있는 HW 세부 정보를 멋지게 추상화하고 LED를 켜거나 끄는 것과 같은 표준 작업을 쉽게 만듭니다. 노출하는 기능은 보드마다 많이 다릅니다. 이 책은 하드웨어에 구애받지 않는 것을 목표로 하므로 보드 크레이트는 이 책에서 다루지 않습니다."

#: src/start/registers.md:27
msgid ""
"If you want to experiment with the STM32F3DISCOVERY board, it is highly "
"recommended to take a look at the [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) board crate, which provides functionality to blink "
"the board LEDs, access its compass, bluetooth and more. The [Discovery]"
"(https://rust-embedded.github.io/discovery/) book offers a great "
"introduction to the use of a board crate."
msgstr "STM32F3DISCOVERY 보드로 실험하고 싶다면 보드 LED를 깜박이고 나침반, 블루투스 등에 액세스하는 기능을 제공하는 [stm32f3-discovery](https://crates.io/crates/stm32f3-discovery) 보드 크레이트를 살펴보는 것이 좋습니다. [Discovery](https://rust-embedded.github.io/discovery/) 책은 보드 크레이트 사용에 대한 훌륭한 소개를 제공합니다."

#: src/start/registers.md:29
msgid ""
"But if you're working on a system that doesn't yet have dedicated board "
"crate, or you need functionality not provided by existing crates, read on as "
"we start from the bottom, with the micro-architecture crates."
msgstr "하지만 아직 전용 보드 크레이트가 없는 시스템에서 작업 중이거나 기존 크레이트에서 제공하지 않는 기능이 필요한 경우 마이크로 아키텍처 크레이트부터 시작하여 계속 읽으십시오."

#: src/start/registers.md:31
msgid "Micro-architecture crate"
msgstr "마이크로 아키텍처 크레이트"

#: src/start/registers.md:33
msgid ""
"Let's look at the SysTick peripheral that's common to all Cortex-M based "
"micro-controllers. We can find a pretty low-level API in the [cortex-m]"
"(https://crates.io/crates/cortex-m) crate, and we can use it like this:"
msgstr "모든 Cortex-M 기반 마이크로컨트롤러에 공통적인 SysTick 주변 장치를 살펴보겠습니다. [cortex-m](https://crates.io/crates/cortex-m) 크레이트에서 매우 낮은 수준의 API를 찾을 수 있으며 다음과 같이 사용할 수 있습니다."

#: src/start/registers.md:51
msgid "// Loop\n"
msgstr "// 루프\n"

#: src/start/registers.md:57
msgid ""
"The functions on the `SYST` struct map pretty closely to the functionality "
"defined by the ARM Technical Reference Manual for this peripheral. There's "
"nothing in this API about 'delaying for X milliseconds' - we have to crudely "
"implement that ourselves using a `while` loop. Note that we can't access our "
"`SYST` struct until we have called `Peripherals::take()` - this is a special "
"routine that guarantees that there is only one `SYST` structure in our "
"entire program. For more on that, see the [Peripherals](../peripherals/"
"index.md) section."
msgstr "`SYST` 구조체의 함수는 이 주변 장치에 대한 ARM 기술 참조 설명서에 정의된 기능과 매우 유사합니다. 이 API에는 'X밀리초 지연'에 대한 내용이 없으므로 `while` 루프를 사용하여 직접 구현해야 합니다. `Peripherals::take()`를 호출하기 전까지는 `SYST` 구조체에 액세스할 수 없습니다. 이는 전체 프로그램에 `SYST` 구조체가 하나만 있도록 보장하는 특수 루틴입니다. 자세한 내용은 [주변 장치](../peripherals/index.md) 섹션을 참조하십시오."

#: src/start/registers.md:61
msgid "Using a Peripheral Access Crate (PAC)"
msgstr "주변 장치 접근 크레이트(PAC) 사용"

#: src/start/registers.md:63
msgid ""
"We won't get very far with our embedded software development if we restrict "
"ourselves to only the basic peripherals included with every Cortex-M. At "
"some point, we're going to need to write some code that's specific to the "
"particular micro-controller we're using. In this example, let's assume we "
"have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB "
"of Flash. We're going to pull in the [tm4c123x](https://crates.io/crates/"
"tm4c123x) crate to make use of this chip."
msgstr "모든 Cortex-M에 포함된 기본 주변 장치에만 국한한다면 임베디드 소프트웨어 개발에 큰 진전을 이루지 못할 것입니다. 어느 시점에는 사용 중인 특정 마이크로컨트롤러에 특정한 코드를 작성해야 합니다. 이 예에서는 256KiB의 플래시가 있는 중간급 80MHz Cortex-M4인 Texas Instruments TM4C123이 있다고 가정해 보겠습니다. 이 칩을 사용하기 위해 [tm4c123x](https://crates.io/crates/tm4c123x) 크레이트를 가져올 것입니다."

#: src/start/registers.md:69 src/start/registers.md:145
msgid "// panic handler\n"
msgstr "// 패닉 핸들러\n"

#: src/start/registers.md:81
msgid "// Mode = 1 => Count up/down mode\n"
msgstr "// 모드 = 1 => 카운트 업/다운 모드\n"

#: src/start/registers.md:84
msgid "// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)\n"
msgstr "// 528 사이클 (264 업 및 다운) = 비디오 라인당 4 루프 (2112 사이클)\n"

#: src/start/registers.md:92
msgid ""
"We've accessed the `PWM0` peripheral in exactly the same way as we accessed "
"the `SYST` peripheral earlier, except we called "
"`tm4c123x::Peripherals::take()`. As this crate was auto-generated using "
"[svd2rust](https://crates.io/crates/svd2rust), the access functions for our "
"register fields take a closure, rather than a numeric argument. While this "
"looks like a lot of code, the Rust compiler can use it to perform a bunch of "
"checks for us, but then generate machine-code which is pretty close to hand-"
"written assembler! Where the auto-generated code isn't able to determine "
"that all possible arguments to a particular accessor function are valid (for "
"example, if the SVD defines the register as 32-bit but doesn't say if some "
"of those 32-bit values have a special meaning), then the function is marked "
"as `unsafe`. We can see this in the example above when setting the `load` "
"and `compa` sub-fields using the `bits()` function."
msgstr "`SYST` 주변 장치에 액세스한 것과 똑같은 방식으로 `PWM0` 주변 장치에 액세스했지만 `tm4c123x::Peripherals::take()`를 호출했습니다. 이 크레이트는 [svd2rust](https://crates.io/crates/svd2rust)를 사용하여 자동 생성되었으므로 레지스터 필드에 대한 액세스 함수는 숫자 인수가 아닌 클로저를 사용합니다. 이것은 많은 코드처럼 보이지만 Rust 컴파일러는 이를 사용하여 여러 검사를 수행한 다음 손으로 작성한 어셈블러에 매우 가까운 기계 코드를 생성할 수 있습니다! 자동 생성된 코드가 특정 접근자 함수에 대한 모든 가능한 인수가 유효한지 확인할 수 없는 경우(예: SVD가 레지스터를 32비트로 정의하지만 해당 32비트 값 중 일부에 특별한 의미가 있는지 여부를 명시하지 않은 경우) 함수는 `unsafe`로 표시됩니다. 위의 예에서 `bits()` 함수를 사용하여 `load` 및 `compa` 하위 필드를 설정할 때 이를 볼 수 있습니다."

#: src/start/registers.md:94
msgid "Reading"
msgstr "읽기"

#: src/start/registers.md:96
msgid ""
"The `read()` function returns an object which gives read-only access to the "
"various sub-fields within this register, as defined by the manufacturer's "
"SVD file for this chip. You can find all the functions available on special "
"`R` return type for this particular register, in this particular peripheral, "
"on this particular chip, in the [tm4c123x documentation](https://docs.rs/"
"tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)."
msgstr "`read()` 함수는 이 칩에 대한 제조업체의 SVD 파일에 정의된 대로 이 레지스터 내의 다양한 하위 필드에 대한 읽기 전용 액세스를 제공하는 객체를 반환합니다. 이 특정 칩의 이 특정 주변 장치에 있는 이 특정 레지스터에 대한 특수 `R` 반환 유형에서 사용 가능한 모든 함수는 [tm4c123x 설명서](https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)에서 찾을 수 있습니다."

#: src/start/registers.md:100
msgid "// Do a thing\n"
msgstr "// 무언가 하기\n"

#: src/start/registers.md:104
msgid "Writing"
msgstr "쓰기"

#: src/start/registers.md:106
msgid ""
"The `write()` function takes a closure with a single argument. Typically we "
"call this `w`. This argument then gives read-write access to the various sub-"
"fields within this register, as defined by the manufacturer's SVD file for "
"this chip. Again, you can find all the functions available on the 'w' for "
"this particular register, in this particular peripheral, on this particular "
"chip, in the [tm4c123x documentation](https://docs.rs/tm4c123x/0.7.0/"
"tm4c123x/pwm0/ctl/struct.W.html). Note that all of the sub-fields that we do "
"not set will be set to a default value for us - any existing content in the "
"register will be lost."
msgstr "`write()` 함수는 단일 인수를 가진 클로저를 사용합니다. 일반적으로 이를 `w`라고 부릅니다. 이 인수는 이 칩에 대한 제조업체의 SVD 파일에 정의된 대로 이 레지스터 내의 다양한 하위 필드에 대한 읽기-쓰기 액세스를 제공합니다. 다시 말하지만, 이 특정 칩의 이 특정 주변 장치에 있는 이 특정 레지스터에 대한 'w'에서 사용 가능한 모든 함수는 [tm4c123x 설명서](https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html)에서 찾을 수 있습니다. 설정하지 않은 모든 하위 필드는 기본값으로 설정되며 레지스터의 기존 내용은 손실됩니다."

#: src/start/registers.md:112
msgid "Modifying"
msgstr "수정"

#: src/start/registers.md:114
msgid ""
"If we wish to change only one particular sub-field in this register and "
"leave the other sub-fields unchanged, we can use the `modify` function. This "
"function takes a closure with two arguments - one for reading and one for "
"writing. Typically we call these `r` and `w` respectively. The `r` argument "
"can be used to inspect the current contents of the register, and the `w` "
"argument can be used to modify the register contents."
msgstr "이 레지스터에서 특정 하위 필드 하나만 변경하고 다른 하위 필드는 변경하지 않으려면 `modify` 함수를 사용할 수 있습니다. 이 함수는 읽기용과 쓰기용 두 개의 인수를 가진 클로저를 사용합니다. 일반적으로 각각 `r`과 `w`라고 부릅니다. `r` 인수는 레지스터의 현재 내용을 검사하는 데 사용할 수 있고 `w` 인수는 레지스터 내용을 수정하는 데 사용할 수 있습니다."

#: src/start/registers.md:120
msgid ""
"The `modify` function really shows the power of closures here. In C, we'd "
"have to read into some temporary value, modify the correct bits and then "
"write the value back. This means there's considerable scope for error:"
msgstr "`modify` 함수는 여기서 클로저의 힘을 실제로 보여줍니다. C에서는 임시 값으로 읽고 올바른 비트를 수정한 다음 값을 다시 써야 합니다. 이는 오류의 여지가 상당히 많다는 것을 의미합니다."

#: src/start/registers.md:128
msgid "// Uh oh! Wrong variable!\n"
msgstr "// 어お! 잘못된 변수!\n"

#: src/start/registers.md:135
msgid "Using a HAL crate"
msgstr "HAL 크레이트 사용"

#: src/start/registers.md:137
msgid ""
"The HAL crate for a chip typically works by implementing a custom Trait for "
"the raw structures exposed by the PAC. Often this trait will define a "
"function called `constrain()` for single peripherals or `split()` for things "
"like GPIO ports with multiple pins. This function will consume the "
"underlying raw peripheral structure and return a new object with a higher-"
"level API. This API may also do things like have the Serial port `new` "
"function require a borrow on some `Clock` structure, which can only be "
"generated by calling the function which configures the PLLs and sets up all "
"the clock frequencies. In this way, it is statically impossible to create a "
"Serial port object without first having configured the clock rates, or for "
"the Serial port object to misconvert the baud rate into clock ticks. Some "
"crates even define special traits for the states each GPIO pin can be in, "
"requiring the user to put a pin into the correct state (say, by selecting "
"the appropriate Alternate Function Mode) before passing the pin into "
"Peripheral. All with no run-time cost!"
msgstr "칩용 HAL 크레이트는 일반적으로 PAC에서 노출하는 원시 구조체에 대한 사용자 지정 Trait를 구현하여 작동합니다. 종종 이 트레이트는 단일 주변 장치에 대해 `constrain()`이라는 함수를 정의하거나 여러 핀이 있는 GPIO 포트와 같은 것에 대해 `split()`을 정의합니다. 이 함수는 기본 원시 주변 장치 구조체를 사용하고 더 높은 수준의 API를 가진 새 객체를 반환합니다. 이 API는 또한 직렬 포트 `new` 함수가 PLL을 구성하고 모든 클록 주파수를 설정하는 함수를 호출해야만 생성할 수 있는 일부 `Clock` 구조체에 대한 빌림을 요구하는 것과 같은 작업을 수행할 수 있습니다. 이러한 방식으로 클록 속도를 먼저 구성하지 않고 직렬 포트 객체를 생성하거나 직렬 포트 객체가 전송 속도를 클록 틱으로 잘못 변환하는 것은 정적으로 불가능합니다. 일부 크레이트는 각 GPIO 핀이 있을 수 있는 상태에 대한 특수 트레이트를 정의하기도 하여 사용자가 핀을 주변 장치로 전달하기 전에 핀을 올바른 상태(예: 적절한 대체 기능 모드 선택)로 설정하도록 요구합니다. 모두 런타임 비용 없이!"

#: src/start/registers.md:139
msgid "Let's see an example:"
msgstr "예를 들어 보겠습니다."

#: src/start/registers.md:158
msgid "// Wrap up the SYSCTL struct into an object with a higher-layer API\n"
msgstr "// SYSCTL 구조체를 더 높은 수준의 API를 가진 객체로 래핑\n"

#: src/start/registers.md:160
msgid "// Pick our oscillation settings\n"
msgstr "// 진동 설정 선택\n"

#: src/start/registers.md:165
msgid "// Configure the PLL with those settings\n"
msgstr "// 해당 설정으로 PLL 구성\n"

#: src/start/registers.md:168
msgid ""
"// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.\n"
"    // Note it needs to borrow `sc.power_control` so it can power up the "
"GPIO\n"
"    // peripheral automatically.\n"
msgstr ""
"// GPIO_PORTA 구조체를 더 높은 수준의 API를 가진 객체로 래핑합니다.\n"
"    // GPIO 주변 장치를 자동으로 켤 수 있도록 `sc.power_control`을 빌려야 합니다.\n"

#: src/start/registers.md:173
msgid "// Activate the UART.\n"
msgstr "// UART 활성화.\n"

#: src/start/registers.md:176
msgid "// The transmit pin\n"
msgstr "// 전송 핀\n"

#: src/start/registers.md:180
msgid "// The receive pin\n"
msgstr "// 수신 핀\n"

#: src/start/registers.md:184
msgid "// No RTS or CTS required\n"
msgstr "// RTS 또는 CTS 필요 없음\n"

#: src/start/registers.md:187
msgid "// The baud rate\n"
msgstr "// 전송 속도\n"

#: src/start/registers.md:189
msgid "// Output handling\n"
msgstr "// 출력 처리\n"

#: src/start/registers.md:191
msgid "// We need the clock rates to calculate the baud rate divisors\n"
msgstr "// 전송 속도 제수를 계산하려면 클록 속도가 필요합니다\n"

#: src/start/registers.md:193
msgid "// We need this to power up the UART peripheral\n"
msgstr "// UART 주변 장치를 켜려면 이것이 필요합니다\n"

#: src/start/registers.md:198
msgid "\"Hello, World!\\r\\n\""
msgstr "\"Hello, World!\\r\\n\""

#: src/start/semihosting.md:3
msgid ""
"Semihosting is a mechanism that lets embedded devices do I/O on the host and "
"is mainly used to log messages to the host console. Semihosting requires a "
"debug session and pretty much nothing else (no extra wires!) so it's super "
"convenient to use. The downside is that it's super slow: each write "
"operation can take several milliseconds depending on the hardware debugger "
"(e.g. ST-Link) you use."
msgstr "세미호스팅은 임베디드 장치가 호스트에서 I/O를 수행할 수 있도록 하는 메커니즘이며 주로 호스트 콘솔에 메시지를 기록하는 데 사용됩니다. 세미호스팅은 디버그 세션이 필요하며 그 외에는 거의 아무것도 필요하지 않으므로(추가 전선 없음!) 사용하기 매우 편리합니다. 단점은 매우 느리다는 것입니다. 각 쓰기 작업은 사용하는 하드웨어 디버거(예: ST-Link)에 따라 수 밀리초가 걸릴 수 있습니다."

#: src/start/semihosting.md:9
msgid ""
"The [`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) "
"crate provides an API to do semihosting operations on Cortex-M devices. The "
"program below is the semihosting version of \"Hello, world!\":"
msgstr "[`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) 크레이트는 Cortex-M 장치에서 세미호스팅 작업을 수행하는 API를 제공합니다. 아래 프로그램은 \"Hello, world!\"의 세미호스팅 버전입니다."

#: src/start/semihosting.md:32
msgid ""
"If you run this program on hardware you'll see the \"Hello, world!\" message "
"within the OpenOCD logs."
msgstr "이 프로그램을 하드웨어에서 실행하면 OpenOCD 로그 내에 \"Hello, world!\" 메시지가 표시됩니다."

#: src/start/semihosting.md:42
msgid "You do need to enable semihosting in OpenOCD from GDB first:"
msgstr "먼저 GDB에서 OpenOCD의 세미호스팅을 활성화해야 합니다."

#: src/start/semihosting.md:48
msgid ""
"QEMU understands semihosting operations so the above program will also work "
"with `qemu-system-arm` without having to start a debug session. Note that "
"you'll need to pass the `-semihosting-config` flag to QEMU to enable "
"semihosting support; these flags are already included in the `.cargo/"
"config.toml` file of the template."
msgstr "QEMU는 세미호스팅 작업을 이해하므로 위 프로그램은 디버그 세션을 시작하지 않고도 `qemu-system-arm`에서 작동합니다. 세미호스팅 지원을 활성화하려면 QEMU에 `-semihosting-config` 플래그를 전달해야 합니다. 이러한 플래그는 템플릿의 `.cargo/config.toml` 파일에 이미 포함되어 있습니다."

#: src/start/semihosting.md:61
msgid ""
"There's also an `exit` semihosting operation that can be used to terminate "
"the QEMU process. Important: do **not** use `debug::exit` on hardware; this "
"function can corrupt your OpenOCD session and you will not be able to debug "
"more programs until you restart it."
msgstr "QEMU 프로세스를 종료하는 데 사용할 수 있는 `exit` 세미호스팅 작업도 있습니다. 중요: 하드웨어에서 `debug::exit`를 사용하지 **마십시오**. 이 함수는 OpenOCD 세션을 손상시킬 수 있으며 다시 시작할 때까지 더 이상 프로그램을 디버깅할 수 없습니다."

#: src/start/semihosting.md:77 src/start/semihosting.md:115
msgid "\"blue\""
msgstr "\"파란색\""

#: src/start/semihosting.md:79 src/start/semihosting.md:117
msgid "\"red\""
msgstr "\"빨간색\""

#: src/start/semihosting.md:97
msgid ""
"One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. "
"This will let you write `no_std` run-pass tests that you can run on QEMU."
msgstr "마지막 팁: 패닉 동작을 `exit(EXIT_FAILURE)`로 설정할 수 있습니다. 이렇게 하면 QEMU에서 실행할 수 있는 `no_std` 실행 통과 테스트를 작성할 수 있습니다."

#: src/start/semihosting.md:100
msgid ""
"For convenience, the `panic-semihosting` crate has an \"exit\" feature that "
"when enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to "
"the host stderr."
msgstr "편의를 위해 `panic-semihosting` 크레이트에는 활성화되면 패닉 메시지를 호스트 stderr에 기록한 후 `exit(EXIT_FAILURE)`를 호출하는 \"exit\" 기능이 있습니다."

#: src/start/semihosting.md:108
msgid "// features = [\"exit\"]\n"
msgstr "// 기능 = [\"종료\"]\n"

#: src/start/semihosting.md:123
msgid ""
"```text\n"
"$ cargo run\n"
"     Running `qemu-system-arm (..)\n"
"panicked at 'assertion failed: `(left == right)`\n"
"  left: `\"blue\"`,\n"
" right: `\"red\"`', examples/hello.rs:15:5\n"
"\n"
"$ echo $?\n"
"1\n"
"```"
msgstr "`bash\n$ cargo run\n     Running `qemu-system-arm (..)\npanicked at 'assertion failed: `(left == right)`\n  left: `\"blue\"`,\n right: `\"red\"`', examples/hello.rs:15:5\n\n$ echo $?\n1\n```"

#: src/start/semihosting.md:134
msgid ""
"**NOTE**: To enable this feature on `panic-semihosting`, edit your "
"`Cargo.toml` dependencies section where `panic-semihosting` is specified "
"with:"
msgstr "**참고**: `panic-semihosting`에서 이 기능을 활성화하려면 `Cargo.toml` 종속성 섹션에서 `panic-semihosting`이 지정된 부분을 다음과 같이 편집하십시오."

#: src/start/semihosting.md:137
msgid ""
"```toml\n"
"panic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n"
"```"
msgstr "`toml\npanic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n```"

#: src/start/semihosting.md:141
msgid ""
"where `VERSION` is the version desired. For more information on dependencies "
"features check the [`specifying dependencies`](https://doc.rust-lang.org/"
"cargo/reference/specifying-dependencies.html) section of the Cargo book."
msgstr "`VERSION`은 원하는 버전입니다. 종속성 기능에 대한 자세한 내용은 Cargo 책의 [`종속성 지정`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) 섹션을 확인하십시오."


#: src/start/panicking.md:3
msgid ""
"Panicking is a core part of the Rust language. Built-in operations like "
"indexing are runtime checked for memory safety. When out of bounds indexing "
"is attempted this results in a panic."
msgstr "패닉은 Rust 언어의 핵심 부분입니다. 인덱싱과 같은 내장 작업은 메모리 안전을 위해 런타임에 확인됩니다. 범위를 벗어난 인덱싱이 시도되면 패닉이 발생합니다."

#: src/start/panicking.md:7
msgid ""
"In the standard library panicking has a defined behavior: it unwinds the "
"stack of the panicking thread, unless the user opted for aborting the "
"program on panics."
msgstr "표준 라이브러리에서 패닉은 정의된 동작을 가집니다. 사용자가 패닉 시 프로그램 중단을 선택하지 않는 한 패닉 스레드의 스택을 해제합니다."

#: src/start/panicking.md:11
msgid ""
"In programs without standard library, however, the panicking behavior is "
"left undefined. A behavior can be chosen by declaring a `#[panic_handler]` "
"function. This function must appear exactly _once_ in the dependency graph "
"of a program, and must have the following signature: `fn(&PanicInfo) -> !`, "
"where [`PanicInfo`](https://doc.rust-lang.org/core/panic/"
"struct.PanicInfo.html) is a struct containing information about the location "
"of the panic."
msgstr "그러나 표준 라이브러리가 없는 프로그램에서는 패닉 동작이 정의되지 않은 상태로 남아 있습니다. `#[panic_handler]` 함수를 선언하여 동작을 선택할 수 있습니다. 이 함수는 프로그램의 종속성 그래프에 정확히 _한 번_ 나타나야 하며 `fn(&PanicInfo) -> !` 시그니처를 가져야 합니다. 여기서 [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html)는 패닉 위치에 대한 정보를 포함하는 구조체입니다."

#: src/start/panicking.md:19
msgid ""
"Given that embedded systems range from user facing to safety critical "
"(cannot crash) there's no one size fits all panicking behavior but there are "
"plenty of commonly used behaviors. These common behaviors have been packaged "
"into crates that define the `#[panic_handler]` function. Some examples "
"include:"
msgstr "임베디드 시스템은 사용자 대면에서 안전에 중요한(충돌할 수 없는) 시스템에 이르기까지 다양하므로 모든 경우에 적용되는 단일 패닉 동작은 없지만 일반적으로 사용되는 동작이 많이 있습니다. 이러한 일반적인 동작은 `#[panic_handler]` 함수를 정의하는 크레이트로 패키지화되었습니다. 몇 가지 예는 다음과 같습니다."

#: src/start/panicking.md:24
msgid ""
"[`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the "
"abort instruction to be executed."
msgstr "[`panic-abort`](https://crates.io/crates/panic-abort). 패닉은 중단 명령을 실행하게 합니다."

#: src/start/panicking.md:25
msgid ""
"[`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the "
"program, or the current thread, to halt by entering an infinite loop."
msgstr "[`panic-halt`](https://crates.io/crates/panic-halt). 패닉은 프로그램 또는 현재 스레드가 무한 루프에 진입하여 중단되도록 합니다."

#: src/start/panicking.md:27
msgid ""
"[`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is "
"logged using the ITM, an ARM Cortex-M specific peripheral."
msgstr "[`panic-itm`](https://crates.io/crates/panic-itm). 패닉 메시지는 ARM Cortex-M 특정 주변 장치인 ITM을 사용하여 기록됩니다."

#: src/start/panicking.md:29
msgid ""
"[`panic-semihosting`](https://crates.io/crates/panic-semihosting). The "
"panicking message is logged to the host using the semihosting technique."
msgstr "[`panic-semihosting`](https://crates.io/crates/panic-semihosting). 패닉 메시지는 세미호스팅 기술을 사용하여 호스트에 기록됩니다."

#: src/start/panicking.md:37
msgid ""
"You may be able to find even more crates searching for the [`panic-handler`]"
"(https://crates.io/keywords/panic-handler) keyword on crates.io."
msgstr "crates.io에서 [`panic-handler`](https://crates.io/keywords/panic-handler) 키워드를 검색하여 더 많은 크레이트를 찾을 수 있습니다."

#: src/start/panicking.md:42
msgid ""
"A program can pick one of these behaviors simply by linking to the "
"corresponding crate. The fact that the panicking behavior is expressed in "
"the source of an application as a single line of code is not only useful as "
"documentation but can also be used to change the panicking behavior "
"according to the compilation profile. For example:"
msgstr "프로그램은 해당 크레이트에 링크하기만 하면 이러한 동작 중 하나를 선택할 수 있습니다. 패닉 동작이 애플리케이션 소스에 한 줄의 코드로 표현된다는 사실은 문서화에 유용할 뿐만 아니라 컴파일 프로필에 따라 패닉 동작을 변경하는 데에도 사용할 수 있습니다. 예를 들어:"

#: src/start/panicking.md:51
msgid ""
"// dev profile: easier to debug panics; can put a breakpoint on "
"`rust_begin_unwind`\n"
msgstr "// 개발 프로필: 패닉 디버깅이 더 쉬움; `rust_begin_unwind`에 중단점을 설정할 수 있음\n"

#: src/start/panicking.md:55
msgid "// release profile: minimize the binary size of the application\n"
msgstr "// 릴리스 프로필: 애플리케이션의 바이너리 크기 최소화\n"

#: src/start/panicking.md:59 src/start/exceptions.md:17
#: src/collections/index.md:132
msgid "// ..\n"
msgstr "// ..\n"

#: src/start/panicking.md:63
msgid ""
"In this example the crate links to the `panic-halt` crate when built with "
"the dev profile (`cargo build`), but links to the `panic-abort` crate when "
"built with the release profile (`cargo build --release`)."
msgstr "이 예에서 크레이트는 개발 프로필(`cargo build`)로 빌드될 때 `panic-halt` 크레이트에 링크되지만 릴리스 프로필(`cargo build --release`)로 빌드될 때는 `panic-abort` 크레이트에 링크됩니다."

#: src/start/panicking.md:67
msgid ""
"The `use panic_abort as _;` form of the `use` statement is used to ensure "
"the `panic_abort` panic handler is included in our final executable while "
"making it clear to the compiler that we won't explicitly use anything from "
"the crate. Without the `as _` rename, the compiler would warn that we have "
"an unused import. Sometimes you might see `extern crate panic_abort` "
"instead, which is an older style used before the 2018 edition of Rust, and "
"should now only be used for \"sysroot\" crates (those distributed with Rust "
"itself) such as `proc_macro`, `alloc`, `std`, and `test`."
msgstr "`use panic_abort as _;` 형식의 `use` 문은 `panic_abort` 패닉 핸들러가 최종 실행 파일에 포함되도록 하는 동시에 컴파일러에게 크레이트에서 명시적으로 아무것도 사용하지 않을 것임을 명확히 하는 데 사용됩니다. `as _` 이름 바꾸기가 없으면 컴파일러는 사용되지 않는 가져오기가 있다는 경고를 표시합니다. 때로는 대신 `extern crate panic_abort`를 볼 수 있는데, 이는 Rust 2018 에디션 이전에 사용된 이전 스타일이며 이제는 `proc_macro`, `alloc`, `std` 및 `test`와 같이 Rust 자체와 함께 배포되는 \"sysroot\" 크레이트에만 사용해야 합니다."

#: src/start/panicking.md:74
msgid "An example"
msgstr "예시"

#: src/start/panicking.md:76
msgid ""
"Here's an example that tries to index an array beyond its length. The "
"operation results in a panic."
msgstr "다음은 배열 길이를 초과하여 인덱싱을 시도하는 예입니다. 이 작업은 패닉을 발생시킵니다."

#: src/start/panicking.md:91
msgid "// out of bounds access\n"
msgstr "// 범위를 벗어난 접근\n"

#: src/start/panicking.md:97
msgid ""
"This example chose the `panic-semihosting` behavior which prints the panic "
"message to the host console using semihosting."
msgstr "이 예에서는 세미호스팅을 사용하여 호스트 콘솔에 패닉 메시지를 출력하는 `panic-semihosting` 동작을 선택했습니다."

#: src/start/panicking.md:106
msgid ""
"You can try changing the behavior to `panic-halt` and confirm that no "
"message is printed in that case."
msgstr "동작을 `panic-halt`로 변경하고 이 경우 메시지가 출력되지 않는지 확인할 수 있습니다."


#: src/start/exceptions.md:3
msgid ""
"Exceptions, and interrupts, are a hardware mechanism by which the processor "
"handles asynchronous events and fatal errors (e.g. executing an invalid "
"instruction). Exceptions imply preemption and involve exception handlers, "
"subroutines executed in response to the signal that triggered the event."
msgstr "예외 및 인터럽트는 프로세서가 비동기 이벤트 및 치명적인 오류(예: 잘못된 명령어 실행)를 처리하는 하드웨어 메커니즘입니다. 예외는 선점을 의미하며 이벤트를 트리거한 신호에 대한 응답으로 실행되는 서브루틴인 예외 처리기를 포함합니다."

#: src/start/exceptions.md:8
msgid ""
"The `cortex-m-rt` crate provides an [`exception`](https://docs.rs/cortex-m-"
"rt-macros/latest/cortex_m_rt_macros/attr.exception.html) attribute to "
"declare exception handlers."
msgstr "`cortex-m-rt` 크레이트는 예외 처리기를 선언하는 [`exception`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html) 속성을 제공합니다."

#: src/start/exceptions.md:14
msgid "// Exception handler for the SysTick (System Timer) exception\n"
msgstr "// SysTick(시스템 타이머) 예외에 대한 예외 처리기\n"

#: src/start/exceptions.md:21
msgid ""
"Other than the `exception` attribute exception handlers look like plain "
"functions but there's one more difference: `exception` handlers can _not_ be "
"called by software. Following the previous example, the statement "
"`SysTick();` would result in a compilation error."
msgstr "`exception` 속성 외에 예외 처리기는 일반 함수처럼 보이지만 한 가지 차이점이 더 있습니다. `exception` 처리기는 소프트웨어에서 호출할 수 _없습니다_. 이전 예에 따라 `SysTick();` 문은 컴파일 오류를 발생시킵니다."

#: src/start/exceptions.md:26
msgid ""
"This behavior is pretty much intended and it's required to provide a "
"feature: `static mut` variables declared _inside_ `exception` handlers are "
"_safe_ to use."
msgstr "이 동작은 거의 의도된 것이며 기능을 제공하는 데 필요합니다. `exception` 처리기 _내부_에 선언된 `static mut` 변수는 _안전하게_ 사용할 수 있습니다."

#: src/start/exceptions.md:34
msgid "// `COUNT` has transformed to type `&mut u32` and it's safe to use\n"
msgstr "// `COUNT`는 `&mut u32` 유형으로 변환되었으며 안전하게 사용할 수 있습니다\n"

#: src/start/exceptions.md:39
msgid ""
"As you may know, using `static mut` variables in a function makes it [_non-"
"reentrant_](https://en.wikipedia.org/wiki/Reentrancy_(computing)). It's "
"undefined behavior to call a non-reentrant function, directly or indirectly, "
"from more than one exception / interrupt handler or from `main` and one or "
"more exception / interrupt handlers."
msgstr "아시다시피 함수에서 `static mut` 변수를 사용하면 [_비재진입_](https://en.wikipedia.org/wiki/Reentrancy_(computing))이 됩니다. 둘 이상의 예외/인터럽트 처리기 또는 `main` 및 하나 이상의 예외/인터럽트 처리기에서 직접 또는 간접적으로 비재진입 함수를 호출하는 것은 정의되지 않은 동작입니다."

#: src/start/exceptions.md:44
msgid ""
"Safe Rust must never result in undefined behavior so non-reentrant functions "
"must be marked as `unsafe`. Yet I just told that `exception` handlers can "
"safely use `static mut` variables. How is this possible? This is possible "
"because `exception` handlers can _not_ be called by software thus reentrancy "
"is not possible. These handlers are called by the hardware itself which is "
"assumed to be physically non-concurrent."
msgstr "안전한 Rust는 정의되지 않은 동작을 초래해서는 안 되므로 비재진입 함수는 `unsafe`로 표시해야 합니다. 하지만 방금 `exception` 처리기가 `static mut` 변수를 안전하게 사용할 수 있다고 말했습니다. 어떻게 이것이 가능할까요? `exception` 처리기는 소프트웨어에서 호출할 수 _없으므로_ 재진입이 불가능하기 때문입니다. 이러한 처리기는 물리적으로 비동시적이라고 가정되는 하드웨어 자체에서 호출됩니다."

#: src/start/exceptions.md:50
msgid ""
"As a result, in the context of exception handlers in embedded systems, the "
"absence of concurrent invocations of the same handler ensures that there are "
"no reentrancy issues, even if the handler uses static mutable variables."
msgstr "결과적으로 임베디드 시스템의 예외 처리기 컨텍스트에서 동일한 처리기의 동시 호출이 없으면 처리기가 정적 가변 변수를 사용하더라도 재진입 문제가 발생하지 않습니다."

#: src/start/exceptions.md:52
msgid ""
"In a multicore system, where multiple processor cores are executing code "
"concurrently, the potential for reentrancy issues becomes relevant again, "
"even within exception handlers. While each core may have its own set of "
"exception handlers, there can still be scenarios where multiple cores "
"attempt to execute the same exception handler simultaneously.  \n"
"To address this concern in a multicore environment, proper synchronization "
"mechanisms need to be employed within the exception handlers to ensure that "
"access to shared resources is properly coordinated among the cores. This "
"typically involves the use of techniques such as locks, semaphores, or "
"atomic operations to prevent data races and maintain data integrity"
msgstr "여러 프로세서 코어가 코드를 동시에 실행하는 멀티코어 시스템에서는 예외 처리기 내에서도 재진입 문제의 가능성이 다시 관련됩니다. 각 코어에 자체 예외 처리기 세트가 있을 수 있지만 여러 코어가 동시에 동일한 예외 처리기를 실행하려고 시도하는 시나리오가 여전히 있을 수 있습니다. \n멀티코어 환경에서 이 문제를 해결하려면 예외 처리기 내에서 적절한 동기화 메커니즘을 사용하여 코어 간에 공유 리소스에 대한 액세스가 적절하게 조정되도록 해야 합니다. 여기에는 일반적으로 잠금, 세마포어 또는 원자적 연산과 같은 기술을 사용하여 데이터 경쟁을 방지하고 데이터 무결성을 유지하는 것이 포함됩니다."

#: src/start/exceptions.md:55
msgid ""
"Note that the `exception` attribute transforms definitions of static "
"variables inside the function by wrapping them into `unsafe` blocks and "
"providing us with new appropriate variables of type `&mut` of the same name. "
"Thus we can dereference the reference via `*` to access the values of the "
"variables without needing to wrap them in an `unsafe` block."
msgstr "`exception` 속성은 함수 내의 정적 변수 정의를 `unsafe` 블록으로 래핑하고 동일한 이름의 `&mut` 유형의 새 적절한 변수를 제공하여 변환합니다. 따라서 `unsafe` 블록으로 래핑할 필요 없이 `*`를 통해 참조를 역참조하여 변수 값에 액세스할 수 있습니다."

#: src/start/exceptions.md:61
msgid "A complete example"
msgstr "완전한 예시"

#: src/start/exceptions.md:63
msgid ""
"Here's an example that uses the system timer to raise a `SysTick` exception "
"roughly every second. The `SysTick` exception handler keeps track of how "
"many times it has been called in the `COUNT` variable and then prints the "
"value of `COUNT` to the host console using semihosting."
msgstr "다음은 시스템 타이머를 사용하여 약 1초마다 `SysTick` 예외를 발생시키는 예입니다. `SysTick` 예외 처리기는 `COUNT` 변수에서 호출된 횟수를 추적한 다음 세미호스팅을 사용하여 `COUNT` 값을 호스트 콘솔에 출력합니다."

#: src/start/exceptions.md:68
msgid ""
"**NOTE**: You can run this example on any Cortex-M device; you can also run "
"it on QEMU"
msgstr "**참고**: 이 예제는 모든 Cortex-M 장치에서 실행할 수 있으며 QEMU에서도 실행할 수 있습니다."

#: src/start/exceptions.md:92
msgid ""
"// configures the system timer to trigger a SysTick exception every second\n"
msgstr "// 시스템 타이머를 1초마다 SysTick 예외를 트리거하도록 구성합니다\n"

#: src/start/exceptions.md:94
msgid ""
"// this is configured for the LM3S6965 which has a default CPU clock of 12 "
"MHz\n"
msgstr "// 이것은 기본 CPU 클록이 12MHz인 LM3S6965용으로 구성되었습니다\n"

#: src/start/exceptions.md:110
msgid "// Lazy initialization\n"
msgstr "// 지연 초기화\n"

#: src/start/exceptions.md:116
msgid "\"{}\""
msgstr "\"{}\""

#: src/start/exceptions.md:119
msgid ""
"// IMPORTANT omit this `if` block if running on real hardware or your\n"
"    // debugger will end in an inconsistent state\n"
msgstr "// 중요: 실제 하드웨어에서 실행 중이거나 디버거가 일관되지 않은 상태로 종료될 경우 이 `if` 블록을 생략하십시오\n"

#: src/start/exceptions.md:122
msgid "// This will terminate the QEMU process\n"
msgstr "// QEMU 프로세스를 종료합니다\n"

#: src/start/exceptions.md:132
msgid ""
"```toml\n"
"[dependencies]\n"
"cortex-m = \"0.5.7\"\n"
"cortex-m-rt = \"0.6.3\"\n"
"panic-halt = \"0.2.0\"\n"
"cortex-m-semihosting = \"0.3.1\"\n"
"```"
msgstr "`toml\n[dependencies]\ncortex-m = \"0.5.7\"\ncortex-m-rt = \"0.6.3\"\npanic-halt = \"0.2.0\"\ncortex-m-semihosting = \"0.3.1\"\n```"

#: src/start/exceptions.md:146
msgid ""
"If you run this on the Discovery board you'll see the output on the OpenOCD "
"console. Also, the program will _not_ stop when the count reaches 9."
msgstr "Discovery 보드에서 실행하면 OpenOCD 콘솔에 출력이 표시됩니다. 또한 카운트가 9에 도달해도 프로그램이 중지되지 _않습니다_."

#: src/start/exceptions.md:149
msgid "The default exception handler"
msgstr "기본 예외 처리기"

#: src/start/exceptions.md:151
msgid ""
"What the `exception` attribute actually does is _override_ the default "
"exception handler for a specific exception. If you don't override the "
"handler for a particular exception it will be handled by the "
"`DefaultHandler` function, which defaults to:"
msgstr "`exception` 속성이 실제로 하는 일은 특정 예외에 대한 기본 예외 처리기를 _재정의_하는 것입니다. 특정 예외에 대한 처리기를 재정의하지 않으면 `DefaultHandler` 함수에서 처리되며 기본값은 다음과 같습니다."

#: src/start/exceptions.md:162
msgid ""
"This function is provided by the `cortex-m-rt` crate and marked as "
"`#[no_mangle]` so you can put a breakpoint on \"DefaultHandler\" and catch "
"_unhandled_ exceptions."
msgstr "이 함수는 `cortex-m-rt` 크레이트에서 제공하며 `#[no_mangle]`로 표시되어 있으므로 \"DefaultHandler\"에 중단점을 설정하고 _처리되지 않은_ 예외를 잡을 수 있습니다."

#: src/start/exceptions.md:166
msgid ""
"It's possible to override this `DefaultHandler` using the `exception` "
"attribute:"
msgstr "`exception` 속성을 사용하여 이 `DefaultHandler`를 재정의할 수 있습니다."

#: src/start/exceptions.md:171
msgid "// custom default handler\n"
msgstr "// 사용자 지정 기본 처리기\n"

#: src/start/exceptions.md:175
msgid ""
"The `irqn` argument indicates which exception is being serviced. A negative "
"value indicates that a Cortex-M exception is being serviced; and zero or a "
"positive value indicate that a device specific exception, AKA interrupt, is "
"being serviced."
msgstr "`irqn` 인수는 서비스 중인 예외를 나타냅니다. 음수 값은 Cortex-M 예외가 서비스 중임을 나타내고 0 또는 양수 값은 장치별 예외(일명 인터럽트)가 서비스 중임을 나타냅니다."

#: src/start/exceptions.md:180
msgid "The hard fault handler"
msgstr "하드 폴트 처리기"

#: src/start/exceptions.md:182
msgid ""
"The `HardFault` exception is a bit special. This exception is fired when the "
"program enters an invalid state so its handler can _not_ return as that "
"could result in undefined behavior. Also, the runtime crate does a bit of "
"work before the user defined `HardFault` handler is invoked to improve "
"debuggability."
msgstr "`HardFault` 예외는 약간 특별합니다. 이 예외는 프로그램이 잘못된 상태에 들어갈 때 발생하므로 처리기가 반환할 수 _없습니다_. 그렇게 하면 정의되지 않은 동작이 발생할 수 있기 때문입니다. 또한 런타임 크레이트는 사용자 정의 `HardFault` 처리기가 호출되기 전에 디버깅 가능성을 향상시키기 위해 약간의 작업을 수행합니다."

#: src/start/exceptions.md:187
msgid ""
"The result is that the `HardFault` handler must have the following "
"signature: `fn(&ExceptionFrame) -> !`. The argument of the handler is a "
"pointer to registers that were pushed into the stack by the exception. These "
"registers are a snapshot of the processor state at the moment the exception "
"was triggered and are useful to diagnose a hard fault."
msgstr "결과적으로 `HardFault` 처리기는 `fn(&ExceptionFrame) -> !` 시그니처를 가져야 합니다. 처리기의 인수는 예외에 의해 스택에 푸시된 레지스터에 대한 포인터입니다. 이러한 레지스터는 예외가 트리거된 순간의 프로세서 상태 스냅샷이며 하드 폴트를 진단하는 데 유용합니다."

#: src/start/exceptions.md:193
msgid ""
"Here's an example that performs an illegal operation: a read to a "
"nonexistent memory location."
msgstr "다음은 잘못된 작업(존재하지 않는 메모리 위치 읽기)을 수행하는 예입니다."

#: src/start/exceptions.md:196
msgid ""
"**NOTE**: This program won't work, i.e. it won't crash, on QEMU because "
"`qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will "
"happily return `0 `on reads to invalid memory."
msgstr "**참고**: 이 프로그램은 QEMU에서 작동하지 않습니다. 즉, 충돌하지 않습니다. `qemu-system-arm -machine lm3s6965evb`는 메모리 로드를 확인하지 않고 잘못된 메모리 읽기 시 `0`을 반환하기 때문입니다."

#: src/start/exceptions.md:214
msgid "// read a nonexistent memory location\n"
msgstr "// 존재하지 않는 메모리 위치 읽기\n"

#: src/start/exceptions.md:225
#: src/static-guarantees/typestate-programming.md:48
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/start/exceptions.md:232
msgid ""
"The `HardFault` handler prints the `ExceptionFrame` value. If you run this "
"you'll see something like this on the OpenOCD console."
msgstr "`HardFault` 처리기는 `ExceptionFrame` 값을 출력합니다. 이것을 실행하면 OpenOCD 콘솔에 다음과 같은 내용이 표시됩니다."

#: src/start/exceptions.md:250
msgid ""
"The `pc` value is the value of the Program Counter at the time of the "
"exception and it points to the instruction that triggered the exception."
msgstr "`pc` 값은 예외 발생 시점의 프로그램 카운터 값이며 예외를 트리거한 명령어를 가리킵니다."

#: src/start/exceptions.md:253
msgid "If you look at the disassembly of the program:"
msgstr "프로그램의 디스어셈블리를 보면 다음과 같습니다."

#: src/start/exceptions.md:266
msgid ""
"You can lookup the value of the program counter `0x0800094a` in the "
"disassembly. You'll see that a load operation (`ldr r0, [r0]` ) caused the "
"exception. The `r0` field of `ExceptionFrame` will tell you the value of "
"register `r0` was `0x3fff_fffe` at that time."
msgstr "디스어셈블리에서 프로그램 카운터 `0x0800094a`의 값을 조회할 수 있습니다. 로드 작업(`ldr r0, [r0]`)이 예외를 발생시켰음을 알 수 있습니다. `ExceptionFrame`의 `r0` 필드는 당시 레지스터 `r0`의 값이 `0x3fff_fffe`였음을 알려줍니다."


#: src/start/interrupts.md:3
msgid ""
"Interrupts differ from exceptions in a variety of ways but their operation "
"and use is largely similar and they are also handled by the same interrupt "
"controller. Whereas exceptions are defined by the Cortex-M architecture, "
"interrupts are always vendor (and often even chip) specific implementations, "
"both in naming and functionality."
msgstr "인터럽트는 다양한 방식으로 예외와 다르지만 작동 및 사용은 대체로 유사하며 동일한 인터럽트 컨트롤러에서 처리됩니다. 예외는 Cortex-M 아키텍처에 의해 정의되는 반면, 인터럽트는 항상 공급업체(그리고 종종 칩)별 구현이며 이름과 기능 모두에서 그렇습니다."

#: src/start/interrupts.md:9
msgid ""
"Interrupts do allow for a lot of flexibility which needs to be accounted for "
"when attempting to use them in an advanced way. We will not cover those uses "
"in this book, however it is a good idea to keep the following in mind:"
msgstr "인터럽트는 고급 방식으로 사용하려고 할 때 고려해야 할 많은 유연성을 허용합니다. 이 책에서는 이러한 사용법을 다루지 않지만 다음 사항을 염두에 두는 것이 좋습니다."

#: src/start/interrupts.md:13
msgid ""
"Interrupts have programmable priorities which determine their handlers' "
"execution order"
msgstr "인터럽트에는 처리기의 실행 순서를 결정하는 프로그래밍 가능한 우선순위가 있습니다."

#: src/start/interrupts.md:14
msgid ""
"Interrupts can nest and preempt, i.e. execution of an interrupt handler "
"might be interrupted by another higher-priority interrupt"
msgstr "인터럽트는 중첩 및 선점할 수 있습니다. 즉, 인터럽트 처리기 실행이 다른 우선순위가 높은 인터럽트에 의해 중단될 수 있습니다."

#: src/start/interrupts.md:15
msgid ""
"In general the reason causing the interrupt to trigger needs to be cleared "
"to prevent re-entering the interrupt handler endlessly"
msgstr "일반적으로 인터럽트 처리기에 끝없이 다시 들어가는 것을 방지하려면 인터럽트를 트리거하는 원인을 지워야 합니다."

#: src/start/interrupts.md:17
msgid "The general initialization steps at runtime are always the same:"
msgstr "런타임의 일반적인 초기화 단계는 항상 동일합니다."

#: src/start/interrupts.md:18
msgid ""
"Setup the peripheral(s) to generate interrupts requests at the desired "
"occasions"
msgstr "원하는 경우에 인터럽트 요청을 생성하도록 주변 장치를 설정합니다."

#: src/start/interrupts.md:19
msgid ""
"Set the desired priority of the interrupt handler in the interrupt controller"
msgstr "인터럽트 컨트롤러에서 인터럽트 처리기의 원하는 우선순위를 설정합니다."

#: src/start/interrupts.md:20
msgid "Enable the interrupt handler in the interrupt controller"
msgstr "인터럽트 컨트롤러에서 인터럽트 처리기를 활성화합니다."

#: src/start/interrupts.md:22
msgid ""
"Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`]"
"(https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/"
"attr.interrupt.html) attribute to declare interrupt handlers. The available "
"interrupts (and their position in the interrupt handler table) are usually "
"automatically generated via `svd2rust` from a SVD description."
msgstr "예외와 유사하게 `cortex-m-rt` 크레이트는 인터럽트 처리기를 선언하는 [`interrupt`](https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html) 속성을 제공합니다. 사용 가능한 인터럽트(및 인터럽트 처리기 테이블에서의 위치)는 일반적으로 SVD 설명에서 `svd2rust`를 통해 자동으로 생성됩니다."

#: src/start/interrupts.md:30
msgid "// Interrupt handler for the Timer2 interrupt\n"
msgstr "// Timer2 인터럽트에 대한 인터럽트 처리기\n"

#: src/start/interrupts.md:33
msgid ""
"// ..\n"
"    // Clear reason for the generated interrupt request\n"
msgstr ""
"// ..\n"
"    // 생성된 인터럽트 요청의 원인 지우기\n"

#: src/start/interrupts.md:38
msgid ""
"Interrupt handlers look like plain functions (except for the lack of "
"arguments) similar to exception handlers. However they can not be called "
"directly by other parts of the firmware due to the special calling "
"conventions. It is however possible to generate interrupt requests in "
"software to trigger a diversion to the interrupt handler."
msgstr "인터럽트 처리기는 예외 처리기와 유사하게 일반 함수처럼 보입니다(인수가 없다는 점 제외). 그러나 특수 호출 규칙으로 인해 펌웨어의 다른 부분에서 직접 호출할 수 없습니다. 그러나 소프트웨어에서 인터럽트 요청을 생성하여 인터럽트 처리기로 전환을 트리거할 수 있습니다."

#: src/start/interrupts.md:44
msgid ""
"Similar to exception handlers it is also possible to declare `static mut` "
"variables inside the interrupt handlers for _safe_ state keeping."
msgstr "예외 처리기와 유사하게 _안전한_ 상태 유지를 위해 인터럽트 처리기 내에 `static mut` 변수를 선언할 수도 있습니다."

#: src/start/interrupts.md:52
msgid "// `COUNT` has type `&mut u32` and it's safe to use\n"
msgstr "// `COUNT`는 `&mut u32` 유형이며 안전하게 사용할 수 있습니다\n"

#: src/start/interrupts.md:57
msgid ""
"For a more detailed description about the mechanisms demonstrated here "
"please refer to the [exceptions section](./exceptions.md)."
msgstr "여기서 설명된 메커니즘에 대한 자세한 내용은 [예외 섹션](./exceptions.md)을 참조하십시오."


#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr "주변 장치란 무엇인가요?"

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr "대부분의 마이크로컨트롤러에는 CPU, RAM 또는 플래시 메모리 외에 마이크로컨트롤러 외부 시스템과 상호 작용하는 데 사용되는 실리콘 섹션과 센서, 모터 컨트롤러 또는 디스플레이나 키보드와 같은 인간 인터페이스를 통해 주변 환경과 직접 및 간접적으로 상호 작용하는 데 사용되는 실리콘 섹션이 포함되어 있습니다. 이러한 구성 요소를 총칭하여 주변 장치라고 합니다."

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr "이러한 주변 장치는 개발자가 처리를 오프로드하여 소프트웨어에서 모든 것을 처리할 필요가 없도록 해주기 때문에 유용합니다. 데스크톱 개발자가 그래픽 처리를 비디오 카드로 오프로드하는 것과 유사하게 임베디드 개발자는 일부 작업을 주변 장치로 오프로드하여 CPU가 다른 중요한 작업을 수행하거나 전력을 절약하기 위해 아무것도 하지 않도록 할 수 있습니다."

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr "1970년대나 1980년대의 구식 가정용 컴퓨터의 주 회로 기판을 보면(그리고 실제로 어제의 데스크톱 PC는 오늘날의 임베디드 시스템과 그리 멀지 않습니다) 다음과 같은 것을 볼 수 있습니다."

#: src/peripherals/index.md:11
msgid "A processor"
msgstr "프로세서"

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr "RAM 칩"

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr "ROM 칩"

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr "I/O 컨트롤러"

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr "RAM 칩, ROM 칩 및 I/O 컨트롤러(이 시스템의 주변 장치)는 '버스'라고 하는 일련의 병렬 트레이스를 통해 프로세서에 연결됩니다. 이 버스는 프로세서가 통신하려는 버스의 장치를 선택하는 주소 정보와 실제 데이터를 전달하는 데이터 버스를 전달합니다. 임베디드 마이크로컨트롤러에서도 동일한 원칙이 적용됩니다. 단지 모든 것이 단일 실리콘 조각에 패키징되어 있다는 점만 다릅니다."

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr "그러나 일반적으로 Vulkan, Metal 또는 OpenGL과 같은 소프트웨어 API가 있는 그래픽 카드와 달리 주변 장치는 메모리 청크에 매핑된 하드웨어 인터페이스를 통해 마이크로컨트롤러에 노출됩니다."

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr "선형 및 실제 메모리 공간"

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr "마이크로컨트롤러에서 `0x4000_0000` 또는 `0x0000_0000`과 같은 다른 임의의 주소에 일부 데이터를 쓰는 것도 완전히 유효한 작업일 수 있습니다."

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr "데스크톱 시스템에서 메모리 액세스는 MMU 또는 메모리 관리 장치에 의해 엄격하게 제어됩니다. 이 구성 요소는 메모리 섹션에 대한 액세스 권한을 적용하고(한 프로세스가 다른 프로세스의 메모리를 읽거나 수정하는 것을 방지) 물리적 메모리의 세그먼트를 소프트웨어에서 사용되는 가상 메모리 범위로 다시 매핑하는 두 가지 주요 책임을 가집니다. 마이크로컨트롤러는 일반적으로 MMU가 없으며 대신 소프트웨어에서 실제 물리적 주소만 사용합니다."

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr "32비트 마이크로컨트롤러는 `0x0000_0000`에서 `0xFFFF_FFFF`까지의 실제 및 선형 주소 공간을 가지고 있지만 일반적으로 실제 메모리에 대해 해당 범위의 수백 킬로바이트만 사용합니다. 이로 인해 상당한 양의 주소 공간이 남게 됩니다. 이전 장에서는 RAM이 `0x2000_0000` 주소에 위치한다고 이야기했습니다. RAM이 64KiB 길이(즉, 최대 주소가 0xFFFF)라면 `0x2000_0000`에서 `0x2000_FFFF`까지의 주소는 RAM에 해당합니다. `0x2000_1234` 주소에 있는 변수에 쓸 때 내부적으로 발생하는 일은 일부 논리가 주소의 상위 부분(이 예에서는 0x2000)을 감지한 다음 RAM을 활성화하여 주소의 하위 부분(이 경우 0x1234)에 대해 작동할 수 있도록 하는 것입니다. Cortex-M에서는 플래시 ROM이 `0x0000_0000` 주소에서 최대 `0x0007_FFFF` 주소(512KiB 플래시 ROM이 있는 경우)까지 매핑되어 있습니다. 이 두 영역 사이의 모든 나머지 공간을 무시하는 대신 마이크로컨트롤러 설계자는 특정 메모리 위치에 주변 장치용 인터페이스를 매핑했습니다. 이것은 다음과 같이 보입니다."

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr "![](../assets/nrf52-memory-map.png)"

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr "[Nordic nRF52832 데이터시트 (pdf)](http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf)"

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr "이러한 주변 장치와의 상호 작용은 언뜻 보기에는 간단합니다. 올바른 데이터를 올바른 주소에 쓰는 것입니다. 예를 들어, 직렬 포트를 통해 32비트 워드를 보내는 것은 특정 메모리 주소에 해당 32비트 워드를 쓰는 것만큼 직접적일 수 있습니다. 그러면 직렬 포트 주변 장치가 인계받아 데이터를 자동으로 보냅니다."

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr "이러한 주변 장치의 구성도 비슷하게 작동합니다. 주변 장치를 구성하기 위해 함수를 호출하는 대신 하드웨어 API 역할을 하는 메모리 청크가 노출됩니다. SPI 주파수 구성 레지스터에 `0x8000_0000`을 쓰면 SPI 포트는 초당 8메가비트로 데이터를 보냅니다. 동일한 주소에 `0x0200_0000`을 쓰면 SPI 포트는 초당 125킬로비트로 데이터를 보냅니다. 이러한 구성 레지스터는 다음과 같이 보입니다."

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr "![](../assets/nrf52-spi-frequency-register.png)"

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr "이 인터페이스는 어셈블리, C 또는 Rust 등 어떤 언어를 사용하든 하드웨어와 상호 작용하는 방식입니다."

#: src/peripherals/a-first-attempt.md:1
msgid "A First Attempt"
msgstr "첫 번째 시도"

#: src/peripherals/a-first-attempt.md:3
msgid "The Registers"
msgstr "레지스터"

#: src/peripherals/a-first-attempt.md:5
msgid ""
"Let's look at the 'SysTick' peripheral - a simple timer which comes with "
"every Cortex-M processor core. Typically you'll be looking these up in the "
"chip manufacturer's data sheet or _Technical Reference Manual_, but this "
"example is common to all ARM Cortex-M cores, let's look in the [ARM "
"reference manual](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/"
"Babieigh.html). We see there are four registers:"
msgstr "'SysTick' 주변 장치를 살펴보겠습니다. 모든 Cortex-M 프로세서 코어에 포함된 간단한 타이머입니다. 일반적으로 칩 제조업체의 데이터 시트나 _기술 참조 설명서_에서 이러한 내용을 찾아보겠지만, 이 예는 모든 ARM Cortex-M 코어에 공통적이므로 [ARM 참조 설명서](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/Babieigh.html)를 살펴보겠습니다. 네 개의 레지스터가 있습니다."

#: src/peripherals/a-first-attempt.md:9
msgid "Offset"
msgstr "오프셋"

#: src/peripherals/a-first-attempt.md:9
#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Name"
msgstr "이름"

#: src/peripherals/a-first-attempt.md:9
msgid "Width"
msgstr "너비"


#: src/peripherals/a-first-attempt.md:11
msgid "0x00"
msgstr "0x00"

#: src/peripherals/a-first-attempt.md:11
msgid "SYST_CSR"
msgstr "SYST_CSR"

#: src/peripherals/a-first-attempt.md:11
msgid "Control and Status Register"
msgstr "제어 및 상태 레지스터"

#: src/peripherals/a-first-attempt.md:11 src/peripherals/a-first-attempt.md:12
#: src/peripherals/a-first-attempt.md:13 src/peripherals/a-first-attempt.md:14
msgid "32 bits"
msgstr "32비트"

#: src/peripherals/a-first-attempt.md:12
msgid "0x04"
msgstr "0x04"

#: src/peripherals/a-first-attempt.md:12
msgid "SYST_RVR"
msgstr "SYST_RVR"

#: src/peripherals/a-first-attempt.md:12
msgid "Reload Value Register"
msgstr "재로드 값 레지스터"

#: src/peripherals/a-first-attempt.md:13
msgid "0x08"
msgstr "0x08"

#: src/peripherals/a-first-attempt.md:13
msgid "SYST_CVR"
msgstr "SYST_CVR"

#: src/peripherals/a-first-attempt.md:13
msgid "Current Value Register"
msgstr "현재 값 레지스터"

#: src/peripherals/a-first-attempt.md:14
msgid "0x0C"
msgstr "0x0C"

#: src/peripherals/a-first-attempt.md:14
msgid "SYST_CALIB"
msgstr "SYST_CALIB"

#: src/peripherals/a-first-attempt.md:14
msgid "Calibration Value Register"
msgstr "교정 값 레지스터"

#: src/peripherals/a-first-attempt.md:16
msgid "The C Approach"
msgstr "C 접근 방식"

#: src/peripherals/a-first-attempt.md:18
msgid ""
"In Rust, we can represent a collection of registers in exactly the same way "
"as we do in C - with a `struct`."
msgstr ""
"Rust에서는 C에서와 똑같은 방식으로 `struct`를 사용하여 레지스터 컬렉션을 나타낼 수 "
"있습니다."

#: src/peripherals/a-first-attempt.md:30
msgid ""
"The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out "
"like a C compiler would. That's very important, as Rust allows structure "
"fields to be re-ordered, while C does not. You can imagine the debugging "
"we'd have to do if these fields were silently re-arranged by the compiler! "
"With this qualifier in place, we have our four 32-bit fields which "
"correspond to the table above. But of course, this `struct` is of no use by "
"itself - we need a variable."
msgstr ""
"한정자 `#[repr(C)]`는 Rust 컴파일러에게 이 구조체를 C 컴파일러가 하는 것처럼 "
"배치하도록 지시합니다. Rust는 구조체 필드를 재정렬할 수 있지만 C는 그렇지 않으므로 "
"이는 매우 중요합니다. 컴파일러가 이 필드를 자동으로 재정렬한다면 우리가 해야 할 "
"디버깅을 상상할 수 있습니다! 이 한정자를 사용하면 위 표에 해당하는 4개의 32비트 "
"필드를 가질 수 있습니다. 하지만 물론 이 `struct` 자체는 쓸모가 없습니다. 변수가 "
"필요합니다."

#: src/peripherals/a-first-attempt.md:37
msgid "Volatile Accesses"
msgstr "휘발성 접근"

#: src/peripherals/a-first-attempt.md:39
msgid "Now, there are a couple of problems with the approach above."
msgstr "이제 위 접근 방식에는 몇 가지 문제가 있습니다."

#: src/peripherals/a-first-attempt.md:41
msgid "We have to use unsafe every time we want to access our Peripheral."
msgstr "주변 장치에 접근할 때마다 `unsafe`를 사용해야 합니다."

#: src/peripherals/a-first-attempt.md:42
msgid ""
"We've got no way of specifying which registers are read-only or read-write."
msgstr ""
"어떤 레지스터가 읽기 전용이고 어떤 레지스터가 읽기-쓰기인지 지정할 방법이 없습니다."

#: src/peripherals/a-first-attempt.md:43
msgid ""
"Any piece of code anywhere in your program could access the hardware through "
"this structure."
msgstr ""
"프로그램의 어느 곳에 있는 어떤 코드라도 이 구조체를 통해 하드웨어에 접근할 수 "
"있습니다."

#: src/peripherals/a-first-attempt.md:45
msgid "Most importantly, it doesn't actually work..."
msgstr "가장 중요한 것은, 실제로는 작동하지 않는다는 것입니다..."

#: src/peripherals/a-first-attempt.md:47
msgid ""
"Now, the problem is that compilers are clever. If you make two writes to the "
"same piece of RAM, one after the other, the compiler can notice this and "
"just skip the first write entirely. In C, we can mark variables as "
"`volatile` to ensure that every read or write occurs as intended. In Rust, "
"we instead mark the _accesses_ as volatile, not the variable."
msgstr ""
"이제 문제는 컴파일러가 영리하다는 것입니다. 동일한 RAM 영역에 두 번 연속으로 "
"쓰기를 하면 컴파일러는 이를 감지하고 첫 번째 쓰기를 완전히 건너뛸 수 있습니다. "
"C에서는 모든 읽기 또는 쓰기가 의도한 대로 발생하도록 변수를 `volatile`로 표시할 "
"수 있습니다. Rust에서는 변수가 아닌 _접근_을 휘발성으로 표시합니다."

#: src/peripherals/a-first-attempt.md:54
msgid ""
"So, we've fixed one of our four problems, but now we have even more `unsafe` "
"code! Fortunately, there's a third party crate which can help - "
"[`volatile_register`](https://crates.io/crates/volatile_register)."
msgstr ""
"그래서 네 가지 문제 중 하나를 해결했지만, 이제 `unsafe` 코드가 훨씬 더 많아졌습니다! "
"다행히도 도움이 될 수 있는 타사 크레이트인 [`volatile_register`](https://crates.io/"
"crates/volatile_register)가 있습니다."

#: src/peripherals/a-first-attempt.md:79
msgid ""
"Now, the volatile accesses are performed automatically through the `read` "
"and `write` methods. It's still `unsafe` to perform writes, but to be fair, "
"hardware is a bunch of mutable state and there's no way for the compiler to "
"know whether these writes are actually safe, so this is a good default "
"position."
msgstr ""
"이제 `read` 및 `write` 메서드를 통해 휘발성 접근이 자동으로 수행됩니다. 쓰기를 "
"수행하는 것은 여전히 `unsafe`하지만, 공정하게 말하면 하드웨어는 변경 가능한 "
"상태의 묶음이며 컴파일러가 이러한 쓰기가 실제로 안전한지 알 방법이 없으므로 이는 "
"좋은 기본 입장입니다."

#: src/peripherals/a-first-attempt.md:81
msgid "The Rusty Wrapper"
msgstr "러스트 래퍼"

#: src/peripherals/a-first-attempt.md:83
msgid ""
"We need to wrap this `struct` up into a higher-layer API that is safe for "
"our users to call. As the driver author, we manually verify the unsafe code "
"is correct, and then present a safe API for our users so they don't have to "
"worry about it (provided they trust us to get it right!)."
msgstr ""
"우리는 이 `struct`를 사용자가 안전하게 호출할 수 있는 상위 계층 API로 래핑해야 "
"합니다. 드라이버 작성자로서 우리는 unsafe 코드가 올바른지 수동으로 확인한 다음, "
"사용자가 걱정할 필요가 없도록 안전한 API를 제공합니다(우리가 올바르게 구현했다고 "
"신뢰하는 경우)."

#: src/peripherals/a-first-attempt.md:85
msgid "One example might be:"
msgstr "한 가지 예는 다음과 같습니다:"

#: src/peripherals/a-first-attempt.md:121
msgid "\"Time is now 0x{:08x}\""
msgstr "\"현재 시간은 0x{:08x}입니다\""

#: src/peripherals/a-first-attempt.md:125
msgid ""
"Now, the problem with this approach is that the following code is perfectly "
"acceptable to the compiler:"
msgstr ""
"이제 이 접근 방식의 문제는 다음 코드가 컴파일러에게 완벽하게 허용된다는 것입니다:"

#: src/peripherals/a-first-attempt.md:139
msgid ""
"Our `&mut self` argument to the `set_reload` function checks that there are "
"no other references to _that_ particular `SystemTimer` struct, but they "
"don't stop the user creating a second `SystemTimer` which points to the "
"exact same peripheral! Code written in this fashion will work if the author "
"is diligent enough to spot all of these 'duplicate' driver instances, but "
"once the code is spread out over multiple modules, drivers, developers, and "
"days, it gets easier and easier to make these kinds of mistakes."
msgstr ""
"우리의 `&mut self` 인수는 `set_reload` 함수에 대한 인수로, 해당 특정 "
"`SystemTimer` 구조체에 대한 다른 참조가 없는지 확인하지만, 동일한 주변 장치를 "
"가리키는 두 번째 `SystemTimer`를 생성하는 것을 막지는 못합니다! 이러한 방식으로 "
"작성된 코드는 작성자가 이러한 '중복' 드라이버 인스턴스를 모두 찾아낼 만큼 "
"부지런하다면 작동하겠지만, 코드가 여러 모듈, 드라이버, 개발자 및 여러 날에 걸쳐 "
"분산되면 이러한 종류의 실수를 저지르기 점점 더 쉬워집니다."

#: src/peripherals/borrowck.md:1
msgid "Mutable Global State"
msgstr "가변 전역 상태"

#: src/peripherals/borrowck.md:3
msgid ""
"Unfortunately, hardware is basically nothing but mutable global state, which "
"can feel very frightening for a Rust developer. Hardware exists "
"independently from the structures of the code we write, and can be modified "
"at any time by the real world."
msgstr ""
"불행히도 하드웨어는 기본적으로 가변 전역 상태에 불과하며, 이는 Rust 개발자에게 "
"매우 두려운 느낌을 줄 수 있습니다. 하드웨어는 우리가 작성하는 코드의 구조와 "
"독립적으로 존재하며, 실제 세계에 의해 언제든지 수정될 수 있습니다."

#: src/peripherals/borrowck.md:5
msgid "What should our rules be?"
msgstr "우리의 규칙은 무엇이어야 할까요?"

#: src/peripherals/borrowck.md:7
msgid "How can we reliably interact with these peripherals?"
msgstr "이러한 주변 장치와 어떻게 안정적으로 상호 작용할 수 있을까요?"

#: src/peripherals/borrowck.md:9
msgid ""
"Always use `volatile` methods to read or write to peripheral memory, as it "
"can change at any time"
msgstr ""
"주변 장치 메모리에 읽기 또는 쓰기를 할 때는 항상 `volatile` 메서드를 사용하십시오. "
"언제든지 변경될 수 있기 때문입니다."

#: src/peripherals/borrowck.md:10
msgid ""
"In software, we should be able to share any number of read-only accesses to "
"these peripherals"
msgstr ""
"소프트웨어에서는 이러한 주변 장치에 대한 읽기 전용 접근을 얼마든지 공유할 수 "
"있어야 합니다."

#: src/peripherals/borrowck.md:11
msgid ""
"If some software should have read-write access to a peripheral, it should "
"hold the only reference to that peripheral"
msgstr ""
"어떤 소프트웨어가 주변 장치에 대한 읽기-쓰기 접근 권한을 가져야 한다면, 해당 "
"주변 장치에 대한 유일한 참조를 유지해야 합니다."

#: src/peripherals/borrowck.md:15
msgid ""
"The last two of these rules sound suspiciously similar to what the Borrow "
"Checker does already!"
msgstr ""
"이 규칙 중 마지막 두 가지는 Borrow Checker가 이미 하는 일과 의심스러울 정도로 "
"비슷하게 들립니다!"

#: src/peripherals/borrowck.md:17
msgid ""
"Imagine if we could pass around ownership of these peripherals, or offer "
"immutable or mutable references to them?"
msgstr ""
"이러한 주변 장치의 소유권을 전달하거나, 불변 또는 가변 참조를 제공할 수 있다면 "
"어떨까요?"

#: src/peripherals/borrowck.md:19
msgid ""
"Well, we can, but for the Borrow Checker, we need to have exactly one "
"instance of each peripheral, so Rust can handle this correctly. Well, "
"luckily in the hardware, there is only one instance of any given peripheral, "
"but how can we expose that in the structure of our code?"
msgstr ""
"음, 가능합니다. 하지만 Borrow Checker를 위해서는 각 주변 장치의 인스턴스가 "
"정확히 하나만 있어야 Rust가 이를 올바르게 처리할 수 있습니다. 다행히 하드웨어에는 "
"주어진 주변 장치의 인스턴스가 하나만 있지만, 코드 구조에서 이를 어떻게 노출할 수 "
"있을까요?"

#: src/peripherals/singletons.md:3
msgid ""
"In software engineering, the singleton pattern is a software design pattern "
"that restricts the instantiation of a class to one object."
msgstr ""
"소프트웨어 공학에서 싱글톤 패턴은 클래스의 인스턴스화를 하나의 객체로 제한하는 "
"소프트웨어 디자인 패턴입니다."

#: src/peripherals/singletons.md:5
msgid ""
"_Wikipedia: [Singleton Pattern](https://en.wikipedia.org/wiki/"
"Singleton_pattern)_"
msgstr ""
"_위키백과: [싱글톤 패턴](https://en.wikipedia.org/wiki/Singleton_pattern)_"

#: src/peripherals/singletons.md:10
msgid "But why can't we just use global variable(s)?"
msgstr "하지만 전역 변수를 사용하면 안 되는 이유는 무엇일까요?"

#: src/peripherals/singletons.md:12
msgid "We could make everything a public static, like this"
msgstr "모든 것을 다음과 같이 공개 정적으로 만들 수 있습니다."

#: src/peripherals/singletons.md:24
msgid ""
"But this has a few problems. It is a mutable global variable, and in Rust, "
"these are always unsafe to interact with. These variables are also visible "
"across your whole program, which means the borrow checker is unable to help "
"you track references and ownership of these variables."
msgstr ""
"하지만 여기에는 몇 가지 문제가 있습니다. 이것은 가변 전역 변수이며, Rust에서는 "
"항상 안전하지 않게 상호 작용합니다. 이러한 변수들은 프로그램 전체에서 볼 수 "
"있으므로, borrow checker가 이러한 변수의 참조 및 소유권을 추적하는 데 도움을 줄 "
"수 없습니다."

#: src/peripherals/singletons.md:26
msgid "How do we do this in Rust?"
msgstr "Rust에서는 어떻게 할까요?"

#: src/peripherals/singletons.md:28
msgid ""
"Instead of just making our peripheral a global variable, we might instead "
"decide to make a structure, in this case called `PERIPHERALS`, which "
"contains an `Option<T>` for each of our peripherals."
msgstr ""
"주변 장치를 단순히 전역 변수로 만드는 대신, 이 경우 `PERIPHERALS`라고 불리는 "
"구조체를 만들고, 이 구조체가 각 주변 장치에 대한 `Option<T>`를 포함하도록 결정할 "
"수 있습니다."

#: src/peripherals/singletons.md:45
msgid ""
"This structure allows us to obtain a single instance of our peripheral. If "
"we try to call `take_serial()` more than once, our code will panic!"
msgstr ""
"이 구조체를 사용하면 주변 장치의 단일 인스턴스를 얻을 수 있습니다. `take_serial()`"
"을 두 번 이상 호출하려고 하면 코드가 패닉 상태가 됩니다!"

#: src/peripherals/singletons.md:50
msgid ""
"// This panics!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"
msgstr ""
"// 이것은 패닉을 일으킵니다!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"

#: src/peripherals/singletons.md:55
msgid ""
"Although interacting with this structure is `unsafe`, once we have the "
"`SerialPort` it contained, we no longer need to use `unsafe`, or the "
"`PERIPHERALS` structure at all."
msgstr ""
"이 구조체와 상호 작용하는 것은 `unsafe`하지만, 일단 포함된 `SerialPort`를 얻으면 "
"더 이상 `unsafe`나 `PERIPHERALS` 구조체를 사용할 필요가 없습니다."

#: src/peripherals/singletons.md:57
msgid ""
"This has a small runtime overhead because we must wrap the `SerialPort` "
"structure in an option, and we'll need to call `take_serial()` once, however "
"this small up-front cost allows us to leverage the borrow checker throughout "
"the rest of our program."
msgstr ""
"이것은 `SerialPort` 구조체를 옵션으로 래핑해야 하고 `take_serial()`을 한 번 "
"호출해야 하므로 작은 런타임 오버헤드가 있습니다. 하지만 이 작은 초기 비용으로 "
"프로그램의 나머지 부분에서 borrow checker를 활용할 수 있습니다."

#: src/peripherals/singletons.md:59
msgid "Existing library support"
msgstr "기존 라이브러리 지원"

#: src/peripherals/singletons.md:61
msgid ""
"Although we created our own `Peripherals` structure above, it is not "
"necessary to do this for your code. the `cortex_m` crate contains a macro "
"called `singleton!()` that will perform this action for you."
msgstr ""
"위에 우리만의 `Peripherals` 구조체를 만들었지만, 코드에 대해 이 작업을 수행할 "
"필요는 없습니다. `cortex_m` 크레이트에는 이 작업을 수행해 줄 `singleton!()`이라는 "
"매크로가 포함되어 있습니다."

#: src/peripherals/singletons.md:67
msgid "// OK if `main` is executed only once\n"
msgstr "// `main`이 한 번만 실행되면 OK\n"

#: src/peripherals/singletons.md:73
msgid ""
"[cortex_m docs](https://docs.rs/cortex-m/latest/cortex_m/"
"macro.singleton.html)"
msgstr ""
"[cortex_m 문서](https://docs.rs/cortex-m/latest/cortex_m/macro.singleton.html)"

#: src/peripherals/singletons.md:75
msgid ""
"Additionally, if you use [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-"
"m-rtic), the entire process of defining and obtaining these peripherals are "
"abstracted for you, and you are instead handed a `Peripherals` structure "
"that contains a non-`Option<T>` version of all of the items you define."
msgstr ""
"또한, [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-m-rtic)를 사용하면 "
"이러한 주변 장치를 정의하고 얻는 전체 프로세스가 추상화되어, 정의한 모든 항목의 "
"`Option<T>`가 아닌 버전이 포함된 `Peripherals` 구조체를 받게 됩니다."

#: src/peripherals/singletons.md:78
msgid "// cortex-m-rtic v0.5.x\n"
msgstr "// cortex-m-rtic v0.5.x\n"

#: src/peripherals/singletons.md:85
msgid "// Cortex-M peripherals\n"
msgstr "// Cortex-M 주변 장치\n"

#: src/peripherals/singletons.md:88
msgid "// Device specific peripherals\n"
msgstr "// 장치별 주변 장치\n"

#: src/peripherals/singletons.md:94
msgid "But why?"
msgstr "하지만 왜?"

#: src/peripherals/singletons.md:96
msgid ""
"But how do these Singletons make a noticeable difference in how our Rust "
"code works?"
msgstr ""
"하지만 이러한 싱글톤이 Rust 코드 작동 방식에 어떻게 눈에 띄는 차이를 만들까요?"

#: src/peripherals/singletons.md:103
msgid "// <------ This is really, really important\n"
msgstr "// <------ 이것은 정말, 정말 중요합니다\n"

#: src/peripherals/singletons.md:112
msgid "There are two important factors in play here:"
msgstr "여기에는 두 가지 중요한 요소가 있습니다:"

#: src/peripherals/singletons.md:114
msgid ""
"Because we are using a singleton, there is only one way or place to obtain a "
"`SerialPort` structure"
msgstr ""
"싱글톤을 사용하고 있기 때문에 `SerialPort` 구조체를 얻는 방법이나 장소는 하나뿐입니다."

#: src/peripherals/singletons.md:115
msgid ""
"To call the `read_speed()` method, we must have ownership or a reference to "
"a `SerialPort` structure"
msgstr ""
"`read_speed()` 메서드를 호출하려면 `SerialPort` 구조체의 소유권 또는 참조를 "
"가지고 있어야 합니다."

#: src/peripherals/singletons.md:117
msgid ""
"These two factors put together means that it is only possible to access the "
"hardware if we have appropriately satisfied the borrow checker, meaning that "
"at no point do we have multiple mutable references to the same hardware!"
msgstr ""
"이 두 가지 요소를 종합하면, borrow checker를 적절하게 만족시킨 경우에만 하드웨어에 "
"접근할 수 있다는 의미입니다. 즉, 동일한 하드웨어에 대한 여러 개의 가변 참조를 "
"동시에 가질 수 없습니다!"

#: src/peripherals/singletons.md:121
msgid ""
"// missing reference to `self`! Won't work.\n"
"    // SerialPort::read_speed();\n"
msgstr ""
"// `self` 참조 누락! 작동하지 않습니다.\n"
"    // SerialPort::read_speed();\n"

#: src/peripherals/singletons.md:126
msgid "// you can only read what you have access to\n"
msgstr "// 접근 권한이 있는 것만 읽을 수 있습니다\n"

#: src/peripherals/singletons.md:131
msgid "Treat your hardware like data"
msgstr "하드웨어를 데이터처럼 다루세요"

#: src/peripherals/singletons.md:133
msgid ""
"Additionally, because some references are mutable, and some are immutable, "
"it becomes possible to see whether a function or method could potentially "
"modify the state of the hardware. For example,"
msgstr ""
"또한, 일부 참조는 가변이고 일부는 불변이기 때문에 함수나 메서드가 하드웨어의 "
"상태를 잠재적으로 수정할 수 있는지 여부를 확인할 수 있습니다. 예를 들어,"

#: src/peripherals/singletons.md:135
msgid "This is allowed to change hardware settings:"
msgstr "이것은 하드웨어 설정을 변경할 수 있습니다:"

#: src/peripherals/singletons.md:142 src/peripherals/singletons.md:150
#: src/design-patterns/hal/gpio.md:17 src/design-patterns/hal/gpio.md:27
#: src/design-patterns/hal/gpio.md:35 src/design-patterns/hal/gpio.md:138
msgid "// ...\n"
msgstr "// ...\n"

#: src/peripherals/singletons.md:146
msgid "This isn't:"
msgstr "이것은 아닙니다:"

#: src/peripherals/singletons.md:154
msgid ""
"This allows us to enforce whether code should or should not make changes to "
"hardware at **compile time**, rather than at runtime. As a note, this "
"generally only works across one application, but for bare metal systems, our "
"software will be compiled into a single application, so this is not usually "
"a restriction."
msgstr ""
"이를 통해 코드가 런타임이 아닌 **컴파일 타임**에 하드웨어 변경을 수행해야 하는지 "
"여부를 강제할 수 있습니다. 참고로, 이는 일반적으로 하나의 애플리케이션에서만 "
"작동하지만, 베어 메탈 시스템의 경우 소프트웨어가 단일 애플리케이션으로 컴파일되므로 "
"일반적으로 제한 사항이 아닙니다."

#: src/static-guarantees/index.md:3
msgid ""
"Rust's type system prevents data races at compile time (see [`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) and [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) traits). The type system can also be "
"used to check other properties at compile time; reducing the need for "
"runtime checks in some cases."
msgstr ""
"Rust의 타입 시스템은 컴파일 타임에 데이터 경쟁을 방지합니다([`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) 및 [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) 트레이트 참조). 타입 시스템은 컴파일 "
"타임에 다른 속성도 확인할 수 있어 일부 경우 런타임 검사의 필요성을 줄여줍니다."

#: src/static-guarantees/index.md:10
msgid ""
"When applied to embedded programs these _static checks_ can be used, for "
"example, to enforce that configuration of I/O interfaces is done properly. "
"For instance, one can design an API where it is only possible to initialize "
"a serial interface by first configuring the pins that will be used by the "
"interface."
msgstr ""
"임베디드 프로그램에 적용될 때 이러한 _정적 검사_는 예를 들어 I/O 인터페이스 "
"구성이 올바르게 수행되도록 강제하는 데 사용될 수 있습니다. 예를 들어, 인터페이스에서 "
"사용될 핀을 먼저 구성해야만 직렬 인터페이스를 초기화할 수 있는 API를 설계할 수 "
"있습니다."

#: src/static-guarantees/index.md:15
msgid ""
"One can also statically check that operations, like setting a pin low, can "
"only be performed on correctly configured peripherals. For example, trying "
"to change the output state of a pin configured in floating input mode would "
"raise a compile error."
msgstr ""
"또한 핀을 낮게 설정하는 것과 같은 작업이 올바르게 구성된 주변 장치에서만 수행될 "
"수 있도록 정적으로 확인할 수 있습니다. 예를 들어, 플로팅 입력 모드로 구성된 핀의 "
"출력 상태를 변경하려고 하면 컴파일 오류가 발생합니다."

#: src/static-guarantees/index.md:20
msgid ""
"And, as seen in the previous chapter, the concept of ownership can be "
"applied to peripherals to ensure that only certain parts of a program can "
"modify a peripheral. This _access control_ makes software easier to reason "
"about compared to the alternative of treating peripherals as global mutable "
"state."
msgstr ""
"그리고 이전 챕터에서 보았듯이, 소유권 개념은 주변 장치에 적용되어 프로그램의 "
"특정 부분만 주변 장치를 수정할 수 있도록 보장할 수 있습니다. 이러한 _접근 제어_는 "
"주변 장치를 전역 가변 상태로 취급하는 대안과 비교하여 소프트웨어에 대해 추론하기 "
"쉽게 만듭니다."

#: src/static-guarantees/typestate-programming.md:3
msgid ""
"The concept of [typestates](https://en.wikipedia.org/wiki/"
"Typestate_analysis) describes the encoding of information about the current "
"state of an object into the type of that object. Although this can sound a "
"little arcane, if you have used the [Builder Pattern](https://doc.rust-"
"lang.org/1.0.0/style/ownership/builders.html) in Rust, you have already "
"started using Typestate Programming!"
msgstr ""
"[타입 상태](https://en.wikipedia.org/wiki/Typestate_analysis) 개념은 객체의 "
"현재 상태에 대한 정보를 해당 객체의 타입으로 인코딩하는 것을 설명합니다. 이것이 "
"다소 난해하게 들릴 수 있지만, Rust에서 [빌더 패턴](https://doc.rust-lang.org/1.0.0/"
"style/ownership/builders.html)을 사용해 본 적이 있다면 이미 타입 상태 프로그래밍을 "
"사용하고 있는 것입니다!"

#: src/static-guarantees/typestate-programming.md:52
msgid ""
"In this example, there is no direct way to create a `Foo` object. We must "
"create a `FooBuilder`, and properly initialize it before we can obtain the "
"`Foo` object we want."
msgstr ""
"이 예제에서는 `Foo` 객체를 직접 생성할 방법이 없습니다. 원하는 `Foo` 객체를 "
"얻으려면 `FooBuilder`를 생성하고 올바르게 초기화해야 합니다."

#: src/static-guarantees/typestate-programming.md:54
msgid "This minimal example encodes two states:"
msgstr "이 최소 예제는 두 가지 상태를 인코딩합니다:"

#: src/static-guarantees/typestate-programming.md:56
msgid ""
"`FooBuilder`, which represents an \"unconfigured\", or \"configuration in "
"process\" state"
msgstr ""
"`FooBuilder`, 이는 \"구성되지 않음\" 또는 \"구성 진행 중\" 상태를 나타냅니다."

#: src/static-guarantees/typestate-programming.md:57
msgid "`Foo`, which represents a \"configured\", or \"ready to use\" state."
msgstr "`Foo`, 이는 \"구성됨\" 또는 \"사용 준비 완료\" 상태를 나타냅니다."

#: src/static-guarantees/typestate-programming.md:59
msgid "Strong Types"
msgstr "강력한 타입"

#: src/static-guarantees/typestate-programming.md:61
msgid ""
"Because Rust has a [Strong Type System](https://en.wikipedia.org/wiki/"
"Strong_and_weak_typing), there is no easy way to magically create an "
"instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling "
"the `into_foo()` method. Additionally, calling the `into_foo()` method "
"consumes the original `FooBuilder` structure, meaning it can not be reused "
"without the creation of a new instance."
msgstr ""
"Rust는 [강력한 타입 시스템](https://en.wikipedia.org/wiki/Strong_and_weak_typing)을 "
"가지고 있기 때문에 `Foo` 인스턴스를 마법처럼 생성하거나 `into_foo()` 메서드를 "
"호출하지 않고 `FooBuilder`를 `Foo`로 바꾸는 쉬운 방법은 없습니다. 또한 `into_foo()` "
"메서드를 호출하면 원래 `FooBuilder` 구조체가 소모되므로 새 인스턴스를 생성하지 "
"않고는 재사용할 수 없습니다."

#: src/static-guarantees/typestate-programming.md:65
msgid ""
"This allows us to represent the states of our system as types, and to "
"include the necessary actions for state transitions into the methods that "
"exchange one type for another. By creating a `FooBuilder`, and exchanging it "
"for a `Foo` object, we have walked through the steps of a basic state "
"machine."
msgstr ""
"이를 통해 시스템의 상태를 타입으로 나타내고, 한 타입을 다른 타입으로 교환하는 "
"메서드에 상태 전환에 필요한 작업을 포함할 수 있습니다. `FooBuilder`를 생성하고 "
"이를 `Foo` 객체로 교환함으로써 기본적인 상태 머신의 단계를 거쳤습니다."

#: src/static-guarantees/state-machines.md:3
msgid ""
"The peripherals of a microcontroller can be thought of as set of state "
"machines. For example, the configuration of a simplified [GPIO pin](https://"
"en.wikipedia.org/wiki/General-purpose_input/output) could be represented as "
"the following tree of states:"
msgstr ""
"마이크로컨트롤러의 주변 장치는 상태 머신의 집합으로 생각할 수 있습니다. 예를 들어, "
"단순화된 [GPIO 핀](https://en.wikipedia.org/wiki/General-purpose_input/output)의 "
"구성은 다음 상태 트리로 나타낼 수 있습니다:"

#: src/static-guarantees/state-machines.md:7
#: src/static-guarantees/state-machines.md:19
msgid "Disabled"
msgstr "비활성화됨"

#: src/static-guarantees/state-machines.md:8
#: src/static-guarantees/state-machines.md:20
msgid "Enabled"
msgstr "활성화됨"

#: src/static-guarantees/state-machines.md:9
#: src/static-guarantees/state-machines.md:33
msgid "Configured as Output"
msgstr "출력으로 구성됨"

#: src/static-guarantees/state-machines.md:10
#: src/static-guarantees/state-machines.md:34
msgid "Output: High"
msgstr "출력: 높음"

#: src/static-guarantees/state-machines.md:11
msgid "Output: Low"
msgstr "출력: 낮음"

#: src/static-guarantees/state-machines.md:12
#: src/static-guarantees/state-machines.md:21
#: src/static-guarantees/state-machines.md:32
msgid "Configured as Input"
msgstr "입력으로 구성됨"

#: src/static-guarantees/state-machines.md:13
#: src/static-guarantees/state-machines.md:22
#: src/static-guarantees/state-machines.md:26
msgid "Input: High Resistance"
msgstr "입력: 고저항"

#: src/static-guarantees/state-machines.md:14
#: src/static-guarantees/state-machines.md:27
#: src/static-guarantees/state-machines.md:31
msgid "Input: Pulled Low"
msgstr "입력: 풀다운"

#: src/static-guarantees/state-machines.md:15
msgid "Input: Pulled High"
msgstr "입력: 풀업"

#: src/static-guarantees/state-machines.md:17
msgid ""
"If the peripheral starts in the `Disabled` mode, to move to the `Input: High "
"Resistance` mode, we must perform the following steps:"
msgstr ""
"주변 장치가 `Disabled` 모드에서 시작하는 경우, `Input: High Resistance` 모드로 "
"이동하려면 다음 단계를 수행해야 합니다:"

#: src/static-guarantees/state-machines.md:24
msgid ""
"If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, "
"we must perform the following steps:"
msgstr ""
"`Input: High Resistance`에서 `Input: Pulled Low`로 이동하려면 다음 단계를 "
"수행해야 합니다:"

#: src/static-guarantees/state-machines.md:29
msgid ""
"Similarly, if we want to move a GPIO pin from configured as `Input: Pulled "
"Low` to `Output: High`, we must perform the following steps:"
msgstr ""
"마찬가지로, GPIO 핀을 `Input: Pulled Low`로 구성된 상태에서 `Output: High`로 "
"이동하려면 다음 단계를 수행해야 합니다:"

#: src/static-guarantees/state-machines.md:36
msgid "Hardware Representation"
msgstr "하드웨어 표현"

#: src/static-guarantees/state-machines.md:38
msgid ""
"Typically the states listed above are set by writing values to given "
"registers mapped to a GPIO peripheral. Let's define an imaginary GPIO "
"Configuration Register to illustrate this:"
msgstr ""
"일반적으로 위에 나열된 상태는 GPIO 주변 장치에 매핑된 주어진 레지스터에 값을 "
"써서 설정됩니다. 이를 설명하기 위해 가상의 GPIO 구성 레지스터를 정의해 봅시다:"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Bit Number(s)"
msgstr "비트 번호"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Value"
msgstr "값"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Meaning"
msgstr "의미"

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Notes"
msgstr "참고"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "enable"
msgstr "활성화"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:7
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:15
msgid "0"
msgstr "0"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "disabled"
msgstr "비활성화됨"

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "Disables the GPIO"
msgstr "GPIO 비활성화"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:8
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:10
#: src/static-guarantees/design-contracts.md:16
msgid "1"
msgstr "1"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "enabled"
msgstr "활성화됨"

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "Enables the GPIO"
msgstr "GPIO 활성화"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "direction"
msgstr "방향"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "input"
msgstr "입력"

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "Sets the direction to Input"
msgstr "방향을 입력으로 설정"

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "output"
msgstr "출력"

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "Sets the direction to Output"
msgstr "방향을 출력으로 설정"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "input_mode"
msgstr "입력 모드"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "2..3"
msgstr "2..3"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "00"
msgstr "00"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "hi-z"
msgstr "하이-Z"

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "Sets the input as high resistance"
msgstr "입력을 고저항으로 설정"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "01"
msgstr "01"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "pull-low"
msgstr "풀다운"

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "Input pin is pulled low"
msgstr "입력 핀이 풀다운됨"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "10"
msgstr "10"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "pull-high"
msgstr "풀업"

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "Input pin is pulled high"
msgstr "입력 핀이 풀업됨"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "11"
msgstr "11"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "n/a"
msgstr "해당 없음"

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "Invalid state. Do not set"
msgstr "유효하지 않은 상태. 설정하지 마십시오."

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "output_mode"
msgstr "출력 모드"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "4"
msgstr "4"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "set-low"
msgstr "낮게 설정"

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "Output pin is driven low"
msgstr "출력 핀이 낮게 구동됨"

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "set-high"
msgstr "높게 설정"

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "Output pin is driven high"
msgstr "출력 핀이 높게 구동됨"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "input_status"
msgstr "입력 상태"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "5"
msgstr "5"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "x"
msgstr "x"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "in-val"
msgstr "입력 값"

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "0 if input is \\< 1.5v, 1 if input >= 1.5v"
msgstr "입력이 1.5v 미만이면 0, 1.5v 이상이면 1"

#: src/static-guarantees/state-machines.md:54
msgid "We _could_ expose the following structure in Rust to control this GPIO:"
msgstr "이 GPIO를 제어하기 위해 Rust에서 다음 구조체를 노출할 수 있습니다:"

#: src/static-guarantees/state-machines.md:57
#: src/static-guarantees/design-contracts.md:22
#: src/static-guarantees/design-contracts.md:107
msgid "/// GPIO interface\n"
msgstr "/// GPIO 인터페이스\n"

#: src/static-guarantees/state-machines.md:59
#: src/static-guarantees/design-contracts.md:24
#: src/static-guarantees/design-contracts.md:109
msgid "/// GPIO Configuration structure generated by svd2rust\n"
msgstr "/// svd2rust에 의해 생성된 GPIO 구성 구조체\n"

#: src/static-guarantees/state-machines.md:94
msgid ""
"However, this would allow us to modify certain registers that do not make "
"sense. For example, what happens if we set the `output_mode` field when our "
"GPIO is configured as an input?"
msgstr ""
"하지만 이렇게 하면 의미 없는 특정 레지스터를 수정할 수 있게 됩니다. 예를 들어, "
"GPIO가 입력으로 구성되어 있을 때 `output_mode` 필드를 설정하면 어떻게 될까요?"

#: src/static-guarantees/state-machines.md:96
msgid ""
"In general, use of this structure would allow us to reach states not defined "
"by our state machine above: e.g. an output that is pulled low, or an input "
"that is set high. For some hardware, this may not matter. On other hardware, "
"it could cause unexpected or undefined behavior!"
msgstr ""
"일반적으로 이 구조체를 사용하면 위에 정의된 상태 머신에서 정의되지 않은 상태에 "
"도달할 수 있습니다. 예를 들어, 낮게 풀링된 출력 또는 높게 설정된 입력과 같은 "
"경우입니다. 일부 하드웨어에서는 문제가 되지 않을 수 있지만, 다른 하드웨어에서는 "
"예기치 않거나 정의되지 않은 동작을 유발할 수 있습니다!"

#: src/static-guarantees/state-machines.md:98
msgid ""
"Although this interface is convenient to write, it doesn't enforce the "
"design contracts set out by our hardware implementation."
msgstr ""
"이 인터페이스는 작성하기 편리하지만, 하드웨어 구현에서 설정한 설계 계약을 "
"강제하지는 않습니다."

#: src/static-guarantees/design-contracts.md:3
msgid ""
"In our last chapter, we wrote an interface that _didn't_ enforce design "
"contracts. Let's take another look at our imaginary GPIO configuration "
"register:"
msgstr ""
"지난 챕터에서 우리는 설계 계약을 _강제하지 않는_ 인터페이스를 작성했습니다. 가상의 "
"GPIO 구성 레지스터를 다시 살펴봅시다:"

#: src/static-guarantees/design-contracts.md:19
msgid ""
"If we instead checked the state before making use of the underlying "
"hardware, enforcing our design contracts at runtime, we might write code "
"that looks like this instead:"
msgstr ""
"대신, 기본 하드웨어를 사용하기 전에 상태를 확인하여 런타임에 설계 계약을 "
"강제한다면, 다음과 같은 코드를 작성할 수 있습니다:"

#: src/static-guarantees/design-contracts.md:37
msgid "// Must be enabled to set direction\n"
msgstr "// 방향을 설정하려면 활성화되어야 합니다\n"

#: src/static-guarantees/design-contracts.md:50
msgid "// Must be enabled to set input mode\n"
msgstr "// 입력 모드를 설정하려면 활성화되어야 합니다\n"

#: src/static-guarantees/design-contracts.md:55
#: src/static-guarantees/design-contracts.md:91
msgid "// Direction must be input\n"
msgstr "// 방향은 입력이어야 합니다\n"

#: src/static-guarantees/design-contracts.md:68
msgid "// Must be enabled to set output status\n"
msgstr "// 출력 상태를 설정하려면 활성화되어야 합니다\n"

#: src/static-guarantees/design-contracts.md:73
msgid "// Direction must be output\n"
msgstr "// 방향은 출력이어야 합니다\n"

#: src/static-guarantees/design-contracts.md:86
msgid "// Must be enabled to get status\n"
msgstr "// 상태를 얻으려면 활성화되어야 합니다\n"

#: src/static-guarantees/design-contracts.md:100
msgid ""
"Because we need to enforce the restrictions on the hardware, we end up doing "
"a lot of runtime checking which wastes time and resources, and this code "
"will be much less pleasant for the developer to use."
msgstr ""
"하드웨어에 대한 제약을 강제해야 하므로, 많은 런타임 검사를 수행하게 되어 시간과 "
"자원을 낭비하고, 이 코드는 개발자가 사용하기에 훨씬 덜 즐거울 것입니다."

#: src/static-guarantees/design-contracts.md:102
msgid "Type States"
msgstr "타입 상태"

#: src/static-guarantees/design-contracts.md:104
msgid ""
"But what if instead, we used Rust's type system to enforce the state "
"transition rules? Take this example:"
msgstr ""
"하지만 대신 Rust의 타입 시스템을 사용하여 상태 전환 규칙을 강제한다면 어떨까요? "
"이 예제를 살펴보세요:"

#: src/static-guarantees/design-contracts.md:115
msgid "// Type states for MODE in GpioConfig\n"
msgstr "// GpioConfig의 MODE에 대한 타입 상태\n"

#: src/static-guarantees/design-contracts.md:125
msgid "/// These functions may be used on any GPIO Pin\n"
msgstr "/// 이 함수들은 모든 GPIO 핀에서 사용될 수 있습니다\n"

#: src/static-guarantees/design-contracts.md:166
msgid "/// This function may be used on an Output Pin\n"
msgstr "/// 이 함수는 출력 핀에서 사용될 수 있습니다\n"

#: src/static-guarantees/design-contracts.md:173
msgid "/// These methods may be used on any enabled input GPIO\n"
msgstr "/// 이 메서드들은 활성화된 모든 입력 GPIO에서 사용될 수 있습니다\n"

#: src/static-guarantees/design-contracts.md:212
msgid "Now let's see what the code using this would look like:"
msgstr "이제 이것을 사용하는 코드가 어떻게 생겼는지 봅시다:"

#: src/static-guarantees/design-contracts.md:215
msgid ""
"/*\n"
" * Example 1: Unconfigured to High-Z input\n"
" */"
msgstr ""
"/*\n"
" * 예제 1: 구성되지 않음에서 High-Z 입력으로\n"
" */"

#: src/static-guarantees/design-contracts.md:219
msgid ""
"// Can't do this, pin isn't enabled!\n"
"// pin.into_input_pull_down();\n"
msgstr ""
"// 이렇게 할 수 없습니다. 핀이 활성화되지 않았습니다!\n"
"// pin.into_input_pull_down();\n"

#: src/static-guarantees/design-contracts.md:222
msgid "// Now turn the pin from unconfigured to a high-z input\n"
msgstr "// 이제 핀을 구성되지 않은 상태에서 high-z 입력으로 전환합니다\n"

#: src/static-guarantees/design-contracts.md:225
msgid "// Read from the pin\n"
msgstr "// 핀에서 읽기\n"

#: src/static-guarantees/design-contracts.md:228
msgid ""
"// Can't do this, input pins don't have this interface!\n"
"// input_pin.set_bit(true);\n"
msgstr ""
"// 이렇게 할 수 없습니다. 입력 핀에는 이 인터페이스가 없습니다!\n"
"// input_pin.set_bit(true);\n"

#: src/static-guarantees/design-contracts.md:231
msgid ""
"/*\n"
" * Example 2: High-Z input to Pulled Low input\n"
" */"
msgstr ""
"/*\n"
" * 예제 2: High-Z 입력에서 풀다운 입력으로\n"
" */"

#: src/static-guarantees/design-contracts.md:237
msgid ""
"/*\n"
" * Example 3: Pulled Low input to Output, set high\n"
" */"
msgstr ""
"/*\n"
" * 예제 3: 풀다운 입력에서 출력으로, 높게 설정\n"
" */"

#: src/static-guarantees/design-contracts.md:243
msgid ""
"// Can't do this, output pins don't have this interface!\n"
"// output_pin.into_input_pull_down();\n"
msgstr ""
"// 이렇게 할 수 없습니다. 출력 핀에는 이 인터페이스가 없습니다!\n"
"// output_pin.into_input_pull_down();\n"

#: src/static-guarantees/design-contracts.md:248
msgid ""
"This is definitely a convenient way to store the state of the pin, but why "
"do it this way? Why is this better than storing the state as an `enum` "
"inside of our `GpioConfig` structure?"
msgstr ""
"이것은 핀의 상태를 저장하는 편리한 방법이지만, 왜 이런 식으로 해야 할까요? "
"`GpioConfig` 구조체 내부에 `enum`으로 상태를 저장하는 것보다 왜 이것이 더 "
"나을까요?"

#: src/static-guarantees/design-contracts.md:250
msgid "Compile Time Functional Safety"
msgstr "컴파일 타임 기능 안전"

#: src/static-guarantees/design-contracts.md:252
msgid ""
"Because we are enforcing our design constraints entirely at compile time, "
"this incurs no runtime cost. It is impossible to set an output mode when you "
"have a pin in an input mode. Instead, you must walk through the states by "
"converting it to an output pin, and then setting the output mode. Because of "
"this, there is no runtime penalty due to checking the current state before "
"executing a function."
msgstr ""
"설계 제약을 전적으로 컴파일 타임에 강제하기 때문에 런타임 비용이 발생하지 않습니다. "
"입력 모드의 핀이 있을 때 출력 모드를 설정하는 것은 불가능합니다. 대신, 핀을 출력 "
"핀으로 변환한 다음 출력 모드를 설정하는 방식으로 상태를 전환해야 합니다. 이로 인해 "
"함수를 실행하기 전에 현재 상태를 확인하는 데 따른 런타임 페널티가 없습니다."

#: src/static-guarantees/design-contracts.md:254
msgid ""
"Also, because these states are enforced by the type system, there is no "
"longer room for errors by consumers of this interface. If they try to "
"perform an illegal state transition, the code will not compile!"
msgstr ""
"또한, 이러한 상태는 타입 시스템에 의해 강제되므로, 이 인터페이스를 사용하는 "
"소비자가 오류를 범할 여지가 없습니다. 만약 유효하지 않은 상태 전환을 시도하면 "
"코드는 컴파일되지 않을 것입니다!"

#: src/static-guarantees/zero-cost-abstractions.md:3
msgid ""
"Type states are also an excellent example of Zero Cost Abstractions - the "
"ability to move certain behaviors to compile time execution or analysis. "
"These type states contain no actual data, and are instead used as markers. "
"Since they contain no data, they have no actual representation in memory at "
"runtime:"
msgstr ""
"타입 상태는 제로 비용 추상화의 훌륭한 예시이기도 합니다. 즉, 특정 동작을 컴파일 "
"타임 실행 또는 분석으로 옮기는 능력입니다. 이러한 타입 상태는 실제 데이터를 "
"포함하지 않으며, 대신 마커로 사용됩니다. 데이터를 포함하지 않으므로 런타임에 "
"메모리에 실제 표현이 없습니다:"

#: src/static-guarantees/zero-cost-abstractions.md:8
#: src/static-guarantees/zero-cost-abstractions.md:9
#: src/static-guarantees/zero-cost-abstractions.md:10
#: src/static-guarantees/zero-cost-abstractions.md:11
msgid "// == 0\n"
msgstr "// == 0\n"

#: src/static-guarantees/zero-cost-abstractions.md:14
msgid "Zero Sized Types"
msgstr "제로 크기 타입"

#: src/static-guarantees/zero-cost-abstractions.md:20
msgid ""
"Structures defined like this are called Zero Sized Types, as they contain no "
"actual data. Although these types act \"real\" at compile time - you can "
"copy them, move them, take references to them, etc., however the optimizer "
"will completely strip them away."
msgstr ""
"이와 같이 정의된 구조체는 실제 데이터를 포함하지 않으므로 제로 크기 타입이라고 "
"합니다. 이러한 타입은 컴파일 타임에는 \"실제\"처럼 작동하지만(복사, 이동, 참조 "
"가져오기 등), 옵티마이저는 이를 완전히 제거합니다."

#: src/static-guarantees/zero-cost-abstractions.md:22
msgid "In this snippet of code:"
msgstr "이 코드 스니펫에서:"

#: src/static-guarantees/zero-cost-abstractions.md:36
msgid ""
"The GpioConfig we return never exists at runtime. Calling this function will "
"generally boil down to a single assembly instruction - storing a constant "
"register value to a register location. This means that the type state "
"interface we've developed is a zero cost abstraction - it uses no more CPU, "
"RAM, or code space tracking the state of `GpioConfig`, and renders to the "
"same machine code as a direct register access."
msgstr ""
"우리가 반환하는 GpioConfig는 런타임에 존재하지 않습니다. 이 함수를 호출하는 "
"것은 일반적으로 단일 어셈블리 명령으로 귀결됩니다. 즉, 상수 레지스터 값을 "
"레지스터 위치에 저장하는 것입니다. 이는 우리가 개발한 타입 상태 인터페이스가 "
"제로 비용 추상화임을 의미합니다. `GpioConfig`의 상태를 추적하는 데 CPU, RAM "
"또는 코드 공간을 더 사용하지 않으며, 직접 레지스터 접근과 동일한 머신 코드로 "
"렌더링됩니다."

#: src/static-guarantees/zero-cost-abstractions.md:38
msgid "Nesting"
msgstr "중첩"

#: src/static-guarantees/zero-cost-abstractions.md:40
msgid ""
"In general, these abstractions may be nested as deeply as you would like. As "
"long as all components used are zero sized types, the whole structure will "
"not exist at runtime."
msgstr ""
"일반적으로 이러한 추상화는 원하는 만큼 깊게 중첩될 수 있습니다. 사용된 모든 "
"구성 요소가 제로 크기 타입인 한, 전체 구조는 런타임에 존재하지 않습니다."

#: src/static-guarantees/zero-cost-abstractions.md:42
msgid ""
"For complex or deeply nested structures, it may be tedious to define all "
"possible combinations of state. In these cases, macros may be used to "
"generate all implementations."
msgstr ""
"복잡하거나 깊게 중첩된 구조체의 경우, 모든 가능한 상태 조합을 정의하는 것이 "
"지루할 수 있습니다. 이러한 경우, 매크로를 사용하여 모든 구현을 생성할 수 있습니다."

#: src/portability/index.md:3
msgid ""
"In embedded environments portability is a very important topic: Every vendor "
"and even each family from a single manufacturer offers different peripherals "
"and capabilities and similarly the ways to interact with the peripherals "
"will vary."
msgstr ""
"임베디드 환경에서 이식성은 매우 중요한 주제입니다. 모든 벤더와 심지어 단일 "
"제조업체의 각 제품군도 다른 주변 장치와 기능을 제공하며, 주변 장치와 상호 "
"작용하는 방식도 유사하게 다릅니다."

#: src/portability/index.md:5
msgid ""
"A common way to equalize such differences is via a layer called Hardware "
"Abstraction layer or **HAL**."
msgstr ""
"이러한 차이를 해소하는 일반적인 방법은 하드웨어 추상화 계층 또는 **HAL**이라는 "
"계층을 통하는 것입니다."

#: src/portability/index.md:7
msgid ""
"Hardware abstractions are sets of routines in software that emulate some "
"platform-specific details, giving programs direct access to the hardware "
"resources."
msgstr ""
"하드웨어 추상화는 소프트웨어에서 일부 플랫폼별 세부 사항을 에뮬레이트하여 "
"프로그램에 하드웨어 리소스에 대한 직접 접근을 제공하는 루틴 집합입니다."

#: src/portability/index.md:9
msgid ""
"They often allow programmers to write device-independent, high performance "
"applications by providing standard operating system (OS) calls to hardware."
msgstr ""
"이들은 종종 표준 운영 체제(OS) 호출을 하드웨어에 제공함으로써 프로그래머가 장치 "
"독립적인 고성능 애플리케이션을 작성할 수 있도록 합니다."

#: src/portability/index.md:11
msgid ""
"_Wikipedia: [Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"
msgstr ""
"_위키백과: [하드웨어 추상화 계층](https://en.wikipedia.org/wiki/Hardware_abstraction)_"

#: src/portability/index.md:15
msgid ""
"Embedded systems are a bit special in this regard since we typically do not "
"have operating systems and user installable software but firmware images "
"which are compiled as a whole as well as a number of other constraints. So "
"while the traditional approach as defined by Wikipedia could potentially "
"work it is likely not the most productive approach to ensure portability."
msgstr ""
"임베디드 시스템은 일반적으로 운영 체제와 사용자 설치 가능 소프트웨어가 아닌 "
"전체적으로 컴파일된 펌웨어 이미지와 여러 다른 제약 조건을 가지고 있기 때문에 이 "
"점에서 다소 특별합니다. 따라서 위키백과에서 정의한 전통적인 접근 방식이 잠재적으로 "
"작동할 수 있지만, 이식성을 보장하는 가장 생산적인 접근 방식은 아닐 것입니다."

#: src/portability/index.md:17
msgid "How do we do this in Rust? Enter **embedded-hal**..."
msgstr "Rust에서는 어떻게 할까요? **embedded-hal**을 소개합니다..."

#: src/portability/index.md:19
msgid "What is embedded-hal?"
msgstr "embedded-hal이란 무엇인가요?"

#: src/portability/index.md:21
msgid ""
"In a nutshell it is a set of traits which define implementation contracts "
"between **HAL implementations**, **drivers** and **applications (or "
"firmwares)**. Those contracts include both capabilities (i.e. if a trait is "
"implemented for a certain type, the **HAL implementation** provides a "
"certain capability) and methods (i.e. if you can construct a type "
"implementing a trait it is guaranteed that you have the methods specified in "
"the trait available)."
msgstr ""
"간단히 말해, **HAL 구현**, **드라이버** 및 **애플리케이션(또는 펌웨어)** 간의 "
"구현 계약을 정의하는 트레이트 집합입니다. 이러한 계약에는 기능(즉, 특정 타입에 "
"대해 트레이트가 구현되면 **HAL 구현**이 특정 기능을 제공함)과 메서드(즉, 트레이트를 "
"구현하는 타입을 구성할 수 있다면 트레이트에 지정된 메서드를 사용할 수 있음이 "
"보장됨)가 모두 포함됩니다."

#: src/portability/index.md:23
msgid "A typical layering might look like this:"
msgstr "일반적인 계층화는 다음과 같습니다:"

#: src/portability/index.md:25
msgid "![](../assets/rust_layers.svg)"
msgstr "![](../assets/rust_layers.svg)"

#: src/portability/index.md:27
msgid "Some of the defined traits in **embedded-hal** are:"
msgstr "**embedded-hal**에 정의된 트레이트 중 일부는 다음과 같습니다:"

#: src/portability/index.md:28
msgid "GPIO (input and output pins)"
msgstr "GPIO (입력 및 출력 핀)"

#: src/portability/index.md:29
msgid "Serial communication"
msgstr "직렬 통신"

#: src/portability/index.md:30 src/appendix/glossary.md:26
msgid "I2C"
msgstr "I2C"

#: src/portability/index.md:31 src/appendix/glossary.md:42
msgid "SPI"
msgstr "SPI"

#: src/portability/index.md:32
msgid "Timers/Countdowns"
msgstr "타이머/카운트다운"

#: src/portability/index.md:33
msgid "Analog Digital Conversion"
msgstr "아날로그 디지털 변환"

#: src/portability/index.md:35
msgid ""
"The main reason for having the **embedded-hal** traits and crates "
"implementing and using them is to keep complexity in check. If you consider "
"that an application might have to implement the use of the peripheral in the "
"hardware as well as the application and potentially drivers for additional "
"hardware components, then it should be easy to see that the re-usability is "
"very limited. Expressed mathematically, if **M** is the number of peripheral "
"HAL implementations and **N** the number of drivers then if we were to "
"reinvent the wheel for every application then we would end up with **M\\*N** "
"implementations while by using the _API_ provided by the **embedded-hal** "
"traits will make the implementation complexity approach **M+N**. Of course "
"there're additional benefits to be had, such as less trial-and-error due to "
"a well-defined and ready-to-use APIs."
msgstr ""
"**embedded-hal** 트레이트와 이를 구현하고 사용하는 크레이트를 사용하는 주된 "
"이유는 복잡성을 제어하기 위함입니다. 애플리케이션이 하드웨어에서 주변 장치 사용을 "
"구현해야 할 뿐만 아니라 애플리케이션 및 추가 하드웨어 구성 요소용 드라이버도 "
"구현해야 한다고 생각하면 재사용성이 매우 제한적이라는 것을 쉽게 알 수 있습니다. "
"수학적으로 표현하면, **M** 이 주변 장치 HAL 구현의 수이고 **N** 이 드라이버의 "
"수라면, 모든 애플리케이션에 대해 바퀴를 재발명한다면 **M*N** 구현으로 끝나게 될 "
"것입니다. 반면 **embedded-hal** 트레이트가 제공하는 _API_를 사용하면 구현 "
"복잡성이 **M+N**에 가까워질 것입니다. 물론 잘 정의되고 바로 사용할 수 있는 API로 "
"인해 시행착오가 줄어드는 등 추가적인 이점도 있습니다."

#: src/portability/index.md:37
msgid "Users of the embedded-hal"
msgstr "embedded-hal 사용자"

#: src/portability/index.md:39
msgid "As said above there are three main users of the HAL:"
msgstr "위에서 언급했듯이 HAL의 주요 사용자는 세 가지입니다:"

#: src/portability/index.md:41
msgid "HAL implementation"
msgstr "HAL 구현"

#: src/portability/index.md:43
msgid ""
"A HAL implementation provides the interfacing between the hardware and the "
"users of the HAL traits. Typical implementations consist of three parts:"
msgstr ""
"HAL 구현은 하드웨어와 HAL 트레이트 사용자 간의 인터페이스를 제공합니다. 일반적인 "
"구현은 세 부분으로 구성됩니다:"

#: src/portability/index.md:44
msgid "One or more hardware specific types"
msgstr "하나 이상의 하드웨어 특정 타입"

#: src/portability/index.md:45
msgid ""
"Functions to create and initialize such a type, often providing various "
"configuration options (speed, operation mode, use pins, etc.)"
msgstr ""
"이러한 타입을 생성하고 초기화하는 함수, 종종 다양한 구성 옵션(속도, 작동 모드, "
"핀 사용 등)을 제공합니다."

#: src/portability/index.md:46
msgid "one or more `trait` `impl` of **embedded-hal** traits for that type"
msgstr "해당 타입에 대한 **embedded-hal** 트레이트의 하나 이상의 `trait` `impl`"

#: src/portability/index.md:48
msgid "Such a **HAL implementation** can come in various flavours:"
msgstr "이러한 **HAL 구현**은 다양한 형태로 제공될 수 있습니다:"

#: src/portability/index.md:49
msgid "Via low-level hardware access, e.g. via registers"
msgstr "저수준 하드웨어 접근을 통해, 예: 레지스터를 통해"

#: src/portability/index.md:50
msgid "Via operating system, e.g. by using the `sysfs` under Linux"
msgstr "운영 체제를 통해, 예: Linux에서 `sysfs`를 사용하여"

#: src/portability/index.md:51
msgid "Via adapter, e.g. a mock of types for unit testing"
msgstr "어댑터를 통해, 예: 단위 테스트를 위한 타입 모의"

#: src/portability/index.md:52
msgid "Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander"
msgstr "하드웨어 어댑터용 드라이버를 통해, 예: I2C 멀티플렉서 또는 GPIO 확장기"

#: src/portability/index.md:54
msgid "Driver"
msgstr "드라이버"

#: src/portability/index.md:56
msgid ""
"A driver implements a set of custom functionality for an internal or "
"external component, connected to a peripheral implementing the embedded-hal "
"traits. Typical examples for such drivers include various sensors "
"(temperature, magnetometer, accelerometer, light), display devices (LED "
"arrays, LCD displays) and actuators (motors, transmitters)."
msgstr ""
"드라이버는 embedded-hal 트레이트를 구현하는 주변 장치에 연결된 내부 또는 외부 "
"구성 요소에 대한 사용자 지정 기능 집합을 구현합니다. 이러한 드라이버의 일반적인 "
"예로는 다양한 센서(온도, 자력계, 가속도계, 조명), 디스플레이 장치(LED 배열, LCD "
"디스플레이) 및 액추에이터(모터, 송신기)가 있습니다."

#: src/portability/index.md:58
msgid ""
"A driver has to be initialized with an instance of type that implements a "
"certain `trait` of the embedded-hal which is ensured via trait bound and "
"provides its own type instance with a custom set of methods allowing to "
"interact with the driven device."
msgstr ""
"드라이버는 트레이트 바운드를 통해 보장되는 embedded-hal의 특정 `trait`를 구현하는 "
"타입의 인스턴스로 초기화되어야 하며, 구동되는 장치와 상호 작용할 수 있는 사용자 "
"지정 메서드 집합을 가진 자체 타입 인스턴스를 제공합니다."

#: src/portability/index.md:60
msgid "Application"
msgstr "애플리케이션"

#: src/portability/index.md:62
msgid ""
"The application binds the various parts together and ensures that the "
"desired functionality is achieved. When porting between different systems, "
"this is the part which requires the most adaptation efforts, since the "
"application needs to correctly initialize the real hardware via the HAL "
"implementation and the initialisation of different hardware differs, "
"sometimes drastically so. Also the user choice often plays a big role, since "
"components can be physically connected to different terminals, hardware "
"buses sometimes need external hardware to match the configuration or there "
"are different trade-offs to be made in the use of internal peripherals (e.g. "
"multiple timers with different capabilities are available or peripherals "
"conflict with others)."
msgstr ""
"애플리케이션은 다양한 부분을 함께 묶고 원하는 기능이 달성되도록 보장합니다. 다른 "
"시스템 간에 포팅할 때, 이 부분은 가장 많은 적응 노력이 필요한데, 애플리케이션이 "
"HAL 구현을 통해 실제 하드웨어를 올바르게 초기화해야 하고, 다른 하드웨어의 초기화는 "
"때때로 크게 다르기 때문입니다. 또한 구성 요소가 물리적으로 다른 터미널에 연결될 "
"수 있고, 하드웨어 버스가 때때로 구성과 일치하도록 외부 하드웨어가 필요하거나, "
"내부 주변 장치 사용에 있어 다른 트레이드오프가 있을 수 있으므로(예: 다른 기능을 "
"가진 여러 타이머를 사용할 수 있거나 주변 장치가 서로 충돌하는 경우) 사용자 선택도 "
"큰 역할을 합니다."

#: src/concurrency/index.md:3
msgid ""
"Concurrency happens whenever different parts of your program might execute "
"at different times or out of order. In an embedded context, this includes:"
msgstr ""
"동시성은 프로그램의 다른 부분이 다른 시간에 또는 순서에 관계없이 실행될 수 있을 "
"때 발생합니다. 임베디드 컨텍스트에서는 다음을 포함합니다:"

#: src/concurrency/index.md:6
msgid ""
"interrupt handlers, which run whenever the associated interrupt happens,"
msgstr ""
"관련 인터럽트가 발생할 때마다 실행되는 인터럽트 핸들러,"

#: src/concurrency/index.md:7
msgid ""
"various forms of multithreading, where your microprocessor regularly swaps "
"between parts of your program,"
msgstr ""
"마이크로프로세서가 프로그램의 여러 부분 사이를 정기적으로 전환하는 다양한 형태의 "
"멀티스레딩,"

#: src/concurrency/index.md:9
msgid ""
"and in some systems, multiple-core microprocessors, where each core can be "
"independently running a different part of your program at the same time."
msgstr ""
"일부 시스템에서는 각 코어가 동시에 프로그램의 다른 부분을 독립적으로 실행할 수 "
"있는 다중 코어 마이크로프로세서."

#: src/concurrency/index.md:12
msgid ""
"Since many embedded programs need to deal with interrupts, concurrency will "
"usually come up sooner or later, and it's also where many subtle and "
"difficult bugs can occur. Luckily, Rust provides a number of abstractions "
"and safety guarantees to help us write correct code."
msgstr ""
"많은 임베디드 프로그램이 인터럽트를 처리해야 하므로 동시성은 조만간 발생할 "
"것이며, 미묘하고 어려운 버그가 많이 발생할 수 있는 곳이기도 합니다. 다행히 "
"Rust는 올바른 코드를 작성하는 데 도움이 되는 여러 추상화와 안전 보장을 제공합니다."

#: src/concurrency/index.md:17
msgid "No Concurrency"
msgstr "동시성 없음"

#: src/concurrency/index.md:19
msgid ""
"The simplest concurrency for an embedded program is no concurrency: your "
"software consists of a single main loop which just keeps running, and there "
"are no interrupts at all. Sometimes this is perfectly suited to the problem "
"at hand! Typically your loop will read some inputs, perform some processing, "
"and write some outputs."
msgstr ""
"임베디드 프로그램에서 가장 간단한 동시성은 동시성이 없는 것입니다. 소프트웨어는 "
"단일 메인 루프로 구성되어 계속 실행되며, 인터럽트는 전혀 없습니다. 때로는 이것이 "
"당면한 문제에 완벽하게 적합합니다! 일반적으로 루프는 일부 입력을 읽고, 일부 처리를 "
"수행하며, 일부 출력을 작성합니다."

#: src/concurrency/index.md:37
msgid ""
"Since there's no concurrency, there's no need to worry about sharing data "
"between parts of your program or synchronising access to peripherals. If you "
"can get away with such a simple approach this can be a great solution."
msgstr ""
"동시성이 없으므로 프로그램의 여러 부분 간에 데이터를 공유하거나 주변 장치에 대한 "
"접근을 동기화하는 것에 대해 걱정할 필요가 없습니다. 이러한 간단한 접근 방식으로 "
"해결할 수 있다면 훌륭한 해결책이 될 수 있습니다."

#: src/concurrency/index.md:41
msgid "Global Mutable Data"
msgstr "전역 가변 데이터"

#: src/concurrency/index.md:43
msgid ""
"Unlike non-embedded Rust, we will not usually have the luxury of creating "
"heap allocations and passing references to that data into a newly-created "
"thread. Instead, our interrupt handlers might be called at any time and must "
"know how to access whatever shared memory we are using. At the lowest level, "
"this means we must have _statically allocated_ mutable memory, which both "
"the interrupt handler and the main code can refer to."
msgstr ""
"비임베디드 Rust와 달리, 일반적으로 힙 할당을 생성하고 새로 생성된 스레드에 해당 "
"데이터에 대한 참조를 전달하는 사치를 누릴 수 없습니다. 대신, 인터럽트 핸들러는 "
"언제든지 호출될 수 있으며 우리가 사용하는 공유 메모리에 접근하는 방법을 알아야 "
"합니다. 가장 낮은 수준에서는 인터럽트 핸들러와 메인 코드 모두 참조할 수 있는 "
"_정적으로 할당된_ 가변 메모리가 있어야 함을 의미합니다."

#: src/concurrency/index.md:50
msgid ""
"In Rust, such [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) variables are "
"always unsafe to read or write, because without taking special care, you "
"might trigger a race condition, where your access to the variable is "
"interrupted halfway through by an interrupt which also accesses that "
"variable."
msgstr ""
"Rust에서 이러한 [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) 변수는 읽거나 "
"쓰기에는 항상 안전하지 않습니다. 특별한 주의를 기울이지 않으면 변수에 대한 "
"접근이 해당 변수에 접근하는 인터럽트에 의해 중간에 중단되는 경쟁 조건을 유발할 "
"수 있기 때문입니다."

#: src/concurrency/index.md:57
msgid ""
"For an example of how this behaviour can cause subtle errors in your code, "
"consider an embedded program which counts rising edges of some input signal "
"in each one-second period (a frequency counter):"
msgstr ""
"이러한 동작이 코드에서 미묘한 오류를 유발할 수 있는 예시로, 매 1초마다 일부 "
"입력 신호의 상승 에지를 세는 임베디드 프로그램(주파수 카운터)을 고려해 보십시오:"

#: src/concurrency/index.md:71
msgid "// DANGER - Not actually safe! Could cause data races.\n"
msgstr "// 위험 - 실제로는 안전하지 않음! 데이터 경쟁을 유발할 수 있습니다.\n"

#: src/concurrency/index.md:84
msgid ""
"Each second, the timer interrupt sets the counter back to 0. Meanwhile, the "
"main loop continually measures the signal, and incremements the counter when "
"it sees a change from low to high. We've had to use `unsafe` to access "
"`COUNTER`, as it's `static mut`, and that means we're promising the compiler "
"we won't cause any undefined behaviour. Can you spot the race condition? The "
"increment on `COUNTER` is _not_ guaranteed to be atomic — in fact, on most "
"embedded platforms, it will be split into a load, then the increment, then a "
"store. If the interrupt fired after the load but before the store, the reset "
"back to 0 would be ignored after the interrupt returns — and we would count "
"twice as many transitions for that period."
msgstr ""
"매초 타이머 인터럽트는 카운터를 0으로 재설정합니다. 한편, 메인 루프는 지속적으로 "
"신호를 측정하고 낮음에서 높음으로의 변경을 감지하면 카운터를 증가시킵니다. "
"`COUNTER`는 `static mut`이므로 `unsafe`를 사용하여 접근해야 했으며, 이는 "
"컴파일러에게 정의되지 않은 동작을 유발하지 않겠다고 약속하는 것을 의미합니다. "
"경쟁 조건을 발견할 수 있습니까? `COUNTER`의 증가는 원자적이라고 보장되지 "
"않습니다. 실제로 대부분의 임베디드 플랫폼에서는 로드, 증가, 저장으로 "
"분할됩니다. 로드 후 저장 전에 인터럽트가 발생하면 인터럽트가 반환된 후 0으로 "
"재설정하는 것이 무시되고 해당 기간 동안 두 배 많은 전환을 계산하게 됩니다."

#: src/concurrency/index.md:95
msgid "Critical Sections"
msgstr "임계 영역"

#: src/concurrency/index.md:97
msgid ""
"So, what can we do about data races? A simple approach is to use _critical "
"sections_, a context where interrupts are disabled. By wrapping the access "
"to `COUNTER` in `main` in a critical section, we can be sure the timer "
"interrupt will not fire until we're finished incrementing `COUNTER`:"
msgstr ""
"그렇다면 데이터 경쟁에 대해 무엇을 할 수 있을까요? 간단한 접근 방식은 인터럽트가 "
"비활성화된 컨텍스트인 _임계 영역_을 사용하는 것입니다. `main`에서 `COUNTER`에 대한 "
"접근을 임계 영역으로 래핑하면 `COUNTER` 증가가 끝날 때까지 타이머 인터럽트가 "
"발생하지 않도록 할 수 있습니다:"

#: src/concurrency/index.md:112
msgid "// New critical section ensures synchronised access to COUNTER\n"
msgstr "// 새 임계 영역은 COUNTER에 대한 동기화된 접근을 보장합니다\n"

#: src/concurrency/index.md:127
msgid ""
"In this example, we use `cortex_m::interrupt::free`, but other platforms "
"will have similar mechanisms for executing code in a critical section. This "
"is also the same as disabling interrupts, running some code, and then re-"
"enabling interrupts."
msgstr ""
"이 예에서는 `cortex_m::interrupt::free`를 사용하지만 다른 플랫폼에는 임계 영역에서 "
"코드를 실행하기 위한 유사한 메커니즘이 있습니다. 이것은 또한 인터럽트를 "
"비활성화하고 일부 코드를 실행한 다음 인터럽트를 다시 활성화하는 것과 동일합니다."

#: src/concurrency/index.md:132
msgid ""
"Note we didn't need to put a critical section inside the timer interrupt, "
"for two reasons:"
msgstr ""
"두 가지 이유로 타이머 인터럽트 내부에 임계 영역을 넣을 필요가 없었습니다:"

#: src/concurrency/index.md:135
msgid ""
"Writing 0 to `COUNTER` can't be affected by a race since we don't read it"
msgstr "`COUNTER`에 0을 쓰는 것은 읽지 않기 때문에 경쟁의 영향을 받지 않습니다."

#: src/concurrency/index.md:136
msgid "It will never be interrupted by the `main` thread anyway"
msgstr "어쨌든 `main` 스레드에 의해 중단되지 않습니다."

#: src/concurrency/index.md:138
msgid ""
"If `COUNTER` was being shared by multiple interrupt handlers that might "
"_preempt_ each other, then each one might require a critical section as well."
msgstr ""
"`COUNTER`가 서로를 _선점_할 수 있는 여러 인터럽트 핸들러에 의해 공유되고 있었다면 "
"각각 임계 영역이 필요할 수도 있습니다."
"`COUNTER`가 서로를 _선점_할 수 있는 여러 인터럽트 핸들러에 의해 공유되고 있었다면 "
"각각 임계 영역이 필요할 수도 있습니다."

#: src/concurrency/index.md:141
msgid ""
"This solves our immediate problem, but we're still left writing a lot of "
"unsafe code which we need to carefully reason about, and we might be using "
"critical sections needlessly. Since each critical section temporarily pauses "
"interrupt processing, there is an associated cost of some extra code size "
"and higher interrupt latency and jitter (interrupts may take longer to be "
"processed, and the time until they are processed will be more variable). "
"Whether this is a problem depends on your system, but in general, we'd like "
"to avoid it."
msgstr ""
"이것은 즉각적인 문제를 해결하지만, 여전히 신중하게 추론해야 하는 많은 안전하지 "
"않은 코드를 작성해야 하며, 불필요하게 임계 영역을 사용하고 있을 수도 있습니다. 각 "
"임계 영역은 일시적으로 인터럽트 처리를 일시 중지하므로 추가 코드 크기 및 더 높은 "
"인터럽트 대기 시간 및 지터(인터럽트 처리에 더 오래 걸릴 수 있으며 처리될 때까지의 "
"시간이 더 가변적임)와 관련된 비용이 발생합니다. 이것이 문제인지는 시스템에 따라 "
"다르지만 일반적으로 피하는 것이 좋습니다."
"이것은 즉각적인 문제를 해결하지만, 여전히 신중하게 추론해야 하는 많은 안전하지 "
"않은 코드를 작성해야 하며, 불필요하게 임계 영역을 사용하고 있을 수도 있습니다. 각 "
"임계 영역은 일시적으로 인터럽트 처리를 일시 중지하므로 추가 코드 크기 및 더 높은 "
"인터럽트 대기 시간 및 지터(인터럽트 처리에 더 오래 걸릴 수 있으며 처리될 때까지의 "
"시간이 더 가변적임)와 관련된 비용이 발생합니다. 이것이 문제인지는 시스템에 따라 "
"다르지만 일반적으로 피하는 것이 좋습니다."

#: src/concurrency/index.md:143
msgid ""
"It's worth noting that while a critical section guarantees no interrupts "
"will fire, it does not provide an exclusivity guarantee on multi-core "
"systems!  The other core could be happily accessing the same memory as your "
"core, even without interrupts. You will need stronger synchronisation "
"primitives if you are using multiple cores."
msgstr ""
"임계 영역이 인터럽트가 발생하지 않도록 보장하지만 다중 코어 시스템에서는 독점성을 "
"보장하지 않는다는 점은 주목할 가치가 있습니다! 다른 코어는 인터럽트 없이도 코어와 "
"동일한 메모리에 행복하게 접근할 수 있습니다. 다중 코어를 사용하는 경우 더 강력한 "
"동기화 기본 요소가 필요합니다."
"임계 영역이 인터럽트가 발생하지 않도록 보장하지만 다중 코어 시스템에서는 독점성을 "
"보장하지 않는다는 점은 주목할 가치가 있습니다! 다른 코어는 인터럽트 없이도 코어와 "
"동일한 메모리에 행복하게 접근할 수 있습니다. 다중 코어를 사용하는 경우 더 강력한 "
"동기화 기본 요소가 필요합니다."

#: src/concurrency/index.md:149
msgid "Atomic Access"
msgstr "원자적 접근"

#: src/concurrency/index.md:151
msgid ""
"On some platforms, special atomic instructions are available, which provide "
"guarantees about read-modify-write operations. Specifically for Cortex-M: "
"`thumbv6` (Cortex-M0, Cortex-M0+) only provide atomic load and store "
"instructions, while `thumbv7` (Cortex-M3 and above) provide full Compare and "
"Swap (CAS) instructions. These CAS instructions give an alternative to the "
"heavy-handed disabling of all interrupts: we can attempt the increment, it "
"will succeed most of the time, but if it was interrupted it will "
"automatically retry the entire increment operation. These atomic operations "
"are safe even across multiple cores."
msgstr ""
"일부 플랫폼에서는 읽기-수정-쓰기 작업에 대한 보장을 제공하는 특수 원자적 "
"명령을 사용할 수 있습니다. 특히 Cortex-M의 경우: `thumbv6`(Cortex-M0, Cortex-M0+)는 "
"원자적 로드 및 저장 명령만 제공하는 반면, `thumbv7`(Cortex-M3 이상)은 전체 비교 및 "
"교환(CAS) 명령을 제공합니다. 이러한 CAS 명령은 모든 인터럽트를 비활성화하는 강력한 "
"방법에 대한 대안을 제공합니다. 증가를 시도할 수 있으며 대부분의 경우 성공하지만 "
"중단된 경우 전체 증가 작업을 자동으로 다시 시도합니다. 이러한 원자적 작업은 다중 "
"코어에서도 안전합니다."
"일부 플랫폼에서는 읽기-수정-쓰기 작업에 대한 보장을 제공하는 특수 원자적 "
"명령을 사용할 수 있습니다. 특히 Cortex-M의 경우: `thumbv6`(Cortex-M0, Cortex-M0+)는 "
"원자적 로드 및 저장 명령만 제공하는 반면, `thumbv7`(Cortex-M3 이상)은 전체 비교 및 "
"교환(CAS) 명령을 제공합니다. 이러한 CAS 명령은 모든 인터럽트를 비활성화하는 강력한 "
"방법에 대한 대안을 제공합니다. 증가를 시도할 수 있으며 대부분의 경우 성공하지만 "
"중단된 경우 전체 증가 작업을 자동으로 다시 시도합니다. 이러한 원자적 작업은 다중 "
"코어에서도 안전합니다."

#: src/concurrency/index.md:173
msgid "// Use `fetch_add` to atomically add 1 to COUNTER\n"
msgstr "// `fetch_add`를 사용하여 COUNTER에 원자적으로 1을 더합니다\n"

#: src/concurrency/index.md:182
msgid "// Use `store` to write 0 directly to COUNTER\n"
msgstr "// `store`를 사용하여 COUNTER에 직접 0을 씁니다\n"

#: src/concurrency/index.md:187
msgid ""
"This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize` "
"type `COUNTER` can be safely modified from both the interrupt handler and "
"the main thread without disabling interrupts. When possible, this is a "
"better solution — but it may not be supported on your platform."
msgstr ""
"이번에는 `COUNTER`가 안전한 `static` 변수입니다. `AtomicUsize` 타입 덕분에 `COUNTER`는 "
"인터럽트를 비활성화하지 않고도 인터럽트 핸들러와 메인 스레드 모두에서 안전하게 "
"수정할 수 있습니다. 가능하면 이것이 더 나은 해결책이지만 플랫폼에서 지원되지 않을 "
"수 있습니다."
"이번에는 `COUNTER`가 안전한 `static` 변수입니다. `AtomicUsize` 타입 덕분에 `COUNTER`는 "
"인터럽트를 비활성화하지 않고도 인터럽트 핸들러와 메인 스레드 모두에서 안전하게 "
"수정할 수 있습니다. 가능하면 이것이 더 나은 해결책이지만 플랫폼에서 지원되지 않을 "
"수 있습니다."

#: src/concurrency/index.md:192
msgid ""
"A note on [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/"
"enum.Ordering.html): this affects how the compiler and hardware may reorder "
"instructions, and also has consequences on cache visibility. Assuming that "
"the target is a single core platform `Relaxed` is sufficient and the most "
"efficient choice in this particular case. Stricter ordering will cause the "
"compiler to emit memory barriers around the atomic operations; depending on "
"what you're using atomics for you may or may not need this! The precise "
"details of the atomic model are complicated and best described elsewhere."
msgstr ""
"[`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)에 "
"대한 참고 사항: 이것은 컴파일러와 하드웨어가 명령을 재정렬하는 방식에 영향을 "
"미치며 캐시 가시성에도 영향을 미칩니다. 대상이 단일 코어 플랫폼이라고 가정하면 이 "
"특정 경우에 `Relaxed`가 충분하고 가장 효율적인 선택입니다. 더 엄격한 순서는 "
"컴파일러가 원자적 작업 주위에 메모리 장벽을 내보내도록 합니다. 원자적 작업을 "
"사용하는 목적에 따라 이것이 필요할 수도 있고 필요하지 않을 수도 있습니다! 원자적 "
"모델의 정확한 세부 사항은 복잡하며 다른 곳에서 가장 잘 설명되어 있습니다."
"[`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)에 "
"대한 참고 사항: 이것은 컴파일러와 하드웨어가 명령을 재정렬하는 방식에 영향을 "
"미치며 캐시 가시성에도 영향을 미칩니다. 대상이 단일 코어 플랫폼이라고 가정하면 이 "
"특정 경우에 `Relaxed`가 충분하고 가장 효율적인 선택입니다. 더 엄격한 순서는 "
"컴파일러가 원자적 작업 주위에 메모리 장벽을 내보내도록 합니다. 원자적 작업을 "
"사용하는 목적에 따라 이것이 필요할 수도 있고 필요하지 않을 수도 있습니다! 원자적 "
"모델의 정확한 세부 사항은 복잡하며 다른 곳에서 가장 잘 설명되어 있습니다."

#: src/concurrency/index.md:200
msgid ""
"For more details on atomics and ordering, see the [nomicon](https://doc.rust-"
"lang.org/nomicon/atomics.html)."
msgstr "원자성과 순서에 대한 자세한 내용은 [노미콘](https://doc.rust-lang.org/nomicon/atomics.html)을 참조하십시오."

#: src/concurrency/index.md:206
msgid "Abstractions, Send, and Sync"
msgstr "추상화, 보내기 및 동기화"

#: src/concurrency/index.md:208
msgid ""
"None of the above solutions are especially satisfactory. They require "
"`unsafe` blocks which must be very carefully checked and are not ergonomic. "
"Surely we can do better in Rust!"
msgstr ""
"위의 해결책 중 어느 것도 특별히 만족스럽지 않습니다. 매우 신중하게 확인해야 하는 "
"`unsafe` 블록이 필요하며 인체공학적이지 않습니다. 분명히 Rust에서는 더 잘할 수 "
"있습니다!"

#: src/concurrency/index.md:212
msgid ""
"We can abstract our counter into a safe interface which can be safely used "
"anywhere else in our code. For this example, we'll use the critical-section "
"counter, but you could do something very similar with atomics."
msgstr ""
"카운터를 코드의 다른 곳에서 안전하게 사용할 수 있는 안전한 인터페이스로 추상화할 "
"수 있습니다. 이 예에서는 임계 영역 카운터를 사용하지만 원자적 연산으로 매우 유사한 "
"작업을 수행할 수 있습니다."

#: src/concurrency/index.md:219
msgid ""
"// Our counter is just a wrapper around UnsafeCell<u32>, which is the heart\n"
"// of interior mutability in Rust. By using interior mutability, we can "
"have\n"
"// COUNTER be `static` instead of `static mut`, but still able to mutate\n"
"// its counter value.\n"
msgstr ""
"// 우리 카운터는 Rust의 내부 가변성의 핵심인 UnsafeCell<u32>를 감싸는 래퍼일 "
"뿐입니다. 내부 가변성을 사용하면 COUNTER를 'static mut' 대신 'static'으로 만들 수 "
"있지만 여전히 카운터 값을 변경할 수 있습니다.\n"

#: src/concurrency/index.md:230
msgid ""
"// By requiring a CriticalSection be passed in, we know we must\n"
"        // be operating inside a CriticalSection, and so can confidently\n"
"        // use this unsafe block (required to call UnsafeCell::get).\n"
msgstr ""
"// CriticalSection을 전달하도록 요구함으로써, 우리는 CriticalSection 내에서 "
"작동해야 함을 알고 있으므로 이 안전하지 않은 블록(UnsafeCell::get을 호출하는 데 "
"필요)을 자신 있게 사용할 수 있습니다.\n"

#: src/concurrency/index.md:240
msgid "// Required to allow static CSCounter. See explanation below.\n"
msgstr "// 정적 CSCounter를 허용하는 데 필요합니다. 아래 설명을 참조하십시오.\n"

#: src/concurrency/index.md:243
msgid ""
"// COUNTER is no longer `mut` as it uses interior mutability;\n"
"// therefore it also no longer requires unsafe blocks to access.\n"
msgstr ""
"// COUNTER는 내부 가변성을 사용하므로 더 이상 'mut'가 아닙니다. 따라서 더 이상 "
"접근하기 위해 안전하지 않은 블록이 필요하지 않습니다.\n"

#: src/concurrency/index.md:255
msgid "// No unsafe here!\n"
msgstr "// 여기에는 안전하지 않은 것이 없습니다!\n"

#: src/concurrency/index.md:264
msgid ""
"// We do need to enter a critical section here just to obtain a valid\n"
"    // cs token, even though we know no other interrupt could pre-empt\n"
"    // this one.\n"
msgstr ""
"// 다른 인터럽트가 이 인터럽트를 선점할 수 없다는 것을 알고 있음에도 불구하고 유효한 "
"cs 토큰을 얻기 위해 여기에 임계 영역을 입력해야 합니다.\n"

#: src/concurrency/index.md:269
msgid ""
"// We could use unsafe code to generate a fake CriticalSection if we\n"
"    // really wanted to, avoiding the overhead:\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"
msgstr ""
"// 정말 원한다면 오버헤드를 피하기 위해 안전하지 않은 코드를 사용하여 가짜 "
"CriticalSection을 생성할 수 있습니다.\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"

#: src/concurrency/index.md:275
msgid ""
"We've moved our `unsafe` code to inside our carefully-planned abstraction, "
"and now our application code does not contain any `unsafe` blocks."
msgstr ""
"우리는 `unsafe` 코드를 신중하게 계획된 추상화 내부로 옮겼고, 이제 애플리케이션 "
"코드에는 `unsafe` 블록이 포함되지 않습니다."

#: src/concurrency/index.md:278
msgid ""
"This design requires that the application pass a `CriticalSection` token in: "
"these tokens are only safely generated by `interrupt::free`, so by requiring "
"one be passed in, we ensure we are operating inside a critical section, "
"without having to actually do the lock ourselves. This guarantee is provided "
"statically by the compiler: there won't be any runtime overhead associated "
"with `cs`. If we had multiple counters, they could all be given the same "
"`cs`, without requiring multiple nested critical sections."
msgstr ""
"이 설계는 애플리케이션이 `CriticalSection` 토큰을 전달하도록 요구합니다. 이러한 "
"토큰은 `interrupt::free`에 의해서만 안전하게 생성되므로, 하나를 전달하도록 "
"요구함으로써 실제로 잠금을 수행하지 않고도 임계 영역 내에서 작동하고 있음을 "
"보장합니다. 이 보장은 컴파일러에 의해 정적으로 제공됩니다. `cs`와 관련된 런타임 "
"오버헤드는 없습니다. 여러 카운터가 있는 경우 여러 중첩된 임계 영역을 요구하지 "
"않고도 모두 동일한 `cs`를 부여할 수 있습니다."

#: src/concurrency/index.md:286
msgid ""
"This also brings up an important topic for concurrency in Rust: the [`Send` "
"and `Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) traits. To "
"summarise the Rust book, a type is Send when it can safely be moved to "
"another thread, while it is Sync when it can be safely shared between "
"multiple threads. In an embedded context, we consider interrupts to be "
"executing in a separate thread to the application code, so variables "
"accessed by both an interrupt and the main code must be Sync."
msgstr ""
"이것은 또한 Rust의 동시성에 대한 중요한 주제인 [`Send` 및 "
"`Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) 특성을 제기합니다. "
"Rust 책을 요약하면, 타입은 다른 스레드로 안전하게 이동할 수 있을 때 Send이고, 여러 "
"스레드 간에 안전하게 공유할 수 있을 때 Sync입니다. 임베디드 컨텍스트에서 우리는 "
"인터럽트가 애플리케이션 코드와 별도의 스레드에서 실행되는 것으로 간주하므로, "
"인터럽트와 메인 코드 모두에서 접근하는 변수는 Sync여야 합니다."

#: src/concurrency/index.md:296
msgid ""
"For most types in Rust, both of these traits are automatically derived for "
"you by the compiler. However, because `CSCounter` contains an [`UnsafeCell`]"
"(https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html), it is not "
"Sync, and therefore we could not make a `static CSCounter`: `static` "
"variables _must_ be Sync, since they can be accessed by multiple threads."
msgstr ""
"Rust의 대부분의 타입에 대해 이 두 특성은 컴파일러에 의해 자동으로 파생됩니다. "
"그러나 `CSCounter`는 [`UnsafeCell`](https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html)을 "
"포함하므로 Sync가 아니므로 `static CSCounter`를 만들 수 없습니다. `static` 변수는 "
"여러 스레드에서 접근할 수 있으므로 _반드시_ Sync여야 합니다."

#: src/concurrency/index.md:303
msgid ""
"To tell the compiler we have taken care that the `CSCounter` is in fact safe "
"to share between threads, we implement the Sync trait explicitly. As with "
"the previous use of critical sections, this is only safe on single-core "
"platforms: with multiple cores, you would need to go to greater lengths to "
"ensure safety."
msgstr ""
"`CSCounter`가 실제로 스레드 간에 안전하게 공유되도록 처리했음을 컴파일러에 "
"알리기 위해 Sync 특성을 명시적으로 구현합니다. 이전의 임계 영역 사용과 마찬가지로 "
"이것은 단일 코어 플랫폼에서만 안전합니다. 다중 코어의 경우 안전을 보장하기 위해 더 "
"많은 노력이 필요합니다."

#: src/concurrency/index.md:308
msgid "Mutexes"
msgstr "뮤텍스"

#: src/concurrency/index.md:310
msgid ""
"We've created a useful abstraction specific to our counter problem, but "
"there are many common abstractions used for concurrency."
msgstr ""
"카운터 문제에 특정한 유용한 추상화를 만들었지만 동시성에 사용되는 일반적인 "
"추상화가 많이 있습니다."

#: src/concurrency/index.md:313
msgid ""
"One such _synchronisation primitive_ is a mutex, short for mutual exclusion. "
"A thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds "
"immediately, or blocks waiting for the lock to be acquired, or returns an "
"error that the mutex could not be locked. While that thread holds the lock, "
"it is granted access to the protected data. When the thread is done, it "
"_unlocks_ (or _releases_) the mutex, allowing another thread to lock it. In "
"Rust, we would usually implement the unlock using the [`Drop`](https://"
"doc.rust-lang.org/core/ops/trait.Drop.html) trait to ensure it is always "
"released when the mutex goes out of scope."
msgstr ""
"그러한 _동기화 기본 요소_ 중 하나는 상호 배제를 의미하는 뮤텍스입니다. 스레드는 "
"뮤텍스를 _잠그려고_ (또는 _획득하려고_) 시도할 수 있으며, 즉시 성공하거나 잠금이 "
"획득될 때까지 차단되거나 뮤텍스를 잠글 수 없다는 오류를 반환합니다. 해당 스레드가 "
"잠금을 보유하는 동안 보호된 데이터에 대한 접근이 허용됩니다. 스레드가 완료되면 "
"뮤텍스를 _잠금 해제_ (또는 _해제_)하여 다른 스레드가 잠글 수 있도록 합니다. Rust에서는 "
"일반적으로 뮤텍스가 범위를 벗어날 때 항상 해제되도록 [`Drop`](https://doc.rust-lang.org/core/ops/trait.Drop.html) "
"특성을 사용하여 잠금 해제를 구현합니다."

#: src/concurrency/index.md:325
msgid ""
"Using a mutex with interrupt handlers can be tricky: it is not normally "
"acceptable for the interrupt handler to block, and it would be especially "
"disastrous for it to block waiting for the main thread to release a lock, "
"since we would then _deadlock_ (the main thread will never release the lock "
"because execution stays in the interrupt handler). Deadlocking is not "
"considered unsafe: it is possible even in safe Rust."
msgstr ""
"인터럽트 핸들러와 함께 뮤텍스를 사용하는 것은 까다로울 수 있습니다. 인터럽트 "
"핸들러가 차단되는 것은 일반적으로 허용되지 않으며, 메인 스레드가 잠금을 해제하기를 "
"기다리며 차단되는 것은 특히 재앙적일 것입니다. 그러면 _교착 상태_가 발생하기 "
"때문입니다(실행이 인터럽트 핸들러에 머물기 때문에 메인 스레드는 잠금을 절대 "
"해제하지 않습니다). 교착 상태는 안전하지 않은 것으로 간주되지 않으며, 안전한 "
"Rust에서도 가능합니다."

#: src/concurrency/index.md:332
msgid ""
"To avoid this behaviour entirely, we could implement a mutex which requires "
"a critical section to lock, just like our counter example. So long as the "
"critical section must last as long as the lock, we can be sure we have "
"exclusive access to the wrapped variable without even needing to track the "
"lock/unlock state of the mutex."
msgstr ""
"이러한 동작을 완전히 피하기 위해, 카운터 예제와 같이 잠그기 위해 임계 영역이 "
"필요한 뮤텍스를 구현할 수 있습니다. 임계 영역이 잠금만큼 오래 지속되어야 하는 한, "
"뮤텍스의 잠금/잠금 해제 상태를 추적할 필요 없이 래핑된 변수에 대한 독점적인 접근 "
"권한을 가질 수 있습니다."

#: src/concurrency/index.md:338
msgid ""
"This is in fact done for us in the `cortex_m` crate! We could have written "
"our counter using it:"
msgstr ""
"사실 이것은 `cortex_m` 크레이트에서 우리를 위해 수행됩니다! 우리는 그것을 사용하여 "
"카운터를 작성할 수 있었습니다:"

#: src/concurrency/index.md:363
msgid ""
"// We still need to enter a critical section here to satisfy the Mutex.\n"
msgstr "// 뮤텍스를 만족시키기 위해 여기에 임계 영역을 입력해야 합니다.\n"

#: src/concurrency/index.md:368
msgid ""
"We're now using [`Cell`](https://doc.rust-lang.org/core/cell/"
"struct.Cell.html), which along with its sibling `RefCell` is used to provide "
"safe interior mutability. We've already seen `UnsafeCell` which is the "
"bottom layer of interior mutability in Rust: it allows you to obtain "
"multiple mutable references to its value, but only with unsafe code. A "
"`Cell` is like an `UnsafeCell` but it provides a safe interface: it only "
"permits taking a copy of the current value or replacing it, not taking a "
"reference, and since it is not Sync, it cannot be shared between threads. "
"These constraints mean it's safe to use, but we couldn't use it directly in "
"a `static` variable as a `static` must be Sync."
msgstr ""
"이제 우리는 [`Cell`](https://doc.rust-lang.org/core/cell/struct.Cell.html)을 "
"사용하고 있습니다. 이것은 형제인 `RefCell`과 함께 안전한 내부 가변성을 제공하는 데 "
"사용됩니다. 우리는 이미 Rust의 내부 가변성의 가장 낮은 계층인 `UnsafeCell`을 "
"보았습니다. 이것은 값에 대한 여러 개의 가변 참조를 얻을 수 있지만 안전하지 않은 "
"코드로만 가능합니다. `Cell`은 `UnsafeCell`과 같지만 안전한 인터페이스를 "
"제공합니다. 현재 값의 복사본을 가져오거나 교체하는 것만 허용하고 참조를 가져오는 "
"것은 허용하지 않으며, Sync가 아니므로 스레드 간에 공유할 수 없습니다. 이러한 제약 "
"조건은 사용하기에 안전하다는 것을 의미하지만, `static`은 Sync여야 하므로 `static` "
"변수에서 직접 사용할 수 없습니다."

#: src/concurrency/index.md:380
msgid ""
"So why does the example above work? The `Mutex<T>` implements Sync for any "
"`T` which is Send — such as a `Cell`. It can do this safely because it only "
"gives access to its contents during a critical section. We're therefore able "
"to get a safe counter with no unsafe code at all!"
msgstr ""
"그렇다면 위의 예제는 왜 작동할까요? `Mutex<T>`는 `Cell`과 같이 Send인 모든 `T`에 "
"대해 Sync를 구현합니다. 임계 영역 동안에만 내용에 대한 접근을 허용하기 때문에 "
"안전하게 이 작업을 수행할 수 있습니다. 따라서 우리는 안전하지 않은 코드 없이 안전한 "
"카운터를 얻을 수 있습니다!"

#: src/concurrency/index.md:385
msgid ""
"This is great for simple types like the `u32` of our counter, but what about "
"more complex types which are not Copy? An extremely common example in an "
"embedded context is a peripheral struct, which generally is not Copy. For "
"that, we can turn to `RefCell`."
msgstr ""
"이것은 우리 카운터의 `u32`와 같은 간단한 타입에는 좋지만, 복사가 아닌 더 복잡한 "
"타입은 어떻습니까? 임베디드 컨텍스트에서 매우 일반적인 예는 일반적으로 복사가 아닌 "
"주변 장치 구조체입니다. 이를 위해 `RefCell`을 사용할 수 있습니다."

#: src/concurrency/index.md:390
msgid "Sharing Peripherals"
msgstr "주변 장치 공유"

#: src/concurrency/index.md:392
msgid ""
"Device crates generated using `svd2rust` and similar abstractions provide "
"safe access to peripherals by enforcing that only one instance of the "
"peripheral struct can exist at a time. This ensures safety, but makes it "
"difficult to access a peripheral from both the main thread and an interrupt "
"handler."
msgstr ""
"`svd2rust` 및 유사한 추상화를 사용하여 생성된 장치 크레이트는 한 번에 주변 장치 "
"구조체의 인스턴스가 하나만 존재하도록 강제하여 주변 장치에 대한 안전한 접근을 "
"제공합니다. 이것은 안전을 보장하지만 메인 스레드와 인터럽트 핸들러 모두에서 주변 "
"장치에 접근하기 어렵게 만듭니다."

#: src/concurrency/index.md:398
msgid ""
"To safely share peripheral access, we can use the `Mutex` we saw before. "
"We'll also need to use [`RefCell`](https://doc.rust-lang.org/core/cell/"
"struct.RefCell.html), which uses a runtime check to ensure only one "
"reference to a peripheral is given out at a time. This has more overhead "
"than the plain `Cell`, but since we are giving out references rather than "
"copies, we must be sure only one exists at a time."
msgstr ""
"주변 장치 접근을 안전하게 공유하기 위해 이전에 본 `Mutex`를 사용할 수 있습니다. "
"또한 한 번에 주변 장치에 대한 참조가 하나만 제공되도록 런타임 검사를 사용하는 "
"[`RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html)을 사용해야 "
"합니다. 이것은 일반 `Cell`보다 오버헤드가 더 많지만, 복사본이 아닌 참조를 "
"제공하므로 한 번에 하나만 존재하는지 확인해야 합니다."

#: src/concurrency/index.md:406
msgid ""
"Finally, we'll also have to account for somehow moving the peripheral into "
"the shared variable after it has been initialised in the main code. To do "
"this we can use the `Option` type, initialised to `None` and later set to "
"the instance of the peripheral."
msgstr ""
"마지막으로, 메인 코드에서 초기화된 후 주변 장치를 공유 변수로 이동하는 방법을 "
"고려해야 합니다. 이를 위해 `Option` 타입을 사용할 수 있으며, `None`으로 초기화한 다음 "
"나중에 주변 장치의 인스턴스로 설정합니다."

#: src/concurrency/index.md:421
msgid ""
"// Obtain the peripheral singletons and configure it.\n"
"    // This example is from an svd2rust-generated crate, but\n"
"    // most embedded device crates will be similar.\n"
msgstr ""
"// 주변 장치 싱글톤을 얻고 구성합니다.\n"
"    // 이 예제는 svd2rust에서 생성된 크레이트에서 가져왔지만\n"
"    // 대부분의 임베디드 장치 크레이트는 유사합니다.\n"

#: src/concurrency/index.md:427
msgid ""
"// Some sort of configuration function.\n"
"    // Assume it sets PA0 to an input and PA1 to an output.\n"
msgstr ""

#: src/concurrency/index.md:431
msgid "// Store the GPIOA in the mutex, moving it.\n"
msgstr "// GPIOA를 뮤텍스에 저장하고 이동합니다.\n"

#: src/concurrency/index.md:433
msgid ""
"// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to\n"
"    // access it via the mutex.\n"
msgstr ""
"// 더 이상 'gpioa' 또는 'dp.GPIOA'를 사용할 수 없으며, 대신 뮤텍스를 통해 접근해야 "
"합니다.\n"

#: src/concurrency/index.md:436
msgid ""
"// Be careful to enable the interrupt only after setting MY_GPIO:\n"
"    // otherwise the interrupt might fire while it still contains None,\n"
"    // and as-written (with `unwrap()`), it would panic.\n"
msgstr ""
"// MY_GPIO를 설정한 후에만 인터럽트를 활성화하도록 주의하십시오.\n"
"    // 그렇지 않으면 인터럽트가 여전히 None을 포함하는 동안 발생할 수 있으며,\n"
"    // 작성된 대로('unwrap()' 포함) 패닉이 발생합니다.\n"

#: src/concurrency/index.md:442
msgid "// We'll now read state as a digital input, via the mutex\n"
msgstr "// 이제 뮤텍스를 통해 상태를 디지털 입력으로 읽습니다\n"

#: src/concurrency/index.md:449
msgid "// Set PA1 high if we've seen a rising edge on PA0.\n"
msgstr "// PA0에서 상승 에지를 감지하면 PA1을 높게 설정합니다.\n"

#: src/concurrency/index.md:461
msgid "// This time in the interrupt we'll just clear PA0.\n"
msgstr "// 이번에는 인터럽트에서 PA0을 지우기만 하면 됩니다.\n"

#: src/concurrency/index.md:463
msgid ""
"// We can use `unwrap()` because we know the interrupt wasn't enabled\n"
"        // until after MY_GPIO was set; otherwise we should handle the "
"potential\n"
"        // for a None value.\n"
msgstr ""
"// 인터럽트가 MY_GPIO가 설정된 후에 활성화되지 않았다는 것을 알고 있으므로 `unwrap()`을 "
"사용할 수 있습니다. 그렇지 않으면 None 값의 가능성을 처리해야 합니다.\n"

#: src/concurrency/index.md:472
msgid "That's quite a lot to take in, so let's break down the important lines."
msgstr "상당히 많은 내용이므로 중요한 부분을 분석해 보겠습니다."

#: src/concurrency/index.md:479
msgid ""
"Our shared variable is now a `Mutex` around a `RefCell` which contains an "
"`Option`. The `Mutex` ensures we only have access during a critical section, "
"and therefore makes the variable Sync, even though a plain `RefCell` would "
"not be Sync. The `RefCell` gives us interior mutability with references, "
"which we'll need to use our `GPIOA`. The `Option` lets us initialise this "
"variable to something empty, and only later actually move the variable in. "
"We cannot access the peripheral singleton statically, only at runtime, so "
"this is required."
msgstr ""
"이제 공유 변수는 `Option`을 포함하는 `RefCell` 주위의 `Mutex`입니다. `Mutex`는 "
"임계 영역 동안에만 접근할 수 있도록 보장하므로 일반 `RefCell`이 Sync가 아니더라도 "
"변수를 Sync로 만듭니다. `RefCell`은 `GPIOA`를 사용하는 데 필요한 참조를 사용하여 "
"내부 가변성을 제공합니다. `Option`을 사용하면 이 변수를 빈 값으로 초기화하고 "
"나중에 실제로 변수를 이동할 수 있습니다. 주변 장치 싱글톤에 정적으로 접근할 수 "
"없으며 런타임에만 접근할 수 있으므로 이것이 필요합니다."

#: src/concurrency/index.md:492
msgid ""
"Inside a critical section we can call `borrow()` on the mutex, which gives "
"us a reference to the `RefCell`. We then call `replace()` to move our new "
"value into the `RefCell`."
msgstr ""
"임계 영역 내에서 뮤텍스에 대해 `borrow()`를 호출할 수 있으며, 이는 `RefCell`에 대한 "
"참조를 제공합니다. 그런 다음 `replace()`를 호출하여 새 값을 `RefCell`로 이동합니다."

#: src/concurrency/index.md:503
msgid ""
"Finally, we use `MY_GPIO` in a safe and concurrent fashion. The critical "
"section prevents the interrupt firing as usual, and lets us borrow the "
"mutex.  The `RefCell` then gives us an `&Option<GPIOA>`, and tracks how long "
"it remains borrowed - once that reference goes out of scope, the `RefCell` "
"will be updated to indicate it is no longer borrowed."
msgstr ""
"마지막으로, `MY_GPIO`를 안전하고 동시적인 방식으로 사용합니다. 임계 영역은 평소와 "
"같이 인터럽트 발생을 방지하고 뮤텍스를 빌릴 수 있도록 합니다. 그런 다음 `RefCell`은 "
"`&Option<GPIOA>`를 제공하고 빌린 상태로 유지되는 기간을 추적합니다. 해당 참조가 "
"범위를 벗어나면 `RefCell`은 더 이상 빌리지 않았음을 나타내도록 업데이트됩니다."

#: src/concurrency/index.md:509
msgid ""
"Since we can't move the `GPIOA` out of the `&Option`, we need to convert it "
"to an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to "
"obtain the `&GPIOA` which lets us modify the peripheral."
msgstr ""
"`GPIOA`를 `&Option` 밖으로 이동할 수 없으므로 `as_ref()`를 사용하여 `&Option<&GPIOA>`로 "
"변환해야 합니다. 마지막으로 `unwrap()`하여 주변 장치를 수정할 수 있는 `&GPIOA`를 "
"얻을 수 있습니다."

#: src/concurrency/index.md:513
msgid ""
"If we need a mutable reference to a shared resource, then `borrow_mut` and "
"`deref_mut` should be used instead. The following code shows an example "
"using the TIM2 timer."
msgstr ""
"공유 리소스에 대한 가변 참조가 필요한 경우 `borrow_mut` 및 `deref_mut`를 대신 "
"사용해야 합니다. 다음 코드는 TIM2 타이머를 사용하는 예제를 보여줍니다."

#: src/concurrency/index.md:531
msgid ""
"// Some sort of timer configuration function.\n"
"    // Assume it configures the TIM2 timer, its NVIC interrupt,\n"
"    // and finally starts the timer.\n"
msgstr ""
"// 어떤 종류의 타이머 구성 함수입니다.\n"
"    // TIM2 타이머, 해당 NVIC 인터럽트를 구성하고\n"
"    // 마지막으로 타이머를 시작한다고 가정합니다.\n"
"// 어떤 종류의 타이머 구성 함수입니다.\n"
"    // TIM2 타이머, 해당 NVIC 인터럽트를 구성하고\n"
"    // 마지막으로 타이머를 시작한다고 가정합니다.\n"

#: src/concurrency/index.md:556
msgid ""
"Whew! This is safe, but it is also a little unwieldy. Is there anything else "
"we can do?"
msgstr "휴! 이것은 안전하지만 다루기에는 약간 번거롭습니다. 우리가 할 수 있는 다른 일이 있을까요?"

#: src/concurrency/index.md:559
msgid "RTIC"
msgstr "RTIC"

#: src/concurrency/index.md:561
msgid ""
"One alternative is the [RTIC framework](https://github.com/rtic-rs/cortex-m-"
"rtic), short for Real Time Interrupt-driven Concurrency. It enforces static "
"priorities and tracks accesses to `static mut` variables (\"resources\") to "
"statically ensure that shared resources are always accessed safely, without "
"requiring the overhead of always entering critical sections and using "
"reference counting (as in `RefCell`). This has a number of advantages such "
"as guaranteeing no deadlocks and giving extremely low time and memory "
"overhead."
msgstr ""
"RTIC 프레임워크(실시간 인터럽트 기반 동시성의 약자)는 한 가지 대안입니다. 정적 "
"우선순위를 적용하고 'static mut' 변수(\"리소스\")에 대한 액세스를 추적하여 공유 "
"리소스에 항상 안전하게 액세스할 수 있도록 정적으로 보장하며, 항상 임계 영역에 "
"들어가고 참조 계산(예: 'RefCell')을 사용하는 오버헤드가 필요하지 않습니다. 이는 "
"교착 상태가 없음을 보장하고 매우 낮은 시간 및 메모리 오버헤드를 제공하는 등 여러 "
"가지 이점이 있습니다."

#: src/concurrency/index.md:570
msgid ""
"The framework also includes other features like message passing, which "
"reduces the need for explicit shared state, and the ability to schedule "
"tasks to run at a given time, which can be used to implement periodic tasks. "
"Check out [the documentation](https://rtic.rs) for more information!"
msgstr ""
"이 프레임워크에는 명시적인 공유 상태의 필요성을 줄여주는 메시지 전달과 같은 다른 "
"기능과 주어진 시간에 실행되도록 작업을 예약하는 기능이 포함되어 있어 주기적인 "
"작업을 구현하는 데 사용할 수 있습니다. 자세한 내용은 [설명서](https://rtic.rs)를 "
"확인하십시오!"

#: src/concurrency/index.md:577
msgid "Real Time Operating Systems"
msgstr "실시간 운영 체제"

#: src/concurrency/index.md:579
msgid ""
"Another common model for embedded concurrency is the real-time operating "
"system (RTOS). While currently less well explored in Rust, they are widely "
"used in traditional embedded development. Open source examples include "
"[FreeRTOS](https://freertos.org/) and [ChibiOS](http://chibios.org/). These "
"RTOSs provide support for running multiple application threads which the CPU "
"swaps between, either when the threads yield control (called cooperative "
"multitasking) or based on a regular timer or interrupts (preemptive "
"multitasking). The RTOS typically provide mutexes and other synchronisation "
"primitives, and often interoperate with hardware features such as DMA "
"engines."
msgstr ""
"임베디드 동시성을 위한 또 다른 일반적인 모델은 실시간 운영 체제(RTOS)입니다. "
"현재 Rust에서는 잘 연구되지 않았지만 기존 임베디드 개발에서는 널리 사용됩니다. "
"오픈 소스 예로는 [FreeRTOS](https://freertos.org/) 및 [ChibiOS](http://chibios.org/)가 "
"있습니다. 이러한 RTOS는 스레드가 제어를 양보할 때(협력적 멀티태스킹이라고 함) "
"또는 일반 타이머 또는 인터럽트(선점형 멀티태스킹)를 기반으로 CPU가 전환하는 "
"여러 애플리케이션 스레드를 실행하기 위한 지원을 제공합니다. RTOS는 일반적으로 "
"뮤텍스 및 기타 동기화 기본 요소를 제공하며 종종 DMA 엔진과 같은 하드웨어 "
"기능과 상호 운용됩니다."

#: src/concurrency/index.md:591
msgid ""
"At the time of writing, there are not many Rust RTOS examples to point to, "
"but it's an interesting area so watch this space!"
msgstr "이 글을 쓰는 시점에는 참고할 만한 Rust RTOS 예제가 많지 않지만 흥미로운 분야이므로 이 공간을 주목하십시오!"

#: src/concurrency/index.md:594
msgid "Multiple Cores"
msgstr "다중 코어"

#: src/concurrency/index.md:596
msgid ""
"It is becoming more common to have two or more cores in embedded processors, "
"which adds an extra layer of complexity to concurrency. All the examples "
"using a critical section (including the `cortex_m::interrupt::Mutex`) assume "
"the only other execution thread is the interrupt thread, but on a multi-core "
"system that's no longer true. Instead, we'll need synchronisation primitives "
"designed for multiple cores (also called SMP, for symmetric multi-"
"processing)."
msgstr ""
"임베디드 프로세서에 두 개 이상의 코어가 있는 것이 더 일반적이 되어 동시성에 "
"복잡성을 한층 더 더합니다. 임계 영역을 사용하는 모든 예제(`cortex_m::interrupt::Mutex` "
"포함)는 유일한 다른 실행 스레드가 인터럽트 스레드라고 가정하지만 다중 코어 "
"시스템에서는 더 이상 그렇지 않습니다. 대신 다중 코어용으로 설계된 동기화 기본 "
"요소(대칭 다중 처리를 위해 SMP라고도 함)가 필요합니다."

#: src/concurrency/index.md:603
msgid ""
"These typically use the atomic instructions we saw earlier, since the "
"processing system will ensure that atomicity is maintained over all cores."
msgstr "처리 시스템이 모든 코어에서 원자성이 유지되도록 보장하므로 일반적으로 이전에 본 원자적 명령을 사용합니다."

#: src/concurrency/index.md:606
msgid ""
"Covering these topics in detail is currently beyond the scope of this book, "
"but the general patterns are the same as for the single-core case."
msgstr "이러한 주제를 자세히 다루는 것은 현재 이 책의 범위를 벗어나지만 일반적인 패턴은 단일 코어의 경우와 동일합니다."

#: src/collections/index.md:3
msgid ""
"Eventually you'll want to use dynamic data structures (AKA collections) in "
"your program. `std` provides a set of common collections: [`Vec`](https://"
"doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html), etc. All the collections "
"implemented in `std` use a global dynamic memory allocator (AKA the heap)."
msgstr ""
"결국 프로그램에서 동적 데이터 구조(일명 컬렉션)를 사용하고 싶을 것입니다. `std`는 "
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html) 등과 같은 일반적인 컬렉션 집합을 "
"제공합니다. `std`에 구현된 모든 컬렉션은 전역 동적 메모리 할당자(일명 힙)를 "
"사용합니다."

#: src/collections/index.md:12
msgid ""
"As `core` is, by definition, free of memory allocations these "
"implementations are not available there, but they can be found in the "
"`alloc` crate that's shipped with the compiler."
msgstr "'core'는 정의상 메모리 할당이 없으므로 이러한 구현은 거기에서 사용할 수 없지만 컴파일러와 함께 제공되는 'alloc' 크레이트에서 찾을 수 있습니다."

#: src/collections/index.md:16
msgid ""
"If you need collections, a heap allocated implementation is not your only "
"option. You can also use _fixed capacity_ collections; one such "
"implementation can be found in the [`heapless`](https://crates.io/crates/"
"heapless) crate."
msgstr ""
"컬렉션이 필요한 경우 힙 할당 구현이 유일한 옵션은 아닙니다. _고정 용량_ "
"컬렉션을 사용할 수도 있습니다. 이러한 구현 중 하나는 [`heapless`](https://crates.io/crates/"
"heapless) 크레이트에서 찾을 수 있습니다."

#: src/collections/index.md:22
msgid "In this section, we'll explore and compare these two implementations."
msgstr "이 섹션에서는 이 두 가지 구현을 살펴보고 비교합니다."

#: src/collections/index.md:24
msgid "Using `alloc`"
msgstr "`alloc` 사용"

#: src/collections/index.md:26
msgid ""
"The `alloc` crate is shipped with the standard Rust distribution. To import "
"the crate you can directly `use` it _without_ declaring it as a dependency "
"in your `Cargo.toml` file."
msgstr ""
"`alloc` 크레이트는 표준 Rust 배포판과 함께 제공됩니다. 크레이트를 가져오려면 "
"`Cargo.toml` 파일에서 종속성으로 선언하지 않고 직접 `use`할 수 있습니다."

#: src/collections/index.md:38
msgid ""
"To be able to use any collection you'll first need use the "
"`global_allocator` attribute to declare the global allocator your program "
"will use. It's required that the allocator you select implements the "
"[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"trait."
msgstr ""
"컬렉션을 사용하려면 먼저 `global_allocator` 속성을 사용하여 프로그램에서 사용할 "
"전역 할당자를 선언해야 합니다. 선택한 할당자는 [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"트레이트를 구현해야 합니다."

#: src/collections/index.md:44
msgid ""
"For completeness and to keep this section as self-contained as possible "
"we'll implement a simple bump pointer allocator and use that as the global "
"allocator. However, we _strongly_ suggest you use a battle tested allocator "
"from crates.io in your program instead of this allocator."
msgstr ""
"완전성을 기하고 이 섹션을 최대한 독립적으로 유지하기 위해 간단한 범프 포인터 "
"할당자를 구현하고 이를 전역 할당자로 사용할 것입니다. 그러나 이 할당자 대신 "
"프로그램에서 crates.io의 검증된 할당자를 사용하는 것이 좋습니다."

#: src/collections/index.md:50
msgid "// Bump pointer allocator implementation\n"
msgstr "// 범프 포인터 할당자 구현\n"

#: src/collections/index.md:57
msgid "// Bump pointer allocator for *single* core systems\n"
msgstr "// *단일* 코어 시스템용 범프 포인터 할당자\n"

#: src/collections/index.md:68
msgid ""
"// `interrupt::free` is a critical section that makes our allocator safe\n"
"        // to use from within interrupts\n"
msgstr "// `interrupt::free`는 인터럽트 내에서 할당자를 안전하게 사용할 수 있도록 하는 임계 영역입니다\n"

#: src/collections/index.md:76
msgid "// move start up to the next alignment boundary\n"
msgstr "// 시작을 다음 정렬 경계로 이동\n"

#: src/collections/index.md:80
msgid "// a null pointer signal an Out Of Memory condition\n"
msgstr "// null 포인터는 메모리 부족 상태를 나타냅니다\n"

#: src/collections/index.md:90
msgid "// this allocator never deallocates memory\n"
msgstr "// 이 할당자는 메모리를 절대 해제하지 않습니다\n"

#: src/collections/index.md:93
msgid ""
"// Declaration of the global memory allocator\n"
"// NOTE the user must ensure that the memory region `[0x2000_0100, "
"0x2000_0200]`\n"
"// is not used by other parts of the program\n"
msgstr ""
"// 전역 메모리 할당자 선언\n"
"// 참고: 사용자는 메모리 영역 `[0x2000_0100, 0x2000_0200]`이\n"
"// 프로그램의 다른 부분에서 사용되지 않도록 해야 합니다\n"

#: src/collections/index.md:104
msgid ""
"Apart from selecting a global allocator the user will also have to define "
"how Out Of Memory (OOM) errors are handled using the _unstable_ "
"`alloc_error_handler` attribute."
msgstr ""
"전역 할당자를 선택하는 것 외에도 사용자는 _불안정한_ `alloc_error_handler` "
"속성을 사용하여 메모리 부족(OOM) 오류를 처리하는 방법을 정의해야 합니다."

#: src/collections/index.md:121
msgid ""
"Once all that is in place, the user can finally use the collections in "
"`alloc`."
msgstr ""

#: src/collections/index.md:137
msgid ""
"If you have used the collections in the `std` crate then these will be "
"familiar as they are exact same implementation."
msgstr "`std` 크레이트의 컬렉션을 사용해 본 적이 있다면 이것들은 정확히 동일한 구현이므로 익숙할 것입니다."

#: src/collections/index.md:140
msgid "Using `heapless`"
msgstr "`heapless` 사용"

#: src/collections/index.md:142
msgid ""
"`heapless` requires no setup as its collections don't depend on a global "
"memory allocator. Just `use` its collections and proceed to instantiate them:"
msgstr ""
"`heapless`는 컬렉션이 전역 메모리 할당자에 의존하지 않으므로 설정이 필요하지 "
"않습니다. 컬렉션을 `use`하고 인스턴스화하기만 하면 됩니다."

#: src/collections/index.md:146
msgid "// heapless version: v0.4.x\n"
msgstr "// heapless 버전: v0.4.x\n"

#: src/collections/index.md:160
msgid ""
"You'll note two differences between these collections and the ones in "
"`alloc`."
msgstr ""

#: src/collections/index.md:162
msgid ""
"First, you have to declare upfront the capacity of the collection. "
"`heapless` collections never reallocate and have fixed capacities; this "
"capacity is part of the type signature of the collection. In this case we "
"have declared that `xs` has a capacity of 8 elements that is the vector can, "
"at most, hold 8 elements. This is indicated by the `U8` (see [`typenum`]"
"(https://crates.io/crates/typenum)) in the type signature."
msgstr ""
"먼저 컬렉션의 용량을 미리 선언해야 합니다. `heapless` 컬렉션은 절대 "
"재할당되지 않으며 고정 용량을 가집니다. 이 용량은 컬렉션의 유형 서명의 "
"일부입니다. 이 경우 `xs`의 용량이 8개 요소라고 선언했습니다. 즉, 벡터는 "
"최대 8개의 요소를 보유할 수 있습니다. 이것은 유형 서명의 `U8`([`typenum`])"
"(https://crates.io/crates/typenum) 참조)로 표시됩니다."

#: src/collections/index.md:170
msgid ""
"Second, the `push` method, and many other methods, return a `Result`. Since "
"the `heapless` collections have fixed capacity all operations that insert "
"elements into the collection can potentially fail. The API reflects this "
"problem by returning a `Result` indicating whether the operation succeeded "
"or not. In contrast, `alloc` collections will reallocate themselves on the "
"heap to increase their capacity."
msgstr ""
"두 번째로, `push` 메서드와 다른 많은 메서드는 `Result`를 반환합니다. "
"`heapless` 컬렉션은 고정 용량을 가지므로 컬렉션에 요소를 삽입하는 모든 "
"작업은 잠재적으로 실패할 수 있습니다. API는 작업 성공 여부를 나타내는 "
"`Result`를 반환하여 이 문제를 반영합니다. 반면 `alloc` 컬렉션은 용량을 "
"늘리기 위해 힙에서 자체적으로 재할당됩니다."

#: src/collections/index.md:177
msgid ""
"As of version v0.4.x all `heapless` collections store all their elements "
"inline. This means that an operation like `let x = heapless::Vec::new();` "
"will allocate the collection on the stack, but it's also possible to "
"allocate the collection on a `static` variable, or even on the heap "
"(`Box<Vec<_, _>>`)."
msgstr ""
"v0.4.x 버전부터 모든 `heapless` 컬렉션은 모든 요소를 인라인으로 저장합니다. "
"즉, `let x = heapless::Vec::new();`와 같은 작업은 스택에 컬렉션을 할당하지만 "
"`static` 변수나 힙(`Box<Vec<_, _>>`)에 컬렉션을 할당할 수도 있습니다."

#: src/collections/index.md:182
msgid "Trade-offs"
msgstr "절충점"

#: src/collections/index.md:184
msgid ""
"Keep these in mind when choosing between heap allocated, relocatable "
"collections and fixed capacity collections."
msgstr "힙 할당, 재배치 가능 컬렉션과 고정 용량 컬렉션 중에서 선택할 때 다음 사항을 염두에 두십시오."

#: src/collections/index.md:187
msgid "Out Of Memory and error handling"
msgstr "메모리 부족 및 오류 처리"

#: src/collections/index.md:189
msgid ""
"With heap allocations Out Of Memory is always a possibility and can occur in "
"any place where a collection may need to grow: for example, all "
"`alloc::Vec.push` invocations can potentially generate an OOM condition. "
"Thus some operations can _implicitly_ fail. Some `alloc` collections expose "
"`try_reserve` methods that let you check for potential OOM conditions when "
"growing the collection but you need be proactive about using them."
msgstr ""
"힙 할당을 사용하면 항상 메모리 부족이 발생할 수 있으며 컬렉션이 커져야 하는 "
"모든 곳에서 발생할 수 있습니다. 예를 들어 모든 `alloc::Vec.push` 호출은 "
"잠재적으로 OOM 조건을 생성할 수 있습니다. 따라서 일부 작업은 _암시적으로_ "
"실패할 수 있습니다. 일부 `alloc` 컬렉션은 컬렉션을 늘릴 때 잠재적인 OOM "
"조건을 확인할 수 있는 `try_reserve` 메서드를 노출하지만 이를 사용하는 데 "
"적극적이어야 합니다."

#: src/collections/index.md:196
msgid ""
"If you exclusively use `heapless` collections and you don't use a memory "
"allocator for anything else then an OOM condition is impossible. Instead, "
"you'll have to deal with collections running out of capacity on a case by "
"case basis. That is you'll have deal with _all_ the `Result`s returned by "
"methods like `Vec.push`."
msgstr ""
"`heapless` 컬렉션만 독점적으로 사용하고 다른 용도로 메모리 할당자를 사용하지 "
"않으면 OOM 조건이 불가능합니다. 대신 컬렉션 용량 부족 문제를 사례별로 "
"처리해야 합니다. 즉, `Vec.push`와 같은 메서드에서 반환되는 모든 `Result`를 "
"처리해야 합니다."

#: src/collections/index.md:202
msgid ""
"OOM failures can be harder to debug than say `unwrap`\\-ing on all `Result`s "
"returned by `heapless::Vec.push` because the observed location of failure "
"may _not_ match with the location of the cause of the problem. For example, "
"even `vec.reserve(1)` can trigger an OOM if the allocator is nearly "
"exhausted because some other collection was leaking memory (memory leaks are "
"possible in safe Rust)."
msgstr ""
"OOM 오류는 `heapless::Vec.push`에서 반환된 모든 `Result`에 대해 `unwrap`하는 "
"것보다 디버깅하기 더 어려울 수 있습니다. 왜냐하면 관찰된 오류 위치가 문제의 "
"원인 위치와 일치하지 않을 수 있기 때문입니다. 예를 들어, 다른 컬렉션에서 "
"메모리가 누수되어 할당자가 거의 소진된 경우 `vec.reserve(1)`조차도 OOM을 "
"유발할 수 있습니다(안전한 Rust에서는 메모리 누수가 가능합니다)."

#: src/collections/index.md:209
msgid "Memory usage"
msgstr "메모리 사용량"

#: src/collections/index.md:211
msgid ""
"Reasoning about memory usage of heap allocated collections is hard because "
"the capacity of long lived collections can change at runtime. Some "
"operations may implicitly reallocate the collection increasing its memory "
"usage, and some collections expose methods like `shrink_to_fit` that can "
"potentially reduce the memory used by the collection -- ultimately, it's up "
"to the allocator to decide whether to actually shrink the memory allocation "
"or not. Additionally, the allocator may have to deal with memory "
"fragmentation which can increase the _apparent_ memory usage."
msgstr ""
"힙 할당 컬렉션의 메모리 사용량을 추론하는 것은 어렵습니다. 왜냐하면 오래 "
"지속되는 컬렉션의 용량이 런타임에 변경될 수 있기 때문입니다. 일부 작업은 "
"컬렉션을 암시적으로 재할당하여 메모리 사용량을 늘릴 수 있으며, 일부 컬렉션은 "
"`shrink_to_fit`과 같은 메서드를 노출하여 컬렉션이 사용하는 메모리를 잠재적으로 "
"줄일 수 있습니다. 궁극적으로 메모리 할당을 실제로 줄일지 여부는 할당자가 "
"결정합니다. 또한 할당자는 메모리 단편화를 처리해야 할 수 있으며, 이는 "
"_겉보기_ 메모리 사용량을 증가시킬 수 있습니다."

#: src/collections/index.md:220
msgid ""
"On the other hand if you exclusively use fixed capacity collections, store "
"most of them in `static` variables and set a maximum size for the call stack "
"then the linker will detect if you try to use more memory than what's "
"physically available."
msgstr ""
"반면에 고정 용량 컬렉션만 독점적으로 사용하고 대부분을 `static` 변수에 저장하며 "
"호출 스택의 최대 크기를 설정하면 링커는 물리적으로 사용 가능한 메모리보다 더 "
"많은 메모리를 사용하려고 하는지 감지합니다."

#: src/collections/index.md:225
msgid ""
"Furthermore, fixed capacity collections allocated on the stack will be "
"reported by [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) flag which means that tools that "
"analyze stack usage (like [`stack-sizes`](https://crates.io/crates/stack-"
"sizes)) will include them in their analysis."
msgstr ""
"또한 스택에 할당된 고정 용량 컬렉션은 [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) 플래그에 의해 보고됩니다. 이는 스택 "
"사용량을 분석하는 도구([`stack-sizes`](https://crates.io/crates/stack-"
"sizes)와 같은)가 분석에 이를 포함한다는 의미입니다."

#: src/collections/index.md:232
msgid ""
"However, fixed capacity collections can _not_ be shrunk which can result in "
"lower load factors (the ratio between the size of the collection and its "
"capacity) than what relocatable collections can achieve."
msgstr ""
"그러나 고정 용량 컬렉션은 축소될 수 없으므로 재배치 가능한 컬렉션이 달성할 수 "
"있는 것보다 낮은 로드 팩터(컬렉션 크기와 용량 간의 비율)를 초래할 수 있습니다."

#: src/collections/index.md:236
msgid "Worst Case Execution Time (WCET)"
msgstr "최악의 경우 실행 시간 (WCET)"

#: src/collections/index.md:238
msgid ""
"If you are building time sensitive applications or hard real time "
"applications then you care, maybe a lot, about the worst case execution time "
"of the different parts of your program."
msgstr ""
"시간에 민감한 애플리케이션 또는 하드 실시간 애플리케이션을 구축하는 경우 "
"프로그램의 다양한 부분의 최악의 경우 실행 시간에 대해 많이 신경 쓸 것입니다."

#: src/collections/index.md:242
msgid ""
"The `alloc` collections can reallocate so the WCET of operations that may "
"grow the collection will also include the time it takes to reallocate the "
"collection, which itself depends on the _runtime_ capacity of the "
"collection. This makes it hard to determine the WCET of, for example, the "
"`alloc::Vec.push` operation as it depends on both the allocator being used "
"and its runtime capacity."
msgstr ""
"`alloc` 컬렉션은 재할당될 수 있으므로 컬렉션을 늘릴 수 있는 작업의 WCET에는 "
"컬렉션을 재할당하는 데 걸리는 시간도 포함되며, 이는 컬렉션의 _런타임_ 용량에 "
"따라 달라집니다. 이로 인해 예를 들어 `alloc::Vec.push` 작업의 WCET를 결정하기 "
"어렵습니다. 이는 사용되는 할당자와 런타임 용량 모두에 따라 달라지기 때문입니다."

#: src/collections/index.md:248
msgid ""
"On the other hand fixed capacity collections never reallocate so all "
"operations have a predictable execution time. For example, "
"`heapless::Vec.push` executes in constant time."
msgstr ""
"반면에 고정 용량 컬렉션은 절대 재할당되지 않으므로 모든 작업은 예측 가능한 "
"실행 시간을 가집니다. 예를 들어 `heapless::Vec.push`는 상수 시간에 실행됩니다."

#: src/collections/index.md:252
msgid "Ease of use"
msgstr "사용 편의성"

#: src/collections/index.md:254
msgid ""
"`alloc` requires setting up a global allocator whereas `heapless` does not. "
"However, `heapless` requires you to pick the capacity of each collection "
"that you instantiate."
msgstr ""
"`alloc`은 전역 할당자를 설정해야 하지만 `heapless`는 그렇지 않습니다. 그러나 "
"`heapless`는 인스턴스화하는 각 컬렉션의 용량을 선택해야 합니다."

#: src/collections/index.md:258
msgid ""
"The `alloc` API will be familiar to virtually every Rust developer. The "
"`heapless` API tries to closely mimic the `alloc` API but it will never be "
"exactly the same due to its explicit error handling -- some developers may "
"feel the explicit error handling is excessive or too cumbersome."
msgstr ""
"`alloc` API는 거의 모든 Rust 개발자에게 익숙할 것입니다. `heapless` API는 "
"`alloc` API를 밀접하게 모방하려고 하지만 명시적인 오류 처리로 인해 정확히 "
"동일하지는 않을 것입니다. 일부 개발자는 명시적인 오류 처리가 과도하거나 너무 "
"번거롭다고 느낄 수 있습니다."

#: src/design-patterns/index.md:3
msgid ""
"This chapter aims to collect various useful design patterns for embedded "
"Rust."
msgstr ""
"이 장은 임베디드 Rust를 위한 다양하고 유용한 디자인 패턴을 수집하는 것을 "
"목표로 합니다."

#: src/design-patterns/hal/index.md:1
msgid "HAL Design Patterns"
msgstr "HAL 디자인 패턴"

#: src/design-patterns/hal/index.md:3
msgid ""
"This is a set of common and recommended patterns for writing hardware "
"abstraction layers (HALs) for microcontrollers in Rust. These patterns are "
"intended to be used in addition to the existing [Rust API Guidelines]"
"(https://rust-lang.github.io/api-guidelines/) when writing HALs for "
"microcontrollers."
msgstr ""
"이것은 Rust에서 마이크로컨트롤러용 하드웨어 추상화 계층(HAL)을 작성하기 위한 "
"일반적이고 권장되는 패턴 집합입니다. 이러한 패턴은 마이크로컨트롤러용 HAL을 "
"작성할 때 기존 [Rust API 가이드라인](https://rust-lang.github.io/api-guidelines/) "
"외에 추가로 사용하도록 의도되었습니다."

#: src/design-patterns/hal/index.md:10
msgid "[Checklist](checklist.md)"
msgstr "[체크리스트](checklist.md)"

#: src/design-patterns/hal/index.md:12
msgid "[Naming](naming.md)"
msgstr "[명명](naming.md)"

#: src/design-patterns/hal/index.md:13
msgid "[Interoperability](interoperability.md)"
msgstr "[상호 운용성](interoperability.md)"

#: src/design-patterns/hal/index.md:14
msgid "[Predictability](predictability.md)"
msgstr "[예측 가능성](predictability.md)"

#: src/design-patterns/hal/index.md:15
msgid "[GPIO](gpio.md)"
msgstr "[GPIO](gpio.md)"

#: src/design-patterns/hal/checklist.md:1
msgid "HAL Design Patterns Checklist"
msgstr "HAL 디자인 패턴 체크리스트"

#: src/design-patterns/hal/checklist.md:3
msgid "**Naming** _(crate aligns with Rust naming conventions)_"
msgstr "**명명** _(크레이트가 Rust 명명 규칙과 일치)_"

#: src/design-patterns/hal/checklist.md:4
msgid ""
"The crate is named appropriately ([C-CRATE-NAME](naming.html#c-crate-name))"
msgstr ""
"크레이트 이름이 적절합니다 ([C-CRATE-NAME](naming.html#c-crate-name))"

#: src/design-patterns/hal/checklist.md:5
msgid ""
"**Interoperability** _(crate interacts nicely with other library "
"functionality)_"
msgstr ""
"**상호 운용성** _(크레이트가 다른 라이브러리 기능과 잘 상호 작용)_"

#: src/design-patterns/hal/checklist.md:6
msgid ""
"Wrapper types provide a destructor method ([C-FREE](interoperability.html#c-"
"free))"
msgstr ""
"래퍼 타입은 소멸자 메서드를 제공합니다 ([C-FREE](interoperability.html#c-"
"free))"

#: src/design-patterns/hal/checklist.md:7
msgid ""
"HALs reexport their register access crate ([C-REEXPORT-PAC]"
"(interoperability.html#c-reexport-pac))"
msgstr ""

#: src/design-patterns/hal/checklist.md:8
msgid ""
"Types implement the `embedded-hal` traits ([C-HAL-TRAITS]"
"(interoperability.html#c-hal-traits))"
msgstr ""
"타입은 `embedded-hal` 트레이트를 구현합니다 ([C-HAL-TRAITS]"

#: src/design-patterns/hal/checklist.md:9
msgid ""
"**Predictability** _(crate enables legible code that acts how it looks)_"
msgstr ""
"**예측 가능성** _(크레이트가 보이는 대로 작동하는 읽기 쉬운 코드를 가능하게 함)_"

#: src/design-patterns/hal/checklist.md:10
msgid ""
"Constructors are used instead of extension traits ([C-CTOR]"
msgstr ""
"확장 트레이트 대신 생성자가 사용됩니다 ([C-CTOR]"

#: src/design-patterns/hal/checklist.md:11
msgid "**GPIO Interfaces** _(GPIO Interfaces follow a common pattern)_"
msgstr "**GPIO 인터페이스** _(GPIO 인터페이스는 공통 패턴을 따름)_"

#: src/design-patterns/hal/checklist.md:12
msgid "Pin types are zero-sized by default ([C-ZST-PIN](gpio.md#c-zst-pin))"
msgstr "핀 타입은 기본적으로 제로 크기입니다 ([C-ZST-PIN](gpio.md#c-zst-pin))"

#: src/design-patterns/hal/checklist.md:13
msgid ""
"Pin types provide methods to erase pin and port ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"
msgstr ""
"핀 타입은 핀과 포트를 지우는 메서드를 제공합니다 ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"

#: src/design-patterns/hal/checklist.md:14
msgid ""
"Pin state should be encoded as type parameters ([C-PIN-STATE](gpio.md#c-pin-"
"state))"
msgstr ""
"핀 상태는 타입 매개변수로 인코딩되어야 합니다 ([C-PIN-STATE](gpio.md#c-pin-"
"state))"

#: src/design-patterns/hal/naming.md:4
msgid "<a id=\"c-crate-name\"></a>"
msgstr "<a id=\"c-crate-name\"></a>"

#: src/design-patterns/hal/naming.md:5
msgid "The crate is named appropriately (C-CRATE-NAME)"
msgstr "크레이트 이름이 적절합니다 (C-CRATE-NAME)"

#: src/design-patterns/hal/naming.md:7
msgid ""
"HAL crates should be named after the chip or family of chips they aim to "
"support. Their name should end with `-hal` to distinguish them from register "
"access crates. The name should not contain underscores (use dashes instead)."
msgstr ""
"HAL 크레이트는 지원하려는 칩 또는 칩 제품군의 이름을 따야 합니다. 레지스터 "
"접근 크레이트와 구별하기 위해 이름은 `-hal`로 끝나야 합니다. 이름에 밑줄을 "
"포함해서는 안 됩니다(대신 대시를 사용하십시오)."

#: src/design-patterns/hal/interoperability.md:4
msgid "<a id=\"c-free\"></a>"
msgstr "<a id=\"c-free\"></a>"

#: src/design-patterns/hal/interoperability.md:5
msgid "Wrapper types provide a destructor method (C-FREE)"
msgstr "래퍼 타입은 소멸자 메서드를 제공합니다 (C-FREE)"

#: src/design-patterns/hal/interoperability.md:7
msgid ""
"Any non-`Copy` wrapper type provided by the HAL should provide a `free` "
"method that consumes the wrapper and returns back the raw peripheral (and "
"possibly other objects) it was created from."
msgstr ""
"HAL에서 제공하는 모든 비-`Copy` 래퍼 타입은 래퍼를 소비하고 생성된 원시 주변 "
"장치(및 다른 객체일 수도 있음)를 반환하는 `free` 메서드를 제공해야 합니다."

#: src/design-patterns/hal/interoperability.md:11
msgid ""
"The method should shut down and reset the peripheral if necessary. Calling "
"`new` with the raw peripheral returned by `free` should not fail due to an "
"unexpected state of the peripheral."
msgstr ""
"메서드는 필요한 경우 주변 장치를 종료하고 재설정해야 합니다. `free`가 반환한 "
"원시 주변 장치로 `new`를 호출할 때 주변 장치의 예기치 않은 상태로 인해 "
"실패해서는 안 됩니다."

#: src/design-patterns/hal/interoperability.md:15
msgid ""
"If the HAL type requires other non-`Copy` objects to be constructed (for "
"example I/O pins), any such object should be released and returned by `free` "
"as well. `free` should return a tuple in that case."
msgstr ""
"HAL 타입이 다른 비-`Copy` 객체(예: I/O 핀)를 구성해야 하는 경우, 해당 객체도 "
"`free`에 의해 해제되고 반환되어야 합니다. 이 경우 `free`는 튜플을 반환해야 "
"합니다."

#: src/design-patterns/hal/interoperability.md:19
msgid "For example:"
msgstr "예를 들어:"

#: src/design-patterns/hal/interoperability.md:36
msgid "<a id=\"c-reexport-pac\"></a>"
msgstr "<a id=\"c-reexport-pac\"></a>"

#: src/design-patterns/hal/interoperability.md:37
msgid "HALs reexport their register access crate (C-REEXPORT-PAC)"
msgstr "HAL은 레지스터 접근 크레이트를 재수출합니다 (C-REEXPORT-PAC)"

#: src/design-patterns/hal/interoperability.md:39
msgid ""
"HALs can be written on top of [svd2rust](https://github.com/rust-embedded/"
"svd2rust)\\-generated PACs, or on top of other crates that provide raw "
"register access. HALs should always reexport the register access crate they "
"are based on in their crate root."
msgstr ""
"HAL은 [svd2rust](https://github.com/rust-embedded/svd2rust)로 생성된 PAC 위에 "
"또는 원시 레지스터 접근을 제공하는 다른 크레이트 위에 작성될 수 있습니다. HAL은 "
"항상 기반으로 하는 레지스터 접근 크레이트를 크레이트 루트에 재수출해야 합니다."

#: src/design-patterns/hal/interoperability.md:43
msgid ""
"A PAC should be reexported under the name `pac`, regardless of the actual "
"name of the crate, as the name of the HAL should already make it clear what "
"PAC is being accessed."
msgstr ""
"PAC는 크레이트의 실제 이름과 관계없이 `pac`라는 이름으로 재수출되어야 합니다. "
"HAL의 이름이 어떤 PAC에 접근하는지 이미 명확하게 해야 하기 때문입니다."

#: src/design-patterns/hal/interoperability.md:49
msgid "<a id=\"c-hal-traits\"></a>"
msgstr "<a id=\"c-hal-traits\"></a>"

#: src/design-patterns/hal/interoperability.md:50
msgid "Types implement the `embedded-hal` traits (C-HAL-TRAITS)"
msgstr "타입은 `embedded-hal` 트레이트를 구현합니다 (C-HAL-TRAITS)"

#: src/design-patterns/hal/interoperability.md:52
msgid ""
"Types provided by the HAL should implement all applicable traits provided by "
"the [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) crate."
msgstr ""
"HAL에서 제공하는 타입은 [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) "
"크레이트에서 제공하는 모든 해당 트레이트를 구현해야 합니다."

#: src/design-patterns/hal/interoperability.md:55
msgid "Multiple traits may be implemented for the same type."
msgstr "동일한 타입에 대해 여러 트레이트가 구현될 수 있습니다."

#: src/design-patterns/hal/predictability.md:4
msgid "<a id=\"c-ctor\"></a>"
msgstr "<a id=\"c-ctor\"></a>"

#: src/design-patterns/hal/predictability.md:5
msgid "Constructors are used instead of extension traits (C-CTOR)"
msgstr "확장 트레이트 대신 생성자가 사용됩니다 (C-CTOR)"

#: src/design-patterns/hal/predictability.md:7
msgid ""
"All peripherals to which the HAL adds functionality should be wrapped in a "
"new type, even if no additional fields are required for that functionality."
msgstr ""
"HAL이 기능을 추가하는 모든 주변 장치는 추가 필드가 필요하지 않더라도 새 타입으로 "
"래핑되어야 합니다."

#: src/design-patterns/hal/predictability.md:10
msgid "Extension traits implemented for the raw peripheral should be avoided."
msgstr "원시 주변 장치에 구현된 확장 트레이트는 피해야 합니다."

#: src/design-patterns/hal/predictability.md:12
msgid "<a id=\"c-inline\"></a>"
msgstr "<a id=\"c-inline\"></a>"

#: src/design-patterns/hal/predictability.md:13
msgid "Methods are decorated with `#[inline]` where appropriate (C-INLINE)"
msgstr "메서드는 적절한 경우 `#[inline]`으로 장식됩니다 (C-INLINE)"

#: src/design-patterns/hal/predictability.md:15
msgid ""
"The Rust compiler does not by default perform full inlining across crate "
"boundaries. As embedded applications are sensitive to unexpected code size "
"increases, `#[inline]` should be used to guide the compiler as follows:"
msgstr ""
"Rust 컴파일러는 기본적으로 크레이트 경계를 넘어 전체 인라이닝을 수행하지 "
"않습니다. 임베디드 애플리케이션은 예기치 않은 코드 크기 증가에 민감하므로, "
"`#[inline]`은 다음과 같이 컴파일러를 안내하는 데 사용해야 합니다:"

#: src/design-patterns/hal/predictability.md:19
msgid ""
"All \"small\" functions should be marked `#[inline]`. What qualifies as "
"\"small\" is subjective, but generally all functions that are expected to "
"compile down to single-digit instruction sequences qualify as small."
msgstr ""
"모든 \"작은\" 함수는 `#[inline]`으로 표시되어야 합니다. \"작은\" 것으로 "
"간주되는 기준은 주관적이지만, 일반적으로 한 자릿수 명령어 시퀀스로 컴파일될 "
"것으로 예상되는 모든 함수는 작은 것으로 간주됩니다."

#: src/design-patterns/hal/predictability.md:22
msgid ""
"Functions that are very likely to take constant values as parameters should "
"be marked as `#[inline]`. This enables the compiler to compute even "
"complicated initialization logic at compile time, provided the function "
"inputs are known."
msgstr ""
"상수 값을 매개변수로 받을 가능성이 매우 높은 함수는 `#[inline]`으로 표시해야 "
"합니다. 이렇게 하면 함수 입력이 알려진 경우 컴파일러가 복잡한 초기화 로직도 "
"컴파일 시간에 계산할 수 있습니다."

#: src/design-patterns/hal/gpio.md:1
msgid "Recommendations for GPIO Interfaces"
msgstr "GPIO 인터페이스 권장 사항"

#: src/design-patterns/hal/gpio.md:3
msgid "<a id=\"c-zst-pin\"></a>"
msgstr "<a id=\"c-zst-pin\"></a>"

#: src/design-patterns/hal/gpio.md:4
msgid "Pin types are zero-sized by default (C-ZST-PIN)"
msgstr "핀 타입은 기본적으로 제로 크기입니다 (C-ZST-PIN)"

#: src/design-patterns/hal/gpio.md:6
msgid ""
"GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types "
"for each pin on every interface or port, resulting in a zero-cost GPIO "
"abstraction when all pin assignments are statically known."
msgstr ""
"HAL이 노출하는 GPIO 인터페이스는 모든 인터페이스 또는 포트의 각 핀에 대해 "
"전용 제로 크기 타입을 제공해야 합니다. 이는 모든 핀 할당이 정적으로 알려진 "
"경우 제로 비용 GPIO 추상화를 초래합니다."

#: src/design-patterns/hal/gpio.md:10
msgid ""
"Each GPIO Interface or Port should implement a `split` method returning a "
"struct with every pin."
msgstr ""
"각 GPIO 인터페이스 또는 포트는 모든 핀을 포함하는 구조체를 반환하는 `split` "
"메서드를 구현해야 합니다."

#: src/design-patterns/hal/gpio.md:13
msgid "Example:"
msgstr "예시:"

#: src/design-patterns/hal/gpio.md:39
msgid "<a id=\"c-erased-pin\"></a>"
msgstr "<a id=\"c-erased-pin\"></a>"

#: src/design-patterns/hal/gpio.md:40
msgid "Pin types provide methods to erase pin and port (C-ERASED-PIN)"
msgstr "핀 타입은 핀과 포트를 지우는 메서드를 제공합니다 (C-ERASED-PIN)"

#: src/design-patterns/hal/gpio.md:42
msgid ""
"Pins should provide type erasure methods that move their properties from "
"compile time to runtime, and allow more flexibility in applications."
msgstr ""
"핀은 컴파일 타임에서 런타임으로 속성을 이동하고 애플리케이션에서 더 많은 "
"유연성을 허용하는 타입 소거 메서드를 제공해야 합니다."

#: src/design-patterns/hal/gpio.md:48
msgid "/// Port A, pin 0.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:56
msgid "/// A pin on port A.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:59
msgid "/// The pin number.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:75
msgid "// (these fields can be packed to reduce the memory footprint)\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:86
msgid "<a id=\"c-pin-state\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:87
msgid "Pin state should be encoded as type parameters (C-PIN-STATE)"
msgstr ""

#: src/design-patterns/hal/gpio.md:89
msgid ""
"Pins may be configured as input or output with different characteristics "
"depending on the chip or family. This state should be encoded in the type "
"system to prevent use of pins in incorrect states."
msgstr ""

#: src/design-patterns/hal/gpio.md:93
msgid ""
"Additional, chip-specific state (eg. drive strength) may also be encoded in "
"this way, using additional type parameters."
msgstr ""

#: src/design-patterns/hal/gpio.md:96
msgid ""
"Methods for changing the pin state should be provided as `into_input` and "
"`into_output` methods."
msgstr ""

#: src/design-patterns/hal/gpio.md:99
msgid ""
"Additionally, `with_{input,output}_state` methods should be provided that "
"temporarily reconfigure a pin in a different state without moving it."
msgstr ""

#: src/design-patterns/hal/gpio.md:102
msgid ""
"The following methods should be provided for every pin type (that is, both "
"erased and non-erased pin types should provide the same API):"
msgstr ""

#: src/design-patterns/hal/gpio.md:105
msgid "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:106
msgid "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:123
msgid ""
"Pin state should be bounded by sealed traits. Users of the HAL should have "
"no need to add their own state. The traits can provide HAL-specific methods "
"required to implement the pin state API."
msgstr ""

#: src/design-patterns/hal/gpio.md:203
msgid "// Same for `PA` and `Pin`, and other pin types.\n"
msgstr ""

#: src/c-tips/index.md:3
msgid ""
"This chapter collects a variety of tips that might be useful to experienced "
"embedded C developers looking to start writing Rust. It will especially "
"highlight how things you might already be used to in C are different in Rust."
msgstr ""

#: src/c-tips/index.md:7
msgid "Preprocessor"
msgstr ""

#: src/c-tips/index.md:9
msgid ""
"In embedded C it is very common to use the preprocessor for a variety of "
"purposes, such as:"
msgstr ""

#: src/c-tips/index.md:12
msgid "Compile-time selection of code blocks with `#ifdef`"
msgstr ""

#: src/c-tips/index.md:13
msgid "Compile-time array sizes and computations"
msgstr ""

#: src/c-tips/index.md:14
msgid "Macros to simplify common patterns (to avoid function call overhead)"
msgstr ""

#: src/c-tips/index.md:16
msgid ""
"In Rust there is no preprocessor, and so many of these use cases are "
"addressed differently. In the rest of this section we cover various "
"alternatives to using the preprocessor."
msgstr ""

#: src/c-tips/index.md:20
msgid "Compile-Time Code Selection"
msgstr ""

#: src/c-tips/index.md:22
msgid ""
"The closest match to `#ifdef ... #endif` in Rust are [Cargo features]"
"(https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-"
"section). These are a little more formal than the C preprocessor: all "
"possible features are explicitly listed per crate, and can only be either on "
"or off. Features are turned on when you list a crate as a dependency, and "
"are additive: if any crate in your dependency tree enables a feature for "
"another crate, that feature will be enabled for all users of that crate."
msgstr ""

#: src/c-tips/index.md:31
msgid ""
"For example, you might have a crate which provides a library of signal "
"processing primitives. Each one might take some extra time to compile or "
"declare some large table of constants which you'd like to avoid. You could "
"declare a Cargo feature for each component in your `Cargo.toml`:"
msgstr ""

#: src/c-tips/index.md:42
msgid ""
"Then, in your code, use `#[cfg(feature=\"FIR\")]` to control what is "
"included."
msgstr ""

#: src/c-tips/index.md:45
msgid "/// In your top-level lib.rs\n"
msgstr ""

#: src/c-tips/index.md:47
msgid "\"FIR\""
msgstr ""

#: src/c-tips/index.md:50
msgid "\"IIR\""
msgstr ""

#: src/c-tips/index.md:54
msgid ""
"You can similarly include code blocks only if a feature is _not_ enabled, or "
"if any combination of features are or are not enabled."
msgstr ""

#: src/c-tips/index.md:57
msgid ""
"Additionally, Rust provides a number of automatically-set conditions you can "
"use, such as `target_arch` to select different code based on architecture. "
"For full details of the conditional compilation support, refer to the "
"[conditional compilation](https://doc.rust-lang.org/reference/conditional-"
"compilation.html) chapter of the Rust reference."
msgstr ""

#: src/c-tips/index.md:64
msgid ""
"The conditional compilation will only apply to the next statement or block. "
"If a block can not be used in the current scope then the `cfg` attribute "
"will need to be used multiple times.  It's worth noting that most of the "
"time it is better to simply include all the code and allow the compiler to "
"remove dead code when optimising: it's simpler for you and your users, and "
"in general the compiler will do a good job of removing unused code."
msgstr ""

#: src/c-tips/index.md:71
msgid "Compile-Time Sizes and Computation"
msgstr ""

#: src/c-tips/index.md:73
msgid ""
"Rust supports `const fn`, functions which are guaranteed to be evaluable at "
"compile-time and can therefore be used where constants are required, such as "
"in the size of arrays. This can be used alongside features mentioned above, "
"for example:"
msgstr ""

#: src/c-tips/index.md:80 src/c-tips/index.md:82
msgid "\"use_more_ram\""
msgstr ""

#: src/c-tips/index.md:89
msgid ""
"These are new to stable Rust as of 1.31, so documentation is still sparse. "
"The functionality available to `const fn` is also very limited at the time "
"of writing; in future Rust releases it is expected to expand on what is "
"permitted in a `const fn`."
msgstr ""

#: src/c-tips/index.md:94
msgid "Macros"
msgstr ""

#: src/c-tips/index.md:96
msgid ""
"Rust provides an extremely powerful [macro system](https://doc.rust-lang.org/"
"book/ch19-06-macros.html). While the C preprocessor operates almost directly "
"on the text of your source code, the Rust macro system operates at a higher "
"level. There are two varieties of Rust macro: _macros by example_ and "
"_procedural macros_. The former are simpler and most common; they look like "
"function calls and can expand to a complete expression, statement, item, or "
"pattern. Procedural macros are more complex but permit extremely powerful "
"additions to the Rust language: they can transform arbitrary Rust syntax "
"into new Rust syntax."
msgstr ""

#: src/c-tips/index.md:107
msgid ""
"In general, where you might have used a C preprocessor macro, you probably "
"want to see if a macro-by-example can do the job instead. They can be "
"defined in your crate and easily used by your own crate or exported for "
"other users. Be aware that since they must expand to complete expressions, "
"statements, items, or patterns, some use cases of C preprocessor macros will "
"not work, for example a macro that expands to part of a variable name or an "
"incomplete set of items in a list."
msgstr ""

#: src/c-tips/index.md:115
msgid ""
"As with Cargo features, it is worth considering if you even need the macro. "
"In many cases a regular function is easier to understand and will be inlined "
"to the same code as a macro. The `#[inline]` and `#[inline(always)]` "
"[attributes](https://doc.rust-lang.org/reference/attributes.html#inline-"
"attribute) give you further control over this process, although care should "
"be taken here as well — the compiler will automatically inline functions "
"from the same crate where appropriate, so forcing it to do so "
"inappropriately might actually lead to decreased performance."
msgstr ""

#: src/c-tips/index.md:125
msgid ""
"Explaining the entire Rust macro system is out of scope for this tips page, "
"so you are encouraged to consult the Rust documentation for full details."
msgstr ""

#: src/c-tips/index.md:128
msgid "Build System"
msgstr ""

#: src/c-tips/index.md:130
msgid ""
"Most Rust crates are built using Cargo (although it is not required). This "
"takes care of many difficult problems with traditional build systems. "
"However, you may wish to customise the build process. Cargo provides "
"[`build.rs` scripts](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html) for this purpose. They are Rust scripts which can interact "
"with the Cargo build system as required."
msgstr ""

#: src/c-tips/index.md:138
msgid "Common use cases for build scripts include:"
msgstr ""

#: src/c-tips/index.md:140
msgid ""
"provide build-time information, for example statically embedding the build "
"date or Git commit hash into your executable"
msgstr ""

#: src/c-tips/index.md:142
msgid ""
"generate linker scripts at build time depending on selected features or "
"other logic"
msgstr ""

#: src/c-tips/index.md:144
msgid "change the Cargo build configuration"
msgstr ""

#: src/c-tips/index.md:145
msgid "add extra static libraries to link against"
msgstr ""

#: src/c-tips/index.md:147
msgid ""
"At present there is no support for post-build scripts, which you might "
"traditionally have used for tasks like automatic generation of binaries from "
"the build objects or printing build information."
msgstr ""

#: src/c-tips/index.md:151
msgid "Cross-Compiling"
msgstr ""

#: src/c-tips/index.md:153
msgid ""
"Using Cargo for your build system also simplifies cross-compiling. In most "
"cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a "
"suitable executable in `target/thumbv6m-none-eabi/debug/myapp`."
msgstr ""

#: src/c-tips/index.md:157
msgid ""
"For platforms not natively supported by Rust, you will need to build "
"`libcore` for that target yourself. On such platforms, [Xargo](https://"
"github.com/japaric/xargo) can be used as a stand-in for Cargo which "
"automatically builds `libcore` for you."
msgstr ""

#: src/c-tips/index.md:163
msgid "Iterators vs Array Access"
msgstr ""

#: src/c-tips/index.md:165
msgid "In C you are probably used to accessing arrays directly by their index:"
msgstr ""

#: src/c-tips/index.md:175
msgid ""
"In Rust this is an anti-pattern: indexed access can be slower (as it needs "
"to be bounds checked) and may prevent various compiler optimisations. This "
"is an important distinction and worth repeating: Rust will check for out-of-"
"bounds access on manual array indexing to guarantee memory safety, while C "
"will happily index outside the array."
msgstr ""

#: src/c-tips/index.md:181
msgid "Instead, use iterators:"
msgstr ""

#: src/c-tips/index.md:190
msgid ""
"Iterators provide a powerful array of functionality you would have to "
"implement manually in C, such as chaining, zipping, enumerating, finding the "
"min or max, summing, and more. Iterator methods can also be chained, giving "
"very readable data processing code."
msgstr ""

#: src/c-tips/index.md:195
msgid ""
"See the [Iterators in the Book](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html) and [Iterator documentation](https://doc.rust-lang.org/core/"
"iter/trait.Iterator.html) for more details."
msgstr ""

#: src/c-tips/index.md:200
msgid "References vs Pointers"
msgstr ""

#: src/c-tips/index.md:202
msgid ""
"In Rust, pointers (called [_raw pointers_](https://doc.rust-lang.org/book/"
"ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer)) exist but are only "
"used in specific circumstances, as dereferencing them is always considered "
"`unsafe` -- Rust cannot provide its usual guarantees about what might be "
"behind the pointer."
msgstr ""

#: src/c-tips/index.md:208
msgid ""
"In most cases, we instead use _references_, indicated by the `&` symbol, or "
"_mutable references_, indicated by `&mut`. References behave similarly to "
"pointers, in that they can be dereferenced to access the underlying values, "
"but they are a key part of Rust's ownership system: Rust will strictly "
"enforce that you may only have one mutable reference _or_ multiple non-"
"mutable references to the same value at any given time."
msgstr ""

#: src/c-tips/index.md:215
msgid ""
"In practice this means you have to be more careful about whether you need "
"mutable access to data: where in C the default is mutable and you must be "
"explicit about `const`, in Rust the opposite is true."
msgstr ""

#: src/c-tips/index.md:219
msgid ""
"One situation where you might still use raw pointers is interacting directly "
"with hardware (for example, writing a pointer to a buffer into a DMA "
"peripheral register), and they are also used under the hood for all "
"peripheral access crates to allow you to read and write memory-mapped "
"registers."
msgstr ""

#: src/c-tips/index.md:224
msgid "Volatile Access"
msgstr ""

#: src/c-tips/index.md:226
msgid ""
"In C, individual variables may be marked `volatile`, indicating to the "
"compiler that the value in the variable may change between accesses. "
"Volatile variables are commonly used in an embedded context for memory-"
"mapped registers."
msgstr ""

#: src/c-tips/index.md:230
msgid ""
"In Rust, instead of marking a variable as `volatile`, we use specific "
"methods to perform volatile access: [`core::ptr::read_volatile`](https://"
"doc.rust-lang.org/core/ptr/fn.read_volatile.html) and "
"[`core::ptr::write_volatile`](https://doc.rust-lang.org/core/ptr/"
"fn.write_volatile.html). These methods take a `*const T` or a `*mut T` (_raw "
"pointers_, as discussed above) and perform a volatile read or write."
msgstr ""

#: src/c-tips/index.md:238
msgid "For example, in C you might write:"
msgstr ""

#: src/c-tips/index.md:244
msgid "// Signal that the interrupt has occurred\n"
msgstr ""

#: src/c-tips/index.md:250 src/c-tips/index.md:275
msgid "// Sleep until signalled\n"
msgstr ""

#: src/c-tips/index.md:252 src/c-tips/index.md:277
msgid "// Reset signalled indicator\n"
msgstr ""

#: src/c-tips/index.md:254 src/c-tips/index.md:279
msgid "// Perform some task that was waiting for the interrupt\n"
msgstr ""

#: src/c-tips/index.md:260
msgid "The equivalent in Rust would use volatile methods on each access:"
msgstr ""

#: src/c-tips/index.md:267
msgid ""
"// Signal that the interrupt has occurred\n"
"    // (In real code, you should consider a higher level primitive,\n"
"    //  such as an atomic type).\n"
msgstr ""

#: src/c-tips/index.md:285
msgid "A few things are worth noting in the code sample:"
msgstr ""

#: src/c-tips/index.md:286
msgid ""
"We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since "
"`&mut T` automatically converts to a `*mut T` (and the same for `*const T`)"
msgstr ""

#: src/c-tips/index.md:288
msgid ""
"We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods, "
"since they are `unsafe` functions. It is the programmer's responsibility to "
"ensure safe use: see the methods' documentation for further details."
msgstr ""

#: src/c-tips/index.md:292
msgid ""
"It is rare to require these functions directly in your code, as they will "
"usually be taken care of for you by higher-level libraries. For memory "
"mapped peripherals, the peripheral access crates will implement volatile "
"access automatically, while for concurrency primitives there are better "
"abstractions available (see the [Concurrency chapter](../concurrency/"
"index.md))."
msgstr ""

#: src/c-tips/index.md:300
msgid "Packed and Aligned Types"
msgstr ""

#: src/c-tips/index.md:302
msgid ""
"In embedded C it is common to tell the compiler a variable must have a "
"certain alignment or a struct must be packed rather than aligned, usually to "
"meet specific hardware or protocol requirements."
msgstr ""

#: src/c-tips/index.md:306
msgid ""
"In Rust this is controlled by the `repr` attribute on a struct or union. The "
"default representation provides no guarantees of layout, so should not be "
"used for code that interoperates with hardware or C. The compiler may re-"
"order struct members or insert padding and the behaviour may change with "
"future versions of Rust."
msgstr ""

#: src/c-tips/index.md:321 src/c-tips/index.md:340 src/c-tips/index.md:366
#: src/c-tips/index.md:390 src/c-tips/index.md:391
msgid "\"{:p} {:p} {:p}\""
msgstr ""

#: src/c-tips/index.md:323
msgid ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// Note ordering has been changed to x, z, y to improve packing.\n"
msgstr ""

#: src/c-tips/index.md:328
msgid "To ensure layouts that are interoperable with C, use `repr(C)`:"
msgstr ""

#: src/c-tips/index.md:342
msgid ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// Ordering is preserved and the layout will not change over time.\n"
"// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.\n"
msgstr ""

#: src/c-tips/index.md:348
msgid "To ensure a packed representation, use `repr(packed)`:"
msgstr ""

#: src/c-tips/index.md:360
msgid ""
"// References must always be aligned, so to check the addresses of the\n"
"    // struct's fields, we use `std::ptr::addr_of!()` to get a raw pointer\n"
"    // instead of just printing `&v.x`.\n"
msgstr ""

#: src/c-tips/index.md:368
msgid ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// No padding has been inserted between `y` and `z`, so now `z` is "
"unaligned.\n"
msgstr ""

#: src/c-tips/index.md:373
msgid ""
"Note that using `repr(packed)` also sets the alignment of the type to `1`."
msgstr ""

#: src/c-tips/index.md:375
msgid ""
"Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is "
"the number of bytes to align to (and must be a power of two):"
msgstr ""

#: src/c-tips/index.md:393
msgid ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// The two instances `u` and `v` have been placed on 4096-byte alignments,\n"
"// evidenced by the `000` at the end of their addresses.\n"
msgstr ""

#: src/c-tips/index.md:400
msgid ""
"Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and "
"C-compatible layout. It is not permissible to combine `repr(align(n))` with "
"`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also "
"not permissible for a `repr(packed)` type to contain a `repr(align(n))` type."
msgstr ""

#: src/c-tips/index.md:405
msgid ""
"For further details on type layouts, refer to the [type layout](https://"
"doc.rust-lang.org/reference/type-layout.html) chapter of the Rust Reference."
msgstr ""

#: src/c-tips/index.md:412
msgid "In this book:"
msgstr ""

#: src/c-tips/index.md:413
msgid "[A little C with your Rust](../interoperability/c-with-rust.md)"
msgstr ""

#: src/c-tips/index.md:414
msgid "[A little Rust with your C](../interoperability/rust-with-c.md)"
msgstr ""

#: src/c-tips/index.md:415
msgid "[The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)"
msgstr ""

#: src/c-tips/index.md:416
msgid "[Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)"
msgstr ""

#: src/c-tips/index.md:417
msgid ""
"[I used to use pointers - now what?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"
msgstr ""

#: src/interoperability/index.md:3
msgid ""
"Interoperability between Rust and C code is always dependent on transforming "
"data between the two languages. For this purpose, there is a dedicated "
"module in the `stdlib` called [`std::ffi`](https://doc.rust-lang.org/std/ffi/"
"index.html)."
msgstr ""

#: src/interoperability/index.md:9
msgid ""
"`std::ffi` provides type definitions for C primitive types, such as `char`, "
"`int`, and `long`. It also provides some utility for converting more complex "
"types such as strings, mapping both `&str` and `String` to C types that are "
"easier and safer to handle."
msgstr ""

#: src/interoperability/index.md:15
msgid ""
"As of Rust 1.30, functionalities of `std::ffi` are available in either "
"`core::ffi` or `alloc::ffi` depending on whether or not memory allocation is "
"involved. The [`cty`](https://crates.io/crates/cty) crate and the "
"[`cstr_core`](https://crates.io/crates/cstr_core) crate also offer similar "
"functionalities."
msgstr ""

#: src/interoperability/index.md:25
msgid "Rust type"
msgstr ""

#: src/interoperability/index.md:25
msgid "Intermediate"
msgstr ""

#: src/interoperability/index.md:25
msgid "C type"
msgstr ""

#: src/interoperability/index.md:27
msgid "`String`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`CString`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`char *`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`&str`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`CStr`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`const char *`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`()`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`c_void`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`void`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`u32` or `u64`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`c_uint`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`unsigned int`"
msgstr ""

#: src/interoperability/index.md:31
msgid "etc"
msgstr ""

#: src/interoperability/index.md:31
msgid "..."
msgstr ""

#: src/interoperability/index.md:33
msgid ""
"A value of a C primitive type can be used as one of the corresponding Rust "
"type and vice versa, since the former is simply a type alias of the latter. "
"For example, the following code compiles on platforms where `unsigned int` "
"is 32-bit long."
msgstr ""

#: src/interoperability/index.md:46
msgid "Interoperability with other build systems"
msgstr ""

#: src/interoperability/index.md:48
msgid ""
"A common requirement for including Rust in your embedded project is "
"combining Cargo with your existing build system, such as make or cmake."
msgstr ""

#: src/interoperability/index.md:51
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #61](https://github.com/rust-embedded/book/issues/61)."
msgstr ""

#: src/interoperability/index.md:56
msgid "Interoperability with RTOSs"
msgstr ""

#: src/interoperability/index.md:58
msgid ""
"Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in "
"progress; especially calling RTOS functions from Rust can be tricky."
msgstr ""

#: src/interoperability/index.md:61
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #62](https://github.com/rust-embedded/book/issues/62)."
msgstr ""

#: src/interoperability/c-with-rust.md:3
msgid "Using C or C++ inside of a Rust project consists of two major parts:"
msgstr ""

#: src/interoperability/c-with-rust.md:5
msgid "Wrapping the exposed C API for use with Rust"
msgstr ""

#: src/interoperability/c-with-rust.md:6
msgid "Building your C or C++ code to be integrated with the Rust code"
msgstr ""

#: src/interoperability/c-with-rust.md:8
msgid ""
"As C++ does not have a stable ABI for the Rust compiler to target, it is "
"recommended to use the `C` ABI when combining Rust with C or C++."
msgstr ""

#: src/interoperability/c-with-rust.md:10
msgid "Defining the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:12
msgid ""
"Before consuming C or C++ code from Rust, it is necessary to define (in "
"Rust) what data types and function signatures exist in the linked code. In C "
"or C++, you would include a header (`.h` or `.hpp`) file which defines this "
"data. In Rust, it is necessary to either manually translate these "
"definitions to Rust, or use a tool to generate these definitions."
msgstr ""

#: src/interoperability/c-with-rust.md:14
msgid ""
"First, we will cover manually translating these definitions from C/C++ to "
"Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:16
msgid "Wrapping C functions and Datatypes"
msgstr ""

#: src/interoperability/c-with-rust.md:18
msgid ""
"Typically, libraries written in C or C++ will provide a header file defining "
"all types and functions used in public interfaces. An example file may look "
"like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:21
msgid "/* File: cool.h */"
msgstr ""

#: src/interoperability/c-with-rust.md:30
msgid "When translated to Rust, this interface would look as such:"
msgstr ""

#: src/interoperability/c-with-rust.md:33
msgid "/* File: cool_bindings.rs */"
msgstr ""

#: src/interoperability/c-with-rust.md:40
#: src/interoperability/c-with-rust.md:66
#: src/interoperability/rust-with-c.md:56
#: src/interoperability/rust-with-c.md:82
msgid "\"C\""
msgstr ""

#: src/interoperability/c-with-rust.md:49
msgid ""
"Let's take a look at this definition one piece at a time, to explain each of "
"the parts."
msgstr ""

#: src/interoperability/c-with-rust.md:56
msgid ""
"By default, Rust does not guarantee order, padding, or the size of data "
"included in a `struct`. In order to guarantee compatibility with C code, we "
"include the `#[repr(C)]` attribute, which instructs the Rust compiler to "
"always use the same rules C does for organizing data within a struct."
msgstr ""

#: src/interoperability/c-with-rust.md:63
msgid ""
"Due to the flexibility of how C or C++ defines an `int` or `char`, it is "
"recommended to use primitive data types defined in `cty`, which will map "
"types from C to types in Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:69
msgid ""
"This statement defines the signature of a function that uses the C ABI, "
"called `cool_function`. By defining the signature without defining the body "
"of the function, the definition of this function will need to be provided "
"elsewhere, or linked into the final library or binary from a static library."
msgstr ""

#: src/interoperability/c-with-rust.md:77
msgid ""
"Similar to our datatype above, we define the datatypes of the function "
"arguments using C-compatible definitions. We also retain the same argument "
"names, for clarity."
msgstr ""

#: src/interoperability/c-with-rust.md:79
msgid ""
"We have one new type here, `*mut CoolStruct`. As C does not have a concept "
"of Rust's references, which would look like this: `&mut CoolStruct`, we "
"instead have a raw pointer. As dereferencing this pointer is `unsafe`, and "
"the pointer may in fact be a `null` pointer, care must be taken to ensure "
"the guarantees typical of Rust when interacting with C or C++ code."
msgstr ""

#: src/interoperability/c-with-rust.md:81
msgid "Automatically generating the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:83
msgid ""
"Rather than manually generating these interfaces, which may be tedious and "
"error prone, there is a tool called [bindgen](https://github.com/rust-lang/"
"rust-bindgen) which will perform these conversions automatically. For "
"instructions of the usage of [bindgen](https://github.com/rust-lang/rust-"
"bindgen), please refer to the [bindgen user's manual](https://rust-"
"lang.github.io/rust-bindgen/), however the typical process consists of the "
"following:"
msgstr ""

#: src/interoperability/c-with-rust.md:85
msgid ""
"Gather all C or C++ headers defining interfaces or datatypes you would like "
"to use with Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:86
msgid ""
"Write a `bindings.h` file, which `#include \"...\"`'s each of the files you "
"gathered in step one."
msgstr ""

#: src/interoperability/c-with-rust.md:87
msgid ""
"Feed this `bindings.h` file, along with any compilation flags used to "
"compile your code into `bindgen`. Tip: use "
"`Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and "
"`Builder.use_core()` / `--use-core` to make the generated code `#![no_std]` "
"compatible."
msgstr ""

#: src/interoperability/c-with-rust.md:90
msgid ""
"`bindgen` will produce the generated Rust code to the output of the terminal "
"window. This output may be piped to a file in your project, such as "
"`bindings.rs`. You may use this file in your Rust project to interact with C/"
"C++ code compiled and linked as an external library. Tip: don't forget to "
"use the [`cty`](https://crates.io/crates/cty) crate if your types in the "
"generated bindings are prefixed with `cty`."
msgstr ""

#: src/interoperability/c-with-rust.md:95
msgid "Building your C/C++ code"
msgstr ""

#: src/interoperability/c-with-rust.md:97
msgid ""
"As the Rust compiler does not directly know how to compile C or C++ code (or "
"code from any other language, which presents a C interface), it is necessary "
"to compile your non-Rust code ahead of time."
msgstr ""

#: src/interoperability/c-with-rust.md:99
msgid ""
"For embedded projects, this most commonly means compiling the C/C++ code to "
"a static archive (such as `cool-library.a`), which can then be combined with "
"your Rust code at the final linking step."
msgstr ""

#: src/interoperability/c-with-rust.md:101
msgid ""
"If the library you would like to use is already distributed as a static "
"archive, it is not necessary to rebuild your code. Just convert the provided "
"interface header file as described above, and include the static archive at "
"compile/link time."
msgstr ""

#: src/interoperability/c-with-rust.md:103
msgid ""
"If your code exists as a source project, it will be necessary to compile "
"your C/C++ code to a static library, either by triggering your existing "
"build system (such as `make`, `CMake`, etc.), or by porting the necessary "
"compilation steps to use a tool called the `cc` crate. For both of these "
"steps, it is necessary to use a `build.rs` script."
msgstr ""

#: src/interoperability/c-with-rust.md:105
msgid "Rust `build.rs` build scripts"
msgstr ""

#: src/interoperability/c-with-rust.md:107
msgid ""
"A `build.rs` script is a file written in Rust syntax, that is executed on "
"your compilation machine, AFTER dependencies of your project have been "
"built, but BEFORE your project is built."
msgstr ""

#: src/interoperability/c-with-rust.md:109
msgid ""
"The full reference may be found [here](https://doc.rust-lang.org/cargo/"
"reference/build-scripts.html). `build.rs` scripts are useful for generating "
"code (such as via [bindgen](https://github.com/rust-lang/rust-bindgen)), "
"calling out to external build systems such as `Make`, or directly compiling "
"C/C++ through use of the `cc` crate."
msgstr ""

#: src/interoperability/c-with-rust.md:111
msgid "Triggering external build systems"
msgstr ""

#: src/interoperability/c-with-rust.md:113
msgid ""
"For projects with complex external projects or build systems, it may be "
"easiest to use [`std::process::Command`](https://doc.rust-lang.org/std/"
"process/struct.Command.html) to \"shell out\" to your other build systems by "
"traversing relative paths, calling a fixed command (such as `make library`), "
"and then copying the resulting static library to the proper location in the "
"`target` build directory."
msgstr ""

#: src/interoperability/c-with-rust.md:115
msgid ""
"While your crate may be targeting a `no_std` embedded platform, your "
"`build.rs` executes only on machines compiling your crate. This means you "
"may use any Rust crates which will run on your compilation host."
msgstr ""

#: src/interoperability/c-with-rust.md:119
msgid "Building C/C++ code with the `cc` crate"
msgstr ""

#: src/interoperability/c-with-rust.md:121
msgid ""
"For projects with limited dependencies or complexity, or for projects where "
"it is difficult to modify the build system to produce a static library "
"(rather than a final binary or executable), it may be easier to instead "
"utilize the [`cc` crate](https://github.com/alexcrichton/cc-rs), which "
"provides an idiomatic Rust interface to the compiler provided by the host."
msgstr ""

#: src/interoperability/c-with-rust.md:125
msgid ""
"In the simplest case of compiling a single C file as a dependency to a "
"static library, an example `build.rs` script using the [`cc` crate](https://"
"github.com/alexcrichton/cc-rs) would look like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:130
msgid "\"src/foo.c\""
msgstr ""

#: src/interoperability/c-with-rust.md:131
msgid "\"foo\""
msgstr ""

#: src/interoperability/c-with-rust.md:135
msgid ""
"The `build.rs` is placed at the root of the package. Then `cargo build` will "
"compile and execute it before the build of the package. A static archive "
"named `libfoo.a` is generated and placed in the `target` directory."
msgstr ""

#: src/interoperability/rust-with-c.md:3
msgid "Using Rust code inside a C or C++ project mostly consists of two parts."
msgstr ""

#: src/interoperability/rust-with-c.md:5
msgid "Creating a C-friendly API in Rust"
msgstr ""

#: src/interoperability/rust-with-c.md:6
msgid "Embedding your Rust project into an external build system"
msgstr ""

#: src/interoperability/rust-with-c.md:8
msgid ""
"Apart from `cargo` and `meson`, most build systems don't have native Rust "
"support. So you're most likely best off just using `cargo` for compiling "
"your crate and any dependencies."
msgstr ""

#: src/interoperability/rust-with-c.md:12
msgid "Setting up a project"
msgstr ""

#: src/interoperability/rust-with-c.md:14
msgid "Create a new `cargo` project as usual."
msgstr ""

#: src/interoperability/rust-with-c.md:16
msgid ""
"There are flags to tell `cargo` to emit a systems library, instead of its "
"regular rust target. This also allows you to set a different output name for "
"your library, if you want it to differ from the rest of your crate."
msgstr ""

#: src/interoperability/rust-with-c.md:21
msgid ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # Creates dynamic lib\n"
"# crate-type = [\"staticlib\"] # Creates static lib\n"
"```"
msgstr ""

#: src/interoperability/rust-with-c.md:28
msgid "Building a `C` API"
msgstr ""

#: src/interoperability/rust-with-c.md:30
msgid ""
"Because C++ has no stable ABI for the Rust compiler to target, we use `C` "
"for any interoperability between different languages. This is no exception "
"when using Rust inside of C and C++ code."
msgstr ""

#: src/interoperability/rust-with-c.md:34
msgid "`#[no_mangle]`"
msgstr ""

#: src/interoperability/rust-with-c.md:36
msgid ""
"The Rust compiler mangles symbol names differently than native code linkers "
"expect. As such, any function that Rust exports to be used outside of Rust "
"needs to be told not to be mangled by the compiler."
msgstr ""

#: src/interoperability/rust-with-c.md:40
msgid "`extern \"C\"`"
msgstr ""

#: src/interoperability/rust-with-c.md:42
msgid ""
"By default, any function you write in Rust will use the Rust ABI (which is "
"also not stabilized). Instead, when building outwards facing FFI APIs we "
"need to tell the compiler to use the system ABI."
msgstr ""

#: src/interoperability/rust-with-c.md:47
msgid ""
"Depending on your platform, you might want to target a specific ABI version, "
"which are documented [here](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""

#: src/interoperability/rust-with-c.md:52
msgid ""
"Putting these parts together, you get a function that looks roughly like "
"this."
msgstr ""

#: src/interoperability/rust-with-c.md:61
msgid ""
"Just as when using `C` code in your Rust project you now need to transform "
"data from and to a form that the rest of the application will understand."
msgstr ""

#: src/interoperability/rust-with-c.md:64
msgid "Linking and greater project context."
msgstr ""

#: src/interoperability/rust-with-c.md:66
msgid ""
"So then, that's one half of the problem solved. How do you use this now?"
msgstr ""

#: src/interoperability/rust-with-c.md:69
msgid "**This very much depends on your project and/or build system**"
msgstr ""

#: src/interoperability/rust-with-c.md:71
msgid ""
"`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file, depending "
"on your platform and settings. This library can simply be linked by your "
"build system."
msgstr ""

#: src/interoperability/rust-with-c.md:75
msgid ""
"However, calling a Rust function from C requires a header file to declare "
"the function signatures."
msgstr ""

#: src/interoperability/rust-with-c.md:78
msgid ""
"Every function in your Rust-ffi API needs to have a corresponding header "
"function."
msgstr ""

#: src/interoperability/rust-with-c.md:85
msgid "would then become"
msgstr ""

#: src/interoperability/rust-with-c.md:91
msgid "etc."
msgstr ""

#: src/interoperability/rust-with-c.md:93
msgid ""
"There is a tool to automate this process, called [cbindgen](https://"
"github.com/eqrion/cbindgen) which analyses your Rust code and then generates "
"headers for your C and C++ projects from it."
msgstr ""

#: src/interoperability/rust-with-c.md:99
msgid ""
"At this point, using the Rust functions from C is as simple as including the "
"header and calling them!"
msgstr ""

#: src/interoperability/rust-with-c.md:103
msgid "\\\"my-rust-project.h\\\""
msgstr "\"my-rust-project.h\""

#: src/unsorted/speed-vs-size.md:1
msgid "Optimizations: the speed size tradeoff"
msgstr "최적화: 속도와 크기의 트레이드오프"

#: src/unsorted/speed-vs-size.md:3
msgid ""
"Everyone wants their program to be super fast and super small but it's "
"usually not possible to have both characteristics. This section discusses "
"the different optimization levels that `rustc` provides and how they affect "
"the execution time and binary size of a program."
msgstr ""
"모든 사람은 자신의 프로그램이 매우 빠르고 매우 작기를 원하지만 일반적으로 두 "
"가지 특성을 모두 갖는 것은 불가능합니다. 이 섹션에서는 `rustc`가 제공하는 "
"다양한 최적화 수준과 이러한 수준이 프로그램의 실행 시간 및 바이너리 크기에 "
"미치는 영향에 대해 설명합니다."

#: src/unsorted/speed-vs-size.md:8
msgid "No optimizations"
msgstr "최적화 없음"

#: src/unsorted/speed-vs-size.md:10
msgid ""
"This is the default. When you call `cargo build` you use the development "
"(AKA `dev`) profile. This profile is optimized for debugging so it enables "
"debug information and does _not_ enable any optimizations, i.e. it uses `-C "
"opt-level = 0`."
msgstr ""
"이것이 기본값입니다. `cargo build`를 호출하면 개발(일명 `dev`) 프로필을 "
"사용합니다. 이 프로필은 디버깅에 최적화되어 있으므로 디버그 정보를 활성화하고 "
"최적화를 활성화하지 않습니다. 즉, `-C opt-level = 0`을 사용합니다."

#: src/unsorted/speed-vs-size.md:15
msgid ""
"At least for bare metal development, debuginfo is zero cost in the sense "
"that it won't occupy space in Flash / ROM so we actually recommend that you "
"enable debuginfo in the release profile -- it is disabled by default. That "
"will let you use breakpoints when debugging release builds."
msgstr ""
"적어도 베어메탈 개발의 경우, 디버그 정보는 플래시/ROM 공간을 차지하지 않는다는 "
"점에서 비용이 없습니다. 따라서 릴리스 프로필에서 디버그 정보를 활성화하는 것이 "
"좋습니다. 기본적으로 비활성화되어 있습니다. 이렇게 하면 릴리스 빌드를 디버깅할 때 "
"중단점을 사용할 수 있습니다."

#: src/unsorted/speed-vs-size.md:26
msgid ""
"No optimizations is great for debugging because stepping through the code "
"feels like you are executing the program statement by statement, plus you "
"can `print` stack variables and function arguments in GDB. When the code is "
"optimized, trying to print variables results in `$0 = <value optimized out>` "
"being printed."
msgstr ""
"최적화가 없으면 코드를 한 문장씩 실행하는 것처럼 느껴지기 때문에 디버깅에 "
"좋습니다. 또한 GDB에서 스택 변수와 함수 인수를 `print`할 수 있습니다. 코드가 "
"최적화되면 변수를 인쇄하려고 하면 `$0 = <value optimized out>`이 인쇄됩니다."

#: src/unsorted/speed-vs-size.md:31
msgid ""
"The biggest downside of the `dev` profile is that the resulting binary will "
"be huge and slow. The size is usually more of a problem because unoptimized "
"binaries can occupy dozens of KiB of Flash, which your target device may not "
"have -- the result: your unoptimized binary doesn't fit in your device!"
msgstr ""
"`dev` 프로필의 가장 큰 단점은 결과 바이너리가 거대하고 느리다는 것입니다. "
"최적화되지 않은 바이너리는 수십 KiB의 플래시를 차지할 수 있으며 대상 장치에 "
"없을 수 있으므로 크기가 일반적으로 더 큰 문제입니다. 결과: 최적화되지 않은 "
"바이너리가 장치에 맞지 않습니다!"

#: src/unsorted/speed-vs-size.md:36
msgid "Can we have smaller, debugger friendly binaries? Yes, there's a trick."
msgstr "더 작고 디버거 친화적인 바이너리를 가질 수 있을까요? 예, 비결이 있습니다."

#: src/unsorted/speed-vs-size.md:38
msgid "Optimizing dependencies"
msgstr "종속성 최적화"

#: src/unsorted/speed-vs-size.md:40
msgid ""
"There's a Cargo feature named [`profile-overrides`](https://doc.rust-"
"lang.org/cargo/reference/profiles.html#overrides) that lets you override the "
"optimization level of dependencies. You can use that feature to optimize all "
"dependencies for size while keeping the top crate unoptimized and debugger "
"friendly."
msgstr ""
"[`profile-overrides`](https://doc.rust-lang.org/cargo/reference/profiles.html#overrides)라는 "
"Cargo 기능이 있어 종속성의 최적화 수준을 재정의할 수 있습니다. 이 기능을 "
"사용하여 모든 종속성을 크기에 맞게 최적화하면서 최상위 크레이트는 최적화되지 "
"않고 디버거 친화적으로 유지할 수 있습니다."

#: src/unsorted/speed-vs-size.md:45
msgid ""
"Beware that generic code can sometimes be optimized alongside the crate "
"where it is instantiated, rather than the crate where it is defined. If you "
"create an instance of a generic struct in your application and find that it "
"pulls in code with a large footprint, it may be that increasing the "
"optimisation level of the relevant dependencies has no effect."
msgstr ""
"제네릭 코드는 정의된 크레이트가 아닌 인스턴스화된 크레이트와 함께 최적화될 "
"수 있다는 점에 유의하십시오. 애플리케이션에서 제네릭 구조체의 인스턴스를 "
"만들고 큰 공간을 차지하는 코드를 가져오는 경우 관련 종속성의 최적화 수준을 "
"높여도 효과가 없을 수 있습니다."

#: src/unsorted/speed-vs-size.md:53
msgid "Here's an example:"
msgstr "다음은 예시입니다."

#: src/unsorted/speed-vs-size.md:55
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"
msgstr ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"

#: src/unsorted/speed-vs-size.md:65
msgid "Without the override:"
msgstr "재정의 없이:"

#: src/unsorted/speed-vs-size.md:78
msgid "With the override:"
msgstr "재정의 포함:"

#: src/unsorted/speed-vs-size.md:91
msgid ""
"That's a 6 KiB reduction in Flash usage without any loss in the "
"debuggability of the top crate. If you step into a dependency then you'll "
"start seeing those `<value optimized out>` messages again but it's usually "
"the case that you want to debug the top crate and not the dependencies. And "
"if you _do_ need to debug a dependency then you can use the `profile-"
"overrides` feature to exclude a particular dependency from being optimized. "
"See example below:"
msgstr ""
"최상위 크레이트의 디버깅 가능성을 잃지 않고 플래시 사용량이 6KiB "
"감소했습니다. 종속성으로 들어가면 `<value optimized out>` 메시지가 다시 "
"표시되지만 일반적으로 종속성이 아닌 최상위 크레이트를 디버그하려는 경우입니다. "
"그리고 종속성을 디버그해야 하는 경우 `profile-overrides` 기능을 사용하여 특정 "
"종속성을 최적화에서 제외할 수 있습니다. 아래 예제를 참조하십시오."

#: src/unsorted/speed-vs-size.md:98
msgid ""
"```toml\n"
"# ..\n"
"\n"
"# don't optimize the `cortex-m-rt` crate\n"
"[profile.dev.package.cortex-m-rt] # +\n"
"opt-level = 0 # +\n"
"\n"
"# but do optimize all the other dependencies\n"
"[profile.dev.package.\"*\"]\n"
"codegen-units = 1 # better optimizations\n"
"opt-level = \"z\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:111
msgid "Now the top crate and `cortex-m-rt` are debugger friendly!"
msgstr "이제 최상위 크레이트와 `cortex-m-rt`는 디버거 친화적입니다!"

#: src/unsorted/speed-vs-size.md:113
msgid "Optimize for speed"
msgstr "속도 최적화"

#: src/unsorted/speed-vs-size.md:115
msgid ""
"As of 2018-09-18 `rustc` supports three \"optimize for speed\" levels: `opt-"
"level = 1`, `2` and `3`. When you run `cargo build --release` you are using "
"the release profile which defaults to `opt-level = 3`."
msgstr ""
"2018-09-18 기준으로 `rustc`는 세 가지 \"속도 최적화\" 수준을 지원합니다: "
"`opt-level = 1`, `2` 및 `3`. `cargo build --release`를 실행하면 기본적으로 "
"`opt-level = 3`인 릴리스 프로필을 사용합니다."

#: src/unsorted/speed-vs-size.md:119
msgid ""
"Both `opt-level = 2` and `3` optimize for speed at the expense of binary "
"size, but level `3` does more vectorization and inlining than level `2`. In "
"particular, you'll see that at `opt-level` equal to or greater than `2` LLVM "
"will unroll loops. Loop unrolling has a rather high cost in terms of Flash / "
"ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also "
"halve the execution time given the right conditions (e.g. number of "
"iterations is big enough)."
msgstr ""
"`opt-level = 2`와 `3` 모두 바이너리 크기를 희생하여 속도를 최적화하지만, "
"수준 `3`은 수준 `2`보다 더 많은 벡터화 및 인라이닝을 수행합니다. 특히 "
"`opt-level`이 `2` 이상이면 LLVM이 루프를 언롤링하는 것을 볼 수 있습니다. "
"루프 언롤링은 플래시/ROM 측면에서 비용이 상당히 높지만(예: 이 배열 루프를 "
"0으로 만드는 데 26바이트에서 194바이트로) 올바른 조건(예: 반복 횟수가 "
"충분히 큼)이 주어지면 실행 시간을 절반으로 줄일 수도 있습니다."

#: src/unsorted/speed-vs-size.md:127
msgid ""
"Currently there's no way to disable loop unrolling in `opt-level = 2` and "
"`3` so if you can't afford its cost you should optimize your program for "
"size."
msgstr "현재 `opt-level = 2` 및 `3`에서 루프 언롤링을 비활성화할 방법이 없으므로 비용을 감당할 수 없다면 프로그램을 크기에 맞게 최적화해야 합니다."

#: src/unsorted/speed-vs-size.md:130
msgid "Optimize for size"
msgstr "크기 최적화"

#: src/unsorted/speed-vs-size.md:132
msgid ""
"As of 2018-09-18 `rustc` supports two \"optimize for size\" levels: `opt-"
"level = \"s\"` and `\"z\"`. These names were inherited from clang / LLVM and "
"are not too descriptive but `\"z\"` is meant to give the idea that it "
"produces smaller binaries than `\"s\"`."
msgstr ""
"2018-09-18 기준으로 `rustc`는 두 가지 \"크기 최적화\" 수준을 지원합니다: "
"`opt-level = \"s\"` 및 `\"z\"`. 이 이름들은 clang / LLVM에서 상속되었으며 "
"그다지 설명적이지는 않지만 `\"z\"`는 `\"s\"`보다 작은 바이너리를 "
"생성한다는 아이디어를 제공하기 위한 것입니다."

#: src/unsorted/speed-vs-size.md:137
msgid ""
"If you want your release binaries to be optimized for size then change the "
"`profile.release.opt-level` setting in `Cargo.toml` as shown below."
msgstr ""
"릴리스 바이너리를 크기에 맞게 최적화하려면 아래와 같이 `Cargo.toml`에서 "
"`profile.release.opt-level` 설정을 변경하십시오."

#: src/unsorted/speed-vs-size.md:140
msgid ""
"```toml\n"
"[profile.release]\n"
"# or \"z\"\n"
"opt-level = \"s\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:146
msgid ""
"These two optimization levels greatly reduce LLVM's inline threshold, a "
"metric used to decide whether to inline a function or not. One of Rust "
"principles are zero cost abstractions; these abstractions tend to use a lot "
"of newtypes and small functions to hold invariants (e.g. functions that "
"borrow an inner value like `deref`, `as_ref`) so a low inline threshold can "
"make LLVM miss optimization opportunities (e.g. eliminate dead branches, "
"inline calls to closures)."
msgstr ""

#: src/unsorted/speed-vs-size.md:154
msgid ""
"When optimizing for size you may want to try increasing the inline threshold "
"to see if that has any effect on the binary size. The recommended way to "
"change the inline threshold is to append the `-C inline-threshold` flag to "
"the other rustflags in `.cargo/config.toml`."
msgstr ""

#: src/unsorted/speed-vs-size.md:159
msgid ""
"```toml\n"
"# .cargo/config.toml\n"
"# this assumes that you are using the cortex-m-quickstart template\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\n"
"  # ..\n"
"  \"-C\", \"inline-threshold=123\", # +\n"
"]\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:169
msgid ""
"What value to use? [As of 1.29.0 these are the inline thresholds that the "
"different optimization levels use](https://github.com/rust-lang/rust/blob/"
"1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122):"
msgstr ""

#: src/unsorted/speed-vs-size.md:174
msgid "`opt-level = 3` uses 275"
msgstr ""

#: src/unsorted/speed-vs-size.md:175
msgid "`opt-level = 2` uses 225"
msgstr ""

#: src/unsorted/speed-vs-size.md:176
msgid "`opt-level = \"s\"` uses 75"
msgstr ""

#: src/unsorted/speed-vs-size.md:177
msgid "`opt-level = \"z\"` uses 25"
msgstr ""

#: src/unsorted/speed-vs-size.md:179
msgid "You should try `225` and `275` when optimizing for size."
msgstr ""

#: src/unsorted/math.md:1
msgid "Performing math functionality with `#[no_std]`"
msgstr "`#[no_std]`로 수학 기능 수행"

#: src/unsorted/math.md:3
msgid ""
"If you want to perform math related functionality like calculating the "
"squareroot or the exponential of a number and you have the full standard "
"library available, your code might look like this:"
msgstr ""
"숫자의 제곱근 또는 지수를 계산하는 것과 같은 수학 관련 기능을 수행하고 싶고 "
"전체 표준 라이브러리를 사용할 수 있다면 코드는 다음과 같을 것입니다:"

#: src/unsorted/math.md:8
msgid "//! Some mathematical functions with standard support available\n"
msgstr "//! 표준 지원을 사용할 수 있는 일부 수학 함수\n"

#: src/unsorted/math.md:19 src/unsorted/math.md:53
msgid "\"Floored test float {} to {}\""
msgstr ""

#: src/unsorted/math.md:20 src/unsorted/math.md:54
msgid "\"The square root of {} is {}\""
msgstr ""

#: src/unsorted/math.md:21 src/unsorted/math.md:55
msgid "\"The sinus of four is {}\""
msgstr ""

#: src/unsorted/math.md:23 src/unsorted/math.md:57
msgid "\"The exponential of four to the base e is {}\""
msgstr ""

#: src/unsorted/math.md:29
msgid ""
"Without standard library support, these functions are not available. An "
"external crate like [`libm`](https://crates.io/crates/libm) can be used "
"instead. The example code would then look like this:"
msgstr ""
"표준 라이브러리 지원 없이는 이러한 함수를 사용할 수 없습니다. 대신 "
"[`libm`](https://crates.io/crates/libm)과 같은 외부 크레이트를 사용할 수 "
"있습니다. 그러면 예제 코드는 다음과 같을 것입니다:"

#: src/unsorted/math.md:69
msgid ""
"If you need to perform more complex operations like DSP signal processing or "
"advanced linear algebra on your MCU, the following crates might help you"
msgstr ""
"MCU에서 DSP 신호 처리 또는 고급 선형 대수와 같은 더 복잡한 작업을 수행해야 "
"하는 경우 다음 크레이트가 도움이 될 수 있습니다."

#: src/unsorted/math.md:72
msgid ""
"[CMSIS DSP library binding](https://github.com/jacobrosenthal/cmsis-dsp-sys)"
msgstr "[CMSIS DSP 라이브러리 바인딩](https://github.com/jacobrosenthal/cmsis-dsp-sys)"

#: src/unsorted/math.md:73
msgid "[`constgebra`](https://crates.io/crates/constgebra)"
msgstr "[`constgebra`](https://crates.io/crates/constgebra)"

#: src/unsorted/math.md:74
msgid "[`micromath`](https://github.com/tarcieri/micromath)"
msgstr "[`micromath`](https://github.com/tarcieri/micromath)"

#: src/unsorted/math.md:75
msgid "[`microfft`](https://crates.io/crates/microfft)"
msgstr "[`microfft`](https://crates.io/crates/microfft)"

#: src/unsorted/math.md:76
msgid "[`nalgebra`](https://github.com/dimforge/nalgebra)"
msgstr "[`nalgebra`](https://github.com/dimforge/nalgebra)"

#: src/appendix/glossary.md:3
msgid ""
"The embedded ecosystem is full of different protocols, hardware components "
"and vendor-specific things that use their own terms and abbreviations. This "
"Glossary attempts to list them with pointers for understanding them better."
msgstr ""
"임베디드 생태계는 다양한 프로토콜, 하드웨어 구성 요소 및 공급업체별 용어와 "
"약어를 사용하는 것들로 가득합니다. 이 용어집은 이러한 것들을 더 잘 이해하기 "
"위한 포인터와 함께 나열하려고 합니다."

#: src/appendix/glossary.md:7
msgid "BSP"
msgstr "BSP"

#: src/appendix/glossary.md:9
msgid ""
"A Board Support Crate provides a high level interface configured for a "
"specific board. It usually depends on a [HAL](#hal) crate. There is a more "
"detailed description on the [memory-mapped registers page](../start/"
"registers.md) or for a broader overview see [this video](https://youtu.be/"
"vLYit_HHPaY)."
msgstr ""
"보드 지원 크레이트는 특정 보드에 대해 구성된 고수준 인터페이스를 제공합니다. "
"일반적으로 [HAL](#hal) 크레이트에 의존합니다. [메모리 매핑 레지스터 "
"페이지](../start/registers.md)에 더 자세한 설명이 있거나 더 넓은 개요는 "
"[이 비디오](https://youtu.be/vLYit_HHPaY)를 참조하십시오."

#: src/appendix/glossary.md:14
msgid "FPU"
msgstr "FPU"

#: src/appendix/glossary.md:16
msgid ""
"Floating-point Unit. A 'math processor' running only operations on floating-"
"point numbers."
msgstr ""
"부동 소수점 장치. 부동 소수점 숫자에 대한 연산만 실행하는 '수학 프로세서'."

#: src/appendix/glossary.md:18
msgid "HAL"
msgstr "HAL"

#: src/appendix/glossary.md:20
msgid ""
"A Hardware Abstraction Layer crate provides a developer friendly interface "
"to a microcontroller's features and peripherals. It is usually implemented "
"on top of a [Peripheral Access Crate (PAC)](#pac). It may also implement "
"traits from the [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"crate. There is a more detailed description on the [memory-mapped registers "
"page](../start/registers.md) or for a broader overview see [this video]"
"(https://youtu.be/vLYit_HHPaY)."
msgstr ""
"하드웨어 추상화 계층 크레이트는 마이크로컨트롤러의 기능과 주변 장치에 대한 "
"개발자 친화적인 인터페이스를 제공합니다. 일반적으로 [주변 장치 접근 "
"크레이트(PAC)](#pac) 위에 구현됩니다. 또한 [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"크레이트의 트레이트를 구현할 수도 있습니다. [메모리 매핑 레지스터 "
"페이지](../start/registers.md)에 더 자세한 설명이 있거나 더 넓은 개요는 "
"[이 비디오](https://youtu.be/vLYit_HHPaY)를 참조하십시오."

#: src/appendix/glossary.md:28
msgid ""
"Sometimes referred to as `I²C` or Inter-IC. It is a protocol meant for "
"hardware communication within a single integrated circuit. See [here]"
"(https://en.wikipedia.org/wiki/I2c) for more details"
msgstr ""
"때로는 `I²C` 또는 Inter-IC라고도 합니다. 단일 집적 회로 내에서 하드웨어 통신을 "
"위한 프로토콜입니다. 자세한 내용은 [여기](https://en.wikipedia.org/wiki/I2c)를 "
"참조하십시오."

#: src/appendix/glossary.md:33
msgid "PAC"
msgstr "PAC"

#: src/appendix/glossary.md:35
msgid ""
"A Peripheral Access Crate provides access to a microcontroller's "
"peripherals. It is one of the lower level crates and is usually generated "
"directly from the provided [SVD](#svd), often using [svd2rust](https://"
"github.com/rust-embedded/svd2rust/). The [Hardware Abstraction Layer](#hal) "
"would usually depend on this crate. There is a more detailed description on "
"the [memory-mapped registers page](../start/registers.md) or for a broader "
"overview see [this video](https://youtu.be/vLYit_HHPaY)."
msgstr ""
"주변 장치 접근 크레이트는 마이크로컨트롤러의 주변 장치에 대한 접근을 제공합니다. "
"이는 저수준 크레이트 중 하나이며 일반적으로 제공된 [SVD](#svd)에서 직접 생성되며, "
"종종 [svd2rust](https://github.com/rust-embedded/svd2rust/)를 사용합니다. "
"[하드웨어 추상화 계층](#hal)은 일반적으로 이 크레이트에 의존합니다. [메모리 매핑 "
"레지스터 페이지](../start/registers.md)에 더 자세한 설명이 있거나 더 넓은 개요는 "
"[이 비디오](https://youtu.be/vLYit_HHPaY)를 참조하십시오."

#: src/appendix/glossary.md:44
msgid ""
"Serial Peripheral Interface. See [here](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface) for more information."
msgstr ""
"직렬 주변 장치 인터페이스. 자세한 내용은 [여기](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface)를 참조하십시오."

#: src/appendix/glossary.md:48
msgid "SVD"
msgstr "SVD"

#: src/appendix/glossary.md:50
msgid ""
"System View Description is an XML file format used to describe the "
"programmers view of a microcontroller device. You can read more about it on "
"[the ARM CMSIS documentation site](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)."
msgstr ""
"시스템 뷰 설명은 마이크로컨트롤러 장치의 프로그래머 뷰를 설명하는 데 사용되는 "
"XML 파일 형식입니다. [ARM CMSIS 문서 사이트](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)에서 자세한 내용을 읽을 수 있습니다."

#: src/appendix/glossary.md:54
msgid "UART"
msgstr "UART"

#: src/appendix/glossary.md:56
msgid ""
"Universal asynchronous receiver-transmitter. See [here](https://"
"en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
"범용 비동기 수신기-송신기. 자세한 내용은 [여기](https://en.wikipedia.org/wiki/"
"Universal_asynchronous_receiver-transmitter)를 참조하십시오."

#: src/appendix/glossary.md:60
msgid "USART"
msgstr "USART"

#: src/appendix/glossary.md:62
msgid ""
"Universal synchronous and asynchronous receiver-transmitter. See [here]"
"(https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
"범용 동기 및 비동기 수신기-송신기. 자세한 내용은 [여기](https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter)를 참조하십시오."
