msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-10-16T13:20:39+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-16T13:20:39+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Rust Programming Language"
msgstr "러스트 프로그래밍 언어"

#: src/SUMMARY.md:3
msgid "The Rust Programming Language Foreword Introduction"
msgstr "러스트 프로그래밍 언어 서문 소개"

#: src/SUMMARY.md:7
msgid "Getting started"
msgstr "시작하기"

#: src/SUMMARY.md:9 src/ch01-00-getting-started.md:1
msgid "Getting Started"
msgstr "시작하기"

#: src/SUMMARY.md:10 src/ch01-01-installation.md:1
msgid "Installation"
msgstr "설치"

#: src/SUMMARY.md:11 src/ch01-02-hello-world.md:1
msgid "Hello, World!"
msgstr "헬로, 월드!"

#: src/SUMMARY.md:12 src/ch01-03-hello-cargo.md:1
msgid "Hello, Cargo!"
msgstr "헬로, 카고!"

#: src/SUMMARY.md:14 src/ch02-00-guessing-game-tutorial.md:1
msgid "Programming a Guessing Game"
msgstr "추측 게임 프로그래밍"

#: src/SUMMARY.md:16 src/ch03-00-common-programming-concepts.md:1
msgid "Common Programming Concepts"
msgstr "일반적인 프로그래밍 개념"

#: src/SUMMARY.md:17 src/ch03-01-variables-and-mutability.md:1
msgid "Variables and Mutability"
msgstr "변수와 가변성"

#: src/SUMMARY.md:18 src/ch03-02-data-types.md:1
msgid "Data Types"
msgstr "데이터 타입"

#: src/SUMMARY.md:19 src/ch03-03-how-functions-work.md:1
msgid "Functions"
msgstr "함수"

#: src/SUMMARY.md:20 src/ch03-04-comments.md:1
msgid "Comments"
msgstr "주석"

#: src/SUMMARY.md:21 src/ch03-05-control-flow.md:1
msgid "Control Flow"
msgstr "제어 흐름"

#: src/SUMMARY.md:23 src/ch04-00-understanding-ownership.md:1
msgid "Understanding Ownership"
msgstr "소유권 이해하기"

#: src/SUMMARY.md:24
msgid "What is Ownership?"
msgstr "소유권이란 무엇인가?"

#: src/SUMMARY.md:25 src/ch04-02-references-and-borrowing.md:1
msgid "References and Borrowing"
msgstr "참조와 대여"

#: src/SUMMARY.md:26 src/ch04-03-slices.md:1
msgid "The Slice Type"
msgstr "슬라이스 타입"

#: src/SUMMARY.md:28 src/ch05-00-structs.md:1
msgid "Using Structs to Structure Related Data"
msgstr "구조체를 사용하여 관련 데이터 구조화하기"

#: src/SUMMARY.md:29 src/ch05-01-defining-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr "구조체 정의하고 인스턴스화하기"

#: src/SUMMARY.md:30 src/ch05-02-example-structs.md:1
msgid "An Example Program Using Structs"
msgstr "구조체를 사용한 예제 프로그램"

#: src/SUMMARY.md:31 src/ch05-03-method-syntax.md:1
msgid "Method Syntax"
msgstr "메서드 문법"

#: src/SUMMARY.md:33 src/ch06-00-enums.md:1
msgid "Enums and Pattern Matching"
msgstr "열거형과 패턴 매칭"

#: src/SUMMARY.md:34 src/ch06-01-defining-an-enum.md:1
msgid "Defining an Enum"
msgstr "열거형 정의하기"

#: src/SUMMARY.md:35 src/ch06-02-match.md:5
msgid "The `match` Control Flow Construct"
msgstr "`match` 제어 흐름 구조"

#: src/SUMMARY.md:36 src/ch06-03-if-let.md:1
msgid "Concise Control Flow with `if let` and `let else`"
msgstr "`if let`과 `let else`를 사용한 간결한 제어 흐름"

#: src/SUMMARY.md:38
msgid "Basic Rust Literacy"
msgstr "기본 러스트 문해력"

#: src/SUMMARY.md:40
#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:1
msgid "Managing Growing Projects with Packages, Crates, and Modules"
msgstr "패키지, 크레이트, 모듈로 성장하는 프로젝트 관리하기"

#: src/SUMMARY.md:41 src/ch07-01-packages-and-crates.md:1
msgid "Packages and Crates"
msgstr "패키지와 크레이트"

#: src/SUMMARY.md:42
#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:1
msgid "Defining Modules to Control Scope and Privacy"
msgstr "스코프와 프라이버시를 제어하는 모듈 정의하기"

#: src/SUMMARY.md:43
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:1
msgid "Paths for Referring to an Item in the Module Tree"
msgstr "모듈 트리의 항목을 참조하는 경로"

#: src/SUMMARY.md:44
msgid "Bringing Paths Into Scope with the `use` Keyword"
msgstr "`use` 키워드로 경로를 스코프로 가져오기"

#: src/SUMMARY.md:45 src/ch07-05-separating-modules-into-different-files.md:1
msgid "Separating Modules into Different Files"
msgstr "모듈을 다른 파일로 분리하기"

#: src/SUMMARY.md:47 src/ch08-00-common-collections.md:1
msgid "Common Collections"
msgstr "일반적인 컬렉션"

#: src/SUMMARY.md:48 src/ch08-01-vectors.md:1
msgid "Storing Lists of Values with Vectors"
msgstr "벡터로 값의 목록 저장하기"

#: src/SUMMARY.md:49 src/ch08-02-strings.md:1
msgid "Storing UTF-8 Encoded Text with Strings"
msgstr "문자열로 UTF-8 인코딩된 텍스트 저장하기"

#: src/SUMMARY.md:50 src/ch08-03-hash-maps.md:1
msgid "Storing Keys with Associated Values in Hash Maps"
msgstr "해시 맵에서 키와 연관된 값 저장하기"

#: src/SUMMARY.md:52 src/ch09-00-error-handling.md:1
msgid "Error Handling"
msgstr "에러 처리"

#: src/SUMMARY.md:53 src/ch09-01-unrecoverable-errors-with-panic.md:1
msgid "Unrecoverable Errors with `panic!`"
msgstr "`panic!`으로 복구 불가능한 에러 처리하기"

#: src/SUMMARY.md:54 src/ch09-02-recoverable-errors-with-result.md:1
msgid "Recoverable Errors with `Result`"
msgstr "`Result`로 복구 가능한 에러 처리하기"

#: src/SUMMARY.md:55 src/ch09-03-to-panic-or-not-to-panic.md:1
msgid "To `panic!` or Not to `panic!`"
msgstr "`panic!`을 사용할지 말지"

#: src/SUMMARY.md:57 src/ch10-00-generics.md:1
msgid "Generic Types, Traits, and Lifetimes"
msgstr "제네릭 타입, 트레이트, 라이프타임"

#: src/SUMMARY.md:58 src/ch10-01-syntax.md:1
msgid "Generic Data Types"
msgstr "제네릭 데이터 타입"

#: src/SUMMARY.md:59 src/ch10-02-traits.md:1
msgid "Traits: Defining Shared Behavior"
msgstr "트레이트: 공유 동작 정의하기"

#: src/SUMMARY.md:60 src/ch10-03-lifetime-syntax.md:1
msgid "Validating References with Lifetimes"
msgstr "라이프타임으로 참조 유효성 검증하기"

#: src/SUMMARY.md:62 src/ch11-00-testing.md:1
msgid "Writing Automated Tests"
msgstr "자동화된 테스트 작성하기"

#: src/SUMMARY.md:63 src/ch11-01-writing-tests.md:1
msgid "How to Write Tests"
msgstr "테스트 작성 방법"

#: src/SUMMARY.md:64 src/ch11-02-running-tests.md:1
msgid "Controlling How Tests Are Run"
msgstr "테스트 실행 방법 제어하기"

#: src/SUMMARY.md:65 src/ch11-03-test-organization.md:1
msgid "Test Organization"
msgstr "테스트 구성"

#: src/SUMMARY.md:67 src/ch12-00-an-io-project.md:1
msgid "An I/O Project: Building a Command Line Program"
msgstr "I/O 프로젝트: 명령줄 프로그램 만들기"

#: src/SUMMARY.md:68 src/ch12-01-accepting-command-line-arguments.md:1
msgid "Accepting Command Line Arguments"
msgstr "명령줄 인수 받기"

#: src/SUMMARY.md:69 src/ch12-02-reading-a-file.md:1
msgid "Reading a File"
msgstr "파일 읽기"

#: src/SUMMARY.md:70 src/ch12-03-improving-error-handling-and-modularity.md:1
msgid "Refactoring to Improve Modularity and Error Handling"
msgstr "모듈성과 에러 처리 개선을 위한 리팩터링"

#: src/SUMMARY.md:71
msgid "Developing the Library’s Functionality with Test Driven Development"
msgstr "테스트 주도 개발을 통한 라이브러리 기능 개발"

#: src/SUMMARY.md:72 src/ch12-05-working-with-environment-variables.md:1
msgid "Working with Environment Variables"
msgstr "환경 변수 다루기"

#: src/SUMMARY.md:73 src/ch12-06-writing-to-stderr-instead-of-stdout.md:1
msgid "Writing Error Messages to Standard Error Instead of Standard Output"
msgstr "표준 출력 대신 표준 에러로 에러 메시지 출력하기"

#: src/SUMMARY.md:75
msgid "Thinking in Rust"
msgstr "러스트적 사고"

#: src/SUMMARY.md:77 src/ch13-00-functional-features.md:1
msgid "Functional Language Features: Iterators and Closures"
msgstr "함수형 언어 기능: 반복자와 클로저"

#: src/SUMMARY.md:78 src/ch13-01-closures.md:5
msgid "Closures: Anonymous Functions that Capture Their Environment"
msgstr "클로저: 환경을 캡처하는 익명 함수"

#: src/SUMMARY.md:79 src/ch13-02-iterators.md:1
msgid "Processing a Series of Items with Iterators"
msgstr "반복자로 일련의 항목 처리하기"

#: src/SUMMARY.md:80 src/ch13-03-improving-our-io-project.md:1
msgid "Improving Our I/O Project"
msgstr "I/O 프로젝트 개선하기"

#: src/SUMMARY.md:81 src/ch13-04-performance.md:1
msgid "Comparing Performance: Loops vs. Iterators"
msgstr "성능 비교: 루프 vs. 반복자"

#: src/SUMMARY.md:83
msgid "More about Cargo and Crates.io"
msgstr "Cargo와 Crates.io에 대해 더 알아보기"

#: src/SUMMARY.md:84 src/ch14-01-release-profiles.md:1
msgid "Customizing Builds with Release Profiles"
msgstr "릴리스 프로필로 빌드 커스터마이징하기"

#: src/SUMMARY.md:85 src/ch14-02-publishing-to-crates-io.md:1
msgid "Publishing a Crate to Crates.io"
msgstr "Crates.io에 크레이트 게시하기"

#: src/SUMMARY.md:86 src/ch14-03-cargo-workspaces.md:1
msgid "Cargo Workspaces"
msgstr "Cargo 워크스페이스"

#: src/SUMMARY.md:87
msgid "Installing Binaries from Crates.io with `cargo install`"
msgstr "`cargo install`로 Crates.io에서 바이너리 설치하기"

#: src/SUMMARY.md:88 src/ch14-05-extending-cargo.md:1
msgid "Extending Cargo with Custom Commands"
msgstr "커스텀 명령어로 Cargo 확장하기"

#: src/SUMMARY.md:90 src/ch15-00-smart-pointers.md:1
msgid "Smart Pointers"
msgstr "스마트 포인터"

#: src/SUMMARY.md:91 src/ch15-01-box.md:1
msgid "Using `Box<T>` to Point to Data on the Heap"
msgstr "`Box<T>`를 사용하여 힙의 데이터 가리키기"

#: src/SUMMARY.md:92 src/ch15-02-deref.md:1
msgid "Treating Smart Pointers Like Regular References with the `Deref` Trait"
msgstr "`Deref` 트레이트로 스마트 포인터를 일반 참조처럼 다루기"

#: src/SUMMARY.md:93 src/ch15-03-drop.md:1
msgid "Running Code on Cleanup with the `Drop` Trait"
msgstr "`Drop` 트레이트로 정리 시 코드 실행하기"

#: src/SUMMARY.md:94 src/ch15-04-rc.md:1
msgid "`Rc<T>`, the Reference Counted Smart Pointer"
msgstr "`Rc<T>`, 참조 카운팅 스마트 포인터"

#: src/SUMMARY.md:95 src/ch15-05-interior-mutability.md:1
msgid "`RefCell<T>` and the Interior Mutability Pattern"
msgstr "`RefCell<T>`과 내부 가변성 패턴"

#: src/SUMMARY.md:96 src/ch15-06-reference-cycles.md:1
msgid "Reference Cycles Can Leak Memory"
msgstr "참조 순환은 메모리 누수를 일으킬 수 있다"

#: src/SUMMARY.md:98 src/ch16-00-concurrency.md:1
msgid "Fearless Concurrency"
msgstr "두려움 없는 동시성"

#: src/SUMMARY.md:99 src/ch16-01-threads.md:1
msgid "Using Threads to Run Code Simultaneously"
msgstr "스레드를 사용하여 코드를 동시에 실행하기"

#: src/SUMMARY.md:100 src/ch16-02-message-passing.md:1
msgid "Using Message Passing to Transfer Data Between Threads"
msgstr "메시지 전달을 사용하여 스레드 간 데이터 전송하기"

#: src/SUMMARY.md:101 src/ch16-03-shared-state.md:1
msgid "Shared-State Concurrency"
msgstr "공유 상태 동시성"

#: src/SUMMARY.md:102 src/ch16-04-extensible-concurrency-sync-and-send.md:1
msgid "Extensible Concurrency with the `Sync` and `Send` Traits"
msgstr "`Sync`와 `Send` 트레이트로 확장 가능한 동시성"

#: src/SUMMARY.md:104 src/ch17-00-async-await.md:1
msgid ""
"Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams"
msgstr "비동기 프로그래밍의 기초: Async, Await, Future, Stream"

#: src/SUMMARY.md:105 src/ch17-01-futures-and-syntax.md:1
msgid "Futures and the Async Syntax"
msgstr "Future와 Async 문법"

#: src/SUMMARY.md:106 src/ch17-02-concurrency-with-async.md:1
msgid "Applying Concurrency with Async"
msgstr "Async로 동시성 적용하기"

#: src/SUMMARY.md:107
msgid "Working With Any Number of Futures"
msgstr "임의의 수의 Future와 작업하기"

#: src/SUMMARY.md:108 src/ch17-04-streams.md:1
msgid "Streams: Futures in Sequence"
msgstr "스트림: 순차적인 Future"

#: src/SUMMARY.md:109 src/ch17-05-traits-for-async.md:1
msgid "A Closer Look at the Traits for Async"
msgstr "Async를 위한 트레이트 자세히 살펴보기"

#: src/SUMMARY.md:110
msgid "Futures, Tasks, and Threads"
msgstr "Future, 태스크, 스레드"

#: src/SUMMARY.md:112
msgid "Object Oriented Programming Features of Rust"
msgstr "러스트의 객체 지향 프로그래밍 기능"

#: src/SUMMARY.md:113 src/ch18-01-what-is-oo.md:1
msgid "Characteristics of Object-Oriented Languages"
msgstr "객체 지향 언어의 특성"

#: src/SUMMARY.md:114 src/ch18-02-trait-objects.md:1
msgid "Using Trait Objects That Allow for Values of Different Types"
msgstr "다른 타입의 값을 허용하는 트레이트 객체 사용하기"

#: src/SUMMARY.md:115 src/ch18-03-oo-design-patterns.md:1
msgid "Implementing an Object-Oriented Design Pattern"
msgstr "객체 지향 디자인 패턴 구현하기"

#: src/SUMMARY.md:117
msgid "Advanced Topics"
msgstr "고급 주제"

#: src/SUMMARY.md:119 src/ch19-00-patterns.md:1
msgid "Patterns and Matching"
msgstr "패턴과 매칭"

#: src/SUMMARY.md:120 src/ch19-01-all-the-places-for-patterns.md:1
msgid "All the Places Patterns Can Be Used"
msgstr "패턴을 사용할 수 있는 모든 곳"

#: src/SUMMARY.md:121 src/ch19-02-refutability.md:1
msgid "Refutability: Whether a Pattern Might Fail to Match"
msgstr "반박 가능성: 패턴이 매치에 실패할 수 있는지 여부"

#: src/SUMMARY.md:122 src/ch19-03-pattern-syntax.md:1
msgid "Pattern Syntax"
msgstr "패턴 문법"

#: src/SUMMARY.md:124 src/ch20-00-advanced-features.md:1
msgid "Advanced Features"
msgstr "고급 기능"

#: src/SUMMARY.md:125 src/ch20-01-unsafe-rust.md:1
msgid "Unsafe Rust"
msgstr "안전하지 않은 러스트"

#: src/SUMMARY.md:126 src/ch20-02-advanced-traits.md:1
msgid "Advanced Traits"
msgstr "고급 트레이트"

#: src/SUMMARY.md:127 src/ch20-03-advanced-types.md:1
msgid "Advanced Types"
msgstr "고급 타입"

#: src/SUMMARY.md:128 src/ch20-04-advanced-functions-and-closures.md:1
msgid "Advanced Functions and Closures"
msgstr "고급 함수와 클로저"

#: src/SUMMARY.md:129 src/ch20-05-macros.md:1
msgid "Macros"
msgstr "매크로"

#: src/SUMMARY.md:131 src/ch21-00-final-project-a-web-server.md:1
msgid "Final Project: Building a Multithreaded Web Server"
msgstr "최종 프로젝트: 멀티스레드 웹 서버 만들기"

#: src/SUMMARY.md:132 src/ch21-01-single-threaded.md:1
msgid "Building a Single-Threaded Web Server"
msgstr "단일 스레드 웹 서버 만들기"

#: src/SUMMARY.md:133 src/ch21-02-multithreaded.md:1
msgid "Turning Our Single-Threaded Server into a Multithreaded Server"
msgstr "단일 스레드 서버를 멀티스레드 서버로 바꾸기"

#: src/SUMMARY.md:134 src/ch21-03-graceful-shutdown-and-cleanup.md:1
msgid "Graceful Shutdown and Cleanup"
msgstr "우아한 종료와 정리"

#: src/SUMMARY.md:136 src/appendix-00.md:1
msgid "Appendix"
msgstr "부록"

#: src/SUMMARY.md:137
msgid "A - Keywords"
msgstr "A - 키워드"

#: src/SUMMARY.md:138
msgid "B - Operators and Symbols"
msgstr "B - 연산자와 기호"

#: src/SUMMARY.md:139
msgid "C - Derivable Traits"
msgstr "C - 파생 가능한 트레이트"

#: src/SUMMARY.md:140
msgid "D - Useful Development Tools"
msgstr "D - 유용한 개발 도구"

#: src/SUMMARY.md:141
msgid "E - Editions"
msgstr "E - 에디션"

#: src/SUMMARY.md:142
msgid "F - Translations of the Book"
msgstr "F - 책의 번역본"

#: src/SUMMARY.md:143
msgid "G - How Rust is Made and “Nightly Rust”"
msgstr "G - 러스트가 만들어지는 방법과 \"Nightly Rust\""

#: src/title-page.md:3
msgid ""
"_by Steve Klabnik, Carol Nichols, and Chris Krycho, with contributions from "
"the Rust Community_"
msgstr "_Steve Klabnik, Carol Nichols, Chris Krycho 저, 러스트 커뮤니티 기여_"

#: src/title-page.md:6
msgid ""
"This version of the text assumes you’re using Rust 1.82.0 (released "
"2024-10-17) or later. See the [“Installation” section of Chapter 1](ch01-01-"
"installation.html)<!-- ignore --> to install or update Rust."
msgstr ""
"이 텍스트 버전은 Rust 1.82.0 (2024-10-17 출시) 이상을 사용한다고 가정합니다. "
"Rust를 설치하거나 업데이트하려면 [1장의 \"설치\" 섹션](ch01-01-"
"installation.html)<!-- ignore -->을 참조하세요."

#: src/title-page.md:10
msgid ""
"The HTML format is available online at [https://doc.rust-lang.org/stable/"
"book/](https://doc.rust-lang.org/stable/book/) and offline with "
"installations of Rust made with `rustup`; run `rustup doc --book` to open."
msgstr ""
"HTML 형식은 온라인에서 [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)에서 "
"이용할 수 있으며, `rustup`으로 설치한 Rust와 함께 오프라인에서도 이용할 수 있습니다. `rustup doc --book`을 실행하여 열 수 있습니다."

#: src/title-page.md:15
msgid ""
"Several community [translations](appendix-06-translation.html) are also "
"available."
msgstr "여러 커뮤니티 [번역본](appendix-06-translation.html)도 이용할 수 있습니다."

#: src/title-page.md:17
msgid ""
"This text is available in [paperback and ebook format from No Starch Press]"
"(https://nostarch.com/rust-programming-language-2nd-edition)."
msgstr ""
"이 텍스트는 [No Starch Press에서 종이책과 전자책 형식](https://nostarch.com/rust-programming-language-2nd-edition)으로 "
"이용할 수 있습니다."

#: src/title-page.md:24
msgid ""
"**🚨 Want a more interactive learning experience? Try out a different "
"version of the Rust Book, featuring: quizzes, highlighting, visualizations, "
"and more**: <https://rust-book.cs.brown.edu>"
msgstr ""
"**🚨 더 상호작용적인 학습 경험을 원하시나요? 퀴즈, 하이라이팅, 시각화 등을 "
"포함한 다른 버전의 Rust Book을 시도해보세요**: <https://rust-book.cs.brown.edu>"

#: src/foreword.md:1
msgid "Foreword"
msgstr "서문"

#: src/foreword.md:3
msgid ""
"It wasn’t always so clear, but the Rust programming language is "
"fundamentally about _empowerment_: no matter what kind of code you are "
"writing now, Rust empowers you to reach farther, to program with confidence "
"in a wider variety of domains than you did before."
msgstr ""
"항상 명확하지는 않았지만, 러스트 프로그래밍 언어는 근본적으로 _역량 강화_에 관한 것입니다: "
"지금 어떤 종류의 코드를 작성하고 있든, 러스트는 여러분이 더 멀리 나아가고, "
"이전보다 더 다양한 영역에서 자신감을 가지고 프로그래밍할 수 있도록 힘을 실어줍니다."

#: src/foreword.md:8
msgid ""
"Take, for example, “systems-level” work that deals with low-level details of "
"memory management, data representation, and concurrency. Traditionally, this "
"realm of programming is seen as arcane, accessible only to a select few who "
"have devoted the necessary years learning to avoid its infamous pitfalls. "
"And even those who practice it do so with caution, lest their code be open "
"to exploits, crashes, or corruption."
msgstr "예를 들어, 메모리 관리, 데이터 표현, 동시성의 저수준 세부사항을 다루는 \"시스템 수준\" 작업을 생각해보세요. 전통적으로 이 프로그래밍 영역은 신비로운 것으로 여겨져, 악명 높은 함정들을 피하는 방법을 배우는 데 필요한 수년을 투자한 선택받은 소수만이 접근할 수 있다고 여겨졌습니다. 그리고 이를 실천하는 사람들조차도 자신의 코드가 익스플로잇, 크래시, 또는 손상에 노출되지 않도록 조심스럽게 작업합니다."

#: src/foreword.md:15
msgid ""
"Rust breaks down these barriers by eliminating the old pitfalls and "
"providing a friendly, polished set of tools to help you along the way. "
"Programmers who need to “dip down” into lower-level control can do so with "
"Rust, without taking on the customary risk of crashes or security holes, and "
"without having to learn the fine points of a fickle toolchain. Better yet, "
"the language is designed to guide you naturally towards reliable code that "
"is efficient in terms of speed and memory usage."
msgstr "러스트는 기존의 함정들을 제거하고 여러분을 도와줄 친근하고 세련된 도구 세트를 제공함으로써 이러한 장벽을 허뭅니다. 더 낮은 수준의 제어로 \"내려가야\" 하는 프로그래머들은 러스트를 사용하여 관례적인 크래시나 보안 홀의 위험을 감수하지 않고도, 그리고 변덕스러운 툴체인의 세부사항을 배울 필요 없이도 그렇게 할 수 있습니다. 더 나아가, 이 언어는 속도와 메모리 사용량 측면에서 효율적인 신뢰할 수 있는 코드로 자연스럽게 안내하도록 설계되었습니다."

#: src/foreword.md:23
msgid ""
"Programmers who are already working with low-level code can use Rust to "
"raise their ambitions. For example, introducing parallelism in Rust is a "
"relatively low-risk operation: the compiler will catch the classical "
"mistakes for you. And you can tackle more aggressive optimizations in your "
"code with the confidence that you won’t accidentally introduce crashes or "
"vulnerabilities."
msgstr ""
"이미 저수준 코드로 작업하고 프로그래머들은 러스트를 사용하여 자신의 야망을 높일 수 있습니다. "
"예를 들어, 러스트에서 병렬성을 도입하는 것은 상대적으로 위험이 낮은 작업입니다: "
"컴파일러가 고전적인 실수들을 잡아줄 것입니다. 그리고 여러분은 실수로 크래시나 "
"취약점을 도입하지 않을 것이라는 확신을 가지고 코드에서 더 공격적인 최적화를 다룰 수 있습니다."

#: src/foreword.md:29
msgid ""
"But Rust isn’t limited to low-level systems programming. It’s expressive and "
"ergonomic enough to make CLI apps, web servers, and many other kinds of code "
"quite pleasant to write — you’ll find simple examples of both later in the "
"book. Working with Rust allows you to build skills that transfer from one "
"domain to another; you can learn Rust by writing a web app, then apply those "
"same skills to target your Raspberry Pi."
msgstr "하지만 러스트는 저수준 시스템 프로그래밍에만 국한되지 않습니다. CLI 앱, 웹 서버, 그리고 다른 많은 종류의 코드를 작성하기에 충분히 표현력이 풍부하고 인체공학적입니다 — 책의 뒷부분에서 둘 다의 간단한 예제를 찾을 수 있을 것입니다. 러스트로 작업하면 한 영역에서 다른 영역으로 전이되는 기술을 구축할 수 있습니다; 웹 앱을 작성하여 러스트를 배운 다음, 동일한 기술을 적용하여 라즈베리 파이를 대상으로 할 수 있습니다."

#: src/foreword.md:36
msgid ""
"This book fully embraces the potential of Rust to empower its users. It’s a "
"friendly and approachable text intended to help you level up not just your "
"knowledge of Rust, but also your reach and confidence as a programmer in "
"general. So dive in, get ready to learn—and welcome to the Rust community!"
msgstr "이 책은 사용자들에게 힘을 실어주는 러스트의 잠재력을 완전히 받아들입니다. 이것은 러스트에 대한 지식뿐만 아니라 일반적으로 프로그래머로서의 여러분의 영향력과 자신감을 향상시키는 데 도움을 주기 위한 친근하고 접근하기 쉬운 텍스트입니다. 그러니 뛰어들어 배울 준비를 하세요—그리고 러스트 커뮤니티에 오신 것을 환영합니다!"

#: src/foreword.md:41
msgid "— Nicholas Matsakis and Aaron Turon"
msgstr "— Nicholas Matsakis와 Aaron Turon"

#: src/ch00-00-introduction.md:1
msgid "Introduction"
msgstr "소개"

#: src/ch00-00-introduction.md:3
msgid ""
"Note: This edition of the book is the same as [The Rust Programming Language]"
"(https://nostarch.com/rust-programming-language-2nd-edition) available in "
"print and ebook format from [No Starch Press](https://nostarch.com/)."
msgstr "참고: 이 책의 에디션은 [No Starch Press](https://nostarch.com/)에서 인쇄본과 전자책 형식으로 제공되는 [The Rust Programming Language](https://nostarch.com/rust-programming-language-2nd-edition)과 동일합니다."

#: src/ch00-00-introduction.md:10
msgid ""
"Welcome to _The Rust Programming Language_, an introductory book about Rust. "
"The Rust programming language helps you write faster, more reliable "
"software. High-level ergonomics and low-level control are often at odds in "
"programming language design; Rust challenges that conflict. Through "
"balancing powerful technical capacity and a great developer experience, Rust "
"gives you the option to control low-level details (such as memory usage) "
"without all the hassle traditionally associated with such control."
msgstr "_러스트 프로그래밍 언어_에 오신 것을 환영합니다. 러스트에 대한 입문서입니다. 러스트 프로그래밍 언어는 더 빠르고 더 신뢰할 수 있는 소프트웨어를 작성하는 데 도움을 줍니다. 고수준 인체공학과 저수준 제어는 프로그래밍 언어 설계에서 종종 상충됩니다. 러스트는 그 갈등에 도전합니다. 강력한 기술적 역량과 훌륭한 개발자 경험의 균형을 통해, 러스트는 전통적으로 그러한 제어와 관련된 모든 번거로움 없이 저수준 세부사항(예: 메모리 사용량)을 제어할 수 있는 옵션을 제공합니다."

#: src/ch00-00-introduction.md:18
msgid "Who Rust Is For"
msgstr "러스트는 누구를 위한 것인가"

#: src/ch00-00-introduction.md:20
msgid ""
"Rust is ideal for many people for a variety of reasons. Let’s look at a few "
"of the most important groups."
msgstr ""
"러스트는 다양한 이유로 많은 사람들에게 이상적입니다. "
"가장 중요한 몇 가지 그룹을 살펴보겠습니다."

#: src/ch00-00-introduction.md:23
msgid "Teams of Developers"
msgstr "개발자 팀"

#: src/ch00-00-introduction.md:25
msgid ""
"Rust is proving to be a productive tool for collaborating among large teams "
"of developers with varying levels of systems programming knowledge. Low-"
"level code is prone to various subtle bugs, which in most other languages "
"can be caught only through extensive testing and careful code review by "
"experienced developers. In Rust, the compiler plays a gatekeeper role by "
"refusing to compile code with these elusive bugs, including concurrency "
"bugs. By working alongside the compiler, the team can spend their time "
"focusing on the program’s logic rather than chasing down bugs."
msgstr ""
"러스트는 다양한 수준의 시스템 프로그래밍 지식을 가진 대규모 개발자 팀 간의 "
"협업을 위한 생산적인 도구임이 입증되고 있습니다. 저수준 코드는 다양한 미묘한 버그에 취약하며, "
"대부분의 다른 언어에서는 광범위한 테스트와 경험 있는 개발자의 신중한 코드 리뷰를 통해서만 "
"잡을 수 있습니다. 러스트에서는 컴파일러가 동시성 버그를 포함하여 이러한 파악하기 어려운 버그가 있는 "
"코드의 컴파일을 거부함으로써 문지기 역할을 합니다. 컴파일러와 함께 작업함으로써, "
"팀은 버그를 쫓아다니는 대신 프로그램의 로직에 집중하는 데 시간을 보낼 수 있습니다."

#: src/ch00-00-introduction.md:34
msgid ""
"Rust also brings contemporary developer tools to the systems programming "
"world:"
msgstr "러스트는 또한 현대적인 개발자 도구를 시스템 프로그래밍 세계에 가져옵니다:"

#: src/ch00-00-introduction.md:36
msgid ""
"Cargo, the included dependency manager and build tool, makes adding, "
"compiling, and managing dependencies painless and consistent across the Rust "
"ecosystem."
msgstr ""
"포함된 의존성 관리자이자 빌드 도구인 Cargo는 러스트 생태계 전반에 걸쳐 "
"의존성을 추가하고, 컴파일하고, 관리하는 것을 고통 없고 일관되게 만듭니다."

#: src/ch00-00-introduction.md:39
msgid ""
"The Rustfmt formatting tool ensures a consistent coding style across "
"developers."
msgstr ""
"Rustfmt 포맷팅 도구는 개발자들 간에 일관된 코딩 스타일을 보장합니다."

#: src/ch00-00-introduction.md:41
msgid ""
"The rust-analyzer powers Integrated Development Environment (IDE) "
"integration for code completion and inline error messages."
msgstr "rust-analyzer는 코드 완성과 인라인 에러 메시지를 위한 통합 개발 환경(IDE) 통합을 지원합니다."

#: src/ch00-00-introduction.md:44
msgid ""
"By using these and other tools in the Rust ecosystem, developers can be "
"productive while writing systems-level code."
msgstr "러스트 생태계의 이러한 도구들과 다른 도구들을 사용함으로써, 개발자들은 시스템 수준 코드를 작성하면서도 생산적일 수 있습니다."

#: src/ch00-00-introduction.md:47
msgid "Students"
msgstr "학생들"

#: src/ch00-00-introduction.md:49
msgid ""
"Rust is for students and those who are interested in learning about systems "
"concepts. Using Rust, many people have learned about topics like operating "
"systems development. The community is very welcoming and happy to answer "
"student questions. Through efforts such as this book, the Rust teams want to "
"make systems concepts more accessible to more people, especially those new "
"to programming."
msgstr "러스트는 학생들과 시스템 개념에 대해 배우는 데 관심이 있는 사람들을 위한 것입니다. 러스트를 사용하여 많은 사람들이 운영 체제 개발과 같은 주제에 대해 배웠습니다. 커뮤니티는 매우 환영하며 학생들의 질문에 기꺼이 답변합니다. 이 책과 같은 노력을 통해, 러스트 팀은 시스템 개념을 더 많은 사람들에게, 특히 프로그래밍을 처음 접하는 사람들에게 더 접근하기 쉽게 만들고자 합니다."

#: src/ch00-00-introduction.md:56
msgid "Companies"
msgstr "기업들"

#: src/ch00-00-introduction.md:58
msgid ""
"Hundreds of companies, large and small, use Rust in production for a variety "
"of tasks, including command line tools, web services, DevOps tooling, "
"embedded devices, audio and video analysis and transcoding, "
"cryptocurrencies, bioinformatics, search engines, Internet of Things "
"applications, machine learning, and even major parts of the Firefox web "
"browser."
msgstr "크고 작은 수백 개의 기업들이 명령줄 도구, 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석과 트랜스코딩, 암호화폐, 생물정보학, 검색 엔진, 사물 인터넷 애플리케이션, 머신 러닝, 그리고 Firefox 웹 브라우저의 주요 부분까지 포함하여 다양한 작업을 위해 프로덕션에서 러스트를 사용합니다."

#: src/ch00-00-introduction.md:64
msgid "Open Source Developers"
msgstr "오픈 소스 개발자들"

#: src/ch00-00-introduction.md:66
msgid ""
"Rust is for people who want to build the Rust programming language, "
"community, developer tools, and libraries. We’d love to have you contribute "
"to the Rust language."
msgstr ""
"러스트는 러스트 프로그래밍 언어, 커뮤니티, 개발자 도구, 라이브러리를 구축하고자 하는 사람들을 위한 것입니다. "
"여러분이 러스트 언어에 기여해주시면 좋겠습니다."

#: src/ch00-00-introduction.md:70
msgid "People Who Value Speed and Stability"
msgstr "속도와 안정성을 중시하는 사람들"

#: src/ch00-00-introduction.md:72
msgid ""
"Rust is for people who crave speed and stability in a language. By speed, we "
"mean both how quickly Rust code can run and the speed at which Rust lets you "
"write programs. The Rust compiler’s checks ensure stability through feature "
"additions and refactoring. This is in contrast to the brittle legacy code in "
"languages without these checks, which developers are often afraid to modify. "
"By striving for zero-cost abstractions—higher-level features that compile to "
"lower-level code as fast as code written manually—Rust endeavors to make "
"safe code be fast code as well."
msgstr "러스트는 언어에서 속도와 안정성을 갈망하는 사람들을 위한 것입니다. 속도란 러스트 코드가 얼마나 빠르게 실행되는지와 러스트가 프로그램을 작성할 수 있게 해주는 속도를 모두 의미합니다. 러스트 컴파일러의 검사는 기능 추가와 리팩터링을 통해 안정성을 보장합니다. 이는 이러한 검사가 없는 언어의 취약한 레거시 코드와 대조적이며, 개발자들은 종종 이를 수정하기를 두려워합니다. 제로 코스트 추상화—수동으로 작성한 코드만큼 빠른 저수준 코드로 컴파일되는 고수준 기능—를 추구함으로써, 러스트는 안전한 코드가 빠른 코드이기도 하도록 노력합니다."

#: src/ch00-00-introduction.md:81
msgid ""
"The Rust language hopes to support many other users as well; those mentioned "
"here are merely some of the biggest stakeholders. Overall, Rust’s greatest "
"ambition is to eliminate the trade-offs that programmers have accepted for "
"decades by providing safety _and_ productivity, speed _and_ ergonomics. Give "
"Rust a try and see if its choices work for you."
msgstr "러스트 언어는 다른 많은 사용자들도 지원하기를 희망합니다. 여기서 언급된 것들은 단지 가장 큰 이해관계자들 중 일부일 뿐입니다. 전반적으로, 러스트의 가장 큰 야망은 안전성 _그리고_ 생산성, 속도 _그리고_ 인체공학을 제공함으로써 프로그래머들이 수십 년 동안 받아들여온 트레이드오프를 제거하는 것입니다. 러스트를 시도해보고 그 선택이 여러분에게 맞는지 확인해보세요."

#: src/ch00-00-introduction.md:87
msgid "Who This Book Is For"
msgstr "이 책은 누구를 위한 것인가"

#: src/ch00-00-introduction.md:89
msgid ""
"This book assumes that you’ve written code in another programming language "
"but doesn’t make any assumptions about which one. We’ve tried to make the "
"material broadly accessible to those from a wide variety of programming "
"backgrounds. We don’t spend a lot of time talking about what programming "
"_is_ or how to think about it. If you’re entirely new to programming, you "
"would be better served by reading a book that specifically provides an "
"introduction to programming."
msgstr "이 책은 여러분이 다른 프로그래밍 언어로 코드를 작성해본 경험이 있다고 가정하지만 어떤 언어인지에 대해서는 가정하지 않습니다. 우리는 다양한 프로그래밍 배경을 가진 사람들이 폭넓게 접근할 수 있도록 자료를 만들려고 노력했습니다. 프로그래밍이 _무엇인지_ 또는 그것에 대해 어떻게 생각해야 하는지에 대해 많은 시간을 할애하지 않습니다. 프로그래밍을 완전히 처음 접한다면, 프로그래밍에 대한 입문을 구체적으로 제공하는 책을 읽는 것이 더 도움이 될 것입니다."

#: src/ch00-00-introduction.md:96
msgid "How to Use This Book"
msgstr "이 책을 사용하는 방법"

#: src/ch00-00-introduction.md:98
msgid ""
"In general, this book assumes that you’re reading it in sequence from front "
"to back. Later chapters build on concepts in earlier chapters, and earlier "
"chapters might not delve into details on a particular topic but will revisit "
"the topic in a later chapter."
msgstr "일반적으로, 이 책은 여러분이 앞에서부터 뒤로 순서대로 읽는다고 가정합니다. 후반 장들은 앞선 장들의 개념을 기반으로 하며, 앞선 장들은 특정 주제에 대한 세부사항을 깊이 다루지 않을 수 있지만 후반 장에서 그 주제를 다시 다룰 것입니다."

#: src/ch00-00-introduction.md:103
msgid ""
"You’ll find two kinds of chapters in this book: concept chapters and project "
"chapters. In concept chapters, you’ll learn about an aspect of Rust. In "
"project chapters, we’ll build small programs together, applying what you’ve "
"learned so far. Chapters 2, 12, and 21 are project chapters; the rest are "
"concept chapters."
msgstr "이 책에서는 두 가지 종류의 장을 찾을 수 있습니다: 개념 장과 프로젝트 장입니다. 개념 장에서는 러스트의 한 측면에 대해 배우게 됩니다. 프로젝트 장에서는 지금까지 배운 것을 적용하여 함께 작은 프로그램을 만들어볼 것입니다. 2장, 12장, 21장이 프로젝트 장이고, 나머지는 개념 장입니다."

#: src/ch00-00-introduction.md:108
msgid ""
"Chapter 1 explains how to install Rust, how to write a “Hello, world!” "
"program, and how to use Cargo, Rust’s package manager and build tool. "
"Chapter 2 is a hands-on introduction to writing a program in Rust, having "
"you build up a number guessing game. Here we cover concepts at a high level, "
"and later chapters will provide additional detail. If you want to get your "
"hands dirty right away, Chapter 2 is the place for that. Chapter 3 covers "
"Rust features that are similar to those of other programming languages, and "
"in Chapter 4 you’ll learn about Rust’s ownership system. If you’re a "
"particularly meticulous learner who prefers to learn every detail before "
"moving on to the next, you might want to skip Chapter 2 and go straight to "
"Chapter 3, returning to Chapter 2 when you’d like to work on a project "
"applying the details you’ve learned."
msgstr ""
"1장은 러스트를 설치하는 방법, \"Hello, world!\" 프로그램을 작성하는 방법, "
"그리고 러스트의 패키지 관리자이자 빌드 도구인 Cargo를 사용하는 방법을 설명합니다. "
"2장은 러스트로 프로그램을 작성하는 실습 입문으로, 숫자 맞추기 게임을 만들어봅니다. "
"여기서는 개념을 높은 수준에서 다루며, 후반 장에서 추가적인 세부사항을 제공할 것입니다. "
"바로 실습을 해보고 싶다면, 2장이 그 장소입니다. 3장은 다른 프로그래밍 언어와 "
"유사한 러스트 기능들을 다루고, 4장에서는 러스트의 소유권 시스템에 대해 배우게 됩니다. "
"다음으로 넘어가기 전에 모든 세부사항을 배우는 것을 선호하는 특히 꼼꼼한 학습자라면, "
"2장을 건너뛰고 바로 3장으로 가서, 배운 세부사항을 적용하는 프로젝트를 작업하고 싶을 때 "
"2장으로 돌아오는 것이 좋을 수도 있습니다."

#: src/ch00-00-introduction.md:120
msgid ""
"Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match` "
"expressions, and the `if let` control flow construct. You’ll use structs and "
"enums to make custom types in Rust."
msgstr ""
"5장은 구조체와 메서드를 다루고, 6장은 열거형, `match` 표현식, "
"그리고 `if let` 제어 흐름 구조를 다룹니다. 러스트에서 커스텀 타입을 만들기 위해 "
"구조체와 열거형을 사용하게 될 것입니다."

#: src/ch00-00-introduction.md:124
msgid ""
"In Chapter 7, you’ll learn about Rust’s module system and about privacy "
"rules for organizing your code and its public Application Programming "
"Interface (API). Chapter 8 discusses some common collection data structures "
"that the standard library provides, such as vectors, strings, and hash maps. "
"Chapter 9 explores Rust’s error-handling philosophy and techniques."
msgstr ""
"7장에서는 러스트의 모듈 시스템과 코드와 공개 애플리케이션 프로그래밍 인터페이스(API)를 "
"구성하기 위한 프라이버시 규칙에 대해 배우게 됩니다. 8장은 벡터, 문자열, 해시 맵과 같이 "
"표준 라이브러리가 제공하는 일반적인 컬렉션 데이터 구조들을 다룹니다. "
"9장은 러스트의 에러 처리 철학과 기법들을 탐구합니다."

#: src/ch00-00-introduction.md:130
msgid ""
"Chapter 10 digs into generics, traits, and lifetimes, which give you the "
"power to define code that applies to multiple types. Chapter 11 is all about "
"testing, which even with Rust’s safety guarantees is necessary to ensure "
"your program’s logic is correct. In Chapter 12, we’ll build our own "
"implementation of a subset of functionality from the `grep` command line "
"tool that searches for text within files. For this, we’ll use many of the "
"concepts we discussed in the previous chapters."
msgstr "10장은 여러 타입에 적용되는 코드를 정의할 수 있는 기능을 제공하는 제네릭, 트레이트, 라이프타임을 깊이 다룹니다. 11장은 러스트의 안전성 보장에도 불구하고 프로그램의 로직이 올바른지 확인하기 위해 필요한 테스팅에 관한 모든 것입니다. 12장에서는 파일 내에서 텍스트를 검색하는 `grep` 명령줄 도구의 기능 일부를 우리만의 구현으로 만들어볼 것입니다. 이를 위해 이전 장들에서 논의한 많은 개념들을 사용할 것입니다."

#: src/ch00-00-introduction.md:138
msgid ""
"Chapter 13 explores closures and iterators: features of Rust that come from "
"functional programming languages. In Chapter 14, we’ll examine Cargo in more "
"depth and talk about best practices for sharing your libraries with others. "
"Chapter 15 discusses smart pointers that the standard library provides and "
"the traits that enable their functionality."
msgstr "13장은 함수형 프로그래밍 언어에서 파생된 러스트의 기능인 클로저와 반복자를 탐구합니다. 14장에서는 Cargo를 더 깊이 살펴보고 다른 사람들과 라이브러리를 공유하기 위한 모범 사례에 대해 이야기할 것입니다. 15장에서는 표준 라이브러리가 제공하는 스마트 포인터와 그 기능을 가능하게 하는 트레이트를 논의합니다."

#: src/ch00-00-introduction.md:144
msgid ""
"In Chapter 16, we’ll walk through different models of concurrent programming "
"and talk about how Rust helps you to program in multiple threads fearlessly. "
"In Chapter 17, we will build on that by exploring Rust’s async and await "
"syntax and the lightweight concurrency model they support."
msgstr ""
"16장에서는 동시 프로그래밍의 다양한 모델을 살펴보고 러스트가 어떻게 "
"여러 스레드에서 두려움 없이 프로그래밍할 수 있도록 도와주는지 이야기합니다. "
"17장에서는 러스트의 async와 await 문법과 그들이 지원하는 경량 동시성 모델을 "
"탐구함으로써 그것을 기반으로 구축할 것입니다."

#: src/ch00-00-introduction.md:149
msgid ""
"Chapter 18 looks at how Rust idioms compare to object-oriented programming "
"principles you might be familiar with."
msgstr "18장에서는 러스트 관용구가 여러분이 익숙할 수 있는 객체지향 프로그래밍 원칙과 어떻게 비교되는지 살펴봅니다."

#: src/ch00-00-introduction.md:152
msgid ""
"Chapter 19 is a reference on patterns and pattern matching, which are "
"powerful ways of expressing ideas throughout Rust programs. Chapter 20 "
"contains a smorgasbord of advanced topics of interest, including unsafe "
"Rust, macros, and more about lifetimes, traits, types, functions, and "
"closures."
msgstr "19장은 러스트 프로그램 전반에 걸쳐 아이디어를 표현하는 강력한 방법인 패턴과 패턴 매칭에 대한 참조입니다. 20장은 안전하지 않은 러스트, 매크로, 그리고 라이프타임, 트레이트, 타입, 함수, 클로저에 대한 더 많은 내용을 포함하여 흥미로운 고급 주제들을 다양하게 다룹니다."

#: src/ch00-00-introduction.md:157
msgid ""
"In Chapter 21, we’ll complete a project in which we’ll implement a low-level "
"multithreaded web server!"
msgstr "21장에서는 저수준 멀티스레드 웹 서버를 구현하는 프로젝트를 완료할 것입니다!"

#: src/ch00-00-introduction.md:160
msgid ""
"Finally, some appendixes contain useful information about the language in a "
"more reference-like format. **Appendix A** covers Rust’s keywords, "
"**Appendix B** covers Rust’s operators and symbols, **Appendix C** covers "
"derivable traits provided by the standard library, **Appendix D** covers "
"some useful development tools, and **Appendix E** explains Rust editions. In "
"**Appendix F**, you can find translations of the book, and in **Appendix G** "
"we’ll cover how Rust is made and what nightly Rust is."
msgstr "마지막으로, 일부 부록에는 언어에 대한 유용한 정보가 더 참조 형식으로 포함되어 있습니다. **부록 A**는 러스트의 키워드를 다루고, **부록 B**는 러스트의 연산자와 기호를 다루며, **부록 C**는 표준 라이브러리에서 제공하는 파생 가능한 트레이트를 다루고, **부록 D**는 몇 가지 유용한 개발 도구를 다루며, **부록 E**는 러스트 에디션을 설명합니다. **부록 F**에서는 책의 번역본을 찾을 수 있으며, **부록 G**에서는 러스트가 어떻게 만들어지는지와 나이틀리 러스트가 무엇인지 다룰 것입니다."

#: src/ch00-00-introduction.md:172
msgid "<span id=\"ferris\"></span>"
msgstr "<span id=\"ferris\"></span>"

#: src/ch00-00-introduction.md:174
msgid ""
"An important part of the process of learning Rust is learning how to read "
"the error messages the compiler displays: these will guide you toward "
"working code. As such, we’ll provide many examples that don’t compile along "
"with the error message the compiler will show you in each situation. Know "
"that if you enter and run a random example, it may not compile! Make sure "
"you read the surrounding text to see whether the example you’re trying to "
"run is meant to error. Ferris will also help you distinguish code that isn’t "
"meant to work:"
msgstr "러스트를 배우는 과정에서 중요한 부분은 컴파일러가 표시하는 오류 메시지를 읽는 방법을 배우는 것입니다. 이 메시지는 작동하는 코드를 향해 여러분을 안내할 것입니다. 따라서 컴파일러가 각 상황에서 보여줄 오류 메시지와 함께 컴파일되지 않는 많은 예제를 제공할 것입니다. 무작위 예제를 입력하고 실행하면 컴파일되지 않을 수 있다는 점을 알아두세요! 실행하려는 예제가 오류를 발생시키도록 의도된 것인지 확인하려면 주변 텍스트를 읽으십시오. 페리스는 또한 작동하도록 의도되지 않은 코드를 구별하는 데 도움을 줄 것입니다:"

#: src/ch00-00-introduction.md:182
msgid "Ferris"
msgstr "페리스"

#: src/ch00-00-introduction.md:182
msgid "Meaning"
msgstr "의미"

#: src/ch00-00-introduction.md:184
msgid ""
"<img src=\"img/ferris/does_not_compile.svg\" class=\"ferris-explain\" "
"alt=\"Ferris with a question mark\"/>"
msgstr ""
"<img src=\"img/ferris/does_not_compile.svg\" class=\"ferris-explain\" "
"alt=\"물음표가 있는 Ferris\"/>"

#: src/ch00-00-introduction.md:184
msgid "This code does not compile!"
msgstr "이 코드는 컴파일되지 않습니다!"

#: src/ch00-00-introduction.md:185
msgid ""
"<img src=\"img/ferris/panics.svg\" class=\"ferris-explain\" alt=\"Ferris "
"throwing up their hands\"/>"
msgstr ""
"<img src=\"img/ferris/panics.svg\" class=\"ferris-explain\" alt=\"손을 "
"들어올리는 Ferris\"/>"

#: src/ch00-00-introduction.md:185
msgid "This code panics!"
msgstr "이 코드는 패닉을 일으킵니다!"

#: src/ch00-00-introduction.md:186
msgid ""
"<img src=\"img/ferris/not_desired_behavior.svg\" class=\"ferris-explain\" "
"alt=\"Ferris with one claw up, shrugging\"/>"
msgstr "<img src=\"img/ferris/not_desired_behavior.svg\" class=\"ferris-explain\" alt=\"한 발톱을 들고 어깨를 으쓱하는 Ferris\"/>"

#: src/ch00-00-introduction.md:186
msgid "This code does not produce the desired behavior."
msgstr "이 코드는 원하는 동작을 생성하지 않습니다."

#: src/ch00-00-introduction.md:188
msgid ""
"In most situations, we’ll lead you to the correct version of any code that "
"doesn’t compile."
msgstr "대부분의 상황에서 컴파일되지 않는 코드의 올바른 버전으로 안내할 것입니다."

#: src/ch00-00-introduction.md:191
msgid "Source Code"
msgstr "소스 코드"

#: src/ch00-00-introduction.md:193
msgid ""
"The source files from which this book is generated can be found on [GitHub]"
"(https://github.com/rust-lang/book/tree/main/src)."
msgstr ""
"이 책이 생성되는 소스 파일들은 [GitHub]"
"(https://github.com/rust-lang/book/tree/main/src)에서 찾을 수 있습니다."

#: src/ch01-00-getting-started.md:3
msgid ""
"Let’s start your Rust journey! There’s a lot to learn, but every journey "
"starts somewhere. In this chapter, we’ll discuss:"
msgstr ""
"러스트 여정을 시작해봅시다! 배울 것이 많지만, 모든 여정은 어딘가에서 시작됩니다. "
"이 장에서는 다음을 다룰 것입니다:"

#: src/ch01-00-getting-started.md:6
msgid "Installing Rust on Linux, macOS, and Windows"
msgstr "Linux, macOS, Windows에서 러스트 설치하기"

#: src/ch01-00-getting-started.md:7
msgid "Writing a program that prints `Hello, world!`"
msgstr "`Hello, world!`를 출력하는 프로그램 작성하기"

#: src/ch01-00-getting-started.md:8
msgid "Using `cargo`, Rust’s package manager and build system"
msgstr "러스트의 패키지 관리자이자 빌드 시스템인 `cargo` 사용하기"

#: src/ch01-01-installation.md:3
msgid ""
"The first step is to install Rust. We’ll download Rust through `rustup`, a "
"command line tool for managing Rust versions and associated tools. You’ll "
"need an internet connection for the download."
msgstr ""
"첫 번째 단계는 러스트를 설치하는 것입니다. 러스트 버전과 관련 도구를 관리하는 "
"명령줄 도구인 `rustup`을 통해 러스트를 다운로드할 것입니다. "
"다운로드를 위해 인터넷 연결이 필요합니다."

#: src/ch01-01-installation.md:7
msgid ""
"Note: If you prefer not to use `rustup` for some reason, please see the "
"[Other Rust Installation Methods page](https://forge.rust-lang.org/infra/"
"other-installation-methods.html) for more options."
msgstr ""
"참고: 어떤 이유로 `rustup`을 사용하고 싶지 않다면, "
"더 많은 옵션을 위해 [다른 러스트 설치 방법 페이지](https://forge.rust-lang.org/infra/"
"other-installation-methods.html)를 참조하세요."

#: src/ch01-01-installation.md:10
msgid ""
"The following steps install the latest stable version of the Rust compiler. "
"Rust’s stability guarantees ensure that all the examples in the book that "
"compile will continue to compile with newer Rust versions. The output might "
"differ slightly between versions because Rust often improves error messages "
"and warnings. In other words, any newer, stable version of Rust you install "
"using these steps should work as expected with the content of this book."
msgstr "다음 단계는 러스트 컴파일러의 최신 안정 버전을 설치합니다. 러스트의 안정성 보장은 책의 모든 예제가 컴파일되면 더 새로운 러스트 버전에서도 계속 컴파일될 것임을 보장합니다. 러스트는 종종 오류 메시지와 경고를 개선하기 때문에 버전 간에 출력이 약간 다를 수 있습니다. 즉, 이 단계를 사용하여 설치하는 모든 최신 안정 러스트 버전은 이 책의 내용과 예상대로 작동해야 합니다."

#: src/ch01-01-installation.md:17
msgid "Command Line Notation"
msgstr "명령줄 표기법"

#: src/ch01-01-installation.md:19
msgid ""
"In this chapter and throughout the book, we’ll show some commands used in "
"the terminal. Lines that you should enter in a terminal all start with `$`. "
"You don’t need to type the `$` character; it’s the command line prompt shown "
"to indicate the start of each command. Lines that don’t start with `$` "
"typically show the output of the previous command. Additionally, PowerShell-"
"specific examples will use `>` rather than `$`."
msgstr "이 장과 책 전체에서 터미널에서 사용되는 몇 가지 명령을 보여줄 것입니다. 터미널에 입력해야 하는 줄은 모두 `$`로 시작합니다. `$` 문자를 입력할 필요는 없습니다. 각 명령의 시작을 나타내는 명령줄 프롬프트입니다. `$`로 시작하지 않는 줄은 일반적으로 이전 명령의 출력을 보여줍니다. 또한 PowerShell 특정 예제는 `$` 대신 `>`를 사용합니다."

#: src/ch01-01-installation.md:26
msgid "Installing `rustup` on Linux or macOS"
msgstr "Linux 또는 macOS에서 `rustup` 설치하기"

#: src/ch01-01-installation.md:28
msgid ""
"If you’re using Linux or macOS, open a terminal and enter the following "
"command:"
msgstr "Linux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력하세요:"

#: src/ch01-01-installation.md:30
msgid ""
"```console\n"
"$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n"
"```"
msgstr "```console\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```"

#: src/ch01-01-installation.md:34
msgid ""
"The command downloads a script and starts the installation of the `rustup` "
"tool, which installs the latest stable version of Rust. You might be "
"prompted for your password. If the install is successful, the following line "
"will appear:"
msgstr ""
"이 명령은 스크립트를 다운로드하고 러스트의 최신 안정 버전을 설치하는 "
"`rustup` 도구의 설치를 시작합니다. 비밀번호를 입력하라는 메시지가 나타날 수 있습니다. "
"설치가 성공하면 다음 줄이 나타날 것입니다:"

#: src/ch01-01-installation.md:42
msgid ""
"You will also need a _linker_, which is a program that Rust uses to join its "
"compiled outputs into one file. It is likely you already have one. If you "
"get linker errors, you should install a C compiler, which will typically "
"include a linker. A C compiler is also useful because some common Rust "
"packages depend on C code and will need a C compiler."
msgstr ""
"또한 러스트가 컴파일된 출력을 하나의 파일로 결합하는 데 사용하는 프로그램인 "
"_링커_가 필요합니다. 이미 하나를 가지고 있을 가능성이 높습니다. 링커 에러가 발생하면 "
"일반적으로 링커를 포함하는 C 컴파일러를 설치해야 합니다. 일부 일반적인 러스트 "
"패키지가 C 코드에 의존하고 C 컴파일러가 필요하기 때문에 C 컴파일러도 유용합니다."

#: src/ch01-01-installation.md:48
msgid "On macOS, you can get a C compiler by running:"
msgstr "macOS에서는 다음을 실행하여 C 컴파일러를 얻을 수 있습니다:"

#: src/ch01-01-installation.md:54
msgid ""
"Linux users should generally install GCC or Clang, according to their "
"distribution’s documentation. For example, if you use Ubuntu, you can "
"install the `build-essential` package."
msgstr "Linux 사용자는 일반적으로 배포판 문서에 따라 GCC 또는 Clang을 설치해야 합니다. 예를 들어 Ubuntu를 사용하는 경우 `build-essential` 패키지를 설치할 수 있습니다."

#: src/ch01-01-installation.md:58
msgid "Installing `rustup` on Windows"
msgstr "Windows에서 `rustup` 설치하기"

#: src/ch01-01-installation.md:60
msgid ""
"On Windows, go to [https://www.rust-lang.org/tools/install](https://www.rust-"
"lang.org/tools/install) and follow the instructions for installing Rust. At "
"some point in the installation, you’ll be prompted to install Visual Studio. "
"This provides a linker and the native libraries needed to compile programs. "
"If you need more help with this step, see [https://rust-lang.github.io/"
"rustup/installation/windows-msvc.html](https://rust-lang.github.io/rustup/"
"installation/windows-msvc.html)"
msgstr "Windows에서는 [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)로 이동하여 Rust 설치 지침을 따르세요. 설치 과정 중 어느 시점에서 Visual Studio를 설치하라는 메시지가 나타날 것입니다. 이는 프로그램을 컴파일하는 데 필요한 링커와 네이티브 라이브러리를 제공합니다. 이 단계에 대한 추가 도움이 필요하면 [https://rust-lang.github.io/rustup/installation/windows-msvc.html](https://rust-lang.github.io/rustup/installation/windows-msvc.html)을 참조하세요."

#: src/ch01-01-installation.md:66
msgid ""
"The rest of this book uses commands that work in both _cmd.exe_ and "
"PowerShell. If there are specific differences, we’ll explain which to use."
msgstr "이 책의 나머지 부분에서는 _cmd.exe_와 PowerShell 모두에서 작동하는 명령을 사용합니다. 특정 차이점이 있는 경우 어떤 것을 사용해야 하는지 설명할 것입니다."

#: src/ch01-01-installation.md:69
msgid "Troubleshooting"
msgstr "문제 해결"

#: src/ch01-01-installation.md:71
msgid ""
"To check whether you have Rust installed correctly, open a shell and enter "
"this line:"
msgstr "Rust가 올바르게 설치되었는지 확인하려면 셸을 열고 다음 줄을 입력하세요:"

#: src/ch01-01-installation.md:78
msgid ""
"You should see the version number, commit hash, and commit date for the "
"latest stable version that has been released, in the following format:"
msgstr "릴리스된 최신 안정 버전의 버전 번호, 커밋 해시 및 커밋 날짜가 다음 형식으로 표시되어야 합니다:"

#: src/ch01-01-installation.md:85
msgid ""
"If you see this information, you have installed Rust successfully! If you "
"don’t see this information, check that Rust is in your `%PATH%` system "
"variable as follows."
msgstr "이 정보가 표시되면 Rust가 성공적으로 설치된 것입니다! 이 정보가 표시되지 않으면 다음과 같이 Rust가 `%PATH%` 시스템 변수에 있는지 확인하세요."

#: src/ch01-01-installation.md:89
msgid "In Windows CMD, use:"
msgstr "Windows CMD에서는 다음을 사용하세요:"

#: src/ch01-01-installation.md:95
msgid "In PowerShell, use:"
msgstr "PowerShell에서는 다음을 사용하세요:"

#: src/ch01-01-installation.md:101
msgid "In Linux and macOS, use:"
msgstr "Linux와 macOS에서는 다음을 사용하세요:"

#: src/ch01-01-installation.md:107
msgid ""
"If that’s all correct and Rust still isn’t working, there are a number of "
"places you can get help. Find out how to get in touch with other Rustaceans "
"(a silly nickname we call ourselves) on [the community page](https://"
"www.rust-lang.org/community)."
msgstr "모든 것이 올바른데도 Rust가 여전히 작동하지 않는다면 도움을 받을 수 있는 여러 곳이 있습니다. [커뮤니티 페이지](https://www.rust-lang.org/community)에서 다른 Rustaceans(우리가 스스로를 부르는 우스꽝스러운 별명)와 연락하는 방법을 알아보세요."

#: src/ch01-01-installation.md:111
msgid "Updating and Uninstalling"
msgstr "업데이트와 제거"

#: src/ch01-01-installation.md:113
msgid ""
"Once Rust is installed via `rustup`, updating to a newly released version is "
"easy. From your shell, run the following update script:"
msgstr "`rustup`을 통해 Rust가 설치되면 새로 릴리스된 버전으로 업데이트하는 것은 쉽습니다. 셸에서 다음 업데이트 스크립트를 실행하세요:"

#: src/ch01-01-installation.md:120
msgid ""
"To uninstall Rust and `rustup`, run the following uninstall script from your "
"shell:"
msgstr "Rust와 `rustup`을 제거하려면 셸에서 다음 제거 스크립트를 실행하세요:"

#: src/ch01-01-installation.md:127
msgid "Local Documentation"
msgstr "로컬 문서"

#: src/ch01-01-installation.md:129
msgid ""
"The installation of Rust also includes a local copy of the documentation so "
"that you can read it offline. Run `rustup doc` to open the local "
"documentation in your browser."
msgstr "Rust 설치에는 문서의 로컬 복사본도 포함되어 있어 오프라인으로 읽을 수 있습니다. `rustup doc`을 실행하여 브라우저에서 로컬 문서를 여세요."

#: src/ch01-01-installation.md:133
msgid ""
"Any time a type or function is provided by the standard library and you’re "
"not sure what it does or how to use it, use the application programming "
"interface (API) documentation to find out!"
msgstr "표준 라이브러리에서 제공하는 타입이나 함수가 무엇을 하는지 또는 어떻게 사용하는지 확실하지 않을 때는 언제든지 애플리케이션 프로그래밍 인터페이스(API) 문서를 사용하여 알아보세요!"

#: src/ch01-01-installation.md:137
msgid "Text Editors and Integrated Development Environments"
msgstr "텍스트 에디터와 통합 개발 환경"

#: src/ch01-01-installation.md:139
msgid ""
"This book makes no assumptions about what tools you use to author Rust code. "
"Just about any text editor will get the job done! However, many text editors "
"and integrated development environments (IDEs) have built-in support for "
"Rust. You can always find a fairly current list of many editors and IDEs on "
"[the tools page](https://www.rust-lang.org/tools) on the Rust website."
msgstr "이 책은 Rust 코드를 작성하는 데 어떤 도구를 사용하는지에 대해 가정하지 않습니다. 거의 모든 텍스트 편집기가 작업을 수행할 것입니다! 그러나 많은 텍스트 편집기와 통합 개발 환경(IDE)에는 Rust에 대한 내장 지원이 있습니다. Rust 웹사이트의 [도구 페이지](https://www.rust-lang.org/tools)에서 많은 편집기와 IDE의 상당히 최신 목록을 항상 찾을 수 있습니다."

#: src/ch01-02-hello-world.md:3
msgid ""
"Now that you’ve installed Rust, it’s time to write your first Rust program. "
"It’s traditional when learning a new language to write a little program that "
"prints the text `Hello, world!` to the screen, so we’ll do the same here!"
msgstr "이제 Rust를 설치했으니 첫 Rust 프로그램을 작성할 시간입니다. 새로운 언어를 배울 때 `Hello, world!` 텍스트를 화면에 출력하는 작은 프로그램을 작성하는 것이 전통적이므로 여기서도 그렇게 할 것입니다!"

#: src/ch01-02-hello-world.md:7
msgid ""
"Note: This book assumes basic familiarity with the command line. Rust makes "
"no specific demands about your editing or tooling or where your code lives, "
"so if you prefer to use an integrated development environment (IDE) instead "
"of the command line, feel free to use your favorite IDE. Many IDEs now have "
"some degree of Rust support; check the IDE’s documentation for details. The "
"Rust team has been focusing on enabling great IDE support via `rust-"
"analyzer`. See [Appendix D](appendix-04-useful-development-tools.html)<!-- "
"ignore --> for more details."
msgstr "참고: 이 책은 명령줄에 대한 기본적인 지식을 가정합니다. Rust는 편집 또는 도구 사용 또는 코드 위치에 대해 특별한 요구 사항이 없으므로 명령줄 대신 통합 개발 환경(IDE)을 사용하려는 경우 좋아하는 IDE를 자유롭게 사용하십시오. 많은 IDE가 이제 Rust 지원을 어느 정도 제공합니다. 자세한 내용은 IDE 문서를 확인하십시오. Rust 팀은 `rust-analyzer`를 통해 훌륭한 IDE 지원을 가능하게 하는 데 집중하고 있습니다. 자세한 내용은 [부록 D](appendix-04-useful-development-tools.html)<!-- ignore -->를 참조하십시오."

#: src/ch01-02-hello-world.md:15
msgid "Creating a Project Directory"
msgstr "프로젝트 디렉터리 생성하기"

#: src/ch01-02-hello-world.md:17
msgid ""
"You’ll start by making a directory to store your Rust code. It doesn’t "
"matter to Rust where your code lives, but for the exercises and projects in "
"this book, we suggest making a _projects_ directory in your home directory "
"and keeping all your projects there."
msgstr "Rust 코드를 저장할 디렉토리를 만드는 것부터 시작할 것입니다. Rust에게 코드가 어디에 있든 상관없지만, 이 책의 연습 문제와 프로젝트를 위해 홈 디렉토리에 _projects_ 디렉토리를 만들고 모든 프로젝트를 그곳에 보관하는 것을 제안합니다."

#: src/ch01-02-hello-world.md:22
msgid ""
"Open a terminal and enter the following commands to make a _projects_ "
"directory and a directory for the “Hello, world!” project within the "
"_projects_ directory."
msgstr "터미널을 열고 다음 명령을 입력하여 _projects_ 디렉토리와 _projects_ 디렉토리 내에 \"Hello, world!\" 프로젝트용 디렉토리를 만드세요."

#: src/ch01-02-hello-world.md:25
msgid "For Linux, macOS, and PowerShell on Windows, enter this:"
msgstr "Linux, macOS, Windows의 PowerShell에서는 다음을 입력하세요:"

#: src/ch01-02-hello-world.md:34
msgid "For Windows CMD, enter this:"
msgstr "Windows CMD에서는 다음을 입력하세요:"

#: src/ch01-02-hello-world.md:37 src/ch01-02-hello-world.md:38
msgid "\"%USERPROFILE%\\projects\""
msgstr "\"%USERPROFILE%\\projects\""

#: src/ch01-02-hello-world.md:43
msgid "Writing and Running a Rust Program"
msgstr "러스트 프로그램 작성하고 실행하기"

#: src/ch01-02-hello-world.md:45
msgid ""
"Next, make a new source file and call it _main.rs_. Rust files always end "
"with the _.rs_ extension. If you’re using more than one word in your "
"filename, the convention is to use an underscore to separate them. For "
"example, use _hello_world.rs_ rather than _helloworld.rs_."
msgstr "다음으로, 새 소스 파일을 만들고 _main.rs_라고 부르세요. Rust 파일은 항상 _.rs_ 확장자로 끝납니다. 파일 이름에 두 개 이상의 단어를 사용하는 경우, 언더스코어를 사용하여 구분하는 것이 관례입니다. 예를 들어 _helloworld.rs_ 대신 _hello_world.rs_를 사용하세요."

#: src/ch01-02-hello-world.md:50
msgid ""
"Now open the _main.rs_ file you just created and enter the code in Listing "
"1-1."
msgstr "이제 방금 생성한 _main.rs_ 파일을 열고 목록 1-1의 코드를 입력하세요."

#: src/ch01-02-hello-world.md:56 src/ch01-01-installation.md:118 src/ch01-03-hello-cargo.md:96 src/ch02-00-guessing-game-tutorial.md:59 src/ch03-03-how-functions-work.md:16 src/ch04-03-slices.md:367 src/ch20-01-unsafe-rust.md:506
msgid "\"Hello, world!\""
msgstr "\"헬로, 월드!\""

#: src/ch01-02-hello-world.md:62
msgid ""
"Save the file and go back to your terminal window in the _~/projects/"
"hello_world_ directory. On Linux or macOS, enter the following commands to "
"compile and run the file:"
msgstr "파일을 저장하고 _~/projects/hello_world_ 디렉토리의 터미널 창으로 돌아가세요. Linux 또는 macOS에서 다음 명령을 입력하여 파일을 컴파일하고 실행하세요:"

#: src/ch01-02-hello-world.md:72
msgid "On Windows, enter the command `.\\main.exe` instead of `./main`:"
msgstr "Windows에서는 `./main` 대신 `.\\main.exe` 명령을 입력하세요:"

#: src/ch01-02-hello-world.md:80
msgid ""
"Regardless of your operating system, the string `Hello, world!` should print "
"to the terminal. If you don’t see this output, refer back to the "
"[“Troubleshooting”](ch01-01-installation.html#troubleshooting)<!-- ignore --"
"> part of the Installation section for ways to get help."
msgstr "운영 체제에 관계없이 `Hello, world!` 문자열이 터미널에 출력되어야 합니다. 이 출력이 표시되지 않으면 [“문제 해결”](ch01-01-installation.html#troubleshooting)<!-- ignore --> 설치 섹션의 도움말을 참조하세요."

#: src/ch01-02-hello-world.md:85
msgid ""
"If `Hello, world!` did print, congratulations! You’ve officially written a "
"Rust program. That makes you a Rust programmer—welcome!"
msgstr "`Hello, world!`가 출력되었다면 축하합니다! 공식적으로 Rust 프로그램을 작성했습니다. 이제 Rust 프로그래머가 되셨습니다—환영합니다!"

#: src/ch01-02-hello-world.md:88
msgid "Anatomy of a Rust Program"
msgstr "러스트 프로그램의 구조"

#: src/ch01-02-hello-world.md:90
msgid ""
"Let’s review this “Hello, world!” program in detail. Here’s the first piece "
"of the puzzle:"
msgstr "이 \"Hello, world!\" 프로그램을 자세히 살펴보겠습니다. 여기 퍼즐의 첫 번째 조각이 있습니다:"

#: src/ch01-02-hello-world.md:99
msgid ""
"These lines define a function named `main`. The `main` function is special: "
"it is always the first code that runs in every executable Rust program. "
"Here, the first line declares a function named `main` that has no parameters "
"and returns nothing. If there were parameters, they would go inside the "
"parentheses `()`."
msgstr "이 줄들은 `main`이라는 함수를 정의합니다. `main` 함수는 특별합니다. 모든 실행 가능한 Rust 프로그램에서 항상 가장 먼저 실행되는 코드입니다. 여기서 첫 번째 줄은 매개변수가 없고 아무것도 반환하지 않는 `main`이라는 함수를 선언합니다. 매개변수가 있다면 괄호 `()` 안에 들어갈 것입니다."

#: src/ch01-02-hello-world.md:104
msgid ""
"The function body is wrapped in `{}`. Rust requires curly brackets around "
"all function bodies. It’s good style to place the opening curly bracket on "
"the same line as the function declaration, adding one space in between."
msgstr "함수 본문은 `{}`로 묶여 있습니다. Rust는 모든 함수 본문에 중괄호를 요구합니다. 여는 중괄호를 함수 선언과 같은 줄에 배치하고 그 사이에 공백 하나를 추가하는 것이 좋은 스타일입니다."

#: src/ch01-02-hello-world.md:108
msgid ""
"Note: If you want to stick to a standard style across Rust projects, you can "
"use an automatic formatter tool called `rustfmt` to format your code in a "
"particular style (more on `rustfmt` in [Appendix D](appendix-04-useful-"
"development-tools.html)<!-- ignore -->). The Rust team has included this "
"tool with the standard Rust distribution, as `rustc` is, so it should "
"already be installed on your computer!"
msgstr "참고: Rust 프로젝트 전반에 걸쳐 표준 스타일을 유지하고 싶다면 `rustfmt`라는 자동 포맷터 도구를 사용하여 코드를 특정 스타일로 포맷할 수 있습니다(자세한 내용은 [부록 D](appendix-04-useful-development-tools.html)<!-- ignore -->에서 `rustfmt`에 대해 더 알아보세요). Rust 팀은 `rustc`와 마찬가지로 이 도구를 표준 Rust 배포판에 포함했으므로 컴퓨터에 이미 설치되어 있을 것입니다!"

#: src/ch01-02-hello-world.md:115
msgid "The body of the `main` function holds the following code:"
msgstr "`main` 함수의 본문에는 다음 코드가 있습니다:"

#: src/ch01-02-hello-world.md:121
msgid ""
"This line does all the work in this little program: it prints text to the "
"screen. There are four important details to notice here."
msgstr "이 줄은 이 작은 프로그램의 모든 작업을 수행합니다. 텍스트를 화면에 출력합니다. 여기에는 주목해야 할 네 가지 중요한 세부 사항이 있습니다."

#: src/ch01-02-hello-world.md:124
msgid ""
"First, `println!` calls a Rust macro. If it had called a function instead, "
"it would be entered as `println` (without the `!`). We’ll discuss Rust "
"macros in more detail in Chapter 20. For now, you just need to know that "
"using a `!` means that you’re calling a macro instead of a normal function "
"and that macros don’t always follow the same rules as functions."
msgstr "첫째, `println!`은 Rust 매크로를 호출합니다. 함수를 호출했다면 `println` ( `!` 없음)으로 입력되었을 것입니다. 20장에서 Rust 매크로에 대해 더 자세히 논의할 것입니다. 지금은 `!`를 사용하는 것이 일반 함수 대신 매크로를 호출하는 것을 의미하며 매크로가 항상 함수와 동일한 규칙을 따르지는 않는다는 것을 알아야 합니다."

#: src/ch01-02-hello-world.md:130
msgid ""
"Second, you see the `\"Hello, world!\"` string. We pass this string as an "
"argument to `println!`, and the string is printed to the screen."
msgstr "둘째, `\"Hello, world!\"` 문자열이 보입니다. 이 문자열을 `println!`에 인수로 전달하면 문자열이 화면에 출력됩니다."

#: src/ch01-02-hello-world.md:133
msgid ""
"Third, we end the line with a semicolon (`;`), which indicates that this "
"expression is over and the next one is ready to begin. Most lines of Rust "
"code end with a semicolon."
msgstr "셋째, 줄을 세미콜론(`;`)으로 끝냅니다. 이는 이 표현식이 끝났고 다음 표현식이 시작될 준비가 되었음을 나타냅니다. 대부분의 Rust 코드 줄은 세미콜론으로 끝납니다."

#: src/ch01-02-hello-world.md:137
msgid "Compiling and Running Are Separate Steps"
msgstr "컴파일과 실행은 별개의 단계입니다"

#: src/ch01-02-hello-world.md:139
msgid ""
"You’ve just run a newly created program, so let’s examine each step in the "
"process."
msgstr "방금 새로 생성된 프로그램을 실행했으므로 프로세스의 각 단계를 살펴보겠습니다."

#: src/ch01-02-hello-world.md:142
msgid ""
"Before running a Rust program, you must compile it using the Rust compiler "
"by entering the `rustc` command and passing it the name of your source file, "
"like this:"
msgstr "Rust 프로그램을 실행하기 전에 `rustc` 명령을 입력하고 소스 파일 이름을 전달하여 Rust 컴파일러를 사용하여 컴파일해야 합니다. 다음과 같이요:"

#: src/ch01-02-hello-world.md:150
msgid ""
"If you have a C or C++ background, you’ll notice that this is similar to "
"`gcc` or `clang`. After compiling successfully, Rust outputs a binary "
"executable."
msgstr "C 또는 C++ 배경이 있다면 이것이 `gcc` 또는 `clang`과 유사하다는 것을 알 수 있을 것입니다. 성공적으로 컴파일한 후 Rust는 바이너리 실행 파일을 출력합니다."

#: src/ch01-02-hello-world.md:153
msgid ""
"On Linux, macOS, and PowerShell on Windows, you can see the executable by "
"entering the `ls` command in your shell:"
msgstr "Linux, macOS, Windows의 PowerShell에서 셸에 `ls` 명령을 입력하여 실행 파일을 볼 수 있습니다:"

#: src/ch01-02-hello-world.md:161
msgid ""
"On Linux and macOS, you’ll see two files. With PowerShell on Windows, you’ll "
"see the same three files that you would see using CMD. With CMD on Windows, "
"you would enter the following:"
msgstr "Linux와 macOS에서는 두 개의 파일이 보일 것입니다. Windows의 PowerShell에서는 CMD를 사용할 때와 동일한 세 개의 파일이 보일 것입니다. Windows의 CMD에서는 다음을 입력할 것입니다:"

#: src/ch01-02-hello-world.md:172
msgid ""
"This shows the source code file with the _.rs_ extension, the executable "
"file (_main.exe_ on Windows, but _main_ on all other platforms), and, when "
"using Windows, a file containing debugging information with the _.pdb_ "
"extension. From here, you run the _main_ or _main.exe_ file, like this:"
msgstr "이것은 _.rs_ 확장자를 가진 소스 코드 파일, 실행 파일(Windows에서는 _main.exe_, 다른 모든 플랫폼에서는 _main_), 그리고 Windows를 사용하는 경우 _.pdb_ 확장자를 가진 디버깅 정보가 포함된 파일을 보여줍니다. 여기에서 _main_ 또는 _main.exe_ 파일을 다음과 같이 실행합니다:"

#: src/ch01-02-hello-world.md:181
msgid ""
"If your _main.rs_ is your “Hello, world!” program, this line prints `Hello, "
"world!` to your terminal."
msgstr "만약 _main.rs_가 \"Hello, world!\" 프로그램이라면, 이 줄은 터미널에 `Hello, world!`를 출력합니다."

#: src/ch01-02-hello-world.md:184
msgid ""
"If you’re more familiar with a dynamic language, such as Ruby, Python, or "
"JavaScript, you might not be used to compiling and running a program as "
"separate steps. Rust is an _ahead-of-time compiled_ language, meaning you "
"can compile a program and give the executable to someone else, and they can "
"run it even without having Rust installed. If you give someone a _.rb_, "
"_.py_, or _.js_ file, they need to have a Ruby, Python, or JavaScript "
"implementation installed (respectively). But in those languages, you only "
"need one command to compile and run your program. Everything is a trade-off "
"in language design."
msgstr "Ruby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙하다면 프로그램을 별도의 단계로 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다. Rust는 _사전 컴파일_ 언어이므로 프로그램을 컴파일하고 실행 파일을 다른 사람에게 제공할 수 있으며, 그들은 Rust가 설치되어 있지 않아도 실행할 수 있습니다. 누군가에게 _.rb_, _.py_ 또는 _.js_ 파일을 제공하면 해당 언어의 구현(각각)이 설치되어 있어야 합니다. 그러나 해당 언어에서는 프로그램을 컴파일하고 실행하는 데 하나의 명령만 필요합니다. 모든 것은 언어 설계의 트레이드오프입니다."

#: src/ch01-02-hello-world.md:193
msgid ""
"Just compiling with `rustc` is fine for simple programs, but as your project "
"grows, you’ll want to manage all the options and make it easy to share your "
"code. Next, we’ll introduce you to the Cargo tool, which will help you write "
"real-world Rust programs."
msgstr "`rustc`로만 컴파일하는 것은 간단한 프로그램에는 괜찮지만, 프로젝트가 커지면 모든 옵션을 관리하고 코드를 쉽게 공유하고 싶을 것입니다. 다음으로 실제 Rust 프로그램을 작성하는 데 도움이 될 Cargo 도구를 소개합니다."

#: src/ch01-03-hello-cargo.md:3
msgid ""
"Cargo is Rust’s build system and package manager. Most Rustaceans use this "
"tool to manage their Rust projects because Cargo handles a lot of tasks for "
"you, such as building your code, downloading the libraries your code depends "
"on, and building those libraries. (We call the libraries that your code "
"needs _dependencies_.)"
msgstr "Cargo는 Rust의 빌드 시스템이자 패키지 관리자입니다. 대부분의 Rustaceans는 Cargo가 코드 빌드, 코드에 의존하는 라이브러리 다운로드, 해당 라이브러리 빌드와 같은 많은 작업을 처리해주기 때문에 이 도구를 사용하여 Rust 프로젝트를 관리합니다. (코드에 필요한 라이브러리를 _의존성_이라고 부릅니다.)"

#: src/ch01-03-hello-cargo.md:9
msgid ""
"The simplest Rust programs, like the one we’ve written so far, don’t have "
"any dependencies. If we had built the “Hello, world!” project with Cargo, it "
"would only use the part of Cargo that handles building your code. As you "
"write more complex Rust programs, you’ll add dependencies, and if you start "
"a project using Cargo, adding dependencies will be much easier to do."
msgstr "지금까지 작성한 것과 같은 가장 간단한 Rust 프로그램은 의존성이 없습니다. \"Hello, world!\" 프로젝트를 Cargo로 빌드했다면 코드 빌드를 처리하는 Cargo 부분만 사용했을 것입니다. 더 복잡한 Rust 프로그램을 작성할수록 의존성을 추가하게 될 것이며, Cargo를 사용하여 프로젝트를 시작하면 의존성을 추가하는 것이 훨씬 쉬워질 것입니다."

#: src/ch01-03-hello-cargo.md:15
msgid ""
"Because the vast majority of Rust projects use Cargo, the rest of this book "
"assumes that you’re using Cargo too. Cargo comes installed with Rust if you "
"used the official installers discussed in the [“Installation”](ch01-01-"
"installation.html#installation)<!-- ignore --> section. If you installed "
"Rust through some other means, check whether Cargo is installed by entering "
"the following in your terminal:"
msgstr "대부분의 Rust 프로젝트가 Cargo를 사용하므로 이 책의 나머지 부분에서도 Cargo를 사용한다고 가정합니다. [“설치”](ch01-01-installation.html#installation)<!-- ignore --> 섹션에서 설명한 공식 설치 프로그램을 사용했다면 Cargo는 Rust와 함께 설치됩니다. 다른 방법으로 Rust를 설치했다면 터미널에 다음을 입력하여 Cargo가 설치되었는지 확인하세요:"

#: src/ch01-03-hello-cargo.md:26
msgid ""
"If you see a version number, you have it! If you see an error, such as "
"`command not found`, look at the documentation for your method of "
"installation to determine how to install Cargo separately."
msgstr "버전 번호가 보이면 설치된 것입니다! `command not found`와 같은 오류가 표시되면 설치 방법에 대한 문서를 참조하여 Cargo를 별도로 설치하는 방법을 확인하세요."

#: src/ch01-03-hello-cargo.md:30
msgid "Creating a Project with Cargo"
msgstr "Cargo로 프로젝트 생성하기"

#: src/ch01-03-hello-cargo.md:32
msgid ""
"Let’s create a new project using Cargo and look at how it differs from our "
"original “Hello, world!” project. Navigate back to your _projects_ directory "
"(or wherever you decided to store your code). Then, on any operating system, "
"run the following:"
msgstr "Cargo를 사용하여 새 프로젝트를 만들고 원래의 \"Hello, world!\" 프로젝트와 어떻게 다른지 살펴보겠습니다. _projects_ 디렉토리(또는 코드를 저장하기로 결정한 곳)로 돌아가세요. 그런 다음 모든 운영 체제에서 다음을 실행하세요:"

#: src/ch01-03-hello-cargo.md:42
msgid ""
"The first command creates a new directory and project called _hello_cargo_. "
"We’ve named our project _hello_cargo_, and Cargo creates its files in a "
"directory of the same name."
msgstr "첫 번째 명령은 _hello_cargo_라는 새 디렉토리와 프로젝트를 만듭니다. 프로젝트 이름을 _hello_cargo_로 지정했으며, Cargo는 동일한 이름의 디렉토리에 파일을 만듭니다."

#: src/ch01-03-hello-cargo.md:46
msgid ""
"Go into the _hello_cargo_ directory and list the files. You’ll see that "
"Cargo has generated two files and one directory for us: a _Cargo.toml_ file "
"and a _src_ directory with a _main.rs_ file inside."
msgstr "_hello_cargo_ 디렉토리로 이동하여 파일을 나열하세요. Cargo가 두 개의 파일과 하나의 디렉토리를 생성했음을 알 수 있습니다. _Cargo.toml_ 파일과 그 안에 _main.rs_ 파일이 있는 _src_ 디렉토리입니다."

#: src/ch01-03-hello-cargo.md:50
msgid ""
"It has also initialized a new Git repository along with a _.gitignore_ file. "
"Git files won’t be generated if you run `cargo new` within an existing Git "
"repository; you can override this behavior by using `cargo new --vcs=git`."
msgstr "또한 _.gitignore_ 파일과 함께 새 Git 리포지토리를 초기화했습니다. 기존 Git 리포지토리 내에서 `cargo new`를 실행하면 Git 파일이 생성되지 않습니다. `cargo new --vcs=git`을 사용하여 이 동작을 재정의할 수 있습니다."

#: src/ch01-03-hello-cargo.md:54
msgid ""
"Note: Git is a common version control system. You can change `cargo new` to "
"use a different version control system or no version control system by using "
"the `--vcs` flag. Run `cargo new --help` to see the available options."
msgstr "참고: Git은 일반적인 버전 관리 시스템입니다. `--vcs` 플래그를 사용하여 `cargo new`가 다른 버전 관리 시스템을 사용하거나 버전 관리 시스템을 사용하지 않도록 변경할 수 있습니다. 사용 가능한 옵션을 보려면 `cargo new --help`를 실행하세요."

#: src/ch01-03-hello-cargo.md:58
msgid ""
"Open _Cargo.toml_ in your text editor of choice. It should look similar to "
"the code in Listing 1-2."
msgstr "선택한 텍스트 편집기에서 _Cargo.toml_을 여세요. 목록 1-2의 코드와 유사하게 보일 것입니다."

#: src/ch01-03-hello-cargo.md:63
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_cargo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr "```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n```"

#: src/ch01-03-hello-cargo.md:74
msgid ""
"This file is in the [_TOML_](https://toml.io)<!-- ignore --> (_Tom’s "
"Obvious, Minimal Language_) format, which is Cargo’s configuration format."
msgstr "이 파일은 Cargo의 구성 형식인 [_TOML_](https://toml.io)<!-- ignore --> (_Tom’s Obvious, Minimal Language_) 형식입니다."

#: src/ch01-03-hello-cargo.md:77
msgid ""
"The first line, `[package]`, is a section heading that indicates that the "
"following statements are configuring a package. As we add more information "
"to this file, we’ll add other sections."
msgstr "첫 번째 줄인 `[package]`는 다음 문이 패키지를 구성하고 있음을 나타내는 섹션 제목입니다. 이 파일에 더 많은 정보를 추가할수록 다른 섹션을 추가할 것입니다."

#: src/ch01-03-hello-cargo.md:81
msgid ""
"The next three lines set the configuration information Cargo needs to "
"compile your program: the name, the version, and the edition of Rust to use. "
"We’ll talk about the `edition` key in [Appendix E](appendix-05-"
"editions.html)<!-- ignore -->."
msgstr "다음 세 줄은 Cargo가 프로그램을 컴파일하는 데 필요한 구성 정보(이름, 버전, 사용할 Rust 에디션)를 설정합니다. [부록 E](appendix-05-editions.html)<!-- ignore -->에서 `edition` 키에 대해 이야기할 것입니다."

#: src/ch01-03-hello-cargo.md:85
msgid ""
"The last line, `[dependencies]`, is the start of a section for you to list "
"any of your project’s dependencies. In Rust, packages of code are referred "
"to as _crates_. We won’t need any other crates for this project, but we will "
"in the first project in Chapter 2, so we’ll use this dependencies section "
"then."
msgstr "마지막 줄인 `[dependencies]`는 프로젝트의 의존성을 나열하는 섹션의 시작입니다. Rust에서는 코드 패키지를 _크레이트_라고 부릅니다. 이 프로젝트에는 다른 크레이트가 필요하지 않지만, 2장의 첫 번째 프로젝트에서는 필요할 것이므로 그때 이 의존성 섹션을 사용할 것입니다."

#: src/ch01-03-hello-cargo.md:90
msgid "Now open _src/main.rs_ and take a look:"
msgstr "이제 _src/main.rs_를 열어서 살펴보세요:"

#: src/ch01-03-hello-cargo.md:92 src/ch02-00-guessing-game-tutorial.md:55
#: src/ch02-00-guessing-game-tutorial.md:877
#: src/ch02-00-guessing-game-tutorial.md:1000
#: src/ch02-00-guessing-game-tutorial.md:1096
#: src/ch03-01-variables-and-mutability.md:18
#: src/ch03-01-variables-and-mutability.md:80
#: src/ch03-01-variables-and-mutability.md:165 src/ch03-02-data-types.md:153
#: src/ch03-02-data-types.md:172 src/ch03-02-data-types.md:205
#: src/ch03-02-data-types.md:224 src/ch03-02-data-types.md:261
#: src/ch03-02-data-types.md:273 src/ch03-02-data-types.md:294
#: src/ch03-02-data-types.md:326 src/ch03-02-data-types.md:381
#: src/ch03-02-data-types.md:402 src/ch03-03-how-functions-work.md:12
#: src/ch03-03-how-functions-work.md:66 src/ch03-03-how-functions-work.md:102
#: src/ch03-03-how-functions-work.md:169 src/ch03-03-how-functions-work.md:221
#: src/ch03-03-how-functions-work.md:261 src/ch03-03-how-functions-work.md:304
#: src/ch03-03-how-functions-work.md:322 src/ch03-04-comments.md:26
#: src/ch03-04-comments.md:37 src/ch03-05-control-flow.md:17
#: src/ch03-05-control-flow.md:85 src/ch03-05-control-flow.md:120
#: src/ch03-05-control-flow.md:139 src/ch03-05-control-flow.md:216
#: src/ch03-05-control-flow.md:273 src/ch03-05-control-flow.md:531
#: src/ch05-03-method-syntax.md:298
#: src/ch12-03-improving-error-handling-and-modularity.md:751
#: src/ch13-03-improving-our-io-project.md:149
#: src/ch15-06-reference-cycles.md:218 src/ch15-06-reference-cycles.md:305
#: src/ch16-02-message-passing.md:35 src/appendix-01-keywords.md:91
#: src/appendix-01-keywords.md:113
#: src/appendix-04-useful-development-tools.md:39
#: src/appendix-04-useful-development-tools.md:79
#: src/appendix-04-useful-development-tools.md:113
#: src/appendix-04-useful-development-tools.md:142
msgid "<span class=\"filename\">Filename: src/main.rs</span>"
msgstr "<span class=\"filename\">파일명: src/main.rs</span>"

#: src/ch01-03-hello-cargo.md:100
msgid ""
"Cargo has generated a “Hello, world!” program for you, just like the one we "
"wrote in Listing 1-1! So far, the differences between our project and the "
"project Cargo generated are that Cargo placed the code in the _src_ "
"directory and we have a _Cargo.toml_ configuration file in the top directory."
msgstr "Cargo는 목록 1-1에서 작성한 것과 똑같은 \"Hello, world!\" 프로그램을 생성했습니다! 지금까지 우리 프로젝트와 Cargo가 생성한 프로젝트의 차이점은 Cargo가 코드를 _src_ 디렉토리에 배치했고 최상위 디렉토리에 _Cargo.toml_ 구성 파일이 있다는 것입니다."

#: src/ch01-03-hello-cargo.md:105
msgid ""
"Cargo expects your source files to live inside the _src_ directory. The top-"
"level project directory is just for README files, license information, "
"configuration files, and anything else not related to your code. Using Cargo "
"helps you organize your projects. There’s a place for everything, and "
"everything is in its place."
msgstr "Cargo는 소스 파일이 _src_ 디렉토리 안에 있어야 한다고 예상합니다. 최상위 프로젝트 디렉토리는 README 파일, 라이선스 정보, 구성 파일 및 코드와 관련 없는 다른 모든 것을 위한 것입니다. Cargo를 사용하면 프로젝트를 구성하는 데 도움이 됩니다. 모든 것에는 제자리가 있고, 모든 것은 제자리에 있습니다."

#: src/ch01-03-hello-cargo.md:111
msgid ""
"If you started a project that doesn’t use Cargo, as we did with the “Hello, "
"world!” project, you can convert it to a project that does use Cargo. Move "
"the project code into the _src_ directory and create an appropriate "
"_Cargo.toml_ file. One easy way to get that _Cargo.toml_ file is to run "
"`cargo init`, which will create it for you automatically."
msgstr "Cargo를 사용하지 않는 프로젝트를 시작했다면, \"Hello, world!\" 프로젝트에서 했던 것처럼 Cargo를 사용하는 프로젝트로 변환할 수 있습니다. 프로젝트 코드를 _src_ 디렉토리로 이동하고 적절한 _Cargo.toml_ 파일을 만드세요. _Cargo.toml_ 파일을 얻는 한 가지 쉬운 방법은 `cargo init`을 실행하는 것입니다. 그러면 자동으로 생성됩니다."

#: src/ch01-03-hello-cargo.md:117
msgid "Building and Running a Cargo Project"
msgstr "Cargo 프로젝트 빌드하고 실행하기"

#: src/ch01-03-hello-cargo.md:119
msgid ""
"Now let’s look at what’s different when we build and run the “Hello, world!” "
"program with Cargo! From your _hello_cargo_ directory, build your project by "
"entering the following command:"
msgstr "이제 Cargo로 \"Hello, world!\" 프로그램을 빌드하고 실행할 때 무엇이 다른지 살펴보겠습니다! _hello_cargo_ 디렉토리에서 다음 명령을 입력하여 프로젝트를 빌드하세요:"

#: src/ch01-03-hello-cargo.md:123
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n"
"```"
msgstr "```console\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```"

#: src/ch01-03-hello-cargo.md:129
msgid ""
"This command creates an executable file in _target/debug/hello_cargo_ (or "
"_target\\debug\\hello_cargo.exe_ on Windows) rather than in your current "
"directory. Because the default build is a debug build, Cargo puts the binary "
"in a directory named _debug_. You can run the executable with this command:"
msgstr "이 명령은 현재 디렉토리가 아닌 _target/debug/hello_cargo_ (Windows에서는 _target\\debug\\hello_cargo.exe_)에 실행 파일을 만듭니다. 기본 빌드가 디버그 빌드이므로 Cargo는 바이너리를 _debug_라는 디렉토리에 넣습니다. 이 명령으로 실행 파일을 실행할 수 있습니다:"

#: src/ch01-03-hello-cargo.md:139
msgid ""
"If all goes well, `Hello, world!` should print to the terminal. Running "
"`cargo build` for the first time also causes Cargo to create a new file at "
"the top level: _Cargo.lock_. This file keeps track of the exact versions of "
"dependencies in your project. This project doesn’t have dependencies, so the "
"file is a bit sparse. You won’t ever need to change this file manually; "
"Cargo manages its contents for you."
msgstr "모든 것이 잘 진행되면 `Hello, world!`가 터미널에 출력되어야 합니다. `cargo build`를 처음 실행하면 Cargo는 최상위 수준에 _Cargo.lock_이라는 새 파일을 만듭니다. 이 파일은 프로젝트의 의존성 정확한 버전을 추적합니다. 이 프로젝트에는 의존성이 없으므로 파일은 다소 희박합니다. 이 파일을 수동으로 변경할 필요는 없습니다. Cargo가 내용을 관리합니다."

#: src/ch01-03-hello-cargo.md:146
msgid ""
"We just built a project with `cargo build` and ran it with `./target/debug/"
"hello_cargo`, but we can also use `cargo run` to compile the code and then "
"run the resultant executable all in one command:"
msgstr "방금 `cargo build`로 프로젝트를 빌드하고 `./target/debug/hello_cargo`로 실행했지만, `cargo run`을 사용하여 코드를 컴파일한 다음 결과 실행 파일을 한 번에 실행할 수도 있습니다:"

#: src/ch01-03-hello-cargo.md:157
msgid ""
"Using `cargo run` is more convenient than having to remember to run `cargo "
"build` and then use the whole path to the binary, so most developers use "
"`cargo run`."
msgstr "`cargo run`을 사용하는 것이 `cargo build`를 실행한 다음 바이너리의 전체 경로를 기억해야 하는 것보다 편리하므로 대부분의 개발자는 `cargo run`을 사용합니다."

#: src/ch01-03-hello-cargo.md:161
msgid ""
"Notice that this time we didn’t see output indicating that Cargo was "
"compiling `hello_cargo`. Cargo figured out that the files hadn’t changed, so "
"it didn’t rebuild but just ran the binary. If you had modified your source "
"code, Cargo would have rebuilt the project before running it, and you would "
"have seen this output:"
msgstr "이번에는 Cargo가 `hello_cargo`를 컴파일하고 있다는 출력이 표시되지 않았습니다. Cargo는 파일이 변경되지 않았음을 파악했으므로 다시 빌드하지 않고 바이너리를 실행했습니다. 소스 코드를 수정했다면 Cargo는 실행하기 전에 프로젝트를 다시 빌드했을 것이며, 이 출력이 표시되었을 것입니다:"

#: src/ch01-03-hello-cargo.md:167
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n"
"     Running `target/debug/hello_cargo`\n"
"Hello, world!\n"
"```"
msgstr "```console\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```"

#: src/ch01-03-hello-cargo.md:175
msgid ""
"Cargo also provides a command called `cargo check`. This command quickly "
"checks your code to make sure it compiles but doesn’t produce an executable:"
msgstr "Cargo는 `cargo check`라는 명령도 제공합니다. 이 명령은 코드가 컴파일되는지 빠르게 확인하지만 실행 파일을 생성하지는 않습니다:"

#: src/ch01-03-hello-cargo.md:178
msgid ""
"```console\n"
"$ cargo check\n"
"   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n"
"```"
msgstr "```console\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```"

#: src/ch01-03-hello-cargo.md:184
msgid ""
"Why would you not want an executable? Often, `cargo check` is much faster "
"than `cargo build` because it skips the step of producing an executable. If "
"you’re continually checking your work while writing the code, using `cargo "
"check` will speed up the process of letting you know if your project is "
"still compiling! As such, many Rustaceans run `cargo check` periodically as "
"they write their program to make sure it compiles. Then they run `cargo "
"build` when they’re ready to use the executable."
msgstr "실행 파일을 원하지 않는 이유는 무엇입니까? 종종 `cargo check`는 실행 파일을 생성하는 단계를 건너뛰기 때문에 `cargo build`보다 훨씬 빠릅니다. 코드를 작성하는 동안 작업을 계속 확인하는 경우 `cargo check`를 사용하면 프로젝트가 여전히 컴파일되는지 여부를 알려주는 프로세스 속도를 높일 수 있습니다! 따라서 많은 Rustaceans는 프로그램을 작성하면서 주기적으로 `cargo check`를 실행하여 컴파일되는지 확인합니다. 그런 다음 실행 파일을 사용할 준비가 되면 `cargo build`를 실행합니다."

#: src/ch01-03-hello-cargo.md:192
msgid "Let’s recap what we’ve learned so far about Cargo:"
msgstr "Cargo에 대해 지금까지 배운 내용을 요약해 봅시다:"

#: src/ch01-03-hello-cargo.md:194
msgid "We can create a project using `cargo new`."
msgstr "`cargo new`를 사용하여 프로젝트를 생성할 수 있습니다."

#: src/ch01-03-hello-cargo.md:195
msgid "We can build a project using `cargo build`."
msgstr "`cargo build`를 사용하여 프로젝트를 빌드할 수 있습니다."

#: src/ch01-03-hello-cargo.md:196
msgid "We can build and run a project in one step using `cargo run`."
msgstr "`cargo run`을 사용하여 한 번에 프로젝트를 빌드하고 실행할 수 있습니다."

#: src/ch01-03-hello-cargo.md:197
msgid ""
"We can build a project without producing a binary to check for errors using "
"`cargo check`."
msgstr "`cargo check`를 사용하여 바이너리를 생성하지 않고 프로젝트를 빌드하여 오류를 확인할 수 있습니다."

#: src/ch01-03-hello-cargo.md:199
msgid ""
"Instead of saving the result of the build in the same directory as our code, "
"Cargo stores it in the _target/debug_ directory."
msgstr "빌드 결과를 코드와 동일한 디렉토리에 저장하는 대신 Cargo는 _target/debug_ 디렉토리에 저장합니다."

#: src/ch01-03-hello-cargo.md:202
msgid ""
"An additional advantage of using Cargo is that the commands are the same no "
"matter which operating system you’re working on. So, at this point, we’ll no "
"longer provide specific instructions for Linux and macOS versus Windows."
msgstr "Cargo를 사용하는 추가적인 장점은 작업하는 운영 체제에 관계없이 명령이 동일하다는 것입니다. 따라서 이 시점부터 Linux 및 macOS와 Windows에 대한 특정 지침은 더 이상 제공하지 않습니다."

#: src/ch01-03-hello-cargo.md:206
msgid "Building for Release"
msgstr "릴리스용 빌드"

#: src/ch01-03-hello-cargo.md:208
msgid ""
"When your project is finally ready for release, you can use `cargo build --"
"release` to compile it with optimizations. This command will create an "
"executable in _target/release_ instead of _target/debug_. The optimizations "
"make your Rust code run faster, but turning them on lengthens the time it "
"takes for your program to compile. This is why there are two different "
"profiles: one for development, when you want to rebuild quickly and often, "
"and another for building the final program you’ll give to a user that won’t "
"be rebuilt repeatedly and that will run as fast as possible. If you’re "
"benchmarking your code’s running time, be sure to run `cargo build --"
"release` and benchmark with the executable in _target/release_."
msgstr "프로젝트가 마침내 릴리스 준비가 되면 `cargo build --release`를 사용하여 최적화와 함께 컴파일할 수 있습니다. 이 명령은 _target/debug_ 대신 _target/release_에 실행 파일을 만듭니다. 최적화는 Rust 코드를 더 빠르게 실행하지만, 이를 켜면 프로그램 컴파일 시간이 길어집니다. 이것이 두 가지 다른 프로필이 있는 이유입니다. 하나는 개발용으로, 빠르고 자주 다시 빌드하고 싶을 때 사용하고, 다른 하나는 사용자에게 제공할 최종 프로그램을 빌드할 때 사용합니다. 이 프로그램은 반복적으로 다시 빌드되지 않으며 가능한 한 빠르게 실행됩니다. 코드의 실행 시간을 벤치마킹하는 경우 `cargo build --release`를 실행하고 _target/release_의 실행 파일로 벤치마킹해야 합니다."

#: src/ch01-03-hello-cargo.md:219
msgid "Cargo as Convention"
msgstr "관례로서의 Cargo"

#: src/ch01-03-hello-cargo.md:221
msgid ""
"With simple projects, Cargo doesn’t provide a lot of value over just using "
"`rustc`, but it will prove its worth as your programs become more intricate. "
"Once programs grow to multiple files or need a dependency, it’s much easier "
"to let Cargo coordinate the build."
msgstr "간단한 프로젝트에서는 Cargo가 단지 `rustc`를 사용하는 것보다 큰 가치를 제공하지는 않지만, 프로그램이 더 복잡해지면 그 가치를 증명할 것입니다. 프로그램이 여러 파일로 커지거나 의존성이 필요하게 되면 Cargo가 빌드를 조정하도록 하는 것이 훨씬 쉽습니다."

#: src/ch01-03-hello-cargo.md:226
msgid ""
"Even though the `hello_cargo` project is simple, it now uses much of the "
"real tooling you’ll use in the rest of your Rust career. In fact, to work on "
"any existing projects, you can use the following commands to check out the "
"code using Git, change to that project’s directory, and build:"
msgstr "`hello_cargo` 프로젝트는 간단하지만, 여러분의 나머지 러스트 경력에서 사용하게 될 실제 도구의 많은 부분을 이미 사용하고 있습니다. 사실, 기존의 어떤 프로젝트에서든 작업하기 위해 다음 명령을 사용하여 Git으로 코드를 확인하고, 해당 프로젝트의 디렉토리로 변경한 다음, 빌드할 수 있습니다:"

#: src/ch01-03-hello-cargo.md:237
msgid ""
"For more information about Cargo, check out [its documentation](https://"
"doc.rust-lang.org/cargo/)."
msgstr "Cargo에 대한 더 많은 정보를 원하시면, [공식 문서](https://doc.rust-lang.org/cargo/)를 확인하세요."

#: src/ch01-03-hello-cargo.md:239 src/ch02-00-guessing-game-tutorial.md:1301
#: src/ch03-05-control-flow.md:544 src/ch04-03-slices.md:501
#: src/ch05-03-method-syntax.md:383 src/ch06-03-if-let.md:346
#: src/ch07-05-separating-modules-into-different-files.md:125
#: src/ch08-03-hash-maps.md:291 src/ch09-03-to-panic-or-not-to-panic.md:270
#: src/ch10-03-lifetime-syntax.md:876 src/ch11-03-test-organization.md:353
#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:113
#: src/ch13-04-performance.md:84 src/ch14-05-extending-cargo.md:10
#: src/ch15-06-reference-cycles.md:508
#: src/ch16-04-extensible-concurrency-sync-and-send.md:63
#: src/ch17-06-futures-tasks-threads.md:206
#: src/ch18-03-oo-design-patterns.md:945 src/ch19-03-pattern-syntax.md:850
#: src/ch20-05-macros.md:569 src/ch21-03-graceful-shutdown-and-cleanup.md:737
msgid "Summary"
msgstr "요약"

#: src/ch01-03-hello-cargo.md:241
msgid ""
"You’re already off to a great start on your Rust journey! In this chapter, "
"you’ve learned how to:"
msgstr "여러분은 이미 러스트 여정을 순조롭게 시작했습니다! 이번 장에서 여러분은 다음을 배웠습니다:"

#: src/ch01-03-hello-cargo.md:244
msgid "Install the latest stable version of Rust using `rustup`"
msgstr "`rustup`을 사용하여 최신 안정 버전의 러스트 설치하기"

#: src/ch01-03-hello-cargo.md:245
msgid "Update to a newer Rust version"
msgstr "새로운 러스트 버전으로 업데이트하기"

#: src/ch01-03-hello-cargo.md:246
msgid "Open locally installed documentation"
msgstr "로컬에 설치된 문서 열기"

#: src/ch01-03-hello-cargo.md:247
msgid "Write and run a “Hello, world!” program using `rustc` directly"
msgstr "`rustc`를 직접 사용하여 “Hello, world!” 프로그램을 작성하고 실행하기"

#: src/ch01-03-hello-cargo.md:248
msgid "Create and run a new project using the conventions of Cargo"
msgstr "Cargo의 관례를 사용하여 새 프로젝트 생성하고 실행하기"

#: src/ch01-03-hello-cargo.md:250
msgid ""
"This is a great time to build a more substantial program to get used to "
"reading and writing Rust code. So, in Chapter 2, we’ll build a guessing game "
"program. If you would rather start by learning how common programming "
"concepts work in Rust, see Chapter 3 and then return to Chapter 2."
msgstr "이제 러스트 코드를 읽고 쓰는 데 익숙해지기 위해 더 실질적인 프로그램을 만들어 볼 좋은 시간입니다. 그래서 2장에서는 추측 게임 프로그램을 만들 것입니다. 만약 러스트에서 일반적인 프로그래밍 개념이 어떻게 작동하는지 먼저 배우고 싶다면, 3장을 보고 2장으로 돌아오세요."

#: src/ch02-00-guessing-game-tutorial.md:3
msgid ""
"Let’s jump into Rust by working through a hands-on project together! This "
"chapter introduces you to a few common Rust concepts by showing you how to "
"use them in a real program. You’ll learn about `let`, `match`, methods, "
"associated functions, external crates, and more! In the following chapters, "
"we’ll explore these ideas in more detail. In this chapter, you’ll just "
"practice the fundamentals."
msgstr "함께 실습 프로젝트를 통해 Rust에 뛰어들어 봅시다! 이 장에서는 몇 가지 일반적인 Rust 개념을 실제 프로그램에서 사용하는 방법을 보여줌으로써 소개합니다. `let`, `match`, 메서드, 연관 함수, 외부 크레이트 등에 대해 배울 것입니다! 다음 장에서는 이러한 아이디어를 더 자세히 탐구할 것입니다. 이 장에서는 기본 사항만 연습할 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:10
msgid ""
"We’ll implement a classic beginner programming problem: a guessing game. "
"Here’s how it works: the program will generate a random integer between 1 "
"and 100. It will then prompt the player to enter a guess. After a guess is "
"entered, the program will indicate whether the guess is too low or too high. "
"If the guess is correct, the game will print a congratulatory message and "
"exit."
msgstr "고전적인 초보자 프로그래밍 문제인 숫자 맞추기 게임을 구현할 것입니다. 작동 방식은 다음과 같습니다. 프로그램은 1에서 100 사이의 무작위 정수를 생성합니다. 그런 다음 플레이어에게 추측을 입력하라는 메시지를 표시합니다. 추측이 입력되면 프로그램은 추측이 너무 낮은지 또는 너무 높은지 나타냅니다. 추측이 맞으면 게임은 축하 메시지를 인쇄하고 종료합니다."

#: src/ch02-00-guessing-game-tutorial.md:16
msgid "Setting Up a New Project"
msgstr "새 프로젝트 설정하기"

#: src/ch02-00-guessing-game-tutorial.md:18
msgid ""
"To set up a new project, go to the _projects_ directory that you created in "
"Chapter 1 and make a new project using Cargo, like so:"
msgstr "새 프로젝트를 설정하려면 1장에서 만든 _projects_ 디렉토리로 이동하여 Cargo를 사용하여 새 프로젝트를 만드세요. 다음과 같이요:"

#: src/ch02-00-guessing-game-tutorial.md:26
msgid ""
"The first command, `cargo new`, takes the name of the project "
"(`guessing_game`) as the first argument. The second command changes to the "
"new project’s directory."
msgstr "첫 번째 명령인 `cargo new`는 프로젝트 이름(`guessing_game`)을 첫 번째 인수로 받습니다. 두 번째 명령은 새 프로젝트 디렉토리로 변경합니다."

#: src/ch02-00-guessing-game-tutorial.md:30
msgid "Look at the generated _Cargo.toml_ file:"
msgstr "생성된 _Cargo.toml_ 파일을 살펴보세요:"

#: src/ch02-00-guessing-game-tutorial.md:41
#: src/ch02-00-guessing-game-tutorial.md:488 src/ch14-01-release-profiles.md:37
#: src/ch14-01-release-profiles.md:62
#: src/ch14-02-publishing-to-crates-io.md:406
#: src/ch14-02-publishing-to-crates-io.md:443
#: src/ch14-02-publishing-to-crates-io.md:465
#: src/ch14-03-cargo-workspaces.md:33 src/ch14-03-cargo-workspaces.md:96
msgid "<span class=\"filename\">Filename: Cargo.toml</span>"
msgstr "<span class=\"filename\">파일명: Cargo.toml</span>"

#: src/ch02-00-guessing-game-tutorial.md:43
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr "```toml\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n```"

#: src/ch02-00-guessing-game-tutorial.md:52
msgid ""
"As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for "
"you. Check out the _src/main.rs_ file:"
msgstr "1장에서 보았듯이 `cargo new`는 \"Hello, world!\" 프로그램을 생성합니다. _src/main.rs_ 파일을 확인하세요:"

#: src/ch02-00-guessing-game-tutorial.md:63
msgid ""
"Now let’s compile this “Hello, world!” program and run it in the same step "
"using the `cargo run` command:"
msgstr "이제 `cargo run` 명령을 사용하여 이 \"Hello, world!\" 프로그램을 컴파일하고 같은 단계에서 실행해 봅시다:"

#: src/ch02-00-guessing-game-tutorial.md:66
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s\n"     Running `target/debug/guessing_game`\nHello, world!\n```"
msgstr "```console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running `target/debug/guessing_game`\nHello, world!\n```"

#: src/ch02-00-guessing-game-tutorial.md:74
msgid ""
"The `run` command comes in handy when you need to rapidly iterate on a "
"project, as we’ll do in this game, quickly testing each iteration before "
"moving on to the next one."
msgstr "`run` 명령은 이 게임에서처럼 프로젝트를 빠르게 반복해야 할 때 유용합니다. 다음 반복으로 넘어가기 전에 각 반복을 빠르게 테스트합니다."

#: src/ch02-00-guessing-game-tutorial.md:78
msgid ""
"Reopen the _src/main.rs_ file. You’ll be writing all the code in this file."
msgstr "_src/main.rs_ 파일을 다시 여세요. 이 파일에 모든 코드를 작성할 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:80
msgid "Processing a Guess"
msgstr "추측 처리하기"

#: src/ch02-00-guessing-game-tutorial.md:82
msgid ""
"The first part of the guessing game program will ask for user input, process "
"that input, and check that the input is in the expected form. To start, "
"we’ll allow the player to input a guess. Enter the code in Listing 2-1 into "
"_src/main.rs_."
msgstr "추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고, 그 입력을 처리하고, 입력이 예상된 형식인지 확인합니다. 시작하려면, 플레이어가 추측을 입력하도록 허용할 것입니다. 목록 2-1의 코드를 _src/main.rs_에 입력하세요."

#: src/ch02-00-guessing-game-tutorial.md:93
#: src/ch02-00-guessing-game-tutorial.md:118
#: src/ch02-00-guessing-game-tutorial.md:148
#: src/ch02-00-guessing-game-tutorial.md:172
#: src/ch02-00-guessing-game-tutorial.md:197
#: src/ch02-00-guessing-game-tutorial.md:262
#: src/ch02-00-guessing-game-tutorial.md:315
#: src/ch02-00-guessing-game-tutorial.md:403
#: src/ch02-00-guessing-game-tutorial.md:665
#: src/ch02-00-guessing-game-tutorial.md:762
#: src/ch02-00-guessing-game-tutorial.md:885
#: src/ch02-00-guessing-game-tutorial.md:1008
#: src/ch02-00-guessing-game-tutorial.md:1104
#: src/ch02-00-guessing-game-tutorial.md:1156
#: src/ch02-00-guessing-game-tutorial.md:1265
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:296
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:349
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:389
#: src/ch09-03-to-panic-or-not-to-panic.md:157
#: src/ch20-03-advanced-types.md:227
msgid "\"Guess the number!\""
msgstr "\"숫자를 맞춰보세요!\""

#: src/ch02-00-guessing-game-tutorial.md:95
#: src/ch02-00-guessing-game-tutorial.md:120
#: src/ch02-00-guessing-game-tutorial.md:150
#: src/ch02-00-guessing-game-tutorial.md:174
#: src/ch02-00-guessing-game-tutorial.md:199
#: src/ch02-00-guessing-game-tutorial.md:264
#: src/ch02-00-guessing-game-tutorial.md:317
#: src/ch02-00-guessing-game-tutorial.md:405
#: src/ch02-00-guessing-game-tutorial.md:671
#: src/ch02-00-guessing-game-tutorial.md:768
#: src/ch02-00-guessing-game-tutorial.md:891
#: src/ch02-00-guessing-game-tutorial.md:1017
#: src/ch02-00-guessing-game-tutorial.md:1111
#: src/ch02-00-guessing-game-tutorial.md:1163
#: src/ch02-00-guessing-game-tutorial.md:1270
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:302
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:355
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:395
#: src/ch09-03-to-panic-or-not-to-panic.md:164
#: src/ch20-03-advanced-types.md:234
msgid "\"Please input your guess.\""
msgstr "추측을 입력하세요."

#: src/ch02-00-guessing-game-tutorial.md:101
#: src/ch02-00-guessing-game-tutorial.md:126
#: src/ch02-00-guessing-game-tutorial.md:156
#: src/ch02-00-guessing-game-tutorial.md:180
#: src/ch02-00-guessing-game-tutorial.md:205
#: src/ch02-00-guessing-game-tutorial.md:270
#: src/ch02-00-guessing-game-tutorial.md:323
#: src/ch02-00-guessing-game-tutorial.md:332
#: src/ch02-00-guessing-game-tutorial.md:411
#: src/ch02-00-guessing-game-tutorial.md:677
#: src/ch02-00-guessing-game-tutorial.md:774
#: src/ch02-00-guessing-game-tutorial.md:899
#: src/ch02-00-guessing-game-tutorial.md:1026
#: src/ch02-00-guessing-game-tutorial.md:1117
#: src/ch02-00-guessing-game-tutorial.md:1171
#: src/ch02-00-guessing-game-tutorial.md:1276 src/ch03-02-data-types.md:416
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:308
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:361
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:401
#: src/ch09-03-to-panic-or-not-to-panic.md:170
#: src/ch20-03-advanced-types.md:242
msgid "\"Failed to read line\""
msgstr "\"줄 읽기 실패\""

#: src/ch02-00-guessing-game-tutorial.md:103
#: src/ch02-00-guessing-game-tutorial.md:128
#: src/ch02-00-guessing-game-tutorial.md:158
#: src/ch02-00-guessing-game-tutorial.md:182
#: src/ch02-00-guessing-game-tutorial.md:207
#: src/ch02-00-guessing-game-tutorial.md:272
#: src/ch02-00-guessing-game-tutorial.md:325
#: src/ch02-00-guessing-game-tutorial.md:413
msgid "\"You guessed: {}\""
msgstr "\"당신의 추측: {}\""

#: src/ch02-00-guessing-game-tutorial.md:109
msgid ""
"This code contains a lot of information, so let’s go over it line by line. "
"To obtain user input and then print the result as output, we need to bring "
"the `io` input/output library into scope. The `io` library comes from the "
"standard library, known as `std`:"
msgstr "이 코드는 많은 정보를 담고 있으므로, 한 줄씩 살펴보겠습니다. 사용자 입력을 받고 그 결과를 출력으로 인쇄하려면, `io` 입출력 라이브러리를 스코프로 가져와야 합니다. `io` 라이브러리는 `std`로 알려진 표준 라이브러리에서 제공됩니다:"

#: src/ch02-00-guessing-game-tutorial.md:132
msgid ""
"By default, Rust has a set of items defined in the standard library that it "
"brings into the scope of every program. This set is called the _prelude_, "
"and you can see everything in it [in the standard library documentation](../"
"std/prelude/index.html)."
msgstr "기본적으로, 러스트는 모든 프로그램의 스코프로 가져오는 표준 라이브러리에 정의된 아이템 세트를 가지고 있습니다. 이 세트를 _프렐류드_라고 하며, [표준 라이브러리 문서](../std/prelude/index.html)에서 모든 것을 볼 수 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:136
msgid ""
"If a type you want to use isn’t in the prelude, you have to bring that type "
"into scope explicitly with a `use` statement. Using the `std::io` library "
"provides you with a number of useful features, including the ability to "
"accept user input."
msgstr "사용하려는 타입이 프렐류드에 없으면, `use` 문을 사용하여 해당 타입을 명시적으로 스코프로 가져와야 합니다. `std::io` 라이브러리를 사용하면 사용자 입력을 받는 기능을 포함하여 여러 유용한 기능을 사용할 수 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:141
msgid ""
"As you saw in Chapter 1, the `main` function is the entry point into the "
"program:"
msgstr "1장에서 보았듯이, `main` 함수는 프로그램의 진입점입니다:"

#: src/ch02-00-guessing-game-tutorial.md:162
msgid ""
"The `fn` syntax declares a new function; the parentheses, `()`, indicate "
"there are no parameters; and the curly bracket, `{`, starts the body of the "
"function."
msgstr "`fn` 구문은 새 함수를 선언하고, 괄호 `()`는 매개변수가 없음을 나타내며, 중괄호 `{`는 함수 본문의 시작을 나타냅니다."

#: src/ch02-00-guessing-game-tutorial.md:165
msgid ""
"As you also learned in Chapter 1, `println!` is a macro that prints a string "
"to the screen:"
msgstr "1장에서 배운 것처럼, `println!`은 화면에 문자열을 출력하는 매크로입니다:"

#: src/ch02-00-guessing-game-tutorial.md:186
msgid ""
"This code is printing a prompt stating what the game is and requesting input "
"from the user."
msgstr "이 코드는 게임이 무엇인지 알리고 사용자로부터 입력을 요청하는 프롬프트를 출력합니다."

#: src/ch02-00-guessing-game-tutorial.md:189
msgid "Storing Values with Variables"
msgstr "변수로 값 저장하기"

#: src/ch02-00-guessing-game-tutorial.md:191
msgid "Next, we’ll create a _variable_ to store the user input, like this:"
msgstr "다음으로, 사용자 입력을 저장할 _변수_를 다음과 같이 생성합니다:"

#: src/ch02-00-guessing-game-tutorial.md:211
msgid ""
"Now the program is getting interesting! There’s a lot going on in this "
"little line. We use the `let` statement to create the variable. Here’s "
"another example:"
msgstr "이제 프로그램이 흥미로워졌습니다! 이 작은 한 줄에 많은 일이 일어나고 있습니다. `let` 문을 사용하여 변수를 생성합니다. 다음은 또 다른 예입니다:"

#: src/ch02-00-guessing-game-tutorial.md:218
msgid ""
"This line creates a new variable named `apples` and binds it to the value 5. "
"In Rust, variables are immutable by default, meaning once we give the "
"variable a value, the value won’t change. We’ll be discussing this concept "
"in detail in the [“Variables and Mutability”](ch03-01-variables-and-"
"mutability.html#variables-and-mutability)<!-- ignore --> section in Chapter "
"3. To make a variable mutable, we add `mut` before the variable name:"
msgstr "이 줄은 `apples`라는 새 변수를 만들고 값 5에 바인딩합니다. 러스트에서 변수는 기본적으로 불변이므로, 일단 변수에 값을 주면 그 값은 변하지 않습니다. 이 개념에 대해서는 3장의 [“변수와 가변성”](ch03-01-variables-and-mutability.html#variables-and-mutability)<!-- ignore --> 섹션에서 자세히 다룰 것입니다. 변수를 가변으로 만들려면, 변수 이름 앞에 `mut`를 추가합니다:"

#: src/ch02-00-guessing-game-tutorial.md:226
msgid "// immutable\n"
msgstr "// 불변\n"

#: src/ch02-00-guessing-game-tutorial.md:227
msgid "// mutable\n"
msgstr "// 가변\n"

#: src/ch02-00-guessing-game-tutorial.md:230
msgid ""
"Note: The `//` syntax starts a comment that continues until the end of the "
"line. Rust ignores everything in comments. We’ll discuss comments in more "
"detail in [Chapter 3](ch03-04-comments.html)<!-- ignore -->."
msgstr "참고: `//` 구문은 줄 끝까지 계속되는 주석을 시작합니다. 러스트는 주석의 모든 것을 무시합니다. 주석에 대해서는 [3장](ch03-04-comments.html)<!-- ignore -->에서 더 자세히 다룰 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:234
msgid ""
"Returning to the guessing game program, you now know that `let mut guess` "
"will introduce a mutable variable named `guess`. The equal sign (`=`) tells "
"Rust we want to bind something to the variable now. On the right of the "
"equal sign is the value that `guess` is bound to, which is the result of "
"calling `String::new`, a function that returns a new instance of a `String`. "
"[`String`](../std/string/struct.String.html)<!-- ignore --> is a string type "
"provided by the standard library that is a growable, UTF-8 encoded bit of "
"text."
msgstr "추측 게임 프로그램으로 돌아가서, 이제 `let mut guess`가 `guess`라는 가변 변수를 도입한다는 것을 알게 되었습니다. 등호(`=`)는 러스트에게 지금 변수에 무언가를 바인딩하고 싶다고 알려줍니다. 등호 오른쪽에는 `guess`가 바인딩되는 값이 있는데, 이는 `String`의 새 인스턴스를 반환하는 함수인 `String::new`를 호출한 결과입니다. [`String`](../std/string/struct.String.html)<!-- ignore -->은 표준 라이브러리에서 제공하는 문자열 타입으로, 커질 수 있는 UTF-8 인코딩된 텍스트 조각입니다."

#: src/ch02-00-guessing-game-tutorial.md:242
msgid ""
"The `::` syntax in the `::new` line indicates that `new` is an associated "
"function of the `String` type. An _associated function_ is a function that’s "
"implemented on a type, in this case `String`. This `new` function creates a "
"new, empty string. You’ll find a `new` function on many types because it’s a "
"common name for a function that makes a new value of some kind."
msgstr "`::new` 줄의 `::` 구문은 `new`가 `String` 타입의 연관 함수임을 나타냅니다. _연관 함수_는 타입에 구현된 함수이며, 이 경우 `String`입니다. 이 `new` 함수는 새롭고 비어있는 문자열을 만듭니다. 많은 타입에서 `new` 함수를 찾을 수 있는데, 이는 어떤 종류의 새 값을 만드는 함수의 일반적인 이름이기 때문입니다."

#: src/ch02-00-guessing-game-tutorial.md:248
msgid ""
"In full, the `let mut guess = String::new();` line has created a mutable "
"variable that is currently bound to a new, empty instance of a `String`. "
"Whew!"
msgstr "전체적으로, `let mut guess = String::new();` 줄은 현재 `String`의 새롭고 비어있는 인스턴스에 바인딩된 가변 변수를 생성했습니다. 휴!"

#: src/ch02-00-guessing-game-tutorial.md:251
msgid "Receiving User Input"
msgstr "사용자 입력 받기"

#: src/ch02-00-guessing-game-tutorial.md:253
msgid ""
"Recall that we included the input/output functionality from the standard "
"library with `use std::io;` on the first line of the program. Now we’ll call "
"the `stdin` function from the `io` module, which will allow us to handle "
"user input:"
msgstr "프로그램의 첫 줄에 `use std::io;`로 표준 라이브러리에서 입출력 기능을 포함시켰던 것을 기억하세요. 이제 `io` 모듈에서 `stdin` 함수를 호출하여 사용자 입력을 처리할 수 있도록 할 것입니다:"

#: src/ch02-00-guessing-game-tutorial.md:276
msgid ""
"If we hadn’t imported the `io` library with `use std::io;` at the beginning "
"of the program, we could still use the function by writing this function "
"call as `std::io::stdin`. The `stdin` function returns an instance of "
"[`std::io::Stdin`](../std/io/struct.Stdin.html)<!-- ignore -->, which is a "
"type that represents a handle to the standard input for your terminal."
msgstr "만약 프로그램 시작 부분에 `use std::io;`로 `io` 라이브러리를 가져오지 않았다면, 이 함수 호출을 `std::io::stdin`으로 작성하여 함수를 계속 사용할 수 있습니다. `stdin` 함수는 터미널의 표준 입력을 나타내는 타입인 [`std::io::Stdin`](../std/io/struct.Stdin.html)<!-- ignore -->의 인스턴스를 반환합니다."

#: src/ch02-00-guessing-game-tutorial.md:282
msgid ""
"Next, the line `.read_line(&mut guess)` calls the [`read_line`](../std/io/"
"struct.Stdin.html#method.read_line)<!--\n"
"ignore --> method on the standard input handle to get input from the user. "
"We’re also passing `&mut guess` as the argument to `read_line` to tell it "
"what string to store the user input in. The full job of `read_line` is to "
"take whatever the user types into standard input and append that into a "
"string (without overwriting its contents), so we therefore pass that string "
"as an argument. The string argument needs to be mutable so the method can "
"change the string’s content."
msgstr "다음으로, `.read_line(&mut guess)` 줄은 표준 입력 핸들에서 [`read_line`](../std/io/struct.Stdin.html#method.read_line)<!--\n무시 --> 메서드를 호출하여 사용자로부터 입력을 받습니다. 또한 `read_line`에 `&mut guess`를 인수로 전달하여 사용자 입력을 저장할 문자열을 알려줍니다. `read_line`의 전체 작업은 사용자가 표준 입력에 입력하는 모든 것을 가져와 문자열에 추가하는 것(내용을 덮어쓰지 않고)이므로, 따라서 해당 문자열을 인수로 전달합니다. 메서드가 문자열의 내용을 변경할 수 있도록 문자열 인수는 가변적이어야 합니다."

#: src/ch02-00-guessing-game-tutorial.md:291
msgid ""
"The `&` indicates that this argument is a _reference_, which gives you a way "
"to let multiple parts of your code access one piece of data without needing "
"to copy that data into memory multiple times. References are a complex "
"feature, and one of Rust’s major advantages is how safe and easy it is to "
"use references. You don’t need to know a lot of those details to finish this "
"program. For now, all you need to know is that, like variables, references "
"are immutable by default. Hence, you need to write `&mut guess` rather than "
"`&guess` to make it mutable. (Chapter 4 will explain references more "
"thoroughly.)"
msgstr "`&`는 이 인수가 _참조_임을 나타내며, 이는 코드의 여러 부분이 데이터를 메모리에 여러 번 복사할 필요 없이 데이터 한 조각에 액세스할 수 있는 방법을 제공합니다. 참조는 복잡한 기능이며, 러스트의 주요 장점 중 하나는 참조를 사용하는 것이 얼마나 안전하고 쉬운가 하는 것입니다. 이 프로그램을 마치기 위해 이러한 세부 사항을 많이 알 필요는 없습니다. 지금은 변수와 마찬가지로 참조도 기본적으로 불변이라는 것만 알면 됩니다. 따라서 가변으로 만들려면 `&guess`가 아닌 `&mut guess`를 작성해야 합니다. (4장에서 참조에 대해 더 자세히 설명할 것입니다.)"

#: src/ch02-00-guessing-game-tutorial.md:303
msgid "<a id=\"handling-potential-failure-with-the-result-type\"></a>"
msgstr "<a id=\"handling-potential-failure-with-the-result-type\"></a>"

#: src/ch02-00-guessing-game-tutorial.md:305
msgid "Handling Potential Failure with `Result`"
msgstr "`Result`로 잠재적 실패 처리하기"

#: src/ch02-00-guessing-game-tutorial.md:307
msgid ""
"We’re still working on this line of code. We’re now discussing a third line "
"of text, but note that it’s still part of a single logical line of code. The "
"next part is this method:"
msgstr "우리는 아직 이 코드 라인에서 작업 중입니다. 이제 세 번째 텍스트 라인을 논의하고 있지만, 이것이 여전히 단일 논리적 코드 라인의 일부라는 점에 유의하세요. 다음 부분은 이 메서드입니다:"

#: src/ch02-00-guessing-game-tutorial.md:329
msgid "We could have written this code as:"
msgstr "이 코드를 다음과 같이 작성할 수도 있었습니다:"

#: src/ch02-00-guessing-game-tutorial.md:335
msgid ""
"However, one long line is difficult to read, so it’s best to divide it. It’s "
"often wise to introduce a newline and other whitespace to help break up long "
"lines when you call a method with the `.method_name()` syntax. Now let’s "
"discuss what this line does."
msgstr "그러나 한 줄이 길면 읽기 어려우므로 나누는 것이 가장 좋습니다. `.method_name()` 구문으로 메서드를 호출할 때 긴 줄을 나누는 데 도움이 되도록 줄 바꿈 및 기타 공백을 도입하는 것이 현명할 때가 많습니다. 이제 이 줄이 무엇을 하는지 논의해 보겠습니다."

#: src/ch02-00-guessing-game-tutorial.md:340
msgid ""
"As mentioned earlier, `read_line` puts whatever the user enters into the "
"string we pass to it, but it also returns a `Result` value. [`Result`](../"
"std/result/enum.Result.html)<!--\n"
"ignore --> is an [_enumeration_](ch06-00-enums.html)<!-- ignore -->, often "
"called an _enum_, which is a type that can be in one of multiple possible "
"states. We call each possible state a _variant_."
msgstr "앞서 언급했듯이, `read_line`은 사용자가 입력하는 모든 것을 우리가 전달하는 문자열에 넣지만, `Result` 값도 반환합니다. [`Result`](../std/result/enum.Result.html)<!--\n무시 -->는 종종 _열거형_이라고 불리는 [_열거형_](ch06-00-enums.html)<!-- 무시 -->이며, 여러 가능한 상태 중 하나일 수 있는 타입입니다. 우리는 각 가능한 상태를 _variant_라고 부릅니다."

#: src/ch02-00-guessing-game-tutorial.md:346
msgid ""
"[Chapter 6](ch06-00-enums.html)<!-- ignore --> will cover enums in more "
"detail. The purpose of these `Result` types is to encode error-handling "
"information."
msgstr "[6장](ch06-00-enums.html)<!-- ignore -->에서 열거형에 대해 더 자세히 다룰 것입니다. 이러한 `Result` 타입의 목적은 오류 처리 정보를 인코딩하는 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:349
msgid ""
"`Result`’s variants are `Ok` and `Err`. The `Ok` variant indicates the "
"operation was successful, and it contains the successfully generated value. "
"The `Err` variant means the operation failed, and it contains information "
"about how or why the operation failed."
msgstr "`Result`의 variant는 `Ok`와 `Err`입니다. `Ok` variant는 작업이 성공했음을 나타내며, 성공적으로 생성된 값을 포함합니다. `Err` variant는 작업이 실패했음을 의미하며, 작업이 실패한 방법이나 이유에 대한 정보를 포함합니다."

#: src/ch02-00-guessing-game-tutorial.md:354
msgid ""
"Values of the `Result` type, like values of any type, have methods defined "
"on them. An instance of `Result` has an [`expect` method](../std/result/"
"enum.Result.html#method.expect)<!-- ignore --> that you can call. If this "
"instance of `Result` is an `Err` value, `expect` will cause the program to "
"crash and display the message that you passed as an argument to `expect`. If "
"the `read_line` method returns an `Err`, it would likely be the result of an "
"error coming from the underlying operating system. If this instance of "
"`Result` is an `Ok` value, `expect` will take the return value that `Ok` is "
"holding and return just that value to you so you can use it. In this case, "
"that value is the number of bytes in the user’s input."
msgstr "`Result` 타입의 값은 다른 타입의 값과 마찬가지로 메서드가 정의되어 있습니다. `Result`의 인스턴스에는 호출할 수 있는 [`expect` 메서드](../std/result/enum.Result.html#method.expect)<!-- ignore -->가 있습니다. 이 `Result` 인스턴스가 `Err` 값이면, `expect`는 프로그램을 충돌시키고 `expect`에 인수로 전달한 메시지를 표시합니다. `read_line` 메서드가 `Err`를 반환하면, 이는 기본 운영 체제에서 발생하는 오류의 결과일 가능성이 높습니다. 이 `Result` 인스턴스가 `Ok` 값이면, `expect`는 `Ok`가 가지고 있는 반환 값을 가져와서 사용할 수 있도록 해당 값만 반환합니다. 이 경우, 그 값은 사용자 입력의 바이트 수입니다."

#: src/ch02-00-guessing-game-tutorial.md:364
msgid ""
"If you don’t call `expect`, the program will compile, but you’ll get a "
"warning:"
msgstr "`expect`를 호출하지 않으면 프로그램은 컴파일되지만, 경고가 표시됩니다:"

#: src/ch02-00-guessing-game-tutorial.md:366
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"warning: unused `Result` that must be used\n"
"  --> src/main.rs:10:5\n"
"   |\n"
"10 |     io::stdin().read_line(&mut guess);\n"
"   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"   |\n"
"   = note: this `Result` may be an `Err` variant, which should be handled\n"
"   = note: `#[warn(unused_must_use)]` on by default\n"
"help: use `let _ = ...` to ignore the resulting value\n"
"   |\n"
"10 |     let _ = io::stdin().read_line(&mut guess);\n"
"   |     +++++++\n"
"\n"
"warning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s\n"
"```"
msgstr "```console\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nwarning: unused `Result` that must be used\n  --> src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&mut guess);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n10 |     let _ = io::stdin().read_line(&mut guess);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s\n```"

#: src/ch02-00-guessing-game-tutorial.md:386
msgid ""
"Rust warns that you haven’t used the `Result` value returned from "
"`read_line`, indicating that the program hasn’t handled a possible error."
msgstr "러스트는 `read_line`에서 반환된 `Result` 값을 사용하지 않았다고 경고하며, 이는 프로그램이 가능한 오류를 처리하지 않았음을 나타냅니다."

#: src/ch02-00-guessing-game-tutorial.md:389
msgid ""
"The right way to suppress the warning is to actually write error-handling "
"code, but in our case we just want to crash this program when a problem "
"occurs, so we can use `expect`. You’ll learn about recovering from errors in "
"[Chapter 9](ch09-02-recoverable-errors-with-result.html)<!-- ignore -->."
msgstr "경고를 억제하는 올바른 방법은 실제로 오류 처리 코드를 작성하는 것이지만, 이 경우에는 문제가 발생했을 때 프로그램을 충돌시키고 싶기 때문에 `expect`를 사용할 수 있습니다. 오류로부터 복구하는 방법에 대해서는 [9장](ch09-02-recoverable-errors-with-result.html)<!-- ignore -->에서 배울 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:394
msgid "Printing Values with `println!` Placeholders"
msgstr "`println!` 플레이스홀더로 값 출력하기"

#: src/ch02-00-guessing-game-tutorial.md:396
msgid ""
"Aside from the closing curly bracket, there’s only one more line to discuss "
"in the code so far:"
msgstr "닫는 중괄호를 제외하고, 지금까지 코드에서 논의할 줄은 한 줄 더 있습니다:"

#: src/ch02-00-guessing-game-tutorial.md:417
msgid ""
"This line prints the string that now contains the user’s input. The `{}` set "
"of curly brackets is a placeholder: think of `{}` as little crab pincers "
"that hold a value in place. When printing the value of a variable, the "
"variable name can go inside the curly brackets. When printing the result of "
"evaluating an expression, place empty curly brackets in the format string, "
"then follow the format string with a comma-separated list of expressions to "
"print in each empty curly bracket placeholder in the same order. Printing a "
"variable and the result of an expression in one call to `println!` would "
"look like this:"
msgstr "이 줄은 이제 사용자 입력을 포함하는 문자열을 출력합니다. `{}` 중괄호 세트는 플레이스홀더입니다: `{}`를 값을 제자리에 고정하는 작은 게 집게라고 생각하세요. 변수 값을 출력할 때, 변수 이름은 중괄호 안에 들어갈 수 있습니다. 표현식 평가 결과를 출력할 때, 형식 문자열에 빈 중괄호를 넣은 다음, 형식 문자열 뒤에 쉼표로 구분된 표현식 목록을 각 빈 중괄호 플레이스홀더에 같은 순서로 출력합니다. `println!` 한 번의 호출로 변수와 표현식 결과를 출력하는 것은 다음과 같습니다:"

#: src/ch02-00-guessing-game-tutorial.md:430
msgid "\"x = {x} and y + 2 = {}\""
msgstr "\"x = {x} and y + 2 = {}\""

#: src/ch02-00-guessing-game-tutorial.md:433
msgid "This code would print `x = 5 and y + 2 = 12`."
msgstr "이 코드는 `x = 5 and y + 2 = 12`를 출력할 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:435
msgid "Testing the First Part"
msgstr "첫 번째 부분 테스트하기"

#: src/ch02-00-guessing-game-tutorial.md:437
msgid ""
"Let’s test the first part of the guessing game. Run it using `cargo run`:"
msgstr "추측 게임의 첫 번째 부분을 테스트해 봅시다. `cargo run`을 사용하여 실행하세요:"

#: src/ch02-00-guessing-game-tutorial.md:445
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"Please input your guess.\n"
"6\n"
"You guessed: 6\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:456
msgid ""
"At this point, the first part of the game is done: we’re getting input from "
"the keyboard and then printing it."
msgstr "이 시점에서 게임의 첫 번째 부분이 완료되었습니다: 키보드에서 입력을 받아 출력하고 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:459
msgid "Generating a Secret Number"
msgstr "비밀 번호 생성하기"

#: src/ch02-00-guessing-game-tutorial.md:461
msgid ""
"Next, we need to generate a secret number that the user will try to guess. "
"The secret number should be different every time so the game is fun to play "
"more than once. We’ll use a random number between 1 and 100 so the game "
"isn’t too difficult. Rust doesn’t yet include random number functionality in "
"its standard library. However, the Rust team does provide a [`rand` crate]"
"(https://crates.io/crates/rand) with said functionality."
msgstr "다음으로, 사용자가 추측할 비밀 번호를 생성해야 합니다. 게임을 여러 번 즐길 수 있도록 비밀 번호는 매번 달라야 합니다. 게임이 너무 어렵지 않도록 1에서 100 사이의 난수를 사용할 것입니다. 러스트는 아직 표준 라이브러리에 난수 기능을 포함하고 있지 않습니다. 그러나 러스트 팀은 해당 기능을 가진 [`rand` 크레이트](https://crates.io/crates/rand)를 제공합니다."

#: src/ch02-00-guessing-game-tutorial.md:468
msgid "Using a Crate to Get More Functionality"
msgstr "크레이트를 사용하여 더 많은 기능 얻기"

#: src/ch02-00-guessing-game-tutorial.md:470
msgid ""
"Remember that a crate is a collection of Rust source code files. The project "
"we’ve been building is a _binary crate_, which is an executable. The `rand` "
"crate is a _library crate_, which contains code that is intended to be used "
"in other programs and can’t be executed on its own."
msgstr "크레이트는 러스트 소스 코드 파일의 모음이라는 것을 기억하세요. 우리가 빌드해 온 프로젝트는 실행 파일인 _바이너리 크레이트_입니다. `rand` 크레이트는 다른 프로그램에서 사용하도록 의도된 코드를 포함하고 자체적으로 실행할 수 없는 _라이브러리 크레이트_입니다."

#: src/ch02-00-guessing-game-tutorial.md:475
msgid ""
"Cargo’s coordination of external crates is where Cargo really shines. Before "
"we can write code that uses `rand`, we need to modify the _Cargo.toml_ file "
"to include the `rand` crate as a dependency. Open that file now and add the "
"following line to the bottom, beneath the `[dependencies]` section header "
"that Cargo created for you. Be sure to specify `rand` exactly as we have "
"here, with this version number, or the code examples in this tutorial may "
"not work:"
msgstr "Cargo의 외부 크레이트 조정은 Cargo가 정말 빛을 발하는 부분입니다. `rand`를 사용하는 코드를 작성하기 전에, `rand` 크레이트를 의존성으로 포함하도록 _Cargo.toml_ 파일을 수정해야 합니다. 지금 그 파일을 열고 Cargo가 생성한 `[dependencies]` 섹션 헤더 아래 맨 아래에 다음 줄을 추가하세요. 여기에 있는 버전 번호와 정확히 동일하게 `rand`를 지정해야 합니다. 그렇지 않으면 이 튜토리얼의 코드 예제가 작동하지 않을 수 있습니다:"

#: src/ch02-00-guessing-game-tutorial.md:490
#: src/ch14-03-cargo-workspaces.md:229
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.8.5\"\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.8.5\"\n"
"```"

#: src/ch02-00-guessing-game-tutorial.md:495
msgid ""
"In the _Cargo.toml_ file, everything that follows a header is part of that "
"section that continues until another section starts. In `[dependencies]` you "
"tell Cargo which external crates your project depends on and which versions "
"of those crates you require. In this case, we specify the `rand` crate with "
"the semantic version specifier `0.8.5`. Cargo understands [Semantic "
"Versioning](http://semver.org)<!-- ignore --> (sometimes called _SemVer_), "
"which is a standard for writing version numbers. The specifier `0.8.5` is "
"actually shorthand for `^0.8.5`, which means any version that is at least "
"0.8.5 but below 0.9.0."
msgstr "_Cargo.toml_ 파일에서 헤더 뒤에 오는 모든 것은 다른 섹션이 시작될 때까지 해당 섹션의 일부입니다. `[dependencies]`에서 Cargo에게 프로젝트가 의존하는 외부 크레이트와 필요한 크레이트의 버전을 알려줍니다. 이 경우, 우리는 의미론적 버전 지정자 `0.8.5`로 `rand` 크레이트를 지정합니다. Cargo는 버전 번호를 작성하는 표준인 [의미론적 버전 관리](http://semver.org)<!-- ignore --> (때로는 _SemVer_라고도 함)를 이해합니다. 지정자 `0.8.5`는 실제로는 `^0.8.5`의 약식이며, 이는 0.8.5 이상이지만 0.9.0 미만인 모든 버전을 의미합니다."

#: src/ch02-00-guessing-game-tutorial.md:505
msgid ""
"Cargo considers these versions to have public APIs compatible with version "
"0.8.5, and this specification ensures you’ll get the latest patch release "
"that will still compile with the code in this chapter. Any version 0.9.0 or "
"greater is not guaranteed to have the same API as what the following "
"examples use."
msgstr "Cargo는 이러한 버전이 0.8.5 버전과 호환되는 공개 API를 가지고 있다고 간주하며, 이 사양은 이 장의 코드와 여전히 컴파일될 최신 패치 릴리스를 얻을 수 있도록 보장합니다. 0.9.0 이상의 모든 버전은 다음 예제에서 사용하는 것과 동일한 API를 가지고 있다고 보장되지 않습니다."

#: src/ch02-00-guessing-game-tutorial.md:510
msgid ""
"Now, without changing any of the code, let’s build the project, as shown in "
"Listing 2-2."
msgstr "이제 코드를 변경하지 않고, 목록 2-2와 같이 프로젝트를 빌드해 보겠습니다."

#: src/ch02-00-guessing-game-tutorial.md:521
msgid ""
"```console\n"
"$ cargo build\n"
"    Updating crates.io index\n"
"     Locking 16 packages to latest compatible versions\n"
"      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: "
"v0.13.3+wasi-0.2.2)\n"
"      Adding zerocopy v0.7.35 (latest: v0.8.9)\n"
"      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)\n"
"  Downloaded syn v2.0.87\n"
"  Downloaded 1 crate (278.1 KB) in 0.16s\n"
"   Compiling proc-macro2 v1.0.89\n"
"   Compiling unicode-ident v1.0.13\n"
"   Compiling libc v0.2.161\n"
"   Compiling cfg-if v1.0.0\n"
"   Compiling byteorder v1.5.0\n"
"   Compiling getrandom v0.2.15\n"
"   Compiling rand_core v0.6.4\n"
"   Compiling quote v1.0.37\n"
"   Compiling syn v2.0.87\n"
"   Compiling zerocopy-derive v0.7.35\n"
"   Compiling zerocopy v0.7.35\n"
"   Compiling ppv-lite86 v0.2.20\n"
"   Compiling rand_chacha v0.3.1\n"
"   Compiling rand v0.8.5\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:550
msgid ""
"You may see different version numbers (but they will all be compatible with "
"the code, thanks to SemVer!) and different lines (depending on the operating "
"system), and the lines may be in a different order."
msgstr "다른 버전 번호(하지만 SemVer 덕분에 모두 코드와 호환됩니다!)와 다른 줄(운영 체제에 따라 다름)이 표시될 수 있으며, 줄 순서가 다를 수 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:554
msgid ""
"When we include an external dependency, Cargo fetches the latest versions of "
"everything that dependency needs from the _registry_, which is a copy of "
"data from [Crates.io](https://crates.io/). Crates.io is where people in the "
"Rust ecosystem post their open source Rust projects for others to use."
msgstr "외부 의존성을 포함하면, Cargo는 해당 의존성이 필요로 하는 모든 것의 최신 버전을 _레지스트리_에서 가져옵니다. 레지스트리는 [Crates.io](https://crates.io/)의 데이터 사본입니다. Crates.io는 러스트 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 러스트 프로젝트를 게시하는 곳입니다."

#: src/ch02-00-guessing-game-tutorial.md:559
msgid ""
"After updating the registry, Cargo checks the `[dependencies]` section and "
"downloads any crates listed that aren’t already downloaded. In this case, "
"although we only listed `rand` as a dependency, Cargo also grabbed other "
"crates that `rand` depends on to work. After downloading the crates, Rust "
"compiles them and then compiles the project with the dependencies available."
msgstr "레지스트리를 업데이트한 후, Cargo는 `[dependencies]` 섹션을 확인하고 아직 다운로드되지 않은 모든 크레이트를 다운로드합니다. 이 경우, 우리는 `rand`만 의존성으로 나열했지만, Cargo는 `rand`가 작동하는 데 의존하는 다른 크레이트도 가져왔습니다. 크레이트를 다운로드한 후, 러스트는 그것들을 컴파일한 다음 사용 가능한 의존성으로 프로젝트를 컴파일합니다."

#: src/ch02-00-guessing-game-tutorial.md:565
msgid ""
"If you immediately run `cargo build` again without making any changes, you "
"won’t get any output aside from the `Finished` line. Cargo knows it has "
"already downloaded and compiled the dependencies, and you haven’t changed "
"anything about them in your _Cargo.toml_ file. Cargo also knows that you "
"haven’t changed anything about your code, so it doesn’t recompile that "
"either. With nothing to do, it simply exits."
msgstr "변경 사항 없이 즉시 `cargo build`를 다시 실행하면, `Finished` 줄 외에는 아무런 출력도 얻지 못할 것입니다. Cargo는 이미 의존성을 다운로드하고 컴파일했으며, _Cargo.toml_ 파일에서 의존성에 대해 아무것도 변경하지 않았다는 것을 알고 있습니다. Cargo는 또한 코드에 대해 아무것도 변경하지 않았다는 것을 알고 있으므로, 그것도 다시 컴파일하지 않습니다. 할 일이 없으면, 그냥 종료됩니다."

#: src/ch02-00-guessing-game-tutorial.md:572
msgid ""
"If you open the _src/main.rs_ file, make a trivial change, and then save it "
"and build again, you’ll only see two lines of output:"
msgstr "_src/main.rs_ 파일을 열고, 사소한 변경을 한 다음, 저장하고 다시 빌드하면, 두 줄의 출력만 보게 될 것입니다:"

#: src/ch02-00-guessing-game-tutorial.md:580
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:586
msgid ""
"These lines show that Cargo only updates the build with your tiny change to "
"the _src/main.rs_ file. Your dependencies haven’t changed, so Cargo knows it "
"can reuse what it has already downloaded and compiled for those."
msgstr "이 줄들은 Cargo가 _src/main.rs_ 파일에 대한 작은 변경 사항으로만 빌드를 업데이트한다는 것을 보여줍니다. 의존성은 변경되지 않았으므로, Cargo는 이미 다운로드하고 컴파일한 것을 재사용할 수 있다는 것을 알고 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:590
msgid "Ensuring Reproducible Builds with the _Cargo.lock_ File"
msgstr "_Cargo.lock_ 파일로 재현 가능한 빌드 보장하기"

#: src/ch02-00-guessing-game-tutorial.md:592
msgid ""
"Cargo has a mechanism that ensures you can rebuild the same artifact every "
"time you or anyone else builds your code: Cargo will use only the versions "
"of the dependencies you specified until you indicate otherwise. For example, "
"say that next week version 0.8.6 of the `rand` crate comes out, and that "
"version contains an important bug fix, but it also contains a regression "
"that will break your code. To handle this, Rust creates the _Cargo.lock_ "
"file the first time you run `cargo build`, so we now have this in the "
"_guessing_game_ directory."
msgstr "Cargo에는 당신이나 다른 사람이 코드를 빌드할 때마다 동일한 아티팩트를 다시 빌드할 수 있도록 보장하는 메커니즘이 있습니다: Cargo는 당신이 달리 명시할 때까지 지정한 의존성 버전만 사용합니다. 예를 들어, 다음 주에 `rand` 크레이트의 0.8.6 버전이 나오고, 그 버전에 중요한 버그 수정이 포함되어 있지만, 코드를 손상시키는 회귀도 포함되어 있다고 가정해 보겠습니다. 이를 처리하기 위해, 러스트는 `cargo build`를 처음 실행할 때 _Cargo.lock_ 파일을 생성하므로, 이제 _guessing_game_ 디렉토리에 이 파일이 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:601
msgid ""
"When you build a project for the first time, Cargo figures out all the "
"versions of the dependencies that fit the criteria and then writes them to "
"the _Cargo.lock_ file. When you build your project in the future, Cargo will "
"see that the _Cargo.lock_ file exists and will use the versions specified "
"there rather than doing all the work of figuring out versions again. This "
"lets you have a reproducible build automatically. In other words, your "
"project will remain at 0.8.5 until you explicitly upgrade, thanks to the "
"_Cargo.lock_ file. Because the _Cargo.lock_ file is important for "
"reproducible builds, it’s often checked into source control with the rest of "
"the code in your project."
msgstr "프로젝트를 처음 빌드할 때, Cargo는 기준에 맞는 모든 의존성 버전을 파악한 다음 _Cargo.lock_ 파일에 씁니다. 나중에 프로젝트를 빌드할 때, Cargo는 _Cargo.lock_ 파일이 존재하는 것을 보고 버전 파악 작업을 다시 수행하는 대신 거기에 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 가질 수 있습니다. 즉, _Cargo.lock_ 파일 덕분에 명시적으로 업그레이드할 때까지 프로젝트는 0.8.5 버전에 머물러 있을 것입니다. _Cargo.lock_ 파일은 재현 가능한 빌드에 중요하기 때문에, 종종 프로젝트의 나머지 코드와 함께 소스 제어에 체크인됩니다."

#: src/ch02-00-guessing-game-tutorial.md:611
msgid "Updating a Crate to Get a New Version"
msgstr "새 버전을 얻기 위해 크레이트 업데이트하기"

#: src/ch02-00-guessing-game-tutorial.md:613
msgid ""
"When you _do_ want to update a crate, Cargo provides the command `update`, "
"which will ignore the _Cargo.lock_ file and figure out all the latest "
"versions that fit your specifications in _Cargo.toml_. Cargo will then write "
"those versions to the _Cargo.lock_ file. In this case, Cargo will only look "
"for versions greater than 0.8.5 and less than 0.9.0. If the `rand` crate has "
"released the two new versions 0.8.6 and 0.9.0, you would see the following "
"if you ran `cargo update`:"
msgstr "크레이트를 업데이트하고 싶을 때, Cargo는 `update` 명령을 제공합니다. 이 명령은 _Cargo.lock_ 파일을 무시하고 _Cargo.toml_의 사양에 맞는 모든 최신 버전을 파악합니다. 그런 다음 Cargo는 해당 버전을 _Cargo.lock_ 파일에 씁니다. 이 경우, Cargo는 0.8.5보다 크고 0.9.0보다 작은 버전만 찾습니다. `rand` 크레이트가 0.8.6과 0.9.0이라는 두 가지 새 버전을 출시했다면, `cargo update`를 실행하면 다음과 같이 표시됩니다:"

#: src/ch02-00-guessing-game-tutorial.md:633
msgid ""
"Cargo ignores the 0.9.0 release. At this point, you would also notice a "
"change in your _Cargo.lock_ file noting that the version of the `rand` crate "
"you are now using is 0.8.6. To use `rand` version 0.9.0 or any version in "
"the 0.9._x_ series, you’d have to update the _Cargo.toml_ file to look like "
"this instead:"
msgstr "Cargo는 0.9.0 릴리스를 무시합니다. 이 시점에서, 당신은 또한 _Cargo.lock_ 파일에서 현재 사용하고 있는 `rand` 크레이트의 버전이 0.8.6이라는 변경 사항을 발견하게 될 것입니다. `rand` 버전 0.9.0 또는 0.9._x_ 시리즈의 버전을 사용하려면, 대신 _Cargo.toml_ 파일을 다음과 같이 업데이트해야 합니다:"

#: src/ch02-00-guessing-game-tutorial.md:638
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.9.0\"\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"rand = \"0.9.0\"\n"
"```"

#: src/ch02-00-guessing-game-tutorial.md:643
msgid ""
"The next time you run `cargo build`, Cargo will update the registry of "
"crates available and reevaluate your `rand` requirements according to the "
"new version you have specified."
msgstr "다음에 `cargo build`를 실행하면, Cargo는 사용 가능한 크레이트의 레지스트리를 업데이트하고 지정한 새 버전에 따라 `rand` 요구 사항을 다시 평가합니다."

#: src/ch02-00-guessing-game-tutorial.md:647
msgid ""
"There’s a lot more to say about [Cargo](https://doc.rust-lang.org/"
"cargo/)<!-- ignore --> and [its ecosystem](https://doc.rust-lang.org/cargo/"
"reference/publishing.html)<!-- ignore -->, which we’ll discuss in Chapter "
"14, but for now, that’s all you need to know. Cargo makes it very easy to "
"reuse libraries, so Rustaceans are able to write smaller projects that are "
"assembled from a number of packages."
msgstr "[Cargo](https://doc.rust-lang.org/cargo/)<!-- ignore -->와 [그 생태계](https://doc.rust-lang.org/cargo/reference/publishing.html)<!-- ignore -->에 대해 할 말이 더 많지만, 14장에서 논의할 것이고, 지금은 이것만 알면 됩니다. Cargo는 라이브러리를 매우 쉽게 재사용할 수 있게 해주므로, 러스트 개발자들은 여러 패키지로 조립된 더 작은 프로젝트를 작성할 수 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:653
msgid "Generating a Random Number"
msgstr "난수 생성하기"

#: src/ch02-00-guessing-game-tutorial.md:655
msgid ""
"Let’s start using `rand` to generate a number to guess. The next step is to "
"update _src/main.rs_, as shown in Listing 2-3."
msgstr "`rand`를 사용하여 추측할 숫자를 생성해 보겠습니다. 다음 단계는 목록 2-3과 같이 _src/main.rs_를 업데이트하는 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:669
#: src/ch02-00-guessing-game-tutorial.md:766
#: src/ch02-00-guessing-game-tutorial.md:889
#: src/ch02-00-guessing-game-tutorial.md:1014
#: src/ch02-00-guessing-game-tutorial.md:1108
#: src/ch02-00-guessing-game-tutorial.md:1160
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:300
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:353
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:393
#: src/ch20-03-advanced-types.md:231
msgid "\"The secret number is: {secret_number}\""
msgstr "\"비밀 번호는: {secret_number}\""

#: src/ch02-00-guessing-game-tutorial.md:679
#: src/ch02-00-guessing-game-tutorial.md:776
#: src/ch02-00-guessing-game-tutorial.md:903
#: src/ch02-00-guessing-game-tutorial.md:1030
#: src/ch02-00-guessing-game-tutorial.md:1121
#: src/ch02-00-guessing-game-tutorial.md:1178
#: src/ch02-00-guessing-game-tutorial.md:1283
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:310
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:363
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:405
#: src/ch20-03-advanced-types.md:249
msgid "\"You guessed: {guess}\""
msgstr "\"당신의 추측: {guess}\""

#: src/ch02-00-guessing-game-tutorial.md:685
msgid ""
"First we add the line `use rand::Rng;`. The `Rng` trait defines methods that "
"random number generators implement, and this trait must be in scope for us "
"to use those methods. Chapter 10 will cover traits in detail."
msgstr "먼저 `use rand::Rng;` 줄을 추가합니다. `Rng` 트레이트는 난수 생성기가 구현하는 메서드를 정의하며, 이 트레이트는 해당 메서드를 사용하기 위해 스코프 내에 있어야 합니다. 10장에서 트레이트에 대해 자세히 다룰 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:689
msgid ""
"Next, we’re adding two lines in the middle. In the first line, we call the "
"`rand::thread_rng` function that gives us the particular random number "
"generator we’re going to use: one that is local to the current thread of "
"execution and is seeded by the operating system. Then we call the "
"`gen_range` method on the random number generator. This method is defined by "
"the `Rng` trait that we brought into scope with the `use rand::Rng;` "
"statement. The `gen_range` method takes a range expression as an argument "
"and generates a random number in the range. The kind of range expression "
"we’re using here takes the form `start..=end` and is inclusive on the lower "
"and upper bounds, so we need to specify `1..=100` to request a number "
"between 1 and 100."
msgstr "다음으로, 중간에 두 줄을 추가합니다. 첫 번째 줄에서는, 우리가 사용할 특정 난수 생성기를 제공하는 `rand::thread_rng` 함수를 호출합니다: 현재 실행 스레드에 로컬이며 운영 체제에 의해 시드됩니다. 그런 다음 난수 생성기에서 `gen_range` 메서드를 호출합니다. 이 메서드는 `use rand::Rng;` 문으로 스코프에 가져온 `Rng` 트레이트에 의해 정의됩니다. `gen_range` 메서드는 범위 표현식을 인수로 사용하고 범위 내에서 난수를 생성합니다. 여기서 사용하는 범위 표현식의 종류는 `start..=end` 형식을 취하며 하한과 상한을 포함하므로, 1에서 100 사이의 숫자를 요청하려면 `1..=100`을 지정해야 합니다."

#: src/ch02-00-guessing-game-tutorial.md:700
msgid ""
"Note: You won’t just know which traits to use and which methods and "
"functions to call from a crate, so each crate has documentation with "
"instructions for using it. Another neat feature of Cargo is that running the "
"`cargo doc --open` command will build documentation provided by all your "
"dependencies locally and open it in your browser. If you’re interested in "
"other functionality in the `rand` crate, for example, run `cargo doc --open` "
"and click `rand` in the sidebar on the left."
msgstr "참고: 어떤 트레이트를 사용해야 하고, 어떤 메서드와 함수를 크레이트에서 호출해야 하는지 그냥 알 수는 없으므로, 각 크레이트에는 사용 지침이 포함된 문서가 있습니다. Cargo의 또 다른 멋진 기능은 `cargo doc --open` 명령을 실행하면 모든 의존성에서 제공하는 문서를 로컬에서 빌드하고 브라우저에서 열어준다는 것입니다. 예를 들어, `rand` 크레이트의 다른 기능에 관심이 있다면, `cargo doc --open`을 실행하고 왼쪽 사이드바에서 `rand`를 클릭하세요."

#: src/ch02-00-guessing-game-tutorial.md:708
msgid ""
"The second new line prints the secret number. This is useful while we’re "
"developing the program to be able to test it, but we’ll delete it from the "
"final version. It’s not much of a game if the program prints the answer as "
"soon as it starts!"
msgstr "두 번째 새 줄은 비밀 번호를 출력합니다. 이것은 프로그램을 개발하는 동안 테스트할 수 있도록 유용하지만, 최종 버전에서는 삭제할 것입니다. 프로그램이 시작하자마자 답을 출력하면 게임이 별로 재미없으니까요!"

#: src/ch02-00-guessing-game-tutorial.md:713
msgid "Try running the program a few times:"
msgstr "프로그램을 몇 번 실행해보세요:"

#: src/ch02-00-guessing-game-tutorial.md:723
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 7\n"
"Please input your guess.\n"
"4\n"
"You guessed: 4\n"
"\n"
"$ cargo run\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 83\n"
"Please input your guess.\n"
"5\n"
"You guessed: 5\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:744
msgid ""
"You should get different random numbers, and they should all be numbers "
"between 1 and 100. Great job!"
msgstr "다른 난수를 얻어야 하며, 모두 1에서 100 사이의 숫자여야 합니다. 잘했습니다!"

#: src/ch02-00-guessing-game-tutorial.md:747
msgid "Comparing the Guess to the Secret Number"
msgstr "추측을 비밀 번호와 비교하기"

#: src/ch02-00-guessing-game-tutorial.md:749
msgid ""
"Now that we have user input and a random number, we can compare them. That "
"step is shown in Listing 2-4. Note that this code won’t compile just yet, as "
"we will explain."
msgstr "이제 사용자 입력과 난수가 있으므로 비교할 수 있습니다. 그 단계는 목록 2-4에 나와 있습니다. 설명하겠지만, 이 코드는 아직 컴파일되지 않습니다."

#: src/ch02-00-guessing-game-tutorial.md:761
#: src/ch02-00-guessing-game-tutorial.md:893
#: src/ch02-00-guessing-game-tutorial.md:1012
#: src/ch02-00-guessing-game-tutorial.md:1019
#: src/ch02-00-guessing-game-tutorial.md:1123
#: src/ch02-00-guessing-game-tutorial.md:1167
#: src/ch02-00-guessing-game-tutorial.md:1180
#: src/ch05-01-defining-structs.md:203 src/ch05-01-defining-structs.md:238
#: src/ch06-01-defining-an-enum.md:208 src/ch06-01-defining-an-enum.md:212
#: src/ch06-02-match.md:123 src/ch06-02-match.md:153 src/ch06-03-if-let.md:71
#: src/ch06-03-if-let.md:98 src/ch06-03-if-let.md:132 src/ch06-03-if-let.md:181
#: src/ch06-03-if-let.md:236 src/ch06-03-if-let.md:301
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:165
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:170
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:196
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:201
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:342
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:345
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:383
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:385
#: src/ch09-03-to-panic-or-not-to-panic.md:162
#: src/ch09-03-to-panic-or-not-to-panic.md:183 src/ch10-02-traits.md:642
#: src/ch11-01-writing-tests.md:407 src/ch11-01-writing-tests.md:471
#: src/ch11-01-writing-tests.md:914 src/ch11-01-writing-tests.md:981
#: src/ch12-02-reading-a-file.md:36
#: src/ch12-03-improving-error-handling-and-modularity.md:84
#: src/ch12-03-improving-error-handling-and-modularity.md:155
#: src/ch12-03-improving-error-handling-and-modularity.md:252
#: src/ch12-03-improving-error-handling-and-modularity.md:254
#: src/ch12-03-improving-error-handling-and-modularity.md:332
#: src/ch12-03-improving-error-handling-and-modularity.md:337
#: src/ch12-03-improving-error-handling-and-modularity.md:480
#: src/ch12-03-improving-error-handling-and-modularity.md:566
#: src/ch12-03-improving-error-handling-and-modularity.md:587
#: src/ch12-03-improving-error-handling-and-modularity.md:632
#: src/ch12-03-improving-error-handling-and-modularity.md:760
#: src/ch12-03-improving-error-handling-and-modularity.md:846
#: src/ch12-03-improving-error-handling-and-modularity.md:859
#: src/ch12-03-improving-error-handling-and-modularity.md:886
#: src/ch12-03-improving-error-handling-and-modularity.md:898
#: src/ch12-05-working-with-environment-variables.md:496
#: src/ch13-03-improving-our-io-project.md:165
#: src/ch13-03-improving-our-io-project.md:192
#: src/ch13-03-improving-our-io-project.md:230
#: src/ch14-02-publishing-to-crates-io.md:232
#: src/ch14-02-publishing-to-crates-io.md:297
#: src/ch14-02-publishing-to-crates-io.md:314
#: src/ch14-02-publishing-to-crates-io.md:347
#: src/ch15-05-interior-mutability.md:411 src/ch16-02-message-passing.md:303
#: src/ch16-02-message-passing.md:340 src/ch17-03-more-futures.md:548
#: src/ch17-03-more-futures.md:563 src/ch17-03-more-futures.md:570
#: src/ch17-03-more-futures.md:1127 src/ch18-03-oo-design-patterns.md:157
#: src/ch18-03-oo-design-patterns.md:207 src/ch18-03-oo-design-patterns.md:250
#: src/ch18-03-oo-design-patterns.md:357 src/ch18-03-oo-design-patterns.md:394
#: src/ch18-03-oo-design-patterns.md:407 src/ch18-03-oo-design-patterns.md:457
#: src/ch18-03-oo-design-patterns.md:472 src/ch18-03-oo-design-patterns.md:595
#: src/ch18-03-oo-design-patterns.md:603 src/ch18-03-oo-design-patterns.md:633
#: src/ch18-03-oo-design-patterns.md:856 src/ch20-02-advanced-traits.md:68
#: src/ch20-03-advanced-types.md:93 src/ch20-03-advanced-types.md:97
#: src/ch20-03-advanced-types.md:118 src/ch20-03-advanced-types.md:122
#: src/ch20-03-advanced-types.md:206 src/ch20-03-advanced-types.md:238
#: src/ch20-03-advanced-types.md:251 src/ch20-03-advanced-types.md:402
#: src/ch20-03-advanced-types.md:410 src/ch20-03-advanced-types.md:420
#: src/ch20-05-macros.md:378 src/ch21-01-single-threaded.md:392
#: src/ch21-01-single-threaded.md:474 src/ch21-01-single-threaded.md:557
#: src/ch21-01-single-threaded.md:630 src/ch21-01-single-threaded.md:634
#: src/ch21-02-multithreaded.md:27 src/ch21-02-multithreaded.md:41
#: src/ch21-02-multithreaded.md:55 src/ch21-02-multithreaded.md:475
#: src/ch21-02-multithreaded.md:549 src/ch21-02-multithreaded.md:613
#: src/ch21-02-multithreaded.md:632 src/ch21-02-multithreaded.md:712
#: src/ch21-02-multithreaded.md:731 src/ch21-02-multithreaded.md:821
#: src/ch21-02-multithreaded.md:842 src/ch21-02-multithreaded.md:888
#: src/ch21-02-multithreaded.md:909 src/ch21-02-multithreaded.md:917
#: src/ch21-02-multithreaded.md:998 src/ch21-02-multithreaded.md:1009
#: src/ch21-02-multithreaded.md:1033 src/ch21-02-multithreaded.md:1041
#: src/ch21-02-multithreaded.md:1051 src/ch21-02-multithreaded.md:1090
#: src/ch21-02-multithreaded.md:1096 src/ch21-02-multithreaded.md:1129
#: src/ch21-02-multithreaded.md:1218 src/ch21-02-multithreaded.md:1374
#: src/ch21-03-graceful-shutdown-and-cleanup.md:279
#: src/ch21-03-graceful-shutdown-and-cleanup.md:293
msgid "// --snip--\n"
msgstr "// --생략--\n"

#: src/ch02-00-guessing-game-tutorial.md:779
#: src/ch02-00-guessing-game-tutorial.md:906
#: src/ch02-00-guessing-game-tutorial.md:1033
#: src/ch02-00-guessing-game-tutorial.md:1126
#: src/ch02-00-guessing-game-tutorial.md:1183
#: src/ch02-00-guessing-game-tutorial.md:1286
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:366
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:408
#: src/ch09-03-to-panic-or-not-to-panic.md:184
#: src/ch20-03-advanced-types.md:254
msgid "\"Too small!\""
msgstr "\"너무 작아요!\""

#: src/ch02-00-guessing-game-tutorial.md:780
#: src/ch02-00-guessing-game-tutorial.md:907
#: src/ch02-00-guessing-game-tutorial.md:1034
#: src/ch02-00-guessing-game-tutorial.md:1127
#: src/ch02-00-guessing-game-tutorial.md:1184
#: src/ch02-00-guessing-game-tutorial.md:1287
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:367
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:409
#: src/ch09-03-to-panic-or-not-to-panic.md:185
#: src/ch20-03-advanced-types.md:255
msgid "\"Too big!\""
msgstr "\"너무 커요!\""

#: src/ch02-00-guessing-game-tutorial.md:781
#: src/ch02-00-guessing-game-tutorial.md:908
#: src/ch02-00-guessing-game-tutorial.md:1035
#: src/ch02-00-guessing-game-tutorial.md:1129
#: src/ch02-00-guessing-game-tutorial.md:1186
#: src/ch02-00-guessing-game-tutorial.md:1289
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:368
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:410
#: src/ch09-03-to-panic-or-not-to-panic.md:187
#: src/ch20-03-advanced-types.md:257
msgid "\"You win!\""
msgstr "\"당신이 이겼습니다!\""

#: src/ch02-00-guessing-game-tutorial.md:788
msgid ""
"First we add another `use` statement, bringing a type called "
"`std::cmp::Ordering` into scope from the standard library. The `Ordering` "
"type is another enum and has the variants `Less`, `Greater`, and `Equal`. "
"These are the three outcomes that are possible when you compare two values."
msgstr "먼저 또 다른 `use` 문을 추가하여, 표준 라이브러리에서 `std::cmp::Ordering`이라는 타입을 스코프로 가져옵니다. `Ordering` 타입은 또 다른 열거형이며 `Less`, `Greater`, `Equal` variant를 가집니다. 이것들은 두 값을 비교할 때 가능한 세 가지 결과입니다."

#: src/ch02-00-guessing-game-tutorial.md:793
msgid ""
"Then we add five new lines at the bottom that use the `Ordering` type. The "
"`cmp` method compares two values and can be called on anything that can be "
"compared. It takes a reference to whatever you want to compare with: here "
"it’s comparing `guess` to `secret_number`. Then it returns a variant of the "
"`Ordering` enum we brought into scope with the `use` statement. We use a "
"[`match`](ch06-02-match.html)<!-- ignore --> expression to decide what to do "
"next based on which variant of `Ordering` was returned from the call to "
"`cmp` with the values in `guess` and `secret_number`."
msgstr "그런 다음 `Ordering` 타입을 사용하는 다섯 줄의 새 코드를 맨 아래에 추가합니다. `cmp` 메서드는 두 값을 비교하며, 비교할 수 있는 모든 것에서 호출할 수 있습니다. 비교하려는 대상에 대한 참조를 인수로 받습니다: 여기서는 `guess`를 `secret_number`와 비교합니다. 그런 다음 `use` 문으로 스코프에 가져온 `Ordering` 열거형의 variant를 반환합니다. `guess`와 `secret_number`의 값으로 `cmp`를 호출하여 반환된 `Ordering`의 variant에 따라 다음에 무엇을 할지 결정하기 위해 [`match`](ch06-02-match.html)<!-- ignore --> 표현식을 사용합니다."

#: src/ch02-00-guessing-game-tutorial.md:802
msgid ""
"A `match` expression is made up of _arms_. An arm consists of a _pattern_ to "
"match against, and the code that should be run if the value given to `match` "
"fits that arm’s pattern. Rust takes the value given to `match` and looks "
"through each arm’s pattern in turn. Patterns and the `match` construct are "
"powerful Rust features: they let you express a variety of situations your "
"code might encounter and they make sure you handle them all. These features "
"will be covered in detail in Chapter 6 and Chapter 19, respectively."
msgstr "`match` 표현식은 _arm_으로 구성됩니다. arm은 매치할 _패턴_과 `match`에 주어진 값이 해당 arm의 패턴에 맞을 경우 실행되어야 하는 코드로 구성됩니다. 러스트는 `match`에 주어진 값을 가져와 각 arm의 패턴을 차례로 살펴봅니다. 패턴과 `match` 구조는 강력한 러스트 기능입니다: 코드가 마주칠 수 있는 다양한 상황을 표현할 수 있게 해주며, 모든 상황을 처리하도록 보장합니다. 이러한 기능은 각각 6장과 19장에서 자세히 다룰 것입니다."

#: src/ch02-00-guessing-game-tutorial.md:810
msgid ""
"Let’s walk through an example with the `match` expression we use here. Say "
"that the user has guessed 50 and the randomly generated secret number this "
"time is 38."
msgstr "여기서 사용하는 `match` 표현식의 예를 살펴보겠습니다. 사용자가 50을 추측했고 이번에 무작위로 생성된 비밀 번호가 38이라고 가정해 보겠습니다."

#: src/ch02-00-guessing-game-tutorial.md:814
msgid ""
"When the code compares 50 to 38, the `cmp` method will return "
"`Ordering::Greater` because 50 is greater than 38. The `match` expression "
"gets the `Ordering::Greater` value and starts checking each arm’s pattern. "
"It looks at the first arm’s pattern, `Ordering::Less`, and sees that the "
"value `Ordering::Greater` does not match `Ordering::Less`, so it ignores the "
"code in that arm and moves to the next arm. The next arm’s pattern is "
"`Ordering::Greater`, which _does_ match `Ordering::Greater`! The associated "
"code in that arm will execute and print `Too big!` to the screen. The "
"`match` expression ends after the first successful match, so it won’t look "
"at the last arm in this scenario."
msgstr "코드가 50을 38과 비교할 때, `cmp` 메서드는 50이 38보다 크기 때문에 `Ordering::Greater`를 반환합니다. `match` 표현식은 `Ordering::Greater` 값을 얻고 각 arm의 패턴을 확인하기 시작합니다. 첫 번째 arm의 패턴인 `Ordering::Less`를 보고, `Ordering::Greater` 값이 `Ordering::Less`와 일치하지 않음을 확인하고, 해당 arm의 코드를 무시하고 다음 arm으로 이동합니다. 다음 arm의 패턴은 `Ordering::Greater`이며, 이는 `Ordering::Greater`와 _일치합니다_! 해당 arm의 연관 코드가 실행되고 화면에 `Too big!`을 출력합니다. `match` 표현식은 첫 번째 성공적인 매치 후에 종료되므로, 이 시나리오에서는 마지막 arm을 보지 않습니다."

#: src/ch02-00-guessing-game-tutorial.md:825
msgid "However, the code in Listing 2-4 won’t compile yet. Let’s try it:"
msgstr "그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 시도해 보겠습니다:"

#: src/ch02-00-guessing-game-tutorial.md:832
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling libc v0.2.86\n"
"   Compiling getrandom v0.2.2\n"
"   Compiling cfg-if v1.0.0\n"
"   Compiling ppv-lite86 v0.2.10\n"
"   Compiling rand_core v0.6.2\n"
"   Compiling rand_chacha v0.3.0\n"
"   Compiling rand v0.8.5\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"error[E0308]: mismatched types\n"
"   --> src/main.rs:22:21\n"
"    |\n"
"22  |     match guess.cmp(&secret_number) {\n"
"    |                 --- ^^^^^^^^^^^^^^ expected `&String`, found "
"`&{integer}`\n"
"    |                 |\n"
"    |                 arguments to this method are incorrect\n"
"    |\n"
"    = note: expected reference `&String`\n"
"               found reference `&{integer}`\n"
"note: method defined here\n"
"   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/"
"core/src/cmp.rs:838:8\n"
"    |\n"
"838 |     fn cmp(&self, other: &Self) -> Ordering;\n"
"    |        ^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `guessing_game` (bin \"guessing_game\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:862
msgid ""
"The core of the error states that there are _mismatched types_. Rust has a "
"strong, static type system. However, it also has type inference. When we "
"wrote `let mut guess = String::new()`, Rust was able to infer that `guess` "
"should be a `String` and didn’t make us write the type. The `secret_number`, "
"on the other hand, is a number type. A few of Rust’s number types can have a "
"value between 1 and 100: `i32`, a 32-bit number; `u32`, an unsigned 32-bit "
"number; `i64`, a 64-bit number; as well as others. Unless otherwise "
"specified, Rust defaults to an `i32`, which is the type of `secret_number` "
"unless you add type information elsewhere that would cause Rust to infer a "
"different numerical type. The reason for the error is that Rust cannot "
"compare a string and a number type."
msgstr "오류의 핵심은 _일치하지 않는 타입_이 있다는 것입니다. 러스트는 강력한 정적 타입 시스템을 가지고 있습니다. 그러나 타입 추론도 가지고 있습니다. `let mut guess = String::new()`를 작성했을 때, 러스트는 `guess`가 `String`이어야 한다고 추론할 수 있었고, 우리가 타입을 작성하도록 강요하지 않았습니다. 반면에 `secret_number`는 숫자 타입입니다. 러스트의 몇 가지 숫자 타입은 1에서 100 사이의 값을 가질 수 있습니다: `i32`, 32비트 숫자; `u32`, 부호 없는 32비트 숫자; `i64`, 64비트 숫자; 등등. 달리 명시하지 않는 한, 러스트는 `i32`를 기본값으로 사용하며, 다른 곳에서 러스트가 다른 숫자 타입을 추론하도록 하는 타입 정보를 추가하지 않는 한 `secret_number`의 타입입니다. 오류의 이유는 러스트가 문자열과 숫자 타입을 비교할 수 없기 때문입니다."

#: src/ch02-00-guessing-game-tutorial.md:873
msgid ""
"Ultimately, we want to convert the `String` the program reads as input into "
"a number type so we can compare it numerically to the secret number. We do "
"so by adding this line to the `main` function body:"
msgstr "궁극적으로, 프로그램이 입력으로 읽는 `String`을 숫자 타입으로 변환하여 비밀 번호와 숫자로 비교하고 싶습니다. `main` 함수 본문에 이 줄을 추가하여 그렇게 합니다:"

#: src/ch02-00-guessing-game-tutorial.md:901
#: src/ch02-00-guessing-game-tutorial.md:916
#: src/ch02-00-guessing-game-tutorial.md:1028
#: src/ch02-00-guessing-game-tutorial.md:1119
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:403
msgid "\"Please type a number!\""
msgstr "\"숫자를 입력해주세요!\""

#: src/ch02-00-guessing-game-tutorial.md:913
msgid "The line is:"
msgstr "해당 줄은 다음과 같습니다:"

#: src/ch02-00-guessing-game-tutorial.md:919
msgid ""
"We create a variable named `guess`. But wait, doesn’t the program already "
"have a variable named `guess`? It does, but helpfully Rust allows us to "
"shadow the previous value of `guess` with a new one. _Shadowing_ lets us "
"reuse the `guess` variable name rather than forcing us to create two unique "
"variables, such as `guess_str` and `guess`, for example. We’ll cover this in "
"more detail in [Chapter 3](ch03-01-variables-and-"
"mutability.html#shadowing)<!-- ignore -->, but for now, know that this "
"feature is often used when you want to convert a value from one type to "
"another type."
msgstr "`guess`라는 이름의 변수를 만듭니다. 하지만 잠깐, 프로그램에 이미 `guess`라는 이름의 변수가 있지 않나요? 그렇습니다. 하지만 고맙게도 러스트는 이전 `guess` 값을 새 값으로 섀도잉할 수 있도록 허용합니다. _섀도잉_을 사용하면 예를 들어 `guess_str`과 `guess`와 같이 두 개의 고유한 변수를 만들도록 강요하는 대신 `guess` 변수 이름을 재사용할 수 있습니다. 이에 대해서는 [3장](ch03-01-variables-and-mutability.html#shadowing)<!-- ignore -->에서 더 자세히 다룰 것이지만, 지금은 이 기능이 한 타입의 값을 다른 타입으로 변환하고 싶을 때 자주 사용된다는 점만 알아두세요."

#: src/ch02-00-guessing-game-tutorial.md:927
msgid ""
"We bind this new variable to the expression `guess.trim().parse()`. The "
"`guess` in the expression refers to the original `guess` variable that "
"contained the input as a string. The `trim` method on a `String` instance "
"will eliminate any whitespace at the beginning and end, which we must do "
"before we can convert the string to a `u32`, which can only contain "
"numerical data. The user must press <kbd>enter</kbd> to satisfy `read_line` "
"and input their guess, which adds a newline character to the string. For "
"example, if the user types <kbd>5</kbd> and presses <kbd>enter</kbd>, "
"`guess` looks like this: `5\\n`. The `\\n` represents “newline.” (On "
"Windows, pressing <kbd>enter</kbd> results in a carriage return and a "
"newline, `\\r\\n`.) The `trim` method eliminates `\\n` or `\\r\\n`, "
"resulting in just `5`."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:939
msgid ""
"The [`parse` method on strings](../std/primitive.str.html#method.parse)<!-- "
"ignore --> converts a string to another type. Here, we use it to convert "
"from a string to a number. We need to tell Rust the exact number type we "
"want by using `let guess: u32`. The colon (`:`) after `guess` tells Rust "
"we’ll annotate the variable’s type. Rust has a few built-in number types; "
"the `u32` seen here is an unsigned, 32-bit integer. It’s a good default "
"choice for a small positive number. You’ll learn about other number types in "
"[Chapter 3](ch03-02-data-types.html#integer-types)<!-- ignore -->."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:947
msgid ""
"Additionally, the `u32` annotation in this example program and the "
"comparison with `secret_number` means Rust will infer that `secret_number` "
"should be a `u32` as well. So now the comparison will be between two values "
"of the same type!"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:952
msgid ""
"The `parse` method will only work on characters that can logically be "
"converted into numbers and so can easily cause errors. If, for example, the "
"string contained `A👍%`, there would be no way to convert that to a number. "
"Because it might fail, the `parse` method returns a `Result` type, much as "
"the `read_line` method does (discussed earlier in [“Handling Potential "
"Failure with `Result`”](#handling-potential-failure-with-result)<!-- ignore--"
">). We’ll treat this `Result` the same way by using the `expect` method "
"again. If `parse` returns an `Err` `Result` variant because it couldn’t "
"create a number from the string, the `expect` call will crash the game and "
"print the message we give it. If `parse` can successfully convert the string "
"to a number, it will return the `Ok` variant of `Result`, and `expect` will "
"return the number that we want from the `Ok` value."
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:965
msgid "Let’s run the program now:"
msgstr "이제 프로그램을 실행해 봅시다:"

#: src/ch02-00-guessing-game-tutorial.md:974
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 58\n"
"Please input your guess.\n"
"  76\n"
"You guessed: 76\n"
"Too big!\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:987
msgid ""
"Nice! Even though spaces were added before the guess, the program still "
"figured out that the user guessed 76. Run the program a few times to verify "
"the different behavior with different kinds of input: guess the number "
"correctly, guess a number that is too high, and guess a number that is too "
"low."
msgstr "좋아요! 추측 앞에 공백이 추가되었음에도 불구하고, 프로그램은 사용자가 76을 추측했다는 것을 알아냈습니다. 프로그램을 몇 번 실행하여 다른 종류의 입력에 대한 다른 동작을 확인하세요: 숫자를 정확하게 추측하고, 너무 높은 숫자를 추측하고, 너무 낮은 숫자를 추측하세요."

#: src/ch02-00-guessing-game-tutorial.md:992
msgid ""
"We have most of the game working now, but the user can make only one guess. "
"Let’s change that by adding a loop!"
msgstr "이제 대부분의 게임이 작동하지만, 사용자는 한 번만 추측할 수 있습니다. 반복문을 추가하여 그것을 변경해 봅시다!"

#: src/ch02-00-guessing-game-tutorial.md:995
msgid "Allowing Multiple Guesses with Looping"
msgstr "반복문으로 여러 번 추측 허용하기"

#: src/ch02-00-guessing-game-tutorial.md:997
msgid ""
"The `loop` keyword creates an infinite loop. We’ll add a loop to give users "
"more chances at guessing the number:"
msgstr "`loop` 키워드는 무한 루프를 만듭니다. 사용자가 숫자를 추측할 기회를 더 많이 주기 위해 루프를 추가할 것입니다:"

#: src/ch02-00-guessing-game-tutorial.md:1041
msgid ""
"As you can see, we’ve moved everything from the guess input prompt onward "
"into a loop. Be sure to indent the lines inside the loop another four spaces "
"each and run the program again. The program will now ask for another guess "
"forever, which actually introduces a new problem. It doesn’t seem like the "
"user can quit!"
msgstr "보시다시피, 추측 입력 프롬프트부터 모든 것을 루프 안으로 옮겼습니다. 루프 안의 줄들을 각각 네 칸씩 더 들여쓰고 프로그램을 다시 실행하세요. 이제 프로그램은 영원히 다른 추측을 요구할 것이며, 이는 실제로 새로운 문제를 야기합니다. 사용자가 종료할 수 없는 것 같습니다!"

#: src/ch02-00-guessing-game-tutorial.md:1046
msgid ""
"The user could always interrupt the program by using the keyboard shortcut "
"<kbd>ctrl</kbd>\\-<kbd>c</kbd>. But there’s another way to escape this "
"insatiable monster, as mentioned in the `parse` discussion in [“Comparing "
"the Guess to the Secret Number”](#comparing-the-guess-to-the-secret-"
"number)<!-- ignore -->: if the user enters a non-number answer, the program "
"will crash. We can take advantage of that to allow the user to quit, as "
"shown here:"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1063
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 59\n"
"Please input your guess.\n"
"45\n"
"You guessed: 45\n"
"Too small!\n"
"Please input your guess.\n"
"60\n"
"You guessed: 60\n"
"Too big!\n"
"Please input your guess.\n"
"59\n"
"You guessed: 59\n"
"You win!\n"
"Please input your guess.\n"
"quit\n"
"thread 'main' panicked at 'Please type a number!: ParseIntError { kind: "
"InvalidDigit }', src/main.rs:28:47\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1088
msgid ""
"Typing `quit` will quit the game, but as you’ll notice, so will entering any "
"other non-number input. This is suboptimal, to say the least; we want the "
"game to also stop when the correct number is guessed."
msgstr "`quit`을 입력하면 게임이 종료되지만, 눈치채셨겠지만, 다른 숫자가 아닌 입력을 입력해도 마찬가지입니다. 이것은 좋지 않은 방법입니다. 우리는 정답을 맞췄을 때도 게임이 멈추기를 원합니다."

#: src/ch02-00-guessing-game-tutorial.md:1092
msgid "Quitting After a Correct Guess"
msgstr "정답 맞춘 후 종료하기"

#: src/ch02-00-guessing-game-tutorial.md:1094
msgid ""
"Let’s program the game to quit when the user wins by adding a `break` "
"statement:"
msgstr "`break` 문을 추가하여 사용자가 이겼을 때 게임이 종료되도록 프로그래밍해 봅시다:"

#: src/ch02-00-guessing-game-tutorial.md:1137
msgid ""
"Adding the `break` line after `You win!` makes the program exit the loop "
"when the user guesses the secret number correctly. Exiting the loop also "
"means exiting the program, because the loop is the last part of `main`."
msgstr "`You win!` 뒤에 `break` 줄을 추가하면 사용자가 비밀 번호를 정확하게 추측했을 때 프로그램이 루프를 종료합니다. 루프를 종료하는 것은 또한 프로그램을 종료하는 것을 의미합니다. 왜냐하면 루프는 `main`의 마지막 부분이기 때문입니다."

#: src/ch02-00-guessing-game-tutorial.md:1141
msgid "Handling Invalid Input"
msgstr "잘못된 입력 처리하기"

#: src/ch02-00-guessing-game-tutorial.md:1143
msgid ""
"To further refine the game’s behavior, rather than crashing the program when "
"the user inputs a non-number, let’s make the game ignore a non-number so the "
"user can continue guessing. We can do that by altering the line where "
"`guess` is converted from a `String` to a `u32`, as shown in Listing 2-5."
msgstr "게임의 동작을 더욱 개선하기 위해, 사용자가 숫자가 아닌 값을 입력했을 때 프로그램을 충돌시키는 대신, 게임이 숫자가 아닌 값을 무시하도록 하여 사용자가 계속 추측할 수 있도록 만들어 봅시다. 목록 2-5와 같이 `guess`가 `String`에서 `u32`로 변환되는 줄을 변경하여 그렇게 할 수 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:1196
msgid ""
"We switch from an `expect` call to a `match` expression to move from "
"crashing on an error to handling the error. Remember that `parse` returns a "
"`Result` type and `Result` is an enum that has the variants `Ok` and `Err`. "
"We’re using a `match` expression here, as we did with the `Ordering` result "
"of the `cmp` method."
msgstr "오류 발생 시 충돌하는 것에서 오류를 처리하는 것으로 이동하기 위해 `expect` 호출에서 `match` 표현식으로 전환합니다. `parse`가 `Result` 타입을 반환하고 `Result`가 `Ok`와 `Err` variant를 갖는 열거형임을 기억하세요. `cmp` 메서드의 `Ordering` 결과와 마찬가지로 여기서도 `match` 표현식을 사용하고 있습니다."

#: src/ch02-00-guessing-game-tutorial.md:1202
msgid ""
"If `parse` is able to successfully turn the string into a number, it will "
"return an `Ok` value that contains the resultant number. That `Ok` value "
"will match the first arm’s pattern, and the `match` expression will just "
"return the `num` value that `parse` produced and put inside the `Ok` value. "
"That number will end up right where we want it in the new `guess` variable "
"we’re creating."
msgstr "`parse`가 문자열을 숫자로 성공적으로 변환할 수 있으면, 결과 숫자를 포함하는 `Ok` 값을 반환합니다. 해당 `Ok` 값은 첫 번째 arm의 패턴과 일치하며, `match` 표현식은 `parse`가 생성하여 `Ok` 값 안에 넣은 `num` 값을 반환합니다. 그 숫자는 우리가 생성하는 새 `guess` 변수에서 원하는 바로 그 위치에 있게 됩니다."

#: src/ch02-00-guessing-game-tutorial.md:1208
msgid ""
"If `parse` is _not_ able to turn the string into a number, it will return an "
"`Err` value that contains more information about the error. The `Err` value "
"does not match the `Ok(num)` pattern in the first `match` arm, but it does "
"match the `Err(_)` pattern in the second arm. The underscore, `_`, is a "
"catch-all value; in this example, we’re saying we want to match all `Err` "
"values, no matter what information they have inside them. So the program "
"will execute the second arm’s code, `continue`, which tells the program to "
"go to the next iteration of the `loop` and ask for another guess. So, "
"effectively, the program ignores all errors that `parse` might encounter!"
msgstr "`parse`가 문자열을 숫자로 변환할 수 _없는_ 경우, 오류에 대한 자세한 정보가 포함된 `Err` 값을 반환합니다. `Err` 값은 첫 번째 `match` arm의 `Ok(num)` 패턴과 일치하지 않지만, 두 번째 arm의 `Err(_)` 패턴과 일치합니다. 밑줄 `_`는 모든 것을 포괄하는 값입니다. 이 예에서는 내부에 어떤 정보가 있든 모든 `Err` 값과 일치시키고 싶다고 말하는 것입니다. 따라서 프로그램은 두 번째 arm의 코드인 `continue`를 실행하며, 이는 프로그램에게 `loop`의 다음 반복으로 이동하여 다른 추측을 요청하도록 지시합니다. 따라서 효과적으로 프로그램은 `parse`가 마주칠 수 있는 모든 오류를 무시합니다!"

#: src/ch02-00-guessing-game-tutorial.md:1218
msgid "Now everything in the program should work as expected. Let’s try it:"
msgstr "이제 프로그램의 모든 것이 예상대로 작동해야 합니다. 시도해 보겠습니다:"

#: src/ch02-00-guessing-game-tutorial.md:1229
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n"
"     Running `target/debug/guessing_game`\n"
"Guess the number!\n"
"The secret number is: 61\n"
"Please input your guess.\n"
"10\n"
"You guessed: 10\n"
"Too small!\n"
"Please input your guess.\n"
"99\n"
"You guessed: 99\n"
"Too big!\n"
"Please input your guess.\n"
"foo\n"
"Please input your guess.\n"
"61\n"
"You guessed: 61\n"
"You win!\n"
"```"
msgstr ""

#: src/ch02-00-guessing-game-tutorial.md:1252
msgid ""
"Awesome! With one tiny final tweak, we will finish the guessing game. Recall "
"that the program is still printing the secret number. That worked well for "
"testing, but it ruins the game. Let’s delete the `println!` that outputs the "
"secret number. Listing 2-6 shows the final code."
msgstr "멋지네요! 마지막으로 작은 수정 하나만 더 하면 추측 게임을 완성할 수 있습니다. 프로그램이 여전히 비밀 번호를 출력하고 있다는 것을 기억하세요. 테스트에는 효과적이었지만, 게임의 재미를 망칩니다. 비밀 번호를 출력하는 `println!`을 삭제합시다. 목록 2-6은 최종 코드를 보여줍니다."

#: src/ch02-00-guessing-game-tutorial.md:1299
msgid ""
"At this point, you’ve successfully built the guessing game. Congratulations!"
msgstr "이 시점에서, 당신은 성공적으로 추측 게임을 만들었습니다. 축하합니다!"

#: src/ch02-00-guessing-game-tutorial.md:1303
msgid ""
"This project was a hands-on way to introduce you to many new Rust concepts: "
"`let`, `match`, functions, the use of external crates, and more. In the next "
"few chapters, you’ll learn about these concepts in more detail. Chapter 3 "
"covers concepts that most programming languages have, such as variables, "
"data types, and functions, and shows how to use them in Rust. Chapter 4 "
"explores ownership, a feature that makes Rust different from other "
"languages. Chapter 5 discusses structs and method syntax, and Chapter 6 "
"explains how enums work."
msgstr "이 프로젝트는 `let`, `match`, 함수, 외부 크레이트 사용 등 많은 새로운 러스트 개념을 소개하는 실습 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 더 자세히 배울 것입니다. 3장에서는 변수, 데이터 타입, 함수와 같이 대부분의 프로그래밍 언어가 가지고 있는 개념을 다루고, 러스트에서 사용하는 방법을 보여줍니다. 4장에서는 러스트를 다른 언어와 다르게 만드는 기능인 소유권을 탐구합니다. 5장에서는 구조체와 메서드 구문을 논의하고, 6장에서는 열거형이 어떻게 작동하는지 설명합니다."

#: src/ch03-00-common-programming-concepts.md:3
msgid ""
"This chapter covers concepts that appear in almost every programming "
"language and how they work in Rust. Many programming languages have much in "
"common at their core. None of the concepts presented in this chapter are "
"unique to Rust, but we’ll discuss them in the context of Rust and explain "
"the conventions around using these concepts."
msgstr "이 장에서는 거의 모든 프로그래밍 언어에 나타나는 개념과 러스트에서 어떻게 작동하는지 다룹니다. 많은 프로그래밍 언어는 핵심적으로 많은 공통점을 가지고 있습니다. 이 장에서 제시된 개념 중 어느 것도 러스트에만 고유한 것은 아니지만, 러스트의 맥락에서 논의하고 이러한 개념을 사용하는 관례에 대해 설명할 것입니다."

#: src/ch03-00-common-programming-concepts.md:9
msgid ""
"Specifically, you’ll learn about variables, basic types, functions, "
"comments, and control flow. These foundations will be in every Rust program, "
"and learning them early will give you a strong core to start from."
msgstr "구체적으로, 변수, 기본 타입, 함수, 주석, 제어 흐름에 대해 배울 것입니다. 이러한 기초는 모든 러스트 프로그램에 있으며, 일찍 배우면 강력한 핵심을 가지고 시작할 수 있습니다."

#: src/ch03-00-common-programming-concepts.md:13
msgid "Keywords"
msgstr "키워드"

#: src/ch03-00-common-programming-concepts.md:15
msgid ""
"The Rust language has a set of _keywords_ that are reserved for use by the "
"language only, much as in other languages. Keep in mind that you cannot use "
"these words as names of variables or functions. Most of the keywords have "
"special meanings, and you’ll be using them to do various tasks in your Rust "
"programs; a few have no current functionality associated with them but have "
"been reserved for functionality that might be added to Rust in the future. "
"You can find a list of the keywords in [Appendix A](appendix-01-"
"keywords.md)<!-- ignore -->."
msgstr "러스트 언어는 다른 언어와 마찬가지로 언어에서만 사용하도록 예약된 _키워드_ 세트를 가지고 있습니다. 이러한 단어는 변수나 함수의 이름으로 사용할 수 없다는 점을 명심하세요. 대부분의 키워드는 특별한 의미를 가지며, 러스트 프로그램에서 다양한 작업을 수행하는 데 사용됩니다. 몇몇은 현재 관련 기능이 없지만 나중에 러스트에 추가될 수 있는 기능을 위해 예약되어 있습니다. 키워드 목록은 [부록 A](appendix-01-keywords.md)<!-- ignore -->에서 찾을 수 있습니다."

#: src/ch03-01-variables-and-mutability.md:3
msgid ""
"As mentioned in the [“Storing Values with Variables”](ch02-00-guessing-game-"
"tutorial.html#storing-values-with-variables)<!-- ignore --> section, by "
"default, variables are immutable. This is one of many nudges Rust gives you "
"to write your code in a way that takes advantage of the safety and easy "
"concurrency that Rust offers. However, you still have the option to make "
"your variables mutable. Let’s explore how and why Rust encourages you to "
"favor immutability and why sometimes you might want to opt out."
msgstr "[“변수로 값 저장하기”](ch02-00-guessing-game-tutorial.html#storing-values-with-variables)<!-- ignore --> 섹션에서 언급했듯이, 기본적으로 변수는 불변입니다. 이것은 러스트가 제공하는 안전성과 쉬운 동시성을 활용하는 방식으로 코드를 작성하도록 유도하는 많은 유인책 중 하나입니다. 그러나 변수를 가변으로 만들 수 있는 옵션도 있습니다. 러스트가 왜 불변성을 선호하도록 권장하는지, 그리고 때로는 왜 그것을 선택하지 않을 수 있는지 살펴보겠습니다."

#: src/ch03-01-variables-and-mutability.md:11
msgid ""
"When a variable is immutable, once a value is bound to a name, you can’t "
"change that value. To illustrate this, generate a new project called "
"_variables_ in your _projects_ directory by using `cargo new variables`."
msgstr "변수가 불변일 때, 값이 이름에 바인딩되면 그 값을 변경할 수 없습니다. 이를 설명하기 위해, `cargo new variables`를 사용하여 _projects_ 디렉토리에 _variables_라는 새 프로젝트를 생성하세요."

#: src/ch03-01-variables-and-mutability.md:15
msgid ""
"Then, in your new _variables_ directory, open _src/main.rs_ and replace its "
"code with the following code, which won’t compile just yet:"
msgstr "그런 다음, 새 _variables_ 디렉토리에서 _src/main.rs_를 열고, 아직 컴파일되지 않는 다음 코드로 내용을 교체하세요:"

#: src/ch03-01-variables-and-mutability.md:23
#: src/ch03-01-variables-and-mutability.md:25
#: src/ch03-01-variables-and-mutability.md:85
#: src/ch03-01-variables-and-mutability.md:87
#: src/ch03-01-variables-and-mutability.md:178
#: src/ch03-03-how-functions-work.md:74 src/ch03-03-how-functions-work.md:271
#: src/ch03-03-how-functions-work.md:310 src/ch03-03-how-functions-work.md:328
msgid "\"The value of x is: {x}\""
msgstr "\"x의 값은: {x}\""

#: src/ch03-01-variables-and-mutability.md:29
msgid ""
"Save and run the program using `cargo run`. You should receive an error "
"message regarding an immutability error, as shown in this output:"
msgstr "`cargo run`을 사용하여 프로그램을 저장하고 실행하세요. 이 출력과 같이 불변성 오류에 대한 오류 메시지를 받아야 합니다:"

#: src/ch03-01-variables-and-mutability.md:32
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"error[E0384]: cannot assign twice to immutable variable `x`\n"
" --> src/main.rs:4:5\n"
"  |\n"
"2 |     let x = 5;\n"
"  |         - first assignment to `x`\n"
"3 |     println!(\"The value of x is: {x}\");\n"
"4 |     x = 6;\n"
"  |     ^^^^^ cannot assign twice to immutable variable\n"
"  |\n"
"help: consider making this binding mutable\n"
"  |\n"
"2 |     let mut x = 5;\n"
"  |         +++\n"
"\n"
"For more information about this error, try `rustc --explain E0384`.\n"
"error: could not compile `variables` (bin \"variables\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:53
msgid ""
"This example shows how the compiler helps you find errors in your programs. "
"Compiler errors can be frustrating, but really they only mean your program "
"isn’t safely doing what you want it to do yet; they do _not_ mean that "
"you’re not a good programmer! Experienced Rustaceans still get compiler "
"errors."
msgstr "이 예는 컴파일러가 프로그램에서 오류를 찾는 데 어떻게 도움이 되는지 보여줍니다. 컴파일러 오류는 답답할 수 있지만, 실제로는 프로그램이 아직 원하는 작업을 안전하게 수행하지 못하고 있다는 의미일 뿐입니다. 당신이 좋은 프로그래머가 아니라는 의미는 _아닙니다_! 숙련된 러스트 개발자도 여전히 컴파일러 오류를 받습니다."

#: src/ch03-01-variables-and-mutability.md:58
msgid ""
"You received the error message `` cannot assign twice to immutable variable "
"`x` `` because you tried to assign a second value to the immutable `x` "
"variable."
msgstr "불변 변수 `x`에 두 번 할당할 수 없다는 오류 메시지를 받았습니다. 왜냐하면 불변 `x` 변수에 두 번째 값을 할당하려고 했기 때문입니다."

#: src/ch03-01-variables-and-mutability.md:60
msgid ""
"It’s important that we get compile-time errors when we attempt to change a "
"value that’s designated as immutable because this very situation can lead to "
"bugs. If one part of our code operates on the assumption that a value will "
"never change and another part of our code changes that value, it’s possible "
"that the first part of the code won’t do what it was designed to do. The "
"cause of this kind of bug can be difficult to track down after the fact, "
"especially when the second piece of code changes the value only _sometimes_. "
"The Rust compiler guarantees that when you state that a value won’t change, "
"it really won’t change, so you don’t have to keep track of it yourself. Your "
"code is thus easier to reason through."
msgstr "불변으로 지정된 값을 변경하려고 할 때 컴파일 타임 오류가 발생하는 것이 중요합니다. 왜냐하면 바로 이 상황이 버그로 이어질 수 있기 때문입니다. 코드의 한 부분이 값이 절대 변경되지 않을 것이라는 가정 하에 작동하고 다른 부분이 그 값을 변경하면, 코드의 첫 번째 부분이 의도한 대로 작동하지 않을 수 있습니다. 이런 종류의 버그의 원인은 사후에 추적하기 어려울 수 있으며, 특히 두 번째 코드가 값을 _때때로_만 변경하는 경우에는 더욱 그렇습니다. 러스트 컴파일러는 값이 변경되지 않을 것이라고 명시하면, 실제로 변경되지 않을 것임을 보장하므로, 직접 추적할 필요가 없습니다. 따라서 코드를 더 쉽게 추론할 수 있습니다."

#: src/ch03-01-variables-and-mutability.md:71
msgid ""
"But mutability can be very useful, and can make code more convenient to "
"write. Although variables are immutable by default, you can make them "
"mutable by adding `mut` in front of the variable name as you did in [Chapter "
"2](ch02-00-guessing-game-tutorial.html#storing-values-with-variables)<!-- "
"ignore -->. Adding `mut` also conveys intent to future readers of the code "
"by indicating that other parts of the code will be changing this variable’s "
"value."
msgstr "하지만 가변성은 매우 유용할 수 있으며, 코드를 더 편리하게 작성할 수 있게 해줍니다. 변수는 기본적으로 불변이지만, [2장](ch02-00-guessing-game-tutorial.html#storing-values-with-variables)<!-- ignore -->에서 했던 것처럼 변수 이름 앞에 `mut`를 추가하여 가변으로 만들 수 있습니다. `mut`를 추가하면 코드의 다른 부분이 이 변수의 값을 변경할 것임을 나타내어 코드의 미래 독자에게 의도를 전달합니다."

#: src/ch03-01-variables-and-mutability.md:78
msgid "For example, let’s change _src/main.rs_ to the following:"
msgstr "예를 들어, _src/main.rs_를 다음과 같이 변경해 보겠습니다:"

#: src/ch03-01-variables-and-mutability.md:91
msgid "When we run the program now, we get this:"
msgstr "이제 프로그램을 실행하면 다음과 같은 결과를 얻습니다:"

#: src/ch03-01-variables-and-mutability.md:93
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/variables`\n"
"The value of x is: 5\n"
"The value of x is: 6\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:102
msgid ""
"We’re allowed to change the value bound to `x` from `5` to `6` when `mut` is "
"used. Ultimately, deciding whether to use mutability or not is up to you and "
"depends on what you think is clearest in that particular situation."
msgstr "`mut`를 사용하면 `x`에 바인딩된 값을 `5`에서 `6`으로 변경할 수 있습니다. 궁극적으로, 가변성을 사용할지 여부는 당신에게 달려 있으며, 특정 상황에서 무엇이 가장 명확하다고 생각하는지에 따라 달라집니다."

#: src/ch03-01-variables-and-mutability.md:106
msgid "Constants"
msgstr "상수"

#: src/ch03-01-variables-and-mutability.md:108
msgid ""
"Like immutable variables, _constants_ are values that are bound to a name "
"and are not allowed to change, but there are a few differences between "
"constants and variables."
msgstr "불변 변수와 마찬가지로, _상수_는 이름에 바인딩되고 변경이 허용되지 않는 값이지만, 상수와 변수 사이에는 몇 가지 차이점이 있습니다."

#: src/ch03-01-variables-and-mutability.md:112
msgid ""
"First, you aren’t allowed to use `mut` with constants. Constants aren’t just "
"immutable by default—they’re always immutable. You declare constants using "
"the `const` keyword instead of the `let` keyword, and the type of the value "
"_must_ be annotated. We’ll cover types and type annotations in the next "
"section, [“Data Types”](ch03-02-data-types.html#data-types)<!-- ignore -->, "
"so don’t worry about the details right now. Just know that you must always "
"annotate the type."
msgstr "첫째, 상수에 `mut`를 사용할 수 없습니다. 상수는 기본적으로 불변일 뿐만 아니라 항상 불변입니다. `let` 키워드 대신 `const` 키워드를 사용하여 상수를 선언하며, 값의 타입은 _반드시_ 명시해야 합니다. 타입과 타입 명시에 대해서는 다음 섹션인 [“데이터 타입”](ch03-02-data-types.html#data-types)<!-- ignore -->에서 다룰 것이므로, 지금은 세부 사항에 대해 걱정하지 마세요. 항상 타입을 명시해야 한다는 것만 알아두세요."

#: src/ch03-01-variables-and-mutability.md:119
msgid ""
"Constants can be declared in any scope, including the global scope, which "
"makes them useful for values that many parts of code need to know about."
msgstr "상수는 전역 스코프를 포함한 모든 스코프에서 선언할 수 있으므로, 코드의 여러 부분에서 알아야 할 값에 유용합니다."

#: src/ch03-01-variables-and-mutability.md:122
msgid ""
"The last difference is that constants may be set only to a constant "
"expression, not the result of a value that could only be computed at runtime."
msgstr "마지막 차이점은 상수는 런타임에만 계산할 수 있는 값의 결과가 아닌, 상수 표현식에만 설정할 수 있다는 것입니다."

#: src/ch03-01-variables-and-mutability.md:125
msgid "Here’s an example of a constant declaration:"
msgstr "다음은 상수 선언의 예입니다:"

#: src/ch03-01-variables-and-mutability.md:131
msgid ""
"The constant’s name is `THREE_HOURS_IN_SECONDS` and its value is set to the "
"result of multiplying 60 (the number of seconds in a minute) by 60 (the "
"number of minutes in an hour) by 3 (the number of hours we want to count in "
"this program). Rust’s naming convention for constants is to use all "
"uppercase with underscores between words. The compiler is able to evaluate a "
"limited set of operations at compile time, which lets us choose to write out "
"this value in a way that’s easier to understand and verify, rather than "
"setting this constant to the value 10,800. See the [Rust Reference’s section "
"on constant evaluation](../reference/const_eval.html) for more information "
"on what operations can be used when declaring constants."
msgstr "상수의 이름은 `THREE_HOURS_IN_SECONDS`이고 그 값은 60(1분의 초)에 60(1시간의 분)을 곱하고 3(이 프로그램에서 계산하려는 시간)을 곱한 결과로 설정됩니다. 러스트의 상수 명명 규칙은 단어 사이에 밑줄을 사용하여 모두 대문자로 사용하는 것입니다. 컴파일러는 컴파일 타임에 제한된 연산 집합을 평가할 수 있으므로, 이 상수를 10,800 값으로 설정하는 대신 더 이해하고 확인하기 쉬운 방식으로 이 값을 작성하도록 선택할 수 있습니다. 상수를 선언할 때 사용할 수 있는 연산에 대한 자세한 내용은 [러스트 참조의 상수 평가 섹션](../reference/const_eval.html)을 참조하세요."

#: src/ch03-01-variables-and-mutability.md:142
msgid ""
"Constants are valid for the entire time a program runs, within the scope in "
"which they were declared. This property makes constants useful for values in "
"your application domain that multiple parts of the program might need to "
"know about, such as the maximum number of points any player of a game is "
"allowed to earn, or the speed of light."
msgstr "상수는 선언된 스코프 내에서 프로그램이 실행되는 전체 시간 동안 유효합니다. 이 속성은 상수를 게임 플레이어가 얻을 수 있는 최대 점수나 빛의 속도와 같이 프로그램의 여러 부분에서 알아야 할 애플리케이션 도메인의 값에 유용하게 만듭니다."

#: src/ch03-01-variables-and-mutability.md:148
msgid ""
"Naming hardcoded values used throughout your program as constants is useful "
"in conveying the meaning of that value to future maintainers of the code. It "
"also helps to have only one place in your code you would need to change if "
"the hardcoded value needed to be updated in the future."
msgstr "프로그램 전체에서 사용되는 하드코딩된 값을 상수로 명명하는 것은 해당 값의 의미를 코드의 미래 유지보수자에게 전달하는 데 유용합니다. 또한 나중에 하드코딩된 값을 업데이트해야 할 경우 변경해야 할 코드가 한 곳에만 있도록 도와줍니다."

#: src/ch03-01-variables-and-mutability.md:153
msgid "Shadowing"
msgstr "섀도잉"

#: src/ch03-01-variables-and-mutability.md:155
msgid ""
"As you saw in the guessing game tutorial in [Chapter 2](ch02-00-guessing-"
"game-tutorial.html#comparing-the-guess-to-the-secret-number)<!-- ignore -->, "
"you can declare a new variable with the same name as a previous variable. "
"Rustaceans say that the first variable is _shadowed_ by the second, which "
"means that the second variable is what the compiler will see when you use "
"the name of the variable. In effect, the second variable overshadows the "
"first, taking any uses of the variable name to itself until either it itself "
"is shadowed or the scope ends. We can shadow a variable by using the same "
"variable’s name and repeating the use of the `let` keyword as follows:"
msgstr "[2장](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)<!-- ignore -->의 추측 게임 튜토리얼에서 보았듯이, 이전 변수와 동일한 이름으로 새 변수를 선언할 수 있습니다. 러스트 개발자들은 첫 번째 변수가 두 번째 변수에 의해 _섀도잉_되었다고 말하는데, 이는 변수 이름을 사용할 때 컴파일러가 보게 될 것이 두 번째 변수라는 것을 의미합니다. 사실상, 두 번째 변수는 첫 번째 변수를 가리고, 변수 이름의 모든 사용을 스스로 가져가거나 스코프가 끝날 때까지 가져갑니다. 다음과 같이 동일한 변수 이름을 사용하고 `let` 키워드를 반복 사용하여 변수를 섀도잉할 수 있습니다:"

#: src/ch03-01-variables-and-mutability.md:175
msgid "\"The value of x in the inner scope is: {x}\""
msgstr "\"내부 스코프에서 x의 값은: {x}\""

#: src/ch03-01-variables-and-mutability.md:182
msgid ""
"This program first binds `x` to a value of `5`. Then it creates a new "
"variable `x` by repeating `let x =`, taking the original value and adding "
"`1` so the value of `x` is then `6`. Then, within an inner scope created "
"with the curly brackets, the third `let` statement also shadows `x` and "
"creates a new variable, multiplying the previous value by `2` to give `x` a "
"value of `12`. When that scope is over, the inner shadowing ends and `x` "
"returns to being `6`. When we run this program, it will output the following:"
msgstr "이 프로그램은 먼저 `x`를 `5` 값에 바인딩합니다. 그런 다음 `let x =`를 반복하여 새 변수 `x`를 만들고, 원래 값에 `1`을 더하여 `x`의 값을 `6`으로 만듭니다. 그런 다음, 중괄호로 생성된 내부 스코프 내에서 세 번째 `let` 문도 `x`를 섀도잉하고 새 변수를 만들어 이전 값에 `2`를 곱하여 `x`에 `12` 값을 부여합니다. 해당 스코프가 끝나면 내부 섀도잉이 끝나고 `x`는 `6`으로 돌아갑니다. 이 프로그램을 실행하면 다음과 같이 출력됩니다:"

#: src/ch03-01-variables-and-mutability.md:190
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/variables`\n"
"The value of x in the inner scope is: 12\n"
"The value of x is: 6\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:199
msgid ""
"Shadowing is different from marking a variable as `mut` because we’ll get a "
"compile-time error if we accidentally try to reassign to this variable "
"without using the `let` keyword. By using `let`, we can perform a few "
"transformations on a value but have the variable be immutable after those "
"transformations have been completed."
msgstr "섀도잉은 변수를 `mut`로 표시하는 것과 다릅니다. 왜냐하면 `let` 키워드를 사용하지 않고 이 변수에 실수로 다시 할당하려고 하면 컴파일 타임 오류가 발생하기 때문입니다. `let`을 사용하면 값에 몇 가지 변환을 수행할 수 있지만, 해당 변환이 완료된 후에는 변수가 불변이 됩니다."

#: src/ch03-01-variables-and-mutability.md:205
msgid ""
"The other difference between `mut` and shadowing is that because we’re "
"effectively creating a new variable when we use the `let` keyword again, we "
"can change the type of the value but reuse the same name. For example, say "
"our program asks a user to show how many spaces they want between some text "
"by inputting space characters, and then we want to store that input as a "
"number:"
msgstr "`mut`와 섀도잉의 또 다른 차이점은 `let` 키워드를 다시 사용할 때 효과적으로 새 변수를 생성하기 때문에 값의 타입을 변경하면서도 동일한 이름을 재사용할 수 있다는 것입니다. 예를 들어, 프로그램이 사용자에게 일부 텍스트 사이에 원하는 공백 수를 공백 문자를 입력하여 표시하도록 요청한 다음, 해당 입력을 숫자로 저장하고 싶다고 가정해 보겠습니다:"

#: src/ch03-01-variables-and-mutability.md:213
#: src/ch03-01-variables-and-mutability.md:226
msgid "\"   \""
msgstr "\"   \""

#: src/ch03-01-variables-and-mutability.md:218
msgid ""
"The first `spaces` variable is a string type and the second `spaces` "
"variable is a number type. Shadowing thus spares us from having to come up "
"with different names, such as `spaces_str` and `spaces_num`; instead, we can "
"reuse the simpler `spaces` name. However, if we try to use `mut` for this, "
"as shown here, we’ll get a compile-time error:"
msgstr "첫 번째 `spaces` 변수는 문자열 타입이고 두 번째 `spaces` 변수는 숫자 타입입니다. 따라서 섀도잉은 `spaces_str`과 `spaces_num`과 같이 다른 이름을 생각해 낼 필요 없이 더 간단한 `spaces` 이름을 재사용할 수 있게 해줍니다. 그러나 여기에 표시된 것처럼 `mut`를 사용하려고 하면 컴파일 타임 오류가 발생합니다:"

#: src/ch03-01-variables-and-mutability.md:231
msgid "The error says we’re not allowed to mutate a variable’s type:"
msgstr "오류는 변수의 타입을 변경할 수 없다고 말합니다:"

#: src/ch03-01-variables-and-mutability.md:233
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling variables v0.1.0 (file:///projects/variables)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:3:14\n"
"  |\n"
"2 |     let mut spaces = \"   \";\n"
"  |                      ----- expected due to this value\n"
"3 |     spaces = spaces.len();\n"
"  |              ^^^^^^^^^^^^ expected `&str`, found `usize`\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `variables` (bin \"variables\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-01-variables-and-mutability.md:248
msgid ""
"Now that we’ve explored how variables work, let’s look at more data types "
"they can have."
msgstr "이제 변수가 어떻게 작동하는지 살펴보았으니, 변수가 가질 수 있는 더 많은 데이터 타입을 살펴보겠습니다."

#: src/ch03-02-data-types.md:3
msgid ""
"Every value in Rust is of a certain _data type_, which tells Rust what kind "
"of data is being specified so it knows how to work with that data. We’ll "
"look at two data type subsets: scalar and compound."
msgstr "러스트의 모든 값은 특정 _데이터 타입_을 가지며, 이는 러스트에게 어떤 종류의 데이터가 지정되었는지 알려주어 해당 데이터를 어떻게 처리해야 하는지 알 수 있도록 합니다. 우리는 두 가지 데이터 타입 하위 집합인 스칼라와 복합을 살펴볼 것입니다."

#: src/ch03-02-data-types.md:7
msgid ""
"Keep in mind that Rust is a _statically typed_ language, which means that it "
"must know the types of all variables at compile time. The compiler can "
"usually infer what type we want to use based on the value and how we use it. "
"In cases when many types are possible, such as when we converted a `String` "
"to a numeric type using `parse` in the [“Comparing the Guess to the Secret "
"Number”](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-"
"secret-number)<!-- ignore --> section in Chapter 2, we must add a type "
"annotation, like this:"
msgstr "러스트는 _정적 타입_ 언어라는 점을 명심하세요. 즉, 컴파일 타임에 모든 변수의 타입을 알아야 합니다. 컴파일러는 일반적으로 값과 사용 방식을 기반으로 우리가 사용하려는 타입을 추론할 수 있습니다. 2장의 [“추측을 비밀 번호와 비교하기”](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)<!-- ignore --> 섹션에서 `parse`를 사용하여 `String`을 숫자 타입으로 변환했을 때와 같이 여러 타입이 가능한 경우, 다음과 같이 타입 명시를 추가해야 합니다:"

#: src/ch03-02-data-types.md:16
msgid "\"42\""
msgstr "\"42\""

#: src/ch03-02-data-types.md:16
msgid "\"Not a number!\""
msgstr "\"숫자가 아닙니다!\""

#: src/ch03-02-data-types.md:19
msgid ""
"If we don’t add the `: u32` type annotation shown in the preceding code, "
"Rust will display the following error, which means the compiler needs more "
"information from us to know which type we want to use:"
msgstr "앞의 코드에 표시된 `: u32` 타입 명시를 추가하지 않으면, 러스트는 다음 오류를 표시합니다. 이는 컴파일러가 우리가 사용하려는 타입을 알기 위해 더 많은 정보가 필요하다는 것을 의미합니다:"

#: src/ch03-02-data-types.md:23
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling no_type_annotations v0.1.0 (file:///projects/"
"no_type_annotations)\n"
"error[E0284]: type annotations needed\n"
" --> src/main.rs:2:9\n"
"  |\n"
"2 |     let guess = \"42\".parse().expect(\"Not a number!\");\n"
"  |         ^^^^^        ----- type must be known at this point\n"
"  |\n"
"  = note: cannot satisfy `<_ as FromStr>::Err == _`\n"
"help: consider giving `guess` an explicit type\n"
"  |\n"
"2 |     let guess: /* Type */ = \"42\".parse().expect(\"Not a number!\");\n"
"  |              ++++++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0284`.\n"
"error: could not compile `no_type_annotations` (bin \"no_type_annotations\") "
"due to 1 previous error\n"
"```"
msgstr ""

#: src/ch03-02-data-types.md:42
msgid "You’ll see different type annotations for other data types."
msgstr "다른 데이터 타입에 대한 다른 타입 명시를 보게 될 것입니다."

#: src/ch03-02-data-types.md:44
msgid "Scalar Types"
msgstr "스칼라 타입"

#: src/ch03-02-data-types.md:46
msgid ""
"A _scalar_ type represents a single value. Rust has four primary scalar "
"types: integers, floating-point numbers, Booleans, and characters. You may "
"recognize these from other programming languages. Let’s jump into how they "
"work in Rust."
msgstr "_스칼라_ 타입은 단일 값을 나타냅니다. 러스트에는 정수, 부동소수점 숫자, 불리언, 문자의 네 가지 기본 스칼라 타입이 있습니다. 다른 프로그래밍 언어에서 이것들을 본 적이 있을 것입니다. 러스트에서 어떻게 작동하는지 살펴보겠습니다."

#: src/ch03-02-data-types.md:50
msgid "Integer Types"
msgstr "정수 타입"

#: src/ch03-02-data-types.md:52
msgid ""
"An _integer_ is a number without a fractional component. We used one integer "
"type in Chapter 2, the `u32` type. This type declaration indicates that the "
"value it’s associated with should be an unsigned integer (signed integer "
"types start with `i` instead of `u`) that takes up 32 bits of space. Table "
"3-1 shows the built-in integer types in Rust. We can use any of these "
"variants to declare the type of an integer value."
msgstr "_정수_는 소수 부분이 없는 숫자입니다. 2장에서 `u32` 타입이라는 한 가지 정수 타입을 사용했습니다. 이 타입 선언은 연관된 값이 32비트 공간을 차지하는 부호 없는 정수(부호 있는 정수 타입은 `u` 대신 `i`로 시작)여야 함을 나타냅니다. 표 3-1은 러스트의 내장 정수 타입을 보여줍니다. 이러한 variant 중 하나를 사용하여 정수 값의 타입을 선언할 수 있습니다."

#: src/ch03-02-data-types.md:59
msgid "<span class=\"caption\">Table 3-1: Integer Types in Rust</span>"
msgstr "<span class=\"caption\">표 3-1: 러스트의 정수 타입</span>"

#: src/ch03-02-data-types.md:61
msgid "Length"
msgstr "길이"

#: src/ch03-02-data-types.md:61
msgid "Signed"
msgstr "부호 있음"

#: src/ch03-02-data-types.md:61
msgid "Unsigned"
msgstr "부호 없음"

#: src/ch03-02-data-types.md:63
msgid "8-bit"
msgstr "8비트"

#: src/ch03-02-data-types.md:63
msgid "`i8`"
msgstr "`i8`"

#: src/ch03-02-data-types.md:63
msgid "`u8`"
msgstr "`u8`"

#: src/ch03-02-data-types.md:64
msgid "16-bit"
msgstr "16비트"

#: src/ch03-02-data-types.md:64
msgid "`i16`"
msgstr "`i16`"

#: src/ch03-02-data-types.md:64
msgid "`u16`"
msgstr "`u16`""

#: src/ch03-02-data-types.md:65
msgid "32-bit"
msgstr "32비트"

#: src/ch03-02-data-types.md:65
msgid "`i32`"
msgstr "`i32`"

#: src/ch03-02-data-types.md:65
msgid "`u32`"
msgstr "`u32`"

#: src/ch03-02-data-types.md:66
msgid "64-bit"
msgstr "64비트"

#: src/ch03-02-data-types.md:66
msgid "`i64`"
msgstr "`i64`"

#: src/ch03-02-data-types.md:66
msgid "`u64`"
msgstr "`u64`"

#: src/ch03-02-data-types.md:67
msgid "128-bit"
msgstr "128비트"

#: src/ch03-02-data-types.md:67
msgid "`i128`"
msgstr "`i128`"

#: src/ch03-02-data-types.md:67
msgid "`u128`"
msgstr "`u128`"

#: src/ch03-02-data-types.md:68
msgid "arch"
msgstr "아키텍처"

#: src/ch03-02-data-types.md:68
msgid "`isize`"
msgstr "`isize`"

#: src/ch03-02-data-types.md:68
msgid "`usize`"
msgstr "`usize`"

#: src/ch03-02-data-types.md:70
msgid ""
"Each variant can be either signed or unsigned and has an explicit size. "
"_Signed_ and _unsigned_ refer to whether it’s possible for the number to be "
"negative—in other words, whether the number needs to have a sign with it "
"(signed) or whether it will only ever be positive and can therefore be "
"represented without a sign (unsigned). It’s like writing numbers on paper: "
"when the sign matters, a number is shown with a plus sign or a minus sign; "
"however, when it’s safe to assume the number is positive, it’s shown with no "
"sign. Signed numbers are stored using [two’s complement](https://"
"en.wikipedia.org/wiki/Two%27s_complement)<!-- ignore\n"
"--> representation."
msgstr "각 variant는 부호 있거나 부호 없을 수 있으며 명시적인 크기를 가집니다. _부호 있음_과 _부호 없음_은 숫자가 음수일 수 있는지 여부, 즉 숫자에 부호가 있어야 하는지(부호 있음) 또는 항상 양수이므로 부호 없이 표현할 수 있는지(부호 없음)를 나타냅니다. 종이에 숫자를 쓰는 것과 같습니다: 부호가 중요할 때, 숫자는 더하기 부호나 빼기 부호와 함께 표시됩니다. 그러나 숫자가 양수라고 가정해도 안전할 때, 부호 없이 표시됩니다. 부호 있는 숫자는 [2의 보수](https://en.wikipedia.org/wiki/Two%27s_complement)<!-- ignore\n--> 표현을 사용하여 저장됩니다."

#: src/ch03-02-data-types.md:80
msgid ""
"Each signed variant can store numbers from −(2<sup>n − 1</sup>) to 2<sup>n − "
"1</sup> − 1 inclusive, where _n_ is the number of bits that variant uses. So "
"an `i8` can store numbers from −(2<sup>7</sup>) to 2<sup>7</sup> − 1, which "
"equals −128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</"
"sup> − 1, so a `u8` can store numbers from 0 to 2<sup>8</sup> − 1, which "
"equals 0 to 255."
msgstr "각 부호 있는 variant는 −(2<sup>n − 1</sup>)에서 2<sup>n − 1</sup> − 1까지의 숫자를 포함하여 저장할 수 있으며, 여기서 _n_은 해당 variant가 사용하는 비트 수입니다. 따라서 `i8`은 −(2<sup>7</sup>)에서 2<sup>7</sup> − 1까지, 즉 −128에서 127까지의 숫자를 저장할 수 있습니다. 부호 없는 variant는 0에서 2<sup>n</sup> − 1까지의 숫자를 저장할 수 있으므로, `u8`은 0에서 2<sup>8</sup> − 1까지, 즉 0에서 255까지의 숫자를 저장할 수 있습니다."

#: src/ch03-02-data-types.md:86
msgid ""
"Additionally, the `isize` and `usize` types depend on the architecture of "
"the computer your program is running on, which is denoted in the table as "
"“arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on "
"a 32-bit architecture."
msgstr "또한, `isize`와 `usize` 타입은 프로그램이 실행되는 컴퓨터의 아키텍처에 따라 달라지며, 표에서는 “arch”로 표시됩니다: 64비트 아키텍처에서는 64비트, 32비트 아키텍처에서는 32비트입니다."

#: src/ch03-02-data-types.md:91
msgid ""
"You can write integer literals in any of the forms shown in Table 3-2. Note "
"that number literals that can be multiple numeric types allow a type suffix, "
"such as `57u8`, to designate the type. Number literals can also use `_` as a "
"visual separator to make the number easier to read, such as `1_000`, which "
"will have the same value as if you had specified `1000`."
msgstr "표 3-2에 표시된 형식 중 하나로 정수 리터럴을 작성할 수 있습니다. 여러 숫자 타입이 될 수 있는 숫자 리터럴은 타입을 지정하기 위해 `57u8`과 같은 타입 접미사를 허용합니다. 또한 숫자 리터럴은 숫자를 더 쉽게 읽을 수 있도록 시각적 구분 기호로 `_`를 사용할 수 있습니다. 예를 들어, `1_000`은 `1000`을 지정한 것과 동일한 값을 가집니다."

#: src/ch03-02-data-types.md:97
msgid "<span class=\"caption\">Table 3-2: Integer Literals in Rust</span>"
msgstr "<span class=\"caption\">표 3-2: 러스트의 정수 리터럴</span>"

#: src/ch03-02-data-types.md:99
msgid "Number literals"
msgstr "숫자 리터럴"

#: src/ch03-02-data-types.md:99 src/appendix-02-operators.md:16
msgid "Example"
msgstr "예시"

#: src/ch03-02-data-types.md:101
msgid "Decimal"
msgstr "십진수"

#: src/ch03-02-data-types.md:101
msgid "`98_222`"
msgstr "`98_222`"

#: src/ch03-02-data-types.md:102
msgid "Hex"
msgstr "16진수"

#: src/ch03-02-data-types.md:102
msgid "`0xff`"
msgstr "`0xff`"

#: src/ch03-02-data-types.md:103
msgid "Octal"
msgstr "8진수"

#: src/ch03-02-data-types.md:103
msgid "`0o77`"
msgstr "`0o77`"

#: src/ch03-02-data-types.md:104
msgid "Binary"
msgstr "2진수"

#: src/ch03-02-data-types.md:104
msgid "`0b1111_0000`"
msgstr "`0b1111_0000`"

#: src/ch03-02-data-types.md:105
msgid "Byte (`u8` only)"
msgstr "바이트 (`u8` 전용)"

#: src/ch03-02-data-types.md:105
msgid "`b'A'`"
msgstr "`b'A'`"

#: src/ch03-02-data-types.md:107
msgid ""
"So how do you know which type of integer to use? If you’re unsure, Rust’s "
"defaults are generally good places to start: integer types default to `i32`. "
"The primary situation in which you’d use `isize` or `usize` is when indexing "
"some sort of collection."
msgstr "그렇다면 어떤 정수 타입을 사용해야 할까요? 확실하지 않다면, 러스트의 기본값이 일반적으로 좋은 시작점입니다: 정수 타입은 기본적으로 `i32`입니다. `isize` 또는 `usize`를 사용하는 주된 상황은 어떤 종류의 컬렉션을 인덱싱할 때입니다."

#: src/ch03-02-data-types.md:112
msgid "Integer Overflow"
msgstr "정수 오버플로"

#: src/ch03-02-data-types.md:114
msgid ""
"Let’s say you have a variable of type `u8` that can hold values between 0 "
"and 255. If you try to change the variable to a value outside that range, "
"such as 256, _integer overflow_ will occur, which can result in one of two "
"behaviors. When you’re compiling in debug mode, Rust includes checks for "
"integer overflow that cause your program to _panic_ at runtime if this "
"behavior occurs. Rust uses the term _panicking_ when a program exits with an "
"error; we’ll discuss panics in more depth in the [“Unrecoverable Errors with "
"`panic!`”](ch09-01-unrecoverable-errors-with-panic.html)<!-- ignore --> "
"section in Chapter 9."
msgstr "0에서 255 사이의 값을 가질 수 있는 `u8` 타입의 변수가 있다고 가정해 봅시다. 변수를 256과 같이 해당 범위를 벗어나는 값으로 변경하려고 하면 _정수 오버플로_가 발생하며, 이는 두 가지 동작 중 하나를 초래할 수 있습니다. 디버그 모드에서 컴파일할 때, 러스트는 정수 오버플로에 대한 검사를 포함하여 이 동작이 발생하면 런타임에 프로그램이 _패닉_하도록 합니다. 러스트는 프로그램이 오류와 함께 종료될 때 _패닉_이라는 용어를 사용합니다. 패닉에 대해서는 9장의 [“`panic!`을 사용한 복구 불가능한 오류”](ch09-01-unrecoverable-errors-with-panic.html)<!-- ignore --> 섹션에서 더 자세히 다룰 것입니다."

#: src/ch03-02-data-types.md:124
msgid ""
"When you’re compiling in release mode with the `--release` flag, Rust does "
"_not_ include checks for integer overflow that cause panics. Instead, if "
"overflow occurs, Rust performs _two’s complement wrapping_. In short, values "
"greater than the maximum value the type can hold “wrap around” to the "
"minimum of the values the type can hold. In the case of a `u8`, the value "
"256 becomes 0, the value 257 becomes 1, and so on. The program won’t panic, "
"but the variable will have a value that probably isn’t what you were "
"expecting it to have. Relying on integer overflow’s wrapping behavior is "
"considered an error."
msgstr "--release` 플래그를 사용하여 릴리스 모드로 컴파일할 때, 러스트는 패닉을 유발하는 정수 오버플로 검사를 _포함하지 않습니다_. 대신, 오버플로가 발생하면 러스트는 _2의 보수 래핑_을 수행합니다. 간단히 말해, 타입이 가질 수 있는 최대값을 초과하는 값은 타입이 가질 수 있는 최소값으로 \"래핑\"됩니다. `u8`의 경우, 값 256은 0이 되고, 값 257은 1이 되는 식입니다. 프로그램은 패닉하지 않지만, 변수는 아마도 당신이 예상했던 값이 아닐 것입니다. 정수 오버플로의 래핑 동작에 의존하는 것은 오류로 간주됩니다."

#: src/ch03-02-data-types.md:133
msgid ""
"To explicitly handle the possibility of overflow, you can use these families "
"of methods provided by the standard library for primitive numeric types:"
msgstr "오버플로 가능성을 명시적으로 처리하려면, 기본 숫자 타입에 대해 표준 라이브러리에서 제공하는 다음 메서드들을 사용할 수 있습니다:"

#: src/ch03-02-data-types.md:136
msgid ""
"Wrap in all modes with the `wrapping_*` methods, such as `wrapping_add`."
msgstr "`wrapping_add`와 같은 `wrapping_*` 메서드를 사용하여 모든 모드에서 래핑합니다."

#: src/ch03-02-data-types.md:137
msgid ""
"Return the `None` value if there is overflow with the `checked_*` methods."
msgstr "`checked_*` 메서드를 사용하여 오버플로가 발생하면 `None` 값을 반환합니다."

#: src/ch03-02-data-types.md:138
msgid ""
"Return the value and a Boolean indicating whether there was overflow with "
"the `overflowing_*` methods."
msgstr "`overflowing_*` 메서드를 사용하여 값과 오버플로 발생 여부를 나타내는 불리언을 반환합니다."

#: src/ch03-02-data-types.md:140
msgid ""
"Saturate at the value’s minimum or maximum values with the `saturating_*` "
"methods."
msgstr "`saturating_*` 메서드를 사용하여 값의 최소 또는 최대값에서 포화시킵니다."

#: src/ch03-02-data-types.md:143
msgid "Floating-Point Types"
msgstr "부동소수점 타입"

#: src/ch03-02-data-types.md:145
msgid ""
"Rust also has two primitive types for _floating-point numbers_, which are "
"numbers with decimal points. Rust’s floating-point types are `f32` and "
"`f64`, which are 32 bits and 64 bits in size, respectively. The default type "
"is `f64` because on modern CPUs, it’s roughly the same speed as `f32` but is "
"capable of more precision. All floating-point types are signed."
msgstr "러스트는 또한 소수점이 있는 숫자, 즉 _부동소수점 숫자_를 위한 두 가지 기본 타입을 가지고 있습니다. 러스트의 부동소수점 타입은 `f32`와 `f64`이며, 각각 32비트와 64비트 크기입니다. 현대 CPU에서는 `f32`와 거의 같은 속도이지만 더 높은 정밀도를 가질 수 있기 때문에 기본 타입은 `f64`입니다. 모든 부동소수점 타입은 부호가 있습니다."

#: src/ch03-02-data-types.md:151
msgid "Here’s an example that shows floating-point numbers in action:"
msgstr "다음은 부동소수점 숫자가 작동하는 방식을 보여주는 예입니다:"

#: src/ch03-02-data-types.md:157
msgid "// f64\n"
msgstr "// f64\n"

#: src/ch03-02-data-types.md:159
msgid "// f32\n"
msgstr "// f32\n"

#: src/ch03-02-data-types.md:163
msgid ""
"Floating-point numbers are represented according to the IEEE-754 standard."
msgstr "부동소수점 숫자는 IEEE-754 표준에 따라 표현됩니다."

#: src/ch03-02-data-types.md:165
msgid "Numeric Operations"
msgstr "수치 연산"

#: src/ch03-02-data-types.md:167
msgid ""
"Rust supports the basic mathematical operations you’d expect for all the "
"number types: addition, subtraction, multiplication, division, and "
"remainder. Integer division truncates toward zero to the nearest integer. "
"The following code shows how you’d use each numeric operation in a `let` "
"statement:"
msgstr "러스트는 모든 숫자 타입에 대해 예상할 수 있는 기본적인 수학 연산(덧셈, 뺄셈, 곱셈, 나눗셈, 나머지)을 지원합니다. 정수 나눗셈은 0에 가까운 가장 가까운 정수로 절삭합니다. 다음 코드는 `let` 문에서 각 수치 연산을 사용하는 방법을 보여줍니다:"

#: src/ch03-02-data-types.md:176
msgid "// addition\n"
msgstr "// 덧셈\n"

#: src/ch03-02-data-types.md:179
msgid "// subtraction\n"
msgstr "// 뺄셈\n"

#: src/ch03-02-data-types.md:182
msgid "// multiplication\n"
msgstr "// 곱셈\n"

#: src/ch03-02-data-types.md:185
msgid "// division\n"
msgstr "// 나눗셈\n"

#: src/ch03-02-data-types.md:187
msgid "// Results in -1\n"
msgstr "// 결과는 -1\n"

#: src/ch03-02-data-types.md:189
msgid "// remainder\n"
msgstr "// 나머지\n"

#: src/ch03-02-data-types.md:194
msgid ""
"Each expression in these statements uses a mathematical operator and "
"evaluates to a single value, which is then bound to a variable. [Appendix B]"
"(appendix-02-operators.md)<!-- ignore --> contains a list of all operators "
"that Rust provides."
msgstr "이 문장의 각 표현식은 수학 연산자를 사용하며 단일 값으로 평가되고, 이 값은 변수에 바인딩됩니다. [부록 B](appendix-02-operators.md)<!-- ignore -->에는 러스트가 제공하는 모든 연산자 목록이 포함되어 있습니다."

#: src/ch03-02-data-types.md:199
msgid "The Boolean Type"
msgstr "불리언 타입"

#: src/ch03-02-data-types.md:201
msgid ""
"As in most other programming languages, a Boolean type in Rust has two "
"possible values: `true` and `false`. Booleans are one byte in size. The "
"Boolean type in Rust is specified using `bool`. For example:"
msgstr "대부분의 다른 프로그래밍 언어와 마찬가지로, 러스트의 불리언 타입은 `true`와 `false` 두 가지 가능한 값을 가집니다. 불리언은 1바이트 크기입니다. 러스트의 불리언 타입은 `bool`을 사용하여 지정됩니다. 예를 들어:"

#: src/ch03-02-data-types.md:211
#: src/ch03-02-data-types.md:229
msgid "// with explicit type annotation\n"
msgstr "// 명시적 타입 명시와 함께\n"

#: src/ch03-02-data-types.md:215
msgid ""
"The main way to use Boolean values is through conditionals, such as an `if` "
"expression. We’ll cover how `if` expressions work in Rust in the [“Control "
"Flow”](ch03-05-control-flow.html#control-flow)<!-- ignore --> section."
msgstr "불리언 값을 사용하는 주된 방법은 `if` 표현식과 같은 조건문을 통해서입니다. 러스트에서 `if` 표현식이 어떻게 작동하는지는 [“제어 흐름”](ch03-05-control-flow.html#control-flow)<!-- ignore --> 섹션에서 다룰 것입니다."

#: src/ch03-02-data-types.md:219
msgid "The Character Type"
msgstr "문자 타입"

#: src/ch03-02-data-types.md:221
msgid ""
"Rust’s `char` type is the language’s most primitive alphabetic type. Here "
"are some examples of declaring `char` values:"
msgstr "러스트의 `char` 타입은 언어의 가장 기본적인 알파벳 타입입니다. 다음은 `char` 값을 선언하는 몇 가지 예입니다:"

#: src/ch03-02-data-types.md:228 src/ch19-03-pattern-syntax.md:144
msgid "'z'"
msgstr "'z'"

#: src/ch03-02-data-types.md:229
msgid "'ℤ'"
msgstr "'ℤ'"

#: src/ch03-02-data-types.md:230
msgid "'😻'"
msgstr "'😻'"

#: src/ch03-02-data-types.md:234
msgid ""
"Note that we specify `char` literals with single quotes, as opposed to "
"string literals, which use double quotes. Rust’s `char` type is four bytes "
"in size and represents a Unicode Scalar Value, which means it can represent "
"a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean "
"characters; emoji; and zero-width spaces are all valid `char` values in "
"Rust. Unicode Scalar Values range from `U+0000` to `U+D7FF` and `U+E000` to "
"`U+10FFFF` inclusive. However, a “character” isn’t really a concept in "
"Unicode, so your human intuition for what a “character” is may not match up "
"with what a `char` is in Rust. We’ll discuss this topic in detail in "
"[“Storing UTF-8 Encoded Text with Strings”](ch08-02-strings.html#storing-"
"utf-8-encoded-text-with-strings)<!-- ignore --> in Chapter 8."
msgstr "문자열 리터럴이 큰따옴표를 사용하는 것과 달리, `char` 리터럴은 작은따옴표로 지정한다는 점에 유의하세요. 러스트의 `char` 타입은 4바이트 크기이며 유니코드 스칼라 값을 나타냅니다. 이는 ASCII보다 훨씬 더 많은 것을 표현할 수 있다는 의미입니다. 악센트가 있는 문자, 중국어, 일본어, 한국어 문자, 이모지, 그리고 너비가 0인 공백은 모두 러스트에서 유효한 `char` 값입니다. 유니코드 스칼라 값은 `U+0000`부터 `U+D7FF`까지, 그리고 `U+E000`부터 `U+10FFFF`까지 포함합니다. 그러나 유니코드에서 \"문자\"는 실제 개념이 아니므로, \"문자\"에 대한 인간의 직관이 러스트의 `char`와 일치하지 않을 수 있습니다. 이 주제는 8장의 [“문자열로 UTF-8 인코딩된 텍스트 저장하기”](ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)<!-- ignore -->에서 자세히 다룰 것입니다."

#: src/ch03-02-data-types.md:245
msgid "Compound Types"
msgstr "복합 타입"

#: src/ch03-02-data-types.md:247
msgid ""
"_Compound types_ can group multiple values into one type. Rust has two "
"primitive compound types: tuples and arrays."
msgstr "_복합 타입_은 여러 값을 하나의 타입으로 그룹화할 수 있습니다. 러스트에는 튜플과 배열이라는 두 가지 기본 복합 타입이 있습니다."

#: src/ch03-02-data-types.md:250
msgid "The Tuple Type"
msgstr "튜플 타입"

#: src/ch03-02-data-types.md:252
msgid ""
"A _tuple_ is a general way of grouping together a number of values with a "
"variety of types into one compound type. Tuples have a fixed length: once "
"declared, they cannot grow or shrink in size."
msgstr "_튜플_은 다양한 타입의 여러 값을 하나의 복합 타입으로 묶는 일반적인 방법입니다. 튜플은 고정된 길이를 가집니다: 일단 선언되면 크기가 커지거나 줄어들 수 없습니다."

#: src/ch03-02-data-types.md:256
msgid ""
"We create a tuple by writing a comma-separated list of values inside "
"parentheses. Each position in the tuple has a type, and the types of the "
"different values in the tuple don’t have to be the same. We’ve added "
"optional type annotations in this example:"
msgstr "괄호 안에 쉼표로 구분된 값 목록을 작성하여 튜플을 생성합니다. 튜플의 각 위치는 타입을 가지며, 튜플 내의 다른 값들의 타입은 같을 필요가 없습니다. 이 예제에서는 선택적 타입 명시를 추가했습니다:"

#: src/ch03-02-data-types.md:269
msgid ""
"The variable `tup` is bound to the entire tuple, because a tuple is "
"considered a single compound element. To get the individual values out of a "
"tuple, we can use pattern matching to destructure a tuple value, like this:"
msgstr ""
"변수 `tup`은 전체 튜플에 바인딩됩니다. 왜냐하면 튜플은 단일 복합 요소로 "
"간주되기 때문입니다. 튜플에서 개별 값을 가져오려면 다음과 같이 패턴 매칭을 사용하여 "
"튜플 값을 분해할 수 있습니다:"

#: src/ch03-02-data-types.md:281 src/ch03-03-how-functions-work.md:230
msgid "\"The value of y is: {y}\""
msgstr "\"y의 값은: {y}\""

#: src/ch03-02-data-types.md:285
msgid ""
"This program first creates a tuple and binds it to the variable `tup`. It "
"then uses a pattern with `let` to take `tup` and turn it into three separate "
"variables, `x`, `y`, and `z`. This is called _destructuring_ because it "
"breaks the single tuple into three parts. Finally, the program prints the "
"value of `y`, which is `6.4`."
msgstr "이 프로그램은 먼저 튜플을 생성하고 `tup` 변수에 바인딩합니다. 그런 다음 `let`과 함께 패턴을 사용하여 `tup`을 가져와 `x`, `y`, `z` 세 개의 개별 변수로 만듭니다. 이것은 단일 튜플을 세 부분으로 나누기 때문에 _구조 분해_라고 불립니다. 마지막으로, 프로그램은 `y`의 값인 `6.4`를 출력합니다."

#: src/ch03-02-data-types.md:291
msgid ""
"We can also access a tuple element directly by using a period (`.`) followed "
"by the index of the value we want to access. For example:"
msgstr "점(`.`) 뒤에 접근하려는 값의 인덱스를 사용하여 튜플 요소를 직접 접근할 수도 있습니다. 예를 들어:"

#: src/ch03-02-data-types.md:308
msgid ""
"This program creates the tuple `x` and then accesses each element of the "
"tuple using their respective indices. As with most programming languages, "
"the first index in a tuple is 0."
msgstr "이 프로그램은 튜플 `x`를 생성한 다음, 각 요소의 인덱스를 사용하여 튜플의 각 요소에 접근합니다. 대부분의 프로그래밍 언어와 마찬가지로, 튜플의 첫 번째 인덱스는 0입니다."

#: src/ch03-02-data-types.md:312
msgid ""
"The tuple without any values has a special name, _unit_. This value and its "
"corresponding type are both written `()` and represent an empty value or an "
"empty return type. Expressions implicitly return the unit value if they "
"don’t return any other value."
msgstr "값이 없는 튜플은 _유닛_이라는 특별한 이름을 가집니다. 이 값과 해당 타입은 모두 `()`로 작성되며 빈 값 또는 빈 반환 타입을 나타냅니다. 표현식은 다른 값을 반환하지 않으면 암시적으로 유닛 값을 반환합니다."

#: src/ch03-02-data-types.md:317
msgid "The Array Type"
msgstr "배열 타입"

#: src/ch03-02-data-types.md:319
msgid ""
"Another way to have a collection of multiple values is with an _array_. "
"Unlike a tuple, every element of an array must have the same type. Unlike "
"arrays in some other languages, arrays in Rust have a fixed length."
msgstr "여러 값의 컬렉션을 가지는 또 다른 방법은 _배열_을 사용하는 것입니다. 튜플과 달리, 배열의 모든 요소는 동일한 타입을 가져야 합니다. 다른 일부 언어의 배열과 달리, 러스트의 배열은 고정된 길이를 가집니다."

#: src/ch03-02-data-types.md:323
msgid ""
"We write the values in an array as a comma-separated list inside square "
"brackets:"
msgstr "배열의 값은 대괄호 안에 쉼표로 구분된 목록으로 작성합니다:"

#: src/ch03-02-data-types.md:334
msgid ""
"Arrays are useful when you want your data allocated on the stack, the same "
"as the other types we have seen so far, rather than the heap (we will "
"discuss the stack and the heap more in [Chapter 4](ch04-01-what-is-"
"ownership.html#the-stack-and-the-heap)<!-- ignore -->) or when you want to "
"ensure you always have a fixed number of elements. An array isn’t as "
"flexible as the vector type, though. A _vector_ is a similar collection type "
"provided by the standard library that _is_ allowed to grow or shrink in "
"size. If you’re unsure whether to use an array or a vector, chances are you "
"should use a vector. [Chapter 8](ch08-01-vectors.html)<!-- ignore --> "
"discusses vectors in more detail."
msgstr "배열은 지금까지 본 다른 타입과 마찬가지로 데이터를 힙이 아닌 스택에 할당하고 싶을 때(스택과 힙에 대해서는 [4장](ch04-01-what-is-ownership.html#the-stack-and-the-heap)<!-- ignore -->에서 더 자세히 논의할 것입니다) 또는 항상 고정된 수의 요소를 가지고 있음을 보장하고 싶을 때 유용합니다. 하지만 배열은 벡터 타입만큼 유연하지 않습니다. _벡터_는 표준 라이브러리에서 제공하는 유사한 컬렉션 타입으로, 크기가 커지거나 줄어들 수 있습니다. 배열을 사용할지 벡터를 사용할지 확실하지 않다면, 아마도 벡터를 사용해야 할 것입니다. [8장](ch08-01-vectors.html)<!-- ignore -->에서 벡터에 대해 더 자세히 논의합니다."

#: src/ch03-02-data-types.md:343
msgid ""
"However, arrays are more useful when you know the number of elements will "
"not need to change. For example, if you were using the names of the month in "
"a program, you would probably use an array rather than a vector because you "
"know it will always contain 12 elements:"
msgstr "그러나 배열은 요소의 수가 변경될 필요가 없다는 것을 알 때 더 유용합니다. 예를 들어, 프로그램에서 월 이름을 사용한다면, 항상 12개의 요소를 포함한다는 것을 알기 때문에 벡터보다는 배열을 사용할 것입니다:"

#: src/ch03-02-data-types.md:349
msgid "\"January\""
msgstr "\"January\""

#: src/ch03-02-data-types.md:349
msgid "\"February\""
msgstr "\"February\""

#: src/ch03-02-data-types.md:349
msgid "\"March\""
msgstr "\"March\""

#: src/ch03-02-data-types.md:349
msgid "\"April\""
msgstr "\"April\""

#: src/ch03-02-data-types.md:349
msgid "\"May\""
msgstr "\"May\""

#: src/ch03-02-data-types.md:349
msgid "\"June\""
msgstr "\"June\""

#: src/ch03-02-data-types.md:349
msgid "\"July\""
msgstr "\"July\""

#: src/ch03-02-data-types.md:350
msgid "\"August\""
msgstr "\"August\""

#: src/ch03-02-data-types.md:350
msgid "\"September\""
msgstr "\"September\""

#: src/ch03-02-data-types.md:350
msgid "\"October\""
msgstr "\"October\""

#: src/ch03-02-data-types.md:350
msgid "\"November\""
msgstr "\"November\""

#: src/ch03-02-data-types.md:350
msgid "\"December\""
msgstr "\"December\""

#: src/ch03-02-data-types.md:353
msgid ""
"You write an array’s type using square brackets with the type of each "
"element, a semicolon, and then the number of elements in the array, like so:"
msgstr "배열의 타입은 각 요소의 타입, 세미콜론, 그리고 배열의 요소 수를 대괄호 안에 사용하여 다음과 같이 작성합니다:"

#: src/ch03-02-data-types.md:360
msgid ""
"Here, `i32` is the type of each element. After the semicolon, the number `5` "
"indicates the array contains five elements."
msgstr "여기서 `i32`는 각 요소의 타입입니다. 세미콜론 뒤의 숫자 `5`는 배열이 다섯 개의 요소를 포함한다는 것을 나타냅니다."

#: src/ch03-02-data-types.md:363
msgid ""
"You can also initialize an array to contain the same value for each element "
"by specifying the initial value, followed by a semicolon, and then the "
"length of the array in square brackets, as shown here:"
msgstr "또한 여기에 표시된 것처럼 초기 값을 지정하고 세미콜론, 그리고 대괄호 안에 배열의 길이를 지정하여 각 요소에 동일한 값을 포함하도록 배열을 초기화할 수도 있습니다:"

#: src/ch03-02-data-types.md:371
msgid ""
"The array named `a` will contain `5` elements that will all be set to the "
"value `3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` "
"but in a more concise way."
msgstr "`a`라는 이름의 배열은 처음에 모두 `3` 값으로 설정될 `5`개의 요소를 포함할 것입니다. 이것은 `let a = [3, 3, 3, 3, 3];`라고 작성하는 것과 같지만 더 간결한 방법입니다."

#: src/ch03-02-data-types.md:375
msgid "Accessing Array Elements"
msgstr "배열 요소에 접근하기"

#: src/ch03-02-data-types.md:377
msgid ""
"An array is a single chunk of memory of a known, fixed size that can be "
"allocated on the stack. You can access elements of an array using indexing, "
"like this:"
msgstr "배열은 알려진 고정 크기의 단일 메모리 덩어리로, 스택에 할당될 수 있습니다. 다음과 같이 인덱싱을 사용하여 배열의 요소에 접근할 수 있습니다:"

#: src/ch03-02-data-types.md:392
msgid ""
"In this example, the variable named `first` will get the value `1` because "
"that is the value at index `[0]` in the array. The variable named `second` "
"will get the value `2` from index `[1]` in the array."
msgstr "이 예에서 `first`라는 변수는 배열의 인덱스 `[0]`에 있는 값이므로 `1`을 얻게 됩니다. `second`라는 변수는 배열의 인덱스 `[1]`에서 `2` 값을 얻게 됩니다."

#: src/ch03-02-data-types.md:396
msgid "Invalid Array Element Access"
msgstr "잘못된 배열 요소 접근"

#: src/ch03-02-data-types.md:398
msgid ""
"Let’s see what happens if you try to access an element of an array that is "
"past the end of the array. Say you run this code, similar to the guessing "
"game in Chapter 2, to get an array index from the user:"
msgstr "배열의 끝을 넘어선 배열 요소에 접근하려고 하면 어떻게 되는지 살펴보겠습니다. 2장의 추측 게임과 유사하게, 사용자로부터 배열 인덱스를 얻기 위해 이 코드를 실행한다고 가정해 봅시다:"

#: src/ch03-02-data-types.md:410
msgid "\"Please enter an array index.\""
msgstr "\"배열 인덱스를 입력하세요.\""

#: src/ch03-02-data-types.md:421
msgid "\"Index entered was not a number\""
msgstr "\"입력된 인덱스가 숫자가 아닙니다\""

#: src/ch03-02-data-types.md:425
msgid "\"The value of the element at index {index} is: {element}\""
msgstr "\"인덱스 {index}에 있는 요소의 값은: {element}\""

#: src/ch03-02-data-types.md:429
msgid ""
"This code compiles successfully. If you run this code using `cargo run` and "
"enter `0`, `1`, `2`, `3`, or `4`, the program will print out the "
"corresponding value at that index in the array. If you instead enter a "
"number past the end of the array, such as `10`, you’ll see output like this:"
msgstr "이 코드는 성공적으로 컴파일됩니다. `cargo run`을 사용하여 이 코드를 실행하고 `0`, `1`, `2`, `3` 또는 `4`를 입력하면 프로그램은 배열의 해당 인덱스에 있는 해당 값을 출력합니다. 대신 배열의 끝을 지난 숫자(예: `10`)를 입력하면 다음과 같은 출력이 표시됩니다."

#: src/ch03-02-data-types.md:446
msgid ""
"The program resulted in a _runtime_ error at the point of using an invalid "
"value in the indexing operation. The program exited with an error message "
"and didn’t execute the final `println!` statement. When you attempt to "
"access an element using indexing, Rust will check that the index you’ve "
"specified is less than the array length. If the index is greater than or "
"equal to the length, Rust will panic. This check has to happen at runtime, "
"especially in this case, because the compiler can’t possibly know what value "
"a user will enter when they run the code later."
msgstr "프로그램은 인덱싱 작업에서 유효하지 않은 값을 사용하는 지점에서 _런타임_ 오류가 발생했습니다. 프로그램은 오류 메시지와 함께 종료되었고 최종 `println!` 문을 실행하지 않았습니다. 인덱싱을 사용하여 요소에 접근하려고 할 때 Rust는 지정한 인덱스가 배열 길이보다 작은지 확인합니다. 인덱스가 길이보다 크거나 같으면 Rust는 패닉합니다. 이 확인은 런타임에 발생해야 합니다. 특히 이 경우 컴파일러는 사용자가 나중에 코드를 실행할 때 어떤 값을 입력할지 알 수 없기 때문입니다."

#: src/ch03-02-data-types.md:455
msgid ""
"This is an example of Rust’s memory safety principles in action. In many low-"
"level languages, this kind of check is not done, and when you provide an "
"incorrect index, invalid memory can be accessed. Rust protects you against "
"this kind of error by immediately exiting instead of allowing the memory "
"access and continuing. Chapter 9 discusses more of Rust’s error handling and "
"how you can write readable, safe code that neither panics nor allows invalid "
"memory access."
msgstr "이것은 러스트의 메모리 안전 원칙이 실제로 작동하는 예입니다. 많은 저수준 언어에서는 이러한 종류의 확인을 수행하지 않으며, 잘못된 인덱스를 제공하면 유효하지 않은 메모리에 접근할 수 있습니다. 러스트는 메모리 접근을 허용하고 계속 진행하는 대신 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9장에서는 러스트의 오류 처리에 대해 더 자세히 논의하고, 패닉을 일으키거나 유효하지 않은 메모리 접근을 허용하지 않는 읽기 쉽고 안전한 코드를 작성하는 방법을 설명합니다."

#: src/ch03-03-how-functions-work.md:3
msgid ""
"Functions are prevalent in Rust code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr "함수는 러스트 코드에서 널리 사용됩니다. 여러분은 이미 언어에서 가장 중요한 함수 중 하나인 `main` 함수를 보았습니다. 이 함수는 많은 프로그램의 진입점입니다. 또한 새 함수를 선언할 수 있게 해주는 `fn` 키워드도 보았습니다."

#: src/ch03-03-how-functions-work.md:8
msgid ""
"Rust code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr "러스트 코드는 함수와 변수 이름에 대한 관례적인 스타일로 _스네이크 케이스_를 사용합니다. 스네이크 케이스에서는 모든 글자가 소문자이고 밑줄이 단어를 구분합니다. 다음은 함수 정의 예시를 포함하는 프로그램입니다:"

#: src/ch03-03-how-functions-work.md:22
msgid "\"Another function.\""
msgstr "\"또 다른 함수.\""

#: src/ch03-03-how-functions-work.md:26
msgid ""
"We define a function in Rust by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr "러스트에서는 `fn` 다음에 함수 이름과 한 쌍의 괄호를 입력하여 함수를 정의합니다. 중괄호는 컴파일러에게 함수 본문이 시작되고 끝나는 위치를 알려줍니다."

#: src/ch03-03-how-functions-work.md:30
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _after_ the `main` function in the source code; we could "
"have defined it before as well. Rust doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr "정의한 함수는 이름 뒤에 괄호를 붙여 호출할 수 있습니다. `another_function`은 프로그램에 정의되어 있으므로 `main` 함수 내에서 호출할 수 있습니다. 소스 코드에서 `main` 함수 _뒤에_ `another_function`을 정의했지만, 그 전에도 정의할 수 있었습니다. 러스트는 함수를 어디에 정의하는지는 신경 쓰지 않고, 호출자가 볼 수 있는 범위 내 어딘가에 정의되어 있기만 하면 됩니다."

#: src/ch03-03-how-functions-work.md:37
msgid ""
"Let’s start a new binary project named _functions_ to explore functions "
"further. Place the `another_function` example in _src/main.rs_ and run it. "
"You should see the following output:"
msgstr "함수를 더 자세히 알아보기 위해 _functions_라는 새 바이너리 프로젝트를 시작하겠습니다. `another_function` 예제를 _src/main.rs_에 넣고 실행하세요. 다음과 같은 출력이 표시되어야 합니다:"

#: src/ch03-03-how-functions-work.md:41
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s\n"
"     Running `target/debug/functions`\n"
"Hello, world!\n"
"Another function.\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:50
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr "줄은 `main` 함수에 나타나는 순서대로 실행됩니다. 먼저 “Hello, world!” 메시지가 출력된 다음 `another_function`이 호출되고 해당 메시지가 출력됩니다."

#: src/ch03-03-how-functions-work.md:54
msgid "Parameters"
msgstr "매개변수"

#: src/ch03-03-how-functions-work.md:56
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr "함수는 함수의 시그니처의 일부인 특별한 변수인 _매개변수_를 갖도록 정의할 수 있습니다. 함수에 매개변수가 있으면 해당 매개변수에 대한 구체적인 값을 제공할 수 있습니다. 기술적으로 구체적인 값은 _인수_라고 하지만, 일상적인 대화에서는 사람들이 함수 정의의 변수나 함수를 호출할 때 전달되는 구체적인 값 모두에 대해 _매개변수_와 _인수_라는 단어를 혼용하여 사용하는 경향이 있습니다."

#: src/ch03-03-how-functions-work.md:64
msgid "In this version of `another_function` we add a parameter:"
msgstr "이 버전의 `another_function`에서는 매개변수를 추가합니다:"

#: src/ch03-03-how-functions-work.md:78
msgid "Try running this program; you should get the following output:"
msgstr "이 프로그램을 실행해 보세요. 다음과 같은 출력을 얻어야 합니다:"

#: src/ch03-03-how-functions-work.md:80
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:88
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `i32`. When we pass `5` in to `another_function`, the "
"`println!` macro puts `5` where the pair of curly brackets containing `x` "
"was in the format string."
msgstr "`another_function`의 선언에는 `x`라는 이름의 매개변수가 하나 있습니다. `x`의 타입은 `i32`로 지정됩니다. `another_function`에 `5`를 전달하면 `println!` 매크로는 형식 문자열에서 `x`를 포함하는 중괄호 쌍이 있던 위치에 `5`를 넣습니다."

#: src/ch03-03-how-functions-work.md:93
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Rust’s design: requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more helpful error messages if it knows what types the function "
"expects."
msgstr "함수 시그니처에서는 각 매개변수의 타입을 _반드시_ 선언해야 합니다. 이것은 러스트 디자인의 의도적인 결정입니다. 함수 정의에서 타입 명시를 요구하면 컴파일러가 코드의 다른 곳에서 타입을 파악하기 위해 타입 명시를 거의 필요로 하지 않게 됩니다. 또한 컴파일러는 함수가 어떤 타입을 예상하는지 알면 더 유용한 오류 메시지를 제공할 수 있습니다."

#: src/ch03-03-how-functions-work.md:99
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr "여러 매개변수를 정의할 때는 다음과 같이 쉼표로 매개변수 선언을 구분합니다:"

#: src/ch03-03-how-functions-work.md:106
msgid "'h'"
msgstr "'h'"

#: src/ch03-03-how-functions-work.md:110
msgid "\"The measurement is: {value}{unit_label}\""
msgstr "\"측정값은: {value}{unit_label}\""

#: src/ch03-03-how-functions-work.md:114
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is an `i32`. The second "
"is named `unit_label` and is type `char`. The function then prints text "
"containing both the `value` and the `unit_label`."
msgstr "이 예제는 두 개의 매개변수를 가진 `print_labeled_measurement`라는 이름의 함수를 만듭니다. 첫 번째 매개변수는 `value`라는 이름의 `i32`입니다. 두 번째는 `unit_label`이라는 이름의 `char` 타입입니다. 그런 다음 함수는 `value`와 `unit_label`을 모두 포함하는 텍스트를 출력합니다."

#: src/ch03-03-how-functions-work.md:119
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/main.rs_ file with the preceding example and run "
"it using `cargo run`:"
msgstr "이 코드를 실행해 봅시다. 현재 _functions_ 프로젝트의 _src/main.rs_ 파일에 있는 프로그램을 앞의 예제로 바꾸고 `cargo run`을 사용하여 실행하세요:"

#: src/ch03-03-how-functions-work.md:123
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/functions`\n"
"The measurement is: 5h\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:131
msgid ""
"Because we called the function with `5` as the value for `value` and `'h'` "
"as the value for `unit_label`, the program output contains those values."
msgstr "`value`에 대한 값으로 `5`를, `unit_label`에 대한 값으로 `'h'`를 사용하여 함수를 호출했기 때문에 프로그램 출력에는 해당 값이 포함됩니다."

#: src/ch03-03-how-functions-work.md:134
msgid "Statements and Expressions"
msgstr "문과 표현식"

#: src/ch03-03-how-functions-work.md:136
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Rust is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr "함수 본문은 선택적으로 표현식으로 끝나는 일련의 문으로 구성됩니다. 지금까지 다룬 함수에는 끝나는 표현식이 포함되지 않았지만, 문의 일부로 표현식을 본 적이 있습니다. 러스트는 표현식 기반 언어이므로 이것은 이해해야 할 중요한 구별입니다. 다른 언어에는 동일한 구별이 없으므로 문과 표현식이 무엇이며 그 차이가 함수 본문에 어떤 영향을 미치는지 살펴보겠습니다."

#: src/ch03-03-how-functions-work.md:144
msgid ""
"**Statements** are instructions that perform some action and do not return a "
"value."
msgstr "**문**은 어떤 동작을 수행하고 값을 반환하지 않는 명령어입니다."

#: src/ch03-03-how-functions-work.md:146
msgid ""
"**Expressions** evaluate to a resultant value. Let’s look at some examples."
msgstr "**표현식**은 결과 값으로 평가됩니다. 몇 가지 예를 살펴보겠습니다."

#: src/ch03-03-how-functions-work.md:148
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 3-1, `let y = 6;` is a statement."
msgstr "사실 우리는 이미 문과 표현식을 사용했습니다. `let` 키워드로 변수를 만들고 값을 할당하는 것은 문입니다. 목록 3-1에서 `let y = 6;`은 문입니다."

#: src/ch03-03-how-functions-work.md:162
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself. (As we will see below, _calling_ a function is not a "
"statement.)"
msgstr "함수 정의도 문입니다. 앞의 전체 예제는 그 자체로 문입니다. (아래에서 보겠지만, 함수를 _호출_하는 것은 문이 아닙니다.)"

#: src/ch03-03-how-functions-work.md:166
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr "문은 값을 반환하지 않습니다. 따라서 다음 코드가 시도하는 것처럼 `let` 문을 다른 변수에 할당할 수 없습니다. 오류가 발생합니다:"

#: src/ch03-03-how-functions-work.md:177
msgid "When you run this program, the error you’ll get looks like this:"
msgstr "이 프로그램을 실행하면 다음과 같은 오류가 발생합니다:"

#: src/ch03-03-how-functions-work.md:179
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error: expected expression, found `let` statement\n"
" --> src/main.rs:2:14\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |              ^^^\n"
"  |\n"
"  = note: only supported directly in conditions of `if` and `while` "
"expressions\n"
"\n"
"warning: unnecessary parentheses around assigned value\n"
" --> src/main.rs:2:13\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |             ^         ^\n"
"  |\n"
"  = note: `#[warn(unused_parens)]` on by default\n"
"help: remove these parentheses\n"
"  |\n"
"2 -     let x = (let y = 6);\n"
"2 +     let x = let y = 6;\n"
"  |\n"
"\n"
"warning: `functions` (bin \"functions\") generated 1 warning\n"
"error: could not compile `functions` (bin \"functions\") due to 1 previous "
"error; 1 warning emitted\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:207
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Rust."
msgstr "`let y = 6` 문은 값을 반환하지 않으므로 `x`에 바인딩할 것이 없습니다. 이것은 할당이 할당 값을 반환하는 C 및 Ruby와 같은 다른 언어에서 발생하는 것과 다릅니다. 해당 언어에서는 `x = y = 6`을 작성하여 `x`와 `y` 모두 `6` 값을 갖게 할 수 있지만 러스트에서는 그렇지 않습니다."

#: src/ch03-03-how-functions-work.md:213
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Rust. Consider a math operation, such as `5 + 6`, which "
"is an expression that evaluates to the value `11`. Expressions can be part "
"of statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an "
"expression that evaluates to the value `6`. Calling a function is an "
"expression. Calling a macro is an expression. A new scope block created with "
"curly brackets is an expression, for example:"
msgstr "표현식은 값으로 평가되며 러스트에서 작성할 나머지 코드의 대부분을 구성합니다. `5 + 6`과 같은 수학 연산을 생각해 보세요. 이것은 `11`이라는 값으로 평가되는 표현식입니다. 표현식은 문의 일부가 될 수 있습니다. 목록 3-1에서 `let y = 6;` 문의 `6`은 `6`이라는 값으로 평가되는 표현식입니다. 함수를 호출하는 것은 표현식입니다. 매크로를 호출하는 것은 표현식입니다. 중괄호로 만든 새 범위 블록은 표현식입니다. 예를 들면 다음과 같습니다."

#: src/ch03-03-how-functions-work.md:234
msgid "This expression:"
msgstr "이 표현식은:"

#: src/ch03-03-how-functions-work.md:243
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note that the `x + 1` line doesn’t have "
"a semicolon at the end, which is unlike most of the lines you’ve seen so "
"far. Expressions do not include ending semicolons. If you add a semicolon to "
"the end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr "는 이 경우 `4`로 평가되는 블록입니다. 그 값은 `let` 문의 일부로 `y`에 바인딩됩니다. `x + 1` 줄 끝에 세미콜론이 없다는 점에 유의하세요. 이는 지금까지 본 대부분의 줄과 다릅니다. 표현식에는 끝나는 세미콜론이 포함되지 않습니다. 표현식 끝에 세미콜론을 추가하면 문으로 바뀌고 값을 반환하지 않습니다. 다음에 함수 반환 값과 표현식을 탐색할 때 이 점을 명심하세요."

#: src/ch03-03-how-functions-work.md:251
msgid "Functions with Return Values"
msgstr "반환 값이 있는 함수"

#: src/ch03-03-how-functions-work.md:253
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Rust, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr "함수는 호출한 코드로 값을 반환할 수 있습니다. 반환 값의 이름은 지정하지 않지만, 화살표(`->`) 뒤에 타입을 선언해야 합니다. 러스트에서 함수의 반환 값은 함수 본문 블록의 마지막 표현식 값과 동의어입니다. `return` 키워드를 사용하고 값을 지정하여 함수에서 일찍 반환할 수 있지만, 대부분의 함수는 마지막 표현식을 암시적으로 반환합니다. 다음은 값을 반환하는 함수의 예입니다."

#: src/ch03-03-how-functions-work.md:275
msgid ""
"There are no function calls, macros, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in "
"Rust. Note that the function’s return type is specified too, as `-> i32`. "
"Try running this code; the output should look like this:"
msgstr "`five` 함수에는 함수 호출, 매크로 또는 `let` 문조차 없습니다. 단지 숫자 `5`만 있습니다. 이것은 러스트에서 완벽하게 유효한 함수입니다. 함수의 반환 타입도 `-> i32`로 지정되어 있습니다. 이 코드를 실행해 보세요. 출력은 다음과 같아야 합니다."

#: src/ch03-03-how-functions-work.md:280
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:288
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `i32`. Let’s examine this in more detail. There are two important "
"bits: first, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr "`five`의 `5`는 함수의 반환 값이므로 반환 타입은 `i32`입니다. 이것을 더 자세히 살펴보겠습니다. 두 가지 중요한 점이 있습니다. 첫째, `let x = five();` 줄은 함수 반환 값을 사용하여 변수를 초기화하고 있음을 보여줍니다. `five` 함수가 `5`를 반환하기 때문에 해당 줄은 다음과 같습니다."

#: src/ch03-03-how-functions-work.md:298
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return."
msgstr "둘째, `five` 함수는 매개변수가 없고 반환 값의 타입을 정의하지만, 함수 본문은 반환하려는 값의 표현식이므로 세미콜론이 없는 외로운 `5`입니다."

#: src/ch03-03-how-functions-work.md:302
msgid "Let’s look at another example:"
msgstr "다른 예를 살펴보겠습니다."

#: src/ch03-03-how-functions-work.md:318
msgid ""
"Running this code will print `The value of x is: 6`. But if we place a "
"semicolon at the end of the line containing `x + 1`, changing it from an "
"expression to a statement, we’ll get an error:"
msgstr "이 코드를 실행하면 `x의 값은: 6`이 출력됩니다. 하지만 `x + 1`을 포함하는 줄 끝에 세미콜론을 넣어 표현식에서 문으로 바꾸면 오류가 발생합니다."

#: src/ch03-03-how-functions-work.md:336
msgid "Compiling this code produces an error, as follows:"
msgstr "이 코드를 컴파일하면 다음과 같이 오류가 발생합니다."

#: src/ch03-03-how-functions-work.md:338
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:7:24\n"
"  |\n"
"7 | fn plus_one(x: i32) -> i32 {\n"
"  |    --------            ^^^ expected `i32`, found `()`\n"
"  |    |\n"
"  |    implicitly returns `()` as its body has no tail or `return` "
"expression\n"
"8 |     x + 1;\n"
"  |          - help: remove this semicolon to return this value\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `functions` (bin \"functions\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:355
msgid ""
"The main error message, `mismatched types`, reveals the core issue with this "
"code. The definition of the function `plus_one` says that it will return an "
"`i32`, but statements don’t evaluate to a value, which is expressed by `()`, "
"the unit type. Therefore, nothing is returned, which contradicts the "
"function definition and results in an error. In this output, Rust provides a "
"message to possibly help rectify this issue: it suggests removing the "
"semicolon, which would fix the error."
msgstr "주요 오류 메시지인 `mismatched types`는 이 코드의 핵심 문제를 보여줍니다. `plus_one` 함수의 정의는 `i32`를 반환한다고 되어 있지만, 문은 값으로 평가되지 않으며, 이는 단위 타입인 `()`로 표현됩니다. 따라서 아무것도 반환되지 않으며, 이는 함수 정의와 모순되어 오류가 발생합니다. 이 출력에서 러스트는 이 문제를 해결하는 데 도움이 될 수 있는 메시지를 제공합니다. 즉, 세미콜론을 제거하면 오류가 해결될 것이라고 제안합니다."

#: src/ch03-04-comments.md:3
msgid ""
"All programmers strive to make their code easy to understand, but sometimes "
"extra explanation is warranted. In these cases, programmers leave _comments_ "
"in their source code that the compiler will ignore but people reading the "
"source code may find useful."
msgstr "모든 프로그래머는 코드를 이해하기 쉽게 만들려고 노력하지만, 때로는 추가 설명이 필요합니다. 이러한 경우 프로그래머는 소스 코드에 _주석_을 남겨 컴파일러는 무시하지만 소스 코드를 읽는 사람들에게는 유용할 수 있습니다."

#: src/ch03-04-comments.md:8
msgid "Here’s a simple comment:"
msgstr "다음은 간단한 주석입니다."

#: src/ch03-04-comments.md:11
msgid "// hello, world"
msgstr "// hello, world"

#: src/ch03-04-comments.md:14
msgid ""
"In Rust, the idiomatic comment style starts a comment with two slashes, and "
"the comment continues until the end of the line. For comments that extend "
"beyond a single line, you’ll need to include `//` on each line, like this:"
msgstr "러스트에서 관용적인 주석 스타일은 두 개의 슬래시로 주석을 시작하고, 주석은 줄 끝까지 계속됩니다. 한 줄을 넘는 주석의 경우, 다음과 같이 각 줄에 `//`를 포함해야 합니다."

#: src/ch03-04-comments.md:19
msgid "" "// So we're doing something complicated here, long enough that we need\n" "// multiple lines of comments to do it! Whew! Hopefully, this comment will\n" "// explain what's going on.\n" msgstr "" "// So we're doing something complicated here, long enough that we need\n" "// multiple lines of comments to do it! Whew! Hopefully, this comment will\n" "// explain what's going on.\n"

#: src/ch03-04-comments.md:24
msgid "Comments can also be placed at the end of lines containing code:"
msgstr "주석은 코드가 포함된 줄 끝에도 배치할 수 있습니다."

#: src/ch03-04-comments.md:30 src/ch03-04-comments.md:41
msgid "// I'm feeling lucky today"
msgstr "// I'm feeling lucky today"

#: src/ch03-04-comments.md:34
msgid ""
"But you’ll more often see them used in this format, with the comment on a "
"separate line above the code it’s annotating:"
msgstr "하지만 주석이 달린 코드 위의 별도 줄에 주석이 있는 이 형식으로 더 자주 사용되는 것을 볼 수 있습니다."

#: src/ch03-04-comments.md:46
msgid ""
"Rust also has another kind of comment, documentation comments, which we’ll "
"discuss in the [“Publishing a Crate to Crates.io”](ch14-02-publishing-to-"
"crates-io.html)<!-- ignore --> section of Chapter 14."
msgstr "러스트에는 문서 주석이라는 또 다른 종류의 주석도 있으며, 이에 대해서는 14장의 [“Crate를 Crates.io에 게시하기”](ch14-02-publishing-to-crates-io.html)<!-- ignore --> 섹션에서 설명합니다."

#: src/ch03-05-control-flow.md:3
msgid ""
"The ability to run some code depending on whether a condition is `true` and "
"to run some code repeatedly while a condition is `true` are basic building "
"blocks in most programming languages. The most common constructs that let "
"you control the flow of execution of Rust code are `if` expressions and "
"loops."
msgstr "조건이 `true`인지 여부에 따라 일부 코드를 실행하고 조건이 `true`인 동안 일부 코드를 반복적으로 실행하는 기능은 대부분의 프로그래밍 언어에서 기본적인 구성 요소입니다. 러스트 코드의 실행 흐름을 제어할 수 있는 가장 일반적인 구문은 `if` 표현식과 루프입니다."

#: src/ch03-05-control-flow.md:8
msgid "`if` Expressions"
msgstr "`if` 표현식"

#: src/ch03-05-control-flow.md:10
msgid ""
"An `if` expression allows you to branch your code depending on conditions. "
"You provide a condition and then state, “If this condition is met, run this "
"block of code. If the condition is not met, do not run this block of code.”"
msgstr "`if` 표현식은 조건에 따라 코드를 분기할 수 있게 해줍니다. 조건을 제공한 다음 “이 조건이 충족되면 이 코드 블록을 실행하세요. 조건이 충족되지 않으면 이 코드 블록을 실행하지 마세요.”라고 명시합니다."

#: src/ch03-05-control-flow.md:14
msgid ""
"Create a new project called _branches_ in your _projects_ directory to "
"explore the `if` expression. In the _src/main.rs_ file, input the following:"
msgstr "`if` 표현식을 탐색하기 위해 _projects_ 디렉토리에 _branches_라는 새 프로젝트를 만드세요. _src/main.rs_ 파일에 다음을 입력하세요."

#: src/ch03-05-control-flow.md:24 src/ch03-05-control-flow.md:64
msgid "\"condition was true\""
msgstr "\"조건이 참이었습니다\""

#: src/ch03-05-control-flow.md:26 src/ch03-05-control-flow.md:66
msgid "\"condition was false\""
msgstr "\"조건이 거짓이었습니다\""

#: src/ch03-05-control-flow.md:31
msgid ""
"All `if` expressions start with the keyword `if`, followed by a condition. "
"In this case, the condition checks whether or not the variable `number` has "
"a value less than 5. We place the block of code to execute if the condition "
"is `true` immediately after the condition inside curly brackets. Blocks of "
"code associated with the conditions in `if` expressions are sometimes called "
"_arms_, just like the arms in `match` expressions that we discussed in the "
"[“Comparing the Guess to the Secret Number”](ch02-00-guessing-game-"
"tutorial.html#comparing-the-guess-to-the-secret-number)<!--\n"
"ignore --> section of Chapter 2."
msgstr "모든 `if` 표현식은 `if` 키워드로 시작하고 그 뒤에 조건이 옵니다. 이 경우 조건은 `number` 변수의 값이 5보다 작은지 여부를 확인합니다. 조건이 `true`일 때 실행할 코드 블록은 조건 바로 뒤에 중괄호 안에 배치합니다. `if` 표현식의 조건과 관련된 코드 블록은 2장의 [“추측을 비밀 번호와 비교하기”](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)<!--\n ignore --> 섹션에서 논의한 `match` 표현식의 암(arm)과 마찬가지로 때때로 _암(arm)_이라고 불립니다."

#: src/ch03-05-control-flow.md:40
msgid ""
"Optionally, we can also include an `else` expression, which we chose to do "
"here, to give the program an alternative block of code to execute should the "
"condition evaluate to `false`. If you don’t provide an `else` expression and "
"the condition is `false`, the program will just skip the `if` block and move "
"on to the next bit of code."
msgstr "선택적으로, `else` 표현식을 포함할 수도 있습니다. 여기서는 조건이 `false`로 평가될 경우 프로그램이 실행할 대체 코드 블록을 제공하기 위해 그렇게 했습니다. `else` 표현식을 제공하지 않고 조건이 `false`이면 프로그램은 `if` 블록을 건너뛰고 다음 코드 부분으로 넘어갑니다."

#: src/ch03-05-control-flow.md:46
msgid "Try running this code; you should see the following output:"
msgstr "이 코드를 실행해 보세요. 다음과 같은 출력이 표시되어야 합니다."

#: src/ch03-05-control-flow.md:48
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"condition was true\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:56
msgid ""
"Let’s try changing the value of `number` to a value that makes the condition "
"`false` to see what happens:"
msgstr "`number`의 값을 조건을 `false`로 만드는 값으로 변경하여 어떤 일이 발생하는지 살펴보겠습니다."

#: src/ch03-05-control-flow.md:71
msgid "Run the program again, and look at the output:"
msgstr "프로그램을 다시 실행하고 출력을 확인하세요."

#: src/ch03-05-control-flow.md:73
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"condition was false\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:81
msgid ""
"It’s also worth noting that the condition in this code _must_ be a `bool`. "
"If the condition isn’t a `bool`, we’ll get an error. For example, try "
"running the following code:"
msgstr "이 코드의 조건은 `bool`이어야 한다는 점도 주목할 가치가 있습니다. 조건이 `bool`이 아니면 오류가 발생합니다. 예를 들어 다음 코드를 실행해 보세요."

#: src/ch03-05-control-flow.md:92
msgid "\"number was three\""
msgstr "\"숫자는 3이었습니다\""

#: src/ch03-05-control-flow.md:97
msgid ""
"The `if` condition evaluates to a value of `3` this time, and Rust throws an "
"error:"
msgstr "이번에는 `if` 조건이 `3` 값으로 평가되고, 러스트는 오류를 발생시킵니다."

#: src/ch03-05-control-flow.md:100
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:4:8\n"
"  |\n"
"4 |     if number {\n"
"  |        ^^^^^^ expected `bool`, found integer\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `branches` (bin \"branches\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:113
msgid ""
"The error indicates that Rust expected a `bool` but got an integer. Unlike "
"languages such as Ruby and JavaScript, Rust will not automatically try to "
"convert non-Boolean types to a Boolean. You must be explicit and always "
"provide `if` with a Boolean as its condition. If we want the `if` code block "
"to run only when a number is not equal to `0`, for example, we can change "
"the `if` expression to the following:"
msgstr "오류는 러스트가 `bool`을 예상했지만 정수를 받았음을 나타냅니다. Ruby 및 JavaScript와 같은 언어와 달리 러스트는 비불리언 타입을 자동으로 불리언으로 변환하려고 시도하지 않습니다. 명시적으로 `if`에 항상 불리언을 조건으로 제공해야 합니다. 예를 들어 숫자가 `0`과 같지 않을 때만 `if` 코드 블록을 실행하려면 `if` 표현식을 다음과 같이 변경할 수 있습니다."

#: src/ch03-05-control-flow.md:127
msgid "\"number was something other than zero\""
msgstr "\"숫자는 0이 아니었습니다\""

#: src/ch03-05-control-flow.md:132
msgid "Running this code will print `number was something other than zero`."
msgstr "이 코드를 실행하면 `숫자는 0이 아니었습니다`가 출력됩니다."

#: src/ch03-05-control-flow.md:134
msgid "Handling Multiple Conditions with `else if`"
msgstr "`else if`로 여러 조건 처리하기"

#: src/ch03-05-control-flow.md:136
msgid ""
"You can use multiple conditions by combining `if` and `else` in an `else if` "
"expression. For example:"
msgstr "`else if` 표현식에서 `if`와 `else`를 결합하여 여러 조건을 사용할 수 있습니다. 예를 들어:"

#: src/ch03-05-control-flow.md:146
msgid "\"number is divisible by 4\""
msgstr "\"숫자는 4로 나누어집니다\""

#: src/ch03-05-control-flow.md:148
msgid "\"number is divisible by 3\""
msgstr "\"숫자는 3으로 나누어집니다\""

#: src/ch03-05-control-flow.md:150
msgid "\"number is divisible by 2\""
msgstr "\"숫자는 2로 나누어집니다\""

#: src/ch03-05-control-flow.md:152
msgid "\"number is not divisible by 4, 3, or 2\""
msgstr "\"숫자는 4, 3, 2로 나누어지지 않습니다\""

#: src/ch03-05-control-flow.md:157
msgid ""
"This program has four possible paths it can take. After running it, you "
"should see the following output:"
msgstr "이 프로그램은 네 가지 가능한 경로를 가질 수 있습니다. 실행 후 다음과 같은 출력이 표시되어야 합니다."

#: src/ch03-05-control-flow.md:160
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/branches`\n"
"number is divisible by 3\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:168
msgid ""
"When this program executes, it checks each `if` expression in turn and "
"executes the first body for which the condition evaluates to `true`. Note "
"that even though 6 is divisible by 2, we don’t see the output `number is "
"divisible by 2`, nor do we see the `number is not divisible by 4, 3, or 2` "
"text from the `else` block. That’s because Rust only executes the block for "
"the first `true` condition, and once it finds one, it doesn’t even check the "
"rest."
msgstr "이 프로그램이 실행되면 각 `if` 표현식을 차례로 확인하고 조건이 `true`로 평가되는 첫 번째 본문을 실행합니다. 6은 2로 나누어지지만, `number is divisible by 2`라는 출력이나 `else` 블록의 `number is not divisible by 4, 3, or 2` 텍스트는 볼 수 없습니다. 이는 러스트가 첫 번째 `true` 조건에 대한 블록만 실행하고, 하나를 찾으면 나머지는 확인하지 않기 때문입니다."

#: src/ch03-05-control-flow.md:175
msgid ""
"Using too many `else if` expressions can clutter your code, so if you have "
"more than one, you might want to refactor your code. Chapter 6 describes a "
"powerful Rust branching construct called `match` for these cases."
msgstr "너무 많은 `else if` 표현식을 사용하면 코드가 복잡해질 수 있으므로, 하나 이상인 경우 코드를 리팩토링하는 것이 좋습니다. 6장에서는 이러한 경우를 위한 `match`라는 강력한 러스트 분기 구문에 대해 설명합니다."

#: src/ch03-05-control-flow.md:179
msgid "Using `if` in a `let` Statement"
msgstr "`let` 문에서 `if` 사용하기"

#: src/ch03-05-control-flow.md:181
msgid ""
"Because `if` is an expression, we can use it on the right side of a `let` "
"statement to assign the outcome to a variable, as in Listing 3-2."
msgstr "`if`는 표현식이므로, 목록 3-2와 같이 `let` 문의 오른쪽에 사용하여 결과를 변수에 할당할 수 있습니다."

#: src/ch03-05-control-flow.md:191 src/ch03-05-control-flow.md:224
msgid "\"The value of number is: {number}\""
msgstr "\"숫자의 값은: {number}\""

#: src/ch03-05-control-flow.md:197
msgid ""
"The `number` variable will be bound to a value based on the outcome of the "
"`if` expression. Run this code to see what happens:"
msgstr "`number` 변수는 `if` 표현식의 결과에 따라 값에 바인딩됩니다. 이 코드를 실행하여 어떤 일이 발생하는지 확인하세요."

#: src/ch03-05-control-flow.md:200
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/branches`\n"
"The value of number is: 5\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:208
msgid ""
"Remember that blocks of code evaluate to the last expression in them, and "
"numbers by themselves are also expressions. In this case, the value of the "
"whole `if` expression depends on which block of code executes. This means "
"the values that have the potential to be results from each arm of the `if` "
"must be the same type; in Listing 3-2, the results of both the `if` arm and "
"the `else` arm were `i32` integers. If the types are mismatched, as in the "
"following example, we’ll get an error:"
msgstr "코드 블록은 마지막 표현식으로 평가되며, 숫자 자체도 표현식이라는 것을 기억하세요. 이 경우 전체 `if` 표현식의 값은 어떤 코드 블록이 실행되는지에 따라 달라집니다. 이는 `if`의 각 암(arm)에서 결과가 될 수 있는 값들이 동일한 타입이어야 함을 의미합니다. 목록 3-2에서 `if` 암과 `else` 암의 결과는 모두 `i32` 정수였습니다. 다음 예제와 같이 타입이 일치하지 않으면 오류가 발생합니다."

#: src/ch03-05-control-flow.md:222
msgid "\"six\""
msgstr "\"여섯\""

#: src/ch03-05-control-flow.md:228
msgid ""
"When we try to compile this code, we’ll get an error. The `if` and `else` "
"arms have value types that are incompatible, and Rust indicates exactly "
"where to find the problem in the program:"
msgstr "이 코드를 컴파일하려고 하면 오류가 발생합니다. `if`와 `else` 암(arm)은 호환되지 않는 값 타입을 가지며, 러스트는 프로그램에서 문제가 있는 정확한 위치를 알려줍니다."

#: src/ch03-05-control-flow.md:232
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling branches v0.1.0 (file:///projects/branches)\n"
"error[E0308]: `if` and `else` have incompatible types\n"
" --> src/main.rs:4:44\n"
"  |\n"
"4 |     let number = if condition { 5 } else { \"six\" };\n"
"  |                                 -          ^^^^^ expected integer, found "
"`&str`\n"
"  |                                 |\n"
"  |                                 expected because of this\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `branches` (bin \"branches\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:247
msgid ""
"The expression in the `if` block evaluates to an integer, and the expression "
"in the `else` block evaluates to a string. This won’t work because variables "
"must have a single type, and Rust needs to know at compile time what type "
"the `number` variable is, definitively. Knowing the type of `number` lets "
"the compiler verify the type is valid everywhere we use `number`. Rust "
"wouldn’t be able to do that if the type of `number` was only determined at "
"runtime; the compiler would be more complex and would make fewer guarantees "
"about the code if it had to keep track of multiple hypothetical types for "
"any variable."
msgstr "`if` 블록의 표현식은 정수로 평가되고, `else` 블록의 표현식은 문자열로 평가됩니다. 변수는 단일 타입을 가져야 하고, 러스트는 컴파일 시점에 `number` 변수의 타입을 명확하게 알아야 하므로 이것은 작동하지 않습니다. `number`의 타입을 알면 컴파일러는 `number`를 사용하는 모든 곳에서 타입이 유효한지 확인할 수 있습니다. `number`의 타입이 런타임에만 결정된다면 러스트는 그렇게 할 수 없을 것입니다. 컴파일러는 더 복잡해지고 어떤 변수에 대해 여러 가상의 타입을 추적해야 한다면 코드에 대한 보장을 덜 할 것입니다."

#: src/ch03-05-control-flow.md:256
msgid "Repetition with Loops"
msgstr "반복문으로 반복하기"

#: src/ch03-05-control-flow.md:258
msgid ""
"It’s often useful to execute a block of code more than once. For this task, "
"Rust provides several _loops_, which will run through the code inside the "
"loop body to the end and then start immediately back at the beginning. To "
"experiment with loops, let’s make a new project called _loops_."
msgstr "코드 블록을 여러 번 실행하는 것이 종종 유용합니다. 이 작업을 위해 러스트는 여러 _루프_를 제공합니다. 루프는 루프 본문 안의 코드를 끝까지 실행한 다음 즉시 처음으로 돌아갑니다. 루프를 실험하기 위해 _loops_라는 새 프로젝트를 만들어 보겠습니다."

#: src/ch03-05-control-flow.md:263
msgid ""
"Rust has three kinds of loops: `loop`, `while`, and `for`. Let’s try each "
"one."
msgstr "러스트에는 `loop`, `while`, `for` 세 가지 종류의 루프가 있습니다. 각각을 시도해 보겠습니다."

#: src/ch03-05-control-flow.md:265
msgid "Repeating Code with `loop`"
msgstr "`loop`로 코드 반복하기"

#: src/ch03-05-control-flow.md:267
msgid ""
"The `loop` keyword tells Rust to execute a block of code over and over again "
"forever or until you explicitly tell it to stop."
msgstr "`loop` 키워드는 러스트에게 코드 블록을 영원히 또는 명시적으로 중지하라고 지시할 때까지 계속해서 실행하도록 지시합니다."

#: src/ch03-05-control-flow.md:270
msgid ""
"As an example, change the _src/main.rs_ file in your _loops_ directory to "
"look like this:"
msgstr "예를 들어, _loops_ 디렉토리의 _src/main.rs_ 파일을 다음과 같이 변경하세요."

#: src/ch03-05-control-flow.md:278
msgid "\"again!\""
msgstr "\"다시!\""

#: src/ch03-05-control-flow.md:283
msgid ""
"When we run this program, we’ll see `again!` printed over and over "
"continuously until we stop the program manually. Most terminals support the "
"keyboard shortcut <kbd>ctrl</kbd>\\-<kbd>c</kbd> to interrupt a program that "
"is stuck in a continual loop. Give it a try:"
msgstr "이 프로그램을 실행하면 프로그램을 수동으로 중지할 때까지 `again!`이 계속해서 반복적으로 출력되는 것을 볼 수 있습니다. 대부분의 터미널은 연속 루프에 갇힌 프로그램을 중단하기 위해 <kbd>ctrl</kbd>\\-<kbd>c</kbd> 키보드 단축키를 지원합니다. 시도해 보세요:"

#: src/ch03-05-control-flow.md:294
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s\n"
"     Running `target/debug/loops`\n"
"again!\n"
"again!\n"
"again!\n"
"again!\n"
"^Cagain!\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:306
msgid ""
"The symbol `^C` represents where you pressed <kbd>ctrl</kbd>\\-<kbd>c</kbd>. "
"You may or may not see the word `again!` printed after the `^C`, depending "
"on where the code was in the loop when it received the interrupt signal."
msgstr "`^C` 기호는 <kbd>ctrl</kbd>\\-<kbd>c</kbd>를 눌렀음을 나타냅니다. 인터럽트 신호를 받았을 때 코드가 루프의 어느 위치에 있었는지에 따라 `^C` 뒤에 `again!`이라는 단어가 인쇄될 수도 있고 인쇄되지 않을 수도 있습니다."

#: src/ch03-05-control-flow.md:310
msgid ""
"Fortunately, Rust also provides a way to break out of a loop using code. You "
"can place the `break` keyword within the loop to tell the program when to "
"stop executing the loop. Recall that we did this in the guessing game in the "
"[“Quitting After a Correct Guess”](ch02-00-guessing-game-"
"tutorial.html#quitting-after-a-correct-guess)<!-- ignore\n"
"--> section of Chapter 2 to exit the program when the user won the game by "
"guessing the correct number."
msgstr "다행히 러스트는 코드를 사용하여 루프를 빠져나오는 방법도 제공합니다. `break` 키워드를 루프 안에 배치하여 프로그램이 루프 실행을 언제 중지해야 하는지 알려줄 수 있습니다. 2장의 [“정답 맞춘 후 종료하기”](ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess)<!-- ignore\n --> 섹션에서 사용자가 정답을 맞춰 게임에서 이겼을 때 프로그램을 종료하기 위해 이 작업을 수행했습니다."

#: src/ch03-05-control-flow.md:317
msgid ""
"We also used `continue` in the guessing game, which in a loop tells the "
"program to skip over any remaining code in this iteration of the loop and go "
"to the next iteration."
msgstr "또한 추측 게임에서 `continue`를 사용했습니다. 이는 루프에서 프로그램에게 현재 루프 반복의 나머지 코드를 건너뛰고 다음 반복으로 이동하도록 지시합니다."

#: src/ch03-05-control-flow.md:321
msgid "Returning Values from Loops"
msgstr "루프에서 값 반환하기"

#: src/ch03-05-control-flow.md:323
msgid ""
"One of the uses of a `loop` is to retry an operation you know might fail, "
"such as checking whether a thread has completed its job. You might also need "
"to pass the result of that operation out of the loop to the rest of your "
"code. To do this, you can add the value you want returned after the `break` "
"expression you use to stop the loop; that value will be returned out of the "
"loop so you can use it, as shown here:"
msgstr "`loop`의 용도 중 하나는 실패할 수 있는 작업을 재시도하는 것입니다. 예를 들어 스레드가 작업을 완료했는지 확인하는 것과 같습니다. 또한 해당 작업의 결과를 루프 밖으로 코드의 나머지 부분으로 전달해야 할 수도 있습니다. 이를 위해 루프를 중지하는 데 사용하는 `break` 표현식 뒤에 반환하려는 값을 추가할 수 있습니다. 이 값은 루프 밖으로 반환되어 여기 표시된 것처럼 사용할 수 있습니다."

#: src/ch03-05-control-flow.md:342
msgid "\"The result is {result}\""
msgstr "\"결과는 {result}입니다\""

#: src/ch03-05-control-flow.md:346
msgid ""
"Before the loop, we declare a variable named `counter` and initialize it to "
"`0`. Then we declare a variable named `result` to hold the value returned "
"from the loop. On every iteration of the loop, we add `1` to the `counter` "
"variable, and then check whether the `counter` is equal to `10`. When it is, "
"we use the `break` keyword with the value `counter * 2`. After the loop, we "
"use a semicolon to end the statement that assigns the value to `result`. "
"Finally, we print the value in `result`, which in this case is `20`."
msgstr "루프 전에 `counter`라는 변수를 선언하고 `0`으로 초기화합니다. 그런 다음 루프에서 반환된 값을 저장할 `result`라는 변수를 선언합니다. 루프의 모든 반복에서 `1`을 `counter` 변수에 더한 다음 `counter`가 `10`과 같은지 확인합니다. 같으면 `counter * 2` 값과 함께 `break` 키워드를 사용합니다. 루프 후에 세미콜론을 사용하여 `result`에 값을 할당하는 문을 종료합니다. 마지막으로 `result`의 값을 출력하는데, 이 경우 `20`입니다."

#: src/ch03-05-control-flow.md:354
msgid ""
"You can also `return` from inside a loop. While `break` only exits the "
"current loop, `return` always exits the current function."
msgstr "루프 안에서 `return`할 수도 있습니다. `break`는 현재 루프만 종료하지만, `return`은 항상 현재 함수를 종료합니다."

#: src/ch03-05-control-flow.md:357
msgid "Loop Labels to Disambiguate Between Multiple Loops"
msgstr "여러 루프 간의 모호성을 없애기 위한 루프 레이블"

#: src/ch03-05-control-flow.md:359
msgid ""
"If you have loops within loops, `break` and `continue` apply to the "
"innermost loop at that point. You can optionally specify a _loop label_ on a "
"loop that you can then use with `break` or `continue` to specify that those "
"keywords apply to the labeled loop instead of the innermost loop. Loop "
"labels must begin with a single quote. Here’s an example with two nested "
"loops:"
msgstr "루프 안에 루프가 있는 경우, `break`와 `continue`는 해당 지점의 가장 안쪽 루프에 적용됩니다. 선택적으로 루프에 _루프 레이블_을 지정할 수 있으며, 이 레이블을 `break` 또는 `continue`와 함께 사용하여 해당 키워드가 가장 안쪽 루프 대신 레이블이 지정된 루프에 적용되도록 지정할 수 있습니다. 루프 레이블은 작은따옴표로 시작해야 합니다. 다음은 두 개의 중첩된 루프 예시입니다."

#: src/ch03-05-control-flow.md:369
msgid "\"count = {count}\""
msgstr "\"count = {count}\""

#: src/ch03-05-control-flow.md:373
msgid "\"remaining = {remaining}\""
msgstr "\"remaining = {remaining}\""

#: src/ch03-05-control-flow.md:385
msgid "\"End count = {count}\""
msgstr "\"최종 count = {count}\""

#: src/ch03-05-control-flow.md:389
msgid ""
"The outer loop has the label `'counting_up`, and it will count up from 0 to "
"2. The inner loop without a label counts down from 10 to 9. The first "
"`break` that doesn’t specify a label will exit the inner loop only. The "
"`break 'counting_up;` statement will exit the outer loop. This code prints:"
msgstr "바깥쪽 루프에는 `'counting_up` 레이블이 있으며, 0부터 2까지 카운트합니다. 레이블이 없는 안쪽 루프는 10부터 9까지 카운트합니다. 레이블을 지정하지 않은 첫 번째 `break`는 안쪽 루프만 종료합니다. `break 'counting_up;` 문은 바깥쪽 루프를 종료합니다. 이 코드는 다음을 출력합니다."

#: src/ch03-05-control-flow.md:394
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running `target/debug/loops`\n"
"count = 0\n"
"remaining = 10\n"
"remaining = 9\n"
"count = 1\n"
"remaining = 10\n"
"remaining = 9\n"
"count = 2\n"
"remaining = 10\n"
"End count = 2\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:410
msgid "Conditional Loops with `while`"
msgstr "`while`을 사용한 조건부 루프"

#: src/ch03-05-control-flow.md:412
msgid ""
"A program will often need to evaluate a condition within a loop. While the "
"condition is `true`, the loop runs. When the condition ceases to be `true`, "
"the program calls `break`, stopping the loop. It’s possible to implement "
"behavior like this using a combination of `loop`, `if`, `else`, and `break`; "
"you could try that now in a program, if you’d like. However, this pattern is "
"so common that Rust has a built-in language construct for it, called a "
"`while` loop. In Listing 3-3, we use `while` to loop the program three "
"times, counting down each time, and then, after the loop, print a message "
"and exit."
msgstr "프로그램은 종종 루프 내에서 조건을 평가해야 합니다. 조건이 `true`인 동안 루프가 실행됩니다. 조건이 `true`가 아니게 되면 프로그램은 `break`를 호출하여 루프를 중지합니다. `loop`, `if`, `else`, `break`의 조합을 사용하여 이와 같은 동작을 구현할 수 있습니다. 원한다면 지금 프로그램에서 시도해 볼 수 있습니다. 그러나 이 패턴은 너무 흔해서 러스트에는 `while` 루프라는 내장 언어 구문이 있습니다. 목록 3-3에서는 `while`을 사용하여 프로그램을 세 번 반복하고, 매번 카운트다운한 다음, 루프 후에 메시지를 출력하고 종료합니다."

#: src/ch03-05-control-flow.md:428 src/ch03-05-control-flow.md:536
msgid "\"{number}!\""
msgstr "\"{number}!\""

#: src/ch03-05-control-flow.md:433 src/ch03-05-control-flow.md:538
msgid "\"LIFTOFF!!!\""
msgstr "\"발사!!!\""

#: src/ch03-05-control-flow.md:439
msgid ""
"This construct eliminates a lot of nesting that would be necessary if you "
"used `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition "
"evaluates to `true`, the code runs; otherwise, it exits the loop."
msgstr "이 구문은 `loop`, `if`, `else`, `break`를 사용했을 때 필요했을 많은 중첩을 제거하며, 더 명확합니다. 조건이 `true`로 평가되는 동안 코드가 실행되고, 그렇지 않으면 루프를 종료합니다."

#: src/ch03-05-control-flow.md:443
msgid "Looping Through a Collection with `for`"
msgstr "`for`로 컬렉션 반복하기"

#: src/ch03-05-control-flow.md:445
msgid ""
"You can also use the `while` construct to loop over the elements of a "
"collection, such as an array. For example, the loop in Listing 3-4 prints "
"each element in the array `a`."
msgstr "`while` 구문을 사용하여 배열과 같은 컬렉션의 요소를 반복할 수도 있습니다. 예를 들어, 목록 3-4의 루프는 배열 `a`의 각 요소를 출력합니다."

#: src/ch03-05-control-flow.md:457
msgid "PLACEHOLDER_FOR_MSGID_114"
msgstr "\"값은: {}입니다\""

#: src/ch03-05-control-flow.md:466
msgid ""
"Here, the code counts up through the elements in the array. It starts at "
"index `0`, and then loops until it reaches the final index in the array "
"(that is, when `index < 5` is no longer `true`). Running this code will "
"print every element in the array:"
msgstr "여기서 코드는 배열의 요소를 통해 카운트합니다. 인덱스 `0`에서 시작하여 배열의 마지막 인덱스에 도달할 때까지 루프를 실행합니다(즉, `index < 5`가 더 이상 `true`가 아닐 때). 이 코드를 실행하면 배열의 모든 요소가 출력됩니다."

#: src/ch03-05-control-flow.md:471
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling loops v0.1.0 (file:///projects/loops)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s\n"
"     Running `target/debug/loops`\n"
"the value is: 10\n"
"the value is: 20\n"
"the value is: 30\n"
"the value is: 40\n"
"the value is: 50\n"
"```"
msgstr ""

#: src/ch03-05-control-flow.md:483
msgid ""
"All five array values appear in the terminal, as expected. Even though "
"`index` will reach a value of `5` at some point, the loop stops executing "
"before trying to fetch a sixth value from the array."
msgstr "예상대로 다섯 개의 배열 값이 모두 터미널에 나타납니다. `index`가 어느 시점에서 `5`에 도달하더라도, 루프는 배열에서 여섯 번째 값을 가져오려고 시도하기 전에 실행을 중지합니다."

#: src/ch03-05-control-flow.md:487
msgid ""
"However, this approach is error prone; we could cause the program to panic "
"if the index value or test condition is incorrect. For example, if you "
"changed the definition of the `a` array to have four elements but forgot to "
"update the condition to `while index < 4`, the code would panic. It’s also "
"slow, because the compiler adds runtime code to perform the conditional "
"check of whether the index is within the bounds of the array on every "
"iteration through the loop."
msgstr "그러나 이 접근 방식은 오류가 발생하기 쉽습니다. 인덱스 값이나 테스트 조건이 잘못되면 프로그램이 패닉 상태에 빠질 수 있습니다. 예를 들어, `a` 배열의 정의를 네 개의 요소를 갖도록 변경했지만 조건을 `while index < 4`로 업데이트하는 것을 잊었다면 코드는 패닉할 것입니다. 또한 컴파일러가 루프의 모든 반복에서 인덱스가 배열 범위 내에 있는지 조건부 검사를 수행하기 위해 런타임 코드를 추가하므로 느립니다."

#: src/ch03-05-control-flow.md:494
msgid ""
"As a more concise alternative, you can use a `for` loop and execute some "
"code for each item in a collection. A `for` loop looks like the code in "
"Listing 3-5."
msgstr "더 간결한 대안으로, `for` 루프를 사용하여 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다. `for` 루프는 목록 3-5의 코드와 같습니다."

#: src/ch03-05-control-flow.md:504
msgid "\"the value is: {element}\""
msgstr "\"값은: {element}입니다\""

#: src/ch03-05-control-flow.md:511
msgid ""
"When we run this code, we’ll see the same output as in Listing 3-4. More "
"importantly, we’ve now increased the safety of the code and eliminated the "
"chance of bugs that might result from going beyond the end of the array or "
"not going far enough and missing some items."
msgstr "이 코드를 실행하면 목록 3-4와 동일한 출력을 볼 수 있습니다. 더 중요하게는, 이제 코드의 안전성을 높이고 배열의 끝을 넘어가거나 충분히 멀리 가지 못해 일부 항목을 놓치는 것으로 인해 발생할 수 있는 버그의 가능성을 제거했습니다."

#: src/ch03-05-control-flow.md:516
msgid ""
"Using the `for` loop, you wouldn’t need to remember to change any other code "
"if you changed the number of values in the array, as you would with the "
"method used in Listing 3-4."
msgstr "`for` 루프를 사용하면 목록 3-4에서 사용된 메서드처럼 배열의 값 수를 변경하더라도 다른 코드를 변경할 필요가 없습니다."

#: src/ch03-05-control-flow.md:520
msgid ""
"The safety and conciseness of `for` loops make them the most commonly used "
"loop construct in Rust. Even in situations in which you want to run some "
"code a certain number of times, as in the countdown example that used a "
"`while` loop in Listing 3-3, most Rustaceans would use a `for` loop. The way "
"to do that would be to use a `Range`, provided by the standard library, "
"which generates all numbers in sequence starting from one number and ending "
"before another number."
msgstr "`for` 루프의 안전성과 간결성은 러스트에서 가장 일반적으로 사용되는 루프 구문입니다. 목록 3-3의 `while` 루프를 사용한 카운트다운 예제처럼 특정 횟수만큼 코드를 실행하려는 상황에서도 대부분의 러스트 개발자는 `for` 루프를 사용할 것입니다. 그렇게 하려면 표준 라이브러리에서 제공하는 `Range`를 사용해야 합니다. `Range`는 한 숫자부터 시작하여 다른 숫자 앞에서 끝나는 모든 숫자를 순서대로 생성합니다."

#: src/ch03-05-control-flow.md:528
msgid ""
"Here’s what the countdown would look like using a `for` loop and another "
"method we’ve not yet talked about, `rev`, to reverse the range:"
msgstr "다음은 `for` 루프와 아직 이야기하지 않은 다른 메서드인 `rev`를 사용하여 범위를 역순으로 만드는 카운트다운의 모습입니다."

#: src/ch03-05-control-flow.md:542
msgid "This code is a bit nicer, isn’t it?"
msgstr "이 코드가 좀 더 깔끔하죠?"

#: src/ch03-05-control-flow.md:546
msgid ""
"You made it! This was a sizable chapter: you learned about variables, scalar "
"and compound data types, functions, comments, `if` expressions, and loops! "
"To practice with the concepts discussed in this chapter, try building "
"programs to do the following:"
msgstr "해냈습니다! 이번 장은 상당한 분량이었습니다. 변수, 스칼라 및 복합 데이터 타입, 함수, 주석, `if` 표현식, 루프에 대해 배웠습니다! 이 장에서 논의된 개념을 연습하려면 다음을 수행하는 프로그램을 만들어 보세요."

#: src/ch03-05-control-flow.md:551
msgid "Convert temperatures between Fahrenheit and Celsius."
msgstr "화씨와 섭씨 온도 변환."

#: src/ch03-05-control-flow.md:552
msgid "Generate the _n_th Fibonacci number."
msgstr "_n_번째 피보나치 수 생성."

#: src/ch03-05-control-flow.md:553
msgid ""
"Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” "
"taking advantage of the repetition in the song."
msgstr "크리스마스 캐럴 “The Twelve Days of Christmas”의 가사를 노래의 반복을 활용하여 출력합니다."

#: src/ch03-05-control-flow.md:556
msgid ""
"When you’re ready to move on, we’ll talk about a concept in Rust that "
"_doesn’t_ commonly exist in other programming languages: ownership."
msgstr "다음으로 넘어갈 준비가 되면, 다른 프로그래밍 언어에는 일반적으로 존재하지 않는 러스트의 개념인 소유권에 대해 이야기하겠습니다."

#: src/ch04-00-understanding-ownership.md:3
msgid ""
"Ownership is Rust’s most unique feature and has deep implications for the "
"rest of the language. It enables Rust to make memory safety guarantees "
"without needing a garbage collector, so it’s important to understand how "
"ownership works. In this chapter, we’ll talk about ownership as well as "
"several related features: borrowing, slices, and how Rust lays data out in "
"memory."
msgstr "소유권은 러스트의 가장 독특한 기능이며 나머지 언어에 깊은 영향을 미칩니다. 이는 러스트가 가비지 컬렉터 없이 메모리 안전 보장을 할 수 있도록 해주므로, 소유권이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 장에서는 소유권뿐만 아니라 몇 가지 관련 기능인 빌림, 슬라이스, 그리고 러스트가 메모리에 데이터를 배치하는 방법에 대해 이야기할 것입니다."

#: src/ch04-01-what-is-ownership.md:1
msgid "What Is Ownership?"
msgstr "소유권이란 무엇인가?"

#: src/ch04-01-what-is-ownership.md:3
msgid ""
"_Ownership_ is a set of rules that govern how a Rust program manages memory. "
"All programs have to manage the way they use a computer’s memory while "
"running. Some languages have garbage collection that regularly looks for no-"
"longer-used memory as the program runs; in other languages, the programmer "
"must explicitly allocate and free the memory. Rust uses a third approach: "
"memory is managed through a system of ownership with a set of rules that the "
"compiler checks. If any of the rules are violated, the program won’t "
"compile. None of the features of ownership will slow down your program while "
"it’s running."
msgstr "_소유권_은 러스트 프로그램이 메모리를 관리하는 방법을 규정하는 규칙 집합입니다. 모든 프로그램은 실행 중에 컴퓨터의 메모리 사용 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행되는 동안 더 이상 사용되지 않는 메모리를 정기적으로 찾는 가비지 컬렉션이 있습니다. 다른 언어에서는 프로그래머가 메모리를 명시적으로 할당하고 해제해야 합니다. 러스트는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 확인하는 일련의 규칙을 가진 소유권 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램은 컴파일되지 않습니다. 소유권의 어떤 기능도 프로그램 실행 속도를 늦추지 않습니다."

#: src/ch04-01-what-is-ownership.md:12
msgid ""
"Because ownership is a new concept for many programmers, it does take some "
"time to get used to. The good news is that the more experienced you become "
"with Rust and the rules of the ownership system, the easier you’ll find it "
"to naturally develop code that is safe and efficient. Keep at it!"
msgstr "소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 러스트와 소유권 시스템 규칙에 더 익숙해질수록 안전하고 효율적인 코드를 자연스럽게 개발하는 것이 더 쉬워진다는 것입니다. 계속 노력하세요!"

#: src/ch04-01-what-is-ownership.md:17
msgid ""
"When you understand ownership, you’ll have a solid foundation for "
"understanding the features that make Rust unique. In this chapter, you’ll "
"learn ownership by working through some examples that focus on a very common "
"data structure: strings."
msgstr "소유권을 이해하면 러스트를 독특하게 만드는 기능을 이해하는 데 견고한 기반을 갖게 될 것입니다. 이 장에서는 매우 일반적인 데이터 구조인 문자열에 초점을 맞춘 몇 가지 예제를 통해 소유권을 배울 것입니다."

#: src/ch04-01-what-is-ownership.md:22
msgid "The Stack and the Heap"
msgstr "스택과 힙"

#: src/ch04-01-what-is-ownership.md:24
msgid ""
"Many programming languages don’t require you to think about the stack and "
"the heap very often. But in a systems programming language like Rust, "
"whether a value is on the stack or the heap affects how the language behaves "
"and why you have to make certain decisions. Parts of ownership will be "
"described in relation to the stack and the heap later in this chapter, so "
"here is a brief explanation in preparation."
msgstr "많은 프로그래밍 언어는 스택과 힙에 대해 자주 생각할 필요가 없습니다. 하지만 러스트와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지가 언어의 동작 방식과 특정 결정을 내려야 하는 이유에 영향을 미칩니다. 소유권의 일부는 이 장의 뒷부분에서 스택과 힙과 관련하여 설명될 것이므로, 여기서는 준비를 위한 간략한 설명을 제공합니다."

#: src/ch04-01-what-is-ownership.md:31
msgid ""
"Both the stack and the heap are parts of memory available to your code to "
"use at runtime, but they are structured in different ways. The stack stores "
"values in the order it gets them and removes the values in the opposite "
"order. This is referred to as _last in, first out_. Think of a stack of "
"plates: when you add more plates, you put them on top of the pile, and when "
"you need a plate, you take one off the top. Adding or removing plates from "
"the middle or bottom wouldn’t work as well! Adding data is called _pushing "
"onto the stack_, and removing data is called _popping off the stack_. All "
"data stored on the stack must have a known, fixed size. Data with an unknown "
"size at compile time or a size that might change must be stored on the heap "
"instead."
msgstr "스택과 힙은 모두 런타임에 코드가 사용할 수 있는 메모리 영역이지만, 서로 다른 방식으로 구성됩니다. 스택은 값을 가져온 순서대로 저장하고 반대 순서로 값을 제거합니다. 이를 _후입선출_이라고 합니다. 접시 더미를 생각해 보세요. 접시를 더 추가할 때는 더미 위에 놓고, 접시가 필요할 때는 맨 위에서 하나를 가져갑니다. 중간이나 아래에서 접시를 추가하거나 제거하는 것은 잘 작동하지 않을 것입니다! 데이터를 추가하는 것을 _스택에 푸시_라고 하고, 데이터를 제거하는 것을 _스택에서 팝_이라고 합니다. 스택에 저장되는 모든 데이터는 알려진 고정된 크기를 가져야 합니다. 컴파일 시점에 크기를 알 수 없거나 크기가 변경될 수 있는 데이터는 대신 힙에 저장되어야 합니다."

#: src/ch04-01-what-is-ownership.md:43
msgid ""
"The heap is less organized: when you put data on the heap, you request a "
"certain amount of space. The memory allocator finds an empty spot in the "
"heap that is big enough, marks it as being in use, and returns a _pointer_, "
"which is the address of that location. This process is called _allocating on "
"the heap_ and is sometimes abbreviated as just _allocating_ (pushing values "
"onto the stack is not considered allocating). Because the pointer to the "
"heap is a known, fixed size, you can store the pointer on the stack, but "
"when you want the actual data, you must follow the pointer. Think of being "
"seated at a restaurant. When you enter, you state the number of people in "
"your group, and the host finds an empty table that fits everyone and leads "
"you there. If someone in your group comes late, they can ask where you’ve "
"been seated to find you."
msgstr "힙은 덜 조직적입니다. 힙에 데이터를 넣을 때, 특정 양의 공간을 요청합니다. 메모리 할당자는 힙에서 충분히 큰 빈 공간을 찾아 사용 중으로 표시하고, 해당 위치의 주소인 _포인터_를 반환합니다. 이 과정을 _힙에 할당_이라고 하며 때로는 단순히 _할당_이라고 줄여 말합니다(값을 스택에 푸시하는 것은 할당으로 간주되지 않습니다). 힙에 대한 포인터는 알려진 고정 크기이므로 포인터를 스택에 저장할 수 있지만, 실제 데이터를 원할 때는 포인터를 따라가야 합니다. 식당에 앉아 있는 것을 생각해 보세요. 입장할 때 그룹 인원수를 말하면, 호스트가 모두에게 맞는 빈 테이블을 찾아 안내합니다. 그룹의 누군가가 늦게 오면, 당신이 어디에 앉아 있는지 물어 찾아올 수 있습니다."

#: src/ch04-01-what-is-ownership.md:56
msgid ""
"Pushing to the stack is faster than allocating on the heap because the "
"allocator never has to search for a place to store new data; that location "
"is always at the top of the stack. Comparatively, allocating space on the "
"heap requires more work because the allocator must first find a big enough "
"space to hold the data and then perform bookkeeping to prepare for the next "
"allocation."
msgstr "스택에 푸시하는 것이 힙에 할당하는 것보다 빠릅니다. 할당자가 새 데이터를 저장할 공간을 검색할 필요가 없기 때문입니다. 해당 위치는 항상 스택의 맨 위에 있습니다. 비교적으로 힙에 공간을 할당하는 것은 더 많은 작업을 필요로 합니다. 할당자가 먼저 데이터를 담을 충분히 큰 공간을 찾은 다음 다음 할당을 준비하기 위해 장부 정리를 수행해야 하기 때문입니다."

#: src/ch04-01-what-is-ownership.md:63
msgid ""
"Accessing data in the heap is slower than accessing data on the stack "
"because you have to follow a pointer to get there. Contemporary processors "
"are faster if they jump around less in memory. Continuing the analogy, "
"consider a server at a restaurant taking orders from many tables. It’s most "
"efficient to get all the orders at one table before moving on to the next "
"table. Taking an order from table A, then an order from table B, then one "
"from A again, and then one from B again would be a much slower process. By "
"the same token, a processor can do its job better if it works on data that’s "
"close to other data (as it is on the stack) rather than farther away (as it "
"can be on the heap)."
msgstr "힙의 데이터에 접근하는 것은 스택의 데이터에 접근하는 것보다 느립니다. 포인터를 따라가야 하기 때문입니다. 현대 프로세서는 메모리에서 덜 이동할수록 더 빠릅니다. 비유를 계속하자면, 식당에서 여러 테이블의 주문을 받는 서버를 생각해 보세요. 다음 테이블로 이동하기 전에 한 테이블의 모든 주문을 받는 것이 가장 효율적입니다. 테이블 A에서 주문을 받고, 테이블 B에서 주문을 받고, 다시 A에서 하나, 다시 B에서 하나를 받는 것은 훨씬 느린 과정일 것입니다. 마찬가지로 프로세서는 다른 데이터와 가까운 데이터(스택에 있는 것처럼)에서 작업할 때 더 멀리 떨어진 데이터(힙에 있을 수 있는 것처럼)에서 작업할 때보다 작업을 더 잘 수행할 수 있습니다."

#: src/ch04-01-what-is-ownership.md:74
msgid ""
"When your code calls a function, the values passed into the function "
"(including, potentially, pointers to data on the heap) and the function’s "
"local variables get pushed onto the stack. When the function is over, those "
"values get popped off the stack."
msgstr "코드가 함수를 호출하면 함수에 전달된 값(잠재적으로 힙의 데이터에 대한 포인터 포함)과 함수의 지역 변수가 스택에 푸시됩니다. 함수가 끝나면 해당 값은 스택에서 팝됩니다."

#: src/ch04-01-what-is-ownership.md:79
msgid ""
"Keeping track of what parts of code are using what data on the heap, "
"minimizing the amount of duplicate data on the heap, and cleaning up unused "
"data on the heap so you don’t run out of space are all problems that "
"ownership addresses. Once you understand ownership, you won’t need to think "
"about the stack and the heap very often, but knowing that the main purpose "
"of ownership is to manage heap data can help explain why it works the way it "
"does."
msgstr "코드의 어떤 부분이 힙의 어떤 데이터를 사용하고 있는지 추적하고, 힙의 중복 데이터 양을 최소화하며, 공간 부족을 방지하기 위해 힙의 사용되지 않는 데이터를 정리하는 것은 모두 소유권이 다루는 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요가 없지만, 소유권의 주요 목적이 힙 데이터를 관리하는 것임을 알면 소유권이 작동하는 방식을 설명하는 데 도움이 될 수 있습니다."

#: src/ch04-01-what-is-ownership.md:86
msgid "Ownership Rules"
msgstr "소유권 규칙"

#: src/ch04-01-what-is-ownership.md:88
msgid ""
"First, let’s take a look at the ownership rules. Keep these rules in mind as "
"we work through the examples that illustrate them:"
msgstr "먼저 소유권 규칙을 살펴보겠습니다. 다음 예제를 통해 설명할 때 이 규칙들을 염두에 두세요."

#: src/ch04-01-what-is-ownership.md:91
msgid "Each value in Rust has an _owner_."
msgstr "러스트의 모든 값에는 _소유자_가 있습니다."

#: src/ch04-01-what-is-ownership.md:92
msgid "There can only be one owner at a time."
msgstr "한 번에 하나의 소유자만 있을 수 있습니다."

#: src/ch04-01-what-is-ownership.md:93
msgid "When the owner goes out of scope, the value will be dropped."
msgstr "소유자가 스코프를 벗어나면 값은 드롭됩니다."

#: src/ch04-01-what-is-ownership.md:95
msgid "Variable Scope"
msgstr "변수 스코프"

#: src/ch04-01-what-is-ownership.md:97
msgid ""
"Now that we’re past basic Rust syntax, we won’t include all the `fn main() "
"{` code in examples, so if you’re following along, make sure to put the "
"following examples inside a `main` function manually. As a result, our "
"examples will be a bit more concise, letting us focus on the actual details "
"rather than boilerplate code."
msgstr "이제 기본적인 러스트 구문을 넘어섰으므로, 예제에 모든 `fn main() {` 코드를 포함하지 않을 것입니다. 따라서 따라하고 있다면, 다음 예제들을 수동으로 `main` 함수 안에 넣으세요. 결과적으로, 우리의 예제는 상용구 코드보다는 실제 세부 사항에 집중할 수 있도록 좀 더 간결해질 것입니다."

#: src/ch04-01-what-is-ownership.md:103
msgid ""
"As a first example of ownership, we’ll look at the _scope_ of some "
"variables. A scope is the range within a program for which an item is valid. "
"Take the following variable:"
msgstr "소유권의 첫 번째 예시로, 일부 변수의 _스코프_를 살펴보겠습니다. 스코프는 프로그램 내에서 항목이 유효한 범위입니다. 다음 변수를 예로 들어 보겠습니다."

#: src/ch04-01-what-is-ownership.md:108 src/ch04-01-what-is-ownership.md:121
#: src/ch04-01-what-is-ownership.md:166 src/ch04-01-what-is-ownership.md:180
#: src/ch04-01-what-is-ownership.md:229 src/ch04-01-what-is-ownership.md:284
#: src/ch04-01-what-is-ownership.md:353 src/ch04-01-what-is-ownership.md:419
#: src/ch04-01-what-is-ownership.md:461 src/ch04-01-what-is-ownership.md:536
#: src/ch04-01-what-is-ownership.md:580 src/ch04-01-what-is-ownership.md:627
#: src/ch04-02-references-and-borrowing.md:19
#: src/ch04-02-references-and-borrowing.md:55
#: src/ch04-02-references-and-borrowing.md:76
#: src/ch04-02-references-and-borrowing.md:107
#: src/ch04-02-references-and-borrowing.md:151
#: src/ch04-02-references-and-borrowing.md:176
#: src/ch04-02-references-and-borrowing.md:233
#: src/ch04-02-references-and-borrowing.md:248
#: src/ch04-02-references-and-borrowing.md:294
#: src/ch04-02-references-and-borrowing.md:338
#: src/ch04-02-references-and-borrowing.md:400
#: src/ch04-02-references-and-borrowing.md:422 src/ch04-03-slices.md:214
#: src/ch04-03-slices.md:224 src/ch04-03-slices.md:236
#: src/ch06-01-defining-an-enum.md:297 src/ch08-02-strings.md:281
#: src/ch13-01-closures.md:243 src/ch20-02-advanced-traits.md:789
#: src/ch20-03-advanced-types.md:277
msgid "    let s = String::from(\"hello\");"
msgstr "    let s = String::from(\"hello\");"

#: src/ch04-01-what-is-ownership.md:111
msgid ""
"The variable `s` refers to a string literal, where the value of the string "
"is hardcoded into the text of our program. The variable is valid from the "
"point at which it’s declared until the end of the current _scope_. Listing "
"4-1 shows a program with comments annotating where the variable `s` would be "
"valid."
msgstr "변수 `s`는 문자열 리터럴을 참조하며, 문자열의 값은 프로그램 텍스트에 하드코딩됩니다. 변수는 선언된 시점부터 현재 _스코프_가 끝날 때까지 유효합니다. 목록 4-1은 변수 `s`가 유효한 위치를 주석으로 표시한 프로그램을 보여줍니다."

#: src/ch04-01-what-is-ownership.md:120
msgid "// s is not valid here, it’s not yet declared"
msgstr "// s는 아직 선언되지 않았으므로 여기서는 유효하지 않습니다."

#: src/ch04-01-what-is-ownership.md:121 src/ch04-01-what-is-ownership.md:229
msgid "// s is valid from this point forward\n"
msgstr "// s는 이 시점부터 유효합니다.\n"

#: src/ch04-01-what-is-ownership.md:123 src/ch04-01-what-is-ownership.md:231
msgid "// do stuff with s\n"
msgstr "// s로 작업 수행\n"

#: src/ch04-01-what-is-ownership.md:124
msgid "// this scope is now over, and s is no longer valid\n"
msgstr "// 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.\n"

#: src/ch04-01-what-is-ownership.md:130
msgid "In other words, there are two important points in time here:"
msgstr "다시 말해, 여기에는 두 가지 중요한 시점이 있습니다."

#: src/ch04-01-what-is-ownership.md:132
msgid "When `s` comes _into_ scope, it is valid."
msgstr "`s`가 스코프 _안으로_ 들어오면 유효합니다."

#: src/ch04-01-what-is-ownership.md:133
msgid "It remains valid until it goes _out of_ scope."
msgstr "스코프 _밖으로_ 나갈 때까지 유효합니다."

#: src/ch04-01-what-is-ownership.md:135
msgid ""
"At this point, the relationship between scopes and when variables are valid "
"is similar to that in other programming languages. Now we’ll build on top of "
"this understanding by introducing the `String` type."
msgstr "이 시점에서 스코프와 변수가 유효한 시점 간의 관계는 다른 프로그래밍 언어와 유사합니다. 이제 이 이해를 바탕으로 `String` 타입을 소개하겠습니다."

#: src/ch04-01-what-is-ownership.md:139
msgid "The `String` Type"
msgstr "`String` 타입"

#: src/ch04-01-what-is-ownership.md:141
msgid ""
"To illustrate the rules of ownership, we need a data type that is more "
"complex than those we covered in the [“Data Types”](ch03-02-data-"
"types.html#data-types)<!-- ignore --> section of Chapter 3. The types "
"covered previously are of a known size, can be stored on the stack and "
"popped off the stack when their scope is over, and can be quickly and "
"trivially copied to make a new, independent instance if another part of code "
"needs to use the same value in a different scope. But we want to look at "
"data that is stored on the heap and explore how Rust knows when to clean up "
"that data, and the `String` type is a great example."
msgstr "소유권 규칙을 설명하기 위해 3장의 [“데이터 타입”](ch03-02-data-types.html#data-types)<!-- ignore --> 섹션에서 다룬 것보다 더 복잡한 데이터 타입이 필요합니다. 이전에 다룬 타입들은 알려진 크기를 가지며, 스택에 저장되고 스코프가 끝나면 스택에서 팝될 수 있으며, 코드의 다른 부분이 다른 스코프에서 동일한 값을 사용해야 하는 경우 새롭고 독립적인 인스턴스를 만들기 위해 빠르고 간단하게 복사될 수 있습니다. 그러나 우리는 힙에 저장된 데이터를 살펴보고 러스트가 언제 해당 데이터를 정리해야 하는지 어떻게 아는지 탐구하고 싶으며, `String` 타입은 좋은 예시입니다."

#: src/ch04-01-what-is-ownership.md:150
msgid ""
"We’ll concentrate on the parts of `String` that relate to ownership. These "
"aspects also apply to other complex data types, whether they are provided by "
"the standard library or created by you. We’ll discuss `String` in more depth "
"in [Chapter 8](ch08-02-strings.html)<!-- ignore -->."
msgstr "`String`의 소유권과 관련된 부분에 집중할 것입니다. 이러한 측면은 표준 라이브러리에서 제공되거나 직접 생성한 다른 복잡한 데이터 타입에도 적용됩니다. `String`에 대해서는 [8장](ch08-02-strings.html)<!-- ignore -->에서 더 자세히 논의할 것입니다."

#: src/ch04-01-what-is-ownership.md:155
msgid ""
"We’ve already seen string literals, where a string value is hardcoded into "
"our program. String literals are convenient, but they aren’t suitable for "
"every situation in which we may want to use text. One reason is that they’re "
"immutable. Another is that not every string value can be known when we write "
"our code: for example, what if we want to take user input and store it? For "
"these situations, Rust has a second string type, `String`. This type manages "
"data allocated on the heap and as such is able to store an amount of text "
"that is unknown to us at compile time. You can create a `String` from a "
"string literal using the `from` function, like so:"
msgstr "우리는 이미 문자열 리터럴을 보았습니다. 문자열 값은 프로그램에 하드코딩됩니다. 문자열 리터럴은 편리하지만, 텍스트를 사용하려는 모든 상황에 적합하지는 않습니다. 한 가지 이유는 불변이기 때문입니다. 또 다른 이유는 모든 문자열 값을 코드를 작성할 때 알 수 없기 때문입니다. 예를 들어 사용자 입력을 받아 저장하고 싶다면 어떻게 해야 할까요? 이러한 상황을 위해 러스트에는 두 번째 문자열 타입인 `String`이 있습니다. 이 타입은 힙에 할당된 데이터를 관리하며, 따라서 컴파일 시점에 알 수 없는 양의 텍스트를 저장할 수 있습니다. `from` 함수를 사용하여 문자열 리터럴에서 `String`을 만들 수 있습니다. 예를 들어:"

#: src/ch04-01-what-is-ownership.md:169
msgid ""
"The double colon `::` operator allows us to namespace this particular `from` "
"function under the `String` type rather than using some sort of name like "
"`string_from`. We’ll discuss this syntax more in the [“Method Syntax”]"
"(ch05-03-method-syntax.html#method-syntax)<!-- ignore --> section of Chapter "
"5, and when we talk about namespacing with modules in [“Paths for Referring "
"to an Item in the Module Tree”](ch07-03-paths-for-referring-to-an-item-in-"
"the-module-tree.html)<!-- ignore --> in Chapter 7."
msgstr "이중 콜론 `::` 연산자를 사용하면 `string_from`과 같은 이름을 사용하는 대신 `String` 타입 아래에 이 특정 `from` 함수를 네임스페이스화할 수 있습니다. 이 구문에 대해서는 5장의 [“메서드 구문”](ch05-03-method-syntax.html#method-syntax)<!-- ignore --> 섹션과 7장의 [“모듈 트리에서 항목을 참조하는 경로”](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore -->에서 모듈을 사용한 네임스페이스화에 대해 이야기할 때 더 자세히 논의할 것입니다."

#: src/ch04-01-what-is-ownership.md:176
msgid "This kind of string _can_ be mutated:"
msgstr "이러한 종류의 문자열은 _변경될 수 있습니다_:"

#: src/ch04-01-what-is-ownership.md:182
msgid "\", world!\""
msgstr "\", world!\""

#: src/ch04-01-what-is-ownership.md:182
msgid "// push_str() appends a literal to a String"
msgstr "// push_str()은 문자열 리터럴을 String에 추가합니다."

#: src/ch04-01-what-is-ownership.md:184
msgid "\"{s}\""
msgstr "\"{s}\""

#: src/ch04-01-what-is-ownership.md:184
msgid "// This will print `hello, world!`"
msgstr "// 이것은 `hello, world!`를 출력할 것입니다."

#: src/ch04-01-what-is-ownership.md:188
msgid ""
"So, what’s the difference here? Why can `String` be mutated but literals "
"cannot? The difference is in how these two types deal with memory."
msgstr "그렇다면 여기서 차이점은 무엇일까요? 왜 `String`은 변경될 수 있지만 리터럴은 변경될 수 없을까요? 차이점은 이 두 타입이 메모리를 다루는 방식에 있습니다."

#: src/ch04-01-what-is-ownership.md:191
msgid "Memory and Allocation"
msgstr "메모리 및 할당"

#: src/ch04-01-what-is-ownership.md:193
msgid ""
"In the case of a string literal, we know the contents at compile time, so "
"the text is hardcoded directly into the final executable. This is why string "
"literals are fast and efficient. But these properties only come from the "
"string literal’s immutability. Unfortunately, we can’t put a blob of memory "
"into the binary for each piece of text whose size is unknown at compile time "
"and whose size might change while running the program."
msgstr "문자열 리터럴의 경우, 컴파일 시점에 내용을 알 수 있으므로 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 하지만 이러한 속성은 문자열 리터럴의 불변성에서만 비롯됩니다. 불행히도, 컴파일 시점에 크기를 알 수 없고 프로그램 실행 중에 크기가 변경될 수 있는 각 텍스트 조각에 대해 메모리 블롭을 바이너리에 넣을 수는 없습니다."

#: src/ch04-01-what-is-ownership.md:200
msgid ""
"With the `String` type, in order to support a mutable, growable piece of "
"text, we need to allocate an amount of memory on the heap, unknown at "
"compile time, to hold the contents. This means:"
msgstr "`String` 타입을 사용하면 변경 가능하고 확장 가능한 텍스트 조각을 지원하기 위해 컴파일 시점에 알 수 없는 양의 메모리를 힙에 할당하여 내용을 저장해야 합니다. 이는 다음을 의미합니다."

#: src/ch04-01-what-is-ownership.md:204
msgid "The memory must be requested from the memory allocator at runtime."
msgstr "메모리는 런타임에 메모리 할당자에게 요청되어야 합니다."

#: src/ch04-01-what-is-ownership.md:205
msgid ""
"We need a way of returning this memory to the allocator when we’re done with "
"our `String`."
msgstr "`String` 사용을 마쳤을 때 이 메모리를 할당자에게 반환하는 방법이 필요합니다."

#: src/ch04-01-what-is-ownership.md:208
msgid ""
"That first part is done by us: when we call `String::from`, its "
"implementation requests the memory it needs. This is pretty much universal "
"in programming languages."
msgstr "첫 번째 부분은 우리가 수행합니다. `String::from`을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이는 프로그래밍 언어에서 거의 보편적입니다."

#: src/ch04-01-what-is-ownership.md:212
msgid ""
"However, the second part is different. In languages with a _garbage "
"collector (GC)_, the GC keeps track of and cleans up memory that isn’t being "
"used anymore, and we don’t need to think about it. In most languages without "
"a GC, it’s our responsibility to identify when memory is no longer being "
"used and to call code to explicitly free it, just as we did to request it. "
"Doing this correctly has historically been a difficult programming problem. "
"If we forget, we’ll waste memory. If we do it too early, we’ll have an "
"invalid variable. If we do it twice, that’s a bug too. We need to pair "
"exactly one `allocate` with exactly one `free`."
msgstr "그러나 두 번째 부분은 다릅니다. _가비지 컬렉터(GC)_가 있는 언어에서는 GC가 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 우리는 이에 대해 생각할 필요가 없습니다. GC가 없는 대부분의 언어에서는 메모리가 더 이상 사용되지 않을 때를 식별하고 요청했던 것처럼 명시적으로 해제하는 코드를 호출하는 것이 우리의 책임입니다. 이를 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 해제하면 유효하지 않은 변수를 갖게 됩니다. 두 번 해제하면 그것도 버그입니다. 정확히 하나의 `allocate`와 정확히 하나의 `free`를 짝지어야 합니다."

#: src/ch04-01-what-is-ownership.md:222
msgid ""
"Rust takes a different path: the memory is automatically returned once the "
"variable that owns it goes out of scope. Here’s a version of our scope "
"example from Listing 4-1 using a `String` instead of a string literal:"
msgstr "러스트는 다른 경로를 택합니다. 메모리는 소유한 변수가 스코프를 벗어나면 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 `String`을 사용한 목록 4-1의 스코프 예제 버전입니다."

#: src/ch04-01-what-is-ownership.md:232
msgid ""
"// this scope is now over, and s is no\n"
"                                       // longer valid\n"
msgstr "// 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.\n"

#: src/ch04-01-what-is-ownership.md:237
msgid ""
"There is a natural point at which we can return the memory our `String` "
"needs to the allocator: when `s` goes out of scope. When a variable goes out "
"of scope, Rust calls a special function for us. This function is called "
"[`drop`](../std/ops/trait.Drop.html#tymethod.drop)<!-- ignore -->, and it’s "
"where the author of `String` can put the code to return the memory. Rust "
"calls `drop` automatically at the closing curly bracket."
msgstr "`String`이 필요로 하는 메모리를 할당자에게 반환할 수 있는 자연스러운 시점이 있습니다. 바로 `s`가 스코프를 벗어날 때입니다. 변수가 스코프를 벗어나면 러스트는 우리를 위해 특별한 함수를 호출합니다. 이 함수는 [`drop`](../std/ops/trait.Drop.html#tymethod.drop)<!-- ignore -->이라고 불리며, `String`의 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳입니다. 러스트는 닫는 중괄호에서 `drop`을 자동으로 호출합니다."

#: src/ch04-01-what-is-ownership.md:244
msgid ""
"Note: In C++, this pattern of deallocating resources at the end of an item’s "
"lifetime is sometimes called _Resource Acquisition Is Initialization "
"(RAII)_. The `drop` function in Rust will be familiar to you if you’ve used "
"RAII patterns."
msgstr "참고: C++에서는 항목의 수명 끝에 리소스를 할당 해제하는 이 패턴을 때때로 _자원 획득은 초기화(RAII)_라고 부릅니다. RAII 패턴을 사용해 본 적이 있다면 러스트의 `drop` 함수가 익숙할 것입니다."

#: src/ch04-01-what-is-ownership.md:249
msgid ""
"This pattern has a profound impact on the way Rust code is written. It may "
"seem simple right now, but the behavior of code can be unexpected in more "
"complicated situations when we want to have multiple variables use the data "
"we’ve allocated on the heap. Let’s explore some of those situations now."
msgstr "이 패턴은 러스트 코드가 작성되는 방식에 지대한 영향을 미칩니다. 지금은 간단해 보일 수 있지만, 여러 변수가 힙에 할당한 데이터를 사용하려고 할 때 더 복잡한 상황에서는 코드의 동작이 예상치 못할 수 있습니다. 이제 그러한 상황 중 일부를 살펴보겠습니다."

#: src/ch04-01-what-is-ownership.md:256
msgid "<a id=\"ways-variables-and-data-interact-move\"></a>"
msgstr "<a id=\"ways-variables-and-data-interact-move\"></a>"

#: src/ch04-01-what-is-ownership.md:258
msgid "Variables and Data Interacting with Move"
msgstr "이동과 상호작용하는 변수와 데이터"

#: src/ch04-01-what-is-ownership.md:260
msgid ""
"Multiple variables can interact with the same data in different ways in "
"Rust. Let’s look at an example using an integer in Listing 4-2."
msgstr "러스트에서는 여러 변수가 동일한 데이터와 다른 방식으로 상호 작용할 수 있습니다. 목록 4-2의 정수를 사용한 예제를 살펴보겠습니다."

#: src/ch04-01-what-is-ownership.md:274
msgid ""
"We can probably guess what this is doing: “bind the value `5` to `x`; then "
"make a copy of the value in `x` and bind it to `y`.” We now have two "
"variables, `x` and `y`, and both equal `5`. This is indeed what is "
"happening, because integers are simple values with a known, fixed size, and "
"these two `5` values are pushed onto the stack."
msgstr "이것이 무엇을 하는지 짐작할 수 있습니다. “값 `5`를 `x`에 바인딩한 다음, `x`의 값을 복사하여 `y`에 바인딩합니다.” 이제 `x`와 `y` 두 개의 변수가 있고, 둘 다 `5`와 같습니다. 정수는 알려진 고정 크기를 가진 단순한 값이므로 실제로 이런 일이 발생하며, 이 두 `5` 값은 스택에 푸시됩니다."

#: src/ch04-01-what-is-ownership.md:280
msgid "Now let’s look at the `String` version:"
msgstr "이제 `String` 버전을 살펴보겠습니다."

#: src/ch04-01-what-is-ownership.md:289
msgid ""
"This looks very similar, so we might assume that the way it works would be "
"the same: that is, the second line would make a copy of the value in `s1` "
"and bind it to `s2`. But this isn’t quite what happens."
msgstr "이것은 매우 유사해 보이므로, 작동 방식도 같을 것이라고 가정할 수 있습니다. 즉, 두 번째 줄은 `s1`의 값을 복사하여 `s2`에 바인딩할 것입니다. 하지만 실제로는 그렇지 않습니다."

#: src/ch04-01-what-is-ownership.md:293
msgid ""
"Take a look at Figure 4-1 to see what is happening to `String` under the "
"covers. A `String` is made up of three parts, shown on the left: a pointer "
"to the memory that holds the contents of the string, a length, and a "
"capacity. This group of data is stored on the stack. On the right is the "
"memory on the heap that holds the contents."
msgstr "그림 4-1을 보면 `String`이 내부적으로 어떻게 작동하는지 알 수 있습니다. `String`은 왼쪽에 표시된 세 부분으로 구성됩니다. 문자열 내용을 담는 메모리에 대한 포인터, 길이, 용량입니다. 이 데이터 그룹은 스택에 저장됩니다. 오른쪽에는 내용을 담는 힙의 메모리가 있습니다."

#: src/ch04-01-what-is-ownership.md:299
msgid "" "<img alt=\"Two tables: the first table contains the representation of s1 on " "the\n" "stack, consisting of its length (5), capacity (5), and a pointer to the " "first\n" "value in the second table. The second table contains the representation of " "the\n" "string data on the heap, byte by byte.\" src=\"img/trpl04-01.svg\" " "class=\"center\"\n" "style=\"width: 50%;\" />"
msgstr "<img alt=\"두 개의 테이블: 첫 번째 테이블은 스택에 있는 s1의 표현을 포함하며, 길이(5), 용량(5), 그리고 두 번째 테이블의 첫 번째 값을 가리키는 포인터로 구성됩니다. 두 번째 테이블은 힙에 있는 문자열 데이터의 바이트별 표현을 포함합니다.\" src=\"img/trpl04-01.svg\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch04-01-what-is-ownership.md:305
msgid ""
"<span class=\"caption\">Figure 4-1: Representation in memory of a `String` "
"holding the value `\"hello\"` bound to `s1`</span>"
msgstr "<span class=\"caption\">그림 4-1: `s1`에 바인딩된 값 `\"hello\"`를 가진 `String`의 메모리 표현</span>"

#: src/ch04-01-what-is-ownership.md:308
msgid ""
"The length is how much memory, in bytes, the contents of the `String` are "
"currently using. The capacity is the total amount of memory, in bytes, that "
"the `String` has received from the allocator. The difference between length "
"and capacity matters, but not in this context, so for now, it’s fine to "
"ignore the capacity."
msgstr "길이는 `String`의 내용이 현재 사용하고 있는 메모리 양(바이트 단위)입니다. 용량은 `String`이 할당자로부터 받은 총 메모리 양(바이트 단위)입니다. 길이와 용량의 차이는 중요하지만, 이 컨텍스트에서는 그렇지 않으므로 지금은 용량을 무시해도 됩니다."

#: src/ch04-01-what-is-ownership.md:314
msgid ""
"When we assign `s1` to `s2`, the `String` data is copied, meaning we copy "
"the pointer, the length, and the capacity that are on the stack. We do not "
"copy the data on the heap that the pointer refers to. In other words, the "
"data representation in memory looks like Figure 4-2."
msgstr "`s1`을 `s2`에 할당할 때 `String` 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이, 용량이 복사됩니다. 포인터가 참조하는 힙의 데이터는 복사되지 않습니다. 다시 말해, 메모리의 데이터 표현은 그림 4-2와 같습니다."

#: src/ch04-01-what-is-ownership.md:319
msgid ""
"<img alt=\"Three tables: tables s1 and s2 representing those strings on the\n"
"stack, respectively, and both pointing to the same string data on the heap."
"\"\n"
"src=\"img/trpl04-02.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:323
msgid ""
"<span class=\"caption\">Figure 4-2: Representation in memory of the variable "
"`s2` that has a copy of the pointer, length, and capacity of `s1`</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:326
msgid ""
"The representation does _not_ look like Figure 4-3, which is what memory "
"would look like if Rust instead copied the heap data as well. If Rust did "
"this, the operation `s2 = s1` could be very expensive in terms of runtime "
"performance if the data on the heap were large."
msgstr "표현은 그림 4-3과 같지 _않습니다_. 만약 러스트가 힙 데이터도 복사했다면 메모리는 그림 4-3과 같았을 것입니다. 만약 러스트가 이렇게 했다면, 힙의 데이터가 클 경우 `s2 = s1` 연산은 런타임 성능 측면에서 매우 비쌀 수 있습니다."
"표현은 그림 4-3과 같지 _않습니다_. 만약 러스트가 힙 데이터도 복사했다면 메모리는 그림 4-3과 같았을 것입니다. "
"만약 러스트가 이렇게 했다면, 힙의 데이터가 클 경우 `s2 = s1` 연산은 런타임 성능 측면에서 매우 비쌀 수 있습니다."

#: src/ch04-01-what-is-ownership.md:331
msgid ""
"<img alt=\"Four tables: two tables representing the stack data for s1 and "
"s2,\n"
"and each points to its own copy of string data on the heap.\"\n"
"src=\"img/trpl04-03.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:335
msgid ""
"<span class=\"caption\">Figure 4-3: Another possibility for what `s2 = s1` "
"might do if Rust copied the heap data as well</span>"
msgstr "<span class=\"caption\">그림 4-3: 러스트가 힙 데이터도 복사했다면 `s2 = s1`이 수행할 수 있는 또 다른 가능성</span>"

#: src/ch04-01-what-is-ownership.md:338
msgid ""
"Earlier, we said that when a variable goes out of scope, Rust automatically "
"calls the `drop` function and cleans up the heap memory for that variable. "
"But Figure 4-2 shows both data pointers pointing to the same location. This "
"is a problem: when `s2` and `s1` go out of scope, they will both try to free "
"the same memory. This is known as a _double free_ error and is one of the "
"memory safety bugs we mentioned previously. Freeing memory twice can lead to "
"memory corruption, which can potentially lead to security vulnerabilities."
msgstr "앞서 변수가 스코프를 벗어나면 러스트가 자동으로 `drop` 함수를 호출하여 해당 변수의 힙 메모리를 정리한다고 말했습니다. 하지만 그림 4-2는 두 데이터 포인터가 모두 동일한 위치를 가리키고 있음을 보여줍니다. 이것은 문제입니다. `s2`와 `s1`이 스코프를 벗어나면 둘 다 동일한 메모리를 해제하려고 시도할 것입니다. 이것은 _이중 해제_ 오류로 알려져 있으며 이전에 언급한 메모리 안전 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상으로 이어질 수 있으며, 이는 잠재적으로 보안 취약점으로 이어질 수 있습니다."

#: src/ch04-01-what-is-ownership.md:346
msgid ""
"To ensure memory safety, after the line `let s2 = s1;`, Rust considers `s1` "
"as no longer valid. Therefore, Rust doesn’t need to free anything when `s1` "
"goes out of scope. Check out what happens when you try to use `s1` after "
"`s2` is created; it won’t work:"
msgstr "메모리 안전을 보장하기 위해 `let s2 = s1;` 줄 다음에 러스트는 `s1`을 더 이상 유효하지 않은 것으로 간주합니다. 따라서 `s1`이 스코프를 벗어날 때 러스트는 아무것도 해제할 필요가 없습니다. `s2`가 생성된 후 `s1`을 사용하려고 할 때 어떤 일이 발생하는지 확인해 보세요. 작동하지 않을 것입니다:"

#: src/ch04-01-what-is-ownership.md:356
msgid "\"{s1}, world!\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:360
msgid ""
"You’ll get an error like this because Rust prevents you from using the "
"invalidated reference:"
msgstr "러스트가 유효하지 않은 참조를 사용하는 것을 막기 때문에 다음과 같은 오류가 발생합니다:"

#: src/ch04-01-what-is-ownership.md:363
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0382]: borrow of moved value: `s1`\n"
" --> src/main.rs:5:15\n"
"  |\n"
"2 |     let s1 = String::from(\"hello\");\n"
"  |         -- move occurs because `s1` has type `String`, which does not "
"implement the `Copy` trait\n"
"3 |     let s2 = s1;\n"
"  |              -- value moved here\n"
"4 |\n"
"5 |     println!(\"{s1}, world!\");\n"
"  |               ^^^^ value borrowed here after move\n"
"  |\n"
"  = note: this error originates in the macro `$crate::format_args_nl` which "
"comes from the expansion of the macro `println` (in Nightly builds, run with "
"-Z macro-backtrace for more info)\n"
"help: consider cloning the value if the performance cost is acceptable\n"
"  |\n"
"3 |     let s2 = s1.clone();\n"
"  |                ++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-01-what-is-ownership.md:387
msgid ""
"If you’ve heard the terms _shallow copy_ and _deep copy_ while working with "
"other languages, the concept of copying the pointer, length, and capacity "
"without copying the data probably sounds like making a shallow copy. But "
"because Rust also invalidates the first variable, instead of being called a "
"shallow copy, it’s known as a _move_. In this example, we would say that "
"`s1` was _moved_ into `s2`. So, what actually happens is shown in Figure 4-4."
msgstr "다른 언어로 작업하면서 _얕은 복사_와 _깊은 복사_라는 용어를 들어본 적이 있다면, 데이터를 복사하지 않고 포인터, 길이, 용량을 복사하는 개념은 얕은 복사를 만드는 것처럼 들릴 것입니다. 하지만 러스트는 첫 번째 변수도 무효화하기 때문에 얕은 복사라고 불리는 대신 _이동_으로 알려져 있습니다. 이 예에서는 `s1`이 `s2`로 _이동_되었다고 말할 것입니다. 따라서 실제로 일어나는 일은 그림 4-4에 나와 있습니다."

#: src/ch04-01-what-is-ownership.md:394
msgid ""
"<img alt=\"Three tables: tables s1 and s2 representing those strings on the\n"
"stack, respectively, and both pointing to the same string data on the heap.\n"
"Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used "
"to\n"
"access the heap data.\" src=\"img/trpl04-04.svg\" class=\"center\" "
"style=\"width:\n"
"50%;\" />"
msgstr ""

#: src/ch04-01-what-is-ownership.md:400
msgid ""
"<span class=\"caption\">Figure 4-4: Representation in memory after `s1` has "
"been invalidated</span>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:403
msgid ""
"That solves our problem! With only `s2` valid, when it goes out of scope it "
"alone will free the memory, and we’re done."
msgstr ""
"문제가 해결되었습니다! `s2`만 유효하므로, 스코프를 벗어나면 `s2`만 메모리를 해제하고 "
"작업이 완료됩니다."

#: src/ch04-01-what-is-ownership.md:406
msgid ""
"In addition, there’s a design choice that’s implied by this: Rust will never "
"automatically create “deep” copies of your data. Therefore, any _automatic_ "
"copying can be assumed to be inexpensive in terms of runtime performance."
msgstr "또한, 이것이 암시하는 설계 선택이 있습니다: 러스트는 데이터의 \"깊은\" 복사본을 자동으로 생성하지 않습니다. 따라서 모든 _자동_ 복사는 런타임 성능 측면에서 비용이 저렴하다고 가정할 수 있습니다."

#: src/ch04-01-what-is-ownership.md:410
msgid "Scope and Assignment"
msgstr "스코프와 할당"

#: src/ch04-01-what-is-ownership.md:412
msgid ""
"The inverse of this is true for the relationship between scoping, ownership, "
"and memory being freed via the `drop` function as well. When you assign a "
"completely new value to an existing variable, Rust will call `drop` and free "
"the original value’s memory immediately. Consider this code, for example:"
msgstr "이것의 역도 스코핑, 소유권, 그리고 `drop` 함수를 통한 메모리 해제 사이의 관계에 해당합니다. 기존 변수에 완전히 새로운 값을 할당하면, 러스트는 `drop`을 호출하고 원래 값의 메모리를 즉시 해제합니다. 예를 들어, 이 코드를 고려해 보세요:"

#: src/ch04-01-what-is-ownership.md:420
msgid "\"ahoy\""
msgstr "\"아호이\""

#: src/ch04-01-what-is-ownership.md:422
msgid "\"{s}, world!\""
msgstr "\" {s}, 세상아!\""

#: src/ch04-01-what-is-ownership.md:426
msgid ""
"We initially declare a variable `s` and bind it to a `String` with the value "
"`\"hello\"`. Then we immediately create a new `String` with the value "
"`\"ahoy\"` and assign it to `s`. At this point, nothing is referring to the "
"original value on the heap at all."
msgstr ""
"처음에 `s`라는 변수를 선언하고 `\"hello\"` 값을 가진 `String`에 바인딩합니다. "
"그런 다음 즉시 `\"ahoy\"` 값을 가진 새 `String`을 만들고 `s`에 할당합니다. "
"이 시점에서 힙의 원래 값을 참조하는 것은 아무것도 없습니다."


#: src/ch04-01-what-is-ownership.md:431
msgid ""
"<img alt=\"One table s representing the string value on the stack, pointing "
"to\n"
"the second piece of string data (ahoy) on the heap, with the original "
"string\n"
"data (hello) grayed out because it cannot be accessed anymore.\"\n"
"src=\"img/trpl04-05.svg\"\n"
"class=\"center\"\n"
"style=\"width: 50%;\"\n"
"/>"
msgstr ""

#: src/ch04-01-what-is-ownership.md:439
msgid ""
"<span class=\"caption\">Figure 4-5: Representation in memory after the "
"initial value has been replaced in its entirety.</span>"
msgstr "<span class=\"caption\">그림 4-5: 초기 값이 전체적으로 교체된 후의 메모리 표현.</span>"

#: src/ch04-01-what-is-ownership.md:442
msgid ""
"The original string thus immediately goes out of scope. Rust will run the "
"`drop` function on it and its memory will be freed right away. When we print "
"the value at the end, it will be `\"ahoy, world!\"`."
msgstr "따라서 원래 문자열은 즉시 스코프를 벗어납니다. 러스트는 해당 문자열에 대해 `drop` 함수를 실행하고 메모리는 즉시 해제됩니다. 마지막에 값을 출력하면 `\"ahoy, world!\"`가 됩니다."
#: src/ch04-01-what-is-ownership.md:448
msgid "<a id=\"ways-variables-and-data-interact-clone\"></a>"
msgstr "<a id=\"ways-variables-and-data-interact-clone\"></a>"

#: src/ch04-01-what-is-ownership.md:450
msgid "Ways Variables and Data Interact: Clone"
msgstr "변수와 데이터가 상호작용하는 방식: 클론"

#: src/ch04-01-what-is-ownership.md:452
msgid ""
"If we _do_ want to deeply copy the heap data of the `String`, not just the "
"stack data, we can use a common method called `clone`. We’ll discuss the "
"`clone` method and trait in more detail in Chapter 5 when we cover traits. "
"For now, it’s enough to know that it’s a common convention for any type that "
"implements the `Copy` trait to have a `clone` method that makes a full deep "
"copy of the data. Here’s an example of the `clone` method in action:"
msgstr ""
"만약 `String`의 힙 데이터를 스택 데이터뿐만 아니라 _깊게 복사_하고 싶다면, "
"`clone`이라는 일반적인 메서드를 사용할 수 있습니다. `clone` 메서드와 트레이트에 "
"대해서는 5장에서 트레이트를 다룰 때 더 자세히 논의할 것입니다. 지금은 `Copy` "
"트레이트를 구현하는 모든 타입에 대해 데이터의 완전한 깊은 복사를 수행하는 `clone` "
"메서드를 갖는 것이 일반적인 관례라는 것을 아는 것으로 충분합니다. 다음은 `clone` "
"메서드가 작동하는 예입니다:"

#: src/ch04-01-what-is-ownership.md:457
msgid "Here’s an example of the `clone` method in action:"
msgstr "다음은 `clone` 메서드가 작동하는 예입니다:"

#: src/ch04-01-what-is-ownership.md:464
msgid "\"s1 = {s1}, s2 = {s2}\""
msgstr "\"s1 = {s1}, s2 = {s2}\""

#: src/ch04-01-what-is-ownership.md:468
msgid ""
"This works just fine and explicitly produces the behavior shown in Figure "
"4-3, where the heap data _does_ get copied."
msgstr "이것은 잘 작동하며 그림 4-3에 표시된 동작, 즉 힙 데이터가 _복사되는_ 동작을 명시적으로 생성합니다."

#: src/ch04-01-what-is-ownership.md:471
msgid ""
"When you see a call to `clone`, you know that some arbitrary code is being "
"executed and that code may be expensive. It’s a visual indicator that "
"something different is going on."
msgstr "`clone` 호출을 보면 임의의 코드가 실행되고 있으며 해당 코드는 비용이 많이들 수 있다는 것을 알 수 있습니다. 이것은 뭔가 다른 일이 일어나고 있다는 시각적 표시입니다."

#: src/ch04-01-what-is-ownership.md:475
msgid "Stack-Only Data: Copy"
msgstr "스택 전용 데이터: 복사"

#: src/ch04-01-what-is-ownership.md:477
msgid ""
"There’s another wrinkle we haven’t talked about yet. This code using integers"
"—part of which was shown in Listing 4-2—works and is valid:"
msgstr "아직 이야기하지 않은 또 다른 주름이 있습니다. 정수를 사용하는 이 코드(일부는 목록 4-2에 표시됨)는 작동하며 유효합니다:"

#: src/ch04-01-what-is-ownership.md:485
msgid "\"x = {x}, y = {y}\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:489
msgid ""
"But this code seems to contradict what we just learned: we don’t have a call "
"to `clone`, but `x` is still valid and wasn’t moved into `y`."
msgstr "하지만 이 코드는 우리가 방금 배운 것과 모순되는 것 같습니다. `clone`을 호출하지 않았지만 `x`는 여전히 유효하며 `y`로 이동되지 않았습니다."

#: src/ch04-01-what-is-ownership.md:492
msgid ""
"The reason is that types such as integers that have a known size at compile "
"time are stored entirely on the stack, so copies of the actual values are "
"quick to make. That means there’s no reason we would want to prevent `x` "
"from being valid after we create the variable `y`. In other words, there’s "
"no difference between deep and shallow copying here, so calling `clone` "
"wouldn’t do anything different from the usual shallow copying, and we can "
"leave it out."
msgstr "그 이유는 컴파일 타임에 알려진 크기를 가진 정수와 같은 타입은 전적으로 스택에 저장되므로 실제 값의 복사본을 빠르게 만들 수 있기 때문입니다. 즉, 변수 `y`를 만든 후 `x`가 유효하지 않도록 막을 이유가 없습니다. 다시 말해, 여기서는 깊은 복사와 얕은 복사 사이에 차이가 없으므로 `clone`을 호출해도 일반적인 얕은 복사와 다른 작업을 수행하지 않으며 생략할 수 있습니다."

#: src/ch04-01-what-is-ownership.md:499
msgid ""
"Rust has a special annotation called the `Copy` trait that we can place on "
"types that are stored on the stack, as integers are (we’ll talk more about "
"traits in [Chapter 10](ch10-02-traits.html)<!-- ignore -->). If a type "
"implements the `Copy` trait, variables that use it do not move, but rather "
"are trivially copied, making them still valid after assignment to another "
"variable."
msgstr "러스트에는 정수와 같이 스택에 저장되는 타입에 배치할 수 있는 `Copy` 트레이트라는 특별한 어노테이션이 있습니다(트레이트에 대해서는 [10장](ch10-02-traits.html)<!-- 무시 -->에서 더 자세히 다룰 것입니다). 타입이 `Copy` 트레이트를 구현하면 해당 타입을 사용하는 변수는 이동되지 않고 간단하게 복사되어 다른 변수에 할당된 후에도 여전히 유효합니다."

#: src/ch04-01-what-is-ownership.md:505
msgid ""
"Rust won’t let us annotate a type with `Copy` if the type, or any of its "
"parts, has implemented the `Drop` trait. If the type needs something special "
"to happen when the value goes out of scope and we add the `Copy` annotation "
"to that type, we’ll get a compile-time error. To learn about how to add the "
"`Copy` annotation to your type to implement the trait, see [“Derivable "
"Traits”](appendix-03-derivable-traits.html)<!-- ignore --> in Appendix C."
msgstr "타입 또는 그 일부가 `Drop` 트레이트를 구현한 경우 러스트는 해당 타입에 `Copy` 어노테이션을 추가하는 것을 허용하지 않습니다. 값이 스코프를 벗어날 때 특별한 일이 일어나야 하는 타입에 `Copy` 어노테이션을 추가하면 컴파일 타임 오류가 발생합니다. 타입에 `Copy` 어노테이션을 추가하여 트레이트를 구현하는 방법에 대해 알아보려면 부록 C의 [“파생 가능한 트레이트”](appendix-03-derivable-traits.html)<!-- 무시 -->를 참조하세요."

#: src/ch04-01-what-is-ownership.md:512
msgid ""
"So, what types implement the `Copy` trait? You can check the documentation "
"for the given type to be sure, but as a general rule, any group of simple "
"scalar values can implement `Copy`, and nothing that requires allocation or "
"is some form of resource can implement `Copy`. Here are some of the types "
"that implement `Copy`:"
msgstr "그렇다면 어떤 타입이 `Copy` 트레이트를 구현할까요? 확실히 하려면 해당 타입의 문서를 확인할 수 있지만, 일반적인 규칙으로 간단한 스칼라 값 그룹은 `Copy`를 구현할 수 있으며, 할당이 필요하거나 어떤 형태의 리소스인 것은 `Copy`를 구현할 수 없습니다. 다음은 `Copy`를 구현하는 몇 가지 타입입니다:"

#: src/ch04-01-what-is-ownership.md:518
msgid "All the integer types, such as `u32`."
msgstr "`u32`와 같은 모든 정수 타입."

#: src/ch04-01-what-is-ownership.md:519
msgid "The Boolean type, `bool`, with values `true` and `false`."
msgstr "`true`와 `false` 값을 갖는 불리언 타입, `bool`."

#: src/ch04-01-what-is-ownership.md:520
msgid "All the floating-point types, such as `f64`."
msgstr "`f64`와 같은 모든 부동 소수점 타입."

#: src/ch04-01-what-is-ownership.md:521
msgid "The character type, `char`."
msgstr "문자 타입, `char`."

#: src/ch04-01-what-is-ownership.md:522
msgid ""
"Tuples, if they only contain types that also implement `Copy`. For example, "
"`(i32, i32)` implements `Copy`, but `(i32, String)` does not."
msgstr "튜플, 만약 `Copy`를 구현하는 타입만 포함하는 경우. 예를 들어, `(i32, i32)`는 `Copy`를 구현하지만 `(i32, String)`은 그렇지 않습니다."

#: src/ch04-01-what-is-ownership.md:525
msgid "Ownership and Functions"
msgstr "소유권과 함수"

#: src/ch04-01-what-is-ownership.md:527
msgid ""
"The mechanics of passing a value to a function are similar to what happens "
"when we assign a value to a variable. Passing a variable to a function will "
"_move_ or _copy_, just as assignment does. Listing 4-6 has an example with "
"some annotations showing where variables go into and out of scope."
msgstr ""
"함수에 값을 전달하는 메커니즘은 변수에 값을 할당할 때 발생하는 것과 유사합니다. "
"변수를 함수에 전달하면 할당과 마찬가지로 _이동_되거나 _복사_됩니다. 목록 4-6은 "
"변수가 스코프 안팎으로 이동하는 것을 보여주는 주석이 있는 예시입니다."

#: src/ch04-01-what-is-ownership.md:536
msgid "// s comes into scope\n"
msgstr "// s가 스코프 안으로 들어옵니다\n"

#: src/ch04-01-what-is-ownership.md:538
msgid ""
"// s's value moves into function and is no longer valid here\n"
msgstr "// s의 값이 함수로 이동하여 여기서는 더 이상 유효하지 않습니다.\n"

#: src/ch04-01-what-is-ownership.md:541
msgid "// x comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:543
msgid ""
"// because i32 implements the Copy trait,\n"
"                                    // x does NOT move into the function,\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:545 src/ch20-02-advanced-traits.md:615
#: src/ch20-02-advanced-traits.md:619 src/ch20-02-advanced-traits.md:647
#: src/ch20-02-advanced-traits.md:651 src/ch20-02-advanced-traits.md:719
#: src/ch20-02-advanced-traits.md:723
msgid "\"{}\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:545
msgid "// so it's okay to use x afterward\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:547
msgid ""
"// Here, x goes out of scope, then s. But because s's value was moved, "
"nothing\n"
"  // special happens.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:550 src/ch04-01-what-is-ownership.md:592
msgid "// some_string comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:551
msgid "\"{some_string}\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:552
msgid ""
"// Here, some_string goes out of scope and `drop` is called. The backing\n"
"  // memory is freed.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:555
msgid "// some_integer comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:556
msgid "\"{some_integer}\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:557
msgid "// Here, some_integer goes out of scope. Nothing special happens.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:562
msgid ""
"If we tried to use `s` after the call to `takes_ownership`, Rust would throw "
"a compile-time error. These static checks protect us from mistakes. Try "
"adding code to `main` that uses `s` and `x` to see where you can use them "
"and where the ownership rules prevent you from doing so."
msgstr ""

#: src/ch04-01-what-is-ownership.md:567
msgid "Return Values and Scope"
msgstr ""

#: src/ch04-01-what-is-ownership.md:569
msgid ""
"Returning values can also transfer ownership. Listing 4-4 shows an example "
"of a function that returns some value, with similar annotations as those in "
"Listing 4-3."
msgstr ""

#: src/ch04-01-what-is-ownership.md:577
msgid ""
"// gives_ownership moves its return\n"
"                                       // value into s1\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:580
msgid "// s2 comes into scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:582
msgid "" "// s2 is moved into\n" "                                       // takes_and_gives_back, which also\n" "                                       // moves its return value into s3\n" msgstr "// s2는 takes_and_gives_back으로 이동되고, 이는 반환 값을 s3으로 이동시킵니다.\n"

#: src/ch04-01-what-is-ownership.md:585
msgid ""
"// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n"
"  // happens. s1 goes out of scope and is dropped.\n"
msgstr "// 여기서 s3는 스코프를 벗어나 드롭됩니다. s2는 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프를 벗어나 드롭됩니다."

#: src/ch04-01-what-is-ownership.md:588
msgid "fn gives_ownership() -> String {             // gives_ownership will move its return value into the function that calls it"
msgstr "fn gives_ownership() -> String {             // gives_ownership는 반환 값을 호출하는 함수로 이동시킵니다."

#: src/ch04-01-what-is-ownership.md:592
msgid "\"yours\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:594
msgid ""
"// some_string is returned and\n"
"                                       // moves out to the calling\n"
"                                       // function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:598
msgid "// This function takes a String and returns a String.\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:601
msgid ""
"// a_string comes into\n"
"    // scope\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:604
msgid "// a_string is returned and moves out to the calling function\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:610
msgid ""
"The ownership of a variable follows the same pattern every time: assigning a "
"value to another variable moves it. When a variable that includes data on "
"the heap goes out of scope, the value will be cleaned up by `drop` unless "
"ownership of the data has been moved to another variable."
msgstr ""

#: src/ch04-01-what-is-ownership.md:615
msgid ""
"While this works, taking ownership and then returning ownership with every "
"function is a bit tedious. What if we want to let a function use a value but "
"not take ownership? It’s quite annoying that anything we pass in also needs "
"to be passed back if we want to use it again, in addition to any data "
"resulting from the body of the function that we might want to return as well."
msgstr ""

#: src/ch04-01-what-is-ownership.md:621
msgid ""
"Rust does let us return multiple values using a tuple, as shown in Listing "
"4-5."
msgstr ""

#: src/ch04-01-what-is-ownership.md:631
msgid "\"The length of '{s2}' is {len}.\""
msgstr ""

#: src/ch04-01-what-is-ownership.md:635
msgid "// len() returns the length of a String\n"
msgstr ""

#: src/ch04-01-what-is-ownership.md:643
msgid ""
"But this is too much ceremony and a lot of work for a concept that should be "
"common. Luckily for us, Rust has a feature for using a value without "
"transferring ownership, called _references_."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:3
msgid ""
"The issue with the tuple code in Listing 4-5 is that we have to return the "
"`String` to the calling function so we can still use the `String` after the "
"call to `calculate_length`, because the `String` was moved into "
"`calculate_length`. Instead, we can provide a reference to the `String` "
"value. A _reference_ is like a pointer in that it’s an address we can follow "
"to access the data stored at that address; that data is owned by some other "
"variable. Unlike a pointer, a reference is guaranteed to point to a valid "
"value of a particular type for the life of that reference."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:12
msgid ""
"Here is how you would define and use a `calculate_length` function that has "
"a reference to an object as a parameter instead of taking ownership of the "
"value:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:23
#: src/ch04-02-references-and-borrowing.md:59
#: src/ch04-02-references-and-borrowing.md:80
msgid "\"The length of '{s1}' is {len}.\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:33
msgid ""
"First, notice that all the tuple code in the variable declaration and the "
"function return value is gone. Second, note that we pass `&s1` into "
"`calculate_length` and, in its definition, we take `&String` rather than "
"`String`. These ampersands represent _references_, and they allow you to "
"refer to some value without taking ownership of it. Figure 4-6 depicts this "
"concept."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:39
msgid ""
"<img alt=\"Three tables: the table for s contains only a pointer to the "
"table\n"
"for s1. The table for s1 contains the stack data for s1 and points to the\n"
"string data on the heap.\" src=\"img/trpl04-06.svg\" class=\"center\" />"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:43
msgid ""
"<span class=\"caption\">Figure 4-6: A diagram of `&String s` pointing at "
"`String s1`</span>"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:46
msgid ""
"Note: The opposite of referencing by using `&` is _dereferencing_, which is "
"accomplished with the dereference operator, `*`. We’ll see some uses of the "
"dereference operator in Chapter 8 and discuss details of dereferencing in "
"Chapter 15."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:51
msgid "Let’s take a closer look at the function call here:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:67
msgid ""
"The `&s1` syntax lets us create a reference that _refers_ to the value of "
"`s1` but does not own it. Because the reference does not own it, the value "
"it points to will not be dropped when the reference stops being used."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:71
msgid ""
"Likewise, the signature of the function uses `&` to indicate that the type "
"of the parameter `s` is a reference. Let’s add some explanatory annotations:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:83
msgid "// s is a reference to a String\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:85
msgid ""
"// Here, s goes out of scope. But because s does not have ownership of what\n"
"  // it refers to, the value is not dropped.\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:89
msgid ""
"The scope in which the variable `s` is valid is the same as any function "
"parameter’s scope, but the value pointed to by the reference is not dropped "
"when `s` stops being used, because `s` doesn’t have ownership. When "
"functions have references as parameters instead of the actual values, we "
"won’t need to return the values in order to give back ownership, because we "
"never had ownership."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:96
msgid ""
"We call the action of creating a reference _borrowing_. As in real life, if "
"a person owns something, you can borrow it from them. When you’re done, you "
"have to give it back. What happens if you try to modify a borrowed value? "
"Try the code in Listing 4-10."
msgstr ""
"우리는 참조를 생성하는 행위를 _빌림_이라고 부릅니다. 실제 생활에서 사람이 무언가를 "
"소유하고 있다면, 그 사람에게서 빌릴 수 있습니다. 사용을 마쳤으면 돌려줘야 합니다. "
"빌린 값을 수정하려고 하면 어떻게 될까요? 목록 4-10의 코드를 시도해 보세요."

#: src/ch04-02-references-and-borrowing.md:100
msgid ""
"So, what happens if we try to modify something we’re borrowing? Try the code "
"in Listing 4-6. Spoiler alert: it doesn’t work!"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:113
#: src/ch04-02-references-and-borrowing.md:157
msgid "\", world\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:119
#: src/ch04-02-references-and-borrowing.md:187
#: src/ch04-02-references-and-borrowing.md:258
#: src/ch04-02-references-and-borrowing.md:346
msgid "Here’s the error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:121
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` "
"reference\n"
" --> src/main.rs:8:5\n"
"  |\n"
"8 |     some_string.push_str(\", world\");\n"
"  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers "
"to cannot be borrowed as mutable\n"
"  |\n"
"help: consider changing this to be a mutable reference\n"
"  |\n"
"7 | fn change(some_string: &mut String) {\n"
"  |                         +++\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:139
msgid ""
"Just as variables are immutable by default, so are references. We’re not "
"allowed to modify something we have a reference to."
msgstr "변수가 기본적으로 불변인 것처럼 참조도 마찬가지입니다. 참조하는 것을 수정할 수 없습니다."

#: src/ch04-02-references-and-borrowing.md:142
msgid "Mutable References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:144
msgid ""
"We can fix the code from Listing 4-6 to allow us to modify a borrowed value "
"with just a few small tweaks that use, instead, a _mutable reference_:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:163
msgid ""
"First we change `s` to be `mut`. Then we create a mutable reference with "
"`&mut s` where we call the `change` function, and update the function "
"signature to accept a mutable reference with `some_string: &mut String`. "
"This makes it very clear that the `change` function will mutate the value it "
"borrows."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:168
msgid ""
"Mutable references have one big restriction: if you have a mutable reference "
"to a value, you can have no other references to that value. This code that "
"attempts to create two mutable references to `s` will fail:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:181
msgid "\"{}, {}\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:189
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0499]: cannot borrow `s` as mutable more than once at a time\n"
" --> src/main.rs:5:14\n"
"  |\n"
"4 |     let r1 = &mut s;\n"
"  |              ------ first mutable borrow occurs here\n"
"5 |     let r2 = &mut s;\n"
"  |              ^^^^^^ second mutable borrow occurs here\n"
"6 |\n"
"7 |     println!(\"{}, {}\", r1, r2);\n"
"  |                        -- first borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0499`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:207
msgid ""
"This error says that this code is invalid because we cannot borrow `s` as "
"mutable more than once at a time. The first mutable borrow is in `r1` and "
"must last until it’s used in the `println!`, but between the creation of "
"that mutable reference and its usage, we tried to create another mutable "
"reference in `r2` that borrows the same data as `r1`."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:213
msgid ""
"The restriction preventing multiple mutable references to the same data at "
"the same time allows for mutation but in a very controlled fashion. It’s "
"something that new Rustaceans struggle with because most languages let you "
"mutate whenever you’d like. The benefit of having this restriction is that "
"Rust can prevent data races at compile time. A _data race_ is similar to a "
"race condition and happens when these three behaviors occur:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:220
msgid "Two or more pointers access the same data at the same time."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:221
msgid "At least one of the pointers is being used to write to the data."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:222
msgid "There’s no mechanism being used to synchronize access to the data."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:224
msgid ""
"Data races cause undefined behavior and can be difficult to diagnose and fix "
"when you’re trying to track them down at runtime; Rust prevents this problem "
"by refusing to compile code with data races!"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:228
msgid ""
"As always, we can use curly brackets to create a new scope, allowing for "
"multiple mutable references, just not _simultaneous_ ones:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:237
msgid ""
"// r1 goes out of scope here, so we can make a new reference with no "
"problems.\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:243
msgid ""
"Rust enforces a similar rule for combining mutable and immutable references. "
"This code results in an error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:250
#: src/ch04-02-references-and-borrowing.md:251
#: src/ch04-02-references-and-borrowing.md:296
#: src/ch04-02-references-and-borrowing.md:297
#: src/ch04-02-references-and-borrowing.md:301
msgid "// no problem\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:252
msgid "// BIG PROBLEM\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:254
msgid "\"{}, {}, and {}\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:260
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0502]: cannot borrow `s` as mutable because it is also borrowed as "
"immutable\n"
" --> src/main.rs:6:14\n"
"  |\n"
"4 |     let r1 = &s; // no problem\n"
"  |              -- immutable borrow occurs here\n"
"5 |     let r2 = &s; // no problem\n"
"6 |     let r3 = &mut s; // BIG PROBLEM\n"
"  |              ^^^^^^ mutable borrow occurs here\n"
"7 |\n"
"8 |     println!(\"{}, {}, and {}\", r1, r2, r3);\n"
"  |                                -- immutable borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:279
msgid ""
"Whew! We _also_ cannot have a mutable reference while we have an immutable "
"one to the same value."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:282
msgid ""
"Users of an immutable reference don’t expect the value to suddenly change "
"out from under them! However, multiple immutable references are allowed "
"because no one who is just reading the data has the ability to affect anyone "
"else’s reading of the data."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:287
msgid ""
"Note that a reference’s scope starts from where it is introduced and "
"continues through the last time that reference is used. For instance, this "
"code will compile because the last usage of the immutable references is in "
"the `println!`, before the mutable reference is introduced:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:298
msgid "\"{r1} and {r2}\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:299
msgid "// Variables r1 and r2 will not be used after this point.\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:302
msgid "\"{r3}\""
msgstr ""

#: src/ch04-02-references-and-borrowing.md:306
msgid ""
"The scopes of the immutable references `r1` and `r2` end after the `println!"
"` where they are last used, which is before the mutable reference `r3` is "
"created. These scopes don’t overlap, so this code is allowed: the compiler "
"can tell that the reference is no longer being used at a point before the "
"end of the scope."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:312
msgid ""
"Even though borrowing errors may be frustrating at times, remember that it’s "
"the Rust compiler pointing out a potential bug early (at compile time rather "
"than at runtime) and showing you exactly where the problem is. Then you "
"don’t have to track down why your data isn’t what you thought it was."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:317
msgid "Dangling References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:319
msgid ""
"In languages with pointers, it’s easy to erroneously create a _dangling "
"pointer_—a pointer that references a location in memory that may have been "
"given to someone else—by freeing some memory while preserving a pointer to "
"that memory. In Rust, by contrast, the compiler guarantees that references "
"will never be dangling references: if you have a reference to some data, the "
"compiler will ensure that the data will not go out of scope before the "
"reference to the data does."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:327
msgid ""
"Let’s try to create a dangling reference to see how Rust prevents them with "
"a compile-time error:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:348
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:5:16\n"
"  |\n"
"5 | fn dangle() -> &String {\n"
"  |                ^ expected named lifetime parameter\n"
"  |\n"
"  = help: this function's return type contains a borrowed value, but there "
"is no value for it to be borrowed from\n"
"help: consider using the `'static` lifetime, but this is uncommon unless "
"you're returning a borrowed value from a `const` or a `static`\n"
"  |\n"
"5 | fn dangle() -> &'static String {\n"
"  |                 +++++++\n"
"help: instead, you are more likely to want to return an owned value\n"
"  |\n"
"5 - fn dangle() -> &String {\n"
"5 + fn dangle() -> String {\n"
"  |\n"
"\n"
"error[E0515]: cannot return reference to local variable `s`\n"
" --> src/main.rs:8:5\n"
"  |\n"
"8 |     &s\n"
"  |     ^^ returns a reference to data owned by the current function\n"
"\n"
"Some errors have detailed explanations: E0106, E0515.\n"
"For more information about an error, try `rustc --explain E0106`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 2 previous "
"errors\n"
"```"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:379
msgid ""
"This error message refers to a feature we haven’t covered yet: lifetimes. "
"We’ll discuss lifetimes in detail in Chapter 10. But, if you disregard the "
"parts about lifetimes, the message does contain the key to why this code is "
"a problem:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:388
msgid ""
"Let’s take a closer look at exactly what’s happening at each stage of our "
"`dangle` code:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:398
msgid "// dangle returns a reference to a String\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:400
msgid "// s is a new String\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:402
msgid "// we return a reference to the String, s\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:403
msgid ""
"// Here, s goes out of scope, and is dropped, so its memory goes away.\n"
"  // Danger!\n"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:409
msgid ""
"Because `s` is created inside `dangle`, when the code of `dangle` is "
"finished, `s` will be deallocated. But we tried to return a reference to it. "
"That means this reference would be pointing to an invalid `String`. That’s "
"no good! Rust won’t let us do this."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:414
msgid "The solution here is to return the `String` directly:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:428
msgid ""
"This works without any problems. Ownership is moved out, and nothing is "
"deallocated."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:431
msgid "The Rules of References"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:433
msgid "Let’s recap what we’ve discussed about references:"
msgstr ""

#: src/ch04-02-references-and-borrowing.md:435
msgid ""
"At any given time, you can have _either_ one mutable reference _or_ any "
"number of immutable references."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:437
#: src/ch15-05-interior-mutability.md:27
msgid "References must always be valid."
msgstr ""

#: src/ch04-02-references-and-borrowing.md:439
msgid "Next, we’ll look at a different kind of reference: slices."
msgstr ""

#: src/ch04-03-slices.md:3
msgid ""
"_Slices_ let you reference a contiguous sequence of elements in a "
"[collection](ch08-00-common-collections.md) rather than the whole "
"collection. A slice is a kind of reference, so it does not have ownership."
msgstr ""

#: src/ch04-03-slices.md:7
msgid ""
"Here’s a small programming problem: write a function that takes a string of "
"words separated by spaces and returns the first word it finds in that "
"string. If the function doesn’t find a space in the string, the whole string "
"must be one word, so the entire string should be returned."
msgstr ""

#: src/ch04-03-slices.md:12
msgid ""
"Let’s work through how we’d write the signature of this function without "
"using slices, to understand the problem that slices will solve:"
msgstr ""

#: src/ch04-03-slices.md:19
msgid ""
"The `first_word` function has a `&String` as a parameter. We don’t need "
"ownership, so this is fine. (In idiomatic Rust, functions do not take "
"ownership of their arguments unless they need to, and the reasons for that "
"will become clear as we keep going!) But what should we return? We don’t "
"really have a way to talk about part of a string. However, we could return "
"the index of the end of the word, indicated by a space. Let’s try that, as "
"shown in Listing 4-7."
msgstr ""

#: src/ch04-03-slices.md:33 src/ch04-03-slices.md:55 src/ch04-03-slices.md:73
#: src/ch04-03-slices.md:107 src/ch04-03-slices.md:132
#: src/ch04-03-slices.md:261 src/ch04-03-slices.md:306
#: src/ch04-03-slices.md:394 src/ch04-03-slices.md:443
#: src/ch10-03-lifetime-syntax.md:586
msgid "b' '"
msgstr ""

#: src/ch04-03-slices.md:46
msgid ""
"Because we need to go through the `String` element by element and check "
"whether a value is a space, we’ll convert our `String` to an array of bytes "
"using the `as_bytes` method."
msgstr ""

#: src/ch04-03-slices.md:66
msgid ""
"Next, we create an iterator over the array of bytes using the `iter` method:"
msgstr ""

#: src/ch04-03-slices.md:84
msgid ""
"We’ll discuss iterators in more detail in [Chapter 13](ch13-02-"
"iterators.html)<!-- ignore -->. For now, know that `iter` is a method that "
"returns each element in a collection and that `enumerate` wraps the result "
"of `iter` and returns each element as part of a tuple instead. The first "
"element of the tuple returned from `enumerate` is the index, and the second "
"element is a reference to the element. This is a bit more convenient than "
"calculating the index ourselves."
msgstr ""

#: src/ch04-03-slices.md:91
msgid ""
"Because the `enumerate` method returns a tuple, we can use patterns to "
"destructure that tuple. We’ll be discussing patterns more in [Chapter 6]"
"(ch06-02-match.html#patterns-that-bind-to-values)<!-- ignore -->. In the "
"`for` loop, we specify a pattern that has `i` for the index in the tuple and "
"`&item` for the single byte in the tuple. Because we get a reference to the "
"element from `.iter().enumerate()`, we use `&` in the pattern."
msgstr ""

#: src/ch04-03-slices.md:98
msgid ""
"Inside the `for` loop, we search for the byte that represents the space by "
"using the byte literal syntax. If we find a space, we return the position. "
"Otherwise, we return the length of the string by using `s.len()`."
msgstr ""

#: src/ch04-03-slices.md:118
msgid ""
"We now have a way to find out the index of the end of the first word in the "
"string, but there’s a problem. We’re returning a `usize` on its own, but "
"it’s only a meaningful number in the context of the `&String`. In other "
"words, because it’s a separate value from the `String`, there’s no guarantee "
"that it will still be valid in the future. Consider the program in Listing "
"4-8 that uses the `first_word` function from Listing 4-7."
msgstr ""

#: src/ch04-03-slices.md:141 src/ch04-03-slices.md:182
#: src/ch04-03-slices.md:315 src/ch04-03-slices.md:403
#: src/ch04-03-slices.md:412 src/ch04-03-slices.md:452
#: src/ch04-03-slices.md:461 src/ch10-03-lifetime-syntax.md:595
#: src/ch10-03-lifetime-syntax.md:600
msgid "\"hello world\""
msgstr ""

#: src/ch04-03-slices.md:143
msgid "// word will get the value 5\n"
msgstr ""

#: src/ch04-03-slices.md:145
msgid "// this empties the String, making it equal to \"\"\n"
msgstr ""

#: src/ch04-03-slices.md:147
msgid ""
"// `word` still has the value `5` here, but `s` no longer has any content\n"
"    // that we could meaningfully use with the value `5`, so `word` is now\n"
"    // totally invalid!\n"
msgstr ""

#: src/ch04-03-slices.md:155
msgid ""
"This program compiles without any errors and would also do so if we used "
"`word` after calling `s.clear()`. Because `word` isn’t connected to the "
"state of `s` at all, `word` still contains the value `5`. We could use that "
"value `5` with the variable `s` to try to extract the first word out, but "
"this would be a bug because the contents of `s` have changed since we saved "
"`5` in `word`."
msgstr ""

#: src/ch04-03-slices.md:161
msgid ""
"Having to worry about the index in `word` getting out of sync with the data "
"in `s` is tedious and error prone! Managing these indices is even more "
"brittle if we write a `second_word` function. Its signature would have to "
"look like this:"
msgstr ""

#: src/ch04-03-slices.md:169
msgid ""
"Now we’re tracking a starting _and_ an ending index, and we have even more "
"values that were calculated from data in a particular state but aren’t tied "
"to that state at all. We have three unrelated variables floating around that "
"need to be kept in sync."
msgstr ""

#: src/ch04-03-slices.md:174
msgid "Luckily, Rust has a solution to this problem: string slices."
msgstr "다행히 러스트는 이 문제에 대한 해결책인 문자열 슬라이스를 가지고 있습니다."

#: src/ch04-03-slices.md:176
msgid "String Slices"
msgstr "문자열 슬라이스"

#: src/ch04-03-slices.md:178
msgid ""
"A _string slice_ is a reference to part of a `String`, and it looks like "
"this:"
msgstr "_문자열 슬라이스_는 `String`의 일부에 대한 참조이며, 다음과 같습니다:"

#: src/ch04-03-slices.md:189
msgid ""
"Rather than a reference to the entire `String`, `hello` is a reference to a "
"portion of the `String`, specified in the extra `[0..5]` bit. We create "
"slices using a range within brackets by specifying "
"`[starting_index..ending_index]`, where _`starting_index`_ is the first "
"position in the slice and _`ending_index`_ is one more than the last "
"position in the slice. Internally, the slice data structure stores the "
"starting position and the length of the slice, which corresponds to "
"_`ending_index`_ minus _`starting_index`_. So, in the case of `let world = "
"&s[6..11];`, `world` would be a slice that contains a pointer to the byte at "
"index 6 of `s` with a length value of `5`."
msgstr "전체 `String`에 대한 참조라기보다는, `hello`는 추가 `[0..5]` 비트에 지정된 `String`의 일부에 대한 참조입니다. 우리는 대괄호 안에 `[starting_index..ending_index]`를 지정하여 범위를 사용하여 슬라이스를 생성합니다. 여기서 _`starting_index`_는 슬라이스의 첫 번째 위치이고 _`ending_index`_는 슬라이스의 마지막 위치보다 하나 더 큰 값입니다. 내부적으로 슬라이스 데이터 구조는 시작 위치와 슬라이스의 길이를 저장하며, 이는 _`ending_index`_에서 _`starting_index`_를 뺀 값에 해당합니다. 따라서 `let world = &s[6..11];`의 경우, `world`는 `s`의 인덱스 6에 있는 바이트에 대한 포인터와 길이 값 `5`를 포함하는 슬라이스가 됩니다."

#: src/ch04-03-slices.md:199
msgid "Figure 4-7 shows this in a diagram."
msgstr "그림 4-7은 이를 다이어그램으로 보여줍니다."

#: src/ch04-03-slices.md:201
msgid ""
"<img alt=\"Three tables: a table representing the stack data of s, which "
"points\n"
"to the byte at index 0 in a table of the string data &quot;hello world&quot; "
"on\n"
"the heap. The third table rep-resents the stack data of the slice world, "
"which\n"
"has a length value of 5 and points to byte 6 of the heap data table.\"\n"
"src=\"img/trpl04-07.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-03-slices.md:207
msgid ""
"<span class=\"caption\">Figure 4-7: String slice referring to part of a "
"`String`</span>"
msgstr ""

#: src/ch04-03-slices.md:210
msgid ""
"With Rust’s `..` range syntax, if you want to start at index 0, you can drop "
"the value before the two periods. In other words, these are equal:"
msgstr "러스트의 `..` 범위 구문을 사용하면, 인덱스 0에서 시작하고 싶을 때 두 개의 점 앞에 있는 값을 생략할 수 있습니다. 즉, 다음은 동일합니다:"

#: src/ch04-03-slices.md:220
msgid ""
"By the same token, if your slice includes the last byte of the `String`, you "
"can drop the trailing number. That means these are equal:"
msgstr "마찬가지로, 슬라이스에 `String`의 마지막 바이트가 포함되면, 뒤에 오는 숫자를 생략할 수 있습니다. 즉, 다음은 동일합니다:"

#: src/ch04-03-slices.md:232
msgid ""
"You can also drop both values to take a slice of the entire string. So these "
"are equal:"
msgstr "전체 문자열의 슬라이스를 가져오기 위해 두 값 모두를 생략할 수도 있습니다. 따라서 다음은 동일합니다:"

#: src/ch04-03-slices.md:244
msgid ""
"Note: String slice range indices must occur at valid UTF-8 character "
"boundaries. If you attempt to create a string slice in the middle of a "
"multibyte character, your program will exit with an error. For the purposes "
"of introducing string slices, we are assuming ASCII only in this section; a "
"more thorough discussion of UTF-8 handling is in the [“Storing UTF-8 Encoded "
"Text with Strings”](ch08-02-strings.html#storing-utf-8-encoded-text-with-"
"strings)<!-- ignore --> section of Chapter 8."
msgstr "참고: 문자열 슬라이스 범위 인덱스는 유효한 UTF-8 문자 경계에서 발생해야 합니다. 멀티바이트 문자 중간에 문자열 슬라이스를 생성하려고 하면 프로그램이 오류와 함께 종료됩니다. 문자열 슬라이스를 소개하기 위해 이 섹션에서는 ASCII만 가정합니다. UTF-8 처리에 대한 더 자세한 논의는 8장의 [“문자열로 UTF-8 인코딩된 텍스트 저장하기”](ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)<!-- ignore --> 섹션에 있습니다."

#: src/ch04-03-slices.md:251
msgid ""
"With all this information in mind, let’s rewrite `first_word` to return a "
"slice. The type that signifies “string slice” is written as `&str`:"
msgstr "이 모든 정보를 염두에 두고, `first_word`를 슬라이스를 반환하도록 다시 작성해 봅시다. \"문자열 슬라이스\"를 나타내는 타입은 `&str`로 작성됩니다:"

#: src/ch04-03-slices.md:274
msgid ""
"We get the index for the end of the word the same way we did in Listing 4-7, "
"by looking for the first occurrence of a space. When we find a space, we "
"return a string slice using the start of the string and the index of the "
"space as the starting and ending indices."
msgstr "목록 4-7에서 했던 것과 동일한 방식으로 공백의 첫 번째 발생을 찾아 단어 끝의 인덱스를 얻습니다. 공백을 찾으면 문자열의 시작과 공백의 인덱스를 시작 및 끝 인덱스로 사용하여 문자열 슬라이스를 반환합니다."

#: src/ch04-03-slices.md:279
msgid ""
"Now when we call `first_word`, we get back a single value that is tied to "
"the underlying data. The value is made up of a reference to the starting "
"point of the slice and the number of elements in the slice."
msgstr "이제 `first_word`를 호출하면, 기본 데이터에 연결된 단일 값을 반환받습니다. 이 값은 슬라이스의 시작점에 대한 참조와 슬라이스 내 요소의 수로 구성됩니다."

#: src/ch04-03-slices.md:283
msgid "Returning a slice would also work for a `second_word` function:"
msgstr "슬라이스를 반환하는 것은 `second_word` 함수에서도 작동할 것입니다:"

#: src/ch04-03-slices.md:289
msgid ""
"We now have a straightforward API that’s much harder to mess up because the "
"compiler will ensure the references into the `String` remain valid. Remember "
"the bug in the program in Listing 4-8, when we got the index to the end of "
"the first word but then cleared the string so our index was invalid? That "
"code was logically incorrect but didn’t show any immediate errors. The "
"problems would show up later if we kept trying to use the first word index "
"with an emptied string. Slices make this bug impossible and let us know we "
"have a problem with our code much sooner. Using the slice version of "
"`first_word` will throw a compile-time error:"
msgstr "이제 컴파일러가 `String`에 대한 참조가 유효하게 유지되도록 보장하기 때문에 훨씬 더 망가뜨리기 어려운 간단한 API를 갖게 되었습니다. 목록 4-8의 프로그램에서 첫 번째 단어의 끝 인덱스를 얻었지만 문자열을 지워서 인덱스가 유효하지 않게 되었던 버그를 기억하세요? 그 코드는 논리적으로는 잘못되었지만 즉각적인 오류를 보여주지는 않았습니다. 비워진 문자열과 함께 첫 번째 단어 인덱스를 계속 사용하려고 하면 나중에 문제가 나타났을 것입니다. 슬라이스는 이러한 버그를 불가능하게 만들고 코드에 문제가 있음을 훨씬 더 빨리 알 수 있도록 합니다. `first_word`의 슬라이스 버전을 사용하면 컴파일 타임 오류가 발생합니다:"

#: src/ch04-03-slices.md:319
msgid "// error!\n"
msgstr "// 오류!\n"

#: src/ch04-03-slices.md:321
msgid "\"the first word is: {word}\""
msgstr ""

#: src/ch04-03-slices.md:327
msgid "Here’s the compiler error:"
msgstr "다음은 컴파일러 오류입니다:"

#: src/ch04-03-slices.md:329
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0502]: cannot borrow `s` as mutable because it is also borrowed as "
"immutable\n"
"  --> src/main.rs:18:5\n"
"   |\n"
"16 |     let word = first_word(&s);\n"
"   |                           -- immutable borrow occurs here\n"
"17 |\n"
"18 |     s.clear(); // error!\n"
"   |     ^^^^^^^^^ mutable borrow occurs here\n"
"19 |\n"
"20 |     println!(\"the first word is: {word}\");\n"
"   |                                  ------ immutable borrow later used "
"here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:348
msgid ""
"Recall from the borrowing rules that if we have an immutable reference to "
"something, we cannot also take a mutable reference. Because `clear` needs to "
"truncate the `String`, it needs to get a mutable reference. The `println!` "
"after the call to `clear` uses the reference in `word`, so the immutable "
"reference must still be active at that point. Rust disallows the mutable "
"reference in `clear` and the immutable reference in `word` from existing at "
"the same time, and compilation fails. Not only has Rust made our API easier "
"to use, but it has also eliminated an entire class of errors at compile time!"
msgstr "빌림 규칙에서 기억하듯이, 어떤 것에 대한 불변 참조가 있다면 가변 참조도 가질 수 없습니다. `clear`는 `String`을 잘라내야 하므로 가변 참조를 얻어야 합니다. `clear` 호출 후의 `println!`은 `word`의 참조를 사용하므로, 불변 참조는 그 시점에도 활성화되어 있어야 합니다. 러스트는 `clear`의 가변 참조와 `word`의 불변 참조가 동시에 존재하는 것을 허용하지 않으며, 컴파일이 실패합니다. 러스트는 API를 사용하기 쉽게 만들었을 뿐만 아니라, 컴파일 타임에 전체 오류 클래스를 제거했습니다!"

#: src/ch04-03-slices.md:359
msgid "<a id=\"string-literals-are-slices\"></a>"
msgstr "<a id=\"string-literals-are-slices\"></a>"

#: src/ch04-03-slices.md:361
msgid "String Literals as Slices"
msgstr "슬라이스로서의 문자열 리터럴"

#: src/ch04-03-slices.md:363
msgid ""
"Recall that we talked about string literals being stored inside the binary. "
"Now that we know about slices, we can properly understand string literals:"
msgstr "문자열 리터럴이 바이너리 내부에 저장된다는 것을 기억하세요. 이제 슬라이스에 대해 알았으니, 문자열 리터럴을 제대로 이해할 수 있습니다:"

#: src/ch04-03-slices.md:370
msgid ""
"The type of `s` here is `&str`: it’s a slice pointing to that specific point "
"of the binary. This is also why string literals are immutable; `&str` is an "
"immutable reference."
msgstr "여기서 `s`의 타입은 `&str`입니다: 이는 바이너리의 특정 지점을 가리키는 슬라이스입니다. 이것이 문자열 리터럴이 불변인 이유이기도 합니다. `&str`은 불변 참조입니다."

#: src/ch04-03-slices.md:374
msgid "String Slices as Parameters"
msgstr "매개변수로서의 문자열 슬라이스"

#: src/ch04-03-slices.md:376
msgid ""
"Knowing that you can take slices of literals and `String` values leads us to "
"one more improvement on `first_word`, and that’s its signature:"
msgstr "리터럴과 `String` 값의 슬라이스를 가져올 수 있다는 것을 알면 `first_word`에 대한 한 가지 개선점으로 이어지며, 그것은 바로 시그니처입니다:"

#: src/ch04-03-slices.md:383
msgid ""
"A more experienced Rustacean would write the signature shown in Listing 4-9 "
"instead because it allows us to use the same function on both `&String` "
"values and `&str` values."
msgstr "더 숙련된 러스트 개발자는 목록 4-9에 표시된 시그니처를 대신 작성할 것입니다. 왜냐하면 `&String` 값과 `&str` 값 모두에 동일한 함수를 사용할 수 있기 때문입니다."

#: src/ch04-03-slices.md:405 src/ch04-03-slices.md:454
msgid ""
"// `first_word` works on slices of `String`s, whether partial or whole.\n"
msgstr ""

#: src/ch04-03-slices.md:408
msgid ""
"// `first_word` also works on references to `String`s, which are equivalent\n"
msgstr ""

#: src/ch04-03-slices.md:409
msgid "// to whole slices of `String`s.\n"
msgstr ""

#: src/ch04-03-slices.md:414
msgid ""
"// `first_word` works on slices of string literals, whether partial or\n"
msgstr ""

#: src/ch04-03-slices.md:415
msgid "// whole.\n"
msgstr ""

#: src/ch04-03-slices.md:419 src/ch10-03-lifetime-syntax.md:605
msgid "// Because string literals *are* string slices already,\n"
msgstr ""

#: src/ch04-03-slices.md:420 src/ch10-03-lifetime-syntax.md:606
msgid "// this works too, without the slice syntax!\n"
msgstr ""

#: src/ch04-03-slices.md:427
msgid ""
"If we have a string slice, we can pass that directly. If we have a `String`, "
"we can pass a slice of the `String` or a reference to the `String`. This "
"flexibility takes advantage of _deref coercions_, a feature we will cover in "
"the [“Implicit Deref Coercions with Functions and Methods”](ch15-02-"
"deref.html#implicit-deref-coercions-with-functions-and-methods)<!--ignore--> "
"section of Chapter 15."
msgstr ""

#: src/ch04-03-slices.md:433
msgid ""
"Defining a function to take a string slice instead of a reference to a "
"`String` makes our API more general and useful without losing any "
"functionality:"
msgstr ""

#: src/ch04-03-slices.md:457
msgid ""
"// `first_word` also works on references to `String`s, which are equivalent\n"
"    // to whole slices of `String`s.\n"
msgstr ""

#: src/ch04-03-slices.md:463
msgid ""
"// `first_word` works on slices of string literals, whether partial or\n"
"    // whole.\n"
msgstr ""

#: src/ch04-03-slices.md:468
msgid ""
"// Because string literals *are* string slices already,\n"
"    // this works too, without the slice syntax!\n"
msgstr ""

#: src/ch04-03-slices.md:476
msgid "Other Slices"
msgstr ""

#: src/ch04-03-slices.md:478
msgid ""
"String slices, as you might imagine, are specific to strings. But there’s a "
"more general slice type too. Consider this array:"
msgstr ""

#: src/ch04-03-slices.md:485
msgid ""
"Just as we might want to refer to part of a string, we might want to refer "
"to part of an array. We’d do so like this:"
msgstr ""

#: src/ch04-03-slices.md:496
msgid ""
"This slice has the type `&[i32]`. It works the same way as string slices do, "
"by storing a reference to the first element and a length. You’ll use this "
"kind of slice for all sorts of other collections. We’ll discuss these "
"collections in detail when we talk about vectors in Chapter 8."
msgstr ""

#: src/ch04-03-slices.md:503
msgid ""
"The concepts of ownership, borrowing, and slices ensure memory safety in "
"Rust programs at compile time. The Rust language gives you control over your "
"memory usage in the same way as other systems programming languages, but "
"having the owner of data automatically clean up that data when the owner "
"goes out of scope means you don’t have to write and debug extra code to get "
"this control."
msgstr ""

#: src/ch04-03-slices.md:509
msgid ""
"Ownership affects how lots of other parts of Rust work, so we’ll talk about "
"these concepts further throughout the rest of the book. Let’s move on to "
"Chapter 5 and look at grouping pieces of data together in a `struct`."
msgstr ""

#: src/ch05-00-structs.md:3
msgid ""
"A _struct_, or _structure_, is a custom data type that lets you package "
"together and name multiple related values that make up a meaningful group. "
"If you’re familiar with an object-oriented language, a _struct_ is like an "
"object’s data attributes. In this chapter, we’ll compare and contrast tuples "
"with structs to build on what you already know and demonstrate when structs "
"are a better way to group data."
msgstr ""

#: src/ch05-00-structs.md:10
msgid ""
"We’ll demonstrate how to define and instantiate structs. We’ll discuss how "
"to define associated functions, especially the kind of associated functions "
"called _methods_, to specify behavior associated with a struct type. Structs "
"and enums (discussed in Chapter 6) are the building blocks for creating new "
"types in your program’s domain to take full advantage of Rust’s compile-time "
"type checking."
msgstr ""

#: src/ch05-01-defining-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in [“The Tuple Type”](ch03-02-data-"
"types.html#the-tuple-type)<!--\n"
"ignore --> section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: you "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""

#: src/ch05-01-defining-structs.md:10
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call _fields_. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-structs.md:31
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _key: value_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type. For example, we can declare a particular user as shown "
"in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:54 src/ch05-01-defining-structs.md:82
#: src/ch05-01-defining-structs.md:124 src/ch05-01-defining-structs.md:169
#: src/ch05-01-defining-structs.md:207 src/ch05-01-defining-structs.md:242
#: src/ch05-01-defining-structs.md:374
msgid "\"someusername123\""
msgstr ""

#: src/ch05-01-defining-structs.md:55 src/ch05-01-defining-structs.md:83
#: src/ch05-01-defining-structs.md:123 src/ch05-01-defining-structs.md:168
#: src/ch05-01-defining-structs.md:206 src/ch05-01-defining-structs.md:241
#: src/ch05-01-defining-structs.md:375
msgid "\"someone@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:63
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-structs.md:87
msgid "\"anotheremail@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:93
msgid ""
"Note that the entire instance must be mutable; Rust doesn’t allow us to mark "
"only certain fields as mutable. As with any expression, we can construct a "
"new instance of the struct as the last expression in the function body to "
"implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-structs.md:98
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value of "
"`true`, and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-structs.md:131
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch05-01-defining-structs.md:138
msgid ""
"<a id=\"using-the-field-init-shorthand-when-variables-and-fields-have-the-"
"same-name\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:140
msgid "Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-structs.md:142
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the _field init shorthand_ syntax to rewrite "
"`build_user` so it behaves exactly the same but doesn’t have the repetition "
"of `username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-structs.md:176
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch05-01-defining-structs.md:182
msgid "Creating Instances from Other Instances with Struct Update Syntax"
msgstr ""

#: src/ch05-01-defining-structs.md:184
msgid ""
"It’s often useful to create a new instance of a struct that includes most of "
"the values from another instance, but changes some. You can do this using "
"_struct update syntax_."
msgstr ""

#: src/ch05-01-defining-structs.md:188
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2` "
"regularly, without the update syntax. We set a new value for `email` but "
"otherwise use the same values from `user1` that we created in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:215 src/ch05-01-defining-structs.md:248
msgid "\"another@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:223
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields "
"not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""

#: src/ch05-01-defining-structs.md:256
msgid ""
"The code in Listing 5-7 also creates an instance in `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields from `user1`. The `..user1` must come "
"last to specify that any remaining fields should get their values from the "
"corresponding fields in `user1`, but we can choose to specify values for as "
"many fields as we want in any order, regardless of the order of the fields "
"in the struct’s definition."
msgstr ""

#: src/ch05-01-defining-structs.md:264
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [“Variables and Data "
"Interacting with Move”](ch04-01-what-is-ownership.html#variables-and-data-"
"interacting-with-move)<!-- ignore --> section. In this example, we can no "
"longer use `user1` as a whole after creating `user2` because the `String` in "
"the `username` field of `user1` was moved into `user2`. If we had given "
"`user2` new `String` values for both `email` and `username`, and thus only "
"used the `active` and `sign_in_count` values from `user1`, then `user1` "
"would still be valid after creating `user2`. Both `active` and "
"`sign_in_count` are types that implement the `Copy` trait, so the behavior "
"we discussed in the [“Stack-Only Data: Copy”](ch04-01-what-is-"
"ownership.html#stack-only-data-copy)<!-- ignore --> section would apply. We "
"can still use `user1.email` in this example, since its value was _not_ moved "
"out."
msgstr ""

#: src/ch05-01-defining-structs.md:276
msgid "Using Tuple Structs Without Named Fields to Create Different Types"
msgstr ""

#: src/ch05-01-defining-structs.md:278
msgid ""
"Rust also supports structs that look similar to tuples, called _tuple "
"structs_. Tuple structs have the added meaning the struct name provides but "
"don’t have names associated with their fields; rather, they just have the "
"types of the fields. Tuple structs are useful when you want to give the "
"whole tuple a name and make the tuple a different type from other tuples, "
"and when naming each field as in a regular struct would be verbose or "
"redundant."
msgstr ""

#: src/ch05-01-defining-structs.md:285
msgid ""
"To define a tuple struct, start with the `struct` keyword and the struct "
"name followed by the types in the tuple. For example, here we define and use "
"two tuple structs named `Color` and `Point`:"
msgstr ""

#: src/ch05-01-defining-structs.md:303
msgid ""
"Note that the `black` and `origin` values are different types because "
"they’re instances of different tuple structs. Each struct you define is its "
"own type, even though the fields within the struct might have the same "
"types. For example, a function that takes a parameter of type `Color` cannot "
"take a `Point` as an argument, even though both types are made up of three "
"`i32` values. Otherwise, tuple struct instances are similar to tuples in "
"that you can destructure them into their individual pieces, and you can use "
"a `.` followed by the index to access an individual value. Unlike tuples, "
"tuple structs require you to name the type of the struct when you "
"destructure them. For example, we would write `let Point(x, y, z) = point`."
msgstr ""

#: src/ch05-01-defining-structs.md:314
msgid "Unit-Like Structs Without Any Fields"
msgstr ""

#: src/ch05-01-defining-structs.md:316
msgid ""
"You can also define structs that don’t have any fields! These are called "
"_unit-like structs_ because they behave similarly to `()`, the unit type "
"that we mentioned in [“The Tuple Type”](ch03-02-data-types.html#the-tuple-"
"type)<!-- ignore --> section. Unit-like structs can be useful when you need "
"to implement a trait on some type but don’t have any data that you want to "
"store in the type itself. We’ll discuss traits in Chapter 10. Here’s an "
"example of declaring and instantiating a unit struct named `AlwaysEqual`:"
msgstr ""

#: src/ch05-01-defining-structs.md:336
msgid ""
"To define `AlwaysEqual`, we use the `struct` keyword, the name we want, and "
"then a semicolon. No need for curly brackets or parentheses! Then we can get "
"an instance of `AlwaysEqual` in the `subject` variable in a similar way: "
"using the name we defined, without any curly brackets or parentheses. "
"Imagine that later we’ll implement behavior for this type such that every "
"instance of `AlwaysEqual` is always equal to every instance of any other "
"type, perhaps to have a known result for testing purposes. We wouldn’t need "
"any data to implement that behavior! You’ll see in Chapter 10 how to define "
"traits and implement them on any type, including unit-like structs."
msgstr ""

#: src/ch05-01-defining-structs.md:346
msgid "Ownership of Struct Data"
msgstr ""

#: src/ch05-01-defining-structs.md:348
msgid ""
"In the `User` struct definition in Listing 5-1, we used the owned `String` "
"type rather than the `&str` string slice type. This is a deliberate choice "
"because we want each instance of this struct to own all of its data and for "
"that data to be valid for as long as the entire struct is valid."
msgstr ""

#: src/ch05-01-defining-structs.md:353
msgid ""
"It’s also possible for structs to store references to data owned by "
"something else, but to do so requires the use of _lifetimes_, a Rust feature "
"that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced "
"by a struct is valid for as long as the struct is. Let’s say you try to "
"store a reference in a struct without specifying lifetimes, like the "
"following; this won’t work:"
msgstr ""

#: src/ch05-01-defining-structs.md:383
msgid "The compiler will complain that it needs lifetime specifiers:"
msgstr ""

#: src/ch05-01-defining-structs.md:385
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling structs v0.1.0 (file:///projects/structs)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:3:15\n"
"  |\n"
"3 |     username: &str,\n"
"  |               ^ expected named lifetime parameter\n"
"  |\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"1 ~ struct User<'a> {\n"
"2 |     active: bool,\n"
"3 ~     username: &'a str,\n"
"  |\n"
"\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:4:12\n"
"  |\n"
"4 |     email: &str,\n"
"  |            ^ expected named lifetime parameter\n"
"  |\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"1 ~ struct User<'a> {\n"
"2 |     active: bool,\n"
"3 |     username: &str,\n"
"4 ~     email: &'a str,\n"
"  |\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `structs` (bin \"structs\") due to 2 previous "
"errors\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:419
msgid ""
"In Chapter 10, we’ll discuss how to fix these errors so you can store "
"references in structs, but for now, we’ll fix errors like these using owned "
"types like `String` instead of references like `&str`."
msgstr ""

#: src/ch05-02-example-structs.md:3
msgid ""
"To understand when we might want to use structs, let’s write a program that "
"calculates the area of a rectangle. We’ll start by using single variables, "
"and then refactor the program until we’re using structs instead."
msgstr ""

#: src/ch05-02-example-structs.md:7
msgid ""
"Let’s make a new binary project with Cargo called _rectangles_ that will "
"take the width and height of a rectangle specified in pixels and calculate "
"the area of the rectangle. Listing 5-8 shows a short program with one way of "
"doing exactly that in our project’s _src/main.rs_."
msgstr ""

#: src/ch05-02-example-structs.md:20 src/ch05-02-example-structs.md:54
#: src/ch05-02-example-structs.md:82 src/ch05-02-example-structs.md:127
#: src/ch05-03-method-syntax.md:40
msgid "\"The area of the rectangle is {} square pixels.\""
msgstr ""

#: src/ch05-02-example-structs.md:32
msgid "Now, run this program using `cargo run`:"
msgstr ""

#: src/ch05-02-example-structs.md:34
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s\n"
"     Running `target/debug/rectangles`\n"
"The area of the rectangle is 1500 square pixels.\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:42
msgid ""
"This code succeeds in figuring out the area of the rectangle by calling the "
"`area` function with each dimension, but we can do more to make this code "
"clear and readable."
msgstr ""

#: src/ch05-02-example-structs.md:46
msgid "The issue with this code is evident in the signature of `area`:"
msgstr ""

#: src/ch05-02-example-structs.md:64
msgid ""
"The `area` function is supposed to calculate the area of one rectangle, but "
"the function we wrote has two parameters, and it’s not clear anywhere in our "
"program that the parameters are related. It would be more readable and more "
"manageable to group width and height together. We’ve already discussed one "
"way we might do that in [“The Tuple Type”](ch03-02-data-types.html#the-tuple-"
"type)<!-- ignore --> section of Chapter 3: by using tuples."
msgstr ""

#: src/ch05-02-example-structs.md:71
msgid "Refactoring with Tuples"
msgstr ""

#: src/ch05-02-example-structs.md:73
msgid "Listing 5-9 shows another version of our program that uses tuples."
msgstr ""

#: src/ch05-02-example-structs.md:94
msgid ""
"In one way, this program is better. Tuples let us add a bit of structure, "
"and we’re now passing just one argument. But in another way, this version is "
"less clear: tuples don’t name their elements, so we have to index into the "
"parts of the tuple, making our calculation less obvious."
msgstr ""

#: src/ch05-02-example-structs.md:99
msgid ""
"Mixing up the width and height wouldn’t matter for the area calculation, but "
"if we want to draw the rectangle on the screen, it would matter! We would "
"have to keep in mind that `width` is the tuple index `0` and `height` is the "
"tuple index `1`. This would be even harder for someone else to figure out "
"and keep in mind if they were to use our code. Because we haven’t conveyed "
"the meaning of our data in our code, it’s now easier to introduce errors."
msgstr ""

#: src/ch05-02-example-structs.md:106
msgid "Refactoring with Structs: Adding More Meaning"
msgstr ""

#: src/ch05-02-example-structs.md:108
msgid ""
"We use structs to add meaning by labeling the data. We can transform the "
"tuple we’re using into a struct with a name for the whole as well as names "
"for the parts, as shown in Listing 5-10."
msgstr ""

#: src/ch05-02-example-structs.md:139
msgid ""
"Here we’ve defined a struct and named it `Rectangle`. Inside the curly "
"brackets, we defined the fields as `width` and `height`, both of which have "
"type `u32`. Then, in `main`, we created a particular instance of `Rectangle` "
"that has a width of `30` and a height of `50`."
msgstr ""

#: src/ch05-02-example-structs.md:144
msgid ""
"Our `area` function is now defined with one parameter, which we’ve named "
"`rectangle`, whose type is an immutable borrow of a struct `Rectangle` "
"instance. As mentioned in Chapter 4, we want to borrow the struct rather "
"than take ownership of it. This way, `main` retains its ownership and can "
"continue using `rect1`, which is the reason we use the `&` in the function "
"signature and where we call the function."
msgstr ""

#: src/ch05-02-example-structs.md:151
msgid ""
"The `area` function accesses the `width` and `height` fields of the "
"`Rectangle` instance (note that accessing fields of a borrowed struct "
"instance does not move the field values, which is why you often see borrows "
"of structs). Our function signature for `area` now says exactly what we "
"mean: calculate the area of `Rectangle`, using its `width` and `height` "
"fields. This conveys that the width and height are related to each other, "
"and it gives descriptive names to the values rather than using the tuple "
"index values of `0` and `1`. This is a win for clarity."
msgstr ""

#: src/ch05-02-example-structs.md:160
msgid "Adding Useful Functionality with Derived Traits"
msgstr ""

#: src/ch05-02-example-structs.md:162
msgid ""
"It’d be useful to be able to print an instance of `Rectangle` while we’re "
"debugging our program and see the values for all its fields. Listing 5-11 "
"tries using the [`println!` macro](../std/macro.println.html)<!-- ignore --> "
"as we have used in previous chapters. This won’t work, however."
msgstr ""

#: src/ch05-02-example-structs.md:181
msgid "\"rect1 is {}\""
msgstr ""

#: src/ch05-02-example-structs.md:187
msgid "When we compile this code, we get an error with this core message:"
msgstr ""

#: src/ch05-02-example-structs.md:193
msgid ""
"The `println!` macro can do many kinds of formatting, and by default, the "
"curly brackets tell `println!` to use formatting known as `Display`: output "
"intended for direct end user consumption. The primitive types we’ve seen so "
"far implement `Display` by default because there’s only one way you’d want "
"to show a `1` or any other primitive type to a user. But with structs, the "
"way `println!` should format the output is less clear because there are more "
"display possibilities: Do you want commas or not? Do you want to print the "
"curly brackets? Should all the fields be shown? Due to this ambiguity, Rust "
"doesn’t try to guess what we want, and structs don’t have a provided "
"implementation of `Display` to use with `println!` and the `{}` placeholder."
msgstr ""

#: src/ch05-02-example-structs.md:204
msgid "If we continue reading the errors, we’ll find this helpful note:"
msgstr ""

#: src/ch05-02-example-structs.md:211
msgid ""
"Let’s try it! The `println!` macro call will now look like `println!(\"rect1 "
"is {rect1:?}\");`. Putting the specifier `:?` inside the curly brackets "
"tells `println!` we want to use an output format called `Debug`. The `Debug` "
"trait enables us to print our struct in a way that is useful for developers "
"so we can see its value while we’re debugging our code."
msgstr ""

#: src/ch05-02-example-structs.md:217
msgid "Compile the code with this change. Drat! We still get an error:"
msgstr ""

#: src/ch05-02-example-structs.md:223
msgid "But again, the compiler gives us a helpful note:"
msgstr ""

#: src/ch05-02-example-structs.md:230
msgid ""
"Rust _does_ include functionality to print out debugging information, but we "
"have to explicitly opt in to make that functionality available for our "
"struct. To do that, we add the outer attribute `#[derive(Debug)]` just "
"before the struct definition, as shown in Listing 5-12."
msgstr ""

#: src/ch05-02-example-structs.md:250
msgid "\"rect1 is {rect1:?}\""
msgstr ""

#: src/ch05-02-example-structs.md:256
msgid ""
"Now when we run the program, we won’t get any errors, and we’ll see the "
"following output:"
msgstr ""

#: src/ch05-02-example-structs.md:259
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/rectangles`\n"
"rect1 is Rectangle { width: 30, height: 50 }\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:267
msgid ""
"Nice! It’s not the prettiest output, but it shows the values of all the "
"fields for this instance, which would definitely help during debugging. When "
"we have larger structs, it’s useful to have output that’s a bit easier to "
"read; in those cases, we can use `{:#?}` instead of `{:?}` in the `println!` "
"string. In this example, using the `{:#?}` style will output the following:"
msgstr ""

#: src/ch05-02-example-structs.md:273
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/rectangles`\n"
"rect1 is Rectangle {\n"
"    width: 30,\n"
"    height: 50,\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:284
msgid ""
"Another way to print out a value using the `Debug` format is to use the "
"[`dbg!` macro](../std/macro.dbg.html)<!-- ignore -->, which takes ownership "
"of an expression (as opposed to `println!`, which takes a reference), prints "
"the file and line number of where that `dbg!` macro call occurs in your code "
"along with the resultant value of that expression, and returns ownership of "
"the value."
msgstr ""

#: src/ch05-02-example-structs.md:290
msgid ""
"Note: Calling the `dbg!` macro prints to the standard error console stream "
"(`stderr`), as opposed to `println!`, which prints to the standard output "
"console stream (`stdout`). We’ll talk more about `stderr` and `stdout` in "
"the [“Writing Error Messages to Standard Error Instead of Standard Output” "
"section in Chapter 12](ch12-06-writing-to-stderr-instead-of-stdout.html)<!-- "
"ignore -->."
msgstr ""

#: src/ch05-02-example-structs.md:296
msgid ""
"Here’s an example where we’re interested in the value that gets assigned to "
"the `width` field, as well as the value of the whole struct in `rect1`:"
msgstr ""

#: src/ch05-02-example-structs.md:317
msgid ""
"We can put `dbg!` around the expression `30 * scale` and, because `dbg!` "
"returns ownership of the expression’s value, the `width` field will get the "
"same value as if we didn’t have the `dbg!` call there. We don’t want `dbg!` "
"to take ownership of `rect1`, so we use a reference to `rect1` in the next "
"call. Here’s what the output of this example looks like:"
msgstr ""

#: src/ch05-02-example-structs.md:323
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running `target/debug/rectangles`\n"
"[src/main.rs:10:16] 30 * scale = 60\n"
"[src/main.rs:14:5] &rect1 = Rectangle {\n"
"    width: 60,\n"
"    height: 50,\n"
"}\n"
"```"
msgstr ""

#: src/ch05-02-example-structs.md:335
msgid ""
"We can see the first bit of output came from _src/main.rs_ line 10 where "
"we’re debugging the expression `30 * scale`, and its resultant value is `60` "
"(the `Debug` formatting implemented for integers is to print only their "
"value). The `dbg!` call on line 14 of _src/main.rs_ outputs the value of "
"`&rect1`, which is the `Rectangle` struct. This output uses the pretty "
"`Debug` formatting of the `Rectangle` type. The `dbg!` macro can be really "
"helpful when you’re trying to figure out what your code is doing!"
msgstr ""

#: src/ch05-02-example-structs.md:343
msgid ""
"In addition to the `Debug` trait, Rust has provided a number of traits for "
"us to use with the `derive` attribute that can add useful behavior to our "
"custom types. Those traits and their behaviors are listed in [Appendix C]"
"(appendix-03-derivable-traits.md)<!--\n"
"ignore -->. We’ll cover how to implement these traits with custom behavior "
"as well as how to create your own traits in Chapter 10. There are also many "
"attributes other than `derive`; for more information, see [the “Attributes” "
"section of the Rust Reference](../reference/attributes.html)."
msgstr ""

#: src/ch05-02-example-structs.md:351
msgid ""
"Our `area` function is very specific: it only computes the area of "
"rectangles. It would be helpful to tie this behavior more closely to our "
"`Rectangle` struct because it won’t work with any other type. Let’s look at "
"how we can continue to refactor this code by turning the `area` function "
"into an `area` _method_ defined on our `Rectangle` type."
msgstr ""

#: src/ch05-03-method-syntax.md:3
msgid ""
"_Methods_ are similar to functions: we declare them with the `fn` keyword "
"and a name, they can have parameters and a return value, and they contain "
"some code that’s run when the method is called from somewhere else. Unlike "
"functions, methods are defined within the context of a struct (or an enum or "
"a trait object, which we cover in [Chapter 6](ch06-00-enums.html)<!-- ignore "
"--> and [Chapter 17](ch18-02-trait-objects.md)<!-- ignore -->, "
"respectively), and their first parameter is always `self`, which represents "
"the instance of the struct the method is being called on."
msgstr ""

#: src/ch05-03-method-syntax.md:12
msgid "Defining Methods"
msgstr "메서드 정의하기"

#: src/ch05-03-method-syntax.md:14
msgid ""
"Let’s change the `area` function that has a `Rectangle` instance as a "
"parameter and instead make an `area` method defined on the `Rectangle` "
"struct, as shown in Listing 5-13."
msgstr ""

#: src/ch05-03-method-syntax.md:48
msgid "" "(implementation) block for `Rectangle`. Everything within this `impl` block " "will be associated with the `Rectangle` type. Then we move the `area` " "function within the `impl` curly brackets and change the first (and in this " "case, only) parameter to be `self` in the signature and everywhere within " "the body. In `main`, where we called the `area` function and passed `rect1` " "as an argument, we can instead use _method syntax_ to call the `area` method " "on our `Rectangle` instance. The method syntax goes after an instance: we " "add a dot followed by the method name, parentheses, and any arguments."msgstr `Rectangle`에 대한 (구현) 블록입니다. 이 `impl` 블록 내의 모든 것은 `Rectangle` 타입과 연관될 것입니다. 그런 다음 `area` 함수를 `impl` 중괄호 안으로 옮기고, 첫 번째 (이 경우 유일한) 매개변수를 시그니처와 본문 내 모든 곳에서 `self`로 변경합니다. `main`에서 `area` 함수를 호출하고 `rect1`을 인수로 전달했던 곳에서, 대신 _메서드 구문_을 사용하여 `Rectangle` 인스턴스에서 `area` 메서드를 호출할 수 있습니다. 메서드 구문은 인스턴스 뒤에 옵니다: 점과 메서드 이름, 괄호, 그리고 모든 인수를 추가합니다.

#: src/ch05-03-method-syntax.md:58
msgid ""
"In the signature for `area`, we use `&self` instead of `rectangle: "
"&Rectangle`. The `&self` is actually short for `self: &Self`. Within an "
"`impl` block, the type `Self` is an alias for the type that the `impl` block "
"is for. Methods must have a parameter named `self` of type `Self` for their "
"first parameter, so Rust lets you abbreviate this with only the name `self` "
"in the first parameter spot. Note that we still need to use the `&` in front "
"of the `self` shorthand to indicate that this method borrows the `Self` "
"instance, just as we did in `rectangle: &Rectangle`. Methods can take "
"ownership of `self`, borrow `self` immutably, as we’ve done here, or borrow "
"`self` mutably, just as they can any other parameter."
msgstr "`area`의 시그니처에서 `rectangle: &Rectangle` 대신 `&self`를 사용합니다. `&self`는 실제로는 `self: &Self`의 약어입니다. `impl` 블록 내에서 `Self` 타입은 `impl` 블록이 적용되는 타입의 별칭입니다. 메서드는 첫 번째 매개변수로 `Self` 타입의 `self`라는 매개변수를 가져야 하므로, 러스트는 첫 번째 매개변수 위치에 `self`라는 이름만으로 이를 축약할 수 있도록 합니다. 이 메서드가 `Self` 인스턴스를 빌려온다는 것을 나타내기 위해 `self` 약어 앞에 `&`를 여전히 사용해야 합니다. 이는 `rectangle: &Rectangle`에서 했던 것과 같습니다. 메서드는 `self`의 소유권을 가져가거나, 여기서처럼 `self`를 불변으로 빌려오거나, 다른 매개변수와 마찬가지로 `self`를 가변으로 빌려올 수 있습니다."

#: src/ch05-03-method-syntax.md:69
msgid ""
"We chose `&self` here for the same reason we used `&Rectangle` in the "
"function version: we don’t want to take ownership, and we just want to read "
"the data in the struct, not write to it. If we wanted to change the instance "
"that we’ve called the method on as part of what the method does, we’d use "
"`&mut self` as the first parameter. Having a method that takes ownership of "
"the instance by using just `self` as the first parameter is rare; this "
"technique is usually used when the method transforms `self` into something "
"else and you want to prevent the caller from using the original instance "
"after the transformation."
msgstr "여기서 `&self`를 선택한 이유는 함수 버전에서 `&Rectangle`을 사용한 것과 동일합니다: 우리는 소유권을 가져가고 싶지 않고, 구조체의 데이터를 읽기만 하고 쓰지 않으려 합니다. 메서드가 수행하는 작업의 일부로 메서드를 호출한 인스턴스를 변경하고 싶다면, 첫 번째 매개변수로 `&mut self`를 사용할 것입니다. 첫 번째 매개변수로 `self`만 사용하여 인스턴스의 소유권을 가져가는 메서드는 드뭅니다. 이 기술은 일반적으로 메서드가 `self`를 다른 것으로 변환하고 변환 후에 호출자가 원래 인스턴스를 사용하는 것을 방지하려는 경우에 사용됩니다."

#: src/ch05-03-method-syntax.md:78
msgid ""
"The main reason for using methods instead of functions, in addition to "
"providing method syntax and not having to repeat the type of `self` in every "
"method’s signature, is for organization. We’ve put all the things we can do "
"with an instance of a type in one `impl` block rather than making future "
"users of our code search for capabilities of `Rectangle` in various places "
"in the library we provide."
msgstr "메서드 구문을 제공하고 모든 메서드의 시그니처에서 `self`의 타입을 반복할 필요가 없다는 점 외에, 함수 대신 메서드를 사용하는 주된 이유는 조직화 때문입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 `impl` 블록에 넣어, 우리가 제공하는 라이브러리의 다양한 곳에서 `Rectangle`의 기능을 찾아야 하는 미래의 사용자들을 번거롭게 하지 않습니다."

#: src/ch05-03-method-syntax.md:85
msgid ""
"Note that we can choose to give a method the same name as one of the "
"struct’s fields. For example, we can define a method on `Rectangle` that is "
"also named `width`:"
msgstr "메서드에 구조체의 필드와 동일한 이름을 부여할 수 있다는 점에 유의하세요. 예를 들어, `Rectangle`에 `width`라는 이름의 메서드를 정의할 수 있습니다:"

#: src/ch05-03-method-syntax.md:111
msgid "\"The rectangle has a nonzero width; it is {}\""
msgstr "직사각형의 너비는 0이 아닙니다. 너비는 {}입니다"

#: src/ch05-03-method-syntax.md:118
msgid ""
"Here, we’re choosing to make the `width` method return `true` if the value "
"in the instance’s `width` field is greater than `0` and `false` if the value "
"is `0`: we can use a field within a method of the same name for any purpose. "
"In `main`, when we follow `rect1.width` with parentheses, Rust knows we mean "
"the method `width`. When we don’t use parentheses, Rust knows we mean the "
"field `width`."
msgstr "여기서 우리는 인스턴스의 `width` 필드 값이 `0`보다 크면 `width` 메서드가 `true`를 반환하고, 값이 `0`이면 `false`를 반환하도록 선택합니다. 즉, 동일한 이름의 메서드 내에서 필드를 어떤 목적으로든 사용할 수 있습니다. `main`에서 `rect1.width` 뒤에 괄호를 붙이면 러스트는 메서드 `width`를 의미한다는 것을 압니다. 괄호를 사용하지 않으면 러스트는 필드 `width`를 의미한다는 것을 압니다."

#: src/ch05-03-method-syntax.md:125
msgid ""
"Often, but not always, when we give a method the same name as a field we "
"want it to only return the value in the field and do nothing else. Methods "
"like this are called _getters_, and Rust does not implement them "
"automatically for struct fields as some other languages do. Getters are "
"useful because you can make the field private but the method public, and "
"thus enable read-only access to that field as part of the type’s public API. "
"We will discuss what public and private are and how to designate a field or "
"method as public or private in [Chapter 7](ch07-03-paths-for-referring-to-an-"
"item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword)<!-- ignore "
"-->."
msgstr "항상 그런 것은 아니지만, 메서드에 필드와 동일한 이름을 부여할 때, 필드의 값만 반환하고 다른 것은 아무것도 하지 않기를 원할 때가 많습니다. 이러한 메서드를 _게터_라고 하며, 러스트는 다른 일부 언어처럼 구조체 필드에 대해 자동으로 구현하지 않습니다. 게터는 필드를 비공개로 만들고 메서드를 공개로 만들어 타입의 공개 API의 일부로 해당 필드에 대한 읽기 전용 접근을 가능하게 하므로 유용합니다. 공개 및 비공개가 무엇인지, 그리고 필드나 메서드를 공개 또는 비공개로 지정하는 방법은 [7장](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword)<!-- ignore -->에서 논의할 것입니다."

#: src/ch05-03-method-syntax.md:134
msgid "Where’s the `->` Operator?"
msgstr "`->` 연산자는 어디에 있나요?"

#: src/ch05-03-method-syntax.md:136
msgid ""
"In C and C++, two different operators are used for calling methods: you use "
"`.` if you’re calling a method on the object directly and `->` if you’re "
"calling the method on a pointer to the object and need to dereference the "
"pointer first. In other words, if `object` is a pointer, `object-"
">something()` is similar to `(*object).something()`.
"
msgstr "C와 C++에서는 메서드를 호출하는 데 두 가지 다른 연산자가 사용됩니다. 객체에서 직접 메서드를 호출할 때는 `.`을 사용하고, 객체에 대한 포인터에서 메서드를 호출하고 먼저 포인터를 역참조해야 할 때는 `->`를 사용합니다. 다시 말해, `object`가 포인터인 경우 `object->something()`은 `(*object).something()`과 유사합니다."

#: src/ch05-03-method-syntax.md:142
msgid ""
"Rust doesn’t have an equivalent to the `->` operator; instead, Rust has a "
"feature called _automatic referencing and dereferencing_. Calling methods is "
"one of the few places in Rust with this behavior."
msgstr "러스트에는 `->` 연산자에 해당하는 것이 없습니다. 대신 러스트에는 _자동 참조 및 역참조_라는 기능이 있습니다. 메서드 호출은 러스트에서 이러한 동작을 보이는 몇 안 되는 곳 중 하나입니다."

#: src/ch05-03-method-syntax.md:146
msgid ""
"Here’s how it works: when you call a method with `object.something()`, Rust "
"automatically adds in `&`, `&mut`, or `*` so `object` matches the signature "
"of the method. In other words, the following are the same:"
msgstr "작동 방식은 다음과 같습니다: `object.something()`으로 메서드를 호출하면, 러스트는 `&`, `&mut`, 또는 `*`를 자동으로 추가하여 `object`가 메서드의 시그니처와 일치하도록 합니다. 즉, 다음은 동일합니다:"

#: src/ch05-03-method-syntax.md:173
msgid ""
"The first one looks much cleaner. This automatic referencing behavior works "
"because methods have a clear receiver—the type of `self`. Given the receiver "
"and name of a method, Rust can figure out definitively whether the method is "
"reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact "
"that Rust makes borrowing implicit for method receivers is a big part of "
"making ownership ergonomic in practice."
msgstr "첫 번째 것이 훨씬 깔끔해 보입니다. 이 자동 참조 동작은 메서드가 명확한 수신자(즉, `self`의 타입)를 가지고 있기 때문에 작동합니다. 수신자와 메서드 이름을 고려하여 러스트는 메서드가 읽기(`&self`), 변경(`&mut self`), 또는 소비(`self`) 중 무엇을 하는지 명확하게 파악할 수 있습니다. 러스트가 메서드 수신자에 대해 빌림을 암시적으로 만드는 사실은 소유권을 실제로 인체공학적으로 만드는 데 큰 부분을 차지합니다."

#: src/ch05-03-method-syntax.md:180
msgid "Methods with More Parameters"
msgstr "더 많은 매개변수를 가진 메서드"

#: src/ch05-03-method-syntax.md:182
msgid ""
"Let’s practice using methods by implementing a second method on the "
"`Rectangle` struct. This time we want an instance of `Rectangle` to take "
"another instance of `Rectangle` and return `true` if the second `Rectangle` "
"can fit completely within `self` (the first `Rectangle`); otherwise, it "
"should return `false`. That is, once we’ve defined the `can_hold` method, we "
"want to be able to write the program shown in Listing 5-14."
msgstr "`Rectangle` 구조체에 두 번째 메서드를 구현하여 메서드 사용을 연습해 봅시다. 이번에는 `Rectangle` 인스턴스가 다른 `Rectangle` 인스턴스를 받아, 두 번째 `Rectangle`이 `self` (첫 번째 `Rectangle`) 안에 완전히 들어갈 수 있으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환하도록 할 것입니다. 즉, `can_hold` 메서드를 정의한 후, 목록 5-14에 표시된 프로그램을 작성할 수 있기를 원합니다."

#: src/ch05-03-method-syntax.md:206 src/ch05-03-method-syntax.md:269
#: src/ch05-03-method-syntax.md:372
msgid "\"Can rect1 hold rect2? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:207 src/ch05-03-method-syntax.md:270
#: src/ch05-03-method-syntax.md:373
msgid "\"Can rect1 hold rect3? {}\""
msgstr ""

#: src/ch05-03-method-syntax.md:213
msgid ""
"The expected output would look like the following because both dimensions of "
"`rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider "
"than `rect1`:"
msgstr "예상되는 출력은 다음과 같을 것입니다. `rect2`의 두 치수 모두 `rect1`의 치수보다 작지만, `rect3`은 `rect1`보다 넓기 때문입니다:"

#: src/ch05-03-method-syntax.md:222
msgid ""
"We know we want to define a method, so it will be within the `impl "
"Rectangle` block. The method name will be `can_hold`, and it will take an "
"immutable borrow of another `Rectangle` as a parameter. We can tell what the "
"type of the parameter will be by looking at the code that calls the method: "
"`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to "
"`rect2`, an instance of `Rectangle`. This makes sense because we only need "
"to read `rect2` (rather than write, which would mean we’d need a mutable "
"borrow), and we want `main` to retain ownership of `rect2` so we can use it "
"again after calling the `can_hold` method. The return value of `can_hold` "
"will be a Boolean, and the implementation will check whether the width and "
"height of `self` are greater than the width and height of the other "
"`Rectangle`, respectively. Let’s add the new `can_hold` method to the `impl` "
"block from Listing 5-13, shown in Listing 5-15."
msgstr "우리는 메서드를 정의하고 싶으므로, `impl Rectangle` 블록 안에 있을 것입니다. 메서드 이름은 `can_hold`가 될 것이고, 다른 `Rectangle`의 불변 빌림을 매개변수로 받을 것입니다. 매개변수의 타입을 알기 위해서는 메서드를 호출하는 코드를 보면 됩니다: `rect1.can_hold(&rect2)`는 `&rect2`를 전달하는데, 이는 `Rectangle` 인스턴스인 `rect2`에 대한 불변 빌림입니다. 이는 `rect2`를 읽기만 하면 되기 때문에 (쓰려면 가변 빌림이 필요할 것입니다) 합리적이며, `main`이 `rect2`의 소유권을 유지하여 `can_hold` 메서드를 호출한 후에도 다시 사용할 수 있도록 하기 위함입니다. `can_hold`의 반환 값은 불리언이 될 것이고, 구현은 `self`의 너비와 높이가 다른 `Rectangle`의 너비와 높이보다 각각 큰지 확인할 것입니다. 목록 5-15에 표시된 목록 5-13의 `impl` 블록에 새 `can_hold` 메서드를 추가해 봅시다."

#: src/ch05-03-method-syntax.md:276
msgid ""
"When we run this code with the `main` function in Listing 5-14, we’ll get "
"our desired output. Methods can take multiple parameters that we add to the "
"signature after the `self` parameter, and those parameters work just like "
"parameters in functions."
msgstr "목록 5-14의 `main` 함수와 함께 이 코드를 실행하면, 우리가 원하는 출력을 얻을 것입니다. 메서드는 `self` 매개변수 뒤에 추가하는 여러 매개변수를 가질 수 있으며, 이 매개변수들은 함수에서의 매개변수와 동일하게 작동합니다."

#: src/ch05-03-method-syntax.md:281
msgid "Associated Functions"
msgstr "연관 함수"

#: src/ch05-03-method-syntax.md:283
msgid ""
"All functions defined within an `impl` block are called _associated "
"functions_ because they’re associated with the type named after the `impl`. "
"We can define associated functions that don’t have `self` as their first "
"parameter (and thus are not methods) because they don’t need an instance of "
"the type to work with. We’ve already used one function like this: the "
"`String::from` function that’s defined on the `String` type."
msgstr "`impl` 블록 내에 정의된 모든 함수는 _연관 함수_라고 불립니다. 왜냐하면 `impl` 뒤에 오는 타입과 연관되어 있기 때문입니다. 첫 번째 매개변수로 `self`를 가지지 않는 (따라서 메서드가 아닌) 연관 함수를 정의할 수 있습니다. 왜냐하면 이들은 작업할 타입의 인스턴스가 필요 없기 때문입니다. 우리는 이미 `String` 타입에 정의된 `String::from` 함수와 같은 함수를 사용했습니다."

#: src/ch05-03-method-syntax.md:290
msgid ""
"Associated functions that aren’t methods are often used for constructors "
"that will return a new instance of the struct. These are often called `new`, "
"but `new` isn’t a special name and isn’t built into the language. For "
"example, we could choose to provide an associated function named `square` "
"that would have one dimension parameter and use that as both width and "
"height, thus making it easier to create a square `Rectangle` rather than "
"having to specify the same value twice:"
msgstr "메서드가 아닌 연관 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자로 사용됩니다. 이들은 종종 `new`라고 불리지만, `new`는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 우리는 `square`라는 이름의 연관 함수를 제공하여 하나의 차원 매개변수를 가지고 그것을 너비와 높이로 모두 사용하여, 동일한 값을 두 번 지정할 필요 없이 정사각형 `Rectangle`을 더 쉽게 생성할 수 있습니다:"

#: src/ch05-03-method-syntax.md:321
msgid ""
"The `Self` keywords in the return type and in the body of the function are "
"aliases for the type that appears after the `impl` keyword, which in this "
"case is `Rectangle`."
msgstr "함수의 반환 타입과 본문에 있는 `Self` 키워드는 `impl` 키워드 뒤에 나타나는 타입의 별칭이며, 이 경우 `Rectangle`입니다."

#: src/ch05-03-method-syntax.md:325
msgid ""
"To call this associated function, we use the `::` syntax with the struct "
"name; `let sq = Rectangle::square(3);` is an example. This function is "
"namespaced by the struct: the `::` syntax is used for both associated "
"functions and namespaces created by modules. We’ll discuss modules in "
"[Chapter 7](ch07-02-defining-modules-to-control-scope-and-privacy.html)<!-- "
"ignore -->."
msgstr "이 연관 함수를 호출하려면 구조체 이름과 함께 `::` 구문을 사용합니다. `let sq = Rectangle::square(3);`가 그 예입니다. 이 함수는 구조체에 의해 네임스페이스가 지정됩니다. `::` 구문은 연관 함수와 모듈에 의해 생성된 네임스페이스 모두에 사용됩니다. [7장](ch07-02-defining-modules-to-control-scope-and-privacy.html)<!-- ignore -->에서 모듈에 대해 논의할 것입니다."

#: src/ch05-03-method-syntax.md:331
msgid "Multiple `impl` Blocks"
msgstr "여러 `impl` 블록"

#: src/ch05-03-method-syntax.md:333
msgid ""
"Each struct is allowed to have multiple `impl` blocks. For example, Listing "
"5-15 is equivalent to the code shown in Listing 5-16, which has each method "
"in its own `impl` block."
msgstr "각 구조체는 여러 `impl` 블록을 가질 수 있습니다. 예를 들어, 목록 5-15는 각 메서드가 자체 `impl` 블록에 있는 목록 5-16에 표시된 코드와 동일합니다."

#: src/ch05-03-method-syntax.md:379
msgid ""
"There’s no reason to separate these methods into multiple `impl` blocks "
"here, but this is valid syntax. We’ll see a case in which multiple `impl` "
"blocks are useful in Chapter 10, where we discuss generic types and traits."
msgstr "여기서 이 메서드들을 여러 `impl` 블록으로 분리할 이유는 없지만, 이것은 유효한 구문입니다. 여러 `impl` 블록이 유용한 경우는 10장에서 제네릭 타입과 트레이트를 논의할 때 볼 것입니다."

#: src/ch05-03-method-syntax.md:385
msgid ""
"Structs let you create custom types that are meaningful for your domain. By "
"using structs, you can keep associated pieces of data connected to each "
"other and name each piece to make your code clear. In `impl` blocks, you can "
"define functions that are associated with your type, and methods are a kind "
"of associated function that let you specify the behavior that instances of "
"your structs have."
msgstr "구조체를 사용하면 도메인에 의미 있는 사용자 정의 타입을 생성할 수 있습니다. 구조체를 사용함으로써 연관된 데이터 조각들을 서로 연결하고 각 조각에 이름을 부여하여 코드를 명확하게 만들 수 있습니다. `impl` 블록에서는 타입과 연관된 함수를 정의할 수 있으며, 메서드는 구조체 인스턴스가 가지는 동작을 지정할 수 있는 일종의 연관 함수입니다."

#: src/ch05-03-method-syntax.md:392
msgid ""
"But structs aren’t the only way you can create custom types: let’s turn to "
"Rust’s enum feature to add another tool to your toolbox."
msgstr "하지만 구조체만이 사용자 정의 타입을 생성하는 유일한 방법은 아닙니다. 러스트의 열거형 기능을 사용하여 도구 상자에 또 다른 도구를 추가해 봅시다."

#: src/ch06-00-enums.md:3
msgid ""
"In this chapter, we’ll look at _enumerations_, also referred to as _enums_. "
"Enums allow you to define a type by enumerating its possible _variants_. "
"First we’ll define and use an enum to show how an enum can encode meaning "
"along with data. Next, we’ll explore a particularly useful enum, called "
"`Option`, which expresses that a value can be either something or nothing. "
"Then we’ll look at how pattern matching in the `match` expression makes it "
"easy to run different code for different values of an enum. Finally, we’ll "
"cover how the `if let` construct is another convenient and concise idiom "
"available to handle enums in your code."
msgstr "이 장에서는 _열거형_이라고도 불리는 _enums_를 살펴볼 것입니다. 열거형은 가능한 _variant_를 열거하여 타입을 정의할 수 있도록 합니다. 먼저 열거형이 데이터와 함께 의미를 어떻게 인코딩할 수 있는지 보여주기 위해 열거형을 정의하고 사용할 것입니다. 다음으로, 값이 어떤 것이거나 아무것도 아닐 수 있음을 표현하는 특히 유용한 열거형인 `Option`을 탐구할 것입니다. 그런 다음 `match` 표현식의 패턴 매칭이 열거형의 다른 값에 대해 다른 코드를 실행하는 것을 얼마나 쉽게 만드는지 살펴볼 것입니다. 마지막으로, `if let` 구문이 코드에서 열거형을 처리하는 데 사용할 수 있는 또 다른 편리하고 간결한 관용구임을 다룰 것입니다."

#: src/ch06-01-defining-an-enum.md:3
msgid ""
"Where structs give you a way of grouping together related fields and data, "
"like a `Rectangle` with its `width` and `height`, enums give you a way of "
"saying a value is one of a possible set of values. For example, we may want "
"to say that `Rectangle` is one of a set of possible shapes that also "
"includes `Circle` and `Triangle`. To do this, Rust allows us to encode these "
"possibilities as an enum."
msgstr "구조체가 `width`와 `height`를 가진 `Rectangle`처럼 관련 필드와 데이터를 함께 그룹화하는 방법을 제공하는 반면, 열거형은 값이 가능한 값 집합 중 하나라고 말하는 방법을 제공합니다. 예를 들어, `Rectangle`이 `Circle`과 `Triangle`을 포함하는 가능한 도형 집합 중 하나라고 말하고 싶을 수 있습니다. 이를 위해 러스트는 이러한 가능성을 열거형으로 인코딩할 수 있도록 합니다."

#: src/ch06-01-defining-an-enum.md:9
msgid ""
"Let’s look at a situation we might want to express in code and see why enums "
"are useful and more appropriate than structs in this case. Say we need to "
"work with IP addresses. Currently, two major standards are used for IP "
"addresses: version four and version six. Because these are the only "
"possibilities for an IP address that our program will come across, we can "
"_enumerate_ all possible variants, which is where enumeration gets its name."
msgstr "코드에서 표현하고 싶은 상황을 살펴보고, 이 경우 열거형이 구조체보다 유용하고 더 적절한 이유를 알아보겠습니다. IP 주소로 작업해야 한다고 가정해 봅시다. 현재 IP 주소에는 두 가지 주요 표준인 버전 4와 버전 6이 사용됩니다. 이들이 우리 프로그램이 접하게 될 IP 주소의 유일한 가능성이므로, 모든 가능한 variant를 _열거_할 수 있으며, 여기서 열거형이라는 이름이 유래합니다."

#: src/ch06-01-defining-an-enum.md:16
msgid ""
"Any IP address can be either a version four or a version six address, but "
"not both at the same time. That property of IP addresses makes the enum data "
"structure appropriate because an enum value can only be one of its variants. "
"Both version four and version six addresses are still fundamentally IP "
"addresses, so they should be treated as the same type when the code is "
"handling situations that apply to any kind of IP address."
msgstr "어떤 IP 주소든 버전 4 또는 버전 6 주소일 수 있지만, 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 열거형 데이터 구조를 적절하게 만듭니다. 왜냐하면 열거형 값은 오직 하나의 variant만 가질 수 있기 때문입니다. 버전 4와 버전 6 주소 모두 여전히 근본적으로 IP 주소이므로, 어떤 종류의 IP 주소에도 적용되는 상황을 코드가 처리할 때 동일한 타입으로 취급되어야 합니다."

#: src/ch06-01-defining-an-enum.md:23
msgid ""
"We can express this concept in code by defining an `IpAddrKind` enumeration "
"and listing the possible kinds an IP address can be, `V4` and `V6`. These "
"are the variants of the enum:"
msgstr "우리는 `IpAddrKind` 열거형을 정의하고 IP 주소가 될 수 있는 가능한 종류인 `V4`와 `V6`를 나열함으로써 이 개념을 코드로 표현할 수 있습니다. 이것들이 열거형의 variant입니다:"

#: src/ch06-01-defining-an-enum.md:44
msgid ""
"`IpAddrKind` is now a custom data type that we can use elsewhere in our code."
msgstr ""
"`IpAddrKind`는 이제 코드의 다른 곳에서 사용할 수 있는 사용자 정의 데이터 타입입니다."

#: src/ch06-01-defining-an-enum.md:46
msgid "Enum Values"
msgstr "열거형 값"

#: src/ch06-01-defining-an-enum.md:48
msgid ""
"We can create instances of each of the two variants of `IpAddrKind` like "
"this:"
msgstr "`IpAddrKind`의 두 가지 variant 각각의 인스턴스를 다음과 같이 생성할 수 있습니다:"

#: src/ch06-01-defining-an-enum.md:67
msgid ""
"Note that the variants of the enum are namespaced under its identifier, and "
"we use a double colon to separate the two. This is useful because now both "
"values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: "
"`IpAddrKind`. We can then, for instance, define a function that takes any "
"`IpAddrKind`:"
msgstr "열거형의 variant는 해당 식별자 아래에 네임스페이스가 지정되며, 두 개를 구분하기 위해 이중 콜론을 사용한다는 점에 유의하세요. 이는 이제 `IpAddrKind::V4`와 `IpAddrKind::V6` 두 값 모두 `IpAddrKind`라는 동일한 타입이기 때문에 유용합니다. 예를 들어, 어떤 `IpAddrKind`든 받아들이는 함수를 정의할 수 있습니다:"

#: src/ch06-01-defining-an-enum.md:89
msgid "And we can call this function with either variant:"
msgstr "그리고 우리는 이 함수를 두 variant 중 하나로 호출할 수 있습니다:"

#: src/ch06-01-defining-an-enum.md:108
msgid ""
"Using enums has even more advantages. Thinking more about our IP address "
"type, at the moment we don’t have a way to store the actual IP address "
"_data_; we only know what _kind_ it is. Given that you just learned about "
"structs in Chapter 5, you might be tempted to tackle this problem with "
"structs as shown in Listing 6-1."
msgstr "열거형을 사용하는 것은 더 많은 장점을 가집니다. IP 주소 타입에 대해 더 생각해 보면, 현재 우리는 실제 IP 주소 _데이터_를 저장할 방법이 없습니다. 우리는 단지 그것이 어떤 _종류_인지 알고 있을 뿐입니다. 5장에서 구조체에 대해 방금 배웠다는 점을 고려하면, 목록 6-1에 표시된 것처럼 구조체로 이 문제를 해결하고 싶을 수도 있습니다."

#: src/ch06-01-defining-an-enum.md:130 src/ch06-01-defining-an-enum.md:163
#: src/ch09-03-to-panic-or-not-to-panic.md:53
msgid "\"127.0.0.1\""
msgstr ""

#: src/ch06-01-defining-an-enum.md:135 src/ch06-01-defining-an-enum.md:165
#: src/ch06-01-defining-an-enum.md:193
msgid "\"::1\""
msgstr ""

#: src/ch06-01-defining-an-enum.md:142
msgid ""
"Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field "
"that is of type `IpAddrKind` (the enum we defined previously) and an "
"`address` field of type `String`. We have two instances of this struct. The "
"first is `home`, and it has the value `IpAddrKind::V4` as its `kind` with "
"associated address data of `127.0.0.1`. The second instance is `loopback`. "
"It has the other variant of `IpAddrKind` as its `kind` value, `V6`, and has "
"address `::1` associated with it. We’ve used a struct to bundle the `kind` "
"and `address` values together, so now the variant is associated with the "
"value."
msgstr "여기서 우리는 `IpAddr` 구조체를 정의했습니다. 이 구조체는 두 개의 필드를 가집니다: `IpAddrKind` 타입의 `kind` 필드(이전에 정의한 열거형)와 `String` 타입의 `address` 필드입니다. 이 구조체의 두 인스턴스가 있습니다. 첫 번째는 `home`이며, `IpAddrKind::V4` 값을 `kind`로 가지고 `127.0.0.1` 주소 데이터를 연관시킵니다. 두 번째 인스턴스는 `loopback`입니다. 이것은 `IpAddrKind`의 다른 variant인 `V6`를 `kind` 값으로 가지고 `::1` 주소를 연관시킵니다. 우리는 `kind`와 `address` 값을 함께 묶기 위해 구조체를 사용했으며, 이제 variant는 값과 연관됩니다."

#: src/ch06-01-defining-an-enum.md:151
msgid ""
"However, representing the same concept using just an enum is more concise: "
"rather than an enum inside a struct, we can put data directly into each enum "
"variant. This new definition of the `IpAddr` enum says that both `V4` and "
"`V6` variants will have associated `String` values:"
msgstr "그러나 동일한 개념을 열거형만 사용하여 표현하는 것이 더 간결합니다. 구조체 안에 열거형을 넣는 대신, 각 열거형 variant에 직접 데이터를 넣을 수 있습니다. `IpAddr` 열거형의 이 새로운 정의는 `V4`와 `V6` variant 모두 연관된 `String` 값을 가질 것이라고 말합니다:"

#: src/ch06-01-defining-an-enum.md:169
msgid ""
"We attach data to each variant of the enum directly, so there is no need for "
"an extra struct. Here, it’s also easier to see another detail of how enums "
"work: the name of each enum variant that we define also becomes a function "
"that constructs an instance of the enum. That is, `IpAddr::V4()` is a "
"function call that takes a `String` argument and returns an instance of the "
"`IpAddr` type. We automatically get this constructor function defined as a "
"result of defining the enum."
msgstr "열거형의 각 variant에 직접 데이터를 첨부하므로, 추가 구조체가 필요 없습니다. 여기서 열거형이 작동하는 또 다른 세부 사항을 더 쉽게 볼 수 있습니다: 우리가 정의하는 각 열거형 variant의 이름은 열거형의 인스턴스를 구성하는 함수도 됩니다. 즉, `IpAddr::V4()`는 `String` 인수를 받아 `IpAddr` 타입의 인스턴스를 반환하는 함수 호출입니다. 열거형을 정의한 결과로 이 생성자 함수가 자동으로 정의됩니다."

#: src/ch06-01-defining-an-enum.md:177
msgid ""
"There’s another advantage to using an enum rather than a struct: each "
"variant can have different types and amounts of associated data. Version "
"four IP addresses will always have four numeric components that will have "
"values between 0 and 255. If we wanted to store `V4` addresses as four `u8` "
"values but still express `V6` addresses as one `String` value, we wouldn’t "
"be able to with a struct. Enums handle this case with ease:"
msgstr "구조체 대신 열거형을 사용하는 또 다른 장점은 각 variant가 다른 타입과 양의 연관 데이터를 가질 수 있다는 것입니다. 버전 4 IP 주소는 항상 0에서 255 사이의 값을 가지는 네 개의 숫자 구성 요소를 가질 것입니다. 만약 `V4` 주소를 네 개의 `u8` 값으로 저장하면서도 `V6` 주소를 하나의 `String` 값으로 표현하고 싶다면, 구조체로는 그렇게 할 수 없을 것입니다. 열거형은 이 경우를 쉽게 처리합니다:"

#: src/ch06-01-defining-an-enum.md:197
msgid ""
"We’ve shown several different ways to define data structures to store "
"version four and version six IP addresses. However, as it turns out, wanting "
"to store IP addresses and encode which kind they are is so common that [the "
"standard library has a definition we can use!](../std/net/"
"enum.IpAddr.html)<!-- ignore --> Let’s look at how the standard library "
"defines `IpAddr`: it has the exact enum and variants that we’ve defined and "
"used, but it embeds the address data inside the variants in the form of two "
"different structs, which are defined differently for each variant:"
msgstr "버전 4와 버전 6 IP 주소를 저장하기 위한 여러 가지 데이터 구조 정의 방법을 보여드렸습니다. 그러나 IP 주소를 저장하고 그 종류를 인코딩하는 것이 매우 흔한 일이라서 [표준 라이브러리에 우리가 사용할 수 있는 정의가 있습니다!](../std/net/enum.IpAddr.html)<!-- ignore --> 표준 라이브러리가 `IpAddr`를 어떻게 정의하는지 살펴보겠습니다. 우리가 정의하고 사용한 것과 정확히 동일한 열거형과 variant를 가지고 있지만, 각 variant에 대해 다르게 정의된 두 가지 다른 구조체 형태로 주소 데이터를 variant 내부에 포함합니다:"

#: src/ch06-01-defining-an-enum.md:221
msgid ""
"This code illustrates that you can put any kind of data inside an enum "
"variant: strings, numeric types, or structs, for example. You can even "
"include another enum! Also, standard library types are often not much more "
"complicated than what you might come up with."
msgstr "이 코드는 열거형 variant 안에 문자열, 숫자 타입, 또는 구조체와 같은 어떤 종류의 데이터도 넣을 수 있음을 보여줍니다. 심지어 다른 열거형을 포함할 수도 있습니다! 또한, 표준 라이브러리 타입은 종종 당신이 생각해낼 수 있는 것보다 훨씬 복잡하지 않습니다."

#: src/ch06-01-defining-an-enum.md:226
msgid ""
"Note that even though the standard library contains a definition for "
"`IpAddr`, we can still create and use our own definition without conflict "
"because we haven’t brought the standard library’s definition into our scope. "
"We’ll talk more about bringing types into scope in Chapter 7."
msgstr "표준 라이브러리에 `IpAddr`에 대한 정의가 포함되어 있더라도, 표준 라이브러리의 정의를 우리 스코프로 가져오지 않았기 때문에 충돌 없이 우리만의 정의를 생성하고 사용할 수 있다는 점에 유의하세요. 7장에서 타입을 스코프로 가져오는 것에 대해 더 자세히 이야기할 것입니다."

#: src/ch06-01-defining-an-enum.md:231
msgid ""
"Let’s look at another example of an enum in Listing 6-2: this one has a wide "
"variety of types embedded in its variants."
msgstr "목록 6-2에 있는 열거형의 또 다른 예를 살펴보겠습니다. 이 열거형은 variant에 다양한 타입이 내장되어 있습니다."

#: src/ch06-01-defining-an-enum.md:249
msgid "This enum has four variants with different types:"
msgstr "이 열거형은 네 가지 다른 타입을 가진 variant를 가집니다:"

#: src/ch06-01-defining-an-enum.md:251
msgid "`Quit` has no data associated with it at all."
msgstr "`Quit`은 연관된 데이터가 전혀 없습니다."

#: src/ch06-01-defining-an-enum.md:252
msgid "`Move` has named fields, like a struct does."
msgstr "`Move`는 구조체처럼 이름 있는 필드를 가집니다."

#: src/ch06-01-defining-an-enum.md:253
msgid "`Write` includes a single `String`."
msgstr "`Write`는 단일 `String`을 포함합니다."

#: src/ch06-01-defining-an-enum.md:254
msgid "`ChangeColor` includes three `i32` values."
msgstr "`ChangeColor`는 세 개의 `i32` 값을 포함합니다."

#: src/ch06-01-defining-an-enum.md:256
msgid ""
"Defining an enum with variants such as the ones in Listing 6-2 is similar to "
"defining different kinds of struct definitions, except the enum doesn’t use "
"the `struct` keyword and all the variants are grouped together under the "
"`Message` type. The following structs could hold the same data that the "
"preceding enum variants hold:"
msgstr "목록 6-2와 같은 variant를 가진 열거형을 정의하는 것은 다른 종류의 구조체 정의와 유사합니다. 단, 열거형은 `struct` 키워드를 사용하지 않고 모든 variant가 `Message` 타입 아래에 함께 그룹화된다는 점이 다릅니다. 다음 구조체들은 이전 열거형 variant들이 가지고 있는 동일한 데이터를 가질 수 있습니다:"

#: src/ch06-01-defining-an-enum.md:263
msgid "// unit struct\n"
msgstr "// 유닛 구조체\n"

#: src/ch06-01-defining-an-enum.md:268 src/ch06-01-defining-an-enum.md:269
msgid "// tuple struct\n"
msgstr "// 튜플 구조체\n"

#: src/ch06-01-defining-an-enum.md:274
msgid ""
"But if we used the different structs, each of which has its own type, we "
"couldn’t as easily define a function to take any of these kinds of messages "
"as we could with the `Message` enum defined in Listing 6-2, which is a "
"single type."
msgstr "하지만 각각 고유한 타입을 가진 다른 구조체를 사용한다면, 목록 6-2에 정의된 `Message` 열거형처럼 단일 타입인 경우만큼 쉽게 이러한 종류의 메시지를 받는 함수를 정의할 수 없을 것입니다."

#: src/ch06-01-defining-an-enum.md:278
msgid ""
"There is one more similarity between enums and structs: just as we’re able "
"to define methods on structs using `impl`, we’re also able to define methods "
"on enums. Here’s a method named `call` that we could define on our `Message` "
"enum:"
msgstr "열거형과 구조체 사이에는 한 가지 더 유사점이 있습니다. `impl`을 사용하여 구조체에 메서드를 정의할 수 있는 것처럼, 열거형에도 메서드를 정의할 수 있습니다. 다음은 `Message` 열거형에 정의할 수 있는 `call`이라는 메서드입니다:"

#: src/ch06-01-defining-an-enum.md:293
msgid "// method body would be defined here\n"
msgstr "// 메서드 본문은 여기에 정의됩니다\n"

#: src/ch06-01-defining-an-enum.md:302
msgid ""
"The body of the method would use `self` to get the value that we called the "
"method on. In this example, we’ve created a variable `m` that has the value "
"`Message::Write(String::from(\"hello\"))`, and that is what `self` will be "
"in the body of the `call` method when `m.call()` runs."
msgstr ""

#: src/ch06-01-defining-an-enum.md:307
msgid ""
"Let’s look at another enum in the standard library that is very common and "
"useful: `Option`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:310
msgid "The `Option` Enum and Its Advantages Over Null Values"
msgstr "`Option` 열거형과 Null 값에 대한 이점"

#: src/ch06-01-defining-an-enum.md:312
msgid ""
"This section explores a case study of `Option`, which is another enum "
"defined by the standard library. The `Option` type encodes the very common "
"scenario in which a value could be something or it could be nothing."
msgstr ""

#: src/ch06-01-defining-an-enum.md:316
msgid ""
"For example, if you request the first item in a non-empty list, you would "
"get a value. If you request the first item in an empty list, you would get "
"nothing. Expressing this concept in terms of the type system means the "
"compiler can check whether you’ve handled all the cases you should be "
"handling; this functionality can prevent bugs that are extremely common in "
"other programming languages."
msgstr ""

#: src/ch06-01-defining-an-enum.md:323
msgid ""
"Programming language design is often thought of in terms of which features "
"you include, but the features you exclude are important too. Rust doesn’t "
"have the null feature that many other languages have. _Null_ is a value that "
"means there is no value there. In languages with null, variables can always "
"be in one of two states: null or not-null."
msgstr ""

#: src/ch06-01-defining-an-enum.md:329
msgid ""
"In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony "
"Hoare, the inventor of null, has this to say:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:332
msgid ""
"I call it my billion-dollar mistake. At that time, I was designing the first "
"comprehensive type system for references in an object-oriented language. My "
"goal was to ensure that all use of references should be absolutely safe, "
"with checking performed automatically by the compiler. But I couldn’t resist "
"the temptation to put in a null reference, simply because it was so easy to "
"implement. This has led to innumerable errors, vulnerabilities, and system "
"crashes, which have probably caused a billion dollars of pain and damage in "
"the last forty years."
msgstr ""

#: src/ch06-01-defining-an-enum.md:341
msgid ""
"The problem with null values is that if you try to use a null value as a not-"
"null value, you’ll get an error of some kind. Because this null or not-null "
"property is pervasive, it’s extremely easy to make this kind of error."
msgstr ""

#: src/ch06-01-defining-an-enum.md:345
msgid ""
"However, the concept that null is trying to express is still a useful one: a "
"null is a value that is currently invalid or absent for some reason."
msgstr ""

#: src/ch06-01-defining-an-enum.md:348
msgid ""
"The problem isn’t really with the concept but with the particular "
"implementation. As such, Rust does not have nulls, but it does have an enum "
"that can encode the concept of a value being present or absent. This enum is "
"`Option<T>`, and it is [defined by the standard library](../std/option/"
"enum.Option.html)<!-- ignore --> as follows:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:361
msgid ""
"The `Option<T>` enum is so useful that it’s even included in the prelude; "
"you don’t need to bring it into scope explicitly. Its variants are also "
"included in the prelude: you can use `Some` and `None` directly without the "
"`Option::` prefix. The `Option<T>` enum is still just a regular enum, and "
"`Some(T)` and `None` are still variants of type `Option<T>`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:367
msgid ""
"The `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a "
"generic type parameter, and we’ll cover generics in more detail in Chapter "
"10. For now, all you need to know is that `<T>` means that the `Some` "
"variant of the `Option` enum can hold one piece of data of any type, and "
"that each concrete type that gets used in place of `T` makes the overall "
"`Option<T>` type a different type. Here are some examples of using `Option` "
"values to hold number types and char types:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:378
msgid "'e'"
msgstr ""

#: src/ch06-01-defining-an-enum.md:384
msgid ""
"The type of `some_number` is `Option<i32>`. The type of `some_char` is "
"`Option<char>`, which is a different type. Rust can infer these types "
"because we’ve specified a value inside the `Some` variant. For "
"`absent_number`, Rust requires us to annotate the overall `Option` type: the "
"compiler can’t infer the type that the corresponding `Some` variant will "
"hold by looking only at a `None` value. Here, we tell Rust that we mean for "
"`absent_number` to be of type `Option<i32>`."
msgstr ""

#: src/ch06-01-defining-an-enum.md:392
msgid ""
"When we have a `Some` value, we know that a value is present and the value "
"is held within the `Some`. When we have a `None` value, in some sense it "
"means the same thing as null: we don’t have a valid value. So why is having "
"`Option<T>` any better than having null?"
msgstr ""

#: src/ch06-01-defining-an-enum.md:397
msgid ""
"In short, because `Option<T>` and `T` (where `T` can be any type) are "
"different types, the compiler won’t let us use an `Option<T>` value as if it "
"were definitely a valid value. For example, this code won’t compile, because "
"it’s trying to add an `i8` to an `Option<i8>`:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:411
msgid "If we run this code, we get an error message like this one:"
msgstr ""

#: src/ch06-01-defining-an-enum.md:413
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling enums v0.1.0 (file:///projects/enums)\n"
"error[E0277]: cannot add `Option<i8>` to `i8`\n"
" --> src/main.rs:5:17\n"
"  |\n"
"5 |     let sum = x + y;\n"
"  |                 ^ no implementation for `i8 + Option<i8>`\n"
"  |\n"
"  = help: the trait `Add<Option<i8>>` is not implemented for `i8`\n"
"  = help: the following other types implement trait `Add<Rhs>`:\n"
"            `&'a i8` implements `Add<i8>`\n"
"            `&i8` implements `Add<&i8>`\n"
"            `i8` implements `Add<&i8>`\n"
"            `i8` implements `Add`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `enums` (bin \"enums\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch06-01-defining-an-enum.md:433
msgid ""
"Intense! In effect, this error message means that Rust doesn’t understand "
"how to add an `i8` and an `Option<i8>`, because they’re different types. "
"When we have a value of a type like `i8` in Rust, the compiler will ensure "
"that we always have a valid value. We can proceed confidently without having "
"to check for null before using that value. Only when we have an `Option<i8>` "
"(or whatever type of value we’re working with) do we have to worry about "
"possibly not having a value, and the compiler will make sure we handle that "
"case before using the value."
msgstr ""

#: src/ch06-01-defining-an-enum.md:442
msgid ""
"In other words, you have to convert an `Option<T>` to a `T` before you can "
"perform `T` operations with it. Generally, this helps catch one of the most "
"common issues with null: assuming that something isn’t null when it actually "
"is."
msgstr ""

#: src/ch06-01-defining-an-enum.md:446
msgid ""
"Eliminating the risk of incorrectly assuming a not-null value helps you to "
"be more confident in your code. In order to have a value that can possibly "
"be null, you must explicitly opt in by making the type of that value "
"`Option<T>`. Then, when you use that value, you are required to explicitly "
"handle the case when the value is null. Everywhere that a value has a type "
"that isn’t an `Option<T>`, you _can_ safely assume that the value isn’t "
"null. This was a deliberate design decision for Rust to limit null’s "
"pervasiveness and increase the safety of Rust code."
msgstr ""

#: src/ch06-01-defining-an-enum.md:455
msgid ""
"So how do you get the `T` value out of a `Some` variant when you have a "
"value of type `Option<T>` so that you can use that value? The `Option<T>` "
"enum has a large number of methods that are useful in a variety of "
"situations; you can check them out in [its documentation](../std/option/"
"enum.Option.html)<!-- ignore -->. Becoming familiar with the methods on "
"`Option<T>` will be extremely useful in your journey with Rust."
msgstr ""

#: src/ch06-01-defining-an-enum.md:462
msgid ""
"In general, in order to use an `Option<T>` value, you want to have code that "
"will handle each variant. You want some code that will run only when you "
"have a `Some(T)` value, and this code is allowed to use the inner `T`. You "
"want some other code to run only if you have a `None` value, and that code "
"doesn’t have a `T` value available. The `match` expression is a control flow "
"construct that does just this when used with enums: it will run different "
"code depending on which variant of the enum it has, and that code can use "
"the data inside the matching value."
msgstr ""

#: src/ch06-02-match.md:3
msgid "<a id=\"the-match-control-flow-operator\"></a>"
msgstr ""

#: src/ch06-02-match.md:7
msgid ""
"Rust has an extremely powerful control flow construct called `match` that "
"allows you to compare a value against a series of patterns and then execute "
"code based on which pattern matches. Patterns can be made up of literal "
"values, variable names, wildcards, and many other things; [Chapter 19]"
"(ch19-00-patterns.html)<!-- ignore --> covers all the different kinds of "
"patterns and what they do. The power of `match` comes from the "
"expressiveness of the patterns and the fact that the compiler confirms that "
"all possible cases are handled."
msgstr ""

#: src/ch06-02-match.md:16
msgid ""
"Think of a `match` expression as being like a coin-sorting machine: coins "
"slide down a track with variously sized holes along it, and each coin falls "
"through the first hole it encounters that it fits into. In the same way, "
"values go through each pattern in a `match`, and at the first pattern the "
"value “fits,” the value falls into the associated code block to be used "
"during execution."
msgstr ""

#: src/ch06-02-match.md:22
msgid ""
"Speaking of coins, let’s use them as an example using `match`! We can write "
"a function that takes an unknown US coin and, in a similar way as the "
"counting machine, determines which coin it is and returns its value in "
"cents, as shown in Listing 6-3."
msgstr ""

#: src/ch06-02-match.md:51
msgid ""
"Let’s break down the `match` in the `value_in_cents` function. First we list "
"the `match` keyword followed by an expression, which in this case is the "
"value `coin`. This seems very similar to a conditional expression used with "
"`if`, but there’s a big difference: with `if`, the condition needs to "
"evaluate to a Boolean value, but here it can be any type. The type of `coin` "
"in this example is the `Coin` enum that we defined on the first line."
msgstr ""

#: src/ch06-02-match.md:58
msgid ""
"Next are the `match` arms. An arm has two parts: a pattern and some code. "
"The first arm here has a pattern that is the value `Coin::Penny` and then "
"the `=>` operator that separates the pattern and the code to run. The code "
"in this case is just the value `1`. Each arm is separated from the next with "
"a comma."
msgstr ""

#: src/ch06-02-match.md:63
msgid ""
"When the `match` expression executes, it compares the resultant value "
"against the pattern of each arm, in order. If a pattern matches the value, "
"the code associated with that pattern is executed. If that pattern doesn’t "
"match the value, execution continues to the next arm, much as in a coin-"
"sorting machine. We can have as many arms as we need: in Listing 6-3, our "
"`match` has four arms."
msgstr ""

#: src/ch06-02-match.md:69
msgid ""
"The code associated with each arm is an expression, and the resultant value "
"of the expression in the matching arm is the value that gets returned for "
"the entire `match` expression."
msgstr ""

#: src/ch06-02-match.md:73
msgid ""
"We don’t typically use curly brackets if the match arm code is short, as it "
"is in Listing 6-3 where each arm just returns a value. If you want to run "
"multiple lines of code in a match arm, you must use curly brackets, and the "
"comma following the arm is then optional. For example, the following code "
"prints “Lucky penny!” every time the method is called with a `Coin::Penny`, "
"but still returns the last value of the block, `1`:"
msgstr ""

#: src/ch06-02-match.md:91
msgid "\"Lucky penny!\""
msgstr "\"운 좋은 페니!\""

#: src/ch06-02-match.md:103
msgid "Patterns That Bind to Values"
msgstr "값에 바인딩하는 패턴"

#: src/ch06-02-match.md:105
msgid ""
"Another useful feature of match arms is that they can bind to the parts of "
"the values that match the pattern. This is how we can extract values out of "
"enum variants."
msgstr ""

#: src/ch06-02-match.md:109
msgid ""
"As an example, let’s change one of our enum variants to hold data inside it. "
"From 1999 through 2008, the United States minted quarters with different "
"designs for each of the 50 states on one side. No other coins got state "
"designs, so only quarters have this extra value. We can add this information "
"to our `enum` by changing the `Quarter` variant to include a `UsState` value "
"stored inside it, which we’ve done in Listing 6-4."
msgstr ""

#: src/ch06-01-defining-an-enum.md:119 src/ch06-03-if-let.md:128 src/ch06-03-if-let.md:177
#: src/ch06-03-if-let.md:232 src/ch06-03-if-let.md:297
msgid "// so we can inspect the state in a minute\n"
msgstr "// 잠시 후에 상태를 검사할 수 있도록\n"

#: src/ch06-02-match.md:138
msgid ""
"Let’s imagine that a friend is trying to collect all 50 state quarters. "
"While we sort our loose change by coin type, we’ll also call out the name of "
"the state associated with each quarter so that if it’s one our friend "
"doesn’t have, they can add it to their collection."
msgstr ""

#: src/ch06-02-match.md:143
msgid ""
"In the match expression for this code, we add a variable called `state` to "
"the pattern that matches values of the variant `Coin::Quarter`. When a "
"`Coin::Quarter` matches, the `state` variable will bind to the value of that "
"quarter’s state. Then we can use `state` in the code for that arm, like so:"
msgstr ""

#: src/ch06-02-match.md:169 src/ch06-03-if-let.md:85 src/ch06-03-if-let.md:112
msgid "\"State quarter from {state:?}!\""
msgstr "\"{state:?} 주 동전!\""

#: src/ch06-02-match.md:180
msgid ""
"If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` "
"would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with "
"each of the match arms, none of them match until we reach "
"`Coin::Quarter(state)`. At that point, the binding for `state` will be the "
"value `UsState::Alaska`. We can then use that binding in the `println!` "
"expression, thus getting the inner state value out of the `Coin` enum "
"variant for `Quarter`."
msgstr "`value_in_cents(Coin::Quarter(UsState::Alaska))`를 호출하면 `coin`은 `Coin::Quarter(UsState::Alaska)`가 됩니다. 이 값을 각 매치 암과 비교하면 `Coin::Quarter(state)`에 도달할 때까지 아무것도 일치하지 않습니다. 그 시점에서 `state`에 대한 바인딩은 `UsState::Alaska` 값이 됩니다. 그런 다음 `println!` 표현식에서 해당 바인딩을 사용하여 `Quarter`에 대한 `Coin` 열거형 variant에서 내부 상태 값을 가져올 수 있습니다."

#: src/ch06-02-match.md:187
msgid "Matching with `Option<T>`"
msgstr "`Option<T>`로 매칭하기"

#: src/ch06-02-match.md:189
msgid ""
"In the previous section, we wanted to get the inner `T` value out of the "
"`Some` case when using `Option<T>`; we can also handle `Option<T>` using "
"`match`, as we did with the `Coin` enum! Instead of comparing coins, we’ll "
"compare the variants of `Option<T>`, but the way the `match` expression "
"works remains the same."
msgstr ""

#: src/ch06-02-match.md:195
msgid ""
"Let’s say we want to write a function that takes an `Option<i32>` and, if "
"there’s a value inside, adds 1 to that value. If there isn’t a value inside, "
"the function should return the `None` value and not attempt to perform any "
"operations."
msgstr ""

#: src/ch06-02-match.md:200
msgid ""
"This function is very easy to write, thanks to `match`, and will look like "
"Listing 6-5."
msgstr ""

#: src/ch06-02-match.md:222
msgid ""
"Let’s examine the first execution of `plus_one` in more detail. When we call "
"`plus_one(five)`, the variable `x` in the body of `plus_one` will have the "
"value `Some(5)`. We then compare that against each match arm:"
msgstr ""

#: src/ch06-02-match.md:241
msgid ""
"The `Some(5)` value doesn’t match the pattern `None`, so we continue to the "
"next arm:"
msgstr ""

#: src/ch06-02-match.md:259
msgid ""
"Does `Some(5)` match `Some(i)`? It does! We have the same variant. The `i` "
"binds to the value contained in `Some`, so `i` takes the value `5`. The code "
"in the match arm is then executed, so we add 1 to the value of `i` and "
"create a new `Some` value with our total `6` inside."
msgstr ""

#: src/ch06-02-match.md:264
msgid ""
"Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` "
"is `None`. We enter the `match` and compare to the first arm:"
msgstr ""

#: src/ch06-02-match.md:282
msgid ""
"It matches! There’s no value to add to, so the program stops and returns the "
"`None` value on the right side of `=>`. Because the first arm matched, no "
"other arms are compared."
msgstr ""

#: src/ch06-02-match.md:286
msgid ""
"Combining `match` and enums is useful in many situations. You’ll see this "
"pattern a lot in Rust code: `match` against an enum, bind a variable to the "
"data inside, and then execute code based on it. It’s a bit tricky at first, "
"but once you get used to it, you’ll wish you had it in all languages. It’s "
"consistently a user favorite."
msgstr ""

#: src/ch06-02-match.md:292
msgid "Matches Are Exhaustive"
msgstr "매치는 완전해야 합니다"

#: src/ch06-02-match.md:294
msgid ""
"There’s one other aspect of `match` we need to discuss: the arms’ patterns "
"must cover all possibilities. Consider this version of our `plus_one` "
"function, which has a bug and won’t compile:"
msgstr ""

#: src/ch06-02-match.md:312
msgid ""
"We didn’t handle the `None` case, so this code will cause a bug. Luckily, "
"it’s a bug Rust knows how to catch. If we try to compile this code, we’ll "
"get this error:"
msgstr ""

#: src/ch06-02-match.md:316
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling enums v0.1.0 (file:///projects/enums)\n"
"error[E0004]: non-exhaustive patterns: `None` not covered\n"
"   --> src/main.rs:3:15\n"
"    |\n"
"3   |         match x {\n"
"    |               ^ pattern `None` not covered\n"
"    |\n"
"note: `Option<i32>` defined here\n"
"   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/"
"core/src/option.rs:571:1\n"
"    |\n"
"571 | pub enum Option<T> {\n"
"    | ^^^^^^^^^^^^^^^^^^\n"
"...\n"
"575 |     None,\n"
"    |     ---- not covered\n"
"    = note: the matched value is of type `Option<i32>`\n"
"help: ensure that all possible cases are being handled by adding a match arm "
"with a wildcard pattern or an explicit pattern as shown\n"
"    |\n"
"4   ~             Some(i) => Some(i + 1),\n"
"5   ~             None => todo!(),\n"
"    |\n"
"\n"
"For more information about this error, try `rustc --explain E0004`.\n"
"error: could not compile `enums` (bin \"enums\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch06-02-match.md:344
msgid ""
"Rust knows that we didn’t cover every possible case, and even knows which "
"pattern we forgot! Matches in Rust are _exhaustive_: we must exhaust every "
"last possibility in order for the code to be valid. Especially in the case "
"of `Option<T>`, when Rust prevents us from forgetting to explicitly handle "
"the `None` case, it protects us from assuming that we have a value when we "
"might have null, thus making the billion-dollar mistake discussed earlier "
"impossible."
msgstr ""

#: src/ch06-02-match.md:351
msgid "Catch-All Patterns and the `_` Placeholder"
msgstr "모든 것을 포괄하는 패턴과 `_` 플레이스홀더"

#: src/ch06-02-match.md:353
msgid ""
"Using enums, we can also take special actions for a few particular values, "
"but for all other values take one default action. Imagine we’re implementing "
"a game where, if you roll a 3 on a dice roll, your player doesn’t move, but "
"instead gets a new fancy hat. If you roll a 7, your player loses a fancy "
"hat. For all other values, your player moves that number of spaces on the "
"game board. Here’s a `match` that implements that logic, with the result of "
"the dice roll hardcoded rather than a random value, and all other logic "
"represented by functions without bodies because actually implementing them "
"is out of scope for this example:"
msgstr ""

#: src/ch06-02-match.md:378
msgid ""
"For the first two arms, the patterns are the literal values `3` and `7`. For "
"the last arm that covers every other possible value, the pattern is the "
"variable we’ve chosen to name `other`. The code that runs for the `other` "
"arm uses the variable by passing it to the `move_player` function."
msgstr ""

#: src/ch06-02-match.md:383
msgid ""
"This code compiles, even though we haven’t listed all the possible values a "
"`u8` can have, because the last pattern will match all values not "
"specifically listed. This catch-all pattern meets the requirement that "
"`match` must be exhaustive. Note that we have to put the catch-all arm last "
"because the patterns are evaluated in order. If we put the catch-all arm "
"earlier, the other arms would never run, so Rust will warn us if we add arms "
"after a catch-all!"
msgstr ""

#: src/ch06-02-match.md:390
msgid ""
"Rust also has a pattern we can use when we want a catch-all but don’t want "
"to _use_ the value in the catch-all pattern: `_` is a special pattern that "
"matches any value and does not bind to that value. This tells Rust we aren’t "
"going to use the value, so Rust won’t warn us about an unused variable."
msgstr ""

#: src/ch06-02-match.md:395
msgid ""
"Let’s change the rules of the game: now, if you roll anything other than a 3 "
"or a 7, you must roll again. We no longer need to use the catch-all value, "
"so we can change our code to use `_` instead of the variable named `other`:"
msgstr "게임 규칙을 변경해 봅시다: 이제 3이나 7이 아닌 다른 것을 굴리면 다시 굴려야 합니다. 더 이상 catch-all 값을 사용할 필요가 없으므로, `other`라는 변수 대신 `_`를 사용하도록 코드를 변경할 수 있습니다:"

#: src/ch06-02-match.md:414
msgid ""
"This example also meets the exhaustiveness requirement because we’re "
"explicitly ignoring all other values in the last arm; we haven’t forgotten "
"anything."
msgstr "이 예제는 마지막 arm에서 다른 모든 값을 명시적으로 무시하므로 완전성 요구 사항도 충족합니다. 우리는 아무것도 잊지 않았습니다."

#: src/ch06-02-match.md:417
msgid ""
"Finally, we’ll change the rules of the game one more time so that nothing "
"else happens on your turn if you roll anything other than a 3 or a 7. We can "
"express that by using the unit value (the empty tuple type we mentioned in "
"[“The Tuple Type”](ch03-02-data-types.html#the-tuple-type)<!-- ignore --> "
"section) as the code that goes with the `_` arm:"
msgstr "마지막으로, 게임 규칙을 한 번 더 변경하여 3이나 7이 아닌 다른 것을 굴리면 당신의 차례에 아무 일도 일어나지 않도록 할 것입니다. 이는 유닛 값( [“튜플 타입”](ch03-02-data-types.html#the-tuple-type)<!-- ignore --> 섹션에서 언급한 빈 튜플 타입)을 `_` arm과 함께 가는 코드로 사용하여 표현할 수 있습니다:"

#: src/ch06-02-match.md:436
msgid ""
"Here, we’re telling Rust explicitly that we aren’t going to use any other "
"value that doesn’t match a pattern in an earlier arm, and we don’t want to "
"run any code in this case."
msgstr "여기서 우리는 러스트에게 이전 arm의 패턴과 일치하지 않는 다른 어떤 값도 사용하지 않을 것이며, 이 경우 어떤 코드도 실행하고 싶지 않다고 명시적으로 말하고 있습니다."

#: src/ch06-02-match.md:440
msgid ""
"There’s more about patterns and matching that we’ll cover in [Chapter 19]"
"(ch19-00-patterns.html)<!-- ignore -->. For now, we’re going to move on to "
"the `if let` syntax, which can be useful in situations where the `match` "
"expression is a bit wordy."
msgstr "[19장](ch19-00-patterns.html)<!-- ignore -->에서 패턴과 매칭에 대해 더 자세히 다룰 것입니다. 지금은 `match` 표현식이 다소 장황한 상황에서 유용할 수 있는 `if let` 구문으로 넘어가겠습니다."

#: src/ch06-03-if-let.md:3
msgid ""
"The `if let` syntax lets you combine `if` and `let` into a less verbose way "
"to handle values that match one pattern while ignoring the rest. Consider "
"the program in Listing 6-6 that matches on an `Option<u8>` value in the "
"`config_max` variable but only wants to execute code if the value is the "
"`Some` variant."
msgstr "`if let` 구문은 `if`와 `let`을 결합하여 하나의 패턴과 일치하는 값을 처리하고 나머지는 무시하는 덜 장황한 방법을 제공합니다. `config_max` 변수의 `Option<u8>` 값과 일치하지만 값이 `Some` variant인 경우에만 코드를 실행하려는 목록 6-6의 프로그램을 고려해 보세요."

#: src/ch06-03-if-let.md:15 src/ch06-03-if-let.md:36
msgid "\"The maximum is configured to be {max}\""
msgstr ""

#: src/ch06-03-if-let.md:23
msgid ""
"If the value is `Some`, we print out the value in the `Some` variant by "
"binding the value to the variable `max` in the pattern. We don’t want to do "
"anything with the `None` value. To satisfy the `match` expression, we have "
"to add `_ => ()` after processing just one variant, which is annoying "
"boilerplate code to add."
msgstr ""

#: src/ch06-03-if-let.md:29
msgid ""
"Instead, we could write this in a shorter way using `if let`. The following "
"code behaves the same as the `match` in Listing 6-6:"
msgstr ""

#: src/ch06-03-if-let.md:41
msgid ""
"The syntax `if let` takes a pattern and an expression separated by an equal "
"sign. It works the same way as a `match`, where the expression is given to "
"the `match` and the pattern is its first arm. In this case, the pattern is "
"`Some(max)`, and the `max` binds to the value inside the `Some`. We can then "
"use `max` in the body of the `if let` block in the same way we used `max` in "
"the corresponding `match` arm. The code in the `if let` block only runs if "
"the value matches the pattern."
msgstr ""

#: src/ch06-03-if-let.md:49
msgid ""
"Using `if let` means less typing, less indentation, and less boilerplate "
"code. However, you lose the exhaustive checking that `match` enforces. "
"Choosing between `match` and `if let` depends on what you’re doing in your "
"particular situation and whether gaining conciseness is an appropriate trade-"
"off for losing exhaustive checking."
msgstr ""

#: src/ch06-03-if-let.md:55
msgid ""
"In other words, you can think of `if let` as syntax sugar for a `match` that "
"runs code when the value matches one pattern and then ignores all other "
"values."
msgstr ""

#: src/ch06-03-if-let.md:58
msgid ""
"We can include an `else` with an `if let`. The block of code that goes with "
"the `else` is the same as the block of code that would go with the `_` case "
"in the `match` expression that is equivalent to the `if let` and `else`. "
"Recall the `Coin` enum definition in Listing 6-4, where the `Quarter` "
"variant also held a `UsState` value. If we wanted to count all non-quarter "
"coins we see while also announcing the state of the quarters, we could do "
"that with a `match` expression, like this:"
msgstr ""

#: src/ch06-03-if-let.md:91
msgid "Or we could use an `if let` and `else` expression, like this:"
msgstr ""

#: src/ch06-03-if-let.md:119
msgid "Staying on the “happy path” with `let else`"
msgstr ""

#: src/ch06-03-if-let.md:121
msgid ""
"One common pattern is to perform some computation when a value is present "
"and return a default value otherwise. Continuing on with our example of "
"coins with a `UsState` value, if we wanted to say something funny depending "
"on how old the state on the quarter was, we might introduce a method on "
"`UsState` to check the age of a state, like so:"
msgstr ""

#: src/ch06-03-if-let.md:140 src/ch06-03-if-let.md:189
#: src/ch06-03-if-let.md:244 src/ch06-03-if-let.md:309
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:159
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:234
msgid "// -- snip --\n"
msgstr "// -- 생략 --\n"

#: src/ch06-03-if-let.md:155 src/ch06-03-if-let.md:204
#: src/ch06-03-if-let.md:264 src/ch06-03-if-let.md:327
msgid "\"{state:?} is pretty old, for America!\""
msgstr ""

#: src/ch06-03-if-let.md:157 src/ch06-03-if-let.md:206
#: src/ch06-03-if-let.md:266 src/ch06-03-if-let.md:329
msgid "\"{state:?} is relatively new.\""
msgstr ""

#: src/ch06-03-if-let.md:166 src/ch06-03-if-let.md:215
#: src/ch06-03-if-let.md:272 src/ch06-03-if-let.md:335
msgid "\"{desc}\""
msgstr ""

#: src/ch06-03-if-let.md:171
msgid ""
"Then we might use `if let` to match on the type of coin, introducing a "
"`state` variable within the body of the condition, as in Listing 6-7."
msgstr "그런 다음 `if let`을 사용하여 코인의 타입과 일치시키고, 목록 6-7과 같이 조건 본문 내에 `state` 변수를 도입할 수 있습니다."

#: src/ch06-03-if-let.md:222
msgid ""
"That gets the job done, but it has pushed the work into the body of the `if "
"let` statement, and if the work to be done is more complicated, it might be "
"hard to follow exactly how the top-level branches relate. We could also take "
"advantage of the fact that expressions produce a value either to produce the "
"`state` from the `if let` or to return early, as in Listing 6-8. (You could "
"do similar with a `match`, of course!)"
msgstr "그것은 작업을 완료하지만, 작업을 `if let` 문의 본문으로 밀어 넣었고, 수행할 작업이 더 복잡하다면 최상위 분기가 어떻게 관련되는지 정확히 파악하기 어려울 수 있습니다. 우리는 표현식이 값을 생성한다는 사실을 활용하여 `if let`에서 `state`를 생성하거나 목록 6-8과 같이 일찍 반환할 수도 있습니다. (물론 `match`로도 유사하게 할 수 있습니다!)"

#: src/ch06-03-if-let.md:279
msgid ""
"This is a bit annoying to follow in its own way, though! One branch of the "
"`if let` produces a value, and the other one returns from the function "
"entirely."
msgstr "하지만 이것은 나름대로 따라가기 좀 번거롭습니다! `if let`의 한 분기는 값을 생성하고, 다른 분기는 함수에서 완전히 반환됩니다."

#: src/ch06-03-if-let.md:282
msgid ""
"To make this common pattern nicer to express, Rust has `let`\\-`else`. The "
"`let`\\-`else` syntax takes a pattern on the left side and an expression on "
"the right, very similar to `if let`, but it does not have an `if` branch, "
"only an `else` branch. If the pattern matches, it will bind the value from "
"the pattern in the outer scope. If the pattern does _not_ match, the program "
"will flow into the `else` arm, which must return from the function."
msgstr ""

#: src/ch06-03-if-let.md:289
msgid ""
"In Listing 6-9, you can see how Listing 6-8 looks when using `let`\\-`else` "
"in place of `if let`. Notice that it stays “on the happy path” in the main "
"body of the function this way, without having significantly different "
"control flow for two branches the way the `if let` did."
msgstr ""

#: src/ch06-03-if-let.md:342
msgid ""
"If you have a situation in which your program has logic that is too verbose "
"to express using a `match`, remember that `if let` and `let else` are in "
"your Rust toolbox as well."
msgstr ""

#: src/ch06-03-if-let.md:348
msgid ""
"We’ve now covered how to use enums to create custom types that can be one of "
"a set of enumerated values. We’ve shown how the standard library’s "
"`Option<T>` type helps you use the type system to prevent errors. When enum "
"values have data inside them, you can use `match` or `if let` to extract and "
"use those values, depending on how many cases you need to handle."
msgstr ""

#: src/ch06-03-if-let.md:354
msgid ""
"Your Rust programs can now express concepts in your domain using structs and "
"enums. Creating custom types to use in your API ensures type safety: the "
"compiler will make certain your functions only get values of the type each "
"function expects."
msgstr ""

#: src/ch06-03-if-let.md:359
msgid ""
"In order to provide a well-organized API to your users that is "
"straightforward to use and only exposes exactly what your users will need, "
"let’s now turn to Rust’s modules."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:3
msgid ""
"As you write large programs, organizing your code will become increasingly "
"important. By grouping related functionality and separating code with "
"distinct features, you’ll clarify where to find code that implements a "
"particular feature and where to go to change how a feature works."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:8
msgid ""
"The programs we’ve written so far have been in one module in one file. As a "
"project grows, you should organize code by splitting it into multiple "
"modules and then multiple files. A package can contain multiple binary "
"crates and optionally one library crate. As a package grows, you can extract "
"parts into separate crates that become external dependencies. This chapter "
"covers all these techniques. For very large projects comprising a set of "
"interrelated packages that evolve together, Cargo provides _workspaces_, "
"which we’ll cover in [“Cargo Workspaces”](ch14-03-cargo-workspaces.html)<!-- "
"ignore --> in Chapter 14."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:17
msgid ""
"We’ll also discuss encapsulating implementation details, which lets you "
"reuse code at a higher level: once you’ve implemented an operation, other "
"code can call your code via its public interface without having to know how "
"the implementation works. The way you write code defines which parts are "
"public for other code to use and which parts are private implementation "
"details that you reserve the right to change. This is another way to limit "
"the amount of detail you have to keep in your head."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:25
msgid ""
"A related concept is scope: the nested context in which code is written has "
"a set of names that are defined as “in scope.” When reading, writing, and "
"compiling code, programmers and compilers need to know whether a particular "
"name at a particular spot refers to a variable, function, struct, enum, "
"module, constant, or other item and what that item means. You can create "
"scopes and change which names are in or out of scope. You can’t have two "
"items with the same name in the same scope; tools are available to resolve "
"name conflicts."
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:33
msgid ""
"Rust has a number of features that allow you to manage your code’s "
"organization, including which details are exposed, which details are "
"private, and what names are in each scope in your programs. These features, "
"sometimes collectively referred to as the _module system_, include:"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:38
msgid ""
"**Packages:** A Cargo feature that lets you build, test, and share crates"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:39
msgid "**Crates:** A tree of modules that produces a library or executable"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:40
msgid ""
"**Modules** and **use:** Let you control the organization, scope, and "
"privacy of paths"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:42
msgid ""
"**Paths:** A way of naming an item, such as a struct, function, or module"
msgstr ""

#: src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md:44
msgid ""
"In this chapter, we’ll cover all these features, discuss how they interact, "
"and explain how to use them to manage scope. By the end, you should have a "
"solid understanding of the module system and be able to work with scopes "
"like a pro!"
msgstr ""

#: src/ch07-01-packages-and-crates.md:3
msgid ""
"The first parts of the module system we’ll cover are packages and crates."
msgstr ""

#: src/ch07-01-packages-and-crates.md:5
msgid ""
"A _crate_ is the smallest amount of code that the Rust compiler considers at "
"a time. Even if you run `rustc` rather than `cargo` and pass a single source "
"code file (as we did all the way back in “Writing and Running a Rust "
"Program” in Chapter 1), the compiler considers that file to be a crate. "
"Crates can contain modules, and the modules may be defined in other files "
"that get compiled with the crate, as we’ll see in the coming sections."
msgstr ""

#: src/ch07-01-packages-and-crates.md:12
msgid ""
"A crate can come in one of two forms: a binary crate or a library crate. "
"_Binary crates_ are programs you can compile to an executable that you can "
"run, such as a command line program or a server. Each must have a function "
"called `main` that defines what happens when the executable runs. All the "
"crates we’ve created so far have been binary crates."
msgstr ""

#: src/ch07-01-packages-and-crates.md:18
msgid ""
"_Library crates_ don’t have a `main` function, and they don’t compile to an "
"executable. Instead, they define functionality intended to be shared with "
"multiple projects. For example, the `rand` crate we used in [Chapter 2]"
"(ch02-00-guessing-game-tutorial.html#generating-a-random-number)<!-- ignore "
"--> provides functionality that generates random numbers. Most of the time "
"when Rustaceans say “crate”, they mean library crate, and they use “crate” "
"interchangeably with the general programming concept of a “library”."
msgstr ""

#: src/ch07-01-packages-and-crates.md:25
msgid ""
"The _crate root_ is a source file that the Rust compiler starts from and "
"makes up the root module of your crate (we’ll explain modules in depth in "
"[“Defining Modules to Control Scope and Privacy”](ch07-02-defining-modules-"
"to-control-scope-and-privacy.html)<!-- ignore -->)."
msgstr ""

#: src/ch07-01-packages-and-crates.md:29
msgid ""
"A _package_ is a bundle of one or more crates that provides a set of "
"functionality. A package contains a _Cargo.toml_ file that describes how to "
"build those crates. Cargo is actually a package that contains the binary "
"crate for the command line tool you’ve been using to build your code. The "
"Cargo package also contains a library crate that the binary crate depends "
"on. Other projects can depend on the Cargo library crate to use the same "
"logic the Cargo command line tool uses. A package can contain as many binary "
"crates as you like, but at most only one library crate. A package must "
"contain at least one crate, whether that’s a library or binary crate."
msgstr ""

#: src/ch07-01-packages-and-crates.md:39
msgid ""
"Let’s walk through what happens when we create a package. First we enter the "
"command `cargo new my-project`:"
msgstr ""

#: src/ch07-01-packages-and-crates.md:52
msgid ""
"After we run `cargo new my-project`, we use `ls` to see what Cargo creates. "
"In the project directory, there’s a _Cargo.toml_ file, giving us a package. "
"There’s also a _src_ directory that contains _main.rs_. Open _Cargo.toml_ in "
"your text editor, and note there’s no mention of _src/main.rs_. Cargo "
"follows a convention that _src/main.rs_ is the crate root of a binary crate "
"with the same name as the package. Likewise, Cargo knows that if the package "
"directory contains _src/lib.rs_, the package contains a library crate with "
"the same name as the package, and _src/lib.rs_ is its crate root. Cargo "
"passes the crate root files to `rustc` to build the library or binary."
msgstr ""

#: src/ch07-01-packages-and-crates.md:62
msgid ""
"Here, we have a package that only contains _src/main.rs_, meaning it only "
"contains a binary crate named `my-project`. If a package contains _src/"
"main.rs_ and _src/lib.rs_, it has two crates: a binary and a library, both "
"with the same name as the package. A package can have multiple binary crates "
"by placing files in the _src/bin_ directory: each file will be a separate "
"binary crate."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:3
msgid ""
"In this section, we’ll talk about modules and other parts of the module "
"system, namely _paths_, which allow you to name items; the `use` keyword "
"that brings a path into scope; and the `pub` keyword to make items public. "
"We’ll also discuss the `as` keyword, external packages, and the glob "
"operator."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:8
msgid "Modules Cheat Sheet"
msgstr "모듈 치트 시트"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:10
msgid ""
"Before we get to the details of modules and paths, here we provide a quick "
"reference on how modules, paths, the `use` keyword, and the `pub` keyword "
"work in the compiler, and how most developers organize their code. We’ll be "
"going through examples of each of these rules throughout this chapter, but "
"this is a great place to refer to as a reminder of how modules work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:16
msgid ""
"**Start from the crate root**: When compiling a crate, the compiler first "
"looks in the crate root file (usually _src/lib.rs_ for a library crate or "
"_src/main.rs_ for a binary crate) for code to compile."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:19
msgid ""
"**Declaring modules**: In the crate root file, you can declare new modules; "
"say you declare a “garden” module with `mod garden;`. The compiler will look "
"for the module’s code in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:22
msgid ""
"Inline, within curly brackets that replace the semicolon following `mod "
"garden`"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:24
msgid "In the file _src/garden.rs_"
msgstr "_src/garden.rs_ 파일에"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:25
msgid "In the file _src/garden/mod.rs_"
msgstr "_src/garden/mod.rs_ 파일에"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:26
msgid ""
"**Declaring submodules**: In any file other than the crate root, you can "
"declare submodules. For example, you might declare `mod vegetables;` in _src/"
"garden.rs_. The compiler will look for the submodule’s code within the "
"directory named for the parent module in these places:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:30
msgid ""
"Inline, directly following `mod vegetables`, within curly brackets instead "
"of the semicolon"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:32
msgid "In the file _src/garden/vegetables.rs_"
msgstr "_src/garden/vegetables.rs_ 파일에"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:33
msgid "In the file _src/garden/vegetables/mod.rs_"
msgstr "_src/garden/vegetables/mod.rs_ 파일에"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:34
msgid ""
"**Paths to code in modules**: Once a module is part of your crate, you can "
"refer to code in that module from anywhere else in that same crate, as long "
"as the privacy rules allow, using the path to the code. For example, an "
"`Asparagus` type in the garden vegetables module would be found at "
"`crate::garden::vegetables::Asparagus`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:39
msgid ""
"**Private vs. public**: Code within a module is private from its parent "
"modules by default. To make a module public, declare it with `pub mod` "
"instead of `mod`. To make items within a public module public as well, use "
"`pub` before their declarations."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:43
msgid ""
"**The `use` keyword**: Within a scope, the `use` keyword creates shortcuts "
"to items to reduce repetition of long paths. In any scope that can refer to "
"`crate::garden::vegetables::Asparagus`, you can create a shortcut with `use "
"crate::garden::vegetables::Asparagus;` and from then on you only need to "
"write `Asparagus` to make use of that type in the scope."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:49
msgid ""
"Here, we create a binary crate named `backyard` that illustrates these "
"rules. The crate’s directory, also named `backyard`, contains these files "
"and directories:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:64
msgid "The crate root file in this case is _src/main.rs_, and it contains:"
msgstr "이 경우 크레이트 루트 파일은 _src/main.rs_이며, 다음을 포함합니다:"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:75
msgid "\"I'm growing {plant:?}!\""
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:81
msgid ""
"The `pub mod garden;` line tells the compiler to include the code it finds "
"in _src/garden.rs_, which is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:92
msgid ""
"Here, `pub mod vegetables;` means the code in _src/garden/vegetables.rs_ is "
"included too. That code is:"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:100
msgid ""
"Now let’s get into the details of these rules and demonstrate them in action!"
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:102
msgid "Grouping Related Code in Modules"
msgstr "모듈로 관련 코드 그룹화하기"

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:104
msgid ""
"_Modules_ let us organize code within a crate for readability and easy "
"reuse. Modules also allow us to control the _privacy_ of items because code "
"within a module is private by default. Private items are internal "
"implementation details not available for outside use. We can choose to make "
"modules and the items within them public, which exposes them to allow "
"external code to use and depend on them."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:111
msgid ""
"As an example, let’s write a library crate that provides the functionality "
"of a restaurant. We’ll define the signatures of functions but leave their "
"bodies empty to concentrate on the organization of the code rather than the "
"implementation of a restaurant."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:116
msgid ""
"In the restaurant industry, some parts of a restaurant are referred to as "
"_front of house_ and others as _back of house_. Front of house is where "
"customers are; this encompasses where the hosts seat customers, servers take "
"orders and payment, and bartenders make drinks. Back of house is where the "
"chefs and cooks work in the kitchen, dishwashers clean up, and managers do "
"administrative work."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:123
msgid ""
"To structure our crate in this way, we can organize its functions into "
"nested modules. Create a new library named `restaurant` by running `cargo "
"new restaurant --lib`. Then enter the code in Listing 7-1 into _src/lib.rs_ "
"to define some modules and function signatures; this code is the front of "
"house section."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:151
msgid ""
"We define a module with the `mod` keyword followed by the name of the module "
"(in this case, `front_of_house`). The body of the module then goes inside "
"curly brackets. Inside modules, we can place other modules, as in this case "
"with the modules `hosting` and `serving`. Modules can also hold definitions "
"for other items, such as structs, enums, constants, traits, and—as in "
"Listing 7-1—functions."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:158
msgid ""
"By using modules, we can group related definitions together and name why "
"they’re related. Programmers using this code can navigate the code based on "
"the groups rather than having to read through all the definitions, making it "
"easier to find the definitions relevant to them. Programmers adding new "
"functionality to this code would know where to place the code to keep the "
"program organized."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:164
msgid ""
"Earlier, we mentioned that _src/main.rs_ and _src/lib.rs_ are called crate "
"roots. The reason for their name is that the contents of either of these two "
"files form a module named `crate` at the root of the crate’s module "
"structure, known as the _module tree_."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:169
msgid "Listing 7-2 shows the module tree for the structure in Listing 7-1."
msgstr "목록 7-2는 목록 7-1의 구조에 대한 모듈 트리를 보여줍니다."

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:187
msgid ""
"This tree shows how some of the modules nest inside other modules; for "
"example, `hosting` nests inside `front_of_house`. The tree also shows that "
"some modules are _siblings_, meaning they’re defined in the same module; "
"`hosting` and `serving` are siblings defined within `front_of_house`. If "
"module A is contained inside module B, we say that module A is the _child_ "
"of module B and that module B is the _parent_ of module A. Notice that the "
"entire module tree is rooted under the implicit module named `crate`."
msgstr ""

#: src/ch07-02-defining-modules-to-control-scope-and-privacy.md:195
msgid ""
"The module tree might remind you of the filesystem’s directory tree on your "
"computer; this is a very apt comparison! Just like directories in a "
"filesystem, you use modules to organize your code. And just like files in a "
"directory, we need a way to find our modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:3
msgid ""
"To show Rust where to find an item in a module tree, we use a path in the "
"same way we use a path when navigating a filesystem. To call a function, we "
"need to know its path."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:7
msgid "A path can take two forms:"
msgstr "경로는 두 가지 형태를 가질 수 있습니다:"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:9
msgid ""
"An _absolute path_ is the full path starting from a crate root; for code "
"from an external crate, the absolute path begins with the crate name, and "
"for code from the current crate, it starts with the literal `crate`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:12
msgid ""
"A _relative path_ starts from the current module and uses `self`, `super`, "
"or an identifier in the current module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:15
msgid ""
"Both absolute and relative paths are followed by one or more identifiers "
"separated by double colons (`::`)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:18
msgid ""
"Returning to Listing 7-1, say we want to call the `add_to_waitlist` "
"function. This is the same as asking: what’s the path of the "
"`add_to_waitlist` function? Listing 7-3 contains Listing 7-1 with some of "
"the modules and functions removed."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:23
msgid ""
"We’ll show two ways to call the `add_to_waitlist` function from a new "
"function, `eat_at_restaurant`, defined in the crate root. These paths are "
"correct, but there’s another problem remaining that will prevent this "
"example from compiling as is. We’ll explain why in a bit."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:28
msgid ""
"The `eat_at_restaurant` function is part of our library crate’s public API, "
"so we mark it with the `pub` keyword. In the [“Exposing Paths with the `pub` "
"Keyword”](ch07-03-paths-for-referring-to-an-item-in-the-module-"
"tree.html#exposing-paths-with-the-pub-keyword)<!-- ignore --> section, we’ll "
"go into more detail about `pub`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:42
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:162
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:237
msgid "// Absolute path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:45
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:165
#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:240
msgid "// Relative path\n"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:52
msgid ""
"The first time we call the `add_to_waitlist` function in "
"`eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function "
"is defined in the same crate as `eat_at_restaurant`, which means we can use "
"the `crate` keyword to start an absolute path. We then include each of the "
"successive modules until we make our way to `add_to_waitlist`. You can "
"imagine a filesystem with the same structure: we’d specify the path `/"
"front_of_house/hosting/add_to_waitlist` to run the `add_to_waitlist` "
"program; using the `crate` name to start from the crate root is like using `/"
"` to start from the filesystem root in your shell."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:61
msgid ""
"The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a "
"relative path. The path starts with `front_of_house`, the name of the module "
"defined at the same level of the module tree as `eat_at_restaurant`. Here "
"the filesystem equivalent would be using the path `front_of_house/hosting/"
"add_to_waitlist`. Starting with a module name means that the path is "
"relative."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:68
msgid ""
"Choosing whether to use a relative or absolute path is a decision you’ll "
"make based on your project, and it depends on whether you’re more likely to "
"move item definition code separately from or together with the code that "
"uses the item. For example, if we moved the `front_of_house` module and the "
"`eat_at_restaurant` function into a module named `customer_experience`, we’d "
"need to update the absolute path to `add_to_waitlist`, but the relative path "
"would still be valid. However, if we moved the `eat_at_restaurant` function "
"separately into a module named `dining`, the absolute path to the "
"`add_to_waitlist` call would stay the same, but the relative path would need "
"to be updated. Our preference in general is to specify absolute paths "
"because it’s more likely we’ll want to move code definitions and item calls "
"independently of each other."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:81
msgid ""
"Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The "
"errors we get are shown in Listing 7-4."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:86
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0603]: module `hosting` is private\n"
" --> src/lib.rs:9:28\n"
"  |\n"
"9 |     crate::front_of_house::hosting::add_to_waitlist();\n"
"  |                            ^^^^^^^  --------------- function "
"`add_to_waitlist` is not publicly re-exported\n"
"  |                            |\n"
"  |                            private module\n"
"  |\n"
"note: the module `hosting` is defined here\n"
" --> src/lib.rs:2:5\n"
"  |\n"
"2 |     mod hosting {\n"
"  |     ^^^^^^^^^^^\n"
"\n"
"error[E0603]: module `hosting` is private\n"
"  --> src/lib.rs:12:21\n"
"   |\n"
"12 |     front_of_house::hosting::add_to_waitlist();\n"
"   |                     ^^^^^^^  --------------- function `add_to_waitlist` "
"is not publicly re-exported\n"
"   |                     |\n"
"   |                     private module\n"
"   |\n"
"note: the module `hosting` is defined here\n"
"  --> src/lib.rs:2:5\n"
"   |\n"
"2  |     mod hosting {\n"
"   |     ^^^^^^^^^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0603`.\n"
"error: could not compile `restaurant` (lib) due to 2 previous errors\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:123
msgid ""
"The error messages say that module `hosting` is private. In other words, we "
"have the correct paths for the `hosting` module and the `add_to_waitlist` "
"function, but Rust won’t let us use them because it doesn’t have access to "
"the private sections. In Rust, all items (functions, methods, structs, "
"enums, modules, and constants) are private to parent modules by default. If "
"you want to make an item like a function or struct private, you put it in a "
"module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:130
msgid ""
"Items in a parent module can’t use the private items inside child modules, "
"but items in child modules can use the items in their ancestor modules. This "
"is because child modules wrap and hide their implementation details, but the "
"child modules can see the context in which they’re defined. To continue with "
"our metaphor, think of the privacy rules as being like the back office of a "
"restaurant: what goes on in there is private to restaurant customers, but "
"office managers can see and do everything in the restaurant they operate."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:138
msgid ""
"Rust chose to have the module system function this way so that hiding inner "
"implementation details is the default. That way, you know which parts of the "
"inner code you can change without breaking outer code. However, Rust does "
"give you the option to expose inner parts of child modules’ code to outer "
"ancestor modules by using the `pub` keyword to make an item public."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:144
msgid "Exposing Paths with the `pub` Keyword"
msgstr "`pub` 키워드로 경로 노출하기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:146
msgid ""
"Let’s return to the error in Listing 7-4 that told us the `hosting` module "
"is private. We want the `eat_at_restaurant` function in the parent module to "
"have access to the `add_to_waitlist` function in the child module, so we "
"mark the `hosting` module with the `pub` keyword, as shown in Listing 7-5."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:172
msgid ""
"Unfortunately, the code in Listing 7-5 still results in compiler errors, as "
"shown in Listing 7-6."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:177
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0603]: function `add_to_waitlist` is private\n"
" --> src/lib.rs:9:37\n"
"  |\n"
"9 |     crate::front_of_house::hosting::add_to_waitlist();\n"
"  |                                     ^^^^^^^^^^^^^^^ private function\n"
"  |\n"
"note: the function `add_to_waitlist` is defined here\n"
" --> src/lib.rs:3:9\n"
"  |\n"
"3 |         fn add_to_waitlist() {}\n"
"  |         ^^^^^^^^^^^^^^^^^^^^\n"
"\n"
"error[E0603]: function `add_to_waitlist` is private\n"
"  --> src/lib.rs:12:30\n"
"   |\n"
"12 |     front_of_house::hosting::add_to_waitlist();\n"
"   |                              ^^^^^^^^^^^^^^^ private function\n"
"   |\n"
"note: the function `add_to_waitlist` is defined here\n"
"  --> src/lib.rs:3:9\n"
"   |\n"
"3  |         fn add_to_waitlist() {}\n"
"   |         ^^^^^^^^^^^^^^^^^^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0603`.\n"
"error: could not compile `restaurant` (lib) due to 2 previous errors\n"
"```"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:210
msgid ""
"What happened? Adding the `pub` keyword in front of `mod hosting` makes the "
"module public. With this change, if we can access `front_of_house`, we can "
"access `hosting`. But the _contents_ of `hosting` are still private; making "
"the module public doesn’t make its contents public. The `pub` keyword on a "
"module only lets code in its ancestor modules refer to it, not access its "
"inner code. Because modules are containers, there’s not much we can do by "
"only making the module public; we need to go further and choose to make one "
"or more of the items within the module public as well."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:219
msgid ""
"The errors in Listing 7-6 say that the `add_to_waitlist` function is "
"private. The privacy rules apply to structs, enums, functions, and methods "
"as well as modules."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:223
msgid ""
"Let’s also make the `add_to_waitlist` function public by adding the `pub` "
"keyword before its definition, as in Listing 7-7."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:247
msgid ""
"Now the code will compile! To see why adding the `pub` keyword lets us use "
"these paths in `eat_at_restaurant` with respect to the privacy rules, let’s "
"look at the absolute and the relative paths."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:251
msgid ""
"In the absolute path, we start with `crate`, the root of our crate’s module "
"tree. The `front_of_house` module is defined in the crate root. While "
"`front_of_house` isn’t public, because the `eat_at_restaurant` function is "
"defined in the same module as `front_of_house` (that is, `eat_at_restaurant` "
"and `front_of_house` are siblings), we can refer to `front_of_house` from "
"`eat_at_restaurant`. Next is the `hosting` module marked with `pub`. We can "
"access the parent module of `hosting`, so we can access `hosting`. Finally, "
"the `add_to_waitlist` function is marked with `pub` and we can access its "
"parent module, so this function call works!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:261
msgid ""
"In the relative path, the logic is the same as the absolute path except for "
"the first step: rather than starting from the crate root, the path starts "
"from `front_of_house`. The `front_of_house` module is defined within the "
"same module as `eat_at_restaurant`, so the relative path starting from the "
"module in which `eat_at_restaurant` is defined works. Then, because "
"`hosting` and `add_to_waitlist` are marked with `pub`, the rest of the path "
"works, and this function call is valid!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:269
msgid ""
"If you plan on sharing your library crate so other projects can use your "
"code, your public API is your contract with users of your crate that "
"determines how they can interact with your code. There are many "
"considerations around managing changes to your public API to make it easier "
"for people to depend on your crate. These considerations are beyond the "
"scope of this book; if you’re interested in this topic, see [The Rust API "
"Guidelines](https://rust-lang.github.io/api-guidelines/)."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:276
msgid "Best Practices for Packages with a Binary and a Library"
msgstr "바이너리 및 라이브러리가 있는 패키지 모범 사례"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:278
msgid ""
"We mentioned that a package can contain both a _src/main.rs_ binary crate "
"root as well as a _src/lib.rs_ library crate root, and both crates will have "
"the package name by default. Typically, packages with this pattern of "
"containing both a library and a binary crate will have just enough code in "
"the binary crate to start an executable that calls code within the library "
"crate. This lets other projects benefit from most of the functionality that "
"the package provides because the library crate’s code can be shared."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:286
msgid ""
"The module tree should be defined in _src/lib.rs_. Then, any public items "
"can be used in the binary crate by starting paths with the name of the "
"package. The binary crate becomes a user of the library crate just like a "
"completely external crate would use the library crate: it can only use the "
"public API. This helps you design a good API; not only are you the author, "
"you’re also a client!"
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:293
msgid ""
"In [Chapter 12](ch12-00-an-io-project.html)<!-- ignore -->, we’ll "
"demonstrate this organizational practice with a command line program that "
"will contain both a binary crate and a library crate."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:297
msgid "Starting Relative Paths with `super`"
msgstr "`super`로 상대 경로 시작하기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:299
msgid ""
"We can construct relative paths that begin in the parent module, rather than "
"the current module or the crate root, by using `super` at the start of the "
"path. This is like starting a filesystem path with the `..` syntax. Using "
"`super` allows us to reference an item that we know is in the parent module, "
"which can make rearranging the module tree easier when the module is closely "
"related to the parent but the parent might be moved elsewhere in the module "
"tree someday."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:307
msgid ""
"Consider the code in Listing 7-8 that models the situation in which a chef "
"fixes an incorrect order and personally brings it out to the customer. The "
"function `fix_incorrect_order` defined in the `back_of_house` module calls "
"the function `deliver_order` defined in the parent module by specifying the "
"path to `deliver_order`, starting with `super`."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:330
msgid ""
"The `fix_incorrect_order` function is in the `back_of_house` module, so we "
"can use `super` to go to the parent module of `back_of_house`, which in this "
"case is `crate`, the root. From there, we look for `deliver_order` and find "
"it. Success! We think the `back_of_house` module and the `deliver_order` "
"function are likely to stay in the same relationship to each other and get "
"moved together should we decide to reorganize the crate’s module tree. "
"Therefore, we used `super` so we’ll have fewer places to update code in the "
"future if this code gets moved to a different module."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:339
msgid "Making Structs and Enums Public"
msgstr "구조체와 열거형을 공개로 만들기"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:341
msgid ""
"We can also use `pub` to designate structs and enums as public, but there "
"are a few extra details to the usage of `pub` with structs and enums. If we "
"use `pub` before a struct definition, we make the struct public, but the "
"struct’s fields will still be private. We can make each field public or not "
"on a case-by-case basis. In Listing 7-9, we’ve defined a public "
"`back_of_house::Breakfast` struct with a public `toast` field but a private "
"`seasonal_fruit` field. This models the case in a restaurant where the "
"customer can pick the type of bread that comes with a meal, but the chef "
"decides which fruit accompanies the meal based on what’s in season and in "
"stock. The available fruit changes quickly, so customers can’t choose the "
"fruit or even see which fruit they’ll get."
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:365
msgid "\"peaches\""
msgstr ""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:372
msgid "// Order a breakfast in the summer with Rye toast.\n"
msgstr "// 호밀 토스트와 함께 여름 아침 식사를 주문하세요.\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:373
msgid "\"Rye\""
msgstr "\"호밀\""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:374
msgid "// Change our mind about what bread we'd like.\n"
msgstr "// 어떤 빵을 먹을지 마음을 바꿉니다.\n"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:375
msgid "\"Wheat\""
msgstr "\"밀\""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:376
msgid "\"I'd like {} toast please\""
msgstr "\"{} 토스트 부탁드립니다\""

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:378
msgid ""
"// The next line won't compile if we uncomment it; we're not allowed\n"
"    // to see or modify the seasonal fruit that comes with the meal.\n"
"    // meal.seasonal_fruit = String::from(\"blueberries\");\n"
msgstr "// 다음 줄은 주석을 해제하면 컴파일되지 않습니다. 우리는 식사와 함께 제공되는\n    // 제철 과일을 보거나 수정할 수 없습니다.\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n"


#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:386
msgid ""
"Because the `toast` field in the `back_of_house::Breakfast` struct is "
"public, in `eat_at_restaurant` we can write and read to the `toast` field "
"using dot notation. Notice that we can’t use the `seasonal_fruit` field in "
"`eat_at_restaurant`, because `seasonal_fruit` is private. Try uncommenting "
"the line modifying the `seasonal_fruit` field value to see what error you "
"get!"
msgstr "`back_of_house::Breakfast` 구조체의 `toast` 필드는 공개(public)이므로, `eat_at_restaurant`에서 점 표기법을 사용하여 `toast` 필드에 쓰고 읽을 수 있습니다. `seasonal_fruit` 필드는 비공개(private)이므로 `eat_at_restaurant`에서 사용할 수 없다는 점에 유의하세요. `seasonal_fruit` 필드 값을 수정하는 줄의 주석을 해제하여 어떤 오류가 발생하는지 확인해 보세요!"

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:392
msgid ""
"Also, note that because `back_of_house::Breakfast` has a private field, the "
"struct needs to provide a public associated function that constructs an "
"instance of `Breakfast` (we’ve named it `summer` here). If `Breakfast` "
"didn’t have such a function, we couldn’t create an instance of `Breakfast` "
"in `eat_at_restaurant` because we couldn’t set the value of the private "
"`seasonal_fruit` field in `eat_at_restaurant`."
msgstr "또한, `back_of_house::Breakfast`에 비공개 필드가 있기 때문에, 구조체는 `Breakfast`의 인스턴스를 구성하는 공개 연관 함수를 제공해야 한다는 점에 유의하세요 (여기서는 `summer`라고 이름 붙였습니다). 만약 `Breakfast`에 그러한 함수가 없었다면, `eat_at_restaurant`에서 비공개 `seasonal_fruit` 필드의 값을 설정할 수 없었기 때문에 `eat_at_restaurant`에서 `Breakfast`의 인스턴스를 생성할 수 없었을 것입니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:399
msgid ""
"In contrast, if we make an enum public, all of its variants are then public. "
"We only need the `pub` before the `enum` keyword, as shown in Listing 7-10."
msgstr "대조적으로, 열거형을 공개(public)로 만들면 모든 variant가 공개됩니다. 목록 7-10에 표시된 것처럼 `enum` 키워드 앞에 `pub`만 있으면 됩니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:420
msgid ""
"Because we made the `Appetizer` enum public, we can use the `Soup` and "
"`Salad` variants in `eat_at_restaurant`."
msgstr "`Appetizer` 열거형을 공개로 만들었기 때문에, `eat_at_restaurant`에서 `Soup`과 `Salad` variant를 사용할 수 있습니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:423
msgid ""
"Enums aren’t very useful unless their variants are public; it would be "
"annoying to have to annotate all enum variants with `pub` in every case, so "
"the default for enum variants is to be public. Structs are often useful "
"without their fields being public, so struct fields follow the general rule "
"of everything being private by default unless annotated with `pub`."
msgstr "열거형은 variant가 공개되지 않으면 그다지 유용하지 않습니다. 모든 경우에 모든 열거형 variant에 `pub`을 명시해야 한다면 번거로울 것이므로, 열거형 variant의 기본값은 공개입니다. 구조체는 필드가 공개되지 않아도 유용한 경우가 많으므로, 구조체 필드는 `pub`으로 명시되지 않는 한 모든 것이 기본적으로 비공개라는 일반적인 규칙을 따릅니다."

#: src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md:429
msgid ""
"There’s one more situation involving `pub` that we haven’t covered, and that "
"is our last module system feature: the `use` keyword. We’ll cover `use` by "
"itself first, and then we’ll show how to combine `pub` and `use`."
msgstr "`pub`과 관련된 한 가지 더 다루지 않은 상황이 있는데, 그것은 우리의 마지막 모듈 시스템 기능인 `use` 키워드입니다. 먼저 `use` 자체를 다룬 다음, `pub`과 `use`를 결합하는 방법을 보여줄 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr "`use` 키워드로 경로를 스코프로 가져오기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. In Listing 7-7, whether we chose the absolute or relative path "
"to the `add_to_waitlist` function, every time we wanted to call "
"`add_to_waitlist` we had to specify `front_of_house` and `hosting` too. "
"Fortunately, there’s a way to simplify this process: we can create a "
"shortcut to a path with the `use` keyword once, and then use the shorter "
"name everywhere else in the scope."
msgstr "함수를 호출하기 위해 경로를 모두 작성하는 것은 불편하고 반복적일 수 있습니다. 목록 7-7에서 `add_to_waitlist` 함수에 대한 절대 경로 또는 상대 경로를 선택했든 상관없이, `add_to_waitlist`를 호출할 때마다 `front_of_house`와 `hosting`도 지정해야 했습니다. 다행히 이 과정을 단순화하는 방법이 있습니다. `use` 키워드를 사용하여 경로에 대한 단축키를 한 번 생성한 다음, 스코프의 다른 모든 곳에서 더 짧은 이름을 사용할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
msgid ""
"In Listing 7-11, we bring the `crate::front_of_house::hosting` module into "
"the scope of the `eat_at_restaurant` function so we only have to specify "
"`hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr "목록 7-11에서 `crate::front_of_house::hosting` 모듈을 `eat_at_restaurant` 함수의 스코프로 가져와서, `eat_at_restaurant` 함수에서 `add_to_waitlist` 함수를 호출하기 위해 `hosting::add_to_waitlist`만 지정하면 됩니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use crate::front_of_house::hosting` in the crate "
"root, `hosting` is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root. Paths brought into "
"scope with `use` also check privacy, like any other paths."
msgstr "스코프에 `use`와 경로를 추가하는 것은 파일 시스템에 심볼릭 링크를 생성하는 것과 유사합니다. 크레이트 루트에 `use crate::front_of_house::hosting`을 추가하면, `hosting`은 이제 해당 스코프에서 유효한 이름이 됩니다. 마치 `hosting` 모듈이 크레이트 루트에 정의된 것처럼 말이죠. `use`로 스코프로 가져온 경로는 다른 경로와 마찬가지로 프라이버시도 확인합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:39
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-12 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile."
msgstr "`use`는 `use`가 발생하는 특정 스코프에 대해서만 단축키를 생성한다는 점에 유의하세요. 목록 7-12는 `eat_at_restaurant` 함수를 `customer`라는 새 자식 모듈로 이동시키는데, 이 모듈은 `use` 문과는 다른 스코프이므로 함수 본문은 컴파일되지 않을 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:64
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr "컴파일러 오류는 단축키가 `customer` 모듈 내에서 더 이상 적용되지 않음을 보여줍니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:67
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0433]: failed to resolve: use of undeclared crate or module "
"`hosting`\n"
"  --> src/lib.rs:11:9\n"
"   |\n"
"11 |         hosting::add_to_waitlist();\n"
"   |         ^^^^^^^ use of undeclared crate or module `hosting`\n"
"   |\n"
"help: consider importing this module through its public re-export\n"
"   |\n"
"10 +     use crate::hosting;\n"
"   |\n"
"\n"
"warning: unused import: `crate::front_of_house::hosting`\n"
" --> src/lib.rs:7:5\n"
"  |\n"
"7 | use crate::front_of_house::hosting;\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: `#[warn(unused_imports)]` on by default\n"
"\n"
"For more information about this error, try `rustc --explain E0433`.\n"
"warning: `restaurant` (lib) generated 1 warning\n"
"error: could not compile `restaurant` (lib) due to 1 previous error; 1 "
"warning emitted\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:94
msgid ""
"Notice there’s also a warning that the `use` is no longer used in its scope! "
"To fix this problem, move the `use` within the `customer` module too, or "
"reference the shortcut in the parent module with `super::hosting` within the "
"child `customer` module."
msgstr "또한 `use`가 해당 스코프에서 더 이상 사용되지 않는다는 경고도 있습니다! 이 문제를 해결하려면 `use`를 `customer` 모듈 안으로 이동하거나, 자식 `customer` 모듈 내에서 `super::hosting`으로 부모 모듈의 단축키를 참조하세요."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:99
msgid "Creating Idiomatic `use` Paths"
msgstr "관용적인 `use` 경로 생성하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:101
msgid ""
"In Listing 7-11, you might have wondered why we specified `use "
"crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` "
"in `eat_at_restaurant`, rather than specifying the `use` path all the way "
"out to the `add_to_waitlist` function to achieve the same result, as in "
"Listing 7-13."
msgstr "목록 7-11에서 `use crate::front_of_house::hosting`을 지정한 다음 `eat_at_restaurant`에서 `hosting::add_to_waitlist`를 호출한 이유가 궁금했을 수도 있습니다. 목록 7-13에서처럼 동일한 결과를 얻기 위해 `add_to_waitlist` 함수까지 `use` 경로를 모두 지정하지 않은 이유 말입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:124
msgid ""
"Although both Listing 7-11 and Listing 7-13 accomplish the same task, "
"Listing 7-11 is the idiomatic way to bring a function into scope with `use`. "
"Bringing the function’s parent module into scope with `use` means we have to "
"specify the parent module when calling the function. Specifying the parent "
"module when calling the function makes it clear that the function isn’t "
"locally defined while still minimizing repetition of the full path. The code "
"in Listing 7-13 is unclear as to where `add_to_waitlist` is defined."
msgstr "목록 7-11과 목록 7-13 모두 동일한 작업을 수행하지만, 목록 7-11은 `use`를 사용하여 함수를 스코프로 가져오는 관용적인 방법입니다. 함수의 부모 모듈을 `use`로 스코프로 가져오는 것은 함수를 호출할 때 부모 모듈을 지정해야 함을 의미합니다. 함수를 호출할 때 부모 모듈을 지정하면 함수가 로컬에서 정의되지 않았음을 명확히 하면서도 전체 경로의 반복을 최소화할 수 있습니다. 목록 7-13의 코드는 `add_to_waitlist`가 어디에 정의되었는지 불분명합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:132
msgid ""
"On the other hand, when bringing in structs, enums, and other items with "
"`use`, it’s idiomatic to specify the full path. Listing 7-14 shows the "
"idiomatic way to bring the standard library’s `HashMap` struct into the "
"scope of a binary crate."
msgstr "반면에, `use`를 사용하여 구조체, 열거형 및 기타 항목을 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 목록 7-14는 표준 라이브러리의 `HashMap` 구조체를 바이너리 크레이트의 스코프로 가져오는 관용적인 방법을 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:150
msgid ""
"There’s no strong reason behind this idiom: it’s just the convention that "
"has emerged, and folks have gotten used to reading and writing Rust code "
"this way."
msgstr "이러한 관용구 뒤에는 강력한 이유가 없습니다. 단지 나타난 관례이며, 사람들은 이런 방식으로 러스트 코드를 읽고 쓰는 데 익숙해졌을 뿐입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:153
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Rust doesn’t allow that. "
"Listing 7-15 shows how to bring two `Result` types into scope that have the "
"same name but different parent modules, and how to refer to them."
msgstr "이 관용구의 예외는 `use` 문으로 동일한 이름을 가진 두 항목을 스코프로 가져오는 경우입니다. 러스트는 이를 허용하지 않기 때문입니다. 목록 7-15는 동일한 이름을 가졌지만 부모 모듈이 다른 두 `Result` 타입을 스코프로 가져오는 방법과 이를 참조하는 방법을 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:177
msgid ""
"As you can see, using the parent modules distinguishes the two `Result` "
"types. If instead we specified `use std::fmt::Result` and `use "
"std::io::Result`, we’d have two `Result` types in the same scope, and Rust "
"wouldn’t know which one we meant when we used `Result`."
msgstr "보시다시피, 부모 모듈을 사용하면 두 `Result` 타입을 구별할 수 있습니다. 만약 `use std::fmt::Result`와 `use std::io::Result`를 대신 지정했다면, 동일한 스코프에 두 개의 `Result` 타입이 있게 되어 러스트는 `Result`를 사용했을 때 어떤 것을 의미하는지 알 수 없을 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:182
msgid "Providing New Names with the `as` Keyword"
msgstr "`as` 키워드로 새 이름 제공하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:184
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: after the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-16 shows another way "
"to write the code in Listing 7-15 by renaming one of the two `Result` types "
"using `as`."
msgstr "`use`를 사용하여 동일한 이름의 두 타입을 동일한 스코프로 가져오는 문제에 대한 또 다른 해결책이 있습니다. 경로 뒤에 `as`와 타입에 대한 새 로컬 이름 또는 _별칭_을 지정할 수 있습니다. 목록 7-16은 `as`를 사용하여 두 `Result` 타입 중 하나를 이름을 변경함으로써 목록 7-15의 코드를 작성하는 또 다른 방법을 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:208
msgid ""
"In the second `use` statement, we chose the new name `IoResult` for the "
"`std::io::Result` type, which won’t conflict with the `Result` from "
"`std::fmt` that we’ve also brought into scope. Listing 7-15 and Listing 7-16 "
"are considered idiomatic, so the choice is up to you!"
msgstr "두 번째 `use` 문에서 우리는 `std::io::Result` 타입에 대해 `IoResult`라는 새 이름을 선택했습니다. 이는 우리가 스코프로 가져온 `std::fmt`의 `Result`와 충돌하지 않을 것입니다. 목록 7-15와 목록 7-16은 관용적인 것으로 간주되므로 선택은 당신에게 달려 있습니다!"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:213
msgid "Re-exporting Names with `pub use`"
msgstr "`pub use`로 이름 재내보내기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:215
msgid ""
"When we bring a name into scope with the `use` keyword, the name available "
"in the new scope is private. To enable the code that calls our code to refer "
"to that name as if it had been defined in that code’s scope, we can combine "
"`pub` and `use`. This technique is called _re-exporting_ because we’re "
"bringing an item into scope but also making that item available for others "
"to bring into their scope."
msgstr "`use` 키워드로 이름을 스코프로 가져오면, 새 스코프에서 사용 가능한 이름은 비공개입니다. 우리 코드를 호출하는 코드가 마치 그 코드의 스코프에서 정의된 것처럼 그 이름을 참조할 수 있도록 하려면 `pub`과 `use`를 결합할 수 있습니다. 이 기술을 _재내보내기_라고 하는데, 항목을 스코프로 가져오면서도 다른 사람들이 자신의 스코프로 가져올 수 있도록 해당 항목을 사용할 수 있게 만들기 때문입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:222
msgid ""
"Listing 7-17 shows the code in Listing 7-11 with `use` in the root module "
"changed to `pub use`."
msgstr "목록 7-17은 루트 모듈의 `use`가 `pub use`로 변경된 목록 7-11의 코드를 보여줍니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:243
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path "
"`restaurant::front_of_house::hosting::add_to_waitlist()`, which also would "
"have required the `front_of_house` module to be marked as `pub`. Now that "
"this `pub use` has re-exported the `hosting` module from the root module, "
"external code can use the path `restaurant::hosting::add_to_waitlist()` "
"instead."
msgstr "이 변경 전에는 외부 코드가 `restaurant::front_of_house::hosting::add_to_waitlist()` 경로를 사용하여 `add_to_waitlist` 함수를 호출해야 했으며, 이는 `front_of_house` 모듈도 `pub`으로 표시되어야 했을 것입니다. 이제 이 `pub use`가 루트 모듈에서 `hosting` 모듈을 재내보냈으므로, 외부 코드는 대신 `restaurant::hosting::add_to_waitlist()` 경로를 사용할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:250
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library. "
"We’ll look at another example of `pub use` and how it affects your crate’s "
"documentation in [“Exporting a Convenient Public API with `pub use`”]"
"(ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-"
"pub-use)<!-- ignore --> in Chapter 14."
msgstr "재내보내기는 코드의 내부 구조가 코드를 호출하는 프로그래머가 도메인에 대해 생각하는 방식과 다를 때 유용합니다. 예를 들어, 이 레스토랑 비유에서 레스토랑을 운영하는 사람들은 \"프론트 오브 하우스\"와 \"백 오브 하우스\"에 대해 생각합니다. 하지만 레스토랑을 방문하는 고객들은 아마도 그런 용어로 레스토랑의 부분을 생각하지 않을 것입니다. `pub use`를 사용하면 하나의 구조로 코드를 작성하면서도 다른 구조를 노출할 수 있습니다. 이렇게 하면 라이브러리에서 작업하는 프로그래머와 라이브러리를 호출하는 프로그래머 모두에게 라이브러리가 잘 조직됩니다. 14장의 [“`pub use`로 편리한 공개 API 내보내기”](ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use)<!-- ignore -->에서 `pub use`의 또 다른 예와 그것이 크레이트 문서에 미치는 영향을 살펴볼 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:261
msgid "Using External Packages"
msgstr "외부 패키지 사용하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:263
msgid ""
"In Chapter 2, we programmed a guessing game project that used an external "
"package called `rand` to get random numbers. To use `rand` in our project, "
"we added this line to _Cargo.toml_:"
msgstr "2장에서 우리는 `rand`라는 외부 패키지를 사용하여 난수를 얻는 추측 게임 프로젝트를 프로그래밍했습니다. 프로젝트에서 `rand`를 사용하기 위해 _Cargo.toml_에 다음 줄을 추가했습니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:275
msgid ""
"```toml\n"
"rand = \"0.8.5\"\n"
"```"
msgstr ""
"```toml\n"
"rand = \"0.8.5\"\n"
"```"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:281
msgid ""
"Adding `rand` as a dependency in _Cargo.toml_ tells Cargo to download the "
"`rand` package and any dependencies from [crates.io](https://crates.io/) and "
"make `rand` available to our project."
msgstr "_Cargo.toml_에 `rand`를 의존성으로 추가하면 Cargo는 `rand` 패키지와 [crates.io](https://crates.io/)에서 모든 의존성을 다운로드하고 `rand`를 우리 프로젝트에서 사용할 수 있도록 합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:285

msgid ""

"Then, to bring `rand` definitions into the scope of our package, we added a "

"`use` line starting with the name of the crate, `rand`, and listed the items "

"we wanted to bring into scope. Recall that in [“Generating a Random Number”] "

"(ch02-00-guessing-game-tutorial.html#generating-a-random-number)<!-- ignore "

"--> in Chapter 2, we brought the `Rng` trait into scope and called the "

"`rand::thread_rng` function:"

msgstr "그런 다음, `rand` 정의를 우리 패키지의 스코프로 가져오기 위해, 크레이트 이름인 `rand`로 시작하는 `use` 줄을 추가하고 스코프로 가져오고 싶은 항목들을 나열했습니다. 2장의 [“난수 생성하기”](ch02-00-guessing-game-tutorial.html#generating-a-random-number)<!-- ignore -->에서 `Rng` 트레이트를 스코프로 가져오고 `rand::thread_rng` 함수를 호출했던 것을 기억하세요:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:314
msgid ""
"Members of the Rust community have made many packages available at "
"[crates.io](https://crates.io/), and pulling any of them into your package "
"involves these same steps: listing them in your package’s _Cargo.toml_ file "
"and using `use` to bring items from their crates into scope."
msgstr "러스트 커뮤니티 구성원들은 [crates.io](https://crates.io/)에 많은 패키지를 제공했으며, 이들 중 어떤 것이든 당신의 패키지로 가져오는 것은 동일한 단계를 포함합니다: 패키지의 _Cargo.toml_ 파일에 나열하고 `use`를 사용하여 해당 크레이트의 항목을 스코프로 가져오는 것입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:319
msgid ""
"Note that the standard `std` library is also a crate that’s external to our "
"package. Because the standard library is shipped with the Rust language, we "
"don’t need to change _Cargo.toml_ to include `std`. But we do need to refer "
"to it with `use` to bring items from there into our package’s scope. For "
"example, with `HashMap` we would use this line:"
msgstr "표준 라이브러리 `std`도 우리 패키지 외부에 있는 크레이트라는 점에 유의하세요. 표준 라이브러리는 러스트 언어와 함께 제공되므로, _Cargo.toml_을 변경하여 `std`를 포함할 필요는 없습니다. 하지만 `use`를 사용하여 거기서 항목을 우리 패키지의 스코프로 가져와야 합니다. 예를 들어, `HashMap`의 경우 이 줄을 사용할 것입니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:329
msgid ""
"This is an absolute path starting with `std`, the name of the standard "
"library crate."
msgstr "이것은 표준 라이브러리 크레이트의 이름인 `std`로 시작하는 절대 경로입니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:332
msgid "Using Nested Paths to Clean Up Large `use` Lists"
msgstr "중첩 경로를 사용하여 긴 `use` 목록 정리하기"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:334
msgid ""
"If we’re using multiple items defined in the same crate or same module, "
"listing each item on its own line can take up a lot of vertical space in our "
"files. For example, these two `use` statements we had in the guessing game "
"in Listing 2-4 bring items from `std` into scope:"
msgstr "동일한 크레이트 또는 동일한 모듈에 정의된 여러 항목을 사용하는 경우, 각 항목을 자체 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 목록 2-4의 추측 게임에서 사용했던 이 두 `use` 문은 `std`의 항목을 스코프로 가져옵니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:375
msgid ""
"Instead, we can use nested paths to bring the same items into scope in one "
"line. We do this by specifying the common part of the path, followed by two "
"colons, and then curly brackets around a list of the parts of the paths that "
"differ, as shown in Listing 7-18."
msgstr "대신, 중첩 경로를 사용하여 동일한 항목을 한 줄로 스코프로 가져올 수 있습니다. 이는 경로의 공통 부분을 지정하고, 이중 콜론을 붙인 다음, 목록 7-18에 표시된 것처럼 다른 경로 부분 목록을 중괄호로 묶어 수행합니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:417
msgid ""
"In bigger programs, bringing many items into scope from the same crate or "
"module using nested paths can reduce the number of separate `use` statements "
"needed by a lot!"
msgstr "더 큰 프로그램에서는 중첩 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 스코프로 가져오면 필요한 개별 `use` 문의 수를 크게 줄일 수 있습니다!"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:421
msgid ""
"We can use a nested path at any level in a path, which is useful when "
"combining two `use` statements that share a subpath. For example, Listing "
"7-19 shows two `use` statements: one that brings `std::io` into scope and "
"one that brings `std::io::Write` into scope."
msgstr "경로의 어떤 수준에서든 중첩 경로를 사용할 수 있으며, 이는 하위 경로를 공유하는 두 `use` 문을 결합할 때 유용합니다. 예를 들어, 목록 7-19는 두 개의 `use` 문을 보여줍니다. 하나는 `std::io`를 스코프로 가져오고, 다른 하나는 `std::io::Write`를 스코프로 가져옵니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:435
msgid ""
"The common part of these two paths is `std::io`, and that’s the complete "
"first path. To merge these two paths into one `use` statement, we can use "
"`self` in the nested path, as shown in Listing 7-20."
msgstr "이 두 경로의 공통 부분은 `std::io`이며, 이것이 완전한 첫 번째 경로입니다. 이 두 경로를 하나의 `use` 문으로 병합하려면, 목록 7-20에 표시된 것처럼 중첩 경로에서 `self`를 사용할 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:447
msgid "This line brings `std::io` and `std::io::Write` into scope."
msgstr "이 줄은 `std::io`와 `std::io::Write`를 스코프로 가져옵니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:449
msgid "The Glob Operator"
msgstr "글로브 연산자"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:451
msgid ""
"If we want to bring _all_ public items defined in a path into scope, we can "
"specify that path followed by the `*` glob operator:"
msgstr "경로에 정의된 _모든_ 공개 항목을 스코프로 가져오려면, 해당 경로 뒤에 `*` 글로브 연산자를 지정할 수 있습니다:"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:458
msgid ""
"This `use` statement brings all public items defined in `std::collections` "
"into the current scope. Be careful when using the glob operator! Glob can "
"make it harder to tell what names are in scope and where a name used in your "
"program was defined."
msgstr "이 `use` 문은 `std::collections`에 정의된 모든 공개 항목을 현재 스코프로 가져옵니다. 글로브 연산자를 사용할 때는 주의하세요! 글로브는 어떤 이름이 스코프에 있고 프로그램에서 사용된 이름이 어디에 정의되었는지 파악하기 어렵게 만들 수 있습니다."

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:463

msgid ""

"The glob operator is often used when testing to bring everything under test "

"into the `tests` module; we’ll talk about that in [“How to Write Tests”] "

"(ch11-01-writing-tests.html#how-to-write-tests)<!-- ignore --> in Chapter "

"11. The glob operator is also sometimes used as part of the prelude pattern: "

"see [the standard library documentation](../std/prelude/index.html#other-"

"preludes)<!-- ignore --> for more information on that pattern."

msgstr "글로브 연산자는 테스트 시 `tests` 모듈로 테스트 대상의 모든 것을 가져올 때 자주 사용됩니다. 이에 대해서는 11장의 [“테스트 작성 방법”](ch11-01-writing-tests.html#how-to-write-tests)<!-- ignore -->에서 다룰 것입니다. 글로브 연산자는 때때로 프렐류드 패턴의 일부로도 사용됩니다. 해당 패턴에 대한 자세한 내용은 [표준 라이브러리 문서](../std/prelude/index.html#other-preludes)<!-- ignore -->를 참조하세요."

#: src/ch07-05-separating-modules-into-different-files.md:3
msgid ""
"So far, all the examples in this chapter defined multiple modules in one "
"file. When modules get large, you might want to move their definitions to a "
"separate file to make the code easier to navigate."
msgstr "지금까지 이 장의 모든 예제는 하나의 파일에 여러 모듈을 정의했습니다. 모듈이 커지면 코드를 더 쉽게 탐색할 수 있도록 정의를 별도의 파일로 옮기고 싶을 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:7
msgid ""
"For example, let’s start from the code in Listing 7-17 that had multiple "
"restaurant modules. We’ll extract modules into files instead of having all "
"the modules defined in the crate root file. In this case, the crate root "
"file is _src/lib.rs_, but this procedure also works with binary crates whose "
"crate root file is _src/main.rs_."
msgstr "예를 들어, 여러 레스토랑 모듈을 가졌던 목록 7-17의 코드부터 시작해 봅시다. 모든 모듈을 크레이트 루트 파일에 정의하는 대신 모듈을 파일로 추출할 것입니다. 이 경우 크레이트 루트 파일은 _src/lib.rs_이지만, 이 절차는 크레이트 루트 파일이 _src/main.rs_인 바이너리 크레이트에서도 작동합니다."

#: src/ch07-05-separating-modules-into-different-files.md:13
msgid ""
"First we’ll extract the `front_of_house` module to its own file. Remove the "
"code inside the curly brackets for the `front_of_house` module, leaving only "
"the `mod front_of_house;` declaration, so that _src/lib.rs_ contains the "
"code shown in Listing 7-21. Note that this won’t compile until we create the "
"_src/front_of_house.rs_ file in Listing 7-22."
msgstr "먼저 `front_of_house` 모듈을 자체 파일로 추출할 것입니다. `front_of_house` 모듈의 중괄호 안의 코드를 제거하고 `mod front_of_house;` 선언만 남겨서 _src/lib.rs_가 목록 7-21에 표시된 코드를 포함하도록 합니다. 목록 7-22에서 _src/front_of_house.rs_ 파일을 생성하기 전까지는 컴파일되지 않을 것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:33
msgid ""
"Next, place the code that was in the curly brackets into a new file named "
"_src/front_of_house.rs_, as shown in Listing 7-22. The compiler knows to "
"look in this file because it came across the module declaration in the crate "
"root with the name `front_of_house`."
msgstr "다음으로, 중괄호 안에 있던 코드를 목록 7-22에 표시된 것처럼 _src/front_of_house.rs_라는 새 파일에 배치합니다. 컴파일러는 크레이트 루트에서 `front_of_house`라는 이름의 모듈 선언을 발견했기 때문에 이 파일을 찾아볼 것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:48
msgid ""
"Note that you only need to load a file using a `mod` declaration _once_ in "
"your module tree. Once the compiler knows the file is part of the project "
"(and knows where in the module tree the code resides because of where you’ve "
"put the `mod` statement), other files in your project should refer to the "
"loaded file’s code using a path to where it was declared, as covered in the "
"[“Paths for Referring to an Item in the Module Tree”](ch07-03-paths-for-"
"referring-to-an-item-in-the-module-tree.html)<!-- ignore --> section. In "
"other words, `mod` is _not_ an “include” operation that you may have seen in "
"other programming languages."
msgstr "모듈 트리에서 `mod` 선언을 사용하여 파일을 _한 번만_ 로드하면 된다는 점에 유의하세요. 컴파일러가 파일이 프로젝트의 일부임을 알게 되면 (그리고 `mod` 문을 어디에 두었는지 때문에 모듈 트리에서 코드가 어디에 있는지 알게 되면), 프로젝트의 다른 파일은 [“모듈 트리에서 항목을 참조하는 경로”](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore --> 섹션에서 다룬 것처럼 선언된 경로를 사용하여 로드된 파일의 코드를 참조해야 합니다. 즉, `mod`는 다른 프로그래밍 언어에서 보았을 수 있는 \"include\" 연산이 _아닙니다_."

#: src/ch07-05-separating-modules-into-different-files.md:57
msgid ""
"Next, we’ll extract the `hosting` module to its own file. The process is a "
"bit different because `hosting` is a child module of `front_of_house`, not "
"of the root module. We’ll place the file for `hosting` in a new directory "
"that will be named for its ancestors in the module tree, in this case _src/"
"front_of_house_."
msgstr "다음으로, `hosting` 모듈을 자체 파일로 추출할 것입니다. `hosting`은 루트 모듈이 아닌 `front_of_house`의 자식 모듈이므로 과정이 약간 다릅니다. `hosting` 파일을 모듈 트리에서 그 조상들의 이름을 따서 명명될 새 디렉토리, 이 경우 _src/front_of_house_에 배치할 것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:62
msgid ""
"To start moving `hosting`, we change _src/front_of_house.rs_ to contain only "
"the declaration of the `hosting` module:"
msgstr "`hosting`을 이동하기 시작하려면, _src/front_of_house.rs_를 `hosting` 모듈의 선언만 포함하도록 변경합니다:"

#: src/ch07-05-separating-modules-into-different-files.md:73
msgid ""
"Then we create a _src/front_of_house_ directory and a _hosting.rs_ file to "
"contain the definitions made in the `hosting` module:"
msgstr "그런 다음 _src/front_of_house_ 디렉토리와 _hosting.rs_ 파일을 생성하여 `hosting` 모듈에 정의된 내용을 포함하도록 합니다:"

#: src/ch07-05-separating-modules-into-different-files.md:84
msgid ""
"If we instead put _hosting.rs_ in the _src_ directory, the compiler would "
"expect the _hosting.rs_ code to be in a `hosting` module declared in the "
"crate root, and not declared as a child of the `front_of_house` module. The "
"compiler’s rules for which files to check for which modules’ code mean the "
"directories and files more closely match the module tree."
msgstr "만약 _hosting.rs_를 _src_ 디렉토리에 넣었다면, 컴파일러는 _hosting.rs_ 코드가 크레이트 루트에 선언된 `hosting` 모듈에 있을 것으로 예상하고, `front_of_house` 모듈의 자식으로 선언되지 않을 것입니다. 컴파일러가 어떤 모듈의 코드를 어떤 파일에서 찾아야 하는지에 대한 규칙은 디렉토리와 파일이 모듈 트리와 더 밀접하게 일치한다는 것을 의미합니다."

#: src/ch07-05-separating-modules-into-different-files.md:90
msgid "Alternate File Paths"
msgstr "대체 파일 경로"

#: src/ch07-05-separating-modules-into-different-files.md:92
msgid ""
"So far we’ve covered the most idiomatic file paths the Rust compiler uses, "
"but Rust also supports an older style of file path. For a module named "
"`front_of_house` declared in the crate root, the compiler will look for the "
"module’s code in:"
msgstr "지금까지 러스트 컴파일러가 사용하는 가장 관용적인 파일 경로를 다루었지만, 러스트는 또한 오래된 스타일의 파일 경로도 지원합니다. 크레이트 루트에 선언된 `front_of_house`라는 이름의 모듈의 경우, 컴파일러는 다음 위치에서 모듈의 코드를 찾을 것입니다:"

#: src/ch07-05-separating-modules-into-different-files.md:97
msgid "_src/front_of_house.rs_ (what we covered)"
msgstr "_src/front_of_house.rs_ (우리가 다룬 내용)"

#: src/ch07-05-separating-modules-into-different-files.md:98
msgid "_src/front_of_house/mod.rs_ (older style, still supported path)"
msgstr "_src/front_of_house/mod.rs_ (오래된 스타일, 여전히 지원되는 경로)"

#: src/ch07-05-separating-modules-into-different-files.md:100
msgid ""
"For a module named `hosting` that is a submodule of `front_of_house`, the "
"compiler will look for the module’s code in:"
msgstr "`front_of_house`의 하위 모듈인 `hosting`이라는 이름의 모듈의 경우, 컴파일러는 다음 위치에서 모듈의 코드를 찾을 것입니다:"

#: src/ch07-05-separating-modules-into-different-files.md:103
msgid "_src/front_of_house/hosting.rs_ (what we covered)"
msgstr "_src/front_of_house/hosting.rs_ (우리가 다룬 내용)"

#: src/ch07-05-separating-modules-into-different-files.md:104
msgid "_src/front_of_house/hosting/mod.rs_ (older style, still supported path)"
msgstr "_src/front_of_house/hosting/mod.rs_ (오래된 스타일, 여전히 지원되는 경로)"

#: src/ch07-05-separating-modules-into-different-files.md:106
msgid ""
"If you use both styles for the same module, you’ll get a compiler error. "
"Using a mix of both styles for different modules in the same project is "
"allowed, but might be confusing for people navigating your project."
msgstr "동일한 모듈에 두 가지 스타일을 모두 사용하면 컴파일러 오류가 발생합니다. 동일한 프로젝트 내에서 다른 모듈에 두 가지 스타일을 혼합하여 사용하는 것은 허용되지만, 프로젝트를 탐색하는 사람들에게 혼란을 줄 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:110
msgid ""
"The main downside to the style that uses files named _mod.rs_ is that your "
"project can end up with many files named _mod.rs_, which can get confusing "
"when you have them open in your editor at the same time."
msgstr "_mod.rs_라는 이름의 파일을 사용하는 스타일의 주요 단점은 프로젝트에 _mod.rs_라는 이름의 파일이 많아질 수 있으며, 이를 편집기에서 동시에 열어두면 혼란스러울 수 있다는 것입니다."

#: src/ch07-05-separating-modules-into-different-files.md:114
msgid ""
"We’ve moved each module’s code to a separate file, and the module tree "
"remains the same. The function calls in `eat_at_restaurant` will work "
"without any modification, even though the definitions live in different "
"files. This technique lets you move modules to new files as they grow in "
"size."
msgstr "각 모듈의 코드를 별도의 파일로 옮겼으며, 모듈 트리는 동일하게 유지됩니다. 정의가 다른 파일에 있더라도 `eat_at_restaurant`의 함수 호출은 수정 없이 작동할 것입니다. 이 기술을 사용하면 모듈의 크기가 커짐에 따라 새 파일로 이동할 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:119
msgid ""
"Note that the `pub use crate::front_of_house::hosting` statement in _src/"
"lib.rs_ also hasn’t changed, nor does `use` have any impact on what files "
"are compiled as part of the crate. The `mod` keyword declares modules, and "
"Rust looks in a file with the same name as the module for the code that goes "
"into that module."
msgstr "_src/lib.rs_의 `pub use crate::front_of_house::hosting` 문도 변경되지 않았으며, `use`는 크레이트의 일부로 컴파일되는 파일에 어떤 영향도 미치지 않는다는 점에 유의하세요. `mod` 키워드는 모듈을 선언하고, 러스트는 해당 모듈에 들어가는 코드를 모듈과 동일한 이름의 파일에서 찾습니다."

#: src/ch07-05-separating-modules-into-different-files.md:127
msgid ""
"Rust lets you split a package into multiple crates and a crate into modules "
"so you can refer to items defined in one module from another module. You can "
"do this by specifying absolute or relative paths. These paths can be brought "
"into scope with a `use` statement so you can use a shorter path for multiple "
"uses of the item in that scope. Module code is private by default, but you "
"can make definitions public by adding the `pub` keyword."
msgstr "러스트는 패키지를 여러 크레이트로, 크레이트를 모듈로 분할할 수 있도록 하여 한 모듈에 정의된 항목을 다른 모듈에서 참조할 수 있게 합니다. 절대 경로 또는 상대 경로를 지정하여 이를 수행할 수 있습니다. 이러한 경로는 `use` 문으로 스코프로 가져올 수 있으므로 해당 스코프에서 항목을 여러 번 사용할 때 더 짧은 경로를 사용할 수 있습니다. 모듈 코드는 기본적으로 비공개이지만, `pub` 키워드를 추가하여 정의를 공개로 만들 수 있습니다."

#: src/ch07-05-separating-modules-into-different-files.md:134
msgid ""
"In the next chapter, we’ll look at some collection data structures in the "
"standard library that you can use in your neatly organized code."
msgstr "다음 장에서는 깔끔하게 정리된 코드에서 사용할 수 있는 표준 라이브러리의 몇 가지 컬렉션 데이터 구조를 살펴볼 것입니다."

#: src/ch08-00-common-collections.md:3
msgid ""
"Rust’s standard library includes a number of very useful data structures "
"called _collections_. Most other data types represent one specific value, "
"but collections can contain multiple values. Unlike the built-in array and "
"tuple types, the data that these collections point to is stored on the heap, "
"which means the amount of data does not need to be known at compile time and "
"can grow or shrink as the program runs. Each kind of collection has "
"different capabilities and costs, and choosing an appropriate one for your "
"current situation is a skill you’ll develop over time. In this chapter, "
"we’ll discuss three collections that are used very often in Rust programs:"
msgstr "러스트의 표준 라이브러리에는 _컬렉션_이라고 불리는 매우 유용한 데이터 구조가 많이 포함되어 있습니다. 대부분의 다른 데이터 타입은 하나의 특정 값을 나타내지만, 컬렉션은 여러 값을 포함할 수 있습니다. 내장 배열 및 튜플 타입과 달리, 이러한 컬렉션이 가리키는 데이터는 힙에 저장됩니다. 이는 데이터 양이 컴파일 타임에 알려질 필요가 없으며 프로그램 실행 중에 커지거나 줄어들 수 있음을 의미합니다. 각 컬렉션 종류는 다른 기능과 비용을 가지며, 현재 상황에 적합한 것을 선택하는 것은 시간이 지남에 따라 개발될 기술입니다. 이 장에서는 러스트 프로그램에서 매우 자주 사용되는 세 가지 컬렉션을 논의할 것입니다:"

#: src/ch08-00-common-collections.md:13
msgid ""
"A _vector_ allows you to store a variable number of values next to each "
"other."
msgstr "_벡터_는 가변적인 수의 값을 서로 옆에 저장할 수 있도록 합니다."

#: src/ch08-00-common-collections.md:14
msgid ""
"A _string_ is a collection of characters. We’ve mentioned the `String` type "
"previously, but in this chapter we’ll talk about it in depth."
msgstr "_문자열_은 문자들의 컬렉션입니다. 이전에 `String` 타입에 대해 언급했지만, 이 장에서는 더 깊이 다룰 것입니다."

#: src/ch08-00-common-collections.md:16
msgid ""
"A _hash map_ allows you to associate a value with a specific key. It’s a "
"particular implementation of the more general data structure called a _map_."
msgstr "_해시 맵_은 특정 키에 값을 연관시킬 수 있도록 합니다. 이는 _맵_이라고 불리는 더 일반적인 데이터 구조의 특정 구현입니다."

#: src/ch08-00-common-collections.md:19
msgid ""
"To learn about the other kinds of collections provided by the standard "
"library, see [the documentation](../std/collections/index.html)."
msgstr "표준 라이브러리에서 제공하는 다른 종류의 컬렉션에 대해 알아보려면, [문서](../std/collections/index.html)를 참조하세요."

#: src/ch08-00-common-collections.md:22
msgid ""
"We’ll discuss how to create and update vectors, strings, and hash maps, as "
"well as what makes each special."
msgstr "벡터, 문자열, 해시 맵을 생성하고 업데이트하는 방법과 각각의 특별한 점에 대해 논의할 것입니다."

#: src/ch08-01-vectors.md:3
msgid ""
"The first collection type we’ll look at is `Vec<T>`, also known as a "
"_vector_. Vectors allow you to store more than one value in a single data "
"structure that puts all the values next to each other in memory. Vectors can "
"only store values of the same type. They are useful when you have a list of "
"items, such as the lines of text in a file or the prices of items in a "
"shopping cart."
msgstr "우리가 살펴볼 첫 번째 컬렉션 타입은 `Vec<T>`이며, _벡터_라고도 알려져 있습니다. 벡터는 메모리에서 모든 값을 서로 옆에 배치하는 단일 데이터 구조에 여러 값을 저장할 수 있도록 합니다. 벡터는 동일한 타입의 값만 저장할 수 있습니다. 파일의 텍스트 줄이나 장바구니의 항목 가격과 같이 항목 목록이 있을 때 유용합니다."

#: src/ch08-01-vectors.md:9
msgid "Creating a New Vector"
msgstr "새 벡터 생성하기"

#: src/ch08-01-vectors.md:11
msgid "To create a new empty vector, we call the `Vec::new` function, as shown in Listing 8-1."
msgstr "새로운 빈 벡터를 생성하려면, 목록 8-1에 표시된 것처럼 `Vec::new` 함수를 호출합니다."

#: src/ch08-01-vectors.md:24
msgid ""
"Note that we added a type annotation here. Because we aren’t inserting any "
"values into this vector, Rust doesn’t know what kind of elements we intend "
"to store. This is an important point. Vectors are implemented using "
"generics; we’ll cover how to use generics with your own types in Chapter 10. "
"For now, know that the `Vec<T>` type provided by the standard library can "
"hold any type. When we create a vector to hold a specific type, we can "
"specify the type within angle brackets. In Listing 8-1, we’ve told Rust that "
"the `Vec<T>` in `v` will hold elements of the `i32` type."
msgstr "여기서 타입 명시를 추가했다는 점에 유의하세요. 이 벡터에 어떤 값도 삽입하지 않기 때문에, 러스트는 우리가 어떤 종류의 요소를 저장할 의도인지 알지 못합니다. 이것은 중요한 점입니다. 벡터는 제네릭을 사용하여 구현됩니다. 10장에서 자신만의 타입으로 제네릭을 사용하는 방법을 다룰 것입니다. 지금은 표준 라이브러리에서 제공하는 `Vec<T>` 타입이 어떤 타입이든 담을 수 있다는 것만 알아두세요. 특정 타입을 담을 벡터를 생성할 때, 꺾쇠 괄호 안에 타입을 지정할 수 있습니다. 목록 8-1에서 우리는 러스트에게 `v`의 `Vec<T>`가 `i32` 타입의 요소를 담을 것이라고 알려주었습니다."

#: src/ch08-01-vectors.md:33
msgid ""
"More often, you’ll create a `Vec<T>` with initial values and Rust will infer "
"the type of value you want to store, so you rarely need to do this type "
"annotation. Rust conveniently provides the `vec!` macro, which will create a "
"new vector that holds the values you give it. Listing 8-2 creates a new "
"`Vec<i32>` that holds the values `1`, `2`, and `3`. The integer type is "
"`i32` because that’s the default integer type, as we discussed in the [“Data "
"Types”](ch03-02-data-types.html#data-types)<!-- ignore --> section of "
"Chapter 3."
msgstr "대부분의 경우, 초기 값을 사용하여 `Vec<T>`를 생성하면 러스트가 저장하려는 값의 타입을 추론하므로, 이러한 타입 명시를 할 필요는 거의 없습니다. 러스트는 편리하게 `vec!` 매크로를 제공하며, 이 매크로는 주어진 값을 담는 새 벡터를 생성합니다. 목록 8-2는 `1`, `2`, `3` 값을 담는 새 `Vec<i32>`를 생성합니다. 정수 타입은 `i32`인데, 이는 3장의 [“데이터 타입”](ch03-02-data-types.html#data-types)<!-- ignore --> 섹션에서 논의했듯이 기본 정수 타입이기 때문입니다."

#: src/ch08-01-vectors.md:51
msgid ""
"Because we’ve given initial `i32` values, Rust can infer that the type of "
"`v` is `Vec<i32>`, and the type annotation isn’t necessary. Next, we’ll look "
"at how to modify a vector."
msgstr "초기 `i32` 값을 주었기 때문에, 러스트는 `v`의 타입이 `Vec<i32>`임을 추론할 수 있으며, 타입 명시는 필요하지 않습니다. 다음으로, 벡터를 수정하는 방법을 살펴보겠습니다."

#: src/ch08-01-vectors.md:55
msgid "Updating a Vector"
msgstr "벡터 업데이트하기"

#: src/ch08-01-vectors.md:57
msgid ""
"To create a vector and then add elements to it, we can use the `push` "
"method, as shown in Listing 8-3."
msgstr ""

#: src/ch08-01-vectors.md:75
msgid ""
"As with any variable, if we want to be able to change its value, we need to "
"make it mutable using the `mut` keyword, as discussed in Chapter 3. The "
"numbers we place inside are all of type `i32`, and Rust infers this from the "
"data, so we don’t need the `Vec<i32>` annotation."
msgstr "다른 변수와 마찬가지로, 값을 변경할 수 있도록 하려면 3장에서 논의했듯이 `mut` 키워드를 사용하여 가변으로 만들어야 합니다. 우리가 안에 넣는 숫자들은 모두 `i32` 타입이며, 러스트는 이를 데이터로부터 추론하므로 `Vec<i32>` 명시가 필요 없습니다."

#: src/ch08-01-vectors.md:80
msgid "Reading Elements of Vectors"
msgstr "벡터 요소 읽기"

#: src/ch08-01-vectors.md:82
msgid ""
"There are two ways to reference a value stored in a vector: via indexing or "
"by using the `get` method. In the following examples, we’ve annotated the "
"types of the values that are returned from these functions for extra clarity."
msgstr "벡터에 저장된 값을 참조하는 방법은 인덱싱을 통하거나 `get` 메서드를 사용하는 두 가지가 있습니다. 다음 예제에서는 추가적인 명확성을 위해 이 함수들에서 반환되는 값의 타입을 명시했습니다."

#: src/ch08-01-vectors.md:86
msgid ""
"Listing 8-4 shows both methods of accessing a value in a vector, with "
"indexing syntax and the `get` method."
msgstr "목록 8-4는 인덱싱 구문과 `get` 메서드를 사용하여 벡터의 값에 접근하는 두 가지 방법을 보여줍니다."

#: src/ch08-01-vectors.md:96 src/ch08-01-vectors.md:100
msgid "\"The third element is {third}\""
msgstr ""

#: src/ch08-01-vectors.md:101
msgid "\"There is no third element.\""
msgstr ""

#: src/ch08-01-vectors.md:108
msgid ""
"Note a few details here. We use the index value of `2` to get the third "
"element because vectors are indexed by number, starting at zero. Using `&` "
"and `[]` gives us a reference to the element at the index value. When we use "
"the `get` method with the index passed as an argument, we get an "
"`Option<&T>` that we can use with `match`."
msgstr ""

#: src/ch08-01-vectors.md:114
msgid ""
"Rust provides these two ways to reference an element so you can choose how "
"the program behaves when you try to use an index value outside the range of "
"existing elements. As an example, let’s see what happens when we have a "
"vector of five elements and then we try to access an element at index 100 "
"with each technique, as shown in Listing 8-5."
msgstr ""

#: src/ch08-01-vectors.md:133
msgid ""
"When we run this code, the first `[]` method will cause the program to panic "
"because it references a nonexistent element. This method is best used when "
"you want your program to crash if there’s an attempt to access an element "
"past the end of the vector."
msgstr ""

#: src/ch08-01-vectors.md:138
msgid ""
"When the `get` method is passed an index that is outside the vector, it "
"returns `None` without panicking. You would use this method if accessing an "
"element beyond the range of the vector may happen occasionally under normal "
"circumstances. Your code will then have logic to handle having either "
"`Some(&element)` or `None`, as discussed in Chapter 6. For example, the "
"index could be coming from a person entering a number. If they accidentally "
"enter a number that’s too large and the program gets a `None` value, you "
"could tell the user how many items are in the current vector and give them "
"another chance to enter a valid value. That would be more user-friendly than "
"crashing the program due to a typo!"
msgstr ""

#: src/ch08-01-vectors.md:149
msgid ""
"When the program has a valid reference, the borrow checker enforces the "
"ownership and borrowing rules (covered in Chapter 4) to ensure this "
"reference and any other references to the contents of the vector remain "
"valid. Recall the rule that states you can’t have mutable and immutable "
"references in the same scope. That rule applies in Listing 8-6, where we "
"hold an immutable reference to the first element in a vector and try to add "
"an element to the end. This program won’t work if we also try to refer to "
"that element later in the function."
msgstr ""

#: src/ch08-01-vectors.md:168
msgid "\"The first element is: {first}\""
msgstr ""

#: src/ch08-01-vectors.md:174
msgid "Compiling this code will result in this error:"
msgstr ""

#: src/ch08-01-vectors.md:176
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"error[E0502]: cannot borrow `v` as mutable because it is also borrowed as "
"immutable\n"
" --> src/main.rs:6:5\n"
"  |\n"
"4 |     let first = &v[0];\n"
"  |                  - immutable borrow occurs here\n"
"5 |\n"
"6 |     v.push(6);\n"
"  |     ^^^^^^^^^ mutable borrow occurs here\n"
"7 |\n"
"8 |     println!(\"The first element is: {first}\");\n"
"  |                                     ------- immutable borrow later used "
"here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `collections` (bin \"collections\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch08-01-vectors.md:195
msgid ""
"The code in Listing 8-6 might look like it should work: why should a "
"reference to the first element care about changes at the end of the vector? "
"This error is due to the way vectors work: because vectors put the values "
"next to each other in memory, adding a new element onto the end of the "
"vector might require allocating new memory and copying the old elements to "
"the new space, if there isn’t enough room to put all the elements next to "
"each other where the vector is currently stored. In that case, the reference "
"to the first element would be pointing to deallocated memory. The borrowing "
"rules prevent programs from ending up in that situation."
msgstr ""

#: src/ch08-01-vectors.md:205
msgid ""
"Note: For more on the implementation details of the `Vec<T>` type, see [“The "
"Rustonomicon”](../nomicon/vec/vec.html)."
msgstr ""

#: src/ch08-01-vectors.md:208
msgid "Iterating Over the Values in a Vector"
msgstr ""

#: src/ch08-01-vectors.md:210
msgid ""
"To access each element in a vector in turn, we would iterate through all of "
"the elements rather than use indices to access one at a time. Listing 8-7 "
"shows how to use a `for` loop to get immutable references to each element in "
"a vector of `i32` values and print them."
msgstr ""

#: src/ch08-01-vectors.md:221
msgid "\"{i}\""
msgstr ""

#: src/ch08-01-vectors.md:228
msgid ""
"We can also iterate over mutable references to each element in a mutable "
"vector in order to make changes to all the elements. The `for` loop in "
"Listing 8-8 will add `50` to each element."
msgstr ""

#: src/ch08-01-vectors.md:245
msgid ""
"To change the value that the mutable reference refers to, we have to use the "
"`*` dereference operator to get to the value in `i` before we can use the "
"`+=` operator. We’ll talk more about the dereference operator in the "
"[“Following the Pointer to the Value”](ch15-02-deref.html#following-the-"
"pointer-to-the-value-with-the-dereference-operator)<!-- ignore --> section "
"of Chapter 15."
msgstr ""

#: src/ch08-01-vectors.md:250
msgid ""
"Iterating over a vector, whether immutably or mutably, is safe because of "
"the borrow checker’s rules. If we attempted to insert or remove items in the "
"`for` loop bodies in Listing 8-7 and Listing 8-8, we would get a compiler "
"error similar to the one we got with the code in Listing 8-6. The reference "
"to the vector that the `for` loop holds prevents simultaneous modification "
"of the whole vector."
msgstr ""

#: src/ch08-01-vectors.md:257
msgid "Using an Enum to Store Multiple Types"
msgstr ""

#: src/ch08-01-vectors.md:259
msgid ""
"Vectors can only store values that are of the same type. This can be "
"inconvenient; there are definitely use cases for needing to store a list of "
"items of different types. Fortunately, the variants of an enum are defined "
"under the same enum type, so when we need one type to represent elements of "
"different types, we can define and use an enum!"
msgstr ""

#: src/ch08-01-vectors.md:265
msgid ""
"For example, say we want to get values from a row in a spreadsheet in which "
"some of the columns in the row contain integers, some floating-point "
"numbers, and some strings. We can define an enum whose variants will hold "
"the different value types, and all the enum variants will be considered the "
"same type: that of the enum. Then we can create a vector to hold that enum "
"and so, ultimately, hold different types. We’ve demonstrated this in Listing "
"8-9."
msgstr ""

#: src/ch08-01-vectors.md:284
msgid "\"blue\""
msgstr ""

#: src/ch08-01-vectors.md:292
msgid ""
"Rust needs to know what types will be in the vector at compile time so it "
"knows exactly how much memory on the heap will be needed to store each "
"element. We must also be explicit about what types are allowed in this "
"vector. If Rust allowed a vector to hold any type, there would be a chance "
"that one or more of the types would cause errors with the operations "
"performed on the elements of the vector. Using an enum plus a `match` "
"expression means that Rust will ensure at compile time that every possible "
"case is handled, as discussed in Chapter 6."
msgstr ""

#: src/ch08-01-vectors.md:300
msgid ""
"If you don’t know the exhaustive set of types a program will get at runtime "
"to store in a vector, the enum technique won’t work. Instead, you can use a "
"trait object, which we’ll cover in Chapter 18."
msgstr ""

#: src/ch08-01-vectors.md:304
msgid ""
"Now that we’ve discussed some of the most common ways to use vectors, be "
"sure to review [the API documentation](../std/vec/struct.Vec.html)<!-- "
"ignore --> for all of the many useful methods defined on `Vec<T>` by the "
"standard library. For example, in addition to `push`, a `pop` method removes "
"and returns the last element."
msgstr ""

#: src/ch08-01-vectors.md:309
msgid "Dropping a Vector Drops Its Elements"
msgstr ""

#: src/ch08-01-vectors.md:311
msgid ""
"Like any other `struct`, a vector is freed when it goes out of scope, as "
"annotated in Listing 8-10."
msgstr ""

#: src/ch08-01-vectors.md:321
msgid "// do stuff with v\n"
msgstr ""

#: src/ch08-01-vectors.md:322
msgid "// <- v goes out of scope and is freed here\n"
msgstr ""

#: src/ch08-01-vectors.md:328
msgid ""
"When the vector gets dropped, all of its contents are also dropped, meaning "
"the integers it holds will be cleaned up. The borrow checker ensures that "
"any references to contents of a vector are only used while the vector itself "
"is valid."
msgstr ""

#: src/ch08-01-vectors.md:333
msgid "Let’s move on to the next collection type: `String`!"
msgstr ""

#: src/ch08-02-strings.md:3
msgid ""
"We talked about strings in Chapter 4, but we’ll look at them in more depth "
"now. New Rustaceans commonly get stuck on strings for a combination of three "
"reasons: Rust’s propensity for exposing possible errors, strings being a "
"more complicated data structure than many programmers give them credit for, "
"and UTF-8. These factors combine in a way that can seem difficult when "
"you’re coming from other programming languages."
msgstr ""

#: src/ch08-02-strings.md:10
msgid ""
"We discuss strings in the context of collections because strings are "
"implemented as a collection of bytes, plus some methods to provide useful "
"functionality when those bytes are interpreted as text. In this section, "
"we’ll talk about the operations on `String` that every collection type has, "
"such as creating, updating, and reading. We’ll also discuss the ways in "
"which `String` is different from the other collections, namely how indexing "
"into a `String` is complicated by the differences between how people and "
"computers interpret `String` data."
msgstr ""

#: src/ch08-02-strings.md:19
msgid "What Is a String?"
msgstr ""

#: src/ch08-02-strings.md:21
msgid ""
"We’ll first define what we mean by the term _string_. Rust has only one "
"string type in the core language, which is the string slice `str` that is "
"usually seen in its borrowed form `&str`. In Chapter 4, we talked about "
"_string slices_, which are references to some UTF-8 encoded string data "
"stored elsewhere. String literals, for example, are stored in the program’s "
"binary and are therefore string slices."
msgstr ""

#: src/ch08-02-strings.md:28
msgid ""
"The `String` type, which is provided by Rust’s standard library rather than "
"coded into the core language, is a growable, mutable, owned, UTF-8 encoded "
"string type. When Rustaceans refer to “strings” in Rust, they might be "
"referring to either the `String` or the string slice `&str` types, not just "
"one of those types. Although this section is largely about `String`, both "
"types are used heavily in Rust’s standard library, and both `String` and "
"string slices are UTF-8 encoded."
msgstr "러스트의 표준 라이브러리에서 제공되며 코어 언어에 코딩되지 않은 `String` 타입은 확장 가능하고, 가변적이며, 소유권을 가지는 UTF-8 인코딩된 문자열 타입입니다. 러스트 개발자들이 러스트에서 \"문자열\"이라고 언급할 때, 그들은 `String` 또는 문자열 슬라이스 `&str` 타입 중 하나를 지칭할 수 있으며, 단순히 한 가지 타입만을 의미하지는 않습니다. 이 섹션은 주로 `String`에 대한 것이지만, 두 타입 모두 러스트의 표준 라이브러리에서 많이 사용되며, `String`과 문자열 슬라이스 모두 UTF-8로 인코딩됩니다."

#: src/ch08-02-strings.md:36
msgid "Creating a New String"
msgstr "새 문자열 생성하기"

#: src/ch08-02-strings.md:38
msgid ""
"Many of the same operations available with `Vec<T>` are available with "
"`String` as well because `String` is actually implemented as a wrapper "
"around a vector of bytes with some extra guarantees, restrictions, and "
"capabilities. An example of a function that works the same way with `Vec<T>` "
"and `String` is the `new` function to create an instance, shown in Listing "
"8-11."
msgstr "`Vec<T>`에서 사용 가능한 많은 동일한 연산들이 `String`에서도 사용 가능합니다. `String`은 실제로 몇 가지 추가 보장, 제한 및 기능을 가진 바이트 벡터를 감싸는 래퍼로 구현되어 있기 때문입니다. `Vec<T>`와 `String`에서 동일하게 작동하는 함수의 예는 목록 8-11에 표시된 인스턴스를 생성하는 `new` 함수입니다."

#: src/ch08-02-strings.md:54
msgid ""
"This line creates a new, empty string called `s`, into which we can then "
"load data. Often, we’ll have some initial data with which we want to start "
"the string. For that, we use the `to_string` method, which is available on "
"any type that implements the `Display` trait, as string literals do. Listing "
"8-12 shows two examples."
msgstr "이 줄은 `s`라는 새롭고 빈 문자열을 생성하며, 여기에 데이터를 로드할 수 있습니다. 종종 문자열을 시작할 초기 데이터가 있을 것입니다. 이를 위해 문자열 리터럴처럼 `Display` 트레이트를 구현하는 모든 타입에서 사용 가능한 `to_string` 메서드를 사용합니다. 목록 8-12는 두 가지 예시를 보여줍니다."

#: src/ch08-02-strings.md:64
#: src/ch08-02-strings.md:69
#: src/ch08-02-strings.md:85
msgid "\"initial contents\""
msgstr "\"초기 내용\""

#: src/ch08-02-strings.md:68
msgid "// The method also works on a literal directly:\n"
msgstr "// 이 메서드는 리터럴에서도 직접 작동합니다:\n"

#: src/ch08-02-strings.md:75
msgid "This code creates a string containing `initial contents`."
msgstr "이 코드는 `initial contents`를 포함하는 문자열을 생성합니다."

#: src/ch08-02-strings.md:77
msgid ""
"We can also use the function `String::from` to create a `String` from a "
"string literal. The code in Listing 8-13 is equivalent to the code in "
"Listing 8-12 that uses `to_string`."
msgstr "또한 `String::from` 함수를 사용하여 문자열 리터럴로부터 `String`을 생성할 수도 있습니다. 목록 8-13의 코드는 `to_string`을 사용하는 목록 8-12의 코드와 동일합니다."

#: src/ch08-02-strings.md:91
msgid ""
"Because strings are used for so many things, we can use many different "
"generic APIs for strings, providing us with a lot of options. Some of them "
"can seem redundant, but they all have their place! In this case, "
"`String::from` and `to_string` do the same thing, so which one you choose is "
"a matter of style and readability."
msgstr "문자열은 매우 다양한 용도로 사용되기 때문에, 문자열에 대해 여러 가지 제네릭 API를 사용할 수 있으며, 이는 우리에게 많은 선택지를 제공합니다. 일부는 중복되어 보일 수 있지만, 모두 제 역할을 합니다! 이 경우 `String::from`과 `to_string`은 동일한 작업을 수행하므로, 어떤 것을 선택할지는 스타일과 가독성의 문제입니다."

#: src/ch08-02-strings.md:97
msgid ""
"Remember that strings are UTF-8 encoded, so we can include any properly "
"encoded data in them, as shown in Listing 8-14."
msgstr "문자열은 UTF-8로 인코딩된다는 점을 기억하세요. 따라서 목록 8-14에 표시된 것처럼 올바르게 인코딩된 모든 데이터를 포함할 수 있습니다."

#: src/ch08-02-strings.md:104
#: src/ch08-02-strings.md:321
#: src/ch08-02-strings.md:342
msgid "\"السلام عليكم\""
msgstr "\"السلام عليكم\""

#: src/ch08-02-strings.md:105
#: src/ch08-02-strings.md:322
#: src/ch08-02-strings.md:343
msgid "\"Dobrý den\""
msgstr "Dobrý den"

#: src/ch08-02-strings.md:106
#: src/ch08-02-strings.md:323
#: src/ch08-02-strings.md:344
#: src/ch10-01-syntax.md:405
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/ch08-02-strings.md:107 src/ch08-02-strings.md:324
#: src/ch08-02-strings.md:345
msgid "\"שלום\""
msgstr "\"שלום\""

#: src/ch08-02-strings.md:108
#: src/ch08-02-strings.md:325
#: src/ch08-02-strings.md:346
msgid "\"नमस्ते\""
msgstr "\"नमस्ते\""

#: src/ch08-02-strings.md:109
#: src/ch08-02-strings.md:326
#: src/ch08-02-strings.md:347
msgid "\"こんにちは\""
msgstr "\"こんにちは\""

#: src/ch08-02-strings.md:110
#: src/ch08-02-strings.md:327
#: src/ch08-02-strings.md:348
msgid "\"안녕하세요\""
msgstr "\"안녕하세요\""

#: src/ch08-02-strings.md:111
#: src/ch08-02-strings.md:328
#: src/ch08-02-strings.md:349
msgid "\"你好\""
msgstr "\"你好\""

#: src/ch08-02-strings.md:112
#: src/ch08-02-strings.md:329
#: src/ch08-02-strings.md:350
msgid "\"Olá\""
msgstr "\"Olá\""

#: src/ch08-02-strings.md:113 src/ch08-02-strings.md:330
#: src/ch08-02-strings.md:351 src/ch08-02-strings.md:364
#: src/ch08-02-strings.md:433
msgid "\"Здравствуйте\""
msgstr "\"Здравствуйте\""

#: src/ch08-02-strings.md:114
#: src/ch08-02-strings.md:331
#: src/ch08-02-strings.md:352
msgid "\"Hola\""
msgstr "\"Hola\""

#: src/ch08-02-strings.md:120
msgid "All of these are valid `String` values."
msgstr "이 모든 것은 유효한 `String` 값입니다."

#: src/ch08-02-strings.md:122
msgid "Updating a String"
msgstr "문자열 업데이트하기"

#: src/ch08-02-strings.md:124
msgid ""
"A `String` can grow in size and its contents can change, just like the "
"contents of a `Vec<T>`, if you push more data into it. In addition, you can "
"conveniently use the `+` operator or the `format!` macro to concatenate "
"`String` values."
msgstr "`String`은 `Vec<T>`의 내용처럼 크기가 커지고 내용이 변경될 수 있습니다. 데이터를 더 추가하면 말이죠. 또한 `+` 연산자나 `format!` 매크로를 편리하게 사용하여 `String` 값을 연결할 수 있습니다."

#: src/ch08-02-strings.md:128
msgid "Appending to a String with `push_str` and `push`"
msgstr "`push_str`과 `push`로 문자열에 추가하기"

#: src/ch08-02-strings.md:130
msgid ""
"We can grow a `String` by using the `push_str` method to append a string "
"slice, as shown in Listing 8-15."
msgstr ""

#: src/ch08-02-strings.md:137
#: src/ch08-02-strings.md:153
#: src/appendix-01-keywords.md:121
msgid "\"foo\""
msgstr "\"foo\""

#: src/ch08-02-strings.md:138 src/ch08-02-strings.md:154
msgid "\"bar\""
msgstr ""

#: src/ch08-02-strings.md:144
msgid ""
"After these two lines, `s` will contain `foobar`. The `push_str` method "
"takes a string slice because we don’t necessarily want to take ownership of "
"the parameter. For example, in the code in Listing 8-16, we want to be able "
"to use `s2` after appending its contents to `s1`."
msgstr ""

#: src/ch08-02-strings.md:156
msgid "\"s2 is {s2}\""
msgstr ""

#: src/ch08-02-strings.md:162
msgid ""
"If the `push_str` method took ownership of `s2`, we wouldn’t be able to "
"print its value on the last line. However, this code works as we’d expect!"
msgstr ""

#: src/ch08-02-strings.md:165
msgid ""
"The `push` method takes a single character as a parameter and adds it to the "
"`String`. Listing 8-17 adds the letter _l_ to a `String` using the `push` "
"method."
msgstr ""

#: src/ch08-02-strings.md:173
msgid "\"lo\""
msgstr ""

#: src/ch08-02-strings.md:174
msgid "'l'"
msgstr ""

#: src/ch08-02-strings.md:180
msgid "As a result, `s` will contain `lol`."
msgstr ""

#: src/ch08-02-strings.md:182
msgid "Concatenation with the `+` Operator or the `format!` Macro"
msgstr ""

#: src/ch08-02-strings.md:184
msgid ""
"Often, you’ll want to combine two existing strings. One way to do so is to "
"use the `+` operator, as shown in Listing 8-18."
msgstr ""

#: src/ch08-02-strings.md:191
msgid "\"Hello, \""
msgstr ""

#: src/ch08-02-strings.md:192
msgid "\"world!\""
msgstr ""

#: src/ch08-02-strings.md:193
msgid "// note s1 has been moved here and can no longer be used\n"
msgstr ""

#: src/ch08-02-strings.md:199
msgid ""
"The string `s3` will contain `Hello, world!`. The reason `s1` is no longer "
"valid after the addition, and the reason we used a reference to `s2`, has to "
"do with the signature of the method that’s called when we use the `+` "
"operator. The `+` operator uses the `add` method, whose signature looks "
"something like this:"
msgstr ""

#: src/ch08-02-strings.md:209
msgid ""
"In the standard library, you’ll see `add` defined using generics and "
"associated types. Here, we’ve substituted in concrete types, which is what "
"happens when we call this method with `String` values. We’ll discuss "
"generics in Chapter 10. This signature gives us the clues we need in order "
"to understand the tricky bits of the `+` operator."
msgstr ""

#: src/ch08-02-strings.md:215
msgid ""
"First, `s2` has an `&`, meaning that we’re adding a _reference_ of the "
"second string to the first string. This is because of the `s` parameter in "
"the `add` function: we can only add a `&str` to a `String`; we can’t add two "
"`String` values together. But wait—the type of `&s2` is `&String`, not "
"`&str`, as specified in the second parameter to `add`. So why does Listing "
"8-18 compile?"
msgstr ""

#: src/ch08-02-strings.md:221
msgid ""
"The reason we’re able to use `&s2` in the call to `add` is that the compiler "
"can _coerce_ the `&String` argument into a `&str`. When we call the `add` "
"method, Rust uses a _deref coercion_, which here turns `&s2` into `&s2[..]`. "
"We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does "
"not take ownership of the `s` parameter, `s2` will still be a valid `String` "
"after this operation."
msgstr ""

#: src/ch08-02-strings.md:228
msgid ""
"Second, we can see in the signature that `add` takes ownership of `self` "
"because `self` does _not_ have an `&`. This means `s1` in Listing 8-18 will "
"be moved into the `add` call and will no longer be valid after that. So, "
"although `let s3 = s1 + &s2;` looks like it will copy both strings and "
"create a new one, this statement actually takes ownership of `s1`, appends a "
"copy of the contents of `s2`, and then returns ownership of the result. In "
"other words, it looks like it’s making a lot of copies, but it isn’t; the "
"implementation is more efficient than copying."
msgstr ""

#: src/ch08-02-strings.md:237
msgid ""
"If we need to concatenate multiple strings, the behavior of the `+` operator "
"gets unwieldy:"
msgstr ""

#: src/ch08-02-strings.md:242 src/ch08-02-strings.md:256
msgid "\"tic\""
msgstr ""

#: src/ch08-02-strings.md:243 src/ch08-02-strings.md:257
msgid "\"tac\""
msgstr ""

#: src/ch08-02-strings.md:244 src/ch08-02-strings.md:258
msgid "\"toe\""
msgstr ""

#: src/ch08-02-strings.md:246
msgid "\"-\""
msgstr ""

#: src/ch08-02-strings.md:250
msgid ""
"At this point, `s` will be `tic-tac-toe`. With all of the `+` and `\"` "
"characters, it’s difficult to see what’s going on. For combining strings in "
"more complicated ways, we can instead use the `format!` macro:"
msgstr ""

#: src/ch08-02-strings.md:260
msgid "\"{s1}-{s2}-{s3}\""
msgstr ""

#: src/ch08-02-strings.md:264
msgid ""
"This code also sets `s` to `tic-tac-toe`. The `format!` macro works like "
"`println!`, but instead of printing the output to the screen, it returns a "
"`String` with the contents. The version of the code using `format!` is much "
"easier to read, and the code generated by the `format!` macro uses "
"references so that this call doesn’t take ownership of any of its parameters."
msgstr ""

#: src/ch08-02-strings.md:270
msgid "Indexing into Strings"
msgstr ""

#: src/ch08-02-strings.md:272
msgid ""
"In many other programming languages, accessing individual characters in a "
"string by referencing them by index is a valid and common operation. "
"However, if you try to access parts of a `String` using indexing syntax in "
"Rust, you’ll get an error. Consider the invalid code in Listing 8-19."
msgstr ""

#: src/ch08-02-strings.md:288
msgid "This code will result in the following error:"
msgstr ""

#: src/ch08-02-strings.md:290
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"error[E0277]: the type `str` cannot be indexed by `{integer}`\n"
" --> src/main.rs:3:16\n"
"  |\n"
"3 |     let h = s1[0];\n"
"  |                ^ string indices are ranges of `usize`\n"
"  |\n"
"  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`, "
"which is required by `String: Index<_>`\n"
"  = note: you can use `.chars().nth()` or `.bytes().nth()`\n"
"          for more information, see chapter 8 in The Book: <https://doc.rust-"
"lang.org/book/ch08-02-strings.html#indexing-into-strings>\n"
"  = help: the trait `SliceIndex<[_]>` is implemented for `usize`\n"
"  = help: for that trait implementation, expected `[_]`, found `str`\n"
"  = note: required for `String` to implement `Index<{integer}>`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `collections` (bin \"collections\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:310
msgid ""
"The error and the note tell the story: Rust strings don’t support indexing. "
"But why not? To answer that question, we need to discuss how Rust stores "
"strings in memory."
msgstr ""

#: src/ch08-02-strings.md:314
msgid "Internal Representation"
msgstr ""

#: src/ch08-02-strings.md:316
msgid ""
"A `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly "
"encoded UTF-8 example strings from Listing 8-14. First, this one:"
msgstr ""

#: src/ch08-02-strings.md:335
msgid ""
"In this case, `len` will be `4`, which means the vector storing the string "
"`\"Hola\"` is 4 bytes long. Each of these letters takes one byte when "
"encoded in UTF-8. The following line, however, may surprise you (note that "
"this string begins with the capital Cyrillic letter _Ze_, not the number 3):"
msgstr ""

#: src/ch08-02-strings.md:356
msgid ""
"If you were asked how long the string is, you might say 12. In fact, Rust’s "
"answer is 24: that’s the number of bytes it takes to encode “Здравствуйте” "
"in UTF-8, because each Unicode scalar value in that string takes 2 bytes of "
"storage. Therefore, an index into the string’s bytes will not always "
"correlate to a valid Unicode scalar value. To demonstrate, consider this "
"invalid Rust code:"
msgstr ""

#: src/ch08-02-strings.md:368
msgid ""
"You already know that `answer` will not be `З`, the first letter. When "
"encoded in UTF-8, the first byte of `З` is `208` and the second is `151`, so "
"it would seem that `answer` should in fact be `208`, but `208` is not a "
"valid character on its own. Returning `208` is likely not what a user would "
"want if they asked for the first letter of this string; however, that’s the "
"only data that Rust has at byte index 0. Users generally don’t want the byte "
"value returned, even if the string contains only Latin letters: if "
"`&\"hi\"[0]` were valid code that returned the byte value, it would return "
"`104`, not `h`."
msgstr ""

#: src/ch08-02-strings.md:377
msgid ""
"The answer, then, is that to avoid returning an unexpected value and causing "
"bugs that might not be discovered immediately, Rust doesn’t compile this "
"code at all and prevents misunderstandings early in the development process."
msgstr ""

#: src/ch08-02-strings.md:381
msgid "Bytes and Scalar Values and Grapheme Clusters! Oh My!"
msgstr ""

#: src/ch08-02-strings.md:383
msgid ""
"Another point about UTF-8 is that there are actually three relevant ways to "
"look at strings from Rust’s perspective: as bytes, scalar values, and "
"grapheme clusters (the closest thing to what we would call _letters_)."
msgstr ""

#: src/ch08-02-strings.md:387
msgid ""
"If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is "
"stored as a vector of `u8` values that looks like this:"
msgstr ""

#: src/ch08-02-strings.md:395
msgid ""
"That’s 18 bytes and is how computers ultimately store this data. If we look "
"at them as Unicode scalar values, which are what Rust’s `char` type is, "
"those bytes look like this:"
msgstr ""

#: src/ch08-02-strings.md:403
msgid ""
"There are six `char` values here, but the fourth and sixth are not letters: "
"they’re diacritics that don’t make sense on their own. Finally, if we look "
"at them as grapheme clusters, we’d get what a person would call the four "
"letters that make up the Hindi word:"
msgstr ""

#: src/ch08-02-strings.md:408
msgid ""
"```text\n"
"[\"न\", \"म\", \"स्\", \"ते\"]\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:412
msgid ""
"Rust provides different ways of interpreting the raw string data that "
"computers store so that each program can choose the interpretation it needs, "
"no matter what human language the data is in."
msgstr ""

#: src/ch08-02-strings.md:416
msgid ""
"A final reason Rust doesn’t allow us to index into a `String` to get a "
"character is that indexing operations are expected to always take constant "
"time (O(1)). But it isn’t possible to guarantee that performance with a "
"`String`, because Rust would have to walk through the contents from the "
"beginning to the index to determine how many valid characters there were."
msgstr ""

#: src/ch08-02-strings.md:422
msgid "Slicing Strings"
msgstr ""

#: src/ch08-02-strings.md:424
msgid ""
"Indexing into a string is often a bad idea because it’s not clear what the "
"return type of the string-indexing operation should be: a byte value, a "
"character, a grapheme cluster, or a string slice. If you really need to use "
"indices to create string slices, therefore, Rust asks you to be more "
"specific."
msgstr ""

#: src/ch08-02-strings.md:429
msgid ""
"Rather than indexing using `[]` with a single number, you can use `[]` with "
"a range to create a string slice containing particular bytes:"
msgstr ""

#: src/ch08-02-strings.md:438
msgid ""
"Here, `s` will be a `&str` that contains the first four bytes of the string. "
"Earlier, we mentioned that each of these characters was two bytes, which "
"means `s` will be `Зд`."
msgstr ""

#: src/ch08-02-strings.md:442
msgid ""
"If we were to try to slice only part of a character’s bytes with something "
"like `&hello[0..1]`, Rust would panic at runtime in the same way as if an "
"invalid index were accessed in a vector:"
msgstr ""

#: src/ch08-02-strings.md:446
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/collections`\n"
"thread 'main' panicked at src/main.rs:4:19:\n"
"byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of "
"`Здравствуйте`\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:456
msgid ""
"You should use caution when creating string slices with ranges, because "
"doing so can crash your program."
msgstr ""

#: src/ch08-02-strings.md:459
msgid "Methods for Iterating Over Strings"
msgstr ""

#: src/ch08-02-strings.md:461
msgid ""
"The best way to operate on pieces of strings is to be explicit about whether "
"you want characters or bytes. For individual Unicode scalar values, use the "
"`chars` method. Calling `chars` on “Зд” separates out and returns two values "
"of type `char`, and you can iterate over the result to access each element:"
msgstr ""

#: src/ch08-02-strings.md:467 src/ch08-02-strings.md:483
msgid "\"Зд\""
msgstr ""

#: src/ch08-02-strings.md:468
msgid "\"{c}\""
msgstr ""

#: src/ch08-02-strings.md:472 src/ch16-03-shared-state.md:334
msgid "This code will print the following:"
msgstr ""

#: src/ch08-02-strings.md:479
msgid ""
"Alternatively, the `bytes` method returns each raw byte, which might be "
"appropriate for your domain:"
msgstr ""

#: src/ch08-02-strings.md:484
msgid "\"{b}\""
msgstr ""

#: src/ch08-02-strings.md:488
msgid "This code will print the four bytes that make up this string:"
msgstr ""

#: src/ch08-02-strings.md:497
msgid ""
"But be sure to remember that valid Unicode scalar values may be made up of "
"more than one byte."
msgstr ""

#: src/ch08-02-strings.md:500
msgid ""
"Getting grapheme clusters from strings, as with the Devanagari script, is "
"complex, so this functionality is not provided by the standard library. "
"Crates are available on [crates.io](https://crates.io/)<!-- ignore --> if "
"this is the functionality you need."
msgstr ""

#: src/ch08-02-strings.md:505
msgid "Strings Are Not So Simple"
msgstr ""

#: src/ch08-02-strings.md:507
msgid ""
"To summarize, strings are complicated. Different programming languages make "
"different choices about how to present this complexity to the programmer. "
"Rust has chosen to make the correct handling of `String` data the default "
"behavior for all Rust programs, which means programmers have to put more "
"thought into handling UTF-8 data up front. This trade-off exposes more of "
"the complexity of strings than is apparent in other programming languages, "
"but it prevents you from having to handle errors involving non-ASCII "
"characters later in your development life cycle."
msgstr ""

#: src/ch08-02-strings.md:516
msgid ""
"The good news is that the standard library offers a lot of functionality "
"built off the `String` and `&str` types to help handle these complex "
"situations correctly. Be sure to check out the documentation for useful "
"methods like `contains` for searching in a string and `replace` for "
"substituting parts of a string with another string."
msgstr ""

#: src/ch08-02-strings.md:522
msgid "Let’s switch to something a bit less complex: hash maps!"
msgstr ""

#: src/ch08-03-hash-maps.md:3
msgid ""
"The last of our common collections is the _hash map_. The type `HashMap<K, "
"V>` stores a mapping of keys of type `K` to values of type `V` using a "
"_hashing function_, which determines how it places these keys and values "
"into memory. Many programming languages support this kind of data structure, "
"but they often use a different name, such as _hash_, _map_, _object_, _hash "
"table_, _dictionary_, or _associative array_, just to name a few."
msgstr ""

#: src/ch08-03-hash-maps.md:10
msgid ""
"Hash maps are useful when you want to look up data not by using an index, as "
"you can with vectors, but by using a key that can be of any type. For "
"example, in a game, you could keep track of each team’s score in a hash map "
"in which each key is a team’s name and the values are each team’s score. "
"Given a team name, you can retrieve its score."
msgstr ""

#: src/ch08-03-hash-maps.md:16
msgid ""
"We’ll go over the basic API of hash maps in this section, but many more "
"goodies are hiding in the functions defined on `HashMap<K, V>` by the "
"standard library. As always, check the standard library documentation for "
"more information."
msgstr ""

#: src/ch08-03-hash-maps.md:20
msgid "Creating a New Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:22
msgid ""
"One way to create an empty hash map is to use `new` and to add elements with "
"`insert`. In Listing 8-20, we’re keeping track of the scores of two teams "
"whose names are _Blue_ and _Yellow_. The Blue team starts with 10 points, "
"and the Yellow team starts with 50."
msgstr ""

#: src/ch08-03-hash-maps.md:35 src/ch08-03-hash-maps.md:66
#: src/ch08-03-hash-maps.md:69 src/ch08-03-hash-maps.md:92
#: src/ch08-03-hash-maps.md:121 src/ch08-03-hash-maps.md:171
#: src/ch08-03-hash-maps.md:172 src/ch08-03-hash-maps.md:208
#: src/ch08-03-hash-maps.md:211
msgid "\"Blue\""
msgstr ""

#: src/ch08-03-hash-maps.md:36 src/ch08-03-hash-maps.md:67
#: src/ch08-03-hash-maps.md:93 src/ch08-03-hash-maps.md:210
msgid "\"Yellow\""
msgstr ""

#: src/ch08-03-hash-maps.md:42
msgid ""
"Note that we need to first `use` the `HashMap` from the collections portion "
"of the standard library. Of our three common collections, this one is the "
"least often used, so it’s not included in the features brought into scope "
"automatically in the prelude. Hash maps also have less support from the "
"standard library; there’s no built-in macro to construct them, for example."
msgstr ""

#: src/ch08-03-hash-maps.md:48
msgid ""
"Just like vectors, hash maps store their data on the heap. This `HashMap` "
"has keys of type `String` and values of type `i32`. Like vectors, hash maps "
"are homogeneous: all of the keys must have the same type, and all of the "
"values must have the same type."
msgstr ""

#: src/ch08-03-hash-maps.md:53
msgid "Accessing Values in a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:55
msgid ""
"We can get a value out of the hash map by providing its key to the `get` "
"method, as shown in Listing 8-21."
msgstr ""

#: src/ch08-03-hash-maps.md:76
msgid ""
"Here, `score` will have the value that’s associated with the Blue team, and "
"the result will be `10`. The `get` method returns an `Option<&V>`; if "
"there’s no value for that key in the hash map, `get` will return `None`. "
"This program handles the `Option` by calling `copied` to get an "
"`Option<i32>` rather than an `Option<&i32>`, then `unwrap_or` to set `score` "
"to zero if `scores` doesn’t have an entry for the key."
msgstr ""

#: src/ch08-03-hash-maps.md:83
msgid ""
"We can iterate over each key-value pair in a hash map in a similar manner as "
"we do with vectors, using a `for` loop:"
msgstr ""

#: src/ch08-03-hash-maps.md:96
msgid "\"{key}: {value}\""
msgstr ""

#: src/ch08-03-hash-maps.md:101
msgid "This code will print each pair in an arbitrary order:"
msgstr ""

#: src/ch08-03-hash-maps.md:108
msgid "Hash Maps and Ownership"
msgstr ""

#: src/ch08-03-hash-maps.md:110
msgid ""
"For types that implement the `Copy` trait, like `i32`, the values are copied "
"into the hash map. For owned values like `String`, the values will be moved "
"and the hash map will be the owner of those values, as demonstrated in "
"Listing 8-22."
msgstr ""

#: src/ch08-03-hash-maps.md:120
msgid "\"Favorite color\""
msgstr ""

#: src/ch08-03-hash-maps.md:125
msgid ""
"// field_name and field_value are invalid at this point, try using them and\n"
"    // see what compiler error you get!\n"
msgstr ""

#: src/ch08-03-hash-maps.md:132
msgid ""
"We aren’t able to use the variables `field_name` and `field_value` after "
"they’ve been moved into the hash map with the call to `insert`."
msgstr ""

#: src/ch08-03-hash-maps.md:135
msgid ""
"If we insert references to values into the hash map, the values won’t be "
"moved into the hash map. The values that the references point to must be "
"valid for at least as long as the hash map is valid. We’ll talk more about "
"these issues in [“Validating References with Lifetimes”](ch10-03-lifetime-"
"syntax.html#validating-references-with-lifetimes)<!-- ignore --> in Chapter "
"10."
msgstr ""

#: src/ch08-03-hash-maps.md:141
msgid "Updating a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:143
msgid ""
"Although the number of key and value pairs is growable, each unique key can "
"only have one value associated with it at a time (but not vice versa: for "
"example, both the Blue team and the Yellow team could have the value `10` "
"stored in the `scores` hash map)."
msgstr ""

#: src/ch08-03-hash-maps.md:148
msgid ""
"When you want to change the data in a hash map, you have to decide how to "
"handle the case when a key already has a value assigned. You could replace "
"the old value with the new value, completely disregarding the old value. You "
"could keep the old value and ignore the new value, only adding the new value "
"if the key _doesn’t_ already have a value. Or you could combine the old "
"value and the new value. Let’s look at how to do each of these!"
msgstr ""

#: src/ch08-03-hash-maps.md:155
msgid "Overwriting a Value"
msgstr ""

#: src/ch08-03-hash-maps.md:157
msgid ""
"If we insert a key and a value into a hash map and then insert that same key "
"with a different value, the value associated with that key will be replaced. "
"Even though the code in Listing 8-23 calls `insert` twice, the hash map will "
"only contain one key-value pair because we’re inserting the value for the "
"Blue team’s key both times."
msgstr ""

#: src/ch08-03-hash-maps.md:174 src/ch08-03-hash-maps.md:213
msgid "\"{scores:?}\""
msgstr ""

#: src/ch08-03-hash-maps.md:180
msgid ""
"This code will print `{\"Blue\": 25}`. The original value of `10` has been "
"overwritten."
msgstr ""

#: src/ch08-03-hash-maps.md:185
msgid "<a id=\"only-inserting-a-value-if-the-key-has-no-value\"></a>"
msgstr ""

#: src/ch08-03-hash-maps.md:187
msgid "Adding a Key and Value Only If a Key Isn’t Present"
msgstr ""

#: src/ch08-03-hash-maps.md:189
msgid ""
"It’s common to check whether a particular key already exists in the hash map "
"with a value and then to take the following actions: if the key does exist "
"in the hash map, the existing value should remain the way it is; if the key "
"doesn’t exist, insert it and a value for it."
msgstr ""

#: src/ch08-03-hash-maps.md:194
msgid ""
"Hash maps have a special API for this called `entry` that takes the key you "
"want to check as a parameter. The return value of the `entry` method is an "
"enum called `Entry` that represents a value that might or might not exist. "
"Let’s say we want to check whether the key for the Yellow team has a value "
"associated with it. If it doesn’t, we want to insert the value `50`, and the "
"same for the Blue team. Using the `entry` API, the code looks like Listing "
"8-24."
msgstr ""

#: src/ch08-03-hash-maps.md:219
msgid ""
"The `or_insert` method on `Entry` is defined to return a mutable reference "
"to the value for the corresponding `Entry` key if that key exists, and if "
"not, it inserts the parameter as the new value for this key and returns a "
"mutable reference to the new value. This technique is much cleaner than "
"writing the logic ourselves and, in addition, plays more nicely with the "
"borrow checker."
msgstr ""

#: src/ch08-03-hash-maps.md:225
msgid ""
"Running the code in Listing 8-24 will print `{\"Yellow\": 50, \"Blue\": 10}"
"`. The first call to `entry` will insert the key for the Yellow team with "
"the value `50` because the Yellow team doesn’t have a value already. The "
"second call to `entry` will not change the hash map because the Blue team "
"already has the value `10`."
msgstr ""

#: src/ch08-03-hash-maps.md:231
msgid "Updating a Value Based on the Old Value"
msgstr ""

#: src/ch08-03-hash-maps.md:233
msgid ""
"Another common use case for hash maps is to look up a key’s value and then "
"update it based on the old value. For instance, Listing 8-25 shows code that "
"counts how many times each word appears in some text. We use a hash map with "
"the words as keys and increment the value to keep track of how many times "
"we’ve seen that word. If it’s the first time we’ve seen a word, we’ll first "
"insert the value `0`."
msgstr ""

#: src/ch08-03-hash-maps.md:246
msgid "\"hello world wonderful world\""
msgstr ""

#: src/ch08-03-hash-maps.md:255
msgid "\"{map:?}\""
msgstr ""

#: src/ch08-03-hash-maps.md:261
msgid ""
"This code will print `{\"world\": 2, \"hello\": 1, \"wonderful\": 1}`. You "
"might see the same key-value pairs printed in a different order: recall from "
"[“Accessing Values in a Hash Map”](#accessing-values-in-a-hash-map)<!-- "
"ignore --> that iterating over a hash map happens in an arbitrary order."
msgstr ""

#: src/ch08-03-hash-maps.md:266
msgid ""
"The `split_whitespace` method returns an iterator over subslices, separated "
"by whitespace, of the value in `text`. The `or_insert` method returns a "
"mutable reference (`&mut V`) to the value for the specified key. Here, we "
"store that mutable reference in the `count` variable, so in order to assign "
"to that value, we must first dereference `count` using the asterisk (`*`). "
"The mutable reference goes out of scope at the end of the `for` loop, so all "
"of these changes are safe and allowed by the borrowing rules."
msgstr ""

#: src/ch08-03-hash-maps.md:274
msgid "Hashing Functions"
msgstr ""

#: src/ch08-03-hash-maps.md:276
msgid ""
"By default, `HashMap` uses a hashing function called _SipHash_ that can "
"provide resistance to denial-of-service (DoS) attacks involving hash "
"tables[^siphash]<!-- ignore -->. This is not the fastest hashing algorithm "
"available, but the trade-off for better security that comes with the drop in "
"performance is worth it. If you profile your code and find that the default "
"hash function is too slow for your purposes, you can switch to another "
"function by specifying a different hasher. A _hasher_ is a type that "
"implements the `BuildHasher` trait. We’ll talk about traits and how to "
"implement them in [Chapter 10](ch10-02-traits.html)<!-- ignore -->. You "
"don’t necessarily have to implement your own hasher from scratch; [crates.io]"
"(https://crates.io/)<!-- ignore --> has libraries shared by other Rust users "
"that provide hashers implementing many common hashing algorithms."
msgstr ""

#: src/ch08-03-hash-maps.md:289
msgid ""
"[https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/"
"SipHash)"
msgstr ""

#: src/ch08-03-hash-maps.md:293
msgid ""
"Vectors, strings, and hash maps will provide a large amount of functionality "
"necessary in programs when you need to store, access, and modify data. Here "
"are some exercises you should now be equipped to solve:"
msgstr ""

#: src/ch08-03-hash-maps.md:297
msgid ""
"Given a list of integers, use a vector and return the median (when sorted, "
"the value in the middle position) and mode (the value that occurs most "
"often; a hash map will be helpful here) of the list."
msgstr ""

#: src/ch08-03-hash-maps.md:300
msgid ""
"Convert strings to pig latin. The first consonant of each word is moved to "
"the end of the word and _ay_ is added, so _first_ becomes _irst-fay_. Words "
"that start with a vowel have _hay_ added to the end instead (_apple_ becomes "
"_apple-hay_). Keep in mind the details about UTF-8 encoding!"
msgstr ""

#: src/ch08-03-hash-maps.md:304
msgid ""
"Using a hash map and vectors, create a text interface to allow a user to add "
"employee names to a department in a company; for example, “Add Sally to "
"Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of "
"all people in a department or all people in the company by department, "
"sorted alphabetically."
msgstr ""

#: src/ch08-03-hash-maps.md:310
msgid ""
"The standard library API documentation describes methods that vectors, "
"strings, and hash maps have that will be helpful for these exercises!"
msgstr ""

#: src/ch08-03-hash-maps.md:313
msgid ""
"We’re getting into more complex programs in which operations can fail, so "
"it’s a perfect time to discuss error handling. We’ll do that next!"
msgstr ""

#: src/ch09-00-error-handling.md:3
msgid ""
"Errors are a fact of life in software, so Rust has a number of features for "
"handling situations in which something goes wrong. In many cases, Rust "
"requires you to acknowledge the possibility of an error and take some action "
"before your code will compile. This requirement makes your program more "
"robust by ensuring that you’ll discover errors and handle them appropriately "
"before deploying your code to production!"
msgstr ""

#: src/ch09-00-error-handling.md:10
msgid ""
"Rust groups errors into two major categories: _recoverable_ and "
"_unrecoverable_ errors. For a recoverable error, such as a _file not found_ "
"error, we most likely just want to report the problem to the user and retry "
"the operation. Unrecoverable errors are always symptoms of bugs, such as "
"trying to access a location beyond the end of an array, and so we want to "
"immediately stop the program."
msgstr ""

#: src/ch09-00-error-handling.md:17
msgid ""
"Most languages don’t distinguish between these two kinds of errors and "
"handle both in the same way, using mechanisms such as exceptions. Rust "
"doesn’t have exceptions. Instead, it has the type `Result<T, E>` for "
"recoverable errors and the `panic!` macro that stops execution when the "
"program encounters an unrecoverable error. This chapter covers calling "
"`panic!` first and then talks about returning `Result<T, E>` values. "
"Additionally, we’ll explore considerations when deciding whether to try to "
"recover from an error or to stop execution."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:3
msgid ""
"Sometimes bad things happen in your code, and there’s nothing you can do "
"about it. In these cases, Rust has the `panic!` macro. There are two ways to "
"cause a panic in practice: by taking an action that causes our code to panic "
"(such as accessing an array past the end) or by explicitly calling the "
"`panic!` macro. In both cases, we cause a panic in our program. By default, "
"these panics will print a failure message, unwind, clean up the stack, and "
"quit. Via an environment variable, you can also have Rust display the call "
"stack when a panic occurs to make it easier to track down the source of the "
"panic."
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:12
msgid "Unwinding the Stack or Aborting in Response to a Panic"
msgstr "패닉에 대한 응답으로 스택 풀기 또는 중단하기"

#: src/ch09-01-unrecoverable-errors-with-panic.md:14
msgid ""
"By default, when a panic occurs the program starts _unwinding_, which means "
"Rust walks back up the stack and cleans up the data from each function it "
"encounters. However, walking back and cleaning up is a lot of work. Rust, "
"therefore, allows you to choose the alternative of immediately _aborting_, "
"which ends the program without cleaning up."
msgstr "기본적으로 패닉이 발생하면 프로그램은 _언와인딩_을 시작합니다. 이는 러스트가 스택을 거슬러 올라가면서 만나는 각 함수에서 데이터를 정리한다는 의미입니다. 그러나 거슬러 올라가서 정리하는 것은 많은 작업입니다. 따라서 러스트는 즉시 _중단_하는 대안을 선택할 수 있도록 허용하며, 이는 정리 작업 없이 프로그램을 종료합니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:20
msgid ""
"Memory that the program was using will then need to be cleaned up by the "
"operating system. If in your project you need to make the resultant binary "
"as small as possible, you can switch from unwinding to aborting upon a panic "
"by adding `panic = 'abort'` to the appropriate `[profile]` sections in your "
"_Cargo.toml_ file. For example, if you want to abort on panic in release "
"mode, add this:"
msgstr "프로그램이 사용하던 메모리는 운영 체제에 의해 정리되어야 합니다. 프로젝트에서 결과 바이너리를 가능한 한 작게 만들 필요가 있다면, _Cargo.toml_ 파일의 적절한 `[profile]` 섹션에 `panic = 'abort'`를 추가하여 패닉 발생 시 언와인딩에서 중단으로 전환할 수 있습니다. 예를 들어, 릴리스 모드에서 패닉 시 중단하려면 다음을 추가하세요:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:32
msgid "Let’s try calling `panic!` in a simple program:"
msgstr "간단한 프로그램에서 `panic!`을 호출해 봅시다:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:38
msgid "\"crash and burn\""
msgstr "\"충돌 및 소실\""

#: src/ch09-01-unrecoverable-errors-with-panic.md:44
msgid "When you run the program, you’ll see something like this:"
msgstr "프로그램을 실행하면 다음과 같은 내용을 볼 수 있습니다:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:46
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling panic v0.1.0 (file:///projects/panic)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s\n"
"     Running `target/debug/panic`\n"
"thread 'main' panicked at src/main.rs:2:5:\n"
"crash and burn\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a \n"
"backtrace\n"
"```"
msgstr ""
"```console\n"
"$ cargo run\n"
"   Compiling panic v0.1.0 (file:///projects/panic)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s\n"
"     Running `target/debug/panic`\n"
"thread 'main' panicked at src/main.rs:2:5:\n"
"crash and burn\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a \n"
"backtrace\n"
"```"

#: src/ch09-01-unrecoverable-errors-with-panic.md:56
msgid ""
"The call to `panic!` causes the error message contained in the last two "
"lines. The first line shows our panic message and the place in our source "
"code where the panic occurred: _src/main.rs:2:5_ indicates that it’s the "
"second line, fifth character of our _src/main.rs_ file."
msgstr "`panic!` 호출은 마지막 두 줄에 포함된 오류 메시지를 발생시킵니다. 첫 번째 줄은 패닉 메시지와 소스 코드에서 패닉이 발생한 위치를 보여줍니다. _src/main.rs:2:5_는 _src/main.rs_ 파일의 두 번째 줄, 다섯 번째 문자를 나타냅니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:61
msgid ""
"In this case, the line indicated is part of our code, and if we go to that "
"line, we see the `panic!` macro call. In other cases, the `panic!` call "
"might be in code that our code calls, and the filename and line number "
"reported by the error message will be someone else’s code where the `panic!` "
"macro is called, not the line of our code that eventually led to the `panic!"
"` call."
msgstr ""
"이 경우, 표시된 줄은 우리 코드의 일부이며, 해당 줄로 이동하면 `panic!` 매크로 호출을 볼 수 있습니다. "
"다른 경우에는 `panic!` 호출이 우리 코드가 호출하는 코드에 있을 수 있으며, 오류 메시지에 보고된 파일 이름과 줄 번호는 `panic!` 매크로가 호출된 다른 사람의 코드이지, 결국 `panic!` 호출로 이어진 우리 코드의 줄이 아닙니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:69
msgid "<a id=\"using-a-panic-backtrace\"></a>"
msgstr "<a id=\"using-a-panic-backtrace\"></a>"

#: src/ch09-01-unrecoverable-errors-with-panic.md:71
msgid ""
"We can use the backtrace of the functions the `panic!` call came from to "
"figure out the part of our code that is causing the problem. To understand "
"how to use a `panic!` backtrace, let’s look at another example and see what "
"it’s like when a `panic!` call comes from a library because of a bug in our "
"code instead of from our code calling the macro directly. Listing 9-1 has "
"some code that attempts to access an index in a vector beyond the range of "
"valid indexes."
msgstr "`panic!` 호출이 발생한 함수의 백트레이스를 사용하여 문제의 원인이 되는 코드 부분을 파악할 수 있습니다. `panic!` 백트레이스를 사용하는 방법을 이해하기 위해, `panic!` 호출이 매크로를 직접 호출하는 우리 코드에서 발생한 것이 아니라 우리 코드의 버그로 인해 라이브러리에서 발생했을 때 어떤 모습인지 다른 예제를 통해 살펴보겠습니다. 목록 9-1에는 유효한 인덱스 범위를 벗어난 벡터의 인덱스에 접근하려는 코드가 있습니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:90
msgid ""
"Here, we’re attempting to access the 100th element of our vector (which is "
"at index 99 because indexing starts at zero), but the vector has only three "
"elements. In this situation, Rust will panic. Using `[]` is supposed to "
"return an element, but if you pass an invalid index, there’s no element that "
"Rust could return here that would be correct."
msgstr "여기서 우리는 벡터의 100번째 요소(인덱싱이 0부터 시작하므로 인덱스 99)에 접근하려고 시도하지만, 벡터에는 세 개의 요소만 있습니다. 이 상황에서 러스트는 패닉을 일으킬 것입니다. `[]`를 사용하는 것은 요소를 반환해야 하지만, 유효하지 않은 인덱스를 전달하면 러스트가 여기서 올바르게 반환할 수 있는 요소가 없습니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:96
msgid ""
"In C, attempting to read beyond the end of a data structure is undefined "
"behavior. You might get whatever is at the location in memory that would "
"correspond to that element in the data structure, even though the memory "
"doesn’t belong to that structure. This is called a _buffer overread_ and can "
"lead to security vulnerabilities if an attacker is able to manipulate the "
"index in such a way as to read data they shouldn’t be allowed to that is "
"stored after the data structure."
msgstr "C에서는 데이터 구조의 끝을 넘어 읽으려고 시도하는 것은 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리 위치에 있는 것을 얻을 수 있습니다. 이를 _버퍼 오버리드_라고 하며, 공격자가 데이터 구조 뒤에 저장된 허용되지 않는 데이터를 읽을 수 있도록 인덱스를 조작할 수 있다면 보안 취약점으로 이어질 수 있습니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:104
msgid ""
"To protect your program from this sort of vulnerability, if you try to read "
"an element at an index that doesn’t exist, Rust will stop execution and "
"refuse to continue. Let’s try it and see:"
msgstr "이러한 종류의 취약점으로부터 프로그램을 보호하기 위해, 존재하지 않는 인덱스의 요소를 읽으려고 시도하면 러스트는 실행을 중지하고 계속 진행하는 것을 거부합니다. 한번 시도해 봅시다:"

#: src/ch09-01-unrecoverable-errors-with-panic.md:108
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling panic v0.1.0 (file:///projects/panic)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n"
"     Running `target/debug/panic`\n"
"thread 'main' panicked at src/main.rs:4:6:\n"
"index out of bounds: the len is 3 but the index is 99\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch09-01-unrecoverable-errors-with-panic.md:118
msgid ""
"This error points at line 4 of our _main.rs_ where we attempt to access "
"index `99` of the vector in `v`."
msgstr "이 오류는 _main.rs_ 파일의 4번째 줄, 즉 `v` 벡터의 인덱스 `99`에 접근하려는 부분을 가리킵니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:121
msgid ""
"The `note:` line tells us that we can set the `RUST_BACKTRACE` environment "
"variable to get a backtrace of exactly what happened to cause the error. A "
"_backtrace_ is a list of all the functions that have been called to get to "
"this point. Backtraces in Rust work as they do in other languages: the key "
"to reading the backtrace is to start from the top and read until you see "
"files you wrote. That’s the spot where the problem originated. The lines "
"above that spot are code that your code has called; the lines below are code "
"that called your code. These before-and-after lines might include core Rust "
"code, standard library code, or crates that you’re using. Let’s try getting "
"a backtrace by setting the `RUST_BACKTRACE` environment variable to any "
"value except `0`. Listing 9-2 shows output similar to what you’ll see."
msgstr "`note:` 줄은 `RUST_BACKTRACE` 환경 변수를 설정하여 오류의 원인이 정확히 무엇인지에 대한 백트레이스를 얻을 수 있다고 알려줍니다. _백트레이스_는 이 지점까지 호출된 모든 함수의 목록입니다. 러스트의 백트레이스는 다른 언어에서와 마찬가지로 작동합니다. 백트레이스를 읽는 핵심은 맨 위에서부터 시작하여 직접 작성한 파일을 볼 때까지 읽는 것입니다. 그 지점이 문제가 시작된 곳입니다. 그 지점 위의 줄은 우리 코드가 호출한 코드이고, 아래 줄은 우리 코드를 호출한 코드입니다. 이러한 이전 및 이후 줄에는 핵심 러스트 코드, 표준 라이브러리 코드 또는 사용 중인 크레이트가 포함될 수 있습니다. `RUST_BACKTRACE` 환경 변수를 `0`을 제외한 아무 값으로 설정하여 백트레이스를 얻어 봅시다. 목록 9-2는 여러분이 보게 될 것과 유사한 출력을 보여줍니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:168
msgid ""
"That’s a lot of output! The exact output you see might be different "
"depending on your operating system and Rust version. In order to get "
"backtraces with this information, debug symbols must be enabled. Debug "
"symbols are enabled by default when using `cargo build` or `cargo run` "
"without the `--release` flag, as we have here."
msgstr "출력이 많죠! 여러분이 보는 정확한 출력은 운영 체제와 러스트 버전에 따라 다를 수 있습니다. 이 정보가 포함된 백트레이스를 얻으려면 디버그 심볼이 활성화되어야 합니다. 디버그 심볼은 `--release` 플래그 없이 `cargo build` 또는 `cargo run`을 사용할 때 기본적으로 활성화됩니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:174
msgid ""
"In the output in Listing 9-2, line 6 of the backtrace points to the line in "
"our project that’s causing the problem: line 4 of _src/main.rs_. If we don’t "
"want our program to panic, we should start our investigation at the location "
"pointed to by the first line mentioning a file we wrote. In Listing 9-1, "
"where we deliberately wrote code that would panic, the way to fix the panic "
"is to not request an element beyond the range of the vector indexes. When "
"your code panics in the future, you’ll need to figure out what action the "
"code is taking with what values to cause the panic and what the code should "
"do instead."
msgstr "목록 9-2의 출력에서 백트레이스의 6번째 줄은 문제의 원인이 되는 프로젝트의 줄, 즉 _src/main.rs_의 4번째 줄을 가리킵니다. 프로그램이 패닉을 일으키지 않기를 원한다면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치에서 조사를 시작해야 합니다. 목록 9-1에서 의도적으로 패닉을 일으킬 코드를 작성한 경우, 패닉을 해결하는 방법은 벡터 인덱스 범위를 벗어난 요소를 요청하지 않는 것입니다. 앞으로 코드가 패닉을 일으키면, 어떤 값으로 어떤 동작을 수행하여 패닉을 일으키는지, 그리고 코드가 대신 무엇을 해야 하는지 파악해야 할 것입니다."

#: src/ch09-01-unrecoverable-errors-with-panic.md:183
msgid ""
"We’ll come back to `panic!` and when we should and should not use `panic!` "
"to handle error conditions in the [“To `panic!` or Not to `panic!`”](ch09-03-"
"to-panic-or-not-to-panic.html#to-panic-or-not-to-panic)<!-- ignore --> "
"section later in this chapter. Next, we’ll look at how to recover from an "
"error using `Result`."
msgstr "이 장의 뒷부분에 있는 [“`panic!`을 사용할 것인가 말 것인가”](ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic)<!-- ignore --> 섹션에서 `panic!`과 오류 상황을 처리하기 위해 `panic!`을 사용해야 하는 경우와 사용하지 말아야 하는 경우에 대해 다시 다룰 것입니다. 다음으로, `Result`를 사용하여 오류에서 복구하는 방법을 살펴보겠습니다."

#: src/ch09-02-recoverable-errors-with-result.md:3
msgid ""
"Most errors aren’t serious enough to require the program to stop entirely. "
"Sometimes when a function fails it’s for a reason that you can easily "
"interpret and respond to. For example, if you try to open a file and that "
"operation fails because the file doesn’t exist, you might want to create the "
"file instead of terminating the process."
msgstr "대부분의 오류는 프로그램이 완전히 중단될 정도로 심각하지 않습니다. 때로는 함수가 실패하는 이유를 쉽게 해석하고 대응할 수 있습니다. 예를 들어, 파일을 열려고 시도했는데 파일이 존재하지 않아 작업이 실패하면, 프로세스를 종료하는 대신 파일을 생성하고 싶을 수 있습니다."

#: src/ch09-02-recoverable-errors-with-result.md:9
msgid ""
"Recall from [“Handling Potential Failure with `Result`”](ch02-00-guessing-"
"game-tutorial.html#handling-potential-failure-with-result)<!--\n"
"ignore --> in Chapter 2 that the `Result` enum is defined as having two "
"variants, `Ok` and `Err`, as follows:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:20
msgid ""
"The `T` and `E` are generic type parameters: we’ll discuss generics in more "
"detail in Chapter 10. What you need to know right now is that `T` represents "
"the type of the value that will be returned in a success case within the "
"`Ok` variant, and `E` represents the type of the error that will be returned "
"in a failure case within the `Err` variant. Because `Result` has these "
"generic type parameters, we can use the `Result` type and the functions "
"defined on it in many different situations where the success value and error "
"value we want to return may differ."
msgstr "`T`와 `E`는 제네릭 타입 매개변수입니다. 제네릭에 대해서는 10장에서 더 자세히 논의할 것입니다. 지금 알아야 할 것은 `T`는 `Ok` variant 내에서 성공 시 반환될 값의 타입을 나타내고, `E`는 `Err` variant 내에서 실패 시 반환될 오류의 타입을 나타낸다는 것입니다. `Result`는 이러한 제네릭 타입 매개변수를 가지므로, 성공 값과 오류 값이 다를 수 있는 다양한 상황에서 `Result` 타입과 그 위에 정의된 함수를 사용할 수 있습니다."

#: src/ch09-02-recoverable-errors-with-result.md:29
msgid ""
"Let’s call a function that returns a `Result` value because the function "
"could fail. In Listing 9-3 we try to open a file."
msgstr "함수가 실패할 수 있으므로 `Result` 값을 반환하는 함수를 호출해 봅시다. 목록 9-3에서 파일을 열려고 시도합니다."

#: src/ch09-02-recoverable-errors-with-result.md:38
#: src/ch09-02-recoverable-errors-with-result.md:72
#: src/ch09-02-recoverable-errors-with-result.md:129
#: src/ch09-02-recoverable-errors-with-result.md:134
#: src/ch09-02-recoverable-errors-with-result.md:182
#: src/ch09-02-recoverable-errors-with-result.md:184
#: src/ch09-02-recoverable-errors-with-result.md:216
#: src/ch09-02-recoverable-errors-with-result.md:247
#: src/ch09-02-recoverable-errors-with-result.md:299
#: src/ch09-02-recoverable-errors-with-result.md:385
#: src/ch09-02-recoverable-errors-with-result.md:442
#: src/ch09-02-recoverable-errors-with-result.md:472
#: src/ch09-02-recoverable-errors-with-result.md:505
#: src/ch09-02-recoverable-errors-with-result.md:624
msgid "\"hello.txt\""
msgstr "\"hello.txt\""

#: src/ch09-02-recoverable-errors-with-result.md:44
msgid ""
"The return type of `File::open` is a `Result<T, E>`. The generic parameter "
"`T` has been filled in by the implementation of `File::open` with the type "
"of the success value, `std::fs::File`, which is a file handle. The type of "
"`E` used in the error value is `std::io::Error`. This return type means the "
"call to `File::open` might succeed and return a file handle that we can read "
"from or write to. The function call also might fail: for example, the file "
"might not exist, or we might not have permission to access the file. The "
"`File::open` function needs to have a way to tell us whether it succeeded or "
"failed and at the same time give us either the file handle or error "
"information. This information is exactly what the `Result` enum conveys."
msgstr "`File::open`의 반환 타입은 `Result<T, E>`입니다. 제네릭 매개변수 `T`는 `File::open`의 구현에 의해 성공 값의 타입인 `std::fs::File` (파일 핸들)로 채워졌습니다. 오류 값에 사용된 `E`의 타입은 `std::io::Error`입니다. 이 반환 타입은 `File::open` 호출이 성공하여 읽거나 쓸 수 있는 파일 핸들을 반환할 수도 있고, 실패할 수도 있음을 의미합니다. 예를 들어, 파일이 존재하지 않거나 파일에 접근할 권한이 없을 수 있습니다. `File::open` 함수는 성공했는지 실패했는지 알려주는 방법과 동시에 파일 핸들 또는 오류 정보를 제공해야 합니다. 이 정보가 바로 `Result` 열거형이 전달하는 내용입니다."

#: src/ch09-02-recoverable-errors-with-result.md:55
msgid ""
"In the case where `File::open` succeeds, the value in the variable "
"`greeting_file_result` will be an instance of `Ok` that contains a file "
"handle. In the case where it fails, the value in `greeting_file_result` will "
"be an instance of `Err` that contains more information about the kind of "
"error that occurred."
msgstr "`File::open`이 성공하는 경우, `greeting_file_result` 변수의 값은 파일 핸들을 포함하는 `Ok` 인스턴스가 될 것입니다. 실패하는 경우, `greeting_file_result`의 값은 발생한 오류 종류에 대한 더 많은 정보를 포함하는 `Err` 인스턴스가 될 것입니다."

#: src/ch09-02-recoverable-errors-with-result.md:61
msgid ""
"We need to add to the code in Listing 9-3 to take different actions "
"depending on the value `File::open` returns. Listing 9-4 shows one way to "
"handle the `Result` using a basic tool, the `match` expression that we "
"discussed in Chapter 6."
msgstr "목록 9-3의 코드에 `File::open`이 반환하는 값에 따라 다른 동작을 취하도록 추가해야 합니다. 목록 9-4는 6장에서 논의했던 기본 도구인 `match` 표현식을 사용하여 `Result`를 처리하는 한 가지 방법을 보여줍니다."

#: src/ch09-02-recoverable-errors-with-result.md:76
#: src/ch09-02-recoverable-errors-with-result.md:188
msgid "\"Problem opening the file: {error:?}\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:83
msgid ""
"Note that, like the `Option` enum, the `Result` enum and its variants have "
"been brought into scope by the prelude, so we don’t need to specify "
"`Result::` before the `Ok` and `Err` variants in the `match` arms."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:87
msgid ""
"When the result is `Ok`, this code will return the inner `file` value out of "
"the `Ok` variant, and we then assign that file handle value to the variable "
"`greeting_file`. After the `match`, we can use the file handle for reading "
"or writing."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:92
msgid ""
"The other arm of the `match` handles the case where we get an `Err` value "
"from `File::open`. In this example, we’ve chosen to call the `panic!` macro. "
"If there’s no file named _hello.txt_ in our current directory and we run "
"this code, we’ll see the following output from the `panic!` macro:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:97
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n"
"     Running `target/debug/error-handling`\n"
"thread 'main' panicked at src/main.rs:8:23:\n"
"Problem opening the file: Os { code: 2, kind: NotFound, message: \"No such "
"file or directory\" }\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:107
msgid "As usual, this output tells us exactly what has gone wrong."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:109
msgid "Matching on Different Errors"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:111
msgid ""
"The code in Listing 9-4 will `panic!` no matter why `File::open` failed. "
"However, we want to take different actions for different failure reasons. If "
"`File::open` failed because the file doesn’t exist, we want to create the "
"file and return the handle to the new file. If `File::open` failed for any "
"other reason—for example, because we didn’t have permission to open the file—"
"we still want the code to `panic!` in the same way it did in Listing 9-4. "
"For this, we add an inner `match` expression, shown in Listing 9-5."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:136
msgid "\"Problem creating the file: {e:?}\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:139
msgid "\"Problem opening the file: {other_error:?}\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:148
msgid ""
"The type of the value that `File::open` returns inside the `Err` variant is "
"`io::Error`, which is a struct provided by the standard library. This struct "
"has a method `kind` that we can call to get an `io::ErrorKind` value. The "
"enum `io::ErrorKind` is provided by the standard library and has variants "
"representing the different kinds of errors that might result from an `io` "
"operation. The variant we want to use is `ErrorKind::NotFound`, which "
"indicates the file we’re trying to open doesn’t exist yet. So we match on "
"`greeting_file_result`, but we also have an inner match on `error.kind()`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:157
msgid ""
"The condition we want to check in the inner match is whether the value "
"returned by `error.kind()` is the `NotFound` variant of the `ErrorKind` "
"enum. If it is, we try to create the file with `File::create`. However, "
"because `File::create` could also fail, we need a second arm in the inner "
"`match` expression. When the file can’t be created, a different error "
"message is printed. The second arm of the outer `match` stays the same, so "
"the program panics on any error besides the missing file error."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:165
msgid "Alternatives to Using `match` with `Result<T, E>`"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:167
msgid ""
"That’s a lot of `match`! The `match` expression is very useful but also very "
"much a primitive. In Chapter 13, you’ll learn about closures, which are used "
"with many of the methods defined on `Result<T, E>`. These methods can be "
"more concise than using `match` when handling `Result<T, E>` values in your "
"code."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:172
msgid ""
"For example, here’s another way to write the same logic as shown in Listing "
"9-5, this time using closures and the `unwrap_or_else` method:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:185
msgid "\"Problem creating the file: {error:?}\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:194
msgid ""
"Although this code has the same behavior as Listing 9-5, it doesn’t contain "
"any `match` expressions and is cleaner to read. Come back to this example "
"after you’ve read Chapter 13, and look up the `unwrap_or_else` method in the "
"standard library documentation. Many more of these methods can clean up huge "
"nested `match` expressions when you’re dealing with errors."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:200
msgid "Shortcuts for Panic on Error: `unwrap` and `expect`"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:202
msgid ""
"Using `match` works well enough, but it can be a bit verbose and doesn’t "
"always communicate intent well. The `Result<T, E>` type has many helper "
"methods defined on it to do various, more specific tasks. The `unwrap` "
"method is a shortcut method implemented just like the `match` expression we "
"wrote in Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` "
"will return the value inside the `Ok`. If the `Result` is the `Err` variant, "
"`unwrap` will call the `panic!` macro for us. Here is an example of `unwrap` "
"in action:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:222
msgid ""
"If we run this code without a _hello.txt_ file, we’ll see an error message "
"from the `panic!` call that the `unwrap` method makes:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:231
msgid ""
"```text\n"
"thread 'main' panicked at src/main.rs:4:49:\n"
"called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, "
"message: \"No such file or directory\" }\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:236
msgid ""
"Similarly, the `expect` method lets us also choose the `panic!` error "
"message. Using `expect` instead of `unwrap` and providing good error "
"messages can convey your intent and make tracking down the source of a panic "
"easier. The syntax of `expect` looks like this:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:248
msgid "\"hello.txt should be included in this project\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:254
msgid ""
"We use `expect` in the same way as `unwrap`: to return the file handle or "
"call the `panic!` macro. The error message used by `expect` in its call to "
"`panic!` will be the parameter that we pass to `expect`, rather than the "
"default `panic!` message that `unwrap` uses. Here’s what it looks like:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:265
msgid ""
"```text\n"
"thread 'main' panicked at src/main.rs:5:10:\n"
"hello.txt should be included in this project: Os { code: 2, kind: NotFound, "
"message: \"No such file or directory\" }\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:270
msgid ""
"In production-quality code, most Rustaceans choose `expect` rather than "
"`unwrap` and give more context about why the operation is expected to always "
"succeed. That way, if your assumptions are ever proven wrong, you have more "
"information to use in debugging."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:275
msgid "Propagating Errors"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:277
msgid ""
"When a function’s implementation calls something that might fail, instead of "
"handling the error within the function itself you can return the error to "
"the calling code so that it can decide what to do. This is known as "
"_propagating_ the error and gives more control to the calling code, where "
"there might be more information or logic that dictates how the error should "
"be handled than what you have available in the context of your code."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:284
msgid ""
"For example, Listing 9-6 shows a function that reads a username from a file. "
"If the file doesn’t exist or can’t be read, this function will return those "
"errors to the code that called the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:317
msgid ""
"This function can be written in a much shorter way, but we’re going to start "
"by doing a lot of it manually in order to explore error handling; at the "
"end, we’ll show the shorter way. Let’s look at the return type of the "
"function first: `Result<String, io::Error>`. This means the function is "
"returning a value of the type `Result<T, E>`, where the generic parameter "
"`T` has been filled in with the concrete type `String` and the generic type "
"`E` has been filled in with the concrete type `io::Error`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:325
msgid ""
"If this function succeeds without any problems, the code that calls this "
"function will receive an `Ok` value that holds a `String`—the `username` "
"that this function read from the file. If this function encounters any "
"problems, the calling code will receive an `Err` value that holds an "
"instance of `io::Error` that contains more information about what the "
"problems were. We chose `io::Error` as the return type of this function "
"because that happens to be the type of the error value returned from both of "
"the operations we’re calling in this function’s body that might fail: the "
"`File::open` function and the `read_to_string` method."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:335
msgid ""
"The body of the function starts by calling the `File::open` function. Then "
"we handle the `Result` value with a `match` similar to the `match` in "
"Listing 9-4. If `File::open` succeeds, the file handle in the pattern "
"variable `file` becomes the value in the mutable variable `username_file` "
"and the function continues. In the `Err` case, instead of calling `panic!`, "
"we use the `return` keyword to return early out of the function entirely and "
"pass the error value from `File::open`, now in the pattern variable `e`, "
"back to the calling code as this function’s error value."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:344
msgid ""
"So, if we have a file handle in `username_file`, the function then creates a "
"new `String` in variable `username` and calls the `read_to_string` method on "
"the file handle in `username_file` to read the contents of the file into "
"`username`. The `read_to_string` method also returns a `Result` because it "
"might fail, even though `File::open` succeeded. So we need another `match` "
"to handle that `Result`: if `read_to_string` succeeds, then our function has "
"succeeded, and we return the username from the file that’s now in `username` "
"wrapped in an `Ok`. If `read_to_string` fails, we return the error value in "
"the same way that we returned the error value in the `match` that handled "
"the return value of `File::open`. However, we don’t need to explicitly say "
"`return`, because this is the last expression in the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:356
msgid ""
"The code that calls this code will then handle getting either an `Ok` value "
"that contains a username or an `Err` value that contains an `io::Error`. "
"It’s up to the calling code to decide what to do with those values. If the "
"calling code gets an `Err` value, it could call `panic!` and crash the "
"program, use a default username, or look up the username from somewhere "
"other than a file, for example. We don’t have enough information on what the "
"calling code is actually trying to do, so we propagate all the success or "
"error information upward for it to handle appropriately."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:365
msgid ""
"This pattern of propagating errors is so common in Rust that Rust provides "
"the question mark operator `?` to make this easier."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:368
msgid "A Shortcut for Propagating Errors: the `?` Operator"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:370
msgid ""
"Listing 9-7 shows an implementation of `read_username_from_file` that has "
"the same functionality as in Listing 9-6, but this implementation uses the `?"
"` operator."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:394
msgid ""
"The `?` placed after a `Result` value is defined to work in almost the same "
"way as the `match` expressions we defined to handle the `Result` values in "
"Listing 9-6. If the value of the `Result` is an `Ok`, the value inside the "
"`Ok` will get returned from this expression, and the program will continue. "
"If the value is an `Err`, the `Err` will be returned from the whole function "
"as if we had used the `return` keyword so the error value gets propagated to "
"the calling code."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:402
msgid ""
"There is a difference between what the `match` expression from Listing 9-6 "
"does and what the `?` operator does: error values that have the `?` operator "
"called on them go through the `from` function, defined in the `From` trait "
"in the standard library, which is used to convert values from one type into "
"another. When the `?` operator calls the `from` function, the error type "
"received is converted into the error type defined in the return type of the "
"current function. This is useful when a function returns one error type to "
"represent all the ways a function might fail, even if parts might fail for "
"many different reasons."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:412
msgid ""
"For example, we could change the `read_username_from_file` function in "
"Listing 9-7 to return a custom error type named `OurError` that we define. "
"If we also define `impl From<io::Error> for OurError` to construct an "
"instance of `OurError` from an `io::Error`, then the `?` operator calls in "
"the body of `read_username_from_file` will call `from` and convert the error "
"types without needing to add any more code to the function."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:419
msgid ""
"In the context of Listing 9-7, the `?` at the end of the `File::open` call "
"will return the value inside an `Ok` to the variable `username_file`. If an "
"error occurs, the `?` operator will return early out of the whole function "
"and give any `Err` value to the calling code. The same thing applies to the "
"`?` at the end of the `read_to_string` call."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:425
msgid ""
"The `?` operator eliminates a lot of boilerplate and makes this function’s "
"implementation simpler. We could even shorten this code further by chaining "
"method calls immediately after the `?`, as shown in Listing 9-8."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:450
msgid ""
"We’ve moved the creation of the new `String` in `username` to the beginning "
"of the function; that part hasn’t changed. Instead of creating a variable "
"`username_file`, we’ve chained the call to `read_to_string` directly onto "
"the result of `File::open(\"hello.txt\")?`. We still have a `?` at the end "
"of the `read_to_string` call, and we still return an `Ok` value containing "
"`username` when both `File::open` and `read_to_string` succeed rather than "
"returning errors. The functionality is again the same as in Listing 9-6 and "
"Listing 9-7; this is just a different, more ergonomic way to write it."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:459
msgid ""
"Listing 9-9 shows a way to make this even shorter using `fs::read_to_string`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:478
msgid ""
"Reading a file into a string is a fairly common operation, so the standard "
"library provides the convenient `fs::read_to_string` function that opens the "
"file, creates a new `String`, reads the contents of the file, puts the "
"contents into that `String`, and returns it. Of course, using "
"`fs::read_to_string` doesn’t give us the opportunity to explain all the "
"error handling, so we did it the longer way first."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:485
msgid "Where The `?` Operator Can Be Used"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:487
msgid ""
"The `?` operator can only be used in functions whose return type is "
"compatible with the value the `?` is used on. This is because the `?` "
"operator is defined to perform an early return of a value out of the "
"function, in the same manner as the `match` expression we defined in Listing "
"9-6. In Listing 9-6, the `match` was using a `Result` value, and the early "
"return arm returned an `Err(e)` value. The return type of the function has "
"to be a `Result` so that it’s compatible with this `return`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:495
msgid ""
"In Listing 9-10, let’s look at the error we’ll get if we use the `?` "
"operator in a `main` function with a return type that is incompatible with "
"the type of the value we use `?` on."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:511
msgid ""
"This code opens a file, which might fail. The `?` operator follows the "
"`Result` value returned by `File::open`, but this `main` function has the "
"return type of `()`, not `Result`. When we compile this code, we get the "
"following error message:"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:516
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n"
"error[E0277]: the `?` operator can only be used in a function that returns "
"`Result` or `Option` (or another type that implements `FromResidual`)\n"
" --> src/main.rs:4:48\n"
"  |\n"
"3 | fn main() {\n"
"  | --------- this function should return `Result` or `Option` to accept `?"
"`\n"
"4 |     let greeting_file = File::open(\"hello.txt\")?;\n"
"  |                                                ^ cannot use the `?` "
"operator in a function that returns `()`\n"
"  |\n"
"  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is "
"not implemented for `()`\n"
"help: consider adding return type\n"
"  |\n"
"3 ~ fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"4 |     let greeting_file = File::open(\"hello.txt\")?;\n"
"5 +     Ok(())\n"
"  |\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `error-handling` (bin \"error-handling\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:539
msgid ""
"This error points out that we’re only allowed to use the `?` operator in a "
"function that returns `Result`, `Option`, or another type that implements "
"`FromResidual`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:543
msgid ""
"To fix the error, you have two choices. One choice is to change the return "
"type of your function to be compatible with the value you’re using the `?` "
"operator on as long as you have no restrictions preventing that. The other "
"choice is to use a `match` or one of the `Result<T, E>` methods to handle "
"the `Result<T, E>` in whatever way is appropriate."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:549
msgid ""
"The error message also mentioned that `?` can be used with `Option<T>` "
"values as well. As with using `?` on `Result`, you can only use `?` on "
"`Option` in a function that returns an `Option`. The behavior of the `?` "
"operator when called on an `Option<T>` is similar to its behavior when "
"called on a `Result<T, E>`: if the value is `None`, the `None` will be "
"returned early from the function at that point. If the value is `Some`, the "
"value inside the `Some` is the resultant value of the expression, and the "
"function continues. Listing 9-11 has an example of a function that finds the "
"last character of the first line in the given text."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:568
msgid "\"Hello, world\\nHow are you today?\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:569
msgid "'d'"
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:572
#: src/ch18-03-oo-design-patterns.md:52 src/ch18-03-oo-design-patterns.md:55
#: src/ch18-03-oo-design-patterns.md:220 src/ch18-03-oo-design-patterns.md:263
#: src/ch18-03-oo-design-patterns.md:370 src/ch18-03-oo-design-patterns.md:600
#: src/ch18-03-oo-design-patterns.md:751 src/ch18-03-oo-design-patterns.md:754
msgid "\"\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:573
msgid "\"\\nhi\""
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:579
msgid ""
"This function returns `Option<char>` because it’s possible that there is a "
"character there, but it’s also possible that there isn’t. This code takes "
"the `text` string slice argument and calls the `lines` method on it, which "
"returns an iterator over the lines in the string. Because this function "
"wants to examine the first line, it calls `next` on the iterator to get the "
"first value from the iterator. If `text` is the empty string, this call to "
"`next` will return `None`, in which case we use `?` to stop and return "
"`None` from `last_char_of_first_line`. If `text` is not the empty string, "
"`next` will return a `Some` value containing a string slice of the first "
"line in `text`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:589
msgid ""
"The `?` extracts the string slice, and we can call `chars` on that string "
"slice to get an iterator of its characters. We’re interested in the last "
"character in this first line, so we call `last` to return the last item in "
"the iterator. This is an `Option` because it’s possible that the first line "
"is the empty string; for example, if `text` starts with a blank line but has "
"characters on other lines, as in `\"\\nhi\"`. However, if there is a last "
"character on the first line, it will be returned in the `Some` variant. The "
"`?` operator in the middle gives us a concise way to express this logic, "
"allowing us to implement the function in one line. If we couldn’t use the `?"
"` operator on `Option`, we’d have to implement this logic using more method "
"calls or a `match` expression."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:600
msgid ""
"Note that you can use the `?` operator on a `Result` in a function that "
"returns `Result`, and you can use the `?` operator on an `Option` in a "
"function that returns `Option`, but you can’t mix and match. The `?` "
"operator won’t automatically convert a `Result` to an `Option` or vice "
"versa; in those cases, you can use methods like the `ok` method on `Result` "
"or the `ok_or` method on `Option` to do the conversion explicitly."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:607
msgid ""
"So far, all the `main` functions we’ve used return `()`. The `main` function "
"is special because it’s the entry point and exit point of an executable "
"program, and there are restrictions on what its return type can be for the "
"program to behave as expected."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:612
msgid ""
"Luckily, `main` can also return a `Result<(), E>`. Listing 9-12 has the code "
"from Listing 9-10, but we’ve changed the return type of `main` to be "
"`Result<(), Box<dyn Error>>` and added a return value `Ok(())` to the end. "
"This code will now compile."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:632
msgid ""
"The `Box<dyn Error>` type is a _trait object_, which we’ll talk about in "
"[“Using Trait Objects That Allow for Values of Different Types”](ch18-02-"
"trait-objects.html#using-trait-objects-that-allow-for-values-of-different-"
"types)<!--\n"
"ignore --> in Chapter 18. For now, you can read `Box<dyn Error>` to mean "
"“any kind of error.” Using `?` on a `Result` value in a `main` function with "
"the error type `Box<dyn Error>` is allowed because it allows any `Err` value "
"to be returned early. Even though the body of this `main` function will only "
"ever return errors of type `std::io::Error`, by specifying `Box<dyn Error>`, "
"this signature will continue to be correct even if more code that returns "
"other errors is added to the body of `main`."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:642
msgid ""
"When a `main` function returns a `Result<(), E>`, the executable will exit "
"with a value of `0` if `main` returns `Ok(())` and will exit with a nonzero "
"value if `main` returns an `Err` value. Executables written in C return "
"integers when they exit: programs that exit successfully return the integer "
"`0`, and programs that error return some integer other than `0`. Rust also "
"returns integers from executables to be compatible with this convention."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:649
msgid ""
"The `main` function may return any types that implement [the "
"`std::process::Termination` trait](../std/process/"
"trait.Termination.html)<!-- ignore -->, which contains a function `report` "
"that returns an `ExitCode`. Consult the standard library documentation for "
"more information on implementing the `Termination` trait for your own types."
msgstr ""

#: src/ch09-02-recoverable-errors-with-result.md:655
msgid ""
"Now that we’ve discussed the details of calling `panic!` or returning "
"`Result`, let’s return to the topic of how to decide which is appropriate to "
"use in which cases."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:3
msgid ""
"So how do you decide when you should call `panic!` and when you should "
"return `Result`? When code panics, there’s no way to recover. You could call "
"`panic!` for any error situation, whether there’s a possible way to recover "
"or not, but then you’re making the decision that a situation is "
"unrecoverable on behalf of the calling code. When you choose to return a "
"`Result` value, you give the calling code options. The calling code could "
"choose to attempt to recover in a way that’s appropriate for its situation, "
"or it could decide that an `Err` value in this case is unrecoverable, so it "
"can call `panic!` and turn your recoverable error into an unrecoverable one. "
"Therefore, returning `Result` is a good default choice when you’re defining "
"a function that might fail."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:14
msgid ""
"In situations such as examples, prototype code, and tests, it’s more "
"appropriate to write code that panics instead of returning a `Result`. Let’s "
"explore why, then discuss situations in which the compiler can’t tell that "
"failure is impossible, but you as a human can. The chapter will conclude "
"with some general guidelines on how to decide whether to panic in library "
"code."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:20
msgid "Examples, Prototype Code, and Tests"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:22
msgid ""
"When you’re writing an example to illustrate some concept, also including "
"robust error-handling code can make the example less clear. In examples, "
"it’s understood that a call to a method like `unwrap` that could panic is "
"meant as a placeholder for the way you’d want your application to handle "
"errors, which can differ based on what the rest of your code is doing."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:28
msgid ""
"Similarly, the `unwrap` and `expect` methods are very handy when "
"prototyping, before you’re ready to decide how to handle errors. They leave "
"clear markers in your code for when you’re ready to make your program more "
"robust."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:32
msgid ""
"If a method call fails in a test, you’d want the whole test to fail, even if "
"that method isn’t the functionality under test. Because `panic!` is how a "
"test is marked as a failure, calling `unwrap` or `expect` is exactly what "
"should happen."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:37
msgid "Cases in Which You Have More Information Than the Compiler"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:39
msgid ""
"It would also be appropriate to call `unwrap` or `expect` when you have some "
"other logic that ensures the `Result` will have an `Ok` value, but the logic "
"isn’t something the compiler understands. You’ll still have a `Result` value "
"that you need to handle: whatever operation you’re calling still has the "
"possibility of failing in general, even though it’s logically impossible in "
"your particular situation. If you can ensure by manually inspecting the code "
"that you’ll never have an `Err` variant, it’s perfectly acceptable to call "
"`unwrap`, and even better to document the reason you think you’ll never have "
"an `Err` variant in the `expect` text. Here’s an example:"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:55
msgid "\"Hardcoded IP address should be valid\""
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:59
msgid ""
"We’re creating an `IpAddr` instance by parsing a hardcoded string. We can "
"see that `127.0.0.1` is a valid IP address, so it’s acceptable to use "
"`expect` here. However, having a hardcoded, valid string doesn’t change the "
"return type of the `parse` method: we still get a `Result` value, and the "
"compiler will still make us handle the `Result` as if the `Err` variant is a "
"possibility because the compiler isn’t smart enough to see that this string "
"is always a valid IP address. If the IP address string came from a user "
"rather than being hardcoded into the program and therefore _did_ have a "
"possibility of failure, we’d definitely want to handle the `Result` in a "
"more robust way instead. Mentioning the assumption that this IP address is "
"hardcoded will prompt us to change `expect` to better error-handling code "
"if, in the future, we need to get the IP address from some other source "
"instead."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:72
msgid "Guidelines for Error Handling"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:74
msgid ""
"It’s advisable to have your code panic when it’s possible that your code "
"could end up in a bad state. In this context, a _bad state_ is when some "
"assumption, guarantee, contract, or invariant has been broken, such as when "
"invalid values, contradictory values, or missing values are passed to your "
"code—plus one or more of the following:"
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:80
msgid ""
"The bad state is something that is unexpected, as opposed to something that "
"will likely happen occasionally, like a user entering data in the wrong "
"format."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:83
msgid ""
"Your code after this point needs to rely on not being in this bad state, "
"rather than checking for the problem at every step."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:85
msgid ""
"There’s not a good way to encode this information in the types you use. "
"We’ll work through an example of what we mean in [“Encoding States and "
"Behavior as Types”](ch18-03-oo-design-patterns.html#encoding-states-and-"
"behavior-as-types)<!-- ignore --> in Chapter 18."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:89
msgid ""
"If someone calls your code and passes in values that don’t make sense, it’s "
"best to return an error if you can so the user of the library can decide "
"what they want to do in that case. However, in cases where continuing could "
"be insecure or harmful, the best choice might be to call `panic!` and alert "
"the person using your library to the bug in their code so they can fix it "
"during development. Similarly, `panic!` is often appropriate if you’re "
"calling external code that is out of your control and it returns an invalid "
"state that you have no way of fixing."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:98
msgid ""
"However, when failure is expected, it’s more appropriate to return a "
"`Result` than to make a `panic!` call. Examples include a parser being given "
"malformed data or an HTTP request returning a status that indicates you have "
"hit a rate limit. In these cases, returning a `Result` indicates that "
"failure is an expected possibility that the calling code must decide how to "
"handle."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:104
msgid ""
"When your code performs an operation that could put a user at risk if it’s "
"called using invalid values, your code should verify the values are valid "
"first and panic if the values aren’t valid. This is mostly for safety "
"reasons: attempting to operate on invalid data can expose your code to "
"vulnerabilities. This is the main reason the standard library will call "
"`panic!` if you attempt an out-of-bounds memory access: trying to access "
"memory that doesn’t belong to the current data structure is a common "
"security problem. Functions often have _contracts_: their behavior is only "
"guaranteed if the inputs meet particular requirements. Panicking when the "
"contract is violated makes sense because a contract violation always "
"indicates a caller-side bug, and it’s not a kind of error you want the "
"calling code to have to explicitly handle. In fact, there’s no reasonable "
"way for calling code to recover; the calling _programmers_ need to fix the "
"code. Contracts for a function, especially when a violation will cause a "
"panic, should be explained in the API documentation for the function."
msgstr ""

#: src/ch09-03-to-panic-or-not-to-panic.md:119
msgid ""
"However, having lots of error checks in all of your functions would be "
"verbose and annoying. Fortunately, you can use Rust’s type system (and thus "
"the type checking done by the compiler) to do many of the checks for you. If "
"your function has a particular type as a parameter, you can proceed with "
"your code’s logic knowing that the compiler has already ensured you have a "
"valid value. For example, if you have a type rather than an `Option`, your "
"program expects to have _something_ rather than _nothing_. Your code then "
"doesn’t have to handle two cases for the `Some` and `None` variants: it will "
"only have one case for definitely having a value. Code trying to pass "
"nothing to your function won’t even compile, so your function doesn’t have "
"to check for that case at runtime. Another example is using an unsigned "
"integer type such as `u32`, which ensures the parameter is never negative."
msgstr "하지만 모든 함수에 많은 오류 검사를 넣는 것은 장황하고 번거로울 것입니다. 다행히 러스트의 타입 시스템(따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 대신 수행할 수 있습니다. 함수가 특정 타입을 매개변수로 가진다면, 컴파일러가 이미 유효한 값을 가지고 있음을 보장했으므로 코드의 로직을 진행할 수 있습니다. 예를 들어, `Option` 대신 타입을 가지고 있다면, 프로그램은 _아무것도 없음_이 아니라 _무언가_를 가질 것으로 예상합니다. 그러면 코드는 `Some`과 `None` variant에 대해 두 가지 경우를 처리할 필요가 없습니다. 확실히 값을 가지는 한 가지 경우만 처리하면 됩니다. 함수에 아무것도 전달하지 않으려는 코드는 컴파일조차 되지 않으므로, 함수는 런타임에 해당 경우를 확인할 필요가 없습니다. 또 다른 예는 매개변수가 절대 음수가 아님을 보장하는 `u32`와 같은 부호 없는 정수 타입을 사용하는 것입니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:132
msgid "Creating Custom Types for Validation"
msgstr "유효성 검사를 위한 사용자 정의 타입 생성하기"

#: src/ch09-03-to-panic-or-not-to-panic.md:134
msgid ""
"Let’s take the idea of using Rust’s type system to ensure we have a valid "
"value one step further and look at creating a custom type for validation. "
"Recall the guessing game in Chapter 2 in which our code asked the user to "
"guess a number between 1 and 100. We never validated that the user’s guess "
"was between those numbers before checking it against our secret number; we "
"only validated that the guess was positive. In this case, the consequences "
"were not very dire: our output of “Too high” or “Too low” would still be "
"correct. But it would be a useful enhancement to guide the user toward valid "
"guesses and have different behavior when the user guesses a number that’s "
"out of range versus when the user types, for example, letters instead."
msgstr "러스트의 타입 시스템을 사용하여 유효한 값을 보장하는 아이디어를 한 단계 더 나아가 유효성 검사를 위한 사용자 정의 타입을 생성하는 방법을 살펴보겠습니다. 2장의 추측 게임에서 우리 코드가 사용자에게 1에서 100 사이의 숫자를 추측하도록 요청했던 것을 기억하세요. 우리는 사용자의 추측이 비밀 숫자와 비교하기 전에 해당 숫자들 사이에 있는지 유효성 검사를 하지 않았습니다. 단지 추측이 양수인지 여부만 유효성 검사했습니다. 이 경우 결과는 그리 심각하지 않았습니다. \"너무 높음\" 또는 \"너무 낮음\"이라는 출력은 여전히 올바를 것입니다. 하지만 사용자가 유효한 추측을 하도록 안내하고, 사용자가 범위를 벗어난 숫자를 추측하거나 예를 들어 문자를 입력할 때 다른 동작을 하도록 하는 유용한 개선 사항이 될 것입니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:145
msgid ""
"One way to do this would be to parse the guess as an `i32` instead of only a "
"`u32` to allow potentially negative numbers, and then add a check for the "
"number being in range, like so:"
msgstr "이를 수행하는 한 가지 방법은 추측을 `u32` 대신 `i32`로 파싱하여 잠재적으로 음수를 허용하고, 그런 다음 다음과 같이 숫자가 범위 내에 있는지 확인하는 검사를 추가하는 것입니다:"

#: src/ch09-03-to-panic-or-not-to-panic.md:178
msgid "\"The secret number will be between 1 and 100.\""
msgstr "\"비밀 숫자는 1에서 100 사이입니다.\""

#: src/ch09-03-to-panic-or-not-to-panic.md:197
msgid ""
"The `if` expression checks whether our value is out of range, tells the user "
"about the problem, and calls `continue` to start the next iteration of the "
"loop and ask for another guess. After the `if` expression, we can proceed "
"with the comparisons between `guess` and the secret number knowing that "
"`guess` is between 1 and 100."
msgstr "`if` 표현식은 값이 범위를 벗어났는지 확인하고, 사용자에게 문제를 알리고, `continue`를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. `if` 표현식 이후에는 `guess`가 1에서 100 사이임을 알고 `guess`와 비밀 숫자 간의 비교를 진행할 수 있습니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:203
msgid ""
"However, this is not an ideal solution: if it were absolutely critical that "
"the program only operated on values between 1 and 100, and it had many "
"functions with this requirement, having a check like this in every function "
"would be tedious (and might impact performance)."
msgstr "하지만 이것은 이상적인 해결책이 아닙니다. 만약 프로그램이 1에서 100 사이의 값으로만 작동하는 것이 절대적으로 중요하고, 이러한 요구 사항을 가진 함수가 많다면, 모든 함수에 이러한 검사를 포함하는 것은 지루할 것이며 (성능에 영향을 미칠 수도 있습니다)."

#: src/ch09-03-to-panic-or-not-to-panic.md:208
msgid ""
"Instead, we can make a new type and put the validations in a function to "
"create an instance of the type rather than repeating the validations "
"everywhere. That way, it’s safe for functions to use the new type in their "
"signatures and confidently use the values they receive. Listing 9-13 shows "
"one way to define a `Guess` type that will only create an instance of "
"`Guess` if the `new` function receives a value between 1 and 100."
msgstr "대신, 새로운 타입을 만들고 유효성 검사를 함수에 넣어 타입의 인스턴스를 생성하도록 할 수 있습니다. 이렇게 하면 모든 곳에서 유효성 검사를 반복할 필요가 없습니다. 그렇게 하면 함수가 시그니처에서 새로운 타입을 안전하게 사용하고 받은 값을 확신을 가지고 사용할 수 있습니다. 목록 9-13은 `new` 함수가 1에서 100 사이의 값을 받을 때만 `Guess`의 인스턴스를 생성하는 `Guess` 타입을 정의하는 한 가지 방법을 보여줍니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:225
#: src/ch11-01-writing-tests.md:863
#: src/ch11-01-writing-tests.md:919
msgid "\"Guess value must be between 1 and 100, got {value}.\""
msgstr "추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:239
msgid ""
"First we define a struct named `Guess` that has a field named `value` that "
"holds an `i32`. This is where the number will be stored."
msgstr "먼저 `value`라는 `i32` 타입의 필드를 가진 `Guess`라는 구조체를 정의합니다. 여기에 숫자가 저장될 것입니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:242
msgid ""
"Then we implement an associated function named `new` on `Guess` that creates "
"instances of `Guess` values. The `new` function is defined to have one "
"parameter named `value` of type `i32` and to return a `Guess`. The code in "
"the body of the `new` function tests `value` to make sure it’s between 1 and "
"100. If `value` doesn’t pass this test, we make a `panic!` call, which will "
"alert the programmer who is writing the calling code that they have a bug "
"they need to fix, because creating a `Guess` with a `value` outside this "
"range would violate the contract that `Guess::new` is relying on. The "
"conditions in which `Guess::new` might panic should be discussed in its "
"public-facing API documentation; we’ll cover documentation conventions "
"indicating the possibility of a `panic!` in the API documentation that you "
"create in Chapter 14. If `value` does pass the test, we create a new `Guess` "
"with its `value` field set to the `value` parameter and return the `Guess`."
msgstr "그런 다음 `Guess`에 `new`라는 연관 함수를 구현하여 `Guess` 값의 인스턴스를 생성합니다. `new` 함수는 `i32` 타입의 `value`라는 매개변수 하나를 가지고 `Guess`를 반환하도록 정의됩니다. `new` 함수의 본문 코드는 `value`가 1에서 100 사이인지 확인합니다. 만약 `value`가 이 테스트를 통과하지 못하면 `panic!` 호출을 발생시켜, 호출 코드를 작성하는 프로그래머에게 수정해야 할 버그가 있음을 알립니다. 왜냐하면 이 범위를 벗어난 `value`로 `Guess`를 생성하는 것은 `Guess::new`가 의존하는 계약을 위반하기 때문입니다. `Guess::new`가 패닉을 일으킬 수 있는 조건은 공개 API 문서에서 논의되어야 합니다. 14장에서 생성할 API 문서에서 `panic!` 가능성을 나타내는 문서화 규칙을 다룰 것입니다. 만약 `value`가 테스트를 통과하면, `value` 필드가 `value` 매개변수로 설정된 새로운 `Guess`를 생성하고 `Guess`를 반환합니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:256
msgid ""
"Next, we implement a method named `value` that borrows `self`, doesn’t have "
"any other parameters, and returns an `i32`. This kind of method is sometimes "
"called a _getter_ because its purpose is to get some data from its fields "
"and return it. This public method is necessary because the `value` field of "
"the `Guess` struct is private. It’s important that the `value` field be "
"private so code using the `Guess` struct is not allowed to set `value` "
"directly: code outside the module _must_ use the `Guess::new` function to "
"create an instance of `Guess`, thereby ensuring there’s no way for a `Guess` "
"to have a `value` that hasn’t been checked by the conditions in the "
"`Guess::new` function."
msgstr "다음으로, `self`를 빌리고 다른 매개변수는 없으며 `i32`를 반환하는 `value`라는 메서드를 구현합니다. 이러한 종류의 메서드는 필드에서 데이터를 가져와 반환하는 것이 목적이므로 때때로 _게터_라고 불립니다. 이 공개 메서드는 `Guess` 구조체의 `value` 필드가 비공개이기 때문에 필요합니다. `value` 필드가 비공개인 것이 중요한데, 이는 `Guess` 구조체를 사용하는 코드가 `value`를 직접 설정할 수 없도록 하기 위함입니다. 모듈 외부의 코드는 `Guess::new` 함수를 사용하여 `Guess` 인스턴스를 생성해야 하며, 이를 통해 `Guess`가 `Guess::new` 함수의 조건에 의해 확인되지 않은 `value`를 가질 수 없도록 보장합니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:266
msgid ""
"A function that has a parameter or returns only numbers between 1 and 100 "
"could then declare in its signature that it takes or returns a `Guess` "
"rather than an `i32` and wouldn’t need to do any additional checks in its "
"body."
msgstr "매개변수를 가지거나 1에서 100 사이의 숫자만 반환하는 함수는 시그니처에서 `i32` 대신 `Guess`를 받거나 반환한다고 선언할 수 있으며, 본문에서 추가적인 검사를 할 필요가 없습니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:272
msgid ""
"Rust’s error-handling features are designed to help you write more robust "
"code. The `panic!` macro signals that your program is in a state it can’t "
"handle and lets you tell the process to stop instead of trying to proceed "
"with invalid or incorrect values. The `Result` enum uses Rust’s type system "
"to indicate that operations might fail in a way that your code could recover "
"from. You can use `Result` to tell code that calls your code that it needs "
"to handle potential success or failure as well. Using `panic!` and `Result` "
"in the appropriate situations will make your code more reliable in the face "
"of inevitable problems."
msgstr "러스트의 오류 처리 기능은 더 견고한 코드를 작성하는 데 도움이 되도록 설계되었습니다. `panic!` 매크로는 프로그램이 처리할 수 없는 상태에 있음을 알리고, 유효하지 않거나 잘못된 값으로 계속 진행하려고 시도하는 대신 프로세스를 중지하도록 지시합니다. `Result` 열거형은 러스트의 타입 시스템을 사용하여 코드가 복구할 수 있는 방식으로 작업이 실패할 수 있음을 나타냅니다. `Result`를 사용하여 코드를 호출하는 코드에 잠재적인 성공 또는 실패를 처리해야 한다고 알릴 수 있습니다. 적절한 상황에서 `panic!`과 `Result`를 사용하면 피할 수 없는 문제에 직면했을 때 코드를 더 안정적으로 만들 수 있습니다."

#: src/ch09-03-to-panic-or-not-to-panic.md:281
msgid ""
"Now that you’ve seen useful ways that the standard library uses generics "
"with the `Option` and `Result` enums, we’ll talk about how generics work and "
"how you can use them in your code."
msgstr "이제 표준 라이브러리가 `Option` 및 `Result` 열거형과 함께 제네릭을 사용하는 유용한 방법을 보았으니, 제네릭이 어떻게 작동하고 코드에서 어떻게 사용할 수 있는지에 대해 이야기할 것입니다."

#: src/ch10-00-generics.md:3
msgid ""
"Every programming language has tools for effectively handling the "
"duplication of concepts. In Rust, one such tool is _generics_: abstract "
"stand-ins for concrete types or other properties. We can express the "
"behavior of generics or how they relate to other generics without knowing "
"what will be in their place when compiling and running the code."
msgstr "모든 프로그래밍 언어에는 개념의 중복을 효과적으로 처리하기 위한 도구가 있습니다. 러스트에서 그러한 도구 중 하나는 _제네릭_입니다. 제네릭은 구체적인 타입 또는 다른 속성을 위한 추상적인 대체물입니다. 우리는 코드를 컴파일하고 실행할 때 무엇이 그 자리에 올지 알지 못하더라도 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있습니다."

#: src/ch10-00-generics.md:9
msgid ""
"Functions can take parameters of some generic type, instead of a concrete "
"type like `i32` or `String`, in the same way they take parameters with "
"unknown values to run the same code on multiple concrete values. In fact, "
"we’ve already used generics in Chapter 6 with `Option<T>`, in Chapter 8 with "
"`Vec<T>` and `HashMap<K, V>`, and in Chapter 9 with `Result<T, E>`. In this "
"chapter, you’ll explore how to define your own types, functions, and methods "
"with generics!"
msgstr "함수는 `i32`나 `String`과 같은 구체적인 타입 대신 일부 제네릭 타입의 매개변수를 받을 수 있습니다. 이는 알 수 없는 값을 가진 매개변수를 받아 여러 구체적인 값에 대해 동일한 코드를 실행하는 방식과 같습니다. 사실, 우리는 이미 6장에서 `Option<T>`로, 8장에서 `Vec<T>`와 `HashMap<K, V>`로, 9장에서 `Result<T, E>`로 제네릭을 사용했습니다. 이 장에서는 제네릭을 사용하여 자신만의 타입, 함수, 메서드를 정의하는 방법을 탐구할 것입니다!"

#: src/ch10-00-generics.md:16
msgid ""
"First we’ll review how to extract a function to reduce code duplication. "
"We’ll then use the same technique to make a generic function from two "
"functions that differ only in the types of their parameters. We’ll also "
"explain how to use generic types in struct and enum definitions."
msgstr "먼저 코드 중복을 줄이기 위해 함수를 추출하는 방법을 검토할 것입니다. 그런 다음 동일한 기술을 사용하여 매개변수 타입만 다른 두 함수로부터 제네릭 함수를 만들 것입니다. 또한 구조체 및 열거형 정의에서 제네릭 타입을 사용하는 방법을 설명할 것입니다."

#: src/ch10-00-generics.md:21
msgid ""
"Then you’ll learn how to use _traits_ to define behavior in a generic way. "
"You can combine traits with generic types to constrain a generic type to "
"accept only those types that have a particular behavior, as opposed to just "
"any type."
msgstr "그런 다음 _트레이트_를 사용하여 제네릭 방식으로 동작을 정의하는 방법을 배울 것입니다. 트레이트를 제네릭 타입과 결합하여 제네릭 타입이 특정 동작을 가진 타입만 허용하도록 제한할 수 있습니다. 단순히 어떤 타입이든 허용하는 것이 아니라 말이죠."

#: src/ch10-00-generics.md:25
msgid ""
"Finally, we’ll discuss _lifetimes_: a variety of generics that give the "
"compiler information about how references relate to each other. Lifetimes "
"allow us to give the compiler enough information about borrowed values so "
"that it can ensure references will be valid in more situations than it could "
"without our help."
msgstr "마지막으로, _라이프타임_에 대해 논의할 것입니다. 라이프타임은 참조가 서로 어떻게 관련되는지에 대한 정보를 컴파일러에 제공하는 다양한 제네릭입니다. 라이프타임을 통해 빌린 값에 대한 충분한 정보를 컴파일러에 제공하여, 컴파일러가 우리의 도움 없이도 참조가 더 많은 상황에서 유효하도록 보장할 수 있습니다."

#: src/ch10-00-generics.md:31
msgid "Removing Duplication by Extracting a Function"
msgstr "함수 추출을 통한 중복 제거"

#: src/ch10-00-generics.md:33
msgid ""
"Generics allow us to replace specific types with a placeholder that "
"represents multiple types to remove code duplication. Before diving into "
"generics syntax, let’s first look at how to remove duplication in a way that "
"doesn’t involve generic types by extracting a function that replaces "
"specific values with a placeholder that represents multiple values. Then "
"we’ll apply the same technique to extract a generic function! By looking at "
"how to recognize duplicated code you can extract into a function, you’ll "
"start to recognize duplicated code that can use generics."
msgstr "제네릭은 특정 타입을 여러 타입을 나타내는 플레이스홀더로 대체하여 코드 중복을 제거할 수 있도록 합니다. 제네릭 문법에 대해 자세히 알아보기 전에, 먼저 특정 값을 여러 값을 나타내는 플레이스홀더로 대체하는 함수를 추출하여 제네릭 타입을 사용하지 않고 중복을 제거하는 방법을 살펴보겠습니다. 그런 다음 동일한 기술을 적용하여 제네릭 함수를 추출할 것입니다! 함수로 추출할 수 있는 중복 코드를 인식하는 방법을 살펴보면, 제네릭을 사용할 수 있는 중복 코드를 인식하기 시작할 것입니다."

#: src/ch10-00-generics.md:42
msgid ""
"We’ll begin with the short program in Listing 10-1 that finds the largest "
"number in a list."
msgstr ""

#: src/ch10-00-generics.md:59 src/ch10-00-generics.md:93
#: src/ch10-00-generics.md:105
msgid "\"The largest number is {largest}\""
msgstr ""

#: src/ch10-00-generics.md:66
msgid ""
"We store a list of integers in the variable `number_list` and place a "
"reference to the first number in the list in a variable named `largest`. We "
"then iterate through all the numbers in the list, and if the current number "
"is greater than the number stored in `largest`, we replace the reference in "
"that variable. However, if the current number is less than or equal to the "
"largest number seen so far, the variable doesn’t change, and the code moves "
"on to the next number in the list. After considering all the numbers in the "
"list, `largest` should refer to the largest number, which in this case is "
"100."
msgstr "우리는 `number_list` 변수에 정수 목록을 저장하고, 목록의 첫 번째 숫자에 대한 참조를 `largest`라는 변수에 저장합니다. 그런 다음 목록의 모든 숫자를 반복하며, 현재 숫자가 `largest`에 저장된 숫자보다 크면 해당 변수의 참조를 교체합니다. 그러나 현재 숫자가 지금까지 본 가장 큰 숫자보다 작거나 같으면 변수는 변경되지 않고, 코드는 목록의 다음 숫자로 이동합니다. 목록의 모든 숫자를 고려한 후, `largest`는 가장 큰 숫자를 참조해야 하며, 이 경우 100입니다."

#: src/ch10-00-generics.md:75
msgid ""
"We’ve now been tasked with finding the largest number in two different lists "
"of numbers. To do so, we can choose to duplicate the code in Listing 10-1 "
"and use the same logic at two different places in the program, as shown in "
"Listing 10-2."
msgstr "이제 두 개의 다른 숫자 목록에서 가장 큰 숫자를 찾는 작업을 맡게 되었습니다. 이를 위해 목록 10-1의 코드를 복제하고 프로그램의 두 다른 위치에서 동일한 로직을 사용할 수 있습니다. 이는 목록 10-2에 나와 있습니다."

#: src/ch10-00-generics.md:111
msgid ""
"Although this code works, duplicating code is tedious and error prone. We "
"also have to remember to update the code in multiple places when we want to "
"change it."
msgstr "이 코드는 작동하지만, 코드 중복은 지루하고 오류가 발생하기 쉽습니다. 또한 코드를 변경할 때 여러 곳에서 업데이트해야 한다는 점도 기억해야 합니다."

#: src/ch10-00-generics.md:115
msgid ""
"To eliminate this duplication, we’ll create an abstraction by defining a "
"function that operates on any list of integers passed in as a parameter. "
"This solution makes our code clearer and lets us express the concept of "
"finding the largest number in a list abstractly."
msgstr "이 중복을 제거하기 위해, 매개변수로 전달된 모든 정수 목록에 대해 작동하는 함수를 정의하여 추상화를 생성할 것입니다. 이 해결책은 코드를 더 명확하게 만들고, 목록에서 가장 큰 숫자를 찾는 개념을 추상적으로 표현할 수 있도록 합니다."

#: src/ch10-00-generics.md:120
msgid ""
"In Listing 10-3, we extract the code that finds the largest number into a "
"function named `largest`. Then we call the function to find the largest "
"number in the two lists from Listing 10-2. We could also use the function on "
"any other list of `i32` values we might have in the future."
msgstr "목록 10-3에서는 가장 큰 숫자를 찾는 코드를 `largest`라는 함수로 추출합니다. 그런 다음 이 함수를 호출하여 목록 10-2의 두 목록에서 가장 큰 숫자를 찾습니다. 앞으로 가질 수 있는 다른 `i32` 값 목록에도 이 함수를 사용할 수 있습니다."

#: src/ch10-00-generics.md:144 src/ch10-00-generics.md:150
#: src/ch10-01-syntax.md:50 src/ch10-01-syntax.md:115
msgid "\"The largest number is {result}\""
msgstr ""

#: src/ch10-00-generics.md:157
msgid ""
"The `largest` function has a parameter called `list`, which represents any "
"concrete slice of `i32` values we might pass into the function. As a result, "
"when we call the function, the code runs on the specific values that we pass "
"in."
msgstr "`largest` 함수는 `list`라는 매개변수를 가지며, 이는 함수에 전달할 수 있는 `i32` 값의 구체적인 슬라이스를 나타냅니다. 결과적으로, 함수를 호출할 때 코드는 우리가 전달하는 특정 값에 대해 실행됩니다."

#: src/ch10-00-generics.md:162
msgid ""
"In summary, here are the steps we took to change the code from Listing 10-2 "
"to Listing 10-3:"
msgstr "요약하자면, 목록 10-2의 코드를 목록 10-3으로 변경하기 위해 수행한 단계는 다음과 같습니다:"

#: src/ch10-00-generics.md:165
msgid "Identify duplicate code."
msgstr "중복 코드 식별."

#: src/ch10-00-generics.md:166
msgid ""
"Extract the duplicate code into the body of the function, and specify the "
"inputs and return values of that code in the function signature."
msgstr "중복 코드를 함수의 본문으로 추출하고, 함수 시그니처에 해당 코드의 입력 및 반환 값을 지정합니다."

#: src/ch10-00-generics.md:168
msgid ""
"Update the two instances of duplicated code to call the function instead."
msgstr "중복된 코드의 두 인스턴스를 함수를 호출하도록 업데이트합니다."

#: src/ch10-00-generics.md:170
msgid ""
"Next, we’ll use these same steps with generics to reduce code duplication. "
"In the same way that the function body can operate on an abstract `list` "
"instead of specific values, generics allow code to operate on abstract types."
msgstr "다음으로, 이와 동일한 단계를 제네릭과 함께 사용하여 코드 중복을 줄일 것입니다. 함수 본문이 특정 값 대신 추상적인 `list`에 대해 작동할 수 있는 것과 마찬가지로, 제네릭은 코드가 추상적인 타입에 대해 작동할 수 있도록 합니다."

#: src/ch10-00-generics.md:174
msgid ""
"For example, say we had two functions: one that finds the largest item in a "
"slice of `i32` values and one that finds the largest item in a slice of "
"`char` values. How would we eliminate that duplication? Let’s find out!"
msgstr "예를 들어, `i32` 값 슬라이스에서 가장 큰 항목을 찾는 함수와 `char` 값 슬라이스에서 가장 큰 항목을 찾는 두 함수가 있다고 가정해 봅시다. 이 중복을 어떻게 제거할 수 있을까요? 알아봅시다!"

#: src/ch10-01-syntax.md:3
msgid ""
"We use generics to create definitions for items like function signatures or "
"structs, which we can then use with many different concrete data types. "
"Let’s first look at how to define functions, structs, enums, and methods "
"using generics. Then we’ll discuss how generics affect code performance."
msgstr "우리는 함수 시그니처나 구조체와 같은 항목에 대한 정의를 생성하기 위해 제네릭을 사용하며, 이를 다양한 구체적인 데이터 타입과 함께 사용할 수 있습니다. 먼저 제네릭을 사용하여 함수, 구조체, 열거형 및 메서드를 정의하는 방법을 살펴보고, 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 논의할 것입니다."

#: src/ch10-01-syntax.md:8
msgid "In Function Definitions"
msgstr "함수 정의에서"

#: src/ch10-01-syntax.md:10
msgid ""
"When defining a function that uses generics, we place the generics in the "
"signature of the function where we would usually specify the data types of "
"the parameters and return value. Doing so makes our code more flexible and "
"provides more functionality to callers of our function while preventing code "
"duplication."
msgstr "제네릭을 사용하는 함수를 정의할 때, 일반적으로 매개변수와 반환 값의 데이터 타입을 지정하는 함수 시그니처에 제네릭을 배치합니다. 이렇게 하면 코드가 더 유연해지고, 코드 중복을 방지하면서 함수 호출자에게 더 많은 기능을 제공합니다."

#: src/ch10-01-syntax.md:15
msgid ""
"Continuing with our `largest` function, Listing 10-4 shows two functions "
"that both find the largest value in a slice. We’ll then combine these into a "
"single function that uses generics."
msgstr "우리의 `largest` 함수를 계속해서 살펴보면, 목록 10-4는 슬라이스에서 가장 큰 값을 찾는 두 함수를 보여줍니다. 그런 다음 이 함수들을 제네릭을 사용하는 단일 함수로 결합할 것입니다."

#: src/ch10-01-syntax.md:53
#: src/ch10-01-syntax.md:57
#: src/ch10-01-syntax.md:117
msgid "'y'"
msgstr "'y'"

#: src/ch10-01-syntax.md:53
#: src/ch10-01-syntax.md:117
msgid "'m'"
msgstr "'m'"

#: src/ch10-01-syntax.md:53
#: src/ch10-01-syntax.md:117
#: src/ch19-01-all-the-places-for-patterns.md:161
#: src/ch19-03-pattern-syntax.md:143
msgid "'a'"
msgstr "'a'"

#: src/ch10-01-syntax.md:53 src/ch10-01-syntax.md:117
msgid "'q'"
msgstr ""

#: src/ch10-01-syntax.md:56 src/ch10-01-syntax.md:120
msgid "\"The largest char is {result}\""
msgstr ""

#: src/ch10-01-syntax.md:63
msgid ""
"The `largest_i32` function is the one we extracted in Listing 10-3 that "
"finds the largest `i32` in a slice. The `largest_char` function finds the "
"largest `char` in a slice. The function bodies have the same code, so let’s "
"eliminate the duplication by introducing a generic type parameter in a "
"single function."
msgstr "`largest_i32` 함수는 목록 10-3에서 추출한 것으로, 슬라이스에서 가장 큰 `i32`를 찾습니다. `largest_char` 함수는 슬라이스에서 가장 큰 `char`를 찾습니다. 함수 본문은 동일한 코드를 가지므로, 단일 함수에 제네릭 타입 매개변수를 도입하여 중복을 제거해 봅시다."

#: src/ch10-01-syntax.md:68
msgid ""
"To parameterize the types in a new single function, we need to name the type "
"parameter, just as we do for the value parameters to a function. You can use "
"any identifier as a type parameter name. But we’ll use `T` because, by "
"convention, type parameter names in Rust are short, often just one letter, "
"and Rust’s type-naming convention is CamelCase. Short for _type_, `T` is the "
"default choice of most Rust programmers."
msgstr "새로운 단일 함수에서 타입을 매개변수화하려면, 함수에 대한 값 매개변수와 마찬가지로 타입 매개변수의 이름을 지정해야 합니다. 어떤 식별자든 타입 매개변수 이름으로 사용할 수 있습니다. 하지만 러스트의 타입 매개변수 이름은 관례적으로 짧고 종종 한 글자이며, 러스트의 타입 명명 규칙은 CamelCase이기 때문에 `T`를 사용할 것입니다. _type_의 약자인 `T`는 대부분의 러스트 프로그래머가 기본적으로 선택하는 것입니다."

#: src/ch10-01-syntax.md:75
msgid ""
"When we use a parameter in the body of the function, we have to declare the "
"parameter name in the signature so the compiler knows what that name means. "
"Similarly, when we use a type parameter name in a function signature, we "
"have to declare the type parameter name before we use it. To define the "
"generic `largest` function, we place type name declarations inside angle "
"brackets, `<>`, between the name of the function and the parameter list, "
"like this:"
msgstr "함수 본문에서 매개변수를 사용할 때, 컴파일러가 그 이름의 의미를 알 수 있도록 시그니처에 매개변수 이름을 선언해야 합니다. 마찬가지로, 함수 시그니처에서 타입 매개변수 이름을 사용할 때, 사용하기 전에 타입 매개변수 이름을 선언해야 합니다. 제네릭 `largest` 함수를 정의하려면, 함수 이름과 매개변수 목록 사이에 꺾쇠 괄호 `<>` 안에 타입 이름 선언을 다음과 같이 배치합니다:"

#: src/ch10-01-syntax.md:86
msgid ""
"We read this definition as: the function `largest` is generic over some type "
"`T`. This function has one parameter named `list`, which is a slice of "
"values of type `T`. The `largest` function will return a reference to a "
"value of the same type `T`."
msgstr "이 정의는 다음과 같이 해석됩니다. `largest` 함수는 어떤 타입 `T`에 대해 제네릭입니다. 이 함수는 `list`라는 하나의 매개변수를 가지며, 이는 `T` 타입 값의 슬라이스입니다. `largest` 함수는 동일한 `T` 타입 값에 대한 참조를 반환할 것입니다."

#: src/ch10-01-syntax.md:91
msgid ""
"Listing 10-5 shows the combined `largest` function definition using the "
"generic data type in its signature. The listing also shows how we can call "
"the function with either a slice of `i32` values or `char` values. Note that "
"this code won’t compile yet, but we’ll fix it later in this chapter."
msgstr "목록 10-5는 제네릭 데이터 타입을 시그니처에 사용하여 결합된 `largest` 함수 정의를 보여줍니다. 이 목록은 또한 `i32` 값 슬라이스 또는 `char` 값으로 함수를 호출하는 방법을 보여줍니다. 이 코드는 아직 컴파일되지 않지만, 이 장의 뒷부분에서 수정할 것입니다."

#: src/ch10-01-syntax.md:126
msgid "If we compile this code right now, we’ll get this error:"
msgstr "이 코드를 지금 컴파일하면 다음과 같은 오류가 발생할 것입니다:"

#: src/ch10-01-syntax.md:128
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0369]: binary operation `>` cannot be applied to type `&T`\n"
" --> src/main.rs:5:17\n"
"  |\n"
"5 |         if item > largest {\n"
"  |            ---- ^ ------- &T\n"
"  |            |\n"
"  |            &T\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n"
"  |             ++++++++++++++++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0369`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:148
msgid ""
"The help text mentions `std::cmp::PartialOrd`, which is a _trait_, and we’re "
"going to talk about traits in the next section. For now, know that this "
"error states that the body of `largest` won’t work for all possible types "
"that `T` could be. Because we want to compare values of type `T` in the "
"body, we can only use types whose values can be ordered. To enable "
"comparisons, the standard library has the `std::cmp::PartialOrd` trait that "
"you can implement on types (see Appendix C for more on this trait). By "
"following the help text’s suggestion, we restrict the types valid for `T` to "
"only those that implement `PartialOrd` and this example will compile, "
"because the standard library implements `PartialOrd` on both `i32` and "
"`char`."
msgstr "도움말 텍스트는 _트레이트_인 `std::cmp::PartialOrd`를 언급하며, 다음 섹션에서 트레이트에 대해 이야기할 것입니다. 지금은 이 오류가 `largest`의 본문이 `T`가 될 수 있는 모든 가능한 타입에 대해 작동하지 않을 것임을 나타낸다는 것을 알아두세요. 본문에서 `T` 타입의 값을 비교하기를 원하므로, 값이 정렬될 수 있는 타입만 사용할 수 있습니다. 비교를 가능하게 하기 위해 표준 라이브러리에는 타입에 구현할 수 있는 `std::cmp::PartialOrd` 트레이트가 있습니다 (이 트레이트에 대한 자세한 내용은 부록 C를 참조하세요). 도움말 텍스트의 제안을 따르면, `T`에 유효한 타입을 `PartialOrd`를 구현하는 타입으로만 제한하며, 표준 라이브러리가 `i32`와 `char` 모두에 `PartialOrd`를 구현하므로 이 예제는 컴파일될 것입니다."

#: src/ch10-01-syntax.md:159
msgid "In Struct Definitions"
msgstr "구조체 정의에서"

#: src/ch10-01-syntax.md:161
msgid ""
"We can also define structs to use a generic type parameter in one or more "
"fields using the `<>` syntax. Listing 10-6 defines a `Point<T>` struct to "
"hold `x` and `y` coordinate values of any type."
msgstr "또한 `<>` 구문을 사용하여 하나 이상의 필드에 제네릭 타입 매개변수를 사용하도록 구조체를 정의할 수 있습니다. 목록 10-6은 어떤 타입의 `x` 및 `y` 좌표 값을 저장하는 `Point<T>` 구조체를 정의합니다."

#: src/ch10-01-syntax.md:181
msgid ""
"The syntax for using generics in struct definitions is similar to that used "
"in function definitions. First we declare the name of the type parameter "
"inside angle brackets just after the name of the struct. Then we use the "
"generic type in the struct definition where we would otherwise specify "
"concrete data types."
msgstr "구조체 정의에서 제네릭을 사용하는 문법은 함수 정의에서 사용되는 문법과 유사합니다. 먼저 구조체 이름 바로 뒤의 꺾쇠 괄호 안에 타입 매개변수 이름을 선언합니다. 그런 다음 구체적인 데이터 타입을 지정했을 구조체 정의에서 제네릭 타입을 사용합니다."

#: src/ch10-01-syntax.md:187
msgid ""
"Note that because we’ve used only one generic type to define `Point<T>`, "
"this definition says that the `Point<T>` struct is generic over some type "
"`T`, and the fields `x` and `y` are _both_ that same type, whatever that "
"type may be. If we create an instance of a `Point<T>` that has values of "
"different types, as in Listing 10-7, our code won’t compile."
msgstr "우리가 `Point<T>`를 정의하기 위해 하나의 제네릭 타입만 사용했기 때문에, 이 정의는 `Point<T>` 구조체가 어떤 타입 `T`에 대해 제네릭이며, `x`와 `y` 필드 _모두_ 그 동일한 타입이라는 것을 의미합니다. 그 타입이 무엇이든 말이죠. 만약 목록 10-7과 같이 다른 타입의 값을 가진 `Point<T>` 인스턴스를 생성하면, 우리 코드는 컴파일되지 않을 것입니다."

#: src/ch10-01-syntax.md:208
msgid ""
"In this example, when we assign the integer value `5` to `x`, we let the "
"compiler know that the generic type `T` will be an integer for this instance "
"of `Point<T>`. Then when we specify `4.0` for `y`, which we’ve defined to "
"have the same type as `x`, we’ll get a type mismatch error like this:"
msgstr "이 예제에서 `x`에 정수 값 `5`를 할당하면, 컴파일러는 `Point<T>`의 이 인스턴스에 대해 제네릭 타입 `T`가 정수임을 알게 됩니다. 그런 다음 `x`와 동일한 타입을 가지도록 정의한 `y`에 `4.0`을 지정하면 다음과 같은 타입 불일치 오류가 발생할 것입니다:"

#: src/ch10-01-syntax.md:213
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:7:38\n"
"  |\n"
"7 |     let wont_work = Point { x: 5, y: 4.0 };\n"
"  |                                      ^^^ expected integer, found "
"floating-point number\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-01-syntax.md:226
msgid ""
"To define a `Point` struct where `x` and `y` are both generics but could "
"have different types, we can use multiple generic type parameters. For "
"example, in Listing 10-8, we change the definition of `Point` to be generic "
"over types `T` and `U` where `x` is of type `T` and `y` is of type `U`."
msgstr "`x`와 `y`가 모두 제네릭이지만 다른 타입을 가질 수 있는 `Point` 구조체를 정의하려면, 여러 제네릭 타입 매개변수를 사용할 수 있습니다. 예를 들어, 목록 10-8에서는 `Point`의 정의를 `x`가 `T` 타입이고 `y`가 `U` 타입인 `T`와 `U` 타입에 대해 제네릭으로 변경합니다."

#: src/ch10-01-syntax.md:248
msgid ""
"Now all the instances of `Point` shown are allowed! You can use as many "
"generic type parameters in a definition as you want, but using more than a "
"few makes your code hard to read. If you’re finding you need lots of generic "
"types in your code, it could indicate that your code needs restructuring "
"into smaller pieces."
msgstr "이제 표시된 `Point`의 모든 인스턴스가 허용됩니다! 정의에서 원하는 만큼 많은 제네릭 타입 매개변수를 사용할 수 있지만, 몇 개 이상을 사용하면 코드를 읽기 어려워집니다. 코드에 많은 제네릭 타입이 필요하다고 생각되면, 코드를 더 작은 조각으로 재구성해야 함을 나타낼 수 있습니다."

#: src/ch10-01-syntax.md:254
msgid "In Enum Definitions"
msgstr "열거형 정의에서"

#: src/ch10-01-syntax.md:256
msgid ""
"As we did with structs, we can define enums to hold generic data types in "
"their variants. Let’s take another look at the `Option<T>` enum that the "
"standard library provides, which we used in Chapter 6:"
msgstr "구조체에서 했던 것처럼, 열거형을 정의하여 variant에 제네릭 데이터 타입을 담을 수 있습니다. 6장에서 사용했던 표준 라이브러리가 제공하는 `Option<T>` 열거형을 다시 살펴보겠습니다:"

#: src/ch10-01-syntax.md:267
msgid ""
"This definition should now make more sense to you. As you can see, the "
"`Option<T>` enum is generic over type `T` and has two variants: `Some`, "
"which holds one value of type `T`, and a `None` variant that doesn’t hold "
"any value. By using the `Option<T>` enum, we can express the abstract "
"concept of an optional value, and because `Option<T>` is generic, we can use "
"this abstraction no matter what the type of the optional value is."
msgstr "이제 이 정의가 여러분에게 더 이해가 될 것입니다. 보시다시피, `Option<T>` 열거형은 `T` 타입에 대해 제네릭이며, `T` 타입의 값 하나를 담는 `Some`과 아무 값도 담지 않는 `None`이라는 두 가지 variant를 가집니다. `Option<T>` 열거형을 사용함으로써 선택적 값이라는 추상적인 개념을 표현할 수 있으며, `Option<T>`가 제네릭이므로 선택적 값의 타입이 무엇이든 이 추상화를 사용할 수 있습니다."

#: src/ch10-01-syntax.md:274
msgid ""
"Enums can use multiple generic types as well. The definition of the `Result` "
"enum that we used in Chapter 9 is one example:"
msgstr "열거형은 여러 제네릭 타입을 사용할 수도 있습니다. 9장에서 사용했던 `Result` 열거형의 정의가 한 예입니다:"

#: src/ch10-01-syntax.md:284
msgid ""
"The `Result` enum is generic over two types, `T` and `E`, and has two "
"variants: `Ok`, which holds a value of type `T`, and `Err`, which holds a "
"value of type `E`. This definition makes it convenient to use the `Result` "
"enum anywhere we have an operation that might succeed (return a value of "
"some type `T`) or fail (return an error of some type `E`). In fact, this is "
"what we used to open a file in Listing 9-3, where `T` was filled in with the "
"type `std::fs::File` when the file was opened successfully and `E` was "
"filled in with the type `std::io::Error` when there were problems opening "
"the file."
msgstr "`Result` 열거형은 `T`와 `E` 두 가지 타입에 대해 제네릭이며, `T` 타입의 값을 담는 `Ok`와 `E` 타입의 값을 담는 `Err` 두 가지 variant를 가집니다. 이 정의는 성공할 수도 있고 (`T` 타입의 값을 반환) 실패할 수도 있는 (`E` 타입의 오류를 반환) 작업이 있는 모든 곳에서 `Result` 열거형을 편리하게 사용할 수 있도록 합니다. 실제로 이것은 목록 9-3에서 파일을 열 때 사용했던 것으로, 파일이 성공적으로 열렸을 때 `T`는 `std::fs::File` 타입으로 채워졌고, 파일을 여는 데 문제가 있었을 때 `E`는 `std::io::Error` 타입으로 채워졌습니다."

#: src/ch10-01-syntax.md:293
msgid ""
"When you recognize situations in your code with multiple struct or enum "
"definitions that differ only in the types of the values they hold, you can "
"avoid duplication by using generic types instead."
msgstr "코드에서 값의 타입만 다른 여러 구조체 또는 열거형 정의가 있는 상황을 인식하면, 대신 제네릭 타입을 사용하여 중복을 피할 수 있습니다."

#: src/ch10-01-syntax.md:297
msgid "In Method Definitions"
msgstr "메서드 정의에서"

#: src/ch10-01-syntax.md:299
msgid ""
"We can implement methods on structs and enums (as we did in Chapter 5) and "
"use generic types in their definitions too. Listing 10-9 shows the "
"`Point<T>` struct we defined in Listing 10-6 with a method named `x` "
"implemented on it."
msgstr "구조체와 열거형에 메서드를 구현하고(5장에서 했던 것처럼) 정의에 제네릭 타입을 사용할 수도 있습니다. 목록 10-9는 목록 10-6에서 정의한 `Point<T>` 구조체에 `x`라는 메서드가 구현된 것을 보여줍니다."

#: src/ch10-01-syntax.md:320 src/ch10-01-syntax.md:367
msgid "\"p.x = {}\""
msgstr ""

#: src/ch10-01-syntax.md:326
msgid ""
"Here, we’ve defined a method named `x` on `Point<T>` that returns a "
"reference to the data in the field `x`."
msgstr "여기서 우리는 `Point<T>`에 `x`라는 메서드를 정의했으며, 이 메서드는 필드 `x`의 데이터에 대한 참조를 반환합니다."

#: src/ch10-01-syntax.md:329
msgid ""
"Note that we have to declare `T` just after `impl` so we can use `T` to "
"specify that we’re implementing methods on the type `Point<T>`. By declaring "
"`T` as a generic type after `impl`, Rust can identify that the type in the "
"angle brackets in `Point` is a generic type rather than a concrete type. We "
"could have chosen a different name for this generic parameter than the "
"generic parameter declared in the struct definition, but using the same name "
"is conventional. If you write a method within an `impl` that declares a "
"generic type, that method will be defined on any instance of the type, no "
"matter what concrete type ends up substituting for the generic type."
msgstr "`impl` 바로 뒤에 `T`를 선언해야 `T`를 사용하여 `Point<T>` 타입에 메서드를 구현하고 있음을 지정할 수 있다는 점에 유의하세요. `impl` 뒤에 `T`를 제네릭 타입으로 선언함으로써 러스트는 `Point`의 꺾쇠 괄호 안의 타입이 구체적인 타입이 아닌 제네릭 타입임을 식별할 수 있습니다. 구조체 정의에 선언된 제네릭 매개변수와 다른 이름을 이 제네릭 매개변수에 대해 선택할 수도 있었지만, 동일한 이름을 사용하는 것이 관례입니다. 제네릭 타입을 선언하는 `impl` 내부에 메서드를 작성하면, 해당 메서드는 어떤 구체적인 타입이 제네릭 타입을 대체하든 상관없이 해당 타입의 모든 인스턴스에 대해 정의될 것입니다."

#: src/ch10-01-syntax.md:339
msgid ""
"We can also specify constraints on generic types when defining methods on "
"the type. We could, for example, implement methods only on `Point<f32>` "
"instances rather than on `Point<T>` instances with any generic type. In "
"Listing 10-10 we use the concrete type `f32`, meaning we don’t declare any "
"types after `impl`."
msgstr "타입에 메서드를 정의할 때 제네릭 타입에 대한 제약 조건을 지정할 수도 있습니다. 예를 들어, 어떤 제네릭 타입을 가진 `Point<T>` 인스턴스 대신 `Point<f32>` 인스턴스에만 메서드를 구현할 수 있습니다. 목록 10-10에서는 구체적인 타입 `f32`를 사용하며, 이는 `impl` 뒤에 어떤 타입도 선언하지 않음을 의미합니다."

#: src/ch10-01-syntax.md:373
msgid ""
"This code means the type `Point<f32>` will have a `distance_from_origin` "
"method; other instances of `Point<T>` where `T` is not of type `f32` will "
"not have this method defined. The method measures how far our point is from "
"the point at coordinates (0.0, 0.0) and uses mathematical operations that "
"are available only for floating-point types."
msgstr "이 코드는 `Point<f32>` 타입이 `distance_from_origin` 메서드를 가질 것임을 의미합니다. `T`가 `f32` 타입이 아닌 `Point<T>`의 다른 인스턴스에는 이 메서드가 정의되지 않습니다. 이 메서드는 우리 점이 좌표 (0.0, 0.0)의 점으로부터 얼마나 떨어져 있는지 측정하며, 부동 소수점 타입에만 사용 가능한 수학 연산을 사용합니다."

#: src/ch10-01-syntax.md:379
msgid ""
"Generic type parameters in a struct definition aren’t always the same as "
"those you use in that same struct’s method signatures. Listing 10-11 uses "
"the generic types `X1` and `Y1` for the `Point` struct and `X2` `Y2` for the "
"`mixup` method signature to make the example clearer. The method creates a "
"new `Point` instance with the `x` value from the `self` `Point` (of type "
"`X1`) and the `y` value from the passed-in `Point` (of type `Y2`)."
msgstr "구조체 정의의 제네릭 타입 매개변수는 항상 동일한 구조체의 메서드 시그니처에서 사용하는 것과 같지 않습니다. 목록 10-11은 예제를 더 명확하게 하기 위해 `Point` 구조체에 `X1`과 `Y1` 제네릭 타입을 사용하고 `mixup` 메서드 시그니처에 `X2` `Y2`를 사용합니다. 이 메서드는 `self` `Point` (타입 `X1`)의 `x` 값과 전달된 `Point` (타입 `Y2`)의 `y` 값으로 새로운 `Point` 인스턴스를 생성합니다."

#: src/ch10-01-syntax.md:405 src/ch19-01-all-the-places-for-patterns.md:161
#: src/ch19-03-pattern-syntax.md:140
msgid "'c'"
msgstr ""

#: src/ch10-01-syntax.md:409
msgid "\"p3.x = {}, p3.y = {}\""
msgstr ""

#: src/ch10-01-syntax.md:415
msgid ""
"In `main`, we’ve defined a `Point` that has an `i32` for `x` (with value "
"`5`) and an `f64` for `y` (with value `10.4`). The `p2` variable is a "
"`Point` struct that has a string slice for `x` (with value `\"Hello\"`) and "
"a `char` for `y` (with value `c`). Calling `mixup` on `p1` with the argument "
"`p2` gives us `p3`, which will have an `i32` for `x` because `x` came from "
"`p1`. The `p3` variable will have a `char` for `y` because `y` came from "
"`p2`. The `println!` macro call will print `p3.x = 5, p3.y = c`."
msgstr "`main`에서 우리는 `x`에 `i32` (값 `5`)를, `y`에 `f64` (값 `10.4`)를 가진 `Point`를 정의했습니다. `p2` 변수는 `x`에 문자열 슬라이스 (값 `\"Hello\"`)를, `y`에 `char` (값 `c`)를 가진 `Point` 구조체입니다. `p1`에 `p2` 인수를 사용하여 `mixup`을 호출하면 `p3`를 얻게 되는데, `x`는 `p1`에서 왔으므로 `p3`는 `x`에 `i32`를 가질 것입니다. `p3` 변수는 `y`에 `char`를 가질 것인데, `y`는 `p2`에서 왔기 때문입니다. `println!` 매크로 호출은 `p3.x = 5, p3.y = c`를 출력할 것입니다."

#: src/ch10-01-syntax.md:423
msgid ""
"The purpose of this example is to demonstrate a situation in which some "
"generic parameters are declared with `impl` and some are declared with the "
"method definition. Here, the generic parameters `X1` and `Y1` are declared "
"after `impl` because they go with the struct definition. The generic "
"parameters `X2` and `Y2` are declared after `fn mixup` because they’re only "
"relevant to the method."
msgstr "이 예제의 목적은 일부 제네릭 매개변수가 `impl`로 선언되고 일부는 메서드 정의로 선언되는 상황을 보여주는 것입니다. 여기서 제네릭 매개변수 `X1`과 `Y1`은 구조체 정의와 함께 사용되므로 `impl` 뒤에 선언됩니다. 제네릭 매개변수 `X2`와 `Y2`는 메서드에만 관련되므로 `fn mixup` 뒤에 선언됩니다."

#: src/ch10-01-syntax.md:430
msgid "Performance of Code Using Generics"
msgstr "제네릭을 사용하는 코드의 성능"

#: src/ch10-01-syntax.md:432
msgid ""
"You might be wondering whether there is a runtime cost when using generic "
"type parameters. The good news is that using generic types won’t make your "
"program run any slower than it would with concrete types."
msgstr "제네릭 타입 매개변수를 사용할 때 런타임 비용이 발생하는지 궁금할 수 있습니다. 좋은 소식은 제네릭 타입을 사용해도 구체적인 타입을 사용할 때보다 프로그램 실행 속도가 느려지지 않는다는 것입니다."

#: src/ch10-01-syntax.md:436
msgid ""
"Rust accomplishes this by performing monomorphization of the code using "
"generics at compile time. _Monomorphization_ is the process of turning "
"generic code into specific code by filling in the concrete types that are "
"used when compiled. In this process, the compiler does the opposite of the "
"steps we used to create the generic function in Listing 10-5: the compiler "
"looks at all the places where generic code is called and generates code for "
"the concrete types the generic code is called with."
msgstr "러스트는 컴파일 시 제네릭을 사용하는 코드의 단형성(monomorphization)을 수행하여 이를 달성합니다. _단형성_은 컴파일될 때 사용되는 구체적인 타입을 채워 제네릭 코드를 특정 코드로 변환하는 과정입니다. 이 과정에서 컴파일러는 목록 10-5에서 제네릭 함수를 생성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 제네릭 코드가 호출되는 모든 위치를 살펴보고 제네릭 코드가 호출되는 구체적인 타입에 대한 코드를 생성합니다."

#: src/ch10-01-syntax.md:444
msgid ""
"Let’s look at how this works by using the standard library’s generic "
"`Option<T>` enum:"
msgstr "표준 라이브러리의 제네릭 `Option<T>` 열거형을 사용하여 이것이 어떻게 작동하는지 살펴보겠습니다:"

#: src/ch10-01-syntax.md:452
msgid ""
"When Rust compiles this code, it performs monomorphization. During that "
"process, the compiler reads the values that have been used in `Option<T>` "
"instances and identifies two kinds of `Option<T>`: one is `i32` and the "
"other is `f64`. As such, it expands the generic definition of `Option<T>` "
"into two definitions specialized to `i32` and `f64`, thereby replacing the "
"generic definition with the specific ones."
msgstr "러스트가 이 코드를 컴파일할 때, 단형성(monomorphization)을 수행합니다. 이 과정에서 컴파일러는 `Option<T>` 인스턴스에서 사용된 값을 읽고 두 가지 종류의 `Option<T>`를 식별합니다. 하나는 `i32`이고 다른 하나는 `f64`입니다. 따라서 `Option<T>`의 제네릭 정의를 `i32`와 `f64`에 특화된 두 가지 정의로 확장하여 제네릭 정의를 특정 정의로 대체합니다."

#: src/ch10-01-syntax.md:459
msgid ""
"The monomorphized version of the code looks similar to the following (the "
"compiler uses different names than what we’re using here for illustration):"
msgstr "단형성된 코드 버전은 다음(컴파일러는 여기에서 설명 목적으로 사용하는 이름과 다른 이름을 사용합니다)과 유사하게 보입니다:"

#: src/ch10-01-syntax.md:483
msgid ""
"The generic `Option<T>` is replaced with the specific definitions created by "
"the compiler. Because Rust compiles generic code into code that specifies "
"the type in each instance, we pay no runtime cost for using generics. When "
"the code runs, it performs just as it would if we had duplicated each "
"definition by hand. The process of monomorphization makes Rust’s generics "
"extremely efficient at runtime."
msgstr "제네릭 `Option<T>`는 컴파일러가 생성한 특정 정의로 대체됩니다. 러스트는 제네릭 코드를 각 인스턴스에서 타입을 지정하는 코드로 컴파일하기 때문에, 제네릭을 사용해도 런타임 비용이 발생하지 않습니다. 코드가 실행될 때, 각 정의를 수동으로 복제한 것과 동일하게 작동합니다. 단형성(monomorphization) 과정은 러스트의 제네릭을 런타임에 매우 효율적으로 만듭니다."

#: src/ch10-02-traits.md:3
msgid ""
"A _trait_ defines the functionality a particular type has and can share with "
"other types. We can use traits to define shared behavior in an abstract way. "
"We can use _trait bounds_ to specify that a generic type can be any type "
"that has certain behavior."
msgstr "_트레이트_는 특정 타입이 가지는 기능과 다른 타입과 공유할 수 있는 기능을 정의합니다. 트레이트를 사용하여 공유된 동작을 추상적인 방식으로 정의할 수 있습니다. _트레이트 바운드_를 사용하여 제네릭 타입이 특정 동작을 가진 어떤 타입이든 될 수 있음을 지정할 수 있습니다."

#: src/ch10-02-traits.md:8
msgid ""
"Note: Traits are similar to a feature often called _interfaces_ in other "
"languages, although with some differences."
msgstr "참고: 트레이트는 다른 언어에서 종종 _인터페이스_라고 불리는 기능과 유사하지만, 몇 가지 차이점이 있습니다."

#: src/ch10-02-traits.md:11
msgid "Defining a Trait"
msgstr "트레이트 정의하기"

#: src/ch10-02-traits.md:13
msgid ""
"A type’s behavior consists of the methods we can call on that type. "
"Different types share the same behavior if we can call the same methods on "
"all of those types. Trait definitions are a way to group method signatures "
"together to define a set of behaviors necessary to accomplish some purpose."
msgstr "타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성됩니다. 모든 타입에서 동일한 메서드를 호출할 수 있다면 다른 타입들도 동일한 동작을 공유합니다. 트레이트 정의는 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메서드 시그니처를 함께 그룹화하는 방법입니다."

#: src/ch10-02-traits.md:18
msgid ""
"For example, let’s say we have multiple structs that hold various kinds and "
"amounts of text: a `NewsArticle` struct that holds a news story filed in a "
"particular location and a `Tweet` that can have, at most, 280 characters "
"along with metadata that indicates whether it was a new tweet, a retweet, or "
"a reply to another tweet."
msgstr "예를 들어, 다양한 종류와 양의 텍스트를 담는 여러 구조체가 있다고 가정해 봅시다. 특정 위치에 보관된 뉴스 기사를 담는 `NewsArticle` 구조체와, 최대 280자까지 가능하며 새 트윗인지, 리트윗인지, 다른 트윗에 대한 답장인지 나타내는 메타데이터를 포함하는 `Tweet`입니다."

#: src/ch10-02-traits.md:24
msgid ""
"We want to make a media aggregator library crate named `aggregator` that can "
"display summaries of data that might be stored in a `NewsArticle` or `Tweet` "
"instance. To do this, we need a summary from each type, and we’ll request "
"that summary by calling a `summarize` method on an instance. Listing 10-12 "
"shows the definition of a public `Summary` trait that expresses this "
"behavior."
msgstr "우리는 `NewsArticle` 또는 `Tweet` 인스턴스에 저장될 수 있는 데이터의 요약을 표시할 수 있는 `aggregator`라는 미디어 애그리게이터 라이브러리 크레이트를 만들고 싶습니다. 이를 위해 각 타입에서 요약이 필요하며, 인스턴스에서 `summarize` 메서드를 호출하여 해당 요약을 요청할 것입니다. 목록 10-12는 이러한 동작을 표현하는 공개 `Summary` 트레이트의 정의를 보여줍니다."

#: src/ch10-02-traits.md:40
msgid ""
"Here, we declare a trait using the `trait` keyword and then the trait’s "
"name, which is `Summary` in this case. We also declare the trait as `pub` so "
"that crates depending on this crate can make use of this trait too, as we’ll "
"see in a few examples. Inside the curly brackets, we declare the method "
"signatures that describe the behaviors of the types that implement this "
"trait, which in this case is `fn summarize(&self) -> String`."
msgstr "여기서 우리는 `trait` 키워드와 트레이트 이름(이 경우 `Summary`)을 사용하여 트레이트를 선언합니다. 또한 이 트레이트를 `pub`으로 선언하여 이 크레이트에 의존하는 크레이트도 이 트레이트를 사용할 수 있도록 합니다. 몇 가지 예제에서 이를 확인할 것입니다. 중괄호 안에는 이 트레이트를 구현하는 타입의 동작을 설명하는 메서드 시그니처를 선언하며, 이 경우 `fn summarize(&self) -> String`입니다."

#: src/ch10-02-traits.md:47
msgid ""
"After the method signature, instead of providing an implementation within "
"curly brackets, we use a semicolon. Each type implementing this trait must "
"provide its own custom behavior for the body of the method. The compiler "
"will enforce that any type that has the `Summary` trait will have the method "
"`summarize` defined with this signature exactly."
msgstr "메서드 시그니처 뒤에는 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 트레이트를 구현하는 각 타입은 메서드 본문에 대해 자체적인 사용자 정의 동작을 제공해야 합니다. 컴파일러는 `Summary` 트레이트를 가진 모든 타입이 이 시그니처와 정확히 일치하는 `summarize` 메서드를 정의하도록 강제할 것입니다."

#: src/ch10-02-traits.md:53
msgid ""
"A trait can have multiple methods in its body: the method signatures are "
"listed one per line, and each line ends in a semicolon."
msgstr "트레이트는 본문에 여러 메서드를 가질 수 있습니다. 메서드 시그니처는 한 줄에 하나씩 나열되며, 각 줄은 세미콜론으로 끝납니다."

#: src/ch10-02-traits.md:56
msgid "Implementing a Trait on a Type"
msgstr "타입에 트레이트 구현하기"

#: src/ch10-02-traits.md:58
msgid ""
"Now that we’ve defined the desired signatures of the `Summary` trait’s "
"methods, we can implement it on the types in our media aggregator. Listing "
"10-13 shows an implementation of the `Summary` trait on the `NewsArticle` "
"struct that uses the headline, the author, and the location to create the "
"return value of `summarize`. For the `Tweet` struct, we define `summarize` "
"as the username followed by the entire text of the tweet, assuming that the "
"tweet content is already limited to 280 characters."
msgstr "이제 `Summary` 트레이트 메서드의 원하는 시그니처를 정의했으므로, 미디어 애그리게이터의 타입에 이를 구현할 수 있습니다. 목록 10-13은 `NewsArticle` 구조체에 `Summary` 트레이트를 구현한 것을 보여주며, 헤드라인, 작성자 및 위치를 사용하여 `summarize`의 반환 값을 생성합니다. `Tweet` 구조체의 경우, 트윗 내용이 이미 280자로 제한되어 있다고 가정하고 `summarize`를 사용자 이름 뒤에 전체 트윗 텍스트로 정의합니다."

#: src/ch10-02-traits.md:82 src/ch10-02-traits.md:344 src/ch10-02-traits.md:483
#: src/ch10-02-traits.md:542
msgid "\"{}, by {} ({})\""
msgstr ""

#: src/ch10-02-traits.md:95 src/ch10-02-traits.md:195 src/ch10-02-traits.md:357
#: src/ch10-02-traits.md:496 src/ch10-02-traits.md:555
msgid "\"{}: {}\""
msgstr ""

#: src/ch10-02-traits.md:102
msgid ""
"Implementing a trait on a type is similar to implementing regular methods. "
"The difference is that after `impl`, we put the trait name we want to "
"implement, then use the `for` keyword, and then specify the name of the type "
"we want to implement the trait for. Within the `impl` block, we put the "
"method signatures that the trait definition has defined. Instead of adding a "
"semicolon after each signature, we use curly brackets and fill in the method "
"body with the specific behavior that we want the methods of the trait to "
"have for the particular type."
msgstr ""

#: src/ch10-02-traits.md:110
msgid ""
"Now that the library has implemented the `Summary` trait on `NewsArticle` "
"and `Tweet`, users of the crate can call the trait methods on instances of "
"`NewsArticle` and `Tweet` in the same way we call regular methods. The only "
"difference is that the user must bring the trait into scope as well as the "
"types. Here’s an example of how a binary crate could use our `aggregator` "
"library crate:"
msgstr ""

#: src/ch10-02-traits.md:122 src/ch10-02-traits.md:304
#: src/ch10-02-traits.md:502 src/ch10-02-traits.md:574
msgid "\"horse_ebooks\""
msgstr ""

#: src/ch10-02-traits.md:124 src/ch10-02-traits.md:306
#: src/ch10-02-traits.md:504 src/ch10-02-traits.md:576
msgid "\"of course, as you probably already know, people\""
msgstr ""

#: src/ch10-02-traits.md:130 src/ch10-02-traits.md:312
msgid "\"1 new tweet: {}\""
msgstr ""

#: src/ch10-02-traits.md:134
msgid ""
"This code prints `1 new tweet: horse_ebooks: of course, as you probably "
"already know, people`."
msgstr ""

#: src/ch10-02-traits.md:137
msgid ""
"Other crates that depend on the `aggregator` crate can also bring the "
"`Summary` trait into scope to implement `Summary` on their own types. One "
"restriction to note is that we can implement a trait on a type only if "
"either the trait or the type, or both, are local to our crate. For example, "
"we can implement standard library traits like `Display` on a custom type "
"like `Tweet` as part of our `aggregator` crate functionality because the "
"type `Tweet` is local to our `aggregator` crate. We can also implement "
"`Summary` on `Vec<T>` in our `aggregator` crate because the trait `Summary` "
"is local to our `aggregator` crate."
msgstr ""

#: src/ch10-02-traits.md:147
msgid ""
"But we can’t implement external traits on external types. For example, we "
"can’t implement the `Display` trait on `Vec<T>` within our `aggregator` "
"crate because `Display` and `Vec<T>` are both defined in the standard "
"library and aren’t local to our `aggregator` crate. This restriction is part "
"of a property called _coherence_, and more specifically the _orphan rule_, "
"so named because the parent type is not present. This rule ensures that "
"other people’s code can’t break your code and vice versa. Without the rule, "
"two crates could implement the same trait for the same type, and Rust "
"wouldn’t know which implementation to use."
msgstr ""

#: src/ch10-02-traits.md:157
msgid "Default Implementations"
msgstr ""

#: src/ch10-02-traits.md:159
msgid ""
"Sometimes it’s useful to have default behavior for some or all of the "
"methods in a trait instead of requiring implementations for all methods on "
"every type. Then, as we implement the trait on a particular type, we can "
"keep or override each method’s default behavior."
msgstr ""

#: src/ch10-02-traits.md:164
msgid ""
"In Listing 10-14, we specify a default string for the `summarize` method of "
"the `Summary` trait instead of only defining the method signature, as we did "
"in Listing 10-12."
msgstr ""

#: src/ch10-02-traits.md:173
msgid "\"(Read more...)\""
msgstr ""

#: src/ch10-02-traits.md:202
msgid ""
"To use a default implementation to summarize instances of `NewsArticle`, we "
"specify an empty `impl` block with `impl Summary for NewsArticle {}`."
msgstr ""

#: src/ch10-02-traits.md:205
msgid ""
"Even though we’re no longer defining the `summarize` method on `NewsArticle` "
"directly, we’ve provided a default implementation and specified that "
"`NewsArticle` implements the `Summary` trait. As a result, we can still call "
"the `summarize` method on an instance of `NewsArticle`, like this:"
msgstr ""

#: src/ch10-02-traits.md:215 src/ch10-02-traits.md:563
msgid "\"Penguins win the Stanley Cup Championship!\""
msgstr ""

#: src/ch10-02-traits.md:216 src/ch10-02-traits.md:565
msgid "\"Pittsburgh, PA, USA\""
msgstr ""

#: src/ch10-02-traits.md:217 src/ch10-02-traits.md:566
msgid "\"Iceburgh\""
msgstr ""

#: src/ch10-02-traits.md:219
msgid ""
"\"The Pittsburgh Penguins once again are the best \\\n"
"             hockey team in the NHL.\""
msgstr ""

#: src/ch10-02-traits.md:224
msgid "\"New article available! {}\""
msgstr ""

#: src/ch10-02-traits.md:228
msgid "This code prints `New article available! (Read more...)`."
msgstr ""

#: src/ch10-02-traits.md:230
msgid ""
"Creating a default implementation doesn’t require us to change anything "
"about the implementation of `Summary` on `Tweet` in Listing 10-13. The "
"reason is that the syntax for overriding a default implementation is the "
"same as the syntax for implementing a trait method that doesn’t have a "
"default implementation."
msgstr ""

#: src/ch10-02-traits.md:235
msgid ""
"Default implementations can call other methods in the same trait, even if "
"those other methods don’t have a default implementation. In this way, a "
"trait can provide a lot of useful functionality and only require "
"implementors to specify a small part of it. For example, we could define the "
"`Summary` trait to have a `summarize_author` method whose implementation is "
"required, and then define a `summarize` method that has a default "
"implementation that calls the `summarize_author` method:"
msgstr ""

#: src/ch10-02-traits.md:248 src/ch10-02-traits.md:274
msgid "\"(Read more from {}...)\""
msgstr ""

#: src/ch10-02-traits.md:261 src/ch10-02-traits.md:287
msgid "\"@{}\""
msgstr ""

#: src/ch10-02-traits.md:266
msgid ""
"To use this version of `Summary`, we only need to define `summarize_author` "
"when we implement the trait on a type:"
msgstr ""

#: src/ch10-02-traits.md:292
msgid ""
"After we define `summarize_author`, we can call `summarize` on instances of "
"the `Tweet` struct, and the default implementation of `summarize` will call "
"the definition of `summarize_author` that we’ve provided. Because we’ve "
"implemented `summarize_author`, the `Summary` trait has given us the "
"behavior of the `summarize` method without requiring us to write any more "
"code. Here’s what that looks like:"
msgstr ""

#: src/ch10-02-traits.md:316
msgid "This code prints `1 new tweet: (Read more from @horse_ebooks...)`."
msgstr ""

#: src/ch10-02-traits.md:318
msgid ""
"Note that it isn’t possible to call the default implementation from an "
"overriding implementation of that same method."
msgstr ""

#: src/ch10-02-traits.md:321
msgid "Traits as Parameters"
msgstr ""

#: src/ch10-02-traits.md:323
msgid ""
"Now that you know how to define and implement traits, we can explore how to "
"use traits to define functions that accept many different types. We’ll use "
"the `Summary` trait we implemented on the `NewsArticle` and `Tweet` types in "
"Listing 10-13 to define a `notify` function that calls the `summarize` "
"method on its `item` parameter, which is of some type that implements the "
"`Summary` trait. To do this, we use the `impl Trait` syntax, like this:"
msgstr ""

#: src/ch10-02-traits.md:362 src/ch10-02-traits.md:385
msgid "\"Breaking news! {}\""
msgstr ""

#: src/ch10-02-traits.md:366
msgid ""
"Instead of a concrete type for the `item` parameter, we specify the `impl` "
"keyword and the trait name. This parameter accepts any type that implements "
"the specified trait. In the body of `notify`, we can call any methods on "
"`item` that come from the `Summary` trait, such as `summarize`. We can call "
"`notify` and pass in any instance of `NewsArticle` or `Tweet`. Code that "
"calls the function with any other type, such as a `String` or an `i32`, "
"won’t compile because those types don’t implement `Summary`."
msgstr ""

#: src/ch10-02-traits.md:376
msgid "<a id=\"fixing-the-largest-function-with-trait-bounds\"></a>"
msgstr "<a id=\"fixing-the-largest-function-with-trait-bounds\"></a>"

#: src/ch10-02-traits.md:378
msgid "Trait Bound Syntax"
msgstr "트레이트 바운드 문법"

#: src/ch10-02-traits.md:380
msgid ""
"The `impl Trait` syntax works for straightforward cases but is actually "
"syntax sugar for a longer form known as a _trait bound_; it looks like this:"
msgstr ""

#: src/ch10-02-traits.md:389
msgid ""
"This longer form is equivalent to the example in the previous section but is "
"more verbose. We place trait bounds with the declaration of the generic type "
"parameter after a colon and inside angle brackets."
msgstr ""

#: src/ch10-02-traits.md:393
msgid ""
"The `impl Trait` syntax is convenient and makes for more concise code in "
"simple cases, while the fuller trait bound syntax can express more "
"complexity in other cases. For example, we can have two parameters that "
"implement `Summary`. Doing so with the `impl Trait` syntax looks like this:"
msgstr ""

#: src/ch10-02-traits.md:402
msgid ""
"Using `impl Trait` is appropriate if we want this function to allow `item1` "
"and `item2` to have different types (as long as both types implement "
"`Summary`). If we want to force both parameters to have the same type, "
"however, we must use a trait bound, like this:"
msgstr ""

#: src/ch10-02-traits.md:411
msgid ""
"The generic type `T` specified as the type of the `item1` and `item2` "
"parameters constrains the function such that the concrete type of the value "
"passed as an argument for `item1` and `item2` must be the same."
msgstr ""

#: src/ch10-02-traits.md:415
msgid "Specifying Multiple Trait Bounds with the `+` Syntax"
msgstr ""

#: src/ch10-02-traits.md:417
msgid ""
"We can also specify more than one trait bound. Say we wanted `notify` to use "
"display formatting as well as `summarize` on `item`: we specify in the "
"`notify` definition that `item` must implement both `Display` and `Summary`. "
"We can do so using the `+` syntax:"
msgstr ""

#: src/ch10-02-traits.md:426
msgid "The `+` syntax is also valid with trait bounds on generic types:"
msgstr ""

#: src/ch10-02-traits.md:432
msgid ""
"With the two trait bounds specified, the body of `notify` can call "
"`summarize` and use `{}` to format `item`."
msgstr ""

#: src/ch10-02-traits.md:435
msgid "Clearer Trait Bounds with `where` Clauses"
msgstr ""

#: src/ch10-02-traits.md:437
msgid ""
"Using too many trait bounds has its downsides. Each generic has its own "
"trait bounds, so functions with multiple generic type parameters can contain "
"lots of trait bound information between the function’s name and its "
"parameter list, making the function signature hard to read. For this reason, "
"Rust has alternate syntax for specifying trait bounds inside a `where` "
"clause after the function signature. So, instead of writing this:"
msgstr ""

#: src/ch10-02-traits.md:448
msgid "we can use a `where` clause, like this:"
msgstr ""

#: src/ch10-02-traits.md:460
msgid ""
"This function’s signature is less cluttered: the function name, parameter "
"list, and return type are close together, similar to a function without lots "
"of trait bounds."
msgstr ""

#: src/ch10-02-traits.md:464
msgid "Returning Types That Implement Traits"
msgstr ""

#: src/ch10-02-traits.md:466
msgid ""
"We can also use the `impl Trait` syntax in the return position to return a "
"value of some type that implements a trait, as shown here:"
msgstr ""

#: src/ch10-02-traits.md:512
msgid ""
"By using `impl Summary` for the return type, we specify that the "
"`returns_summarizable` function returns some type that implements the "
"`Summary` trait without naming the concrete type. In this case, "
"`returns_summarizable` returns a `Tweet`, but the code calling this function "
"doesn’t need to know that."
msgstr ""

#: src/ch10-02-traits.md:517
msgid ""
"The ability to specify a return type only by the trait it implements is "
"especially useful in the context of closures and iterators, which we cover "
"in Chapter 13. Closures and iterators create types that only the compiler "
"knows or types that are very long to specify. The `impl Trait` syntax lets "
"you concisely specify that a function returns some type that implements the "
"`Iterator` trait without needing to write out a very long type."
msgstr ""

#: src/ch10-02-traits.md:524
msgid ""
"However, you can only use `impl Trait` if you’re returning a single type. "
"For example, this code that returns either a `NewsArticle` or a `Tweet` with "
"the return type specified as `impl Summary` wouldn’t work:"
msgstr ""

#: src/ch10-02-traits.md:568
msgid ""
"\"The Pittsburgh Penguins once again are the best \\\n"
"                 hockey team in the NHL.\""
msgstr ""

#: src/ch10-02-traits.md:585
msgid ""
"Returning either a `NewsArticle` or a `Tweet` isn’t allowed due to "
"restrictions around how the `impl Trait` syntax is implemented in the "
"compiler. We’ll cover how to write a function with this behavior in the "
"[“Using Trait Objects That Allow for Values of Different Types”](ch18-02-"
"trait-objects.html#using-trait-objects-that-allow-for-values-of-different-"
"types)<!--\n"
"ignore --> section of Chapter 18."
msgstr ""

#: src/ch10-02-traits.md:592
msgid "Using Trait Bounds to Conditionally Implement Methods"
msgstr ""

#: src/ch10-02-traits.md:594
msgid ""
"By using a trait bound with an `impl` block that uses generic type "
"parameters, we can implement methods conditionally for types that implement "
"the specified traits. For example, the type `Pair<T>` in Listing 10-15 "
"always implements the `new` function to return a new instance of `Pair<T>` "
"(recall from the [“Defining Methods”](ch05-03-method-syntax.html#defining-"
"methods)<!-- ignore --> section of Chapter 5 that `Self` is a type alias for "
"the type of the `impl` block, which in this case is `Pair<T>`). But in the "
"next `impl` block, `Pair<T>` only implements the `cmp_display` method if its "
"inner type `T` implements the `PartialOrd` trait that enables comparison "
"_and_ the `Display` trait that enables printing."
msgstr ""

#: src/ch10-02-traits.md:623
msgid "\"The largest member is x = {}\""
msgstr ""

#: src/ch10-02-traits.md:625
msgid "\"The largest member is y = {}\""
msgstr ""

#: src/ch10-02-traits.md:633
msgid ""
"We can also conditionally implement a trait for any type that implements "
"another trait. Implementations of a trait on any type that satisfies the "
"trait bounds are called _blanket implementations_ and are used extensively "
"in the Rust standard library. For example, the standard library implements "
"the `ToString` trait on any type that implements the `Display` trait. The "
"`impl` block in the standard library looks similar to this code:"
msgstr ""

#: src/ch10-02-traits.md:646
msgid ""
"Because the standard library has this blanket implementation, we can call "
"the `to_string` method defined by the `ToString` trait on any type that "
"implements the `Display` trait. For example, we can turn integers into their "
"corresponding `String` values like this because integers implement `Display`:"
msgstr ""

#: src/ch10-02-traits.md:655
msgid ""
"Blanket implementations appear in the documentation for the trait in the "
"“Implementors” section."
msgstr ""

#: src/ch10-02-traits.md:658
msgid ""
"Traits and trait bounds let us write code that uses generic type parameters "
"to reduce duplication but also specify to the compiler that we want the "
"generic type to have particular behavior. The compiler can then use the "
"trait bound information to check that all the concrete types used with our "
"code provide the correct behavior. In dynamically typed languages, we would "
"get an error at runtime if we called a method on a type which didn’t define "
"the method. But Rust moves these errors to compile time so we’re forced to "
"fix the problems before our code is even able to run. Additionally, we don’t "
"have to write code that checks for behavior at runtime because we’ve already "
"checked at compile time. Doing so improves performance without having to "
"give up the flexibility of generics."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:3
msgid ""
"Lifetimes are another kind of generic that we’ve already been using. Rather "
"than ensuring that a type has the behavior we want, lifetimes ensure that "
"references are valid as long as we need them to be."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:7
msgid ""
"One detail we didn’t discuss in the [“References and Borrowing”](ch04-02-"
"references-and-borrowing.html#references-and-borrowing)<!-- ignore --> "
"section in Chapter 4 is that every reference in Rust has a _lifetime_, which "
"is the scope for which that reference is valid. Most of the time, lifetimes "
"are implicit and inferred, just like most of the time, types are inferred. "
"We must annotate types only when multiple types are possible. In a similar "
"way, we must annotate lifetimes when the lifetimes of references could be "
"related in a few different ways. Rust requires us to annotate the "
"relationships using generic lifetime parameters to ensure the actual "
"references used at runtime will definitely be valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:17
msgid ""
"Annotating lifetimes is not even a concept most other programming languages "
"have, so this is going to feel unfamiliar. Although we won’t cover lifetimes "
"in their entirety in this chapter, we’ll discuss common ways you might "
"encounter lifetime syntax so you can get comfortable with the concept."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:22
msgid "Preventing Dangling References with Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:24
msgid ""
"The main aim of lifetimes is to prevent _dangling references_, which cause a "
"program to reference data other than the data it’s intended to reference. "
"Consider the program in Listing 10-16, which has an outer scope and an inner "
"scope."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:40 src/ch10-03-lifetime-syntax.md:105
#: src/ch10-03-lifetime-syntax.md:129
msgid "\"r: {r}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:46
msgid ""
"Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables "
"without giving them an initial value, so the variable name exists in the "
"outer scope. At first glance, this might appear to be in conflict with "
"Rust’s having no null values. However, if we try to use a variable before "
"giving it a value, we’ll get a compile-time error, which shows that Rust "
"indeed does not allow null values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:53
msgid ""
"The outer scope declares a variable named `r` with no initial value, and the "
"inner scope declares a variable named `x` with the initial value of `5`. "
"Inside the inner scope, we attempt to set the value of `r` as a reference to "
"`x`. Then the inner scope ends, and we attempt to print the value in `r`. "
"This code won’t compile because the value that `r` is referring to has gone "
"out of scope before we try to use it. Here is the error message:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:60
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `x` does not live long enough\n"
" --> src/main.rs:6:13\n"
"  |\n"
"5 |         let x = 5;\n"
"  |             - binding `x` declared here\n"
"6 |         r = &x;\n"
"  |             ^^ borrowed value does not live long enough\n"
"7 |     }\n"
"  |     - `x` dropped here while still borrowed\n"
"8 |\n"
"9 |     println!(\"r: {r}\");\n"
"  |                  --- borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:80
msgid ""
"The error message says that the variable `x` “does not live long enough.” "
"The reason is that `x` will be out of scope when the inner scope ends on "
"line 7. But `r` is still valid for the outer scope; because its scope is "
"larger, we say that it “lives longer.” If Rust allowed this code to work, "
"`r` would be referencing memory that was deallocated when `x` went out of "
"scope, and anything we tried to do with `r` wouldn’t work correctly. So how "
"does Rust determine that this code is invalid? It uses a borrow checker."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:88
msgid "The Borrow Checker"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:90
msgid ""
"The Rust compiler has a _borrow checker_ that compares scopes to determine "
"whether all borrows are valid. Listing 10-17 shows the same code as Listing "
"10-16 but with annotations showing the lifetimes of the variables."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:98
msgid ""
"// ---------+-- 'a\n"
"                          //          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:100 src/ch10-03-lifetime-syntax.md:105
msgid "//          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:101
msgid "// -+-- 'b  |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:102
msgid "//  |       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:103
msgid ""
"// -+       |\n"
"                          //          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:106
msgid "// ---------+\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:111
msgid ""
"Here, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x` "
"with `'b`. As you can see, the inner `'b` block is much smaller than the "
"outer `'a` lifetime block. At compile time, Rust compares the size of the "
"two lifetimes and sees that `r` has a lifetime of `'a` but that it refers to "
"memory with a lifetime of `'b`. The program is rejected because `'b` is "
"shorter than `'a`: the subject of the reference doesn’t live as long as the "
"reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:118
msgid ""
"Listing 10-18 fixes the code so it doesn’t have a dangling reference and it "
"compiles without any errors."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:125
msgid ""
"// ----------+-- 'b\n"
"                          //           |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:127
msgid ""
"// --+-- 'a  |\n"
"                          //   |       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:129
msgid ""
"//   |       |\n"
"                          // --+       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:131
msgid "// ----------+\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:136
msgid ""
"Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. "
"This means `r` can reference `x` because Rust knows that the reference in "
"`r` will always be valid while `x` is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:140
msgid ""
"Now that you know where the lifetimes of references are and how Rust "
"analyzes lifetimes to ensure references will always be valid, let’s explore "
"generic lifetimes of parameters and return values in the context of "
"functions."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:144
msgid "Generic Lifetimes in Functions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:146
msgid ""
"We’ll write a function that returns the longer of two string slices. This "
"function will take two string slices and return a single string slice. After "
"we’ve implemented the `longest` function, the code in Listing 10-19 should "
"print `The longest string is abcd`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:155 src/ch10-03-lifetime-syntax.md:179
#: src/ch10-03-lifetime-syntax.md:280 src/ch10-03-lifetime-syntax.md:454
#: src/ch10-03-lifetime-syntax.md:484 src/ch10-03-lifetime-syntax.md:837
msgid "\"abcd\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:156 src/ch10-03-lifetime-syntax.md:180
#: src/ch10-03-lifetime-syntax.md:281 src/ch10-03-lifetime-syntax.md:347
#: src/ch10-03-lifetime-syntax.md:385 src/ch10-03-lifetime-syntax.md:485
#: src/ch10-03-lifetime-syntax.md:838
msgid "\"xyz\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:159 src/ch10-03-lifetime-syntax.md:183
#: src/ch10-03-lifetime-syntax.md:284 src/ch10-03-lifetime-syntax.md:349
#: src/ch10-03-lifetime-syntax.md:388 src/ch10-03-lifetime-syntax.md:458
#: src/ch10-03-lifetime-syntax.md:488 src/ch10-03-lifetime-syntax.md:845
msgid "\"The longest string is {result}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:165
msgid ""
"Note that we want the function to take string slices, which are references, "
"rather than strings, because we don’t want the `longest` function to take "
"ownership of its parameters. Refer to [“String Slices as Parameters”]"
"(ch04-03-slices.html#string-slices-as-parameters)<!-- ignore --> in Chapter "
"4 for more discussion about why the parameters we use in Listing 10-19 are "
"the ones we want."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:172
msgid ""
"If we try to implement the `longest` function as shown in Listing 10-20, it "
"won’t compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:197
msgid "Instead, we get the following error that talks about lifetimes:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:199
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:9:33\n"
"  |\n"
"9 | fn longest(x: &str, y: &str) -> &str {\n"
"  |               ----     ----     ^ expected named lifetime parameter\n"
"  |\n"
"  = help: this function's return type contains a borrowed value, but the "
"signature does not say whether it is borrowed from `x` or `y`\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"  |           ++++     ++          ++          ++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:218
msgid ""
"The help text reveals that the return type needs a generic lifetime "
"parameter on it because Rust can’t tell whether the reference being returned "
"refers to `x` or `y`. Actually, we don’t know either, because the `if` block "
"in the body of this function returns a reference to `x` and the `else` block "
"returns a reference to `y`!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:224
msgid ""
"When we’re defining this function, we don’t know the concrete values that "
"will be passed into this function, so we don’t know whether the `if` case or "
"the `else` case will execute. We also don’t know the concrete lifetimes of "
"the references that will be passed in, so we can’t look at the scopes as we "
"did in Listings 10-17 and 10-18 to determine whether the reference we return "
"will always be valid. The borrow checker can’t determine this either, "
"because it doesn’t know how the lifetimes of `x` and `y` relate to the "
"lifetime of the return value. To fix this error, we’ll add generic lifetime "
"parameters that define the relationship between the references so the borrow "
"checker can perform its analysis."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:235
msgid "Lifetime Annotation Syntax"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:237
msgid ""
"Lifetime annotations don’t change how long any of the references live. "
"Rather, they describe the relationships of the lifetimes of multiple "
"references to each other without affecting the lifetimes. Just as functions "
"can accept any type when the signature specifies a generic type parameter, "
"functions can accept references with any lifetime by specifying a generic "
"lifetime parameter."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:243
msgid ""
"Lifetime annotations have a slightly unusual syntax: the names of lifetime "
"parameters must start with an apostrophe (`'`) and are usually all lowercase "
"and very short, like generic types. Most people use the name `'a` for the "
"first lifetime annotation. We place lifetime parameter annotations after the "
"`&` of a reference, using a space to separate the annotation from the "
"reference’s type."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:249
msgid ""
"Here are some examples: a reference to an `i32` without a lifetime "
"parameter, a reference to an `i32` that has a lifetime parameter named `'a`, "
"and a mutable reference to an `i32` that also has the lifetime `'a`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:254
msgid "// a reference\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:255
msgid "// a reference with an explicit lifetime\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:256
msgid "// a mutable reference with an explicit lifetime\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:259
msgid ""
"One lifetime annotation by itself doesn’t have much meaning because the "
"annotations are meant to tell Rust how generic lifetime parameters of "
"multiple references relate to each other. Let’s examine how the lifetime "
"annotations relate to each other in the context of the `longest` function."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:264
msgid "Lifetime Annotations in Function Signatures"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:266
msgid ""
"To use lifetime annotations in function signatures, we need to declare the "
"generic _lifetime_ parameters inside angle brackets between the function "
"name and the parameter list, just as we did with generic _type_ parameters."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:270
msgid ""
"We want the signature to express the following constraint: the returned "
"reference will be valid as long as both the parameters are valid. This is "
"the relationship between lifetimes of the parameters and the return value. "
"We’ll name the lifetime `'a` and then add it to each reference, as shown in "
"Listing 10-21."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:298
msgid ""
"This code should compile and produce the result we want when we use it with "
"the `main` function in Listing 10-19."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:301
msgid ""
"The function signature now tells Rust that for some lifetime `'a`, the "
"function takes two parameters, both of which are string slices that live at "
"least as long as lifetime `'a`. The function signature also tells Rust that "
"the string slice returned from the function will live at least as long as "
"lifetime `'a`. In practice, it means that the lifetime of the reference "
"returned by the `longest` function is the same as the smaller of the "
"lifetimes of the values referred to by the function arguments. These "
"relationships are what we want Rust to use when analyzing this code."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:310
msgid ""
"Remember, when we specify the lifetime parameters in this function "
"signature, we’re not changing the lifetimes of any values passed in or "
"returned. Rather, we’re specifying that the borrow checker should reject any "
"values that don’t adhere to these constraints. Note that the `longest` "
"function doesn’t need to know exactly how long `x` and `y` will live, only "
"that some scope can be substituted for `'a` that will satisfy this signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:317
msgid ""
"When annotating lifetimes in functions, the annotations go in the function "
"signature, not in the function body. The lifetime annotations become part of "
"the contract of the function, much like the types in the signature. Having "
"function signatures contain the lifetime contract means the analysis the "
"Rust compiler does can be simpler. If there’s a problem with the way a "
"function is annotated or the way it is called, the compiler errors can point "
"to the part of our code and the constraints more precisely. If, instead, the "
"Rust compiler made more inferences about what we intended the relationships "
"of the lifetimes to be, the compiler might only be able to point to a use of "
"our code many steps away from the cause of the problem."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:328
msgid ""
"When we pass concrete references to `longest`, the concrete lifetime that is "
"substituted for `'a` is the part of the scope of `x` that overlaps with the "
"scope of `y`. In other words, the generic lifetime `'a` will get the "
"concrete lifetime that is equal to the smaller of the lifetimes of `x` and "
"`y`. Because we’ve annotated the returned reference with the same lifetime "
"parameter `'a`, the returned reference will also be valid for the length of "
"the smaller of the lifetimes of `x` and `y`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:336
msgid ""
"Let’s look at how the lifetime annotations restrict the `longest` function "
"by passing in references that have different concrete lifetimes. Listing "
"10-22 is a straightforward example."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:344 src/ch10-03-lifetime-syntax.md:382
msgid "\"long string is long\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:364
msgid ""
"In this example, `string1` is valid until the end of the outer scope, "
"`string2` is valid until the end of the inner scope, and `result` references "
"something that is valid until the end of the inner scope. Run this code and "
"you’ll see that the borrow checker approves; it will compile and print `The "
"longest string is long string is long`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:370
msgid ""
"Next, let’s try an example that shows that the lifetime of the reference in "
"`result` must be the smaller lifetime of the two arguments. We’ll move the "
"declaration of the `result` variable outside the inner scope but leave the "
"assignment of the value to the `result` variable inside the scope with "
"`string2`. Then we’ll move the `println!` that uses `result` to outside the "
"inner scope, after the inner scope has ended. The code in Listing 10-23 will "
"not compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:402
msgid "When we try to compile this code, we get this error:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:404
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `string2` does not live long enough\n"
" --> src/main.rs:6:44\n"
"  |\n"
"5 |         let string2 = String::from(\"xyz\");\n"
"  |             ------- binding `string2` declared here\n"
"6 |         result = longest(string1.as_str(), string2.as_str());\n"
"  |                                            ^^^^^^^ borrowed value does "
"not live long enough\n"
"7 |     }\n"
"  |     - `string2` dropped here while still borrowed\n"
"8 |     println!(\"The longest string is {result}\");\n"
"  |                                     -------- borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:423
msgid ""
"The error shows that for `result` to be valid for the `println!` statement, "
"`string2` would need to be valid until the end of the outer scope. Rust "
"knows this because we annotated the lifetimes of the function parameters and "
"return values using the same lifetime parameter `'a`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:428
msgid ""
"As humans, we can look at this code and see that `string1` is longer than "
"`string2`, and therefore, `result` will contain a reference to `string1`. "
"Because `string1` has not gone out of scope yet, a reference to `string1` "
"will still be valid for the `println!` statement. However, the compiler "
"can’t see that the reference is valid in this case. We’ve told Rust that the "
"lifetime of the reference returned by the `longest` function is the same as "
"the smaller of the lifetimes of the references passed in. Therefore, the "
"borrow checker disallows the code in Listing 10-23 as possibly having an "
"invalid reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:437
msgid ""
"Try designing more experiments that vary the values and lifetimes of the "
"references passed in to the `longest` function and how the returned "
"reference is used. Make hypotheses about whether or not your experiments "
"will pass the borrow checker before you compile; then check to see if you’re "
"right!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:442
msgid "Thinking in Terms of Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:444
msgid ""
"The way in which you need to specify lifetime parameters depends on what "
"your function is doing. For example, if we changed the implementation of the "
"`longest` function to always return the first parameter rather than the "
"longest string slice, we wouldn’t need to specify a lifetime on the `y` "
"parameter. The following code will compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:455
msgid "\"efghijklmnopqrstuvwxyz\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:468
msgid ""
"We’ve specified a lifetime parameter `'a` for the parameter `x` and the "
"return type, but not for the parameter `y`, because the lifetime of `y` does "
"not have any relationship with the lifetime of `x` or the return value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:472
msgid ""
"When returning a reference from a function, the lifetime parameter for the "
"return type needs to match the lifetime parameter for one of the parameters. "
"If the reference returned does _not_ refer to one of the parameters, it must "
"refer to a value created within this function. However, this would be a "
"dangling reference because the value will go out of scope at the end of the "
"function. Consider this attempted implementation of the `longest` function "
"that won’t compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:492
msgid "\"really long string\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:499
msgid ""
"Here, even though we’ve specified a lifetime parameter `'a` for the return "
"type, this implementation will fail to compile because the return value "
"lifetime is not related to the lifetime of the parameters at all. Here is "
"the error message we get:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:504
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0515]: cannot return value referencing local variable `result`\n"
"  --> src/main.rs:11:5\n"
"   |\n"
"11 |     result.as_str()\n"
"   |     ------^^^^^^^^^\n"
"   |     |\n"
"   |     returns a value referencing data owned by the current function\n"
"   |     `result` is borrowed here\n"
"\n"
"For more information about this error, try `rustc --explain E0515`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:520
msgid ""
"The problem is that `result` goes out of scope and gets cleaned up at the "
"end of the `longest` function. We’re also trying to return a reference to "
"`result` from the function. There is no way we can specify lifetime "
"parameters that would change the dangling reference, and Rust won’t let us "
"create a dangling reference. In this case, the best fix would be to return "
"an owned data type rather than a reference so the calling function is then "
"responsible for cleaning up the value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:528
msgid ""
"Ultimately, lifetime syntax is about connecting the lifetimes of various "
"parameters and return values of functions. Once they’re connected, Rust has "
"enough information to allow memory-safe operations and disallow operations "
"that would create dangling pointers or otherwise violate memory safety."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:533
msgid "Lifetime Annotations in Struct Definitions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:535
msgid ""
"So far, the structs we’ve defined all hold owned types. We can define "
"structs to hold references, but in that case we would need to add a lifetime "
"annotation on every reference in the struct’s definition. Listing 10-24 has "
"a struct named `ImportantExcerpt` that holds a string slice."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:548 src/ch10-03-lifetime-syntax.md:763
#: src/ch10-03-lifetime-syntax.md:796
msgid "\"Call me Ishmael. Some years ago...\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:549 src/ch10-03-lifetime-syntax.md:764
#: src/ch10-03-lifetime-syntax.md:797
msgid "'.'"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:558
msgid ""
"This struct has the single field `part` that holds a string slice, which is "
"a reference. As with generic data types, we declare the name of the generic "
"lifetime parameter inside angle brackets after the name of the struct so we "
"can use the lifetime parameter in the body of the struct definition. This "
"annotation means an instance of `ImportantExcerpt` can’t outlive the "
"reference it holds in its `part` field."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:565
msgid ""
"The `main` function here creates an instance of the `ImportantExcerpt` "
"struct that holds a reference to the first sentence of the `String` owned by "
"the variable `novel`. The data in `novel` exists before the "
"`ImportantExcerpt` instance is created. In addition, `novel` doesn’t go out "
"of scope until after the `ImportantExcerpt` goes out of scope, so the "
"reference in the `ImportantExcerpt` instance is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:572
msgid "Lifetime Elision"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:574
msgid ""
"You’ve learned that every reference has a lifetime and that you need to "
"specify lifetime parameters for functions or structs that use references. "
"However, we had a function in Listing 4-9, shown again in Listing 10-25, "
"that compiled without lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:597
msgid "// first_word works on slices of `String`s\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:602
msgid "// first_word works on slices of string literals\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:613
msgid ""
"The reason this function compiles without lifetime annotations is "
"historical: in early versions (pre-1.0) of Rust, this code wouldn’t have "
"compiled because every reference needed an explicit lifetime. At that time, "
"the function signature would have been written like this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:622
msgid ""
"After writing a lot of Rust code, the Rust team found that Rust programmers "
"were entering the same lifetime annotations over and over in particular "
"situations. These situations were predictable and followed a few "
"deterministic patterns. The developers programmed these patterns into the "
"compiler’s code so the borrow checker could infer the lifetimes in these "
"situations and wouldn’t need explicit annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:629
msgid ""
"This piece of Rust history is relevant because it’s possible that more "
"deterministic patterns will emerge and be added to the compiler. In the "
"future, even fewer lifetime annotations might be required."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:633
msgid ""
"The patterns programmed into Rust’s analysis of references are called the "
"_lifetime elision rules_. These aren’t rules for programmers to follow; "
"they’re a set of particular cases that the compiler will consider, and if "
"your code fits these cases, you don’t need to write the lifetimes explicitly."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:638
msgid ""
"The elision rules don’t provide full inference. If there is still ambiguity "
"as to what lifetimes the references have after Rust applies the rules, the "
"compiler won’t guess what the lifetime of the remaining references should "
"be. Instead of guessing, the compiler will give you an error that you can "
"resolve by adding the lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:644
msgid ""
"Lifetimes on function or method parameters are called _input lifetimes_, and "
"lifetimes on return values are called _output lifetimes_."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:647
msgid ""
"The compiler uses three rules to figure out the lifetimes of the references "
"when there aren’t explicit annotations. The first rule applies to input "
"lifetimes, and the second and third rules apply to output lifetimes. If the "
"compiler gets to the end of the three rules and there are still references "
"for which it can’t figure out lifetimes, the compiler will stop with an "
"error. These rules apply to `fn` definitions as well as `impl` blocks."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:654
msgid ""
"The first rule is that the compiler assigns a lifetime parameter to each "
"parameter that’s a reference. In other words, a function with one parameter "
"gets one lifetime parameter: `fn foo<'a>(x: &'a i32)`; a function with two "
"parameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a "
"i32, y: &'b i32)`; and so on."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:660
msgid ""
"The second rule is that, if there is exactly one input lifetime parameter, "
"that lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: "
"&'a i32) -> &'a i32`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:664
msgid ""
"The third rule is that, if there are multiple input lifetime parameters, but "
"one of them is `&self` or `&mut self` because this is a method, the lifetime "
"of `self` is assigned to all output lifetime parameters. This third rule "
"makes methods much nicer to read and write because fewer symbols are "
"necessary."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:669
msgid ""
"Let’s pretend we’re the compiler. We’ll apply these rules to figure out the "
"lifetimes of the references in the signature of the `first_word` function in "
"Listing 10-25. The signature starts without any lifetimes associated with "
"the references:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:678
msgid ""
"Then the compiler applies the first rule, which specifies that each "
"parameter gets its own lifetime. We’ll call it `'a` as usual, so now the "
"signature is this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:686
msgid ""
"The second rule applies because there is exactly one input lifetime. The "
"second rule specifies that the lifetime of the one input parameter gets "
"assigned to the output lifetime, so the signature is now this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:694
msgid ""
"Now all the references in this function signature have lifetimes, and the "
"compiler can continue its analysis without needing the programmer to "
"annotate the lifetimes in this function signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:698
msgid ""
"Let’s look at another example, this time using the `longest` function that "
"had no lifetime parameters when we started working with it in Listing 10-20:"
msgstr "이번에는 목록 10-20에서 작업하기 시작했을 때 라이프타임 매개변수가 없었던 `longest` 함수를 사용하여 다른 예제를 살펴보겠습니다:"

#: src/ch10-03-lifetime-syntax.md:705
msgid ""
"Let’s apply the first rule: each parameter gets its own lifetime. This time "
"we have two parameters instead of one, so we have two lifetimes:"
msgstr "첫 번째 규칙을 적용해 봅시다. 각 매개변수는 자체 라이프타임을 가집니다. 이번에는 매개변수가 하나가 아니라 두 개이므로 두 개의 라이프타임을 가집니다:"

#: src/ch10-03-lifetime-syntax.md:712
msgid ""
"You can see that the second rule doesn’t apply because there is more than "
"one input lifetime. The third rule doesn’t apply either, because `longest` "
"is a function rather than a method, so none of the parameters are `self`. "
"After working through all three rules, we still haven’t figured out what the "
"return type’s lifetime is. This is why we got an error trying to compile the "
"code in Listing 10-20: the compiler worked through the lifetime elision "
"rules but still couldn’t figure out all the lifetimes of the references in "
"the signature."
msgstr "두 번째 규칙은 입력 라이프타임이 하나 이상이므로 적용되지 않습니다. 세 번째 규칙도 `longest`가 메서드가 아닌 함수이므로 매개변수 중 `self`가 없기 때문에 적용되지 않습니다. 세 가지 규칙을 모두 적용한 후에도 반환 타입의 라이프타임이 무엇인지 파악하지 못했습니다. 이것이 목록 10-20의 코드를 컴파일하려고 할 때 오류가 발생한 이유입니다. 컴파일러는 라이프타임 생략 규칙을 적용했지만 시그니처의 참조에 대한 모든 라이프타임을 여전히 파악할 수 없었습니다."

#: src/ch10-03-lifetime-syntax.md:720
msgid ""
"Because the third rule really only applies in method signatures, we’ll look "
"at lifetimes in that context next to see why the third rule means we don’t "
"have to annotate lifetimes in method signatures very often."
msgstr "세 번째 규칙은 실제로 메서드 시그니처에만 적용되므로, 다음으로 해당 컨텍스트에서 라이프타임을 살펴보고 세 번째 규칙 때문에 메서드 시그니처에 라이프타임을 자주 명시할 필요가 없는 이유를 알아보겠습니다."

#: src/ch10-03-lifetime-syntax.md:724
msgid "Lifetime Annotations in Method Definitions"
msgstr "메서드 정의의 라이프타임 명시"

#: src/ch10-03-lifetime-syntax.md:726
msgid ""
"When we implement methods on a struct with lifetimes, we use the same syntax "
"as that of generic type parameters, as shown in Listing 10-11. Where we "
"declare and use the lifetime parameters depends on whether they’re related "
"to the struct fields or the method parameters and return values."
msgstr "라이프타임을 가진 구조체에 메서드를 구현할 때, 목록 10-11에 표시된 것처럼 제네릭 타입 매개변수와 동일한 문법을 사용합니다. 라이프타임 매개변수를 선언하고 사용하는 위치는 구조체 필드와 관련이 있는지, 아니면 메서드 매개변수 및 반환 값과 관련이 있는지에 따라 달라집니다."

#: src/ch10-03-lifetime-syntax.md:731
msgid ""
"Lifetime names for struct fields always need to be declared after the `impl` "
"keyword and then used after the struct’s name because those lifetimes are "
"part of the struct’s type."
msgstr "구조체 필드의 라이프타임 이름은 항상 `impl` 키워드 뒤에 선언되어야 하며, 그런 다음 구조체 이름 뒤에 사용되어야 합니다. 왜냐하면 해당 라이프타임은 구조체 타입의 일부이기 때문입니다."

#: src/ch10-03-lifetime-syntax.md:735
msgid ""
"In method signatures inside the `impl` block, references might be tied to "
"the lifetime of references in the struct’s fields, or they might be "
"independent. In addition, the lifetime elision rules often make it so that "
"lifetime annotations aren’t necessary in method signatures. Let’s look at "
"some examples using the struct named `ImportantExcerpt` that we defined in "
"Listing 10-24."
msgstr "`impl` 블록 내부의 메서드 시그니처에서 참조는 구조체 필드의 참조 라이프타임에 묶여 있을 수도 있고, 독립적일 수도 있습니다. 또한 라이프타임 생략 규칙으로 인해 메서드 시그니처에 라이프타임 명시가 필요 없는 경우가 많습니다. 목록 10-24에서 정의한 `ImportantExcerpt`라는 구조체를 사용하여 몇 가지 예제를 살펴보겠습니다."

#: src/ch10-03-lifetime-syntax.md:741
msgid ""
"First we’ll use a method named `level` whose only parameter is a reference "
"to `self` and whose return value is an `i32`, which is not a reference to "
"anything:"
msgstr "먼저 유일한 매개변수가 `self`에 대한 참조이고 반환 값이 `i32`인 `level`이라는 메서드를 사용할 것입니다. `i32`는 어떤 것에도 대한 참조가 아닙니다:"

#: src/ch10-03-lifetime-syntax.md:757 src/ch10-03-lifetime-syntax.md:790
msgid "\"Attention please: {announcement}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:771
msgid ""
"The lifetime parameter declaration after `impl` and its use after the type "
"name are required, but we’re not required to annotate the lifetime of the "
"reference to `self` because of the first elision rule."
msgstr "`impl` 뒤의 라이프타임 매개변수 선언과 타입 이름 뒤의 사용은 필수적이지만, 첫 번째 생략 규칙 때문에 `self`에 대한 참조의 라이프타임을 명시할 필요는 없습니다."

#: src/ch10-03-lifetime-syntax.md:775
msgid "Here is an example where the third lifetime elision rule applies:"
msgstr "다음은 세 번째 라이프타임 생략 규칙이 적용되는 예제입니다:"

#: src/ch10-03-lifetime-syntax.md:804
msgid ""
"There are two input lifetimes, so Rust applies the first lifetime elision "
"rule and gives both `&self` and `announcement` their own lifetimes. Then, "
"because one of the parameters is `&self`, the return type gets the lifetime "
"of `&self`, and all lifetimes have been accounted for."
msgstr "두 개의 입력 라이프타임이 있으므로, 러스트는 첫 번째 라이프타임 생략 규칙을 적용하여 `&self`와 `announcement` 모두에게 자체 라이프타임을 부여합니다. 그런 다음 매개변수 중 하나가 `&self`이므로 반환 타입은 `&self`의 라이프타임을 얻게 되며, 모든 라이프타임이 고려됩니다."

#: src/ch10-03-lifetime-syntax.md:809
msgid "The Static Lifetime"
msgstr "정적 라이프타임"

#: src/ch10-03-lifetime-syntax.md:811
msgid ""
"One special lifetime we need to discuss is `'static`, which denotes that the "
"affected reference _can_ live for the entire duration of the program. All "
"string literals have the `'static` lifetime, which we can annotate as "
"follows:"
msgstr "논의해야 할 한 가지 특별한 라이프타임은 `'static`입니다. 이는 영향을 받는 참조가 프로그램의 전체 기간 동안 _살아있을 수 있음_을 나타냅니다. 모든 문자열 리터럴은 `'static` 라이프타임을 가지며, 다음과 같이 명시할 수 있습니다:"

#: src/ch10-03-lifetime-syntax.md:816
msgid "\"I have a static lifetime.\""
msgstr "\"나는 정적 라이프타임을 가지고 있습니다.\""

#: src/ch10-03-lifetime-syntax.md:819
msgid ""
"The text of this string is stored directly in the program’s binary, which is "
"always available. Therefore, the lifetime of all string literals is "
"`'static`."
msgstr "이 문자열의 텍스트는 프로그램의 바이너리에 직접 저장되며, 이는 항상 사용 가능합니다. 따라서 모든 문자열 리터럴의 라이프타임은 `'static`입니다."

#: src/ch10-03-lifetime-syntax.md:822
msgid ""
"You might see suggestions in error messages to use the `'static` lifetime. "
"But before specifying `'static` as the lifetime for a reference, think about "
"whether the reference you have actually lives the entire lifetime of your "
"program or not, and whether you want it to. Most of the time, an error "
"message suggesting the `'static` lifetime results from attempting to create "
"a dangling reference or a mismatch of the available lifetimes. In such "
"cases, the solution is to fix those problems, not to specify the `'static` "
"lifetime."
msgstr "오류 메시지에서 `'static` 라이프타임을 사용하라는 제안을 볼 수도 있습니다. 하지만 참조에 대해 `'static`을 라이프타임으로 지정하기 전에, 가지고 있는 참조가 실제로 프로그램의 전체 라이프타임 동안 살아있는지 여부와 그렇게 되기를 원하는지 생각해 보세요. 대부분의 경우, `'static` 라이프타임을 제안하는 오류 메시지는 매달린 참조를 생성하려 했거나 사용 가능한 라이프타임이 일치하지 않아 발생합니다. 이러한 경우 해결책은 `'static` 라이프타임을 지정하는 것이 아니라 해당 문제를 해결하는 것입니다."

#: src/ch10-03-lifetime-syntax.md:830
msgid "Generic Type Parameters, Trait Bounds, and Lifetimes Together"
msgstr "제네릭 타입 매개변수, 트레이트 바운드 및 라이프타임 함께 사용하기"

#: src/ch10-03-lifetime-syntax.md:832
msgid ""
"Let’s briefly look at the syntax of specifying generic type parameters, "
"trait bounds, and lifetimes all in one function!"
msgstr "제네릭 타입 매개변수, 트레이트 바운드, 라이프타임을 모두 하나의 함수에서 지정하는 문법을 간략하게 살펴보겠습니다!"

#: src/ch10-03-lifetime-syntax.md:843
msgid "\"Today is someone's birthday!\""
msgstr "\"오늘은 누군가의 생일입니다!\""

#: src/ch10-03-lifetime-syntax.md:858
msgid "\"Announcement! {ann}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:867
msgid ""
"This is the `longest` function from Listing 10-21 that returns the longer of "
"two string slices. But now it has an extra parameter named `ann` of the "
"generic type `T`, which can be filled in by any type that implements the "
"`Display` trait as specified by the `where` clause. This extra parameter "
"will be printed using `{}`, which is why the `Display` trait bound is "
"necessary. Because lifetimes are a type of generic, the declarations of the "
"lifetime parameter `'a` and the generic type parameter `T` go in the same "
"list inside the angle brackets after the function name."
msgstr "이것은 목록 10-21의 `longest` 함수로, 두 문자열 슬라이스 중 더 긴 것을 반환합니다. 하지만 이제 `where` 절에 지정된 대로 `Display` 트레이트를 구현하는 모든 타입으로 채워질 수 있는 제네릭 타입 `T`의 `ann`이라는 추가 매개변수를 가집니다. 이 추가 매개변수는 `{}`를 사용하여 출력될 것이며, 이것이 `Display` 트레이트 바운드가 필요한 이유입니다. 라이프타임은 제네릭의 한 종류이므로, 라이프타임 매개변수 `'a`와 제네릭 타입 매개변수 `T`의 선언은 함수 이름 뒤의 꺾쇠 괄호 안의 동일한 목록에 들어갑니다."

#: src/ch10-03-lifetime-syntax.md:878
msgid ""
"We covered a lot in this chapter! Now that you know about generic type "
"parameters, traits and trait bounds, and generic lifetime parameters, you’re "
"ready to write code without repetition that works in many different "
"situations. Generic type parameters let you apply the code to different "
"types. Traits and trait bounds ensure that even though the types are "
"generic, they’ll have the behavior the code needs. You learned how to use "
"lifetime annotations to ensure that this flexible code won’t have any "
"dangling references. And all of this analysis happens at compile time, which "
"doesn’t affect runtime performance!"
msgstr "이 장에서 많은 내용을 다루었습니다! 이제 제네릭 타입 매개변수, 트레이트 및 트레이트 바운드, 제네릭 라이프타임 매개변수에 대해 알게 되었으므로, 다양한 상황에서 작동하는 반복 없는 코드를 작성할 준비가 되었습니다. 제네릭 타입 매개변수를 사용하면 코드를 다른 타입에 적용할 수 있습니다. 트레이트 및 트레이트 바운드는 타입이 제네릭이더라도 코드가 필요로 하는 동작을 가질 수 있도록 보장합니다. 라이프타임 명시를 사용하여 이 유연한 코드가 매달린 참조를 가지지 않도록 보장하는 방법을 배웠습니다. 그리고 이 모든 분석은 컴파일 타임에 이루어지므로 런타임 성능에 영향을 미치지 않습니다!"

#: src/ch10-03-lifetime-syntax.md:887
msgid ""
"Believe it or not, there is much more to learn on the topics we discussed in "
"this chapter: Chapter 18 discusses trait objects, which are another way to "
"use traits. There are also more complex scenarios involving lifetime "
"annotations that you will only need in very advanced scenarios; for those, "
"you should read the [Rust Reference](../reference/index.html). But next, "
"you’ll learn how to write tests in Rust so you can make sure your code is "
"working the way it should."
msgstr "믿거나 말거나, 이 장에서 논의한 주제에 대해 배울 것이 훨씬 더 많습니다. 18장에서는 트레이트를 사용하는 또 다른 방법인 트레이트 객체에 대해 다룹니다. 또한 매우 고급 시나리오에서만 필요한 라이프타임 명시와 관련된 더 복잡한 시나리오도 있습니다. 이에 대해서는 [러스트 참조](../reference/index.html)를 읽어야 합니다. 하지만 다음으로, 코드가 제대로 작동하는지 확인할 수 있도록 러스트에서 테스트를 작성하는 방법을 배울 것입니다."

#: src/ch11-00-testing.md:3
msgid ""
"In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that "
"“program testing can be a very effective way to show the presence of bugs, "
"but it is hopelessly inadequate for showing their absence.” That doesn’t "
"mean we shouldn’t try to test as much as we can!"
msgstr "1972년 에세이 “겸손한 프로그래머”에서 에츠허르 W. 다익스트라는 “프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법일 수 있지만, 버그의 부재를 보여주는 데는 절망적으로 부적절하다”고 말했습니다. 그렇다고 해서 우리가 할 수 있는 한 많이 테스트하지 말아야 한다는 의미는 아닙니다!"

#: src/ch11-00-testing.md:8
msgid ""
"Correctness in our programs is the extent to which our code does what we "
"intend it to do. Rust is designed with a high degree of concern about the "
"correctness of programs, but correctness is complex and not easy to prove. "
"Rust’s type system shoulders a huge part of this burden, but the type system "
"cannot catch everything. As such, Rust includes support for writing "
"automated software tests."
msgstr "우리 프로그램의 정확성은 코드가 의도한 대로 작동하는 정도를 의미합니다. 러스트는 프로그램의 정확성에 대한 높은 관심으로 설계되었지만, 정확성은 복잡하고 증명하기 쉽지 않습니다. 러스트의 타입 시스템이 이 부담의 상당 부분을 담당하지만, 타입 시스템이 모든 것을 잡아낼 수는 없습니다. 따라서 러스트는 자동화된 소프트웨어 테스트 작성을 지원합니다."

#: src/ch11-00-testing.md:14
msgid ""
"Say we write a function `add_two` that adds 2 to whatever number is passed "
"to it. This function’s signature accepts an integer as a parameter and "
"returns an integer as a result. When we implement and compile that function, "
"Rust does all the type checking and borrow checking that you’ve learned so "
"far to ensure that, for instance, we aren’t passing a `String` value or an "
"invalid reference to this function. But Rust _can’t_ check that this "
"function will do precisely what we intend, which is return the parameter "
"plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! "
"That’s where tests come in."
msgstr "매개변수로 전달된 숫자에 2를 더하는 `add_two` 함수를 작성한다고 가정해 봅시다. 이 함수의 시그니처는 정수를 매개변수로 받고 정수를 결과로 반환합니다. 이 함수를 구현하고 컴파일할 때, 러스트는 지금까지 배운 모든 타입 검사와 빌림 검사를 수행하여 예를 들어 `String` 값이나 유효하지 않은 참조를 이 함수에 전달하지 않도록 보장합니다. 하지만 러스트는 이 함수가 우리가 의도한 대로 정확히 작동하는지, 즉 매개변수에 10을 더하거나 50을 빼는 대신 매개변수에 2를 더하는지 _확인할 수 없습니다_! 바로 이 지점에서 테스트가 필요합니다."

#: src/ch11-00-testing.md:23
msgid ""
"We can write tests that assert, for example, that when we pass `3` to the "
"`add_two` function, the returned value is `5`. We can run these tests "
"whenever we make changes to our code to make sure any existing correct "
"behavior has not changed."
msgstr "예를 들어, `add_two` 함수에 `3`을 전달했을 때 반환 값이 `5`임을 단언하는 테스트를 작성할 수 있습니다. 코드에 변경 사항이 있을 때마다 이러한 테스트를 실행하여 기존의 올바른 동작이 변경되지 않았는지 확인할 수 있습니다."

#: src/ch11-00-testing.md:28
msgid ""
"Testing is a complex skill: although we can’t cover in one chapter every "
"detail about how to write good tests, in this chapter we will discuss the "
"mechanics of Rust’s testing facilities. We’ll talk about the annotations and "
"macros available to you when writing your tests, the default behavior and "
"options provided for running your tests, and how to organize tests into unit "
"tests and integration tests."
msgstr "테스트는 복잡한 기술입니다. 이 한 장에서 좋은 테스트를 작성하는 모든 세부 사항을 다룰 수는 없지만, 이 장에서는 러스트의 테스트 기능의 메커니즘에 대해 논의할 것입니다. 테스트를 작성할 때 사용할 수 있는 어노테이션과 매크로, 테스트 실행을 위해 제공되는 기본 동작과 옵션, 그리고 테스트를 단위 테스트와 통합 테스트로 구성하는 방법에 대해 이야기할 것입니다."

#: src/ch11-01-writing-tests.md:3
msgid ""
"Tests are Rust functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr "테스트는 비테스트 코드가 예상대로 작동하는지 확인하는 러스트 함수입니다. 테스트 함수의 본문은 일반적으로 다음 세 가지 작업을 수행합니다:"

#: src/ch11-01-writing-tests.md:7
msgid "Set up any needed data or state."
msgstr "필요한 데이터 또는 상태를 설정합니다."

#: src/ch11-01-writing-tests.md:8
msgid "Run the code you want to test."
msgstr "테스트하려는 코드를 실행합니다."

#: src/ch11-01-writing-tests.md:9
msgid "Assert that the results are what you expect."
msgstr "결과가 예상한 것과 일치하는지 단언합니다."

#: src/ch11-01-writing-tests.md:11
msgid ""
"Let’s look at the features Rust provides specifically for writing tests that "
"take these actions, which include the `test` attribute, a few macros, and "
"the `should_panic` attribute."
msgstr "러스트가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다. 여기에는 `test` 속성, 몇 가지 매크로, 그리고 `should_panic` 속성이 포함됩니다."

#: src/ch11-01-writing-tests.md:15
msgid "The Anatomy of a Test Function"
msgstr "테스트 함수의 구조"

#: src/ch11-01-writing-tests.md:17
msgid ""
"At its simplest, a test in Rust is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Rust code; one "
"example is the `derive` attribute we used with structs in Chapter 5. To "
"change a function into a test function, add `#[test]` on the line before "
"`fn`. When you run your tests with the `cargo test` command, Rust builds a "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr "가장 간단하게, 러스트의 테스트는 `test` 속성으로 주석이 달린 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용했던 `derive` 속성입니다. 함수를 테스트 함수로 변경하려면 `fn` 앞에 `#[test]`를 추가합니다. `cargo test` 명령으로 테스트를 실행하면, 러스트는 주석이 달린 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고하는 테스트 러너 바이너리를 빌드합니다."

#: src/ch11-01-writing-tests.md:25
msgid ""
"Whenever we make a new library project with Cargo, a test module with a test "
"function in it is automatically generated for us. This module gives you a "
"template for writing your tests so you don’t have to look up the exact "
"structure and syntax every time you start a new project. You can add as many "
"additional test functions and as many test modules as you want!"
msgstr "Cargo로 새 라이브러리 프로젝트를 만들 때마다 테스트 함수가 포함된 테스트 모듈이 자동으로 생성됩니다. 이 모듈은 테스트 작성을 위한 템플릿을 제공하므로 새 프로젝트를 시작할 때마다 정확한 구조와 구문을 찾아볼 필요가 없습니다. 원하는 만큼 추가 테스트 함수와 테스트 모듈을 추가할 수 있습니다!"

#: src/ch11-01-writing-tests.md:31
msgid ""
"We’ll explore some aspects of how tests work by experimenting with the "
"template test before we actually test any code. Then we’ll write some real-"
"world tests that call some code that we’ve written and assert that its "
"behavior is correct."
msgstr "실제로 코드를 테스트하기 전에 템플릿 테스트를 실험하여 테스트가 어떻게 작동하는지 몇 가지 측면을 탐구할 것입니다. 그런 다음 우리가 작성한 코드를 호출하고 그 동작이 올바른지 단언하는 실제 테스트를 작성할 것입니다."

#: src/ch11-01-writing-tests.md:35
msgid ""
"Let’s create a new library project called `adder` that will add two numbers:"
msgstr ""

#: src/ch11-01-writing-tests.md:43
msgid ""
"The contents of the _src/lib.rs_ file in your `adder` library should look "
"like Listing 11-1."
msgstr "여러분의 `adder` 라이브러리의 _src/lib.rs_ 파일 내용은 목록 11-1과 같아야 합니다."

#: src/ch11-01-writing-tests.md:78
msgid ""
"The file starts with an example `add` function, so that we have something to "
"test."
msgstr "파일은 예제 `add` 함수로 시작하므로, 테스트할 무언가가 있습니다."

#: src/ch11-01-writing-tests.md:81
msgid ""
"For now, let’s focus solely on the `it_works` function. Note the `#[test]` "
"annotation: this attribute indicates this is a test function, so the test "
"runner knows to treat this function as a test. We might also have non-test "
"functions in the `tests` module to help set up common scenarios or perform "
"common operations, so we always need to indicate which functions are tests."
msgstr "지금은 `it_works` 함수에만 집중해 봅시다. `#[test]` 어노테이션에 주목하세요. 이 속성은 이것이 테스트 함수임을 나타내므로, 테스트 러너는 이 함수를 테스트로 처리해야 한다는 것을 압니다. `tests` 모듈에는 공통 시나리오를 설정하거나 공통 작업을 수행하는 데 도움이 되는 비테스트 함수도 있을 수 있으므로, 어떤 함수가 테스트인지 항상 표시해야 합니다."

#: src/ch11-01-writing-tests.md:87
msgid ""
"The example function body uses the `assert_eq!` macro to assert that "
"`result`, which contains the result of calling `add` with 2 and 2, equals 4. "
"This assertion serves as an example of the format for a typical test. Let’s "
"run it to see that this test passes."
msgstr "예제 함수 본문은 `assert_eq!` 매크로를 사용하여 2와 2를 더한 `add` 호출의 결과인 `result`가 4와 같음을 단언합니다. 이 단언은 일반적인 테스트 형식의 예시 역할을 합니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다."

#: src/ch11-01-writing-tests.md:92
msgid ""
"The `cargo test` command runs all tests in our project, as shown in Listing "
"11-2."
msgstr ""

#: src/ch11-01-writing-tests.md:97
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n"
"     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/"
"adder-7acb243c25ffd9dc)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:117
msgid ""
"Cargo compiled and ran the test. We see the line `running 1 test`. The next "
"line shows the name of the generated test function, called "
"`tests::it_works`, and that the result of running that test is `ok`. The "
"overall summary `test result: ok.` means that all the tests passed, and the "
"portion that reads `1 passed; 0 failed` totals the number of tests that "
"passed or failed."
msgstr "Cargo가 테스트를 컴파일하고 실행했습니다. `running 1 test` 줄이 보입니다. 다음 줄은 생성된 테스트 함수 `tests::it_works`의 이름과 해당 테스트 실행 결과가 `ok`임을 보여줍니다. 전체 요약 `test result: ok.`는 모든 테스트가 통과했음을 의미하며, `1 passed; 0 failed` 부분은 통과하거나 실패한 테스트의 총 개수를 나타냅니다."

#: src/ch11-01-writing-tests.md:123
msgid ""
"It’s possible to mark a test as ignored so it doesn’t run in a particular "
"instance; we’ll cover that in the [“Ignoring Some Tests Unless Specifically "
"Requested”](ch11-02-running-tests.html#ignoring-some-tests-unless-"
"specifically-requested)<!-- ignore --> section later in this chapter. "
"Because we haven’t done that here, the summary shows `0 ignored`. We can "
"also pass an argument to the `cargo test` command to run only tests whose "
"name matches a string; this is called _filtering_ and we’ll cover that in "
"the [“Running a Subset of Tests by Name”](ch11-02-running-tests.html#running-"
"a-subset-of-tests-by-name)<!-- ignore --> section. Here we haven’t filtered "
"the tests being run, so the end of the summary shows `0 filtered out`."
msgstr "특정 인스턴스에서 실행되지 않도록 테스트를 무시로 표시할 수 있습니다. 이에 대해서는 이 장의 뒷부분에 있는 [“특별히 요청하지 않는 한 일부 테스트 무시하기”](ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested)<!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 그렇게 하지 않았으므로 요약에는 `0 ignored`가 표시됩니다. `cargo test` 명령에 문자열과 이름이 일치하는 테스트만 실행하도록 인수를 전달할 수도 있습니다. 이를 _필터링_이라고 하며, [“이름으로 테스트 하위 집합 실행하기”](ch11-02-running-tests.html#running-a-subset-of-tests-by-name)<!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 실행되는 테스트를 필터링하지 않았으므로 요약 끝에는 `0 filtered out`이 표시됩니다."

#: src/ch11-01-writing-tests.md:132
msgid ""
"The `0 measured` statistic is for benchmark tests that measure performance. "
"Benchmark tests are, as of this writing, only available in nightly Rust. See "
"[the documentation about benchmark tests](../unstable-book/library-features/"
"test.html) to learn more."
msgstr "`0 measured` 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다. 벤치마크 테스트는 이 글을 쓰는 시점에는 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 [벤치마크 테스트에 대한 문서](../unstable-book/library-features/test.html)를 참조하세요."

#: src/ch11-01-writing-tests.md:136
msgid ""
"The next part of the test output starting at `Doc-tests adder` is for the "
"results of any documentation tests. We don’t have any documentation tests "
"yet, but Rust can compile any code examples that appear in our API "
"documentation. This feature helps keep your docs and your code in sync! "
"We’ll discuss how to write documentation tests in the [“Documentation "
"Comments as Tests”](ch14-02-publishing-to-crates-io.html#documentation-"
"comments-as-tests)<!-- ignore --> section of Chapter 14. For now, we’ll "
"ignore the `Doc-tests` output."
msgstr "`Doc-tests adder`에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트 결과에 대한 것입니다. 아직 문서 테스트는 없지만, 러스트는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 [“테스트로서의 문서 주석”](ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests)<!-- ignore --> 섹션에서 문서 테스트를 작성하는 방법을 논의할 것입니다. 지금은 `Doc-tests` 출력을 무시하겠습니다."

#: src/ch11-01-writing-tests.md:144
msgid ""
"Let’s start to customize the test to our own needs. First, change the name "
"of the `it_works` function to a different name, such as `exploration`, like "
"so:"
msgstr "이제 테스트를 우리의 필요에 맞게 사용자 정의해 봅시다. 먼저 `it_works` 함수의 이름을 `exploration`과 같은 다른 이름으로 변경합니다. 다음과 같이 말이죠:"

#: src/ch11-01-writing-tests.md:147 src/ch11-01-writing-tests.md:386
#: src/ch11-01-writing-tests.md:708 src/ch11-02-running-tests.md:301
#: src/ch11-03-test-organization.md:38
#: src/ch12-04-testing-the-librarys-functionality.md:493
#: src/ch12-05-working-with-environment-variables.md:275
msgid "<span class=\"filename\">Filename: src/lib.rs</span>"
msgstr "<span class=\"filename\">파일명: src/lib.rs</span>"

#: src/ch11-01-writing-tests.md:166
msgid ""
"Then run `cargo test` again. The output now shows `exploration` instead of "
"`it_works`:"
msgstr "그런 다음 `cargo test`를 다시 실행합니다. 이제 출력은 `it_works` 대신 `exploration`을 보여줍니다:"

#: src/ch11-01-writing-tests.md:169
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::exploration ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:188
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. In Chapter 9, we talked about how the simplest way "
"to panic is to call the `panic!` macro. Enter the new test as a function "
"named `another`, so your _src/lib.rs_ file looks like Listing 11-3."
msgstr "이제 또 다른 테스트를 추가할 것입니다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 함수 내에서 무언가가 패닉을 일으키면 테스트는 실패합니다. 각 테스트는 새 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 확인하면 테스트는 실패로 표시됩니다. 9장에서 가장 간단한 패닉 방법은 `panic!` 매크로를 호출하는 것이라고 이야기했습니다. 새 테스트를 `another`라는 함수로 입력하면 _src/lib.rs_ 파일은 목록 11-3과 같아집니다."

#: src/ch11-01-writing-tests.md:214
msgid "\"Make this test fail\""
msgstr "\"이 테스트를 실패하게 만드세요\""

#: src/ch11-01-writing-tests.md:221
msgid ""
"Run the tests again using `cargo test`. The output should look like Listing "
"11-4, which shows that our `exploration` test passed and `another` failed."
msgstr "`cargo test`를 사용하여 테스트를 다시 실행합니다. 출력은 목록 11-4와 같아야 하며, `exploration` 테스트는 통과하고 `another` 테스트는 실패했음을 보여줍니다."

#: src/ch11-01-writing-tests.md:226
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::another ... FAILED\n"
"test tests::exploration ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::another stdout ----\n"
"thread 'tests::another' panicked at src/lib.rs:17:9:\n"
"Make this test fail\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::another\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:259
msgid ""
"Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new "
"sections appear between the individual results and the summary: the first "
"displays the detailed reason for each test failure. In this case, we get the "
"details that `another` failed because it `panicked at 'Make this test fail'` "
"on line 17 in the _src/lib.rs_ file. The next section lists just the names "
"of all the failing tests, which is useful when there are lots of tests and "
"lots of detailed failing test output. We can use the name of a failing test "
"to run just that test to more easily debug it; we’ll talk more about ways to "
"run tests in the [“Controlling How Tests Are Run”](ch11-02-running-"
"tests.html#controlling-how-tests-are-run)<!-- ignore\n"
"--> section."
msgstr "`ok` 대신 `test tests::another` 줄은 `FAILED`를 보여줍니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션은 각 테스트 실패에 대한 자세한 이유를 표시합니다. 이 경우 `another`가 _src/lib.rs_ 파일의 17번째 줄에서 `panicked at 'Make this test fail'`로 인해 실패했다는 세부 정보를 얻습니다. 다음 섹션은 실패한 모든 테스트의 이름만 나열하며, 이는 많은 테스트와 많은 자세한 실패 테스트 출력이 있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 해당 테스트만 실행하여 더 쉽게 디버깅할 수 있습니다. [“테스트 실행 방법 제어하기”](ch11-02-running-tests.html#controlling-how-tests-are-run)<!-- ignore --> 섹션에서 테스트 실행 방법에 대해 더 자세히 이야기할 것입니다."

#: src/ch11-01-writing-tests.md:270
msgid ""
"The summary line displays at the end: overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr "요약 줄은 마지막에 표시됩니다. 전체적으로 테스트 결과는 `FAILED`입니다. 하나의 테스트가 통과했고 하나의 테스트가 실패했습니다."

#: src/ch11-01-writing-tests.md:273
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some macros other than `panic!` that are useful in tests."
msgstr "이제 다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으니, 테스트에 유용한 `panic!` 외의 다른 매크로들을 살펴보겠습니다."

#: src/ch11-01-writing-tests.md:276
msgid "Checking Results with the `assert!` Macro"
msgstr "`assert!` 매크로로 결과 확인하기"

#: src/ch11-01-writing-tests.md:278
msgid ""
"The `assert!` macro, provided by the standard library, is useful when you "
"want to ensure that some condition in a test evaluates to `true`. We give "
"the `assert!` macro an argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic!` to cause the test to fail. Using the `assert!"
"` macro helps us check that our code is functioning in the way we intend."
msgstr ""

#: src/ch11-01-writing-tests.md:285
msgid ""
"In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold` "
"method, which are repeated here in Listing 11-5. Let’s put this code in the "
"_src/lib.rs_ file, then write some tests for it using the `assert!` macro."
msgstr "5장 목록 5-15에서 `Rectangle` 구조체와 `can_hold` 메서드를 사용했는데, 이는 목록 11-5에 다시 반복됩니다. 이 코드를 _src/lib.rs_ 파일에 넣고, `assert!` 매크로를 사용하여 몇 가지 테스트를 작성해 봅시다."

#: src/ch11-01-writing-tests.md:307
msgid ""
"The `can_hold` method returns a Boolean, which means it’s a perfect use case "
"for the `assert!` macro. In Listing 11-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of 8 "
"and a height of 7 and asserting that it can hold another `Rectangle` "
"instance that has a width of 5 and a height of 1."
msgstr "`can_hold` 메서드는 불리언을 반환하므로, `assert!` 매크로에 완벽한 사용 사례입니다. 목록 11-6에서는 너비 8, 높이 7인 `Rectangle` 인스턴스를 생성하고, 너비 5, 높이 1인 다른 `Rectangle` 인스턴스를 담을 수 있음을 단언하여 `can_hold` 메서드를 테스트하는 코드를 작성합니다."

#: src/ch11-01-writing-tests.md:350
msgid ""
"Note the `use super::*;` line inside the `tests` module. The `tests` module "
"is a regular module that follows the usual visibility rules we covered in "
"Chapter 7 in the [“Paths for Referring to an Item in the Module Tree”] "
"(ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore "
"--> section. Because the `tests` module is an inner module, we need to bring "
"the code under test in the outer module into the scope of the inner module. "
"We use a glob here, so anything we define in the outer module is available "
"to this `tests` module."
msgstr "`tests` 모듈 내부의 `use super::*;` 줄에 주목하세요. `tests` 모듈은 7장의 [“모듈 트리에서 항목을 참조하는 경로”](ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore --> 섹션에서 다룬 일반적인 가시성 규칙을 따르는 일반 모듈입니다. `tests` 모듈은 내부 모듈이므로, 외부 모듈의 테스트 대상 코드를 내부 모듈의 스코프로 가져와야 합니다. 여기서는 글로브를 사용하므로, 외부 모듈에 정의된 모든 것이 이 `tests` 모듈에서 사용 가능합니다."

#: src/ch11-01-writing-tests.md:359
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(&smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr "우리는 테스트 이름을 `larger_can_hold_smaller`로 지정했고, 필요한 두 `Rectangle` 인스턴스를 생성했습니다. 그런 다음 `assert!` 매크로를 호출하고 `larger.can_hold(&smaller)` 호출 결과를 전달했습니다. 이 표현식은 `true`를 반환해야 하므로 테스트는 통과해야 합니다. 확인해 봅시다!"

#: src/ch11-01-writing-tests.md:364
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 1 test\n"
"test tests::larger_can_hold_smaller ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:383
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr "통과했습니다! 이제 다른 테스트를 추가해 봅시다. 이번에는 더 작은 사각형이 더 큰 사각형을 담을 수 없음을 단언하는 테스트입니다:"

#: src/ch11-01-writing-tests.md:436
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr "이 경우 `can_hold` 함수의 올바른 결과는 `false`이므로, `assert!` 매크로에 전달하기 전에 그 결과를 부정해야 합니다. 결과적으로 `can_hold`가 `false`를 반환하면 테스트는 통과할 것입니다:"

#: src/ch11-01-writing-tests.md:440
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... ok\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:460
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign with a less-than sign "
"when it compares the widths:"
msgstr "두 개의 테스트가 통과했습니다! 이제 코드에 버그를 도입했을 때 테스트 결과가 어떻게 되는지 살펴봅시다. 너비를 비교할 때 `can_hold` 메서드의 구현에서 크다 기호를 작다 기호로 변경할 것입니다:"

#: src/ch11-01-writing-tests.md:513
msgid "Running the tests now produces the following:"
msgstr "이제 테스트를 실행하면 다음과 같은 결과가 나옵니다:"

#: src/ch11-01-writing-tests.md:515
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... FAILED\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::larger_can_hold_smaller stdout ----\n"
"thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\n"
"assertion failed: larger.can_hold(&smaller)\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::larger_can_hold_smaller\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:541
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: 8 is "
"not less than 5."
msgstr ""

#: src/ch11-01-writing-tests.md:545
msgid "Testing Equality with the `assert_eq!` and `assert_ne!` Macros"
msgstr ""

#: src/ch11-01-writing-tests.md:547
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this by using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to "
"perform this test more conveniently. These macros compare two arguments for "
"equality or inequality, respectively. They’ll also print the two values if "
"the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr ""

#: src/ch11-01-writing-tests.md:558
msgid ""
"In Listing 11-7, we write a function named `add_two` that adds `2` to its "
"parameter, then we test this function using the `assert_eq!` macro."
msgstr ""

#: src/ch11-01-writing-tests.md:582
msgid "Let’s check that it passes!"
msgstr ""

#: src/ch11-01-writing-tests.md:584
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:603
msgid ""
"We create a variable named `result` that holds the result of calling "
"`add_two(2)`. Then we pass `result` and `4` as the arguments to `assert_eq!"
"`. The output line for this test is `test tests::it_adds_two ... ok`, and "
"the `ok` text indicates that our test passed!"
msgstr ""

#: src/ch11-01-writing-tests.md:608
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""

#: src/ch11-01-writing-tests.md:628
msgid "Run the tests again:"
msgstr ""

#: src/ch11-01-writing-tests.md:630
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::it_adds_two stdout ----\n"
"thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:\n"
"assertion `left == right` failed\n"
"  left: 5\n"
" right: 4\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::it_adds_two\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:657
msgid ""
"Our test caught the bug! The `it_adds_two` test failed, and the message "
"tells us that the assertion that failed was ``assertion `left == right` "
"failed`` and what the `left` and `right` values are. This message helps us "
"start debugging: the `left` argument, where we had the result of calling "
"`add_two(2)`, was `5` but the `right` argument was `4`. You can imagine that "
"this would be especially helpful when we have a lot of tests going on."
msgstr ""

#: src/ch11-01-writing-tests.md:664
msgid ""
"Note that in some languages and test frameworks, the parameters to equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Rust, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(4, result)`, which would result in the same "
"failure message that that displays `` assertion failed: `(left == right)` ``."
msgstr ""

#: src/ch11-01-writing-tests.md:672
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and fail if they’re equal. This macro is most useful for cases when we’re "
"not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but the way in which the input is changed "
"depends on the day of the week that we run our tests, the best thing to "
"assert might be that the output of the function is not equal to the input."
msgstr ""

#: src/ch11-01-writing-tests.md:680
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators `==` and `!=`, respectively. When the assertions fail, these "
"macros print their arguments using debug formatting, which means the values "
"being compared must implement the `PartialEq` and `Debug` traits. All "
"primitive types and most of the standard library types implement these "
"traits. For structs and enums that you define yourself, you’ll need to "
"implement `PartialEq` to assert equality of those types. You’ll also need to "
"implement `Debug` to print the values when the assertion fails. Because both "
"traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this "
"is usually as straightforward as adding the `#[derive(PartialEq, Debug)]` "
"annotation to your struct or enum definition. See Appendix C, [“Derivable "
"Traits,”](appendix-03-derivable-traits.html)<!-- ignore --> for more details "
"about these and other derivable traits."
msgstr ""

#: src/ch11-01-writing-tests.md:693
msgid "Adding Custom Failure Messages"
msgstr ""

#: src/ch11-01-writing-tests.md:695
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in [“Concatenation with the `+` Operator or the "
"`format!` Macro”](ch08-02-strings.html#concatenation-with-the--operator-or-"
"the-format-macro)<!--\n"
"ignore --> in Chapter 8), so you can pass a format string that contains `{}` "
"placeholders and values to go in those placeholders. Custom messages are "
"useful for documenting what an assertion means; when a test fails, you’ll "
"have a better idea of what the problem is with the code."
msgstr ""

#: src/ch11-01-writing-tests.md:705
msgid ""
"For example, let’s say we have a function that greets people by name and we "
"want to test that the name we pass into the function appears in the output:"
msgstr ""

#: src/ch11-01-writing-tests.md:712
msgid "\"Hello {name}!\""
msgstr ""

#: src/ch11-01-writing-tests.md:721 src/ch11-01-writing-tests.md:722
#: src/ch11-01-writing-tests.md:748 src/ch11-01-writing-tests.md:749
#: src/ch11-01-writing-tests.md:798 src/ch11-01-writing-tests.md:800
msgid "\"Carol\""
msgstr ""

#: src/ch11-01-writing-tests.md:727
msgid ""
"The requirements for this program haven’t been agreed upon yet, and we’re "
"pretty sure the `Hello` text at the beginning of the greeting will change. "
"We decided we don’t want to have to update the test when the requirements "
"change, so instead of checking for exact equality to the value returned from "
"the `greeting` function, we’ll just assert that the output contains the text "
"of the input parameter."
msgstr ""

#: src/ch11-01-writing-tests.md:734
msgid ""
"Now let’s introduce a bug into this code by changing `greeting` to exclude "
"`name` to see what the default test failure looks like:"
msgstr ""

#: src/ch11-01-writing-tests.md:739 src/ch11-01-writing-tests.md:789
#: src/ch17-03-more-futures.md:607 src/ch19-03-pattern-syntax.md:533
#: src/ch19-03-pattern-syntax.md:554
msgid "\"Hello!\""
msgstr ""

#: src/ch11-01-writing-tests.md:754
msgid "Running this test produces the following:"
msgstr ""

#: src/ch11-01-writing-tests.md:756
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\n"
"assertion failed: result.contains(\"Carol\")\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:781
msgid ""
"This result just indicates that the assertion failed and which line the "
"assertion is on. A more useful failure message would print the value from "
"the `greeting` function. Let’s add a custom failure message composed of a "
"format string with a placeholder filled in with the actual value we got from "
"the `greeting` function:"
msgstr ""

#: src/ch11-01-writing-tests.md:801
msgid "\"Greeting did not contain name, value was `{result}`\""
msgstr ""

#: src/ch11-01-writing-tests.md:807
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""

#: src/ch11-01-writing-tests.md:809
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\n"
"Greeting did not contain name, value was `Hello!`\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:834
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr ""

#: src/ch11-01-writing-tests.md:837
msgid "Checking for Panics with `should_panic`"
msgstr ""

#: src/ch11-01-writing-tests.md:839
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the `Guess` "
"type that we created in Chapter 9, Listing 9-13. Other code that uses "
"`Guess` depends on the guarantee that `Guess` instances will contain only "
"values between 1 and 100. We can write a test that ensures that attempting "
"to create a `Guess` instance with a value outside that range panics."
msgstr ""

#: src/ch11-01-writing-tests.md:846
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch11-01-writing-tests.md:850
msgid ""
"Listing 11-8 shows a test that checks that the error conditions of "
"`Guess::new` happen when we expect them to."
msgstr ""

#: src/ch11-01-writing-tests.md:884
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""

#: src/ch11-01-writing-tests.md:888
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests guessing_game\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:907
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than 100:"
msgstr ""

#: src/ch11-01-writing-tests.md:938
msgid "When we run the test in Listing 11-8, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:940
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"note: test did not panic as expected\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:962
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch11-01-writing-tests.md:966
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"`expected` parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 11-9 where the `new` "
"function panics with different messages depending on whether the value is "
"too small or too large."
msgstr ""

#: src/ch11-01-writing-tests.md:988 src/ch11-01-writing-tests.md:1040
msgid "\"Guess value must be greater than or equal to 1, got {value}.\""
msgstr ""

#: src/ch11-01-writing-tests.md:992 src/ch11-01-writing-tests.md:1036
msgid "\"Guess value must be less than or equal to 100, got {value}.\""
msgstr ""

#: src/ch11-01-writing-tests.md:1005 src/ch11-01-writing-tests.md:1053
msgid "\"less than or equal to 100\""
msgstr ""

#: src/ch11-01-writing-tests.md:1014
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is a substring of the message that the "
"`Guess::new` function panics with. We could have specified the entire panic "
"message that we expect, which in this case would be `Guess value must be "
"less than or equal to 100, got 200`. What you choose to specify depends on "
"how much of the panic message is unique or dynamic and how precise you want "
"your test to be. In this case, a substring of the panic message is enough to "
"ensure that the code in the test function executes the `else if value > 100` "
"case."
msgstr ""

#: src/ch11-01-writing-tests.md:1023
msgid ""
"To see what happens when a `should_panic` test with an `expected` message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""

#: src/ch11-01-writing-tests.md:1060
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:1062
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\n"
"Guess value must be greater than or equal to 1, got 200.\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"note: panic did not contain expected string\n"
"      panic message: `\"Guess value must be greater than or equal to 1, got "
"200.\"`,\n"
" expected substring: `\"less than or equal to 100\"`\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:1089
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string `less "
"than or equal to 100`. The panic message that we did get in this case was "
"`Guess value must be greater than or equal to 1, got 200.` Now we can start "
"figuring out where our bug is!"
msgstr ""

#: src/ch11-01-writing-tests.md:1095
msgid "Using `Result<T, E>` in Tests"
msgstr ""

#: src/ch11-01-writing-tests.md:1097
msgid ""
"Our tests so far all panic when they fail. We can also write tests that use "
"`Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use "
"`Result<T, E>` and return an `Err` instead of panicking:"
msgstr ""

#: src/ch11-01-writing-tests.md:1117
msgid "\"two plus two does not equal four\""
msgstr ""

#: src/ch11-01-writing-tests.md:1123
msgid ""
"The `it_works` function now has the `Result<(), String>` return type. In the "
"body of the function, rather than calling the `assert_eq!` macro, we return "
"`Ok(())` when the test passes and an `Err` with a `String` inside when the "
"test fails."
msgstr ""

#: src/ch11-01-writing-tests.md:1128
msgid ""
"Writing tests so they return a `Result<T, E>` enables you to use the "
"question mark operator in the body of tests, which can be a convenient way "
"to write tests that should fail if any operation within them returns an "
"`Err` variant."
msgstr ""

#: src/ch11-01-writing-tests.md:1132
msgid ""
"You can’t use the `#[should_panic]` annotation on tests that use `Result<T, "
"E>`. To assert that an operation returns an `Err` variant, _don’t_ use the "
"question mark operator on the `Result<T, E>` value. Instead, use `assert!"
"(value.is_err())`."
msgstr ""

#: src/ch11-01-writing-tests.md:1137
msgid ""
"Now that you know several ways to write tests, let’s look at what is "
"happening when we run our tests and explore the different options we can use "
"with `cargo test`."
msgstr ""

#: src/ch11-02-running-tests.md:3
msgid ""
"Just as `cargo run` compiles your code and then runs the resultant binary, "
"`cargo test` compiles your code in test mode and runs the resultant test "
"binary. The default behavior of the binary produced by `cargo test` is to "
"run all the tests in parallel and capture output generated during test runs, "
"preventing the output from being displayed and making it easier to read the "
"output related to the test results. You can, however, specify command line "
"options to change this default behavior."
msgstr ""

#: src/ch11-02-running-tests.md:11
msgid ""
"Some command line options go to `cargo test`, and some go to the resultant "
"test binary. To separate these two types of arguments, you list the "
"arguments that go to `cargo test` followed by the separator `--` and then "
"the ones that go to the test binary. Running `cargo test --help` displays "
"the options you can use with `cargo test`, and running `cargo test -- --"
"help` displays the options you can use after the separator. Those options "
"are also documented in [the “Tests” section](https://doc.rust-lang.org/rustc/"
"tests/index.html) of the [the rustc book](https://doc.rust-lang.org/rustc/"
"index.html)."
msgstr ""

#: src/ch11-02-running-tests.md:22
msgid "Running Tests in Parallel or Consecutively"
msgstr ""

#: src/ch11-02-running-tests.md:24
msgid ""
"When you run multiple tests, by default they run in parallel using threads, "
"meaning they finish running faster and you get feedback quicker. Because the "
"tests are running at the same time, you must make sure your tests don’t "
"depend on each other or on any shared state, including a shared environment, "
"such as the current working directory or environment variables."
msgstr ""

#: src/ch11-02-running-tests.md:30
msgid ""
"For example, say each of your tests runs some code that creates a file on "
"disk named _test-output.txt_ and writes some data to that file. Then each "
"test reads the data in that file and asserts that the file contains a "
"particular value, which is different in each test. Because the tests run at "
"the same time, one test might overwrite the file in the time between another "
"test writing and reading the file. The second test will then fail, not "
"because the code is incorrect but because the tests have interfered with "
"each other while running in parallel. One solution is to make sure each test "
"writes to a different file; another solution is to run the tests one at a "
"time."
msgstr ""

#: src/ch11-02-running-tests.md:40
msgid ""
"If you don’t want to run the tests in parallel or if you want more fine-"
"grained control over the number of threads used, you can send the `--test-"
"threads` flag and the number of threads you want to use to the test binary. "
"Take a look at the following example:"
msgstr ""

#: src/ch11-02-running-tests.md:49
msgid ""
"We set the number of test threads to `1`, telling the program not to use any "
"parallelism. Running the tests using one thread will take longer than "
"running them in parallel, but the tests won’t interfere with each other if "
"they share state."
msgstr ""

#: src/ch11-02-running-tests.md:54
msgid "Showing Function Output"
msgstr ""

#: src/ch11-02-running-tests.md:56
msgid ""
"By default, if a test passes, Rust’s test library captures anything printed "
"to standard output. For example, if we call `println!` in a test and the "
"test passes, we won’t see the `println!` output in the terminal; we’ll see "
"only the line that indicates the test passed. If a test fails, we’ll see "
"whatever was printed to standard output with the rest of the failure message."
msgstr ""

#: src/ch11-02-running-tests.md:62
msgid ""
"As an example, Listing 11-10 has a silly function that prints the value of "
"its parameter and returns 10, as well as a test that passes and a test that "
"fails."
msgstr ""

#: src/ch11-02-running-tests.md:69
msgid "\"I got the value {a}\""
msgstr ""

#: src/ch11-02-running-tests.md:93
msgid ""
"When we run these tests with `cargo test`, we’ll see the following output:"
msgstr ""

#: src/ch11-02-running-tests.md:95
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"silly_function-160869f38cff9166)\n"
"\n"
"running 2 tests\n"
"test tests::this_test_will_fail ... FAILED\n"
"test tests::this_test_will_pass ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::this_test_will_fail stdout ----\n"
"I got the value 8\n"
"thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\n"
"assertion `left == right` failed\n"
"  left: 10\n"
" right: 5\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::this_test_will_fail\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:124
msgid ""
"Note that nowhere in this output do we see `I got the value 4`, which is "
"printed when the test that passes runs. That output has been captured. The "
"output from the test that failed, `I got the value 8`, appears in the "
"section of the test summary output, which also shows the cause of the test "
"failure."
msgstr ""

#: src/ch11-02-running-tests.md:129
msgid ""
"If we want to see printed values for passing tests as well, we can tell Rust "
"to also show the output of successful tests with `--show-output`:"
msgstr ""

#: src/ch11-02-running-tests.md:136
msgid ""
"When we run the tests in Listing 11-10 again with the `--show-output` flag, "
"we see the following output:"
msgstr ""

#: src/ch11-02-running-tests.md:139
msgid ""
"```console\n"
"$ cargo test -- --show-output\n"
"   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"silly_function-160869f38cff9166)\n"
"\n"
"running 2 tests\n"
"test tests::this_test_will_fail ... FAILED\n"
"test tests::this_test_will_pass ... ok\n"
"\n"
"successes:\n"
"\n"
"---- tests::this_test_will_pass stdout ----\n"
"I got the value 4\n"
"\n"
"\n"
"successes:\n"
"    tests::this_test_will_pass\n"
"\n"
"failures:\n"
"\n"
"---- tests::this_test_will_fail stdout ----\n"
"I got the value 8\n"
"thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\n"
"assertion `left == right` failed\n"
"  left: 10\n"
" right: 5\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::this_test_will_fail\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:177
msgid "Running a Subset of Tests by Name"
msgstr ""

#: src/ch11-02-running-tests.md:179
msgid ""
"Sometimes, running a full test suite can take a long time. If you’re working "
"on code in a particular area, you might want to run only the tests "
"pertaining to that code. You can choose which tests to run by passing `cargo "
"test` the name or names of the test(s) you want to run as an argument."
msgstr ""

#: src/ch11-02-running-tests.md:184
msgid ""
"To demonstrate how to run a subset of tests, we’ll first create three tests "
"for our `add_two` function, as shown in Listing 11-11, and choose which ones "
"to run."
msgstr ""

#: src/ch11-02-running-tests.md:220
msgid ""
"If we run the tests without passing any arguments, as we saw earlier, all "
"the tests will run in parallel:"
msgstr ""

#: src/ch11-02-running-tests.md:223
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 3 tests\n"
"test tests::add_three_and_two ... ok\n"
"test tests::add_two_and_two ... ok\n"
"test tests::one_hundred ... ok\n"
"\n"
"test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:244
msgid "Running Single Tests"
msgstr ""

#: src/ch11-02-running-tests.md:246
msgid ""
"We can pass the name of any test function to `cargo test` to run only that "
"test:"
msgstr ""

#: src/ch11-02-running-tests.md:248
msgid ""
"```console\n"
"$ cargo test one_hundred\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::one_hundred ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:261
msgid ""
"Only the test with the name `one_hundred` ran; the other two tests didn’t "
"match that name. The test output lets us know we had more tests that didn’t "
"run by displaying `2 filtered out` at the end."
msgstr ""

#: src/ch11-02-running-tests.md:265
msgid ""
"We can’t specify the names of multiple tests in this way; only the first "
"value given to `cargo test` will be used. But there is a way to run multiple "
"tests."
msgstr ""

#: src/ch11-02-running-tests.md:268
msgid "Filtering to Run Multiple Tests"
msgstr ""

#: src/ch11-02-running-tests.md:270
msgid ""
"We can specify part of a test name, and any test whose name matches that "
"value will be run. For example, because two of our tests’ names contain "
"`add`, we can run those two by running `cargo test add`:"
msgstr ""

#: src/ch11-02-running-tests.md:274
msgid ""
"```console\n"
"$ cargo test add\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::add_three_and_two ... ok\n"
"test tests::add_two_and_two ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:288
msgid ""
"This command ran all tests with `add` in the name and filtered out the test "
"named `one_hundred`. Also note that the module in which a test appears "
"becomes part of the test’s name, so we can run all the tests in a module by "
"filtering on the module’s name."
msgstr ""

#: src/ch11-02-running-tests.md:293
msgid "Ignoring Some Tests Unless Specifically Requested"
msgstr ""

#: src/ch11-02-running-tests.md:295
msgid ""
"Sometimes a few specific tests can be very time-consuming to execute, so you "
"might want to exclude them during most runs of `cargo test`. Rather than "
"listing as arguments all tests you do want to run, you can instead annotate "
"the time-consuming tests using the `ignore` attribute to exclude them, as "
"shown here:"
msgstr ""

#: src/ch11-02-running-tests.md:321
msgid "// code that takes an hour to run\n"
msgstr ""

#: src/ch11-02-running-tests.md:326
msgid ""
"After `#[test]`, we add the `#[ignore]` line to the test we want to exclude. "
"Now when we run our tests, `it_works` runs, but `expensive_test` doesn’t:"
msgstr ""

#: src/ch11-02-running-tests.md:329
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::expensive_test ... ignored\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:349
msgid ""
"The `expensive_test` function is listed as `ignored`. If we want to run only "
"the ignored tests, we can use `cargo test -- --ignored`:"
msgstr ""

#: src/ch11-02-running-tests.md:352
msgid ""
"```console\n"
"$ cargo test -- --ignored\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test expensive_test ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-02-running-tests.md:371
msgid ""
"By controlling which tests run, you can make sure your `cargo test` results "
"will be returned quickly. When you’re at a point where it makes sense to "
"check the results of the `ignored` tests and you have time to wait for the "
"results, you can run `cargo test -- --ignored` instead. If you want to run "
"all tests whether they’re ignored or not, you can run `cargo test -- --"
"include-ignored`."
msgstr ""

#: src/ch11-03-test-organization.md:3
msgid ""
"As mentioned at the start of the chapter, testing is a complex discipline, "
"and different people use different terminology and organization. The Rust "
"community thinks about tests in terms of two main categories: unit tests and "
"integration tests. _Unit tests_ are small and more focused, testing one "
"module in isolation at a time, and can test private interfaces. _Integration "
"tests_ are entirely external to your library and use your code in the same "
"way any other external code would, using only the public interface and "
"potentially exercising multiple modules per test."
msgstr ""

#: src/ch11-03-test-organization.md:12
msgid ""
"Writing both kinds of tests is important to ensure that the pieces of your "
"library are doing what you expect them to, separately and together."
msgstr ""

#: src/ch11-03-test-organization.md:15
msgid "Unit Tests"
msgstr ""

#: src/ch11-03-test-organization.md:17
msgid ""
"The purpose of unit tests is to test each unit of code in isolation from the "
"rest of the code to quickly pinpoint where code is and isn’t working as "
"expected. You’ll put unit tests in the _src_ directory in each file with the "
"code that they’re testing. The convention is to create a module named "
"`tests` in each file to contain the test functions and to annotate the "
"module with `cfg(test)`."
msgstr ""

#: src/ch11-03-test-organization.md:24
msgid "The Tests Module and `#[cfg(test)]`"
msgstr ""

#: src/ch11-03-test-organization.md:26
msgid ""
"The `#[cfg(test)]` annotation on the `tests` module tells Rust to compile "
"and run the test code only when you run `cargo test`, not when you run "
"`cargo build`. This saves compile time when you only want to build the "
"library and saves space in the resultant compiled artifact because the tests "
"are not included. You’ll see that because integration tests go in a "
"different directory, they don’t need the `#[cfg(test)]` annotation. However, "
"because unit tests go in the same files as the code, you’ll use "
"`#[cfg(test)]` to specify that they shouldn’t be included in the compiled "
"result."
msgstr ""

#: src/ch11-03-test-organization.md:35
msgid ""
"Recall that when we generated the new `adder` project in the first section "
"of this chapter, Cargo generated this code for us:"
msgstr ""

#: src/ch11-03-test-organization.md:57
msgid ""
"On the automatically generated `tests` module, the attribute `cfg` stands "
"for _configuration_ and tells Rust that the following item should only be "
"included given a certain configuration option. In this case, the "
"configuration option is `test`, which is provided by Rust for compiling and "
"running tests. By using the `cfg` attribute, Cargo compiles our test code "
"only if we actively run the tests with `cargo test`. This includes any "
"helper functions that might be within this module, in addition to the "
"functions annotated with `#[test]`."
msgstr ""

#: src/ch11-03-test-organization.md:65
msgid "Testing Private Functions"
msgstr ""

#: src/ch11-03-test-organization.md:67
msgid ""
"There’s debate within the testing community about whether or not private "
"functions should be tested directly, and other languages make it difficult "
"or impossible to test private functions. Regardless of which testing "
"ideology you adhere to, Rust’s privacy rules do allow you to test private "
"functions. Consider the code in Listing 11-12 with the private function "
"`internal_adder`."
msgstr ""

#: src/ch11-03-test-organization.md:98
msgid ""
"Note that the `internal_adder` function is not marked as `pub`. Tests are "
"just Rust code, and the `tests` module is just another module. As we "
"discussed in [“Paths for Referring to an Item in the Module Tree”](ch07-03-"
"paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore -->, "
"items in child modules can use the items in their ancestor modules. In this "
"test, we bring all of the `tests` module’s parent’s items into scope with "
"`use super::*`, and then the test can call `internal_adder`. If you don’t "
"think private functions should be tested, there’s nothing in Rust that will "
"compel you to do so."
msgstr ""

#: src/ch11-03-test-organization.md:107
msgid "Integration Tests"
msgstr ""

#: src/ch11-03-test-organization.md:109
msgid ""
"In Rust, integration tests are entirely external to your library. They use "
"your library in the same way any other code would, which means they can only "
"call functions that are part of your library’s public API. Their purpose is "
"to test whether many parts of your library work together correctly. Units of "
"code that work correctly on their own could have problems when integrated, "
"so test coverage of the integrated code is important as well. To create "
"integration tests, you first need a _tests_ directory."
msgstr ""

#: src/ch11-03-test-organization.md:117
msgid "The _tests_ Directory"
msgstr ""

#: src/ch11-03-test-organization.md:119
msgid ""
"We create a _tests_ directory at the top level of our project directory, "
"next to _src_. Cargo knows to look for integration test files in this "
"directory. We can then make as many test files as we want, and Cargo will "
"compile each of the files as an individual crate."
msgstr ""

#: src/ch11-03-test-organization.md:124
msgid ""
"Let’s create an integration test. With the code in Listing 11-12 still in "
"the _src/lib.rs_ file, make a _tests_ directory, and create a new file named "
"_tests/integration_test.rs_. Your directory structure should look like this:"
msgstr ""

#: src/ch11-03-test-organization.md:138
msgid ""
"Enter the code in Listing 11-13 into the _tests/integration_test.rs_ file."
msgstr ""

#: src/ch11-03-test-organization.md:154
msgid ""
"Each file in the _tests_ directory is a separate crate, so we need to bring "
"our library into each test crate’s scope. For that reason we add `use "
"adder::add_two;` at the top of the code, which we didn’t need in the unit "
"tests."
msgstr ""

#: src/ch11-03-test-organization.md:158
msgid ""
"We don’t need to annotate any code in _tests/integration_test.rs_ with "
"`#[cfg(test)]`. Cargo treats the _tests_ directory specially and compiles "
"files in this directory only when we run `cargo test`. Run `cargo test` now:"
msgstr ""

#: src/ch11-03-test-organization.md:162
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-1082c4b063a8fbe6)\n"
"\n"
"running 1 test\n"
"test tests::internal ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-1082c4b063a8fbe6)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:188
msgid ""
"The three sections of output include the unit tests, the integration test, "
"and the doc tests. Note that if any test in a section fails, the following "
"sections will not be run. For example, if a unit test fails, there won’t be "
"any output for integration and doc tests because those tests will only be "
"run if all unit tests are passing."
msgstr ""

#: src/ch11-03-test-organization.md:194
msgid ""
"The first section for the unit tests is the same as we’ve been seeing: one "
"line for each unit test (one named `internal` that we added in Listing "
"11-12) and then a summary line for the unit tests."
msgstr ""

#: src/ch11-03-test-organization.md:198
msgid ""
"The integration tests section starts with the line `Running tests/"
"integration_test.rs`. Next, there is a line for each test function in that "
"integration test and a summary line for the results of the integration test "
"just before the `Doc-tests adder` section starts."
msgstr ""

#: src/ch11-03-test-organization.md:203
msgid ""
"Each integration test file has its own section, so if we add more files in "
"the _tests_ directory, there will be more integration test sections."
msgstr ""

#: src/ch11-03-test-organization.md:206
msgid ""
"We can still run a particular integration test function by specifying the "
"test function’s name as an argument to `cargo test`. To run all the tests in "
"a particular integration test file, use the `--test` argument of `cargo "
"test` followed by the name of the file:"
msgstr ""

#: src/ch11-03-test-organization.md:211
msgid ""
"```console\n"
"$ cargo test --test integration_test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-82e7799c1bc62298)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:224
msgid ""
"This command runs only the tests in the _tests/integration_test.rs_ file."
msgstr ""

#: src/ch11-03-test-organization.md:226
msgid "Submodules in Integration Tests"
msgstr ""

#: src/ch11-03-test-organization.md:228
msgid ""
"As you add more integration tests, you might want to make more files in the "
"_tests_ directory to help organize them; for example, you can group the test "
"functions by the functionality they’re testing. As mentioned earlier, each "
"file in the _tests_ directory is compiled as its own separate crate, which "
"is useful for creating separate scopes to more closely imitate the way end "
"users will be using your crate. However, this means files in the _tests_ "
"directory don’t share the same behavior as files in _src_ do, as you learned "
"in Chapter 7 regarding how to separate code into modules and files."
msgstr ""

#: src/ch11-03-test-organization.md:237
msgid ""
"The different behavior of _tests_ directory files is most noticeable when "
"you have a set of helper functions to use in multiple integration test files "
"and you try to follow the steps in the [“Separating Modules into Different "
"Files”](ch07-05-separating-modules-into-different-files.html)<!-- ignore --> "
"section of Chapter 7 to extract them into a common module. For example, if "
"we create _tests/common.rs_ and place a function named `setup` in it, we can "
"add some code to `setup` that we want to call from multiple test functions "
"in multiple test files:"
msgstr ""

#: src/ch11-03-test-organization.md:245
msgid "<span class=\"filename\">Filename: tests/common.rs</span>"
msgstr ""

#: src/ch11-03-test-organization.md:249
msgid "// setup code specific to your library's tests would go here\n"
msgstr ""

#: src/ch11-03-test-organization.md:253
msgid ""
"When we run the tests again, we’ll see a new section in the test output for "
"the _common.rs_ file, even though this file doesn’t contain any test "
"functions nor did we call the `setup` function from anywhere:"
msgstr ""

#: src/ch11-03-test-organization.md:257
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::internal ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running tests/integration_test.rs (target/debug/deps/"
"integration_test-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-03-test-organization.md:289
msgid ""
"Having `common` appear in the test results with `running 0 tests` displayed "
"for it is not what we wanted. We just wanted to share some code with the "
"other integration test files. To avoid having `common` appear in the test "
"output, instead of creating _tests/common.rs_, we’ll create _tests/common/"
"mod.rs_. The project directory now looks like this:"
msgstr ""

#: src/ch11-03-test-organization.md:306
msgid ""
"This is the older naming convention that Rust also understands that we "
"mentioned in [“Alternate File Paths”](ch07-05-separating-modules-into-"
"different-files.html#alternate-file-paths)<!-- ignore --> in Chapter 7. "
"Naming the file this way tells Rust not to treat the `common` module as an "
"integration test file. When we move the `setup` function code into _tests/"
"common/mod.rs_ and delete the _tests/common.rs_ file, the section in the "
"test output will no longer appear. Files in subdirectories of the _tests_ "
"directory don’t get compiled as separate crates or have sections in the test "
"output."
msgstr ""

#: src/ch11-03-test-organization.md:314
msgid ""
"After we’ve created _tests/common/mod.rs_, we can use it from any of the "
"integration test files as a module. Here’s an example of calling the `setup` "
"function from the `it_adds_two` test in _tests/integration_test.rs_:"
msgstr ""

#: src/ch11-03-test-organization.md:318
msgid "<span class=\"filename\">Filename: tests/integration_test.rs</span>"
msgstr ""

#: src/ch11-03-test-organization.md:334
msgid ""
"Note that the `mod common;` declaration is the same as the module "
"declaration we demonstrated in Listing 7-21. Then, in the test function, we "
"can call the `common::setup()` function."
msgstr ""

#: src/ch11-03-test-organization.md:338
msgid "Integration Tests for Binary Crates"
msgstr ""

#: src/ch11-03-test-organization.md:340
msgid ""
"If our project is a binary crate that only contains a _src/main.rs_ file and "
"doesn’t have a _src/lib.rs_ file, we can’t create integration tests in the "
"_tests_ directory and bring functions defined in the _src/main.rs_ file into "
"scope with a `use` statement. Only library crates expose functions that "
"other crates can use; binary crates are meant to be run on their own."
msgstr ""

#: src/ch11-03-test-organization.md:346
msgid ""
"This is one of the reasons Rust projects that provide a binary have a "
"straightforward _src/main.rs_ file that calls logic that lives in the _src/"
"lib.rs_ file. Using that structure, integration tests _can_ test the library "
"crate with `use` to make the important functionality available. If the "
"important functionality works, the small amount of code in the _src/main.rs_ "
"file will work as well, and that small amount of code doesn’t need to be "
"tested."
msgstr ""

#: src/ch11-03-test-organization.md:355
msgid ""
"Rust’s testing features provide a way to specify how code should function to "
"ensure it continues to work as you expect, even as you make changes. Unit "
"tests exercise different parts of a library separately and can test private "
"implementation details. Integration tests check that many parts of the "
"library work together correctly, and they use the library’s public API to "
"test the code in the same way external code will use it. Even though Rust’s "
"type system and ownership rules help prevent some kinds of bugs, tests are "
"still important to reduce logic bugs having to do with how your code is "
"expected to behave."
msgstr ""

#: src/ch11-03-test-organization.md:364
msgid ""
"Let’s combine the knowledge you learned in this chapter and in previous "
"chapters to work on a project!"
msgstr ""

#: src/ch12-00-an-io-project.md:3
msgid ""
"This chapter is a recap of the many skills you’ve learned so far and an "
"exploration of a few more standard library features. We’ll build a command "
"line tool that interacts with file and command line input/output to practice "
"some of the Rust concepts you now have under your belt."
msgstr ""

#: src/ch12-00-an-io-project.md:8
msgid ""
"Rust’s speed, safety, single binary output, and cross-platform support make "
"it an ideal language for creating command line tools, so for our project, "
"we’ll make our own version of the classic command line search tool `grep` "
"(**g**lobally search a **r**egular **e**xpression and **p**rint). In the "
"simplest use case, `grep` searches a specified file for a specified string. "
"To do so, `grep` takes as its arguments a file path and a string. Then it "
"reads the file, finds lines in that file that contain the string argument, "
"and prints those lines."
msgstr ""

#: src/ch12-00-an-io-project.md:17
msgid ""
"Along the way, we’ll show how to make our command line tool use the terminal "
"features that many other command line tools use. We’ll read the value of an "
"environment variable to allow the user to configure the behavior of our "
"tool. We’ll also print error messages to the standard error console stream "
"(`stderr`) instead of standard output (`stdout`) so that, for example, the "
"user can redirect successful output to a file while still seeing error "
"messages onscreen."
msgstr ""

#: src/ch12-00-an-io-project.md:24
msgid ""
"One Rust community member, Andrew Gallant, has already created a fully "
"featured, very fast version of `grep`, called `ripgrep`. By comparison, our "
"version will be fairly simple, but this chapter will give you some of the "
"background knowledge you need to understand a real-world project such as "
"`ripgrep`."
msgstr ""

#: src/ch12-00-an-io-project.md:30
msgid ""
"Our `grep` project will combine a number of concepts you’ve learned so far:"
msgstr ""

#: src/ch12-00-an-io-project.md:32
msgid ""
"Organizing code ([Chapter 7](ch07-00-managing-growing-projects-with-packages-"
"crates-and-modules.html)<!-- ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:33
msgid ""
"Using vectors and strings ([Chapter 8](ch08-00-common-collections.html)<!-- "
"ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:34
msgid ""
"Handling errors ([Chapter 9](ch09-00-error-handling.html)<!-- ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:35
msgid ""
"Using traits and lifetimes where appropriate ([Chapter 10](ch10-00-"
"generics.html)<!-- ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:36
msgid "Writing tests ([Chapter 11](ch11-00-testing.html)<!-- ignore -->)"
msgstr ""

#: src/ch12-00-an-io-project.md:38
msgid ""
"We’ll also briefly introduce closures, iterators, and trait objects, which "
"[Chapter 13](ch13-00-functional-features.html)<!-- ignore --> and [Chapter "
"18](ch18-00-oop.html)<!-- ignore --> will cover in detail."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:3
msgid ""
"Let’s create a new project with, as always, `cargo new`. We’ll call our "
"project `minigrep` to distinguish it from the `grep` tool that you might "
"already have on your system."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:13
msgid ""
"The first task is to make `minigrep` accept its two command line arguments: "
"the file path and a string to search for. That is, we want to be able to run "
"our program with `cargo run`, two hyphens to indicate the following "
"arguments are for our program rather than for `cargo`, a string to search "
"for, and a path to a file to search in, like so:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:23
msgid ""
"Right now, the program generated by `cargo new` cannot process arguments we "
"give it. Some existing libraries on [crates.io](https://crates.io/) can help "
"with writing a program that accepts command line arguments, but because "
"you’re just learning this concept, let’s implement this capability ourselves."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:28
msgid "Reading the Argument Values"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:30
msgid ""
"To enable `minigrep` to read the values of command line arguments we pass to "
"it, we’ll need the `std::env::args` function provided in Rust’s standard "
"library. This function returns an iterator of the command line arguments "
"passed to `minigrep`. We’ll cover iterators fully in [Chapter 13](ch13-00-"
"functional-features.html)<!-- ignore\n"
"-->. For now, you only need to know two details about iterators: iterators "
"produce a series of values, and we can call the `collect` method on an "
"iterator to turn it into a collection, such as a vector, that contains all "
"the elements the iterator produces."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:39
msgid ""
"The code in Listing 12-1 allows your `minigrep` program to read any command "
"line arguments passed to it, and then collect the values into a vector."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:55
msgid ""
"First we bring the `std::env` module into scope with a `use` statement so we "
"can use its `args` function. Notice that the `std::env::args` function is "
"nested in two levels of modules. As we discussed in [Chapter 7](ch07-04-"
"bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-"
"paths)<!-- ignore -->, in cases where the desired function is nested in more "
"than one module, we’ve chosen to bring the parent module into scope rather "
"than the function. By doing so, we can easily use other functions from "
"`std::env`. It’s also less ambiguous than adding `use std::env::args` and "
"then calling the function with just `args`, because `args` might easily be "
"mistaken for a function that’s defined in the current module."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:65
msgid "The `args` Function and Invalid Unicode"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:67
msgid ""
"Note that `std::env::args` will panic if any argument contains invalid "
"Unicode. If your program needs to accept arguments containing invalid "
"Unicode, use `std::env::args_os` instead. That function returns an iterator "
"that produces `OsString` values instead of `String` values. We’ve chosen to "
"use `std::env::args` here for simplicity because `OsString` values differ "
"per platform and are more complex to work with than `String` values."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:74
msgid ""
"On the first line of `main`, we call `env::args`, and we immediately use "
"`collect` to turn the iterator into a vector containing all the values "
"produced by the iterator. We can use the `collect` function to create many "
"kinds of collections, so we explicitly annotate the type of `args` to "
"specify that we want a vector of strings. Although you very rarely need to "
"annotate types in Rust, `collect` is one function you do often need to "
"annotate because Rust isn’t able to infer the kind of collection you want."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:82
msgid ""
"Finally, we print the vector using the debug macro. Let’s try running the "
"code first with no arguments and then with two arguments:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:85
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running `target/debug/minigrep`\n"
"[src/main.rs:5:5] args = [\n"
"    \"target/debug/minigrep\",\n"
"]\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:95
msgid ""
"```console\n"
"$ cargo run -- needle haystack\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s\n"
"     Running `target/debug/minigrep needle haystack`\n"
"[src/main.rs:5:5] args = [\n"
"    \"target/debug/minigrep\",\n"
"    \"needle\",\n"
"    \"haystack\",\n"
"]\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:107
msgid ""
"Notice that the first value in the vector is `\"target/debug/minigrep\"`, "
"which is the name of our binary. This matches the behavior of the arguments "
"list in C, letting programs use the name by which they were invoked in their "
"execution. It’s often convenient to have access to the program name in case "
"you want to print it in messages or change the behavior of the program based "
"on what command line alias was used to invoke the program. But for the "
"purposes of this chapter, we’ll ignore it and save only the two arguments we "
"need."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:115
msgid "Saving the Argument Values in Variables"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:117
msgid ""
"The program is currently able to access the values specified as command line "
"arguments. Now we need to save the values of the two arguments in variables "
"so we can use the values throughout the rest of the program. We do that in "
"Listing 12-2."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:133
#: src/ch12-02-reading-a-file.md:42
#: src/ch12-03-improving-error-handling-and-modularity.md:86
msgid "\"Searching for {query}\""
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:134
#: src/ch12-02-reading-a-file.md:43
#: src/ch12-03-improving-error-handling-and-modularity.md:87
msgid "\"In file {file_path}\""
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:140
msgid ""
"As we saw when we printed the vector, the program’s name takes up the first "
"value in the vector at `args[0]`, so we’re starting arguments at index 1. "
"The first argument `minigrep` takes is the string we’re searching for, so we "
"put a reference to the first argument in the variable `query`. The second "
"argument will be the file path, so we put a reference to the second argument "
"in the variable `file_path`."
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:147
msgid ""
"We temporarily print the values of these variables to prove that the code is "
"working as we intend. Let’s run this program again with the arguments `test` "
"and `sample.txt`:"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:151
msgid ""
"```console\n"
"$ cargo run -- test sample.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep test sample.txt`\n"
"Searching for test\n"
"In file sample.txt\n"
"```"
msgstr ""

#: src/ch12-01-accepting-command-line-arguments.md:160
msgid ""
"Great, the program is working! The values of the arguments we need are being "
"saved into the right variables. Later we’ll add some error handling to deal "
"with certain potential erroneous situations, such as when the user provides "
"no arguments; for now, we’ll ignore that situation and work on adding file-"
"reading capabilities instead."
msgstr ""

#: src/ch12-02-reading-a-file.md:3
msgid ""
"Now we’ll add functionality to read the file specified in the `file_path` "
"argument. First we need a sample file to test it with: we’ll use a file with "
"a small amount of text over multiple lines with some repeated words. Listing "
"12-3 has an Emily Dickinson poem that will work well! Create a file called "
"_poem.txt_ at the root level of your project, and enter the poem “I’m "
"Nobody! Who are you?”"
msgstr ""

#: src/ch12-02-reading-a-file.md:26
msgid ""
"With the text in place, edit _src/main.rs_ and add code to read the file, as "
"shown in Listing 12-4."
msgstr ""

#: src/ch12-02-reading-a-file.md:46
#: src/ch12-03-improving-error-handling-and-modularity.md:90
#: src/ch12-03-improving-error-handling-and-modularity.md:153
#: src/ch12-03-improving-error-handling-and-modularity.md:248
#: src/ch12-03-improving-error-handling-and-modularity.md:321
#: src/ch12-03-improving-error-handling-and-modularity.md:413
#: src/ch12-03-improving-error-handling-and-modularity.md:486
#: src/ch12-03-improving-error-handling-and-modularity.md:583
msgid "\"Should have been able to read the file\""
msgstr ""

#: src/ch12-02-reading-a-file.md:48
#: src/ch12-03-improving-error-handling-and-modularity.md:92
#: src/ch12-03-improving-error-handling-and-modularity.md:157
#: src/ch12-03-improving-error-handling-and-modularity.md:250
#: src/ch12-03-improving-error-handling-and-modularity.md:323
#: src/ch12-03-improving-error-handling-and-modularity.md:415
#: src/ch12-03-improving-error-handling-and-modularity.md:488
#: src/ch12-03-improving-error-handling-and-modularity.md:585
#: src/ch12-03-improving-error-handling-and-modularity.md:653
#: src/ch12-03-improving-error-handling-and-modularity.md:781
#: src/ch12-03-improving-error-handling-and-modularity.md:862
msgid "\"With text:\\n{contents}\""
msgstr ""

#: src/ch12-02-reading-a-file.md:54
msgid ""
"First we bring in a relevant part of the standard library with a `use` "
"statement: we need `std::fs` to handle files."
msgstr ""

#: src/ch12-02-reading-a-file.md:57
msgid ""
"In `main`, the new statement `fs::read_to_string` takes the `file_path`, "
"opens that file, and returns a value of type `std::io::Result<String>` that "
"contains the file’s contents."
msgstr ""

#: src/ch12-02-reading-a-file.md:61
msgid ""
"After that, we again add a temporary `println!` statement that prints the "
"value of `contents` after the file is read, so we can check that the program "
"is working so far."
msgstr ""

#: src/ch12-02-reading-a-file.md:65
msgid ""
"Let’s run this code with any string as the first command line argument "
"(because we haven’t implemented the searching part yet) and the _poem.txt_ "
"file as the second argument:"
msgstr ""

#: src/ch12-02-reading-a-file.md:69
msgid ""
"```console\n"
"$ cargo run -- the poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep the poem.txt`\n"
"Searching for the\n"
"In file poem.txt\n"
"With text:\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"Then there's a pair of us - don't tell!\n"
"They'd banish us, you know.\n"
"\n"
"How dreary to be somebody!\n"
"How public, like a frog\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"\n"
"```"
msgstr ""

#: src/ch12-02-reading-a-file.md:89
msgid ""
"Great! The code read and then printed the contents of the file. But the code "
"has a few flaws. At the moment, the `main` function has multiple "
"responsibilities: generally, functions are clearer and easier to maintain if "
"each function is responsible for only one idea. The other problem is that "
"we’re not handling errors as well as we could. The program is still small, "
"so these flaws aren’t a big problem, but as the program grows, it will be "
"harder to fix them cleanly. It’s a good practice to begin refactoring early "
"on when developing a program because it’s much easier to refactor smaller "
"amounts of code. We’ll do that next."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:3
msgid ""
"To improve our program, we’ll fix four problems that have to do with the "
"program’s structure and how it’s handling potential errors. First, our "
"`main` function now performs two tasks: it parses arguments and reads files. "
"As our program grows, the number of separate tasks the `main` function "
"handles will increase. As a function gains responsibilities, it becomes more "
"difficult to reason about, harder to test, and harder to change without "
"breaking one of its parts. It’s best to separate functionality so each "
"function is responsible for one task."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:12
msgid ""
"This issue also ties into the second problem: although `query` and "
"`file_path` are configuration variables to our program, variables like "
"`contents` are used to perform the program’s logic. The longer `main` "
"becomes, the more variables we’ll need to bring into scope; the more "
"variables we have in scope, the harder it will be to keep track of the "
"purpose of each. It’s best to group the configuration variables into one "
"structure to make their purpose clear."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:19
msgid ""
"The third problem is that we’ve used `expect` to print an error message when "
"reading the file fails, but the error message just prints `Should have been "
"able to read the file`. Reading a file can fail in a number of ways: for "
"example, the file could be missing, or we might not have permission to open "
"it. Right now, regardless of the situation, we’d print the same error "
"message for everything, which wouldn’t give the user any information!"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:26
msgid ""
"Fourth, we use `expect` to handle an error, and if the user runs our program "
"without specifying enough arguments, they’ll get an `index out of bounds` "
"error from Rust that doesn’t clearly explain the problem. It would be best "
"if all the error-handling code were in one place so future maintainers had "
"only one place to consult the code if the error-handling logic needed to "
"change. Having all the error-handling code in one place will also ensure "
"that we’re printing messages that will be meaningful to our end users."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:34
msgid "Let’s address these four problems by refactoring our project."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:36
msgid "Separation of Concerns for Binary Projects"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:38
msgid ""
"The organizational problem of allocating responsibility for multiple tasks "
"to the `main` function is common to many binary projects. As a result, the "
"Rust community has developed guidelines for splitting the separate concerns "
"of a binary program when `main` starts getting large. This process has the "
"following steps:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:44
msgid ""
"Split your program into a _main.rs_ file and a _lib.rs_ file and move your "
"program’s logic to _lib.rs_."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:46
msgid ""
"As long as your command line parsing logic is small, it can remain in "
"_main.rs_."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:48
msgid ""
"When the command line parsing logic starts getting complicated, extract it "
"from _main.rs_ and move it to _lib.rs_."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:51
msgid ""
"The responsibilities that remain in the `main` function after this process "
"should be limited to the following:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:54
msgid "Calling the command line parsing logic with the argument values"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:55
msgid "Setting up any other configuration"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:56
msgid "Calling a `run` function in _lib.rs_"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:57
msgid "Handling the error if `run` returns an error"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:59
msgid ""
"This pattern is about separating concerns: _main.rs_ handles running the "
"program and _lib.rs_ handles all the logic of the task at hand. Because you "
"can’t test the `main` function directly, this structure lets you test all of "
"your program’s logic by moving it into functions in _lib.rs_. The code that "
"remains in _main.rs_ will be small enough to verify its correctness by "
"reading it. Let’s rework our program by following this process."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:66
msgid "Extracting the Argument Parser"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:68
msgid ""
"We’ll extract the functionality for parsing arguments into a function that "
"`main` will call to prepare for moving the command line parsing logic to "
"_src/lib.rs_. Listing 12-5 shows the new start of `main` that calls a new "
"function `parse_config`, which we’ll define in _src/main.rs_ for the moment."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:105
msgid ""
"We’re still collecting the command line arguments into a vector, but instead "
"of assigning the argument value at index 1 to the variable `query` and the "
"argument value at index 2 to the variable `file_path` within the `main` "
"function, we pass the whole vector to the `parse_config` function. The "
"`parse_config` function then holds the logic that determines which argument "
"goes in which variable and passes the values back to `main`. We still create "
"the `query` and `file_path` variables in `main`, but `main` no longer has "
"the responsibility of determining how the command line arguments and "
"variables correspond."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:115
msgid ""
"This rework may seem like overkill for our small program, but we’re "
"refactoring in small, incremental steps. After making this change, run the "
"program again to verify that the argument parsing still works. It’s good to "
"check your progress often, to help identify the cause of problems when they "
"occur."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:120
msgid "Grouping Configuration Values"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:122
msgid ""
"We can take another small step to improve the `parse_config` function "
"further. At the moment, we’re returning a tuple, but then we immediately "
"break that tuple into individual parts again. This is a sign that perhaps we "
"don’t have the right abstraction yet."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:127
msgid ""
"Another indicator that shows there’s room for improvement is the `config` "
"part of `parse_config`, which implies that the two values we return are "
"related and are both part of one configuration value. We’re not currently "
"conveying this meaning in the structure of the data other than by grouping "
"the two values into a tuple; we’ll instead put the two values into one "
"struct and give each of the struct fields a meaningful name. Doing so will "
"make it easier for future maintainers of this code to understand how the "
"different values relate to each other and what their purpose is."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:136
msgid "Listing 12-6 shows the improvements to the `parse_config` function."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:149
#: src/ch12-03-improving-error-handling-and-modularity.md:244
#: src/ch12-03-improving-error-handling-and-modularity.md:317
#: src/ch12-03-improving-error-handling-and-modularity.md:409
#: src/ch12-03-improving-error-handling-and-modularity.md:482
#: src/ch12-03-improving-error-handling-and-modularity.md:575
#: src/ch12-03-improving-error-handling-and-modularity.md:644
#: src/ch12-03-improving-error-handling-and-modularity.md:769
#: src/ch12-03-improving-error-handling-and-modularity.md:894
msgid "\"Searching for {}\""
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:150
#: src/ch12-03-improving-error-handling-and-modularity.md:245
#: src/ch12-03-improving-error-handling-and-modularity.md:318
#: src/ch12-03-improving-error-handling-and-modularity.md:410
#: src/ch12-03-improving-error-handling-and-modularity.md:483
#: src/ch12-03-improving-error-handling-and-modularity.md:576
#: src/ch12-03-improving-error-handling-and-modularity.md:645
#: src/ch12-03-improving-error-handling-and-modularity.md:770
#: src/ch12-03-improving-error-handling-and-modularity.md:895
msgid "\"In file {}\""
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:175
msgid ""
"We’ve added a struct named `Config` defined to have fields named `query` and "
"`file_path`. The signature of `parse_config` now indicates that it returns a "
"`Config` value. In the body of `parse_config`, where we used to return "
"string slices that reference `String` values in `args`, we now define "
"`Config` to contain owned `String` values. The `args` variable in `main` is "
"the owner of the argument values and is only letting the `parse_config` "
"function borrow them, which means we’d violate Rust’s borrowing rules if "
"`Config` tried to take ownership of the values in `args`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:184
msgid ""
"There are a number of ways we could manage the `String` data; the easiest, "
"though somewhat inefficient, route is to call the `clone` method on the "
"values. This will make a full copy of the data for the `Config` instance to "
"own, which takes more time and memory than storing a reference to the string "
"data. However, cloning the data also makes our code very straightforward "
"because we don’t have to manage the lifetimes of the references; in this "
"circumstance, giving up a little performance to gain simplicity is a "
"worthwhile trade-off."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:192
msgid "The Trade-Offs of Using `clone`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:194
msgid ""
"There’s a tendency among many Rustaceans to avoid using `clone` to fix "
"ownership problems because of its runtime cost. In [Chapter 13](ch13-00-"
"functional-features.html)<!-- ignore -->, you’ll learn how to use more "
"efficient methods in this type of situation. But for now, it’s okay to copy "
"a few strings to continue making progress because you’ll make these copies "
"only once and your file path and query string are very small. It’s better to "
"have a working program that’s a bit inefficient than to try to hyperoptimize "
"code on your first pass. As you become more experienced with Rust, it’ll be "
"easier to start with the most efficient solution, but for now, it’s "
"perfectly acceptable to call `clone`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:205
msgid ""
"We’ve updated `main` so it places the instance of `Config` returned by "
"`parse_config` into a variable named `config`, and we updated the code that "
"previously used the separate `query` and `file_path` variables so it now "
"uses the fields on the `Config` struct instead."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:210
msgid ""
"Now our code more clearly conveys that `query` and `file_path` are related "
"and that their purpose is to configure how the program will work. Any code "
"that uses these values knows to find them in the `config` instance in the "
"fields named for their purpose."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:215
msgid "Creating a Constructor for `Config`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:217
msgid ""
"So far, we’ve extracted the logic responsible for parsing the command line "
"arguments from `main` and placed it in the `parse_config` function. Doing so "
"helped us see that the `query` and `file_path` values were related, and that "
"relationship should be conveyed in our code. We then added a `Config` struct "
"to name the related purpose of `query` and `file_path` and to be able to "
"return the values’ names as struct field names from the `parse_config` "
"function."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:224
msgid ""
"So now that the purpose of the `parse_config` function is to create a "
"`Config` instance, we can change `parse_config` from a plain function to a "
"function named `new` that is associated with the `Config` struct. Making "
"this change will make the code more idiomatic. We can create instances of "
"types in the standard library, such as `String`, by calling `String::new`. "
"Similarly, by changing `parse_config` into a `new` function associated with "
"`Config`, we’ll be able to create instances of `Config` by calling "
"`Config::new`. Listing 12-7 shows the changes we need to make."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:274
msgid ""
"We’ve updated `main` where we were calling `parse_config` to instead call "
"`Config::new`. We’ve changed the name of `parse_config` to `new` and moved "
"it within an `impl` block, which associates the `new` function with "
"`Config`. Try compiling this code again to make sure it works."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:279
msgid "Fixing the Error Handling"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:281
msgid ""
"Now we’ll work on fixing our error handling. Recall that attempting to "
"access the values in the `args` vector at index 1 or index 2 will cause the "
"program to panic if the vector contains fewer than three items. Try running "
"the program without any arguments; it will look like this:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:286
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep`\n"
"thread 'main' panicked at src/main.rs:27:21:\n"
"index out of bounds: the len is 1 but the index is 1\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:296
msgid ""
"The line `index out of bounds: the len is 1 but the index is 1` is an error "
"message intended for programmers. It won’t help our end users understand "
"what they should do instead. Let’s fix that now."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:300
msgid "Improving the Error Message"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:302
msgid ""
"In Listing 12-8, we add a check in the `new` function that will verify that "
"the slice is long enough before accessing index 1 and index 2. If the slice "
"isn’t long enough, the program panics and displays a better error message."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:335
#: src/ch12-03-improving-error-handling-and-modularity.md:426
#: src/ch12-03-improving-error-handling-and-modularity.md:499
#: src/ch12-03-improving-error-handling-and-modularity.md:598
#: src/ch12-03-improving-error-handling-and-modularity.md:666
#: src/ch12-03-improving-error-handling-and-modularity.md:794
#: src/ch12-03-improving-error-handling-and-modularity.md:848
#: src/ch12-04-testing-the-librarys-functionality.md:52
#: src/ch12-04-testing-the-librarys-functionality.md:115
#: src/ch12-04-testing-the-librarys-functionality.md:267
#: src/ch12-04-testing-the-librarys-functionality.md:334
#: src/ch12-04-testing-the-librarys-functionality.md:402
#: src/ch12-04-testing-the-librarys-functionality.md:507
#: src/ch12-05-working-with-environment-variables.md:33
#: src/ch12-05-working-with-environment-variables.md:137
#: src/ch12-05-working-with-environment-variables.md:290
#: src/ch12-05-working-with-environment-variables.md:397
#: src/ch12-05-working-with-environment-variables.md:511
#: src/ch13-03-improving-our-io-project.md:32
#: src/ch13-03-improving-our-io-project.md:232
#: src/ch13-03-improving-our-io-project.md:493
msgid "\"not enough arguments\""
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:349
msgid ""
"This code is similar to [the `Guess::new` function we wrote in Listing 9-13]"
"(ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-"
"validation)<!-- ignore -->, where we called `panic!` when the `value` "
"argument was out of the range of valid values. Instead of checking for a "
"range of values here, we’re checking that the length of `args` is at least "
"`3` and the rest of the function can operate under the assumption that this "
"condition has been met. If `args` has fewer than three items, this condition "
"will be `true`, and we call the `panic!` macro to end the program "
"immediately."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:357
msgid ""
"With these extra few lines of code in `new`, let’s run the program without "
"any arguments again to see what the error looks like now:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:360
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep`\n"
"thread 'main' panicked at src/main.rs:26:13:\n"
"not enough arguments\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:370
msgid ""
"This output is better: we now have a reasonable error message. However, we "
"also have extraneous information we don’t want to give to our users. Perhaps "
"the technique we used in Listing 9-13 isn’t the best one to use here: a call "
"to `panic!` is more appropriate for a programming problem than a usage "
"problem, [as discussed in Chapter 9](ch09-03-to-panic-or-not-to-"
"panic.html#guidelines-for-error-handling)<!-- ignore -->. Instead, we’ll use "
"the other technique you learned about in Chapter 9—[returning a `Result`]"
"(ch09-02-recoverable-errors-with-result.html)<!-- ignore --> that indicates "
"either success or an error."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:380
msgid "<a id=\"returning-a-result-from-new-instead-of-calling-panic\"></a>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:382
msgid "Returning a `Result` Instead of Calling `panic!`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:384
msgid ""
"We can instead return a `Result` value that will contain a `Config` instance "
"in the successful case and will describe the problem in the error case. "
"We’re also going to change the function name from `new` to `build` because "
"many programmers expect `new` functions to never fail. When `Config::build` "
"is communicating to `main`, we can use the `Result` type to signal there was "
"a problem. Then we can change `main` to convert an `Err` variant into a more "
"practical error for our users without the surrounding text about `thread "
"'main'` and `RUST_BACKTRACE` that a call to `panic!` causes."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:393
msgid ""
"Listing 12-9 shows the changes we need to make to the return value of the "
"function we’re now calling `Config::build` and the body of the function "
"needed to return a `Result`. Note that this won’t compile until we update "
"`main` as well, which we’ll do in the next listing."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:439
msgid ""
"Our `build` function returns a `Result` with a `Config` instance in the "
"success case and a string literal in the error case. Our error values will "
"always be string literals that have the `'static` lifetime."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:443
msgid ""
"We’ve made two changes in the body of the function: instead of calling "
"`panic!` when the user doesn’t pass enough arguments, we now return an `Err` "
"value, and we’ve wrapped the `Config` return value in an `Ok`. These changes "
"make the function conform to its new type signature."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:448
msgid ""
"Returning an `Err` value from `Config::build` allows the `main` function to "
"handle the `Result` value returned from the `build` function and exit the "
"process more cleanly in the error case."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:454
msgid "<a id=\"calling-confignew-and-handling-errors\"></a>"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:456
msgid "Calling `Config::build` and Handling Errors"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:458
msgid ""
"To handle the error case and print a user-friendly message, we need to "
"update `main` to handle the `Result` being returned by `Config::build`, as "
"shown in Listing 12-10. We’ll also take the responsibility of exiting the "
"command line tool with a nonzero error code away from `panic!` and instead "
"implement it by hand. A nonzero exit status is a convention to signal to the "
"process that called our program that the program exited with an error state."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:476
#: src/ch12-03-improving-error-handling-and-modularity.md:571
#: src/ch12-03-improving-error-handling-and-modularity.md:640
#: src/ch12-03-improving-error-handling-and-modularity.md:765
#: src/ch12-03-improving-error-handling-and-modularity.md:890
#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:69
#: src/ch13-03-improving-our-io-project.md:161
#: src/ch13-03-improving-our-io-project.md:188
msgid "\"Problem parsing arguments: {err}\""
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:512
msgid ""
"In this listing, we’ve used a method we haven’t covered in detail yet: "
"`unwrap_or_else`, which is defined on `Result<T, E>` by the standard "
"library. Using `unwrap_or_else` allows us to define some custom, non-`panic!"
"` error handling. If the `Result` is an `Ok` value, this method’s behavior "
"is similar to `unwrap`: it returns the inner value that `Ok` is wrapping. "
"However, if the value is an `Err` value, this method calls the code in the "
"_closure_, which is an anonymous function we define and pass as an argument "
"to `unwrap_or_else`. We’ll cover closures in more detail in [Chapter 13]"
"(ch13-00-functional-features.html)<!-- ignore -->. For now, you just need to "
"know that `unwrap_or_else` will pass the inner value of the `Err`, which in "
"this case is the static string `\"not enough arguments\"` that we added in "
"Listing 12-9, to our closure in the argument `err` that appears between the "
"vertical pipes. The code in the closure can then use the `err` value when it "
"runs."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:526
msgid ""
"We’ve added a new `use` line to bring `process` from the standard library "
"into scope. The code in the closure that will be run in the error case is "
"only two lines: we print the `err` value and then call `process::exit`. The "
"`process::exit` function will stop the program immediately and return the "
"number that was passed as the exit status code. This is similar to the "
"`panic!`\\-based handling we used in Listing 12-8, but we no longer get all "
"the extra output. Let’s try it:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:534
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/minigrep`\n"
"Problem parsing arguments: not enough arguments\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:542
msgid "Great! This output is much friendlier for our users."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:544
msgid "Extracting Logic from `main`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:546
msgid ""
"Now that we’ve finished refactoring the configuration parsing, let’s turn to "
"the program’s logic. As we stated in [“Separation of Concerns for Binary "
"Projects”](#separation-of-concerns-for-binary-projects)<!-- ignore -->, "
"we’ll extract a function named `run` that will hold all the logic currently "
"in the `main` function that isn’t involved with setting up configuration or "
"handling errors. When we’re done, `main` will be concise and easy to verify "
"by inspection, and we’ll be able to write tests for all the other logic."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:554
msgid ""
"Listing 12-11 shows the extracted `run` function. For now, we’re just making "
"the small, incremental improvement of extracting the function. We’re still "
"defining the function in _src/main.rs_."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:611
msgid ""
"The `run` function now contains all the remaining logic from `main`, "
"starting from reading the file. The `run` function takes the `Config` "
"instance as an argument."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:615
msgid "Returning Errors from the `run` Function"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:617
msgid ""
"With the remaining program logic separated into the `run` function, we can "
"improve the error handling, as we did with `Config::build` in Listing 12-9. "
"Instead of allowing the program to panic by calling `expect`, the `run` "
"function will return a `Result<T, E>` when something goes wrong. This will "
"let us further consolidate the logic around handling errors into `main` in a "
"user-friendly way. Listing 12-12 shows the changes we need to make to the "
"signature and body of `run`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:679
msgid ""
"We’ve made three significant changes here. First, we changed the return type "
"of the `run` function to `Result<(), Box<dyn Error>>`. This function "
"previously returned the unit type, `()`, and we keep that as the value "
"returned in the `Ok` case."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:684
msgid ""
"For the error type, we used the _trait object_ `Box<dyn Error>` (and we’ve "
"brought `std::error::Error` into scope with a `use` statement at the top). "
"We’ll cover trait objects in [Chapter 18](ch18-00-oop.html)<!-- ignore -->. "
"For now, just know that `Box<dyn Error>` means the function will return a "
"type that implements the `Error` trait, but we don’t have to specify what "
"particular type the return value will be. This gives us flexibility to "
"return error values that may be of different types in different error cases. "
"The `dyn` keyword is short for _dynamic_."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:693
msgid ""
"Second, we’ve removed the call to `expect` in favor of the `?` operator, as "
"we talked about in [Chapter 9](ch09-02-recoverable-errors-with-result.html#a-"
"shortcut-for-propagating-errors-the--operator)<!-- ignore -->. Rather than "
"`panic!` on an error, `?` will return the error value from the current "
"function for the caller to handle."
msgstr ""
"두 번째로, [9장](ch09-02-recoverable-errors-with-result.html#a-"
"shortcut-for-propagating-errors-the--operator)<!-- ignore -->에서 이야기했듯이 `expect` 호출을 `?` 연산자로 대체했습니다. "
"오류 발생 시 `panic!`을 호출하는 대신, `?`는 현재 함수에서 오류 값을 반환하여 호출자가 처리하도록 합니다."

#: src/ch12-03-improving-error-handling-and-modularity.md:698
msgid ""
"Third, the `run` function now returns an `Ok` value in the success case. "
"We’ve declared the `run` function’s success type as `()` in the signature, "
"which means we need to wrap the unit type value in the `Ok` value. This "
"`Ok(())` syntax might look a bit strange at first, but using `()` like this "
"is the idiomatic way to indicate that we’re calling `run` for its side "
"effects only; it doesn’t return a value we need."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:705
msgid "When you run this code, it will compile but will display a warning:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:707
msgid ""
"```console\n"
"$ cargo run -- the poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"warning: unused `Result` that must be used\n"
"  --> src/main.rs:19:5\n"
"   |\n"
"19 |     run(config);\n"
"   |     ^^^^^^^^^^^\n"
"   |\n"
"   = note: this `Result` may be an `Err` variant, which should be handled\n"
"   = note: `#[warn(unused_must_use)]` on by default\n"
"help: use `let _ = ...` to ignore the resulting value\n"
"   |\n"
"19 |     let _ = run(config);\n"
"   |     +++++++\n"
"\n"
"warning: `minigrep` (bin \"minigrep\") generated 1 warning\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n"
"     Running `target/debug/minigrep the poem.txt`\n"
"Searching for the\n"
"In file poem.txt\n"
"With text:\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"Then there's a pair of us - don't tell!\n"
"They'd banish us, you know.\n"
"\n"
"How dreary to be somebody!\n"
"How public, like a frog\n"
"To tell your name the livelong day\n"
"To an admiring bog!\n"
"\n"
"```"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:741
msgid ""
"Rust tells us that our code ignored the `Result` value and the `Result` "
"value might indicate that an error occurred. But we’re not checking to see "
"whether or not there was an error, and the compiler reminds us that we "
"probably meant to have some error-handling code here! Let’s rectify that "
"problem now."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:746
msgid "Handling Errors Returned from `run` in `main`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:748
msgid ""
"We’ll check for errors and handle them using a technique similar to one we "
"used with `Config::build` in Listing 12-10, but with a slight difference:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:773
#: src/ch12-03-improving-error-handling-and-modularity.md:899
#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:74
#: src/ch13-03-improving-our-io-project.md:168
#: src/ch13-03-improving-our-io-project.md:195
msgid "\"Application error: {e}\""
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:805
msgid ""
"We use `if let` rather than `unwrap_or_else` to check whether `run` returns "
"an `Err` value and to call `process::exit(1)` if it does. The `run` function "
"doesn’t return a value that we want to `unwrap` in the same way that "
"`Config::build` returns the `Config` instance. Because `run` returns `()` in "
"the success case, we only care about detecting an error, so we don’t need "
"`unwrap_or_else` to return the unwrapped value, which would only be `()`."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:812
msgid ""
"The bodies of the `if let` and the `unwrap_or_else` functions are the same "
"in both cases: we print the error and exit."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:815
msgid "Splitting Code into a Library Crate"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:817
msgid ""
"Our `minigrep` project is looking good so far! Now we’ll split the _src/"
"main.rs_ file and put some code into the _src/lib.rs_ file. That way, we can "
"test the code and have a _src/main.rs_ file with fewer responsibilities."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:821
msgid ""
"Let’s move all the code that isn’t in the `main` function from _src/main.rs_ "
"to _src/lib.rs_:"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:824
msgid "The `run` function definition"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:825
msgid "The relevant `use` statements"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:826
msgid "The definition of `Config`"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:827
msgid "The `Config::build` function definition"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:829
msgid ""
"The contents of _src/lib.rs_ should have the signatures shown in Listing "
"12-13 (we’ve omitted the bodies of the functions for brevity). Note that "
"this won’t compile until we modify _src/main.rs_ in Listing 12-14."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:870
msgid ""
"We’ve made liberal use of the `pub` keyword: on `Config`, on its fields and "
"its `build` method, and on the `run` function. We now have a library crate "
"that has a public API we can test!"
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:874
msgid ""
"Now we need to bring the code we moved to _src/lib.rs_ into the scope of the "
"binary crate in _src/main.rs_, as shown in Listing 12-14."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:907
msgid ""
"We add a `use minigrep::Config` line to bring the `Config` type from the "
"library crate into the binary crate’s scope, and we prefix the `run` "
"function with our crate name. Now all the functionality should be connected "
"and should work. Run the program with `cargo run` and make sure everything "
"works correctly."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:912
msgid ""
"Whew! That was a lot of work, but we’ve set ourselves up for success in the "
"future. Now it’s much easier to handle errors, and we’ve made the code more "
"modular. Almost all of our work will be done in _src/lib.rs_ from here on "
"out."
msgstr ""

#: src/ch12-03-improving-error-handling-and-modularity.md:916
msgid ""
"Let’s take advantage of this newfound modularity by doing something that "
"would have been difficult with the old code but is easy with the new code: "
"we’ll write some tests!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:1
msgid "Developing the Library’s Functionality with Test-Driven Development"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:3
msgid ""
"Now that we’ve extracted the logic into _src/lib.rs_ and left the argument "
"collecting and error handling in _src/main.rs_, it’s much easier to write "
"tests for the core functionality of our code. We can call functions directly "
"with various arguments and check return values without having to call our "
"binary from the command line."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:9
msgid ""
"In this section, we’ll add the searching logic to the `minigrep` program "
"using the test-driven development (TDD) process with the following steps:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:12
msgid ""
"Write a test that fails and run it to make sure it fails for the reason you "
"expect."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:14
msgid "Write or modify just enough code to make the new test pass."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:15
msgid ""
"Refactor the code you just added or changed and make sure the tests continue "
"to pass."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:17
msgid "Repeat from step 1!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:19
msgid ""
"Though it’s just one of many ways to write software, TDD can help drive code "
"design. Writing the test before you write the code that makes the test pass "
"helps to maintain high test coverage throughout the process."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:23
msgid ""
"We’ll test-drive the implementation of the functionality that will actually "
"do the searching for the query string in the file contents and produce a "
"list of lines that match the query. We’ll add this functionality in a "
"function called `search`."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:28
msgid "Writing a Failing Test"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:30
msgid ""
"Because we don’t need them anymore, let’s remove the `println!` statements "
"from _src/lib.rs_ and _src/main.rs_ that we used to check the program’s "
"behavior. Then, in _src/lib.rs_, we’ll add a `tests` module with a test "
"function, as we did in [Chapter 11](ch11-01-writing-tests.html#the-anatomy-"
"of-a-test-function)<!-- ignore -->. The test function specifies the behavior "
"we want the `search` function to have: it will take a query and the text to "
"search, and it will return only the lines from the text that contain the "
"query. Listing 12-15 shows this test, which won’t compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:74
#: src/ch12-04-testing-the-librarys-functionality.md:141
#: src/ch12-04-testing-the-librarys-functionality.md:295
#: src/ch12-04-testing-the-librarys-functionality.md:364
#: src/ch12-04-testing-the-librarys-functionality.md:436
#: src/ch12-04-testing-the-librarys-functionality.md:545
#: src/ch12-05-working-with-environment-variables.md:71
#: src/ch12-05-working-with-environment-variables.md:191
#: src/ch12-05-working-with-environment-variables.md:350
#: src/ch12-05-working-with-environment-variables.md:457
#: src/ch12-05-working-with-environment-variables.md:577
#: src/ch13-03-improving-our-io-project.md:98
#: src/ch13-03-improving-our-io-project.md:298
#: src/ch13-03-improving-our-io-project.md:437
#: src/ch13-03-improving-our-io-project.md:527
#: src/ch13-03-improving-our-io-project.md:631
msgid "\"duct\""
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:75
msgid ""
"\"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\""
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:80
#: src/ch12-04-testing-the-librarys-functionality.md:147
#: src/ch12-04-testing-the-librarys-functionality.md:301
#: src/ch12-04-testing-the-librarys-functionality.md:370
#: src/ch12-04-testing-the-librarys-functionality.md:442
#: src/ch12-04-testing-the-librarys-functionality.md:551
#: src/ch12-05-working-with-environment-variables.md:78
#: src/ch12-05-working-with-environment-variables.md:198
#: src/ch12-05-working-with-environment-variables.md:357
#: src/ch12-05-working-with-environment-variables.md:464
#: src/ch12-05-working-with-environment-variables.md:584
#: src/ch13-03-improving-our-io-project.md:105
#: src/ch13-03-improving-our-io-project.md:305
#: src/ch13-03-improving-our-io-project.md:444
#: src/ch13-03-improving-our-io-project.md:533
#: src/ch13-03-improving-our-io-project.md:638
msgid "\"safe, fast, productive.\""
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:87
msgid ""
"This test searches for the string `\"duct\"`. The text we’re searching is "
"three lines, only one of which contains `\"duct\"` (note that the backslash "
"after the opening double quote tells Rust not to put a newline character at "
"the beginning of the contents of this string literal). We assert that the "
"value returned from the `search` function contains only the line we expect."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:93
msgid ""
"We aren’t yet able to run this test and watch it fail because the test "
"doesn’t even compile: the `search` function doesn’t exist yet! In accordance "
"with TDD principles, we’ll add just enough code to get the test to compile "
"and run by adding a definition of the `search` function that always returns "
"an empty vector, as shown in Listing 12-16. Then the test should compile and "
"fail because an empty vector doesn’t match a vector containing the line "
"`\"safe, fast, productive.\"`"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:142
#: src/ch12-04-testing-the-librarys-functionality.md:296
#: src/ch12-04-testing-the-librarys-functionality.md:365
#: src/ch12-04-testing-the-librarys-functionality.md:437
#: src/ch12-04-testing-the-librarys-functionality.md:546
#: src/ch13-03-improving-our-io-project.md:528
msgid ""
"\"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\""
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:154
msgid ""
"Notice that we need to define an explicit lifetime `'a` in the signature of "
"`search` and use that lifetime with the `contents` argument and the return "
"value. Recall in [Chapter 10](ch10-03-lifetime-syntax.html)<!-- ignore --> "
"that the lifetime parameters specify which argument lifetime is connected to "
"the lifetime of the return value. In this case, we indicate that the "
"returned vector should contain string slices that reference slices of the "
"argument `contents` (rather than the argument `query`)."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:162
msgid ""
"In other words, we tell Rust that the data returned by the `search` function "
"will live as long as the data passed into the `search` function in the "
"`contents` argument. This is important! The data referenced _by_ a slice "
"needs to be valid for the reference to be valid; if the compiler assumes "
"we’re making string slices of `query` rather than `contents`, it will do its "
"safety checking incorrectly."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:169
msgid ""
"If we forget the lifetime annotations and try to compile this function, "
"we’ll get this error:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:172
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"error[E0106]: missing lifetime specifier\n"
"  --> src/lib.rs:28:51\n"
"   |\n"
"28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n"
"   |                      ----            ----         ^ expected named "
"lifetime parameter\n"
"   |\n"
"   = help: this function's return type contains a borrowed value, but the "
"signature does not say whether it is borrowed from `query` or `contents`\n"
"help: consider introducing a named lifetime parameter\n"
"   |\n"
"28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {\n"
"   |              ++++         ++                 ++              ++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `minigrep` (lib) due to 1 previous error\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:191
msgid ""
"Rust can’t possibly know which of the two arguments we need, so we need to "
"tell it explicitly. Because `contents` is the argument that contains all of "
"our text and we want to return the parts of that text that match, we know "
"`contents` is the argument that should be connected to the return value "
"using the lifetime syntax."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:197
msgid ""
"Other programming languages don’t require you to connect arguments to return "
"values in the signature, but this practice will get easier over time. You "
"might want to compare this example with the examples in the [“Validating "
"References with Lifetimes”](ch10-03-lifetime-syntax.html#validating-"
"references-with-lifetimes)<!-- ignore --> section in Chapter 10."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:203
msgid "Now let’s run the test:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:205
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 1 test\n"
"test tests::one_result ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::one_result stdout ----\n"
"thread 'tests::one_result' panicked at src/lib.rs:44:9:\n"
"assertion `left == right` failed\n"
"  left: [\"safe, fast, productive.\"]\n"
" right: []\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::one_result\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:232
msgid ""
"Great, the test fails, exactly as we expected. Let’s get the test to pass!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:234
msgid "Writing Code to Pass the Test"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:236
msgid ""
"Currently, our test is failing because we always return an empty vector. To "
"fix that and implement `search`, our program needs to follow these steps:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:239
msgid "Iterate through each line of the contents."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:240
msgid "Check whether the line contains our query string."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:241
msgid "If it does, add it to the list of values we’re returning."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:242
msgid "If it doesn’t, do nothing."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:243
msgid "Return the list of results that match."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:245
msgid "Let’s work through each step, starting with iterating through lines."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:247
msgid "Iterating Through Lines with the `lines` Method"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:249
msgid ""
"Rust has a helpful method to handle line-by-line iteration of strings, "
"conveniently named `lines`, that works as shown in Listing 12-17. Note that "
"this won’t compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:285
#: src/ch12-04-testing-the-librarys-functionality.md:353
msgid "// do something with line\n"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:308
msgid ""
"The `lines` method returns an iterator. We’ll talk about iterators in depth "
"in [Chapter 13](ch13-02-iterators.html)<!-- ignore -->, but recall that you "
"saw this way of using an iterator in [Listing 3-5](ch03-05-control-"
"flow.html#looping-through-a-collection-with-for)<!-- ignore -->, where we "
"used a `for` loop with an iterator to run some code on each item in a "
"collection."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:313
msgid "Searching Each Line for the Query"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:315
msgid ""
"Next, we’ll check whether the current line contains our query string. "
"Fortunately, strings have a helpful method named `contains` that does this "
"for us! Add a call to the `contains` method in the `search` function, as "
"shown in Listing 12-18. Note that this still won’t compile yet."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:377
msgid ""
"At the moment, we’re building up functionality. To get the code to compile, "
"we need to return a value from the body as we indicated we would in the "
"function signature."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:381
msgid "Storing Matching Lines"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:383
msgid ""
"To finish this function, we need a way to store the matching lines that we "
"want to return. For that, we can make a mutable vector before the `for` loop "
"and call the `push` method to store a `line` in the vector. After the `for` "
"loop, we return the vector, as shown in Listing 12-19."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:449
msgid ""
"Now the `search` function should return only the lines that contain `query`, "
"and our test should pass. Let’s run the test:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:452
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 1 test\n"
"test tests::one_result ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests minigrep\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:477
msgid "Our test passed, so we know it works!"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:479
msgid ""
"At this point, we could consider opportunities for refactoring the "
"implementation of the search function while keeping the tests passing to "
"maintain the same functionality. The code in the search function isn’t too "
"bad, but it doesn’t take advantage of some useful features of iterators. "
"We’ll return to this example in [Chapter 13](ch13-02-iterators.html)<!-- "
"ignore -->, where we’ll explore iterators in detail, and look at how to "
"improve it."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:486
msgid "Using the `search` Function in the `run` Function"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:488
msgid ""
"Now that the `search` function is working and tested, we need to call "
"`search` from our `run` function. We need to pass the `config.query` value "
"and the `contents` that `run` reads from the file to the `search` function. "
"Then `run` will print each line returned from `search`:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:521
#: src/ch12-05-working-with-environment-variables.md:47
#: src/ch12-05-working-with-environment-variables.md:151
#: src/ch12-05-working-with-environment-variables.md:310
#: src/ch12-05-working-with-environment-variables.md:417
#: src/ch12-05-working-with-environment-variables.md:537
#: src/ch13-03-improving-our-io-project.md:58
#: src/ch13-03-improving-our-io-project.md:258
#: src/ch13-03-improving-our-io-project.md:397
#: src/ch13-03-improving-our-io-project.md:596
msgid "\"{line}\""
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:556
msgid ""
"We’re still using a `for` loop to return each line from `search` and print "
"it."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:558
msgid ""
"Now the entire program should work! Let’s try it out, first with a word that "
"should return exactly one line from the Emily Dickinson poem: _frog_."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:561
msgid ""
"```console\n"
"$ cargo run -- frog poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n"
"     Running `target/debug/minigrep frog poem.txt`\n"
"How public, like a frog\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:569
msgid "Cool! Now let’s try a word that will match multiple lines, like _body_:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:571
msgid ""
"```console\n"
"$ cargo run -- body poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep body poem.txt`\n"
"I'm nobody! Who are you?\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:581
msgid ""
"And finally, let’s make sure that we don’t get any lines when we search for "
"a word that isn’t anywhere in the poem, such as _monomorphization_:"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:584
msgid ""
"```console\n"
"$ cargo run -- monomorphization poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep monomorphization poem.txt`\n"
"```"
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:591
msgid ""
"Excellent! We’ve built our own mini version of a classic tool and learned a "
"lot about how to structure applications. We’ve also learned a bit about file "
"input and output, lifetimes, testing, and command line parsing."
msgstr ""

#: src/ch12-04-testing-the-librarys-functionality.md:595
msgid ""
"To round out this project, we’ll briefly demonstrate how to work with "
"environment variables and how to print to standard error, both of which are "
"useful when you’re writing command line programs."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:3
msgid ""
"We’ll improve `minigrep` by adding an extra feature: an option for case-"
"insensitive searching that the user can turn on via an environment variable. "
"We could make this feature a command line option and require that users "
"enter it each time they want it to apply, but by instead making it an "
"environment variable, we allow our users to set the environment variable "
"once and have all their searches be case insensitive in that terminal "
"session."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:10
msgid "Writing a Failing Test for the Case-Insensitive `search` Function"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:12
msgid ""
"We first add a new `search_case_insensitive` function that will be called "
"when the environment variable has a value. We’ll continue to follow the TDD "
"process, so the first step is again to write a failing test. We’ll add a new "
"test for the new `search_case_insensitive` function and rename our old test "
"from `one_result` to `case_sensitive` to clarify the differences between the "
"two tests, as shown in Listing 12-20."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:72
msgid ""
"\"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\n"
"Duct tape.\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:83
#: src/ch12-05-working-with-environment-variables.md:203
#: src/ch12-05-working-with-environment-variables.md:362
#: src/ch12-05-working-with-environment-variables.md:469
#: src/ch12-05-working-with-environment-variables.md:589
#: src/ch13-03-improving-our-io-project.md:110
#: src/ch13-03-improving-our-io-project.md:310
#: src/ch13-03-improving-our-io-project.md:449
#: src/ch13-03-improving-our-io-project.md:643
msgid "\"rUsT\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:84
msgid ""
"\"\\\n"
"Rust:\n"
"safe, fast, productive.\n"
"Pick three.\n"
"Trust me.\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:91
#: src/ch12-05-working-with-environment-variables.md:211
#: src/ch12-05-working-with-environment-variables.md:370
#: src/ch12-05-working-with-environment-variables.md:477
#: src/ch12-05-working-with-environment-variables.md:597
#: src/ch13-03-improving-our-io-project.md:118
#: src/ch13-03-improving-our-io-project.md:318
#: src/ch13-03-improving-our-io-project.md:457
#: src/ch13-03-improving-our-io-project.md:651
msgid "\"Rust:\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:91
#: src/ch12-05-working-with-environment-variables.md:211
#: src/ch12-05-working-with-environment-variables.md:370
#: src/ch12-05-working-with-environment-variables.md:477
#: src/ch12-05-working-with-environment-variables.md:597
#: src/ch13-03-improving-our-io-project.md:118
#: src/ch13-03-improving-our-io-project.md:318
#: src/ch13-03-improving-our-io-project.md:457
#: src/ch13-03-improving-our-io-project.md:651
msgid "\"Trust me.\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:100
msgid ""
"Note that we’ve edited the old test’s `contents` too. We’ve added a new line "
"with the text `\"Duct tape.\"` using a capital _D_ that shouldn’t match the "
"query `\"duct\"` when we’re searching in a case-sensitive manner. Changing "
"the old test in this way helps ensure that we don’t accidentally break the "
"case-sensitive search functionality that we’ve already implemented. This "
"test should pass now and should continue to pass as we work on the case-"
"insensitive search."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:107
msgid ""
"The new test for the case-_insensitive_ search uses `\"rUsT\"` as its query. "
"In the `search_case_insensitive` function we’re about to add, the query "
"`\"rUsT\"` should match the line containing `\"Rust:\"` with a capital _R_ "
"and match the line `\"Trust me.\"` even though both have different casing "
"from the query. This is our failing test, and it will fail to compile "
"because we haven’t yet defined the `search_case_insensitive` function. Feel "
"free to add a skeleton implementation that always returns an empty vector, "
"similar to the way we did for the `search` function in Listing 12-16 to see "
"the test compile and fail."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:116
msgid "Implementing the `search_case_insensitive` Function"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:118
msgid ""
"The `search_case_insensitive` function, shown in Listing 12-21, will be "
"almost the same as the `search` function. The only difference is that we’ll "
"lowercase the `query` and each `line` so that whatever the case of the input "
"arguments, they’ll be the same case when we check whether the line contains "
"the query."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:192
#: src/ch12-05-working-with-environment-variables.md:351
#: src/ch12-05-working-with-environment-variables.md:458
#: src/ch12-05-working-with-environment-variables.md:578
#: src/ch13-03-improving-our-io-project.md:99
#: src/ch13-03-improving-our-io-project.md:299
#: src/ch13-03-improving-our-io-project.md:438
#: src/ch13-03-improving-our-io-project.md:632
msgid ""
"\"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Duct tape.\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:204
#: src/ch12-05-working-with-environment-variables.md:363
#: src/ch12-05-working-with-environment-variables.md:470
#: src/ch12-05-working-with-environment-variables.md:590
#: src/ch13-03-improving-our-io-project.md:111
#: src/ch13-03-improving-our-io-project.md:311
#: src/ch13-03-improving-our-io-project.md:450
#: src/ch13-03-improving-our-io-project.md:644
msgid ""
"\"\\\n"
"# Rust:\n"
"# safe, fast, productive.\n"
"# Pick three.\n"
"# Trust me.\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:220
msgid ""
"First we lowercase the `query` string and store it in a new variable with "
"the same name, shadowing the original. Calling `to_lowercase` on the query "
"is necessary so that no matter whether the user’s query is `\"rust\"`, "
"`\"RUST\"`, `\"Rust\"`, or `\"rUsT\"`, we’ll treat the query as if it were "
"`\"rust\"` and be insensitive to the case. While `to_lowercase` will handle "
"basic Unicode, it won’t be 100% accurate. If we were writing a real "
"application, we’d want to do a bit more work here, but this section is about "
"environment variables, not Unicode, so we’ll leave it at that here."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:229
msgid ""
"Note that `query` is now a `String` rather than a string slice because "
"calling `to_lowercase` creates new data rather than referencing existing "
"data. Say the query is `\"rUsT\"`, as an example: that string slice doesn’t "
"contain a lowercase `u` or `t` for us to use, so we have to allocate a new "
"`String` containing `\"rust\"`. When we pass `query` as an argument to the "
"`contains` method now, we need to add an ampersand because the signature of "
"`contains` is defined to take a string slice."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:237
msgid ""
"Next, we add a call to `to_lowercase` on each `line` to lowercase all "
"characters. Now that we’ve converted `line` and `query` to lowercase, we’ll "
"find matches no matter what the case of the query is."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:241
msgid "Let’s see if this implementation passes the tests:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:243
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 2 tests\n"
"test tests::case_insensitive ... ok\n"
"test tests::case_sensitive ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"minigrep-9cd200e5fac0fc94)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests minigrep\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:269
msgid ""
"Great! They passed. Now, let’s call the new `search_case_insensitive` "
"function from the `run` function. First we’ll add a configuration option to "
"the `Config` struct to switch between case-sensitive and case-insensitive "
"search. Adding this field will cause compiler errors because we aren’t "
"initializing this field anywhere yet:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:377
msgid ""
"We added the `ignore_case` field that holds a Boolean. Next, we need the "
"`run` function to check the `ignore_case` field’s value and use that to "
"decide whether to call the `search` function or the "
"`search_case_insensitive` function, as shown in Listing 12-22. This still "
"won’t compile yet."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:486
msgid ""
"Finally, we need to check for the environment variable. The functions for "
"working with environment variables are in the `env` module in the standard "
"library, so we bring that module into scope at the top of _src/lib.rs_. Then "
"we’ll use the `var` function from the `env` module to check to see if any "
"value has been set for an environment variable named `IGNORE_CASE`, as shown "
"in Listing 12-23."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:517
#: src/ch13-03-improving-our-io-project.md:38
#: src/ch13-03-improving-our-io-project.md:238
#: src/ch13-03-improving-our-io-project.md:377
#: src/ch13-03-improving-our-io-project.md:576
msgid "\"IGNORE_CASE\""
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:606
msgid ""
"Here, we create a new variable, `ignore_case`. To set its value, we call the "
"`env::var` function and pass it the name of the `IGNORE_CASE` environment "
"variable. The `env::var` function returns a `Result` that will be the "
"successful `Ok` variant that contains the value of the environment variable "
"if the environment variable is set to any value. It will return the `Err` "
"variant if the environment variable is not set."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:613
msgid ""
"We’re using the `is_ok` method on the `Result` to check whether the "
"environment variable is set, which means the program should do a case-"
"insensitive search. If the `IGNORE_CASE` environment variable isn’t set to "
"anything, `is_ok` will return `false` and the program will perform a case-"
"sensitive search. We don’t care about the _value_ of the environment "
"variable, just whether it’s set or unset, so we’re checking `is_ok` rather "
"than using `unwrap`, `expect`, or any of the other methods we’ve seen on "
"`Result`."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:621
msgid ""
"We pass the value in the `ignore_case` variable to the `Config` instance so "
"the `run` function can read that value and decide whether to call "
"`search_case_insensitive` or `search`, as we implemented in Listing 12-22."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:625
msgid ""
"Let’s give it a try! First we’ll run our program without the environment "
"variable set and with the query `to`, which should match any line that "
"contains the word _to_ in all lowercase:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:629
msgid ""
"```console\n"
"$ cargo run -- to poem.txt\n"
"   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n"
"     Running `target/debug/minigrep to poem.txt`\n"
"Are you nobody, too?\n"
"How dreary to be somebody!\n"
"```"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:638
msgid ""
"Looks like that still works! Now let’s run the program with `IGNORE_CASE` "
"set to `1` but with the same query _to_:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:645
msgid ""
"If you’re using PowerShell, you will need to set the environment variable "
"and run the program as separate commands:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:652
msgid ""
"This will make `IGNORE_CASE` persist for the remainder of your shell "
"session. It can be unset with the `Remove-Item` cmdlet:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:659
msgid ""
"We should get lines that contain _to_ that might have uppercase letters:"
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:674
msgid ""
"Excellent, we also got lines containing _To_! Our `minigrep` program can now "
"do case-insensitive searching controlled by an environment variable. Now you "
"know how to manage options set using either command line arguments or "
"environment variables."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:679
msgid ""
"Some programs allow arguments _and_ environment variables for the same "
"configuration. In those cases, the programs decide that one or the other "
"takes precedence. For another exercise on your own, try controlling case "
"sensitivity through either a command line argument or an environment "
"variable. Decide whether the command line argument or the environment "
"variable should take precedence if the program is run with one set to case "
"sensitive and one set to ignore case."
msgstr ""

#: src/ch12-05-working-with-environment-variables.md:687
msgid ""
"The `std::env` module contains many more useful features for dealing with "
"environment variables: check out its documentation to see what is available."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:3
msgid ""
"At the moment, we’re writing all of our output to the terminal using the "
"`println!` macro. In most terminals, there are two kinds of output: "
"_standard output_ (`stdout`) for general information and _standard error_ "
"(`stderr`) for error messages. This distinction enables users to choose to "
"direct the successful output of a program to a file but still print error "
"messages to the screen."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:10
msgid ""
"The `println!` macro is only capable of printing to standard output, so we "
"have to use something else to print to standard error."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:13
msgid "Checking Where Errors Are Written"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:15
msgid ""
"First let’s observe how the content printed by `minigrep` is currently being "
"written to standard output, including any error messages we want to write to "
"standard error instead. We’ll do that by redirecting the standard output "
"stream to a file while intentionally causing an error. We won’t redirect the "
"standard error stream, so any content sent to standard error will continue "
"to display on the screen."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:22
msgid ""
"Command line programs are expected to send error messages to the standard "
"error stream so we can still see error messages on the screen even if we "
"redirect the standard output stream to a file. Our program is not currently "
"well behaved: we’re about to see that it saves the error message output to a "
"file instead!"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:27
msgid ""
"To demonstrate this behavior, we’ll run the program with `>` and the file "
"path, _output.txt_, that we want to redirect the standard output stream to. "
"We won’t pass any arguments, which should cause an error:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:35
msgid ""
"The `>` syntax tells the shell to write the contents of standard output to "
"_output.txt_ instead of the screen. We didn’t see the error message we were "
"expecting printed to the screen, so that means it must have ended up in the "
"file. This is what _output.txt_ contains:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:44
msgid ""
"Yup, our error message is being printed to standard output. It’s much more "
"useful for error messages like this to be printed to standard error so only "
"data from a successful run ends up in the file. We’ll change that."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:48
msgid "Printing Errors to Standard Error"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:50
msgid ""
"We’ll use the code in Listing 12-24 to change how error messages are "
"printed. Because of the refactoring we did earlier in this chapter, all the "
"code that prints error messages is in one function, `main`. The standard "
"library provides the `eprintln!` macro that prints to the standard error "
"stream, so let’s change the two places we were calling `println!` to print "
"errors to use `eprintln!` instead."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:82
msgid ""
"Let’s now run the program again in the same way, without any arguments and "
"redirecting standard output with `>`:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:90
msgid ""
"Now we see the error onscreen and _output.txt_ contains nothing, which is "
"the behavior we expect of command line programs."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:93
msgid ""
"Let’s run the program again with arguments that don’t cause an error but "
"still redirect standard output to a file, like so:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:100
msgid ""
"We won’t see any output to the terminal, and _output.txt_ will contain our "
"results:"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:103
msgid "<span class=\"filename\">Filename: output.txt</span>"
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:110
msgid ""
"This demonstrates that we’re now using standard output for successful output "
"and standard error for error output as appropriate."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:115
msgid ""
"This chapter recapped some of the major concepts you’ve learned so far and "
"covered how to perform common I/O operations in Rust. By using command line "
"arguments, files, environment variables, and the `eprintln!` macro for "
"printing errors, you’re now prepared to write command line applications. "
"Combined with the concepts in previous chapters, your code will be well "
"organized, store data effectively in the appropriate data structures, handle "
"errors nicely, and be well tested."
msgstr ""

#: src/ch12-06-writing-to-stderr-instead-of-stdout.md:123
msgid ""
"Next, we’ll explore some Rust features that were influenced by functional "
"languages: closures and iterators."
msgstr ""

#: src/ch13-00-functional-features.md:3
msgid ""
"Rust’s design has taken inspiration from many existing languages and "
"techniques, and one significant influence is _functional programming_. "
"Programming in a functional style often includes using functions as values "
"by passing them in arguments, returning them from other functions, assigning "
"them to variables for later execution, and so forth."
msgstr ""

#: src/ch13-00-functional-features.md:9
msgid ""
"In this chapter, we won’t debate the issue of what functional programming is "
"or isn’t but will instead discuss some features of Rust that are similar to "
"features in many languages often referred to as functional."
msgstr ""

#: src/ch13-00-functional-features.md:13
msgid "More specifically, we’ll cover:"
msgstr ""

#: src/ch13-00-functional-features.md:15
msgid "_Closures_, a function-like construct you can store in a variable"
msgstr ""

#: src/ch13-00-functional-features.md:16
msgid "_Iterators_, a way of processing a series of elements"
msgstr ""

#: src/ch13-00-functional-features.md:17
msgid ""
"How to use closures and iterators to improve the I/O project in Chapter 12"
msgstr ""

#: src/ch13-00-functional-features.md:18
msgid ""
"The performance of closures and iterators (Spoiler alert: they’re faster "
"than you might think!)"
msgstr ""

#: src/ch13-00-functional-features.md:21
msgid ""
"We’ve already covered some other Rust features, such as pattern matching and "
"enums, that are also influenced by the functional style. Because mastering "
"closures and iterators is an important part of writing idiomatic, fast Rust "
"code, we’ll devote this entire chapter to them."
msgstr ""

#: src/ch13-01-closures.md:3
msgid ""
"<a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></"
"a>"
msgstr ""

#: src/ch13-01-closures.md:7
msgid ""
"Rust’s closures are anonymous functions you can save in a variable or pass "
"as arguments to other functions. You can create the closure in one place and "
"then call the closure elsewhere to evaluate it in a different context. "
"Unlike functions, closures can capture values from the scope in which "
"they’re defined. We’ll demonstrate how these closure features allow for code "
"reuse and behavior customization."
msgstr ""

#: src/ch13-01-closures.md:16
msgid ""
"<a id=\"creating-an-abstraction-of-behavior-with-closures\"></a> <a "
"id=\"refactoring-using-functions\"></a> <a id=\"refactoring-with-closures-to-"
"store-code\"></a>"
msgstr ""

#: src/ch13-01-closures.md:20
msgid "Capturing the Environment with Closures"
msgstr ""

#: src/ch13-01-closures.md:22
msgid ""
"We’ll first examine how we can use closures to capture values from the "
"environment they’re defined in for later use. Here’s the scenario: Every so "
"often, our t-shirt company gives away an exclusive, limited-edition shirt to "
"someone on our mailing list as a promotion. People on the mailing list can "
"optionally add their favorite color to their profile. If the person chosen "
"for a free shirt has their favorite color set, they get that color shirt. If "
"the person hasn’t specified a favorite color, they get whatever color the "
"company currently has the most of."
msgstr ""

#: src/ch13-01-closures.md:31
msgid ""
"There are many ways to implement this. For this example, we’re going to use "
"an enum called `ShirtColor` that has the variants `Red` and `Blue` (limiting "
"the number of colors available for simplicity). We represent the company’s "
"inventory with an `Inventory` struct that has a field named `shirts` that "
"contains a `Vec<ShirtColor>` representing the shirt colors currently in "
"stock. The method `giveaway` defined on `Inventory` gets the optional shirt "
"color preference of the free shirt winner, and returns the shirt color the "
"person will get. This setup is shown in Listing 13-1:"
msgstr ""

#: src/ch13-01-closures.md:84 src/ch13-01-closures.md:91
msgid "\"The user with preference {:?} gets {:?}\""
msgstr ""

#: src/ch13-01-closures.md:99
msgid ""
"The `store` defined in `main` has two blue shirts and one red shirt "
"remaining to distribute for this limited-edition promotion. We call the "
"`giveaway` method for a user with a preference for a red shirt and a user "
"without any preference."
msgstr ""

#: src/ch13-01-closures.md:103
msgid ""
"Again, this code could be implemented in many ways, and here, to focus on "
"closures, we’ve stuck to concepts you’ve already learned except for the body "
"of the `giveaway` method that uses a closure. In the `giveaway` method, we "
"get the user preference as a parameter of type `Option<ShirtColor>` and call "
"the `unwrap_or_else` method on `user_preference`. The [`unwrap_or_else` "
"method on `Option<T>`](../std/option/"
"enum.Option.html#method.unwrap_or_else)<!-- ignore --> is defined by the "
"standard library. It takes one argument: a closure without any arguments "
"that returns a value `T` (the same type stored in the `Some` variant of the "
"`Option<T>`, in this case `ShirtColor`). If the `Option<T>` is the `Some` "
"variant, `unwrap_or_else` returns the value from within the `Some`. If the "
"`Option<T>` is the `None` variant, `unwrap_or_else` calls the closure and "
"returns the value returned by the closure."
msgstr ""

#: src/ch13-01-closures.md:116
msgid ""
"We specify the closure expression `|| self.most_stocked()` as the argument "
"to `unwrap_or_else`. This is a closure that takes no parameters itself (if "
"the closure had parameters, they would appear between the two vertical "
"bars). The body of the closure calls `self.most_stocked()`. We’re defining "
"the closure here, and the implementation of `unwrap_or_else` will evaluate "
"the closure later if the result is needed."
msgstr ""

#: src/ch13-01-closures.md:123
msgid "Running this code prints:"
msgstr ""

#: src/ch13-01-closures.md:125
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n"
"     Running `target/debug/shirt-company`\n"
"The user with preference Some(Red) gets Red\n"
"The user with preference None gets Blue\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:134
msgid ""
"One interesting aspect here is that we’ve passed a closure that calls "
"`self.most_stocked()` on the current `Inventory` instance. The standard "
"library didn’t need to know anything about the `Inventory` or `ShirtColor` "
"types we defined, or the logic we want to use in this scenario. The closure "
"captures an immutable reference to the `self` `Inventory` instance and "
"passes it with the code we specify to the `unwrap_or_else` method. "
"Functions, on the other hand, are not able to capture their environment in "
"this way."
msgstr ""

#: src/ch13-01-closures.md:142
msgid "Closure Type Inference and Annotation"
msgstr ""

#: src/ch13-01-closures.md:144
msgid ""
"There are more differences between functions and closures. Closures don’t "
"usually require you to annotate the types of the parameters or the return "
"value like `fn` functions do. Type annotations are required on functions "
"because the types are part of an explicit interface exposed to your users. "
"Defining this interface rigidly is important for ensuring that everyone "
"agrees on what types of values a function uses and returns. Closures, on the "
"other hand, aren’t used in an exposed interface like this: they’re stored in "
"variables and used without naming them and exposing them to users of our "
"library."
msgstr ""

#: src/ch13-01-closures.md:153
msgid ""
"Closures are typically short and relevant only within a narrow context "
"rather than in any arbitrary scenario. Within these limited contexts, the "
"compiler can infer the types of the parameters and the return type, similar "
"to how it’s able to infer the types of most variables (there are rare cases "
"where the compiler needs closure type annotations too)."
msgstr ""

#: src/ch13-01-closures.md:159
msgid ""
"As with variables, we can add type annotations if we want to increase "
"explicitness and clarity at the cost of being more verbose than is strictly "
"necessary. Annotating the types for a closure would look like the definition "
"shown in Listing 13-2. In this example, we’re defining a closure and storing "
"it in a variable rather than defining the closure in the spot we pass it as "
"an argument as we did in Listing 13-1."
msgstr ""

#: src/ch13-01-closures.md:174
msgid "\"calculating slowly...\""
msgstr ""

#: src/ch13-01-closures.md:180
msgid "\"Today, do {} pushups!\""
msgstr ""

#: src/ch13-01-closures.md:181
msgid "\"Next, do {} situps!\""
msgstr ""

#: src/ch13-01-closures.md:184
msgid "\"Take a break today! Remember to stay hydrated!\""
msgstr ""

#: src/ch13-01-closures.md:187
msgid "\"Today, run for {} minutes!\""
msgstr ""

#: src/ch13-01-closures.md:204
msgid ""
"With type annotations added, the syntax of closures looks more similar to "
"the syntax of functions. Here we define a function that adds 1 to its "
"parameter and a closure that has the same behavior, for comparison. We’ve "
"added some spaces to line up the relevant parts. This illustrates how "
"closure syntax is similar to function syntax except for the use of pipes and "
"the amount of syntax that is optional:"
msgstr ""

#: src/ch13-01-closures.md:218
msgid ""
"The first line shows a function definition, and the second line shows a "
"fully annotated closure definition. In the third line, we remove the type "
"annotations from the closure definition. In the fourth line, we remove the "
"brackets, which are optional because the closure body has only one "
"expression. These are all valid definitions that will produce the same "
"behavior when they’re called. The `add_one_v3` and `add_one_v4` lines "
"require the closures to be evaluated to be able to compile because the types "
"will be inferred from their usage. This is similar to `let v = Vec::new();` "
"needing either type annotations or values of some type to be inserted into "
"the `Vec` for Rust to be able to infer the type."
msgstr ""

#: src/ch13-01-closures.md:228
msgid ""
"For closure definitions, the compiler will infer one concrete type for each "
"of their parameters and for their return value. For instance, Listing 13-3 "
"shows the definition of a short closure that just returns the value it "
"receives as a parameter. This closure isn’t very useful except for the "
"purposes of this example. Note that we haven’t added any type annotations to "
"the definition. Because there are no type annotations, we can call the "
"closure with any type, which we’ve done here with `String` the first time. "
"If we then try to call `example_closure` with an integer, we’ll get an error."
msgstr ""

#: src/ch13-01-closures.md:250
msgid "The compiler gives us this error:"
msgstr ""

#: src/ch13-01-closures.md:252
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:5:29\n"
"  |\n"
"5 |     let n = example_closure(5);\n"
"  |             --------------- ^- help: try using a conversion method: "
"`.to_string()`\n"
"  |             |               |\n"
"  |             |               expected `String`, found integer\n"
"  |             arguments to this function are incorrect\n"
"  |\n"
"note: expected because the closure was earlier called with an argument of "
"type `String`\n"
" --> src/main.rs:4:29\n"
"  |\n"
"4 |     let s = example_closure(String::from(\"hello\"));\n"
"  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this "
"argument is of type `String`\n"
"  |             |\n"
"  |             in this closure call\n"
"note: closure parameter defined here\n"
" --> src/main.rs:2:28\n"
"  |\n"
"2 |     let example_closure = |x| x;\n"
"  |                            ^\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `closure-example` (bin \"closure-example\") due to "
"1 previous error\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:281
msgid ""
"The first time we call `example_closure` with the `String` value, the "
"compiler infers the type of `x` and the return type of the closure to be "
"`String`. Those types are then locked into the closure in `example_closure`, "
"and we get a type error when we next try to use a different type with the "
"same closure."
msgstr ""

#: src/ch13-01-closures.md:286
msgid "Capturing References or Moving Ownership"
msgstr ""

#: src/ch13-01-closures.md:288
msgid ""
"Closures can capture values from their environment in three ways, which "
"directly map to the three ways a function can take a parameter: borrowing "
"immutably, borrowing mutably, and taking ownership. The closure will decide "
"which of these to use based on what the body of the function does with the "
"captured values."
msgstr ""

#: src/ch13-01-closures.md:294
msgid ""
"In Listing 13-4, we define a closure that captures an immutable reference to "
"the vector named `list` because it only needs an immutable reference to "
"print the value:"
msgstr ""

#: src/ch13-01-closures.md:303 src/ch13-01-closures.md:345
#: src/ch13-01-closures.md:395
msgid "\"Before defining closure: {list:?}\""
msgstr ""

#: src/ch13-01-closures.md:305
msgid "\"From closure: {list:?}\""
msgstr ""

#: src/ch13-01-closures.md:307
msgid "\"Before calling closure: {list:?}\""
msgstr ""

#: src/ch13-01-closures.md:309 src/ch13-01-closures.md:350
msgid "\"After calling closure: {list:?}\""
msgstr ""

#: src/ch13-01-closures.md:315
msgid ""
"This example also illustrates that a variable can bind to a closure "
"definition, and we can later call the closure by using the variable name and "
"parentheses as if the variable name were a function name."
msgstr ""

#: src/ch13-01-closures.md:319
msgid ""
"Because we can have multiple immutable references to `list` at the same "
"time, `list` is still accessible from the code before the closure "
"definition, after the closure definition but before the closure is called, "
"and after the closure is called. This code compiles, runs, and prints:"
msgstr ""

#: src/ch13-01-closures.md:324
msgid ""
"```console\n"
"$ cargo run\n"
"     Locking 1 package to latest compatible version\n"
"      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/"
"listings/ch13-functional-features/listing-13-04)\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/closure-example`\n"
"Before defining closure: [1, 2, 3]\n"
"Before calling closure: [1, 2, 3]\n"
"From closure: [1, 2, 3]\n"
"After calling closure: [1, 2, 3]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:337
msgid ""
"Next, in Listing 13-5, we change the closure body so that it adds an element "
"to the `list` vector. The closure now captures a mutable reference:"
msgstr ""

#: src/ch13-01-closures.md:356
msgid "This code compiles, runs, and prints:"
msgstr ""

#: src/ch13-01-closures.md:358
msgid ""
"```console\n"
"$ cargo run\n"
"     Locking 1 package to latest compatible version\n"
"      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/"
"listings/ch13-functional-features/listing-13-05)\n"
"   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/closure-example`\n"
"Before defining closure: [1, 2, 3]\n"
"After calling closure: [1, 2, 3, 7]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:369
msgid ""
"Note that there’s no longer a `println!` between the definition and the call "
"of the `borrows_mutably` closure: when `borrows_mutably` is defined, it "
"captures a mutable reference to `list`. We don’t use the closure again after "
"the closure is called, so the mutable borrow ends. Between the closure "
"definition and the closure call, an immutable borrow to print isn’t allowed "
"because no other borrows are allowed when there’s a mutable borrow. Try "
"adding a `println!` there to see what error message you get!"
msgstr ""

#: src/ch13-01-closures.md:377
msgid ""
"If you want to force the closure to take ownership of the values it uses in "
"the environment even though the body of the closure doesn’t strictly need "
"ownership, you can use the `move` keyword before the parameter list."
msgstr ""

#: src/ch13-01-closures.md:381
msgid ""
"This technique is mostly useful when passing a closure to a new thread to "
"move the data so that it’s owned by the new thread. We’ll discuss threads "
"and why you would want to use them in detail in Chapter 16 when we talk "
"about concurrency, but for now, let’s briefly explore spawning a new thread "
"using a closure that needs the `move` keyword. Listing 13-6 shows Listing "
"13-4 modified to print the vector in a new thread rather than in the main "
"thread:"
msgstr ""

#: src/ch13-01-closures.md:397
msgid "\"From thread: {list:?}\""
msgstr ""

#: src/ch13-01-closures.md:405
msgid ""
"We spawn a new thread, giving the thread a closure to run as an argument. "
"The closure body prints out the list. In Listing 13-4, the closure only "
"captured `list` using an immutable reference because that's the least amount "
"of access to `list` needed to print it. In this example, even though the "
"closure body still only needs an immutable reference, we need to specify "
"that `list` should be moved into the closure by putting the `move` keyword "
"at the beginning of the closure definition. The new thread might finish "
"before the rest of the main thread finishes, or the main thread might finish "
"first. If the main thread maintained ownership of `list` but ended before "
"the new thread did and dropped `list`, the immutable reference in the thread "
"would be invalid. Therefore, the compiler requires that `list` be moved into "
"the closure given to the new thread so the reference will be valid. Try "
"removing the `move` keyword or using `list` in the main thread after the "
"closure is defined to see what compiler errors you get!"
msgstr ""

#: src/ch13-01-closures.md:422
msgid ""
"<a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a> "
"<a id=\"limitations-of-the-cacher-implementation\"></a> <a id=\"moving-"
"captured-values-out-of-the-closure-and-the-fn-traits\"></a>"
msgstr ""

#: src/ch13-01-closures.md:426
msgid "Moving Captured Values Out of Closures and the `Fn` Traits"
msgstr ""

#: src/ch13-01-closures.md:428
msgid ""
"Once a closure has captured a reference or captured ownership of a value "
"from the environment where the closure is defined (thus affecting what, if "
"anything, is moved _into_ the closure), the code in the body of the closure "
"defines what happens to the references or values when the closure is "
"evaluated later (thus affecting what, if anything, is moved _out of_ the "
"closure). A closure body can do any of the following: move a captured value "
"out of the closure, mutate the captured value, neither move nor mutate the "
"value, or capture nothing from the environment to begin with."
msgstr ""

#: src/ch13-01-closures.md:437
msgid ""
"The way a closure captures and handles values from the environment affects "
"which traits the closure implements, and traits are how functions and "
"structs can specify what kinds of closures they can use. Closures will "
"automatically implement one, two, or all three of these `Fn` traits, in an "
"additive fashion, depending on how the closure’s body handles the values:"
msgstr ""

#: src/ch13-01-closures.md:443
msgid ""
"`FnOnce` applies to closures that can be called once. All closures implement "
"at least this trait, because all closures can be called. A closure that "
"moves captured values out of its body will only implement `FnOnce` and none "
"of the other `Fn` traits, because it can only be called once."
msgstr ""

#: src/ch13-01-closures.md:447
msgid ""
"`FnMut` applies to closures that don’t move captured values out of their "
"body, but that might mutate the captured values. These closures can be "
"called more than once."
msgstr ""

#: src/ch13-01-closures.md:450
msgid ""
"`Fn` applies to closures that don’t move captured values out of their body "
"and that don’t mutate captured values, as well as closures that capture "
"nothing from their environment. These closures can be called more than once "
"without mutating their environment, which is important in cases such as "
"calling a closure multiple times concurrently."
msgstr ""

#: src/ch13-01-closures.md:456
msgid ""
"Let’s look at the definition of the `unwrap_or_else` method on `Option<T>` "
"that we used in Listing 13-1:"
msgstr ""

#: src/ch13-01-closures.md:473
msgid ""
"Recall that `T` is the generic type representing the type of the value in "
"the `Some` variant of an `Option`. That type `T` is also the return type of "
"the `unwrap_or_else` function: code that calls `unwrap_or_else` on an "
"`Option<String>`, for example, will get a `String`."
msgstr ""

#: src/ch13-01-closures.md:478
msgid ""
"Next, notice that the `unwrap_or_else` function has the additional generic "
"type parameter `F`. The `F` type is the type of the parameter named `f`, "
"which is the closure we provide when calling `unwrap_or_else`."
msgstr ""

#: src/ch13-01-closures.md:482
msgid ""
"The trait bound specified on the generic type `F` is `FnOnce() -> T`, which "
"means `F` must be able to be called once, take no arguments, and return a "
"`T`. Using `FnOnce` in the trait bound expresses the constraint that "
"`unwrap_or_else` is only going to call `f` at most one time. In the body of "
"`unwrap_or_else`, we can see that if the `Option` is `Some`, `f` won’t be "
"called. If the `Option` is `None`, `f` will be called once. Because all "
"closures implement `FnOnce`, `unwrap_or_else` accepts all three kinds of "
"closures and is as flexible as it can be."
msgstr ""

#: src/ch13-01-closures.md:491
msgid ""
"Note: If what we want to do doesn’t require capturing a value from the "
"environment, we can use the name of a function rather than a closure. For "
"example, we could call `unwrap_or_else(Vec::new)` on a `Option<Vec<T>>` "
"value to get a new, empty vector if the value is `None`. The compiler "
"automatically implements whichever of the `Fn` traits is applicable for a "
"function definition."
msgstr ""

#: src/ch13-01-closures.md:498
msgid ""
"Now let’s look at the standard library method `sort_by_key` defined on "
"slices, to see how that differs from `unwrap_or_else` and why `sort_by_key` "
"uses `FnMut` instead of `FnOnce` for the trait bound. The closure gets one "
"argument in the form of a reference to the current item in the slice being "
"considered, and returns a value of type `K` that can be ordered. This "
"function is useful when you want to sort a slice by a particular attribute "
"of each item. In Listing 13-7, we have a list of `Rectangle` instances and "
"we use `sort_by_key` to order them by their `width` attribute from low to "
"high:"
msgstr ""

#: src/ch13-01-closures.md:524 src/ch13-01-closures.md:585
msgid "\"{list:#?}\""
msgstr ""

#: src/ch13-01-closures.md:530
msgid "This code prints:"
msgstr ""

#: src/ch13-01-closures.md:532
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n"
"     Running `target/debug/rectangles`\n"
"[\n"
"    Rectangle {\n"
"        width: 3,\n"
"        height: 5,\n"
"    },\n"
"    Rectangle {\n"
"        width: 7,\n"
"        height: 12,\n"
"    },\n"
"    Rectangle {\n"
"        width: 10,\n"
"        height: 1,\n"
"    },\n"
"]\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:553
msgid ""
"The reason `sort_by_key` is defined to take an `FnMut` closure is that it "
"calls the closure multiple times: once for each item in the slice. The "
"closure `|r| r.width` doesn’t capture, mutate, or move out anything from its "
"environment, so it meets the trait bound requirements."
msgstr ""

#: src/ch13-01-closures.md:558
msgid ""
"In contrast, Listing 13-8 shows an example of a closure that implements just "
"the `FnOnce` trait, because it moves a value out of the environment. The "
"compiler won’t let us use this closure with `sort_by_key`:"
msgstr ""

#: src/ch13-01-closures.md:579
msgid "\"closure called\""
msgstr ""

#: src/ch13-01-closures.md:591
msgid ""
"This is a contrived, convoluted way (that doesn’t work) to try and count the "
"number of times `sort_by_key` calls the closure when sorting `list`. This "
"code attempts to do this counting by pushing `value`—a `String` from the "
"closure’s environment—into the `sort_operations` vector. The closure "
"captures `value` then moves `value` out of the closure by transferring "
"ownership of `value` to the `sort_operations` vector. This closure can be "
"called once; trying to call it a second time wouldn’t work because `value` "
"would no longer be in the environment to be pushed into `sort_operations` "
"again! Therefore, this closure only implements `FnOnce`. When we try to "
"compile this code, we get this error that `value` can’t be moved out of the "
"closure because the closure must implement `FnMut`:"
msgstr ""

#: src/ch13-01-closures.md:603
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n"
"error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` "
"closure\n"
"  --> src/main.rs:18:30\n"
"   |\n"
"15 |     let value = String::from(\"closure called\");\n"
"   |         ----- captured outer variable\n"
"16 |\n"
"17 |     list.sort_by_key(|r| {\n"
"   |                      --- captured by this `FnMut` closure\n"
"18 |         sort_operations.push(value);\n"
"   |                              ^^^^^ move occurs because `value` has type "
"`String`, which does not implement the `Copy` trait\n"
"   |\n"
"help: consider cloning the value if the performance cost is acceptable\n"
"   |\n"
"18 |         sort_operations.push(value.clone());\n"
"   |                                   ++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0507`.\n"
"error: could not compile `rectangles` (bin \"rectangles\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch13-01-closures.md:626
msgid ""
"The error points to the line in the closure body that moves `value` out of "
"the environment. To fix this, we need to change the closure body so that it "
"doesn’t move values out of the environment. To count the number of times the "
"closure is called, keeping a counter in the environment and incrementing its "
"value in the closure body is a more straightforward way to calculate that. "
"The closure in Listing 13-9 works with `sort_by_key` because it is only "
"capturing a mutable reference to the `num_sort_operations` counter and can "
"therefore be called more than once:"
msgstr ""

#: src/ch13-01-closures.md:656
msgid "\"{list:#?}, sorted in {num_sort_operations} operations\""
msgstr ""

#: src/ch13-01-closures.md:662
msgid ""
"The `Fn` traits are important when defining or using functions or types that "
"make use of closures. In the next section, we’ll discuss iterators. Many "
"iterator methods take closure arguments, so keep these closure details in "
"mind as we continue!"
msgstr ""

#: src/ch13-02-iterators.md:3
msgid ""
"The iterator pattern allows you to perform some task on a sequence of items "
"in turn. An iterator is responsible for the logic of iterating over each "
"item and determining when the sequence has finished. When you use iterators, "
"you don’t have to reimplement that logic yourself."
msgstr ""

#: src/ch13-02-iterators.md:8
msgid ""
"In Rust, iterators are _lazy_, meaning they have no effect until you call "
"methods that consume the iterator to use it up. For example, the code in "
"Listing 13-10 creates an iterator over the items in the vector `v1` by "
"calling the `iter` method defined on `Vec<T>`. This code by itself doesn’t "
"do anything useful."
msgstr ""

#: src/ch13-02-iterators.md:26
msgid ""
"The iterator is stored in the `v1_iter` variable. Once we’ve created an "
"iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, "
"we iterated over an array using a `for` loop to execute some code on each of "
"its items. Under the hood this implicitly created and then consumed an "
"iterator, but we glossed over how exactly that works until now."
msgstr ""

#: src/ch13-02-iterators.md:32
msgid ""
"In the example in Listing 13-11, we separate the creation of the iterator "
"from the use of the iterator in the `for` loop. When the `for` loop is "
"called using the iterator in `v1_iter`, each element in the iterator is used "
"in one iteration of the loop, which prints out each value."
msgstr ""

#: src/ch13-02-iterators.md:46
msgid "\"Got: {val}\""
msgstr ""

#: src/ch13-02-iterators.md:53
msgid ""
"In languages that don’t have iterators provided by their standard libraries, "
"you would likely write this same functionality by starting a variable at "
"index 0, using that variable to index into the vector to get a value, and "
"incrementing the variable value in a loop until it reached the total number "
"of items in the vector."
msgstr ""

#: src/ch13-02-iterators.md:59
msgid ""
"Iterators handle all that logic for you, cutting down on repetitive code you "
"could potentially mess up. Iterators give you more flexibility to use the "
"same logic with many different kinds of sequences, not just data structures "
"you can index into, like vectors. Let’s examine how iterators do that."
msgstr ""

#: src/ch13-02-iterators.md:64
msgid "The `Iterator` Trait and the `next` Method"
msgstr ""

#: src/ch13-02-iterators.md:66
msgid ""
"All iterators implement a trait named `Iterator` that is defined in the "
"standard library. The definition of the trait looks like this:"
msgstr ""

#: src/ch13-02-iterators.md:75
msgid "// methods with default implementations elided\n"
msgstr ""

#: src/ch13-02-iterators.md:79
msgid ""
"Notice this definition uses some new syntax: `type Item` and `Self::Item`, "
"which are defining an _associated type_ with this trait. We’ll talk about "
"associated types in depth in Chapter 20. For now, all you need to know is "
"that this code says implementing the `Iterator` trait requires that you also "
"define an `Item` type, and this `Item` type is used in the return type of "
"the `next` method. In other words, the `Item` type will be the type returned "
"from the iterator."
msgstr ""

#: src/ch13-02-iterators.md:87
msgid ""
"The `Iterator` trait only requires implementors to define one method: the "
"`next` method, which returns one item of the iterator at a time wrapped in "
"`Some` and, when iteration is over, returns `None`."
msgstr ""

#: src/ch13-02-iterators.md:91
msgid ""
"We can call the `next` method on iterators directly; Listing 13-12 "
"demonstrates what values are returned from repeated calls to `next` on the "
"iterator created from the vector."
msgstr ""

#: src/ch13-02-iterators.md:116
msgid ""
"Note that we needed to make `v1_iter` mutable: calling the `next` method on "
"an iterator changes internal state that the iterator uses to keep track of "
"where it is in the sequence. In other words, this code _consumes_, or uses "
"up, the iterator. Each call to `next` eats up an item from the iterator. We "
"didn’t need to make `v1_iter` mutable when we used a `for` loop because the "
"loop took ownership of `v1_iter` and made it mutable behind the scenes."
msgstr ""

#: src/ch13-02-iterators.md:123
msgid ""
"Also note that the values we get from the calls to `next` are immutable "
"references to the values in the vector. The `iter` method produces an "
"iterator over immutable references. If we want to create an iterator that "
"takes ownership of `v1` and returns owned values, we can call `into_iter` "
"instead of `iter`. Similarly, if we want to iterate over mutable references, "
"we can call `iter_mut` instead of `iter`."
msgstr ""

#: src/ch13-02-iterators.md:130
msgid "Methods that Consume the Iterator"
msgstr ""

#: src/ch13-02-iterators.md:132
msgid ""
"The `Iterator` trait has a number of different methods with default "
"implementations provided by the standard library; you can find out about "
"these methods by looking in the standard library API documentation for the "
"`Iterator` trait. Some of these methods call the `next` method in their "
"definition, which is why you’re required to implement the `next` method when "
"implementing the `Iterator` trait."
msgstr ""

#: src/ch13-02-iterators.md:139
msgid ""
"Methods that call `next` are called _consuming adapters_, because calling "
"them uses up the iterator. One example is the `sum` method, which takes "
"ownership of the iterator and iterates through the items by repeatedly "
"calling `next`, thus consuming the iterator. As it iterates through, it adds "
"each item to a running total and returns the total when iteration is "
"complete. Listing 13-13 has a test illustrating a use of the `sum` method:"
msgstr ""

#: src/ch13-02-iterators.md:166
msgid ""
"We aren’t allowed to use `v1_iter` after the call to `sum` because `sum` "
"takes ownership of the iterator we call it on."
msgstr ""

#: src/ch13-02-iterators.md:169
msgid "Methods that Produce Other Iterators"
msgstr ""

#: src/ch13-02-iterators.md:171
msgid ""
"_Iterator adapters_ are methods defined on the `Iterator` trait that don’t "
"consume the iterator. Instead, they produce different iterators by changing "
"some aspect of the original iterator."
msgstr ""

#: src/ch13-02-iterators.md:175
msgid ""
"Listing 13-14 shows an example of calling the iterator adapter method `map`, "
"which takes a closure to call on each item as the items are iterated "
"through. The `map` method returns a new iterator that produces the modified "
"items. The closure here creates a new iterator in which each item from the "
"vector will be incremented by 1:"
msgstr ""

#: src/ch13-02-iterators.md:193
msgid "However, this code produces a warning:"
msgstr "하지만 이 코드는 경고를 발생시킵니다:"

#: src/ch13-02-iterators.md:195
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling iterators v0.1.0 (file:///projects/iterators)\n"
"warning: unused `Map` that must be used\n"
" --> src/main.rs:4:5\n"
"  |\n"
"4 |     v1.iter().map(|x| x + 1);\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: iterators are lazy and do nothing unless consumed\n"
"  = note: `#[warn(unused_must_use)]` on by default\n"
"help: use `let _ = ...` to ignore the resulting value\n"
"  |\n"
"4 |     let _ = v1.iter().map(|x| x + 1);\n"
"  |     +++++++\n"
"\n"
"warning: `iterators` (bin \"iterators\") generated 1 warning\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s\n"
"     Running `target/debug/iterators`\n"
"```"
msgstr ""

#: src/ch13-02-iterators.md:216
msgid ""
"The code in Listing 13-14 doesn’t do anything; the closure we’ve specified "
"never gets called. The warning reminds us why: iterator adapters are lazy, "
"and we need to consume the iterator here."
msgstr ""
"목록 13-14의 코드는 아무것도 하지 않습니다. 우리가 지정한 클로저는 절대 호출되지 않습니다. "
"경고는 그 이유를 상기시켜 줍니다. 반복자 어댑터는 지연(lazy)이며, 여기서 반복자를 소비해야 합니다."

#: src/ch13-02-iterators.md:220
msgid ""
"To fix this warning and consume the iterator, we’ll use the `collect` "
"method, which we used in Chapter 12 with `env::args` in Listing 12-1. This "
"method consumes the iterator and collects the resulting values into a "
"collection data type."
msgstr ""

#: src/ch13-02-iterators.md:225
msgid ""
"In Listing 13-15, we collect the results of iterating over the iterator "
"that’s returned from the call to `map` into a vector. This vector will end "
"up containing each item from the original vector incremented by 1."
msgstr ""

#: src/ch13-02-iterators.md:243
msgid ""
"Because `map` takes a closure, we can specify any operation we want to "
"perform on each item. This is a great example of how closures let you "
"customize some behavior while reusing the iteration behavior that the "
"`Iterator` trait provides."
msgstr ""

#: src/ch13-02-iterators.md:248
msgid ""
"You can chain multiple calls to iterator adapters to perform complex actions "
"in a readable way. But because all iterators are lazy, you have to call one "
"of the consuming adapter methods to get results from calls to iterator "
"adapters."
msgstr ""

#: src/ch13-02-iterators.md:252
msgid "Using Closures that Capture Their Environment"
msgstr ""

#: src/ch13-02-iterators.md:254
msgid ""
"Many iterator adapters take closures as arguments, and commonly the closures "
"we’ll specify as arguments to iterator adapters will be closures that "
"capture their environment."
msgstr ""

#: src/ch13-02-iterators.md:258
msgid ""
"For this example, we’ll use the `filter` method that takes a closure. The "
"closure gets an item from the iterator and returns a `bool`. If the closure "
"returns `true`, the value will be included in the iteration produced by "
"`filter`. If the closure returns `false`, the value won’t be included."
msgstr ""

#: src/ch13-02-iterators.md:263
msgid ""
"In Listing 13-16, we use `filter` with a closure that captures the "
"`shoe_size` variable from its environment to iterate over a collection of "
"`Shoe` struct instances. It will return only shoes that are the specified "
"size."
msgstr ""

#: src/ch13-02-iterators.md:289 src/ch13-02-iterators.md:308
msgid "\"sneaker\""
msgstr ""

#: src/ch13-02-iterators.md:293
msgid "\"sandal\""
msgstr ""

#: src/ch13-02-iterators.md:297 src/ch13-02-iterators.md:312
msgid "\"boot\""
msgstr ""

#: src/ch13-02-iterators.md:322
msgid ""
"The `shoes_in_size` function takes ownership of a vector of shoes and a shoe "
"size as parameters. It returns a vector containing only shoes of the "
"specified size."
msgstr ""

#: src/ch13-02-iterators.md:326
msgid ""
"In the body of `shoes_in_size`, we call `into_iter` to create an iterator "
"that takes ownership of the vector. Then we call `filter` to adapt that "
"iterator into a new iterator that only contains elements for which the "
"closure returns `true`."
msgstr ""

#: src/ch13-02-iterators.md:331
msgid ""
"The closure captures the `shoe_size` parameter from the environment and "
"compares the value with each shoe’s size, keeping only shoes of the size "
"specified. Finally, calling `collect` gathers the values returned by the "
"adapted iterator into a vector that’s returned by the function."
msgstr ""

#: src/ch13-02-iterators.md:336
msgid ""
"The test shows that when we call `shoes_in_size`, we get back only shoes "
"that have the same size as the value we specified."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:3
msgid ""
"With this new knowledge about iterators, we can improve the I/O project in "
"Chapter 12 by using iterators to make places in the code clearer and more "
"concise. Let’s look at how iterators can improve our implementation of the "
"`Config::build` function and the `search` function."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:8
msgid "Removing a `clone` Using an Iterator"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:10
msgid ""
"In Listing 12-6, we added code that took a slice of `String` values and "
"created an instance of the `Config` struct by indexing into the slice and "
"cloning the values, allowing the `Config` struct to own those values. In "
"Listing 13-17, we’ve reproduced the implementation of the `Config::build` "
"function as it was in Listing 12-23:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:127
msgid ""
"At the time, we said not to worry about the inefficient `clone` calls "
"because we would remove them in the future. Well, that time is now!"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:130
msgid ""
"We needed `clone` here because we have a slice with `String` elements in the "
"parameter `args`, but the `build` function doesn’t own `args`. To return "
"ownership of a `Config` instance, we had to clone the values from the "
"`query` and `file_path` fields of `Config` so the `Config` instance can own "
"its values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:135
msgid ""
"With our new knowledge about iterators, we can change the `build` function "
"to take ownership of an iterator as its argument instead of borrowing a "
"slice. We’ll use the iterator functionality instead of the code that checks "
"the length of the slice and indexes into specific locations. This will "
"clarify what the `Config::build` function is doing because the iterator will "
"access the values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:141
msgid ""
"Once `Config::build` takes ownership of the iterator and stops using "
"indexing operations that borrow, we can move the `String` values from the "
"iterator into `Config` rather than calling `clone` and making a new "
"allocation."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:145
msgid "Using the Returned Iterator Directly"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:147
msgid ""
"Open your I/O project’s _src/main.rs_ file, which should look like this:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:174
msgid ""
"We’ll first change the start of the `main` function that we had in Listing "
"12-24 to the code in Listing 13-18, which this time uses an iterator. This "
"won’t compile until we update `Config::build` as well."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:203
msgid ""
"The `env::args` function returns an iterator! Rather than collecting the "
"iterator values into a vector and then passing a slice to `Config::build`, "
"now we’re passing ownership of the iterator returned from `env::args` to "
"`Config::build` directly."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:208
msgid ""
"Next, we need to update the definition of `Config::build`. In your I/O "
"project’s _src/lib.rs_ file, let’s change the signature of `Config::build` "
"to look like Listing 13-19. This still won’t compile because we need to "
"update the function body."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:327
msgid ""
"The standard library documentation for the `env::args` function shows that "
"the type of the iterator it returns is `std::env::Args`, and that type "
"implements the `Iterator` trait and returns `String` values."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:331
msgid ""
"We’ve updated the signature of the `Config::build` function so the parameter "
"`args` has a generic type with the trait bounds `impl Iterator<Item = "
"String>` instead of `&[String]`. This usage of the `impl Trait` syntax we "
"discussed in the [“Traits as Parameters”](ch10-02-traits.html#traits-as-"
"parameters)<!-- ignore --> section of Chapter 10 means that `args` can be "
"any type that implements the `Iterator` trait and returns `String` items."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:338
msgid ""
"Because we’re taking ownership of `args` and we’ll be mutating `args` by "
"iterating over it, we can add the `mut` keyword into the specification of "
"the `args` parameter to make it mutable."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:342
msgid "Using `Iterator` Trait Methods Instead of Indexing"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:344
msgid ""
"Next, we’ll fix the body of `Config::build`. Because `args` implements the "
"`Iterator` trait, we know we can call the `next` method on it! Listing 13-20 "
"updates the code from Listing 12-23 to use the `next` method:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:369
#: src/ch13-03-improving-our-io-project.md:568
msgid "\"Didn't get a query string\""
msgstr ""

#: src/ch13-03-improving-our-io-project.md:374
#: src/ch13-03-improving-our-io-project.md:573
msgid "\"Didn't get a file path\""
msgstr ""

#: src/ch13-03-improving-our-io-project.md:466
msgid ""
"Remember that the first value in the return value of `env::args` is the name "
"of the program. We want to ignore that and get to the next value, so first "
"we call `next` and do nothing with the return value. Second, we call `next` "
"to get the value we want to put in the `query` field of `Config`. If `next` "
"returns a `Some`, we use a `match` to extract the value. If it returns "
"`None`, it means not enough arguments were given and we return early with an "
"`Err` value. We do the same thing for the `file_path` value."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:474
msgid "Making Code Clearer with Iterator Adapters"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:476
msgid ""
"We can also take advantage of iterators in the `search` function in our I/O "
"project, which is reproduced here in Listing 13-21 as it was in Listing "
"12-19:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:540
msgid ""
"We can write this code in a more concise way using iterator adapter methods. "
"Doing so also lets us avoid having a mutable intermediate `results` vector. "
"The functional programming style prefers to minimize the amount of mutable "
"state to make code clearer. Removing the mutable state might enable a future "
"enhancement to make searching happen in parallel, because we wouldn’t have "
"to manage concurrent access to the `results` vector. Listing 13-22 shows "
"this change:"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:660
msgid ""
"Recall that the purpose of the `search` function is to return all lines in "
"`contents` that contain the `query`. Similar to the `filter` example in "
"Listing 13-16, this code uses the `filter` adapter to keep only the lines "
"that `line.contains(query)` returns `true` for. We then collect the matching "
"lines into another vector with `collect`. Much simpler! Feel free to make "
"the same change to use iterator methods in the `search_case_insensitive` "
"function as well."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:668
msgid "Choosing Between Loops or Iterators"
msgstr ""

#: src/ch13-03-improving-our-io-project.md:670
msgid ""
"The next logical question is which style you should choose in your own code "
"and why: the original implementation in Listing 13-21 or the version using "
"iterators in Listing 13-22. Most Rust programmers prefer to use the iterator "
"style. It’s a bit tougher to get the hang of at first, but once you get a "
"feel for the various iterator adapters and what they do, iterators can be "
"easier to understand. Instead of fiddling with the various bits of looping "
"and building new vectors, the code focuses on the high-level objective of "
"the loop. This abstracts away some of the commonplace code so it’s easier to "
"see the concepts that are unique to this code, such as the filtering "
"condition each element in the iterator must pass."
msgstr ""

#: src/ch13-03-improving-our-io-project.md:681
msgid ""
"But are the two implementations truly equivalent? The intuitive assumption "
"might be that the more low-level loop will be faster. Let’s talk about "
"performance."
msgstr ""

#: src/ch13-04-performance.md:3
msgid ""
"To determine whether to use loops or iterators, you need to know which "
"implementation is faster: the version of the `search` function with an "
"explicit `for` loop or the version with iterators."
msgstr ""

#: src/ch13-04-performance.md:7
msgid ""
"We ran a benchmark by loading the entire contents of _The Adventures of "
"Sherlock Holmes_ by Sir Arthur Conan Doyle into a `String` and looking for "
"the word _the_ in the contents. Here are the results of the benchmark on the "
"version of `search` using the `for` loop and the version using iterators:"
msgstr ""

#: src/ch13-04-performance.md:17
msgid ""
"The two implementations have similar performance! We won’t explain the "
"benchmark code here, because the point is not to prove that the two versions "
"are equivalent but to get a general sense of how these two implementations "
"compare performance-wise."
msgstr ""

#: src/ch13-04-performance.md:22
msgid ""
"For a more comprehensive benchmark, you should check using various texts of "
"various sizes as the `contents`, different words and words of different "
"lengths as the `query`, and all kinds of other variations. The point is "
"this: iterators, although a high-level abstraction, get compiled down to "
"roughly the same code as if you’d written the lower-level code yourself. "
"Iterators are one of Rust’s _zero-cost abstractions_, by which we mean using "
"the abstraction imposes no additional runtime overhead. This is analogous to "
"how Bjarne Stroustrup, the original designer and implementor of C++, defines "
"_zero-overhead_ in “Foundations of C++” (2012):"
msgstr ""

#: src/ch13-04-performance.md:32
msgid ""
"In general, C++ implementations obey the zero-overhead principle: What you "
"don’t use, you don’t pay for. And further: What you do use, you couldn’t "
"hand code any better."
msgstr ""

#: src/ch13-04-performance.md:36
msgid ""
"As another example, the following code is taken from an audio decoder. The "
"decoding algorithm uses the linear prediction mathematical operation to "
"estimate future values based on a linear function of the previous samples. "
"This code uses an iterator chain to do some math on three variables in "
"scope: a `buffer` slice of data, an array of 12 `coefficients`, and an "
"amount by which to shift data in `qlp_shift`. We’ve declared the variables "
"within this example but not given them any values; although this code "
"doesn’t have much meaning outside of its context, it’s still a concise, real-"
"world example of how Rust translates high-level ideas to low-level code."
msgstr ""

#: src/ch13-04-performance.md:61
msgid ""
"To calculate the value of `prediction`, this code iterates through each of "
"the 12 values in `coefficients` and uses the `zip` method to pair the "
"coefficient values with the previous 12 values in `buffer`. Then, for each "
"pair, we multiply the values together, sum all the results, and shift the "
"bits in the sum `qlp_shift` bits to the right."
msgstr ""

#: src/ch13-04-performance.md:67
msgid ""
"Calculations in applications like audio decoders often prioritize "
"performance most highly. Here, we’re creating an iterator, using two "
"adapters, and then consuming the value. What assembly code would this Rust "
"code compile to? Well, as of this writing, it compiles down to the same "
"assembly you’d write by hand. There’s no loop at all corresponding to the "
"iteration over the values in `coefficients`: Rust knows that there are 12 "
"iterations, so it “unrolls” the loop. _Unrolling_ is an optimization that "
"removes the overhead of the loop controlling code and instead generates "
"repetitive code for each iteration of the loop."
msgstr ""

#: src/ch13-04-performance.md:77
msgid ""
"All of the coefficients get stored in registers, which means accessing the "
"values is very fast. There are no bounds checks on the array access at "
"runtime. All these optimizations that Rust is able to apply make the "
"resulting code extremely efficient. Now that you know this, you can use "
"iterators and closures without fear! They make code seem like it’s higher "
"level but don’t impose a runtime performance penalty for doing so."
msgstr ""

#: src/ch13-04-performance.md:86
msgid ""
"Closures and iterators are Rust features inspired by functional programming "
"language ideas. They contribute to Rust’s capability to clearly express high-"
"level ideas at low-level performance. The implementations of closures and "
"iterators are such that runtime performance is not affected. This is part of "
"Rust’s goal to strive to provide zero-cost abstractions."
msgstr ""

#: src/ch13-04-performance.md:92
msgid ""
"Now that we’ve improved the expressiveness of our I/O project, let’s look at "
"some more features of `cargo` that will help us share the project with the "
"world."
msgstr ""

#: src/ch14-00-more-about-cargo.md:1
msgid "More About Cargo and Crates.io"
msgstr ""

#: src/ch14-00-more-about-cargo.md:3
msgid ""
"So far we’ve used only the most basic features of Cargo to build, run, and "
"test our code, but it can do a lot more. In this chapter, we’ll discuss some "
"of its other, more advanced features to show you how to do the following:"
msgstr ""

#: src/ch14-00-more-about-cargo.md:7
msgid "Customize your build through release profiles"
msgstr ""

#: src/ch14-00-more-about-cargo.md:8
msgid "Publish libraries on [crates.io](https://crates.io/)<!-- ignore -->"
msgstr ""

#: src/ch14-00-more-about-cargo.md:9
msgid "Organize large projects with workspaces"
msgstr ""

#: src/ch14-00-more-about-cargo.md:10
msgid "Install binaries from [crates.io](https://crates.io/)<!-- ignore -->"
msgstr ""

#: src/ch14-00-more-about-cargo.md:11
msgid "Extend Cargo using custom commands"
msgstr ""

#: src/ch14-00-more-about-cargo.md:13
msgid ""
"Cargo can do even more than the functionality we cover in this chapter, so "
"for a full explanation of all its features, see [its documentation](https://"
"doc.rust-lang.org/cargo/)."
msgstr ""

#: src/ch14-01-release-profiles.md:3
msgid ""
"In Rust, _release profiles_ are predefined and customizable profiles with "
"different configurations that allow a programmer to have more control over "
"various options for compiling code. Each profile is configured independently "
"of the others."
msgstr ""

#: src/ch14-01-release-profiles.md:8
msgid ""
"Cargo has two main profiles: the `dev` profile Cargo uses when you run "
"`cargo build` and the `release` profile Cargo uses when you run `cargo build "
"--release`. The `dev` profile is defined with good defaults for development, "
"and the `release` profile has good defaults for release builds."
msgstr ""

#: src/ch14-01-release-profiles.md:13
msgid "These profile names might be familiar from the output of your builds:"
msgstr ""

#: src/ch14-01-release-profiles.md:29
msgid ""
"The `dev` and `release` are these different profiles used by the compiler."
msgstr ""

#: src/ch14-01-release-profiles.md:31
msgid ""
"Cargo has default settings for each of the profiles that apply when you "
"haven't explicitly added any `[profile.*]` sections in the project’s "
"_Cargo.toml_ file. By adding `[profile.*]` sections for any profile you want "
"to customize, you override any subset of the default settings. For example, "
"here are the default values for the `opt-level` setting for the `dev` and "
"`release` profiles:"
msgstr ""

#: src/ch14-01-release-profiles.md:47
msgid ""
"The `opt-level` setting controls the number of optimizations Rust will apply "
"to your code, with a range of 0 to 3. Applying more optimizations extends "
"compiling time, so if you’re in development and compiling your code often, "
"you’ll want fewer optimizations to compile faster even if the resulting code "
"runs slower. The default `opt-level` for `dev` is therefore `0`. When you’re "
"ready to release your code, it’s best to spend more time compiling. You’ll "
"only compile in release mode once, but you’ll run the compiled program many "
"times, so release mode trades longer compile time for code that runs faster. "
"That is why the default `opt-level` for the `release` profile is `3`."
msgstr ""

#: src/ch14-01-release-profiles.md:57
msgid ""
"You can override a default setting by adding a different value for it in "
"_Cargo.toml_. For example, if we want to use optimization level 1 in the "
"development profile, we can add these two lines to our project’s "
"_Cargo.toml_ file:"
msgstr ""

#: src/ch14-01-release-profiles.md:69
msgid ""
"This code overrides the default setting of `0`. Now when we run `cargo "
"build`, Cargo will use the defaults for the `dev` profile plus our "
"customization to `opt-level`. Because we set `opt-level` to `1`, Cargo will "
"apply more optimizations than the default, but not as many as in a release "
"build."
msgstr ""

#: src/ch14-01-release-profiles.md:74
msgid ""
"For the full list of configuration options and defaults for each profile, "
"see [Cargo’s documentation](https://doc.rust-lang.org/cargo/reference/"
"profiles.html)."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:3
msgid ""
"We’ve used packages from [crates.io](https://crates.io/)<!-- ignore --> as "
"dependencies of our project, but you can also share your code with other "
"people by publishing your own packages. The crate registry at [crates.io]"
"(https://crates.io/)<!-- ignore --> distributes the source code of your "
"packages, so it primarily hosts code that is open source."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:9
msgid ""
"Rust and Cargo have features that make your published package easier for "
"people to find and use. We’ll talk about some of these features next and "
"then explain how to publish a package."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:13
msgid "Making Useful Documentation Comments"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:15
msgid ""
"Accurately documenting your packages will help other users know how and when "
"to use them, so it’s worth investing the time to write documentation. In "
"Chapter 3, we discussed how to comment Rust code using two slashes, `//`. "
"Rust also has a particular kind of comment for documentation, known "
"conveniently as a _documentation comment_, that will generate HTML "
"documentation. The HTML displays the contents of documentation comments for "
"public API items intended for programmers interested in knowing how to _use_ "
"your crate as opposed to how your crate is _implemented_."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:24
msgid ""
"Documentation comments use three slashes, `///`, instead of two and support "
"Markdown notation for formatting the text. Place documentation comments just "
"before the item they’re documenting. Listing 14-1 shows documentation "
"comments for an `add_one` function in a crate named `my_crate`."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:32
msgid ""
"/// Adds one to the number given.\n"
"///\n"
"/// # Examples\n"
"///\n"
"/// ```\n"
"/// let arg = 5;\n"
"/// let answer = my_crate::add_one(arg);\n"
"///\n"
"/// assert_eq!(6, answer);\n"
"/// ```\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:49
msgid ""
"Here, we give a description of what the `add_one` function does, start a "
"section with the heading `Examples`, and then provide code that demonstrates "
"how to use the `add_one` function. We can generate the HTML documentation "
"from this documentation comment by running `cargo doc`. This command runs "
"the `rustdoc` tool distributed with Rust and puts the generated HTML "
"documentation in the _target/doc_ directory."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:56
msgid ""
"For convenience, running `cargo doc --open` will build the HTML for your "
"current crate’s documentation (as well as the documentation for all of your "
"crate’s dependencies) and open the result in a web browser. Navigate to the "
"`add_one` function and you’ll see how the text in the documentation comments "
"is rendered, as shown in Figure 14-1:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:64
msgid ""
"<span class=\"caption\">Figure 14-1: HTML documentation for the `add_one` "
"function</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:67
msgid "Commonly Used Sections"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:69
msgid ""
"We used the `# Examples` Markdown heading in Listing 14-1 to create a "
"section in the HTML with the title “Examples.” Here are some other sections "
"that crate authors commonly use in their documentation:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:73
msgid ""
"**Panics**: The scenarios in which the function being documented could "
"panic. Callers of the function who don’t want their programs to panic should "
"make sure they don’t call the function in these situations."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:76
msgid ""
"**Errors**: If the function returns a `Result`, describing the kinds of "
"errors that might occur and what conditions might cause those errors to be "
"returned can be helpful to callers so they can write code to handle the "
"different kinds of errors in different ways."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:80
msgid ""
"**Safety**: If the function is `unsafe` to call (we discuss unsafety in "
"Chapter 20), there should be a section explaining why the function is unsafe "
"and covering the invariants that the function expects callers to uphold."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:84
msgid ""
"Most documentation comments don’t need all of these sections, but this is a "
"good checklist to remind you of the aspects of your code users will be "
"interested in knowing about."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:88
msgid "Documentation Comments as Tests"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:90
msgid ""
"Adding example code blocks in your documentation comments can help "
"demonstrate how to use your library, and doing so has an additional bonus: "
"running `cargo test` will run the code examples in your documentation as "
"tests! Nothing is better than documentation with examples. But nothing is "
"worse than examples that don’t work because the code has changed since the "
"documentation was written. If we run `cargo test` with the documentation for "
"the `add_one` function from Listing 14-1, we will see a section in the test "
"results like this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:113
msgid ""
"Now if we change either the function or the example so the `assert_eq!` in "
"the example panics and run `cargo test` again, we’ll see that the doc tests "
"catch that the example and the code are out of sync with each other!"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:117
msgid "Commenting Contained Items"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:119
msgid ""
"The style of doc comment `//!` adds documentation to the item that contains "
"the comments rather than to the items following the comments. We typically "
"use these doc comments inside the crate root file (_src/lib.rs_ by "
"convention) or inside a module to document the crate or the module as a "
"whole."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:124
msgid ""
"For example, to add documentation that describes the purpose of the "
"`my_crate` crate that contains the `add_one` function, we add documentation "
"comments that start with `//!` to the beginning of the _src/lib.rs_ file, as "
"shown in Listing 14-2:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:132
msgid ""
"//! # My Crate\n"
"//!\n"
"//! `my_crate` is a collection of utilities to make performing certain\n"
"//! calculations more convenient.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:136
msgid ""
"/// Adds one to the number given.\n"
"// --snip--\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:139
#: src/ch14-02-publishing-to-crates-io.md:141
#: src/ch14-02-publishing-to-crates-io.md:145 src/ch21-02-multithreaded.md:615
#: src/ch21-02-multithreaded.md:617 src/ch21-02-multithreaded.md:619
#: src/ch21-02-multithreaded.md:714 src/ch21-02-multithreaded.md:716
#: src/ch21-02-multithreaded.md:718 src/ch21-02-multithreaded.md:823
#: src/ch21-02-multithreaded.md:825 src/ch21-02-multithreaded.md:827
#: src/ch21-02-multithreaded.md:890 src/ch21-02-multithreaded.md:892
#: src/ch21-02-multithreaded.md:894 src/ch21-02-multithreaded.md:1011
#: src/ch21-02-multithreaded.md:1013 src/ch21-02-multithreaded.md:1015
#: src/ch21-02-multithreaded.md:1098 src/ch21-02-multithreaded.md:1100
#: src/ch21-02-multithreaded.md:1102 src/ch21-02-multithreaded.md:1182
#: src/ch21-02-multithreaded.md:1184 src/ch21-02-multithreaded.md:1186
#: src/ch21-02-multithreaded.md:1339 src/ch21-02-multithreaded.md:1341
#: src/ch21-02-multithreaded.md:1343
#: src/ch21-03-graceful-shutdown-and-cleanup.md:46
#: src/ch21-03-graceful-shutdown-and-cleanup.md:48
#: src/ch21-03-graceful-shutdown-and-cleanup.md:50
#: src/ch21-03-graceful-shutdown-and-cleanup.md:182
#: src/ch21-03-graceful-shutdown-and-cleanup.md:184
#: src/ch21-03-graceful-shutdown-and-cleanup.md:186
#: src/ch21-03-graceful-shutdown-and-cleanup.md:286
#: src/ch21-03-graceful-shutdown-and-cleanup.md:288
#: src/ch21-03-graceful-shutdown-and-cleanup.md:290
#: src/ch21-03-graceful-shutdown-and-cleanup.md:380
#: src/ch21-03-graceful-shutdown-and-cleanup.md:382
#: src/ch21-03-graceful-shutdown-and-cleanup.md:384
msgid "///\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:140
msgid "/// # Examples\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:142
#: src/ch14-02-publishing-to-crates-io.md:147
msgid "/// ```\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:143
msgid "/// let arg = 5;\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:144
msgid "/// let answer = my_crate::add_one(arg);\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:146
msgid "/// assert_eq!(6, answer);\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:155
msgid ""
"Notice there isn’t any code after the last line that begins with `//!`. "
"Because we started the comments with `//!` instead of `///`, we’re "
"documenting the item that contains this comment rather than an item that "
"follows this comment. In this case, that item is the _src/lib.rs_ file, "
"which is the crate root. These comments describe the entire crate."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:161
msgid ""
"When we run `cargo doc --open`, these comments will display on the front "
"page of the documentation for `my_crate` above the list of public items in "
"the crate, as shown in Figure 14-2:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:167
msgid ""
"<span class=\"caption\">Figure 14-2: Rendered documentation for `my_crate`, "
"including the comment describing the crate as a whole</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:170
msgid ""
"Documentation comments within items are useful for describing crates and "
"modules especially. Use them to explain the overall purpose of the container "
"to help your users understand the crate’s organization."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:174
msgid "Exporting a Convenient Public API with `pub use`"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:176
msgid ""
"The structure of your public API is a major consideration when publishing a "
"crate. People who use your crate are less familiar with the structure than "
"you are and might have difficulty finding the pieces they want to use if "
"your crate has a large module hierarchy."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:181
msgid ""
"In Chapter 7, we covered how to make items public using the `pub` keyword, "
"and bring items into a scope with the `use` keyword. However, the structure "
"that makes sense to you while you’re developing a crate might not be very "
"convenient for your users. You might want to organize your structs in a "
"hierarchy containing multiple levels, but then people who want to use a type "
"you’ve defined deep in the hierarchy might have trouble finding out that "
"type exists. They might also be annoyed at having to enter `use` "
"`my_crate::some_module::another_module::UsefulType;` rather than `use` "
"`my_crate::UsefulType;`."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:191
msgid ""
"The good news is that if the structure _isn’t_ convenient for others to use "
"from another library, you don’t have to rearrange your internal "
"organization: instead, you can re-export items to make a public structure "
"that’s different from your private structure by using `pub use`. Re-"
"exporting takes a public item in one location and makes it public in another "
"location, as if it were defined in the other location instead."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:198
msgid ""
"For example, say we made a library named `art` for modeling artistic "
"concepts. Within this library are two modules: a `kinds` module containing "
"two enums named `PrimaryColor` and `SecondaryColor` and a `utils` module "
"containing a function named `mix`, as shown in Listing 14-3:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:206
#: src/ch14-02-publishing-to-crates-io.md:288
msgid ""
"//! # Art\n"
"//!\n"
"//! A library for modeling artistic concepts.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:211
#: src/ch14-02-publishing-to-crates-io.md:298
msgid "/// The primary colors according to the RYB color model.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:218
#: src/ch14-02-publishing-to-crates-io.md:305
msgid "/// The secondary colors according to the RYB color model.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:229
msgid ""
"/// Combines two primary colors in equal amounts to create\n"
"    /// a secondary color.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:240
msgid ""
"Figure 14-3 shows what the front page of the documentation for this crate "
"generated by `cargo doc` would look like:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:245
msgid ""
"<span class=\"caption\">Figure 14-3: Front page of the documentation for "
"`art` that lists the `kinds` and `utils` modules</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:248
msgid ""
"Note that the `PrimaryColor` and `SecondaryColor` types aren’t listed on the "
"front page, nor is the `mix` function. We have to click `kinds` and `utils` "
"to see them."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:252
msgid ""
"Another crate that depends on this library would need `use` statements that "
"bring the items from `art` into scope, specifying the module structure "
"that’s currently defined. Listing 14-4 shows an example of a crate that uses "
"the `PrimaryColor` and `mix` items from the `art` crate:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:272
msgid ""
"The author of the code in Listing 14-4, which uses the `art` crate, had to "
"figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the "
"`utils` module. The module structure of the `art` crate is more relevant to "
"developers working on the `art` crate than to those using it. The internal "
"structure doesn’t contain any useful information for someone trying to "
"understand how to use the `art` crate, but rather causes confusion because "
"developers who use it have to figure out where to look, and must specify the "
"module names in the `use` statements."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:281
msgid ""
"To remove the internal organization from the public API, we can modify the "
"`art` crate code in Listing 14-3 to add `pub use` statements to re-export "
"the items at the top level, as shown in Listing 14-5:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:317
msgid "/// Combines two primary colors in equal amounts to create\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:318
msgid "/// a secondary color.\n"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:327
msgid ""
"The API documentation that `cargo doc` generates for this crate will now "
"list and link re-exports on the front page, as shown in Figure 14-4, making "
"the `PrimaryColor` and `SecondaryColor` types and the `mix` function easier "
"to find."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:333
msgid ""
"<span class=\"caption\">Figure 14-4: The front page of the documentation for "
"`art` that lists the re-exports</span>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:336
msgid ""
"The `art` crate users can still see and use the internal structure from "
"Listing 14-3 as demonstrated in Listing 14-4, or they can use the more "
"convenient structure in Listing 14-5, as shown in Listing 14-6:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:356
msgid ""
"In cases where there are many nested modules, re-exporting the types at the "
"top level with `pub use` can make a significant difference in the experience "
"of people who use the crate. Another common use of `pub use` is to re-export "
"definitions of a dependency in the current crate to make that crate's "
"definitions part of your crate’s public API."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:362
msgid ""
"Creating a useful public API structure is more of an art than a science, and "
"you can iterate to find the API that works best for your users. Choosing "
"`pub use` gives you flexibility in how you structure your crate internally "
"and decouples that internal structure from what you present to your users. "
"Look at some of the code of crates you’ve installed to see if their internal "
"structure differs from their public API."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:369
msgid "Setting Up a Crates.io Account"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:371
msgid ""
"Before you can publish any crates, you need to create an account on "
"[crates.io](https://crates.io/)<!-- ignore --> and get an API token. To do "
"so, visit the home page at [crates.io](https://crates.io/)<!-- ignore --> "
"and log in via a GitHub account. (The GitHub account is currently a "
"requirement, but the site might support other ways of creating an account in "
"the future.) Once you’re logged in, visit your account settings at [https://"
"crates.io/me/](https://crates.io/me/)<!-- ignore --> and retrieve your API "
"key. Then run the `cargo login` command and paste your API key when "
"prompted, like this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:385
msgid ""
"This command will inform Cargo of your API token and store it locally in "
"_~/.cargo/credentials_. Note that this token is a _secret_: do not share it "
"with anyone else. If you do share it with anyone for any reason, you should "
"revoke it and generate a new token on [crates.io](https://crates.io/)<!-- "
"ignore\n"
"-->."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:391
msgid "Adding Metadata to a New Crate"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:393
msgid ""
"Let’s say you have a crate you want to publish. Before publishing, you’ll "
"need to add some metadata in the `[package]` section of the crate’s "
"_Cargo.toml_ file."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:397
msgid ""
"Your crate will need a unique name. While you’re working on a crate locally, "
"you can name a crate whatever you’d like. However, crate names on [crates.io]"
"(https://crates.io/)<!-- ignore --> are allocated on a first-come, first-"
"served basis. Once a crate name is taken, no one else can publish a crate "
"with that name. Before attempting to publish a crate, search for the name "
"you want to use. If the name has been used, you will need to find another "
"name and edit the `name` field in the _Cargo.toml_ file under the "
"`[package]` section to use the new name for publishing, like so:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:408
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:413
msgid ""
"Even if you’ve chosen a unique name, when you run `cargo publish` to publish "
"the crate at this point, you’ll get a warning and then an error:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:422
msgid ""
"```console\n"
"$ cargo publish\n"
"    Updating crates.io index\n"
"warning: manifest has no description, license, license-file, documentation, "
"homepage or repository.\n"
"See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata "
"for more info.\n"
"--snip--\n"
"error: failed to publish to registry at https://crates.io\n"
"\n"
"Caused by:\n"
"  the remote server responded with an error (status 400 Bad Request): "
"missing or empty metadata fields: description, license. Please see https://"
"doc.rust-lang.org/cargo/reference/manifest.html for more information on "
"configuring these field\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:434
msgid ""
"This errors because you’re missing some crucial information: a description "
"and license are required so people will know what your crate does and under "
"what terms they can use it. In _Cargo.toml_, add a description that's just a "
"sentence or two, because it will appear with your crate in search results. "
"For the `license` field, you need to give a _license identifier value_. The "
"[Linux Foundation’s Software Package Data Exchange (SPDX)](http://spdx.org/"
"licenses/) lists the identifiers you can use for this value. For example, to "
"specify that you’ve licensed your crate using the MIT License, add the `MIT` "
"identifier:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:445
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"license = \"MIT\"\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:451
msgid ""
"If you want to use a license that doesn’t appear in the SPDX, you need to "
"place the text of that license in a file, include the file in your project, "
"and then use `license-file` to specify the name of that file instead of "
"using the `license` key."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:456
msgid ""
"Guidance on which license is appropriate for your project is beyond the "
"scope of this book. Many people in the Rust community license their projects "
"in the same way as Rust by using a dual license of `MIT OR Apache-2.0`. This "
"practice demonstrates that you can also specify multiple license identifiers "
"separated by `OR` to have multiple licenses for your project."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:462
msgid ""
"With a unique name, the version, your description, and a license added, the "
"_Cargo.toml_ file for a project that is ready to publish might look like "
"this:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:467
msgid ""
"```toml\n"
"[package]\n"
"name = \"guessing_game\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"description = \"A fun game where you guess what number the computer has "
"chosen.\"\n"
"license = \"MIT OR Apache-2.0\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:478
msgid ""
"[Cargo’s documentation](https://doc.rust-lang.org/cargo/) describes other "
"metadata you can specify to ensure others can discover and use your crate "
"more easily."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:482
msgid "Publishing to Crates.io"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:484
msgid ""
"Now that you’ve created an account, saved your API token, chosen a name for "
"your crate, and specified the required metadata, you’re ready to publish! "
"Publishing a crate uploads a specific version to [crates.io](https://"
"crates.io/)<!-- ignore --> for others to use."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:489
msgid ""
"Be careful, because a publish is _permanent_. The version can never be "
"overwritten, and the code cannot be deleted. One major goal of [crates.io]"
"(https://crates.io/)<!-- ignore --> is to act as a permanent archive of code "
"so that builds of all projects that depend on crates from [crates.io]"
"(https://crates.io/)<!-- ignore --> will continue to work. Allowing version "
"deletions would make fulfilling that goal impossible. However, there is no "
"limit to the number of crate versions you can publish."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:497
msgid "Run the `cargo publish` command again. It should succeed now:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:505
msgid ""
"```console\n"
"$ cargo publish\n"
"    Updating crates.io index\n"
"   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"   Compiling guessing_game v0.1.0\n"
"(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s\n"
"   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"```"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:516
msgid ""
"Congratulations! You’ve now shared your code with the Rust community, and "
"anyone can easily add your crate as a dependency of their project."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:519
msgid "Publishing a New Version of an Existing Crate"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:521
msgid ""
"When you’ve made changes to your crate and are ready to release a new "
"version, you change the `version` value specified in your _Cargo.toml_ file "
"and republish. Use the [Semantic Versioning rules](http://semver.org/) to "
"decide what an appropriate next version number is based on the kinds of "
"changes you’ve made. Then run `cargo publish` to upload the new version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:529
msgid "<a id=\"removing-versions-from-cratesio-with-cargo-yank\"></a>"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:531
msgid "Deprecating Versions from Crates.io with `cargo yank`"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:533
msgid ""
"Although you can’t remove previous versions of a crate, you can prevent any "
"future projects from adding them as a new dependency. This is useful when a "
"crate version is broken for one reason or another. In such situations, Cargo "
"supports _yanking_ a crate version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:538
msgid ""
"Yanking a version prevents new projects from depending on that version while "
"allowing all existing projects that depend on it to continue. Essentially, a "
"yank means that all projects with a _Cargo.lock_ will not break, and any "
"future _Cargo.lock_ files generated will not use the yanked version."
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:543
msgid ""
"To yank a version of a crate, in the directory of the crate that you’ve "
"previously published, run `cargo yank` and specify which version you want to "
"yank. For example, if we've published a crate named `guessing_game` version "
"1.0.1 and we want to yank it, in the project directory for `guessing_game` "
"we'd run:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:560
msgid ""
"By adding `--undo` to the command, you can also undo a yank and allow "
"projects to start depending on a version again:"
msgstr ""

#: src/ch14-02-publishing-to-crates-io.md:569
msgid ""
"A yank _does not_ delete any code. It cannot, for example, delete "
"accidentally uploaded secrets. If that happens, you must reset those secrets "
"immediately."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:3
msgid ""
"In Chapter 12, we built a package that included a binary crate and a library "
"crate. As your project develops, you might find that the library crate "
"continues to get bigger and you want to split your package further into "
"multiple library crates. Cargo offers a feature called _workspaces_ that can "
"help manage multiple related packages that are developed in tandem."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:9
msgid "Creating a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:11
msgid ""
"A _workspace_ is a set of packages that share the same _Cargo.lock_ and "
"output directory. Let’s make a project using a workspace—we’ll use trivial "
"code so we can concentrate on the structure of the workspace. There are "
"multiple ways to structure a workspace, so we'll just show one common way. "
"We’ll have a workspace containing a binary and two libraries. The binary, "
"which will provide the main functionality, will depend on the two libraries. "
"One library will provide an `add_one` function, and a second library an "
"`add_two` function. These three crates will be part of the same workspace. "
"We’ll start by creating a new directory for the workspace:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:26
msgid ""
"Next, in the _add_ directory, we create the _Cargo.toml_ file that will "
"configure the entire workspace. This file won’t have a `[package]` section. "
"Instead, it will start with a `[workspace]` section that will allow us to "
"add members to the workspace. We also make a point to use the latest and "
"greatest version of Cargo’s resolver algorithm in our workspace by setting "
"the `resolver` to `\"2\"`."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:35
msgid ""
"```toml\n"
"[workspace]\n"
"resolver = \"2\"\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:40
msgid ""
"Next, we’ll create the `adder` binary crate by running `cargo new` within "
"the _add_ directory:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:50
msgid ""
"```console\n"
"$ cargo new adder\n"
"    Creating binary (application) `adder` package\n"
"      Adding `adder` as member of workspace at `file:///projects/add`\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:56
msgid ""
"Running `cargo new` inside a workspace also automatically adds the newly "
"created package to the `members` key in the `[workspace]` definition in the "
"workspace `Cargo.toml`, like this:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:60
msgid ""
"```toml\n"
"[workspace]\n"
"resolver = \"2\"\n"
"members = [\"adder\"]\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:66
msgid ""
"At this point, we can build the workspace by running `cargo build`. The "
"files in your _add_ directory should look like this:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:79
msgid ""
"The workspace has one _target_ directory at the top level that the compiled "
"artifacts will be placed into; the `adder` package doesn’t have its own "
"_target_ directory. Even if we were to run `cargo build` from inside the "
"_adder_ directory, the compiled artifacts would still end up in _add/target_ "
"rather than _add/adder/target_. Cargo structures the _target_ directory in a "
"workspace like this because the crates in a workspace are meant to depend on "
"each other. If each crate had its own _target_ directory, each crate would "
"have to recompile each of the other crates in the workspace to place the "
"artifacts in its own _target_ directory. By sharing one _target_ directory, "
"the crates can avoid unnecessary rebuilding."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:90
msgid "Creating the Second Package in the Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:92
msgid ""
"Next, let’s create another member package in the workspace and call it "
"`add_one`. Change the top-level _Cargo.toml_ to specify the _add_one_ path "
"in the `members` list:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:98
msgid ""
"```toml\n"
"[workspace]\n"
"resolver = \"2\"\n"
"members = [\"adder\", \"add_one\"]\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:104
msgid "Then generate a new library crate named `add_one`:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:113
msgid ""
"```console\n"
"$ cargo new add_one --lib\n"
"    Creating library `add_one` package\n"
"      Adding `add_one` as member of workspace at `file:///projects/add`\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:119
msgid "Your _add_ directory should now have these directories and files:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:135
msgid "In the _add_one/src/lib.rs_ file, let’s add an `add_one` function:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:137 src/ch14-03-cargo-workspaces.md:306
msgid "<span class=\"filename\">Filename: add_one/src/lib.rs</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:145
msgid ""
"Now we can have the `adder` package with our binary depend on the `add_one` "
"package that has our library. First, we’ll need to add a path dependency on "
"`add_one` to _adder/Cargo.toml_."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:149
msgid "<span class=\"filename\">Filename: adder/Cargo.toml</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:151
msgid ""
"```toml\n"
"[dependencies]\n"
"add_one = { path = \"../add_one\" }\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:156
msgid ""
"Cargo doesn’t assume that crates in a workspace will depend on each other, "
"so we need to be explicit about the dependency relationships."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:159
msgid ""
"Next, let’s use the `add_one` function (from the `add_one` crate) in the "
"`adder` crate. Open the _adder/src/main.rs_ file and change the `main` "
"function to call the `add_one` function, as in Listing 14-7."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:168
msgid "\"Hello, world! {num} plus one is {}!\""
msgstr ""

#: src/ch14-03-cargo-workspaces.md:174
msgid ""
"Let’s build the workspace by running `cargo build` in the top-level _add_ "
"directory!"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:183
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:190
msgid ""
"To run the binary crate from the _add_ directory, we can specify which "
"package in the workspace we want to run by using the `-p` argument and the "
"package name with `cargo run`:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:207
msgid ""
"This runs the code in _adder/src/main.rs_, which depends on the `add_one` "
"crate."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:209
msgid "Depending on an External Package in a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:211
msgid ""
"Notice that the workspace has only one _Cargo.lock_ file at the top level, "
"rather than having a _Cargo.lock_ in each crate’s directory. This ensures "
"that all crates are using the same version of all dependencies. If we add "
"the `rand` package to the _adder/Cargo.toml_ and _add_one/Cargo.toml_ files, "
"Cargo will resolve both of those to one version of `rand` and record that in "
"the one _Cargo.lock_. Making all crates in the workspace use the same "
"dependencies means the crates will always be compatible with each other. "
"Let’s add the `rand` crate to the `[dependencies]` section in the _add_one/"
"Cargo.toml_ file so we can use the `rand` crate in the `add_one` crate:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:227
msgid "<span class=\"filename\">Filename: add_one/Cargo.toml</span>"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:234
msgid ""
"We can now add `use rand;` to the _add_one/src/lib.rs_ file, and building "
"the whole workspace by running `cargo build` in the _add_ directory will "
"bring in and compile the `rand` crate. We will get one warning because we "
"aren’t referring to the `rand` we brought into scope:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:245
msgid ""
"```console\n"
"$ cargo build\n"
"    Updating crates.io index\n"
"  Downloaded rand v0.8.5\n"
"   --snip--\n"
"   Compiling rand v0.8.5\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"warning: unused import: `rand`\n"
" --> add_one/src/lib.rs:1:5\n"
"  |\n"
"1 | use rand;\n"
"  |     ^^^^\n"
"  |\n"
"  = note: `#[warn(unused_imports)]` on by default\n"
"\n"
"warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p "
"add_one` to apply 1 suggestion)\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:265
msgid ""
"The top-level _Cargo.lock_ now contains information about the dependency of "
"`add_one` on `rand`. However, even though `rand` is used somewhere in the "
"workspace, we can’t use it in other crates in the workspace unless we add "
"`rand` to their _Cargo.toml_ files as well. For example, if we add `use "
"rand;` to the _adder/src/main.rs_ file for the `adder` package, we’ll get an "
"error:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:277
msgid ""
"```console\n"
"$ cargo build\n"
"  --snip--\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"error[E0432]: unresolved import `rand`\n"
" --> adder/src/main.rs:2:5\n"
"  |\n"
"2 | use rand;\n"
"  |     ^^^^ no external crate `rand`\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:288
msgid ""
"To fix this, edit the _Cargo.toml_ file for the `adder` package and indicate "
"that `rand` is a dependency for it as well. Building the `adder` package "
"will add `rand` to the list of dependencies for `adder` in _Cargo.lock_, but "
"no additional copies of `rand` will be downloaded. Cargo will ensure that "
"every crate in every package in the workspace using the `rand` package will "
"be using the same version as long as they specify compatible versions of "
"`rand`, saving us space and ensuring that the crates in the workspace will "
"be compatible with each other."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:297
msgid ""
"If crates in the workspace specify incompatible versions of the same "
"dependency, Cargo will resolve each of them, but will still try to resolve "
"as few versions as possible."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:301
msgid "Adding a Test to a Workspace"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:303
msgid ""
"For another enhancement, let’s add a test of the `add_one::add_one` function "
"within the `add_one` crate:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:324
msgid ""
"Now run `cargo test` in the top-level _add_ directory. Running `cargo test` "
"in a workspace structured like this one will run the tests for all the "
"crates in the workspace:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:335
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n"
"   Compiling adder v0.1.0 (file:///projects/add/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n"
"     Running unittests src/lib.rs (target/debug/deps/add_one-"
"f0253159197f7841)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"     Running unittests src/main.rs (target/debug/deps/"
"adder-49979ff40686fa8e)\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests add_one\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"```"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:360
msgid ""
"The first section of the output shows that the `it_works` test in the "
"`add_one` crate passed. The next section shows that zero tests were found in "
"the `adder` crate, and then the last section shows zero documentation tests "
"were found in the `add_one` crate."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:365
msgid ""
"We can also run tests for one particular crate in a workspace from the top-"
"level directory by using the `-p` flag and specifying the name of the crate "
"we want to test:"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:392
msgid ""
"This output shows `cargo test` only ran the tests for the `add_one` crate "
"and didn’t run the `adder` crate tests."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:395
msgid ""
"If you publish the crates in the workspace to [crates.io](https://"
"crates.io/), each crate in the workspace will need to be published "
"separately. Like `cargo test`, we can publish a particular crate in our "
"workspace by using the `-p` flag and specifying the name of the crate we "
"want to publish."
msgstr ""

#: src/ch14-03-cargo-workspaces.md:400
msgid ""
"For additional practice, add an `add_two` crate to this workspace in a "
"similar way as the `add_one` crate!"
msgstr ""

#: src/ch14-03-cargo-workspaces.md:403
msgid ""
"As your project grows, consider using a workspace: it’s easier to understand "
"smaller, individual components than one big blob of code. Furthermore, "
"keeping the crates in a workspace can make coordination between crates "
"easier if they are often changed at the same time."
msgstr ""

#: src/ch14-04-installing-binaries.md:3
msgid "<a id=\"installing-binaries-from-cratesio-with-cargo-install\"></a>"
msgstr ""

#: src/ch14-04-installing-binaries.md:5
msgid "Installing Binaries with `cargo install`"
msgstr ""

#: src/ch14-04-installing-binaries.md:7
msgid ""
"The `cargo install` command allows you to install and use binary crates "
"locally. This isn’t intended to replace system packages; it’s meant to be a "
"convenient way for Rust developers to install tools that others have shared "
"on [crates.io](https://crates.io/)<!-- ignore -->. Note that you can only "
"install packages that have binary targets. A _binary target_ is the runnable "
"program that is created if the crate has a _src/main.rs_ file or another "
"file specified as a binary, as opposed to a library target that isn’t "
"runnable on its own but is suitable for including within other programs. "
"Usually, crates have information in the _README_ file about whether a crate "
"is a library, has a binary target, or both."
msgstr ""

#: src/ch14-04-installing-binaries.md:18
msgid ""
"All binaries installed with `cargo install` are stored in the installation "
"root’s _bin_ folder. If you installed Rust using _rustup.rs_ and don’t have "
"any custom configurations, this directory will be _$HOME/.cargo/bin_. Ensure "
"that directory is in your `$PATH`to be able to run programs you’ve installed "
"with`cargo install`."
msgstr ""

#: src/ch14-04-installing-binaries.md:23
msgid ""
"For example, in Chapter 12 we mentioned that there’s a Rust implementation "
"of the `grep` tool called `ripgrep` for searching files. To install "
"`ripgrep`, we can run the following:"
msgstr ""

#: src/ch14-04-installing-binaries.md:44
msgid ""
"The second-to-last line of the output shows the location and the name of the "
"installed binary, which in the case of `ripgrep` is `rg`. As long as the "
"installation directory is in your `$PATH`, as mentioned previously, you can "
"then run `rg --help` and start using a faster, rustier tool for searching "
"files!"
msgstr ""

#: src/ch14-05-extending-cargo.md:3
msgid ""
"Cargo is designed so you can extend it with new subcommands without having "
"to modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you "
"can run it as if it was a Cargo subcommand by running `cargo something`. "
"Custom commands like this are also listed when you run `cargo --list`. Being "
"able to use `cargo install` to install extensions and then run them just "
"like the built-in Cargo tools is a super convenient benefit of Cargo’s "
"design!"
msgstr ""

#: src/ch14-05-extending-cargo.md:12
msgid ""
"Sharing code with Cargo and [crates.io](https://crates.io/)<!-- ignore --> "
"is part of what makes the Rust ecosystem useful for many different tasks. "
"Rust’s standard library is small and stable, but crates are easy to share, "
"use, and improve on a timeline different from that of the language. Don’t be "
"shy about sharing code that’s useful to you on [crates.io](https://"
"crates.io/)<!-- ignore\n"
"-->; it’s likely that it will be useful to someone else as well!"
msgstr ""

#: src/ch15-00-smart-pointers.md:3
msgid ""
"A _pointer_ is a general concept for a variable that contains an address in "
"memory. This address refers to, or “points at,” some other data. The most "
"common kind of pointer in Rust is a reference, which you learned about in "
"Chapter 4. References are indicated by the `&` symbol and borrow the value "
"they point to. They don’t have any special capabilities other than referring "
"to data, and have no overhead."
msgstr ""

#: src/ch15-00-smart-pointers.md:10
msgid ""
"_Smart pointers_, on the other hand, are data structures that act like a "
"pointer but also have additional metadata and capabilities. The concept of "
"smart pointers isn’t unique to Rust: smart pointers originated in C++ and "
"exist in other languages as well. Rust has a variety of smart pointers "
"defined in the standard library that provide functionality beyond that "
"provided by references. To explore the general concept, we’ll look at a "
"couple of different examples of smart pointers, including a _reference "
"counting_ smart pointer type. This pointer enables you to allow data to have "
"multiple owners by keeping track of the number of owners and, when no owners "
"remain, cleaning up the data."
msgstr ""

#: src/ch15-00-smart-pointers.md:20
msgid ""
"Rust, with its concept of ownership and borrowing, has an additional "
"difference between references and smart pointers: while references only "
"borrow data, in many cases, smart pointers _own_ the data they point to."
msgstr ""

#: src/ch15-00-smart-pointers.md:24
msgid ""
"Though we didn’t call them as such at the time, we’ve already encountered a "
"few smart pointers in this book, including `String` and `Vec<T>` in Chapter "
"8. Both these types count as smart pointers because they own some memory and "
"allow you to manipulate it. They also have metadata and extra capabilities "
"or guarantees. `String`, for example, stores its capacity as metadata and "
"has the extra ability to ensure its data will always be valid UTF-8."
msgstr ""

#: src/ch15-00-smart-pointers.md:31
msgid ""
"Smart pointers are usually implemented using structs. Unlike an ordinary "
"struct, smart pointers implement the `Deref` and `Drop` traits. The `Deref` "
"trait allows an instance of the smart pointer struct to behave like a "
"reference so you can write your code to work with either references or smart "
"pointers. The `Drop` trait allows you to customize the code that’s run when "
"an instance of the smart pointer goes out of scope. In this chapter, we’ll "
"discuss both of these traits and demonstrate why they’re important to smart "
"pointers."
msgstr ""

#: src/ch15-00-smart-pointers.md:39
msgid ""
"Given that the smart pointer pattern is a general design pattern used "
"frequently in Rust, this chapter won’t cover every existing smart pointer. "
"Many libraries have their own smart pointers, and you can even write your "
"own. We’ll cover the most common smart pointers in the standard library:"
msgstr ""

#: src/ch15-00-smart-pointers.md:44
msgid "`Box<T>` for allocating values on the heap"
msgstr ""

#: src/ch15-00-smart-pointers.md:45
msgid "`Rc<T>`, a reference counting type that enables multiple ownership"
msgstr ""

#: src/ch15-00-smart-pointers.md:46
msgid ""
"`Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that "
"enforces the borrowing rules at runtime instead of compile time"
msgstr ""

#: src/ch15-00-smart-pointers.md:49
msgid ""
"In addition, we’ll cover the _interior mutability_ pattern where an "
"immutable type exposes an API for mutating an interior value. We’ll also "
"discuss _reference cycles_: how they can leak memory and how to prevent them."
msgstr ""

#: src/ch15-00-smart-pointers.md:53
msgid "Let’s dive in!"
msgstr ""

#: src/ch15-01-box.md:3
msgid ""
"The most straightforward smart pointer is a _box_, whose type is written "
"`Box<T>`. Boxes allow you to store data on the heap rather than the stack. "
"What remains on the stack is the pointer to the heap data. Refer to Chapter "
"4 to review the difference between the stack and the heap."
msgstr ""

#: src/ch15-01-box.md:8
msgid ""
"Boxes don’t have performance overhead, other than storing their data on the "
"heap instead of on the stack. But they don’t have many extra capabilities "
"either. You’ll use them most often in these situations:"
msgstr ""

#: src/ch15-01-box.md:12
msgid ""
"When you have a type whose size can’t be known at compile time and you want "
"to use a value of that type in a context that requires an exact size"
msgstr ""

#: src/ch15-01-box.md:14
msgid ""
"When you have a large amount of data and you want to transfer ownership but "
"ensure the data won’t be copied when you do so"
msgstr ""

#: src/ch15-01-box.md:16
msgid ""
"When you want to own a value and you care only that it’s a type that "
"implements a particular trait rather than being of a specific type"
msgstr ""

#: src/ch15-01-box.md:19
msgid ""
"We’ll demonstrate the first situation in the [“Enabling Recursive Types with "
"Boxes”](#enabling-recursive-types-with-boxes)<!-- ignore --> section. In the "
"second case, transferring ownership of a large amount of data can take a "
"long time because the data is copied around on the stack. To improve "
"performance in this situation, we can store the large amount of data on the "
"heap in a box. Then, only the small amount of pointer data is copied around "
"on the stack, while the data it references stays in one place on the heap. "
"The third case is known as a _trait object_, and Chapter 18 devotes an "
"entire section, [“Using Trait Objects That Allow for Values of Different "
"Types,”](ch18-02-trait-objects.html#using-trait-objects-that-allow-for-"
"values-of-different-types)<!--\n"
"ignore --> just to that topic. So what you learn here you’ll apply again in "
"Chapter 18!"
msgstr ""

#: src/ch15-01-box.md:31
msgid "Using a `Box<T>` to Store Data on the Heap"
msgstr ""

#: src/ch15-01-box.md:33
msgid ""
"Before we discuss the heap storage use case for `Box<T>`, we’ll cover the "
"syntax and how to interact with values stored within a `Box<T>`."
msgstr ""

#: src/ch15-01-box.md:36
msgid ""
"Listing 15-1 shows how to use a box to store an `i32` value on the heap:"
msgstr ""

#: src/ch15-01-box.md:43
msgid "\"b = {b}\""
msgstr ""

#: src/ch15-01-box.md:49
msgid ""
"We define the variable `b` to have the value of a `Box` that points to the "
"value `5`, which is allocated on the heap. This program will print `b = 5`; "
"in this case, we can access the data in the box similarly to how we would if "
"this data were on the stack. Just like any owned value, when a box goes out "
"of scope, as `b` does at the end of `main`, it will be deallocated. The "
"deallocation happens both for the box (stored on the stack) and the data it "
"points to (stored on the heap)."
msgstr ""

#: src/ch15-01-box.md:57
msgid ""
"Putting a single value on the heap isn’t very useful, so you won’t use boxes "
"by themselves in this way very often. Having values like a single `i32` on "
"the stack, where they’re stored by default, is more appropriate in the "
"majority of situations. Let’s look at a case where boxes allow us to define "
"types that we wouldn’t be allowed to if we didn’t have boxes."
msgstr ""

#: src/ch15-01-box.md:63
msgid "Enabling Recursive Types with Boxes"
msgstr ""

#: src/ch15-01-box.md:65
msgid ""
"A value of _recursive type_ can have another value of the same type as part "
"of itself. Recursive types pose an issue because, at compile time, Rust "
"needs to know how much space a type takes up. However, the nesting of values "
"of recursive types could theoretically continue infinitely, so Rust can’t "
"know how much space the value needs. Because boxes have a known size, we can "
"enable recursive types by inserting a box in the recursive type definition."
msgstr ""

#: src/ch15-01-box.md:72
msgid ""
"As an example of a recursive type, let’s explore the _cons list_. This is a "
"data type commonly found in functional programming languages. The cons list "
"type we’ll define is straightforward except for the recursion; therefore, "
"the concepts in the example we’ll work with will be useful any time you get "
"into more complex situations involving recursive types."
msgstr ""

#: src/ch15-01-box.md:78
msgid "More Information About the Cons List"
msgstr ""

#: src/ch15-01-box.md:80
msgid ""
"A _cons list_ is a data structure that comes from the Lisp programming "
"language and its dialects and is made up of nested pairs, and is the Lisp "
"version of a linked list. Its name comes from the `cons` function (short for "
"“construct function”) in Lisp that constructs a new pair from its two "
"arguments. By calling `cons` on a pair consisting of a value and another "
"pair, we can construct cons lists made up of recursive pairs."
msgstr ""

#: src/ch15-01-box.md:87
msgid ""
"For example, here’s a pseudocode representation of a cons list containing "
"the list 1, 2, 3 with each pair in parentheses:"
msgstr ""

#: src/ch15-01-box.md:94
msgid ""
"Each item in a cons list contains two elements: the value of the current "
"item and the next item. The last item in the list contains only a value "
"called `Nil` without a next item. A cons list is produced by recursively "
"calling the `cons` function. The canonical name to denote the base case of "
"the recursion is `Nil`. Note that this is not the same as the “null” or "
"“nil” concept discussed in Chapter 6, which is an invalid or absent value."
msgstr ""

#: src/ch15-01-box.md:101
msgid ""
"The cons list isn’t a commonly used data structure in Rust. Most of the time "
"when you have a list of items in Rust, `Vec<T>` is a better choice to use. "
"Other, more complex recursive data types _are_ useful in various situations, "
"but by starting with the cons list in this chapter, we can explore how boxes "
"let us define a recursive data type without much distraction."
msgstr ""

#: src/ch15-01-box.md:107
msgid ""
"Listing 15-2 contains an enum definition for a cons list. Note that this "
"code won’t compile yet because the `List` type doesn’t have a known size, "
"which we’ll demonstrate."
msgstr ""

#: src/ch15-01-box.md:124
msgid ""
"Note: We’re implementing a cons list that holds only `i32` values for the "
"purposes of this example. We could have implemented it using generics, as we "
"discussed in Chapter 10, to define a cons list type that could store values "
"of any type."
msgstr ""

#: src/ch15-01-box.md:129
msgid ""
"Using the `List` type to store the list `1, 2, 3` would look like the code "
"in Listing 15-3:"
msgstr ""

#: src/ch15-01-box.md:149
msgid ""
"The first `Cons` value holds `1` and another `List` value. This `List` value "
"is another `Cons` value that holds `2` and another `List` value. This `List` "
"value is one more `Cons` value that holds `3` and a `List` value, which is "
"finally `Nil`, the non-recursive variant that signals the end of the list."
msgstr ""

#: src/ch15-01-box.md:154
msgid ""
"If we try to compile the code in Listing 15-3, we get the error shown in "
"Listing 15-4:"
msgstr ""

#: src/ch15-01-box.md:159
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"error[E0072]: recursive type `List` has infinite size\n"
" --> src/main.rs:1:1\n"
"  |\n"
"1 | enum List {\n"
"  | ^^^^^^^^^\n"
"2 |     Cons(i32, List),\n"
"  |               ---- recursive without indirection\n"
"  |\n"
"help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the "
"cycle\n"
"  |\n"
"2 |     Cons(i32, Box<List>),\n"
"  |               ++++    +\n"
"\n"
"error[E0391]: cycle detected when computing when `List` needs drop\n"
" --> src/main.rs:1:1\n"
"  |\n"
"1 | enum List {\n"
"  | ^^^^^^^^^\n"
"  |\n"
"  = note: ...which immediately requires computing when `List` needs drop "
"again\n"
"  = note: cycle used when computing whether `List` needs drop\n"
"  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries "
"and https://rustc-dev-guide.rust-lang.org/query.html for more information\n"
"\n"
"Some errors have detailed explanations: E0072, E0391.\n"
"For more information about an error, try `rustc --explain E0072`.\n"
"error: could not compile `cons-list` (bin \"cons-list\") due to 2 previous "
"errors\n"
"```"
msgstr ""

#: src/ch15-01-box.md:192
msgid ""
"The error shows this type “has infinite size.” The reason is that we’ve "
"defined `List` with a variant that is recursive: it holds another value of "
"itself directly. As a result, Rust can’t figure out how much space it needs "
"to store a `List` value. Let’s break down why we get this error. First, "
"we’ll look at how Rust decides how much space it needs to store a value of a "
"non-recursive type."
msgstr ""

#: src/ch15-01-box.md:198
msgid "Computing the Size of a Non-Recursive Type"
msgstr ""

#: src/ch15-01-box.md:200
msgid ""
"Recall the `Message` enum we defined in Listing 6-2 when we discussed enum "
"definitions in Chapter 6:"
msgstr ""

#: src/ch15-01-box.md:214
msgid ""
"To determine how much space to allocate for a `Message` value, Rust goes "
"through each of the variants to see which variant needs the most space. Rust "
"sees that `Message::Quit` doesn’t need any space, `Message::Move` needs "
"enough space to store two `i32` values, and so forth. Because only one "
"variant will be used, the most space a `Message` value will need is the "
"space it would take to store the largest of its variants."
msgstr ""

#: src/ch15-01-box.md:221
msgid ""
"Contrast this with what happens when Rust tries to determine how much space "
"a recursive type like the `List` enum in Listing 15-2 needs. The compiler "
"starts by looking at the `Cons` variant, which holds a value of type `i32` "
"and a value of type `List`. Therefore, `Cons` needs an amount of space equal "
"to the size of an `i32` plus the size of a `List`. To figure out how much "
"memory the `List` type needs, the compiler looks at the variants, starting "
"with the `Cons` variant. The `Cons` variant holds a value of type `i32` and "
"a value of type `List`, and this process continues infinitely, as shown in "
"Figure 15-1."
msgstr ""

#: src/ch15-01-box.md:232
msgid ""
"<span class=\"caption\">Figure 15-1: An infinite `List` consisting of "
"infinite `Cons` variants</span>"
msgstr ""

#: src/ch15-01-box.md:235
msgid "Using `Box<T>` to Get a Recursive Type with a Known Size"
msgstr ""

#: src/ch15-01-box.md:237
msgid ""
"Because Rust can’t figure out how much space to allocate for recursively "
"defined types, the compiler gives an error with this helpful suggestion:"
msgstr ""

#: src/ch15-01-box.md:251
msgid ""
"In this suggestion, “indirection” means that instead of storing a value "
"directly, we should change the data structure to store the value indirectly "
"by storing a pointer to the value instead."
msgstr ""

#: src/ch15-01-box.md:255
msgid ""
"Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>` "
"needs: a pointer’s size doesn’t change based on the amount of data it’s "
"pointing to. This means we can put a `Box<T>` inside the `Cons` variant "
"instead of another `List` value directly. The `Box<T>` will point to the "
"next `List` value that will be on the heap rather than inside the `Cons` "
"variant. Conceptually, we still have a list, created with lists holding "
"other lists, but this implementation is now more like placing the items next "
"to one another rather than inside one another."
msgstr ""

#: src/ch15-01-box.md:264
msgid ""
"We can change the definition of the `List` enum in Listing 15-2 and the "
"usage of the `List` in Listing 15-3 to the code in Listing 15-5, which will "
"compile:"
msgstr ""

#: src/ch15-01-box.md:284
msgid ""
"The `Cons` variant needs the size of an `i32` plus the space to store the "
"box’s pointer data. The `Nil` variant stores no values, so it needs less "
"space than the `Cons` variant. We now know that any `List` value will take "
"up the size of an `i32` plus the size of a box’s pointer data. By using a "
"box, we’ve broken the infinite, recursive chain, so the compiler can figure "
"out the size it needs to store a `List` value. Figure 15-2 shows what the "
"`Cons` variant looks like now."
msgstr ""

#: src/ch15-01-box.md:294
msgid ""
"<span class=\"caption\">Figure 15-2: A `List` that is not infinitely sized "
"because `Cons` holds a `Box`</span>"
msgstr ""

#: src/ch15-01-box.md:297
msgid ""
"Boxes provide only the indirection and heap allocation; they don’t have any "
"other special capabilities, like those we’ll see with the other smart "
"pointer types. They also don’t have the performance overhead that these "
"special capabilities incur, so they can be useful in cases like the cons "
"list where the indirection is the only feature we need. We’ll look at more "
"use cases for boxes in Chapter 18, too."
msgstr ""

#: src/ch15-01-box.md:304
msgid ""
"The `Box<T>` type is a smart pointer because it implements the `Deref` "
"trait, which allows `Box<T>` values to be treated like references. When a "
"`Box<T>` value goes out of scope, the heap data that the box is pointing to "
"is cleaned up as well because of the `Drop` trait implementation. These two "
"traits will be even more important to the functionality provided by the "
"other smart pointer types we’ll discuss in the rest of this chapter. Let’s "
"explore these two traits in more detail."
msgstr ""

#: src/ch15-02-deref.md:3
msgid ""
"Implementing the `Deref` trait allows you to customize the behavior of the "
"_dereference operator_ `*` (not to be confused with the multiplication or "
"glob operator). By implementing `Deref` in such a way that a smart pointer "
"can be treated like a regular reference, you can write code that operates on "
"references and use that code with smart pointers too."
msgstr ""

#: src/ch15-02-deref.md:9
msgid ""
"Let’s first look at how the dereference operator works with regular "
"references. Then we’ll try to define a custom type that behaves like "
"`Box<T>`, and see why the dereference operator doesn’t work like a reference "
"on our newly defined type. We’ll explore how implementing the `Deref` trait "
"makes it possible for smart pointers to work in ways similar to references. "
"Then we’ll look at Rust’s _deref coercion_ feature and how it lets us work "
"with either references or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:17
msgid ""
"Note: There’s one big difference between the `MyBox<T>` type we’re about to "
"build and the real `Box<T>`: our version will not store its data on the "
"heap. We are focusing this example on `Deref`, so where the data is actually "
"stored is less important than the pointer-like behavior."
msgstr ""

#: src/ch15-02-deref.md:24
msgid ""
"<a id=\"following-the-pointer-to-the-value-with-the-dereference-operator\"></"
"a>"
msgstr ""

#: src/ch15-02-deref.md:26
msgid "Following the Pointer to the Value"
msgstr ""

#: src/ch15-02-deref.md:28
msgid ""
"A regular reference is a type of pointer, and one way to think of a pointer "
"is as an arrow to a value stored somewhere else. In Listing 15-6, we create "
"a reference to an `i32` value and then use the dereference operator to "
"follow the reference to the value:"
msgstr ""

#: src/ch15-02-deref.md:47
msgid ""
"The variable `x` holds an `i32` value `5`. We set `y` equal to a reference "
"to `x`. We can assert that `x` is equal to `5`. However, if we want to make "
"an assertion about the value in `y`, we have to use `*y` to follow the "
"reference to the value it’s pointing to (hence _dereference_) so the "
"compiler can compare the actual value. Once we dereference `y`, we have "
"access to the integer value `y` is pointing to that we can compare with `5`."
msgstr ""

#: src/ch15-02-deref.md:54
msgid ""
"If we tried to write `assert_eq!(5, y);` instead, we would get this "
"compilation error:"
msgstr ""

#: src/ch15-02-deref.md:57
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0277]: can't compare `{integer}` with `&{integer}`\n"
" --> src/main.rs:6:5\n"
"  |\n"
"6 |     assert_eq!(5, y);\n"
"  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"
"  |\n"
"  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}"
"`\n"
"  = note: this error originates in the macro `assert_eq` (in Nightly builds, "
"run with -Z macro-backtrace for more info)\n"
"help: consider dereferencing here\n"
" --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/"
"src/macros/mod.rs:46:35\n"
"  |\n"
"46|                 if !(*left_val == **right_val) {\n"
"  |                                   +\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `deref-example` (bin \"deref-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:78
msgid ""
"Comparing a number and a reference to a number isn’t allowed because they’re "
"different types. We must use the dereference operator to follow the "
"reference to the value it’s pointing to."
msgstr ""

#: src/ch15-02-deref.md:82
msgid "Using `Box<T>` Like a Reference"
msgstr ""

#: src/ch15-02-deref.md:84
msgid ""
"We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a "
"reference; the dereference operator used on the `Box<T>` in Listing 15-7 "
"functions in the same way as the dereference operator used on the reference "
"in Listing 15-6:"
msgstr ""

#: src/ch15-02-deref.md:103
msgid ""
"The main difference between Listing 15-7 and Listing 15-6 is that here we "
"set `y` to be an instance of a `Box<T>` pointing to a copied value of `x` "
"rather than a reference pointing to the value of `x`. In the last assertion, "
"we can use the dereference operator to follow the pointer of the `Box<T>` in "
"the same way that we did when `y` was a reference. Next, we’ll explore what "
"is special about `Box<T>` that enables us to use the dereference operator by "
"defining our own type."
msgstr ""

#: src/ch15-02-deref.md:111
msgid "Defining Our Own Smart Pointer"
msgstr ""

#: src/ch15-02-deref.md:113
msgid ""
"Let’s build a smart pointer similar to the `Box<T>` type provided by the "
"standard library to experience how smart pointers behave differently from "
"references by default. Then we’ll look at how to add the ability to use the "
"dereference operator."
msgstr ""

#: src/ch15-02-deref.md:118
msgid ""
"The `Box<T>` type is ultimately defined as a tuple struct with one element, "
"so Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define "
"a `new` function to match the `new` function defined on `Box<T>`."
msgstr ""

#: src/ch15-02-deref.md:138
msgid ""
"We define a struct named `MyBox` and declare a generic parameter `T`, "
"because we want our type to hold values of any type. The `MyBox` type is a "
"tuple struct with one element of type `T`. The `MyBox::new` function takes "
"one parameter of type `T` and returns a `MyBox` instance that holds the "
"value passed in."
msgstr ""

#: src/ch15-02-deref.md:143
msgid ""
"Let’s try adding the `main` function in Listing 15-7 to Listing 15-8 and "
"changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. "
"The code in Listing 15-9 won’t compile because Rust doesn’t know how to "
"dereference `MyBox`."
msgstr ""

#: src/ch15-02-deref.md:170
msgid "Here’s the resulting compilation error:"
msgstr ""

#: src/ch15-02-deref.md:172
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n"
"  --> src/main.rs:14:19\n"
"   |\n"
"14 |     assert_eq!(5, *y);\n"
"   |                   ^^\n"
"\n"
"For more information about this error, try `rustc --explain E0614`.\n"
"error: could not compile `deref-example` (bin \"deref-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:185
msgid ""
"Our `MyBox<T>` type can’t be dereferenced because we haven’t implemented "
"that ability on our type. To enable dereferencing with the `*` operator, we "
"implement the `Deref` trait."
msgstr ""

#: src/ch15-02-deref.md:191
msgid ""
"<a id=\"treating-a-type-like-a-reference-by-implementing-the-deref-trait\"></"
"a>"
msgstr ""

#: src/ch15-02-deref.md:193
msgid "Implementing the `Deref` Trait"
msgstr ""

#: src/ch15-02-deref.md:195
msgid ""
"As discussed in [“Implementing a Trait on a Type”](ch10-02-"
"traits.html#implementing-a-trait-on-a-type)<!-- ignore --> in Chapter 10, to "
"implement a trait, we need to provide implementations for the trait’s "
"required methods. The `Deref` trait, provided by the standard library, "
"requires us to implement one method named `deref` that borrows `self` and "
"returns a reference to the inner data. Listing 15-10 contains an "
"implementation of `Deref` to add to the definition of `MyBox<T>`:"
msgstr ""

#: src/ch15-02-deref.md:234
msgid ""
"The `type Target = T;` syntax defines an associated type for the `Deref` "
"trait to use. Associated types are a slightly different way of declaring a "
"generic parameter, but you don’t need to worry about them for now; we’ll "
"cover them in more detail in Chapter 20."
msgstr ""

#: src/ch15-02-deref.md:239
msgid ""
"We fill in the body of the `deref` method with `&self.0` so `deref` returns "
"a reference to the value we want to access with the `*` operator; recall "
"from the [“Using Tuple Structs without Named Fields to Create Different "
"Types”](ch05-01-defining-structs.html#using-tuple-structs-without-named-"
"fields-to-create-different-types)<!-- ignore --> section of Chapter 5 that "
"`.0` accesses the first value in a tuple struct. The `main` function in "
"Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles, and the "
"assertions pass!"
msgstr ""

#: src/ch15-02-deref.md:246
msgid ""
"Without the `Deref` trait, the compiler can only dereference `&` references. "
"The `deref` method gives the compiler the ability to take a value of any "
"type that implements `Deref` and call the `deref` method to get an `&` "
"reference that it knows how to dereference."
msgstr ""

#: src/ch15-02-deref.md:251
msgid ""
"When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran "
"this code:"
msgstr ""

#: src/ch15-02-deref.md:258
msgid ""
"Rust substitutes the `*` operator with a call to the `deref` method and then "
"a plain dereference so we don’t have to think about whether or not we need "
"to call the `deref` method. This Rust feature lets us write code that "
"functions identically whether we have a regular reference or a type that "
"implements `Deref`."
msgstr ""

#: src/ch15-02-deref.md:264
msgid ""
"The reason the `deref` method returns a reference to a value, and that the "
"plain dereference outside the parentheses in `*(y.deref())` is still "
"necessary, is to do with the ownership system. If the `deref` method "
"returned the value directly instead of a reference to the value, the value "
"would be moved out of `self`. We don’t want to take ownership of the inner "
"value inside `MyBox<T>` in this case or in most cases where we use the "
"dereference operator."
msgstr ""

#: src/ch15-02-deref.md:271
msgid ""
"Note that the `*` operator is replaced with a call to the `deref` method and "
"then a call to the `*` operator just once, each time we use a `*` in our "
"code. Because the substitution of the `*` operator does not recurse "
"infinitely, we end up with data of type `i32`, which matches the `5` in "
"`assert_eq!` in Listing 15-9."
msgstr ""

#: src/ch15-02-deref.md:277
msgid "Implicit Deref Coercions with Functions and Methods"
msgstr ""

#: src/ch15-02-deref.md:279
msgid ""
"_Deref coercion_ converts a reference to a type that implements the `Deref` "
"trait into a reference to another type. For example, deref coercion can "
"convert `&String` to `&str` because `String` implements the `Deref` trait "
"such that it returns `&str`. Deref coercion is a convenience Rust performs "
"on arguments to functions and methods, and works only on types that "
"implement the `Deref` trait. It happens automatically when we pass a "
"reference to a particular type’s value as an argument to a function or "
"method that doesn’t match the parameter type in the function or method "
"definition. A sequence of calls to the `deref` method converts the type we "
"provided into the type the parameter needs."
msgstr ""

#: src/ch15-02-deref.md:289
msgid ""
"Deref coercion was added to Rust so that programmers writing function and "
"method calls don’t need to add as many explicit references and dereferences "
"with `&` and `*`. The deref coercion feature also lets us write more code "
"that can work for either references or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:294
msgid ""
"To see deref coercion in action, let’s use the `MyBox<T>` type we defined in "
"Listing 15-8 as well as the implementation of `Deref` that we added in "
"Listing 15-10. Listing 15-11 shows the definition of a function that has a "
"string slice parameter:"
msgstr ""

#: src/ch15-02-deref.md:303 src/ch15-02-deref.md:337 src/ch15-02-deref.md:382
msgid "\"Hello, {name}!\""
msgstr ""

#: src/ch15-02-deref.md:311
msgid ""
"We can call the `hello` function with a string slice as an argument, such as "
"`hello(\"Rust\");` for example. Deref coercion makes it possible to call "
"`hello` with a reference to a value of type `MyBox<String>`, as shown in "
"Listing 15-12:"
msgstr ""

#: src/ch15-02-deref.md:341 src/ch15-02-deref.md:386
msgid "\"Rust\""
msgstr ""

#: src/ch15-02-deref.md:348
msgid ""
"Here we’re calling the `hello` function with the argument `&m`, which is a "
"reference to a `MyBox<String>` value. Because we implemented the `Deref` "
"trait on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into "
"`&String` by calling `deref`. The standard library provides an "
"implementation of `Deref` on `String` that returns a string slice, and this "
"is in the API documentation for `Deref`. Rust calls `deref` again to turn "
"the `&String` into `&str`, which matches the `hello` function’s definition."
msgstr ""

#: src/ch15-02-deref.md:356
msgid ""
"If Rust didn’t implement deref coercion, we would have to write the code in "
"Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a "
"value of type `&MyBox<String>`."
msgstr ""

#: src/ch15-02-deref.md:393
msgid ""
"The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` "
"and `[..]` take a string slice of the `String` that is equal to the whole "
"string to match the signature of `hello`. This code without deref coercions "
"is harder to read, write, and understand with all of these symbols involved. "
"Deref coercion allows Rust to handle these conversions for us automatically."
msgstr ""

#: src/ch15-02-deref.md:399
msgid ""
"When the `Deref` trait is defined for the types involved, Rust will analyze "
"the types and use `Deref::deref` as many times as necessary to get a "
"reference to match the parameter’s type. The number of times that "
"`Deref::deref` needs to be inserted is resolved at compile time, so there is "
"no runtime penalty for taking advantage of deref coercion!"
msgstr ""

#: src/ch15-02-deref.md:405
msgid "How Deref Coercion Interacts with Mutability"
msgstr ""

#: src/ch15-02-deref.md:407
msgid ""
"Similar to how you use the `Deref` trait to override the `*` operator on "
"immutable references, you can use the `DerefMut` trait to override the `*` "
"operator on mutable references."
msgstr ""

#: src/ch15-02-deref.md:411
msgid ""
"Rust does deref coercion when it finds types and trait implementations in "
"three cases:"
msgstr ""

#: src/ch15-02-deref.md:414
msgid "From `&T` to `&U` when `T: Deref<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:415
msgid "From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:416
msgid "From `&mut T` to `&U` when `T: Deref<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:418
msgid ""
"The first two cases are the same as each other except that the second "
"implements mutability. The first case states that if you have a `&T`, and "
"`T` implements `Deref` to some type `U`, you can get a `&U` transparently. "
"The second case states that the same deref coercion happens for mutable "
"references."
msgstr ""

#: src/ch15-02-deref.md:423
msgid ""
"The third case is trickier: Rust will also coerce a mutable reference to an "
"immutable one. But the reverse is _not_ possible: immutable references will "
"never coerce to mutable references. Because of the borrowing rules, if you "
"have a mutable reference, that mutable reference must be the only reference "
"to that data (otherwise, the program wouldn’t compile). Converting one "
"mutable reference to one immutable reference will never break the borrowing "
"rules. Converting an immutable reference to a mutable reference would "
"require that the initial immutable reference is the only immutable reference "
"to that data, but the borrowing rules don’t guarantee that. Therefore, Rust "
"can’t make the assumption that converting an immutable reference to a "
"mutable reference is possible."
msgstr ""

#: src/ch15-03-drop.md:3
msgid ""
"The second trait important to the smart pointer pattern is `Drop`, which "
"lets you customize what happens when a value is about to go out of scope. "
"You can provide an implementation for the `Drop` trait on any type, and that "
"code can be used to release resources like files or network connections."
msgstr ""

#: src/ch15-03-drop.md:8
msgid ""
"We’re introducing `Drop` in the context of smart pointers because the "
"functionality of the `Drop` trait is almost always used when implementing a "
"smart pointer. For example, when a `Box<T>` is dropped, it will deallocate "
"the space on the heap that the box points to."
msgstr ""

#: src/ch15-03-drop.md:13
msgid ""
"In some languages, for some types, the programmer must call code to free "
"memory or resources every time they finish using an instance of those types. "
"Examples include file handles, sockets, or locks. If they forget, the system "
"might become overloaded and crash. In Rust, you can specify that a "
"particular bit of code be run whenever a value goes out of scope, and the "
"compiler will insert this code automatically. As a result, you don’t need to "
"be careful about placing cleanup code everywhere in a program that an "
"instance of a particular type is finished with—you still won’t leak "
"resources!"
msgstr ""

#: src/ch15-03-drop.md:22
msgid ""
"You specify the code to run when a value goes out of scope by implementing "
"the `Drop` trait. The `Drop` trait requires you to implement one method "
"named `drop` that takes a mutable reference to `self`. To see when Rust "
"calls `drop`, let’s implement `drop` with `println!` statements for now."
msgstr ""

#: src/ch15-03-drop.md:27
msgid ""
"Listing 15-14 shows a `CustomSmartPointer` struct whose only custom "
"functionality is that it will print `Dropping CustomSmartPointer!` when the "
"instance goes out of scope, to show when Rust runs the `drop` function."
msgstr ""

#: src/ch15-03-drop.md:40 src/ch15-03-drop.md:114 src/ch15-03-drop.md:179
msgid "\"Dropping CustomSmartPointer with data `{}`!\""
msgstr ""

#: src/ch15-03-drop.md:46
msgid "\"my stuff\""
msgstr ""

#: src/ch15-03-drop.md:49
msgid "\"other stuff\""
msgstr ""

#: src/ch15-03-drop.md:51
msgid "\"CustomSmartPointers created.\""
msgstr ""

#: src/ch15-03-drop.md:57
msgid ""
"The `Drop` trait is included in the prelude, so we don’t need to bring it "
"into scope. We implement the `Drop` trait on `CustomSmartPointer` and "
"provide an implementation for the `drop` method that calls `println!`. The "
"body of the `drop` function is where you would place any logic that you "
"wanted to run when an instance of your type goes out of scope. We’re "
"printing some text here to demonstrate visually when Rust will call `drop`."
msgstr ""

#: src/ch15-03-drop.md:64
msgid ""
"In `main`, we create two instances of `CustomSmartPointer` and then print "
"`CustomSmartPointers created`. At the end of `main`, our instances of "
"`CustomSmartPointer` will go out of scope, and Rust will call the code we "
"put in the `drop` method, printing our final message. Note that we didn’t "
"need to call the `drop` method explicitly."
msgstr ""

#: src/ch15-03-drop.md:70
msgid "When we run this program, we’ll see the following output:"
msgstr ""

#: src/ch15-03-drop.md:72
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s\n"
"     Running `target/debug/drop-example`\n"
"CustomSmartPointers created.\n"
"Dropping CustomSmartPointer with data `other stuff`!\n"
"Dropping CustomSmartPointer with data `my stuff`!\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:82
msgid ""
"Rust automatically called `drop` for us when our instances went out of "
"scope, calling the code we specified. Variables are dropped in the reverse "
"order of their creation, so `d` was dropped before `c`. This example’s "
"purpose is to give you a visual guide to how the `drop` method works; "
"usually you would specify the cleanup code that your type needs to run "
"rather than a print message."
msgstr ""

#: src/ch15-03-drop.md:89
msgid "Dropping a Value Early with `std::mem::drop`"
msgstr ""

#: src/ch15-03-drop.md:91
msgid ""
"Unfortunately, it’s not straightforward to disable the automatic `drop` "
"functionality. Disabling `drop` isn’t usually necessary; the whole point of "
"the `Drop` trait is that it’s taken care of automatically. Occasionally, "
"however, you might want to clean up a value early. One example is when using "
"smart pointers that manage locks: you might want to force the `drop` method "
"that releases the lock so that other code in the same scope can acquire the "
"lock. Rust doesn’t let you call the `Drop` trait’s `drop` method manually; "
"instead you have to call the `std::mem::drop` function provided by the "
"standard library if you want to force a value to be dropped before the end "
"of its scope."
msgstr ""

#: src/ch15-03-drop.md:101
msgid ""
"If we try to call the `Drop` trait’s `drop` method manually by modifying the "
"`main` function from Listing 15-14, as shown in Listing 15-15, we’ll get a "
"compiler error:"
msgstr ""

#: src/ch15-03-drop.md:120 src/ch15-03-drop.md:185
msgid "\"some data\""
msgstr ""

#: src/ch15-03-drop.md:122 src/ch15-03-drop.md:187
msgid "\"CustomSmartPointer created.\""
msgstr ""

#: src/ch15-03-drop.md:124 src/ch15-03-drop.md:189
msgid "\"CustomSmartPointer dropped before the end of main.\""
msgstr ""

#: src/ch15-03-drop.md:130
msgid "When we try to compile this code, we’ll get this error:"
msgstr ""

#: src/ch15-03-drop.md:132
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"error[E0040]: explicit use of destructor method\n"
"  --> src/main.rs:16:7\n"
"   |\n"
"16 |     c.drop();\n"
"   |       ^^^^ explicit destructor calls not allowed\n"
"   |\n"
"help: consider using `drop` function\n"
"   |\n"
"16 |     drop(c);\n"
"   |     +++++ ~\n"
"\n"
"For more information about this error, try `rustc --explain E0040`.\n"
"error: could not compile `drop-example` (bin \"drop-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:150
msgid ""
"This error message states that we’re not allowed to explicitly call `drop`. "
"The error message uses the term _destructor_, which is the general "
"programming term for a function that cleans up an instance. A destructor is "
"analogous to a _constructor_, which creates an instance. The `drop` function "
"in Rust is one particular destructor."
msgstr ""

#: src/ch15-03-drop.md:156
msgid ""
"Rust doesn’t let us call `drop` explicitly because Rust would still "
"automatically call `drop` on the value at the end of `main`. This would "
"cause a _double free_ error because Rust would be trying to clean up the "
"same value twice."
msgstr ""

#: src/ch15-03-drop.md:161
msgid ""
"We can’t disable the automatic insertion of `drop` when a value goes out of "
"scope, and we can’t call the `drop` method explicitly. So, if we need to "
"force a value to be cleaned up early, we use the `std::mem::drop` function."
msgstr ""

#: src/ch15-03-drop.md:165
msgid ""
"The `std::mem::drop` function is different from the `drop` method in the "
"`Drop` trait. We call it by passing as an argument the value we want to "
"force drop. The function is in the prelude, so we can modify `main` in "
"Listing 15-15 to call the `drop` function, as shown in Listing 15-16:"
msgstr ""

#: src/ch15-03-drop.md:195
msgid "Running this code will print the following:"
msgstr ""

#: src/ch15-03-drop.md:197
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n"
"     Running `target/debug/drop-example`\n"
"CustomSmartPointer created.\n"
"Dropping CustomSmartPointer with data `some data`!\n"
"CustomSmartPointer dropped before the end of main.\n"
"```"
msgstr ""

#: src/ch15-03-drop.md:207
msgid ""
"The text ``Dropping CustomSmartPointer with data `some data`!`` is printed "
"between the `CustomSmartPointer created.` and `CustomSmartPointer dropped "
"before the end of main.` text, showing that the `drop` method code is called "
"to drop `c` at that point."
msgstr ""

#: src/ch15-03-drop.md:212
msgid ""
"You can use code specified in a `Drop` trait implementation in many ways to "
"make cleanup convenient and safe: for instance, you could use it to create "
"your own memory allocator! With the `Drop` trait and Rust’s ownership "
"system, you don’t have to remember to clean up because Rust does it "
"automatically."
msgstr ""

#: src/ch15-03-drop.md:217
msgid ""
"You also don’t have to worry about problems resulting from accidentally "
"cleaning up values still in use: the ownership system that makes sure "
"references are always valid also ensures that `drop` gets called only once "
"when the value is no longer being used."
msgstr ""

#: src/ch15-03-drop.md:222
msgid ""
"Now that we’ve examined `Box<T>` and some of the characteristics of smart "
"pointers, let’s look at a few other smart pointers defined in the standard "
"library."
msgstr ""

#: src/ch15-04-rc.md:3
msgid ""
"In the majority of cases, ownership is clear: you know exactly which "
"variable owns a given value. However, there are cases when a single value "
"might have multiple owners. For example, in graph data structures, multiple "
"edges might point to the same node, and that node is conceptually owned by "
"all of the edges that point to it. A node shouldn’t be cleaned up unless it "
"doesn’t have any edges pointing to it and so has no owners."
msgstr ""

#: src/ch15-04-rc.md:10
msgid ""
"You have to enable multiple ownership explicitly by using the Rust type "
"`Rc<T>`, which is an abbreviation for _reference counting_. The `Rc<T>` type "
"keeps track of the number of references to a value to determine whether or "
"not the value is still in use. If there are zero references to a value, the "
"value can be cleaned up without any references becoming invalid."
msgstr ""

#: src/ch15-04-rc.md:16
msgid ""
"Imagine `Rc<T>` as a TV in a family room. When one person enters to watch "
"TV, they turn it on. Others can come into the room and watch the TV. When "
"the last person leaves the room, they turn off the TV because it’s no longer "
"being used. If someone turns off the TV while others are still watching it, "
"there would be uproar from the remaining TV watchers!"
msgstr ""

#: src/ch15-04-rc.md:22
msgid ""
"We use the `Rc<T>` type when we want to allocate some data on the heap for "
"multiple parts of our program to read and we can’t determine at compile time "
"which part will finish using the data last. If we knew which part would "
"finish last, we could just make that part the data’s owner, and the normal "
"ownership rules enforced at compile time would take effect."
msgstr ""

#: src/ch15-04-rc.md:28
msgid ""
"Note that `Rc<T>` is only for use in single-threaded scenarios. When we "
"discuss concurrency in Chapter 16, we’ll cover how to do reference counting "
"in multithreaded programs."
msgstr ""

#: src/ch15-04-rc.md:32
msgid "Using `Rc<T>` to Share Data"
msgstr ""

#: src/ch15-04-rc.md:34
msgid ""
"Let’s return to our cons list example in Listing 15-5. Recall that we "
"defined it using `Box<T>`. This time, we’ll create two lists that both share "
"ownership of a third list. Conceptually, this looks similar to Figure 15-3:"
msgstr ""

#: src/ch15-04-rc.md:40
msgid ""
"<span class=\"caption\">Figure 15-3: Two lists, `b` and `c`, sharing "
"ownership of a third list, `a`</span>"
msgstr ""

#: src/ch15-04-rc.md:43
msgid ""
"We’ll create list `a` that contains 5 and then 10. Then we’ll make two more "
"lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c` "
"lists will then continue on to the first `a` list containing 5 and 10. In "
"other words, both lists will share the first list containing 5 and 10."
msgstr ""

#: src/ch15-04-rc.md:48
msgid ""
"Trying to implement this scenario using our definition of `List` with "
"`Box<T>` won’t work, as shown in Listing 15-17:"
msgstr ""

#: src/ch15-04-rc.md:70
msgid "When we compile this code, we get this error:"
msgstr ""

#: src/ch15-04-rc.md:72
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"error[E0382]: use of moved value: `a`\n"
"  --> src/main.rs:11:30\n"
"   |\n"
"9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n"
"   |         - move occurs because `a` has type `List`, which does not "
"implement the `Copy` trait\n"
"10 |     let b = Cons(3, Box::new(a));\n"
"   |                              - value moved here\n"
"11 |     let c = Cons(4, Box::new(a));\n"
"   |                              ^ value used here after move\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `cons-list` (bin \"cons-list\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:89
msgid ""
"The `Cons` variants own the data they hold, so when we create the `b` list, "
"`a` is moved into `b` and `b` owns `a`. Then, when we try to use `a` again "
"when creating `c`, we’re not allowed to because `a` has been moved."
msgstr ""

#: src/ch15-04-rc.md:93
msgid ""
"We could change the definition of `Cons` to hold references instead, but "
"then we would have to specify lifetime parameters. By specifying lifetime "
"parameters, we would be specifying that every element in the list will live "
"at least as long as the entire list. This is the case for the elements and "
"lists in Listing 15-17, but not in every scenario."
msgstr ""

#: src/ch15-04-rc.md:99
msgid ""
"Instead, we’ll change our definition of `List` to use `Rc<T>` in place of "
"`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a "
"value and an `Rc<T>` pointing to a `List`. When we create `b`, instead of "
"taking ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, "
"thereby increasing the number of references from one to two and letting `a` "
"and `b` share ownership of the data in that `Rc<List>`. We’ll also clone `a` "
"when creating `c`, increasing the number of references from two to three. "
"Every time we call `Rc::clone`, the reference count to the data within the "
"`Rc<List>` will increase, and the data won’t be cleaned up unless there are "
"zero references to it."
msgstr ""

#: src/ch15-04-rc.md:130
msgid ""
"We need to add a `use` statement to bring `Rc<T>` into scope because it’s "
"not in the prelude. In `main`, we create the list holding 5 and 10 and store "
"it in a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the "
"`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an "
"argument."
msgstr ""

#: src/ch15-04-rc.md:136
msgid ""
"We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s "
"convention is to use `Rc::clone` in this case. The implementation of "
"`Rc::clone` doesn’t make a deep copy of all the data like most types’ "
"implementations of `clone` do. The call to `Rc::clone` only increments the "
"reference count, which doesn’t take much time. Deep copies of data can take "
"a lot of time. By using `Rc::clone` for reference counting, we can visually "
"distinguish between the deep-copy kinds of clones and the kinds of clones "
"that increase the reference count. When looking for performance problems in "
"the code, we only need to consider the deep-copy clones and can disregard "
"calls to `Rc::clone`."
msgstr ""

#: src/ch15-04-rc.md:147
msgid "Cloning an `Rc<T>` Increases the Reference Count"
msgstr ""

#: src/ch15-04-rc.md:149
msgid ""
"Let’s change our working example in Listing 15-18 so we can see the "
"reference counts changing as we create and drop references to the `Rc<List>` "
"in `a`."
msgstr ""

#: src/ch15-04-rc.md:152
msgid ""
"In Listing 15-19, we’ll change `main` so it has an inner scope around list "
"`c`; then we can see how the reference count changes when `c` goes out of "
"scope."
msgstr ""

#: src/ch15-04-rc.md:168
msgid "\"count after creating a = {}\""
msgstr ""

#: src/ch15-04-rc.md:170
msgid "\"count after creating b = {}\""
msgstr ""

#: src/ch15-04-rc.md:173
msgid "\"count after creating c = {}\""
msgstr ""

#: src/ch15-04-rc.md:175
msgid "\"count after c goes out of scope = {}\""
msgstr ""

#: src/ch15-04-rc.md:181
msgid ""
"At each point in the program where the reference count changes, we print the "
"reference count, which we get by calling the `Rc::strong_count` function. "
"This function is named `strong_count` rather than `count` because the "
"`Rc<T>` type also has a `weak_count`; we’ll see what `weak_count` is used "
"for in [“Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`”]"
"(ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-"
"into-a-weakt)<!-- ignore -->."
msgstr ""

#: src/ch15-04-rc.md:188
msgid "This code prints the following:"
msgstr ""

#: src/ch15-04-rc.md:190
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n"
"     Running `target/debug/cons-list`\n"
"count after creating a = 1\n"
"count after creating b = 2\n"
"count after creating c = 3\n"
"count after c goes out of scope = 2\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:201
msgid ""
"We can see that the `Rc<List>` in `a` has an initial reference count of 1; "
"then each time we call `clone`, the count goes up by 1. When `c` goes out of "
"scope, the count goes down by 1. We don’t have to call a function to "
"decrease the reference count like we have to call `Rc::clone` to increase "
"the reference count: the implementation of the `Drop` trait decreases the "
"reference count automatically when an `Rc<T>` value goes out of scope."
msgstr ""

#: src/ch15-04-rc.md:208
msgid ""
"What we can’t see in this example is that when `b` and then `a` go out of "
"scope at the end of `main`, the count is then 0, and the `Rc<List>` is "
"cleaned up completely. Using `Rc<T>` allows a single value to have multiple "
"owners, and the count ensures that the value remains valid as long as any of "
"the owners still exist."
msgstr ""

#: src/ch15-04-rc.md:214
msgid ""
"Via immutable references, `Rc<T>` allows you to share data between multiple "
"parts of your program for reading only. If `Rc<T>` allowed you to have "
"multiple mutable references too, you might violate one of the borrowing "
"rules discussed in Chapter 4: multiple mutable borrows to the same place can "
"cause data races and inconsistencies. But being able to mutate data is very "
"useful! In the next section, we’ll discuss the interior mutability pattern "
"and the `RefCell<T>` type that you can use in conjunction with an `Rc<T>` to "
"work with this immutability restriction."
msgstr ""

#: src/ch15-05-interior-mutability.md:3
msgid ""
"_Interior mutability_ is a design pattern in Rust that allows you to mutate "
"data even when there are immutable references to that data; normally, this "
"action is disallowed by the borrowing rules. To mutate data, the pattern "
"uses `unsafe` code inside a data structure to bend Rust’s usual rules that "
"govern mutation and borrowing. Unsafe code indicates to the compiler that "
"we’re checking the rules manually instead of relying on the compiler to "
"check them for us; we will discuss unsafe code more in Chapter 20."
msgstr ""

#: src/ch15-05-interior-mutability.md:11
msgid ""
"We can use types that use the interior mutability pattern only when we can "
"ensure that the borrowing rules will be followed at runtime, even though the "
"compiler can’t guarantee that. The `unsafe` code involved is then wrapped in "
"a safe API, and the outer type is still immutable."
msgstr ""

#: src/ch15-05-interior-mutability.md:16
msgid ""
"Let’s explore this concept by looking at the `RefCell<T>` type that follows "
"the interior mutability pattern."
msgstr ""

#: src/ch15-05-interior-mutability.md:19
msgid "Enforcing Borrowing Rules at Runtime with `RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:21
msgid ""
"Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the "
"data it holds. So, what makes `RefCell<T>` different from a type like "
"`Box<T>`? Recall the borrowing rules you learned in Chapter 4:"
msgstr ""

#: src/ch15-05-interior-mutability.md:25
msgid ""
"At any given time, you can have _either_ (but not both) one mutable "
"reference or any number of immutable references."
msgstr ""

#: src/ch15-05-interior-mutability.md:29
msgid ""
"With references and `Box<T>`, the borrowing rules’ invariants are enforced "
"at compile time. With `RefCell<T>`, these invariants are enforced _at "
"runtime_. With references, if you break these rules, you’ll get a compiler "
"error. With `RefCell<T>`, if you break these rules, your program will panic "
"and exit."
msgstr ""

#: src/ch15-05-interior-mutability.md:34
msgid ""
"The advantages of checking the borrowing rules at compile time are that "
"errors will be caught sooner in the development process, and there is no "
"impact on runtime performance because all the analysis is completed "
"beforehand. For those reasons, checking the borrowing rules at compile time "
"is the best choice in the majority of cases, which is why this is Rust’s "
"default."
msgstr ""

#: src/ch15-05-interior-mutability.md:40
msgid ""
"The advantage of checking the borrowing rules at runtime instead is that "
"certain memory-safe scenarios are then allowed, where they would’ve been "
"disallowed by the compile-time checks. Static analysis, like the Rust "
"compiler, is inherently conservative. Some properties of code are impossible "
"to detect by analyzing the code: the most famous example is the Halting "
"Problem, which is beyond the scope of this book but is an interesting topic "
"to research."
msgstr ""

#: src/ch15-05-interior-mutability.md:47
msgid ""
"Because some analysis is impossible, if the Rust compiler can’t be sure the "
"code complies with the ownership rules, it might reject a correct program; "
"in this way, it’s conservative. If Rust accepted an incorrect program, users "
"wouldn’t be able to trust in the guarantees Rust makes. However, if Rust "
"rejects a correct program, the programmer will be inconvenienced, but "
"nothing catastrophic can occur. The `RefCell<T>` type is useful when you’re "
"sure your code follows the borrowing rules but the compiler is unable to "
"understand and guarantee that."
msgstr ""

#: src/ch15-05-interior-mutability.md:56
msgid ""
"Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded "
"scenarios and will give you a compile-time error if you try using it in a "
"multithreaded context. We’ll talk about how to get the functionality of "
"`RefCell<T>` in a multithreaded program in Chapter 16."
msgstr ""

#: src/ch15-05-interior-mutability.md:61
msgid ""
"Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:"
msgstr ""

#: src/ch15-05-interior-mutability.md:63
msgid ""
"`Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>` "
"have single owners."
msgstr ""

#: src/ch15-05-interior-mutability.md:65
msgid ""
"`Box<T>` allows immutable or mutable borrows checked at compile time; "
"`Rc<T>` allows only immutable borrows checked at compile time; `RefCell<T>` "
"allows immutable or mutable borrows checked at runtime."
msgstr ""

#: src/ch15-05-interior-mutability.md:68
msgid ""
"Because `RefCell<T>` allows mutable borrows checked at runtime, you can "
"mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is "
"immutable."
msgstr ""

#: src/ch15-05-interior-mutability.md:72
msgid ""
"Mutating the value inside an immutable value is the _interior mutability_ "
"pattern. Let’s look at a situation in which interior mutability is useful "
"and examine how it’s possible."
msgstr ""

#: src/ch15-05-interior-mutability.md:76
msgid "Interior Mutability: A Mutable Borrow to an Immutable Value"
msgstr ""

#: src/ch15-05-interior-mutability.md:78
msgid ""
"A consequence of the borrowing rules is that when you have an immutable "
"value, you can’t borrow it mutably. For example, this code won’t compile:"
msgstr ""

#: src/ch15-05-interior-mutability.md:88
msgid "If you tried to compile this code, you’d get the following error:"
msgstr ""

#: src/ch15-05-interior-mutability.md:90
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling borrowing v0.1.0 (file:///projects/borrowing)\n"
"error[E0596]: cannot borrow `x` as mutable, as it is not declared as "
"mutable\n"
" --> src/main.rs:3:13\n"
"  |\n"
"3 |     let y = &mut x;\n"
"  |             ^^^^^^ cannot borrow as mutable\n"
"  |\n"
"help: consider changing this to be mutable\n"
"  |\n"
"2 |     let mut x = 5;\n"
"  |         +++\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `borrowing` (bin \"borrowing\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:108
msgid ""
"However, there are situations in which it would be useful for a value to "
"mutate itself in its methods but appear immutable to other code. Code "
"outside the value’s methods would not be able to mutate the value. Using "
"`RefCell<T>` is one way to get the ability to have interior mutability, but "
"`RefCell<T>` doesn’t get around the borrowing rules completely: the borrow "
"checker in the compiler allows this interior mutability, and the borrowing "
"rules are checked at runtime instead. If you violate the rules, you’ll get a "
"`panic!` instead of a compiler error."
msgstr ""

#: src/ch15-05-interior-mutability.md:117
msgid ""
"Let’s work through a practical example where we can use `RefCell<T>` to "
"mutate an immutable value and see why that is useful."
msgstr ""

#: src/ch15-05-interior-mutability.md:120
msgid "A Use Case for Interior Mutability: Mock Objects"
msgstr ""

#: src/ch15-05-interior-mutability.md:122
msgid ""
"Sometimes during testing a programmer will use a type in place of another "
"type, in order to observe particular behavior and assert it’s implemented "
"correctly. This placeholder type is called a _test double_. Think of it in "
"the sense of a “stunt double” in filmmaking, where a person steps in and "
"substitutes for an actor to do a particular tricky scene. Test doubles stand "
"in for other types when we’re running tests. _Mock objects_ are specific "
"types of test doubles that record what happens during a test so you can "
"assert that the correct actions took place."
msgstr ""

#: src/ch15-05-interior-mutability.md:131
msgid ""
"Rust doesn’t have objects in the same sense as other languages have objects, "
"and Rust doesn’t have mock object functionality built into the standard "
"library as some other languages do. However, you can definitely create a "
"struct that will serve the same purposes as a mock object."
msgstr ""

#: src/ch15-05-interior-mutability.md:136
msgid ""
"Here’s the scenario we’ll test: we’ll create a library that tracks a value "
"against a maximum value and sends messages based on how close to the maximum "
"value the current value is. This library could be used to keep track of a "
"user’s quota for the number of API calls they’re allowed to make, for "
"example."
msgstr ""

#: src/ch15-05-interior-mutability.md:141
msgid ""
"Our library will only provide the functionality of tracking how close to the "
"maximum a value is and what the messages should be at what times. "
"Applications that use our library will be expected to provide the mechanism "
"for sending the messages: the application could put a message in the "
"application, send an email, send a text message, or something else. The "
"library doesn’t need to know that detail. All it needs is something that "
"implements a trait we’ll provide called `Messenger`. Listing 15-20 shows the "
"library code:"
msgstr ""

#: src/ch15-05-interior-mutability.md:180
#: src/ch15-05-interior-mutability.md:243
#: src/ch15-05-interior-mutability.md:375
#: src/ch15-05-interior-mutability.md:495
msgid "\"Error: You are over your quota!\""
msgstr ""

#: src/ch15-05-interior-mutability.md:183
#: src/ch15-05-interior-mutability.md:246
#: src/ch15-05-interior-mutability.md:378
#: src/ch15-05-interior-mutability.md:498
msgid "\"Urgent warning: You've used up over 90% of your quota!\""
msgstr ""

#: src/ch15-05-interior-mutability.md:186
#: src/ch15-05-interior-mutability.md:249
#: src/ch15-05-interior-mutability.md:381
#: src/ch15-05-interior-mutability.md:501
msgid "\"Warning: You've used up over 75% of your quota!\""
msgstr ""

#: src/ch15-05-interior-mutability.md:194
msgid ""
"One important part of this code is that the `Messenger` trait has one method "
"called `send` that takes an immutable reference to `self` and the text of "
"the message. This trait is the interface our mock object needs to implement "
"so that the mock can be used in the same way a real object is. The other "
"important part is that we want to test the behavior of the `set_value` "
"method on the `LimitTracker`. We can change what we pass in for the `value` "
"parameter, but `set_value` doesn’t return anything for us to make assertions "
"on. We want to be able to say that if we create a `LimitTracker` with "
"something that implements the `Messenger` trait and a particular value for "
"`max`, when we pass different numbers for `value`, the messenger is told to "
"send the appropriate messages."
msgstr ""

#: src/ch15-05-interior-mutability.md:205
msgid ""
"We need a mock object that, instead of sending an email or text message when "
"we call `send`, will only keep track of the messages it’s told to send. We "
"can create a new instance of the mock object, create a `LimitTracker` that "
"uses the mock object, call the `set_value` method on `LimitTracker`, and "
"then check that the mock object has the messages we expect. Listing 15-21 "
"shows an attempt to implement a mock object to do just that, but the borrow "
"checker won’t allow it:"
msgstr ""

#: src/ch15-05-interior-mutability.md:290
msgid ""
"This test code defines a `MockMessenger` struct that has a `sent_messages` "
"field with a `Vec` of `String` values to keep track of the messages it’s "
"told to send. We also define an associated function `new` to make it "
"convenient to create new `MockMessenger` values that start with an empty "
"list of messages. We then implement the `Messenger` trait for "
"`MockMessenger` so we can give a `MockMessenger` to a `LimitTracker`. In the "
"definition of the `send` method, we take the message passed in as a "
"parameter and store it in the `MockMessenger` list of `sent_messages`."
msgstr ""

#: src/ch15-05-interior-mutability.md:299
msgid ""
"In the test, we’re testing what happens when the `LimitTracker` is told to "
"set `value` to something that is more than 75 percent of the `max` value. "
"First, we create a new `MockMessenger`, which will start with an empty list "
"of messages. Then we create a new `LimitTracker` and give it a reference to "
"the new `MockMessenger` and a `max` value of 100. We call the `set_value` "
"method on the `LimitTracker` with a value of 80, which is more than 75 "
"percent of 100. Then we assert that the list of messages that the "
"`MockMessenger` is keeping track of should now have one message in it."
msgstr ""

#: src/ch15-05-interior-mutability.md:308
msgid "However, there’s one problem with this test, as shown here:"
msgstr ""

#: src/ch15-05-interior-mutability.md:310
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n"
"error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind "
"a `&` reference\n"
"  --> src/lib.rs:58:13\n"
"   |\n"
"58 |             self.sent_messages.push(String::from(message));\n"
"   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data "
"it refers to cannot be borrowed as mutable\n"
"   |\n"
"help: consider changing this to be a mutable reference in the `impl` method "
"and the `trait` definition\n"
"   |\n"
"2  ~     fn send(&mut self, msg: &str);\n"
"3  | }\n"
"...\n"
"56 |     impl Messenger for MockMessenger {\n"
"57 ~         fn send(&mut self, message: &str) {\n"
"   |\n"
"\n"
"For more information about this error, try `rustc --explain E0596`.\n"
"error: could not compile `limit-tracker` (lib test) due to 1 previous error\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:332
msgid ""
"We can’t modify the `MockMessenger` to keep track of the messages, because "
"the `send` method takes an immutable reference to `self`. We also can’t take "
"the suggestion from the error text to use `&mut self` in both the `impl` "
"method and the `trait` definition. We do not want to change the `Messenger` "
"trait solely for the sake of testing. Instead, we need to find a way to make "
"our test code work correctly with our existing design."
msgstr ""

#: src/ch15-05-interior-mutability.md:339
msgid ""
"This is a situation in which interior mutability can help! We’ll store the "
"`sent_messages` within a `RefCell<T>`, and then the `send` method will be "
"able to modify `sent_messages` to store the messages we’ve seen. Listing "
"15-22 shows what that looks like:"
msgstr ""

#: src/ch15-05-interior-mutability.md:424
msgid ""
"The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of "
"`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>` "
"instance around the empty vector."
msgstr ""

#: src/ch15-05-interior-mutability.md:428
msgid ""
"For the implementation of the `send` method, the first parameter is still an "
"immutable borrow of `self`, which matches the trait definition. We call "
"`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a "
"mutable reference to the value inside the `RefCell<Vec<String>>`, which is "
"the vector. Then we can call `push` on the mutable reference to the vector "
"to keep track of the messages sent during the test."
msgstr ""

#: src/ch15-05-interior-mutability.md:435
msgid ""
"The last change we have to make is in the assertion: to see how many items "
"are in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to "
"get an immutable reference to the vector."
msgstr ""

#: src/ch15-05-interior-mutability.md:439
msgid ""
"Now that you’ve seen how to use `RefCell<T>`, let’s dig into how it works!"
msgstr ""

#: src/ch15-05-interior-mutability.md:441
msgid "Keeping Track of Borrows at Runtime with `RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:443
msgid ""
"When creating immutable and mutable references, we use the `&` and `&mut` "
"syntax, respectively. With `RefCell<T>`, we use the `borrow` and "
"`borrow_mut` methods, which are part of the safe API that belongs to "
"`RefCell<T>`. The `borrow` method returns the smart pointer type `Ref<T>`, "
"and `borrow_mut` returns the smart pointer type `RefMut<T>`. Both types "
"implement `Deref`, so we can treat them like regular references."
msgstr ""

#: src/ch15-05-interior-mutability.md:450
msgid ""
"The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart "
"pointers are currently active. Every time we call `borrow`, the `RefCell<T>` "
"increases its count of how many immutable borrows are active. When a "
"`Ref<T>` value goes out of scope, the count of immutable borrows goes down "
"by one. Just like the compile-time borrowing rules, `RefCell<T>` lets us "
"have many immutable borrows or one mutable borrow at any point in time."
msgstr ""

#: src/ch15-05-interior-mutability.md:457
msgid ""
"If we try to violate these rules, rather than getting a compiler error as we "
"would with references, the implementation of `RefCell<T>` will panic at "
"runtime. Listing 15-23 shows a modification of the implementation of `send` "
"in Listing 15-22. We’re deliberately trying to create two mutable borrows "
"active for the same scope to illustrate that `RefCell<T>` prevents us from "
"doing this at runtime."
msgstr ""

#: src/ch15-05-interior-mutability.md:547
msgid ""
"We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned "
"from `borrow_mut`. Then we create another mutable borrow in the same way in "
"the variable `two_borrow`. This makes two mutable references in the same "
"scope, which isn’t allowed. When we run the tests for our library, the code "
"in Listing 15-23 will compile without any errors, but the test will fail:"
msgstr ""

#: src/ch15-05-interior-mutability.md:553
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n"
"     Running unittests src/lib.rs (target/debug/deps/limit_tracker-"
"e599811fa246dbde)\n"
"\n"
"running 1 test\n"
"test tests::it_sends_an_over_75_percent_warning_message ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::it_sends_an_over_75_percent_warning_message stdout ----\n"
"thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/"
"lib.rs:60:53:\n"
"already borrowed: BorrowMutError\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::it_sends_an_over_75_percent_warning_message\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:578
msgid ""
"Notice that the code panicked with the message `already borrowed: "
"BorrowMutError`. This is how `RefCell<T>` handles violations of the "
"borrowing rules at runtime."
msgstr ""

#: src/ch15-05-interior-mutability.md:582
msgid ""
"Choosing to catch borrowing errors at runtime rather than compile time, as "
"we’ve done here, means you’d potentially be finding mistakes in your code "
"later in the development process: possibly not until your code was deployed "
"to production. Also, your code would incur a small runtime performance "
"penalty as a result of keeping track of the borrows at runtime rather than "
"compile time. However, using `RefCell<T>` makes it possible to write a mock "
"object that can modify itself to keep track of the messages it has seen "
"while you’re using it in a context where only immutable values are allowed. "
"You can use `RefCell<T>` despite its trade-offs to get more functionality "
"than regular references provide."
msgstr ""

#: src/ch15-05-interior-mutability.md:593
msgid ""
"Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`"
msgstr ""

#: src/ch15-05-interior-mutability.md:595
msgid ""
"A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that "
"`Rc<T>` lets you have multiple owners of some data, but it only gives "
"immutable access to that data. If you have an `Rc<T>` that holds a "
"`RefCell<T>`, you can get a value that can have multiple owners _and_ that "
"you can mutate!"
msgstr ""

#: src/ch15-05-interior-mutability.md:600
msgid ""
"For example, recall the cons list example in Listing 15-18 where we used "
"`Rc<T>` to allow multiple lists to share ownership of another list. Because "
"`Rc<T>` holds only immutable values, we can’t change any of the values in "
"the list once we’ve created them. Let’s add in `RefCell<T>` to gain the "
"ability to change the values in the lists. Listing 15-24 shows that by using "
"a `RefCell<T>` in the `Cons` definition, we can modify the value stored in "
"all the lists:"
msgstr ""

#: src/ch15-05-interior-mutability.md:631
msgid "\"a after = {a:?}\""
msgstr ""

#: src/ch15-05-interior-mutability.md:632
msgid "\"b after = {b:?}\""
msgstr ""

#: src/ch15-05-interior-mutability.md:633
msgid "\"c after = {c:?}\""
msgstr ""

#: src/ch15-05-interior-mutability.md:639
msgid ""
"We create a value that is an instance of `Rc<RefCell<i32>>` and store it in "
"a variable named `value` so we can access it directly later. Then we create "
"a `List` in `a` with a `Cons` variant that holds `value`. We need to clone "
"`value` so both `a` and `value` have ownership of the inner `5` value rather "
"than transferring ownership from `value` to `a` or having `a` borrow from "
"`value`."
msgstr ""

#: src/ch15-05-interior-mutability.md:646
msgid ""
"We wrap the list `a` in an `Rc<T>` so that when we create lists `b` and `c`, "
"they can both refer to `a`, which is what we did in Listing 15-18."
msgstr ""

#: src/ch15-05-interior-mutability.md:649
msgid ""
"After we’ve created the lists in `a`, `b`, and `c`, we want to add 10 to the "
"value in `value`. We do this by calling `borrow_mut` on `value`, which uses "
"the automatic dereferencing feature we discussed in Chapter 5 (see [“Where’s "
"the `->` Operator?”](ch05-03-method-syntax.html#wheres-the---operator)<!-- "
"ignore -->) to dereference the `Rc<T>` to the inner `RefCell<T>` value. The "
"`borrow_mut` method returns a `RefMut<T>` smart pointer, and we use the "
"dereference operator on it and change the inner value."
msgstr ""

#: src/ch15-05-interior-mutability.md:657
msgid ""
"When we print `a`, `b`, and `c`, we can see that they all have the modified "
"value of 15 rather than 5:"
msgstr ""

#: src/ch15-05-interior-mutability.md:660
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s\n"
"     Running `target/debug/cons-list`\n"
"a after = Cons(RefCell { value: 15 }, Nil)\n"
"b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\n"
"c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n"
"```"
msgstr ""

#: src/ch15-05-interior-mutability.md:670
msgid ""
"This technique is pretty neat! By using `RefCell<T>`, we have an outwardly "
"immutable `List` value. But we can use the methods on `RefCell<T>` that "
"provide access to its interior mutability so we can modify our data when we "
"need to. The runtime checks of the borrowing rules protect us from data "
"races, and it’s sometimes worth trading a bit of speed for this flexibility "
"in our data structures. Note that `RefCell<T>` does not work for "
"multithreaded code! `Mutex<T>` is the thread-safe version of `RefCell<T>` "
"and we’ll discuss `Mutex<T>` in Chapter 16."
msgstr ""

#: src/ch15-06-reference-cycles.md:3
msgid ""
"Rust’s memory safety guarantees make it difficult, but not impossible, to "
"accidentally create memory that is never cleaned up (known as a _memory "
"leak_). Preventing memory leaks entirely is not one of Rust’s guarantees, "
"meaning memory leaks are memory safe in Rust. We can see that Rust allows "
"memory leaks by using `Rc<T>` and `RefCell<T>`: it’s possible to create "
"references where items refer to each other in a cycle. This creates memory "
"leaks because the reference count of each item in the cycle will never reach "
"0, and the values will never be dropped."
msgstr ""

#: src/ch15-06-reference-cycles.md:12
msgid "Creating a Reference Cycle"
msgstr ""

#: src/ch15-06-reference-cycles.md:14
msgid ""
"Let’s look at how a reference cycle might happen and how to prevent it, "
"starting with the definition of the `List` enum and a `tail` method in "
"Listing 15-25:"
msgstr ""

#: src/ch15-06-reference-cycles.md:45
msgid ""
"We’re using another variation of the `List` definition from Listing 15-5. "
"The second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning "
"that instead of having the ability to modify the `i32` value as we did in "
"Listing 15-24, we want to modify the `List` value a `Cons` variant is "
"pointing to. We’re also adding a `tail` method to make it convenient for us "
"to access the second item if we have a `Cons` variant."
msgstr ""

#: src/ch15-06-reference-cycles.md:52
msgid ""
"In Listing 15-26, we’re adding a `main` function that uses the definitions "
"in Listing 15-25. This code creates a list in `a` and a list in `b` that "
"points to the list in `a`. Then it modifies the list in `a` to point to `b`, "
"creating a reference cycle. There are `println!` statements along the way to "
"show what the reference counts are at various points in this process."
msgstr ""

#: src/ch15-06-reference-cycles.md:83
msgid "\"a initial rc count = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:84
msgid "\"a next item = {:?}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:88
msgid "\"a rc count after b creation = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:89
msgid "\"b initial rc count = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:90
msgid "\"b next item = {:?}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:96
msgid "\"b rc count after changing a = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:97
msgid "\"a rc count after changing a = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:99
msgid ""
"// Uncomment the next line to see that we have a cycle;\n"
"    // it will overflow the stack.\n"
"    // println!(\"a next item = {:?}\", a.tail());\n"
msgstr ""

#: src/ch15-06-reference-cycles.md:107
msgid ""
"We create an `Rc<List>` instance holding a `List` value in the variable `a` "
"with an initial list of `5, Nil`. We then create an `Rc<List>` instance "
"holding another `List` value in the variable `b` that contains the value 10 "
"and points to the list in `a`."
msgstr ""

#: src/ch15-06-reference-cycles.md:112
msgid ""
"We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We do "
"that by using the `tail` method to get a reference to the "
"`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use "
"the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value "
"inside from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`."
msgstr ""

#: src/ch15-06-reference-cycles.md:118
msgid ""
"When we run this code, keeping the last `println!` commented out for the "
"moment, we’ll get this output:"
msgstr ""

#: src/ch15-06-reference-cycles.md:121
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s\n"
"     Running `target/debug/cons-list`\n"
"a initial rc count = 1\n"
"a next item = Some(RefCell { value: Nil })\n"
"a rc count after b creation = 2\n"
"b initial rc count = 1\n"
"b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\n"
"b rc count after changing a = 2\n"
"a rc count after changing a = 2\n"
"```"
msgstr ""

#: src/ch15-06-reference-cycles.md:135
msgid ""
"The reference count of the `Rc<List>` instances in both `a` and `b` are 2 "
"after we change the list in `a` to point to `b`. At the end of `main`, Rust "
"drops the variable `b`, which decreases the reference count of the `b` "
"`Rc<List>` instance from 2 to 1. The memory that `Rc<List>` has on the heap "
"won’t be dropped at this point, because its reference count is 1, not 0. "
"Then Rust drops `a`, which decreases the reference count of the `a` "
"`Rc<List>` instance from 2 to 1 as well. This instance’s memory can’t be "
"dropped either, because the other `Rc<List>` instance still refers to it. "
"The memory allocated to the list will remain uncollected forever. To "
"visualize this reference cycle, we’ve created the diagram in Figure 15-4."
msgstr ""

#: src/ch15-06-reference-cycles.md:148
msgid ""
"<span class=\"caption\">Figure 15-4: A reference cycle of lists `a` and `b` "
"pointing to each other</span>"
msgstr ""

#: src/ch15-06-reference-cycles.md:151
msgid ""
"If you uncomment the last `println!` and run the program, Rust will try to "
"print this cycle with `a` pointing to `b` pointing to `a`, and so forth, "
"until it overflows the stack."
msgstr ""

#: src/ch15-06-reference-cycles.md:155
msgid ""
"Compared to a real-world program, the consequences of creating a reference "
"cycle in this example aren’t very dire: right after we create the reference "
"cycle, the program ends. However, if a more complex program allocated lots "
"of memory in a cycle and held onto it for a long time, the program would use "
"more memory than it needed and might overwhelm the system, causing it to run "
"out of available memory."
msgstr ""

#: src/ch15-06-reference-cycles.md:162
msgid ""
"Creating reference cycles is not easily done, but it’s not impossible "
"either. If you have `RefCell<T>` values that contain `Rc<T>` values or "
"similar nested combinations of types with interior mutability and reference "
"counting, you must ensure that you don’t create cycles; you can’t rely on "
"Rust to catch them. Creating a reference cycle would be a logic bug in your "
"program that you should use automated tests, code reviews, and other "
"software development practices to minimize."
msgstr ""

#: src/ch15-06-reference-cycles.md:170
msgid ""
"Another solution for avoiding reference cycles is reorganizing your data "
"structures so that some references express ownership and some references "
"don’t. As a result, you can have cycles made up of some ownership "
"relationships and some non-ownership relationships, and only the ownership "
"relationships affect whether or not a value can be dropped. In Listing "
"15-25, we always want `Cons` variants to own their list, so reorganizing the "
"data structure isn’t possible. Let’s look at an example using graphs made up "
"of parent nodes and child nodes to see when non-ownership relationships are "
"an appropriate way to prevent reference cycles."
msgstr ""

#: src/ch15-06-reference-cycles.md:180
msgid "Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`"
msgstr ""

#: src/ch15-06-reference-cycles.md:182
msgid ""
"So far, we’ve demonstrated that calling `Rc::clone` increases the "
"`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only "
"cleaned up if its `strong_count` is 0. You can also create a _weak "
"reference_ to the value within an `Rc<T>` instance by calling "
"`Rc::downgrade` and passing a reference to the `Rc<T>`. _Strong references_ "
"are how you can share ownership of an `Rc<T>` instance. _Weak references_ "
"don’t express an ownership relationship, and their count doesn’t affect when "
"an `Rc<T>` instance is cleaned up. They won’t cause a reference cycle "
"because any cycle involving some weak references will be broken once the "
"strong reference count of values involved is 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:192
msgid ""
"When you call `Rc::downgrade`, you get a smart pointer of type `Weak<T>`. "
"Instead of increasing the `strong_count` in the `Rc<T>` instance by 1, "
"calling `Rc::downgrade` increases the `weak_count` by 1. The `Rc<T>` type "
"uses `weak_count` to keep track of how many `Weak<T>` references exist, "
"similar to `strong_count`. The difference is the `weak_count` doesn’t need "
"to be 0 for the `Rc<T>` instance to be cleaned up."
msgstr ""

#: src/ch15-06-reference-cycles.md:199
msgid ""
"Because the value that `Weak<T>` references might have been dropped, to do "
"anything with the value that a `Weak<T>` is pointing to, you must make sure "
"the value still exists. Do this by calling the `upgrade` method on a "
"`Weak<T>` instance, which will return an `Option<Rc<T>>`. You’ll get a "
"result of `Some` if the `Rc<T>` value has not been dropped yet and a result "
"of `None` if the `Rc<T>` value has been dropped. Because `upgrade` returns "
"an `Option<Rc<T>>`, Rust will ensure that the `Some` case and the `None` "
"case are handled, and there won’t be an invalid pointer."
msgstr ""

#: src/ch15-06-reference-cycles.md:208
msgid ""
"As an example, rather than using a list whose items know only about the next "
"item, we’ll create a tree whose items know about their children items _and_ "
"their parent items."
msgstr ""

#: src/ch15-06-reference-cycles.md:212
msgid "Creating a Tree Data Structure: a `Node` with Child Nodes"
msgstr ""

#: src/ch15-06-reference-cycles.md:214
msgid ""
"To start, we’ll build a tree with nodes that know about their child nodes. "
"We’ll create a struct named `Node` that holds its own `i32` value as well as "
"references to its children `Node` values:"
msgstr ""

#: src/ch15-06-reference-cycles.md:243
msgid ""
"We want a `Node` to own its children, and we want to share that ownership "
"with variables so we can access each `Node` in the tree directly. To do "
"this, we define the `Vec<T>` items to be values of type `Rc<Node>`. We also "
"want to modify which nodes are children of another node, so we have a "
"`RefCell<T>` in `children` around the `Vec<Rc<Node>>`."
msgstr ""

#: src/ch15-06-reference-cycles.md:249
msgid ""
"Next, we’ll use our struct definition and create one `Node` instance named "
"`leaf` with the value 3 and no children, and another instance named `branch` "
"with the value 5 and `leaf` as one of its children, as shown in Listing "
"15-27:"
msgstr ""

#: src/ch15-06-reference-cycles.md:280
msgid ""
"We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the "
"`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from "
"`branch` to `leaf` through `branch.children`, but there’s no way to get from "
"`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` "
"and doesn’t know they’re related. We want `leaf` to know that `branch` is "
"its parent. We’ll do that next."
msgstr ""

#: src/ch15-06-reference-cycles.md:287
msgid "Adding a Reference from a Child to Its Parent"
msgstr ""

#: src/ch15-06-reference-cycles.md:289
msgid ""
"To make the child node aware of its parent, we need to add a `parent` field "
"to our `Node` struct definition. The trouble is in deciding what the type of "
"`parent` should be. We know it can’t contain an `Rc<T>`, because that would "
"create a reference cycle with `leaf.parent` pointing to `branch` and "
"`branch.children` pointing to `leaf`, which would cause their `strong_count` "
"values to never be 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:296
msgid ""
"Thinking about the relationships another way, a parent node should own its "
"children: if a parent node is dropped, its child nodes should be dropped as "
"well. However, a child should not own its parent: if we drop a child node, "
"the parent should still exist. This is a case for weak references!"
msgstr ""

#: src/ch15-06-reference-cycles.md:301
msgid ""
"So instead of `Rc<T>`, we’ll make the type of `parent` use `Weak<T>`, "
"specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks "
"like this:"
msgstr ""

#: src/ch15-06-reference-cycles.md:325 src/ch15-06-reference-cycles.md:335
#: src/ch15-06-reference-cycles.md:363 src/ch15-06-reference-cycles.md:373
#: src/ch15-06-reference-cycles.md:471
msgid "\"leaf parent = {:?}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:339
msgid ""
"A node will be able to refer to its parent node but doesn’t own its parent. "
"In Listing 15-28, we update `main` to use this new definition so the `leaf` "
"node will have a way to refer to its parent, `branch`:"
msgstr ""

#: src/ch15-06-reference-cycles.md:379
msgid ""
"Creating the `leaf` node looks similar to Listing 15-27 with the exception "
"of the `parent` field: `leaf` starts out without a parent, so we create a "
"new, empty `Weak<Node>` reference instance."
msgstr ""

#: src/ch15-06-reference-cycles.md:383
msgid ""
"At this point, when we try to get a reference to the parent of `leaf` by "
"using the `upgrade` method, we get a `None` value. We see this in the output "
"from the first `println!` statement:"
msgstr ""

#: src/ch15-06-reference-cycles.md:391
msgid ""
"When we create the `branch` node, it will also have a new `Weak<Node>` "
"reference in the `parent` field, because `branch` doesn’t have a parent "
"node. We still have `leaf` as one of the children of `branch`. Once we have "
"the `Node` instance in `branch`, we can modify `leaf` to give it a "
"`Weak<Node>` reference to its parent. We use the `borrow_mut` method on the "
"`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the "
"`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from "
"the `Rc<Node>` in `branch`."
msgstr ""

#: src/ch15-06-reference-cycles.md:400
msgid ""
"When we print the parent of `leaf` again, this time we’ll get a `Some` "
"variant holding `branch`: now `leaf` can access its parent! When we print "
"`leaf`, we also avoid the cycle that eventually ended in a stack overflow "
"like we had in Listing 15-26; the `Weak<Node>` references are printed as "
"`(Weak)`:"
msgstr ""

#: src/ch15-06-reference-cycles.md:411
msgid ""
"The lack of infinite output indicates that this code didn’t create a "
"reference cycle. We can also tell this by looking at the values we get from "
"calling `Rc::strong_count` and `Rc::weak_count`."
msgstr ""

#: src/ch15-06-reference-cycles.md:415
msgid "Visualizing Changes to `strong_count` and `weak_count`"
msgstr ""

#: src/ch15-06-reference-cycles.md:417
msgid ""
"Let’s look at how the `strong_count` and `weak_count` values of the "
"`Rc<Node>` instances change by creating a new inner scope and moving the "
"creation of `branch` into that scope. By doing so, we can see what happens "
"when `branch` is created and then dropped when it goes out of scope. The "
"modifications are shown in Listing 15-29:"
msgstr ""

#: src/ch15-06-reference-cycles.md:444 src/ch15-06-reference-cycles.md:465
#: src/ch15-06-reference-cycles.md:473
msgid "\"leaf strong = {}, weak = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:459
msgid "\"branch strong = {}, weak = {}\""
msgstr ""

#: src/ch15-06-reference-cycles.md:482
msgid ""
"After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak "
"count of 0. In the inner scope, we create `branch` and associate it with "
"`leaf`, at which point, when we print the counts, the `Rc<Node>` in `branch` "
"will have a strong count of 1 and a weak count of 1 (for `leaf.parent` "
"pointing to `branch` with a `Weak<Node>`). When we print the counts in "
"`leaf`, we’ll see it will have a strong count of 2, because `branch` now has "
"a clone of the `Rc<Node>` of `leaf` stored in `branch.children`, but will "
"still have a weak count of 0."
msgstr ""

#: src/ch15-06-reference-cycles.md:491
msgid ""
"When the inner scope ends, `branch` goes out of scope and the strong count "
"of the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count "
"of 1 from `leaf.parent` has no bearing on whether or not `Node` is dropped, "
"so we don’t get any memory leaks!"
msgstr ""

#: src/ch15-06-reference-cycles.md:496
msgid ""
"If we try to access the parent of `leaf` after the end of the scope, we’ll "
"get `None` again. At the end of the program, the `Rc<Node>` in `leaf` has a "
"strong count of 1 and a weak count of 0, because the variable `leaf` is now "
"the only reference to the `Rc<Node>` again."
msgstr ""

#: src/ch15-06-reference-cycles.md:501
msgid ""
"All of the logic that manages the counts and value dropping is built into "
"`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By "
"specifying that the relationship from a child to its parent should be a "
"`Weak<T>` reference in the definition of `Node`, you’re able to have parent "
"nodes point to child nodes and vice versa without creating a reference cycle "
"and memory leaks."
msgstr ""

#: src/ch15-06-reference-cycles.md:510
msgid ""
"This chapter covered how to use smart pointers to make different guarantees "
"and trade-offs from those Rust makes by default with regular references. The "
"`Box<T>` type has a known size and points to data allocated on the heap. The "
"`Rc<T>` type keeps track of the number of references to data on the heap so "
"that data can have multiple owners. The `RefCell<T>` type with its interior "
"mutability gives us a type that we can use when we need an immutable type "
"but need to change an inner value of that type; it also enforces the "
"borrowing rules at runtime instead of at compile time."
msgstr ""
"이 장에서는 일반 참조와 다른 보증 및 절충안을 만들기 위해 스마트 포인터를 사용하는 방법을 다루었습니다. "
"`Box<T>` 타입은 알려진 크기를 가지며 힙에 할당된 데이터를 가리킵니다. "
"`Rc<T>` 타입은 힙의 데이터에 대한 참조 수를 추적하여 데이터가 여러 소유자를 가질 수 있도록 합니다. "
"내부 가변성을 가진 `RefCell<T>` 타입은 불변 타입이 필요하지만 해당 타입의 내부 값을 변경해야 할 때 사용할 수 있는 타입을 제공하며, 컴파일 타임 대신 런타임에 빌림 규칙을 적용합니다."

#: src/ch15-06-reference-cycles.md:519
msgid ""
"Also discussed were the `Deref` and `Drop` traits, which enable a lot of the "
"functionality of smart pointers. We explored reference cycles that can cause "
"memory leaks and how to prevent them using `Weak<T>`."
msgstr ""

#: src/ch15-06-reference-cycles.md:523
msgid ""
"If this chapter has piqued your interest and you want to implement your own "
"smart pointers, check out [“The Rustonomicon”](../nomicon/index.html) for "
"more useful information."
msgstr ""

#: src/ch15-06-reference-cycles.md:527
msgid ""
"Next, we’ll talk about concurrency in Rust. You’ll even learn about a few "
"new smart pointers."
msgstr ""

#: src/ch16-00-concurrency.md:3
msgid ""
"Handling concurrent programming safely and efficiently is another of Rust’s "
"major goals. _Concurrent programming_, in which different parts of a program "
"execute independently, and _parallel programming_, in which different parts "
"of a program execute at the same time, are becoming increasingly important "
"as more computers take advantage of their multiple processors. Historically, "
"programming in these contexts has been difficult and error prone. Rust hopes "
"to change that."
msgstr ""

#: src/ch16-00-concurrency.md:11
msgid ""
"Initially, the Rust team thought that ensuring memory safety and preventing "
"concurrency problems were two separate challenges to be solved with "
"different methods. Over time, the team discovered that the ownership and "
"type systems are a powerful set of tools to help manage memory safety _and_ "
"concurrency problems! By leveraging ownership and type checking, many "
"concurrency errors are compile-time errors in Rust rather than runtime "
"errors. Therefore, rather than making you spend lots of time trying to "
"reproduce the exact circumstances under which a runtime concurrency bug "
"occurs, incorrect code will refuse to compile and present an error "
"explaining the problem. As a result, you can fix your code while you’re "
"working on it rather than potentially after it has been shipped to "
"production. We’ve nicknamed this aspect of Rust _fearless_ _concurrency_. "
"Fearless concurrency allows you to write code that is free of subtle bugs "
"and is easy to refactor without introducing new bugs."
msgstr ""

#: src/ch16-00-concurrency.md:25
msgid ""
"Note: For simplicity’s sake, we’ll refer to many of the problems as "
"_concurrent_ rather than being more precise by saying _concurrent and/or "
"parallel_. If this book were about concurrency and/or parallelism, we’d be "
"more specific. For this chapter, please mentally substitute _concurrent and/"
"or parallel_ whenever we use _concurrent_."
msgstr ""

#: src/ch16-00-concurrency.md:31
msgid ""
"Many languages are dogmatic about the solutions they offer for handling "
"concurrent problems. For example, Erlang has elegant functionality for "
"message-passing concurrency but has only obscure ways to share state between "
"threads. Supporting only a subset of possible solutions is a reasonable "
"strategy for higher-level languages, because a higher-level language "
"promises benefits from giving up some control to gain abstractions. However, "
"lower-level languages are expected to provide the solution with the best "
"performance in any given situation and have fewer abstractions over the "
"hardware. Therefore, Rust offers a variety of tools for modeling problems in "
"whatever way is appropriate for your situation and requirements."
msgstr ""

#: src/ch16-00-concurrency.md:42
msgid "Here are the topics we’ll cover in this chapter:"
msgstr ""

#: src/ch16-00-concurrency.md:44
msgid "How to create threads to run multiple pieces of code at the same time"
msgstr ""

#: src/ch16-00-concurrency.md:45
msgid ""
"_Message-passing_ concurrency, where channels send messages between threads"
msgstr ""

#: src/ch16-00-concurrency.md:46
msgid ""
"_Shared-state_ concurrency, where multiple threads have access to some piece "
"of data"
msgstr ""

#: src/ch16-00-concurrency.md:48
msgid ""
"The `Sync` and `Send` traits, which extend Rust’s concurrency guarantees to "
"user-defined types as well as types provided by the standard library"
msgstr ""

#: src/ch16-01-threads.md:3
msgid ""
"In most current operating systems, an executed program’s code is run in a "
"_process_, and the operating system will manage multiple processes at once. "
"Within a program, you can also have independent parts that run "
"simultaneously. The features that run these independent parts are called "
"_threads_. For example, a web server could have multiple threads so that it "
"can respond to more than one request at the same time."
msgstr ""

#: src/ch16-01-threads.md:10
msgid ""
"Splitting the computation in your program into multiple threads to run "
"multiple tasks at the same time can improve performance, but it also adds "
"complexity. Because threads can run simultaneously, there’s no inherent "
"guarantee about the order in which parts of your code on different threads "
"will run. This can lead to problems, such as:"
msgstr ""

#: src/ch16-01-threads.md:16
msgid ""
"Race conditions, in which threads are accessing data or resources in an "
"inconsistent order"
msgstr ""

#: src/ch16-01-threads.md:18
msgid ""
"Deadlocks, in which two threads are waiting for each other, preventing both "
"threads from continuing"
msgstr ""

#: src/ch16-01-threads.md:20
msgid ""
"Bugs that happen only in certain situations and are hard to reproduce and "
"fix reliably"
msgstr ""

#: src/ch16-01-threads.md:23
msgid ""
"Rust attempts to mitigate the negative effects of using threads, but "
"programming in a multithreaded context still takes careful thought and "
"requires a code structure that is different from that in programs running in "
"a single thread."
msgstr ""

#: src/ch16-01-threads.md:28
msgid ""
"Programming languages implement threads in a few different ways, and many "
"operating systems provide an API the language can call for creating new "
"threads. The Rust standard library uses a _1:1_ model of thread "
"implementation, whereby a program uses one operating system thread per one "
"language thread. There are crates that implement other models of threading "
"that make different tradeoffs to the 1:1 model. (Rust’s async system, which "
"we will see in the next chapter, provides another approach to concurrency as "
"well.)"
msgstr ""

#: src/ch16-01-threads.md:36
msgid "Creating a New Thread with `spawn`"
msgstr ""

#: src/ch16-01-threads.md:38
msgid ""
"To create a new thread, we call the `thread::spawn` function and pass it a "
"closure (we talked about closures in Chapter 13) containing the code we want "
"to run in the new thread. The example in Listing 16-1 prints some text from "
"a main thread and other text from a new thread:"
msgstr ""

#: src/ch16-01-threads.md:52 src/ch16-01-threads.md:122
#: src/ch16-01-threads.md:179
msgid "\"hi number {i} from the spawned thread!\""
msgstr ""

#: src/ch16-01-threads.md:58 src/ch16-01-threads.md:128
#: src/ch16-01-threads.md:187
msgid "\"hi number {i} from the main thread!\""
msgstr ""

#: src/ch16-01-threads.md:66
msgid ""
"Note that when the main thread of a Rust program completes, all spawned "
"threads are shut down, whether or not they have finished running. The output "
"from this program might be a little different every time, but it will look "
"similar to the following:"
msgstr ""

#: src/ch16-01-threads.md:87
msgid ""
"The calls to `thread::sleep` force a thread to stop its execution for a "
"short duration, allowing a different thread to run. The threads will "
"probably take turns, but that isn’t guaranteed: it depends on how your "
"operating system schedules the threads. In this run, the main thread printed "
"first, even though the print statement from the spawned thread appears first "
"in the code. And even though we told the spawned thread to print until `i` "
"is `9`, it only got to `5` before the main thread shut down."
msgstr ""

#: src/ch16-01-threads.md:95
msgid ""
"If you run this code and only see output from the main thread, or don’t see "
"any overlap, try increasing the numbers in the ranges to create more "
"opportunities for the operating system to switch between the threads."
msgstr ""

#: src/ch16-01-threads.md:99
msgid "Waiting for All Threads to Finish Using `join` Handles"
msgstr ""

#: src/ch16-01-threads.md:101
msgid ""
"The code in Listing 16-1 not only stops the spawned thread prematurely most "
"of the time due to the main thread ending, but because there is no guarantee "
"on the order in which threads run, we also can’t guarantee that the spawned "
"thread will get to run at all!"
msgstr ""

#: src/ch16-01-threads.md:106
msgid ""
"We can fix the problem of the spawned thread not running or ending "
"prematurely by saving the return value of `thread::spawn` in a variable. The "
"return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned "
"value that, when we call the `join` method on it, will wait for its thread "
"to finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we "
"created in Listing 16-1 and how to call `join` to make sure the spawned "
"thread finishes before `main` exits:"
msgstr ""

#: src/ch16-01-threads.md:138
msgid ""
"Calling `join` on the handle blocks the thread currently running until the "
"thread represented by the handle terminates. _Blocking_ a thread means that "
"thread is prevented from performing work or exiting. Because we’ve put the "
"call to `join` after the main thread’s `for` loop, running Listing 16-2 "
"should produce output similar to this:"
msgstr ""

#: src/ch16-01-threads.md:164
msgid ""
"The two threads continue alternating, but the main thread waits because of "
"the call to `handle.join()` and does not end until the spawned thread is "
"finished."
msgstr ""

#: src/ch16-01-threads.md:167
msgid ""
"But let’s see what happens when we instead move `handle.join()` before the "
"`for` loop in `main`, like this:"
msgstr ""

#: src/ch16-01-threads.md:195
msgid ""
"The main thread will wait for the spawned thread to finish and then run its "
"`for` loop, so the output won’t be interleaved anymore, as shown here:"
msgstr ""

#: src/ch16-01-threads.md:218
msgid ""
"Small details, such as where `join` is called, can affect whether or not "
"your threads run at the same time."
msgstr ""

#: src/ch16-01-threads.md:221
msgid "Using `move` Closures with Threads"
msgstr ""

#: src/ch16-01-threads.md:223
msgid ""
"We'll often use the `move` keyword with closures passed to `thread::spawn` "
"because the closure will then take ownership of the values it uses from the "
"environment, thus transferring ownership of those values from one thread to "
"another. In [“Capturing References or Moving Ownership”](ch13-01-"
"closures.html#capturing-references-or-moving-ownership)<!-- ignore --> in "
"Chapter 13, we discussed `move` in the context of closures. Now, we’ll "
"concentrate more on the interaction between `move` and `thread::spawn`."
msgstr ""

#: src/ch16-01-threads.md:230
msgid ""
"Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no "
"arguments: we’re not using any data from the main thread in the spawned "
"thread’s code. To use data from the main thread in the spawned thread, the "
"spawned thread’s closure must capture the values it needs. Listing 16-3 "
"shows an attempt to create a vector in the main thread and use it in the "
"spawned thread. However, this won’t yet work, as you’ll see in a moment."
msgstr ""

#: src/ch16-01-threads.md:246 src/ch16-01-threads.md:305
#: src/ch16-01-threads.md:351
msgid "\"Here's a vector: {v:?}\""
msgstr ""

#: src/ch16-01-threads.md:255
msgid ""
"The closure uses `v`, so it will capture `v` and make it part of the "
"closure’s environment. Because `thread::spawn` runs this closure in a new "
"thread, we should be able to access `v` inside that new thread. But when we "
"compile this example, we get the following error:"
msgstr ""

#: src/ch16-01-threads.md:260
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling threads v0.1.0 (file:///projects/threads)\n"
"error[E0373]: closure may outlive the current function, but it borrows `v`, "
"which is owned by the current function\n"
" --> src/main.rs:6:32\n"
"  |\n"
"6 |     let handle = thread::spawn(|| {\n"
"  |                                ^^ may outlive borrowed value `v`\n"
"7 |         println!(\"Here's a vector: {v:?}\");\n"
"  |                                     - `v` is borrowed here\n"
"  |\n"
"note: function requires argument type to outlive `'static`\n"
" --> src/main.rs:6:18\n"
"  |\n"
"6 |       let handle = thread::spawn(|| {\n"
"  |  __________________^\n"
"7 | |         println!(\"Here's a vector: {v:?}\");\n"
"8 | |     });\n"
"  | |______^\n"
"help: to force the closure to take ownership of `v` (and any other "
"referenced variables), use the `move` keyword\n"
"  |\n"
"6 |     let handle = thread::spawn(move || {\n"
"  |                                ++++\n"
"\n"
"For more information about this error, try `rustc --explain E0373`.\n"
"error: could not compile `threads` (bin \"threads\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:288
msgid ""
"Rust _infers_ how to capture `v`, and because `println!` only needs a "
"reference to `v`, the closure tries to borrow `v`. However, there’s a "
"problem: Rust can’t tell how long the spawned thread will run, so it doesn’t "
"know if the reference to `v` will always be valid."
msgstr ""

#: src/ch16-01-threads.md:293
msgid ""
"Listing 16-4 provides a scenario that’s more likely to have a reference to "
"`v` that won’t be valid:"
msgstr ""

#: src/ch16-01-threads.md:308
msgid "// oh no!\n"
msgstr ""

#: src/ch16-01-threads.md:316
msgid ""
"If Rust allowed us to run this code, there’s a possibility the spawned "
"thread would be immediately put in the background without running at all. "
"The spawned thread has a reference to `v` inside, but the main thread "
"immediately drops `v`, using the `drop` function we discussed in Chapter 15. "
"Then, when the spawned thread starts to execute, `v` is no longer valid, so "
"a reference to it is also invalid. Oh no!"
msgstr ""

#: src/ch16-01-threads.md:323
msgid ""
"To fix the compiler error in Listing 16-3, we can use the error message’s "
"advice:"
msgstr ""

#: src/ch16-01-threads.md:337
msgid ""
"By adding the `move` keyword before the closure, we force the closure to "
"take ownership of the values it’s using rather than allowing Rust to infer "
"that it should borrow the values. The modification to Listing 16-3 shown in "
"Listing 16-5 will compile and run as we intend:"
msgstr ""

#: src/ch16-01-threads.md:360
msgid ""
"We might be tempted to try the same thing to fix the code in Listing 16-4 "
"where the main thread called `drop` by using a `move` closure. However, this "
"fix will not work because what Listing 16-4 is trying to do is disallowed "
"for a different reason. If we added `move` to the closure, we would move `v` "
"into the closure’s environment, and we could no longer call `drop` on it in "
"the main thread. We would get this compiler error instead:"
msgstr ""

#: src/ch16-01-threads.md:367
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling threads v0.1.0 (file:///projects/threads)\n"
"error[E0382]: use of moved value: `v`\n"
"  --> src/main.rs:10:10\n"
"   |\n"
"4  |     let v = vec![1, 2, 3];\n"
"   |         - move occurs because `v` has type `Vec<i32>`, which does not "
"implement the `Copy` trait\n"
"5  |\n"
"6  |     let handle = thread::spawn(move || {\n"
"   |                                ------- value moved into closure here\n"
"7  |         println!(\"Here's a vector: {v:?}\");\n"
"   |                                     - variable moved due to use in "
"closure\n"
"...\n"
"10 |     drop(v); // oh no!\n"
"   |          ^ value used here after move\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `threads` (bin \"threads\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch16-01-threads.md:388
msgid ""
"Rust’s ownership rules have saved us again! We got an error from the code in "
"Listing 16-3 because Rust was being conservative and only borrowing `v` for "
"the thread, which meant the main thread could theoretically invalidate the "
"spawned thread’s reference. By telling Rust to move ownership of `v` to the "
"spawned thread, we’re guaranteeing to Rust that the main thread won’t use "
"`v` anymore. If we change Listing 16-4 in the same way, we’re then violating "
"the ownership rules when we try to use `v` in the main thread. The `move` "
"keyword overrides Rust’s conservative default of borrowing; it doesn’t let "
"us violate the ownership rules."
msgstr ""

#: src/ch16-01-threads.md:398
msgid ""
"With a basic understanding of threads and the thread API, let’s look at what "
"we can _do_ with threads."
msgstr ""

#: src/ch16-02-message-passing.md:3
msgid ""
"One increasingly popular approach to ensuring safe concurrency is _message "
"passing_, where threads or actors communicate by sending each other messages "
"containing data. Here’s the idea in a slogan from [the Go language "
"documentation](https://golang.org/doc/effective_go.html#concurrency): “Do "
"not communicate by sharing memory; instead, share memory by communicating.”"
msgstr ""

#: src/ch16-02-message-passing.md:8
msgid ""
"To accomplish message-sending concurrency, Rust's standard library provides "
"an implementation of channels. A _channel_ is a general programming concept "
"by which data is sent from one thread to another."
msgstr ""

#: src/ch16-02-message-passing.md:12
msgid ""
"You can imagine a channel in programming as being like a directional channel "
"of water, such as a stream or a river. If you put something like a rubber "
"duck into a river, it will travel downstream to the end of the waterway."
msgstr ""

#: src/ch16-02-message-passing.md:16
msgid ""
"A channel has two halves: a transmitter and a receiver. The transmitter half "
"is the upstream location where you put rubber ducks into the river, and the "
"receiver half is where the rubber duck ends up downstream. One part of your "
"code calls methods on the transmitter with the data you want to send, and "
"another part checks the receiving end for arriving messages. A channel is "
"said to be _closed_ if either the transmitter or receiver half is dropped."
msgstr ""

#: src/ch16-02-message-passing.md:23
msgid ""
"Here, we’ll work up to a program that has one thread to generate values and "
"send them down a channel, and another thread that will receive the values "
"and print them out. We’ll be sending simple values between threads using a "
"channel to illustrate the feature. Once you’re familiar with the technique, "
"you could use channels for any threads that need to communicate between each "
"other, such as a chat system or a system where many threads perform parts of "
"a calculation and send the parts to one thread that aggregates the results."
msgstr ""

#: src/ch16-02-message-passing.md:31
msgid ""
"First, in Listing 16-6, we’ll create a channel but not do anything with it. "
"Note that this won’t compile yet because Rust can’t tell what type of values "
"we want to send over the channel."
msgstr ""

#: src/ch16-02-message-passing.md:45
msgid ""
"<span class=\"caption\">Listing 16-6: Creating a channel and assigning the "
"two halves to `tx` and `rx`</span>"
msgstr ""

#: src/ch16-02-message-passing.md:48
msgid ""
"We create a new channel using the `mpsc::channel` function; `mpsc` stands "
"for _multiple producer, single consumer_. In short, the way Rust’s standard "
"library implements channels means a channel can have multiple _sending_ ends "
"that produce values but only one _receiving_ end that consumes those values. "
"Imagine multiple streams flowing together into one big river: everything "
"sent down any of the streams will end up in one river at the end. We’ll "
"start with a single producer for now, but we’ll add multiple producers when "
"we get this example working."
msgstr ""

#: src/ch16-02-message-passing.md:57
msgid ""
"The `mpsc::channel` function returns a tuple, the first element of which is "
"the sending end—the transmitter—and the second element is the receiving end—"
"the receiver. The abbreviations `tx` and `rx` are traditionally used in many "
"fields for _transmitter_ and _receiver_ respectively, so we name our "
"variables as such to indicate each end. We’re using a `let` statement with a "
"pattern that destructures the tuples; we’ll discuss the use of patterns in "
"`let` statements and destructuring in Chapter 19. For now, know that using a "
"`let` statement this way is a convenient approach to extract the pieces of "
"the tuple returned by `mpsc::channel`."
msgstr ""

#: src/ch16-02-message-passing.md:67
msgid ""
"Let’s move the transmitting end into a spawned thread and have it send one "
"string so that the spawned thread is communicating with the main thread, as "
"shown in Listing 16-7. This is like putting a rubber duck in the river "
"upstream or sending a chat message from one thread to another."
msgstr ""

#: src/ch16-02-message-passing.md:82 src/ch16-02-message-passing.md:116
#: src/ch16-02-message-passing.md:178 src/ch16-02-message-passing.md:241
#: src/ch16-02-message-passing.md:310 src/ch17-02-concurrency-with-async.md:265
#: src/ch17-02-concurrency-with-async.md:321
#: src/ch17-02-concurrency-with-async.md:409
#: src/ch17-02-concurrency-with-async.md:487
#: src/ch17-02-concurrency-with-async.md:530 src/ch17-03-more-futures.md:25
#: src/ch17-03-more-futures.md:91 src/ch17-03-more-futures.md:198
#: src/ch17-03-more-futures.md:260 src/ch17-03-more-futures.md:455
#: src/ch17-03-more-futures.md:550 src/ch20-03-advanced-types.md:90
#: src/ch20-03-advanced-types.md:115
msgid "\"hi\""
msgstr ""

#: src/ch16-02-message-passing.md:90
msgid ""
"Again, we’re using `thread::spawn` to create a new thread and then using "
"`move` to move `tx` into the closure so that the spawned thread owns `tx`. "
"The spawned thread needs to own the transmitter to be able to send messages "
"through the channel."
msgstr ""

#: src/ch16-02-message-passing.md:95
msgid ""
"The transmitter has a `send` method that takes the value we want to send. "
"The `send` method returns a `Result<T, E>` type, so if the receiver has "
"already been dropped and there’s nowhere to send a value, the send operation "
"will return an error. In this example, we’re calling `unwrap` to panic in "
"case of an error. But in a real application, we would handle it properly: "
"return to Chapter 9 to review strategies for proper error handling."
msgstr ""

#: src/ch16-02-message-passing.md:102
msgid ""
"In Listing 16-8, we’ll get the value from the receiver in the main thread. "
"This is like retrieving the rubber duck from the water at the end of the "
"river or receiving a chat message."
msgstr ""

#: src/ch16-02-message-passing.md:121 src/ch16-02-message-passing.md:184
#: src/ch16-02-message-passing.md:254 src/ch16-02-message-passing.md:337
#: src/ch17-02-concurrency-with-async.md:269
msgid "\"Got: {received}\""
msgstr ""

#: src/ch16-02-message-passing.md:127
msgid ""
"The receiver has two useful methods: `recv` and `try_recv`. We’re using "
"`recv`, short for _receive_, which will block the main thread’s execution "
"and wait until a value is sent down the channel. Once a value is sent, "
"`recv` will return it in a `Result<T, E>`. When the transmitter closes, "
"`recv` will return an error to signal that no more values will be coming."
msgstr ""

#: src/ch16-02-message-passing.md:133
msgid ""
"The `try_recv` method doesn’t block, but will instead return a `Result<T, "
"E>` immediately: an `Ok` value holding a message if one is available and an "
"`Err` value if there aren’t any messages this time. Using `try_recv` is "
"useful if this thread has other work to do while waiting for messages: we "
"could write a loop that calls `try_recv` every so often, handles a message "
"if one is available, and otherwise does other work for a little while until "
"checking again."
msgstr ""

#: src/ch16-02-message-passing.md:141
msgid ""
"We’ve used `recv` in this example for simplicity; we don’t have any other "
"work for the main thread to do other than wait for messages, so blocking the "
"main thread is appropriate."
msgstr ""

#: src/ch16-02-message-passing.md:145
msgid ""
"When we run the code in Listing 16-8, we’ll see the value printed from the "
"main thread:"
msgstr ""

#: src/ch16-02-message-passing.md:156
msgid "Perfect!"
msgstr ""

#: src/ch16-02-message-passing.md:158
msgid "Channels and Ownership Transference"
msgstr ""

#: src/ch16-02-message-passing.md:160
msgid ""
"The ownership rules play a vital role in message sending because they help "
"you write safe, concurrent code. Preventing errors in concurrent programming "
"is the advantage of thinking about ownership throughout your Rust programs. "
"Let’s do an experiment to show how channels and ownership work together to "
"prevent problems: we’ll try to use a `val` value in the spawned thread "
"_after_ we’ve sent it down the channel. Try compiling the code in Listing "
"16-9 to see why this code isn’t allowed:"
msgstr ""

#: src/ch16-02-message-passing.md:180
msgid "\"val is {val}\""
msgstr ""

#: src/ch16-02-message-passing.md:190
msgid ""
"Here, we try to print `val` after we’ve sent it down the channel via "
"`tx.send`. Allowing this would be a bad idea: once the value has been sent "
"to another thread, that thread could modify or drop it before we try to use "
"the value again. Potentially, the other thread’s modifications could cause "
"errors or unexpected results due to inconsistent or nonexistent data. "
"However, Rust gives us an error if we try to compile the code in Listing "
"16-9:"
msgstr ""

#: src/ch16-02-message-passing.md:197
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling message-passing v0.1.0 (file:///projects/message-passing)\n"
"error[E0382]: borrow of moved value: `val`\n"
"  --> src/main.rs:10:26\n"
"   |\n"
"8  |         let val = String::from(\"hi\");\n"
"   |             --- move occurs because `val` has type `String`, which does "
"not implement the `Copy` trait\n"
"9  |         tx.send(val).unwrap();\n"
"   |                 --- value moved here\n"
"10 |         println!(\"val is {val}\");\n"
"   |                          ^^^^^ value borrowed here after move\n"
"   |\n"
"   = note: this error originates in the macro `$crate::format_args_nl` which "
"comes from the expansion of the macro `println` (in Nightly builds, run with "
"-Z macro-backtrace for more info)\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `message-passing` (bin \"message-passing\") due to "
"1 previous error\n"
"```"
msgstr ""

#: src/ch16-02-message-passing.md:216
msgid ""
"Our concurrency mistake has caused a compile time error. The `send` function "
"takes ownership of its parameter, and when the value is moved, the receiver "
"takes ownership of it. This stops us from accidentally using the value again "
"after sending it; the ownership system checks that everything is okay."
msgstr ""

#: src/ch16-02-message-passing.md:221
msgid "Sending Multiple Values and Seeing the Receiver Waiting"
msgstr ""

#: src/ch16-02-message-passing.md:223
msgid ""
"The code in Listing 16-8 compiled and ran, but it didn’t clearly show us "
"that two separate threads were talking to each other over the channel. In "
"Listing 16-10 we’ve made some modifications that will prove the code in "
"Listing 16-8 is running concurrently: the spawned thread will now send "
"multiple messages and pause for a second between each message."
msgstr ""

#: src/ch16-02-message-passing.md:242 src/ch16-02-message-passing.md:311
#: src/ch17-02-concurrency-with-async.md:322
#: src/ch17-02-concurrency-with-async.md:410
#: src/ch17-02-concurrency-with-async.md:488
#: src/ch17-02-concurrency-with-async.md:531 src/ch17-03-more-futures.md:26
#: src/ch17-03-more-futures.md:92 src/ch17-03-more-futures.md:199
#: src/ch17-03-more-futures.md:261 src/ch17-03-more-futures.md:456
#: src/ch17-03-more-futures.md:551
msgid "\"from\""
msgstr ""

#: src/ch16-02-message-passing.md:243 src/ch16-02-message-passing.md:312
#: src/ch17-02-concurrency-with-async.md:323
#: src/ch17-02-concurrency-with-async.md:411
#: src/ch17-02-concurrency-with-async.md:489
#: src/ch17-02-concurrency-with-async.md:532 src/ch17-03-more-futures.md:27
#: src/ch17-03-more-futures.md:93 src/ch17-03-more-futures.md:200
#: src/ch17-03-more-futures.md:262 src/ch17-03-more-futures.md:457
#: src/ch17-03-more-futures.md:552
msgid "\"the\""
msgstr ""

#: src/ch16-02-message-passing.md:244 src/ch16-02-message-passing.md:313
msgid "\"thread\""
msgstr ""

#: src/ch16-02-message-passing.md:261
msgid ""
"This time, the spawned thread has a vector of strings that we want to send "
"to the main thread. We iterate over them, sending each individually, and "
"pause between each by calling the `thread::sleep` function with a `Duration` "
"value of 1 second."
msgstr ""

#: src/ch16-02-message-passing.md:266
msgid ""
"In the main thread, we’re not calling the `recv` function explicitly "
"anymore: instead, we’re treating `rx` as an iterator. For each value "
"received, we’re printing it. When the channel is closed, iteration will end."
msgstr ""

#: src/ch16-02-message-passing.md:270
msgid ""
"When running the code in Listing 16-10, you should see the following output "
"with a 1-second pause in between each line:"
msgstr ""

#: src/ch16-02-message-passing.md:284
msgid ""
"Because we don’t have any code that pauses or delays in the `for` loop in "
"the main thread, we can tell that the main thread is waiting to receive "
"values from the spawned thread."
msgstr ""

#: src/ch16-02-message-passing.md:288
msgid "Creating Multiple Producers by Cloning the Transmitter"
msgstr ""

#: src/ch16-02-message-passing.md:290
msgid ""
"Earlier we mentioned that `mpsc` was an acronym for _multiple producer, "
"single consumer_. Let’s put `mpsc` to use and expand the code in Listing "
"16-10 to create multiple threads that all send values to the same receiver. "
"We can do so by cloning the transmitter, as shown in Listing 16-11:"
msgstr ""

#: src/ch16-02-message-passing.md:324 src/ch17-02-concurrency-with-async.md:550
#: src/ch17-03-more-futures.md:45 src/ch17-03-more-futures.md:111
#: src/ch17-03-more-futures.md:218 src/ch17-03-more-futures.md:280
#: src/ch17-03-more-futures.md:475 src/ch17-03-more-futures.md:572
msgid "\"more\""
msgstr ""

#: src/ch16-02-message-passing.md:325 src/ch17-02-concurrency-with-async.md:551
#: src/ch17-03-more-futures.md:46 src/ch17-03-more-futures.md:112
#: src/ch17-03-more-futures.md:219 src/ch17-03-more-futures.md:281
#: src/ch17-03-more-futures.md:476 src/ch17-03-more-futures.md:573
msgid "\"messages\""
msgstr ""

#: src/ch16-02-message-passing.md:326 src/ch17-02-concurrency-with-async.md:552
#: src/ch17-03-more-futures.md:47 src/ch17-03-more-futures.md:113
#: src/ch17-03-more-futures.md:220 src/ch17-03-more-futures.md:282
#: src/ch17-03-more-futures.md:477 src/ch17-03-more-futures.md:574
msgid "\"for\""
msgstr ""

#: src/ch16-02-message-passing.md:327 src/ch17-02-concurrency-with-async.md:553
#: src/ch17-03-more-futures.md:48 src/ch17-03-more-futures.md:114
#: src/ch17-03-more-futures.md:221 src/ch17-03-more-futures.md:283
#: src/ch17-03-more-futures.md:478 src/ch17-03-more-futures.md:575
msgid "\"you\""
msgstr ""

#: src/ch16-02-message-passing.md:346
msgid ""
"This time, before we create the first spawned thread, we call `clone` on the "
"transmitter. This will give us a new transmitter we can pass to the first "
"spawned thread. We pass the original transmitter to a second spawned thread. "
"This gives us two threads, each sending different messages to the one "
"receiver."
msgstr ""

#: src/ch16-02-message-passing.md:351
msgid "When you run the code, your output should look something like this:"
msgstr ""

#: src/ch16-02-message-passing.md:368
msgid ""
"You might see the values in another order, depending on your system. This is "
"what makes concurrency interesting as well as difficult. If you experiment "
"with `thread::sleep`, giving it various values in the different threads, "
"each run will be more nondeterministic and create different output each time."
msgstr ""

#: src/ch16-02-message-passing.md:373
msgid ""
"Now that we’ve looked at how channels work, let’s look at a different method "
"of concurrency."
msgstr ""

#: src/ch16-03-shared-state.md:3
msgid ""
"Message passing is a fine way of handling concurrency, but it’s not the only "
"one. Another method would be for multiple threads to access the same shared "
"data. Consider this part of the slogan from the Go language documentation "
"again: “do not communicate by sharing memory.”"
msgstr ""

#: src/ch16-03-shared-state.md:8
msgid ""
"What would communicating by sharing memory look like? In addition, why would "
"message-passing enthusiasts caution not to use memory sharing?"
msgstr ""

#: src/ch16-03-shared-state.md:11
msgid ""
"In a way, channels in any programming language are similar to single "
"ownership, because once you transfer a value down a channel, you should no "
"longer use that value. Shared memory concurrency is like multiple ownership: "
"multiple threads can access the same memory location at the same time. As "
"you saw in Chapter 15, where smart pointers made multiple ownership "
"possible, multiple ownership can add complexity because these different "
"owners need managing. Rust’s type system and ownership rules greatly assist "
"in getting this management correct. For an example, let’s look at mutexes, "
"one of the more common concurrency primitives for shared memory."
msgstr ""

#: src/ch16-03-shared-state.md:21
msgid "Using Mutexes to Allow Access to Data from One Thread at a Time"
msgstr ""

#: src/ch16-03-shared-state.md:23
msgid ""
"_Mutex_ is an abbreviation for _mutual exclusion_, as in, a mutex allows "
"only one thread to access some data at any given time. To access the data in "
"a mutex, a thread must first signal that it wants access by asking to "
"acquire the mutex’s _lock_. The lock is a data structure that is part of the "
"mutex that keeps track of who currently has exclusive access to the data. "
"Therefore, the mutex is described as _guarding_ the data it holds via the "
"locking system."
msgstr ""

#: src/ch16-03-shared-state.md:30
msgid ""
"Mutexes have a reputation for being difficult to use because you have to "
"remember two rules:"
msgstr ""

#: src/ch16-03-shared-state.md:33
msgid "You must attempt to acquire the lock before using the data."
msgstr ""

#: src/ch16-03-shared-state.md:34
msgid ""
"When you’re done with the data that the mutex guards, you must unlock the "
"data so other threads can acquire the lock."
msgstr ""

#: src/ch16-03-shared-state.md:37
msgid ""
"For a real-world metaphor for a mutex, imagine a panel discussion at a "
"conference with only one microphone. Before a panelist can speak, they have "
"to ask or signal that they want to use the microphone. When they get the "
"microphone, they can talk for as long as they want to and then hand the "
"microphone to the next panelist who requests to speak. If a panelist forgets "
"to hand the microphone off when they’re finished with it, no one else is "
"able to speak. If management of the shared microphone goes wrong, the panel "
"won’t work as planned!"
msgstr ""

#: src/ch16-03-shared-state.md:46
msgid ""
"Management of mutexes can be incredibly tricky to get right, which is why so "
"many people are enthusiastic about channels. However, thanks to Rust’s type "
"system and ownership rules, you can’t get locking and unlocking wrong."
msgstr ""

#: src/ch16-03-shared-state.md:50
msgid "The API of `Mutex<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:52
msgid ""
"As an example of how to use a mutex, let’s start by using a mutex in a "
"single-threaded context, as shown in Listing 16-12:"
msgstr ""

#: src/ch16-03-shared-state.md:68
msgid "\"m = {m:?}\""
msgstr ""

#: src/ch16-03-shared-state.md:74
msgid ""
"As with many types, we create a `Mutex<T>` using the associated function "
"`new`. To access the data inside the mutex, we use the `lock` method to "
"acquire the lock. This call will block the current thread so it can’t do any "
"work until it’s our turn to have the lock."
msgstr ""

#: src/ch16-03-shared-state.md:79
msgid ""
"The call to `lock` would fail if another thread holding the lock panicked. "
"In that case, no one would ever be able to get the lock, so we’ve chosen to "
"`unwrap` and have this thread panic if we’re in that situation."
msgstr ""

#: src/ch16-03-shared-state.md:83
msgid ""
"After we’ve acquired the lock, we can treat the return value, named `num` in "
"this case, as a mutable reference to the data inside. The type system "
"ensures that we acquire a lock before using the value in `m`. The type of "
"`m` is `Mutex<i32>`, not `i32`, so we _must_ call `lock` to be able to use "
"the `i32` value. We can’t forget; the type system won’t let us access the "
"inner `i32` otherwise."
msgstr ""

#: src/ch16-03-shared-state.md:90
msgid ""
"As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the "
"call to `lock` _returns_ a smart pointer called `MutexGuard`, wrapped in a "
"`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` "
"smart pointer implements `Deref` to point at our inner data; the smart "
"pointer also has a `Drop` implementation that releases the lock "
"automatically when a `MutexGuard` goes out of scope, which happens at the "
"end of the inner scope. As a result, we don’t risk forgetting to release the "
"lock and blocking the mutex from being used by other threads, because the "
"lock release happens automatically."
msgstr ""

#: src/ch16-03-shared-state.md:100
msgid ""
"After dropping the lock, we can print the mutex value and see that we were "
"able to change the inner `i32` to 6."
msgstr ""

#: src/ch16-03-shared-state.md:103
msgid "Sharing a `Mutex<T>` Between Multiple Threads"
msgstr ""

#: src/ch16-03-shared-state.md:105
msgid ""
"Now, let’s try to share a value between multiple threads using `Mutex<T>`. "
"We’ll spin up 10 threads and have them each increment a counter value by 1, "
"so the counter goes from 0 to 10. The next example in Listing 16-13 will "
"have a compiler error, and we’ll use that error to learn more about using "
"`Mutex<T>` and how Rust helps us use it correctly."
msgstr ""

#: src/ch16-03-shared-state.md:134 src/ch16-03-shared-state.md:221
#: src/ch16-03-shared-state.md:328
msgid "\"Result: {}\""
msgstr ""

#: src/ch16-03-shared-state.md:140
msgid ""
"We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we "
"did in Listing 16-12. Next, we create 10 threads by iterating over a range "
"of numbers. We use `thread::spawn` and give all the threads the same "
"closure: one that moves the counter into the thread, acquires a lock on the "
"`Mutex<T>` by calling the `lock` method, and then adds 1 to the value in the "
"mutex. When a thread finishes running its closure, `num` will go out of "
"scope and release the lock so another thread can acquire it."
msgstr ""

#: src/ch16-03-shared-state.md:148
msgid ""
"In the main thread, we collect all the join handles. Then, as we did in "
"Listing 16-2, we call `join` on each handle to make sure all the threads "
"finish. At that point, the main thread will acquire the lock and print the "
"result of this program."
msgstr ""

#: src/ch16-03-shared-state.md:153
msgid "We hinted that this example wouldn’t compile. Now let’s find out why!"
msgstr ""

#: src/ch16-03-shared-state.md:155
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0382]: borrow of moved value: `counter`\n"
"  --> src/main.rs:21:29\n"
"   |\n"
"5  |     let counter = Mutex::new(0);\n"
"   |         ------- move occurs because `counter` has type `Mutex<i32>`, "
"which does not implement the `Copy` trait\n"
"...\n"
"8  |     for _ in 0..10 {\n"
"   |     -------------- inside of this loop\n"
"9  |         let handle = thread::spawn(move || {\n"
"   |                                    ------- value moved into closure "
"here, in previous iteration of loop\n"
"...\n"
"21 |     println!(\"Result: {}\", *counter.lock().unwrap());\n"
"   |                             ^^^^^^^ value borrowed here after move\n"
"   |\n"
"help: consider moving the expression out of the loop so it is only moved "
"once\n"
"   |\n"
"8  ~     let mut value = counter.lock();\n"
"9  ~     for _ in 0..10 {\n"
"10 |         let handle = thread::spawn(move || {\n"
"11 ~             let mut num = value.unwrap();\n"
"   |\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `shared-state` (bin \"shared-state\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:184
msgid ""
"The error message states that the `counter` value was moved in the previous "
"iteration of the loop. Rust is telling us that we can’t move the ownership "
"of `counter` into multiple threads. Let’s fix the compiler error with a "
"multiple-ownership method we discussed in Chapter 15."
msgstr ""

#: src/ch16-03-shared-state.md:189
msgid "Multiple Ownership with Multiple Threads"
msgstr ""

#: src/ch16-03-shared-state.md:191
msgid ""
"In Chapter 15, we gave a value multiple owners by using the smart pointer "
"`Rc<T>` to create a reference counted value. Let’s do the same here and see "
"what happens. We’ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and "
"clone the `Rc<T>` before moving ownership to the thread."
msgstr ""

#: src/ch16-03-shared-state.md:227
msgid ""
"Once again, we compile and get… different errors! The compiler is teaching "
"us a lot."
msgstr ""

#: src/ch16-03-shared-state.md:230
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely\n"
"   --> src/main.rs:11:36\n"
"    |\n"
"11  |           let handle = thread::spawn(move || {\n"
"    |                        ------------- ^------\n"
"    |                        |             |\n"
"    |  ______________________|_____________within this `{closure@src/"
"main.rs:11:36: 11:43}`\n"
"    | |                      |\n"
"    | |                      required by a bound introduced by this call\n"
"12  | |             let mut num = counter.lock().unwrap();\n"
"13  | |\n"
"14  | |             *num += 1;\n"
"15  | |         });\n"
"    | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely\n"
"    |\n"
"    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is "
"not implemented for `Rc<Mutex<i32>>`, which is required by `{closure@src/"
"main.rs:11:36: 11:43}: Send`\n"
"note: required because it's used within this closure\n"
"   --> src/main.rs:11:36\n"
"    |\n"
"11  |         let handle = thread::spawn(move || {\n"
"    |                                    ^^^^^^^\n"
"note: required by a bound in `spawn`\n"
"   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/"
"src/thread/mod.rs:675:8\n"
"    |\n"
"672 | pub fn spawn<F, T>(f: F) -> JoinHandle<T>\n"
"    |        ----- required by a bound in this function\n"
"...\n"
"675 |     F: Send + 'static,\n"
"    |        ^^^^ required by this bound in `spawn`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `shared-state` (bin \"shared-state\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:267
msgid ""
"Wow, that error message is very wordy! Here’s the important part to focus "
"on: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The "
"compiler is also telling us the reason why: `` the trait `Send` is not "
"implemented for `Rc<Mutex<i32>>` ``. We’ll talk about `Send` in the next "
"section: it’s one of the traits that ensures the types we use with threads "
"are meant for use in concurrent situations."
msgstr ""

#: src/ch16-03-shared-state.md:274
msgid ""
"Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>` "
"manages the reference count, it adds to the count for each call to `clone` "
"and subtracts from the count when each clone is dropped. But it doesn’t use "
"any concurrency primitives to make sure that changes to the count can’t be "
"interrupted by another thread. This could lead to wrong counts—subtle bugs "
"that could in turn lead to memory leaks or a value being dropped before "
"we’re done with it. What we need is a type that is exactly like `Rc<T>` but "
"one that makes changes to the reference count in a thread-safe way."
msgstr ""

#: src/ch16-03-shared-state.md:283
msgid "Atomic Reference Counting with `Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:285
msgid ""
"Fortunately, `Arc<T>` _is_ a type like `Rc<T>` that is safe to use in "
"concurrent situations. The _a_ stands for _atomic_, meaning it’s an "
"_atomically reference-counted_ type. Atomics are an additional kind of "
"concurrency primitive that we won’t cover in detail here: see the standard "
"library documentation for [`std::sync::atomic`](../std/sync/atomic/"
"index.html)<!-- ignore --> for more details. At this point, you just need to "
"know that atomics work like primitive types but are safe to share across "
"threads."
msgstr ""

#: src/ch16-03-shared-state.md:293
msgid ""
"You might then wonder why all primitive types aren’t atomic and why standard "
"library types aren’t implemented to use `Arc<T>` by default. The reason is "
"that thread safety comes with a performance penalty that you only want to "
"pay when you really need to. If you’re just performing operations on values "
"within a single thread, your code can run faster if it doesn’t have to "
"enforce the guarantees atomics provide."
msgstr ""

#: src/ch16-03-shared-state.md:300
msgid ""
"Let’s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we "
"fix our program by changing the `use` line, the call to `new`, and the call "
"to `clone`. The code in Listing 16-15 will finally compile and run:"
msgstr ""

#: src/ch16-03-shared-state.md:344
msgid ""
"We did it! We counted from 0 to 10, which may not seem very impressive, but "
"it did teach us a lot about `Mutex<T>` and thread safety. You could also use "
"this program’s structure to do more complicated operations than just "
"incrementing a counter. Using this strategy, you can divide a calculation "
"into independent parts, split those parts across threads, and then use a "
"`Mutex<T>` to have each thread update the final result with its part."
msgstr ""

#: src/ch16-03-shared-state.md:351
msgid ""
"Note that if you are doing simple numerical operations, there are types "
"simpler than `Mutex<T>` types provided by the [`std::sync::atomic` module of "
"the standard library](../std/sync/atomic/index.html)<!-- ignore -->. These "
"types provide safe, concurrent, atomic access to primitive types. We chose "
"to use `Mutex<T>` with a primitive type for this example so we could "
"concentrate on how `Mutex<T>` works."
msgstr ""

#: src/ch16-03-shared-state.md:357
msgid "Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:359
msgid ""
"You might have noticed that `counter` is immutable, but we could get a "
"mutable reference to the value inside it; this means `Mutex<T>` provides "
"interior mutability, as the `Cell` family does. In the same way we used "
"`RefCell<T>` in Chapter 15 to allow us to mutate contents inside an `Rc<T>`, "
"we use `Mutex<T>` to mutate contents inside an `Arc<T>`."
msgstr ""

#: src/ch16-03-shared-state.md:365
msgid ""
"Another detail to note is that Rust can’t protect you from all kinds of "
"logic errors when you use `Mutex<T>`. Recall from Chapter 15 that using "
"`Rc<T>` came with the risk of creating reference cycles, where two `Rc<T>` "
"values refer to each other, causing memory leaks. Similarly, `Mutex<T>` "
"comes with the risk of creating _deadlocks_. These occur when an operation "
"needs to lock two resources and two threads have each acquired one of the "
"locks, causing them to wait for each other forever. If you’re interested in "
"deadlocks, try creating a Rust program that has a deadlock; then research "
"deadlock mitigation strategies for mutexes in any language and have a go at "
"implementing them in Rust. The standard library API documentation for "
"`Mutex<T>` and `MutexGuard` offers useful information."
msgstr ""

#: src/ch16-03-shared-state.md:377
msgid ""
"We’ll round out this chapter by talking about the `Send` and `Sync` traits "
"and how we can use them with custom types."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:3
msgid ""
"Interestingly, the Rust language has _very_ few concurrency features. Almost "
"every concurrency feature we’ve talked about so far in this chapter has been "
"part of the standard library, not the language. Your options for handling "
"concurrency are not limited to the language or the standard library; you can "
"write your own concurrency features or use those written by others."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:9
msgid ""
"However, two concurrency concepts are embedded in the language: the "
"`std::marker` traits `Sync` and `Send`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:12
msgid "Allowing Transference of Ownership Between Threads with `Send`"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:14
msgid ""
"The `Send` marker trait indicates that ownership of values of the type "
"implementing `Send` can be transferred between threads. Almost every Rust "
"type is `Send`, but there are some exceptions, including `Rc<T>`: this "
"cannot be `Send` because if you cloned an `Rc<T>` value and tried to "
"transfer ownership of the clone to another thread, both threads might update "
"the reference count at the same time. For this reason, `Rc<T>` is "
"implemented for use in single-threaded situations where you don’t want to "
"pay the thread-safe performance penalty."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:23
msgid ""
"Therefore, Rust’s type system and trait bounds ensure that you can never "
"accidentally send an `Rc<T>` value across threads unsafely. When we tried to "
"do this in Listing 16-14, we got the error `the trait Send is not "
"implemented for Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is "
"`Send`, the code compiled."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:29
msgid ""
"Any type composed entirely of `Send` types is automatically marked as `Send` "
"as well. Almost all primitive types are `Send`, aside from raw pointers, "
"which we’ll discuss in Chapter 20."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:33
msgid "Allowing Access from Multiple Threads with `Sync`"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:35
msgid ""
"The `Sync` marker trait indicates that it is safe for the type implementing "
"`Sync` to be referenced from multiple threads. In other words, any type `T` "
"is `Sync` if `&T` (an immutable reference to `T`) is `Send`, meaning the "
"reference can be sent safely to another thread. Similar to `Send`, primitive "
"types are `Sync`, and types composed entirely of types that are `Sync` are "
"also `Sync`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:41
msgid ""
"The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it’s "
"not `Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and "
"the family of related `Cell<T>` types are not `Sync`. The implementation of "
"borrow checking that `RefCell<T>` does at runtime is not thread-safe. The "
"smart pointer `Mutex<T>` is `Sync` and can be used to share access with "
"multiple threads as you saw in [“Sharing a `Mutex<T>` Between Multiple "
"Threads”](ch16-03-shared-state.html#sharing-a-mutext-between-multiple-"
"threads)<!-- ignore -->."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:49
msgid "Implementing `Send` and `Sync` Manually Is Unsafe"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:51
msgid ""
"Because types that are made up of `Send` and `Sync` traits are automatically "
"also `Send` and `Sync`, we don’t have to implement those traits manually. As "
"marker traits, they don’t even have any methods to implement. They’re just "
"useful for enforcing invariants related to concurrency."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:56
msgid ""
"Manually implementing these traits involves implementing unsafe Rust code. "
"We’ll talk about using unsafe Rust code in Chapter 20; for now, the "
"important information is that building new concurrent types not made up of "
"`Send` and `Sync` parts requires careful thought to uphold the safety "
"guarantees. [“The Rustonomicon”](../nomicon/index.html) has more information "
"about these guarantees and how to uphold them."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:65
msgid ""
"This isn’t the last you’ll see of concurrency in this book: the whole next "
"chapter focuses on async programming, and the project in Chapter 21 will use "
"the concepts in this chapter in a more realistic situation than the smaller "
"examples discussed here."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:70
msgid ""
"As mentioned earlier, because very little of how Rust handles concurrency is "
"part of the language, many concurrency solutions are implemented as crates. "
"These evolve more quickly than the standard library, so be sure to search "
"online for the current, state-of-the-art crates to use in multithreaded "
"situations."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:76
msgid ""
"The Rust standard library provides channels for message passing and smart "
"pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in "
"concurrent contexts. The type system and the borrow checker ensure that the "
"code using these solutions won’t end up with data races or invalid "
"references. Once you get your code to compile, you can rest assured that it "
"will happily run on multiple threads without the kinds of hard-to-track-down "
"bugs common in other languages. Concurrent programming is no longer a "
"concept to be afraid of: go forth and make your programs concurrent, "
"fearlessly!"
msgstr ""

#: src/ch17-00-async-await.md:3
msgid ""
"Many operations we ask the computer to do can take a while to finish. It "
"would be nice if we could do something else while we are waiting for those "
"long-running processes to complete. Modern computers offer two techniques "
"for working on more than one operation at a time: parallelism and "
"concurrency. Once we start writing programs that involve parallel or "
"concurrent operations, though, we quickly encounter new challenges inherent "
"to _asynchronous programming_, where operations may not finish sequentially "
"in the order they were started. This chapter builds on Chapter 16’s use of "
"threads for parallelism and concurrency by introducing an alternative "
"approach to asynchronous programming: Rust’s Futures, Streams, the `async` "
"and `await` syntax that supports them, and the tools for managing and "
"coordinating between asynchronous operations."
msgstr ""

#: src/ch17-00-async-await.md:16
msgid ""
"Let’s consider an example. Say you’re exporting a video you’ve created of a "
"family celebration, an operation that could take anywhere from minutes to "
"hours. The video export will use as much CPU and GPU power as it can. If you "
"had only one CPU core and your operating system didn’t pause that export "
"until it completed—that is, if it executed the export _synchronously_—you "
"couldn’t do anything else on your computer while that task was running. That "
"would be a pretty frustrating experience. Fortunately, your computer’s "
"operating system can, and does, invisibly interrupt the export often enough "
"to let you get other work done simultaneously."
msgstr ""

#: src/ch17-00-async-await.md:26
msgid ""
"Now say you’re downloading a video shared by someone else, which can also "
"take a while but does not take up as much CPU time. In this case, the CPU "
"has to wait for data to arrive from the network. While you can start reading "
"the data once it starts to arrive, it might take some time for all of it to "
"show up. Even once the data is all present, if the video is quite large, it "
"could take at least a second or two to load it all. That might not sound "
"like much, but it’s a very long time for a modern processor, which can "
"perform billions of operations every second. Again, your operating system "
"will invisibly interrupt your program to allow the CPU to perform other work "
"while waiting for the network call to finish."
msgstr ""

#: src/ch17-00-async-await.md:37
msgid ""
"The video export is an example of a _CPU-bound_ or _compute-bound_ "
"operation. It’s limited by the computer’s potential data processing speed "
"within the CPU or GPU, and how much of that speed it can dedicate to the "
"operation. The video download is an example of an _IO-bound_ operation, "
"because it’s limited by the speed of the computer’s _input and output_; it "
"can only go as fast as the data can be sent across the network."
msgstr ""

#: src/ch17-00-async-await.md:44
msgid ""
"In both of these examples, the operating system’s invisible interrupts "
"provide a form of concurrency. That concurrency happens only at the level of "
"the entire program, though: the operating system interrupts one program to "
"let other programs get work done. In many cases, because we understand our "
"programs at a much more granular level than the operating system does, we "
"can spot opportunities for concurrency that the operating system can’t see."
msgstr ""

#: src/ch17-00-async-await.md:51
msgid ""
"For example, if we’re building a tool to manage file downloads, we should be "
"able to write our program so that starting one download won’t lock up the "
"UI, and users should be able to start multiple downloads at the same time. "
"Many operating system APIs for interacting with the network are _blocking_, "
"though; that is, they block the program’s progress until the data they’re "
"processing is completely ready."
msgstr ""

#: src/ch17-00-async-await.md:58
msgid ""
"Note: This is how _most_ function calls work, if you think about it. "
"However, the term _blocking_ is usually reserved for function calls that "
"interact with files, the network, or other resources on the computer, "
"because those are the cases where an individual program would benefit from "
"the operation being _non_\\-blocking."
msgstr ""

#: src/ch17-00-async-await.md:64
msgid ""
"We could avoid blocking our main thread by spawning a dedicated thread to "
"download each file. However, the overhead of those threads would eventually "
"become a problem. It would be preferable if the call didn’t block in the "
"first place. It would also be better if we could write in the same direct "
"style we use in blocking code, similar to this:"
msgstr ""

#: src/ch17-00-async-await.md:72
msgid "\"{data}\""
msgstr ""

#: src/ch17-00-async-await.md:75
msgid ""
"That is exactly what Rust’s _async_ (short for _asynchronous_) abstraction "
"gives us. In this chapter, you’ll learn all about async as we cover the "
"following topics:"
msgstr ""

#: src/ch17-00-async-await.md:79
msgid "How to use Rust’s `async` and `await` syntax"
msgstr ""

#: src/ch17-00-async-await.md:80
msgid ""
"How to use the async model to solve some of the same challenges we looked at "
"in Chapter 16"
msgstr ""

#: src/ch17-00-async-await.md:82
msgid ""
"How multithreading and async provide complementary solutions, that you can "
"combine in many cases"
msgstr ""

#: src/ch17-00-async-await.md:85
msgid ""
"Before we see how async works in practice, though, we need to take a short "
"detour to discuss the differences between parallelism and concurrency."
msgstr ""

#: src/ch17-00-async-await.md:88
msgid "Parallelism and Concurrency"
msgstr ""

#: src/ch17-00-async-await.md:90
msgid ""
"We’ve treated parallelism and concurrency as mostly interchangeable so far. "
"Now we need to distinguish between them more precisely, because the "
"differences will show up as we start working."
msgstr ""

#: src/ch17-00-async-await.md:94
msgid ""
"Consider the different ways a team could split up work on a software "
"project. You could assign a single member multiple tasks, assign each member "
"one task, or use a mix of the two approaches."
msgstr ""

#: src/ch17-00-async-await.md:98
msgid ""
"When an individual works on several different tasks before any of them is "
"complete, this is _concurrency_. Maybe you have two different projects "
"checked out on your computer, and when you get bored or stuck on one "
"project, you switch to the other. You’re just one person, so you can’t make "
"progress on both tasks at the exact same time, but you can multi-task, "
"making progress on one at a time by switching between them (see Figure 17-1)."
msgstr ""

#: src/ch17-00-async-await.md:113
msgid ""
"When the team splits up a group of tasks by having each member take one task "
"and work on it alone, this is _parallelism_. Each person on the team can "
"make progress at the exact same time (see Figure 17-2)."
msgstr ""

#: src/ch17-00-async-await.md:125
msgid ""
"In both of these workflows, you might have to coordinate between different "
"tasks. Maybe you _thought_ the task assigned to one person was totally "
"independent from everyone else’s work, but it actually requires another "
"person on the team to finish their task first. Some of the work could be "
"done in parallel, but some of it was actually _serial_: it could only happen "
"in a series, one task after the other, as in Figure 17-3."
msgstr ""

#: src/ch17-00-async-await.md:140
msgid ""
"Likewise, you might realize that one of your own tasks depends on another of "
"your tasks. Now your concurrent work has also become serial."
msgstr ""

#: src/ch17-00-async-await.md:143
msgid ""
"Parallelism and concurrency can intersect with each other, too. If you learn "
"that a colleague is stuck until you finish one of your tasks, you’ll "
"probably focus all your efforts on that task to “unblock” your colleague. "
"You and your coworker are no longer able to work in parallel, and you’re "
"also no longer able to work concurrently on your own tasks."
msgstr ""

#: src/ch17-00-async-await.md:149
msgid ""
"The same basic dynamics come into play with software and hardware. On a "
"machine with a single CPU core, the CPU can perform only one operation at a "
"time, but it can still work concurrently. Using tools such as threads, "
"processes, and async, the computer can pause one activity and switch to "
"others before eventually cycling back to that first activity again. On a "
"machine with multiple CPU cores, it can also do work in parallel. One core "
"can be performing one task while another core performs a completely "
"unrelated one, and those operations actually happen at the same time."
msgstr ""

#: src/ch17-00-async-await.md:158
msgid ""
"When working with async in Rust, we’re always dealing with concurrency. "
"Depending on the hardware, the operating system, and the async runtime we "
"are using (more on async runtimes shortly), that concurrency may also use "
"parallelism under the hood."
msgstr ""

#: src/ch17-00-async-await.md:163
msgid "Now, let’s dive into how async programming in Rust actually works."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:3
msgid ""
"The key elements of asynchronous programming in Rust are _futures_ and "
"Rust’s `async` and `await` keywords."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:6
msgid ""
"A _future_ is a value that may not be ready now but will become ready at "
"some point in the future. (This same concept shows up in many languages, "
"sometimes under other names such as _task_ or _promise_.) Rust provides a "
"`Future` trait as a building block so that different async operations can be "
"implemented with different data structures but with a common interface. In "
"Rust, futures are types that implement the `Future` trait. Each future holds "
"its own information about the progress that has been made and what \"ready\" "
"means."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:14
msgid ""
"You can apply the `async` keyword to blocks and functions to specify that "
"they can be interrupted and resumed. Within an async block or async "
"function, you can use the `await` keyword to _await a future_ (that is, wait "
"for it to become ready). Any point where you await a future within an async "
"block or function is a potential spot for that async block or function to "
"pause and resume. The process of checking with a future to see if its value "
"is available yet is called _polling_."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:22
msgid ""
"Some other languages, such as C# and JavaScript, also use `async` and "
"`await` keywords for async programming. If you’re familiar with those "
"languages, you may notice some significant differences in how Rust does "
"things, including how it handles the syntax. That’s for good reason, as "
"we’ll see!"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:27
msgid ""
"When writing async Rust, we use the `async` and `await` keywords most of the "
"time. Rust compiles them into equivalent code using the `Future` trait, much "
"as it compiles `for` loops into equivalent code using the `Iterator` trait. "
"Because Rust provides the `Future` trait, though, you can also implement it "
"for your own data types when you need to. Many of the functions we’ll see "
"throughout this chapter return types with their own implementations of "
"`Future`. We’ll return to the definition of the trait at the end of the "
"chapter and dig into more of how it works, but this is enough detail to keep "
"us moving forward."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:36
msgid ""
"This may all feel a bit abstract, so let’s write our first async program: a "
"little web scraper. We’ll pass in two URLs from the command line, fetch both "
"of them concurrently, and return the result of whichever one finishes first. "
"This example will have a fair bit of new syntax, but don’t worry—we’ll "
"explain everything you need to know as we go."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:42
msgid "Our First Async Program"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:44
msgid ""
"To keep the focus of this chapter on learning async rather than juggling "
"parts of the ecosystem, we’ve created the `trpl` crate (`trpl` is short for "
"“The Rust Programming Language”). It re-exports all the types, traits, and "
"functions you’ll need, primarily from the [`futures`](https://crates.io/"
"crates/futures)<!-- ignore --> and [`tokio`](https://tokio.rs)<!-- ignore --"
"> crates. The `futures` crate is an official home for Rust experimentation "
"for async code, and it’s actually where the `Future` trait was originally "
"designed. Tokio is the most widely used async runtime in Rust today, "
"especially for web applications. There are other great runtimes out there, "
"and they may be more suitable for your purposes. We use the `tokio` crate "
"under the hood for `trpl` because it’s well tested and widely used."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:55
msgid ""
"In some cases, `trpl` also renames or wraps the original APIs to keep you "
"focused on the details relevant to this chapter. If you want to understand "
"what the crate does, we encourage you to check out [its source code](https://"
"github.com/rust-lang/book/tree/main/packages/trpl)<!-- ignore -->. You’ll be "
"able to see what crate each re-export comes from, and we’ve left extensive "
"comments explaining what the crate does."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:62
msgid ""
"Create a new binary project named `hello-async` and add the `trpl` crate as "
"a dependency:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:71
msgid ""
"Now we can use the various pieces provided by `trpl` to write our first "
"async program. We’ll build a little command line tool that fetches two web "
"pages, pulls the `<title>` element from each, and prints out the title of "
"whichever page finishes that whole process first."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:76
msgid "Defining the page_title Function"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:78
msgid ""
"Let’s start by writing a function that takes one page URL as a parameter, "
"makes a request to it, and returns the text of the title element (see "
"Listing 17-1)."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:84 src/ch17-01-futures-and-syntax.md:154
#: src/ch17-01-futures-and-syntax.md:188 src/ch17-01-futures-and-syntax.md:240
#: src/ch17-01-futures-and-syntax.md:314 src/ch17-01-futures-and-syntax.md:370
#: src/ch17-01-futures-and-syntax.md:416
#: src/ch17-02-concurrency-with-async.md:34
#: src/ch17-02-concurrency-with-async.md:101
#: src/ch17-02-concurrency-with-async.md:171
#: src/ch17-02-concurrency-with-async.md:259
#: src/ch17-02-concurrency-with-async.md:312
#: src/ch17-02-concurrency-with-async.md:399
#: src/ch17-02-concurrency-with-async.md:477
#: src/ch17-02-concurrency-with-async.md:519 src/ch17-03-more-futures.md:14
#: src/ch17-03-more-futures.md:80 src/ch17-03-more-futures.md:187
#: src/ch17-03-more-futures.md:249 src/ch17-03-more-futures.md:440
#: src/ch17-03-more-futures.md:534 src/ch17-03-more-futures.md:602
#: src/ch17-03-more-futures.md:644 src/ch17-03-more-futures.md:718
#: src/ch17-03-more-futures.md:747 src/ch17-03-more-futures.md:823
#: src/ch17-03-more-futures.md:902 src/ch17-03-more-futures.md:958
#: src/ch17-03-more-futures.md:1033 src/ch17-03-more-futures.md:1075
#: src/ch17-03-more-futures.md:1122 src/ch17-04-streams.md:35
#: src/ch17-04-streams.md:112 src/ch17-04-streams.md:139
#: src/ch17-04-streams.md:183 src/ch17-04-streams.md:246
#: src/ch17-04-streams.md:296 src/ch17-04-streams.md:413
#: src/ch17-04-streams.md:485 src/ch17-04-streams.md:562
#: src/ch17-04-streams.md:653 src/ch17-04-streams.md:774
#: src/ch17-06-futures-tasks-threads.md:35
msgid "// required for mdbook test\n"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:87 src/ch17-01-futures-and-syntax.md:159
msgid "// TODO: we'll add this next!\n"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:96 src/ch17-01-futures-and-syntax.md:165
#: src/ch17-01-futures-and-syntax.md:196 src/ch17-01-futures-and-syntax.md:256
#: src/ch17-01-futures-and-syntax.md:333 src/ch17-01-futures-and-syntax.md:444
msgid "\"title\""
msgstr ""

#: src/ch17-01-futures-and-syntax.md:103
msgid ""
"First, we define a function named `page_title` and mark it with the `async` "
"keyword. Then we use the `trpl::get` function to fetch whatever URL is "
"passed in and add the `await` keyword to await the response. To get the text "
"of the response, we call its `text` method, and once again await it with the "
"`await` keyword. Both of these steps are asynchronous. For the `get` "
"function, we have to wait for the server to send back the first part of its "
"response, which will include HTTP headers, cookies, and so on, and can be "
"delivered separately from the response body. Especially if the body is very "
"large, it can take some time for it all to arrive. Because we have to wait "
"for the _entirety_ of the response to arrive, the `text` method is also "
"async."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:114
msgid ""
"We have to explicitly await both of these futures, because futures in Rust "
"are _lazy_: they don’t do anything until you ask them to with the `await` "
"keyword. (In fact, Rust will show a compiler warning if you don’t use a "
"future.) This might remind you of Chapter 13’s discussion of iterators in "
"the section [Processing a Series of Items With Iterators](ch13-02-"
"iterators.html)<!-- ignore -->. Iterators do nothing unless you call their "
"`next` method—whether directly or by using `for` loops or methods such as "
"`map` that use `next` under the hood. Likewise, futures do nothing unless "
"you explicitly ask them to. This laziness allows Rust to avoid running async "
"code until it’s actually needed."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:124
msgid ""
"Note: This is different from the behavior we saw in the previous chapter "
"when using `thread::spawn` in [Creating a New Thread with spawn](ch16-01-"
"threads.html#creating-a-new-thread-with-spawn)<!--ignore-->, where the "
"closure we passed to another thread started running immediately. It’s also "
"different from how many other languages approach async. But it’s important "
"for Rust, and we’ll see why later."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:131
msgid ""
"Once we have `response_text`, we can parse it into an instance of the `Html` "
"type using `Html::parse`. Instead of a raw string, we now have a data type "
"we can use to work with the HTML as a richer data structure. In particular, "
"we can use the `select_first` method to find the first instance of a given "
"CSS selector. By passing the string `\"title\"`, we’ll get the first "
"`<title>` element in the document, if there is one. Because there may not be "
"any matching element, `select_first` returns an `Option<ElementRef>`. "
"Finally, we use the `Option::map` method, which lets us work with the item "
"in the `Option` if it’s present, and do nothing if it isn’t. (We could also "
"use a `match` expression here, but `map` is more idiomatic.) In the body of "
"the function we supply to `map`, we call `inner_html` on the `title_element` "
"to get its content, which is a `String`. When all is said and done, we have "
"an `Option<String>`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:144
msgid ""
"Notice that Rust’s `await` keyword goes _after_ the expression you’re "
"awaiting, not before it. That is, it’s a _postfix_ keyword. This may differ "
"from what you’re used to if you’ve used `async` in other languages, but in "
"Rust it makes chains of methods much nicer to work with. As a result, we can "
"change the body of `page_url_for` to chain the `trpl::get` and `text` "
"function calls together with `await` between them, as shown in Listing 17-2."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:172
msgid ""
"With that, we have successfully written our first async function! Before we "
"add some code in `main` to call it, let’s talk a little more about what "
"we’ve written and what it means."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:176
msgid ""
"When Rust sees a block marked with the `async` keyword, it compiles it into "
"a unique, anonymous data type that implements the `Future` trait. When Rust "
"sees a function marked with `async`, it compiles it into a non-async "
"function whose body is an async block. An async function’s return type is "
"the type of the anonymous data type the compiler creates for that async "
"block."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:182
msgid ""
"Thus, writing `async fn` is equivalent to writing a function that returns a "
"_future_ of the return type. To the compiler, a function definition such as "
"the `async fn page_title` in Listing 17-1 is equivalent to a non-async "
"function defined like this:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:202
msgid "Let’s walk through each part of the transformed version:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:204
msgid ""
"It uses the `impl Trait` syntax we discussed back in Chapter 10 in the "
"[“Traits as Parameters”](ch10-02-traits.html#traits-as-parameters)<!-- "
"ignore --> section."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:206
msgid ""
"The returned trait is a `Future` with an associated type of `Output`. Notice "
"that the `Output` type is `Option<String>`, which is the same as the "
"original return type from the `async fn` version of `page_title`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:209
msgid ""
"All of the code called in the body of the original function is wrapped in an "
"`async move` block. Remember that blocks are expressions. This whole block "
"is the expression returned from the function."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:212
msgid ""
"This async block produces a value with the type `Option<String>`, as just "
"described. That value matches the `Output` type in the return type. This is "
"just like other blocks you have seen."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:215
msgid ""
"The new function body is an `async move` block because of how it uses the "
"`url` parameter. (We’ll talk much more about `async` versus `async move` "
"later in the chapter.)"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:218
msgid ""
"The new version of the function has a kind of lifetime we haven’t seen "
"before in the output type: `'_`. Because the function returns a future that "
"refers to a reference—in this case, the reference from the `url` parameter—"
"we need to tell Rust that we want that reference to be included. We don’t "
"have to name the lifetime here, because Rust is smart enough to know there’s "
"only one reference that could be involved, but we _do_ have to be explicit "
"that the resulting future is bound by that lifetime."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:226
msgid "Now we can call `page_title` in `main`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:228
msgid "Determining a Single Page’s Title"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:230
msgid ""
"To start, we’ll just get the title for a single page. In Listing 17-3, we "
"follow the same pattern we used in Chapter 12 to get command line arguments "
"in the [Accepting Command Line Arguments](ch12-01-accepting-command-line-"
"arguments.html)<!-- ignore --> section. Then we pass the first URL "
"`page_title` and await the result. Because the value produced by the future "
"is an `Option<String>`, we use a `match` expression to print different "
"messages to account for whether the page had a `<title>`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:248 src/ch17-01-futures-and-syntax.md:324
#: src/ch17-05-traits-for-async.md:73 src/ch17-05-traits-for-async.md:91
msgid "\"The title for {url} was {title}\""
msgstr ""

#: src/ch17-01-futures-and-syntax.md:249 src/ch17-01-futures-and-syntax.md:325
#: src/ch17-05-traits-for-async.md:74 src/ch17-05-traits-for-async.md:92
msgid "\"{url} had no title\""
msgstr ""

#: src/ch17-01-futures-and-syntax.md:263
msgid ""
"Unfortunately, this code doesn’t compile. The only place we can use the "
"`await` keyword is in async functions or blocks, and Rust won’t let us mark "
"the special `main` function as `async`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:281
msgid ""
"The reason `main` can’t be marked `async` is that async code needs a "
"_runtime_: a Rust crate that manages the details of executing asynchronous "
"code. A program’s `main` function can _initialize_ a runtime, but it’s not a "
"runtime _itself_. (We’ll see more about why this is the case in a bit.) "
"Every Rust program that executes async code has at least one place where it "
"sets up a runtime and executes the futures."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:288
msgid ""
"Most languages that support async bundle a runtime, but Rust does not. "
"Instead, there are many different async runtimes available, each of which "
"makes different tradeoffs suitable to the use case it targets. For example, "
"a high-throughput web server with many CPU cores and a large amount of RAM "
"has very different needs than a microcontroller with a single core, a small "
"amount of RAM, and no heap allocation ability. The crates that provide those "
"runtimes also often supply async versions of common functionality such as "
"file or network I/O."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:296
msgid ""
"Here, and throughout the rest of this chapter, we’ll use the `run` function "
"from the `trpl` crate, which takes a future as an argument and runs it to "
"completion. Behind the scenes, calling `run` sets up a runtime that’s used "
"to run the future passed in. Once the future completes, `run` returns "
"whatever value the future produced."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:302
msgid ""
"We could pass the future returned by `page_title` directly to `run`, and "
"once it completed, we could match on the resulting `Option<String>`, as we "
"tried to do in Listing 17-3. However, for most of the examples in the "
"chapter (and most async code in the real world), we’ll be doing more than "
"just one async function call, so instead we’ll pass an `async` block and "
"explicitly await the result of the `page_title` call, as in Listing 17-4."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:340
msgid "When we run this code, we get the behavior we expected initially:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:349
msgid ""
"```console\n"
"$ cargo run -- https://www.rust-lang.org\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s\n"
"     Running `target/debug/async_await 'https://www.rust-lang.org'`\n"
"The title for https://www.rust-lang.org was\n"
"            Rust Programming Language\n"
"```"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:357
msgid ""
"Phew—we finally have some working async code! But before we add the code to "
"race the two sites against each other, let’s briefly turn our attention back "
"to how futures work."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:361
msgid ""
"Each _await point_—that is, every place where the code uses the `await` "
"keyword—represents a place where control is handed back to the runtime. To "
"make that work, Rust needs to keep track of the state involved in the async "
"block so that the runtime can kick off some other work and then come back "
"when it’s ready to try advancing the first one again. This is an invisible "
"state machine, as if you’d written an enum like this to save the current "
"state at each await point:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:379
msgid ""
"Writing the code to transition between each state by hand would be tedious "
"and error-prone, however, especially when you need to add more functionality "
"and more states to the code later. Fortunately, the Rust compiler creates "
"and manages the state machine data structures for async code automatically. "
"The normal borrowing and ownership rules around data structures all still "
"apply, and happily, the compiler also handles checking those for us and "
"provides useful error messages. We’ll work through a few of those later in "
"the chapter."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:387
msgid ""
"Ultimately, something has to execute this state machine, and that something "
"is a runtime. (This is why you may come across references to _executors_ "
"when looking into runtimes: an executor is the part of a runtime responsible "
"for executing the async code.)"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:392
msgid ""
"Now you can see why the compiler stopped us from making `main` itself an "
"async function back in Listing 17-3. If `main` were an async function, "
"something else would need to manage the state machine for whatever future "
"`main` returned, but `main` is the starting point for the program! Instead, "
"we called the `trpl::run` function in `main` to set up a runtime and run the "
"future returned by the `async` block until it returns `Ready`."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:399
msgid ""
"Note: Some runtimes provide macros so you _can_ write an async `main` "
"function. Those macros rewrite `async fn main() { ... }` to be a normal `fn "
"main`, which does the same thing we did by hand in Listing 17-5: call a "
"function that runs a future to completion the way `trpl::run` does."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:404
msgid ""
"Now let’s put these pieces together and see how we can write concurrent code."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:406
msgid "Racing Our Two URLs Against Each Other"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:408
msgid ""
"In Listing 17-5, we call `page_title` with two different URLs passed in from "
"the command line and race them."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:433
msgid "\"{url} returned first\""
msgstr ""

#: src/ch17-01-futures-and-syntax.md:435
msgid "\"Its page title is: '{title}'\""
msgstr ""

#: src/ch17-01-futures-and-syntax.md:436
msgid "\"Its title could not be parsed.\""
msgstr "제목을 파싱할 수 없습니다."

#: src/ch17-01-futures-and-syntax.md:452
msgid ""
"We begin by calling `page_title` for each of the user-supplied URLs. We save "
"the resulting futures as `title_fut_1` and `title_fut_2`. Remember, these "
"don’t do anything yet, because futures are lazy and we haven’t yet awaited "
"them. Then we pass the futures to `trpl::race`, which returns a value to "
"indicate which of the futures passed to it finishes first."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:458
msgid ""
"Note: Under the hood, `race` is built on a more general function, `select`, "
"which you will encounter more often in real-world Rust code. A `select` "
"function can do a lot of things that the `trpl::race` function can’t, but it "
"also has some additional complexity that we can skip over for now."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:463
msgid ""
"Either future can legitimately “win,” so it doesn’t make sense to return a "
"`Result`. Instead, `race` returns a type we haven’t seen before, "
"`trpl::Either`. The `Either` type is somewhat similar to a `Result` in that "
"it has two cases. Unlike `Result`, though, there is no notion of success or "
"failure baked into `Either`. Instead, it uses `Left` and `Right` to indicate "
"“one or the other”:"
msgstr ""

#: src/ch17-01-futures-and-syntax.md:477
msgid ""
"The `race` function returns `Left` with that future’s output if the first "
"argument wins, and `Right` with the second future argument’s output if "
"_that_ one wins. This matches the order the arguments appear in when calling "
"the function: the first argument is to the left of the second argument."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:482
msgid ""
"We also update `page_title` to return the same URL passed in. That way, if "
"the page that returns first does not have a `<title>` we can resolve, we can "
"still print a meaningful message. With that information available, we wrap "
"up by updating our `println!` output to indicate both which URL finished "
"first and what, if any, the `<title>` is for the web page at that URL."
msgstr ""

#: src/ch17-01-futures-and-syntax.md:488
msgid ""
"You have built a small working web scraper now! Pick a couple URLs and run "
"the command line tool. You may discover that some sites are consistently "
"faster than others, while in other cases the faster site varies from run to "
"run. More importantly, you’ve learned the basics of working with futures, so "
"now we can dig deeper into what we can do with async."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:5
msgid "<a id=\"concurrency-with-async\"></a>"
msgstr "<a id=\"concurrency-with-async\"></a>"

#: src/ch17-02-concurrency-with-async.md:7
msgid ""
"In this section, we’ll apply async to some of the same concurrency "
"challenges we tackled with threads in chapter 16. Because we already talked "
"about a lot of the key ideas there, in this section we’ll focus on what’s "
"different between threads and futures."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:12
msgid ""
"In many cases, the APIs for working with concurrency using async are very "
"similar to those for using threads. In other cases, they end up being quite "
"different. Even when the APIs _look_ similar between threads and async, they "
"often have different behavior—and they nearly always have different "
"performance characteristics."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:20
msgid "<a id=\"counting\"></a>"
msgstr "<a id=\"counting\"></a>"

#: src/ch17-02-concurrency-with-async.md:22
msgid "Creating a New Task with `spawn_task`"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:24
msgid ""
"The first operation we tackled in [Creating a New Thread with Spawn](ch16-01-"
"threads.html#creating-a-new-thread-with-spawn)<!-- ignore --> was counting "
"up on two separate threads. Let’s do the same using async. The `trpl` crate "
"supplies a `spawn_task` function that looks very similar to the "
"`thread::spawn` API, and a `sleep` function that is an async version of the "
"`thread::sleep` API. We can use these together to implement the counting "
"example, as shown in Listing 17-6."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:42
#: src/ch17-02-concurrency-with-async.md:109
#: src/ch17-02-concurrency-with-async.md:179
msgid "\"hi number {i} from the first task!\""
msgstr ""

#: src/ch17-02-concurrency-with-async.md:48
#: src/ch17-02-concurrency-with-async.md:115
#: src/ch17-02-concurrency-with-async.md:186
msgid "\"hi number {i} from the second task!\""
msgstr ""

#: src/ch17-02-concurrency-with-async.md:57
msgid ""
"As our starting point, we set up our `main` function with `trpl::run` so "
"that our top-level function can be async."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:60
msgid ""
"Note: From this point forward in the chapter, every example will include "
"this exact same wrapping code with `trpl::run` in `main`, so we’ll often "
"skip it just as we do with `main`. Don’t forget to include it in your code!"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:64
msgid ""
"Then we write two loops within that block, each containing a `trpl::sleep` "
"call, which waits for half a second (500 milliseconds) before sending the "
"next message. We put one loop in the body of a `trpl::spawn_task` and the "
"other in a top-level `for` loop. We also add an `await` after the `sleep` "
"calls."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:69
msgid ""
"This code behaves similarly to the thread-based implementation—including the "
"fact that you may see the messages appear in a different order in your own "
"terminal when you run it:"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:89
msgid ""
"This version stops as soon as the `for` loop in the body of the main async "
"block finishes, because the task spawned by `spawn_task` is shut down when "
"the `main` function ends. If you want it to run all the way to the task’s "
"completion, you will need to use a join handle to wait for the first task to "
"complete. With threads, we used the `join` method to “block” until the "
"thread was done running. In Listing 17-7, we can use `await` to do the same "
"thing, because the task handle itself is a future. Its `Output` type is a "
"`Result`, so we also unwrap it after awaiting it."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:126
msgid "This updated version runs until _both_ loops finish."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:148
msgid ""
"So far, it looks like async and threads give us the same basic outcomes, "
"just with different syntax: using `await` instead of calling `join` on the "
"join handle, and awaiting the `sleep` calls."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:152
msgid ""
"The bigger difference is that we didn’t need to spawn another operating "
"system thread to do this. In fact, we don’t even need to spawn a task here. "
"Because async blocks compile to anonymous futures, we can put each loop in "
"an async block and have the runtime run them both to completion using the "
"`trpl::join` function."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:158
msgid ""
"In the section [Waiting for All Threads to Finishing Using `join` Handles]"
"(ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-"
"handles)<!-- ignore -->, we showed how to use the `join` method on the "
"`JoinHandle` type returned when you call `std::thread::spawn`. The "
"`trpl::join` function is similar, but for futures. When you give it two "
"futures, it produces a single new future whose output is a tuple containing "
"the output of each future you passed in once they _both_ complete. Thus, in "
"Listing 17-8, we use `trpl::join` to wait for both `fut1` and `fut2` to "
"finish. We do _not_ await `fut1` and `fut2` but instead the new future "
"produced by `trpl::join`. We ignore the output, because it’s just a tuple "
"containing two unit values."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:198
msgid "When we run this, we see both futures run to completion:"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:220
msgid ""
"Now, you’ll see the exact same order every time, which is very different "
"from what we saw with threads. That is because the `trpl::join` function is "
"_fair_, meaning it checks each future equally often, alternating between "
"them, and never lets one race ahead if the other is ready. With threads, the "
"operating system decides which thread to check and how long to let it run. "
"With async Rust, the runtime decides which task to check. (In practice, the "
"details get complicated because an async runtime might use operating system "
"threads under the hood as part of how it manages concurrency, so "
"guaranteeing fairness can be more work for a runtime—but it’s still "
"possible!) Runtimes don’t have to guarantee fairness for any given "
"operation, and they often offer different APIs to let you choose whether or "
"not you want fairness."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:232
msgid ""
"Try some of these variations on awaiting the futures and see what they do:"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:234
msgid "Remove the async block from around either or both of the loops."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:235
msgid "Await each async block immediately after defining it."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:236
msgid ""
"Wrap only the first loop in an async block, and await the resulting future "
"after the body of second loop."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:239
msgid ""
"For an extra challenge, see if you can figure out what the output will be in "
"each case _before_ running the code!"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:244
msgid "<a id=\"message-passing\"></a>"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:246
msgid "Counting Up on Two Tasks Using Message Passing"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:248
msgid ""
"Sharing data between futures will also be familiar: we’ll use message "
"passing again, but this time with async versions of the types and functions. "
"We’ll take a slightly different path than we did in [Using Message Passing "
"to Transfer Data Between Threads](ch16-02-message-passing.html)<!-- ignore --"
"> to illustrate some of the key differences between thread-based and futures-"
"based concurrency. In Listing 17-9, we’ll begin with just a single async "
"block—_not_ spawning a separate task as we spawned a separate thread."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:276
msgid ""
"Here, we use `trpl::channel`, an async version of the multiple-producer, "
"single-consumer channel API we used with threads back in Chapter 16. The "
"async version of the API is only a little different from the thread-based "
"version: it uses a mutable rather than an immutable receiver `rx`, and its "
"`recv` method produces a future we need to await rather than producing the "
"value directly. Now we can send messages from the sender to the receiver. "
"Notice that we don’t have to spawn a separate thread or even a task; we "
"merely need to await the `rx.recv` call."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:285
msgid ""
"The synchronous `Receiver::recv` method in `std::mpsc::channel` blocks until "
"it receives a message. The `trpl::Receiver::recv` method does not, because "
"it is async. Instead of blocking, it hands control back to the runtime until "
"either a message is received or the send side of the channel closes. By "
"contrast, we don’t await the `send` call, because it doesn’t block. It "
"doesn’t need to, because the channel we’re sending it into is unbounded."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:292
msgid ""
"Note: Because all of this async code runs in an async block in a `trpl::run` "
"call, everything within it can avoid blocking. However, the code _outside_ "
"it will block on the `run` function returning. That’s the whole point of the "
"`trpl::run` function: it lets you _choose_ where to block on some set of "
"async code, and thus where to transition between sync and async code. In "
"most async runtimes, `run` is actually named `block_on` for exactly this "
"reason."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:299
msgid ""
"Notice two things about this example. First, the message will arrive right "
"away. Second, although we use a future here, there’s no concurrency yet. "
"Everything in the listing happens in sequence, just as it would if there "
"were no futures involved."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:304
msgid ""
"Let’s address the first part by sending a series of messages and sleeping in "
"between them, as shown in Listing 17-10."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:324
#: src/ch17-02-concurrency-with-async.md:412
#: src/ch17-02-concurrency-with-async.md:490
#: src/ch17-02-concurrency-with-async.md:533 src/ch17-03-more-futures.md:28
#: src/ch17-03-more-futures.md:94 src/ch17-03-more-futures.md:201
#: src/ch17-03-more-futures.md:263 src/ch17-03-more-futures.md:458
#: src/ch17-03-more-futures.md:553
msgid "\"future\""
msgstr ""

#: src/ch17-02-concurrency-with-async.md:333
#: src/ch17-02-concurrency-with-async.md:423
#: src/ch17-02-concurrency-with-async.md:501
#: src/ch17-02-concurrency-with-async.md:544 src/ch17-03-more-futures.md:39
#: src/ch17-03-more-futures.md:105 src/ch17-03-more-futures.md:212
#: src/ch17-03-more-futures.md:274 src/ch17-03-more-futures.md:469
#: src/ch17-03-more-futures.md:565
msgid "\"received '{value}'\""
msgstr ""

#: src/ch17-02-concurrency-with-async.md:341
msgid ""
"In addition to sending the messages, we need to receive them. In this case, "
"because we know how many messages are coming in, we could do that manually "
"by calling `rx.recv().await` four times. In the real world, though, we’ll "
"generally be waiting on some _unknown_ number of messages, so we need to "
"keep waiting until we determine that there are no more messages."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:347
msgid ""
"In Listing 16-10, we used a `for` loop to process all the items received "
"from a synchronous channel. Rust doesn’t yet have a way to write a `for` "
"loop over an _asynchronous_ series of items, however, so we need to use a "
"loop we haven’t seen before: the `while let` conditional loop. This is the "
"loop version of the `if let` construct we saw back in the section [Concise "
"Control Flow with `if let` and `let else`](ch06-03-if-let.html)<!-- ignore --"
">. The loop will continue executing as long as the pattern it specifies "
"continues to match the value."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:355
msgid ""
"The `rx.recv` call produces a future, which we await. The runtime will pause "
"the future until it is ready. Once a message arrives, the future will "
"resolve to `Some(message)` as many times as a message arrives. When the "
"channel closes, regardless of whether _any_ messages have arrived, the "
"future will instead resolve to `None` to indicate that there are no more "
"values and thus we should stop polling—that is, stop awaiting."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:362
msgid ""
"The `while let` loop pulls all of this together. If the result of calling "
"`rx.recv().await` is `Some(message)`, we get access to the message and we "
"can use it in the loop body, just as we could with `if let`. If the result "
"is `None`, the loop ends. Every time the loop completes, it hits the await "
"point again, so the runtime pauses it again until another message arrives."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:368
msgid ""
"The code now successfully sends and receives all of the messages. "
"Unfortunately, there are still a couple of problems. For one thing, the "
"messages do not arrive at half-second intervals. They arrive all at once, 2 "
"(2,000 milliseconds) after we start the program. For another, this program "
"also never exits! Instead, it waits forever for new messages. You will need "
"to shut it down using <span\n"
"class=\"keystroke\">ctrl-c</span>."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:375
msgid ""
"Let’s start by examining why the messages come in all at once after the full "
"delay, rather than coming in with delays between each one. Within a given "
"async block, the order in which `await` keywords appear in the code is also "
"the order in which they’re executed when the program runs."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:380
msgid ""
"There’s only one async block in Listing 17-10, so everything in it runs "
"linearly. There’s still no concurrency. All the `tx.send` calls happen, "
"interspersed with all of the `trpl::sleep` calls and their associated await "
"points. Only then does the `while let` loop get to go through any of the "
"`await` points on the `recv` calls."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:386
msgid ""
"To get the behavior we want, where the sleep delay happens between each "
"message, we need to put the `tx` and `rx` operations in their own async "
"blocks, as shown in Listing 17-11. Then the runtime can execute each of them "
"separately using `trpl::join`, just as in the counting example. Once again, "
"we await the result of calling `trpl::join`, not the individual futures. If "
"we awaited the individual futures in sequence, we would just end up back in "
"a sequential flow—exactly what we’re trying _not_ to do."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:434
msgid ""
"With the updated code in Listing 17-11, the messages get printed at 500-"
"millisecond intervals, rather than all in a rush after 2 seconds."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:437
msgid ""
"The program still never exits, though, because of the way `while let` loop "
"interacts with `trpl::join`:"
msgstr ""

#: src/ch17-02-concurrency-with-async.md:440
msgid ""
"The future returned from `trpl::join` completes only once _both_ futures "
"passed to it have completed."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:442
msgid ""
"The `tx` future completes once it finishes sleeping after sending the last "
"message in `vals`."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:444
msgid "The `rx` future won’t complete until the `while let` loop ends."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:445
msgid ""
"The `while let` loop won’t end until awaiting `rx.recv` produces `None`."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:446
msgid ""
"Awaiting `rx.recv` will return `None` only once the other end of the channel "
"is closed."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:448
msgid ""
"The channel will close only if we call `rx.close` or when the sender side, "
"`tx`, is dropped."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:450
msgid ""
"We don’t call `rx.close` anywhere, and `tx` won’t be dropped until the "
"outermost async block passed to `trpl::run` ends."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:452
msgid ""
"The block can’t end because it is blocked on `trpl::join` completing, which "
"takes us back to the top of this list."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:455
msgid ""
"We could manually close `rx` by calling `rx.close` somewhere, but that "
"doesn’t make much sense. Stopping after handling some arbitrary number of "
"messages would make the program shut down, but we could miss messages. We "
"need some other way to make sure that `tx` gets dropped _before_ the end of "
"the function."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:460
msgid ""
"Right now, the async block where we send the messages only borrows `tx` "
"because sending a message doesn’t require ownership, but if we could move "
"`tx` into that async block, it would be dropped once that block ends. In the "
"Chapter 13 section [Capturing References or Moving Ownership](ch13-01-"
"closures.html#capturing-references-or-moving-ownership)<!-- ignore -->, you "
"learned how to use the `move` keyword with closures, and, as discussed in "
"the Chapter 16 section [Using `move` Closures with Threads](ch16-01-"
"threads.html#using-move-closures-with-threads)<!-- ignore\n"
"-->, we often need to move data into closures when working with threads. The "
"same basic dynamics apply to async blocks, so the `move` keyword works with "
"async blocks just as it does with closures."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:470
msgid ""
"In Listing 17-12, we change the block used to send messages from `async` to "
"`async move`. When we run _this_ version of the code, it shuts down "
"gracefully after the last message is sent and received."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:512
msgid ""
"This async channel is also a multiple-producer channel, so we can call "
"`clone` on `tx` if we want to send messages from multiple futures, as shown "
"in Listing 17-13."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:569
msgid ""
"First, we clone `tx`, creating `tx1` outside the first async block. We move "
"`tx1` into that block just as we did before with `tx`. Then, later, we move "
"the original `tx` into a _new_ async block, where we send more messages on a "
"slightly slower delay. We happen to put this new async block after the async "
"block for receiving messages, but it could go before it just as well. The "
"key is the order in which the futures are awaited, not in which they’re "
"created."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:576
msgid ""
"Both of the async blocks for sending messages need to be `async move` blocks "
"so that both `tx` and `tx1` get dropped when those blocks finish. Otherwise, "
"we’ll end up back in the same infinite loop we started out in. Finally, we "
"switch from `trpl::join` to `trpl::join3` to handle the additional future."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:581
msgid ""
"Now we see all the messages from both sending futures, and because the "
"sending futures use slightly different delays after sending, the messages "
"are also received at those different intervals."
msgstr ""

#: src/ch17-02-concurrency-with-async.md:600
msgid ""
"This is a good start, but it limits us to just a handful of futures: two "
"with `join`, or three with `join3`. Let’s see how we might work with more "
"futures."
msgstr ""

#: src/ch17-03-more-futures.md:1
msgid "Working with Any Number of Futures"
msgstr ""

#: src/ch17-03-more-futures.md:3
msgid ""
"When we switched from using two futures to three in the previous section, we "
"also had to switch from using `join` to using `join3`. It would be annoying "
"to have to call a different function every time we changed the number of "
"futures we wanted to join. Happily, we have a macro form of `join` to which "
"we can pass an arbitrary number of arguments. It also handles awaiting the "
"futures itself. Thus, we could rewrite the code from Listing 17-13 to use "
"`join!` instead of `join3`, as in Listing 17-14."
msgstr ""

#: src/ch17-03-more-futures.md:64
msgid ""
"This is definitely an improvement over swapping between `join` and `join3` "
"and `join4` and so on! However, even this macro form only works when we know "
"the number of futures ahead of time. In real-world Rust, though, pushing "
"futures into a collection and then waiting on some or all the futures of "
"them to complete is a common pattern."
msgstr ""

#: src/ch17-03-more-futures.md:70
msgid ""
"To check all the futures in some collection, we’ll need to iterate over and "
"join on _all_ of them. The `trpl::join_all` function accepts any type that "
"implements the `Iterator` trait, which you learned about back in [The "
"Iterator Trait and the `next` Method](ch13-02-iterators.html#the-iterator-"
"trait-and-the-next-method)<!-- ignore --> Chapter 13, so it seems like just "
"the ticket. Let’s try putting our futures in a vector and replacing `join!` "
"with `join_all` as show in Listing 17-15."
msgstr ""

#: src/ch17-03-more-futures.md:132
msgid "Unfortunately, this code doesn’t compile. Instead, we get this error:"
msgstr ""

#: src/ch17-03-more-futures.md:160
msgid ""
"This might be surprising. After all, none of the async blocks returns "
"anything, so each one produces a `Future<Output = ()>`. Remember that "
"`Future` is a trait, though, and that the compiler creates a unique enum for "
"each async block. You can’t put two different hand-written structs in a "
"`Vec`, and the same rule applies to the different enums generated by the "
"compiler."
msgstr ""

#: src/ch17-03-more-futures.md:166
msgid ""
"To make this work, we need to use _trait objects_, just as we did in "
"[“Returning Errors from the run function”](ch12-03-improving-error-handling-"
"and-modularity.html)<!-- ignore --> in Chapter 12. (We’ll cover trait "
"objects in detail in Chapter 18.) Using trait objects lets us treat each of "
"the anonymous futures produced by these types as the same type, because all "
"of them implement the `Future` trait."
msgstr ""

#: src/ch17-03-more-futures.md:172
msgid ""
"Note: In the Chapter 8 section [Using an Enum to Store Multiple Values]"
"(ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-"
"the-run-function)<!-- ignore -->, we discussed another way to include "
"multiple types in a `Vec`: using an enum to represent each type that can "
"appear in the vector. We can’t do that here, though. For one thing, we have "
"no way to name the different types, because they are anonymous. For another, "
"the reason we reached for a vector and `join_all` in the first place was to "
"be able to work with a dynamic collection of futures where we only care that "
"they have the same output type."
msgstr ""

#: src/ch17-03-more-futures.md:181
msgid ""
"We start by wrapping each future in the `vec!` in a `Box::new`, as shown in "
"Listing 17-16."
msgstr ""

#: src/ch17-03-more-futures.md:240
msgid ""
"Unfortunately, this code still doesn’t compile. In fact, we get the same "
"basic error we got before for both the second and third `Box::new` calls, as "
"well as new errors referring to the `Unpin` trait. We’ll come back to the "
"`Unpin` errors in a moment. First, let’s fix the type errors on the "
"`Box::new` calls by explicitly annotating the type of the `futures` variable "
"(see Listing 17-17)."
msgstr ""

#: src/ch17-03-more-futures.md:302
msgid "This type declaration is a little involved, so let’s walk through it:"
msgstr ""

#: src/ch17-03-more-futures.md:304
msgid ""
"The innermost type is the future itself. We note explicitly that the output "
"of the future is the unit type `()` by writing `Future<Output = ()>`."
msgstr ""

#: src/ch17-03-more-futures.md:306
msgid "Then we annotate the trait with `dyn` to mark it as dynamic."
msgstr ""

#: src/ch17-03-more-futures.md:307
msgid "The entire trait reference is wrapped in a `Box`."
msgstr ""

#: src/ch17-03-more-futures.md:308
msgid ""
"Finally, we state explicitly that `futures` is a `Vec` containing these "
"items."
msgstr ""

#: src/ch17-03-more-futures.md:311
msgid ""
"That already made a big difference. Now when we run the compiler, we get "
"only the errors mentioning `Unpin`. Although there are three of them, their "
"contents are very similar."
msgstr ""

#: src/ch17-03-more-futures.md:322
msgid ""
"```text\n"
"error[E0308]: mismatched types\n"
"   --> src/main.rs:46:46\n"
"    |\n"
"10  |         let tx1_fut = async move {\n"
"    |                       ---------- the expected `async` block\n"
"...\n"
"24  |         let rx_fut = async {\n"
"    |                      ----- the found `async` block\n"
"...\n"
"46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), "
"Box::new(tx_fut)];\n"
"    |                                     -------- ^^^^^^ expected `async` "
"block, found a different `async` block\n"
"    |                                     |\n"
"    |                                     arguments to this function are "
"incorrect\n"
"    |\n"
"    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`\n"
"               found `async` block `{async block@src/main.rs:24:22: 24:27}`\n"
"    = note: no two async blocks, even if identical, have the same type\n"
"    = help: consider pinning your async block and casting it to a trait "
"object\n"
"note: associated function defined here\n"
"   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/"
"alloc/src/boxed.rs:255:12\n"
"    |\n"
"255 |     pub fn new(x: T) -> Self {\n"
"    |            ^^^\n"
"\n"
"error[E0308]: mismatched types\n"
"   --> src/main.rs:46:64\n"
"    |\n"
"10  |         let tx1_fut = async move {\n"
"    |                       ---------- the expected `async` block\n"
"...\n"
"30  |         let tx_fut = async move {\n"
"    |                      ---------- the found `async` block\n"
"...\n"
"46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), "
"Box::new(tx_fut)];\n"
"    |                                                       -------- ^^^^^^ "
"expected `async` block, found a different `async` block\n"
"    |                                                       |\n"
"    |                                                       arguments to "
"this function are incorrect\n"
"    |\n"
"    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`\n"
"               found `async` block `{async block@src/main.rs:30:22: 30:32}`\n"
"    = note: no two async blocks, even if identical, have the same type\n"
"    = help: consider pinning your async block and casting it to a trait "
"object\n"
"note: associated function defined here\n"
"   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/"
"alloc/src/boxed.rs:255:12\n"
"    |\n"
"255 |     pub fn new(x: T) -> Self {\n"
"    |            ^^^\n"
"\n"
"error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n"
"   --> src/main.rs:48:24\n"
"    |\n"
"48  |         trpl::join_all(futures).await;\n"
"    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented "
"for `{async block@src/main.rs:10:23: 10:33}`, which is required by "
"`Box<{async block@src/main.rs:10:23: 10:33}>: Future`\n"
"    |         |\n"
"    |         required by a bound introduced by this call\n"
"    |\n"
"    = note: consider using the `pin!` macro\n"
"            consider using `Box::pin` if you need to access the pinned value "
"outside of the current scope\n"
"    = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to "
"implement `Future`\n"
"note: required by a bound in `join_all`\n"
"   --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/"
"futures-util-0.3.30/src/future/join_all.rs:105:14\n"
"    |\n"
"102 | pub fn join_all<I>(iter: I) -> JoinAll<I::Item>\n"
"    |        -------- required by a bound in this function\n"
"...\n"
"105 |     I::Item: Future,\n"
"    |              ^^^^^^ required by this bound in `join_all`\n"
"\n"
"error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n"
"  --> src/main.rs:48:9\n"
"   |\n"
"48 |         trpl::join_all(futures).await;\n"
"   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented "
"for `{async block@src/main.rs:10:23: 10:33}`, which is required by "
"`Box<{async block@src/main.rs:10:23: 10:33}>: Future`\n"
"   |\n"
"   = note: consider using the `pin!` macro\n"
"           consider using `Box::pin` if you need to access the pinned value "
"outside of the current scope\n"
"   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to "
"implement `Future`\n"
"note: required by a bound in `futures_util::future::join_all::JoinAll`\n"
"  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/"
"futures-util-0.3.30/src/future/join_all.rs:29:8\n"
"   |\n"
"27 | pub struct JoinAll<F>\n"
"   |            ------- required by a bound in this struct\n"
"28 | where\n"
"29 |     F: Future,\n"
"   |        ^^^^^^ required by this bound in `JoinAll`\n"
"\n"
"error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n"
"  --> src/main.rs:48:33\n"
"   |\n"
"48 |         trpl::join_all(futures).await;\n"
"   |                                 ^^^^^ the trait `Unpin` is not "
"implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required "
"by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`\n"
"   |\n"
"   = note: consider using the `pin!` macro\n"
"           consider using `Box::pin` if you need to access the pinned value "
"outside of the current scope\n"
"   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to "
"implement `Future`\n"
"note: required by a bound in `futures_util::future::join_all::JoinAll`\n"
"  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/"
"futures-util-0.3.30/src/future/join_all.rs:29:8\n"
"   |\n"
"27 | pub struct JoinAll<F>\n"
"   |            ------- required by a bound in this struct\n"
"28 | where\n"
"29 |     F: Future,\n"
"   |        ^^^^^^ required by this bound in `JoinAll`\n"
"```"
msgstr ""

#: src/ch17-03-more-futures.md:428
msgid ""
"That is a _lot_ to digest, so let’s pull it apart. The first part of the "
"message tell us that the first async block (`src/main.rs:8:23: 20:10`) does "
"not implement the `Unpin` trait and suggests using `pin!` or `Box::pin` to "
"resolve it. Later in the chapter, we’ll dig into a few more details about "
"`Pin` and `Unpin`. For the moment, though, we can just follow the compiler’s "
"advice to get unstuck. In Listing 17-18, we start by updating the type "
"annotation for `futures`, with a `Pin` wrapping each `Box`. Second, we use "
"`Box::pin` to pin the futures themselves."
msgstr ""

#: src/ch17-03-more-futures.md:497
msgid "If we compile and run this, we finally get the output we hoped for:"
msgstr ""

#: src/ch17-03-more-futures.md:514
msgid "Phew!"
msgstr ""

#: src/ch17-03-more-futures.md:516
msgid ""
"There’s a bit more to explore here. For one thing, using `Pin<Box<T>>` adds "
"a small amount of overhead from putting these futures on the heap with `Box`—"
"and we’re only doing that to get the types to line up. We don’t actually "
"_need_ the heap allocation, after all: these futures are local to this "
"particular function. As noted before, `Pin` is itself a wrapper type, so we "
"can get the benefit of having a single type in the `Vec`—the original reason "
"we reached for `Box`—without doing a heap allocation. We can use `Pin` "
"directly with each future, using the `std::pin::pin` macro."
msgstr ""

#: src/ch17-03-more-futures.md:525
msgid ""
"However, we must still be explicit about the type of the pinned reference; "
"otherwise, Rust will still not know to interpret these as dynamic trait "
"objects, which is what we need them to be in the `Vec`. We therefore `pin!` "
"each future when we define it, and define `futures` as a `Vec` containing "
"pinned mutable references to the dynamic future type, as in Listing 17-19."
msgstr ""

#: src/ch17-03-more-futures.md:594
msgid ""
"We got this far by ignoring the fact that we might have different `Output` "
"types. For example, in Listing 17-20, the anonymous future for `a` "
"implements `Future<Output = u32>`, the anonymous future for `b` implements "
"`Future<Output = &str>`, and the anonymous future for `c` implements "
"`Future<Output = bool>`."
msgstr ""

#: src/ch17-03-more-futures.md:611
msgid "\"{a_result}, {b_result}, {c_result}\""
msgstr ""

#: src/ch17-03-more-futures.md:618
msgid ""
"We can use `trpl::join!` to await them, because it allows us to pass in "
"multiple future types and produces a tuple of those types. We _cannot_ use "
"`trpl::join_all`, because it requires all of the futures passed in to have "
"the same type. Remember, that error is what got us started on this adventure "
"with `Pin`!"
msgstr ""

#: src/ch17-03-more-futures.md:624
msgid ""
"This is a fundamental tradeoff: we can either deal with a dynamic number of "
"futures with `join_all`, as long as they all have the same type, or we can "
"deal with a set number of futures with the `join` functions or the `join!` "
"macro, even if they have different types. This is the same scenario we’d "
"face when working with any other types in Rust. Futures are not special, "
"even though we have some nice syntax for working with them, and that’s a "
"good thing."
msgstr ""

#: src/ch17-03-more-futures.md:631
msgid "Racing Futures"
msgstr ""

#: src/ch17-03-more-futures.md:633
msgid ""
"When we “join” futures with the `join` family of functions and macros, we "
"require _all_ of them to finish before we move on. Sometimes, though, we "
"only need _some_ future from a set to finish before we move on—kind of "
"similar to racing one future against another."
msgstr ""

#: src/ch17-03-more-futures.md:638
msgid ""
"In Listing 17-21, we once again use `trpl::race` to run two futures, `slow` "
"and `fast`, against each other."
msgstr ""

#: src/ch17-03-more-futures.md:651
msgid "\"'slow' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:653
msgid "\"'slow' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:657
msgid "\"'fast' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:659
msgid "\"'fast' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:669
msgid ""
"Each future prints a message when it starts running, pauses for some amount "
"of time by calling and awaiting `sleep`, and then prints another message "
"when it finishes. Then we pass both `slow` and `fast` to `trpl::race` and "
"wait for one of them to finish. (The outcome here isn’t too surprising: "
"`fast` wins.) Unlike when we used `race` back in [“Our First Async Program”]"
"(ch17-01-futures-and-syntax.html#our-first-async-program)<!--\n"
"ignore -->, we just ignore the `Either` instance it returns here, because "
"all of the interesting behavior happens in the body of the async blocks."
msgstr ""

#: src/ch17-03-more-futures.md:677
msgid ""
"Notice that if you flip the order of the arguments to `race`, the order of "
"the “started” messages changes, even though the `fast` future always "
"completes first. That’s because the implementation of this particular `race` "
"function is not fair. It always runs the futures passed in as arguments in "
"the order in which they’re passed. Other implementations _are_ fair and will "
"randomly choose which future to poll first. Regardless of whether the "
"implementation of race we’re using is fair, though, _one_ of the futures "
"will run up to the first `await` in its body before another task can start."
msgstr ""

#: src/ch17-03-more-futures.md:686
msgid ""
"Recall from [Our First Async Program](ch17-01-futures-and-syntax.html#our-"
"first-async-program)<!-- ignore --> that at each await point, Rust gives a "
"runtime a chance to pause the task and switch to another one if the future "
"being awaited isn’t ready. The inverse is also true: Rust _only_ pauses "
"async blocks and hands control back to a runtime at an await point. "
"Everything between await points is synchronous."
msgstr ""

#: src/ch17-03-more-futures.md:692
msgid ""
"That means if you do a bunch of work in an async block without an await "
"point, that future will block any other futures from making progress. You "
"may sometimes hear this referred to as one future _starving_ other futures. "
"In some cases, that may not be a big deal. However, if you are doing some "
"kind of expensive setup or long-running work, or if you have a future that "
"will keep doing some particular task indefinitely, you’ll need to think "
"about when and where to hand control back to the runtime."
msgstr ""

#: src/ch17-03-more-futures.md:700
msgid ""
"By the same token, if you have long-running blocking operations, async can "
"be a useful tool for providing ways for different parts of the program to "
"relate to each other."
msgstr ""

#: src/ch17-03-more-futures.md:704
msgid "But _how_ would you hand control back to the runtime in those cases?"
msgstr ""

#: src/ch17-03-more-futures.md:708
msgid "<a id=\"yielding\"></a>"
msgstr ""

#: src/ch17-03-more-futures.md:710
msgid "Yielding Control to the Runtime"
msgstr ""

#: src/ch17-03-more-futures.md:712
msgid ""
"Let’s simulate a long-running operation. Listing 17-22 introduces a `slow` "
"function."
msgstr ""

#: src/ch17-03-more-futures.md:724
msgid "// We will call `slow` here later\n"
msgstr ""

#: src/ch17-03-more-futures.md:730 src/ch17-03-more-futures.md:778
#: src/ch17-03-more-futures.md:861 src/ch17-03-more-futures.md:938
msgid "\"'{name}' ran for {ms}ms\""
msgstr ""

#: src/ch17-03-more-futures.md:736
msgid ""
"This code uses `std::thread::sleep` instead of `trpl::sleep` so that calling "
"`slow` will block the current thread for some number of milliseconds. We can "
"use `slow` to stand in for real-world operations that are both long-running "
"and blocking."
msgstr ""

#: src/ch17-03-more-futures.md:741
msgid ""
"In Listing 17-23, we use `slow` to emulate doing this kind of CPU-bound work "
"in a pair of futures."
msgstr ""

#: src/ch17-03-more-futures.md:754 src/ch17-03-more-futures.md:832
#: src/ch17-03-more-futures.md:909
msgid "\"'a' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:755 src/ch17-03-more-futures.md:756
#: src/ch17-03-more-futures.md:757 src/ch17-03-more-futures.md:833
#: src/ch17-03-more-futures.md:835 src/ch17-03-more-futures.md:837
#: src/ch17-03-more-futures.md:910 src/ch17-03-more-futures.md:912
#: src/ch17-03-more-futures.md:914 src/ch17-04-streams.md:200
#: src/ch17-04-streams.md:268 src/ch17-04-streams.md:320
#: src/ch17-04-streams.md:437 src/ch17-04-streams.md:510
#: src/ch17-04-streams.md:590 src/ch17-04-streams.md:682
#: src/ch17-04-streams.md:803 src/ch17-06-futures-tasks-threads.md:64
msgid "\"a\""
msgstr ""

#: src/ch17-03-more-futures.md:759 src/ch17-03-more-futures.md:839
#: src/ch17-03-more-futures.md:916
msgid "\"'a' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:763 src/ch17-03-more-futures.md:843
#: src/ch17-03-more-futures.md:920
msgid "\"'b' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:764 src/ch17-03-more-futures.md:765
#: src/ch17-03-more-futures.md:766 src/ch17-03-more-futures.md:767
#: src/ch17-03-more-futures.md:844 src/ch17-03-more-futures.md:846
#: src/ch17-03-more-futures.md:848 src/ch17-03-more-futures.md:850
#: src/ch17-03-more-futures.md:921 src/ch17-03-more-futures.md:923
#: src/ch17-03-more-futures.md:925 src/ch17-03-more-futures.md:927
#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"b\""
msgstr ""

#: src/ch17-03-more-futures.md:769 src/ch17-03-more-futures.md:852
#: src/ch17-03-more-futures.md:929
msgid "\"'b' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:784
msgid ""
"To begin, each future only hands control back to the runtime _after_ "
"carrying out a bunch of slow operations. If you run this code, you will see "
"this output:"
msgstr ""

#: src/ch17-03-more-futures.md:806
msgid ""
"As with our earlier example, `race` still finishes as soon as `a` is done. "
"There’s no interleaving between the two futures, though. The `a` future does "
"all of its work until the `trpl::sleep` call is awaited, then the `b` future "
"does all of its work until its own `trpl::sleep` call is awaited, and "
"finally the `a` future completes. To allow both futures to make progress "
"between their slow tasks, we need await points so we can hand control back "
"to the runtime. That means we need something we can await!"
msgstr ""

#: src/ch17-03-more-futures.md:814
msgid ""
"We can already see this kind of handoff happening in Listing 17-23: if we "
"removed the `trpl::sleep` at the end of the `a` future, it would complete "
"without the `b` future running _at all_. Let’s try using the `sleep` "
"function as a starting point for letting operations switch off making "
"progress, as shown in Listing 17-24."
msgstr ""

#: src/ch17-03-more-futures.md:867
msgid ""
"In Listing 17-24, we add `trpl::sleep` calls with await points between each "
"call to `slow`. Now the two futures’ work is interleaved:"
msgstr ""

#: src/ch17-03-more-futures.md:888
msgid ""
"The `a` future still runs for a bit before handing off control to `b`, "
"because it calls `slow` before ever calling `trpl::sleep`, but after that "
"the futures swap back and forth each time one of them hits an await point. "
"In this case, we have done that after every call to `slow`, but we could "
"break up the work in whatever way makes the most sense to us."
msgstr ""

#: src/ch17-03-more-futures.md:894
msgid ""
"We don’t really want to _sleep_ here, though: we want to make progress as "
"fast as we can. We just need to hand back control to the runtime. We can do "
"that directly, using the `yield_now` function. In Listing 17-25, we replace "
"all those `sleep` calls with `yield_now`."
msgstr ""

#: src/ch17-03-more-futures.md:944
msgid ""
"This code is both clearer about the actual intent and can be significantly "
"faster than using `sleep`, because timers such as the one used by `sleep` "
"often have limits on how granular they can be. The version of `sleep` we are "
"using, for example, will always sleep for at least a millisecond, even if we "
"pass it a `Duration` of one nanosecond. Again, modern computers are _fast_: "
"they can do a lot in one millisecond!"
msgstr ""

#: src/ch17-03-more-futures.md:951
msgid ""
"You can see this for yourself by setting up a little benchmark, such as the "
"one in Listing 17-26. (This isn’t an especially rigorous way to do "
"performance testing, but it suffices to show the difference here.)"
msgstr ""

#: src/ch17-03-more-futures.md:974
msgid "\"'sleep' version finished after {} seconds.\""
msgstr ""

#: src/ch17-03-more-futures.md:987
msgid "\"'yield' version finished after {} seconds.\""
msgstr ""

#: src/ch17-03-more-futures.md:996
msgid ""
"Here, we skip all the status printing, pass a one-nanosecond `Duration` to "
"`trpl::sleep`, and let each future run by itself, with no switching between "
"the futures. Then we run for 1,000 iterations and see how long the future "
"using `trpl::sleep` takes compared to the future using `trpl::yield_now`."
msgstr ""

#: src/ch17-03-more-futures.md:1001
msgid "The version with `yield_now` is _way_ faster!"
msgstr ""

#: src/ch17-03-more-futures.md:1003
msgid ""
"This means that async can be useful even for compute-bound tasks, depending "
"on what else your program is doing, because it provides a useful tool for "
"structuring the relationships between different parts of the program. This "
"is a form of _cooperative multitasking_, where each future has the power to "
"determine when it hands over control via await points. Each future therefore "
"also has the responsibility to avoid blocking for too long. In some Rust-"
"based embedded operating systems, this is the _only_ kind of multitasking!"
msgstr ""

#: src/ch17-03-more-futures.md:1011
msgid ""
"In real-world code, you won’t usually be alternating function calls with "
"await points on every single line, of course. While yielding control in this "
"way is relatively inexpensive, it’s not free. In many cases, trying to break "
"up a compute-bound task might make it significantly slower, so sometimes "
"it’s better for _overall_ performance to let an operation block briefly. "
"Always measure to see what your code’s actual performance bottlenecks are. "
"The underlying dynamic is important to keep in mind, though, if you _are_ "
"seeing a lot of work happening in serial that you expected to happen "
"concurrently!"
msgstr ""

#: src/ch17-03-more-futures.md:1020
msgid "Building Our Own Async Abstractions"
msgstr ""

#: src/ch17-03-more-futures.md:1022
msgid ""
"We can also compose futures together to create new patterns. For example, we "
"can build a `timeout` function with async building blocks we already have. "
"When we’re done, the result will be another building block we could use to "
"create still more async abstractions."
msgstr ""

#: src/ch17-03-more-futures.md:1027
msgid ""
"Listing 17-27 shows how we would expect this `timeout` to work with a slow "
"future."
msgstr ""

#: src/ch17-03-more-futures.md:1041
msgid "\"I finished!\""
msgstr ""

#: src/ch17-03-more-futures.md:1045 src/ch17-03-more-futures.md:1087
#: src/ch17-03-more-futures.md:1138
msgid "\"Succeeded with '{message}'\""
msgstr ""

#: src/ch17-03-more-futures.md:1047 src/ch17-03-more-futures.md:1089
#: src/ch17-03-more-futures.md:1140
msgid "\"Failed after {} seconds\""
msgstr ""

#: src/ch17-03-more-futures.md:1056
msgid ""
"Let’s implement this! To begin, let’s think about the API for `timeout`:"
msgstr ""

#: src/ch17-03-more-futures.md:1058
msgid "It needs to be an async function itself so we can await it."
msgstr ""

#: src/ch17-03-more-futures.md:1059
msgid ""
"Its first parameter should be a future to run. We can make it generic to "
"allow it to work with any future."
msgstr ""

#: src/ch17-03-more-futures.md:1061
msgid ""
"Its second parameter will be the maximum time to wait. If we use a "
"`Duration`, that will make it easy to pass along to `trpl::sleep`."
msgstr ""

#: src/ch17-03-more-futures.md:1063
msgid ""
"It should return a `Result`. If the future completes successfully, the "
"`Result` will be `Ok` with the value produced by the future. If the timeout "
"elapses first, the `Result` will be `Err` with the duration that the timeout "
"waited for."
msgstr ""

#: src/ch17-03-more-futures.md:1068
msgid "Listing 17-28 shows this declaration."
msgstr ""

#: src/ch17-03-more-futures.md:1083 src/ch17-03-more-futures.md:1134
msgid "\"Finally finished\""
msgstr ""

#: src/ch17-03-more-futures.md:1099
msgid "// Here is where our implementation will go!\n"
msgstr ""

#: src/ch17-03-more-futures.md:1105
msgid ""
"That satisfies our goals for the types. Now let’s think about the _behavior_ "
"we need: we want to race the future passed in against the duration. We can "
"use `trpl::sleep` to make a timer future from the duration, and use "
"`trpl::race` to run that timer with the future the caller passes in."
msgstr ""

#: src/ch17-03-more-futures.md:1110
msgid ""
"We also know that `race` is not fair, polling arguments in the order in "
"which they are passed. Thus, we pass `future_to_try` to `race` first so it "
"gets a chance to complete even if `max_time` is a very short duration. If "
"`future_to_try` finishes first, `race` will return `Left` with the output "
"from `future_to_try`. If `timer` finishes first, `race` will return `Right` "
"with the timer’s output of `()`."
msgstr ""

#: src/ch17-03-more-futures.md:1117
msgid "In Listing 17-29, we match on the result of awaiting `trpl::race`."
msgstr ""

#: src/ch17-03-more-futures.md:1159
msgid ""
"If the `future_to_try` succeeds and we get a `Left(output)`, we return "
"`Ok(output)`. If the sleep timer elapses instead and we get a `Right(())`, "
"we ignore the `()` with `_` and return `Err(max_time)` instead."
msgstr ""

#: src/ch17-03-more-futures.md:1163
msgid ""
"With that, we have a working `timeout` built out of two other async helpers. "
"If we run our code, it will print the failure mode after the timeout:"
msgstr ""

#: src/ch17-03-more-futures.md:1170
msgid ""
"Because futures compose with other futures, you can build really powerful "
"tools using smaller async building blocks. For example, you can use this "
"same approach to combine timeouts with retries, and in turn use those with "
"operations such as network calls (one of the examples from the beginning of "
"the chapter)."
msgstr ""

#: src/ch17-03-more-futures.md:1175
msgid ""
"In practice, you’ll usually work directly with `async` and `await`, and "
"secondarily with functions and macros such as `join`, `join_all`, `race`, "
"and so on. You’ll only need to reach for `pin` now and again to use futures "
"with those APIs."
msgstr ""

#: src/ch17-03-more-futures.md:1180
msgid ""
"We’ve now seen a number of ways to work with multiple futures at the same "
"time. Up next, we’ll look at how we can work with multiple futures in a "
"sequence over time with _streams_. Here are a couple more things you might "
"want to consider first, though:"
msgstr ""

#: src/ch17-03-more-futures.md:1185
msgid ""
"We used a `Vec` with `join_all` to wait for all of the futures in some group "
"to finish. How could you use a `Vec` to process a group of futures in "
"sequence instead? What are the tradeoffs of doing that?"
msgstr ""

#: src/ch17-03-more-futures.md:1189
msgid ""
"Take a look at the `futures::stream::FuturesUnordered` type from the "
"`futures` crate. How would using it be different from using a `Vec`? (Don’t "
"worry about the fact that it’s from the `stream` part of the crate; it works "
"just fine with any collection of futures.)"
msgstr ""

#: src/ch17-04-streams.md:5
msgid "<a id=\"streams\"></a>"
msgstr ""

#: src/ch17-04-streams.md:7
msgid ""
"So far in this chapter, we’ve mostly stuck to individual futures. The one "
"big exception was the async channel we used. Recall how we used the receiver "
"for our async channel earlier in this chapter in the [“Message Passing”]"
"(ch17-02-concurrency-with-async.html#message-passing)<!-- ignore --> "
"section. The async `recv` method produces a sequence of items over time. "
"This is an instance of a much more general pattern known as a _stream_."
msgstr ""

#: src/ch17-04-streams.md:14
msgid ""
"We saw a sequence of items back in Chapter 13, when we looked at the "
"`Iterator` trait in [The Iterator Trait and the `next` Method](ch13-02-"
"iterators.html#the-iterator-trait-and-the-next-method)<!-- ignore\n"
"--> section, but there are two differences between iterators and the async "
"channel receiver. The first difference is time: iterators are synchronous, "
"while the channel receiver is asynchronous. The second is the API. When "
"working directly with `Iterator`, we call its synchronous `next` method. "
"With the `trpl::Receiver` stream in particular, we called an asynchronous "
"`recv` method instead. Otherwise, these APIs feel very similar, and that "
"similarity isn’t a coincidence. A stream is like an asynchronous form of "
"iteration. Whereas the `trpl::Receiver` specifically waits to receive "
"messages, though, the general-purpose stream API is much broader: it "
"provides the next item the way `Iterator` does, but asynchronously."
msgstr ""

#: src/ch17-04-streams.md:27
msgid ""
"The similarity between iterators and streams in Rust means we can actually "
"create a stream from any iterator. As with an iterator, we can work with a "
"stream by calling its `next` method and then awaiting the output, as in "
"Listing 17-30."
msgstr ""

#: src/ch17-04-streams.md:44 src/ch17-04-streams.md:123
#: src/ch17-04-streams.md:153
msgid "\"The value was: {value}\""
msgstr ""

#: src/ch17-04-streams.md:52
msgid ""
"We start with an array of numbers, which we convert to an iterator and then "
"call `map` on to double all the values. Then we convert the iterator into a "
"stream using the `trpl::stream_from_iter` function. Next, we loop over the "
"items in the stream as they arrive with the `while let` loop."
msgstr ""

#: src/ch17-04-streams.md:57
msgid ""
"Unfortunately, when we try to run the code, it doesn’t compile, but instead "
"it reports that there’s no `next` method available:"
msgstr ""

#: src/ch17-04-streams.md:65
msgid ""
"`````````console\n"
"error[E0599]: no method named `next` found for struct `Iter` in the current "
"scope\n"
"  --> src/main.rs:10:40\n"
"   |\n"
"10 |         while let Some(value) = stream.next().await {\n"
"   |                                        ^^^^\n"
"   |\n"
"   = note: the full type name has been written to 'file:///projects/"
"async_await/target/debug/deps/async_await-9de943556a6001b8.long-"
"type-1281356139287206597.txt'\n"
"   = note: consider using `--verbose` to print the full type name to the "
"console\n"
"   = help: items from traits can only be used if the trait is in scope\n"
"help: the following traits which provide `next` are implemented but not in "
"scope; perhaps you want to import one of them\n"
"   |\n"
"1  + use crate::trpl::StreamExt;\n"
"   |\n"
"1  + use futures_util::stream::stream::StreamExt;\n"
"   |\n"
"1  + use std::iter::Iterator;\n"
"   |\n"
"1  + use std::str::pattern::Searcher;\n"
"   |\n"
"help: there is a method `try_next` with a similar name\n"
"   |\n"
"10 |         while let Some(value) = stream.try_next().await {\n"
"   |                                        ~~~~~~~~\n"
"`````````"
msgstr ""

#: src/ch17-04-streams.md:91
msgid ""
"As this output explains, the reason for the compiler error is that we need "
"the right trait in scope to be able to use the `next` method. Given our "
"discussion so far, you might reasonably expect that trait to be `Stream`, "
"but it’s actually `StreamExt`. Short for _extension_, `Ext` is a common "
"pattern in the Rust community for extending one trait with another."
msgstr ""

#: src/ch17-04-streams.md:97
msgid ""
"We’ll explain the `Stream` and `StreamExt` traits in a bit more detail at "
"the end of the chapter, but for now all you need to know is that the "
"`Stream` trait defines a low-level interface that effectively combines the "
"`Iterator` and `Future` traits. `StreamExt` supplies a higher-level set of "
"APIs on top of `Stream`, including the `next` method as well as other "
"utility methods similar to those provided by the `Iterator` trait. `Stream` "
"and `StreamExt` are not yet part of Rust’s standard library, but most "
"ecosystem crates use the same definition."
msgstr ""

#: src/ch17-04-streams.md:106
msgid ""
"The fix to the compiler error is to add a `use` statement for "
"`trpl::StreamExt`, as in Listing 17-31."
msgstr ""

#: src/ch17-04-streams.md:131
msgid ""
"With all those pieces put together, this code works the way we want! What’s "
"more, now that we have `StreamExt` in scope, we can use all of its utility "
"methods, just as with iterators. For example, in Listing 17-32, we use the "
"`filter` method to filter out everything but multiples of three and five."
msgstr ""

#: src/ch17-04-streams.md:161
msgid ""
"Of course, this isn’t very interesting, since we could do the same with "
"normal iterators and without any async at all. Let’s look at what we can do "
"that _is_ unique to streams."
msgstr ""

#: src/ch17-04-streams.md:165
msgid "Composing Streams"
msgstr ""

#: src/ch17-04-streams.md:167
msgid ""
"Many concepts are naturally represented as streams: items becoming available "
"in a queue, chunks of data being pulled incrementally from the filesystem "
"when the full data set is too large for the computer’s memory, or data "
"arriving over the network over time. Because streams are futures, we can use "
"them with any other kind of future and combine them in interesting ways. For "
"example, we can batch up events to avoid triggering too many network calls, "
"set timeouts on sequences of long-running operations, or throttle user "
"interface events to avoid doing needless work."
msgstr ""

#: src/ch17-04-streams.md:176
msgid ""
"Let’s start by building a little stream of messages as a stand-in for a "
"stream of data we might see from a WebSocket or another real-time "
"communication protocol, as shown in Listing 17-33."
msgstr ""

#: src/ch17-04-streams.md:192 src/ch17-04-streams.md:258
#: src/ch17-04-streams.md:309 src/ch17-04-streams.md:426
#: src/ch17-04-streams.md:499 src/ch17-04-streams.md:579
#: src/ch17-04-streams.md:671 src/ch17-06-futures-tasks-threads.md:185
msgid "\"{message}\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"c\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"d\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"e\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"f\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"g\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"h\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"i\""
msgstr ""

#: src/ch17-04-streams.md:200 src/ch17-04-streams.md:268
#: src/ch17-04-streams.md:320 src/ch17-04-streams.md:437
#: src/ch17-04-streams.md:510 src/ch17-04-streams.md:590
#: src/ch17-04-streams.md:682 src/ch17-04-streams.md:803
#: src/ch17-06-futures-tasks-threads.md:64
msgid "\"j\""
msgstr ""

#: src/ch17-04-streams.md:202 src/ch17-04-streams.md:270
#: src/ch17-04-streams.md:325 src/ch17-04-streams.md:442
#: src/ch17-04-streams.md:515 src/ch17-04-streams.md:595
#: src/ch17-04-streams.md:687 src/ch17-04-streams.md:809
#: src/ch17-06-futures-tasks-threads.md:70
msgid "\"Message: '{message}'\""
msgstr ""

#: src/ch17-04-streams.md:211
msgid ""
"First, we create a function called `get_messages` that returns `impl "
"Stream<Item = String>`. For its implementation, we create an async channel, "
"loop over the first 10 letters of the English alphabet, and send them across "
"the channel."
msgstr ""

#: src/ch17-04-streams.md:215
msgid ""
"We also use a new type: `ReceiverStream`, which converts the `rx` receiver "
"from the `trpl::channel` into a `Stream` with a `next` method. Back in "
"`main`, we use a `while let` loop to print all the messages from the stream."
msgstr ""

#: src/ch17-04-streams.md:219
msgid "When we run this code, we get exactly the results we would expect:"
msgstr ""

#: src/ch17-04-streams.md:238
msgid ""
"Again, we could do this with the regular `Receiver` API or even the regular "
"`Iterator` API, though, so let’s add a feature that requires streams: adding "
"a timeout that applies to every item in the stream, and a delay on the items "
"we emit, as shown in Listing 17-34."
msgstr ""

#: src/ch17-04-streams.md:259 src/ch17-04-streams.md:310
#: src/ch17-04-streams.md:427 src/ch17-04-streams.md:500
#: src/ch17-04-streams.md:580 src/ch17-04-streams.md:672
#: src/ch17-04-streams.md:793 src/ch17-06-futures-tasks-threads.md:54
msgid "\"Problem: {reason:?}\""
msgstr ""

#: src/ch17-04-streams.md:279
msgid ""
"We start by adding a timeout to the stream with the `timeout` method, which "
"comes from the `StreamExt` trait. Then we update the body of the `while let` "
"loop, because the stream now returns a `Result`. The `Ok` variant indicates "
"a message arrived in time; the `Err` variant indicates that the timeout "
"elapsed before any message arrived. We `match` on that result and either "
"print the message when we receive it successfully or print a notice about "
"the timeout. Finally, notice that we pin the messages after applying the "
"timeout to them, because the timeout helper produces a stream that needs to "
"be pinned to be polled."
msgstr ""

#: src/ch17-04-streams.md:289
msgid ""
"However, because there are no delays between messages, this timeout does not "
"change the behavior of the program. Let’s add a variable delay to the "
"messages we send, as shown in Listing 17-35."
msgstr ""

#: src/ch17-04-streams.md:335
msgid ""
"In `get_messages`, we use the `enumerate` iterator method with the "
"`messages` array so that we can get the index of each item we’re sending "
"along with the item itself. Then we apply a 100-millisecond delay to even-"
"index items and a 300-millisecond delay to odd-index items to simulate the "
"different delays we might see from a stream of messages in the real world. "
"Because our timeout is for 200 milliseconds, this should affect half of the "
"messages."
msgstr ""

#: src/ch17-04-streams.md:342
msgid ""
"To sleep between messages in the `get_messages` function without blocking, "
"we need to use async. However, we can’t make `get_messages` itself into an "
"async function, because then we’d return a `Future<Output = Stream<Item = "
"String>>` instead of a `Stream<Item = String>>`. The caller would have to "
"await `get_messages` itself to get access to the stream. But remember: "
"everything in a given future happens linearly; concurrency happens _between_ "
"futures. Awaiting `get_messages` would require it to send all the messages, "
"including the sleep delay between each message, before returning the "
"receiver stream. As a result, the timeout would be useless. There would be "
"no delays in the stream itself; they would all happen before the stream was "
"even available."
msgstr ""

#: src/ch17-04-streams.md:353
msgid ""
"Instead, we leave `get_messages` as a regular function that returns a "
"stream, and we spawn a task to handle the async `sleep` calls."
msgstr ""

#: src/ch17-04-streams.md:356
msgid ""
"Note: Calling `spawn_task` in this way works because we already set up our "
"runtime; had we not, it would cause a panic. Other implementations choose "
"different tradeoffs: they might spawn a new runtime and avoid the panic but "
"end up with a bit of extra overhead, or they may simply not provide a "
"standalone way to spawn tasks without reference to a runtime. Make sure you "
"know what tradeoff your runtime has chosen and write your code accordingly!"
msgstr ""

#: src/ch17-04-streams.md:363
msgid ""
"Now our code has a much more interesting result. Between every other pair of "
"messages, a `Problem: Elapsed(())` error."
msgstr ""

#: src/ch17-04-streams.md:390
msgid ""
"The timeout doesn’t prevent the messages from arriving in the end. We still "
"get all of the original messages, because our channel is _unbounded_: it can "
"hold as many messages as we can fit in memory. If the message doesn’t arrive "
"before the timeout, our stream handler will account for that, but when it "
"polls the stream again, the message may now have arrived."
msgstr ""

#: src/ch17-04-streams.md:396
msgid ""
"You can get different behavior if needed by using other kinds of channels or "
"other kinds of streams more generally. Let’s see one of those in practice by "
"combining a stream of time intervals with this stream of messages."
msgstr ""

#: src/ch17-04-streams.md:400
msgid "Merging Streams"
msgstr ""

#: src/ch17-04-streams.md:402
msgid ""
"First, let’s create another stream, which will emit an item every "
"millisecond if we let it run directly. For simplicity, we can use the "
"`sleep` function to send a message on a delay and combine it with the same "
"approach we used in `get_messages` of creating a stream from a channel. The "
"difference is that this time, we’re going to send back the count of "
"intervals that have elapsed, so the return type will be `impl Stream<Item = "
"u32>`, and we can call the function `get_intervals` (see Listing 17-36)."
msgstr ""

#: src/ch17-04-streams.md:467
msgid ""
"We start by defining a `count` in the task. (We could define it outside the "
"task, too, but it’s clearer to limit the scope of any given variable.) Then "
"we create an infinite loop. Each iteration of the loop asynchronously sleeps "
"for one millisecond, increments the count, and then sends it over the "
"channel. Because this is all wrapped in the task created by `spawn_task`, "
"all of it—including the infinite loop—will get cleaned up along with the "
"runtime."
msgstr ""

#: src/ch17-04-streams.md:474
msgid ""
"This kind of infinite loop, which ends only when the whole runtime gets torn "
"down, is fairly common in async Rust: many programs need to keep running "
"indefinitely. With async, this doesn’t block anything else, as long as there "
"is at least one await point in each iteration through the loop."
msgstr ""

#: src/ch17-04-streams.md:479
msgid ""
"Now, back in our main function’s async block, we can attempt to merge the "
"`messages` and `intervals` streams, as shown in Listing 17-37."
msgstr ""

#: src/ch17-04-streams.md:540
msgid ""
"We start by calling `get_intervals`. Then we merge the `messages` and "
"`intervals` streams with the `merge` method, which combines multiple streams "
"into one stream that produces items from any of the source streams as soon "
"as the items are available, without imposing any particular ordering. "
"Finally, we loop over that combined stream instead of over `messages`."
msgstr ""

#: src/ch17-04-streams.md:546
msgid ""
"At this point, neither `messages` nor `intervals` needs to be pinned or "
"mutable, because both will be combined into the single `merged` stream. "
"However, this call to `merge` doesn’t compile! (Neither does the `next` call "
"in the `while let` loop, but we’ll come back to that.) This is because the "
"two streams have different types. The `messages` stream has the type "
"`Timeout<impl Stream<Item = String>>`, where `Timeout` is the type that "
"implements `Stream` for a `timeout` call. The `intervals` stream has the "
"type `impl Stream<Item = u32>`. To merge these two streams, we need to "
"transform one of them to match the other. We’ll rework the intervals stream, "
"because messages is already in the basic format we want and has to handle "
"timeout errors (see Listing 17-38)."
msgstr ""

#: src/ch17-04-streams.md:572 src/ch17-04-streams.md:663
msgid "\"Interval: {count}\""
msgstr ""

#: src/ch17-04-streams.md:620
msgid ""
"First, we can use the `map` helper method to transform the `intervals` into "
"a string. Second, we need to match the `Timeout` from `messages`. Because we "
"don’t actually _want_ a timeout for `intervals`, though, we can just create "
"a timeout which is longer than the other durations we are using. Here, we "
"create a 10-second timeout with `Duration::from_secs(10)`. Finally, we need "
"to make `stream` mutable, so that the `while let` loop’s `next` calls can "
"iterate through the stream, and pin it so that it’s safe to do so. That gets "
"us _almost_ to where we need to be. Everything type checks. If you run this, "
"though, there will be two problems. First, it will never stop! You’ll need "
"to stop it with <span class=\"keystroke\">ctrl-c</span>. Second, the "
"messages from the English alphabet will be buried in the midst of all the "
"interval counter messages:"
msgstr ""

#: src/ch17-04-streams.md:648
msgid "Listing 17-39 shows one way to solve these last two problems."
msgstr ""

#: src/ch17-04-streams.md:712
msgid ""
"First, we use the `throttle` method on the `intervals` stream so that it "
"doesn’t overwhelm the `messages` stream. _Throttling_ is a way of limiting "
"the rate at which a function will be called—or, in this case, how often the "
"stream will be polled. Once every 100 milliseconds should do, because that’s "
"roughly how often our messages arrive."
msgstr ""

#: src/ch17-04-streams.md:718
msgid ""
"To limit the number of items we will accept from a stream, we apply the "
"`take` method to the `merged` stream, because we want to limit the final "
"output, not just one stream or the other."
msgstr ""

#: src/ch17-04-streams.md:722
msgid ""
"Now when we run the program, it stops after pulling 20 items from the "
"stream, and the intervals don’t overwhelm the messages. We also don’t get "
"`Interval: 100` or `Interval: 200` or so on, but instead get `Interval: 1`, "
"`Interval: 2`, and so on—even though we have a source stream that _can_ "
"produce an event every millisecond. That’s because the `throttle` call "
"produces a new stream that wraps the original stream so that the original "
"stream gets polled only at the throttle rate, not its own “native” rate. We "
"don’t have a bunch of unhandled interval messages we’re choosing to ignore. "
"Instead, we never produce those interval messages in the first place! This "
"is the inherent “laziness” of Rust’s futures at work again, allowing us to "
"choose our performance characteristics."
msgstr ""

#: src/ch17-04-streams.md:762
msgid ""
"There’s one last thing we need to handle: errors! With both of these channel-"
"based streams, the `send` calls could fail when the other side of the "
"channel closes—and that’s just a matter of how the runtime executes the "
"futures that make up the stream. Up until now, we’ve ignored this "
"possibility by calling `unwrap`, but in a well-behaved app, we should "
"explicitly handle the error, at minimum by ending the loop so we don’t try "
"to send any more messages. Listing 17-40 shows a simple error strategy: "
"print the issue and then `break` from the loops."
msgstr ""

#: src/ch17-04-streams.md:784 src/ch17-06-futures-tasks-threads.md:45
msgid "\"Interval #{count}\""
msgstr ""

#: src/ch17-04-streams.md:792 src/ch17-06-futures-tasks-threads.md:53
msgid "\"{item}\""
msgstr ""

#: src/ch17-04-streams.md:810 src/ch17-06-futures-tasks-threads.md:71
msgid "\"Cannot send message '{message}': {send_error}\""
msgstr ""

#: src/ch17-04-streams.md:829 src/ch17-06-futures-tasks-threads.md:92
msgid "\"Could not send interval {count}: {send_error}\""
msgstr ""

#: src/ch17-04-streams.md:841
msgid ""
"As usual, the correct way to handle a message send error will vary; just "
"make sure you have a strategy."
msgstr ""

#: src/ch17-04-streams.md:844
msgid ""
"Now that we’ve seen a bunch of async in practice, let’s take a step back and "
"dig into a few of the details of how `Future`, `Stream`, and the other key "
"traits Rust uses to make async work."
msgstr ""

#: src/ch17-05-traits-for-async.md:5
msgid "<a id=\"digging-into-the-traits-for-async\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:7
msgid ""
"Throughout the chapter, we’ve used the `Future`, `Pin`, `Unpin`, `Stream`, "
"and `StreamExt` traits in various ways. So far, though, we’ve avoided "
"getting too far into the details of how they work or how they fit together, "
"which is fine most of the time for your day-to-day Rust work. Sometimes, "
"though, you’ll encounter situations where you’ll need to understand a few "
"more of these details. In this section, we’ll dig in just enough to help in "
"those scenarios, still leaving the _really_ deep dive for other "
"documentation."
msgstr ""

#: src/ch17-05-traits-for-async.md:17
msgid "<a id=\"future\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:19
msgid "The `Future` Trait"
msgstr ""

#: src/ch17-05-traits-for-async.md:21
msgid ""
"Let’s start by taking a closer look at how the `Future` trait works. Here’s "
"how Rust defines it:"
msgstr ""

#: src/ch17-05-traits-for-async.md:35
msgid ""
"That trait definition includes a bunch of new types and also some syntax we "
"haven’t seen before, so let’s walk through the definition piece by piece."
msgstr ""

#: src/ch17-05-traits-for-async.md:38
msgid ""
"First, `Future`’s associated type `Output` says what the future resolves to. "
"This is analogous to the `Item` associated type for the `Iterator` trait. "
"Second, `Future` also has the `poll` method, which takes a special `Pin` "
"reference for its `self` parameter and a mutable reference to a `Context` "
"type, and returns a `Poll<Self::Output>`. We’ll talk more about `Pin` and "
"`Context` in a moment. For now, let’s focus on what the method returns, the "
"`Poll` type:"
msgstr ""

#: src/ch17-05-traits-for-async.md:53
msgid ""
"This `Poll` type is similar to an `Option`. It has one variant that has a "
"value, `Ready(T)`, and one which does not, `Pending`. `Poll` means something "
"quite different from `Option`, though! The `Pending` variant indicates that "
"the future still has work to do, so the caller will need to check again "
"later. The `Ready` variant indicates that the future has finished its work "
"and the `T` value is available."
msgstr ""

#: src/ch17-05-traits-for-async.md:60
msgid ""
"Note: With most futures, the caller should not call `poll` again after the "
"future has returned `Ready`. Many futures will panic if polled again after "
"becoming ready. Futures that are safe to poll again will say so explicitly "
"in their documentation. This is similar to how `Iterator::next` behaves."
msgstr ""

#: src/ch17-05-traits-for-async.md:65
msgid ""
"When you see code that uses `await`, Rust compiles it under the hood to code "
"that calls `poll`. If you look back at Listing 17-4, where we printed out "
"the page title for a single URL once it resolved, Rust compiles it into "
"something kind of (although not exactly) like this:"
msgstr ""

#: src/ch17-05-traits-for-async.md:77
msgid "// But what goes here?\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:82
msgid ""
"What should we do when the future is still `Pending`? We need some way to "
"try again, and again, and again, until the future is finally ready. In other "
"words, we need a loop:"
msgstr ""

#: src/ch17-05-traits-for-async.md:95
msgid "// continue\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:101
msgid ""
"If Rust compiled it to exactly that code, though, every `await` would be "
"blocking—exactly the opposite of what we were going for! Instead, Rust makes "
"sure that the loop can hand off control to something that can pause work on "
"this future to work on other futures and then check this one again later. As "
"we’ve seen, that something is an async runtime, and this scheduling and "
"coordination work is one of its main jobs."
msgstr ""

#: src/ch17-05-traits-for-async.md:108
msgid ""
"Earlier in the chapter, we described waiting on `rx.recv`. The `recv` call "
"returns a future, and awaiting the future polls it. We noted that a runtime "
"will pause the future until it’s ready with either `Some(message)` or `None` "
"when the channel closes. With our deeper understanding of the `Future` "
"trait, and specifically `Future::poll`, we can see how that works. The "
"runtime knows the future isn’t ready when it returns `Poll::Pending`. "
"Conversely, the runtime knows the future _is_ ready and advances it when "
"`poll` returns `Poll::Ready(Some(message))` or `Poll::Ready(None)`."
msgstr ""

#: src/ch17-05-traits-for-async.md:117
msgid ""
"The exact details of how a runtime does that are beyond the scope of this "
"book, but the key is to see the basic mechanics of futures: a runtime "
"_polls_ each future it is responsible for, putting the future back to sleep "
"when it is not yet ready."
msgstr ""

#: src/ch17-05-traits-for-async.md:124
msgid "<a id=\"pinning-and-the-pin-and-unpin-traits\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:126
msgid "The `Pin` and `Unpin` Traits"
msgstr ""

#: src/ch17-05-traits-for-async.md:128
msgid ""
"When we introduced the idea of pinning in Listing 17-16, we ran into a very "
"gnarly error message. Here is the relevant part of it again:"
msgstr ""

#: src/ch17-05-traits-for-async.md:137
msgid ""
"```text\n"
"error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n"
"  --> src/main.rs:48:33\n"
"   |\n"
"48 |         trpl::join_all(futures).await;\n"
"   |                                 ^^^^^ the trait `Unpin` is not "
"implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required "
"by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`\n"
"   |\n"
"   = note: consider using the `pin!` macro\n"
"           consider using `Box::pin` if you need to access the pinned value "
"outside of the current scope\n"
"   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to "
"implement `Future`\n"
"note: required by a bound in `futures_util::future::join_all::JoinAll`\n"
"  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/"
"futures-util-0.3.30/src/future/join_all.rs:29:8\n"
"   |\n"
"27 | pub struct JoinAll<F>\n"
"   |            ------- required by a bound in this struct\n"
"28 | where\n"
"29 |     F: Future,\n"
"   |        ^^^^^^ required by this bound in `JoinAll`\n"
"```"
msgstr ""

#: src/ch17-05-traits-for-async.md:157
msgid ""
"This error message tells us not only that we need to pin the values but also "
"why pinning is required. The `trpl::join_all` function returns a struct "
"called `JoinAll`. That struct is generic over a type `F`, which is "
"constrained to implement the `Future` trait. Directly awaiting a future with "
"`await` pins the future implicitly. That’s why we don’t need to use `pin!` "
"everywhere we want to await futures."
msgstr ""

#: src/ch17-05-traits-for-async.md:164
msgid ""
"However, we’re not directly awaiting a future here. Instead, we construct a "
"new future, `JoinAll`, by passing a collection of futures to the `join_all` "
"function. The signature for `join_all` requires that the types of the items "
"in the collection all implement the `Future` trait, and `Box<T>` implements "
"`Future` only if the `T` it wraps is a future that implements the `Unpin` "
"trait."
msgstr ""

#: src/ch17-05-traits-for-async.md:170
msgid ""
"That’s a lot to absorb! To really understand it, let’s dive a little further "
"into how the `Future` trait actually works, in particular around _pinning_."
msgstr ""

#: src/ch17-05-traits-for-async.md:173
msgid "Look again at the definition of the `Future` trait:"
msgstr ""

#: src/ch17-05-traits-for-async.md:182
msgid "// Required method\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:187
msgid ""
"The `cx` parameter and its `Context` type are the key to how a runtime "
"actually knows when to check any given future while still being lazy. Again, "
"the details of how that works are beyond the scope of this chapter, and you "
"generally only need to think about this when writing a custom `Future` "
"implementation. We’ll focus instead on the type for `self`, as this is the "
"first time we’ve seen a method where `self` has a type annotation. A type "
"annotation for `self` works like type annotations for other function "
"parameters, but with two key differences:"
msgstr ""

#: src/ch17-05-traits-for-async.md:196
msgid "It tells Rust what type `self` must be for the method to be called."
msgstr ""

#: src/ch17-05-traits-for-async.md:198
msgid ""
"It can’t be just any type. It’s restricted to the type on which the method "
"is implemented, a reference or smart pointer to that type, or a `Pin` "
"wrapping a reference to that type."
msgstr ""

#: src/ch17-05-traits-for-async.md:202
msgid ""
"We’ll see more on this syntax in [Chapter 18](ch18-00-oop.html)<!-- ignore --"
">. For now, it’s enough to know that if we want to poll a future to check "
"whether it is `Pending` or `Ready(Output)`, we need a `Pin`\\-wrapped "
"mutable reference to the type."
msgstr ""

#: src/ch17-05-traits-for-async.md:207
msgid ""
"`Pin` is a wrapper for pointer-like types such as `&`, `&mut`, `Box`, and "
"`Rc`. (Technically, `Pin` works with types that implement the `Deref` or "
"`DerefMut` traits, but this is effectively equivalent to working only with "
"pointers.) `Pin` is not a pointer itself and doesn’t have any behavior of "
"its own like `Rc` and `Arc` do with reference counting; it’s purely a tool "
"the compiler can use to enforce constraints on pointer usage."
msgstr ""

#: src/ch17-05-traits-for-async.md:214
msgid ""
"Recalling that `await` is implemented in terms of calls to `poll` starts to "
"explain the error message we saw earlier, but that was in terms of `Unpin`, "
"not `Pin`. So how exactly does `Pin` relate to `Unpin`, and why does "
"`Future` need `self` to be in a `Pin` type to call `poll`?"
msgstr ""

#: src/ch17-05-traits-for-async.md:219
msgid ""
"Remember from earlier in this chapter a series of await points in a future "
"get compiled into a state machine, and the compiler makes sure that state "
"machine follows all of Rust’s normal rules around safety, including "
"borrowing and ownership. To make that work, Rust looks at what data is "
"needed between one await point and either the next await point or the end of "
"the async block. It then creates a corresponding variant in the compiled "
"state machine. Each variant gets the access it needs to the data that will "
"be used in that section of the source code, whether by taking ownership of "
"that data or by getting a mutable or immutable reference to it."
msgstr ""

#: src/ch17-05-traits-for-async.md:229
msgid ""
"So far, so good: if we get anything wrong about the ownership or references "
"in a given async block, the borrow checker will tell us. When we want to "
"move around the future that corresponds to that block—like moving it into a "
"`Vec` to pass to `join_all`—things get trickier."
msgstr ""

#: src/ch17-05-traits-for-async.md:234
msgid ""
"When we move a future—whether by pushing it into a data structure to use as "
"an iterator with `join_all` or by returning it from a function—that actually "
"means moving the state machine Rust creates for us. And unlike most other "
"types in Rust, the futures Rust creates for async blocks can end up with "
"references to themselves in the fields of any given variant, as shown in the "
"simplified illustration in Figure 17-4."
msgstr ""

#: src/ch17-05-traits-for-async.md:248
msgid ""
"By default, though, any object that has a reference to itself is unsafe to "
"move, because references always point to the actual memory address of "
"whatever they refer to (see Figure 17-5). If you move the data structure "
"itself, those internal references will be left pointing to the old location. "
"However, that memory location is now invalid. For one thing, its value will "
"not be updated when you make changes to the data structure. For another—more "
"important—thing, the computer is now free to reuse that memory for other "
"purposes! You could end up reading completely unrelated data later."
msgstr ""

#: src/ch17-05-traits-for-async.md:265
msgid ""
"Theoretically, the Rust compiler could try to update every reference to an "
"object whenever it gets moved, but that could add a lot of performance "
"overhead, especially if a whole web of references needs updating. If we "
"could instead make sure the data structure in question _doesn’t move in "
"memory_, we wouldn’t have to update any references. This is exactly what "
"Rust’s borrow checker requires: in safe code, it prevents you from moving "
"any item with an active reference to it."
msgstr ""

#: src/ch17-05-traits-for-async.md:273
msgid ""
"`Pin` builds on that to give us the exact guarantee we need. When we _pin_ a "
"value by wrapping a pointer to that value in `Pin`, it can no longer move. "
"Thus, if you have `Pin<Box<SomeType>>`, you actually pin the `SomeType` "
"value, _not_ the `Box` pointer. Figure 17-6 illustrates this process."
msgstr ""

#: src/ch17-05-traits-for-async.md:286
msgid ""
"In fact, the `Box` pointer can still move around freely. Remember: we care "
"about making sure the data ultimately being referenced stays in place. If a "
"pointer moves around, _but the data it points to is in the same place_, as "
"in Figure 17-7, there’s no potential problem. As an independent exercise, "
"look at the docs for the types as well as the `std::pin` module and try to "
"work out how you’d do this with a `Pin` wrapping a `Box`.) The key is that "
"the self-referential type itself cannot move, because it is still pinned."
msgstr ""

#: src/ch17-05-traits-for-async.md:302
msgid ""
"However, most types are perfectly safe to move around, even if they happen "
"to be behind a `Pin` pointer. We only need to think about pinning when items "
"have internal references. Primitive values such as numbers and Booleans are "
"safe since they obviously don’t have any internal references, so they’re "
"obviously safe. Neither do most types you normally work with in Rust. You "
"can move around a `Vec`, for example, without worrying. Given only what we "
"have seen so far, if you have a `Pin<Vec<String>>`, you’d have to do "
"everything via the safe but restrictive APIs provided by `Pin`, even though "
"a `Vec<String>` is always safe to move if there are no other references to "
"it. We need a way to tell the compiler that it’s fine to move items around "
"in cases like this—and there’s where `Unpin` comes into play."
msgstr ""

#: src/ch17-05-traits-for-async.md:314
msgid ""
"`Unpin` is a marker trait, similar to the `Send` and `Sync` traits we saw in "
"Chapter 16, and thus has no functionality of its own. Marker traits exist "
"only to tell the compiler it’s safe to use the type implementing a given "
"trait in a particular context. `Unpin` informs the compiler that a given "
"type does _not_ need to uphold any guarantees about whether the value in "
"question can be safely moved."
msgstr ""

#: src/ch17-05-traits-for-async.md:327
msgid ""
"Just as with `Send` and `Sync`, the compiler implements `Unpin` "
"automatically for all types where it can prove it is safe. A special case, "
"again similar to `Send` and `Sync`, is where `Unpin` is _not_ implemented "
"for a type. The notation for this is <code>impl !Unpin for <em>SomeType</"
"em></code>, where <code><em>SomeType</em></code> is the name of a type that "
"_does_ need to uphold those guarantees to be safe whenever a pointer to that "
"type is used in a `Pin`."
msgstr ""

#: src/ch17-05-traits-for-async.md:334
msgid ""
"In other words, there are two things to keep in mind about the relationship "
"between `Pin` and `Unpin`. First, `Unpin` is the “normal” case, and `!Unpin` "
"is the special case. Second, whether a type implements `Unpin` or `!Unpin` "
"_only_ matters when you’re using a pinned pointer to that type like "
"<code>Pin\\<&mut <em>SomeType</em>\\></code>."
msgstr ""

#: src/ch17-05-traits-for-async.md:340
msgid ""
"To make that concrete, think about a `String`: it has a length and the "
"Unicode characters that make it up. We can wrap a `String` in `Pin`, as seen "
"in Figure 17-8. However, `String` automatically implements `Unpin`, as do "
"most other types in Rust."
msgstr ""

#: src/ch17-05-traits-for-async.md:353
msgid ""
"As a result, we can do things that would be illegal if `String` implemented "
"`!Unpin` instead, such as replacing one string with another at the exact "
"same location in memory as in Figure 17-9. This doesn’t violate the `Pin` "
"contract, because `String` has no internal references that make it unsafe to "
"move around! That is precisely why it implements `Unpin` rather than `!"
"Unpin`."
msgstr ""

#: src/ch17-05-traits-for-async.md:367
msgid ""
"Now we know enough to understand the errors reported for that `join_all` "
"call from back in Listing 17-17. We originally tried to move the futures "
"produced by async blocks into a `Vec<Box<dyn Future<Output = ()>>>`, but as "
"we’ve seen, those futures may have internal references, so they don’t "
"implement `Unpin`. They need to be pinned, and then we can pass the `Pin` "
"type into the `Vec`, confident that the underlying data in the futures will "
"_not_ be moved."
msgstr ""

#: src/ch17-05-traits-for-async.md:374
msgid ""
"`Pin` and `Unpin` are mostly important for building lower-level libraries, "
"or when you’re building a runtime itself, rather than for day-to-day Rust "
"code. When you see these traits in error messages, though, now you’ll have a "
"better idea of how to fix your code!"
msgstr ""

#: src/ch17-05-traits-for-async.md:379
msgid ""
"Note: This combination of `Pin` and `Unpin` makes it possible to safely "
"implement a whole class of complex types in Rust that would otherwise prove "
"challenging because they’re self-referential. Types that require `Pin` show "
"up most commonly in async Rust today, but every once in a while, you might "
"see them in other contexts, too."
msgstr ""

#: src/ch17-05-traits-for-async.md:385
msgid ""
"The specifics of how `Pin` and `Unpin` work, and the rules they’re required "
"to uphold, are covered extensively in the API documentation for `std::pin`, "
"so if you’re interested in learning more, that’s a great place to start."
msgstr ""

#: src/ch17-05-traits-for-async.md:389
msgid ""
"If you want to understand how things work under the hood in even more "
"detail, see Chapters [2](https://rust-lang.github.io/async-book/02_execution/"
"01_chapter.html) and [4](https://rust-lang.github.io/async-book/04_pinning/"
"01_chapter.html) of [_Asynchronous Programming in Rust_](https://rust-"
"lang.github.io/async-book/)."
msgstr ""

#: src/ch17-05-traits-for-async.md:393
msgid "The `Stream` Trait"
msgstr ""

#: src/ch17-05-traits-for-async.md:395
msgid ""
"Now that you have a deeper grasp on the `Future`, `Pin`, and `Unpin` traits, "
"we can turn our attention to the `Stream` trait. As you learned earlier in "
"the chapter, streams are similar to asynchronous iterators. Unlike "
"`Iterator` and `Future`, however, `Stream` has no definition in the standard "
"library as of this writing, but there _is_ a very common definition from the "
"`futures` crate used throughout the ecosystem."
msgstr ""

#: src/ch17-05-traits-for-async.md:402
msgid ""
"Let’s review the definitions of the `Iterator` and `Future` traits before "
"looking at how a `Stream` trait might merge them together. From `Iterator`, "
"we have the idea of a sequence: its `next` method provides an "
"`Option<Self::Item>`. From `Future`, we have the idea of readiness over "
"time: its `poll` method provides a `Poll<Self::Output>`. To represent a "
"sequence of items that become ready over time, we define a `Stream` trait "
"that puts those features together:"
msgstr ""

#: src/ch17-05-traits-for-async.md:423
msgid ""
"The `Stream` trait defines an associated type called `Item` for the type of "
"the items produced by the stream. This is similar to `Iterator`, where there "
"may be zero to many items, and unlike `Future`, where there is always a "
"single `Output`, even if it’s the unit type `()`."
msgstr ""

#: src/ch17-05-traits-for-async.md:428
msgid ""
"`Stream` also defines a method to get those items. We call it `poll_next`, "
"to make it clear that it polls in the same way `Future::poll` does and "
"produces a sequence of items in the same way `Iterator::next` does. Its "
"return type combines `Poll` with `Option`. The outer type is `Poll`, because "
"it has to be checked for readiness, just as a future does. The inner type is "
"`Option`, because it needs to signal whether there are more messages, just "
"as an iterator does."
msgstr ""

#: src/ch17-05-traits-for-async.md:436
msgid ""
"Something very similar to this definition will likely end up as part of "
"Rust’s standard library. In the meantime, it’s part of the toolkit of most "
"runtimes, so you can rely on it, and everything we cover next should "
"generally apply!"
msgstr ""

#: src/ch17-05-traits-for-async.md:440
msgid ""
"In the example we saw in the section on streaming, though, we didn’t use "
"`poll_next` _or_ `Stream`, but instead used `next` and `StreamExt`. We "
"_could_ work directly in terms of the `poll_next` API by hand-writing our "
"own `Stream` state machines, of course, just as we _could_ work with futures "
"directly via their `poll` method. Using `await` is much nicer, though, and "
"the `StreamExt` trait supplies the `next` method so we can do just that:"
msgstr ""

#: src/ch17-05-traits-for-async.md:464
msgid "// other methods...\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:473
msgid ""
"Note: The actual definition we used earlier in the chapter looks slightly "
"different than this, because it supports versions of Rust that did not yet "
"support using async functions in traits. As a result, it looks like this:"
msgstr ""

#: src/ch17-05-traits-for-async.md:481
msgid ""
"That `Next` type is a `struct` that implements `Future` and allows us to "
"name the lifetime of the reference to `self` with `Next<'_, Self>`, so that "
"`await` can work with this method."
msgstr ""

#: src/ch17-05-traits-for-async.md:485
msgid ""
"The `StreamExt` trait is also the home of all the interesting methods "
"available to use with streams. `StreamExt` is automatically implemented for "
"every type that implements `Stream`, but these traits are defined separately "
"to enable the community to iterate on convenience APIs without affecting the "
"foundational trait."
msgstr ""

#: src/ch17-05-traits-for-async.md:491
msgid ""
"In the version of `StreamExt` used in the `trpl` crate, the trait not only "
"defines the `next` method but also supplies a default implementation of "
"`next` that correctly handles the details of calling `Stream::poll_next`. "
"This means that even when you need to write your own streaming data type, "
"you _only_ have to implement `Stream`, and then anyone who uses your data "
"type can use `StreamExt` and its methods with it automatically."
msgstr ""

#: src/ch17-05-traits-for-async.md:498
msgid ""
"That’s all we’re going to cover for the lower-level details on these traits. "
"To wrap up, let’s consider how futures (including streams), tasks, and "
"threads all fit together!"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:1
msgid "Putting It All Together: Futures, Tasks, and Threads"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:3
msgid ""
"As we saw in [Chapter 16](http://localhost:3000/ch16-00-"
"concurrency.html)<!-- ignore -->, threads provide one approach to "
"concurrency. We’ve seen another approach in this chapter: using async with "
"futures and streams. If you‘re wondering when to choose method over the "
"other, the answer is: it depends! And in many cases, the choice isn’t "
"threads _or_ async but rather threads _and_ async."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:9
msgid ""
"Many operating systems have supplied threading-based concurrency models for "
"decades now, and many programming languages support them as a result. "
"However, these models are not without their tradeoffs. On many operating "
"systems, they use a fair bit of memory for each thread, and they come with "
"some overhead for starting up and shutting down. Threads are also only an "
"option when your operating system and hardware support them. Unlike "
"mainstream desktop and mobile computers, some embedded systems don’t have an "
"OS at all, so they also don’t have threads."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:18
msgid ""
"The async model provides a different—and ultimately complementary—set of "
"tradeoffs. In the async model, concurrent operations don’t require their own "
"threads. Instead, they can run on tasks, as when we used `trpl::spawn_task` "
"to kick off work from a synchronous function in the streams section. A task "
"is similar to a thread, but instead of being managed by the operating "
"system, it’s managed by library-level code: the runtime."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:25
msgid ""
"In the previous section, we saw that we could build a stream by using an "
"async channel and spawning an async task we could call from synchronous "
"code. We can do the exact same thing with a thread. In Listing 17-40, we "
"used `trpl::spawn_task` and `trpl::sleep`. In Listing 17-41, we replace "
"those with the `thread::spawn` and `thread::sleep` APIs from the standard "
"library in the `get_intervals` function."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:83
msgid "// This is *not* `trpl::spawn` but `std::thread::spawn`!\n"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:87
msgid "// Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!\n"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:104
msgid ""
"If you run this code, the output is identical to that of Listing 17-40. And "
"notice how little changes here from the perspective of the calling code. "
"What’s more, even though one of our functions spawned an async task on the "
"runtime and the other spawned an OS thread, the resulting streams were "
"unaffected by the differences."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:110
msgid ""
"Despite their similarities, these two approaches behave very differently, "
"although we might have a hard time measuring it in this very simple example. "
"We could spawn millions of async tasks on any modern personal computer. If "
"we tried to do that with threads, we would literally run out of memory!"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:115
msgid ""
"However, there’s a reason these APIs are so similar. Threads act as a "
"boundary for sets of synchronous operations; concurrency is possible "
"_between_ threads. Tasks act as a boundary for sets of _asynchronous_ "
"operations; concurrency is possible both _between_ and _within_ tasks, "
"because a task can switch between futures in its body. Finally, futures are "
"Rust’s most granular unit of concurrency, and each future may represent a "
"tree of other futures. The runtime—specifically, its executor—manages tasks, "
"and tasks manage futures. In that regard, tasks are similar to lightweight, "
"runtime-managed threads with added capabilities that come from being managed "
"by a runtime instead of by the operating system."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:126
msgid ""
"This doesn’t mean that async tasks are always better than threads (or vice "
"versa). Concurrency with threads is in some ways a simpler programming model "
"than concurrency with `async`. That can be a strength or a weakness. Threads "
"are somewhat “fire and forget”; they have no native equivalent to a future, "
"so they simply run to completion without being interrupted except by the "
"operating system itself. That is, they have no built-in support for "
"_intratask concurrency_ the way futures do. Threads in Rust also have no "
"mechanisms for cancellation—a subject we haven’t covered explicitly in this "
"chapter but was implied by the fact that whenever we ended a future, its "
"state got cleaned up correctly."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:137
msgid ""
"These limitations also make threads harder to compose than futures. It’s "
"much more difficult, for example, to use threads to build helpers such as "
"the `timeout` and `throttle` methods we built earlier in this chapter. The "
"fact that futures are richer data structures means they can be composed "
"together more naturally, as we have seen."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:143
msgid ""
"Tasks, then, give us _additional_ control over futures, allowing us to "
"choose where and how to group them. And it turns out that threads and tasks "
"often work very well together, because tasks can (at least in some runtimes) "
"be moved around between threads. In fact, under the hood, the runtime we’ve "
"been using—including the `spawn_blocking` and `spawn_task` functions—is "
"multithreaded by default! Many runtimes use an approach called _work "
"stealing_ to transparently move tasks around between threads, based on how "
"the threads are currently being utilized, to improve the system’s overall "
"performance. That approach actually requires threads _and_ tasks, and "
"therefore futures."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:153
msgid ""
"When thinking about which method to use when, consider these rules of thumb:"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:155
msgid ""
"If the work is _very parallelizable_, such as processing a bunch of data "
"where each part can be processed separately, threads are a better choice."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:157
msgid ""
"If the work is _very concurrent_, such as handling messages from a bunch of "
"different sources that may come in at different intervals or different "
"rates, async is a better choice."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:161
msgid ""
"And if you need both parallelism and concurrency, you don’t have to choose "
"between threads and async. You can use them together freely, letting each "
"one play the part it’s best at. For example, Listing 17-42 shows a fairly "
"common example of this kind of mix in real-world Rust code."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:169
msgid "// for mdbook test\n"
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:193
msgid ""
"We begin by creating an async channel, then spawn a thread that takes "
"ownership of the sender side of the channel. Within the thread, we send the "
"numbers 1 through 10, sleeping for a second between each. Finally, we run a "
"future created with an async block passed to `trpl::run` just as we have "
"throughout the chapter. In that future, we await those messages, just as in "
"the other message-passing examples we have seen."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:200
msgid ""
"To return to the scenario we opened the chapter with, imagine running a set "
"of video encoding tasks using a dedicated thread (because video encoding is "
"compute-bound) but notifying the UI that those operations are done with an "
"async channel. There are countless examples of these kinds of combinations "
"in real-world use cases."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:208
msgid ""
"This isn’t the last you’ll see of concurrency in this book. The project in "
"[Chapter 21](ch21-00-final-project-a-web-server.html) will apply these "
"concepts in a more realistic situation than the simpler examples discussed "
"here and compare problem-solving with threading versus tasks more directly."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:212
msgid ""
"No matter which of these approaches you choose, Rust gives you the tools you "
"need to write safe, fast, concurrent code—whether for a high-throughput web "
"server or an embedded operating system."
msgstr ""

#: src/ch17-06-futures-tasks-threads.md:215
msgid ""
"Next, we’ll talk about idiomatic ways to model problems and structure "
"solutions as your Rust programs get bigger. In addition, we’ll discuss how "
"Rust’s idioms relate to those you might be familiar with from object-"
"oriented programming."
msgstr ""

#: src/ch18-00-oop.md:1
msgid "Object-Oriented Programming Features of Rust"
msgstr ""

#: src/ch18-00-oop.md:3
msgid ""
"Object-oriented programming (OOP) is a way of modeling programs. Objects as "
"a programmatic concept were introduced in the programming language Simula in "
"the 1960s. Those objects influenced Alan Kay’s programming architecture in "
"which objects pass messages to each other. To describe this architecture, he "
"coined the term _object-oriented programming_ in 1967. Many competing "
"definitions describe what OOP is, and by some of these definitions Rust is "
"object-oriented, but by others it is not. In this chapter, we’ll explore "
"certain characteristics that are commonly considered object-oriented and how "
"those characteristics translate to idiomatic Rust. We’ll then show you how "
"to implement an object-oriented design pattern in Rust and discuss the trade-"
"offs of doing so versus implementing a solution using some of Rust’s "
"strengths instead."
msgstr ""

#: src/ch18-01-what-is-oo.md:3
msgid ""
"There is no consensus in the programming community about what features a "
"language must have to be considered object-oriented. Rust is influenced by "
"many programming paradigms, including OOP; for example, we explored the "
"features that came from functional programming in Chapter 13. Arguably, OOP "
"languages share certain common characteristics, namely objects, "
"encapsulation, and inheritance. Let’s look at what each of those "
"characteristics means and whether Rust supports it."
msgstr ""

#: src/ch18-01-what-is-oo.md:11
msgid "Objects Contain Data and Behavior"
msgstr ""

#: src/ch18-01-what-is-oo.md:13
msgid ""
"The book _Design Patterns: Elements of Reusable Object-Oriented Software_ by "
"Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley "
"Professional, 1994), colloquially referred to as _The Gang of Four_ book, is "
"a catalog of object-oriented design patterns. It defines OOP this way:"
msgstr ""

#: src/ch18-01-what-is-oo.md:18
msgid ""
"Object-oriented programs are made up of objects. An **object** packages both "
"data and the procedures that operate on that data. The procedures are "
"typically called **methods** or **operations**."
msgstr ""

#: src/ch18-01-what-is-oo.md:22
msgid ""
"Using this definition, Rust is object-oriented: structs and enums have data, "
"and `impl` blocks provide methods on structs and enums. Even though structs "
"and enums with methods aren’t _called_ objects, they provide the same "
"functionality, according to the Gang of Four’s definition of objects."
msgstr ""

#: src/ch18-01-what-is-oo.md:27
msgid "Encapsulation that Hides Implementation Details"
msgstr ""

#: src/ch18-01-what-is-oo.md:29
msgid ""
"Another aspect commonly associated with OOP is the idea of _encapsulation_, "
"which means that the implementation details of an object aren’t accessible "
"to code using that object. Therefore, the only way to interact with an "
"object is through its public API; code using the object shouldn’t be able to "
"reach into the object’s internals and change data or behavior directly. This "
"enables the programmer to change and refactor an object’s internals without "
"needing to change the code that uses the object."
msgstr ""

#: src/ch18-01-what-is-oo.md:37
msgid ""
"We discussed how to control encapsulation in Chapter 7: we can use the `pub` "
"keyword to decide which modules, types, functions, and methods in our code "
"should be public, and by default everything else is private. For example, we "
"can define a struct `AveragedCollection` that has a field containing a "
"vector of `i32` values. The struct can also have a field that contains the "
"average of the values in the vector, meaning the average doesn’t have to be "
"computed on demand whenever anyone needs it. In other words, "
"`AveragedCollection` will cache the calculated average for us. Listing 18-1 "
"has the definition of the `AveragedCollection` struct:"
msgstr ""

#: src/ch18-01-what-is-oo.md:58
msgid ""
"The struct is marked `pub` so that other code can use it, but the fields "
"within the struct remain private. This is important in this case because we "
"want to ensure that whenever a value is added or removed from the list, the "
"average is also updated. We do this by implementing `add`, `remove`, and "
"`average` methods on the struct, as shown in Listing 18-2:"
msgstr ""

#: src/ch18-01-what-is-oo.md:102
msgid ""
"The public methods `add`, `remove`, and `average` are the only ways to "
"access or modify data in an instance of `AveragedCollection`. When an item "
"is added to `list` using the `add` method or removed using the `remove` "
"method, the implementations of each call the private `update_average` method "
"that handles updating the `average` field as well."
msgstr ""

#: src/ch18-01-what-is-oo.md:108
msgid ""
"We leave the `list` and `average` fields private so there is no way for "
"external code to add or remove items to or from the `list` field directly; "
"otherwise, the `average` field might become out of sync when the `list` "
"changes. The `average` method returns the value in the `average` field, "
"allowing external code to read the `average` but not modify it."
msgstr ""

#: src/ch18-01-what-is-oo.md:114
msgid ""
"Because we’ve encapsulated the implementation details of the struct "
"`AveragedCollection`, we can easily change aspects, such as the data "
"structure, in the future. For instance, we could use a `HashSet<i32>` "
"instead of a `Vec<i32>` for the `list` field. As long as the signatures of "
"the `add`, `remove`, and `average` public methods stay the same, code using "
"`AveragedCollection` wouldn’t need to change in order to compile. If we made "
"`list` public instead, this wouldn’t necessarily be the case: `HashSet<i32>` "
"and `Vec<i32>` have different methods for adding and removing items, so the "
"external code would likely have to change if it were modifying `list` "
"directly."
msgstr ""

#: src/ch18-01-what-is-oo.md:124
msgid ""
"If encapsulation is a required aspect for a language to be considered object-"
"oriented, then Rust meets that requirement. The option to use `pub` or not "
"for different parts of code enables encapsulation of implementation details."
msgstr ""

#: src/ch18-01-what-is-oo.md:128
msgid "Inheritance as a Type System and as Code Sharing"
msgstr ""

#: src/ch18-01-what-is-oo.md:130
msgid ""
"_Inheritance_ is a mechanism whereby an object can inherit elements from "
"another object’s definition, thus gaining the parent object’s data and "
"behavior without you having to define them again."
msgstr ""

#: src/ch18-01-what-is-oo.md:134
msgid ""
"If a language must have inheritance to be an object-oriented language, then "
"Rust is not one. There is no way to define a struct that inherits the parent "
"struct’s fields and method implementations without using a macro."
msgstr ""

#: src/ch18-01-what-is-oo.md:138
msgid ""
"However, if you’re used to having inheritance in your programming toolbox, "
"you can use other solutions in Rust, depending on your reason for reaching "
"for inheritance in the first place."
msgstr ""

#: src/ch18-01-what-is-oo.md:142
msgid ""
"You would choose inheritance for two main reasons. One is for reuse of code: "
"you can implement particular behavior for one type, and inheritance enables "
"you to reuse that implementation for a different type. You can do this in a "
"limited way in Rust code using default trait method implementations, which "
"you saw in Listing 10-14 when we added a default implementation of the "
"`summarize` method on the `Summary` trait. Any type implementing the "
"`Summary` trait would have the `summarize` method available on it without "
"any further code. This is similar to a parent class having an implementation "
"of a method and an inheriting child class also having the implementation of "
"the method. We can also override the default implementation of the "
"`summarize` method when we implement the `Summary` trait, which is similar "
"to a child class overriding the implementation of a method inherited from a "
"parent class."
msgstr ""

#: src/ch18-01-what-is-oo.md:155
msgid ""
"The other reason to use inheritance relates to the type system: to enable a "
"child type to be used in the same places as the parent type. This is also "
"called _polymorphism_, which means that you can substitute multiple objects "
"for each other at runtime if they share certain characteristics."
msgstr ""

#: src/ch18-01-what-is-oo.md:160
msgid "Polymorphism"
msgstr ""

#: src/ch18-01-what-is-oo.md:162
msgid ""
"To many people, polymorphism is synonymous with inheritance. But it’s "
"actually a more general concept that refers to code that can work with data "
"of multiple types. For inheritance, those types are generally subclasses."
msgstr ""

#: src/ch18-01-what-is-oo.md:166
msgid ""
"Rust instead uses generics to abstract over different possible types and "
"trait bounds to impose constraints on what those types must provide. This is "
"sometimes called _bounded parametric polymorphism_."
msgstr ""

#: src/ch18-01-what-is-oo.md:170
msgid ""
"Inheritance has recently fallen out of favor as a programming design "
"solution in many programming languages because it’s often at risk of sharing "
"more code than necessary. Subclasses shouldn’t always share all "
"characteristics of their parent class but will do so with inheritance. This "
"can make a program’s design less flexible. It also introduces the "
"possibility of calling methods on subclasses that don’t make sense or that "
"cause errors because the methods don’t apply to the subclass. In addition, "
"some languages will only allow _single inheritance_ (meaning a subclass can "
"only inherit from one class), further restricting the flexibility of a "
"program’s design."
msgstr ""

#: src/ch18-01-what-is-oo.md:180
msgid ""
"For these reasons, Rust takes the different approach of using trait objects "
"instead of inheritance. Let’s look at how trait objects enable polymorphism "
"in Rust."
msgstr ""

#: src/ch18-02-trait-objects.md:3
msgid ""
"In Chapter 8, we mentioned that one limitation of vectors is that they can "
"store elements of only one type. We created a workaround in Listing 8-9 "
"where we defined a `SpreadsheetCell` enum that had variants to hold "
"integers, floats, and text. This meant we could store different types of "
"data in each cell and still have a vector that represented a row of cells. "
"This is a perfectly good solution when our interchangeable items are a fixed "
"set of types that we know when our code is compiled."
msgstr ""

#: src/ch18-02-trait-objects.md:11
msgid ""
"However, sometimes we want our library user to be able to extend the set of "
"types that are valid in a particular situation. To show how we might achieve "
"this, we’ll create an example graphical user interface (GUI) tool that "
"iterates through a list of items, calling a `draw` method on each one to "
"draw it to the screen—a common technique for GUI tools. We’ll create a "
"library crate called `gui` that contains the structure of a GUI library. "
"This crate might include some types for people to use, such as `Button` or "
"`TextField`. In addition, `gui` users will want to create their own types "
"that can be drawn: for instance, one programmer might add an `Image` and "
"another might add a `SelectBox`."
msgstr ""

#: src/ch18-02-trait-objects.md:22
msgid ""
"We won’t implement a fully fledged GUI library for this example but will "
"show how the pieces would fit together. At the time of writing the library, "
"we can’t know and define all the types other programmers might want to "
"create. But we do know that `gui` needs to keep track of many values of "
"different types, and it needs to call a `draw` method on each of these "
"differently typed values. It doesn’t need to know exactly what will happen "
"when we call the `draw` method, just that the value will have that method "
"available for us to call."
msgstr ""

#: src/ch18-02-trait-objects.md:30
msgid ""
"To do this in a language with inheritance, we might define a class named "
"`Component` that has a method named `draw` on it. The other classes, such as "
"`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus "
"inherit the `draw` method. They could each override the `draw` method to "
"define their custom behavior, but the framework could treat all of the types "
"as if they were `Component` instances and call `draw` on them. But because "
"Rust doesn’t have inheritance, we need another way to structure the `gui` "
"library to allow users to extend it with new types."
msgstr ""

#: src/ch18-02-trait-objects.md:39
msgid "Defining a Trait for Common Behavior"
msgstr ""

#: src/ch18-02-trait-objects.md:41
msgid ""
"To implement the behavior we want `gui` to have, we’ll define a trait named "
"`Draw` that will have one method named `draw`. Then we can define a vector "
"that takes a trait object. A _trait object_ points to both an instance of a "
"type implementing our specified trait and a table used to look up trait "
"methods on that type at runtime. We create a trait object by specifying some "
"sort of pointer, such as an `&` reference or a `Box<T>` smart pointer, then "
"the `dyn` keyword, and then specifying the relevant trait. (We’ll talk about "
"the reason trait objects must use a pointer in [“Dynamically Sized Types and "
"the `Sized` Trait”](ch20-03-advanced-types.html#dynamically-sized-types-and-"
"the-sized-trait)<!-- ignore --> in Chapter 20.) We can use trait objects in "
"place of a generic or concrete type. Wherever we use a trait object, Rust’s "
"type system will ensure at compile time that any value used in that context "
"will implement the trait object’s trait. Consequently, we don’t need to know "
"all the possible types at compile time."
msgstr ""

#: src/ch18-02-trait-objects.md:55
msgid ""
"We’ve mentioned that, in Rust, we refrain from calling structs and enums "
"“objects” to distinguish them from other languages’ objects. In a struct or "
"enum, the data in the struct fields and the behavior in `impl` blocks are "
"separated, whereas in other languages, the data and behavior combined into "
"one concept is often labeled an object. However, trait objects _are_ more "
"like objects in other languages in the sense that they combine data and "
"behavior. But trait objects differ from traditional objects in that we can’t "
"add data to a trait object. Trait objects aren’t as generally useful as "
"objects in other languages: their specific purpose is to allow abstraction "
"across common behavior."
msgstr ""

#: src/ch18-02-trait-objects.md:66
msgid ""
"Listing 18-3 shows how to define a trait named `Draw` with one method named "
"`draw`:"
msgstr ""

#: src/ch18-02-trait-objects.md:79
msgid ""
"This syntax should look familiar from our discussions on how to define "
"traits in Chapter 10. Next comes some new syntax: Listing 18-4 defines a "
"struct named `Screen` that holds a vector named `components`. This vector is "
"of type `Box<dyn Draw>`, which is a trait object; it’s a stand-in for any "
"type inside a `Box` that implements the `Draw` trait."
msgstr ""

#: src/ch18-02-trait-objects.md:99
msgid ""
"On the `Screen` struct, we’ll define a method named `run` that will call the "
"`draw` method on each of its `components`, as shown in Listing 18-5:"
msgstr ""

#: src/ch18-02-trait-objects.md:124
msgid ""
"This works differently from defining a struct that uses a generic type "
"parameter with trait bounds. A generic type parameter can be substituted "
"with only one concrete type at a time, whereas trait objects allow for "
"multiple concrete types to fill in for the trait object at runtime. For "
"example, we could have defined the `Screen` struct using a generic type and "
"a trait bound as in Listing 18-6:"
msgstr ""

#: src/ch18-02-trait-objects.md:156
msgid ""
"This restricts us to a `Screen` instance that has a list of components all "
"of type `Button` or all of type `TextField`. If you’ll only ever have "
"homogeneous collections, using generics and trait bounds is preferable "
"because the definitions will be monomorphized at compile time to use the "
"concrete types."
msgstr ""

#: src/ch18-02-trait-objects.md:161
msgid ""
"On the other hand, with the method using trait objects, one `Screen` "
"instance can hold a `Vec<T>` that contains a `Box<Button>` as well as a "
"`Box<TextField>`. Let’s look at how this works, and then we’ll talk about "
"the runtime performance implications."
msgstr ""

#: src/ch18-02-trait-objects.md:166
msgid "Implementing the Trait"
msgstr ""

#: src/ch18-02-trait-objects.md:168
msgid ""
"Now we’ll add some types that implement the `Draw` trait. We’ll provide the "
"`Button` type. Again, actually implementing a GUI library is beyond the "
"scope of this book, so the `draw` method won’t have any useful "
"implementation in its body. To imagine what the implementation might look "
"like, a `Button` struct might have fields for `width`, `height`, and "
"`label`, as shown in Listing 18-7:"
msgstr ""

#: src/ch18-02-trait-objects.md:201
msgid "// code to actually draw a button\n"
msgstr ""

#: src/ch18-02-trait-objects.md:208
msgid ""
"The `width`, `height`, and `label` fields on `Button` will differ from the "
"fields on other components; for example, a `TextField` type might have those "
"same fields plus a `placeholder` field. Each of the types we want to draw on "
"the screen will implement the `Draw` trait but will use different code in "
"the `draw` method to define how to draw that particular type, as `Button` "
"has here (without the actual GUI code, as mentioned). The `Button` type, for "
"instance, might have an additional `impl` block containing methods related "
"to what happens when a user clicks the button. These kinds of methods won’t "
"apply to types like `TextField`."
msgstr ""

#: src/ch18-02-trait-objects.md:218
msgid ""
"If someone using our library decides to implement a `SelectBox` struct that "
"has `width`, `height`, and `options` fields, they implement the `Draw` trait "
"on the `SelectBox` type as well, as shown in Listing 18-8:"
msgstr ""

#: src/ch18-02-trait-objects.md:235 src/ch18-02-trait-objects.md:263
msgid "// code to actually draw a select box\n"
msgstr ""

#: src/ch18-02-trait-objects.md:244
msgid ""
"Our library’s user can now write their `main` function to create a `Screen` "
"instance. To the `Screen` instance, they can add a `SelectBox` and a "
"`Button` by putting each in a `Box<T>` to become a trait object. They can "
"then call the `run` method on the `Screen` instance, which will call `draw` "
"on each of the components. Listing 18-9 shows this implementation:"
msgstr ""

#: src/ch18-02-trait-objects.md:276
msgid "\"Yes\""
msgstr ""

#: src/ch18-02-trait-objects.md:277
msgid "\"Maybe\""
msgstr ""

#: src/ch18-02-trait-objects.md:278
msgid "\"No\""
msgstr ""

#: src/ch18-02-trait-objects.md:284
msgid "\"OK\""
msgstr ""

#: src/ch18-02-trait-objects.md:295
msgid ""
"When we wrote the library, we didn’t know that someone might add the "
"`SelectBox` type, but our `Screen` implementation was able to operate on the "
"new type and draw it because `SelectBox` implements the `Draw` trait, which "
"means it implements the `draw` method."
msgstr ""

#: src/ch18-02-trait-objects.md:300
msgid ""
"This concept—of being concerned only with the messages a value responds to "
"rather than the value’s concrete type—is similar to the concept of _duck "
"typing_ in dynamically typed languages: if it walks like a duck and quacks "
"like a duck, then it must be a duck! In the implementation of `run` on "
"`Screen` in Listing 18-5, `run` doesn’t need to know what the concrete type "
"of each component is. It doesn’t check whether a component is an instance of "
"a `Button` or a `SelectBox`, it just calls the `draw` method on the "
"component. By specifying `Box<dyn Draw>` as the type of the values in the "
"`components` vector, we’ve defined `Screen` to need values that we can call "
"the `draw` method on."
msgstr ""

#: src/ch18-02-trait-objects.md:311
msgid ""
"The advantage of using trait objects and Rust’s type system to write code "
"similar to code using duck typing is that we never have to check whether a "
"value implements a particular method at runtime or worry about getting "
"errors if a value doesn’t implement a method but we call it anyway. Rust "
"won’t compile our code if the values don’t implement the traits that the "
"trait objects need."
msgstr ""

#: src/ch18-02-trait-objects.md:317
msgid ""
"For example, Listing 18-10 shows what happens if we try to create a `Screen` "
"with a `String` as a component:"
msgstr ""

#: src/ch18-02-trait-objects.md:327
msgid "\"Hi\""
msgstr ""

#: src/ch18-02-trait-objects.md:336
msgid ""
"We’ll get this error because `String` doesn’t implement the `Draw` trait:"
msgstr ""

#: src/ch18-02-trait-objects.md:338
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling gui v0.1.0 (file:///projects/gui)\n"
"error[E0277]: the trait bound `String: Draw` is not satisfied\n"
" --> src/main.rs:5:26\n"
"  |\n"
"5 |         components: vec![Box::new(String::from(\"Hi\"))],\n"
"  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` "
"is not implemented for `String`\n"
"  |\n"
"  = help: the trait `Draw` is implemented for `Button`\n"
"  = note: required for the cast from `Box<String>` to `Box<dyn Draw>`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `gui` (bin \"gui\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch18-02-trait-objects.md:354
msgid ""
"This error lets us know that either we’re passing something to `Screen` we "
"didn’t mean to pass and so should pass a different type or we should "
"implement `Draw` on `String` so that `Screen` is able to call `draw` on it."
msgstr ""

#: src/ch18-02-trait-objects.md:358
msgid "Trait Objects Perform Dynamic Dispatch"
msgstr ""

#: src/ch18-02-trait-objects.md:360
msgid ""
"Recall in [“Performance of Code Using Generics”](ch10-01-"
"syntax.html#performance-of-code-using-generics)<!-- ignore --> in Chapter 10 "
"our discussion on the monomorphization process performed on generics by the "
"compiler: the compiler generates nongeneric implementations of functions and "
"methods for each concrete type that we use in place of a generic type "
"parameter. The code that results from monomorphization is doing _static "
"dispatch_, which is when the compiler knows what method you’re calling at "
"compile time. This is opposed to _dynamic dispatch_, which is when the "
"compiler can’t tell at compile time which method you’re calling. In dynamic "
"dispatch cases, the compiler emits code that at runtime will figure out "
"which method to call."
msgstr ""

#: src/ch18-02-trait-objects.md:371
msgid ""
"When we use trait objects, Rust must use dynamic dispatch. The compiler "
"doesn’t know all the types that might be used with the code that’s using "
"trait objects, so it doesn’t know which method implemented on which type to "
"call. Instead, at runtime, Rust uses the pointers inside the trait object to "
"know which method to call. This lookup incurs a runtime cost that doesn’t "
"occur with static dispatch. Dynamic dispatch also prevents the compiler from "
"choosing to inline a method’s code, which in turn prevents some "
"optimizations, and Rust has some rules about where you can and cannot use "
"dynamic dispatch, called [_dyn compatibility_](https://doc.rust-lang.org/"
"reference/items/traits.html#dyn-compatibility). However, we did get extra "
"flexibility in the code that we wrote in Listing 18-5 and were able to "
"support in Listing 18-9, so it’s a trade-off to consider."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:3
msgid ""
"The _state pattern_ is an object-oriented design pattern. The crux of the "
"pattern is that we define a set of states a value can have internally. The "
"states are represented by a set of _state objects_, and the value’s behavior "
"changes based on its state. We’re going to work through an example of a blog "
"post struct that has a field to hold its state, which will be a state object "
"from the set \"draft\", \"review\", or \"published\"."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:10
msgid ""
"The state objects share functionality: in Rust, of course, we use structs "
"and traits rather than objects and inheritance. Each state object is "
"responsible for its own behavior and for governing when it should change "
"into another state. The value that holds a state object knows nothing about "
"the different behavior of the states or when to transition between states."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:16
msgid ""
"The advantage of using the state pattern is that, when the business "
"requirements of the program change, we won’t need to change the code of the "
"value holding the state or the code that uses the value. We’ll only need to "
"update the code inside one of the state objects to change its rules or "
"perhaps add more state objects."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:22
msgid ""
"First, we’re going to implement the state pattern in a more traditional "
"object-oriented way, then we’ll use an approach that’s a bit more natural in "
"Rust. Let’s dig in to incrementally implementing a blog post workflow using "
"the state pattern."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:27
msgid "The final functionality will look like this:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:29
msgid "A blog post starts as an empty draft."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:30
msgid "When the draft is done, a review of the post is requested."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:31
msgid "When the post is approved, it gets published."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:32
msgid ""
"Only published blog posts return content to print, so unapproved posts can’t "
"accidentally be published."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:35
msgid ""
"Any other changes attempted on a post should have no effect. For example, if "
"we try to approve a draft blog post before we’ve requested a review, the "
"post should remain an unpublished draft."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:39
msgid ""
"Listing 18-11 shows this workflow in code form: this is an example usage of "
"the API we’ll implement in a library crate named `blog`. This won’t compile "
"yet because we haven’t implemented the `blog` crate."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:51 src/ch18-03-oo-design-patterns.md:58
#: src/ch18-03-oo-design-patterns.md:750 src/ch18-03-oo-design-patterns.md:757
#: src/ch18-03-oo-design-patterns.md:911 src/ch18-03-oo-design-patterns.md:917
msgid "\"I ate a salad for lunch today\""
msgstr ""

#: src/ch18-03-oo-design-patterns.md:64
msgid ""
"We want to allow the user to create a new draft blog post with `Post::new`. "
"We want to allow text to be added to the blog post. If we try to get the "
"post’s content immediately, before approval, we shouldn’t get any text "
"because the post is still a draft. We’ve added `assert_eq!` in the code for "
"demonstration purposes. An excellent unit test for this would be to assert "
"that a draft blog post returns an empty string from the `content` method, "
"but we’re not going to write tests for this example."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:72
msgid ""
"Next, we want to enable a request for a review of the post, and we want "
"`content` to return an empty string while waiting for the review. When the "
"post receives approval, it should get published, meaning the text of the "
"post will be returned when `content` is called."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:77
msgid ""
"Notice that the only type we’re interacting with from the crate is the "
"`Post` type. This type will use the state pattern and will hold a value that "
"will be one of three state objects representing the various states a post "
"can be in—draft, waiting for review, or published. Changing from one state "
"to another will be managed internally within the `Post` type. The states "
"change in response to the methods called by our library’s users on the "
"`Post` instance, but they don’t have to manage the state changes directly. "
"Also, users can’t make a mistake with the states, like publishing a post "
"before it’s reviewed."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:86
msgid "Defining `Post` and Creating a New Instance in the Draft State"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:88
msgid ""
"Let’s get started on the implementation of the library! We know we need a "
"public `Post` struct that holds some content, so we’ll start with the "
"definition of the struct and an associated public `new` function to create "
"an instance of `Post`, as shown in Listing 18-12. We’ll also make a private "
"`State` trait that will define the behavior that all state objects for a "
"`Post` must have."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:95
msgid ""
"Then `Post` will hold a trait object of `Box<dyn State>` inside an "
"`Option<T>` in a private field named `state` to hold the state object. "
"You’ll see why the `Option<T>` is necessary in a bit."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:125
msgid ""
"The `State` trait defines the behavior shared by different post states. The "
"state objects are `Draft`, `PendingReview`, and `Published`, and they will "
"all implement the `State` trait. For now, the trait doesn’t have any "
"methods, and we’ll start by defining just the `Draft` state because that is "
"the state we want a post to start in."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:131
msgid ""
"When we create a new `Post`, we set its `state` field to a `Some` value that "
"holds a `Box`. This `Box` points to a new instance of the `Draft` struct. "
"This ensures whenever we create a new instance of `Post`, it will start out "
"as a draft. Because the `state` field of `Post` is private, there is no way "
"to create a `Post` in any other state! In the `Post::new` function, we set "
"the `content` field to a new, empty `String`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:138
msgid "Storing the Text of the Post Content"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:140
msgid ""
"We saw in Listing 18-11 that we want to be able to call a method named "
"`add_text` and pass it a `&str` that is then added as the text content of "
"the blog post. We implement this as a method, rather than exposing the "
"`content` field as `pub`, so that later we can implement a method that will "
"control how the `content` field’s data is read. The `add_text` method is "
"pretty straightforward, so let’s add the implementation in Listing 18-13 to "
"the `impl Post` block:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:179
msgid ""
"The `add_text` method takes a mutable reference to `self`, because we’re "
"changing the `Post` instance that we’re calling `add_text` on. We then call "
"`push_str` on the `String` in `content` and pass the `text` argument to add "
"to the saved `content`. This behavior doesn’t depend on the state the post "
"is in, so it’s not part of the state pattern. The `add_text` method doesn’t "
"interact with the `state` field at all, but it is part of the behavior we "
"want to support."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:187
msgid "Ensuring the Content of a Draft Post Is Empty"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:189
msgid ""
"Even after we’ve called `add_text` and added some content to our post, we "
"still want the `content` method to return an empty string slice because the "
"post is still in the draft state, as shown on line 7 of Listing 18-11. For "
"now, let’s implement the `content` method with the simplest thing that will "
"fulfill this requirement: always returning an empty string slice. We’ll "
"change this later once we implement the ability to change a post’s state so "
"it can be published. So far, posts can only be in the draft state, so the "
"post content should always be empty. Listing 18-14 shows this placeholder "
"implementation:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:233
msgid ""
"With this added `content` method, everything in Listing 18-11 up to line 7 "
"works as intended."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:236
msgid "Requesting a Review of the Post Changes Its State"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:238
msgid ""
"Next, we need to add functionality to request a review of a post, which "
"should change its state from `Draft` to `PendingReview`. Listing 18-15 shows "
"this code:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:296
msgid ""
"We give `Post` a public method named `request_review` that will take a "
"mutable reference to `self`. Then we call an internal `request_review` "
"method on the current state of `Post`, and this second `request_review` "
"method consumes the current state and returns a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:301
msgid ""
"We add the `request_review` method to the `State` trait; all types that "
"implement the trait will now need to implement the `request_review` method. "
"Note that rather than having `self`, `&self`, or `&mut self` as the first "
"parameter of the method, we have `self: Box<Self>`. This syntax means the "
"method is only valid when called on a `Box` holding the type. This syntax "
"takes ownership of `Box<Self>`, invalidating the old state so the state "
"value of the `Post` can transform into a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:309
msgid ""
"To consume the old state, the `request_review` method needs to take "
"ownership of the state value. This is where the `Option` in the `state` "
"field of `Post` comes in: we call the `take` method to take the `Some` value "
"out of the `state` field and leave a `None` in its place, because Rust "
"doesn’t let us have unpopulated fields in structs. This lets us move the "
"`state` value out of `Post` rather than borrowing it. Then we’ll set the "
"post’s `state` value to the result of this operation."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:317
msgid ""
"We need to set `state` to `None` temporarily rather than setting it directly "
"with code like `self.state = self.state.request_review();` to get ownership "
"of the `state` value. This ensures `Post` can’t use the old `state` value "
"after we’ve transformed it into a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:322
msgid ""
"The `request_review` method on `Draft` returns a new, boxed instance of a "
"new `PendingReview` struct, which represents the state when a post is "
"waiting for a review. The `PendingReview` struct also implements the "
"`request_review` method but doesn’t do any transformations. Rather, it "
"returns itself, because when we request a review on a post already in the "
"`PendingReview` state, it should stay in the `PendingReview` state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:329
msgid ""
"Now we can start seeing the advantages of the state pattern: the "
"`request_review` method on `Post` is the same no matter its `state` value. "
"Each state is responsible for its own rules."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:333
msgid ""
"We’ll leave the `content` method on `Post` as is, returning an empty string "
"slice. We can now have a `Post` in the `PendingReview` state as well as in "
"the `Draft` state, but we want the same behavior in the `PendingReview` "
"state. Listing 18-11 now works up to line 10!"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:340
msgid ""
"<a id=\"adding-the-approve-method-that-changes-the-behavior-of-content\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:342
msgid "Adding `approve` to Change the Behavior of `content`"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:344
msgid ""
"The `approve` method will be similar to the `request_review` method: it will "
"set `state` to the value that the current state says it should have when "
"that state is approved, as shown in Listing 18-16:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:432
msgid ""
"We add the `approve` method to the `State` trait and add a new struct that "
"implements `State`, the `Published` state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:435
msgid ""
"Similar to the way `request_review` on `PendingReview` works, if we call the "
"`approve` method on a `Draft`, it will have no effect because `approve` will "
"return `self`. When we call `approve` on `PendingReview`, it returns a new, "
"boxed instance of the `Published` struct. The `Published` struct implements "
"the `State` trait, and for both the `request_review` method and the "
"`approve` method, it returns itself, because the post should stay in the "
"`Published` state in those cases."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:443
msgid ""
"Now we need to update the `content` method on `Post`. We want the value "
"returned from `content` to depend on the current state of the `Post`, so "
"we’re going to have the `Post` delegate to a `content` method defined on its "
"`state`, as shown in Listing 18-17:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:531
msgid ""
"Because the goal is to keep all these rules inside the structs that "
"implement `State`, we call a `content` method on the value in `state` and "
"pass the post instance (that is, `self`) as an argument. Then we return the "
"value that’s returned from using the `content` method on the `state` value."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:536
msgid ""
"We call the `as_ref` method on the `Option` because we want a reference to "
"the value inside the `Option` rather than ownership of the value. Because "
"`state` is an `Option<Box<dyn State>>`, when we call `as_ref`, an "
"`Option<&Box<dyn State>>` is returned. If we didn’t call `as_ref`, we would "
"get an error because we can’t move `state` out of the borrowed `&self` of "
"the function parameter."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:542
msgid ""
"We then call the `unwrap` method, which we know will never panic, because we "
"know the methods on `Post` ensure that `state` will always contain a `Some` "
"value when those methods are done. This is one of the cases we talked about "
"in the [“Cases In Which You Have More Information Than the Compiler”]"
"(ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-"
"information-than-the-compiler)<!-- ignore --> section of Chapter 9 when we "
"know that a `None` value is never possible, even though the compiler isn’t "
"able to understand that."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:550
msgid ""
"At this point, when we call `content` on the `&Box<dyn State>`, deref "
"coercion will take effect on the `&` and the `Box` so the `content` method "
"will ultimately be called on the type that implements the `State` trait. "
"That means we need to add `content` to the `State` trait definition, and "
"that is where we’ll put the logic for what content to return depending on "
"which state we have, as shown in Listing 18-18:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:650
msgid ""
"We add a default implementation for the `content` method that returns an "
"empty string slice. That means we don’t need to implement `content` on the "
"`Draft` and `PendingReview` structs. The `Published` struct will override "
"the `content` method and return the value in `post.content`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:655
msgid ""
"Note that we need lifetime annotations on this method, as we discussed in "
"Chapter 10. We’re taking a reference to a `post` as an argument and "
"returning a reference to part of that `post`, so the lifetime of the "
"returned reference is related to the lifetime of the `post` argument."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:660
msgid ""
"And we’re done—all of Listing 18-11 now works! We’ve implemented the state "
"pattern with the rules of the blog post workflow. The logic related to the "
"rules lives in the state objects rather than being scattered throughout "
"`Post`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:664
msgid "Why Not An Enum?"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:666
msgid ""
"You may have been wondering why we didn’t use an `enum` with the different "
"possible post states as variants. That’s certainly a possible solution, try "
"it and compare the end results to see which you prefer! One disadvantage of "
"using an enum is every place that checks the value of the enum will need a "
"`match` expression or similar to handle every possible variant. This could "
"get more repetitive than this trait object solution."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:673
msgid "Trade-offs of the State Pattern"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:675
msgid ""
"We’ve shown that Rust is capable of implementing the object-oriented state "
"pattern to encapsulate the different kinds of behavior a post should have in "
"each state. The methods on `Post` know nothing about the various behaviors. "
"The way we organized the code, we have to look in only one place to know the "
"different ways a published post can behave: the implementation of the "
"`State` trait on the `Published` struct."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:682
msgid ""
"If we were to create an alternative implementation that didn’t use the state "
"pattern, we might instead use `match` expressions in the methods on `Post` "
"or even in the `main` code that checks the state of the post and changes "
"behavior in those places. That would mean we would have to look in several "
"places to understand all the implications of a post being in the published "
"state! This would only increase the more states we added: each of those "
"`match` expressions would need another arm."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:690
msgid ""
"With the state pattern, the `Post` methods and the places we use `Post` "
"don’t need `match` expressions, and to add a new state, we would only need "
"to add a new struct and implement the trait methods on that one struct."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:694
msgid ""
"The implementation using the state pattern is easy to extend to add more "
"functionality. To see the simplicity of maintaining code that uses the state "
"pattern, try a few of these suggestions:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:698
msgid ""
"Add a `reject` method that changes the post’s state from `PendingReview` "
"back to `Draft`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:700
msgid ""
"Require two calls to `approve` before the state can be changed to "
"`Published`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:701
msgid ""
"Allow users to add text content only when a post is in the `Draft` state. "
"Hint: have the state object responsible for what might change about the "
"content but not responsible for modifying the `Post`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:705
msgid ""
"One downside of the state pattern is that, because the states implement the "
"transitions between states, some of the states are coupled to each other. If "
"we add another state between `PendingReview` and `Published`, such as "
"`Scheduled`, we would have to change the code in `PendingReview` to "
"transition to `Scheduled` instead. It would be less work if `PendingReview` "
"didn’t need to change with the addition of a new state, but that would mean "
"switching to another design pattern."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:713
msgid ""
"Another downside is that we’ve duplicated some logic. To eliminate some of "
"the duplication, we might try to make default implementations for the "
"`request_review` and `approve` methods on the `State` trait that return "
"`self`; however, this would not be dyn compatible, because the trait doesn’t "
"know what the concrete `self` will be exactly. We want to be able to use "
"`State` as a trait object, so we need its methods to be dyn compatible."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:720
msgid ""
"Other duplication includes the similar implementations of the "
"`request_review` and `approve` methods on `Post`. Both methods delegate to "
"the implementation of the same method on the value in the `state` field of "
"`Option` and set the new value of the `state` field to the result. If we had "
"a lot of methods on `Post` that followed this pattern, we might consider "
"defining a macro to eliminate the repetition (see the [“Macros”](ch20-05-"
"macros.html#macros)<!-- ignore --> section in Chapter 20)."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:727
msgid ""
"By implementing the state pattern exactly as it’s defined for object-"
"oriented languages, we’re not taking as full advantage of Rust’s strengths "
"as we could. Let’s look at some changes we can make to the `blog` crate that "
"can make invalid states and transitions into compile time errors."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:732
msgid "Encoding States and Behavior as Types"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:734
msgid ""
"We’ll show you how to rethink the state pattern to get a different set of "
"trade-offs. Rather than encapsulating the states and transitions completely "
"so outside code has no knowledge of them, we’ll encode the states into "
"different types. Consequently, Rust’s type checking system will prevent "
"attempts to use draft posts where only published posts are allowed by "
"issuing a compiler error."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:740
msgid "Let’s consider the first part of `main` in Listing 18-11:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:763
msgid ""
"We still enable the creation of new posts in the draft state using "
"`Post::new` and the ability to add text to the post’s content. But instead "
"of having a `content` method on a draft post that returns an empty string, "
"we’ll make it so draft posts don’t have the `content` method at all. That "
"way, if we try to get a draft post’s content, we’ll get a compiler error "
"telling us the method doesn’t exist. As a result, it will be impossible for "
"us to accidentally display draft post content in production, because that "
"code won’t even compile. Listing 18-19 shows the definition of a `Post` "
"struct and a `DraftPost` struct, as well as methods on each:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:805
msgid ""
"Both the `Post` and `DraftPost` structs have a private `content` field that "
"stores the blog post text. The structs no longer have the `state` field "
"because we’re moving the encoding of the state to the types of the structs. "
"The `Post` struct will represent a published post, and it has a `content` "
"method that returns the `content`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:811
msgid ""
"We still have a `Post::new` function, but instead of returning an instance "
"of `Post`, it returns an instance of `DraftPost`. Because `content` is "
"private and there aren’t any functions that return `Post`, it’s not possible "
"to create an instance of `Post` right now."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:816
msgid ""
"The `DraftPost` struct has an `add_text` method, so we can add text to "
"`content` as before, but note that `DraftPost` does not have a `content` "
"method defined! So now the program ensures all posts start as draft posts, "
"and draft posts don’t have their content available for display. Any attempt "
"to get around these constraints will result in a compiler error."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:822
msgid "Implementing Transitions as Transformations into Different Types"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:824
msgid ""
"So how do we get a published post? We want to enforce the rule that a draft "
"post has to be reviewed and approved before it can be published. A post in "
"the pending review state should still not display any content. Let’s "
"implement these constraints by adding another struct, `PendingReviewPost`, "
"defining the `request_review` method on `DraftPost` to return a "
"`PendingReviewPost`, and defining an `approve` method on `PendingReviewPost` "
"to return a `Post`, as shown in Listing 18-20:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:883
msgid ""
"The `request_review` and `approve` methods take ownership of `self`, thus "
"consuming the `DraftPost` and `PendingReviewPost` instances and transforming "
"them into a `PendingReviewPost` and a published `Post`, respectively. This "
"way, we won’t have any lingering `DraftPost` instances after we’ve called "
"`request_review` on them, and so forth. The `PendingReviewPost` struct "
"doesn’t have a `content` method defined on it, so attempting to read its "
"content results in a compiler error, as with `DraftPost`. Because the only "
"way to get a published `Post` instance that does have a `content` method "
"defined is to call the `approve` method on a `PendingReviewPost`, and the "
"only way to get a `PendingReviewPost` is to call the `request_review` method "
"on a `DraftPost`, we’ve now encoded the blog post workflow into the type "
"system."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:895
msgid ""
"But we also have to make some small changes to `main`. The `request_review` "
"and `approve` methods return new instances rather than modifying the struct "
"they’re called on, so we need to add more `let post =` shadowing assignments "
"to save the returned instances. We also can’t have the assertions about the "
"draft and pending review posts’ contents be empty strings, nor do we need "
"them: we can’t compile code that tries to use the content of posts in those "
"states any longer. The updated code in `main` is shown in Listing 18-21:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:923
msgid ""
"The changes we needed to make to `main` to reassign `post` mean that this "
"implementation doesn’t quite follow the object-oriented state pattern "
"anymore: the transformations between the states are no longer encapsulated "
"entirely within the `Post` implementation. However, our gain is that invalid "
"states are now impossible because of the type system and the type checking "
"that happens at compile time! This ensures that certain bugs, such as "
"display of the content of an unpublished post, will be discovered before "
"they make it to production."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:931
msgid ""
"Try the tasks suggested at the start of this section on the `blog` crate as "
"it is after Listing 18-21 to see what you think about the design of this "
"version of the code. Note that some of the tasks might be completed already "
"in this design."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:936
msgid ""
"We’ve seen that even though Rust is capable of implementing object-oriented "
"design patterns, other patterns, such as encoding state into the type "
"system, are also available in Rust. These patterns have different trade-"
"offs. Although you might be very familiar with object-oriented patterns, "
"rethinking the problem to take advantage of Rust’s features can provide "
"benefits, such as preventing some bugs at compile time. Object-oriented "
"patterns won’t always be the best solution in Rust due to certain features, "
"like ownership, that object-oriented languages don’t have."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:947
msgid ""
"No matter whether or not you think Rust is an object-oriented language after "
"reading this chapter, you now know that you can use trait objects to get "
"some object-oriented features in Rust. Dynamic dispatch can give your code "
"some flexibility in exchange for a bit of runtime performance. You can use "
"this flexibility to implement object-oriented patterns that can help your "
"code’s maintainability. Rust also has other features, like ownership, that "
"object-oriented languages don’t have. An object-oriented pattern won’t "
"always be the best way to take advantage of Rust’s strengths, but is an "
"available option."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:957
msgid ""
"Next, we’ll look at patterns, which are another of Rust’s features that "
"enable lots of flexibility. We’ve looked at them briefly throughout the book "
"but haven’t seen their full capability yet. Let’s go!"
msgstr ""

#: src/ch19-00-patterns.md:3
msgid ""
"_Patterns_ are a special syntax in Rust for matching against the structure "
"of types, both complex and simple. Using patterns in conjunction with "
"`match` expressions and other constructs gives you more control over a "
"program’s control flow. A pattern consists of some combination of the "
"following:"
msgstr ""

#: src/ch19-00-patterns.md:8
msgid "Literals"
msgstr ""

#: src/ch19-00-patterns.md:9
msgid "Destructured arrays, enums, structs, or tuples"
msgstr ""

#: src/ch19-00-patterns.md:10
msgid "Variables"
msgstr ""

#: src/ch19-00-patterns.md:11
msgid "Wildcards"
msgstr ""

#: src/ch19-00-patterns.md:12
msgid "Placeholders"
msgstr ""

#: src/ch19-00-patterns.md:14
msgid ""
"Some example patterns include `x`, `(a, 3)`, and `Some(Color::Red)`. In the "
"contexts in which patterns are valid, these components describe the shape of "
"data. Our program then matches values against the patterns to determine "
"whether it has the correct shape of data to continue running a particular "
"piece of code."
msgstr ""

#: src/ch19-00-patterns.md:19
msgid ""
"To use a pattern, we compare it to some value. If the pattern matches the "
"value, we use the value parts in our code. Recall the `match` expressions in "
"Chapter 6 that used patterns, such as the coin-sorting machine example. If "
"the value fits the shape of the pattern, we can use the named pieces. If it "
"doesn’t, the code associated with the pattern won’t run."
msgstr ""

#: src/ch19-00-patterns.md:25
msgid ""
"This chapter is a reference on all things related to patterns. We’ll cover "
"the valid places to use patterns, the difference between refutable and "
"irrefutable patterns, and the different kinds of pattern syntax that you "
"might see. By the end of the chapter, you’ll know how to use patterns to "
"express many concepts in a clear way."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:3
msgid ""
"Patterns pop up in a number of places in Rust, and you’ve been using them a "
"lot without realizing it! This section discusses all the places where "
"patterns are valid."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:7
msgid "`match` Arms"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:9
msgid ""
"As discussed in Chapter 6, we use patterns in the arms of `match` "
"expressions. Formally, `match` expressions are defined as the keyword "
"`match`, a value to match on, and one or more match arms that consist of a "
"pattern and an expression to run if the value matches that arm’s pattern, "
"like this:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:22
msgid ""
"For example, here's the `match` expression from Listing 6-5 that matches on "
"an `Option<i32>` value in the variable `x`:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:32
msgid ""
"The patterns in this `match` expression are the `None` and `Some(i)` on the "
"left of each arrow."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:35
msgid ""
"One requirement for `match` expressions is that they need to be _exhaustive_ "
"in the sense that all possibilities for the value in the `match` expression "
"must be accounted for. One way to ensure you’ve covered every possibility is "
"to have a catch-all pattern for the last arm: for example, a variable name "
"matching any value can never fail and thus covers every remaining case."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:41
msgid ""
"The particular pattern `_` will match anything, but it never binds to a "
"variable, so it’s often used in the last match arm. The `_` pattern can be "
"useful when you want to ignore any value not specified, for example. We’ll "
"cover the `_` pattern in more detail in the [“Ignoring Values in a Pattern”]"
"(ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern)<!-- ignore --> "
"section later in this chapter."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:48
msgid "Conditional `if let` Expressions"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:50
msgid ""
"In Chapter 6 we discussed how to use `if let` expressions mainly as a "
"shorter way to write the equivalent of a `match` that only matches one case. "
"Optionally, `if let` can have a corresponding `else` containing code to run "
"if the pattern in the `if let` doesn’t match."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:55
msgid ""
"Listing 19-1 shows that it’s also possible to mix and match `if let`, `else "
"if`, and `else if let` expressions. Doing so gives us more flexibility than "
"a `match` expression in which we can express only one value to compare with "
"the patterns. Also, Rust doesn't require that the conditions in a series of "
"`if let`, `else if`, `else if let` arms relate to each other."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:61
msgid ""
"The code in Listing 19-1 determines what color to make your background based "
"on a series of checks for several conditions. For this example, we’ve "
"created variables with hardcoded values that a real program might receive "
"from user input."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:72
msgid "\"34\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:75
msgid "\"Using your favorite color, {color}, as the background\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:77
msgid "\"Tuesday is green day!\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:80
msgid "\"Using purple as the background color\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:82
msgid "\"Using orange as the background color\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:85
msgid "\"Using blue as the background color\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:92
msgid ""
"If the user specifies a favorite color, that color is used as the "
"background. If no favorite color is specified and today is Tuesday, the "
"background color is green. Otherwise, if the user specifies their age as a "
"string and we can parse it as a number successfully, the color is either "
"purple or orange depending on the value of the number. If none of these "
"conditions apply, the background color is blue."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:99
msgid ""
"This conditional structure lets us support complex requirements. With the "
"hardcoded values we have here, this example will print `Using purple as the "
"background color`."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:103
msgid ""
"You can see that `if let` can also introduce new variables which shadow "
"existing variables in the same way that `match` arms can: the line `if let "
"Ok(age) = age` introduces a new `age` variable that contains the value "
"inside the `Ok` variant, shadowing the existing `age` variable. This means "
"we need to place the `if age > 30` condition within that block: we can’t "
"combine these two conditions into `if let Ok(age) = age && age > 30`. The "
"new `age` we want to compare to 30 isn’t valid until the new scope starts "
"with the curly bracket."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:111
msgid ""
"The downside of using `if let` expressions is that the compiler doesn’t "
"check for exhaustiveness, whereas with `match` expressions it does. If we "
"omitted the last `else` block and therefore missed handling some cases, the "
"compiler would not alert us to the possible logic bug."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:116
msgid "`while let` Conditional Loops"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:118
msgid ""
"Similar in construction to `if let`, the `while let` conditional loop allows "
"a `while` loop to run for as long as a pattern continues to match. We first "
"saw a `while let` loop in Chapter 17, where we used it to keep looping as "
"long as a stream produced new values. Similarly, in Listing 19-2 we show a "
"`while let` loop that waits on messages sent between threads, but in this "
"case checking a `Result` instead of an `Option`."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:137
msgid "\"{value}\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:144
msgid ""
"This example prints 1, 2, and 3. When we saw `recv` back in Chapter 16, we "
"unwrapped the error directly, or interacted with it as an iterator using a "
"`for` loop. As Listing 19-2 shows, though, we can also use `while let`, "
"because the `recv` method returns `Ok` as long as the sender is producing "
"messages, and then produces an `Err` once the sender side disconnects."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:150
msgid "`for` Loops"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:152
msgid ""
"In a `for` loop, the value that directly follows the keyword `for` is a "
"pattern. For example, in `for x in y` the `x` is the pattern. Listing 19-3 "
"demonstrates how to use a pattern in a `for` loop to destructure, or break "
"apart, a tuple as part of the `for` loop."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:161
msgid "'b'"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:164
msgid "\"{value} is at index {index}\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:171
msgid "The code in Listing 19-3 will print the following:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:173
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s\n"
"     Running `target/debug/patterns`\n"
"a is at index 0\n"
"b is at index 1\n"
"c is at index 2\n"
"```"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:183
msgid ""
"We adapt an iterator using the `enumerate` method so it produces a value and "
"the index for that value, placed into a tuple. The first value produced is "
"the tuple `(0, 'a')`. When this value is matched to the pattern `(index, "
"value)`, `index` will be `0` and `value` will be `'a'`, printing the first "
"line of the output."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:189
msgid "`let` Statements"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:191
msgid ""
"Prior to this chapter, we had only explicitly discussed using patterns with "
"`match` and `if let`, but in fact, we’ve used patterns in other places as "
"well, including in `let` statements. For example, consider this "
"straightforward variable assignment with `let`:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:200
msgid ""
"Every time you've used a `let` statement like this you've been using "
"patterns, although you might not have realized it! More formally, a `let` "
"statement looks like this:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:208
msgid ""
"In statements like `let x = 5;` with a variable name in the `PATTERN` slot, "
"the variable name is just a particularly simple form of a pattern. Rust "
"compares the expression against the pattern and assigns any names it finds. "
"So in the `let x = 5;` example, `x` is a pattern that means “bind what "
"matches here to the variable `x`.” Because the name `x` is the whole "
"pattern, this pattern effectively means “bind everything to the variable "
"`x`, whatever the value is.”"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:215
msgid ""
"To see the pattern matching aspect of `let` more clearly, consider Listing "
"19-4, which uses a pattern with `let` to destructure a tuple."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:228
msgid ""
"Here, we match a tuple against a pattern. Rust compares the value `(1, 2, "
"3)` to the pattern `(x, y, z)` and sees that the value matches the pattern, "
"so Rust binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this "
"tuple pattern as nesting three individual variable patterns inside it."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:233
msgid ""
"If the number of elements in the pattern doesn’t match the number of "
"elements in the tuple, the overall type won’t match and we’ll get a compiler "
"error. For example, Listing 19-5 shows an attempt to destructure a tuple "
"with three elements into two variables, which won’t work."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:248
msgid "Attempting to compile this code results in this type error:"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:250
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:2:9\n"
"  |\n"
"2 |     let (x, y) = (1, 2, 3);\n"
"  |         ^^^^^^   --------- this expression has type `({integer}, "
"{integer}, {integer})`\n"
"  |         |\n"
"  |         expected a tuple with 3 elements, found one with 2 elements\n"
"  |\n"
"  = note: expected tuple `({integer}, {integer}, {integer})`\n"
"             found tuple `(_, _)`\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `patterns` (bin \"patterns\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:268
msgid ""
"To fix the error, we could ignore one or more of the values in the tuple "
"using `_` or `..`, as you’ll see in the [“Ignoring Values in a Pattern”]"
"(ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern)<!-- ignore --> "
"section. If the problem is that we have too many variables in the pattern, "
"the solution is to make the types match by removing variables so the number "
"of variables equals the number of elements in the tuple."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:275
msgid "Function Parameters"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:277
msgid ""
"Function parameters can also be patterns. The code in Listing 19-6, which "
"declares a function named `foo` that takes one parameter named `x` of type "
"`i32`, should by now look familiar."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:285
msgid "// code goes here\n"
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:293
msgid ""
"The `x` part is a pattern! As we did with `let`, we could match a tuple in a "
"function’s arguments to the pattern. Listing 19-7 splits the values in a "
"tuple as we pass it to a function."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:301
msgid "\"Current location: ({x}, {y})\""
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:312
msgid ""
"This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the "
"pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:315
msgid ""
"We can also use patterns in closure parameter lists in the same way as in "
"function parameter lists, because closures are similar to functions, as "
"discussed in Chapter 13."
msgstr ""

#: src/ch19-01-all-the-places-for-patterns.md:319
msgid ""
"At this point, you’ve seen several ways of using patterns, but patterns "
"don’t work the same in every place we can use them. In some places, the "
"patterns must be irrefutable; in other circumstances, they can be refutable. "
"We’ll discuss these two concepts next."
msgstr ""

#: src/ch19-02-refutability.md:3
msgid ""
"Patterns come in two forms: refutable and irrefutable. Patterns that will "
"match for any possible value passed are _irrefutable_. An example would be "
"`x` in the statement `let x = 5;` because `x` matches anything and therefore "
"cannot fail to match. Patterns that can fail to match for some possible "
"value are _refutable_. An example would be `Some(x)` in the expression `if "
"let Some(x) = a_value` because if the value in the `a_value` variable is "
"`None` rather than `Some`, the `Some(x)` pattern will not match."
msgstr ""

#: src/ch19-02-refutability.md:11
msgid ""
"Function parameters, `let` statements, and `for` loops can only accept "
"irrefutable patterns, because the program cannot do anything meaningful when "
"values don’t match. The `if let` and `while let` expressions and the `let`\\-"
"`else` statement accept refutable and irrefutable patterns, but the compiler "
"warns against irrefutable patterns because by definition they’re intended to "
"handle possible failure: the functionality of a conditional is in its "
"ability to perform differently depending on success or failure."
msgstr ""

#: src/ch19-02-refutability.md:19
msgid ""
"In general, you shouldn’t have to worry about the distinction between "
"refutable and irrefutable patterns; however, you do need to be familiar with "
"the concept of refutability so you can respond when you see it in an error "
"message. In those cases, you’ll need to change either the pattern or the "
"construct you’re using the pattern with, depending on the intended behavior "
"of the code."
msgstr ""

#: src/ch19-02-refutability.md:25
msgid ""
"Let’s look at an example of what happens when we try to use a refutable "
"pattern where Rust requires an irrefutable pattern and vice versa. Listing "
"19-8 shows a `let` statement, but for the pattern we’ve specified `Some(x)`, "
"a refutable pattern. As you might expect, this code will not compile."
msgstr ""

#: src/ch19-02-refutability.md:41
msgid ""
"If `some_option_value` was a `None` value, it would fail to match the "
"pattern `Some(x)`, meaning the pattern is refutable. However, the `let` "
"statement can only accept an irrefutable pattern because there is nothing "
"valid the code can do with a `None` value. At compile time, Rust will "
"complain that we’ve tried to use a refutable pattern where an irrefutable "
"pattern is required:"
msgstr ""

#: src/ch19-02-refutability.md:47
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error[E0005]: refutable pattern in local binding\n"
" --> src/main.rs:3:9\n"
"  |\n"
"3 |     let Some(x) = some_option_value;\n"
"  |         ^^^^^^^ pattern `None` not covered\n"
"  |\n"
"  = note: `let` bindings require an \"irrefutable pattern\", like a `struct` "
"or an `enum` with only one variant\n"
"  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-"
"refutability.html\n"
"  = note: the matched value is of type `Option<i32>`\n"
"help: you might want to use `let else` to handle the variant that isn't "
"matched\n"
"  |\n"
"3 |     let Some(x) = some_option_value else { todo!() };\n"
"  |                                     ++++++++++++++++\n"
"\n"
"For more information about this error, try `rustc --explain E0005`.\n"
"error: could not compile `patterns` (bin \"patterns\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch19-02-refutability.md:68
msgid ""
"Because we didn’t cover (and couldn’t cover!) every valid value with the "
"pattern `Some(x)`, Rust rightfully produces a compiler error."
msgstr ""

#: src/ch19-02-refutability.md:71
msgid ""
"If we have a refutable pattern where an irrefutable pattern is needed, we "
"can fix it by changing the code that uses the pattern: instead of using "
"`let`, we can use `if let`. Then if the pattern doesn’t match, the code will "
"just skip the code in the curly brackets, giving it a way to continue "
"validly. Listing 19-9 shows how to fix the code in Listing 19-8."
msgstr ""

#: src/ch19-02-refutability.md:83 src/ch19-02-refutability.md:100
#: src/appendix-04-useful-development-tools.md:44
#: src/appendix-04-useful-development-tools.md:84
msgid "\"{x}\""
msgstr ""

#: src/ch19-02-refutability.md:90
msgid ""
"We’ve given the code an out! This code is perfectly valid now. However, if "
"we give `if let` an irrefutable pattern (a pattern that will always match), "
"such as `x`, as shown in Listing 19-10, the compiler will give a warning."
msgstr ""

#: src/ch19-02-refutability.md:107
msgid ""
"Rust complains that it doesn’t make sense to use `if let` with an "
"irrefutable pattern:"
msgstr ""

#: src/ch19-02-refutability.md:110
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"warning: irrefutable `if let` pattern\n"
" --> src/main.rs:2:8\n"
"  |\n"
"2 |     if let x = 5 {\n"
"  |        ^^^^^^^^^\n"
"  |\n"
"  = note: this pattern will always match, so the `if let` is useless\n"
"  = help: consider replacing the `if let` with a `let`\n"
"  = note: `#[warn(irrefutable_let_patterns)]` on by default\n"
"\n"
"warning: `patterns` (bin \"patterns\") generated 1 warning\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s\n"
"     Running `target/debug/patterns`\n"
"5\n"
"```"
msgstr ""

#: src/ch19-02-refutability.md:129
msgid ""
"For this reason, match arms must use refutable patterns, except for the last "
"arm, which should match any remaining values with an irrefutable pattern. "
"Rust allows us to use an irrefutable pattern in a `match` with only one arm, "
"but this syntax isn’t particularly useful and could be replaced with a "
"simpler `let` statement."
msgstr ""

#: src/ch19-02-refutability.md:135
msgid ""
"Now that you know where to use patterns and the difference between refutable "
"and irrefutable patterns, let’s cover all the syntax we can use to create "
"patterns."
msgstr ""

#: src/ch19-03-pattern-syntax.md:3
msgid ""
"In this section, we gather all the syntax valid in patterns and discuss why "
"and when you might want to use each one."
msgstr ""

#: src/ch19-03-pattern-syntax.md:6
msgid "Matching Literals"
msgstr ""

#: src/ch19-03-pattern-syntax.md:8
msgid ""
"As you saw in Chapter 6, you can match patterns against literals directly. "
"The following code gives some examples:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:16
msgid "\"one\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:17
msgid "\"two\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:18 src/ch19-03-pattern-syntax.md:101
msgid "\"three\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:19 src/ch19-03-pattern-syntax.md:102
msgid "\"anything\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:24
msgid ""
"This code prints `one` because the value in `x` is 1. This syntax is useful "
"when you want your code to take an action if it gets a particular concrete "
"value."
msgstr ""

#: src/ch19-03-pattern-syntax.md:28
msgid "Matching Named Variables"
msgstr ""

#: src/ch19-03-pattern-syntax.md:30
msgid ""
"Named variables are irrefutable patterns that match any value, and we’ve "
"used them many times in the book. However, there is a complication when you "
"use named variables in `match`, `if let`, or `while let` expressions. "
"Because each of these kinds of expression starts a new scope, variables "
"declared as part of a pattern inside the expression will shadow those with "
"the same name outside, as is the case with all variables. In Listing 19-11, "
"we declare a variable named `x` with the value `Some(5)` and a variable `y` "
"with the value `10`. We then create a `match` expression on the value `x`. "
"Look at the patterns in the match arms and `println!` at the end, and try to "
"figure out what the code will print before running this code or reading "
"further."
msgstr ""

#: src/ch19-03-pattern-syntax.md:49 src/ch19-03-pattern-syntax.md:728
msgid "\"Got 50\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:50
msgid "\"Matched, y = {y}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:51 src/ch19-03-pattern-syntax.md:730
msgid "\"Default case, x = {x:?}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:54 src/ch19-03-pattern-syntax.md:733
msgid "\"at the end: x = {x:?}, y = {y}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:60
msgid ""
"Let’s walk through what happens when the `match` expression runs. The "
"pattern in the first match arm doesn’t match the defined value of `x`, so "
"the code continues."
msgstr ""

#: src/ch19-03-pattern-syntax.md:64
msgid ""
"The pattern in the second match arm introduces a new variable named `y` that "
"will match any value inside a `Some` value. Because we’re in a new scope "
"inside the `match` expression, this is a new `y` variable, not the `y` we "
"declared at the beginning with the value 10. This new `y` binding will match "
"any value inside a `Some`, which is what we have in `x`. Therefore, this new "
"`y` binds to the inner value of the `Some` in `x`. That value is `5`, so the "
"expression for that arm executes and prints `Matched, y = 5`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:72
msgid ""
"If `x` had been a `None` value instead of `Some(5)`, the patterns in the "
"first two arms wouldn’t have matched, so the value would have matched to the "
"underscore. We didn’t introduce the `x` variable in the pattern of the "
"underscore arm, so the `x` in the expression is still the outer `x` that "
"hasn’t been shadowed. In this hypothetical case, the `match` would print "
"`Default case, x = None`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:79
msgid ""
"When the `match` expression is done, its scope ends, and so does the scope "
"of the inner `y`. The last `println!` produces `at the end: x = Some(5), y = "
"10`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:82
msgid ""
"To create a `match` expression that compares the values of the outer `x` and "
"`y`, rather than introducing a new variable which shadows the existing `y` "
"variable, we would need to use a match guard conditional instead. We’ll talk "
"about match guards later in the [“Extra Conditionals with Match Guards”]"
"(#extra-conditionals-with-match-guards)<!-- ignore --> section."
msgstr ""

#: src/ch19-03-pattern-syntax.md:88
msgid "Multiple Patterns"
msgstr ""

#: src/ch19-03-pattern-syntax.md:90
msgid ""
"You can match multiple patterns using the `|` syntax, which is the pattern "
"_or_ operator. For example, in the following code we match the value of `x` "
"against the match arms, the first of which has an _or_ option, meaning if "
"the value of `x` matches either of the values in that arm, that arm’s code "
"will run:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:100
msgid "\"one or two\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:107
msgid "This code prints `one or two`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:109
msgid "Matching Ranges of Values with `..=`"
msgstr ""

#: src/ch19-03-pattern-syntax.md:111
msgid ""
"The `..=` syntax allows us to match to an inclusive range of values. In the "
"following code, when a pattern matches any of the values within the given "
"range, that arm will execute:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:120
msgid "\"one through five\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:121 src/ch19-03-pattern-syntax.md:145
msgid "\"something else\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:126
msgid ""
"If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more "
"convenient for multiple match values than using the `|` operator to express "
"the same idea; if we were to use `|` we would have to specify `1 | 2 | 3 | 4 "
"| 5`. Specifying a range is much shorter, especially if we want to match, "
"say, any number between 1 and 1,000!"
msgstr ""

#: src/ch19-03-pattern-syntax.md:132
msgid ""
"The compiler checks that the range isn’t empty at compile time, and because "
"the only types for which Rust can tell if a range is empty or not are `char` "
"and numeric values, ranges are only allowed with numeric or `char` values."
msgstr ""

#: src/ch19-03-pattern-syntax.md:136
msgid "Here is an example using ranges of `char` values:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:143
msgid "'j'"
msgstr ""

#: src/ch19-03-pattern-syntax.md:143
msgid "\"early ASCII letter\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:144
msgid "'k'"
msgstr ""

#: src/ch19-03-pattern-syntax.md:144
msgid "\"late ASCII letter\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:150
msgid ""
"Rust can tell that `'c'` is within the first pattern’s range and prints "
"`early ASCII letter`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:153
msgid "Destructuring to Break Apart Values"
msgstr ""

#: src/ch19-03-pattern-syntax.md:155
msgid ""
"We can also use patterns to destructure structs, enums, and tuples to use "
"different parts of these values. Let’s walk through each value."
msgstr ""

#: src/ch19-03-pattern-syntax.md:158
msgid "Destructuring Structs"
msgstr ""

#: src/ch19-03-pattern-syntax.md:160
msgid ""
"Listing 19-12 shows a `Point` struct with two fields, `x` and `y`, that we "
"can break apart using a pattern with a `let` statement."
msgstr ""

#: src/ch19-03-pattern-syntax.md:182
msgid ""
"This code creates the variables `a` and `b` that match the values of the `x` "
"and `y` fields of the `p` struct. This example shows that the names of the "
"variables in the pattern don’t have to match the field names of the struct. "
"However, it’s common to match the variable names to the field names to make "
"it easier to remember which variables came from which fields. Because of "
"this common usage, and because writing `let Point { x: x, y: y } = p;` "
"contains a lot of duplication, Rust has a shorthand for patterns that match "
"struct fields: you only need to list the name of the struct field, and the "
"variables created from the pattern will have the same names. Listing 19-13 "
"behaves in the same way as the code in Listing 19-12, but the variables "
"created in the `let` pattern are `x` and `y` instead of `a` and `b`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:213
msgid ""
"This code creates the variables `x` and `y` that match the `x` and `y` "
"fields of the `p` variable. The outcome is that the variables `x` and `y` "
"contain the values from the `p` struct."
msgstr ""

#: src/ch19-03-pattern-syntax.md:217
msgid ""
"We can also destructure with literal values as part of the struct pattern "
"rather than creating variables for all the fields. Doing so allows us to "
"test some of the fields for particular values while creating variables to "
"destructure the other fields."
msgstr ""

#: src/ch19-03-pattern-syntax.md:222
msgid ""
"In Listing 19-14, we have a `match` expression that separates `Point` values "
"into three cases: points that lie directly on the `x` axis (which is true "
"when `y = 0`), on the `y` axis (`x = 0`), or neither."
msgstr ""

#: src/ch19-03-pattern-syntax.md:238
msgid "\"On the x axis at {x}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:239
msgid "\"On the y axis at {y}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:241
msgid "\"On neither axis: ({x}, {y})\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:249
msgid ""
"The first arm will match any point that lies on the `x` axis by specifying "
"that the `y` field matches if its value matches the literal `0`. The pattern "
"still creates an `x` variable that we can use in the code for this arm."
msgstr ""

#: src/ch19-03-pattern-syntax.md:253
msgid ""
"Similarly, the second arm matches any point on the `y` axis by specifying "
"that the `x` field matches if its value is `0` and creates a variable `y` "
"for the value of the `y` field. The third arm doesn’t specify any literals, "
"so it matches any other `Point` and creates variables for both the `x` and "
"`y` fields."
msgstr ""

#: src/ch19-03-pattern-syntax.md:258
msgid ""
"In this example, the value `p` matches the second arm by virtue of `x` "
"containing a 0, so this code will print `On the y axis at 7`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:261
msgid ""
"Remember that a `match` expression stops checking arms once it has found the "
"first matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` "
"axis and the `y` axis, this code would only print `On the x axis at 0`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:265
msgid "Destructuring Enums"
msgstr ""

#: src/ch19-03-pattern-syntax.md:267
msgid ""
"We've destructured enums in this book (for example, Listing 6-5 in Chapter "
"6), but haven’t yet explicitly discussed that the pattern to destructure an "
"enum corresponds to the way the data stored within the enum is defined. As "
"an example, in Listing 19-15 we use the `Message` enum from Listing 6-2 and "
"write a `match` with patterns that will destructure each inner value."
msgstr ""

#: src/ch19-03-pattern-syntax.md:288
msgid "\"The Quit variant has no data to destructure.\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:291
msgid "\"Move in the x direction {x} and in the y direction {y}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:294
msgid "\"Text message: {text}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:297
msgid "\"Change the color to red {r}, green {g}, and blue {b}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:305
msgid ""
"This code will print `Change the color to red 0, green 160, and blue 255`. "
"Try changing the value of `msg` to see the code from the other arms run."
msgstr ""

#: src/ch19-03-pattern-syntax.md:308
msgid ""
"For enum variants without any data, like `Message::Quit`, we can’t "
"destructure the value any further. We can only match on the literal "
"`Message::Quit` value, and no variables are in that pattern."
msgstr ""

#: src/ch19-03-pattern-syntax.md:312
msgid ""
"For struct-like enum variants, such as `Message::Move`, we can use a pattern "
"similar to the pattern we specify to match structs. After the variant name, "
"we place curly brackets and then list the fields with variables so we break "
"apart the pieces to use in the code for this arm. Here we use the shorthand "
"form as we did in Listing 19-13."
msgstr ""

#: src/ch19-03-pattern-syntax.md:318
msgid ""
"For tuple-like enum variants, like `Message::Write` that holds a tuple with "
"one element and `Message::ChangeColor` that holds a tuple with three "
"elements, the pattern is similar to the pattern we specify to match tuples. "
"The number of variables in the pattern must match the number of elements in "
"the variant we’re matching."
msgstr ""

#: src/ch19-03-pattern-syntax.md:324
msgid "Destructuring Nested Structs and Enums"
msgstr ""

#: src/ch19-03-pattern-syntax.md:326
msgid ""
"So far, our examples have all been matching structs or enums one level deep, "
"but matching can work on nested items too! For example, we can refactor the "
"code in Listing 19-15 to support RGB and HSV colors in the `ChangeColor` "
"message, as shown in Listing 19-16."
msgstr ""

#: src/ch19-03-pattern-syntax.md:351
msgid "\"Change color to red {r}, green {g}, and blue {b}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:354
msgid "\"Change color to hue {h}, saturation {s}, value {v}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:363
msgid ""
"The pattern of the first arm in the `match` expression matches a "
"`Message::ChangeColor` enum variant that contains a `Color::Rgb` variant; "
"then the pattern binds to the three inner `i32` values. The pattern of the "
"second arm also matches a `Message::ChangeColor` enum variant, but the inner "
"enum matches `Color::Hsv` instead. We can specify these complex conditions "
"in one `match` expression, even though two enums are involved."
msgstr ""

#: src/ch19-03-pattern-syntax.md:370
msgid "Destructuring Structs and Tuples"
msgstr ""

#: src/ch19-03-pattern-syntax.md:372
msgid ""
"We can mix, match, and nest destructuring patterns in even more complex "
"ways. The following example shows a complicated destructure where we nest "
"structs and tuples inside a tuple and destructure all the primitive values "
"out:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:387
msgid ""
"This code lets us break complex types into their component parts so we can "
"use the values we’re interested in separately."
msgstr ""

#: src/ch19-03-pattern-syntax.md:390
msgid ""
"Destructuring with patterns is a convenient way to use pieces of values, "
"such as the value from each field in a struct, separately from each other."
msgstr ""

#: src/ch19-03-pattern-syntax.md:393
msgid "Ignoring Values in a Pattern"
msgstr ""

#: src/ch19-03-pattern-syntax.md:395
msgid ""
"You’ve seen that it’s sometimes useful to ignore values in a pattern, such "
"as in the last arm of a `match`, to get a catch-all that doesn’t actually do "
"anything but does account for all remaining possible values. There are a few "
"ways to ignore entire values or parts of values in a pattern: using the `_` "
"pattern (which you’ve seen), using the `_` pattern within another pattern, "
"using a name that starts with an underscore, or using `..` to ignore "
"remaining parts of a value. Let’s explore how and why to use each of these "
"patterns."
msgstr ""

#: src/ch19-03-pattern-syntax.md:403
msgid "Ignoring an Entire Value with `_`"
msgstr ""

#: src/ch19-03-pattern-syntax.md:405
msgid ""
"We’ve used the underscore as a wildcard pattern that will match any value "
"but not bind to the value. This is especially useful as the last arm in a "
"`match` expression, but we can also use it in any pattern, including "
"function parameters, as shown in Listing 19-17."
msgstr ""

#: src/ch19-03-pattern-syntax.md:414
msgid "\"This code only uses the y parameter: {y}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:424
msgid ""
"This code will completely ignore the value `3` passed as the first argument, "
"and will print `This code only uses the y parameter: 4`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:427
msgid ""
"In most cases when you no longer need a particular function parameter, you "
"would change the signature so it doesn’t include the unused parameter. "
"Ignoring a function parameter can be especially useful in cases when, for "
"example, you're implementing a trait when you need a certain type signature "
"but the function body in your implementation doesn’t need one of the "
"parameters. You then avoid getting a compiler warning about unused function "
"parameters, as you would if you used a name instead."
msgstr ""

#: src/ch19-03-pattern-syntax.md:435
msgid "Ignoring Parts of a Value with a Nested `_`"
msgstr ""

#: src/ch19-03-pattern-syntax.md:437
msgid ""
"We can also use `_` inside another pattern to ignore just part of a value, "
"for example, when we want to test for only part of a value but have no use "
"for the other parts in the corresponding code we want to run. Listing 19-18 "
"shows code responsible for managing a setting’s value. The business "
"requirements are that the user should not be allowed to overwrite an "
"existing customization of a setting but can unset the setting and give it a "
"value if it is currently unset."
msgstr ""

#: src/ch19-03-pattern-syntax.md:453
msgid "\"Can't overwrite an existing customized value\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:460
msgid "\"setting is {setting_value:?}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:466
msgid ""
"This code will print `Can't overwrite an existing customized value` and then "
"`setting is Some(5)`. In the first match arm, we don’t need to match on or "
"use the values inside either `Some` variant, but we do need to test for the "
"case when `setting_value` and `new_setting_value` are the `Some` variant. In "
"that case, we print the reason for not changing `setting_value`, and it "
"doesn’t get changed."
msgstr ""

#: src/ch19-03-pattern-syntax.md:473
msgid ""
"In all other cases (if either `setting_value` or `new_setting_value` are "
"`None`) expressed by the `_` pattern in the second arm, we want to allow "
"`new_setting_value` to become `setting_value`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:477
msgid ""
"We can also use underscores in multiple places within one pattern to ignore "
"particular values. Listing 19-19 shows an example of ignoring the second and "
"fourth values in a tuple of five items."
msgstr ""

#: src/ch19-03-pattern-syntax.md:489
msgid "\"Some numbers: {first}, {third}, {fifth}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:497
msgid ""
"This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will "
"be ignored."
msgstr ""

#: src/ch19-03-pattern-syntax.md:500
msgid "Ignoring an Unused Variable by Starting Its Name with `_`"
msgstr ""

#: src/ch19-03-pattern-syntax.md:502
msgid ""
"If you create a variable but don’t use it anywhere, Rust will usually issue "
"a warning because an unused variable could be a bug. However, sometimes it’s "
"useful to be able to create a variable you won’t use yet, such as when "
"you’re prototyping or just starting a project. In this situation, you can "
"tell Rust not to warn you about the unused variable by starting the name of "
"the variable with an underscore. In Listing 19-20, we create two unused "
"variables, but when we compile this code, we should only get a warning about "
"one of them."
msgstr ""

#: src/ch19-03-pattern-syntax.md:521
msgid ""
"Here we get a warning about not using the variable `y`, but we don’t get a "
"warning about not using `_x`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:524
msgid ""
"Note that there is a subtle difference between using only `_` and using a "
"name that starts with an underscore. The syntax `_x` still binds the value "
"to the variable, whereas `_` doesn’t bind at all. To show a case where this "
"distinction matters, Listing 19-21 will provide us with an error."
msgstr ""

#: src/ch19-03-pattern-syntax.md:536 src/ch19-03-pattern-syntax.md:557
msgid "\"found a string\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:539 src/ch19-03-pattern-syntax.md:560
msgid "\"{s:?}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:545
msgid ""
"We’ll receive an error because the `s` value will still be moved into `_s`, "
"which prevents us from using `s` again. However, using the underscore by "
"itself doesn’t ever bind to the value. Listing 19-22 will compile without "
"any errors because `s` doesn’t get moved into `_`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:566
msgid ""
"This code works just fine because we never bind `s` to anything; it isn’t "
"moved."
msgstr ""

#: src/ch19-03-pattern-syntax.md:568
msgid "Ignoring Remaining Parts of a Value with `..`"
msgstr ""

#: src/ch19-03-pattern-syntax.md:570
msgid ""
"With values that have many parts, we can use the `..` syntax to use specific "
"parts and ignore the rest, avoiding the need to list underscores for each "
"ignored value. The `..` pattern ignores any parts of a value that we haven’t "
"explicitly matched in the rest of the pattern. In Listing 19-23, we have a "
"`Point` struct that holds a coordinate in three-dimensional space. In the "
"`match` expression, we want to operate only on the `x` coordinate and ignore "
"the values in the `y` and `z` fields."
msgstr ""

#: src/ch19-03-pattern-syntax.md:591
msgid "\"x is {x}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:598
msgid ""
"We list the `x` value and then just include the `..` pattern. This is "
"quicker than having to list `y: _` and `z: _`, particularly when we’re "
"working with structs that have lots of fields in situations where only one "
"or two fields are relevant."
msgstr ""

#: src/ch19-03-pattern-syntax.md:603
msgid ""
"The syntax `..` will expand to as many values as it needs to be. Listing "
"19-24 shows how to use `..` with a tuple."
msgstr ""

#: src/ch19-03-pattern-syntax.md:614
msgid "\"Some numbers: {first}, {last}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:622
msgid ""
"In this code, the first and last value are matched with `first` and `last`. "
"The `..` will match and ignore everything in the middle."
msgstr ""

#: src/ch19-03-pattern-syntax.md:625
msgid ""
"However, using `..` must be unambiguous. If it is unclear which values are "
"intended for matching and which should be ignored, Rust will give us an "
"error. Listing 19-25 shows an example of using `..` ambiguously, so it will "
"not compile."
msgstr ""

#: src/ch19-03-pattern-syntax.md:638
msgid "\"Some numbers: {second}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:646
msgid "When we compile this example, we get this error:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:648
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling patterns v0.1.0 (file:///projects/patterns)\n"
"error: `..` can only be used once per tuple pattern\n"
" --> src/main.rs:5:22\n"
"  |\n"
"5 |         (.., second, ..) => {\n"
"  |          --          ^^ can only be used once per tuple pattern\n"
"  |          |\n"
"  |          previously used here\n"
"\n"
"error: could not compile `patterns` (bin \"patterns\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch19-03-pattern-syntax.md:662
msgid ""
"It’s impossible for Rust to determine how many values in the tuple to ignore "
"before matching a value with `second` and then how many further values to "
"ignore thereafter. This code could mean that we want to ignore `2`, bind "
"`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to "
"ignore `2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and "
"so forth. The variable name `second` doesn’t mean anything special to Rust, "
"so we get a compiler error because using `..` in two places like this is "
"ambiguous."
msgstr ""

#: src/ch19-03-pattern-syntax.md:670
msgid "Extra Conditionals with Match Guards"
msgstr ""

#: src/ch19-03-pattern-syntax.md:672
msgid ""
"A _match guard_ is an additional `if` condition, specified after the pattern "
"in a `match` arm, that must also match for that arm to be chosen. Match "
"guards are useful for expressing more complex ideas than a pattern alone "
"allows. They are only available in `match` expressions, not in `if let` or "
"`while let` expressions."
msgstr ""

#: src/ch19-03-pattern-syntax.md:678
msgid ""
"The condition can use variables created in the pattern. Listing 19-26 shows "
"a `match` where the first arm has the pattern `Some(x)` and also has a match "
"guard of `if x % 2 == 0` (which will be true if the number is even)."
msgstr ""

#: src/ch19-03-pattern-syntax.md:689
msgid "\"The number {x} is even\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:690
msgid "\"The number {x} is odd\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:698
msgid ""
"This example will print `The number 4 is even`. When `num` is compared to "
"the pattern in the first arm, it matches, because `Some(4)` matches "
"`Some(x)`. Then the match guard checks whether the remainder of dividing `x` "
"by 2 is equal to 0, and because it is, the first arm is selected."
msgstr ""

#: src/ch19-03-pattern-syntax.md:703
msgid ""
"If `num` had been `Some(5)` instead, the match guard in the first arm would "
"have been false because the remainder of 5 divided by 2 is 1, which is not "
"equal to 0. Rust would then go to the second arm, which would match because "
"the second arm doesn’t have a match guard and therefore matches any `Some` "
"variant."
msgstr ""

#: src/ch19-03-pattern-syntax.md:708
msgid ""
"There is no way to express the `if x % 2 == 0` condition within a pattern, "
"so the match guard gives us the ability to express this logic. The downside "
"of this additional expressiveness is that the compiler doesn't try to check "
"for exhaustiveness when match guard expressions are involved."
msgstr ""

#: src/ch19-03-pattern-syntax.md:713
msgid ""
"In Listing 19-11, we mentioned that we could use match guards to solve our "
"pattern-shadowing problem. Recall that we created a new variable inside the "
"pattern in the `match` expression instead of using the variable outside the "
"`match`. That new variable meant we couldn’t test against the value of the "
"outer variable. Listing 19-27 shows how we can use a match guard to fix this "
"problem."
msgstr ""

#: src/ch19-03-pattern-syntax.md:729
msgid "\"Matched, n = {n}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:739
msgid ""
"This code will now print `Default case, x = Some(5)`. The pattern in the "
"second match arm doesn’t introduce a new variable `y` that would shadow the "
"outer `y`, meaning we can use the outer `y` in the match guard. Instead of "
"specifying the pattern as `Some(y)`, which would have shadowed the outer "
"`y`, we specify `Some(n)`. This creates a new variable `n` that doesn’t "
"shadow anything because there is no `n` variable outside the `match`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:746
msgid ""
"The match guard `if n == y` is not a pattern and therefore doesn’t introduce "
"new variables. This `y` _is_ the outer `y` rather than a new `y` shadowing "
"it, and we can look for a value that has the same value as the outer `y` by "
"comparing `n` to `y`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:751
msgid ""
"You can also use the _or_ operator `|` in a match guard to specify multiple "
"patterns; the match guard condition will apply to all the patterns. Listing "
"19-28 shows the precedence when combining a pattern that uses `|` with a "
"match guard. The important part of this example is that the `if y` match "
"guard applies to `4`, `5`, _and_ `6`, even though it might look like `if y` "
"only applies to `6`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:766
msgid "\"yes\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:767
msgid "\"no\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:774
msgid ""
"The match condition states that the arm only matches if the value of `x` is "
"equal to `4`, `5`, or `6` _and_ if `y` is `true`. When this code runs, the "
"pattern of the first arm matches because `x` is `4`, but the match guard `if "
"y` is false, so the first arm is not chosen. The code moves on to the second "
"arm, which does match, and this program prints `no`. The reason is that the "
"`if` condition applies to the whole pattern `4 | 5 | 6`, not only to the "
"last value `6`. In other words, the precedence of a match guard in relation "
"to a pattern behaves like this:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:787
msgid "rather than this:"
msgstr ""

#: src/ch19-03-pattern-syntax.md:793
msgid ""
"After running the code, the precedence behavior is evident: if the match "
"guard were applied only to the final value in the list of values specified "
"using the `|` operator, the arm would have matched and the program would "
"have printed `yes`."
msgstr ""

#: src/ch19-03-pattern-syntax.md:798
msgid "`@` Bindings"
msgstr ""

#: src/ch19-03-pattern-syntax.md:800
msgid ""
"The _at_ operator `@` lets us create a variable that holds a value at the "
"same time as we’re testing that value for a pattern match. In Listing 19-29, "
"we want to test that a `Message::Hello` `id` field is within the range "
"`3..=7`. We also want to bind the value to the variable `id_variable` so we "
"can use it in the code associated with the arm. We could name this variable "
"`id`, the same as the field, but for this example we’ll use a different name."
msgstr ""

#: src/ch19-03-pattern-syntax.md:820
msgid "\"Found an id in range: {id_variable}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:822
msgid "\"Found an id in another range\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:824
msgid "\"Found some other id: {id}\""
msgstr ""

#: src/ch19-03-pattern-syntax.md:831
msgid ""
"This example will print `Found an id in range: 5`. By specifying "
"`id_variable @` before the range `3..=7`, we’re capturing whatever value "
"matched the range while also testing that the value matched the range "
"pattern."
msgstr ""

#: src/ch19-03-pattern-syntax.md:835
msgid ""
"In the second arm, where we only have a range specified in the pattern, the "
"code associated with the arm doesn’t have a variable that contains the "
"actual value of the `id` field. The `id` field’s value could have been 10, "
"11, or 12, but the code that goes with that pattern doesn’t know which it "
"is. The pattern code isn’t able to use the value from the `id` field, "
"because we haven’t saved the `id` value in a variable."
msgstr ""

#: src/ch19-03-pattern-syntax.md:842
msgid ""
"In the last arm, where we’ve specified a variable without a range, we do "
"have the value available to use in the arm’s code in a variable named `id`. "
"The reason is that we’ve used the struct field shorthand syntax. But we "
"haven’t applied any test to the value in the `id` field in this arm, as we "
"did with the first two arms: any value would match this pattern."
msgstr ""

#: src/ch19-03-pattern-syntax.md:848
msgid ""
"Using `@` lets us test a value and save it in a variable within one pattern."
msgstr ""

#: src/ch19-03-pattern-syntax.md:852
msgid ""
"Rust’s patterns are very useful in distinguishing between different kinds of "
"data. When used in `match` expressions, Rust ensures your patterns cover "
"every possible value, or your program won’t compile. Patterns in `let` "
"statements and function parameters make those constructs more useful, "
"enabling the destructuring of values into smaller parts and assigning those "
"parts to variables. We can create simple or complex patterns to suit our "
"needs."
msgstr ""

#: src/ch19-03-pattern-syntax.md:859
msgid ""
"Next, for the penultimate chapter of the book, we’ll look at some advanced "
"aspects of a variety of Rust’s features."
msgstr ""

#: src/ch20-00-advanced-features.md:3
msgid ""
"By now, you’ve learned the most commonly used parts of the Rust programming "
"language. Before we do one more project in Chapter 21, we’ll look at a few "
"aspects of the language you might run into every once in a while, but may "
"not use every day. You can use this chapter as a reference for when you "
"encounter any unknowns. The features covered here are useful in very "
"specific situations. Although you might not reach for them often, we want to "
"make sure you have a grasp of all the features Rust has to offer."
msgstr ""

#: src/ch20-00-advanced-features.md:11
msgid "In this chapter, we’ll cover:"
msgstr ""

#: src/ch20-00-advanced-features.md:13
msgid ""
"Unsafe Rust: how to opt out of some of Rust’s guarantees and take "
"responsibility for manually upholding those guarantees"
msgstr ""

#: src/ch20-00-advanced-features.md:15
msgid ""
"Advanced traits: associated types, default type parameters, fully qualified "
"syntax, supertraits, and the newtype pattern in relation to traits"
msgstr ""

#: src/ch20-00-advanced-features.md:17
msgid ""
"Advanced types: more about the newtype pattern, type aliases, the never "
"type, and dynamically sized types"
msgstr ""

#: src/ch20-00-advanced-features.md:19
msgid ""
"Advanced functions and closures: function pointers and returning closures"
msgstr ""

#: src/ch20-00-advanced-features.md:20
msgid "Macros: ways to define code that defines more code at compile time"
msgstr ""

#: src/ch20-00-advanced-features.md:22
msgid ""
"It’s a panoply of Rust features with something for everyone! Let’s dive in!"
msgstr ""

#: src/ch20-01-unsafe-rust.md:3
msgid ""
"All the code we’ve discussed so far has had Rust’s memory safety guarantees "
"enforced at compile time. However, Rust has a second language hidden inside "
"it that doesn’t enforce these memory safety guarantees: it’s called _unsafe "
"Rust_ and works just like regular Rust, but gives us extra superpowers."
msgstr ""

#: src/ch20-01-unsafe-rust.md:8
msgid ""
"Unsafe Rust exists because, by nature, static analysis is conservative. When "
"the compiler tries to determine whether or not code upholds the guarantees, "
"it’s better for it to reject some valid programs than to accept some invalid "
"programs. Although the code _might_ be okay, if the Rust compiler doesn’t "
"have enough information to be confident, it will reject the code. In these "
"cases, you can use unsafe code to tell the compiler, “Trust me, I know what "
"I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: "
"if you use unsafe code incorrectly, problems can occur due to memory "
"unsafety, such as null pointer dereferencing."
msgstr ""

#: src/ch20-01-unsafe-rust.md:18
msgid ""
"Another reason Rust has an unsafe alter ego is that the underlying computer "
"hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, "
"you couldn’t do certain tasks. Rust needs to allow you to do low-level "
"systems programming, such as directly interacting with the operating system "
"or even writing your own operating system. Working with low-level systems "
"programming is one of the goals of the language. Let’s explore what we can "
"do with unsafe Rust and how to do it."
msgstr ""

#: src/ch20-01-unsafe-rust.md:26
msgid "Unsafe Superpowers"
msgstr ""

#: src/ch20-01-unsafe-rust.md:28
msgid ""
"To switch to unsafe Rust, use the `unsafe` keyword and then start a new "
"block that holds the unsafe code. You can take five actions in unsafe Rust "
"that you can’t in safe Rust, which we call _unsafe superpowers_. Those "
"superpowers include the ability to:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:33
msgid "Dereference a raw pointer"
msgstr ""

#: src/ch20-01-unsafe-rust.md:34
msgid "Call an unsafe function or method"
msgstr ""

#: src/ch20-01-unsafe-rust.md:35
msgid "Access or modify a mutable static variable"
msgstr ""

#: src/ch20-01-unsafe-rust.md:36
msgid "Implement an unsafe trait"
msgstr ""

#: src/ch20-01-unsafe-rust.md:37
msgid "Access fields of a `union`"
msgstr ""

#: src/ch20-01-unsafe-rust.md:39
msgid ""
"It’s important to understand that `unsafe` doesn’t turn off the borrow "
"checker or disable any other of Rust’s safety checks: if you use a reference "
"in unsafe code, it will still be checked. The `unsafe` keyword only gives "
"you access to these five features that are then not checked by the compiler "
"for memory safety. You’ll still get some degree of safety inside of an "
"unsafe block."
msgstr ""

#: src/ch20-01-unsafe-rust.md:45
msgid ""
"In addition, `unsafe` does not mean the code inside the block is necessarily "
"dangerous or that it will definitely have memory safety problems: the intent "
"is that as the programmer, you’ll ensure the code inside an `unsafe` block "
"will access memory in a valid way."
msgstr ""

#: src/ch20-01-unsafe-rust.md:50
msgid ""
"People are fallible, and mistakes will happen, but by requiring these five "
"unsafe operations to be inside blocks annotated with `unsafe` you’ll know "
"that any errors related to memory safety must be within an `unsafe` block. "
"Keep `unsafe` blocks small; you’ll be thankful later when you investigate "
"memory bugs."
msgstr ""

#: src/ch20-01-unsafe-rust.md:56
msgid ""
"To isolate unsafe code as much as possible, it’s best to enclose unsafe code "
"within a safe abstraction and provide a safe API, which we’ll discuss later "
"in the chapter when we examine unsafe functions and methods. Parts of the "
"standard library are implemented as safe abstractions over unsafe code that "
"has been audited. Wrapping unsafe code in a safe abstraction prevents uses "
"of `unsafe` from leaking out into all the places that you or your users "
"might want to use the functionality implemented with `unsafe` code, because "
"using a safe abstraction is safe."
msgstr ""

#: src/ch20-01-unsafe-rust.md:65
msgid ""
"Let’s look at each of the five unsafe superpowers in turn. We’ll also look "
"at some abstractions that provide a safe interface to unsafe code."
msgstr ""

#: src/ch20-01-unsafe-rust.md:68
msgid "Dereferencing a Raw Pointer"
msgstr ""

#: src/ch20-01-unsafe-rust.md:70
msgid ""
"In Chapter 4, in [“Dangling References”](ch04-02-references-and-"
"borrowing.html#dangling-references)<!-- ignore -->, we mentioned that the "
"compiler ensures references are always valid. Unsafe Rust has two new types "
"called _raw pointers_ that are similar to references. As with references, "
"raw pointers can be immutable or mutable and are written as `*const T` and "
"`*mut T`, respectively. The asterisk isn’t the dereference operator; it’s "
"part of the type name. In the context of raw pointers, _immutable_ means "
"that the pointer can’t be directly assigned to after being dereferenced."
msgstr ""

#: src/ch20-01-unsafe-rust.md:78
msgid "Different from references and smart pointers, raw pointers:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:80
msgid ""
"Are allowed to ignore the borrowing rules by having both immutable and "
"mutable pointers or multiple mutable pointers to the same location"
msgstr ""

#: src/ch20-01-unsafe-rust.md:82
msgid "Aren’t guaranteed to point to valid memory"
msgstr ""

#: src/ch20-01-unsafe-rust.md:83
msgid "Are allowed to be null"
msgstr ""

#: src/ch20-01-unsafe-rust.md:84
msgid "Don’t implement any automatic cleanup"
msgstr ""

#: src/ch20-01-unsafe-rust.md:86
msgid ""
"By opting out of having Rust enforce these guarantees, you can give up "
"guaranteed safety in exchange for greater performance or the ability to "
"interface with another language or hardware where Rust’s guarantees don’t "
"apply."
msgstr ""

#: src/ch20-01-unsafe-rust.md:90
msgid ""
"Listing 20-1 shows how to create an immutable and a mutable raw pointer."
msgstr ""

#: src/ch20-01-unsafe-rust.md:105
msgid ""
"Notice that we don’t include the `unsafe` keyword in this code. We can "
"create raw pointers in safe code; we just can’t dereference raw pointers "
"outside an unsafe block, as you’ll see in a bit."
msgstr ""

#: src/ch20-01-unsafe-rust.md:109
msgid ""
"We’ve created raw pointers by using the raw borrow operators: `&raw const "
"num` creates a `*const i32` immutable raw pointer, and `&raw mut num` "
"creates a `*mut i32` mutable raw pointer. Because we created them directly "
"from a local variable, we know these particular raw pointers are valid, but "
"we can’t make that assumption about just any raw pointer."
msgstr ""

#: src/ch20-01-unsafe-rust.md:115
msgid ""
"To demonstrate this, next we’ll create a raw pointer whose validity we can’t "
"be so certain of, using `as` to cast a value instead of using the raw "
"reference operators. Listing 20-2 shows how to create a raw pointer to an "
"arbitrary location in memory. Trying to use arbitrary memory is undefined: "
"there might be data at that address or there might not, the compiler might "
"optimize the code so there is no memory access, or the program might error "
"with a segmentation fault. Usually, there is no good reason to write code "
"like this, especially in cases where you can use a raw borrow operator "
"instead, but it is possible."
msgstr ""

#: src/ch20-01-unsafe-rust.md:135
msgid ""
"Recall that we can create raw pointers in safe code, but we can’t "
"_dereference_ raw pointers and read the data being pointed to. In Listing "
"20-3, we use the dereference operator `*` on a raw pointer that requires an "
"`unsafe` block."
msgstr ""

#: src/ch20-01-unsafe-rust.md:149
msgid "\"r1 is: {}\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:150
msgid "\"r2 is: {}\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:157
msgid ""
"Creating a pointer does no harm; it’s only when we try to access the value "
"that it points at that we might end up dealing with an invalid value."
msgstr ""

#: src/ch20-01-unsafe-rust.md:160
msgid ""
"Note also that in Listing 20-1 and 20-3, we created `*const i32` and `*mut "
"i32` raw pointers that both pointed to the same memory location, where `num` "
"is stored. If we instead tried to create an immutable and a mutable "
"reference to `num`, the code would not have compiled because Rust’s "
"ownership rules don’t allow a mutable reference at the same time as any "
"immutable references. With raw pointers, we can create a mutable pointer and "
"an immutable pointer to the same location and change data through the "
"mutable pointer, potentially creating a data race. Be careful!"
msgstr ""

#: src/ch20-01-unsafe-rust.md:169
msgid ""
"With all of these dangers, why would you ever use raw pointers? One major "
"use case is when interfacing with C code, as you’ll see in the next section, "
"[“Calling an Unsafe Function or Method.”](#calling-an-unsafe-function-or-"
"method)<!-- ignore --> Another case is when building up safe abstractions "
"that the borrow checker doesn’t understand. We’ll introduce unsafe functions "
"and then look at an example of a safe abstraction that uses unsafe code."
msgstr ""

#: src/ch20-01-unsafe-rust.md:177
msgid "Calling an Unsafe Function or Method"
msgstr ""

#: src/ch20-01-unsafe-rust.md:179
msgid ""
"The second type of operation you can perform in an unsafe block is calling "
"unsafe functions. Unsafe functions and methods look exactly like regular "
"functions and methods, but they have an extra `unsafe` before the rest of "
"the definition. The `unsafe` keyword in this context indicates the function "
"has requirements we need to uphold when we call this function, because Rust "
"can’t guarantee we’ve met these requirements. By calling an unsafe function "
"within an `unsafe` block, we’re saying that we’ve read this function’s "
"documentation and take responsibility for upholding the function’s contracts."
msgstr ""

#: src/ch20-01-unsafe-rust.md:188
msgid ""
"Here is an unsafe function named `dangerous` that doesn’t do anything in its "
"body:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:201
msgid ""
"We must call the `dangerous` function within a separate `unsafe` block. If "
"we try to call `dangerous` without the `unsafe` block, we’ll get an error:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:204
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n"
"error[E0133]: call to unsafe function `dangerous` is unsafe and requires "
"unsafe function or block\n"
" --> src/main.rs:4:5\n"
"  |\n"
"4 |     dangerous();\n"
"  |     ^^^^^^^^^^^ call to unsafe function\n"
"  |\n"
"  = note: consult the function's documentation for information on how to "
"avoid undefined behavior\n"
"\n"
"For more information about this error, try `rustc --explain E0133`.\n"
"error: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch20-01-unsafe-rust.md:219
msgid ""
"With the `unsafe` block, we’re asserting to Rust that we’ve read the "
"function’s documentation, we understand how to use it properly, and we’ve "
"verified that we’re fulfilling the contract of the function."
msgstr ""

#: src/ch20-01-unsafe-rust.md:223
msgid ""
"To perform unsafe operations in the body of an unsafe function, you still "
"need to use an `unsafe` block just as within a regular function, and the "
"compiler will warn you if you forget. This helps to keep `unsafe` blocks as "
"small as possible, as unsafe operations may not be needed across the whole "
"function body."
msgstr ""

#: src/ch20-01-unsafe-rust.md:229
msgid "Creating a Safe Abstraction over Unsafe Code"
msgstr ""

#: src/ch20-01-unsafe-rust.md:231
msgid ""
"Just because a function contains unsafe code doesn’t mean we need to mark "
"the entire function as unsafe. In fact, wrapping unsafe code in a safe "
"function is a common abstraction. As an example, let’s study the "
"`split_at_mut` function from the standard library, which requires some "
"unsafe code. We’ll explore how we might implement it. This safe method is "
"defined on mutable slices: it takes one slice and makes it two by splitting "
"the slice at the index given as an argument. Listing 20-4 shows how to use "
"`split_at_mut`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:256
msgid ""
"We can’t implement this function using only safe Rust. An attempt might look "
"something like Listing 20-5, which won’t compile. For simplicity, we’ll "
"implement `split_at_mut` as a function rather than a method and only for "
"slices of `i32` values rather than for a generic type `T`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:280
msgid ""
"This function first gets the total length of the slice. Then it asserts that "
"the index given as a parameter is within the slice by checking whether it’s "
"less than or equal to the length. The assertion means that if we pass an "
"index that is greater than the length to split the slice at, the function "
"will panic before it attempts to use that index."
msgstr ""

#: src/ch20-01-unsafe-rust.md:286
msgid ""
"Then we return two mutable slices in a tuple: one from the start of the "
"original slice to the `mid` index and another from `mid` to the end of the "
"slice."
msgstr ""

#: src/ch20-01-unsafe-rust.md:290
msgid "When we try to compile the code in Listing 20-5, we’ll get an error."
msgstr ""

#: src/ch20-01-unsafe-rust.md:292
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n"
"error[E0499]: cannot borrow `*values` as mutable more than once at a time\n"
" --> src/main.rs:6:31\n"
"  |\n"
"1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut "
"[i32]) {\n"
"  |                         - let's call the lifetime of this reference "
"`'1`\n"
"...\n"
"6 |     (&mut values[..mid], &mut values[mid..])\n"
"  |     --------------------------^^^^^^--------\n"
"  |     |     |                   |\n"
"  |     |     |                   second mutable borrow occurs here\n"
"  |     |     first mutable borrow occurs here\n"
"  |     returning this value requires that `*values` is borrowed for `'1`\n"
"  |\n"
"  = help: use `.split_at_mut(position)` to obtain two mutable non-"
"overlapping sub-slices\n"
"\n"
"For more information about this error, try `rustc --explain E0499`.\n"
"error: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch20-01-unsafe-rust.md:314
msgid ""
"Rust’s borrow checker can’t understand that we’re borrowing different parts "
"of the slice; it only knows that we’re borrowing from the same slice twice. "
"Borrowing different parts of a slice is fundamentally okay because the two "
"slices aren’t overlapping, but Rust isn’t smart enough to know this. When we "
"know code is okay, but Rust doesn’t, it’s time to reach for unsafe code."
msgstr ""

#: src/ch20-01-unsafe-rust.md:320
msgid ""
"Listing 20-6 shows how to use an `unsafe` block, a raw pointer, and some "
"calls to unsafe functions to make the implementation of `split_at_mut` work."
msgstr ""

#: src/ch20-01-unsafe-rust.md:350
msgid ""
"Recall from [“The Slice Type”](ch04-03-slices.html#the-slice-type)<!-- "
"ignore --> in Chapter 4 that slices are a pointer to some data and the "
"length of the slice. We use the `len` method to get the length of a slice "
"and the `as_mut_ptr` method to access the raw pointer of a slice. In this "
"case, because we have a mutable slice to `i32` values, `as_mut_ptr` returns "
"a raw pointer with the type `*mut i32`, which we’ve stored in the variable "
"`ptr`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:357
msgid ""
"We keep the assertion that the `mid` index is within the slice. Then we get "
"to the unsafe code: the `slice::from_raw_parts_mut` function takes a raw "
"pointer and a length, and it creates a slice. We use this function to create "
"a slice that starts from `ptr` and is `mid` items long. Then we call the "
"`add` method on `ptr` with `mid` as an argument to get a raw pointer that "
"starts at `mid`, and we create a slice using that pointer and the remaining "
"number of items after `mid` as the length."
msgstr ""

#: src/ch20-01-unsafe-rust.md:365
msgid ""
"The function `slice::from_raw_parts_mut` is unsafe because it takes a raw "
"pointer and must trust that this pointer is valid. The `add` method on raw "
"pointers is also unsafe, because it must trust that the offset location is "
"also a valid pointer. Therefore, we had to put an `unsafe` block around our "
"calls to `slice::from_raw_parts_mut` and `add` so we could call them. By "
"looking at the code and by adding the assertion that `mid` must be less than "
"or equal to `len`, we can tell that all the raw pointers used within the "
"`unsafe` block will be valid pointers to data within the slice. This is an "
"acceptable and appropriate use of `unsafe`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:375
msgid ""
"Note that we don’t need to mark the resulting `split_at_mut` function as "
"`unsafe`, and we can call this function from safe Rust. We’ve created a safe "
"abstraction to the unsafe code with an implementation of the function that "
"uses `unsafe` code in a safe way, because it creates only valid pointers "
"from the data this function has access to."
msgstr ""

#: src/ch20-01-unsafe-rust.md:381
msgid ""
"In contrast, the use of `slice::from_raw_parts_mut` in Listing 20-7 would "
"likely crash when the slice is used. This code takes an arbitrary memory "
"location and creates a slice 10,000 items long."
msgstr ""

#: src/ch20-01-unsafe-rust.md:400
msgid ""
"We don’t own the memory at this arbitrary location, and there is no "
"guarantee that the slice this code creates contains valid `i32` values. "
"Attempting to use `values` as though it’s a valid slice results in undefined "
"behavior."
msgstr ""

#: src/ch20-01-unsafe-rust.md:404
msgid "Using `extern` Functions to Call External Code"
msgstr ""

#: src/ch20-01-unsafe-rust.md:406
msgid ""
"Sometimes, your Rust code might need to interact with code written in "
"another language. For this, Rust has the keyword `extern` that facilitates "
"the creation and use of a _Foreign Function Interface (FFI)_. An FFI is a "
"way for a programming language to define functions and enable a different "
"(foreign) programming language to call those functions."
msgstr ""

#: src/ch20-01-unsafe-rust.md:412
msgid ""
"Listing 20-8 demonstrates how to set up an integration with the `abs` "
"function from the C standard library. Functions declared within `extern` "
"blocks are usually unsafe to call from Rust code, so they must also be "
"marked `unsafe`. The reason is that other languages don’t enforce Rust’s "
"rules and guarantees, and Rust can’t check them, so responsibility falls on "
"the programmer to ensure safety."
msgstr ""

#: src/ch20-01-unsafe-rust.md:422 src/ch20-01-unsafe-rust.md:450
#: src/ch20-01-unsafe-rust.md:486
msgid "\"C\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:428 src/ch20-01-unsafe-rust.md:455
msgid "\"Absolute value of -3 according to C: {}\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:435
msgid ""
"Within the `unsafe extern \"C\"` block, we list the names and signatures of "
"external functions from another language we want to call. The `\"C\"` part "
"defines which _application binary interface (ABI)_ the external function "
"uses: the ABI defines how to call the function at the assembly level. The "
"`\"C\"` ABI is the most common and follows the C programming language’s ABI."
msgstr ""

#: src/ch20-01-unsafe-rust.md:441
msgid ""
"This particular function does not have any memory safety considerations, "
"though. In fact, we know that any call to `abs` will always be safe for any "
"`i32`, so we can use the `safe` keyword to say that this specific function "
"is safe to call even though it is in an `unsafe extern` block. Once we make "
"that change, calling it no longer requires an `unsafe` block, as shown in "
"Listing 20-9."
msgstr ""

#: src/ch20-01-unsafe-rust.md:461
msgid ""
"Marking a function as `safe` does not inherently make it safe! Instead, it "
"is like a promise you are making to Rust that it _is_ safe. It is still your "
"responsibility to make sure that promise is kept!"
msgstr ""

#: src/ch20-01-unsafe-rust.md:465
msgid "Calling Rust Functions from Other Languages"
msgstr ""

#: src/ch20-01-unsafe-rust.md:467
msgid ""
"We can also use `extern` to create an interface that allows other languages "
"to call Rust functions. Instead of creating a whole `extern` block, we add "
"the `extern` keyword and specify the ABI to use just before the `fn` keyword "
"for the relevant function. We also need to add a `#[unsafe(no_mangle)]` "
"annotation to tell the Rust compiler not to mangle the name of this "
"function. _Mangling_ is when a compiler changes the name we’ve given a "
"function to a different name that contains more information for other parts "
"of the compilation process to consume but is less human readable. Every "
"programming language compiler mangles names slightly differently, so for a "
"Rust function to be nameable by other languages, we must disable the Rust "
"compiler’s name mangling. This is unsafe because there might be name "
"collisions across libraries without the built-in mangling, so it is our "
"responsibility to make sure the name we have exported is safe to export "
"without mangling."
msgstr ""

#: src/ch20-01-unsafe-rust.md:481
msgid ""
"In the following example, we make the `call_from_c` function accessible from "
"C code, after it’s compiled to a shared library and linked from C:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:487
msgid "\"Just called a Rust function from C!\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:491
msgid "This usage of `extern` does not require `unsafe`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:493
msgid "Accessing or Modifying a Mutable Static Variable"
msgstr ""

#: src/ch20-01-unsafe-rust.md:495
msgid ""
"In this book, we’ve not yet talked about _global variables_, which Rust does "
"support but can be problematic with Rust’s ownership rules. If two threads "
"are accessing the same mutable global variable, it can cause a data race."
msgstr ""

#: src/ch20-01-unsafe-rust.md:499
msgid ""
"In Rust, global variables are called _static_ variables. Listing 20-10 shows "
"an example declaration and use of a static variable with a string slice as a "
"value."
msgstr ""

#: src/ch20-01-unsafe-rust.md:509
msgid "\"name is: {HELLO_WORLD}\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:515
msgid ""
"Static variables are similar to constants, which we discussed in "
"[“Constants”](ch03-01-variables-and-mutability.html#constants)<!-- ignore --"
"> in Chapter 3. The names of static variables are in `SCREAMING_SNAKE_CASE` "
"by convention. Static variables can only store references with the `'static` "
"lifetime, which means the Rust compiler can figure out the lifetime and we "
"aren’t required to annotate it explicitly. Accessing an immutable static "
"variable is safe."
msgstr ""

#: src/ch20-01-unsafe-rust.md:523
msgid ""
"A subtle difference between constants and immutable static variables is that "
"values in a static variable have a fixed address in memory. Using the value "
"will always access the same data. Constants, on the other hand, are allowed "
"to duplicate their data whenever they’re used. Another difference is that "
"static variables can be mutable. Accessing and modifying mutable static "
"variables is _unsafe_. Listing 20-11 shows how to declare, access, and "
"modify a mutable static variable named `COUNTER`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:535
msgid ""
"/// SAFETY: Calling this from more than a single thread at a time is "
"undefined\n"
"/// behavior, so you *must* guarantee you only call it from a single thread "
"at\n"
"/// a time.\n"
msgstr ""

#: src/ch20-01-unsafe-rust.md:547
msgid "// SAFETY: This is only called from a single thread in `main`.\n"
msgstr ""

#: src/ch20-01-unsafe-rust.md:549
msgid "\"COUNTER: {}\""
msgstr ""

#: src/ch20-01-unsafe-rust.md:556
msgid ""
"As with regular variables, we specify mutability using the `mut` keyword. "
"Any code that reads or writes from `COUNTER` must be within an `unsafe` "
"block. The code in Listing 20-11 compiles and prints `COUNTER: 3` as we "
"would expect because it’s single threaded. Having multiple threads access "
"`COUNTER` would likely result in data races, so it is undefined behavior. "
"Therefore, we need to mark the entire function as `unsafe`, and document the "
"safety limitation, so anyone calling the function knows what they are and "
"are not allowed to do safely."
msgstr ""

#: src/ch20-01-unsafe-rust.md:565
msgid ""
"Whenever we write an unsafe function, it is idiomatic to write a comment "
"starting with `SAFETY` and explaining what the caller needs to do to call "
"the function safely. Likewise, whenever we perform an unsafe operation, it "
"is idiomatic to write a comment starting with `SAFETY` to explain how the "
"safety rules are upheld."
msgstr ""

#: src/ch20-01-unsafe-rust.md:571
msgid ""
"Additionally, the compiler will not allow you to create references to a "
"mutable static variable. You can only access it via a raw pointer, created "
"with one of the raw borrow operators. That includes in cases where the "
"reference is created invisibly, as when it is used in the `println!` in this "
"code listing. The requirement that references to static mutable variables "
"can only be created via raw pointers helps make the safety requirements for "
"using them more obvious."
msgstr ""

#: src/ch20-01-unsafe-rust.md:578
msgid ""
"With mutable data that is globally accessible, it’s difficult to ensure "
"there are no data races, which is why Rust considers mutable static "
"variables to be unsafe. Where possible, it’s preferable to use the "
"concurrency techniques and thread-safe smart pointers we discussed in "
"Chapter 16 so the compiler checks that data accessed from different threads "
"is done safely."
msgstr ""

#: src/ch20-01-unsafe-rust.md:584
msgid "Implementing an Unsafe Trait"
msgstr ""

#: src/ch20-01-unsafe-rust.md:586
msgid ""
"We can use `unsafe` to implement an unsafe trait. A trait is unsafe when at "
"least one of its methods has some invariant that the compiler can’t verify. "
"We declare that a trait is `unsafe` by adding the `unsafe` keyword before "
"`trait` and marking the implementation of the trait as `unsafe` too, as "
"shown in Listing 20-12."
msgstr ""

#: src/ch20-01-unsafe-rust.md:596
msgid "// methods go here\n"
msgstr ""

#: src/ch20-01-unsafe-rust.md:600
msgid "// method implementations go here\n"
msgstr ""

#: src/ch20-01-unsafe-rust.md:608
msgid ""
"By using `unsafe impl`, we’re promising that we’ll uphold the invariants "
"that the compiler can’t verify."
msgstr ""

#: src/ch20-01-unsafe-rust.md:611
msgid ""
"As an example, recall the `Sync` and `Send` marker traits we discussed in "
"[“Extensible Concurrency with the `Sync` and `Send` Traits”](ch16-04-"
"extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-"
"sync-and-send-traits)<!-- ignore --> in Chapter 16: the compiler implements "
"these traits automatically if our types are composed entirely of `Send` and "
"`Sync` types. If we implement a type that contains a type that is not `Send` "
"or `Sync`, such as raw pointers, and we want to mark that type as `Send` or "
"`Sync`, we must use `unsafe`. Rust can’t verify that our type upholds the "
"guarantees that it can be safely sent across threads or accessed from "
"multiple threads; therefore, we need to do those checks manually and "
"indicate as such with `unsafe`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:622
msgid "Accessing Fields of a Union"
msgstr ""

#: src/ch20-01-unsafe-rust.md:624
msgid ""
"The final action that works only with `unsafe` is accessing fields of a "
"_union_. A `union` is similar to a `struct`, but only one declared field is "
"used in a particular instance at one time. Unions are primarily used to "
"interface with unions in C code. Accessing union fields is unsafe because "
"Rust can’t guarantee the type of the data currently being stored in the "
"union instance. You can learn more about unions in [the Rust Reference](../"
"reference/items/unions.html)."
msgstr ""

#: src/ch20-01-unsafe-rust.md:631
msgid "Using Miri to check unsafe code"
msgstr ""

#: src/ch20-01-unsafe-rust.md:633
msgid ""
"When writing unsafe code, you might want to check that what you have written "
"actually is safe and correct. One of the best ways to do that is to use "
"[Miri](https://github.com/rust-lang/miri), an official Rust tool for "
"detecting undefined behavior. Whereas the borrow checker is a _static_ tool "
"which works at compile time, Miri is a _dynamic_ tool which works at "
"runtime. It checks your code by running your program, or its test suite, and "
"detecting when you violate the rules it understands about how Rust should "
"work."
msgstr ""

#: src/ch20-01-unsafe-rust.md:641
msgid ""
"Using Miri requires a nightly build of Rust (which we talk about more in "
"[Appendix G: How Rust is Made and “Nightly Rust”](appendix-07-nightly-"
"rust.html)). You can install both a nightly version of Rust and the Miri "
"tool by typing `rustup +nightly component add miri`. This does not change "
"what version of Rust your project uses; it only adds the tool to your system "
"so you can use it when you want to. You can run Miri on a project by typing "
"`cargo +nightly miri run` or `cargo +nightly miri test`."
msgstr ""

#: src/ch20-01-unsafe-rust.md:649
msgid ""
"For an example of how helpful this can be, consider what happens when we run "
"it against Listing 20-11:"
msgstr ""

#: src/ch20-01-unsafe-rust.md:652
msgid ""
"```console\n"
"$ cargo +nightly miri run\n"
"   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s\n"
"     Running `/Users/chris/.rustup/toolchains/nightly-aarch64-apple-darwin/"
"bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-"
"example`\n"
"warning: creating a shared reference to mutable static is discouraged\n"
"  --> src/main.rs:14:33\n"
"   |\n"
"14 |         println!(\"COUNTER: {}\", COUNTER);\n"
"   |                                 ^^^^^^^ shared reference to mutable "
"static\n"
"   |\n"
"   = note: for more information, see <https://doc.rust-lang.org/nightly/"
"edition-guide/rust-2024/static-mut-references.html>\n"
"   = note: shared references to mutable statics are dangerous; it's "
"undefined behavior if the static is mutated or if a mutable reference is "
"created for it while the shared reference lives\n"
"   = note: `#[warn(static_mut_refs)]` on by default\n"
"\n"
"COUNTER: 3\n"
"```"
msgstr ""

#: src/ch20-01-unsafe-rust.md:670
msgid ""
"It helpfully and correctly notices that we have shared references to mutable "
"data, and warns about it. In this case, it does not tell us how to fix the "
"problem, but it means that we know there is a possible issue and can think "
"about how to make sure it is safe. In other cases, it can actually tell us "
"that some code is _sure_ to be wrong and make recommendations about how to "
"fix it."
msgstr ""

#: src/ch20-01-unsafe-rust.md:676
msgid ""
"Miri doesn’t catch _everything_ you might get wrong when writing unsafe "
"code. For one thing, since it is a dynamic check, it only catches problems "
"with code that actually gets run. That means you will need to use it in "
"conjunction with good testing techniques to increase your confidence about "
"the unsafe code you have written. For another thing, it does not cover every "
"possible way your code can be unsound. If Miri _does_ catch a problem, you "
"know there’s a bug, but just because Miri _doesn’t_ catch a bug doesn’t mean "
"there isn’t a problem. Miri can catch a lot, though. Try running it on the "
"other examples of unsafe code in this chapter and see what it says!"
msgstr ""

#: src/ch20-01-unsafe-rust.md:686
msgid "When to Use Unsafe Code"
msgstr ""

#: src/ch20-01-unsafe-rust.md:688
msgid ""
"Using `unsafe` to take one of the five actions (superpowers) just discussed "
"isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code "
"correct because the compiler can’t help uphold memory safety. When you have "
"a reason to use `unsafe` code, you can do so, and having the explicit "
"`unsafe` annotation makes it easier to track down the source of problems "
"when they occur. Whenever you write unsafe code, you can use Miri to help "
"you be more confident that the code you have written upholds Rust’s rules."
msgstr ""

#: src/ch20-01-unsafe-rust.md:696
msgid ""
"For a much deeper exploration of how to work effectively with unsafe Rust, "
"read Rust’s official guide to the subject, the [Rustonomicon](https://"
"doc.rust-lang.org/nomicon/)."
msgstr ""

#: src/ch20-02-advanced-traits.md:3
msgid ""
"We first covered traits in [“Traits: Defining Shared Behavior”](ch10-02-"
"traits.html#traits-defining-shared-behavior)<!-- ignore --> in Chapter 10, "
"but we didn’t discuss the more advanced details. Now that you know more "
"about Rust, we can get into the nitty-gritty."
msgstr ""

#: src/ch20-02-advanced-traits.md:8
msgid "Specifying Placeholder Types in Trait Definitions with Associated Types"
msgstr ""

#: src/ch20-02-advanced-traits.md:10
msgid ""
"_Associated types_ connect a type placeholder with a trait such that the "
"trait method definitions can use these placeholder types in their "
"signatures. The implementor of a trait will specify the concrete type to be "
"used instead of the placeholder type for the particular implementation. That "
"way, we can define a trait that uses some types without needing to know "
"exactly what those types are until the trait is implemented."
msgstr ""

#: src/ch20-02-advanced-traits.md:17
msgid ""
"We’ve described most of the advanced features in this chapter as being "
"rarely needed. Associated types are somewhere in the middle: they’re used "
"more rarely than features explained in the rest of the book but more "
"commonly than many of the other features discussed in this chapter."
msgstr ""

#: src/ch20-02-advanced-traits.md:22
msgid ""
"One example of a trait with an associated type is the `Iterator` trait that "
"the standard library provides. The associated type is named `Item` and "
"stands in for the type of the values the type implementing the `Iterator` "
"trait is iterating over. The definition of the `Iterator` trait is as shown "
"in Listing 20-13."
msgstr ""

#: src/ch20-02-advanced-traits.md:40
msgid ""
"The type `Item` is a placeholder, and the `next` method’s definition shows "
"that it will return values of type `Option<Self::Item>`. Implementors of the "
"`Iterator` trait will specify the concrete type for `Item`, and the `next` "
"method will return an `Option` containing a value of that concrete type."
msgstr ""

#: src/ch20-02-advanced-traits.md:45
msgid ""
"Associated types might seem like a similar concept to generics, in that the "
"latter allow us to define a function without specifying what types it can "
"handle. To examine the difference between the two concepts, we’ll look at an "
"implementation of the `Iterator` trait on a type named `Counter` that "
"specifies the `Item` type is `u32`:"
msgstr ""

#: src/ch20-02-advanced-traits.md:81
msgid ""
"This syntax seems comparable to that of generics. So why not just define the "
"`Iterator` trait with generics, as shown in Listing 20-14?"
msgstr ""

#: src/ch20-02-advanced-traits.md:94
msgid ""
"The difference is that when using generics, as in Listing 20-14, we must "
"annotate the types in each implementation; because we can also implement "
"`Iterator<String> for Counter` or any other type, we could have multiple "
"implementations of `Iterator` for `Counter`. In other words, when a trait "
"has a generic parameter, it can be implemented for a type multiple times, "
"changing the concrete types of the generic type parameters each time. When "
"we use the `next` method on `Counter`, we would have to provide type "
"annotations to indicate which implementation of `Iterator` we want to use."
msgstr ""

#: src/ch20-02-advanced-traits.md:103
msgid ""
"With associated types, we don’t need to annotate types because we can’t "
"implement a trait on a type multiple times. In Listing 20-13 with the "
"definition that uses associated types, we can only choose what the type of "
"`Item` will be once, because there can only be one `impl Iterator for "
"Counter`. We don’t have to specify that we want an iterator of `u32` values "
"everywhere that we call `next` on `Counter`."
msgstr ""

#: src/ch20-02-advanced-traits.md:110
msgid ""
"Associated types also become part of the trait’s contract: implementors of "
"the trait must provide a type to stand in for the associated type "
"placeholder. Associated types often have a name that describes how the type "
"will be used, and documenting the associated type in the API documentation "
"is good practice."
msgstr ""

#: src/ch20-02-advanced-traits.md:115
msgid "Default Generic Type Parameters and Operator Overloading"
msgstr ""

#: src/ch20-02-advanced-traits.md:117
msgid ""
"When we use generic type parameters, we can specify a default concrete type "
"for the generic type. This eliminates the need for implementors of the trait "
"to specify a concrete type if the default type works. You specify a default "
"type when declaring a generic type with the `<PlaceholderType=ConcreteType>` "
"syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:122
msgid ""
"A great example of a situation where this technique is useful is with "
"_operator overloading_, in which you customize the behavior of an operator "
"(such as `+`) in particular situations."
msgstr ""

#: src/ch20-02-advanced-traits.md:126
msgid ""
"Rust doesn’t allow you to create your own operators or overload arbitrary "
"operators. But you can overload the operations and corresponding traits "
"listed in `std::ops` by implementing the traits associated with the "
"operator. For example, in Listing 20-15 we overload the `+` operator to add "
"two `Point` instances together. We do this by implementing the `Add` trait "
"on a `Point` struct:"
msgstr ""

#: src/ch20-02-advanced-traits.md:165
msgid ""
"The `add` method adds the `x` values of two `Point` instances and the `y` "
"values of two `Point` instances to create a new `Point`. The `Add` trait has "
"an associated type named `Output` that determines the type returned from the "
"`add` method."
msgstr ""

#: src/ch20-02-advanced-traits.md:170
msgid ""
"The default generic type in this code is within the `Add` trait. Here is its "
"definition:"
msgstr ""

#: src/ch20-02-advanced-traits.md:181
msgid ""
"This code should look generally familiar: a trait with one method and an "
"associated type. The new part is `Rhs=Self`: this syntax is called _default "
"type parameters_. The `Rhs` generic type parameter (short for “right hand "
"side”) defines the type of the `rhs` parameter in the `add` method. If we "
"don’t specify a concrete type for `Rhs` when we implement the `Add` trait, "
"the type of `Rhs` will default to `Self`, which will be the type we’re "
"implementing `Add` on."
msgstr ""

#: src/ch20-02-advanced-traits.md:189
msgid ""
"When we implemented `Add` for `Point`, we used the default for `Rhs` because "
"we wanted to add two `Point` instances. Let’s look at an example of "
"implementing the `Add` trait where we want to customize the `Rhs` type "
"rather than using the default."
msgstr ""

#: src/ch20-02-advanced-traits.md:194
msgid ""
"We have two structs, `Millimeters` and `Meters`, holding values in different "
"units. This thin wrapping of an existing type in another struct is known as "
"the _newtype pattern_, which we describe in more detail in the [“Using the "
"Newtype Pattern to Implement External Traits on External Types”](ch20-02-"
"advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-"
"on-external-types)<!-- ignore\n"
"--> section. We want to add values in millimeters to values in meters and "
"have the implementation of `Add` do the conversion correctly. We can "
"implement `Add` for `Millimeters` with `Meters` as the `Rhs`, as shown in "
"Listing 20-16."
msgstr ""

#: src/ch20-02-advanced-traits.md:221
msgid ""
"To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the "
"value of the `Rhs` type parameter instead of using the default of `Self`."
msgstr ""

#: src/ch20-02-advanced-traits.md:224
msgid "You’ll use default type parameters in two main ways:"
msgstr ""

#: src/ch20-02-advanced-traits.md:226
msgid "To extend a type without breaking existing code"
msgstr ""

#: src/ch20-02-advanced-traits.md:227
msgid "To allow customization in specific cases most users won’t need"
msgstr ""

#: src/ch20-02-advanced-traits.md:229
msgid ""
"The standard library’s `Add` trait is an example of the second purpose: "
"usually, you’ll add two like types, but the `Add` trait provides the ability "
"to customize beyond that. Using a default type parameter in the `Add` trait "
"definition means you don’t have to specify the extra parameter most of the "
"time. In other words, a bit of implementation boilerplate isn’t needed, "
"making it easier to use the trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:236
msgid ""
"The first purpose is similar to the second but in reverse: if you want to "
"add a type parameter to an existing trait, you can give it a default to "
"allow extension of the functionality of the trait without breaking the "
"existing implementation code."
msgstr ""

#: src/ch20-02-advanced-traits.md:241
msgid ""
"Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name"
msgstr ""

#: src/ch20-02-advanced-traits.md:243
msgid ""
"Nothing in Rust prevents a trait from having a method with the same name as "
"another trait’s method, nor does Rust prevent you from implementing both "
"traits on one type. It’s also possible to implement a method directly on the "
"type with the same name as methods from traits."
msgstr ""

#: src/ch20-02-advanced-traits.md:248
msgid ""
"When calling methods with the same name, you’ll need to tell Rust which one "
"you want to use. Consider the code in Listing 20-17 where we’ve defined two "
"traits, `Pilot` and `Wizard`, that both have a method called `fly`. We then "
"implement both traits on a type `Human` that already has a method named "
"`fly` implemented on it. Each `fly` method does something different."
msgstr ""

#: src/ch20-02-advanced-traits.md:269 src/ch20-02-advanced-traits.md:308
#: src/ch20-02-advanced-traits.md:354
msgid "\"This is your captain speaking.\""
msgstr ""

#: src/ch20-02-advanced-traits.md:275 src/ch20-02-advanced-traits.md:314
#: src/ch20-02-advanced-traits.md:360
msgid "\"Up!\""
msgstr ""

#: src/ch20-02-advanced-traits.md:281 src/ch20-02-advanced-traits.md:320
#: src/ch20-02-advanced-traits.md:366
msgid "\"*waving arms furiously*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:290
msgid ""
"When we call `fly` on an instance of `Human`, the compiler defaults to "
"calling the method that is directly implemented on the type, as shown in "
"Listing 20-18."
msgstr ""

#: src/ch20-02-advanced-traits.md:332
msgid ""
"Running this code will print `*waving arms furiously*`, showing that Rust "
"called the `fly` method implemented on `Human` directly."
msgstr ""

#: src/ch20-02-advanced-traits.md:335
msgid ""
"To call the `fly` methods from either the `Pilot` trait or the `Wizard` "
"trait, we need to use more explicit syntax to specify which `fly` method we "
"mean. Listing 20-19 demonstrates this syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:380
msgid ""
"Specifying the trait name before the method name clarifies to Rust which "
"implementation of `fly` we want to call. We could also write "
"`Human::fly(&person)`, which is equivalent to the `person.fly()` that we "
"used in Listing 20-19, but this is a bit longer to write if we don’t need to "
"disambiguate."
msgstr ""

#: src/ch20-02-advanced-traits.md:386
msgid "Running this code prints the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:388
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n"
"     Running `target/debug/traits-example`\n"
"This is your captain speaking.\n"
"Up!\n"
"*waving arms furiously*\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:398
msgid ""
"Because the `fly` method takes a `self` parameter, if we had two _types_ "
"that both implement one _trait_, Rust could figure out which implementation "
"of a trait to use based on the type of `self`."
msgstr ""

#: src/ch20-02-advanced-traits.md:402
msgid ""
"However, associated functions that are not methods don’t have a `self` "
"parameter. When there are multiple types or traits that define non-method "
"functions with the same function name, Rust doesn't always know which type "
"you mean unless you use _fully qualified syntax_. For example, in Listing "
"20-20 we create a trait for an animal shelter that wants to name all baby "
"dogs _Spot_. We make an `Animal` trait with an associated non-method "
"function `baby_name`. The `Animal` trait is implemented for the struct "
"`Dog`, on which we also provide an associated non-method function "
"`baby_name` directly."
msgstr ""

#: src/ch20-02-advanced-traits.md:422 src/ch20-02-advanced-traits.md:473
#: src/ch20-02-advanced-traits.md:531
msgid "\"Spot\""
msgstr ""

#: src/ch20-02-advanced-traits.md:428 src/ch20-02-advanced-traits.md:479
#: src/ch20-02-advanced-traits.md:537
msgid "\"puppy\""
msgstr ""

#: src/ch20-02-advanced-traits.md:433 src/ch20-02-advanced-traits.md:484
#: src/ch20-02-advanced-traits.md:542
msgid "\"A baby dog is called a {}\""
msgstr ""

#: src/ch20-02-advanced-traits.md:439
msgid ""
"We implement the code for naming all puppies Spot in the `baby_name` "
"associated function that is defined on `Dog`. The `Dog` type also implements "
"the trait `Animal`, which describes characteristics that all animals have. "
"Baby dogs are called puppies, and that is expressed in the implementation of "
"the `Animal` trait on `Dog` in the `baby_name` function associated with the "
"`Animal` trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:445
msgid ""
"In `main`, we call the `Dog::baby_name` function, which calls the associated "
"function defined on `Dog` directly. This code prints the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:448
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a Spot\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:456
msgid ""
"This output isn’t what we wanted. We want to call the `baby_name` function "
"that is part of the `Animal` trait that we implemented on `Dog` so the code "
"prints `A baby dog is called a puppy`. The technique of specifying the trait "
"name that we used in Listing 20-19 doesn’t help here; if we change `main` to "
"the code in Listing 20-21, we’ll get a compilation error."
msgstr ""

#: src/ch20-02-advanced-traits.md:490
msgid ""
"Because `Animal::baby_name` doesn’t have a `self` parameter, and there could "
"be other types that implement the `Animal` trait, Rust can’t figure out "
"which implementation of `Animal::baby_name` we want. We’ll get this compiler "
"error:"
msgstr ""

#: src/ch20-02-advanced-traits.md:494
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0790]: cannot call associated function on trait without specifying "
"the corresponding `impl` type\n"
"  --> src/main.rs:20:43\n"
"   |\n"
"2  |     fn baby_name() -> String;\n"
"   |     ------------------------- `Animal::baby_name` defined here\n"
"...\n"
"20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n"
"   |                                           ^^^^^^^^^^^^^^^^^^^ cannot "
"call associated function of trait\n"
"   |\n"
"help: use the fully-qualified path to the only available implementation\n"
"   |\n"
"20 |     println!(\"A baby dog is called a {}\", <Dog as "
"Animal>::baby_name());\n"
"   |                                           +++++++       +\n"
"\n"
"For more information about this error, try `rustc --explain E0790`.\n"
"error: could not compile `traits-example` (bin \"traits-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:515
msgid ""
"To disambiguate and tell Rust that we want to use the implementation of "
"`Animal` for `Dog` as opposed to the implementation of `Animal` for some "
"other type, we need to use fully qualified syntax. Listing 20-22 "
"demonstrates how to use fully qualified syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:548
msgid ""
"We’re providing Rust with a type annotation within the angle brackets, which "
"indicates we want to call the `baby_name` method from the `Animal` trait as "
"implemented on `Dog` by saying that we want to treat the `Dog` type as an "
"`Animal` for this function call. This code will now print what we want:"
msgstr ""

#: src/ch20-02-advanced-traits.md:553
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a puppy\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:561
msgid "In general, fully qualified syntax is defined as follows:"
msgstr ""

#: src/ch20-02-advanced-traits.md:567
msgid ""
"For associated functions that aren’t methods, there would not be a "
"`receiver`: there would only be the list of other arguments. You could use "
"fully qualified syntax everywhere that you call functions or methods. "
"However, you’re allowed to omit any part of this syntax that Rust can figure "
"out from other information in the program. You only need to use this more "
"verbose syntax in cases where there are multiple implementations that use "
"the same name and Rust needs help to identify which implementation you want "
"to call."
msgstr ""

#: src/ch20-02-advanced-traits.md:575
msgid ""
"Using Supertraits to Require One Trait’s Functionality Within Another Trait"
msgstr ""

#: src/ch20-02-advanced-traits.md:577
msgid ""
"Sometimes, you might write a trait definition that depends on another trait: "
"for a type to implement the first trait, you want to require that type to "
"also implement the second trait. You would do this so that your trait "
"definition can make use of the associated items of the second trait. The "
"trait your trait definition is relying on is called a _supertrait_ of your "
"trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:583
msgid ""
"For example, let’s say we want to make an `OutlinePrint` trait with an "
"`outline_print` method that will print a given value formatted so that it's "
"framed in asterisks. That is, given a `Point` struct that implements the "
"standard library trait `Display` to result in `(x, y)`, when we call "
"`outline_print` on a `Point` instance that has `1` for `x` and `3` for `y`, "
"it should print the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:598
msgid ""
"In the implementation of the `outline_print` method, we want to use the "
"`Display` trait’s functionality. Therefore, we need to specify that the "
"`OutlinePrint` trait will work only for types that also implement `Display` "
"and provide the functionality that `OutlinePrint` needs. We can do that in "
"the trait definition by specifying `OutlinePrint: Display`. This technique "
"is similar to adding a trait bound to the trait. Listing 20-23 shows an "
"implementation of the `OutlinePrint` trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:615 src/ch20-02-advanced-traits.md:619
#: src/ch20-02-advanced-traits.md:647 src/ch20-02-advanced-traits.md:651
#: src/ch20-02-advanced-traits.md:719 src/ch20-02-advanced-traits.md:723
msgid "\"*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:616 src/ch20-02-advanced-traits.md:618
#: src/ch20-02-advanced-traits.md:648 src/ch20-02-advanced-traits.md:650
#: src/ch20-02-advanced-traits.md:720 src/ch20-02-advanced-traits.md:722
msgid "\"*{}*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:616 src/ch20-02-advanced-traits.md:618
#: src/ch20-02-advanced-traits.md:648 src/ch20-02-advanced-traits.md:650
#: src/ch20-02-advanced-traits.md:720 src/ch20-02-advanced-traits.md:722
msgid "\" \""
msgstr ""

#: src/ch20-02-advanced-traits.md:617 src/ch20-02-advanced-traits.md:649
#: src/ch20-02-advanced-traits.md:721
msgid "\"* {output} *\""
msgstr ""

#: src/ch20-02-advanced-traits.md:628
msgid ""
"Because we’ve specified that `OutlinePrint` requires the `Display` trait, we "
"can use the `to_string` function that is automatically implemented for any "
"type that implements `Display`. If we tried to use `to_string` without "
"adding a colon and specifying the `Display` trait after the trait name, we’d "
"get an error saying that no method named `to_string` was found for the type "
"`&Self` in the current scope."
msgstr ""

#: src/ch20-02-advanced-traits.md:635
msgid ""
"Let’s see what happens when we try to implement `OutlinePrint` on a type "
"that doesn’t implement `Display`, such as the `Point` struct:"
msgstr ""

#: src/ch20-02-advanced-traits.md:670
msgid "We get an error saying that `Display` is required but not implemented:"
msgstr ""

#: src/ch20-02-advanced-traits.md:672
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0277]: `Point` doesn't implement `std::fmt::Display`\n"
"  --> src/main.rs:20:23\n"
"   |\n"
"20 | impl OutlinePrint for Point {}\n"
"   |                       ^^^^^ `Point` cannot be formatted with the "
"default formatter\n"
"   |\n"
"   = help: the trait `std::fmt::Display` is not implemented for `Point`\n"
"   = note: in format strings you may be able to use `{:?}` (or {:#?} for "
"pretty-print) instead\n"
"note: required by a bound in `OutlinePrint`\n"
"  --> src/main.rs:3:21\n"
"   |\n"
"3  | trait OutlinePrint: fmt::Display {\n"
"   |                     ^^^^^^^^^^^^ required by this bound in "
"`OutlinePrint`\n"
"\n"
"error[E0277]: `Point` doesn't implement `std::fmt::Display`\n"
"  --> src/main.rs:24:7\n"
"   |\n"
"24 |     p.outline_print();\n"
"   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default "
"formatter\n"
"   |\n"
"   = help: the trait `std::fmt::Display` is not implemented for `Point`\n"
"   = note: in format strings you may be able to use `{:?}` (or {:#?} for "
"pretty-print) instead\n"
"note: required by a bound in `OutlinePrint::outline_print`\n"
"  --> src/main.rs:3:21\n"
"   |\n"
"3  | trait OutlinePrint: fmt::Display {\n"
"   |                     ^^^^^^^^^^^^ required by this bound in "
"`OutlinePrint::outline_print`\n"
"4  |     fn outline_print(&self) {\n"
"   |        ------------- required by a bound in this associated function\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `traits-example` (bin \"traits-example\") due to 2 "
"previous errors\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:709
msgid ""
"To fix this, we implement `Display` on `Point` and satisfy the constraint "
"that `OutlinePrint` requires, like so:"
msgstr ""

#: src/ch20-02-advanced-traits.md:738
msgid "\"({}, {})\""
msgstr ""

#: src/ch20-02-advanced-traits.md:750
msgid ""
"Then implementing the `OutlinePrint` trait on `Point` will compile "
"successfully, and we can call `outline_print` on a `Point` instance to "
"display it within an outline of asterisks."
msgstr ""

#: src/ch20-02-advanced-traits.md:754
msgid ""
"Using the Newtype Pattern to Implement External Traits on External Types"
msgstr ""

#: src/ch20-02-advanced-traits.md:756
msgid ""
"In [“Implementing a Trait on a Type”](ch10-02-traits.html#implementing-a-"
"trait-on-a-type)<!-- ignore\n"
"--> in Chapter 10, we mentioned the orphan rule that states we’re only "
"allowed to implement a trait on a type if either the trait or the type are "
"local to our crate. It’s possible to get around this restriction using the "
"_newtype pattern_, which involves creating a new type in a tuple struct. (We "
"covered tuple structs in [“Using Tuple Structs without Named Fields to "
"Create Different Types”](ch05-01-defining-structs.html#using-tuple-structs-"
"without-named-fields-to-create-different-types)<!-- ignore --> in Chapter "
"5.) The tuple struct will have one field and be a thin wrapper around the "
"type we want to implement a trait for. Then the wrapper type is local to our "
"crate, and we can implement the trait on the wrapper. _Newtype_ is a term "
"that originates from the Haskell programming language. There is no runtime "
"performance penalty for using this pattern, and the wrapper type is elided "
"at compile time."
msgstr ""

#: src/ch20-02-advanced-traits.md:769
msgid ""
"As an example, let’s say we want to implement `Display` on `Vec<T>`, which "
"the orphan rule prevents us from doing directly because the `Display` trait "
"and the `Vec<T>` type are defined outside our crate. We can make a `Wrapper` "
"struct that holds an instance of `Vec<T>`; then we can implement `Display` "
"on `Wrapper` and use the `Vec<T>` value, as shown in Listing 20-24."
msgstr ""

#: src/ch20-02-advanced-traits.md:784
msgid "\"[{}]\""
msgstr ""

#: src/ch20-02-advanced-traits.md:784
msgid "\", \""
msgstr ""

#: src/ch20-02-advanced-traits.md:789
msgid "\"world\""
msgstr ""

#: src/ch20-02-advanced-traits.md:790
msgid "\"w = {w}\""
msgstr ""

#: src/ch20-02-advanced-traits.md:796
msgid ""
"The implementation of `Display` uses `self.0` to access the inner `Vec<T>`, "
"because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in "
"the tuple. Then we can use the functionality of the `Display` trait on "
"`Wrapper`."
msgstr ""

#: src/ch20-02-advanced-traits.md:800
msgid ""
"The downside of using this technique is that `Wrapper` is a new type, so it "
"doesn’t have the methods of the value it’s holding. We would have to "
"implement all the methods of `Vec<T>` directly on `Wrapper` such that the "
"methods delegate to `self.0`, which would allow us to treat `Wrapper` "
"exactly like a `Vec<T>`. If we wanted the new type to have every method the "
"inner type has, implementing the `Deref` trait (discussed in [“Treating "
"Smart Pointers Like Regular References with the `Deref` Trait”](ch15-02-"
"deref.html#treating-smart-pointers-like-regular-references-with-the-deref-"
"trait)<!-- ignore --> in Chapter 15) on the `Wrapper` to return the inner "
"type would be a solution. If we don’t want the `Wrapper` type to have all "
"the methods of the inner type—for example, to restrict the `Wrapper` type’s "
"behavior—we would have to implement just the methods we do want manually."
msgstr ""

#: src/ch20-02-advanced-traits.md:812
msgid ""
"This newtype pattern is also useful even when traits are not involved. Let’s "
"switch focus and look at some advanced ways to interact with Rust’s type "
"system."
msgstr ""

#: src/ch20-03-advanced-types.md:3
msgid ""
"The Rust type system has some features that we’ve so far mentioned but "
"haven’t yet discussed. We’ll start by discussing newtypes in general as we "
"examine why newtypes are useful as types. Then we’ll move on to type "
"aliases, a feature similar to newtypes but with slightly different "
"semantics. We’ll also discuss the `!` type and dynamically sized types."
msgstr ""

#: src/ch20-03-advanced-types.md:9
msgid "Using the Newtype Pattern for Type Safety and Abstraction"
msgstr ""

#: src/ch20-03-advanced-types.md:11
msgid ""
"This section assumes you’ve read the earlier section [“Using the Newtype "
"Pattern to Implement External Traits on External Types.”](ch20-02-advanced-"
"traits.html#using-the-newtype-pattern-to-implement-external-traits-on-"
"external-types)<!--\n"
"ignore --> The newtype pattern is also useful for tasks beyond those we’ve "
"discussed so far, including statically enforcing that values are never "
"confused and indicating the units of a value. You saw an example of using "
"newtypes to indicate units in Listing 20-16: recall that the `Millimeters` "
"and `Meters` structs wrapped `u32` values in a newtype. If we wrote a "
"function with a parameter of type `Millimeters`, we couldn’t compile a "
"program that accidentally tried to call that function with a value of type "
"`Meters` or a plain `u32`."
msgstr ""

#: src/ch20-03-advanced-types.md:21
msgid ""
"We can also use the newtype pattern to abstract away some implementation "
"details of a type: the new type can expose a public API that is different "
"from the API of the private inner type."
msgstr ""

#: src/ch20-03-advanced-types.md:25
msgid ""
"Newtypes can also hide internal implementation. For example, we could "
"provide a `People` type to wrap a `HashMap<i32, String>` that stores a "
"person’s ID associated with their name. Code using `People` would only "
"interact with the public API we provide, such as a method to add a name "
"string to the `People` collection; that code wouldn’t need to know that we "
"assign an `i32` ID to names internally. The newtype pattern is a lightweight "
"way to achieve encapsulation to hide implementation details, which we "
"discussed in [“Encapsulation that Hides Implementation Details”](ch18-01-"
"what-is-oo.html#encapsulation-that-hides-implementation-details)<!--\n"
"ignore --> in Chapter 18."
msgstr ""

#: src/ch20-03-advanced-types.md:35
msgid "Creating Type Synonyms with Type Aliases"
msgstr ""

#: src/ch20-03-advanced-types.md:37
msgid ""
"Rust provides the ability to declare a _type alias_ to give an existing type "
"another name. For this we use the `type` keyword. For example, we can create "
"the alias `Kilometers` to `i32` like so:"
msgstr ""

#: src/ch20-03-advanced-types.md:48 src/ch20-03-advanced-types.md:64
msgid "\"x + y = {}\""
msgstr ""

#: src/ch20-03-advanced-types.md:52
msgid ""
"Now, the alias `Kilometers` is a _synonym_ for `i32`; unlike the "
"`Millimeters` and `Meters` types we created in Listing 20-16, `Kilometers` "
"is not a separate, new type. Values that have the type `Kilometers` will be "
"treated the same as values of type `i32`:"
msgstr ""

#: src/ch20-03-advanced-types.md:68
msgid ""
"Because `Kilometers` and `i32` are the same type, we can add values of both "
"types and we can pass `Kilometers` values to functions that take `i32` "
"parameters. However, using this method, we don’t get the type checking "
"benefits that we get from the newtype pattern discussed earlier. In other "
"words, if we mix up `Kilometers` and `i32` values somewhere, the compiler "
"will not give us an error."
msgstr ""

#: src/ch20-03-advanced-types.md:75
msgid ""
"The main use case for type synonyms is to reduce repetition. For example, we "
"might have a lengthy type like this:"
msgstr ""

#: src/ch20-03-advanced-types.md:82
msgid ""
"Writing this lengthy type in function signatures and as type annotations all "
"over the code can be tiresome and error prone. Imagine having a project full "
"of code like that in Listing 20-25."
msgstr ""

#: src/ch20-03-advanced-types.md:105
msgid ""
"A type alias makes this code more manageable by reducing the repetition. In "
"Listing 20-26, we’ve introduced an alias named `Thunk` for the verbose type "
"and can replace all uses of the type with the shorter alias `Thunk`."
msgstr ""

#: src/ch20-03-advanced-types.md:130
msgid ""
"This code is much easier to read and write! Choosing a meaningful name for a "
"type alias can help communicate your intent as well (_thunk_ is a word for "
"code to be evaluated at a later time, so it’s an appropriate name for a "
"closure that gets stored)."
msgstr ""

#: src/ch20-03-advanced-types.md:135
msgid ""
"Type aliases are also commonly used with the `Result<T, E>` type for "
"reducing repetition. Consider the `std::io` module in the standard library. "
"I/O operations often return a `Result<T, E>` to handle situations when "
"operations fail to work. This library has a `std::io::Error` struct that "
"represents all possible I/O errors. Many of the functions in `std::io` will "
"be returning `Result<T, E>` where the `E` is `std::io::Error`, such as these "
"functions in the `Write` trait:"
msgstr ""

#: src/ch20-03-advanced-types.md:156
msgid ""
"The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type "
"alias declaration:"
msgstr ""

#: src/ch20-03-advanced-types.md:173
msgid ""
"Because this declaration is in the `std::io` module, we can use the fully "
"qualified alias `std::io::Result<T>`; that is, a `Result<T, E>` with the `E` "
"filled in as `std::io::Error`. The `Write` trait function signatures end up "
"looking like this:"
msgstr ""

#: src/ch20-03-advanced-types.md:192
msgid ""
"The type alias helps in two ways: it makes code easier to write _and_ it "
"gives us a consistent interface across all of `std::io`. Because it’s an "
"alias, it’s just another `Result<T, E>`, which means we can use any methods "
"that work on `Result<T, E>` with it, as well as special syntax like the `?` "
"operator."
msgstr ""

#: src/ch20-03-advanced-types.md:197
msgid "The Never Type that Never Returns"
msgstr ""

#: src/ch20-03-advanced-types.md:199
msgid ""
"Rust has a special type named `!` that’s known in type theory lingo as the "
"_empty type_ because it has no values. We prefer to call it the _never type_ "
"because it stands in the place of the return type when a function will never "
"return. Here is an example:"
msgstr ""

#: src/ch20-03-advanced-types.md:211
msgid ""
"This code is read as “the function `bar` returns never.” Functions that "
"return never are called _diverging functions_. We can’t create values of the "
"type `!` so `bar` can never possibly return."
msgstr ""

#: src/ch20-03-advanced-types.md:215
msgid ""
"But what use is a type you can never create values for? Recall the code from "
"Listing 2-5, part of the number guessing game; we’ve reproduced a bit of it "
"here in Listing 20-27."
msgstr ""

#: src/ch20-03-advanced-types.md:267
msgid ""
"At the time, we skipped over some details in this code. In [“The `match` "
"Control Flow Operator”](ch06-02-match.html#the-match-control-flow-"
"operator)<!-- ignore --> in Chapter 6, we discussed that `match` arms must "
"all return the same type. So, for example, the following code doesn’t work:"
msgstr ""

#: src/ch20-03-advanced-types.md:274
msgid "\"3\""
msgstr ""

#: src/ch20-03-advanced-types.md:282
msgid ""
"The type of `guess` in this code would have to be an integer _and_ a string, "
"and Rust requires that `guess` have only one type. So what does `continue` "
"return? How were we allowed to return a `u32` from one arm and have another "
"arm that ends with `continue` in Listing 20-27?"
msgstr ""

#: src/ch20-03-advanced-types.md:287
msgid ""
"As you might have guessed, `continue` has a `!` value. That is, when Rust "
"computes the type of `guess`, it looks at both match arms, the former with a "
"value of `u32` and the latter with a `!` value. Because `!` can never have a "
"value, Rust decides that the type of `guess` is `u32`."
msgstr ""

#: src/ch20-03-advanced-types.md:292
msgid ""
"The formal way of describing this behavior is that expressions of type `!` "
"can be coerced into any other type. We’re allowed to end this `match` arm "
"with `continue` because `continue` doesn’t return a value; instead, it moves "
"control back to the top of the loop, so in the `Err` case, we never assign a "
"value to `guess`."
msgstr ""

#: src/ch20-03-advanced-types.md:298
msgid ""
"The never type is useful with the `panic!` macro as well. Recall the "
"`unwrap` function that we call on `Option<T>` values to produce a value or "
"panic with this definition:"
msgstr ""

#: src/ch20-03-advanced-types.md:314
msgid "\"called `Option::unwrap()` on a `None` value\""
msgstr ""

#: src/ch20-03-advanced-types.md:320
msgid ""
"In this code, the same thing happens as in the `match` in Listing 20-27: "
"Rust sees that `val` has the type `T` and `panic!` has the type `!`, so the "
"result of the overall `match` expression is `T`. This code works because "
"`panic!` doesn’t produce a value; it ends the program. In the `None` case, "
"we won’t be returning a value from `unwrap`, so this code is valid."
msgstr ""

#: src/ch20-03-advanced-types.md:326
msgid "One final expression that has the type `!` is a `loop`:"
msgstr ""

#: src/ch20-03-advanced-types.md:330
msgid "\"forever \""
msgstr ""

#: src/ch20-03-advanced-types.md:333
msgid "\"and ever \""
msgstr ""

#: src/ch20-03-advanced-types.md:338
msgid ""
"Here, the loop never ends, so `!` is the value of the expression. However, "
"this wouldn’t be true if we included a `break`, because the loop would "
"terminate when it got to the `break`."
msgstr ""

#: src/ch20-03-advanced-types.md:342
msgid "Dynamically Sized Types and the `Sized` Trait"
msgstr ""

#: src/ch20-03-advanced-types.md:344
msgid ""
"Rust needs to know certain details about its types, such as how much space "
"to allocate for a value of a particular type. This leaves one corner of its "
"type system a little confusing at first: the concept of _dynamically sized "
"types_. Sometimes referred to as _DSTs_ or _unsized types_, these types let "
"us write code using values whose size we can know only at runtime."
msgstr ""

#: src/ch20-03-advanced-types.md:350
msgid ""
"Let’s dig into the details of a dynamically sized type called `str`, which "
"we’ve been using throughout the book. That’s right, not `&str`, but `str` on "
"its own, is a DST. We can’t know how long the string is until runtime, "
"meaning we can’t create a variable of type `str`, nor can we take an "
"argument of type `str`. Consider the following code, which does not work:"
msgstr ""

#: src/ch20-03-advanced-types.md:358
msgid "\"Hello there!\""
msgstr ""

#: src/ch20-03-advanced-types.md:359
msgid "\"How's it going?\""
msgstr ""

#: src/ch20-03-advanced-types.md:363
msgid ""
"Rust needs to know how much memory to allocate for any value of a particular "
"type, and all values of a type must use the same amount of memory. If Rust "
"allowed us to write this code, these two `str` values would need to take up "
"the same amount of space. But they have different lengths: `s1` needs 12 "
"bytes of storage and `s2` needs 15. This is why it’s not possible to create "
"a variable holding a dynamically sized type."
msgstr ""

#: src/ch20-03-advanced-types.md:370
msgid ""
"So what do we do? In this case, you already know the answer: we make the "
"types of `s1` and `s2` a `&str` rather than a `str`. Recall from [“String "
"Slices”](ch04-03-slices.html#string-slices)<!-- ignore --> in Chapter 4 that "
"the slice data structure just stores the starting position and the length of "
"the slice. So although a `&T` is a single value that stores the memory "
"address of where the `T` is located, a `&str` is _two_ values: the address "
"of the `str` and its length. As such, we can know the size of a `&str` value "
"at compile time: it’s twice the length of a `usize`. That is, we always know "
"the size of a `&str`, no matter how long the string it refers to is. In "
"general, this is the way in which dynamically sized types are used in Rust: "
"they have an extra bit of metadata that stores the size of the dynamic "
"information. The golden rule of dynamically sized types is that we must "
"always put values of dynamically sized types behind a pointer of some kind."
msgstr ""

#: src/ch20-03-advanced-types.md:384
msgid ""
"We can combine `str` with all kinds of pointers: for example, `Box<str>` or "
"`Rc<str>`. In fact, you’ve seen this before but with a different dynamically "
"sized type: traits. Every trait is a dynamically sized type we can refer to "
"by using the name of the trait. In [“Using Trait Objects That Allow for "
"Values of Different Types”](ch18-02-trait-objects.html#using-trait-objects-"
"that-allow-for-values-of-different-types)<!-- ignore\n"
"--> in Chapter 18, we mentioned that to use traits as trait objects, we must "
"put them behind a pointer, such as `&dyn Trait` or `Box<dyn Trait>` (`Rc<dyn "
"Trait>` would work too)."
msgstr ""

#: src/ch20-03-advanced-types.md:394
msgid ""
"To work with DSTs, Rust provides the `Sized` trait to determine whether or "
"not a type’s size is known at compile time. This trait is automatically "
"implemented for everything whose size is known at compile time. In addition, "
"Rust implicitly adds a bound on `Sized` to every generic function. That is, "
"a generic function definition like this:"
msgstr ""

#: src/ch20-03-advanced-types.md:406
msgid "is actually treated as though we had written this:"
msgstr ""

#: src/ch20-03-advanced-types.md:414
msgid ""
"By default, generic functions will work only on types that have a known size "
"at compile time. However, you can use the following special syntax to relax "
"this restriction:"
msgstr ""

#: src/ch20-03-advanced-types.md:424
msgid ""
"A trait bound on `?Sized` means “`T` may or may not be `Sized`” and this "
"notation overrides the default that generic types must have a known size at "
"compile time. The `?Trait` syntax with this meaning is only available for "
"`Sized`, not any other traits."
msgstr ""

#: src/ch20-03-advanced-types.md:429
msgid ""
"Also note that we switched the type of the `t` parameter from `T` to `&T`. "
"Because the type might not be `Sized`, we need to use it behind some kind of "
"pointer. In this case, we’ve chosen a reference."
msgstr ""

#: src/ch20-03-advanced-types.md:433
msgid "Next, we’ll talk about functions and closures!"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:3
msgid ""
"This section explores some advanced features related to functions and "
"closures, including function pointers and returning closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:6
msgid "Function Pointers"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:8
msgid ""
"We’ve talked about how to pass closures to functions; you can also pass "
"regular functions to functions! This technique is useful when you want to "
"pass a function you’ve already defined rather than defining a new closure. "
"Functions coerce to the type `fn` (with a lowercase f), not to be confused "
"with the `Fn` closure trait. The `fn` type is called a _function pointer_. "
"Passing functions with function pointers will allow you to use functions as "
"arguments to other functions."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:16
msgid ""
"The syntax for specifying that a parameter is a function pointer is similar "
"to that of closures, as shown in Listing 20-28, where we’ve defined a "
"function `add_one` that adds one to its parameter. The function `do_twice` "
"takes two parameters: a function pointer to any function that takes an `i32` "
"parameter and returns an `i32`, and one `i32` value. The `do_twice` function "
"calls the function `f` twice, passing it the `arg` value, then adds the two "
"function call results together. The `main` function calls `do_twice` with "
"the arguments `add_one` and `5`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:39
msgid "\"The answer is: {answer}\""
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:45
msgid ""
"This code prints `The answer is: 12`. We specify that the parameter `f` in "
"`do_twice` is an `fn` that takes one parameter of type `i32` and returns an "
"`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can "
"pass the function name `add_one` as the first argument to `do_twice`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:50
msgid ""
"Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as "
"the parameter type directly rather than declaring a generic type parameter "
"with one of the `Fn` traits as a trait bound."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:54
msgid ""
"Function pointers implement all three of the closure traits (`Fn`, `FnMut`, "
"and `FnOnce`), meaning you can always pass a function pointer as an argument "
"for a function that expects a closure. It’s best to write functions using a "
"generic type and one of the closure traits so your functions can accept "
"either functions or closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:60
msgid ""
"That said, one example of where you would want to only accept `fn` and not "
"closures is when interfacing with external code that doesn’t have closures: "
"C functions can accept functions as arguments, but C doesn’t have closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:64
msgid ""
"As an example of where you could use either a closure defined inline or a "
"named function, let’s look at a use of the `map` method provided by the "
"`Iterator` trait in the standard library. To use the `map` function to turn "
"a vector of numbers into a vector of strings, we could use a closure, like "
"this:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:77
msgid ""
"Or we could name a function as the argument to `map` instead of the closure, "
"like this:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:88
msgid ""
"Note that we must use the fully qualified syntax that we talked about in "
"[“Advanced Traits”](ch20-02-advanced-traits.html#advanced-traits)<!-- ignore "
"--> because there are multiple functions available named `to_string`. Here, "
"we’re using the `to_string` function defined in the `ToString` trait, which "
"the standard library has implemented for any type that implements `Display`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:94
msgid ""
"Recall from [“Enum values”](ch06-01-defining-an-enum.html#enum-values)<!-- "
"ignore --> in Chapter 6 that the name of each enum variant that we define "
"also becomes an initializer function. We can use these initializer functions "
"as function pointers that implement the closure traits, which means we can "
"specify the initializer functions as arguments for methods that take "
"closures, like so:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:111
msgid ""
"Here we create `Status::Value` instances using each `u32` value in the range "
"that `map` is called on by using the initializer function of "
"`Status::Value`. Some people prefer this style, and some people prefer to "
"use closures. They compile to the same code, so use whichever style is "
"clearer to you."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:116
msgid "Returning Closures"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:118
msgid ""
"Closures are represented by traits, which means you can’t return closures "
"directly. In most cases where you might want to return a trait, you can "
"instead use the concrete type that implements the trait as the return value "
"of the function. However, you can’t do that with closures because they don’t "
"have a concrete type that is returnable; you’re not allowed to use the "
"function pointer `fn` as a return type, for example."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:125
msgid ""
"Instead, you will normally use the `impl Trait` syntax we learned about in "
"Chapter 10. You can return any function type, using `Fn`, `FnOnce` and "
"`FnMut`. For example, this code will work just fine:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:135
msgid ""
"However, as we noted in the [“Closure Type Inference and Annotation”]"
"(ch13-01-closures.html#closure-type-inference-and-annotation)<!-- ignore --> "
"section in Chapter 13, each closure is also its own distinct type. If you "
"need to work with multiple functions that have the same signature but "
"different implementations, you will need to use a trait object for them:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:146
msgid "\"{output}\""
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:159
msgid ""
"This code will compile just fine—but it wouldn’t if we had tried to stick "
"with `impl Fn(i32) -> i32`. For more about trait objects, refer to the "
"section [“Using Trait Objects That Allow for Values of Different Types”]"
"(ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-"
"different-types)<!-- ignore\n"
"--> in Chapter 18."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:165
msgid "Next, let’s look at macros!"
msgstr ""

#: src/ch20-05-macros.md:3
msgid ""
"We’ve used macros like `println!` throughout this book, but we haven’t fully "
"explored what a macro is and how it works. The term _macro_ refers to a "
"family of features in Rust: _declarative_ macros with `macro_rules!` and "
"three kinds of _procedural_ macros:"
msgstr ""

#: src/ch20-05-macros.md:8
msgid ""
"Custom `#[derive]` macros that specify code added with the `derive` "
"attribute used on structs and enums"
msgstr ""

#: src/ch20-05-macros.md:10
msgid "Attribute-like macros that define custom attributes usable on any item"
msgstr ""

#: src/ch20-05-macros.md:11
msgid ""
"Function-like macros that look like function calls but operate on the tokens "
"specified as their argument"
msgstr ""

#: src/ch20-05-macros.md:14
msgid ""
"We’ll talk about each of these in turn, but first, let’s look at why we even "
"need macros when we already have functions."
msgstr ""

#: src/ch20-05-macros.md:17
msgid "The Difference Between Macros and Functions"
msgstr ""

#: src/ch20-05-macros.md:19
msgid ""
"Fundamentally, macros are a way of writing code that writes other code, "
"which is known as _metaprogramming_. In Appendix C, we discuss the `derive` "
"attribute, which generates an implementation of various traits for you. "
"We’ve also used the `println!` and `vec!` macros throughout the book. All of "
"these macros _expand_ to produce more code than the code you’ve written "
"manually."
msgstr ""

#: src/ch20-05-macros.md:25
msgid ""
"Metaprogramming is useful for reducing the amount of code you have to write "
"and maintain, which is also one of the roles of functions. However, macros "
"have some additional powers that functions don’t."
msgstr ""

#: src/ch20-05-macros.md:29
msgid ""
"A function signature must declare the number and type of parameters the "
"function has. Macros, on the other hand, can take a variable number of "
"parameters: we can call `println!(\"hello\")` with one argument or `println!"
"(\"hello {}\", name)` with two arguments. Also, macros are expanded before "
"the compiler interprets the meaning of the code, so a macro can, for "
"example, implement a trait on a given type. A function can’t, because it "
"gets called at runtime and a trait needs to be implemented at compile time."
msgstr ""

#: src/ch20-05-macros.md:37
msgid ""
"The downside to implementing a macro instead of a function is that macro "
"definitions are more complex than function definitions because you’re "
"writing Rust code that writes Rust code. Due to this indirection, macro "
"definitions are generally more difficult to read, understand, and maintain "
"than function definitions."
msgstr ""

#: src/ch20-05-macros.md:43
msgid ""
"Another important difference between macros and functions is that you must "
"define macros or bring them into scope _before_ you call them in a file, as "
"opposed to functions you can define anywhere and call anywhere."
msgstr ""

#: src/ch20-05-macros.md:47
msgid "Declarative Macros with `macro_rules!` for General Metaprogramming"
msgstr ""

#: src/ch20-05-macros.md:49
msgid ""
"The most widely used form of macros in Rust is the _declarative macro_. "
"These are also sometimes referred to as “macros by example,” “`macro_rules!` "
"macros,” or just plain “macros.” At their core, declarative macros allow you "
"to write something similar to a Rust `match` expression. As discussed in "
"Chapter 6, `match` expressions are control structures that take an "
"expression, compare the resulting value of the expression to patterns, and "
"then run the code associated with the matching pattern. Macros also compare "
"a value to patterns that are associated with particular code: in this "
"situation, the value is the literal Rust source code passed to the macro; "
"the patterns are compared with the structure of that source code; and the "
"code associated with each pattern, when matched, replaces the code passed to "
"the macro. This all happens during compilation."
msgstr ""

#: src/ch20-05-macros.md:62
msgid ""
"To define a macro, you use the `macro_rules!` construct. Let’s explore how "
"to use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter "
"8 covered how we can use the `vec!` macro to create a new vector with "
"particular values. For example, the following macro creates a new vector "
"containing three integers:"
msgstr ""

#: src/ch20-05-macros.md:72
msgid ""
"We could also use the `vec!` macro to make a vector of two integers or a "
"vector of five string slices. We wouldn’t be able to use a function to do "
"the same because we wouldn’t know the number or type of values up front."
msgstr ""

#: src/ch20-05-macros.md:76
msgid ""
"Listing 20-29 shows a slightly simplified definition of the `vec!` macro."
msgstr ""

#: src/ch20-05-macros.md:97
msgid ""
"Note: The actual definition of the `vec!` macro in the standard library "
"includes code to preallocate the correct amount of memory up front. That "
"code is an optimization that we don’t include here to make the example "
"simpler."
msgstr ""

#: src/ch20-05-macros.md:101
msgid ""
"The `#[macro_export]` annotation indicates that this macro should be made "
"available whenever the crate in which the macro is defined is brought into "
"scope. Without this annotation, the macro can’t be brought into scope."
msgstr ""

#: src/ch20-05-macros.md:105
msgid ""
"We then start the macro definition with `macro_rules!` and the name of the "
"macro we’re defining _without_ the exclamation mark. The name, in this case "
"`vec`, is followed by curly brackets denoting the body of the macro "
"definition."
msgstr ""

#: src/ch20-05-macros.md:109
msgid ""
"The structure in the `vec!` body is similar to the structure of a `match` "
"expression. Here we have one arm with the pattern `( $( $x:expr ),* )`, "
"followed by `=>` and the block of code associated with this pattern. If the "
"pattern matches, the associated block of code will be emitted. Given that "
"this is the only pattern in this macro, there is only one valid way to "
"match; any other pattern will result in an error. More complex macros will "
"have more than one arm."
msgstr ""

#: src/ch20-05-macros.md:117
msgid ""
"Valid pattern syntax in macro definitions is different than the pattern "
"syntax covered in Chapter 19 because macro patterns are matched against Rust "
"code structure rather than values. Let’s walk through what the pattern "
"pieces in Listing 20-29 mean; for the full macro pattern syntax, see the "
"[Rust Reference](../reference/macros-by-example.html)."
msgstr ""

#: src/ch20-05-macros.md:123
msgid ""
"First, we use a set of parentheses to encompass the whole pattern. We use a "
"dollar sign (`$`) to declare a variable in the macro system that will "
"contain the Rust code matching the pattern. The dollar sign makes it clear "
"this is a macro variable as opposed to a regular Rust variable. Next comes a "
"set of parentheses that captures values that match the pattern within the "
"parentheses for use in the replacement code. Within `$()` is `$x:expr`, "
"which matches any Rust expression and gives the expression the name `$x`."
msgstr ""

#: src/ch20-05-macros.md:131
msgid ""
"The comma following `$()` indicates that a literal comma separator character "
"must appear between each instance of the code that matches the code within `$"
"()`. The `*` specifies that the pattern matches zero or more of whatever "
"precedes the `*`."
msgstr ""

#: src/ch20-05-macros.md:136
msgid ""
"When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches "
"three times with the three expressions `1`, `2`, and `3`."
msgstr ""

#: src/ch20-05-macros.md:139
msgid ""
"Now let’s look at the pattern in the body of the code associated with this "
"arm: `temp_vec.push()` within `$()*` is generated for each part that matches "
"`$()` in the pattern zero or more times depending on how many times the "
"pattern matches. The `$x` is replaced with each expression matched. When we "
"call this macro with `vec![1, 2, 3];`, the code generated that replaces this "
"macro call will be the following:"
msgstr ""

#: src/ch20-05-macros.md:156
msgid ""
"We’ve defined a macro that can take any number of arguments of any type and "
"can generate code to create a vector containing the specified elements."
msgstr ""

#: src/ch20-05-macros.md:159
msgid ""
"To learn more about how to write macros, consult the online documentation or "
"other resources, such as [“The Little Book of Rust Macros”](https://"
"veykril.github.io/tlborm/) started by Daniel Keep and continued by Lukas "
"Wirth."
msgstr ""

#: src/ch20-05-macros.md:163
msgid "Procedural Macros for Generating Code from Attributes"
msgstr ""

#: src/ch20-05-macros.md:165
msgid ""
"The second form of macros is the _procedural macro_, which acts more like a "
"function (and is a type of procedure). Procedural macros accept some code as "
"an input, operate on that code, and produce some code as an output rather "
"than matching against patterns and replacing the code with other code as "
"declarative macros do. The three kinds of procedural macros are custom "
"derive, attribute-like, and function-like, and all work in a similar fashion."
msgstr ""

#: src/ch20-05-macros.md:172
msgid ""
"When creating procedural macros, the definitions must reside in their own "
"crate with a special crate type. This is for complex technical reasons that "
"we hope to eliminate in the future. In Listing 20-30, we show how to define "
"a procedural macro, where `some_attribute` is a placeholder for using a "
"specific macro variety."
msgstr ""

#: src/ch20-05-macros.md:190
msgid ""
"The function that defines a procedural macro takes a `TokenStream` as an "
"input and produces a `TokenStream` as an output. The `TokenStream` type is "
"defined by the `proc_macro` crate that is included with Rust and represents "
"a sequence of tokens. This is the core of the macro: the source code that "
"the macro is operating on makes up the input `TokenStream`, and the code the "
"macro produces is the output `TokenStream`. The function also has an "
"attribute attached to it that specifies which kind of procedural macro we’re "
"creating. We can have multiple kinds of procedural macros in the same crate."
msgstr ""

#: src/ch20-05-macros.md:199
msgid ""
"Let’s look at the different kinds of procedural macros. We’ll start with a "
"custom derive macro and then explain the small dissimilarities that make the "
"other forms different."
msgstr ""

#: src/ch20-05-macros.md:203
msgid "How to Write a Custom `derive` Macro"
msgstr ""

#: src/ch20-05-macros.md:205
msgid ""
"Let’s create a crate named `hello_macro` that defines a trait named "
"`HelloMacro` with one associated function named `hello_macro`. Rather than "
"making our users implement the `HelloMacro` trait for each of their types, "
"we’ll provide a procedural macro so users can annotate their type with "
"`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro` "
"function. The default implementation will print `Hello, Macro! My name is "
"TypeName!` where `TypeName` is the name of the type on which this trait has "
"been defined. In other words, we’ll write a crate that enables another "
"programmer to write code like Listing 20-31 using our crate."
msgstr ""

#: src/ch20-05-macros.md:231
msgid ""
"This code will print `Hello, Macro! My name is Pancakes!` when we’re done. "
"The first step is to make a new library crate, like this:"
msgstr ""

#: src/ch20-05-macros.md:238
msgid "Next, we’ll define the `HelloMacro` trait and its associated function:"
msgstr ""

#: src/ch20-05-macros.md:250
msgid ""
"We have a trait and its function. At this point, our crate user could "
"implement the trait to achieve the desired functionality, like so:"
msgstr ""

#: src/ch20-05-macros.md:260
msgid "\"Hello, Macro! My name is Pancakes!\""
msgstr ""

#: src/ch20-05-macros.md:269
msgid ""
"However, they would need to write the implementation block for each type "
"they wanted to use with `hello_macro`; we want to spare them from having to "
"do this work."
msgstr ""

#: src/ch20-05-macros.md:273
msgid ""
"Additionally, we can’t yet provide the `hello_macro` function with default "
"implementation that will print the name of the type the trait is implemented "
"on: Rust doesn’t have reflection capabilities, so it can’t look up the "
"type’s name at runtime. We need a macro to generate code at compile time."
msgstr ""

#: src/ch20-05-macros.md:278
msgid ""
"The next step is to define the procedural macro. At the time of this "
"writing, procedural macros need to be in their own crate. Eventually, this "
"restriction might be lifted. The convention for structuring crates and macro "
"crates is as follows: for a crate named `foo`, a custom derive procedural "
"macro crate is called `foo_derive`. Let’s start a new crate called "
"`hello_macro_derive` inside our `hello_macro` project:"
msgstr ""

#: src/ch20-05-macros.md:289
msgid ""
"Our two crates are tightly related, so we create the procedural macro crate "
"within the directory of our `hello_macro` crate. If we change the trait "
"definition in `hello_macro`, we’ll have to change the implementation of the "
"procedural macro in `hello_macro_derive` as well. The two crates will need "
"to be published separately, and programmers using these crates will need to "
"add both as dependencies and bring them both into scope. We could instead "
"have the `hello_macro` crate use `hello_macro_derive` as a dependency and re-"
"export the procedural macro code. However, the way we’ve structured the "
"project makes it possible for programmers to use `hello_macro` even if they "
"don’t want the `derive` functionality."
msgstr ""

#: src/ch20-05-macros.md:300
msgid ""
"We need to declare the `hello_macro_derive` crate as a procedural macro "
"crate. We’ll also need functionality from the `syn` and `quote` crates, as "
"you’ll see in a moment, so we need to add them as dependencies. Add the "
"following to the _Cargo.toml_ file for `hello_macro_derive`:"
msgstr ""

#: src/ch20-05-macros.md:307
msgid ""
"```toml\n"
"[lib]\n"
"proc-macro = true\n"
"\n"
"[dependencies]\n"
"syn = \"2.0\"\n"
"quote = \"1.0\"\n"
"```"
msgstr ""

#: src/ch20-05-macros.md:318
msgid ""
"To start defining the procedural macro, place the code in Listing 20-32 into "
"your _src/lib.rs_ file for the `hello_macro_derive` crate. Note that this "
"code won’t compile until we add a definition for the `impl_hello_macro` "
"function."
msgstr ""

#: src/ch20-05-macros.md:330
msgid ""
"// Construct a representation of Rust code as a syntax tree\n"
"    // that we can manipulate.\n"
msgstr ""

#: src/ch20-05-macros.md:334
msgid "// Build the trait implementation.\n"
msgstr ""

#: src/ch20-05-macros.md:341
msgid ""
"Notice that we’ve split the code into the `hello_macro_derive` function, "
"which is responsible for parsing the `TokenStream`, and the "
"`impl_hello_macro` function, which is responsible for transforming the "
"syntax tree: this makes writing a procedural macro more convenient. The code "
"in the outer function (`hello_macro_derive` in this case) will be the same "
"for almost every procedural macro crate you see or create. The code you "
"specify in the body of the inner function (`impl_hello_macro` in this case) "
"will be different depending on your procedural macro’s purpose."
msgstr ""

#: src/ch20-05-macros.md:350
msgid ""
"We’ve introduced three new crates: `proc_macro`, [`syn`](https://crates.io/"
"crates/syn), and [`quote`](https://crates.io/crates/quote). The `proc_macro` "
"crate comes with Rust, so we didn’t need to add that to the dependencies in "
"_Cargo.toml_. The `proc_macro` crate is the compiler’s API that allows us to "
"read and manipulate Rust code from our code."
msgstr ""

#: src/ch20-05-macros.md:355
msgid ""
"The `syn` crate parses Rust code from a string into a data structure that we "
"can perform operations on. The `quote` crate turns `syn` data structures "
"back into Rust code. These crates make it much simpler to parse any sort of "
"Rust code we might want to handle: writing a full parser for Rust code is no "
"simple task."
msgstr ""

#: src/ch20-05-macros.md:361
msgid ""
"The `hello_macro_derive` function will be called when a user of our library "
"specifies `#[derive(HelloMacro)]` on a type. This is possible because we’ve "
"annotated the `hello_macro_derive` function here with `proc_macro_derive` "
"and specified the name `HelloMacro`, which matches our trait name; this is "
"the convention most procedural macros follow."
msgstr ""

#: src/ch20-05-macros.md:367
msgid ""
"The `hello_macro_derive` function first converts the `input` from a "
"`TokenStream` to a data structure that we can then interpret and perform "
"operations on. This is where `syn` comes into play. The `parse` function in "
"`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing "
"the parsed Rust code. Listing 20-33 shows the relevant parts of the "
"`DeriveInput` struct we get from parsing the `struct Pancakes;` string:"
msgstr ""

#: src/ch20-05-macros.md:381
msgid "\"Pancakes\""
msgstr ""

#: src/ch20-05-macros.md:398
msgid ""
"The fields of this struct show that the Rust code we’ve parsed is a unit "
"struct with the `ident` (identifier, meaning the name) of `Pancakes`. There "
"are more fields on this struct for describing all sorts of Rust code; check "
"the [`syn` documentation for `DeriveInput`](https://docs.rs/syn/2.0/syn/"
"struct.DeriveInput.html) for more information."
msgstr ""

#: src/ch20-05-macros.md:403
msgid ""
"Soon we’ll define the `impl_hello_macro` function, which is where we’ll "
"build the new Rust code we want to include. But before we do, note that the "
"output for our derive macro is also a `TokenStream`. The returned "
"`TokenStream` is added to the code that our crate users write, so when they "
"compile their crate, they’ll get the extra functionality that we provide in "
"the modified `TokenStream`."
msgstr ""

#: src/ch20-05-macros.md:410
msgid ""
"You might have noticed that we’re calling `unwrap` to cause the "
"`hello_macro_derive` function to panic if the call to the `syn::parse` "
"function fails here. It’s necessary for our procedural macro to panic on "
"errors because `proc_macro_derive` functions must return `TokenStream` "
"rather than `Result` to conform to the procedural macro API. We’ve "
"simplified this example by using `unwrap`; in production code, you should "
"provide more specific error messages about what went wrong by using `panic!` "
"or `expect`."
msgstr ""

#: src/ch20-05-macros.md:418
msgid ""
"Now that we have the code to turn the annotated Rust code from a "
"`TokenStream` into a `DeriveInput` instance, let’s generate the code that "
"implements the `HelloMacro` trait on the annotated type, as shown in Listing "
"20-34."
msgstr ""

#: src/ch20-05-macros.md:430
msgid "// Construct a representation of Rust code as a syntax tree\n"
msgstr ""

#: src/ch20-05-macros.md:431
msgid "// that we can manipulate\n"
msgstr ""

#: src/ch20-05-macros.md:434
msgid "// Build the trait implementation\n"
msgstr ""

#: src/ch20-05-macros.md:443
msgid "\"Hello, Macro! My name is {}!\""
msgstr ""

#: src/ch20-05-macros.md:453
msgid ""
"We get an `Ident` struct instance containing the name (identifier) of the "
"annotated type using `ast.ident`. The struct in Listing 20-33 shows that "
"when we run the `impl_hello_macro` function on the code in Listing 20-31, "
"the `ident` we get will have the `ident` field with a value of "
"`\"Pancakes\"`. Thus, the `name` variable in Listing 20-34 will contain an "
"`Ident` struct instance that, when printed, will be the string "
"`\"Pancakes\"`, the name of the struct in Listing 20-31."
msgstr ""

#: src/ch20-05-macros.md:461
msgid ""
"The `quote!` macro lets us define the Rust code that we want to return. The "
"compiler expects something different to the direct result of the `quote!` "
"macro’s execution, so we need to convert it to a `TokenStream`. We do this "
"by calling the `into` method, which consumes this intermediate "
"representation and returns a value of the required `TokenStream` type."
msgstr ""

#: src/ch20-05-macros.md:467
msgid ""
"The `quote!` macro also provides some very cool templating mechanics: we can "
"enter `#name`, and `quote!` will replace it with the value in the variable "
"`name`. You can even do some repetition similar to the way regular macros "
"work. Check out [the `quote` crate’s docs](https://docs.rs/quote) for a "
"thorough introduction."
msgstr ""

#: src/ch20-05-macros.md:472
msgid ""
"We want our procedural macro to generate an implementation of our "
"`HelloMacro` trait for the type the user annotated, which we can get by "
"using `#name`. The trait implementation has the one function `hello_macro`, "
"whose body contains the functionality we want to provide: printing `Hello, "
"Macro! My name is` and then the name of the annotated type."
msgstr ""

#: src/ch20-05-macros.md:478
msgid ""
"The `stringify!` macro used here is built into Rust. It takes a Rust "
"expression, such as `1 + 2`, and at compile time turns the expression into a "
"string literal, such as `\"1 + 2\"`. This is different than `format!` or "
"`println!`, macros which evaluate the expression and then turn the result "
"into a `String`. There is a possibility that the `#name` input might be an "
"expression to print literally, so we use `stringify!`. Using `stringify!` "
"also saves an allocation by converting `#name` to a string literal at "
"compile time."
msgstr ""

#: src/ch20-05-macros.md:486
msgid ""
"At this point, `cargo build` should complete successfully in both "
"`hello_macro` and `hello_macro_derive`. Let’s hook up these crates to the "
"code in Listing 20-31 to see the procedural macro in action! Create a new "
"binary project in your _projects_ directory using `cargo new pancakes`. We "
"need to add `hello_macro` and `hello_macro_derive` as dependencies in the "
"`pancakes` crate’s _Cargo.toml_. If you’re publishing your versions of "
"`hello_macro` and `hello_macro_derive` to [crates.io](https://crates.io/), "
"they would be regular dependencies; if not, you can specify them as `path` "
"dependencies as follows:"
msgstr ""

#: src/ch20-05-macros.md:495
msgid ""
"```toml\n"
"hello_macro = { path = \"../hello_macro\" }\n"
"hello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n"
"```"
msgstr ""

#: src/ch20-05-macros.md:500
msgid ""
"Put the code in Listing 20-31 into _src/main.rs_, and run `cargo run`: it "
"should print `Hello, Macro! My name is Pancakes!` The implementation of the "
"`HelloMacro` trait from the procedural macro was included without the "
"`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added "
"the trait implementation."
msgstr ""

#: src/ch20-05-macros.md:506
msgid ""
"Next, let’s explore how the other kinds of procedural macros differ from "
"custom derive macros."
msgstr ""

#: src/ch20-05-macros.md:509
msgid "Attribute-Like macros"
msgstr ""

#: src/ch20-05-macros.md:511
msgid ""
"Attribute-like macros are similar to custom derive macros, but instead of "
"generating code for the `derive` attribute, they allow you to create new "
"attributes. They’re also more flexible: `derive` only works for structs and "
"enums; attributes can be applied to other items as well, such as functions. "
"Here’s an example of using an attribute-like macro: say you have an "
"attribute named `route` that annotates functions when using a web "
"application framework:"
msgstr ""

#: src/ch20-05-macros.md:519
msgid "\"/\""
msgstr ""

#: src/ch20-05-macros.md:523
msgid ""
"This `#[route]` attribute would be defined by the framework as a procedural "
"macro. The signature of the macro definition function would look like this:"
msgstr ""

#: src/ch20-05-macros.md:531
msgid ""
"Here, we have two parameters of type `TokenStream`. The first is for the "
"contents of the attribute: the `GET, \"/\"` part. The second is the body of "
"the item the attribute is attached to: in this case, `fn index() {}` and the "
"rest of the function’s body."
msgstr ""

#: src/ch20-05-macros.md:536
msgid ""
"Other than that, attribute-like macros work the same way as custom derive "
"macros: you create a crate with the `proc-macro` crate type and implement a "
"function that generates the code you want!"
msgstr ""

#: src/ch20-05-macros.md:540
msgid "Function-Like macros"
msgstr ""

#: src/ch20-05-macros.md:542
msgid ""
"Function-like macros define macros that look like function calls. Similarly "
"to `macro_rules!` macros, they’re more flexible than functions; for example, "
"they can take an unknown number of arguments. However, `macro_rules!` macros "
"can only be defined using the match-like syntax we discussed in "
"[“Declarative Macros with `macro_rules!` for General Metaprogramming”]"
"(#declarative-macros-with-macro_rules-for-general-metaprogramming)<!-- "
"ignore --> earlier. Function-like macros take a `TokenStream` parameter and "
"their definition manipulates that `TokenStream` using Rust code as the other "
"two types of procedural macros do. An example of a function-like macro is an "
"`sql!` macro that might be called like so:"
msgstr ""

#: src/ch20-05-macros.md:556
msgid ""
"This macro would parse the SQL statement inside it and check that it’s "
"syntactically correct, which is much more complex processing than a "
"`macro_rules!` macro can do. The `sql!` macro would be defined like this:"
msgstr ""

#: src/ch20-05-macros.md:565
msgid ""
"This definition is similar to the custom derive macro’s signature: we "
"receive the tokens that are inside the parentheses and return the code we "
"wanted to generate."
msgstr ""

#: src/ch20-05-macros.md:571
msgid ""
"Whew! Now you have some Rust features in your toolbox that you likely won’t "
"use often, but you’ll know they’re available in very particular "
"circumstances. We’ve introduced several complex topics so that when you "
"encounter them in error message suggestions or in other peoples’ code, "
"you’ll be able to recognize these concepts and syntax. Use this chapter as a "
"reference to guide you to solutions."
msgstr ""

#: src/ch20-05-macros.md:578
msgid ""
"Next, we’ll put everything we’ve discussed throughout the book into practice "
"and do one more project!"
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:3
msgid ""
"It’s been a long journey, but we’ve reached the end of the book. In this "
"chapter, we’ll build one more project together to demonstrate some of the "
"concepts we covered in the final chapters, as well as recap some earlier "
"lessons."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:8
msgid ""
"For our final project, we’ll make a web server that says “hello” and looks "
"like Figure 21-1 in a web browser."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:11
msgid "![hello from rust](img/trpl21-01.png)"
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:13
msgid "<span class=\"caption\">Figure 21-1: Our final shared project</span>"
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:15
msgid "Here is our plan for building the web server:"
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:17
msgid "Learn a bit about TCP and HTTP."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:18
msgid "Listen for TCP connections on a socket."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:19
msgid "Parse a small number of HTTP requests."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:20
msgid "Create a proper HTTP response."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:21
msgid "Improve the throughput of our server with a thread pool."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:23
msgid ""
"Before we get started, we should mention two details: First, the method "
"we’ll use won’t be the best way to build a web server with Rust. Community "
"members have published a number of production-ready crates available on "
"[crates.io](https://crates.io/) that provide more complete web server and "
"thread pool implementations than we’ll build. However, our intention in this "
"chapter is to help you learn, not to take the easy route. Because Rust is a "
"systems programming language, we can choose the level of abstraction we want "
"to work with and can go to a lower level than is possible or practical in "
"other languages."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:33
msgid ""
"Second, we will not be using async and await here. Building a thread pool is "
"a big enough challenge on its own, without adding in building an async "
"runtime! However, we will note how async and await might be applicable to "
"some of the same problems we will see in this chapter. Ultimately, as we "
"noted back in Chapter 17, many async runtimes use thread pools for managing "
"their work."
msgstr ""

#: src/ch21-00-final-project-a-web-server.md:39
msgid ""
"We’ll therefore write the basic HTTP server and thread pool manually so you "
"can learn the general ideas and techniques behind the crates you might use "
"in the future."
msgstr ""

#: src/ch21-01-single-threaded.md:3
msgid ""
"We’ll start by getting a single-threaded web server working. Before we "
"begin, let’s look at a quick overview of the protocols involved in building "
"web servers. The details of these protocols are beyond the scope of this "
"book, but a brief overview will give you the information you need."
msgstr ""

#: src/ch21-01-single-threaded.md:8
msgid ""
"The two main protocols involved in web servers are _Hypertext Transfer "
"Protocol_ _(HTTP)_ and _Transmission Control Protocol_ _(TCP)_. Both "
"protocols are _request-response_ protocols, meaning a _client_ initiates "
"requests and a _server_ listens to the requests and provides a response to "
"the client. The contents of those requests and responses are defined by the "
"protocols."
msgstr ""

#: src/ch21-01-single-threaded.md:14
msgid ""
"TCP is the lower-level protocol that describes the details of how "
"information gets from one server to another but doesn’t specify what that "
"information is. HTTP builds on top of TCP by defining the contents of the "
"requests and responses. It’s technically possible to use HTTP with other "
"protocols, but in the vast majority of cases, HTTP sends its data over TCP. "
"We’ll work with the raw bytes of TCP and HTTP requests and responses."
msgstr ""

#: src/ch21-01-single-threaded.md:21
msgid "Listening to the TCP Connection"
msgstr ""

#: src/ch21-01-single-threaded.md:23
msgid ""
"Our web server needs to listen to a TCP connection, so that’s the first part "
"we’ll work on. The standard library offers a `std::net` module that lets us "
"do this. Let’s make a new project in the usual fashion:"
msgstr ""

#: src/ch21-01-single-threaded.md:33
msgid ""
"Now enter the code in Listing 21-1 in _src/main.rs_ to start. This code will "
"listen at the local address `127.0.0.1:7878` for incoming TCP streams. When "
"it gets an incoming stream, it will print `Connection established!`."
msgstr ""

#: src/ch21-01-single-threaded.md:43 src/ch21-01-single-threaded.md:148
#: src/ch21-01-single-threaded.md:317 src/ch21-01-single-threaded.md:396
#: src/ch21-01-single-threaded.md:467 src/ch21-01-single-threaded.md:534
#: src/ch21-01-single-threaded.md:623 src/ch21-02-multithreaded.md:31
#: src/ch21-02-multithreaded.md:165 src/ch21-02-multithreaded.md:235
#: src/ch21-02-multithreaded.md:337
#: src/ch21-03-graceful-shutdown-and-cleanup.md:473
#: src/ch21-03-graceful-shutdown-and-cleanup.md:588
msgid "\"127.0.0.1:7878\""
msgstr ""

#: src/ch21-01-single-threaded.md:48
msgid "\"Connection established!\""
msgstr ""

#: src/ch21-01-single-threaded.md:55
msgid ""
"Using `TcpListener`, we can listen for TCP connections at the address "
"`127.0.0.1:7878`. In the address, the section before the colon is an IP "
"address representing your computer (this is the same on every computer and "
"doesn’t represent the authors’ computer specifically), and `7878` is the "
"port. We’ve chosen this port for two reasons: HTTP isn’t normally accepted "
"on this port so our server is unlikely to conflict with any other web server "
"you might have running on your machine, and 7878 is _rust_ typed on a "
"telephone."
msgstr ""

#: src/ch21-01-single-threaded.md:63
msgid ""
"The `bind` function in this scenario works like the `new` function in that "
"it will return a new `TcpListener` instance. The function is called `bind` "
"because, in networking, connecting to a port to listen to is known as "
"“binding to a port.”"
msgstr ""

#: src/ch21-01-single-threaded.md:68
msgid ""
"The `bind` function returns a `Result<T, E>`, which indicates that it’s "
"possible for binding to fail. For example, connecting to port 80 requires "
"administrator privileges (non-administrators can listen only on ports higher "
"than 1023), so if we tried to connect to port 80 without being an "
"administrator, binding wouldn’t work. Binding also wouldn’t work, for "
"example, if we ran two instances of our program and so had two programs "
"listening to the same port. Because we’re writing a basic server just for "
"learning purposes, we won’t worry about handling these kinds of errors; "
"instead, we use `unwrap` to stop the program if errors happen."
msgstr ""

#: src/ch21-01-single-threaded.md:78
msgid ""
"The `incoming` method on `TcpListener` returns an iterator that gives us a "
"sequence of streams (more specifically, streams of type `TcpStream`). A "
"single _stream_ represents an open connection between the client and the "
"server. A _connection_ is the name for the full request and response process "
"in which a client connects to the server, the server generates a response, "
"and the server closes the connection. As such, we will read from the "
"`TcpStream` to see what the client sent and then write our response to the "
"stream to send data back to the client. Overall, this `for` loop will "
"process each connection in turn and produce a series of streams for us to "
"handle."
msgstr ""

#: src/ch21-01-single-threaded.md:88
msgid ""
"For now, our handling of the stream consists of calling `unwrap` to "
"terminate our program if the stream has any errors; if there aren’t any "
"errors, the program prints a message. We’ll add more functionality for the "
"success case in the next listing. The reason we might receive errors from "
"the `incoming` method when a client connects to the server is that we’re not "
"actually iterating over connections. Instead, we’re iterating over "
"_connection attempts_. The connection might not be successful for a number "
"of reasons, many of them operating system specific. For example, many "
"operating systems have a limit to the number of simultaneous open "
"connections they can support; new connection attempts beyond that number "
"will produce an error until some of the open connections are closed."
msgstr ""

#: src/ch21-01-single-threaded.md:100
msgid ""
"Let’s try running this code! Invoke `cargo run` in the terminal and then "
"load _127.0.0.1:7878_ in a web browser. The browser should show an error "
"message like “Connection reset” because the server isn’t currently sending "
"back any data. But when you look at your terminal, you should see several "
"messages that were printed when the browser connected to the server!"
msgstr ""

#: src/ch21-01-single-threaded.md:113
msgid ""
"Sometimes you’ll see multiple messages printed for one browser request; the "
"reason might be that the browser is making a request for the page as well as "
"a request for other resources, like the _favicon.ico_ icon that appears in "
"the browser tab."
msgstr ""

#: src/ch21-01-single-threaded.md:118
msgid ""
"It could also be that the browser is trying to connect to the server "
"multiple times because the server isn’t responding with any data. When "
"`stream` goes out of scope and is dropped at the end of the loop, the "
"connection is closed as part of the `drop` implementation. Browsers "
"sometimes deal with closed connections by retrying, because the problem "
"might be temporary. The important factor is that we’ve successfully gotten a "
"handle to a TCP connection!"
msgstr ""

#: src/ch21-01-single-threaded.md:125
msgid ""
"Remember to stop the program by pressing <kbd>ctrl</kbd>\\-<kbd>c</kbd> when "
"you’re done running a particular version of the code. Then restart the "
"program by invoking the `cargo run` command after you’ve made each set of "
"code changes to make sure you’re running the newest code."
msgstr ""

#: src/ch21-01-single-threaded.md:130
msgid "Reading the Request"
msgstr ""

#: src/ch21-01-single-threaded.md:132
msgid ""
"Let’s implement the functionality to read the request from the browser! To "
"separate the concerns of first getting a connection and then taking some "
"action with the connection, we’ll start a new function for processing "
"connections. In this new `handle_connection` function, we’ll read data from "
"the TCP stream and print it so we can see the data being sent from the "
"browser. Change the code to look like Listing 21-2."
msgstr ""

#: src/ch21-01-single-threaded.md:165
msgid "\"Request: {http_request:#?}\""
msgstr ""

#: src/ch21-01-single-threaded.md:171
msgid ""
"We bring `std::io::prelude` and `std::io::BufReader` into scope to get "
"access to traits and types that let us read from and write to the stream. In "
"the `for` loop in the `main` function, instead of printing a message that "
"says we made a connection, we now call the new `handle_connection` function "
"and pass the `stream` to it."
msgstr ""

#: src/ch21-01-single-threaded.md:177
msgid ""
"In the `handle_connection` function, we create a new `BufReader` instance "
"that wraps a reference to the `stream`. The `BufReader` adds buffering by "
"managing calls to the `std::io::Read` trait methods for us."
msgstr ""

#: src/ch21-01-single-threaded.md:181
msgid ""
"We create a variable named `http_request` to collect the lines of the "
"request the browser sends to our server. We indicate that we want to collect "
"these lines in a vector by adding the `Vec<_>` type annotation."
msgstr ""

#: src/ch21-01-single-threaded.md:185
msgid ""
"`BufReader` implements the `std::io::BufRead` trait, which provides the "
"`lines` method. The `lines` method returns an iterator of `Result<String, "
"std::io::Error>` by splitting the stream of data whenever it sees a newline "
"byte. To get each `String`, we map and `unwrap` each `Result`. The `Result` "
"might be an error if the data isn’t valid UTF-8 or if there was a problem "
"reading from the stream. Again, a production program should handle these "
"errors more gracefully, but we’re choosing to stop the program in the error "
"case for simplicity."
msgstr ""

#: src/ch21-01-single-threaded.md:194
msgid ""
"The browser signals the end of an HTTP request by sending two newline "
"characters in a row, so to get one request from the stream, we take lines "
"until we get a line that is the empty string. Once we’ve collected the lines "
"into the vector, we’re printing them out using pretty debug formatting so we "
"can take a look at the instructions the web browser is sending to our server."
msgstr ""

#: src/ch21-01-single-threaded.md:200
msgid ""
"Let’s try this code! Start the program and make a request in a web browser "
"again. Note that we’ll still get an error page in the browser, but our "
"program’s output in the terminal will now look similar to this:"
msgstr ""

#: src/ch21-01-single-threaded.md:204
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n"
"     Running `target/debug/hello`\n"
"Request: [\n"
"    \"GET / HTTP/1.1\",\n"
"    \"Host: 127.0.0.1:7878\",\n"
"    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) "
"Gecko/20100101 Firefox/99.0\",\n"
"    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/"
"avif,image/webp,*/*;q=0.8\",\n"
"    \"Accept-Language: en-US,en;q=0.5\",\n"
"    \"Accept-Encoding: gzip, deflate, br\",\n"
"    \"DNT: 1\",\n"
"    \"Connection: keep-alive\",\n"
"    \"Upgrade-Insecure-Requests: 1\",\n"
"    \"Sec-Fetch-Dest: document\",\n"
"    \"Sec-Fetch-Mode: navigate\",\n"
"    \"Sec-Fetch-Site: none\",\n"
"    \"Sec-Fetch-User: ?1\",\n"
"    \"Cache-Control: max-age=0\",\n"
"]\n"
"```"
msgstr ""

#: src/ch21-01-single-threaded.md:227
msgid ""
"Depending on your browser, you might get slightly different output. Now that "
"we’re printing the request data, we can see why we get multiple connections "
"from one browser request by looking at the path after `GET` in the first "
"line of the request. If the repeated connections are all requesting _/_, we "
"know the browser is trying to fetch _/_ repeatedly because it’s not getting "
"a response from our program."
msgstr ""

#: src/ch21-01-single-threaded.md:234
msgid ""
"Let’s break down this request data to understand what the browser is asking "
"of our program."
msgstr ""

#: src/ch21-01-single-threaded.md:237
msgid "A Closer Look at an HTTP Request"
msgstr ""

#: src/ch21-01-single-threaded.md:239
msgid "HTTP is a text-based protocol, and a request takes this format:"
msgstr ""

#: src/ch21-01-single-threaded.md:247
msgid ""
"The first line is the _request line_ that holds information about what the "
"client is requesting. The first part of the request line indicates the "
"_method_ being used, such as `GET` or `POST`, which describes how the client "
"is making this request. Our client used a `GET` request, which means it is "
"asking for information."
msgstr ""

#: src/ch21-01-single-threaded.md:253
msgid ""
"The next part of the request line is _/_, which indicates the _uniform "
"resource identifier_ _(URI)_ the client is requesting: a URI is almost, but "
"not quite, the same as a _uniform resource locator_ _(URL)_. The difference "
"between URIs and URLs isn’t important for our purposes in this chapter, but "
"the HTTP spec uses the term URI, so we can just mentally substitute _URL_ "
"for _URI_ here."
msgstr ""

#: src/ch21-01-single-threaded.md:259
msgid ""
"The last part is the HTTP version the client uses, and then the request line "
"ends in a CRLF sequence. (CRLF stands for _carriage return_ and _line feed_, "
"which are terms from the typewriter days!) The CRLF sequence can also be "
"written as `\\r\\n`, where `\\r` is a carriage return and `\\n` is a line "
"feed. The _CRLF sequence_ separates the request line from the rest of the "
"request data. Note that when the CRLF is printed, we see a new line start "
"rather than `\\r\\n`."
msgstr ""

#: src/ch21-01-single-threaded.md:266
msgid ""
"Looking at the request line data we received from running our program so "
"far, we see that `GET` is the method, _/_ is the request URI, and `HTTP/1.1` "
"is the version."
msgstr ""

#: src/ch21-01-single-threaded.md:270
msgid ""
"After the request line, the remaining lines starting from `Host:` onward are "
"headers. `GET` requests have no body."
msgstr ""

#: src/ch21-01-single-threaded.md:273
msgid ""
"Try making a request from a different browser or asking for a different "
"address, such as _127.0.0.1:7878/test_, to see how the request data changes."
msgstr ""

#: src/ch21-01-single-threaded.md:276
msgid ""
"Now that we know what the browser is asking for, let’s send back some data!"
msgstr ""

#: src/ch21-01-single-threaded.md:278
msgid "Writing a Response"
msgstr ""

#: src/ch21-01-single-threaded.md:280
msgid ""
"We’re going to implement sending data in response to a client request. "
"Responses have the following format:"
msgstr ""

#: src/ch21-01-single-threaded.md:289
msgid ""
"The first line is a _status line_ that contains the HTTP version used in the "
"response, a numeric status code that summarizes the result of the request, "
"and a reason phrase that provides a text description of the status code. "
"After the CRLF sequence are any headers, another CRLF sequence, and the body "
"of the response."
msgstr ""

#: src/ch21-01-single-threaded.md:295
msgid ""
"Here is an example response that uses HTTP version 1.1, and has a status "
"code of 200, an OK reason phrase, no headers, and no body:"
msgstr ""

#: src/ch21-01-single-threaded.md:302
msgid ""
"The status code 200 is the standard success response. The text is a tiny "
"successful HTTP response. Let’s write this to the stream as our response to "
"a successful request! From the `handle_connection` function, remove the "
"`println!` that was printing the request data and replace it with the code "
"in Listing 21-3."
msgstr ""

#: src/ch21-01-single-threaded.md:334
msgid "\"HTTP/1.1 200 OK\\r\\n\\r\\n\""
msgstr ""

#: src/ch21-01-single-threaded.md:342
msgid ""
"The first new line defines the `response` variable that holds the success "
"message’s data. Then we call `as_bytes` on our `response` to convert the "
"string data to bytes. The `write_all` method on `stream` takes a `&[u8]` and "
"sends those bytes directly down the connection. Because the `write_all` "
"operation could fail, we use `unwrap` on any error result as before. Again, "
"in a real application you would add error handling here."
msgstr ""

#: src/ch21-01-single-threaded.md:349
msgid ""
"With these changes, let’s run our code and make a request. We’re no longer "
"printing any data to the terminal, so we won’t see any output other than the "
"output from Cargo. When you load _127.0.0.1:7878_ in a web browser, you "
"should get a blank page instead of an error. You’ve just handcoded receiving "
"an HTTP request and sending a response!"
msgstr ""

#: src/ch21-01-single-threaded.md:355
msgid "Returning Real HTML"
msgstr ""

#: src/ch21-01-single-threaded.md:357
msgid ""
"Let’s implement the functionality for returning more than a blank page. "
"Create the new file _hello.html_ in the root of your project directory, not "
"in the _src_ directory. You can input any HTML you want; Listing 21-4 shows "
"one possibility."
msgstr ""

#: src/ch21-01-single-threaded.md:366 src/ch21-01-single-threaded.md:584
msgid "\"en\""
msgstr ""

#: src/ch21-01-single-threaded.md:368 src/ch21-01-single-threaded.md:586
msgid "\"utf-8\""
msgstr ""

#: src/ch21-01-single-threaded.md:380
msgid ""
"This is a minimal HTML5 document with a heading and some text. To return "
"this from the server when a request is received, we’ll modify "
"`handle_connection` as shown in Listing 21-5 to read the HTML file, add it "
"to the response as a body, and send it."
msgstr ""

#: src/ch21-01-single-threaded.md:413 src/ch21-01-single-threaded.md:482
#: src/ch21-01-single-threaded.md:548 src/ch21-01-single-threaded.md:639
#: src/ch21-02-multithreaded.md:47 src/ch21-02-multithreaded.md:50
#: src/ch21-02-multithreaded.md:181 src/ch21-02-multithreaded.md:184
#: src/ch21-02-multithreaded.md:252 src/ch21-02-multithreaded.md:255
#: src/ch21-02-multithreaded.md:354 src/ch21-02-multithreaded.md:357
#: src/ch21-03-graceful-shutdown-and-cleanup.md:492
#: src/ch21-03-graceful-shutdown-and-cleanup.md:495
#: src/ch21-03-graceful-shutdown-and-cleanup.md:607
#: src/ch21-03-graceful-shutdown-and-cleanup.md:610
msgid "\"HTTP/1.1 200 OK\""
msgstr ""

#: src/ch21-01-single-threaded.md:414 src/ch21-01-single-threaded.md:483
#: src/ch21-01-single-threaded.md:549 src/ch21-01-single-threaded.md:639
#: src/ch21-02-multithreaded.md:47 src/ch21-02-multithreaded.md:50
#: src/ch21-02-multithreaded.md:181 src/ch21-02-multithreaded.md:184
#: src/ch21-02-multithreaded.md:252 src/ch21-02-multithreaded.md:255
#: src/ch21-02-multithreaded.md:354 src/ch21-02-multithreaded.md:357
#: src/ch21-03-graceful-shutdown-and-cleanup.md:492
#: src/ch21-03-graceful-shutdown-and-cleanup.md:495
#: src/ch21-03-graceful-shutdown-and-cleanup.md:607
#: src/ch21-03-graceful-shutdown-and-cleanup.md:610
msgid "\"hello.html\""
msgstr ""

#: src/ch21-01-single-threaded.md:418 src/ch21-01-single-threaded.md:487
#: src/ch21-01-single-threaded.md:553 src/ch21-01-single-threaded.md:564
#: src/ch21-01-single-threaded.md:648 src/ch21-02-multithreaded.md:61
#: src/ch21-02-multithreaded.md:193 src/ch21-02-multithreaded.md:264
#: src/ch21-02-multithreaded.md:366
#: src/ch21-03-graceful-shutdown-and-cleanup.md:504
#: src/ch21-03-graceful-shutdown-and-cleanup.md:619
msgid "\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\""
msgstr ""

#: src/ch21-01-single-threaded.md:426
msgid ""
"We’ve added `fs` to the `use` statement to bring the standard library’s "
"filesystem module into scope. The code for reading the contents of a file to "
"a string should look familiar; we used it when we read the contents of a "
"file for our I/O project in Listing 12-4."
msgstr ""

#: src/ch21-01-single-threaded.md:431
msgid ""
"Next, we use `format!` to add the file’s contents as the body of the success "
"response. To ensure a valid HTTP response, we add the `Content-Length` "
"header which is set to the size of our response body, in this case the size "
"of `hello.html`."
msgstr ""

#: src/ch21-01-single-threaded.md:436
msgid ""
"Run this code with `cargo run` and load _127.0.0.1:7878_ in your browser; "
"you should see your HTML rendered!"
msgstr ""

#: src/ch21-01-single-threaded.md:439
msgid ""
"Currently, we’re ignoring the request data in `http_request` and just "
"sending back the contents of the HTML file unconditionally. That means if "
"you try requesting _127.0.0.1:7878/something-else_ in your browser, you’ll "
"still get back this same HTML response. At the moment, our server is very "
"limited and does not do what most web servers do. We want to customize our "
"responses depending on the request and only send back the HTML file for a "
"well-formed request to _/_."
msgstr ""

#: src/ch21-01-single-threaded.md:447
msgid "Validating the Request and Selectively Responding"
msgstr ""

#: src/ch21-01-single-threaded.md:449
msgid ""
"Right now, our web server will return the HTML in the file no matter what "
"the client requested. Let’s add functionality to check that the browser is "
"requesting _/_ before returning the HTML file and return an error if the "
"browser requests anything else. For this we need to modify "
"`handle_connection`, as shown in Listing 21-6. This new code checks the "
"content of the request received against what we know a request for _/_ looks "
"like and adds `if` and `else` blocks to treat requests differently."
msgstr ""

#: src/ch21-01-single-threaded.md:481 src/ch21-01-single-threaded.md:547
#: src/ch21-01-single-threaded.md:638 src/ch21-02-multithreaded.md:47
#: src/ch21-02-multithreaded.md:181 src/ch21-02-multithreaded.md:252
#: src/ch21-02-multithreaded.md:354
#: src/ch21-03-graceful-shutdown-and-cleanup.md:492
#: src/ch21-03-graceful-shutdown-and-cleanup.md:607
msgid "\"GET / HTTP/1.1\""
msgstr ""

#: src/ch21-01-single-threaded.md:492
msgid "// some other request\n"
msgstr ""

#: src/ch21-01-single-threaded.md:499
msgid ""
"We’re only going to be looking at the first line of the HTTP request, so "
"rather than reading the entire request into a vector, we’re calling `next` "
"to get the first item from the iterator. The first `unwrap` takes care of "
"the `Option` and stops the program if the iterator has no items. The second "
"`unwrap` handles the `Result` and has the same effect as the `unwrap` that "
"was in the `map` added in Listing 21-2."
msgstr ""

#: src/ch21-01-single-threaded.md:506
msgid ""
"Next, we check the `request_line` to see if it equals the request line of a "
"GET request to the _/_ path. If it does, the `if` block returns the contents "
"of our HTML file."
msgstr ""

#: src/ch21-01-single-threaded.md:510
msgid ""
"If the `request_line` does _not_ equal the GET request to the _/_ path, it "
"means we’ve received some other request. We’ll add code to the `else` block "
"in a moment to respond to all other requests."
msgstr ""

#: src/ch21-01-single-threaded.md:514
msgid ""
"Run this code now and request _127.0.0.1:7878_; you should get the HTML in "
"_hello.html_. If you make any other request, such as _127.0.0.1:7878/"
"something-else_, you’ll get a connection error like those you saw when "
"running the code in Listing 21-1 and Listing 21-2."
msgstr ""

#: src/ch21-01-single-threaded.md:519
msgid ""
"Now let’s add the code in Listing 21-7 to the `else` block to return a "
"response with the status code 404, which signals that the content for the "
"request was not found. We’ll also return some HTML for a page to render in "
"the browser indicating the response to the end user."
msgstr ""

#: src/ch21-01-single-threaded.md:559 src/ch21-01-single-threaded.md:641
#: src/ch21-02-multithreaded.md:52 src/ch21-02-multithreaded.md:186
#: src/ch21-02-multithreaded.md:257 src/ch21-02-multithreaded.md:359
#: src/ch21-03-graceful-shutdown-and-cleanup.md:497
#: src/ch21-03-graceful-shutdown-and-cleanup.md:612
msgid "\"HTTP/1.1 404 NOT FOUND\""
msgstr ""

#: src/ch21-01-single-threaded.md:560 src/ch21-01-single-threaded.md:641
#: src/ch21-02-multithreaded.md:52 src/ch21-02-multithreaded.md:186
#: src/ch21-02-multithreaded.md:257 src/ch21-02-multithreaded.md:359
#: src/ch21-03-graceful-shutdown-and-cleanup.md:497
#: src/ch21-03-graceful-shutdown-and-cleanup.md:612
msgid "\"404.html\""
msgstr ""

#: src/ch21-01-single-threaded.md:574
msgid ""
"Here, our response has a status line with status code 404 and the reason "
"phrase `NOT FOUND`. The body of the response will be the HTML in the file "
"_404.html_. You’ll need to create a _404.html_ file next to _hello.html_ for "
"the error page; again feel free to use any HTML you want or use the example "
"HTML in Listing 21-8."
msgstr ""

#: src/ch21-01-single-threaded.md:598
msgid ""
"With these changes, run your server again. Requesting _127.0.0.1:7878_ "
"should return the contents of _hello.html_, and any other request, like "
"_127.0.0.1:7878/foo_, should return the error HTML from _404.html_."
msgstr ""

#: src/ch21-01-single-threaded.md:602
msgid "A Touch of Refactoring"
msgstr ""

#: src/ch21-01-single-threaded.md:604
msgid ""
"At the moment, the `if` and `else` blocks have a lot of repetition: they’re "
"both reading files and writing the contents of the files to the stream. The "
"only differences are the status line and the filename. Let’s make the code "
"more concise by pulling out those differences into separate `if` and `else` "
"lines that will assign the values of the status line and the filename to "
"variables; we can then use those variables unconditionally in the code to "
"read the file and write the response. Listing 21-9 shows the resultant code "
"after replacing the large `if` and `else` blocks."
msgstr ""

#: src/ch21-01-single-threaded.md:656
msgid ""
"Now the `if` and `else` blocks only return the appropriate values for the "
"status line and filename in a tuple; we then use destructuring to assign "
"these two values to `status_line` and `filename` using a pattern in the "
"`let` statement, as discussed in Chapter 19."
msgstr ""

#: src/ch21-01-single-threaded.md:661
msgid ""
"The previously duplicated code is now outside the `if` and `else` blocks and "
"uses the `status_line` and `filename` variables. This makes it easier to see "
"the difference between the two cases, and it means we have only one place to "
"update the code if we want to change how the file reading and response "
"writing work. The behavior of the code in Listing 21-9 will be the same as "
"that in Listing 21-7."
msgstr ""

#: src/ch21-01-single-threaded.md:668
msgid ""
"Awesome! We now have a simple web server in approximately 40 lines of Rust "
"code that responds to one request with a page of content and responds to all "
"other requests with a 404 response."
msgstr ""

#: src/ch21-01-single-threaded.md:672
msgid ""
"Currently, our server runs in a single thread, meaning it can only serve one "
"request at a time. Let’s examine how that can be a problem by simulating "
"some slow requests. Then we’ll fix it so our server can handle multiple "
"requests at once."
msgstr ""

#: src/ch21-02-multithreaded.md:3
msgid ""
"Right now, the server will process each request in turn, meaning it won’t "
"process a second connection until the first is finished processing. If the "
"server received more and more requests, this serial execution would be less "
"and less optimal. If the server receives a request that takes a long time to "
"process, subsequent requests will have to wait until the long request is "
"finished, even if the new requests can be processed quickly. We’ll need to "
"fix this, but first we’ll look at the problem in action."
msgstr ""

#: src/ch21-02-multithreaded.md:11
msgid "Simulating a Slow Request in the Current Server Implementation"
msgstr ""

#: src/ch21-02-multithreaded.md:13
msgid ""
"We’ll look at how a slow-processing request can affect other requests made "
"to our current server implementation. Listing 21-10 implements handling a "
"request to _/sleep_ with a simulated slow response that will cause the "
"server to sleep for five seconds before responding."
msgstr ""

#: src/ch21-02-multithreaded.md:48 src/ch21-02-multithreaded.md:182
#: src/ch21-02-multithreaded.md:253 src/ch21-02-multithreaded.md:355
#: src/ch21-03-graceful-shutdown-and-cleanup.md:493
#: src/ch21-03-graceful-shutdown-and-cleanup.md:608
msgid "\"GET /sleep HTTP/1.1\""
msgstr ""

#: src/ch21-02-multithreaded.md:69
msgid ""
"We switched from `if` to `match` now that we have three cases. We need to "
"explicitly match on a slice of `request_line` to pattern match against the "
"string literal values; `match` doesn’t do automatic referencing and "
"dereferencing, like the equality method does."
msgstr ""

#: src/ch21-02-multithreaded.md:74
msgid ""
"The first arm is the same as the `if` block from Listing 21-9. The second "
"arm matches a request to _/sleep_. When that request is received, the server "
"will sleep for five seconds before rendering the successful HTML page. The "
"third arm is the same as the `else` block from Listing 21-9."
msgstr ""

#: src/ch21-02-multithreaded.md:79
msgid ""
"You can see how primitive our server is: real libraries would handle the "
"recognition of multiple requests in a much less verbose way!"
msgstr ""

#: src/ch21-02-multithreaded.md:82
msgid ""
"Start the server using `cargo run`. Then open two browser windows: one for "
"_http://127.0.0.1:7878/_ and the other for _http://127.0.0.1:7878/sleep_. If "
"you enter the _/_ URI a few times, as before, you’ll see it respond quickly. "
"But if you enter _/sleep_ and then load _/_, you’ll see that _/_ waits until "
"`sleep` has slept for its full five seconds before loading."
msgstr ""

#: src/ch21-02-multithreaded.md:88
msgid ""
"There are multiple techniques we could use to avoid requests backing up "
"behind a slow request, including using async as we did Chapter 17; the one "
"we’ll implement is a thread pool."
msgstr ""

#: src/ch21-02-multithreaded.md:92
msgid "Improving Throughput with a Thread Pool"
msgstr ""

#: src/ch21-02-multithreaded.md:94
msgid ""
"A _thread pool_ is a group of spawned threads that are waiting and ready to "
"handle a task. When the program receives a new task, it assigns one of the "
"threads in the pool to the task, and that thread will process the task. The "
"remaining threads in the pool are available to handle any other tasks that "
"come in while the first thread is processing. When the first thread is done "
"processing its task, it’s returned to the pool of idle threads, ready to "
"handle a new task. A thread pool allows you to process connections "
"concurrently, increasing the throughput of your server."
msgstr ""

#: src/ch21-02-multithreaded.md:103
msgid ""
"We’ll limit the number of threads in the pool to a small number to protect "
"us from DoS attacks; if we had our program create a new thread for each "
"request as it came in, someone making 10 million requests to our server "
"could create havoc by using up all our server’s resources and grinding the "
"processing of requests to a halt."
msgstr ""

#: src/ch21-02-multithreaded.md:109
msgid ""
"Rather than spawning unlimited threads, then, we’ll have a fixed number of "
"threads waiting in the pool. Requests that come in are sent to the pool for "
"processing. The pool will maintain a queue of incoming requests. Each of the "
"threads in the pool will pop off a request from this queue, handle the "
"request, and then ask the queue for another request. With this design, we "
"can process up to _`N`_ requests concurrently, where _`N`_ is the number of "
"threads. If each thread is responding to a long-running request, subsequent "
"requests can still back up in the queue, but we’ve increased the number of "
"long-running requests we can handle before reaching that point."
msgstr ""

#: src/ch21-02-multithreaded.md:119
msgid ""
"This technique is just one of many ways to improve the throughput of a web "
"server. Other options you might explore are the fork/join model, the single-"
"threaded async I/O model, and the multi-threaded async I/O model. If you’re "
"interested in this topic, you can read more about other solutions and try to "
"implement them; with a low-level language like Rust, all of these options "
"are possible."
msgstr ""

#: src/ch21-02-multithreaded.md:126
msgid ""
"Before we begin implementing a thread pool, let’s talk about what using the "
"pool should look like. When you’re trying to design code, writing the client "
"interface first can help guide your design. Write the API of the code so "
"it’s structured in the way you want to call it; then implement the "
"functionality within that structure rather than implementing the "
"functionality and then designing the public API."
msgstr ""

#: src/ch21-02-multithreaded.md:133
msgid ""
"Similar to how we used test-driven development in the project in Chapter 12, "
"we’ll use compiler-driven development here. We’ll write the code that calls "
"the functions we want, and then we’ll look at errors from the compiler to "
"determine what we should change next to get the code to work. Before we do "
"that, however, we’ll explore the technique we’re not going to use as a "
"starting point."
msgstr ""

#: src/ch21-02-multithreaded.md:141
msgid ""
"<a id=\"code-structure-if-we-could-spawn-a-thread-for-each-request\"></a>"
msgstr ""

#: src/ch21-02-multithreaded.md:143
msgid "Spawning a Thread for Each Request"
msgstr ""

#: src/ch21-02-multithreaded.md:145
msgid ""
"First, let’s explore how our code might look if it did create a new thread "
"for every connection. As mentioned earlier, this isn’t our final plan due to "
"the problems with potentially spawning an unlimited number of threads, but "
"it is a starting point to get a working multithreaded server first. Then "
"we’ll add the thread pool as an improvement, and contrasting the two "
"solutions will be easier. Listing 21-11 shows the changes to make to `main` "
"to spawn a new thread to handle each stream within the `for` loop."
msgstr ""

#: src/ch21-02-multithreaded.md:201
msgid ""
"As you learned in Chapter 16, `thread::spawn` will create a new thread and "
"then run the code in the closure in the new thread. If you run this code and "
"load _/sleep_ in your browser, then _/_ in two more browser tabs, you’ll "
"indeed see that the requests to _/_ don’t have to wait for _/sleep_ to "
"finish. However, as we mentioned, this will eventually overwhelm the system "
"because you’d be making new threads without any limit."
msgstr ""

#: src/ch21-02-multithreaded.md:208
msgid ""
"You may also recall from Chapter 17 that this is exactly the kind of "
"situation where async and await really shine! Keep that in mind as we build "
"the thread pool and think about how things would look different or the same "
"with async."
msgstr ""

#: src/ch21-02-multithreaded.md:214
msgid ""
"<a id=\"creating-a-similar-interface-for-a-finite-number-of-threads\"></a>"
msgstr ""

#: src/ch21-02-multithreaded.md:216
msgid "Creating a Finite Number of Threads"
msgstr ""

#: src/ch21-02-multithreaded.md:218
msgid ""
"We want our thread pool to work in a similar, familiar way so that switching "
"from threads to a thread pool doesn’t require large changes to the code that "
"uses our API. Listing 21-12 shows the hypothetical interface for a "
"`ThreadPool` struct we want to use instead of `thread::spawn`."
msgstr ""

#: src/ch21-02-multithreaded.md:272
msgid ""
"We use `ThreadPool::new` to create a new thread pool with a configurable "
"number of threads, in this case four. Then, in the `for` loop, "
"`pool.execute` has a similar interface as `thread::spawn` in that it takes a "
"closure the pool should run for each stream. We need to implement "
"`pool.execute` so it takes the closure and gives it to a thread in the pool "
"to run. This code won’t yet compile, but we’ll try so the compiler can guide "
"us in how to fix it."
msgstr ""

#: src/ch21-02-multithreaded.md:281
msgid ""
"<a id=\"building-the-threadpool-struct-using-compiler-driven-development\"></"
"a>"
msgstr ""

#: src/ch21-02-multithreaded.md:283
msgid "Building `ThreadPool` Using Compiler Driven Development"
msgstr ""

#: src/ch21-02-multithreaded.md:285
msgid ""
"Make the changes in Listing 21-12 to _src/main.rs_, and then let’s use the "
"compiler errors from `cargo check` to drive our development. Here is the "
"first error we get:"
msgstr ""

#: src/ch21-02-multithreaded.md:289
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0433]: failed to resolve: use of undeclared type `ThreadPool`\n"
"  --> src/main.rs:11:16\n"
"   |\n"
"11 |     let pool = ThreadPool::new(4);\n"
"   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0433`.\n"
"error: could not compile `hello` (bin \"hello\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:302
msgid ""
"Great! This error tells us we need a `ThreadPool` type or module, so we’ll "
"build one now. Our `ThreadPool` implementation will be independent of the "
"kind of work our web server is doing. So let’s switch the `hello` crate from "
"a binary crate to a library crate to hold our `ThreadPool` implementation. "
"After we change to a library crate, we could also use the separate thread "
"pool library for any work we want to do using a thread pool, not just for "
"serving web requests."
msgstr ""

#: src/ch21-02-multithreaded.md:310
msgid ""
"Create a _src/lib.rs_ file that contains the following, which is the "
"simplest definition of a `ThreadPool` struct that we can have for now:"
msgstr ""

#: src/ch21-02-multithreaded.md:321
msgid ""
"Then edit _main.rs_ file to bring `ThreadPool` into scope from the library "
"crate by adding the following code to the top of _src/main.rs_:"
msgstr ""

#: src/ch21-02-multithreaded.md:374
msgid ""
"This code still won’t work, but let’s check it again to get the next error "
"that we need to address:"
msgstr ""

#: src/ch21-02-multithreaded.md:377
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0599]: no function or associated item named `new` found for struct "
"`ThreadPool` in the current scope\n"
"  --> src/main.rs:12:28\n"
"   |\n"
"12 |     let pool = ThreadPool::new(4);\n"
"   |                            ^^^ function or associated item not found in "
"`ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0599`.\n"
"error: could not compile `hello` (bin \"hello\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:390
msgid ""
"This error indicates that next we need to create an associated function "
"named `new` for `ThreadPool`. We also know that `new` needs to have one "
"parameter that can accept `4` as an argument and should return a "
"`ThreadPool` instance. Let’s implement the simplest `new` function that will "
"have those characteristics:"
msgstr ""

#: src/ch21-02-multithreaded.md:410
msgid ""
"We chose `usize` as the type of the `size` parameter because we know that a "
"negative number of threads doesn’t make any sense. We also know we’ll use "
"this `4` as the number of elements in a collection of threads, which is what "
"the `usize` type is for, as discussed in [“Integer Types”](ch03-02-data-"
"types.html#integer-types)<!-- ignore\n"
"--> in Chapter 3."
msgstr ""

#: src/ch21-02-multithreaded.md:416
msgid "Let’s check the code again:"
msgstr ""

#: src/ch21-02-multithreaded.md:418
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0599]: no method named `execute` found for struct `ThreadPool` in the "
"current scope\n"
"  --> src/main.rs:17:14\n"
"   |\n"
"17 |         pool.execute(|| {\n"
"   |         -----^^^^^^^ method not found in `ThreadPool`\n"
"\n"
"For more information about this error, try `rustc --explain E0599`.\n"
"error: could not compile `hello` (bin \"hello\") due to 1 previous error\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:431
msgid ""
"Now the error occurs because we don’t have an `execute` method on "
"`ThreadPool`. Recall from [“Creating a Finite Number of Threads”](#creating-"
"a-finite-number-of-threads)<!-- ignore --> that we decided our thread pool "
"should have an interface similar to `thread::spawn`. In addition, we’ll "
"implement the `execute` function so it takes the closure it’s given and "
"gives it to an idle thread in the pool to run."
msgstr ""

#: src/ch21-02-multithreaded.md:438
msgid ""
"We’ll define the `execute` method on `ThreadPool` to take a closure as a "
"parameter. Recall from [“Moving Captured Values Out of the Closure and the "
"`Fn` Traits”](ch13-01-closures.html#moving-captured-values-out-of-the-"
"closure-and-the-fn-traits)<!-- ignore --> in Chapter 13 that we can take "
"closures as parameters with three different traits: `Fn`, `FnMut`, and "
"`FnOnce`. We need to decide which kind of closure to use here. We know we’ll "
"end up doing something similar to the standard library `thread::spawn` "
"implementation, so we can look at what bounds the signature of "
"`thread::spawn` has on its parameter. The documentation shows us the "
"following:"
msgstr ""

#: src/ch21-02-multithreaded.md:455
msgid ""
"The `F` type parameter is the one we’re concerned with here; the `T` type "
"parameter is related to the return value, and we’re not concerned with that. "
"We can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is "
"probably what we want as well, because we’ll eventually pass the argument we "
"get in `execute` to `spawn`. We can be further confident that `FnOnce` is "
"the trait we want to use because the thread for running a request will only "
"execute that request’s closure one time, which matches the `Once` in "
"`FnOnce`."
msgstr ""

#: src/ch21-02-multithreaded.md:463
msgid ""
"The `F` type parameter also has the trait bound `Send` and the lifetime "
"bound `'static`, which are useful in our situation: we need `Send` to "
"transfer the closure from one thread to another and `'static` because we "
"don’t know how long the thread will take to execute. Let’s create an "
"`execute` method on `ThreadPool` that will take a generic parameter of type "
"`F` with these bounds:"
msgstr ""

#: src/ch21-02-multithreaded.md:490
msgid ""
"We still use the `()` after `FnOnce` because this `FnOnce` represents a "
"closure that takes no parameters and returns the unit type `()`. Just like "
"function definitions, the return type can be omitted from the signature, but "
"even if we have no parameters, we still need the parentheses."
msgstr ""

#: src/ch21-02-multithreaded.md:495
msgid ""
"Again, this is the simplest implementation of the `execute` method: it does "
"nothing, but we’re only trying to make our code compile. Let’s check it "
"again:"
msgstr ""

#: src/ch21-02-multithreaded.md:498
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:504
msgid ""
"It compiles! But note that if you try `cargo run` and make a request in the "
"browser, you’ll see the errors in the browser that we saw at the beginning "
"of the chapter. Our library isn’t actually calling the closure passed to "
"`execute` yet!"
msgstr ""

#: src/ch21-02-multithreaded.md:509
msgid ""
"Note: A saying you might hear about languages with strict compilers, such as "
"Haskell and Rust, is “if the code compiles, it works.” But this saying is "
"not universally true. Our project compiles, but it does absolutely nothing! "
"If we were building a real, complete project, this would be a good time to "
"start writing unit tests to check that the code compiles _and_ has the "
"behavior we want."
msgstr ""

#: src/ch21-02-multithreaded.md:516
msgid ""
"Consider: what would be different here if we were going to execute a "
"_future_ instead of a closure?"
msgstr ""

#: src/ch21-02-multithreaded.md:519
msgid "Validating the Number of Threads in `new`"
msgstr ""

#: src/ch21-02-multithreaded.md:521
msgid ""
"We aren’t doing anything with the parameters to `new` and `execute`. Let’s "
"implement the bodies of these functions with the behavior we want. To start, "
"let’s think about `new`. Earlier we chose an unsigned type for the `size` "
"parameter because a pool with a negative number of threads makes no sense. "
"However, a pool with zero threads also makes no sense, yet zero is a "
"perfectly valid `usize`. We’ll add code to check that `size` is greater than "
"zero before we return a `ThreadPool` instance and have the program panic if "
"it receives a zero by using the `assert!` macro, as shown in Listing 21-13."
msgstr ""

#: src/ch21-02-multithreaded.md:536
#: src/ch21-03-graceful-shutdown-and-cleanup.md:643
msgid ""
"/// Create a new ThreadPool.\n"
"    ///\n"
"    /// The size is the number of threads in the pool.\n"
"    ///\n"
"    /// # Panics\n"
"    ///\n"
"    /// The `new` function will panic if the size is zero.\n"
msgstr ""

#: src/ch21-02-multithreaded.md:560
msgid ""
"We’ve also added some documentation for our `ThreadPool` with doc comments. "
"Note that we followed good documentation practices by adding a section that "
"calls out the situations in which our function can panic, as discussed in "
"Chapter 14. Try running `cargo doc --open` and clicking the `ThreadPool` "
"struct to see what the generated docs for `new` look like!"
msgstr ""

#: src/ch21-02-multithreaded.md:566
msgid ""
"Instead of adding the `assert!` macro as we’ve done here, we could change "
"`new` into `build` and return a `Result` like we did with `Config::build` in "
"the I/O project in Listing 12-9. But we’ve decided in this case that trying "
"to create a thread pool without any threads should be an unrecoverable "
"error. If you’re feeling ambitious, try to write a function named `build` "
"with the following signature to compare with the `new` function:"
msgstr ""

#: src/ch21-02-multithreaded.md:577
msgid "Creating Space to Store the Threads"
msgstr ""

#: src/ch21-02-multithreaded.md:579
msgid ""
"Now that we have a way to know we have a valid number of threads to store in "
"the pool, we can create those threads and store them in the `ThreadPool` "
"struct before returning the struct. But how do we “store” a thread? Let’s "
"take another look at the `thread::spawn` signature:"
msgstr ""

#: src/ch21-02-multithreaded.md:592
msgid ""
"The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that "
"the closure returns. Let’s try using `JoinHandle` too and see what happens. "
"In our case, the closures we’re passing to the thread pool will handle the "
"connection and not return anything, so `T` will be the unit type `()`."
msgstr ""

#: src/ch21-02-multithreaded.md:597
msgid ""
"The code in Listing 21-14 will compile but doesn’t create any threads yet. "
"We’ve changed the definition of `ThreadPool` to hold a vector of "
"`thread::JoinHandle<()>` instances, initialized the vector with a capacity "
"of `size`, set up a `for` loop that will run some code to create the "
"threads, and returned a `ThreadPool` instance containing them."
msgstr ""

#: src/ch21-02-multithreaded.md:614 src/ch21-02-multithreaded.md:713
#: src/ch21-02-multithreaded.md:822 src/ch21-02-multithreaded.md:889
#: src/ch21-02-multithreaded.md:1010 src/ch21-02-multithreaded.md:1097
#: src/ch21-02-multithreaded.md:1181 src/ch21-02-multithreaded.md:1338
#: src/ch21-03-graceful-shutdown-and-cleanup.md:45
#: src/ch21-03-graceful-shutdown-and-cleanup.md:181
#: src/ch21-03-graceful-shutdown-and-cleanup.md:285
#: src/ch21-03-graceful-shutdown-and-cleanup.md:379
msgid "/// Create a new ThreadPool.\n"
msgstr ""

#: src/ch21-02-multithreaded.md:616 src/ch21-02-multithreaded.md:715
#: src/ch21-02-multithreaded.md:824 src/ch21-02-multithreaded.md:891
#: src/ch21-02-multithreaded.md:1012 src/ch21-02-multithreaded.md:1099
#: src/ch21-02-multithreaded.md:1183 src/ch21-02-multithreaded.md:1340
#: src/ch21-03-graceful-shutdown-and-cleanup.md:47
#: src/ch21-03-graceful-shutdown-and-cleanup.md:183
#: src/ch21-03-graceful-shutdown-and-cleanup.md:287
#: src/ch21-03-graceful-shutdown-and-cleanup.md:381
msgid "/// The size is the number of threads in the pool.\n"
msgstr ""

#: src/ch21-02-multithreaded.md:618 src/ch21-02-multithreaded.md:717
#: src/ch21-02-multithreaded.md:826 src/ch21-02-multithreaded.md:893
#: src/ch21-02-multithreaded.md:1014 src/ch21-02-multithreaded.md:1101
#: src/ch21-02-multithreaded.md:1185 src/ch21-02-multithreaded.md:1342
#: src/ch21-03-graceful-shutdown-and-cleanup.md:49
#: src/ch21-03-graceful-shutdown-and-cleanup.md:185
#: src/ch21-03-graceful-shutdown-and-cleanup.md:289
#: src/ch21-03-graceful-shutdown-and-cleanup.md:383
msgid "/// # Panics\n"
msgstr ""

#: src/ch21-02-multithreaded.md:620 src/ch21-02-multithreaded.md:719
#: src/ch21-02-multithreaded.md:828 src/ch21-02-multithreaded.md:895
#: src/ch21-02-multithreaded.md:1016 src/ch21-02-multithreaded.md:1103
#: src/ch21-02-multithreaded.md:1187 src/ch21-02-multithreaded.md:1344
#: src/ch21-03-graceful-shutdown-and-cleanup.md:51
#: src/ch21-03-graceful-shutdown-and-cleanup.md:187
#: src/ch21-03-graceful-shutdown-and-cleanup.md:291
#: src/ch21-03-graceful-shutdown-and-cleanup.md:385
msgid "/// The `new` function will panic if the size is zero.\n"
msgstr ""

#: src/ch21-02-multithreaded.md:627
msgid "// create some threads and store them in the vector\n"
msgstr ""

#: src/ch21-02-multithreaded.md:644
msgid ""
"We’ve brought `std::thread` into scope in the library crate because we’re "
"using `thread::JoinHandle` as the type of the items in the vector in "
"`ThreadPool`."
msgstr ""

#: src/ch21-02-multithreaded.md:648
msgid ""
"Once a valid size is received, our `ThreadPool` creates a new vector that "
"can hold `size` items. The `with_capacity` function performs the same task "
"as `Vec::new` but with an important difference: it pre-allocates space in "
"the vector. Because we know we need to store `size` elements in the vector, "
"doing this allocation up front is slightly more efficient than using "
"`Vec::new`, which resizes itself as elements are inserted."
msgstr ""

#: src/ch21-02-multithreaded.md:655
msgid "When you run `cargo check` again, it should succeed."
msgstr ""

#: src/ch21-02-multithreaded.md:657
msgid ""
"A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a "
"Thread"
msgstr ""

#: src/ch21-02-multithreaded.md:659
msgid ""
"We left a comment in the `for` loop in Listing 21-14 regarding the creation "
"of threads. Here, we’ll look at how we actually create threads. The standard "
"library provides `thread::spawn` as a way to create threads, and "
"`thread::spawn` expects to get some code the thread should run as soon as "
"the thread is created. However, in our case, we want to create the threads "
"and have them _wait_ for code that we’ll send later. The standard library’s "
"implementation of threads doesn’t include any way to do that; we have to "
"implement it manually."
msgstr ""

#: src/ch21-02-multithreaded.md:668
msgid ""
"We’ll implement this behavior by introducing a new data structure between "
"the `ThreadPool` and the threads that will manage this new behavior. We’ll "
"call this data structure _Worker_, which is a common term in pooling "
"implementations. The `Worker` picks up code that needs to be run and runs "
"the code in the Worker’s thread."
msgstr ""

#: src/ch21-02-multithreaded.md:674
msgid ""
"Think of people working in the kitchen at a restaurant: the workers wait "
"until orders come in from customers, and then they’re responsible for taking "
"those orders and fulfilling them."
msgstr ""

#: src/ch21-02-multithreaded.md:678
msgid ""
"Instead of storing a vector of `JoinHandle<()>` instances in the thread "
"pool, we’ll store instances of the `Worker` struct. Each `Worker` will store "
"a single `JoinHandle<()>` instance. Then we’ll implement a method on "
"`Worker` that will take a closure of code to run and send it to the already "
"running thread for execution. We’ll also give each `Worker` an `id` so we "
"can distinguish between the different instances of `Worker` in the pool when "
"logging or debugging."
msgstr ""

#: src/ch21-02-multithreaded.md:685
msgid ""
"Here is the new process that will happen when we create a `ThreadPool`. "
"We’ll implement the code that sends the closure to the thread after we have "
"`Worker` set up in this way:"
msgstr ""

#: src/ch21-02-multithreaded.md:689
msgid "Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`."
msgstr ""

#: src/ch21-02-multithreaded.md:690
msgid "Change `ThreadPool` to hold a vector of `Worker` instances."
msgstr ""

#: src/ch21-02-multithreaded.md:691
msgid ""
"Define a `Worker::new` function that takes an `id` number and returns a "
"`Worker` instance that holds the `id` and a thread spawned with an empty "
"closure."
msgstr ""

#: src/ch21-02-multithreaded.md:694
msgid ""
"In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create "
"a new `Worker` with that `id`, and store the worker in the vector."
msgstr ""

#: src/ch21-02-multithreaded.md:697
msgid ""
"If you’re up for a challenge, try implementing these changes on your own "
"before looking at the code in Listing 21-15."
msgstr ""

#: src/ch21-02-multithreaded.md:700
msgid ""
"Ready? Here is Listing 21-15 with one way to make the preceding "
"modifications."
msgstr ""

#: src/ch21-02-multithreaded.md:756
msgid ""
"We’ve changed the name of the field on `ThreadPool` from `threads` to "
"`workers` because it’s now holding `Worker` instances instead of "
"`JoinHandle<()>` instances. We use the counter in the `for` loop as an "
"argument to `Worker::new`, and we store each new `Worker` in the vector "
"named `workers`."
msgstr ""

#: src/ch21-02-multithreaded.md:761
msgid ""
"External code (like our server in _src/main.rs_) doesn’t need to know the "
"implementation details regarding using a `Worker` struct within "
"`ThreadPool`, so we make the `Worker` struct and its `new` function private. "
"The `Worker::new` function uses the `id` we give it and stores a "
"`JoinHandle<()>` instance that is created by spawning a new thread using an "
"empty closure."
msgstr ""

#: src/ch21-02-multithreaded.md:767
msgid ""
"Note: If the operating system can’t create a thread because there aren’t "
"enough system resources, `thread::spawn` will panic. That will cause our "
"whole server to panic, even though the creation of some threads might "
"succeed. For simplicity’s sake, this behavior is fine, but in a production "
"thread pool implementation, you’d likely want to use [`std::thread::Builder`]"
"(../std/thread/struct.Builder.html)<!-- ignore --> and its [`spawn`](../std/"
"thread/struct.Builder.html#method.spawn)<!-- ignore --> method that returns "
"`Result` instead."
msgstr ""

#: src/ch21-02-multithreaded.md:775
msgid ""
"This code will compile and will store the number of `Worker` instances we "
"specified as an argument to `ThreadPool::new`. But we’re _still_ not "
"processing the closure that we get in `execute`. Let’s look at how to do "
"that next."
msgstr ""

#: src/ch21-02-multithreaded.md:779
msgid "Sending Requests to Threads via Channels"
msgstr ""

#: src/ch21-02-multithreaded.md:781
msgid ""
"The next problem we’ll tackle is that the closures given to `thread::spawn` "
"do absolutely nothing. Currently, we get the closure we want to execute in "
"the `execute` method. But we need to give `thread::spawn` a closure to run "
"when we create each `Worker` during the creation of the `ThreadPool`."
msgstr ""

#: src/ch21-02-multithreaded.md:786
msgid ""
"We want the `Worker` structs that we just created to fetch the code to run "
"from a queue held in the `ThreadPool` and send that code to its thread to "
"run."
msgstr ""

#: src/ch21-02-multithreaded.md:789
msgid ""
"The channels we learned about in Chapter 16—a simple way to communicate "
"between two threads—would be perfect for this use case. We’ll use a channel "
"to function as the queue of jobs, and `execute` will send a job from the "
"`ThreadPool` to the `Worker` instances, which will send the job to its "
"thread. Here is the plan:"
msgstr ""

#: src/ch21-02-multithreaded.md:794
msgid "The `ThreadPool` will create a channel and hold on to the sender."
msgstr ""

#: src/ch21-02-multithreaded.md:795
msgid "Each `Worker` will hold on to the receiver."
msgstr ""

#: src/ch21-02-multithreaded.md:796
msgid ""
"We’ll create a new `Job` struct that will hold the closures we want to send "
"down the channel."
msgstr ""

#: src/ch21-02-multithreaded.md:798
msgid ""
"The `execute` method will send the job it wants to execute through the "
"sender."
msgstr ""

#: src/ch21-02-multithreaded.md:800
msgid ""
"In its thread, the `Worker` will loop over its receiver and execute the "
"closures of any jobs it receives."
msgstr ""

#: src/ch21-02-multithreaded.md:803
msgid ""
"Let’s start by creating a channel in `ThreadPool::new` and holding the "
"sender in the `ThreadPool` instance, as shown in Listing 21-16. The `Job` "
"struct doesn’t hold anything for now but will be the type of item we’re "
"sending down the channel."
msgstr ""

#: src/ch21-02-multithreaded.md:867
msgid ""
"In `ThreadPool::new`, we create our new channel and have the pool hold the "
"sender. This will successfully compile."
msgstr ""

#: src/ch21-02-multithreaded.md:870
msgid ""
"Let’s try passing a receiver of the channel into each `Worker` as the thread "
"pool creates the channel. We know we want to use the receiver in the thread "
"that the `Worker` instances spawn, so we’ll reference the `receiver` "
"parameter in the closure. The code in Listing 21-17 won’t quite compile yet."
msgstr ""

#: src/ch21-02-multithreaded.md:939
msgid ""
"We’ve made some small and straightforward changes: we pass the receiver into "
"`Worker::new`, and then we use it inside the closure."
msgstr ""

#: src/ch21-02-multithreaded.md:942
msgid "When we try to check this code, we get this error:"
msgstr ""

#: src/ch21-02-multithreaded.md:944
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0382]: use of moved value: `receiver`\n"
"  --> src/lib.rs:26:42\n"
"   |\n"
"21 |         let (sender, receiver) = mpsc::channel();\n"
"   |                      -------- move occurs because `receiver` has type "
"`std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait\n"
"...\n"
"25 |         for id in 0..size {\n"
"   |         ----------------- inside of this loop\n"
"26 |             workers.push(Worker::new(id, receiver));\n"
"   |                                          ^^^^^^^^ value moved here, in "
"previous iteration of loop\n"
"   |\n"
"note: consider changing this parameter type in method `new` to borrow "
"instead if owning the value isn't necessary\n"
"  --> src/lib.rs:47:33\n"
"   |\n"
"47 |     fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n"
"   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter "
"takes ownership of the value\n"
"help: consider moving the expression out of the loop so it is only moved "
"once\n"
"   |\n"
"25 ~         let mut value = Worker::new(id, receiver);\n"
"26 ~         for id in 0..size {\n"
"27 ~             workers.push(value);\n"
"   |\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `hello` (lib) due to 1 previous error\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:974
msgid ""
"The code is trying to pass `receiver` to multiple `Worker` instances. This "
"won’t work, as you’ll recall from Chapter 16: the channel implementation "
"that Rust provides is multiple _producer_, single _consumer_. This means we "
"can’t just clone the consuming end of the channel to fix this code. We also "
"don’t want to send a message multiple times to multiple consumers; we want "
"one list of messages with multiple `Worker` instances such that each message "
"gets processed once."
msgstr ""

#: src/ch21-02-multithreaded.md:982
msgid ""
"Additionally, taking a job off the channel queue involves mutating the "
"`receiver`, so the threads need a safe way to share and modify `receiver`; "
"otherwise, we might get race conditions (as covered in Chapter 16)."
msgstr ""

#: src/ch21-02-multithreaded.md:986
msgid ""
"Recall the thread-safe smart pointers discussed in Chapter 16: to share "
"ownership across multiple threads and allow the threads to mutate the value, "
"we need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple `Worker` "
"instances own the receiver, and `Mutex` will ensure that only one `Worker` "
"gets a job from the receiver at a time. Listing 21-18 shows the changes we "
"need to make."
msgstr ""

#: src/ch21-02-multithreaded.md:1063
msgid ""
"In `ThreadPool::new`, we put the receiver in an `Arc` and a `Mutex`. For "
"each new `Worker`, we clone the `Arc` to bump the reference count so the "
"`Worker` instances can share ownership of the receiver."
msgstr ""

#: src/ch21-02-multithreaded.md:1067
msgid "With these changes, the code compiles! We’re getting there!"
msgstr ""

#: src/ch21-02-multithreaded.md:1069
msgid "Implementing the `execute` Method"
msgstr ""

#: src/ch21-02-multithreaded.md:1071
msgid ""
"Let’s finally implement the `execute` method on `ThreadPool`. We’ll also "
"change `Job` from a struct to a type alias for a trait object that holds the "
"type of closure that `execute` receives. As discussed in [“Creating Type "
"Synonyms with Type Aliases”](ch20-03-advanced-types.html#creating-type-"
"synonyms-with-type-aliases)<!-- ignore --> in Chapter 20, type aliases allow "
"us to make long types shorter for ease of use. Look at Listing 21-19."
msgstr ""

#: src/ch21-02-multithreaded.md:1150
msgid ""
"After creating a new `Job` instance using the closure we get in `execute`, "
"we send that job down the sending end of the channel. We’re calling `unwrap` "
"on `send` for the case that sending fails. This might happen if, for "
"example, we stop all our threads from executing, meaning the receiving end "
"has stopped receiving new messages. At the moment, we can’t stop our threads "
"from executing: our threads continue executing as long as the pool exists. "
"The reason we use `unwrap` is that we know the failure case won’t happen, "
"but the compiler doesn’t know that."
msgstr ""

#: src/ch21-02-multithreaded.md:1159
msgid ""
"But we’re not quite done yet! In the `Worker`, our closure being passed to "
"`thread::spawn` still only _references_ the receiving end of the channel. "
"Instead, we need the closure to loop forever, asking the receiving end of "
"the channel for a job and running the job when it gets one. Let’s make the "
"change shown in Listing 21-20 to `Worker::new`."
msgstr ""

#: src/ch21-02-multithreaded.md:1226 src/ch21-02-multithreaded.md:1381
#: src/ch21-03-graceful-shutdown-and-cleanup.md:98
#: src/ch21-03-graceful-shutdown-and-cleanup.md:234
#: src/ch21-03-graceful-shutdown-and-cleanup.md:345
#: src/ch21-03-graceful-shutdown-and-cleanup.md:439
#: src/ch21-03-graceful-shutdown-and-cleanup.md:705
msgid "\"Worker {id} got a job; executing.\""
msgstr ""

#: src/ch21-02-multithreaded.md:1238
msgid ""
"Here, we first call `lock` on the `receiver` to acquire the mutex, and then "
"we call `unwrap` to panic on any errors. Acquiring a lock might fail if the "
"mutex is in a _poisoned_ state, which can happen if some other thread "
"panicked while holding the lock rather than releasing the lock. In this "
"situation, calling `unwrap` to have this thread panic is the correct action "
"to take. Feel free to change this `unwrap` to an `expect` with an error "
"message that is meaningful to you."
msgstr ""

#: src/ch21-02-multithreaded.md:1246
msgid ""
"If we get the lock on the mutex, we call `recv` to receive a `Job` from the "
"channel. A final `unwrap` moves past any errors here as well, which might "
"occur if the thread holding the sender has shut down, similar to how the "
"`send` method returns `Err` if the receiver shuts down."
msgstr ""

#: src/ch21-02-multithreaded.md:1251
msgid ""
"The call to `recv` blocks, so if there is no job yet, the current thread "
"will wait until a job becomes available. The `Mutex<T>` ensures that only "
"one `Worker` thread at a time is trying to request a job."
msgstr ""

#: src/ch21-02-multithreaded.md:1255
msgid ""
"Our thread pool is now in a working state! Give it a `cargo run` and make "
"some requests:"
msgstr ""

#: src/ch21-02-multithreaded.md:1265
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"warning: field `workers` is never read\n"
" --> src/lib.rs:7:5\n"
"  |\n"
"6 | pub struct ThreadPool {\n"
"  |            ---------- field in this struct\n"
"7 |     workers: Vec<Worker>,\n"
"  |     ^^^^^^^\n"
"  |\n"
"  = note: `#[warn(dead_code)]` on by default\n"
"\n"
"warning: fields `id` and `thread` are never read\n"
"  --> src/lib.rs:48:5\n"
"   |\n"
"47 | struct Worker {\n"
"   |        ------ fields in this struct\n"
"48 |     id: usize,\n"
"   |     ^^\n"
"49 |     thread: thread::JoinHandle<()>,\n"
"   |     ^^^^^^\n"
"\n"
"warning: `hello` (lib) generated 2 warnings\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s\n"
"     Running `target/debug/hello`\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"Worker 1 got a job; executing.\n"
"Worker 3 got a job; executing.\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"Worker 1 got a job; executing.\n"
"Worker 3 got a job; executing.\n"
"Worker 0 got a job; executing.\n"
"Worker 2 got a job; executing.\n"
"```"
msgstr ""

#: src/ch21-02-multithreaded.md:1303
msgid ""
"Success! We now have a thread pool that executes connections asynchronously. "
"There are never more than four threads created, so our system won’t get "
"overloaded if the server receives a lot of requests. If we make a request to "
"_/sleep_, the server will be able to serve other requests by having another "
"thread run them."
msgstr ""

#: src/ch21-02-multithreaded.md:1309
msgid ""
"Note: If you open _/sleep_ in multiple browser windows simultaneously, they "
"might load one at a time in five-second intervals. Some web browsers execute "
"multiple instances of the same request sequentially for caching reasons. "
"This limitation is not caused by our web server."
msgstr ""

#: src/ch21-02-multithreaded.md:1314
msgid ""
"This is a good time to pause and consider how the code in Listings 21-18, "
"21-19, and 21-20 would be different if we were using futures instead of a "
"closure for the work to be done. What types would change? How would the "
"method signatures be different, if at all? What parts of the code would stay "
"the same?"
msgstr ""

#: src/ch21-02-multithreaded.md:1319
msgid ""
"After learning about the `while let` loop in Chapters 17 and 18, you might "
"be wondering why we didn’t write the worker thread code as shown in Listing "
"21-21."
msgstr ""

#: src/ch21-02-multithreaded.md:1394
msgid ""
"This code compiles and runs but doesn’t result in the desired threading "
"behavior: a slow request will still cause other requests to wait to be "
"processed. The reason is somewhat subtle: the `Mutex` struct has no public "
"`unlock` method because the ownership of the lock is based on the lifetime "
"of the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the "
"`lock` method returns. At compile time, the borrow checker can then enforce "
"the rule that a resource guarded by a `Mutex` cannot be accessed unless we "
"hold the lock. However, this implementation can also result in the lock "
"being held longer than intended if we aren’t mindful of the lifetime of the "
"`MutexGuard<T>`."
msgstr ""

#: src/ch21-02-multithreaded.md:1405
msgid ""
"The code in Listing 21-20 that uses `let job = "
"receiver.lock().unwrap().recv().unwrap();` works because with `let`, any "
"temporary values used in the expression on the right hand side of the equal "
"sign are immediately dropped when the `let` statement ends. However, `while "
"let` (and `if let` and `match`) does not drop temporary values until the end "
"of the associated block. In Listing 21-21, the lock remains held for the "
"duration of the call to `job()`, meaning other `Worker` instances cannot "
"receive jobs."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:3
msgid ""
"The code in Listing 21-20 is responding to requests asynchronously through "
"the use of a thread pool, as we intended. We get some warnings about the "
"`workers`, `id`, and `thread` fields that we’re not using in a direct way "
"that reminds us we’re not cleaning up anything. When we use the less elegant "
"<kbd>ctrl</kbd>\\-<kbd>c</kbd> method to halt the main thread, all other "
"threads are stopped immediately as well, even if they’re in the middle of "
"serving a request."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:11
msgid ""
"Next, then, we’ll implement the `Drop` trait to call `join` on each of the "
"threads in the pool so they can finish the requests they’re working on "
"before closing. Then we’ll implement a way to tell the threads they should "
"stop accepting new requests and shut down. To see this code in action, we’ll "
"modify our server to accept only two requests before gracefully shutting "
"down its thread pool."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:18
msgid ""
"One thing to notice as we go: none of this affects the parts of the code "
"that handle executing the closures, so everything here would be just the "
"same if we were using a thread pool for an async runtime."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:22
msgid "Implementing the `Drop` Trait on `ThreadPool`"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:24
msgid ""
"Let’s start with implementing `Drop` on our thread pool. When the pool is "
"dropped, our threads should all join to make sure they finish their work. "
"Listing 21-22 shows a first attempt at a `Drop` implementation; this code "
"won’t quite work yet."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:81
#: src/ch21-03-graceful-shutdown-and-cleanup.md:217
#: src/ch21-03-graceful-shutdown-and-cleanup.md:328
#: src/ch21-03-graceful-shutdown-and-cleanup.md:420
#: src/ch21-03-graceful-shutdown-and-cleanup.md:684
msgid "\"Shutting down worker {}\""
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:110
msgid ""
"First, we loop through each of the thread pool `workers`. We use `&mut` for "
"this because `self` is a mutable reference, and we also need to be able to "
"mutate `worker`. For each worker, we print a message saying that this "
"particular `Worker` instance is shutting down, and then we call `join` on "
"that `Worker` instance’s thread. If the call to `join` fails, we use "
"`unwrap` to make Rust panic and go into an ungraceful shutdown."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:117
msgid "Here is the error we get when we compile this code:"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:119
msgid ""
"```console\n"
"$ cargo check\n"
"    Checking hello v0.1.0 (file:///projects/hello)\n"
"error[E0507]: cannot move out of `worker.thread` which is behind a mutable "
"reference\n"
"    --> src/lib.rs:52:13\n"
"     |\n"
"52   |             worker.thread.join().unwrap();\n"
"     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this "
"method call\n"
"     |             |\n"
"     |             move occurs because `worker.thread` has type "
"`JoinHandle<()>`, which does not implement the `Copy` trait\n"
"     |\n"
"note: `JoinHandle::<T>::join` takes ownership of the receiver `self`, which "
"moves `worker.thread`\n"
"    --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/"
"std/src/thread/mod.rs:1763:17\n"
"     |\n"
"1763 |     pub fn join(self) -> Result<T> {\n"
"     |                 ^^^^\n"
"\n"
"For more information about this error, try `rustc --explain E0507`.\n"
"error: could not compile `hello` (lib) due to 1 previous error\n"
"```"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:140
msgid ""
"The error tells us we can’t call `join` because we only have a mutable "
"borrow of each `worker` and `join` takes ownership of its argument. To solve "
"this issue, we need to move the thread out of the `Worker` instance that "
"owns `thread` so `join` can consume the thread. One way to do this is by "
"taking the same approach we did in Listing 18-15. If `Worker` held an "
"`Option<thread::JoinHandle<()>>`, we could call the `take` method on the "
"`Option` to move the value out of the `Some` variant and leave a `None` "
"variant in its place. In other words, a `Worker` that is running would have "
"a `Some` variant in `thread`, and when we wanted to clean up a `Worker`, "
"we’d replace `Some` with `None` so the `Worker` wouldn’t have a thread to "
"run."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:151
msgid ""
"However, the _only_ time this would come up would be when dropping the "
"`Worker`. In exchange, we’d have to deal with an "
"`Option<thread::JoinHandle<()>>` anywhere we accessed `worker.thread`. "
"Idiomatic Rust uses `Option` quite a bit, but when you find yourself "
"wrapping something you know will always be present in `Option` as a "
"workaround like this, it’s a good idea to look for alternative approaches. "
"They can make your code cleaner and less error-prone."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:158
msgid ""
"In this case, a better alternative exists: the `Vec::drain` method. It "
"accepts a range parameter to specify which items to remove from the `Vec`, "
"and returns an iterator of those items. Passing the `..` range syntax will "
"remove _every_ value from the `Vec`."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:163
msgid "So we need to update the `ThreadPool` `drop` implementation like this:"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:246
msgid ""
"This resolves the compiler error and does not require any other changes to "
"our code."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:249
msgid "Signaling to the Threads to Stop Listening for Jobs"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:251
msgid ""
"With all the changes we’ve made, our code compiles without any warnings. "
"However, the bad news is that this code doesn’t function the way we want it "
"to yet. The key is the logic in the closures run by the threads of the "
"`Worker` instances: at the moment, we call `join`, but that won’t shut down "
"the threads because they `loop` forever looking for jobs. If we try to drop "
"our `ThreadPool` with our current implementation of `drop`, the main thread "
"will block forever, waiting for the first thread to finish."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:259
msgid ""
"To fix this problem, we’ll need a change in the `ThreadPool` `drop` "
"implementation and then a change in the `Worker` loop."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:262
msgid ""
"First we’ll change the `ThreadPool` `drop` implementation to explicitly drop "
"the `sender` before waiting for the threads to finish. Listing 21-23 shows "
"the changes to `ThreadPool` to explicitly drop `sender`. Unlike with the "
"thread, here we _do_ need to use an `Option` to be able to move `sender` out "
"of `ThreadPool` with `Option::take`."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:357
msgid ""
"Dropping `sender` closes the channel, which indicates no more messages will "
"be sent. When that happens, all the calls to `recv` that the `Worker` "
"instances do in the infinite loop will return an error. In Listing 21-24, we "
"change the `Worker` loop to gracefully exit the loop in that case, which "
"means the threads will finish when the `ThreadPool` `drop` implementation "
"calls `join` on them."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:444
#: src/ch21-03-graceful-shutdown-and-cleanup.md:710
msgid "\"Worker {id} disconnected; shutting down.\""
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:457
msgid ""
"To see this code in action, let’s modify `main` to accept only two requests "
"before gracefully shutting down the server, as shown in Listing 21-25."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:484
#: src/ch21-03-graceful-shutdown-and-cleanup.md:599
msgid "\"Shutting down.\""
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:512
msgid ""
"You wouldn’t want a real-world web server to shut down after serving only "
"two requests. This code just demonstrates that the graceful shutdown and "
"cleanup is in working order."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:516
msgid ""
"The `take` method is defined in the `Iterator` trait and limits the "
"iteration to the first two items at most. The `ThreadPool` will go out of "
"scope at the end of `main`, and the `drop` implementation will run."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:520
msgid ""
"Start the server with `cargo run`, and make three requests. The third "
"request should error, and in your terminal you should see output similar to "
"this:"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:534
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello v0.1.0 (file:///projects/hello)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n"
"     Running `target/debug/hello`\n"
"Worker 0 got a job; executing.\n"
"Shutting down.\n"
"Shutting down worker 0\n"
"Worker 3 got a job; executing.\n"
"Worker 1 disconnected; shutting down.\n"
"Worker 2 disconnected; shutting down.\n"
"Worker 3 disconnected; shutting down.\n"
"Worker 0 disconnected; shutting down.\n"
"Shutting down worker 1\n"
"Shutting down worker 2\n"
"Shutting down worker 3\n"
"```"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:552
msgid ""
"You might see a different ordering of `Worker` IDs and messages printed. We "
"can see how this code works from the messages: `Worker` instances 0 and 3 "
"got the first two requests. The server stopped accepting connections after "
"the second connection, and the `Drop` implementation on `ThreadPool` starts "
"executing before `Worker` 3 even starts its job. Dropping the `sender` "
"disconnects all the `Worker` instances and tells them to shut down. The "
"`Worker` instances each print a message when they disconnect, and then the "
"thread pool calls `join` to wait for each `Worker` thread to finish."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:561
msgid ""
"Notice one interesting aspect of this particular execution: the `ThreadPool` "
"dropped the `sender`, and before any `Worker` received an error, we tried to "
"join `Worker` 0. `Worker` 0 had not yet gotten an error from `recv`, so the "
"main thread blocked waiting for `Worker` 0 to finish. In the meantime, "
"`Worker` 3 received a job and then all threads received an error. When "
"`Worker` 0 finished, the main thread waited for the rest of the `Worker` "
"instances to finish. At that point, they had all exited their loops and "
"stopped."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:569
msgid ""
"Congrats! We’ve now completed our project; we have a basic web server that "
"uses a thread pool to respond asynchronously. We’re able to perform a "
"graceful shutdown of the server, which cleans up all the threads in the pool."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:573
msgid "Here’s the full code for reference:"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:726
msgid ""
"We could do more here! If you want to continue enhancing this project, here "
"are some ideas:"
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:729
msgid "Add more documentation to `ThreadPool` and its public methods."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:730
msgid "Add tests of the library’s functionality."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:731
msgid "Change calls to `unwrap` to more robust error handling."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:732
msgid "Use `ThreadPool` to perform some task other than serving web requests."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:733
msgid ""
"Find a thread pool crate on [crates.io](https://crates.io/) and implement a "
"similar web server using the crate instead. Then compare its API and "
"robustness to the thread pool we implemented."
msgstr ""

#: src/ch21-03-graceful-shutdown-and-cleanup.md:739
msgid ""
"Well done! You’ve made it to the end of the book! We want to thank you for "
"joining us on this tour of Rust. You’re now ready to implement your own Rust "
"projects and help with other people’s projects. Keep in mind that there is a "
"welcoming community of other Rustaceans who would love to help you with any "
"challenges you encounter on your Rust journey."
msgstr ""

#: src/appendix-00.md:3
msgid ""
"The following sections contain reference material you may find useful in "
"your Rust journey."
msgstr ""

#: src/appendix-01-keywords.md:1
msgid "Appendix A: Keywords"
msgstr ""

#: src/appendix-01-keywords.md:3
msgid ""
"The following list contains keywords that are reserved for current or future "
"use by the Rust language. As such, they cannot be used as identifiers "
"(except as raw identifiers as we’ll discuss in the “[Raw Identifiers](#raw-"
"identifiers)<!-- ignore -->” section). Identifiers are names of functions, "
"variables, parameters, struct fields, modules, crates, constants, macros, "
"static values, attributes, types, traits, or lifetimes."
msgstr ""

#: src/appendix-01-keywords.md:12
msgid "Keywords Currently in Use"
msgstr ""

#: src/appendix-01-keywords.md:14
msgid ""
"The following is a list of keywords currently in use, with their "
"functionality described."
msgstr ""

#: src/appendix-01-keywords.md:17
msgid ""
"`as` - perform primitive casting, disambiguate the specific trait containing "
"an item, or rename items in `use` statements"
msgstr ""

#: src/appendix-01-keywords.md:19
msgid "`async` - return a `Future` instead of blocking the current thread"
msgstr ""

#: src/appendix-01-keywords.md:20
msgid "`await` - suspend execution until the result of a `Future` is ready"
msgstr ""

#: src/appendix-01-keywords.md:21
msgid "`break` - exit a loop immediately"
msgstr ""

#: src/appendix-01-keywords.md:22
msgid "`const` - define constant items or constant raw pointers"
msgstr ""

#: src/appendix-01-keywords.md:23
msgid "`continue` - continue to the next loop iteration"
msgstr ""

#: src/appendix-01-keywords.md:24
msgid "`crate` - in a module path, refers to the crate root"
msgstr ""

#: src/appendix-01-keywords.md:25
msgid "`dyn` - dynamic dispatch to a trait object"
msgstr ""

#: src/appendix-01-keywords.md:26
msgid "`else` - fallback for `if` and `if let` control flow constructs"
msgstr ""

#: src/appendix-01-keywords.md:27
msgid "`enum` - define an enumeration"
msgstr ""

#: src/appendix-01-keywords.md:28
msgid "`extern` - link an external function or variable"
msgstr ""

#: src/appendix-01-keywords.md:29
msgid "`false` - Boolean false literal"
msgstr ""

#: src/appendix-01-keywords.md:30
msgid "`fn` - define a function or the function pointer type"
msgstr ""

#: src/appendix-01-keywords.md:31
msgid ""
"`for` - loop over items from an iterator, implement a trait, or specify a "
"higher-ranked lifetime"
msgstr ""

#: src/appendix-01-keywords.md:33
msgid "`if` - branch based on the result of a conditional expression"
msgstr ""

#: src/appendix-01-keywords.md:34
msgid "`impl` - implement inherent or trait functionality"
msgstr ""

#: src/appendix-01-keywords.md:35
msgid "`in` - part of `for` loop syntax"
msgstr ""

#: src/appendix-01-keywords.md:36
msgid "`let` - bind a variable"
msgstr ""

#: src/appendix-01-keywords.md:37
msgid "`loop` - loop unconditionally"
msgstr ""

#: src/appendix-01-keywords.md:38
msgid "`match` - match a value to patterns"
msgstr ""

#: src/appendix-01-keywords.md:39
msgid "`mod` - define a module"
msgstr ""

#: src/appendix-01-keywords.md:40
msgid "`move` - make a closure take ownership of all its captures"
msgstr ""

#: src/appendix-01-keywords.md:41
msgid ""
"`mut` - denote mutability in references, raw pointers, or pattern bindings"
msgstr ""

#: src/appendix-01-keywords.md:42
msgid ""
"`pub` - denote public visibility in struct fields, `impl` blocks, or modules"
msgstr ""

#: src/appendix-01-keywords.md:43
msgid "`ref` - bind by reference"
msgstr ""

#: src/appendix-01-keywords.md:44
msgid "`return` - return from function"
msgstr "`return` - 함수에서 반환"

#: src/appendix-01-keywords.md:45
msgid "`Self` - a type alias for the type we are defining or implementing"
msgstr "`Self` - 정의하거나 구현하는 타입에 대한 타입 별칭"

#: src/appendix-01-keywords.md:46
msgid "`self` - method subject or current module"
msgstr "`self` - 메서드 주체 또는 현재 모듈"

#: src/appendix-01-keywords.md:47
msgid ""
"`static` - global variable or lifetime lasting the entire program execution"
msgstr "`static` - 전역 변수 또는 전체 프로그램 실행 동안 지속되는 라이프타임"

#: src/appendix-01-keywords.md:48
msgid "`struct` - define a structure"
msgstr "`struct` - 구조체 정의"

#: src/appendix-01-keywords.md:49
msgid "`super` - parent module of the current module"
msgstr "`super` - 현재 모듈의 부모 모듈"

#: src/appendix-01-keywords.md:50
msgid "`trait` - define a trait"
msgstr "`trait` - 트레이트 정의"

#: src/appendix-01-keywords.md:51
msgid "`true` - Boolean true literal"
msgstr "`true` - 불리언 참 리터럴"

#: src/appendix-01-keywords.md:52
msgid "`type` - define a type alias or associated type"
msgstr "`type` - 타입 별칭 또는 연관 타입 정의"

#: src/appendix-01-keywords.md:53
msgid ""
"`union` - define a [union](../reference/items/unions.html)<!-- ignore -->; "
"is only a keyword when used in a union declaration"
msgstr "`union` - [유니온](../reference/items/unions.html)<!-- ignore --> 정의; 유니온 선언에서 사용될 때만 키워드입니다"

#: src/appendix-01-keywords.md:55
msgid "`unsafe` - denote unsafe code, functions, traits, or implementations"
msgstr "`unsafe` - 안전하지 않은 코드, 함수, 트레이트 또는 구현을 나타냄"

#: src/appendix-01-keywords.md:56
msgid ""
"`use` - bring symbols into scope; specify precise captures for generic and "
"lifetime bounds"
msgstr "`use` - 심볼을 스코프로 가져옴; 제네릭 및 라이프타임 바운드에 대한 정확한 캡처 지정"

#: src/appendix-01-keywords.md:58
msgid "`where` - denote clauses that constrain a type"
msgstr "`where` - 타입을 제약하는 절을 나타냄"

#: src/appendix-01-keywords.md:59
msgid "`while` - loop conditionally based on the result of an expression"
msgstr "`while` - 표현식의 결과에 따라 조건부로 반복"

#: src/appendix-01-keywords.md:63
msgid "Keywords Reserved for Future Use"
msgstr "향후 사용을 위해 예약된 키워드"

#: src/appendix-01-keywords.md:65
msgid ""
"The following keywords do not yet have any functionality but are reserved by "
"Rust for potential future use."
msgstr "다음 키워드들은 아직 기능이 없지만 러스트에서 잠재적인 미래 사용을 위해 예약되어 있습니다."

#: src/appendix-01-keywords.md:68
msgid "`abstract`"
msgstr "`abstract`"

#: src/appendix-01-keywords.md:69
msgid "`become`"
msgstr "`become`"

#: src/appendix-01-keywords.md:70
msgid "`box`"
msgstr "`box`"

#: src/appendix-01-keywords.md:71
msgid "`do`"
msgstr "`do`"

#: src/appendix-01-keywords.md:72
msgid "`final`"
msgstr "`final`"

#: src/appendix-01-keywords.md:73
msgid "`gen`"
msgstr "`gen`"

#: src/appendix-01-keywords.md:74
msgid "`macro`"
msgstr "`macro`"

#: src/appendix-01-keywords.md:75
msgid "`override`"
msgstr "`override`"

#: src/appendix-01-keywords.md:76
msgid "`priv`"
msgstr "`priv`"

#: src/appendix-01-keywords.md:77
msgid "`try`"
msgstr "`try`"

#: src/appendix-01-keywords.md:78
msgid "`typeof`"
msgstr "`typeof`"

#: src/appendix-01-keywords.md:79
msgid "`unsized`"
msgstr "`unsized`"

#: src/appendix-01-keywords.md:80
msgid "`virtual`"
msgstr "`virtual`"

#: src/appendix-01-keywords.md:81
msgid "`yield`"
msgstr "`yield`"

#: src/appendix-01-keywords.md:83
msgid "Raw Identifiers"
msgstr "원시 식별자"

#: src/appendix-01-keywords.md:85
msgid ""
"_Raw identifiers_ are the syntax that lets you use keywords where they "
"wouldn’t normally be allowed. You use a raw identifier by prefixing a "
"keyword with `r#`."
msgstr "_원시 식별자_는 일반적으로 허용되지 않는 곳에 키워드를 사용할 수 있게 해주는 문법입니다. 키워드 앞에 `r#`를 붙여 원시 식별자를 사용합니다."

#: src/appendix-01-keywords.md:88
msgid ""
"For example, `match` is a keyword. If you try to compile the following "
"function that uses `match` as its name:"
msgstr "예를 들어, `match`는 키워드입니다. `match`를 이름으로 사용하는 다음 함수를 컴파일하려고 하면:"

#: src/appendix-01-keywords.md:99
msgid "you’ll get this error:"
msgstr "다음과 같은 오류가 발생합니다:"

#: src/appendix-01-keywords.md:109
msgid ""
"The error shows that you can’t use the keyword `match` as the function "
"identifier. To use `match` as a function name, you need to use the raw "
"identifier syntax, like this:"
msgstr "오류는 `match` 키워드를 함수 식별자로 사용할 수 없음을 보여줍니다. `match`를 함수 이름으로 사용하려면 다음과 같이 원시 식별자 구문을 사용해야 합니다:"

#: src/appendix-01-keywords.md:121
msgid "\"foobar\""
msgstr "\"foobar\""

#: src/appendix-01-keywords.md:125
msgid ""
"This code will compile without any errors. Note the `r#` prefix on the "
"function name in its definition as well as where the function is called in "
"`main`."
msgstr "이 코드는 오류 없이 컴파일됩니다. 함수 정의의 함수 이름과 `main`에서 함수가 호출되는 곳에 `r#` 접두사가 붙어 있음을 확인하세요."

#: src/appendix-01-keywords.md:128
msgid ""
"Raw identifiers allow you to use any word you choose as an identifier, even "
"if that word happens to be a reserved keyword. This gives us more freedom to "
"choose identifier names, as well as lets us integrate with programs written "
"in a language where these words aren’t keywords. In addition, raw "
"identifiers allow you to use libraries written in a different Rust edition "
"than your crate uses. For example, `try` isn’t a keyword in the 2015 edition "
"but is in the 2018, 2021, and 2024 editions. If you depend on a library "
"that’s written using the 2015 edition and has a `try` function, you’ll need "
"to use the raw identifier syntax, `r#try` in this case, to call that "
"function from your 2018 edition code. See [Appendix E](appendix-05-"
"editions.html)<!-- ignore --> for more information on editions."
msgstr "원시 식별자를 사용하면 예약된 키워드라도 원하는 단어를 식별자로 사용할 수 있습니다. 이는 식별자 이름을 선택하는 데 더 많은 자유를 제공하며, 해당 단어가 키워드가 아닌 언어로 작성된 프로그램과 통합할 수 있게 해줍니다. 또한 원시 식별자를 사용하면 크레이트가 사용하는 Rust 에디션과 다른 에디션으로 작성된 라이브러리를 사용할 수 있습니다. 예를 들어, `try`는 2015년 에디션에서는 키워드가 아니지만 2018, 2021, 2024년 에디션에서는 키워드입니다. 2015년 에디션을 사용하여 작성되었고 `try` 함수를 가진 라이브러리에 의존하는 경우, 2018년 에디션 코드에서 해당 함수를 호출하려면 이 경우 `r#try`와 같은 원시 식별자 구문을 사용해야 합니다. 에디션에 대한 자세한 내용은 [부록 E](appendix-05-editions.html)<!-- ignore -->를 참조하세요."

#: src/appendix-02-operators.md:1
msgid "Appendix B: Operators and Symbols"
msgstr "부록 B: 연산자와 기호"

#: src/appendix-02-operators.md:3
msgid ""
"This appendix contains a glossary of Rust’s syntax, including operators and "
"other symbols that appear by themselves or in the context of paths, "
"generics, trait bounds, macros, attributes, comments, tuples, and brackets."
msgstr "이 부록에는 연산자 및 경로, 제네릭, 트레이트 바운드, 매크로, 속성, 주석, 튜플, 대괄호 컨텍스트에서 단독으로 또는 함께 나타나는 기타 기호를 포함한 Rust 구문 용어집이 포함되어 있습니다."

#: src/appendix-02-operators.md:7
msgid "Operators"
msgstr "연산자"

#: src/appendix-02-operators.md:9
msgid ""
"Table B-1 contains the operators in Rust, an example of how the operator "
"would appear in context, a short explanation, and whether that operator is "
"overloadable. If an operator is overloadable, the relevant trait to use to "
"overload that operator is listed."
msgstr "표 B-1에는 Rust의 연산자, 컨텍스트에서 연산자가 어떻게 나타나는지에 대한 예시, 간략한 설명, 그리고 해당 연산자가 오버로드 가능한지 여부가 포함되어 있습니다. 연산자가 오버로드 가능하다면, 해당 연산자를 오버로드하는 데 사용할 관련 트레이트가 나열됩니다."

#: src/appendix-02-operators.md:14
msgid "<span class=\"caption\">Table B-1: Operators</span>"
msgstr "<span class=\"caption\">표 B-1: 연산자</span>"

#: src/appendix-02-operators.md:16
msgid "Operator"
msgstr "연산자"

#: src/appendix-02-operators.md:16 src/appendix-02-operators.md:83
#: src/appendix-02-operators.md:102 src/appendix-02-operators.md:119
#: src/appendix-02-operators.md:135 src/appendix-02-operators.md:149
#: src/appendix-02-operators.md:162 src/appendix-02-operators.md:175
#: src/appendix-02-operators.md:190 src/appendix-02-operators.md:199
msgid "Explanation"
msgstr "설명"

#: src/appendix-02-operators.md:16
msgid "Overloadable?"
msgstr "오버로드 가능?"

#: src/appendix-02-operators.md:18 src/appendix-02-operators.md:19
#: src/appendix-02-operators.md:94
msgid "`!`"
msgstr "`!`"

#: src/appendix-02-operators.md:18 src/appendix-02-operators.md:156
msgid "`ident!(...)`, `ident!{...}`, `ident![...]`"
msgstr "`ident!(...)`, `ident!{...}`, `ident![...]`"

#: src/appendix-02-operators.md:18
msgid "Macro expansion"
msgstr "매크로 확장"

#: src/appendix-02-operators.md:19
msgid "`!expr`"
msgstr "`!expr`"

#: src/appendix-02-operators.md:19
msgid "Bitwise or logical complement"
msgstr "비트 단위 또는 논리적 보수"

#: src/appendix-02-operators.md:19
msgid "`Not`"
msgstr "`Not`"

#: src/appendix-02-operators.md:20
msgid "`!=`"
msgstr "`!=`"

#: src/appendix-02-operators.md:20
msgid "`expr != expr`"
msgstr "`expr != expr`"

#: src/appendix-02-operators.md:20
msgid "Nonequality comparison"
msgstr "불평등 비교"

#: src/appendix-02-operators.md:20 src/appendix-02-operators.md:58
msgid "`PartialEq`"
msgstr "`PartialEq`"

#: src/appendix-02-operators.md:21
msgid "`%`"
msgstr "`%`"

#: src/appendix-02-operators.md:21
msgid "`expr % expr`"
msgstr "`expr % expr`"

#: src/appendix-02-operators.md:21
msgid "Arithmetic remainder"
msgstr "산술 나머지"

#: src/appendix-02-operators.md:21
msgid "`Rem`"
msgstr "`Rem`"

#: src/appendix-02-operators.md:22
msgid "`%=`"
msgstr "`%=`"

#: src/appendix-02-operators.md:22
msgid "`var %= expr`"
msgstr "`var %= expr`"

#: src/appendix-02-operators.md:22
msgid "Arithmetic remainder and assignment"
msgstr "산술 나머지 및 할당"

#: src/appendix-02-operators.md:22
msgid "`RemAssign`"
msgstr "`RemAssign`"

#: src/appendix-02-operators.md:23 src/appendix-02-operators.md:24
#: src/appendix-02-operators.md:25
msgid "`&`"
msgstr "`&`"

#: src/appendix-02-operators.md:23
msgid "`&expr`, `&mut expr`"
msgstr "`&expr`, `&mut expr`"

#: src/appendix-02-operators.md:23
msgid "Borrow"
msgstr "대여"

#: src/appendix-02-operators.md:24
msgid "`&type`, `&mut type`, `&'a type`, `&'a mut type`"
msgstr "`&type`, `&mut type`, `&'a type`, `&'a mut type`"

#: src/appendix-02-operators.md:24
msgid "Borrowed pointer type"
msgstr "대여된 포인터 타입"

#: src/appendix-02-operators.md:25
msgid "`expr & expr`"
msgstr "`expr & expr`"

#: src/appendix-02-operators.md:25
msgid "Bitwise AND"
msgstr "비트 단위 AND"

#: src/appendix-02-operators.md:25
msgid "`BitAnd`"
msgstr "`BitAnd`"

#: src/appendix-02-operators.md:26
msgid "`&=`"
msgstr "`&=`"

#: src/appendix-02-operators.md:26
msgid "`var &= expr`"
msgstr "`var &= expr`"

#: src/appendix-02-operators.md:26
msgid "Bitwise AND and assignment"
msgstr "비트 단위 AND 및 할당"

#: src/appendix-02-operators.md:26
msgid "`BitAndAssign`"
msgstr "`BitAndAssign`"

#: src/appendix-02-operators.md:27
msgid "`&&`"
msgstr "`&&`"

#: src/appendix-02-operators.md:27
msgid "`expr && expr`"
msgstr "`expr && expr`"

#: src/appendix-02-operators.md:27
msgid "Short-circuiting logical AND"
msgstr "단락 논리 AND"

#: src/appendix-02-operators.md:28 src/appendix-02-operators.md:30
#: src/appendix-02-operators.md:31
msgid "`*`"
msgstr "`*`"

#: src/appendix-02-operators.md:28
msgid "`expr * expr`"
msgstr "`expr * expr`"

#: src/appendix-02-operators.md:28
msgid "Arithmetic multiplication"
msgstr "산술 곱셈"

#: src/appendix-02-operators.md:28
msgid "`Mul`"
msgstr "`Mul`"

#: src/appendix-02-operators.md:29
msgid "`*=`"
msgstr "`*=`"

#: src/appendix-02-operators.md:29
msgid "`var *= expr`"
msgstr "`var *= expr`"

#: src/appendix-02-operators.md:29
msgid "Arithmetic multiplication and assignment"
msgstr "산술 곱셈 및 할당"

#: src/appendix-02-operators.md:29
msgid "`MulAssign`"
msgstr "`MulAssign`"

#: src/appendix-02-operators.md:30
msgid "`*expr`"
msgstr "`*expr`"

#: src/appendix-02-operators.md:30
msgid "Dereference"
msgstr "역참조"

#: src/appendix-02-operators.md:30
msgid "`Deref`"
msgstr "`Deref`"

#: src/appendix-02-operators.md:31
msgid "`*const type`, `*mut type`"
msgstr "`*const type`, `*mut type`"

#: src/appendix-02-operators.md:31
msgid "Raw pointer"
msgstr "원시 포인터"

#: src/appendix-02-operators.md:32 src/appendix-02-operators.md:33
msgid "`+`"
msgstr "`+`"

#: src/appendix-02-operators.md:32
msgid "`trait + trait`, `'a + trait`"
msgstr "`trait + trait`, `'a + trait`"

#: src/appendix-02-operators.md:32 src/appendix-02-operators.md:142
msgid "Compound type constraint"
msgstr "복합 타입 제약"

#: src/appendix-02-operators.md:33
msgid "`expr + expr`"
msgstr "`expr + expr`"

#: src/appendix-02-operators.md:33
msgid "Arithmetic addition"
msgstr "산술 덧셈"

#: src/appendix-02-operators.md:33
msgid "`Add`"
msgstr "`Add`"

#: src/appendix-02-operators.md:34
msgid "`+=`"
msgstr "`+=`"

#: src/appendix-02-operators.md:34
msgid "`var += expr`"
msgstr "`var += expr`"

#: src/appendix-02-operators.md:34
msgid "Arithmetic addition and assignment"
msgstr "산술 덧셈 및 할당"

#: src/appendix-02-operators.md:34
msgid "`AddAssign`"
msgstr "`AddAssign`"

#: src/appendix-02-operators.md:35
msgid "`,`"
msgstr "`,`"

#: src/appendix-02-operators.md:35
msgid "`expr, expr`"
msgstr "`expr, expr`"

#: src/appendix-02-operators.md:35
msgid "Argument and element separator"
msgstr "인수 및 요소 구분자"

#: src/appendix-02-operators.md:36 src/appendix-02-operators.md:37
msgid "`-`"
msgstr "`-`"

#: src/appendix-02-operators.md:36
msgid "`- expr`"
msgstr "`- expr`"

#: src/appendix-02-operators.md:36
msgid "Arithmetic negation"
msgstr "산술 부정"

#: src/appendix-02-operators.md:36
msgid "`Neg`"
msgstr "`Neg`"

#: src/appendix-02-operators.md:37
msgid "`expr - expr`"
msgstr "`expr - expr`"

#: src/appendix-02-operators.md:37
msgid "Arithmetic subtraction"
msgstr "산술 뺄셈"

#: src/appendix-02-operators.md:37
msgid "`Sub`"
msgstr "`Sub`"

#: src/appendix-02-operators.md:38
msgid "`-=`"
msgstr "`-=`"

#: src/appendix-02-operators.md:38
msgid "`var -= expr`"
msgstr "`var -= expr`"

#: src/appendix-02-operators.md:38
msgid "Arithmetic subtraction and assignment"
msgstr "산술 뺄셈 및 할당"

#: src/appendix-02-operators.md:38
msgid "`SubAssign`"
msgstr "`SubAssign`"

#: src/appendix-02-operators.md:39
msgid "`->`"
msgstr "`->`"

#: src/appendix-02-operators.md:39
msgid "`fn(...) -> type`, <code>\\|...\\| -> type</code>"
msgstr "`fn(...) -> type`, <code>\\|...\\| -> type</code>"

#: src/appendix-02-operators.md:39
msgid "Function and closure return type"
msgstr "함수 및 클로저 반환 타입"

#: src/appendix-02-operators.md:40
msgid "`.`"
msgstr "`.`"

#: src/appendix-02-operators.md:40
msgid "`expr.ident`"
msgstr "`expr.ident`"

#: src/appendix-02-operators.md:40
msgid "Member access"
msgstr "멤버 접근"

#: src/appendix-02-operators.md:41 src/appendix-02-operators.md:43
#: src/appendix-02-operators.md:44
msgid "`..`"
msgstr "`..`"

#: src/appendix-02-operators.md:41
msgid "`..`, `expr..`, `..expr`, `expr..expr`"
msgstr "`..`, `expr..`, `..expr`, `expr..expr`"

#: src/appendix-02-operators.md:41
msgid "Right-exclusive range literal"
msgstr "오른쪽 배타적 범위 리터럴"

#: src/appendix-02-operators.md:41 src/appendix-02-operators.md:42
#: src/appendix-02-operators.md:55 src/appendix-02-operators.md:56
#: src/appendix-02-operators.md:60 src/appendix-02-operators.md:61
msgid "`PartialOrd`"
msgstr "`PartialOrd`"

#: src/appendix-02-operators.md:42
msgid "`..=`"
msgstr "`..=`"

#: src/appendix-02-operators.md:42
msgid "`..=expr`, `expr..=expr`"
msgstr "`..=expr`, `expr..=expr`"

#: src/appendix-02-operators.md:42
msgid "Right-inclusive range literal"
msgstr "오른쪽 포함 범위 리터럴"

#: src/appendix-02-operators.md:43
msgid "`..expr`"
msgstr "`..expr`"

#: src/appendix-02-operators.md:43
msgid "Struct literal update syntax"
msgstr "구조체 리터럴 업데이트 구문"

#: src/appendix-02-operators.md:44
msgid "`variant(x, ..)`, `struct_type { x, .. }`"
msgstr "`variant(x, ..)`, `struct_type { x, .. }`"

#: src/appendix-02-operators.md:44
msgid "“And the rest” pattern binding"
msgstr "\"나머지\" 패턴 바인딩"

#: src/appendix-02-operators.md:45
msgid "`...`"
msgstr "`...`"

#: src/appendix-02-operators.md:45
msgid "`expr...expr`"
msgstr "`expr...expr`"

#: src/appendix-02-operators.md:45
msgid "(Deprecated, use `..=` instead) In a pattern: inclusive range pattern"
msgstr "(더 이상 사용되지 않음, 대신 `..=` 사용) 패턴에서: 포함 범위 패턴"

#: src/appendix-02-operators.md:46
msgid "`/`"
msgstr "`/`"

#: src/appendix-02-operators.md:46
msgid "`expr / expr`"
msgstr "`expr / expr`"

#: src/appendix-02-operators.md:46
msgid "Arithmetic division"
msgstr "산술 나눗셈"

#: src/appendix-02-operators.md:46
msgid "`Div`"
msgstr "`Div`"

#: src/appendix-02-operators.md:47
msgid "`/=`"
msgstr "`/=`"

#: src/appendix-02-operators.md:47
msgid "`var /= expr`"
msgstr "`var /= expr`"

#: src/appendix-02-operators.md:47
msgid "Arithmetic division and assignment"
msgstr "산술 나눗셈 및 할당"

#: src/appendix-02-operators.md:47
msgid "`DivAssign`"
msgstr "`DivAssign`"

#: src/appendix-02-operators.md:48 src/appendix-02-operators.md:49
#: src/appendix-02-operators.md:50
msgid "`:`"
msgstr "`:`"

#: src/appendix-02-operators.md:48
msgid "`pat: type`, `ident: type`"
msgstr "`pat: type`, `ident: type`"

#: src/appendix-02-operators.md:48
msgid "Constraints"
msgstr ""

#: src/appendix-02-operators.md:49
msgid "`ident: expr`"
msgstr ""

#: src/appendix-02-operators.md:49
msgid "Struct field initializer"
msgstr ""

#: src/appendix-02-operators.md:50
msgid "`'a: loop {...}`"
msgstr ""

#: src/appendix-02-operators.md:50
msgid "Loop label"
msgstr ""

#: src/appendix-02-operators.md:51 src/appendix-02-operators.md:52
msgid "`;`"
msgstr ""

#: src/appendix-02-operators.md:51
msgid "`expr;`"
msgstr ""

#: src/appendix-02-operators.md:51
msgid "Statement and item terminator"
msgstr ""

#: src/appendix-02-operators.md:52
msgid "`[...; len]`"
msgstr ""

#: src/appendix-02-operators.md:52
msgid "Part of fixed-size array syntax"
msgstr ""

#: src/appendix-02-operators.md:53
msgid "`<<`"
msgstr ""

#: src/appendix-02-operators.md:53
msgid "`expr << expr`"
msgstr ""

#: src/appendix-02-operators.md:53
msgid "Left-shift"
msgstr ""

#: src/appendix-02-operators.md:53
msgid "`Shl`"
msgstr ""

#: src/appendix-02-operators.md:54
msgid "`<<=`"
msgstr ""

#: src/appendix-02-operators.md:54
msgid "`var <<= expr`"
msgstr ""

#: src/appendix-02-operators.md:54
msgid "Left-shift and assignment"
msgstr ""

#: src/appendix-02-operators.md:54
msgid "`ShlAssign`"
msgstr ""

#: src/appendix-02-operators.md:55
msgid "`<`"
msgstr ""

#: src/appendix-02-operators.md:55
msgid "`expr < expr`"
msgstr ""

#: src/appendix-02-operators.md:55
msgid "Less than comparison"
msgstr ""

#: src/appendix-02-operators.md:56
msgid "`<=`"
msgstr ""

#: src/appendix-02-operators.md:56
msgid "`expr <= expr`"
msgstr ""

#: src/appendix-02-operators.md:56
msgid "Less than or equal to comparison"
msgstr ""

#: src/appendix-02-operators.md:57
msgid "`=`"
msgstr ""

#: src/appendix-02-operators.md:57
msgid "`var = expr`, `ident = type`"
msgstr ""

#: src/appendix-02-operators.md:57
msgid "Assignment/equivalence"
msgstr ""

#: src/appendix-02-operators.md:58
msgid "`==`"
msgstr ""

#: src/appendix-02-operators.md:58
msgid "`expr == expr`"
msgstr ""

#: src/appendix-02-operators.md:58
msgid "Equality comparison"
msgstr ""

#: src/appendix-02-operators.md:59
msgid "`=>`"
msgstr ""

#: src/appendix-02-operators.md:59
msgid "`pat => expr`"
msgstr ""

#: src/appendix-02-operators.md:59
msgid "Part of match arm syntax"
msgstr ""

#: src/appendix-02-operators.md:60
msgid "`>`"
msgstr ""

#: src/appendix-02-operators.md:60
msgid "`expr > expr`"
msgstr ""

#: src/appendix-02-operators.md:60
msgid "Greater than comparison"
msgstr ""

#: src/appendix-02-operators.md:61
msgid "`>=`"
msgstr ""

#: src/appendix-02-operators.md:61
msgid "`expr >= expr`"
msgstr ""

#: src/appendix-02-operators.md:61
msgid "Greater than or equal to comparison"
msgstr ""

#: src/appendix-02-operators.md:62
msgid "`>>`"
msgstr ""

#: src/appendix-02-operators.md:62
msgid "`expr >> expr`"
msgstr ""

#: src/appendix-02-operators.md:62
msgid "Right-shift"
msgstr ""

#: src/appendix-02-operators.md:62
msgid "`Shr`"
msgstr ""

#: src/appendix-02-operators.md:63
msgid "`>>=`"
msgstr ""

#: src/appendix-02-operators.md:63
msgid "`var >>= expr`"
msgstr ""

#: src/appendix-02-operators.md:63
msgid "Right-shift and assignment"
msgstr ""

#: src/appendix-02-operators.md:63
msgid "`ShrAssign`"
msgstr ""

#: src/appendix-02-operators.md:64
msgid "`@`"
msgstr ""

#: src/appendix-02-operators.md:64
msgid "`ident @ pat`"
msgstr ""

#: src/appendix-02-operators.md:64
msgid "Pattern binding"
msgstr ""

#: src/appendix-02-operators.md:65
msgid "`^`"
msgstr ""

#: src/appendix-02-operators.md:65
msgid "`expr ^ expr`"
msgstr ""

#: src/appendix-02-operators.md:65
msgid "Bitwise exclusive OR"
msgstr ""

#: src/appendix-02-operators.md:65
msgid "`BitXor`"
msgstr ""

#: src/appendix-02-operators.md:66
msgid "`^=`"
msgstr ""

#: src/appendix-02-operators.md:66
msgid "`var ^= expr`"
msgstr ""

#: src/appendix-02-operators.md:66
msgid "Bitwise exclusive OR and assignment"
msgstr ""

#: src/appendix-02-operators.md:66
msgid "`BitXorAssign`"
msgstr ""

#: src/appendix-02-operators.md:67 src/appendix-02-operators.md:68
msgid "<code>\\|</code>"
msgstr ""

#: src/appendix-02-operators.md:67
msgid "<code>pat \\| pat</code>"
msgstr ""

#: src/appendix-02-operators.md:67
msgid "Pattern alternatives"
msgstr ""

#: src/appendix-02-operators.md:68
msgid "<code>expr \\| expr</code>"
msgstr ""

#: src/appendix-02-operators.md:68
msgid "Bitwise OR"
msgstr ""

#: src/appendix-02-operators.md:68
msgid "`BitOr`"
msgstr ""

#: src/appendix-02-operators.md:69
msgid "<code>\\|=</code>"
msgstr ""

#: src/appendix-02-operators.md:69
msgid "<code>var \\|= expr</code>"
msgstr ""

#: src/appendix-02-operators.md:69
msgid "Bitwise OR and assignment"
msgstr ""

#: src/appendix-02-operators.md:69
msgid "`BitOrAssign`"
msgstr ""

#: src/appendix-02-operators.md:70
msgid "<code>\\|\\|</code>"
msgstr ""

#: src/appendix-02-operators.md:70
msgid "<code>expr \\|\\| expr</code>"
msgstr ""

#: src/appendix-02-operators.md:70
msgid "Short-circuiting logical OR"
msgstr ""

#: src/appendix-02-operators.md:71
msgid "`?`"
msgstr ""

#: src/appendix-02-operators.md:71
msgid "`expr?`"
msgstr ""

#: src/appendix-02-operators.md:71
msgid "Error propagation"
msgstr ""

#: src/appendix-02-operators.md:73
msgid "Non-operator Symbols"
msgstr ""

#: src/appendix-02-operators.md:75
msgid ""
"The following list contains all symbols that don’t function as operators; "
"that is, they don’t behave like a function or method call."
msgstr ""

#: src/appendix-02-operators.md:78
msgid ""
"Table B-2 shows symbols that appear on their own and are valid in a variety "
"of locations."
msgstr ""

#: src/appendix-02-operators.md:81
msgid "<span class=\"caption\">Table B-2: Stand-Alone Syntax</span>"
msgstr ""

#: src/appendix-02-operators.md:83 src/appendix-02-operators.md:102
#: src/appendix-02-operators.md:119 src/appendix-02-operators.md:135
#: src/appendix-02-operators.md:149 src/appendix-02-operators.md:162
#: src/appendix-02-operators.md:175
msgid "Symbol"
msgstr ""

#: src/appendix-02-operators.md:85
msgid "`'ident`"
msgstr ""

#: src/appendix-02-operators.md:85
msgid "Named lifetime or loop label"
msgstr ""

#: src/appendix-02-operators.md:86
msgid "`...u8`, `...i32`, `...f64`, `...usize`, etc."
msgstr ""

#: src/appendix-02-operators.md:86
msgid "Numeric literal of specific type"
msgstr ""

#: src/appendix-02-operators.md:87
msgid "`\"...\"`"
msgstr ""

#: src/appendix-02-operators.md:87
msgid "String literal"
msgstr ""

#: src/appendix-02-operators.md:88
msgid "`r\"...\"`, `r#\"...\"#`, `r##\"...\"##`, etc."
msgstr ""

#: src/appendix-02-operators.md:88
msgid "Raw string literal, escape characters not processed"
msgstr ""

#: src/appendix-02-operators.md:89
msgid "`b\"...\"`"
msgstr ""

#: src/appendix-02-operators.md:89
msgid "Byte string literal; constructs an array of bytes instead of a string"
msgstr ""

#: src/appendix-02-operators.md:90
msgid "`br\"...\"`, `br#\"...\"#`, `br##\"...\"##`, etc."
msgstr ""

#: src/appendix-02-operators.md:90
msgid "Raw byte string literal, combination of raw and byte string literal"
msgstr ""

#: src/appendix-02-operators.md:91
msgid "`'...'`"
msgstr ""

#: src/appendix-02-operators.md:91
msgid "Character literal"
msgstr ""

#: src/appendix-02-operators.md:92
msgid "`b'...'`"
msgstr ""

#: src/appendix-02-operators.md:92
msgid "ASCII byte literal"
msgstr ""

#: src/appendix-02-operators.md:93
msgid "<code>\\|...\\| expr</code>"
msgstr ""

#: src/appendix-02-operators.md:93
msgid "Closure"
msgstr ""

#: src/appendix-02-operators.md:94
msgid "Always empty bottom type for diverging functions"
msgstr ""

#: src/appendix-02-operators.md:95
msgid "`_`"
msgstr ""

#: src/appendix-02-operators.md:95
msgid "“Ignored” pattern binding; also used to make integer literals readable"
msgstr ""

#: src/appendix-02-operators.md:97
msgid ""
"Table B-3 shows symbols that appear in the context of a path through the "
"module hierarchy to an item."
msgstr ""

#: src/appendix-02-operators.md:100
msgid "<span class=\"caption\">Table B-3: Path-Related Syntax</span>"
msgstr ""

#: src/appendix-02-operators.md:104
msgid "`ident::ident`"
msgstr ""

#: src/appendix-02-operators.md:104
msgid "Namespace path"
msgstr ""

#: src/appendix-02-operators.md:105
msgid "`::path`"
msgstr ""

#: src/appendix-02-operators.md:105
msgid ""
"Path relative to the extern prelude, where all other crates are rooted "
"(i.e., an explicitly absolute path including crate name)"
msgstr ""

#: src/appendix-02-operators.md:106
msgid "`self::path`"
msgstr ""

#: src/appendix-02-operators.md:106
msgid ""
"Path relative to the current module (i.e., an explicitly relative path)."
msgstr ""

#: src/appendix-02-operators.md:107
msgid "`super::path`"
msgstr ""

#: src/appendix-02-operators.md:107
msgid "Path relative to the parent of the current module"
msgstr ""

#: src/appendix-02-operators.md:108
msgid "`type::ident`, `<type as trait>::ident`"
msgstr ""

#: src/appendix-02-operators.md:108
msgid "Associated constants, functions, and types"
msgstr ""

#: src/appendix-02-operators.md:109
msgid "`<type>::...`"
msgstr ""

#: src/appendix-02-operators.md:109
msgid ""
"Associated item for a type that cannot be directly named (e.g., `<&T>::...`, "
"`<[T]>::...`, etc.)"
msgstr ""

#: src/appendix-02-operators.md:110
msgid "`trait::method(...)`"
msgstr ""

#: src/appendix-02-operators.md:110
msgid "Disambiguating a method call by naming the trait that defines it"
msgstr ""

#: src/appendix-02-operators.md:111
msgid "`type::method(...)`"
msgstr ""

#: src/appendix-02-operators.md:111
msgid "Disambiguating a method call by naming the type for which it’s defined"
msgstr ""

#: src/appendix-02-operators.md:112
msgid "`<type as trait>::method(...)`"
msgstr ""

#: src/appendix-02-operators.md:112
msgid "Disambiguating a method call by naming the trait and type"
msgstr ""

#: src/appendix-02-operators.md:114
msgid ""
"Table B-4 shows symbols that appear in the context of using generic type "
"parameters."
msgstr ""

#: src/appendix-02-operators.md:117
msgid "<span class=\"caption\">Table B-4: Generics</span>"
msgstr ""

#: src/appendix-02-operators.md:121
msgid "`path<...>`"
msgstr ""

#: src/appendix-02-operators.md:121
msgid "Specifies parameters to generic type in a type (e.g., `Vec<u8>`)"
msgstr ""

#: src/appendix-02-operators.md:122
msgid "`path::<...>`, `method::<...>`"
msgstr ""

#: src/appendix-02-operators.md:122
msgid ""
"Specifies parameters to generic type, function, or method in an expression; "
"often referred to as turbofish (e.g., `\"42\".parse::<i32>()`)"
msgstr ""

#: src/appendix-02-operators.md:123
msgid "`fn ident<...> ...`"
msgstr ""

#: src/appendix-02-operators.md:123
msgid "Define generic function"
msgstr ""

#: src/appendix-02-operators.md:124
msgid "`struct ident<...> ...`"
msgstr ""

#: src/appendix-02-operators.md:124
msgid "Define generic structure"
msgstr ""

#: src/appendix-02-operators.md:125
msgid "`enum ident<...> ...`"
msgstr ""

#: src/appendix-02-operators.md:125
msgid "Define generic enumeration"
msgstr ""

#: src/appendix-02-operators.md:126
msgid "`impl<...> ...`"
msgstr ""

#: src/appendix-02-operators.md:126
msgid "Define generic implementation"
msgstr ""

#: src/appendix-02-operators.md:127
msgid "`for<...> type`"
msgstr ""

#: src/appendix-02-operators.md:127
msgid "Higher-ranked lifetime bounds"
msgstr ""

#: src/appendix-02-operators.md:128
msgid "`type<ident=type>`"
msgstr ""

#: src/appendix-02-operators.md:128
msgid ""
"A generic type where one or more associated types have specific assignments "
"(e.g., `Iterator<Item=T>`)"
msgstr ""

#: src/appendix-02-operators.md:130
msgid ""
"Table B-5 shows symbols that appear in the context of constraining generic "
"type parameters with trait bounds."
msgstr ""

#: src/appendix-02-operators.md:133
msgid "<span class=\"caption\">Table B-5: Trait Bound Constraints</span>"
msgstr ""

#: src/appendix-02-operators.md:137
msgid "`T: U`"
msgstr ""

#: src/appendix-02-operators.md:137
msgid "Generic parameter `T` constrained to types that implement `U`"
msgstr ""

#: src/appendix-02-operators.md:138
msgid "`T: 'a`"
msgstr ""

#: src/appendix-02-operators.md:138
msgid ""
"Generic type `T` must outlive lifetime `'a` (meaning the type cannot "
"transitively contain any references with lifetimes shorter than `'a`)"
msgstr ""

#: src/appendix-02-operators.md:139
msgid "`T: 'static`"
msgstr ""

#: src/appendix-02-operators.md:139
msgid ""
"Generic type `T` contains no borrowed references other than `'static` ones"
msgstr ""

#: src/appendix-02-operators.md:140
msgid "`'b: 'a`"
msgstr ""

#: src/appendix-02-operators.md:140
msgid "Generic lifetime `'b` must outlive lifetime `'a`"
msgstr ""

#: src/appendix-02-operators.md:141
msgid "`T: ?Sized`"
msgstr ""

#: src/appendix-02-operators.md:141
msgid "Allow generic type parameter to be a dynamically sized type"
msgstr ""

#: src/appendix-02-operators.md:142
msgid "`'a + trait`, `trait + trait`"
msgstr ""

#: src/appendix-02-operators.md:144
msgid ""
"Table B-6 shows symbols that appear in the context of calling or defining "
"macros and specifying attributes on an item."
msgstr ""

#: src/appendix-02-operators.md:147
msgid "<span class=\"caption\">Table B-6: Macros and Attributes</span>"
msgstr ""

#: src/appendix-02-operators.md:151
msgid "`#[meta]`"
msgstr ""

#: src/appendix-02-operators.md:151
msgid "Outer attribute"
msgstr ""

#: src/appendix-02-operators.md:152
msgid "`#![meta]`"
msgstr ""

#: src/appendix-02-operators.md:152
msgid "Inner attribute"
msgstr ""

#: src/appendix-02-operators.md:153
msgid "`$ident`"
msgstr ""

#: src/appendix-02-operators.md:153
msgid "Macro substitution"
msgstr ""

#: src/appendix-02-operators.md:154
msgid "`$ident:kind`"
msgstr ""

#: src/appendix-02-operators.md:154
msgid "Macro capture"
msgstr ""

#: src/appendix-02-operators.md:155
msgid "`$(…)…`"
msgstr ""

#: src/appendix-02-operators.md:155
msgid "Macro repetition"
msgstr ""

#: src/appendix-02-operators.md:156
msgid "Macro invocation"
msgstr ""

#: src/appendix-02-operators.md:158
msgid "Table B-7 shows symbols that create comments."
msgstr ""

#: src/appendix-02-operators.md:160
msgid "<span class=\"caption\">Table B-7: Comments</span>"
msgstr ""

#: src/appendix-02-operators.md:164
msgid "`//`"
msgstr ""

#: src/appendix-02-operators.md:164
msgid "Line comment"
msgstr ""

#: src/appendix-02-operators.md:165
msgid "`//!`"
msgstr ""

#: src/appendix-02-operators.md:165
msgid "Inner line doc comment"
msgstr ""

#: src/appendix-02-operators.md:166
msgid "`///`"
msgstr ""

#: src/appendix-02-operators.md:166
msgid "Outer line doc comment"
msgstr ""

#: src/appendix-02-operators.md:167
msgid "`/*...*/`"
msgstr ""

#: src/appendix-02-operators.md:167
msgid "Block comment"
msgstr ""

#: src/appendix-02-operators.md:168
msgid "`/*!...*/`"
msgstr ""

#: src/appendix-02-operators.md:168
msgid "Inner block doc comment"
msgstr ""

#: src/appendix-02-operators.md:169
msgid "`/**...*/`"
msgstr ""

#: src/appendix-02-operators.md:169
msgid "Outer block doc comment"
msgstr ""

#: src/appendix-02-operators.md:171
msgid "Table B-8 shows symbols that appear in the context of using tuples."
msgstr ""

#: src/appendix-02-operators.md:173
msgid "<span class=\"caption\">Table B-8: Tuples</span>"
msgstr ""

#: src/appendix-02-operators.md:177
msgid "`()`"
msgstr ""

#: src/appendix-02-operators.md:177
msgid "Empty tuple (aka unit), both literal and type"
msgstr ""

#: src/appendix-02-operators.md:178
msgid "`(expr)`"
msgstr ""

#: src/appendix-02-operators.md:178
msgid "Parenthesized expression"
msgstr ""

#: src/appendix-02-operators.md:179
msgid "`(expr,)`"
msgstr ""

#: src/appendix-02-operators.md:179
msgid "Single-element tuple expression"
msgstr ""

#: src/appendix-02-operators.md:180
msgid "`(type,)`"
msgstr ""

#: src/appendix-02-operators.md:180
msgid "Single-element tuple type"
msgstr ""

#: src/appendix-02-operators.md:181
msgid "`(expr, ...)`"
msgstr ""

#: src/appendix-02-operators.md:181
msgid "Tuple expression"
msgstr ""

#: src/appendix-02-operators.md:182
msgid "`(type, ...)`"
msgstr ""

#: src/appendix-02-operators.md:182
msgid "Tuple type"
msgstr ""

#: src/appendix-02-operators.md:183
msgid "`expr(expr, ...)`"
msgstr ""

#: src/appendix-02-operators.md:183
msgid ""
"Function call expression; also used to initialize tuple `struct`s and tuple "
"`enum` variants"
msgstr ""

#: src/appendix-02-operators.md:184
msgid "`expr.0`, `expr.1`, etc."
msgstr ""

#: src/appendix-02-operators.md:184
msgid "Tuple indexing"
msgstr ""

#: src/appendix-02-operators.md:186
msgid "Table B-9 shows the contexts in which curly braces are used."
msgstr ""

#: src/appendix-02-operators.md:188
msgid "<span class=\"caption\">Table B-9: Curly Brackets</span>"
msgstr ""

#: src/appendix-02-operators.md:190 src/appendix-02-operators.md:199
msgid "Context"
msgstr ""

#: src/appendix-02-operators.md:192
msgid "`{...}`"
msgstr ""

#: src/appendix-02-operators.md:192
msgid "Block expression"
msgstr ""

#: src/appendix-02-operators.md:193
msgid "`Type {...}`"
msgstr ""

#: src/appendix-02-operators.md:193
msgid "`struct` literal"
msgstr ""

#: src/appendix-02-operators.md:195
msgid "Table B-10 shows the contexts in which square brackets are used."
msgstr ""

#: src/appendix-02-operators.md:197
msgid "<span class=\"caption\">Table B-10: Square Brackets</span>"
msgstr ""

#: src/appendix-02-operators.md:201
msgid "`[...]`"
msgstr ""

#: src/appendix-02-operators.md:201
msgid "Array literal"
msgstr ""

#: src/appendix-02-operators.md:202
msgid "`[expr; len]`"
msgstr ""

#: src/appendix-02-operators.md:202
msgid "Array literal containing `len` copies of `expr`"
msgstr ""

#: src/appendix-02-operators.md:203
msgid "`[type; len]`"
msgstr ""

#: src/appendix-02-operators.md:203
msgid "Array type containing `len` instances of `type`"
msgstr ""

#: src/appendix-02-operators.md:204
msgid "`expr[expr]`"
msgstr ""

#: src/appendix-02-operators.md:204
msgid "Collection indexing. Overloadable (`Index`, `IndexMut`)"
msgstr ""

#: src/appendix-02-operators.md:205
msgid "`expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]`"
msgstr ""

#: src/appendix-02-operators.md:205
msgid ""
"Collection indexing pretending to be collection slicing, using `Range`, "
"`RangeFrom`, `RangeTo`, or `RangeFull` as the “index”"
msgstr ""

#: src/appendix-03-derivable-traits.md:1
msgid "Appendix C: Derivable Traits"
msgstr ""

#: src/appendix-03-derivable-traits.md:3
msgid ""
"In various places in the book, we’ve discussed the `derive` attribute, which "
"you can apply to a struct or enum definition. The `derive` attribute "
"generates code that will implement a trait with its own default "
"implementation on the type you’ve annotated with the `derive` syntax."
msgstr ""

#: src/appendix-03-derivable-traits.md:8
msgid ""
"In this appendix, we provide a reference of all the traits in the standard "
"library that you can use with `derive`. Each section covers:"
msgstr ""

#: src/appendix-03-derivable-traits.md:11
msgid "What operators and methods deriving this trait will enable"
msgstr ""

#: src/appendix-03-derivable-traits.md:12
msgid "What the implementation of the trait provided by `derive` does"
msgstr ""

#: src/appendix-03-derivable-traits.md:13
msgid "What implementing the trait signifies about the type"
msgstr ""

#: src/appendix-03-derivable-traits.md:14
msgid ""
"The conditions in which you’re allowed or not allowed to implement the trait"
msgstr ""

#: src/appendix-03-derivable-traits.md:15
msgid "Examples of operations that require the trait"
msgstr ""

#: src/appendix-03-derivable-traits.md:17
msgid ""
"If you want different behavior from that provided by the `derive` attribute, "
"consult the [standard library documentation](../std/index.html)<!-- ignore --"
"> for each trait for details of how to manually implement them."
msgstr ""

#: src/appendix-03-derivable-traits.md:21
msgid ""
"These traits listed here are the only ones defined by the standard library "
"that can be implemented on your types using `derive`. Other traits defined "
"in the standard library don’t have sensible default behavior, so it’s up to "
"you to implement them in the way that makes sense for what you’re trying to "
"accomplish."
msgstr ""

#: src/appendix-03-derivable-traits.md:26
msgid ""
"An example of a trait that can’t be derived is `Display`, which handles "
"formatting for end users. You should always consider the appropriate way to "
"display a type to an end user. What parts of the type should an end user be "
"allowed to see? What parts would they find relevant? What format of the data "
"would be most relevant to them? The Rust compiler doesn’t have this insight, "
"so it can’t provide appropriate default behavior for you."
msgstr ""

#: src/appendix-03-derivable-traits.md:33
msgid ""
"The list of derivable traits provided in this appendix is not comprehensive: "
"libraries can implement `derive` for their own traits, making the list of "
"traits you can use `derive` with truly open-ended. Implementing `derive` "
"involves using a procedural macro, which is covered in the [“Macros”]"
"(ch20-05-macros.html#macros)<!-- ignore --> section of Chapter 20."
msgstr ""

#: src/appendix-03-derivable-traits.md:39
msgid "`Debug` for Programmer Output"
msgstr ""

#: src/appendix-03-derivable-traits.md:41
msgid ""
"The `Debug` trait enables debug formatting in format strings, which you "
"indicate by adding `:?` within `{}` placeholders."
msgstr ""

#: src/appendix-03-derivable-traits.md:44
msgid ""
"The `Debug` trait allows you to print instances of a type for debugging "
"purposes, so you and other programmers using your type can inspect an "
"instance at a particular point in a program’s execution."
msgstr ""

#: src/appendix-03-derivable-traits.md:48
msgid ""
"The `Debug` trait is required, for example, in using the `assert_eq!` macro. "
"This macro prints the values of instances given as arguments if the equality "
"assertion fails so programmers can see why the two instances weren’t equal."
msgstr ""

#: src/appendix-03-derivable-traits.md:52
msgid "`PartialEq` and `Eq` for Equality Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:54
msgid ""
"The `PartialEq` trait allows you to compare instances of a type to check for "
"equality and enables use of the `==` and `!=` operators."
msgstr ""

#: src/appendix-03-derivable-traits.md:57
msgid ""
"Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived "
"on structs, two instances are equal only if _all_ fields are equal, and the "
"instances are not equal if any fields are not equal. When derived on enums, "
"each variant is equal to itself and not equal to the other variants."
msgstr ""

#: src/appendix-03-derivable-traits.md:62
msgid ""
"The `PartialEq` trait is required, for example, with the use of the "
"`assert_eq!` macro, which needs to be able to compare two instances of a "
"type for equality."
msgstr ""

#: src/appendix-03-derivable-traits.md:66
msgid ""
"The `Eq` trait has no methods. Its purpose is to signal that for every value "
"of the annotated type, the value is equal to itself. The `Eq` trait can only "
"be applied to types that also implement `PartialEq`, although not all types "
"that implement `PartialEq` can implement `Eq`. One example of this is "
"floating point number types: the implementation of floating point numbers "
"states that two instances of the not-a-number (`NaN`) value are not equal to "
"each other."
msgstr ""

#: src/appendix-03-derivable-traits.md:73
msgid ""
"An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the "
"`HashMap<K, V>` can tell whether two keys are the same."
msgstr ""

#: src/appendix-03-derivable-traits.md:76
msgid "`PartialOrd` and `Ord` for Ordering Comparisons"
msgstr ""

#: src/appendix-03-derivable-traits.md:78
msgid ""
"The `PartialOrd` trait allows you to compare instances of a type for sorting "
"purposes. A type that implements `PartialOrd` can be used with the `<`, `>`, "
"`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types "
"that also implement `PartialEq`."
msgstr ""

#: src/appendix-03-derivable-traits.md:83
msgid ""
"Deriving `PartialOrd` implements the `partial_cmp` method, which returns an "
"`Option<Ordering>` that will be `None` when the values given don’t produce "
"an ordering. An example of a value that doesn’t produce an ordering, even "
"though most values of that type can be compared, is the `NaN` floating point "
"value. Calling `partial_cmp` with any floating point number and the `NaN` "
"floating point value will return `None`."
msgstr ""

#: src/appendix-03-derivable-traits.md:90
msgid ""
"When derived on structs, `PartialOrd` compares two instances by comparing "
"the value in each field in the order in which the fields appear in the "
"struct definition. When derived on enums, variants of the enum declared "
"earlier in the enum definition are considered less than the variants listed "
"later."
msgstr ""

#: src/appendix-03-derivable-traits.md:95
msgid ""
"The `PartialOrd` trait is required, for example, for the `gen_range` method "
"from the `rand` crate that generates a random value in the range specified "
"by a range expression."
msgstr ""

#: src/appendix-03-derivable-traits.md:99
msgid ""
"The `Ord` trait allows you to know that for any two values of the annotated "
"type, a valid ordering will exist. The `Ord` trait implements the `cmp` "
"method, which returns an `Ordering` rather than an `Option<Ordering>` "
"because a valid ordering will always be possible. You can only apply the "
"`Ord` trait to types that also implement `PartialOrd` and `Eq` (and `Eq` "
"requires `PartialEq`). When derived on structs and enums, `cmp` behaves the "
"same way as the derived implementation for `partial_cmp` does with "
"`PartialOrd`."
msgstr ""

#: src/appendix-03-derivable-traits.md:107
msgid ""
"An example of when `Ord` is required is when storing values in a "
"`BTreeSet<T>`, a data structure that stores data based on the sort order of "
"the values."
msgstr ""

#: src/appendix-03-derivable-traits.md:110
msgid "`Clone` and `Copy` for Duplicating Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:112
msgid ""
"The `Clone` trait allows you to explicitly create a deep copy of a value, "
"and the duplication process might involve running arbitrary code and copying "
"heap data. See [Variables and Data Interacting with Clone”](ch04-01-what-is-"
"ownership.html#variables-and-data-interacting-with-clone)<!-- ignore --> in "
"Chapter 4 for more information on `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:118
msgid ""
"Deriving `Clone` implements the `clone` method, which when implemented for "
"the whole type, calls `clone` on each of the parts of the type. This means "
"all the fields or values in the type must also implement `Clone` to derive "
"`Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:122
msgid ""
"An example of when `Clone` is required is when calling the `to_vec` method "
"on a slice. The slice doesn’t own the type instances it contains, but the "
"vector returned from `to_vec` will need to own its instances, so `to_vec` "
"calls `clone` on each item. Thus, the type stored in the slice must "
"implement `Clone`."
msgstr ""

#: src/appendix-03-derivable-traits.md:127
msgid ""
"The `Copy` trait allows you to duplicate a value by only copying bits stored "
"on the stack; no arbitrary code is necessary. See [“Stack-Only Data: Copy”]"
"(ch04-01-what-is-ownership.html#stack-only-data-copy)<!-- ignore --> in "
"Chapter 4 for more information on `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:132
msgid ""
"The `Copy` trait doesn’t define any methods to prevent programmers from "
"overloading those methods and violating the assumption that no arbitrary "
"code is being run. That way, all programmers can assume that copying a value "
"will be very fast."
msgstr ""

#: src/appendix-03-derivable-traits.md:137
msgid ""
"You can derive `Copy` on any type whose parts all implement `Copy`. A type "
"that implements `Copy` must also implement `Clone`, because a type that "
"implements `Copy` has a trivial implementation of `Clone` that performs the "
"same task as `Copy`."
msgstr ""

#: src/appendix-03-derivable-traits.md:142
msgid ""
"The `Copy` trait is rarely required; types that implement `Copy` have "
"optimizations available, meaning you don’t have to call `clone`, which makes "
"the code more concise."
msgstr ""

#: src/appendix-03-derivable-traits.md:146
msgid ""
"Everything possible with `Copy` you can also accomplish with `Clone`, but "
"the code might be slower or have to use `clone` in places."
msgstr ""

#: src/appendix-03-derivable-traits.md:149
msgid "`Hash` for Mapping a Value to a Value of Fixed Size"
msgstr ""

#: src/appendix-03-derivable-traits.md:151
msgid ""
"The `Hash` trait allows you to take an instance of a type of arbitrary size "
"and map that instance to a value of fixed size using a hash function. "
"Deriving `Hash` implements the `hash` method. The derived implementation of "
"the `hash` method combines the result of calling `hash` on each of the parts "
"of the type, meaning all fields or values must also implement `Hash` to "
"derive `Hash`."
msgstr ""

#: src/appendix-03-derivable-traits.md:157
msgid ""
"An example of when `Hash` is required is in storing keys in a `HashMap<K, "
"V>` to store data efficiently."
msgstr ""

#: src/appendix-03-derivable-traits.md:160
msgid "`Default` for Default Values"
msgstr ""

#: src/appendix-03-derivable-traits.md:162
msgid ""
"The `Default` trait allows you to create a default value for a type. "
"Deriving `Default` implements the `default` function. The derived "
"implementation of the `default` function calls the `default` function on "
"each part of the type, meaning all fields or values in the type must also "
"implement `Default` to derive `Default`."
msgstr ""

#: src/appendix-03-derivable-traits.md:168
msgid ""
"The `Default::default` function is commonly used in combination with the "
"struct update syntax discussed in [“Creating Instances From Other Instances "
"With Struct Update Syntax”](ch05-01-defining-structs.html#creating-instances-"
"from-other-instances-with-struct-update-syntax)<!--\n"
"ignore --> in Chapter 5. You can customize a few fields of a struct and then "
"set and use a default value for the rest of the fields by using "
"`..Default::default()`."
msgstr ""

#: src/appendix-03-derivable-traits.md:176
msgid ""
"The `Default` trait is required when you use the method `unwrap_or_default` "
"on `Option<T>` instances, for example. If the `Option<T>` is `None`, the "
"method `unwrap_or_default` will return the result of `Default::default` for "
"the type `T` stored in the `Option<T>`."
msgstr ""

#: src/appendix-04-useful-development-tools.md:1
msgid "Appendix D - Useful Development Tools"
msgstr ""

#: src/appendix-04-useful-development-tools.md:3
msgid ""
"In this appendix, we talk about some useful development tools that the Rust "
"project provides. We’ll look at automatic formatting, quick ways to apply "
"warning fixes, a linter, and integrating with IDEs."
msgstr ""

#: src/appendix-04-useful-development-tools.md:7
msgid "Automatic Formatting with `rustfmt`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:9
msgid ""
"The `rustfmt` tool reformats your code according to the community code "
"style. Many collaborative projects use `rustfmt` to prevent arguments about "
"which style to use when writing Rust: everyone formats their code using the "
"tool."
msgstr ""

#: src/appendix-04-useful-development-tools.md:13
msgid "To install `rustfmt`, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:19
msgid ""
"This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives "
"you both `rustc` and `cargo`. To format any Cargo project, enter the "
"following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:26
msgid ""
"Running this command reformats all the Rust code in the current crate. This "
"should only change the code style, not the code semantics. For more "
"information on `rustfmt`, see [its documentation](https://github.com/rust-"
"lang/rustfmt)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:32
msgid "Fix Your Code with `rustfix`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:34
msgid ""
"The rustfix tool is included with Rust installations and can automatically "
"fix compiler warnings that have a clear way to correct the problem that’s "
"likely what you want. It’s likely you’ve seen compiler warnings before. For "
"example, consider this code:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:48
msgid ""
"Here, we’re defining variable `x` as mutable, but we never actually mutate "
"it. Rust warns us about that:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:51
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling myprogram v0.1.0 (file:///projects/myprogram)\n"
"warning: variable does not need to be mutable\n"
" --> src/main.rs:2:9\n"
"  |\n"
"2 |     let mut x = 0;\n"
"  |         ----^\n"
"  |         |\n"
"  |         help: remove this `mut`\n"
"  |\n"
"  = note: `#[warn(unused_mut)]` on by default\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:65
msgid ""
"The warning suggests that we remove the `mut` keyword. We can automatically "
"apply that suggestion using the `rustfix` tool by running the command `cargo "
"fix`:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:69
msgid ""
"```console\n"
"$ cargo fix\n"
"    Checking myprogram v0.1.0 (file:///projects/myprogram)\n"
"      Fixing src/main.rs (1 fix)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:76
msgid ""
"When we look at _src/main.rs_ again, we’ll see that `cargo fix` has changed "
"the code:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:88
msgid "The `x` variable is now immutable, and the warning no longer appears."
msgstr ""

#: src/appendix-04-useful-development-tools.md:90
msgid ""
"You can also use the `cargo fix` command to transition your code between "
"different Rust editions. Editions are covered in [Appendix E](appendix-05-"
"editions.md)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:93
msgid "More Lints with Clippy"
msgstr ""

#: src/appendix-04-useful-development-tools.md:95
msgid ""
"The Clippy tool is a collection of lints to analyze your code so you can "
"catch common mistakes and improve your Rust code."
msgstr ""

#: src/appendix-04-useful-development-tools.md:98
msgid "To install Clippy, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:104
msgid "To run Clippy’s lints on any Cargo project, enter the following:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:110
msgid ""
"For example, say you write a program that uses an approximation of a "
"mathematical constant, such as pi, as this program does:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:119
#: src/appendix-04-useful-development-tools.md:148
msgid "\"the area of the circle is {}\""
msgstr ""

#: src/appendix-04-useful-development-tools.md:123
msgid "Running `cargo clippy` on this project results in this error:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:125
msgid ""
"```text\n"
"error: approximate value of `f{32, 64}::consts::PI` found\n"
" --> src/main.rs:2:13\n"
"  |\n"
"2 |     let x = 3.1415;\n"
"  |             ^^^^^^\n"
"  |\n"
"  = note: `#[deny(clippy::approx_constant)]` on by default\n"
"  = help: consider using the constant directly\n"
"  = help: for further information visit https://rust-lang.github.io/rust-"
"clippy/master/index.html#approx_constant\n"
"```"
msgstr ""

#: src/appendix-04-useful-development-tools.md:137
msgid ""
"This error lets you know that Rust already has a more precise `PI` constant "
"defined, and that your program would be more correct if you used the "
"constant instead. You would then change your code to use the `PI` constant. "
"The following code doesn’t result in any errors or warnings from Clippy:"
msgstr ""

#: src/appendix-04-useful-development-tools.md:152
msgid ""
"For more information on Clippy, see [its documentation](https://github.com/"
"rust-lang/rust-clippy)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:156
msgid "IDE Integration Using `rust-analyzer`"
msgstr ""

#: src/appendix-04-useful-development-tools.md:158
msgid ""
"To help IDE integration, the Rust community recommends using [`rust-"
"analyzer`](https://rust-analyzer.github.io)<!-- ignore -->. This tool is a "
"set of compiler-centric utilities that speaks the [Language Server Protocol]"
"(http://langserver.org/)<!--\n"
"ignore -->, which is a specification for IDEs and programming languages to "
"communicate with each other. Different clients can use `rust-analyzer`, such "
"as [the Rust analyzer plug-in for Visual Studio Code](https://"
"marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)."
msgstr ""

#: src/appendix-04-useful-development-tools.md:168
msgid ""
"Visit the `rust-analyzer` project’s [home page](https://rust-"
"analyzer.github.io)<!-- ignore --> for installation instructions, then "
"install the language server support in your particular IDE. Your IDE will "
"gain abilities such as autocompletion, jump to definition, and inline errors."
msgstr ""
"`rust-analyzer` 프로젝트의 [홈페이지](https://rust-"
"analyzer.github.io)<!-- ignore -->에서 설치 지침을 확인한 다음, "
"사용 중인 IDE에 언어 서버 지원을 설치하세요. 그러면 자동 완성, 정의로 이동, 인라인 오류와 같은 기능을 IDE에서 사용할 수 있습니다."

#: src/appendix-05-editions.md:1
msgid "Appendix E - Editions"
msgstr "부록 E - 에디션"

#: src/appendix-05-editions.md:3
msgid ""
"In Chapter 1, you saw that `cargo new` adds a bit of metadata to your "
"_Cargo.toml_ file about an edition. This appendix talks about what that "
"means!"
msgstr ""

#: src/appendix-05-editions.md:6
msgid ""
"The Rust language and compiler have a six-week release cycle, meaning users "
"get a constant stream of new features. Other programming languages release "
"larger changes less often; Rust releases smaller updates more frequently. "
"After a while, all of these tiny changes add up. But from release to "
"release, it can be difficult to look back and say, “Wow, between Rust 1.10 "
"and Rust 1.31, Rust has changed a lot!”"
msgstr ""

#: src/appendix-05-editions.md:13
msgid ""
"Every two or three years, the Rust team produces a new Rust _edition_. Each "
"edition brings together the features that have landed into a clear package "
"with fully updated documentation and tooling. New editions ship as part of "
"the usual six-week release process."
msgstr ""

#: src/appendix-05-editions.md:18
msgid "Editions serve different purposes for different people:"
msgstr ""

#: src/appendix-05-editions.md:20
msgid ""
"For active Rust users, a new edition brings together incremental changes "
"into an easy-to-understand package."
msgstr ""

#: src/appendix-05-editions.md:22
msgid ""
"For non-users, a new edition signals that some major advancements have "
"landed, which might make Rust worth another look."
msgstr ""

#: src/appendix-05-editions.md:24
msgid ""
"For those developing Rust, a new edition provides a rallying point for the "
"project as a whole."
msgstr ""

#: src/appendix-05-editions.md:27
msgid ""
"At the time of this writing, four Rust editions are available: Rust 2015, "
"Rust 2018, Rust 2021, and Rust 2024. This book is written using Rust 2024 "
"edition idioms."
msgstr ""

#: src/appendix-05-editions.md:31
msgid ""
"The `edition` key in _Cargo.toml_ indicates which edition the compiler "
"should use for your code. If the key doesn’t exist, Rust uses `2015` as the "
"edition value for backward compatibility reasons."
msgstr ""

#: src/appendix-05-editions.md:35
msgid ""
"Each project can opt in to an edition other than the default 2015 edition. "
"Editions can contain incompatible changes, such as including a new keyword "
"that conflicts with identifiers in code. However, unless you opt in to those "
"changes, your code will continue to compile even as you upgrade the Rust "
"compiler version you use."
msgstr ""

#: src/appendix-05-editions.md:41
msgid ""
"All Rust compiler versions support any edition that existed prior to that "
"compiler’s release, and they can link crates of any supported editions "
"together. Edition changes only affect the way the compiler initially parses "
"code. Therefore, if you’re using Rust 2015 and one of your dependencies uses "
"Rust 2018, your project will compile and be able to use that dependency. The "
"opposite situation, where your project uses Rust 2018 and a dependency uses "
"Rust 2015, works as well."
msgstr ""

#: src/appendix-05-editions.md:49
msgid ""
"To be clear: most features will be available on all editions. Developers "
"using any Rust edition will continue to see improvements as new stable "
"releases are made. However, in some cases, mainly when new keywords are "
"added, some new features might only be available in later editions. You will "
"need to switch editions if you want to take advantage of such features."
msgstr ""

#: src/appendix-05-editions.md:55
msgid ""
"For more details, the [_Edition Guide_](https://doc.rust-lang.org/stable/"
"edition-guide/) is a complete book about editions that enumerates the "
"differences between editions and explains how to automatically upgrade your "
"code to a new edition via `cargo fix`."
msgstr ""

#: src/appendix-06-translation.md:1
msgid "Appendix F: Translations of the Book"
msgstr "부록 F: 책의 번역본"

#: src/appendix-06-translation.md:3
msgid ""
"For resources in languages other than English. Most are still in progress; "
"see [the Translations label](https://github.com/rust-lang/book/issues?"
"q=is%3Aopen+is%3Aissue+label%3ATranslations) to help or let us know about a "
"new translation!"
msgstr ""
"영어가 아닌 다른 언어로 된 자료입니다. 대부분 아직 진행 중입니다. "
"[번역 레이블](https://github.com/rust-lang/book/issues?"
"q=is%3Aopen+is%3Aissue+label%3ATranslations)을 참조하여 도움을 주시거나 새로운 번역에 대해 알려주세요!"

#: src/appendix-06-translation.md:8
msgid "[Português](https://github.com/rust-br/rust-book-pt-br) (BR)"
msgstr "[Português](https://github.com/rust-br/rust-book-pt-br) (BR)"

#: src/appendix-06-translation.md:9
msgid "[Português](https://github.com/nunojesus/rust-book-pt-pt) (PT)"
msgstr "[Português](https://github.com/nunojesus/rust-book-pt-pt) (PT)"

#: src/appendix-06-translation.md:10
msgid ""
"简体中文: [KaiserY/trpl-zh-cn](https://github.com/KaiserY/trpl-zh-cn), "
"[gnu4cn/rust-lang-Zh_CN](https://github.com/gnu4cn/rust-lang-Zh_CN)"
msgstr ""
"简体中文: [KaiserY/trpl-zh-cn](https://github.com/KaiserY/trpl-zh-cn), "
"[gnu4cn/rust-lang-Zh_CN](https://github.com/gnu4cn/rust-lang-Zh_CN)"

#: src/appendix-06-translation.md:11
msgid "[正體中文](https://github.com/rust-tw/book-tw)"
msgstr "[正體中文](https://github.com/rust-tw/book-tw)"

#: src/appendix-06-translation.md:12
msgid "[Українська](https://rust-lang-ua.github.io/rustbook_ukrainian)"
msgstr "[Українська](https://rust-lang-ua.github.io/rustbook_ukrainian)"

#: src/appendix-06-translation.md:13
msgid ""
"[Español](https://github.com/thecodix/book), [alternate](https://github.com/"
"ManRR/rust-book-es), [Español por RustLangES](https://github.com/RustLangES/"
"rust-book-es)"
msgstr ""
"[Español](https://github.com/thecodix/book), [alternate](https://github.com/"
"ManRR/rust-book-es), [Español por RustLangES](https://github.com/RustLangES/"
"rust-book-es)"

#: src/appendix-06-translation.md:14
msgid "[Русский](https://github.com/rust-lang-ru/book)"
msgstr "[Русский](https://github.com/rust-lang-ru/book)"

#: src/appendix-06-translation.md:15
msgid "[한국어](https://github.com/rust-kr/doc.rust-kr.org)"
msgstr "[한국어](https://github.com/rust-kr/doc.rust-kr.org)"

#: src/appendix-06-translation.md:16
msgid "[日本語](https://github.com/rust-lang-ja/book-ja)"
msgstr "[日本語](https://github.com/rust-lang-ja/book-ja)"

#: src/appendix-06-translation.md:17
msgid "[Français](https://github.com/Jimskapt/rust-book-fr)"
msgstr "[Français](https://github.com/Jimskapt/rust-book-fr)"

#: src/appendix-06-translation.md:18
msgid "[Polski](https://github.com/paytchoo/book-pl)"
msgstr "[Polski](https://github.com/paytchoo/book-pl)"

#: src/appendix-06-translation.md:19
msgid "[Cebuano](https://github.com/agentzero1/book)"
msgstr "[Cebuano](https://github.com/agentzero1/book)"

#: src/appendix-06-translation.md:20
msgid "[Tagalog](https://github.com/josephace135/book)"
msgstr "[Tagalog](https://github.com/josephace135/book)"

#: src/appendix-06-translation.md:21
msgid "[Esperanto](https://github.com/psychoslave/Rust-libro)"
msgstr "[Esperanto](https://github.com/psychoslave/Rust-libro)"

#: src/appendix-06-translation.md:22
msgid "[ελληνική](https://github.com/TChatzigiannakis/rust-book-greek)"
msgstr "[ελληνική](https://github.com/TChatzigiannakis/rust-book-greek)"

#: src/appendix-06-translation.md:23
msgid "[Svenska](https://github.com/sebras/book)"
msgstr "[Svenska](https://github.com/sebras/book)"

#: src/appendix-06-translation.md:24
msgid ""
"[Farsi](https://github.com/RustFarsi/book), [Persian (FA)](https://"
"github.com/persian-rust/book)"
msgstr ""
"[Farsi](https://github.com/RustFarsi/book), [Persian (FA)](https://"
"github.com/persian-rust/book)"

#: src/appendix-06-translation.md:25
msgid "[Deutsch](https://github.com/rust-lang-de/rustbook-de)"
msgstr "[Deutsch](https://github.com/rust-lang-de/rustbook-de)"

#: src/appendix-06-translation.md:26
msgid "[हिंदी](https://github.com/venkatarun95/rust-book-hindi)"
msgstr "[हिंदी](https://github.com/venkatarun95/rust-book-hindi)"

#: src/appendix-06-translation.md:27
msgid "[ไทย](https://github.com/rust-lang-th/book-th)"
msgstr "[ไทย](https://github.com/rust-lang-th/book-th)"

#: src/appendix-06-translation.md:28
msgid "[Danske](https://github.com/DanKHansen/book-dk)"
msgstr "[Danske](https://github.com/DanKHansen/book-dk)"

#: src/appendix-07-nightly-rust.md:1
msgid "Appendix G - How Rust is Made and “Nightly Rust”"
msgstr "부록 G - Rust는 어떻게 만들어지며 “Nightly Rust”란 무엇인가"

#: src/appendix-07-nightly-rust.md:3
msgid ""
"This appendix is about how Rust is made and how that affects you as a Rust "
"developer."
msgstr ""
"이 부록은 Rust가 어떻게 만들어지는지와 그것이 Rust 개발자로서 당신에게 어떤 영향을 미치는지에 대한 내용입니다."

#: src/appendix-07-nightly-rust.md:6
msgid "Stability Without Stagnation"
msgstr "정체 없는 안정성"

#: src/appendix-07-nightly-rust.md:8
msgid ""
"As a language, Rust cares a _lot_ about the stability of your code. We want "
"Rust to be a rock-solid foundation you can build on, and if things were "
"constantly changing, that would be impossible. At the same time, if we can’t "
"experiment with new features, we may not find out important flaws until "
"after their release, when we can no longer change things."
msgstr ""
"언어로서 Rust는 코드의 안정성에 대해 _매우_ 중요하게 생각합니다. "
"우리는 Rust가 여러분이 구축할 수 있는 견고한 기반이 되기를 원하며, 만약 상황이 계속해서 바뀐다면 그것은 불가능할 것입니다. "
"동시에, 새로운 기능을 실험할 수 없다면, 출시 후에야 중요한 결함을 발견하게 될 수 있으며, 그때는 더 이상 변경할 수 없습니다."

#: src/appendix-07-nightly-rust.md:14
msgid ""
"Our solution to this problem is what we call “stability without stagnation”, "
"and our guiding principle is this: you should never have to fear upgrading "
"to a new version of stable Rust. Each upgrade should be painless, but should "
"also bring you new features, fewer bugs, and faster compile times."
msgstr ""
"이 문제에 대한 우리의 해결책은 “정체 없는 안정성”이라고 부르는 것이며, 우리의 기본 원칙은 다음과 같습니다. "
"안정적인 Rust의 새 버전으로 업그레이드하는 것을 두려워해서는 안 됩니다. "
"각 업그레이드는 고통 없이 이루어져야 하며, 새로운 기능, 더 적은 버그, 더 빠른 컴파일 시간을 제공해야 합니다."

#: src/appendix-07-nightly-rust.md:19
msgid "Choo, Choo! Release Channels and Riding the Trains"
msgstr "추-추! 릴리스 채널과 기차 타기"

#: src/appendix-07-nightly-rust.md:21
msgid ""
"Rust development operates on a _train schedule_. That is, all development is "
"done on the `master` branch of the Rust repository. Releases follow a "
"software release train model, which has been used by Cisco IOS and other "
"software projects. There are three _release channels_ for Rust:"
msgstr ""
"Rust 개발은 _기차 일정_에 따라 운영됩니다. 즉, 모든 개발은 Rust 저장소의 `master` 브랜치에서 이루어집니다. "
"릴리스는 Cisco IOS 및 기타 소프트웨어 프로젝트에서 사용된 소프트웨어 릴리스 트레인 모델을 따릅니다. "
"Rust에는 세 가지 _릴리스 채널_이 있습니다:"

#: src/appendix-07-nightly-rust.md:26
msgid "Nightly"
msgstr "나이틀리"

#: src/appendix-07-nightly-rust.md:27
msgid "Beta"
msgstr "베타"

#: src/appendix-07-nightly-rust.md:28
msgid "Stable"
msgstr "스테이블"

#: src/appendix-07-nightly-rust.md:30
msgid ""
"Most Rust developers primarily use the stable channel, but those who want to "
"try out experimental new features may use nightly or beta."
msgstr ""
"대부분의 Rust 개발자는 주로 안정 채널을 사용하지만, 실험적인 새로운 기능을 사용해보고 싶은 사람들은 나이틀리 또는 베타를 사용할 수 있습니다."

#: src/appendix-07-nightly-rust.md:33
msgid ""
"Here’s an example of how the development and release process works: let’s "
"assume that the Rust team is working on the release of Rust 1.5. That "
"release happened in December of 2015, but it will provide us with realistic "
"version numbers. A new feature is added to Rust: a new commit lands on the "
"`master` branch. Each night, a new nightly version of Rust is produced. "
"Every day is a release day, and these releases are created by our release "
"infrastructure automatically. So as time passes, our releases look like "
"this, once a night:"
msgstr ""
"개발 및 릴리스 프로세스가 어떻게 작동하는지에 대한 예는 다음과 같습니다. "
"Rust 팀이 Rust 1.5 릴리스 작업을 하고 있다고 가정해 보겠습니다. "
"해당 릴리스는 2015년 12월에 있었지만, 현실적인 버전 번호를 제공할 것입니다. "
"새로운 기능이 Rust에 추가됩니다. 새로운 커밋이 `master` 브랜치에 적용됩니다. "
"매일 밤 새로운 나이틀리 버전의 Rust가 생성됩니다. "
"매일이 릴리스 날이며, 이러한 릴리스는 릴리스 인프라에서 자동으로 생성됩니다. "
"따라서 시간이 지남에 따라 릴리스는 하룻밤에 한 번씩 다음과 같이 보입니다:"

#: src/appendix-07-nightly-rust.md:45
msgid ""
"Every six weeks, it’s time to prepare a new release! The `beta` branch of "
"the Rust repository branches off from the `master` branch used by nightly. "
"Now, there are two releases:"
msgstr ""

#: src/appendix-07-nightly-rust.md:55
msgid ""
"Most Rust users do not use beta releases actively, but test against beta in "
"their CI system to help Rust discover possible regressions. In the meantime, "
"there’s still a nightly release every night:"
msgstr ""

#: src/appendix-07-nightly-rust.md:65
msgid ""
"Let’s say a regression is found. Good thing we had some time to test the "
"beta release before the regression snuck into a stable release! The fix is "
"applied to `master`, so that nightly is fixed, and then the fix is "
"backported to the `beta` branch, and a new release of beta is produced:"
msgstr ""

#: src/appendix-07-nightly-rust.md:76
msgid ""
"Six weeks after the first beta was created, it’s time for a stable release! "
"The `stable` branch is produced from the `beta` branch:"
msgstr ""

#: src/appendix-07-nightly-rust.md:87
msgid ""
"Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the "
"six weeks have gone by, we also need a new beta of the _next_ version of "
"Rust, 1.6. So after `stable` branches off of `beta`, the next version of "
"`beta` branches off of `nightly` again:"
msgstr ""

#: src/appendix-07-nightly-rust.md:100
msgid ""
"This is called the “train model” because every six weeks, a release “leaves "
"the station”, but still has to take a journey through the beta channel "
"before it arrives as a stable release."
msgstr ""

#: src/appendix-07-nightly-rust.md:104
msgid ""
"Rust releases every six weeks, like clockwork. If you know the date of one "
"Rust release, you can know the date of the next one: it’s six weeks later. A "
"nice aspect of having releases scheduled every six weeks is that the next "
"train is coming soon. If a feature happens to miss a particular release, "
"there’s no need to worry: another one is happening in a short time! This "
"helps reduce pressure to sneak possibly unpolished features in close to the "
"release deadline."
msgstr ""

#: src/appendix-07-nightly-rust.md:111
msgid ""
"Thanks to this process, you can always check out the next build of Rust and "
"verify for yourself that it’s easy to upgrade to: if a beta release doesn’t "
"work as expected, you can report it to the team and get it fixed before the "
"next stable release happens! Breakage in a beta release is relatively rare, "
"but `rustc` is still a piece of software, and bugs do exist."
msgstr ""

#: src/appendix-07-nightly-rust.md:117
msgid "Maintenance time"
msgstr ""

#: src/appendix-07-nightly-rust.md:119
msgid ""
"The Rust project supports the most recent stable version. When a new stable "
"version is released, the old version reaches its end of life (EOL). This "
"means each version is supported for six weeks."
msgstr ""

#: src/appendix-07-nightly-rust.md:123
msgid "Unstable Features"
msgstr ""

#: src/appendix-07-nightly-rust.md:125
msgid ""
"There’s one more catch with this release model: unstable features. Rust uses "
"a technique called “feature flags” to determine what features are enabled in "
"a given release. If a new feature is under active development, it lands on "
"`master`, and therefore, in nightly, but behind a _feature flag_. If you, as "
"a user, wish to try out the work-in-progress feature, you can, but you must "
"be using a nightly release of Rust and annotate your source code with the "
"appropriate flag to opt in."
msgstr ""

#: src/appendix-07-nightly-rust.md:133
msgid ""
"If you’re using a beta or stable release of Rust, you can’t use any feature "
"flags. This is the key that allows us to get practical use with new features "
"before we declare them stable forever. Those who wish to opt into the "
"bleeding edge can do so, and those who want a rock-solid experience can "
"stick with stable and know that their code won’t break. Stability without "
"stagnation."
msgstr ""

#: src/appendix-07-nightly-rust.md:139
msgid ""
"This book only contains information about stable features, as in-progress "
"features are still changing, and surely they’ll be different between when "
"this book was written and when they get enabled in stable builds. You can "
"find documentation for nightly-only features online."
msgstr ""

#: src/appendix-07-nightly-rust.md:144
msgid "Rustup and the Role of Rust Nightly"
msgstr ""

#: src/appendix-07-nightly-rust.md:146
msgid ""
"Rustup makes it easy to change between different release channels of Rust, "
"on a global or per-project basis. By default, you’ll have stable Rust "
"installed. To install nightly, for example:"
msgstr ""

#: src/appendix-07-nightly-rust.md:154
msgid ""
"You can see all of the _toolchains_ (releases of Rust and associated "
"components) you have installed with `rustup` as well. Here’s an example on "
"one of your authors’ Windows computer:"
msgstr ""

#: src/appendix-07-nightly-rust.md:165
msgid ""
"As you can see, the stable toolchain is the default. Most Rust users use "
"stable most of the time. You might want to use stable most of the time, but "
"use nightly on a specific project, because you care about a cutting-edge "
"feature. To do so, you can use `rustup override` in that project’s directory "
"to set the nightly toolchain as the one `rustup` should use when you’re in "
"that directory:"
msgstr ""

#: src/appendix-07-nightly-rust.md:176
msgid ""
"Now, every time you call `rustc` or `cargo` inside of _~/projects/needs-"
"nightly_, `rustup` will make sure that you are using nightly Rust, rather "
"than your default of stable Rust. This comes in handy when you have a lot of "
"Rust projects!"
msgstr ""

#: src/appendix-07-nightly-rust.md:181
msgid "The RFC Process and Teams"
msgstr ""

#: src/appendix-07-nightly-rust.md:183
msgid ""
"So how do you learn about these new features? Rust’s development model "
"follows a _Request For Comments (RFC) process_. If you’d like an improvement "
"in Rust, you can write up a proposal, called an RFC."
msgstr ""

#: src/appendix-07-nightly-rust.md:187
msgid ""
"Anyone can write RFCs to improve Rust, and the proposals are reviewed and "
"discussed by the Rust team, which is comprised of many topic subteams. "
"There’s a full list of the teams [on Rust’s website](https://www.rust-"
"lang.org/governance), which includes teams for each area of the project: "
"language design, compiler implementation, infrastructure, documentation, and "
"more. The appropriate team reads the proposal and the comments, writes some "
"comments of their own, and eventually, there’s consensus to accept or reject "
"the feature."
msgstr ""

#: src/appendix-07-nightly-rust.md:195
msgid ""
"If the feature is accepted, an issue is opened on the Rust repository, and "
"someone can implement it. The person who implements it very well may not be "
"the person who proposed the feature in the first place! When the "
"implementation is ready, it lands on the `master` branch behind a feature "
"gate, as we discussed in the [“Unstable Features”](#unstable-features)<!-- "
"ignore --> section."
msgstr ""

#: src/appendix-07-nightly-rust.md:201
msgid ""
"After some time, once Rust developers who use nightly releases have been "
"able to try out the new feature, team members will discuss the feature, how "
"it’s worked out on nightly, and decide if it should make it into stable Rust "
"or not. If the decision is to move forward, the feature gate is removed, and "
"the feature is now considered stable! It rides the trains into a new stable "
"release of Rust."
msgstr ""
