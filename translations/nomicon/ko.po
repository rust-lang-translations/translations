msgid ""
msgstr ""
"Project-Id-Version: The Rustonomicon\n"
"POT-Creation-Date: 2025-10-15T16:18:45+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:18:45+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:3 src/ffi.md:3
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:5 src/meet-safe-and-unsafe.md:1
msgid "Meet Safe and Unsafe"
msgstr "안전과 비안전을 만나다"

#: src/SUMMARY.md:6 src/safe-unsafe-meaning.md:1
msgid "How Safe and Unsafe Interact"
msgstr "안전과 비안전은 어떻게 상호작용하는가"

#: src/SUMMARY.md:7
msgid "What Unsafe Can Do"
msgstr "비안전이 할 수 있는 것"

#: src/SUMMARY.md:8 src/working-with-unsafe.md:1
msgid "Working with Unsafe"
msgstr "비안전과 함께 작업하기"

#: src/SUMMARY.md:9
msgid "Data Layout"
msgstr "데이터 레이아웃"

#: src/SUMMARY.md:10 src/repr-rust.md:1
msgid "repr(Rust)"
msgstr "repr(Rust)"

#: src/SUMMARY.md:11 src/exotic-sizes.md:1
msgid "Exotically Sized Types"
msgstr "이례적인 크기의 타입"

#: src/SUMMARY.md:12
msgid "Other reprs"
msgstr "다른 repr들"

#: src/SUMMARY.md:13
msgid "Ownership"
msgstr "소유권"

#: src/SUMMARY.md:14 src/references.md:1
msgid "References"
msgstr "참조"

#: src/SUMMARY.md:15 src/aliasing.md:1
msgid "Aliasing"
msgstr "별칭"

#: src/SUMMARY.md:16 src/lifetimes.md:1
msgid "Lifetimes"
msgstr "수명"

#: src/SUMMARY.md:17 src/lifetime-mismatch.md:1
msgid "Limits of Lifetimes"
msgstr "수명의 한계"

#: src/SUMMARY.md:18 src/lifetime-elision.md:1
msgid "Lifetime Elision"
msgstr "수명 생략"

#: src/SUMMARY.md:19 src/unbounded-lifetimes.md:1
msgid "Unbounded Lifetimes"
msgstr "무한 수명"

#: src/SUMMARY.md:20
msgid "Higher-Rank Trait Bounds"
msgstr "고차 트레잇 바운드"

#: src/SUMMARY.md:21 src/subtyping.md:1
msgid "Subtyping and Variance"
msgstr "서브타이핑과 공변성"

#: src/SUMMARY.md:22 src/dropck.md:1
msgid "Drop Check"
msgstr "드롭 체크"

#: src/SUMMARY.md:23 src/phantom-data.md:1
msgid "PhantomData"
msgstr "팬텀 데이터"

#: src/SUMMARY.md:24 src/borrow-splitting.md:1
msgid "Splitting Borrows"
msgstr "차용 분할"

#: src/SUMMARY.md:25 src/conversions.md:1
msgid "Type Conversions"
msgstr "타입 변환"

#: src/SUMMARY.md:26 src/coercions.md:1
msgid "Coercions"
msgstr "강제 변환"

#: src/SUMMARY.md:27 src/dot-operator.md:1
msgid "The Dot Operator"
msgstr "점 연산자"

#: src/SUMMARY.md:28 src/casts.md:1
msgid "Casts"
msgstr "캐스트"

#: src/SUMMARY.md:29 src/transmutes.md:1
msgid "Transmutes"
msgstr "트랜스뮤트"

#: src/SUMMARY.md:30
msgid "Uninitialized Memory"
msgstr "초기화되지 않은 메모리"

#: src/SUMMARY.md:31
msgid "Checked"
msgstr "확인됨"

#: src/SUMMARY.md:32 src/drop-flags.md:1
msgid "Drop Flags"
msgstr "드롭 플래그"

#: src/SUMMARY.md:33
msgid "Unchecked"
msgstr "미확인"

#: src/SUMMARY.md:34
msgid "Ownership Based Resource Management"
msgstr "소유권 기반 자원 관리"

#: src/SUMMARY.md:35 src/constructors.md:1
msgid "Constructors"
msgstr "생성자"

#: src/SUMMARY.md:36 src/destructors.md:1 src/ffi.md:235
msgid "Destructors"
msgstr "소멸자"

#: src/SUMMARY.md:37 src/leaking.md:1
msgid "Leaking"
msgstr "누수"

#: src/SUMMARY.md:38 src/unwinding.md:1
msgid "Unwinding"
msgstr "언와인딩"

#: src/SUMMARY.md:39 src/exception-safety.md:1
msgid "Exception Safety"
msgstr "예외 안전성"

#: src/SUMMARY.md:40 src/poisoning.md:1
msgid "Poisoning"
msgstr "오염"

#: src/SUMMARY.md:41
msgid "Concurrency"
msgstr "동시성"

#: src/SUMMARY.md:42
msgid "Races"
msgstr "경쟁"

#: src/SUMMARY.md:43 src/send-and-sync.md:1 src/arc-mutex/arc-base.md:33
msgid "Send and Sync"
msgstr "Send와 Sync"

#: src/SUMMARY.md:44 src/atomics.md:1
msgid "Atomics"
msgstr "아토믹"

#: src/SUMMARY.md:45
msgid "Implementing Vec"
msgstr "Vec 구현하기"

#: src/SUMMARY.md:46 src/SUMMARY.md:59 src/vec/vec-layout.md:1
#: src/arc-mutex/arc-layout.md:1
msgid "Layout"
msgstr "레이아웃"

#: src/SUMMARY.md:47
msgid "Allocating"
msgstr "할당하기"

#: src/SUMMARY.md:48 src/vec/vec-push-pop.md:1
msgid "Push and Pop"
msgstr "푸시와 팝"

#: src/SUMMARY.md:49 src/vec/vec-dealloc.md:1
msgid "Deallocating"
msgstr "할당 해제"

#: src/SUMMARY.md:50 src/vec/vec-deref.md:1 src/arc-mutex/arc-base.md:78
msgid "Deref"
msgstr "역참조"

#: src/SUMMARY.md:51 src/vec/vec-insert-remove.md:1
msgid "Insert and Remove"
msgstr "삽입과 제거"

#: src/SUMMARY.md:52 src/vec/vec-into-iter.md:1
msgid "IntoIter"
msgstr "IntoIter"

#: src/SUMMARY.md:53 src/vec/vec-raw.md:1
msgid "RawVec"
msgstr "RawVec"

#: src/SUMMARY.md:54 src/leaking.md:52 src/vec/vec-drain.md:1
msgid "Drain"
msgstr "드레인"

#: src/SUMMARY.md:55 src/vec/vec-zsts.md:1
msgid "Handling Zero-Sized Types"
msgstr "크기 0 타입 처리"

#: src/SUMMARY.md:56 src/SUMMARY.md:63 src/arc-mutex/arc-final.md:1
msgid "Final Code"
msgstr "최종 코드"

#: src/SUMMARY.md:57 src/arc-mutex/arc-and-mutex.md:1
msgid "Implementing Arc and Mutex"
msgstr "Arc와 Mutex 구현하기"

#: src/SUMMARY.md:58
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:60 src/arc-mutex/arc-base.md:1
msgid "Base Code"
msgstr "기본 코드"

#: src/SUMMARY.md:61 src/arc-mutex/arc-clone.md:1
msgid "Cloning"
msgstr "클로닝"

#: src/SUMMARY.md:62 src/arc-mutex/arc-drop.md:1
msgid "Dropping"
msgstr "드롭하기"

#: src/SUMMARY.md:64
msgid "FFI"
msgstr "FFI"

#: src/SUMMARY.md:65 src/beneath-std.md:1
msgid "Beneath `std`"
msgstr "`std` 아래"

#: src/SUMMARY.md:66 src/panic-handler.md:1
msgid "\\#\\[panic_handler\\]"
msgstr "#[panic_handler]"

#: src/intro.md:1
msgid "The Rustonomicon"
msgstr "러스트노미콘"

#: src/intro.md:5
msgid ""
"Warning: This book is incomplete. Documenting everything and rewriting "
"outdated parts take a while. See the [issue tracker](https://github.com/rust-"
"lang-nomicon/issues) to check what's missing/outdated, and if there are any "
"mistakes or ideas that haven't been reported, feel free to open a new issue "
"there."
msgstr ""
"경고: 이 책은 미완성입니다. 모든 것을 문서화하고 오래된 부분을 다시 작성하는 데는 시간이 걸립니다. 누락되거나 오래된 내용을 확인하려면 [이슈 트래커](https://github.com/rust-lang-nomicon/issues)를 참조하고, 보고되지 않은 오류나 아이디어가 있다면 언제든지 새 이슈를 열어주세요."

#: src/intro.md:14
msgid "The Dark Arts of Unsafe Rust"
msgstr "안전하지 않은 러스트의 어두운 기술"

#: src/intro.md:16
msgid ""
"THE KNOWLEDGE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS "
"OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF UNLEASHING "
"INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN "
"THE UNKNOWABLY INFINITE COSMOS."
msgstr ""
"이 지식은 명시적이든 묵시적이든 어떠한 종류의 보증도 없이 '있는 그대로' 제공됩니다. 여기에는 당신의 정신을 산산조각 내고 알 수 없는 무한한 우주 속으로 당신의 마음을 표류하게 할 형언할 수 없는 공포를 풀어놓는 것에 대한 보증이 포함되지만 이에 국한되지 않습니다."

#: src/intro.md:18
msgid ""
"The Rustonomicon digs into all the awful details that you need to understand "
"when writing Unsafe Rust programs."
msgstr ""
"러스트노미콘은 안전하지 않은 러스트 프로그램을 작성할 때 이해해야 할 모든 끔찍한 세부 사항을 파고듭니다."

#: src/intro.md:20
msgid ""
"Should you wish a long and happy career of writing Rust programs, you should "
"turn back now and forget you ever saw this book. It is not necessary. "
"However if you intend to write unsafe code — or just want to dig into the "
"guts of the language — this book contains lots of useful information."
msgstr ""
"러스트 프로그램을 작성하는 길고 행복한 경력을 원한다면, 지금 당장 이 책을 잊고 돌아가야 합니다. 이 책은 필수가 아닙니다. 하지만 안전하지 않은 코드를 작성하거나 언어의 내부를 파고들고 싶다면, 이 책은 많은 유용한 정보를 담고 있습니다."

#: src/intro.md:24
msgid ""
"Unlike _[The Rust Programming Language](../book/index.html)_, we will be "
msgstr ""
"_[러스트 프로그래밍 언어](../book/index.html)_와 달리, 우리는"

#: src/intro.md:30
msgid ""
"This book exists primarily as a high-level companion to [The Reference](../"
"reference/index.html). Where The Reference exists to detail the syntax and "
"semantics of every part of the language, The Rustonomicon exists to describe "
"how to use those pieces together, and the issues that you will have in doing "
"so."
msgstr ""
"이 책은 주로 [참조서](../reference/index.html)의 고급 동반자 역할을 합니다. 참조서가 언어의 모든 부분의 구문과 의미를 자세히 설명하는 반면, 러스트노미콘은 이러한 부분들을 함께 사용하는 방법과 그렇게 할 때 발생할 수 있는 문제들을 설명합니다."

#: src/intro.md:33
msgid ""
"The Reference will tell you the syntax and semantics of references, "
"destructors, and unwinding, but it won't tell you how combining them can "
"lead to exception-safety issues, or how to deal with those issues."
msgstr ""
"참조서는 참조, 소멸자, 언와인딩의 구문과 의미를 알려주지만, 이들을 결합하는 것이 어떻게 예외 안전성 문제로 이어질 수 있는지, 또는 그러한 문제들을 어떻게 다루어야 하는지는 알려주지 않습니다."

#: src/intro.md:35
msgid ""
"It should be noted that we haven't synced The Rustnomicon and The Reference "
"well, so they may have duplicate content. In general, if the two documents "
"disagree, The Reference should be assumed to be correct (it isn't yet "
"considered normative, it's just better maintained)."
msgstr ""
"러스트노미콘과 참조서가 잘 동기화되지 않아 중복된 내용이 있을 수 있다는 점에 유의해야 합니다. 일반적으로 두 문서가 일치하지 않는 경우, 참조서가 올바르다고 가정해야 합니다(아직 규범적인 것으로 간주되지는 않지만, 더 잘 관리되고 있습니다)."

#: src/intro.md:38
msgid ""
"Topics that are within the scope of this book include: the meaning of "
"(un)safety, unsafe primitives provided by the language and standard library, "
"techniques for creating safe abstractions with those unsafe primitives, "
"subtyping and variance, exception-safety (panic/unwind-safety), working with "
"uninitialized memory, type punning, concurrency, interoperating with other "
"languages (FFI), optimization tricks, how constructs lower to compiler/OS/"
msgstr "이 책의 범위에 포함되는 주제는 다음과 같습니다: (비)안전의 의미, 언어 및 표준 라이브러리에서 제공하는 안전하지 않은 기본 요소, 이러한 안전하지 않은 기본 요소를 사용하여 안전한 추상화를 만드는 기술, 서브타이핑 및 공변성, 예외 안전성(패닉/언와인드 안전성), 초기화되지 않은 메모리 작업, 타입 퍼닝, 동시성, 다른 언어와의 상호 운용(FFI), 최적화 트릭, 구성 요소가 컴파일러/OS로 어떻게 낮아지는지"

#: src/intro.md:40
msgid ""
"The Rustonomicon is not a place to exhaustively describe the semantics and "
"guarantees of every single API in the standard library, nor is it a place to "
"exhaustively describe every feature of Rust."
msgstr ""
"러스트노미콘은 표준 라이브러리의 모든 단일 API의 의미와 보증을 상세하게 설명하는 곳이 아니며, 러스트의 모든 기능을 상세하게 설명하는 곳도 아닙니다."

#: src/intro.md:42
msgid ""
"Unless otherwise noted, Rust code in this book uses the Rust 2021 edition."
msgstr ""
"별도로 명시되지 않는 한, 이 책의 러스트 코드는 러스트 2021 에디션을 사용합니다."

#: src/meet-safe-and-unsafe.md:3
msgid "![safe and unsafe](img/safeandunsafe.svg)"
msgstr "![안전과 비안전](img/safeandunsafe.svg)"

#: src/meet-safe-and-unsafe.md:5
msgid "" "It would be great to not have to worry about low-level implementation " "details. Who could possibly care how much space the empty tuple occupies? " "Sadly, it sometimes matters and we need to worry about it. The most common " "reason developers start to care about implementation details is performance, "msgstr "저수준 구현 세부 사항에 대해 걱정할 필요가 없다면 좋을 것입니다. 빈 튜플이 얼마나 많은 공간을 차지하는지 누가 신경 쓸까요? 안타깝게도 때로는 중요하며 우리는 그것에 대해 걱정해야 합니다. 개발자들이 구현 세부 사항에 관심을 갖기 시작하는 가장 흔한 이유는 성능입니다."

#: src/meet-safe-and-unsafe.md:12
msgid ""
"When implementation details start to matter in a safe programming language, "
"programmers usually have three options:"
msgstr ""
"안전한 프로그래밍 언어에서 구현 세부 사항이 중요해지기 시작할 때, 프로그래머는 일반적으로 세 가지 선택지가 있습니다:"

#: src/meet-safe-and-unsafe.md:15
msgid ""
"fiddle with the code to encourage the compiler/runtime to perform an "
"optimization"
msgstr ""
"컴파일러/런타임이 최적화를 수행하도록 코드를 조작합니다."

#: src/meet-safe-and-unsafe.md:16
msgid ""
"adopt a more unidiomatic or cumbersome design to get the desired "
"implementation"
msgstr ""
"원하는 구현을 얻기 위해 더 비관용적이거나 번거로운 설계를 채택합니다."

#: src/meet-safe-and-unsafe.md:17
msgid ""
"rewrite the implementation in a language that lets you deal with those "
"details"
msgstr ""
"해당 세부 사항을 처리할 수 있는 언어로 구현을 다시 작성합니다."

#: src/meet-safe-and-unsafe.md:19
msgid ""
"For that last option, the language programmers tend to use is _C_. This is "
"often necessary to interface with systems that only declare a C interface."
msgstr ""
"마지막 옵션의 경우, 프로그래머들이 사용하는 언어는 주로 _C_입니다. 이는 C 인터페이스만 선언하는 시스템과 인터페이스하기 위해 종종 필요합니다."

#: src/meet-safe-and-unsafe.md:22
msgid ""
"Unfortunately, C is incredibly unsafe to use (sometimes for good reason), "
"and this unsafety is magnified when trying to interoperate with another "
"language. Care must be taken to ensure C and the other language agree on "
"what's happening, and that they don't step on each other's toes."
msgstr ""
"불행히도 C는 사용하기에 믿을 수 없을 정도로 안전하지 않으며(때로는 타당한 이유로), 다른 언어와 상호 운용하려고 할 때 이러한 불안전성은 증폭됩니다. C와 다른 언어가 무엇이 일어나고 있는지 동의하고 서로의 영역을 침범하지 않도록 주의해야 합니다."

#: src/meet-safe-and-unsafe.md:27
msgid "So what does this have to do with Rust?"
msgstr "그렇다면 이것이 러스트와 무슨 관련이 있을까요?"

#: src/meet-safe-and-unsafe.md:29
msgid "Well, unlike C, Rust is a safe programming language."
msgstr "음, C와 달리 러스트는 안전한 프로그래밍 언어입니다."

#: src/meet-safe-and-unsafe.md:31
msgid "But, like C, Rust is an unsafe programming language."
msgstr "하지만 C와 마찬가지로 러스트는 안전하지 않은 프로그래밍 언어입니다."

#: src/meet-safe-and-unsafe.md:33
msgid ""
"More accurately, Rust _contains_ both a safe and unsafe programming language."
msgstr ""
"더 정확히 말하면, 러스트는 안전한 프로그래밍 언어와 안전하지 않은 프로그래밍 언어를 모두 _포함_합니다."

#: src/meet-safe-and-unsafe.md:35
msgid ""
"Rust can be thought of as a combination of two programming languages: _Safe "
"Rust_ and _Unsafe Rust_. Conveniently, these names mean exactly what they "
"say: Safe Rust is Safe. Unsafe Rust is, well, not. In fact, Unsafe Rust lets "
"us do some _really_ unsafe things. Things the Rust authors will implore you "
"not to do, but we'll do anyway."
msgstr ""
"러스트는 두 가지 프로그래밍 언어의 조합으로 생각할 수 있습니다: _안전한 러스트_와 _안전하지 않은 러스트_. 편리하게도 이 이름들은 정확히 그 의미를 가집니다. 안전한 러스트는 안전합니다. 안전하지 않은 러스트는, 음, 그렇지 않습니다. 사실, 안전하지 않은 러스트는 우리가 _정말로_ 안전하지 않은 일들을 할 수 있게 해줍니다. 러스트 저자들이 하지 말라고 간청할 일들이지만, 우리는 어쨌든 할 것입니다."

#: src/meet-safe-and-unsafe.md:41
msgid ""
"Safe Rust is the _true_ Rust programming language. If all you do is write "
"Safe Rust, you will never have to worry about type-safety or memory-safety. "
"You will never endure a dangling pointer, a use-after-free, or any other "
"kind of Undefined Behavior (a.k.a. UB)."
msgstr ""
"안전한 러스트는 _진정한_ 러스트 프로그래밍 언어입니다. 안전한 러스트만 작성한다면, 타입 안전성이나 메모리 안전성에 대해 걱정할 필요가 없을 것입니다. 매달린 포인터, 해제 후 사용, 또는 다른 종류의 정의되지 않은 동작(UB)을 겪을 일은 없을 것입니다."

#: src/meet-safe-and-unsafe.md:46
msgid ""
"The standard library also gives you enough utilities out of the box that "
"you'll be able to write high-performance applications and libraries in pure "
"idiomatic Safe Rust."
msgstr ""
"표준 라이브러리는 또한 순수하고 관용적인 안전한 러스트로 고성능 애플리케이션과 라이브러리를 작성할 수 있도록 충분한 유틸리티를 제공합니다."

#: src/meet-safe-and-unsafe.md:50
msgid ""
"But maybe you want to talk to another language. Maybe you're writing a low-"
msgstr ""
"하지만 다른 언어와 통신하고 싶을 수도 있습니다. 저수준"

#: src/meet-safe-and-unsafe.md:56
msgid ""
"Unsafe Rust is exactly like Safe Rust with all the same rules and semantics. "
"It just lets you do some _extra_ things that are Definitely Not Safe (which "
"we will define in the next section)."
msgstr ""
"안전하지 않은 러스트는 모든 규칙과 의미론이 안전한 러스트와 정확히 같습니다. 단지 확실히 안전하지 않은 _추가적인_ 작업(다음 섹션에서 정의할 것임)을 할 수 있게 해줄 뿐입니다."

#: src/meet-safe-and-unsafe.md:60
msgid ""
"The value of this separation is that we gain the benefits of using an unsafe "
"language like C — low level control over implementation details — without "
"most of the problems that come with trying to integrate it with a completely "
"different safe language."
msgstr "이러한 분리의 가치는 C와 같은 안전하지 않은 언어를 사용하는 이점, 즉 구현 세부 사항에 대한 저수준 제어를 얻으면서도, 완전히 다른 안전한 언어와 통합하려고 할 때 발생하는 대부분의 문제 없이 가능하게 합니다."

#: src/meet-safe-and-unsafe.md:65
msgid ""
"There are still some problems — most notably, we must become aware of "
"properties that the type system assumes and audit them in any code that "
"interacts with Unsafe Rust. That's the purpose of this book: to teach you "
"about these assumptions and how to manage them."
msgstr ""
"여전히 몇 가지 문제가 있습니다. 가장 주목할 만한 것은 타입 시스템이 가정하는 속성을 인지하고 안전하지 않은 러스트와 상호 작용하는 모든 코드에서 이를 감사해야 한다는 것입니다. 이것이 이 책의 목적입니다: 이러한 가정과 관리 방법을 가르치는 것입니다."

#: src/safe-unsafe-meaning.md:3
msgid ""
"What's the relationship between Safe Rust and Unsafe Rust? How do they "
"interact?"
msgstr ""
"안전한 러스트와 안전하지 않은 러스트의 관계는 무엇일까요? 이들은 어떻게 상호 작용할까요?"

#: src/safe-unsafe-meaning.md:6
msgid ""
"The separation between Safe Rust and Unsafe Rust is controlled with the "
"`unsafe` keyword, which acts as an interface from one to the other. This is "
"why we can say Safe Rust is a safe language: all the unsafe parts are kept "
"exclusively behind the `unsafe` boundary. If you wish, you can even toss `#!"
"[forbid(unsafe_code)]` into your code base to statically guarantee that "
"you're only writing Safe Rust."
msgstr ""
"안전한 러스트와 안전하지 않은 러스트의 분리는 `unsafe` 키워드로 제어되며, 이는 둘 사이의 인터페이스 역할을 합니다. 이것이 안전한 러스트가 안전한 언어라고 말할 수 있는 이유입니다. 모든 안전하지 않은 부분은 `unsafe` 경계 뒤에만 존재합니다. 원한다면 `#[forbid(unsafe_code)]`를 코드베이스에 넣어 안전한 러스트만 작성하고 있음을 정적으로 보장할 수도 있습니다. 이는 임베디드 러스트에서 흔히 사용되는 관행으로, 전체 애플리케이션은 종종 안전한 러스트로 작성되고, `unsafe` 코드는 작은 HAL(하드웨어 추상화 계층) 크레이트에 국한됩니다."

#: src/safe-unsafe-meaning.md:13
msgid ""
"The `unsafe` keyword has two uses: to declare the existence of contracts the "
"compiler can't check, and to declare that a programmer has checked that "
"these contracts have been upheld."
msgstr ""
"`unsafe` 키워드는 두 가지 용도로 사용됩니다. 컴파일러가 확인할 수 없는 계약의 존재를 선언하고, 프로그래머가 이러한 계약이 준수되었음을 확인했음을 선언하는 것입니다."

#: src/safe-unsafe-meaning.md:17
msgid ""
"that the contracts are upheld. On trait declarations, `unsafe` means that "
"implementors of the trait must check that the trait's documentation to "
"ensure that the contracts are upheld."
msgstr ""
"계약이 준수되도록 해야 합니다. 트레잇 선언에서 `unsafe`는 트레잇 구현자가 트레잇의 문서를 확인하여 계약이 준수되도록 해야 함을 의미합니다."

#: src/safe-unsafe-meaning.md:25
msgid ""
"You can use `unsafe` on a block to declare that all unsafe actions performed "
"within are verified to uphold the contracts of those operations. For "
"instance, the index passed to [`slice::get_unchecked`](../std/"
"primitive.slice.html#method.get_unchecked) is in-bounds."
msgstr ""
"블록에 `unsafe`를 사용하여 그 안에서 수행되는 모든 안전하지 않은 작업이 해당 작업의 계약을 준수하는지 확인되었음을 선언할 수 있습니다. 예를 들어, [`slice::get_unchecked`](../std/primitive.slice.html#method.get_unchecked)에 전달된 인덱스가 범위 내에 있습니다."

#: src/safe-unsafe-meaning.md:29
msgid ""
"You can use `unsafe` on a trait implementation to declare that the "
"implementation upholds the trait's contract. For instance, that a type "
"implementing [`Send`](../std/marker/trait.Send.html) is really safe to move "
"to another thread."
msgstr ""
"트레잇 구현에 `unsafe`를 사용하여 해당 구현이 트레잇의 계약을 준수함을 선언할 수 있습니다. 예를 들어, [`Send`](../std/marker/trait.Send.html)를 구현하는 타입이 실제로 다른 스레드로 이동해도 안전하다는 것을 선언할 수 있습니다."

#: src/safe-unsafe-meaning.md:33
msgid "The standard library has a number of unsafe functions, including:"
msgstr "표준 라이브러리에는 다음을 포함한 여러 안전하지 않은 함수가 있습니다:"

#: src/safe-unsafe-meaning.md:35
msgid ""
"[`slice::get_unchecked`](../std/primitive.slice.html#method.get_unchecked), "
"which performs unchecked indexing, allowing memory safety to be freely "
"violated."
msgstr ""
"[`slice::get_unchecked`](../std/primitive.slice.html#method.get_unchecked)`는 검사되지 않은 인덱싱을 수행하여 메모리 안전성을 자유롭게 위반할 수 있습니다."

#: src/safe-unsafe-meaning.md:37
msgid "" "[`mem::transmute`](../std/mem/fn.transmute.html) reinterprets some value as " "having a given type, bypassing type safety in arbitrary ways (see " "[conversions](conversions.html) for details)."
msgstr "" "[`mem::transmute`](../std/mem/fn.transmute.html)`는 어떤 값을 주어진 타입으로 재해석하여, 임의의 방식으로 타입 안전성을 우회합니다([변환](conversions.html)에서 자세한 내용을 참조하세요)."

#: src/safe-unsafe-meaning.md:39
msgid ""
"Every raw pointer to a sized type has an [`offset`](../std/"
"primitive.pointer.html#method.offset) method that invokes Undefined Behavior "
"if the passed offset is not [\"in bounds\"](../std/"
"primitive.pointer.html#method.offset)."
msgstr ""
"크기가 지정된 타입에 대한 모든 원시 포인터는 전달된 오프셋이 [\"범위 내\"](../std/primitive.pointer.html#method.offset)에 있지 않으면 정의되지 않은 동작을 호출하는 [`offset`](../std/primitive.pointer.html#method.offset) 메서드를 가집니다."

#: src/safe-unsafe-meaning.md:41
msgid ""
"All FFI (Foreign Function Interface) functions are `unsafe` to call because "
"the other language can do arbitrary operations that the Rust compiler can't "
"check."
msgstr ""
"모든 FFI(외부 함수 인터페이스) 함수는 다른 언어가 러스트 컴파일러가 확인할 수 없는 임의의 작업을 수행할 수 있기 때문에 `unsafe`로 호출해야 합니다."

#: src/safe-unsafe-meaning.md:44
msgid ""
"As of Rust 1.29.2 the standard library defines the following unsafe traits "
"(there are others, but they are not stabilized yet and some of them may "
"never be):"
msgstr ""
"러스트 1.29.2 기준으로 표준 라이브러리는 다음 안전하지 않은 트레잇을 정의합니다(다른 트레잇도 있지만 아직 안정화되지 않았으며 일부는 영원히 안정화되지 않을 수도 있습니다):"

#: src/safe-unsafe-meaning.md:48
msgid ""
"[`Send`](../std/marker/trait.Send.html) is a marker trait (a trait with no "
"API) that promises implementors are safe to send (move) to another thread."
msgstr ""
"[`Send`](../std/marker/trait.Send.html)`는 구현체가 다른 스레드로 안전하게 전송(이동)될 수 있음을 약속하는 마커 트레잇(API가 없는 트레잇)입니다."

#: src/safe-unsafe-meaning.md:50
msgid ""
"[`Sync`](../std/marker/trait.Sync.html) is a marker trait that promises "
"threads can safely share implementors through a shared reference."
msgstr ""
"[`Sync`](../std/marker/trait.Sync.html)`는 구현체가 스레드 간에 참조를 안전하게 공유할 수 있음을 약속하는 마커 트레잇(API가 없는 트레잇)입니다."

#: src/safe-unsafe-meaning.md:52
msgid "" "[`GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html) allows customizing the " "memory allocator of the whole program." msgstr "" "[`GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html)`은 전체 프로그램의 메모리 할당자를 사용자 정의할 수 있습니다."

#: src/safe-unsafe-meaning.md:54
msgid ""
"Much of the Rust standard library also uses Unsafe Rust internally. These "
"implementations have generally been rigorously manually checked, so the Safe "
"Rust interfaces built on top of these implementations can be assumed to be "
"safe."
msgstr ""
"러스트 표준 라이브러리의 많은 부분도 내부적으로 안전하지 않은 러스트를 사용합니다. 이러한 구현은 일반적으로 엄격하게 수동으로 검사되었으므로, 이러한 구현 위에 구축된 안전한 러스트 인터페이스는 안전하다고 가정할 수 있습니다."

#: src/safe-unsafe-meaning.md:58
msgid ""
"The need for all of this separation boils down a single fundamental property "
"of Safe Rust, the _soundness property_:"
msgstr ""
"이 모든 분리의 필요성은 안전한 러스트의 단 하나의 근본적인 속성인 _건전성 속성_으로 귀결됩니다:"

#: src/safe-unsafe-meaning.md:61
msgid "**No matter what, Safe Rust can't cause Undefined Behavior.**"
msgstr "**어떤 경우에도 안전한 러스트는 정의되지 않은 동작을 유발할 수 없습니다.**"

#: src/safe-unsafe-meaning.md:63
msgid ""
"The design of the safe/unsafe split means that there is an asymmetric trust "
"relationship between Safe and Unsafe Rust. Safe Rust inherently has to trust "
"that any Unsafe Rust it touches has been written correctly. On the other "
"hand, Unsafe Rust cannot trust Safe Rust without care."
msgstr ""
"안전/비안전 분리의 설계는 안전한 러스트와 안전하지 않은 러스트 사이에 비대칭적인 신뢰 관계가 있음을 의미합니다. 안전한 러스트는 자신이 접하는 모든 안전하지 않은 러스트가 올바르게 작성되었다고 본질적으로 신뢰해야 합니다. 반면에 안전하지 않은 러스트는 주의 없이는 안전한 러스트를 신뢰할 수 없습니다."

#: src/safe-unsafe-meaning.md:68
msgid ""
"As an example, Rust has the [`PartialOrd`](../std/cmp/trait.PartialOrd.html) "
"and [`Ord`](../std/cmp/trait.Ord.html) traits to differentiate between types "
"which can \"just\" be compared, and those that provide a \"total\" ordering "
"(which basically means that comparison behaves reasonably)."
msgstr ""
"예를 들어, 러스트에는 [`PartialOrd`](../std/cmp/trait.PartialOrd.html) 및 [`Ord`](../std/cmp/trait.Ord.html) 트레잇이 있어 단순히 비교할 수 있는 타입과 \"전체\" 순서(기본적으로 비교가 합리적으로 작동함을 의미)를 제공하는 타입을 구분합니다."

#: src/safe-unsafe-meaning.md:72
msgid ""
"[`BTreeMap`](../std/collections/struct.BTreeMap.html) doesn't really make "
"sense for partially-ordered types, and so it requires that its keys "
"implement `Ord`. However, `BTreeMap` has Unsafe Rust code inside of its "
"implementation. Because it would be unacceptable for a sloppy `Ord` "
"implementation (which is Safe to write) to cause Undefined Behavior, the "
"Unsafe code in BTreeMap must be written to be robust against `Ord` "
"implementations which aren't actually total — even though that's the whole "
"point of requiring `Ord`."
msgstr ""
"[`BTreeMap`](../std/collections/struct.BTreeMap.html)`은 부분적으로 정렬된 타입에는 적합하지 않으므로, 키가 `Ord`를 구현하도록 요구합니다. 그러나 `BTreeMap`은 구현 내부에 안전하지 않은 러스트 코드를 가지고 있습니다. 허술한 `Ord` 구현(안전하게 작성할 수 있음)이 정의되지 않은 동작을 유발하는 것은 용납할 수 없으므로, `BTreeMap`의 안전하지 않은 코드는 `Ord`를 요구하는 전체적인 목적에도 불구하고 실제로는 완전하지 않은 `Ord` 구현에 대해 견고하도록 작성되어야 합니다."

#: src/safe-unsafe-meaning.md:79
msgid ""
"The Unsafe Rust code just can't trust the Safe Rust code to be written "
"correctly. That said, `BTreeMap` will still behave completely erratically if "
"you feed in values that don't have a total ordering. It just won't ever "
"cause Undefined Behavior."
msgstr ""
"안전하지 않은 러스트 코드는 안전한 러스트 코드가 올바르게 작성되었다고 신뢰할 수 없습니다. 그렇다고 해도, `BTreeMap`은 전체 순서가 없는 값을 입력하면 여전히 완전히 불규칙하게 작동할 것입니다. 단지 정의되지 않은 동작을 유발하지는 않을 것입니다."

#: src/safe-unsafe-meaning.md:84
msgid ""
"One may wonder, if `BTreeMap` cannot trust `Ord` because it's Safe, why can "
"it trust _any_ Safe code? For instance `BTreeMap` relies on integers and "
"slices to be implemented correctly. Those are safe too, right?"
msgstr ""
"`BTreeMap`이 `Ord`가 안전하다는 이유로 신뢰할 수 없다면, 왜 _어떤_ 안전한 코드도 신뢰할 수 있는지 궁금할 수 있습니다. 예를 들어 `BTreeMap`은 정수와 슬라이스가 올바르게 구현되었다고 가정합니다. 그것들도 안전하겠죠?"

#: src/safe-unsafe-meaning.md:88
msgid ""
"The difference is one of scope. When `BTreeMap` relies on integers and "
"slices, it's relying on one very specific implementation. This is a measured "
"risk that can be weighed against the benefit. In this case there's basically "
"zero risk; if integers and slices are broken, _everyone_ is broken. Also, "
"they're maintained by the same people who maintain `BTreeMap`, so it's easy "
"to keep tabs on them."
msgstr ""
"차이점은 범위에 있습니다. `BTreeMap`이 정수와 슬라이스에 의존할 때, 이는 매우 특정한 구현에 의존하는 것입니다. 이는 이점에 대비하여 측정할 수 있는 위험입니다. 이 경우 위험은 기본적으로 0입니다. 정수와 슬라이스가 고장 나면 _모든 사람_이 고장 납니다. 또한, `BTreeMap`을 유지 관리하는 동일한 사람들이 유지 관리하므로, 이들을 쉽게 추적할 수 있습니다."

#: src/safe-unsafe-meaning.md:94
msgid "" "The answer is that `BTreeMap` doesn't trust `Ord` because `Ord` is a trait. " "Traits are implemented by users, and users can write buggy implementations. " "Integers and slices, on the other hand, are built-in types. They are part " "of the language itself, and their behavior is guaranteed by the language " "specification." msgstr "답은 `BTreeMap`이 `Ord`를 트레잇이기 때문에 신뢰하지 않는다는 것입니다. 트레잇은 사용자가 구현하며, 사용자는 버그 있는 구현을 작성할 수 있습니다. 반면에 정수와 슬라이스는 내장 타입입니다. 이들은 언어 자체의 일부이며, 그 동작은 언어 사양에 의해 보장됩니다."

#: src/safe-unsafe-meaning.md:101
msgid ""
"The same logic applies to trusting a closure that's passed to you to behave "
"correctly."
msgstr ""
"동일한 논리가 올바르게 작동하도록 전달된 클로저를 신뢰하는 데에도 적용됩니다."

#: src/safe-unsafe-meaning.md:104
msgid ""
"This problem of unbounded generic trust is the problem that `unsafe` traits "
"exist to resolve. The `BTreeMap` type could theoretically require that keys "
"implement a new trait called `UnsafeOrd`, rather than `Ord`, that might look "
"like this:"
msgstr ""
"이러한 무한한 일반 신뢰 문제는 `unsafe` 트레잇이 해결하기 위해 존재하는 문제입니다. `BTreeMap` 타입은 이론적으로 `Ord` 대신 `UnsafeOrd`라는 새로운 트레잇을 키가 구현하도록 요구할 수 있으며, 이는 다음과 같을 수 있습니다:"

#: src/safe-unsafe-meaning.md:117
msgid ""
"Then, a type would use `unsafe` to implement `UnsafeOrd`, indicating that "
"they've ensured their implementation maintains whatever contracts the trait "
"expects. In this situation, the Unsafe Rust in the internals of `BTreeMap` "
"would be justified in trusting that the key type's `UnsafeOrd` "
"implementation is correct. If it isn't, it's the fault of the unsafe trait "
"implementation, which is consistent with Rust's safety guarantees."
msgstr "그러면 타입은 `unsafe`를 사용하여 `UnsafeOrd`를 구현하고, 해당 구현이 트레잇이 기대하는 모든 계약을 유지함을 보장했음을 나타냅니다. 이 상황에서 `BTreeMap` 내부의 안전하지 않은 러스트는 키 타입의 `UnsafeOrd` 구현이 올바르다고 신뢰하는 것이 정당화될 것입니다. 만약 그렇지 않다면, 이는 안전하지 않은 트레잇 구현의 잘못이며, 이는 러스트의 안전 보장과 일치합니다."

#: src/safe-unsafe-meaning.md:124
msgid ""
"The decision of whether to mark a trait `unsafe` is an API design choice. A "
"safe trait is easier to implement, but any unsafe code that relies on it "
"must defend against incorrect behavior. Marking a trait `unsafe` shifts this "
"responsibility to the implementor. Rust has traditionally avoided marking "
"traits `unsafe` because it makes Unsafe Rust pervasive, which isn't "
"desirable."
msgstr ""
"트레잇을 `unsafe`로 표시할지 여부는 API 설계 선택입니다. 안전한 트레잇은 구현하기 쉽지만, 이에 의존하는 모든 안전하지 않은 코드는 잘못된 동작에 대해 방어해야 합니다. 트레잇을 `unsafe`로 표시하면 이 책임이 구현자에게 전가됩니다. 러스트는 전통적으로 트레잇을 `unsafe`로 표시하는 것을 피했는데, 이는 안전하지 않은 러스트를 만연하게 만들어 바람직하지 않기 때문입니다."

#: src/safe-unsafe-meaning.md:130
msgid ""
"`Send` and `Sync` are marked unsafe because thread safety is a _fundamental "
"property_ that unsafe code can't possibly hope to defend against in the way "
"it could defend against a buggy `Ord` implementation. Similarly, "
"`GlobalAllocator` is keeping accounts of all the memory in the program and "
"other things like `Box` or `Vec` build on top of it. If it does something "
"weird (giving the same chunk of memory to another request when it is still "
"in use), there's no chance to detect that and do anything about it."
msgstr ""
"`Send`와 `Sync`는 스레드 안전성이 _근본적인 속성_이므로 안전하지 않은 것으로 표시됩니다. 안전하지 않은 코드는 버그 있는 `Ord` 구현에 대해 방어할 수 있는 방식으로 스레드 안전성에 대해 방어할 수 없습니다. 마찬가지로 `GlobalAllocator`는 프로그램의 모든 메모리를 관리하며 `Box` 또는 `Vec`와 같은 다른 것들이 그 위에 구축됩니다. 만약 `GlobalAllocator`가 이상한 행동을 한다면(여전히 사용 중인 메모리 청크를 다른 요청에 제공하는 등), 이를 감지하고 조치할 기회가 없습니다."

#: src/safe-unsafe-meaning.md:138
msgid ""
"The decision of whether to mark your own traits `unsafe` depends on the same "
"sort of consideration. If `unsafe` code can't reasonably expect to defend "
"against a broken implementation of the trait, then marking the trait "
"`unsafe` is a reasonable choice."
msgstr ""
"자신만의 트레잇을 `unsafe`로 표시할지 여부는 동일한 종류의 고려 사항에 따라 달라집니다. `unsafe` 코드가 트레잇의 깨진 구현에 대해 합리적으로 방어할 수 없다면, 트레잇을 `unsafe`로 표시하는 것이 합리적인 선택입니다."

#: src/safe-unsafe-meaning.md:143
msgid ""
"As an aside, while `Send` and `Sync` are `unsafe` traits, they are _also_ "
"automatically implemented for types when such derivations are provably safe "
"to do. `Send` is automatically derived for all types composed only of values "
"whose types also implement `Send`. `Sync` is automatically derived for all "
"types composed only of values whose types also implement `Sync`. This "
"automatic derivation is a convenience, but it's also a source of potential "
"bugs if you're not careful."
msgstr ""
"덧붙여, `Send`와 `Sync`는 `unsafe` 트레잇이지만, 그러한 파생이 안전하다고 증명될 때 타입에 대해 _자동으로_ 구현됩니다. `Send`는 타입이 `Send`를 구현하는 값으로만 구성된 모든 타입에 대해 자동으로 파생됩니다. `Sync`는 타입이 `Sync`를 구현하는 값으로만 구성된 모든 타입에 대해 자동으로 파생됩니다. 이러한 자동 파생은 편리하지만, 주의하지 않으면 잠재적인 버그의 원인이 될 수도 있습니다."

#: src/safe-unsafe-meaning.md:152
msgid ""
"This is the balance between Safe and Unsafe Rust. The separation is designed "
"to make using Safe Rust as ergonomic as possible, but requires extra effort "
"and care when writing Unsafe Rust. The rest of this book is largely a "
"discussion of the sort of care that must be taken, and what contracts Unsafe "
"Rust must uphold."
msgstr ""
"이것이 안전한 러스트와 안전하지 않은 러스트 사이의 균형입니다. 분리는 안전한 러스트를 가능한 한 인체공학적으로 사용하도록 설계되었지만, 안전하지 않은 러스트를 작성할 때는 추가적인 노력과 주의가 필요합니다. 이 책의 나머지 부분은 주로 취해야 할 주의 사항과 안전하지 않은 러스트가 준수해야 하는 계약에 대한 논의입니다."

#: src/what-unsafe-does.md:1
msgid "What Unsafe Rust Can Do"
msgstr "안전하지 않은 Rust가 할 수 있는 일"

#: src/what-unsafe-does.md:3
msgid "The only things that are different in Unsafe Rust are that you can:"
msgstr "안전하지 않은 Rust에서 다른 유일한 점은 다음을 수행할 수 있다는 것입니다."

#: src/what-unsafe-does.md:5
msgid "Dereference raw pointers"
msgstr "원시 포인터 역참조"

#: src/what-unsafe-does.md:6
msgid ""
"Call `unsafe` functions (including C functions, compiler intrinsics, and the "
"raw allocator)"
msgstr "안전하지 않은 함수 호출(C 함수, 컴파일러 내장 함수 및 원시 할당자 포함)"

#: src/what-unsafe-does.md:7
msgid "Implement `unsafe` traits"
msgstr "안전하지 않은 트레잇 구현"

#: src/what-unsafe-does.md:8
msgid "Access or modify mutable statics"
msgstr "변경 가능한 정적 변수 접근 또는 수정"

#: src/what-unsafe-does.md:9
msgid "Access fields of `union`s"
msgstr "`union`의 필드 접근"

#: src/what-unsafe-does.md:11
msgid ""
"That's it. The reason these operations are relegated to Unsafe is that "
"misusing any of these things will cause the ever dreaded Undefined Behavior. "
"Invoking Undefined Behavior gives the compiler full rights to do arbitrarily "
"bad things to your program. You definitely _should not_ invoke Undefined "
"Behavior."
msgstr "이게 전부입니다. 이러한 작업이 Unsafe에 맡겨진 이유는 이 중 어느 것이든 잘못 사용하면 항상 두려운 정의되지 않은 동작이 발생하기 때문입니다. 정의되지 않은 동작을 호출하면 컴파일러는 프로그램에 임의로 나쁜 짓을 할 수 있는 모든 권한을 갖게 됩니다. 정의되지 않은 동작을 호출해서는 _절대_ 안 됩니다."

#: src/what-unsafe-does.md:16
msgid ""
"Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the "
"core language cares about is preventing the following things:"
msgstr "C와 달리 Rust에서 정의되지 않은 동작은 범위가 매우 제한적입니다. 핵심 언어는 다음 사항을 방지하는 데 중점을 둡니다."

#: src/what-unsafe-does.md:19
msgid ""
"Dereferencing (using the `*` operator on) dangling or unaligned pointers "
"(see below)"
msgstr "매달려 있거나 정렬되지 않은 포인터 역참조(아래 참조)"

#: src/what-unsafe-does.md:20
msgid "Breaking the [pointer aliasing rules](references.html)"
msgstr "[포인터 별칭 규칙](references.html) 위반"

#: src/what-unsafe-does.md:21
msgid ""
"Calling a function with the wrong call ABI or unwinding from a function with "
"the wrong unwind ABI."
msgstr "잘못된 호출 ABI로 함수를 호출하거나 잘못된 해제 ABI로 함수에서 해제하는 경우."

#: src/what-unsafe-does.md:22
msgid "Causing a [data race](races.html)"
msgstr "[데이터 경쟁](races.html) 유발"

#: src/what-unsafe-does.md:23
msgid ""
"Executing code compiled with [target features](../reference/attributes/"
"codegen.html#the-target_feature-attribute) that the current thread of "
"execution does not support"
msgstr "현재 실행 스레드가 지원하지 않는 [대상 기능](../reference/attributes/codegen.html#the-target_feature-attribute)으로 컴파일된 코드 실행"

#: src/what-unsafe-does.md:25
msgid ""
"Producing invalid values (either alone or as a field of a compound type such "
"as `enum`/`struct`/array/tuple):"
msgstr "(단독으로 또는 `enum`/`struct`/배열/튜플과 같은 복합 타입의 필드로) 유효하지 않은 값 생성:"

#: src/what-unsafe-does.md:27
msgid "a `bool` that isn't 0 or 1"
msgstr "0 또는 1이 아닌 `bool`"

#: src/what-unsafe-does.md:28
msgid "an `enum` with an invalid discriminant"
msgstr "유효하지 않은 판별자를 가진 `enum`"

#: src/what-unsafe-does.md:29
msgid "a null `fn` pointer"
msgstr "널 `fn` 포인터"

#: src/what-unsafe-does.md:30
msgid ""
"a `char` outside the ranges \\[0x0, 0xD7FF\\] and \\[0xE000, 0x10FFFF\\]"
msgstr "범위 \\[0x0, 0xD7FF\\] 및 \\[0xE000, 0x10FFFF\\] 밖에 있는 `char`"

#: src/what-unsafe-does.md:31
msgid "a `!` (all values are invalid for this type)"
msgstr "`!` (모든 값이 이 타입에 대해 유효하지 않음)"

#: src/what-unsafe-does.md:32
msgid ""
"an integer (`i*`/`u*`), floating point value (`f*`), or raw pointer read "
"from [uninitialized memory](uninitialized.html), or uninitialized memory in "
"a `str`."
msgstr "정수(`i*`/`u*`), 부동 소수점 값(`f*`), 또는 [초기화되지 않은 메모리](uninitialized.html)에서 읽은 원시 포인터, 또는 `str`의 초기화되지 않은 메모리."

#: src/what-unsafe-does.md:34
msgid ""
"a reference/`Box` that is dangling, unaligned, or points to an invalid value."
msgstr "매달려 있거나, 정렬되지 않았거나, 유효하지 않은 값을 가리키는 참조/`Box`."

#: src/what-unsafe-does.md:35
msgid "a wide reference, `Box`, or raw pointer that has invalid metadata:"
msgstr ""

#: src/what-unsafe-does.md:36
msgid ""
"`dyn Trait` metadata is invalid if it is not a pointer to a vtable for "
"`Trait` that matches the actual dynamic trait the pointer or reference "
"points to"
msgstr ""

#: src/what-unsafe-does.md:38
msgid ""
"slice metadata is invalid if the length is not a valid `usize` (i.e., it "
"must not be read from uninitialized memory)"
msgstr ""

#: src/what-unsafe-does.md:40
msgid ""
"a type with custom invalid values that is one of those values, such as a "
"[`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom "
"invalid values is an unstable feature, but some stable libstd types, like "
"`NonNull`, make use of it.)"
msgstr ""

#: src/what-unsafe-does.md:44
msgid ""
"For a more detailed explanation about \"Undefined Behavior\", you may refer "
"to [the reference](../reference/behavior-considered-undefined.html)."
msgstr ""

#: src/what-unsafe-does.md:47
msgid ""
"\"Producing\" a value happens any time a value is assigned, passed to a "
"function/primitive operation or returned from a function/primitive operation."
msgstr ""

#: src/what-unsafe-does.md:50
msgid ""
"A reference/pointer is \"dangling\" if it is null or not all of the bytes it "
"points to are part of the same allocation (so in particular they all have to "
"be part of _some_ allocation). The span of bytes it points to is determined "
"by the pointer value and the size of the pointee type. As a consequence, if "
"the span is empty, \"dangling\" is the same as \"null\". Note that slices "
"and strings point to their entire range, so it's important that the length "
"metadata is never too large (in particular, allocations and therefore slices "
"and strings cannot be bigger than `isize::MAX` bytes). If for some reason "
"this is too cumbersome, consider using raw pointers."
msgstr ""

#: src/what-unsafe-does.md:60
msgid ""
"That's it. That's all the causes of Undefined Behavior baked into Rust. Of "
"course, unsafe functions and traits are free to declare arbitrary other "
"constraints that a program must maintain to avoid Undefined Behavior. For "
"instance, the allocator APIs declare that deallocating unallocated memory is "
"Undefined Behavior."
msgstr ""

#: src/what-unsafe-does.md:66
msgid ""
"However, violations of these constraints generally will just transitively "
"lead to one of the above problems. Some additional constraints may also "
"derive from compiler intrinsics that make special assumptions about how code "
"can be optimized. For instance, Vec and Box make use of intrinsics that "
"require their pointers to be non-null at all times."
msgstr ""

#: src/what-unsafe-does.md:71
msgid ""
"Rust is otherwise quite permissive with respect to other dubious operations. "
"Rust considers it \"safe\" to:"
msgstr ""

#: src/what-unsafe-does.md:74
msgid "Deadlock"
msgstr ""

#: src/what-unsafe-does.md:75
msgid "Have a [race condition](races.html)"
msgstr ""

#: src/what-unsafe-does.md:76
msgid "Leak memory"
msgstr ""

#: src/what-unsafe-does.md:77
msgid "Overflow integers (with the built-in operators such as `+` etc.)"
msgstr ""

#: src/what-unsafe-does.md:78
msgid "Abort the program"
msgstr ""

#: src/what-unsafe-does.md:79
msgid "Delete the production database"
msgstr ""

#: src/what-unsafe-does.md:81
msgid ""
"For more detailed information, you may refer to [the reference](../reference/"
"behavior-not-considered-unsafe.html)."
msgstr ""

#: src/what-unsafe-does.md:83
msgid ""
"However any program that actually manages to do such a thing is _probably_ "
"incorrect. Rust provides lots of tools to make these things rare, but these "
"problems are considered impractical to categorically prevent."
msgstr ""

#: src/working-with-unsafe.md:3
msgid ""
"Rust generally only gives us the tools to talk about Unsafe Rust in a scoped "
"and binary manner. Unfortunately, reality is significantly more complicated "
"than that. For instance, consider the following toy function:"
msgstr ""

#: src/working-with-unsafe.md:19
msgid ""
"This function is safe and correct. We check that the index is in bounds, and "
"if it is, index into the array in an unchecked manner. We say that such a "
"correct unsafely implemented function is _sound_, meaning that safe code "
"cannot cause Undefined Behavior through it (which, remember, is the single "
"fundamental property of Safe Rust)."
msgstr ""

#: src/working-with-unsafe.md:25
msgid ""
"But even in such a trivial function, the scope of the unsafe block is "
"questionable. Consider changing the `<` to a `<=`:"
msgstr ""

#: src/working-with-unsafe.md:40
msgid ""
"This program is now _unsound_, Safe Rust can cause Undefined Behavior, and "
"yet _we only modified safe code_. This is the fundamental problem of safety: "
"it's non-local. The soundness of our unsafe operations necessarily depends "
"on the state established by otherwise \"safe\" operations."
msgstr ""

#: src/working-with-unsafe.md:45
msgid ""
"Safety is modular in the sense that opting into unsafety doesn't require you "
"to consider arbitrary other kinds of badness. For instance, doing an "
"unchecked index into a slice doesn't mean you suddenly need to worry about "
"the slice being null or containing uninitialized memory. Nothing "
"fundamentally changes. However safety _isn't_ modular in the sense that "
"programs are inherently stateful and your unsafe operations may depend on "
"arbitrary other state."
msgstr ""

#: src/working-with-unsafe.md:52
msgid ""
"This non-locality gets much worse when we incorporate actual persistent "
"state. Consider a simple implementation of `Vec`:"
msgstr ""

#: src/working-with-unsafe.md:57
msgid ""
"// Note: This definition is naive. See the chapter on implementing Vec.\n"
msgstr ""

#: src/working-with-unsafe.md:64
msgid ""
"// Note this implementation does not correctly handle zero-sized types.\n"
"// See the chapter on implementing Vec.\n"
msgstr ""

#: src/working-with-unsafe.md:70
msgid "// not important for this example\n"
msgstr ""

#: src/working-with-unsafe.md:84
msgid ""
"This code is simple enough to reasonably audit and informally verify. Now "
"consider adding the following method:"
msgstr ""

#: src/working-with-unsafe.md:90
msgid "// grow the capacity\n"
msgstr ""

#: src/working-with-unsafe.md:95
msgid ""
"This code is 100% Safe Rust but it is also completely unsound. Changing the "
"capacity violates the invariants of Vec (that `cap` reflects the allocated "
"space in the Vec). This is not something the rest of Vec can guard against. "
"It _has_ to trust the capacity field because there's no way to verify it."
msgstr ""

#: src/working-with-unsafe.md:100
msgid ""
"Because it relies on invariants of a struct field, this `unsafe` code does "
"more than pollute a whole function: it pollutes a whole _module_. Generally, "
"the only bullet-proof way to limit the scope of unsafe code is at the module "
"boundary with privacy."
msgstr ""

#: src/working-with-unsafe.md:105
msgid ""
"However this works _perfectly_. The existence of `make_room` is _not_ a "
"problem for the soundness of Vec because we didn't mark it as public. Only "
"the module that defines this function can call it. Also, `make_room` "
"directly accesses the private fields of Vec, so it can only be written in "
"the same module as Vec."
msgstr ""

#: src/working-with-unsafe.md:111
msgid ""
"It is therefore possible for us to write a completely safe abstraction that "
"relies on complex invariants. This is _critical_ to the relationship between "
"Safe Rust and Unsafe Rust."
msgstr ""

#: src/working-with-unsafe.md:115
msgid ""
"We have already seen that Unsafe code must trust _some_ Safe code, but "
"shouldn't trust _generic_ Safe code. Privacy is important to unsafe code for "
"similar reasons: it prevents us from having to trust all the safe code in "
"the universe from messing with our trusted state."
msgstr ""

#: src/working-with-unsafe.md:120
msgid "Safety lives!"
msgstr ""

#: src/data.md:1
msgid "Data Representation in Rust"
msgstr ""

#: src/data.md:3
msgid ""
"Low-level programming cares a lot about data layout. It's a big deal. It "
"also pervasively influences the rest of the language, so we're going to "
"start by digging into how data is represented in Rust."
msgstr ""

#: src/data.md:7
msgid ""
"This chapter is ideally in agreement with, and rendered redundant by, the "
"[Type Layout section of the Reference](../reference/type-layout.html). When "
"this book was first written, the reference was in complete disrepair, and "
"the Rustonomicon was attempting to serve as a partial replacement for the "
"reference. This is no longer the case, so this whole chapter can ideally be "
"deleted."
msgstr ""

#: src/data.md:13
msgid ""
"We'll keep this chapter around for a bit longer, but ideally you should be "
"contributing any new facts or improvements to the Reference instead."
msgstr ""

#: src/repr-rust.md:3
msgid ""
"First and foremost, all types have an alignment specified in bytes. The "
"alignment of a type specifies what addresses are valid to store the value "
"at. A value with alignment `n` must only be stored at an address that is a "
"multiple of `n`. So alignment 2 means you must be stored at an even address, "
"and 1 means that you can be stored anywhere. Alignment is at least 1, and "
"always a power of 2."
msgstr ""

#: src/repr-rust.md:10
msgid ""
"Primitives are usually aligned to their size, although this is platform-"
"specific behavior. For example, on x86 `u64` and `f64` are often aligned to "
"4 bytes (32 bits)."
msgstr ""

#: src/repr-rust.md:14
msgid ""
"A type's size must always be a multiple of its alignment (Zero being a valid "
"size for any alignment). This ensures that an array of that type may always "
"be indexed by offsetting by a multiple of its size. Note that the size and "
"alignment of a type may not be known statically in the case of [dynamically "
"sized types](exotic-sizes.html#dynamically-sized-types-dsts)."
msgstr ""

#: src/repr-rust.md:19
msgid "Rust gives you the following ways to lay out composite data:"
msgstr ""

#: src/repr-rust.md:21
msgid "structs (named product types)"
msgstr ""

#: src/repr-rust.md:22
msgid "tuples (anonymous product types)"
msgstr ""

#: src/repr-rust.md:23
msgid "arrays (homogeneous product types)"
msgstr ""

#: src/repr-rust.md:24
msgid "enums (named sum types -- tagged unions)"
msgstr ""

#: src/repr-rust.md:25
msgid "unions (untagged unions)"
msgstr ""

#: src/repr-rust.md:27
msgid ""
"An enum is said to be _field-less_ if none of its variants have associated "
"data."
msgstr ""

#: src/repr-rust.md:29
msgid ""
"By default, composite structures have an alignment equal to the maximum of "
"their fields' alignments. Rust will consequently insert padding where "
"necessary to ensure that all fields are properly aligned and that the "
"overall type's size is a multiple of its alignment. For instance:"
msgstr ""

#: src/repr-rust.md:42
msgid ""
"will be 32-bit aligned on a target that aligns these primitives to their "
"respective sizes. The whole struct will therefore have a size that is a "
"multiple of 32-bits. It may become:"
msgstr ""

#: src/repr-rust.md:49
msgid "// to align `b`\n"
msgstr ""

#: src/repr-rust.md:52
msgid "// to make overall size multiple of 4\n"
msgstr ""

#: src/repr-rust.md:56
msgid "or maybe:"
msgstr ""

#: src/repr-rust.md:67
msgid ""
"There is _no indirection_ for these types; all data is stored within the "
"struct, as you would expect in C. However with the exception of arrays "
"(which are densely packed and in-order), the layout of data is not specified "
"by default. Given the two following struct definitions:"
msgstr ""

#: src/repr-rust.md:84
msgid ""
"Rust _does_ guarantee that two instances of A have their data laid out in "
"exactly the same way. However Rust _does not_ currently guarantee that an "
"instance of A has the same field ordering or padding as an instance of B."
msgstr ""

#: src/repr-rust.md:88
msgid ""
"With A and B as written, this point would seem to be pedantic, but several "
"other features of Rust make it desirable for the language to play with data "
"layout in complex ways."
msgstr ""

#: src/repr-rust.md:92
msgid "For instance, consider this struct:"
msgstr ""

#: src/repr-rust.md:102
msgid ""
"Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. "
"If Rust lays out the fields in the order specified, we expect it to pad the "
"values in the struct to satisfy their alignment requirements. So if Rust "
"didn't reorder fields, we would expect it to produce the following:"
msgstr ""

#: src/repr-rust.md:124
msgid ""
"The latter case quite simply wastes space. An optimal use of space requires "
"different monomorphizations to have _different field orderings_."
msgstr ""

#: src/repr-rust.md:127
msgid ""
"Enums make this consideration even more complicated. Naively, an enum such "
"as:"
msgstr ""

#: src/repr-rust.md:137
msgid "might be laid out as:"
msgstr ""

#: src/repr-rust.md:141
msgid "// this is either a u64, u32, or u8 based on `tag`\n"
msgstr ""

#: src/repr-rust.md:142
msgid "// 0 = A, 1 = B, 2 = C\n"
msgstr ""

#: src/repr-rust.md:146
msgid ""
"And indeed this is approximately how it would be laid out (modulo the size "
"and position of `tag`)."
msgstr ""

#: src/repr-rust.md:149
msgid ""
"However there are several cases where such a representation is inefficient. "
"The classic case of this is Rust's \"null pointer optimization\": an enum "
"consisting of a single outer unit variant (e.g. `None`) and a (potentially "
"nested) non- nullable pointer variant (e.g. `Some(&T)`) makes the tag "
"unnecessary. A null pointer can safely be interpreted as the unit (`None`) "
"variant. The net result is that, for example, `size_of::<Option<&T>>() == "
"size_of::<&T>()`."
msgstr ""

#: src/repr-rust.md:156
msgid ""
"There are many types in Rust that are, or contain, non-nullable pointers "
"such as `Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can "
"imagine nested enums pooling their tags into a single discriminant, as they "
"are by definition known to have a limited range of valid values. In "
"principle enums could use fairly elaborate algorithms to store bits "
"throughout nested types with forbidden values. As such it is _especially_ "
"desirable that we leave enum layout unspecified today."
msgstr ""

#: src/exotic-sizes.md:3
msgid ""
"Most of the time, we expect types to have a statically known and positive "
"size. This isn't always the case in Rust."
msgstr ""

#: src/exotic-sizes.md:6
msgid "Dynamically Sized Types (DSTs)"
msgstr ""

#: src/exotic-sizes.md:8
msgid ""
"Rust supports Dynamically Sized Types (DSTs): types without a statically "
"known size or alignment. On the surface, this is a bit nonsensical: Rust "
"_must_ know the size and alignment of something in order to correctly work "
"with it! In this regard, DSTs are not normal types. Since they lack a "
"statically known size, these types can only exist behind a pointer. Any "
"pointer to a DST consequently becomes a _wide_ pointer consisting of the "
"pointer and the information that \"completes\" them (more on this below)."
msgstr ""

#: src/exotic-sizes.md:16
msgid "There are two major DSTs exposed by the language:"
msgstr ""

#: src/exotic-sizes.md:18
msgid "trait objects: `dyn MyTrait`"
msgstr ""

#: src/exotic-sizes.md:19
msgid ""
"slices: [`[T]`](../std/primitive.slice.html), [`str`](../std/"
"primitive.str.html), and others"
msgstr ""

#: src/exotic-sizes.md:21
msgid ""
"A trait object represents some type that implements the traits it specifies. "
"The exact original type is _erased_ in favor of runtime reflection with a "
"vtable containing all the information necessary to use the type. The "
"information that completes a trait object pointer is the vtable pointer. The "
"runtime size of the pointee can be dynamically requested from the vtable."
msgstr ""

#: src/exotic-sizes.md:27
msgid ""
"A slice is simply a view into some contiguous storage -- typically an array "
"or `Vec`. The information that completes a slice pointer is just the number "
"of elements it points to. The runtime size of the pointee is just the "
"statically known size of an element multiplied by the number of elements."
msgstr ""

#: src/exotic-sizes.md:32
msgid ""
"Structs can actually store a single DST directly as their last field, but "
"this makes them a DST as well:"
msgstr ""

#: src/exotic-sizes.md:36
msgid "// Can't be stored on the stack directly\n"
msgstr ""

#: src/exotic-sizes.md:43
msgid ""
"Unfortunately, such a type is largely useless without a way to construct it. "
"Currently the only properly supported way to create a custom DST is by "
"making your type generic and performing an _unsizing coercion_:"
msgstr ""

#: src/exotic-sizes.md:61
msgid "// prints: \"17 [0, 0, 0, 0, 0, 0, 0, 0]\"\n"
msgstr ""

#: src/exotic-sizes.md:62
msgid "\"{} {:?}\""
msgstr ""

#: src/exotic-sizes.md:66
msgid "(Yes, custom DSTs are a largely half-baked feature for now.)"
msgstr ""

#: src/exotic-sizes.md:68
msgid "Zero Sized Types (ZSTs)"
msgstr ""

#: src/exotic-sizes.md:70
msgid "Rust also allows types to be specified that occupy no space:"
msgstr ""

#: src/exotic-sizes.md:73
msgid "// No fields = no size\n"
msgstr ""

#: src/exotic-sizes.md:74
msgid "// All fields have no size = no size\n"
msgstr ""

#: src/exotic-sizes.md:78
msgid "// empty tuple has no size\n"
msgstr ""

#: src/exotic-sizes.md:79
msgid "// empty array has no size\n"
msgstr ""

#: src/exotic-sizes.md:83
msgid ""
"On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty "
"useless. However as with many curious layout choices in Rust, their "
"potential is realized in a generic context: Rust largely understands that "
"any operation that produces or stores a ZST can be reduced to a no-op. First "
"off, storing it doesn't even make sense -- it doesn't occupy any space. Also "
"there's only one value of that type, so anything that loads it can just "
"produce it from the aether -- which is also a no-op since it doesn't occupy "
"any space."
msgstr ""

#: src/exotic-sizes.md:91
msgid ""
"One of the most extreme examples of this is Sets and Maps. Given a `Map<Key, "
"Value>`, it is common to implement a `Set<Key>` as just a thin wrapper "
"around `Map<Key, UselessJunk>`. In many languages, this would necessitate "
"allocating space for UselessJunk and doing work to store and load "
"UselessJunk only to discard it. Proving this unnecessary would be a "
"difficult analysis for the compiler."
msgstr ""

#: src/exotic-sizes.md:98
msgid ""
"However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust "
"statically knows that every load and store is useless, and no allocation has "
"any size. The result is that the monomorphized code is basically a custom "
"implementation of a HashSet with none of the overhead that HashMap would "
"have to support values."
msgstr ""

#: src/exotic-sizes.md:104
msgid ""
"Safe code need not worry about ZSTs, but _unsafe_ code must be careful about "
"the consequence of types with no size. In particular, pointer offsets are no-"
"ops, and allocators typically [require a non-zero size](../std/alloc/"
"trait.GlobalAlloc.html#tymethod.alloc)."
msgstr ""

#: src/exotic-sizes.md:108
msgid ""
"Note that references to ZSTs (including empty slices), just like all other "
"references, must be non-null and suitably aligned. Dereferencing a null or "
"unaligned pointer to a ZST is [undefined behavior](what-unsafe-does.html), "
"just like for any other type."
msgstr ""

#: src/exotic-sizes.md:116
msgid "Empty Types"
msgstr ""

#: src/exotic-sizes.md:118
msgid ""
"Rust also enables types to be declared that _cannot even be instantiated_. "
"These types can only be talked about at the type level, and never at the "
"value level. Empty types can be declared by specifying an enum with no "
"variants:"
msgstr ""

#: src/exotic-sizes.md:123
msgid "// No variants = EMPTY\n"
msgstr ""

#: src/exotic-sizes.md:126
msgid ""
"Empty types are even more marginal than ZSTs. The primary motivating example "
"for an empty type is type-level unreachability. For instance, suppose an API "
"needs to return a Result in general, but a specific case actually is "
"infallible. It's actually possible to communicate this at the type level by "
"returning a `Result<T, Void>`. Consumers of the API can confidently unwrap "
"such a Result knowing that it's _statically impossible_ for this value to be "
"an `Err`, as this would require providing a value of type `Void`."
msgstr ""

#: src/exotic-sizes.md:134
msgid ""
"In principle, Rust can do some interesting analyses and optimizations based "
"on this fact. For instance, `Result<T, Void>` is represented as just `T`, "
"because the `Err` case doesn't actually exist (strictly speaking, this is "
"only an optimization that is not guaranteed, so for example transmuting one "
"into the other is still Undefined Behavior)."
msgstr ""

#: src/exotic-sizes.md:140
msgid "The following also compiles:"
msgstr ""

#: src/exotic-sizes.md:146
msgid "// Err doesn't exist anymore, so Ok is actually irrefutable.\n"
msgstr ""

#: src/exotic-sizes.md:151
msgid ""
"One final subtle detail about empty types is that raw pointers to them are "
"actually valid to construct, but dereferencing them is Undefined Behavior "
"because that wouldn't make sense."
msgstr ""

#: src/exotic-sizes.md:155
msgid ""
"We recommend against modelling C's `void*` type with `*const Void`. A lot of "
"people started doing that but quickly ran into trouble because Rust doesn't "
"really have any safety guards against trying to instantiate empty types with "
"unsafe code, and if you do it, it's Undefined Behavior. This was especially "
"problematic because developers had a habit of converting raw pointers to "
"references and `&Void` is _also_ Undefined Behavior to construct."
msgstr ""

#: src/exotic-sizes.md:163
msgid ""
"`*const ()` (or equivalent) works reasonably well for `void*`, and can be "
"made into a reference without any safety problems. It still doesn't prevent "
"you from trying to read or write values, but at least it compiles to a no-op "
"instead of Undefined Behavior."
msgstr ""

#: src/exotic-sizes.md:168
msgid "Extern Types"
msgstr ""

#: src/exotic-sizes.md:170
msgid ""
"There is [an accepted RFC](https://github.com/rust-lang/rfcs/blob/master/"
"text/1861-extern-types.md) to add proper types with an unknown size, called "
"_extern types_, which would let Rust developers model things like C's "
"`void*` and other \"declared but never defined\" types more accurately. "
"However as of Rust 2018, [the feature is stuck in limbo over how "
"`size_of_val::<MyExternType>()` should behave](https://github.com/rust-lang/"
"rust/issues/43467)."
msgstr ""

#: src/other-reprs.md:1
msgid "Alternative representations"
msgstr ""

#: src/other-reprs.md:3
msgid ""
"Rust allows you to specify alternative data layout strategies from the "
"default. There's also the [unsafe code guidelines](https://rust-"
"lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** "
"normative)."
msgstr ""

#: src/other-reprs.md:6
msgid "repr(C)"
msgstr ""

#: src/other-reprs.md:8
msgid ""
"This is the most important `repr`. It has fairly simple intent: do what C "
"does. The order, size, and alignment of fields is exactly what you would "
"expect from C or C++. The type is also passed across `extern \"C\"` function "
"call boundaries the same way C would pass the corresponding type. Any type "
"you expect to pass through an FFI boundary should have `repr(C)`, as C is "
"the lingua-franca of the programming world. This is also necessary to "
"soundly do more elaborate tricks with data layout such as reinterpreting "
"values as a different type."
msgstr ""

#: src/other-reprs.md:16
msgid ""
"We strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-"
"bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage "
"your FFI boundaries for you. The Rust team works closely with those projects "
"to ensure that they work robustly and are compatible with current and future "
"guarantees about type layouts and `repr`s."
msgstr ""

#: src/other-reprs.md:21
msgid ""
"The interaction of `repr(C)` with Rust's more exotic data layout features "
"must be kept in mind. Due to its dual purpose as \"for FFI\" and \"for "
"layout control\", `repr(C)` can be applied to types that will be nonsensical "
"or problematic if passed through the FFI boundary."
msgstr ""

#: src/other-reprs.md:26
msgid ""
"ZSTs are still zero-sized, even though this is not a standard behavior in C, "
"and is explicitly contrary to the behavior of an empty type in C++, which "
"says they should still consume a byte of space."
msgstr ""

#: src/other-reprs.md:30
msgid ""
"DST pointers (wide pointers) and tuples are not a concept in C, and as such "
"are never FFI-safe."
msgstr ""

#: src/other-reprs.md:33
msgid ""
"Enums with fields also aren't a concept in C or C++, but a valid bridging of "
"the types [is defined](https://github.com/rust-lang/rfcs/blob/master/text/"
"2195-really-tagged-unions.md)."
msgstr ""

#: src/other-reprs.md:36
msgid ""
"If `T` is an [FFI-safe non-nullable pointer type](ffi.html#the-nullable-"
"pointer-optimization), `Option<T>` is guaranteed to have the same layout and "
"ABI as `T` and is therefore also FFI-safe. As of this writing, this covers "
"`&`, `&mut`, and function pointers, all of which can never be null."
msgstr ""

#: src/other-reprs.md:42
msgid ""
"Tuple structs are like structs with regards to `repr(C)`, as the only "
"difference from a struct is that the fields aren’t named."
msgstr ""

#: src/other-reprs.md:45
msgid ""
"`repr(C)` is equivalent to one of `repr(u*)` (see the next section) for "
"fieldless enums. The chosen size and sign is the default enum size and sign "
"for the target platform's C application binary interface (ABI). Note that "
"enum representation in C is implementation defined, so this is really a "
"\"best guess\". In particular, this may be incorrect when the C code of "
"interest is compiled with certain flags."
msgstr ""

#: src/other-reprs.md:51
msgid ""
"Fieldless enums with `repr(C)` or `repr(u*)` still may not be set to an "
"integer value without a corresponding variant, even though this is permitted "
"behavior in C or C++. It is undefined behavior to (unsafely) construct an "
"instance of an enum that does not match one of its variants. (This allows "
"exhaustive matches to continue to be written and compiled as normal.)"
msgstr ""

#: src/other-reprs.md:58
msgid "repr(transparent)"
msgstr ""

#: src/other-reprs.md:60
msgid ""
"`#[repr(transparent)]` can only be used on a struct or single-variant enum "
"that has a single non-zero-sized field (there may be additional zero-sized "
"fields). The effect is that the layout and ABI of the whole struct/enum is "
"guaranteed to be the same as that one field."
msgstr ""

#: src/other-reprs.md:63
msgid ""
"NOTE: There's a `transparent_unions` nightly feature to apply "
"`repr(transparent)` to unions, but it hasn't been stabilized due to design "
"concerns. See the [tracking issue](https://github.com/rust-lang/rust/issues/"
"60405) for more details."
msgstr ""

#: src/other-reprs.md:66
msgid ""
"The goal is to make it possible to transmute between the single field and "
"the struct/enum. An example of that is [`UnsafeCell`](../std/cell/"
"struct.UnsafeCell.html), which can be transmuted into the type it wraps "
"([`UnsafeCell`](../std/cell/struct.UnsafeCell.html) also uses the unstable "
"[no_niche](https://github.com/rust-lang/rust/pull/68491), so its ABI is not "
"actually guaranteed to be the same when nested in other types)."
msgstr ""

#: src/other-reprs.md:71
msgid ""
"Also, passing the struct/enum through FFI where the inner field type is "
"expected on the other side is guaranteed to work. In particular, this is "
"necessary for `struct Foo(f32)` or `enum Foo { Bar(f32) }` to always have "
"the same ABI as `f32`."
msgstr ""

#: src/other-reprs.md:75
msgid ""
"This repr is only considered part of the public ABI of a type if either the "
"single field is `pub`, or if its layout is documented in prose. Otherwise, "
"the layout should not be relied upon by other crates."
msgstr ""

#: src/other-reprs.md:79
msgid ""
"More details are in the [RFC 1758](https://github.com/rust-lang/rfcs/blob/"
"master/text/1758-repr-transparent.md) and the [RFC 2645](https://rust-"
"lang.github.io/rfcs/2645-transparent-unions.html)."
msgstr ""

#: src/other-reprs.md:81
msgid "repr(u\\*), repr(i\\*)"
msgstr ""

#: src/other-reprs.md:83
msgid ""
"These specify the size and sign to make a fieldless enum. If the "
"discriminant overflows the integer it has to fit in, it will produce a "
"compile-time error. You can manually ask Rust to allow this by setting the "
"overflowing element to explicitly be 0. However Rust will not allow you to "
"create an enum where two variants have the same discriminant."
msgstr ""

#: src/other-reprs.md:89
msgid ""
"The term \"fieldless enum\" only means that the enum doesn't have data in "
"any of its variants. A fieldless enum without a `repr` is still a Rust "
"native type, and does not have a stable layout or representation. Adding a "
"`repr(u*)`/`repr(i*)` causes it to be treated exactly like the specified "
"integer type for layout purposes (except that the compiler will still "
"exploit its knowledge of \"invalid\" values at this type to optimize enum "
"layout, such as when this enum is wrapped in `Option`). Note that the "
"function call ABI for these types is still in general unspecified, except "
"that across `extern \"C\"` calls they are ABI-compatible with C enums of the "
"same sign and size."
msgstr ""

#: src/other-reprs.md:99
msgid ""
"If the enum has fields, the effect is similar to the effect of `repr(C)` in "
"that there is a defined layout of the type. This makes it possible to pass "
"the enum to C code, or access the type's raw representation and directly "
"manipulate its tag and fields. See [the RFC](https://github.com/rust-lang/"
"rfcs/blob/master/text/2195-really-tagged-unions.md) for details."
msgstr ""

#: src/other-reprs.md:104
msgid "These `repr`s have no effect on a struct."
msgstr ""

#: src/other-reprs.md:106
msgid ""
"Adding an explicit `repr(u*)`, `repr(i*)`, or `repr(C)` to an enum with "
"fields suppresses the null-pointer optimization, like:"
msgstr ""

#: src/other-reprs.md:125
msgid ""
"This optimization still applies to fieldless enums with an explicit "
"`repr(u*)`, `repr(i*)`, or `repr(C)`."
msgstr ""

#: src/other-reprs.md:127
msgid "repr(packed), repr(packed(n))"
msgstr ""

#: src/other-reprs.md:129
msgid ""
"`repr(packed(n))` (where `n` is a power of two) forces the type to have an "
"alignment of _at most_ `n`. Most commonly used without an explicit `n`, "
"`repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip "
"any padding, and only align the type to a byte. This may improve the memory "
"footprint, but will likely have other negative side-effects."
msgstr ""

#: src/other-reprs.md:135
msgid ""
"In particular, most architectures _strongly_ prefer values to be naturally "
"aligned. This may mean that unaligned loads are penalized (x86), or even "
"fault (some ARM chips). For simple cases like directly loading or storing a "
"packed field, the compiler might be able to paper over alignment issues with "
"shifts and masks. However if you take a reference to a packed field, it's "
"unlikely that the compiler will be able to emit code to avoid an unaligned "
"load."
msgstr ""

#: src/other-reprs.md:142
msgid ""
"[As this can cause undefined behavior](https://github.com/rust-lang/rust/"
"issues/27060), the lint has been implemented and it will become a hard error."
msgstr ""

#: src/other-reprs.md:145
msgid ""
"`repr(packed)/repr(packed(n))` is not to be used lightly. Unless you have "
"extreme requirements, this should not be used."
msgstr ""

#: src/other-reprs.md:148
msgid ""
"This repr is a modifier on `repr(C)` and `repr(Rust)`. For FFI compatibilty "
"you most likely always want to be explicit: `repr(C, packed)`."
msgstr ""

#: src/other-reprs.md:151
msgid "repr(align(n))"
msgstr ""

#: src/other-reprs.md:153
msgid ""
"`repr(align(n))` (where `n` is a power of two) forces the type to have an "
"alignment of _at least_ `n`."
msgstr ""

#: src/other-reprs.md:156
msgid ""
"This enables several tricks, like making sure neighboring elements of an "
"array never share the same cache line with each other (which may speed up "
"certain kinds of concurrent code)."
msgstr ""

#: src/other-reprs.md:160
msgid ""
"This is a modifier on `repr(C)` and `repr(Rust)`. It is incompatible with "
"`repr(packed)`."
msgstr ""

#: src/ownership.md:1
msgid "Ownership and Lifetimes"
msgstr ""

#: src/ownership.md:3
msgid ""
"Ownership is the breakout feature of Rust. It allows Rust to be completely "
"memory-safe and efficient, while avoiding garbage collection. Before getting "
"into the ownership system in detail, we will consider the motivation of this "
"design."
msgstr ""

#: src/ownership.md:8
msgid ""
"We will assume that you accept that garbage collection (GC) is not always an "
"optimal solution, and that it is desirable to manually manage memory in some "
"contexts. If you do not accept this, might I interest you in a different "
"language?"
msgstr ""

#: src/ownership.md:13
msgid ""
"Regardless of your feelings on GC, it is pretty clearly a _massive_ boon to "
"making code safe. You never have to worry about things going away _too soon_ "
"(although whether you still wanted to be pointing at that thing is a "
"different issue...). This is a pervasive problem that C and C++ programs "
"need to deal with. Consider this simple mistake that all of us who have used "
"a non-GC'd language have made at one point:"
msgstr ""

#: src/ownership.md:22
msgid "// compute the string\n"
msgstr ""

#: src/ownership.md:23 src/ownership.md:59 src/lifetimes.md:98
#: src/lifetimes.md:109 src/lifetimes.md:137 src/lifetimes.md:150
#: src/lifetimes.md:162 src/lifetimes.md:182 src/lifetimes.md:198
#: src/lifetimes.md:238 src/lifetimes.md:273 src/lifetimes.md:292
#: src/lifetimes.md:295 src/hrtb.md:24 src/hrtb.md:52 src/hrtb.md:105
#: src/checked-uninit.md:10 src/checked-uninit.md:39 src/checked-uninit.md:51
#: src/checked-uninit.md:68 src/checked-uninit.md:95 src/drop-flags.md:52
#: src/drop-flags.md:66 src/drop-flags.md:78 src/leaking.md:89 src/races.md:60
#: src/races.md:88 src/panic-handler.md:47
msgid "\"{}\""
msgstr ""

#: src/ownership.md:25
msgid ""
"// OH NO! We returned a reference to something that\n"
"    // exists only in this function!\n"
"    // Dangling pointer! Use after free! Alas!\n"
"    // (this does not compile in Rust)\n"
msgstr ""

#: src/ownership.md:33
msgid ""
"This is exactly what Rust's ownership system was built to solve. Rust knows "
"the scope in which the `&s` lives, and as such can prevent it from escaping. "
"However this is a simple case that even a C compiler could plausibly catch. "
"Things get more complicated as code gets bigger and pointers get fed through "
"various functions. Eventually, a C compiler will fall down and won't be able "
"to perform sufficient escape analysis to prove your code unsound. It will "
"consequently be forced to accept your program on the assumption that it is "
"correct."
msgstr ""

#: src/ownership.md:41
msgid ""
"This will never happen to Rust. It's up to the programmer to prove to the "
"compiler that everything is sound."
msgstr ""

#: src/ownership.md:44
msgid ""
"Of course, Rust's story around ownership is much more complicated than just "
"verifying that references don't escape the scope of their referent. That's "
"because ensuring pointers are always valid is much more complicated than "
"this. For instance in this code,"
msgstr ""

#: src/ownership.md:50
msgid "// get an internal reference\n"
msgstr ""

#: src/ownership.md:53
msgid ""
"// OH NO! `push` causes the backing storage of `data` to be reallocated.\n"
"// Dangling pointer! Use after free! Alas!\n"
"// (this does not compile in Rust)\n"
msgstr ""

#: src/ownership.md:62
msgid ""
"naive scope analysis would be insufficient to prevent this bug, because "
"`data` does in fact live as long as we needed. However it was _changed_ "
"while we had a reference into it. This is why Rust requires any references "
"to freeze the referent and its owners."
msgstr ""

#: src/references.md:3
msgid "There are two kinds of references:"
msgstr ""

#: src/references.md:5
msgid "Shared reference: `&`"
msgstr ""

#: src/references.md:6
msgid "Mutable reference: `&mut`"
msgstr ""

#: src/references.md:8
msgid "Which obey the following rules:"
msgstr ""

#: src/references.md:10
msgid "A reference cannot outlive its referent"
msgstr ""

#: src/references.md:11
msgid "A mutable reference cannot be aliased"
msgstr ""

#: src/references.md:13
msgid "That's it. That's the whole model references follow."
msgstr ""

#: src/references.md:15
msgid "Of course, we should probably define what _aliased_ means."
msgstr ""

#: src/references.md:17
msgid ""
"```text\n"
"error[E0425]: cannot find value `aliased` in this scope\n"
" --> <rust.rs>:2:20\n"
"  |\n"
"2 |     println!(\"{}\", aliased);\n"
"  |                    ^^^^^^^ not found in this scope\n"
"\n"
"error: aborting due to previous error\n"
"```"
msgstr ""

#: src/references.md:27
msgid "Unfortunately, Rust hasn't actually defined its aliasing model. 🙀"
msgstr ""

#: src/references.md:29
msgid ""
"While we wait for the Rust devs to specify the semantics of their language, "
"let's use the next section to discuss what aliasing is in general, and why "
"it matters."
msgstr ""

#: src/aliasing.md:3
msgid "First off, let's get some important caveats out of the way:"
msgstr ""

#: src/aliasing.md:5
msgid ""
"We will be using the broadest possible definition of aliasing for the sake "
"of discussion. Rust's definition will probably be more restricted to factor "
"in mutations and liveness."
msgstr ""

#: src/aliasing.md:9
msgid ""
"We will be assuming a single-threaded, interrupt-free, execution. We will "
"also be ignoring things like memory-mapped hardware. Rust assumes these "
"things don't happen unless you tell it otherwise. For more details, see the "
"[Concurrency Chapter](concurrency.html)."
msgstr ""

#: src/aliasing.md:14
msgid ""
"With that said, here's our working definition: variables and pointers "
"_alias_ if they refer to overlapping regions of memory."
msgstr ""

#: src/aliasing.md:17
msgid "Why Aliasing Matters"
msgstr ""

#: src/aliasing.md:19
msgid "So why should we care about aliasing?"
msgstr ""

#: src/aliasing.md:21
msgid "Consider this simple function:"
msgstr ""

#: src/aliasing.md:31
msgid "// remember that `output` will be `2` if `input > 10`\n"
msgstr ""

#: src/aliasing.md:35
msgid "We would _like_ to be able to optimize it to the following function:"
msgstr ""

#: src/aliasing.md:39
msgid "// keep `*input` in a register\n"
msgstr ""

#: src/aliasing.md:41
msgid ""
"// If the input is greater than 10, the previous code would set the output "
"to 1 and then double it,\n"
"        // resulting in an output of 2 (because `>10` implies `>5`).\n"
"        // Here, we avoid the double assignment and just set it directly to "
"2.\n"
msgstr ""

#: src/aliasing.md:51
msgid ""
"In Rust, this optimization should be sound. For almost any other language, "
"it wouldn't be (barring global analysis). This is because the optimization "
"relies on knowing that aliasing doesn't occur, which most languages are "
"fairly liberal with. Specifically, we need to worry about function arguments "
"that make `input` and `output` overlap, such as `compute(&x, &mut x)`."
msgstr ""

#: src/aliasing.md:57
msgid "With that input, we could get this execution:"
msgstr ""

#: src/aliasing.md:61
msgid ""
"//  input ==  output == 0xabad1dea\n"
"                    // *input == *output == 20\n"
msgstr ""

#: src/aliasing.md:63
msgid "// true  (*input == 20)\n"
msgstr ""

#: src/aliasing.md:64
msgid "// also overwrites *input, because they are the same\n"
msgstr ""

#: src/aliasing.md:66
msgid "// false (*input == 1)\n"
msgstr ""

#: src/aliasing.md:69
msgid "// *input == *output == 1\n"
msgstr ""

#: src/aliasing.md:72
msgid ""
"Our optimized function would produce `*output == 2` for this input, so the "
"correctness of our optimization relies on this input being impossible."
msgstr ""

#: src/aliasing.md:75
msgid ""
"In Rust we know this input should be impossible because `&mut` isn't allowed "
"to be aliased. So we can safely reject its possibility and perform this "
"optimization. In most other languages, this input would be entirely "
"possible, and must be considered."
msgstr ""

#: src/aliasing.md:79
msgid ""
"This is why alias analysis is important: it lets the compiler perform useful "
"optimizations! Some examples:"
msgstr ""

#: src/aliasing.md:82
msgid ""
"keeping values in registers by proving no pointers access the value's memory"
msgstr ""

#: src/aliasing.md:83
msgid ""
"eliminating reads by proving some memory hasn't been written to since last "
"we read it"
msgstr ""

#: src/aliasing.md:84
msgid ""
"eliminating writes by proving some memory is never read before the next "
"write to it"
msgstr ""

#: src/aliasing.md:85
msgid ""
"moving or reordering reads and writes by proving they don't depend on each "
"other"
msgstr ""

#: src/aliasing.md:87
msgid ""
"These optimizations also tend to prove the soundness of bigger optimizations "
"such as loop vectorization, constant propagation, and dead code elimination."
msgstr ""

#: src/aliasing.md:90
msgid ""
"In the previous example, we used the fact that `&mut u32` can't be aliased "
"to prove that writes to `*output` can't possibly affect `*input`. This lets "
"us cache `*input` in a register, eliminating a read."
msgstr ""

#: src/aliasing.md:94
msgid ""
"By caching this read, we knew that the write in the `> 10` branch couldn't "
"affect whether we take the `> 5` branch, allowing us to also eliminate a "
"read-modify-write (doubling `*output`) when `*input > 10`."
msgstr ""

#: src/aliasing.md:98
msgid ""
"The key thing to remember about alias analysis is that writes are the "
"primary hazard for optimizations. That is, the only thing that prevents us "
"from moving a read to any other part of the program is the possibility of us "
"re-ordering it with a write to the same location."
msgstr ""

#: src/aliasing.md:103
msgid ""
"For instance, we have no concern for aliasing in the following modified "
"version of our function, because we've moved the only write to `*output` to "
"the very end of our function. This allows us to freely reorder the reads of "
"`*input` that occur before it:"
msgstr ""

#: src/aliasing.md:121
msgid ""
"We're still relying on alias analysis to assume that `input` doesn't alias "
"`temp`, but the proof is much simpler: the value of a local variable can't "
"be aliased by things that existed before it was declared. This is an "
"assumption every language freely makes, and so this version of the function "
"could be optimized the way we want in any language."
msgstr ""

#: src/aliasing.md:127
msgid ""
"This is why the definition of \"alias\" that Rust will use likely involves "
"some notion of liveness and mutation: we don't actually care if aliasing "
"occurs if there aren't any actual writes to memory happening."
msgstr ""

#: src/aliasing.md:131
msgid ""
"Of course, a full aliasing model for Rust must also take into consideration "
"things like function calls (which may mutate things we don't see), raw "
"pointers (which have no aliasing requirements on their own), and UnsafeCell "
"(which lets the referent of an `&` be mutated)."
msgstr ""

#: src/lifetimes.md:3
msgid ""
"Rust enforces these rules through _lifetimes_. Lifetimes are named regions "
"of code that a reference must be valid for. Those regions may be fairly "
"complex, as they correspond to paths of execution in the program. There may "
"even be holes in these paths of execution, as it's possible to invalidate a "
"reference as long as it's reinitialized before it's used again. Types which "
"contain references (or pretend to) may also be tagged with lifetimes so that "
"Rust can prevent them from being invalidated as well."
msgstr ""

#: src/lifetimes.md:12
msgid ""
"In most of our examples, the lifetimes will coincide with scopes. This is "
"because our examples are simple. The more complex cases where they don't "
"coincide are described below."
msgstr ""

#: src/lifetimes.md:16
msgid ""
"Within a function body, Rust generally doesn't let you explicitly name the "
"lifetimes involved. This is because it's generally not really necessary to "
"talk about lifetimes in a local context; Rust has all the information and "
"can work out everything as optimally as possible. Many anonymous scopes and "
"temporaries that you would otherwise have to write are often introduced to "
"make your code Just Work."
msgstr ""

#: src/lifetimes.md:23
msgid ""
"However once you cross the function boundary, you need to start talking "
"about lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. "
"To dip our toes with lifetimes, we're going to pretend that we're actually "
"allowed to label scopes with lifetimes, and desugar the examples from the "
"start of this chapter."
msgstr ""

#: src/lifetimes.md:29
msgid ""
"Originally, our examples made use of _aggressive_ sugar -- high fructose "
"corn syrup even -- around scopes and lifetimes, because writing everything "
"out explicitly is _extremely noisy_. All Rust code relies on aggressive "
"inference and elision of \"obvious\" things."
msgstr ""

#: src/lifetimes.md:34
msgid ""
"One particularly interesting piece of sugar is that each `let` statement "
"implicitly introduces a scope. For the most part, this doesn't really "
"matter. However it does matter for variables that refer to each other. As a "
"simple example, let's completely desugar this simple piece of Rust code:"
msgstr ""

#: src/lifetimes.md:45
msgid ""
"The borrow checker always tries to minimize the extent of a lifetime, so it "
"will likely desugar to the following:"
msgstr ""

#: src/lifetimes.md:50
msgid "// NOTE: `'a: {` and `&'b x` is not valid syntax!\n"
msgstr ""

#: src/lifetimes.md:54
msgid "// lifetime used is 'b because that's good enough.\n"
msgstr ""

#: src/lifetimes.md:57
msgid "// ditto on 'c\n"
msgstr ""

#: src/lifetimes.md:58
msgid ""
"// \"a reference to a reference to an i32\" (with lifetimes annotated)\n"
msgstr ""

#: src/lifetimes.md:64
msgid ""
"Wow. That's... awful. Let's all take a moment to thank Rust for making this "
"easier."
msgstr ""

#: src/lifetimes.md:66
msgid ""
"Actually passing references to outer scopes will cause Rust to infer a "
"larger lifetime:"
msgstr ""

#: src/lifetimes.md:83
msgid ""
"// Must use 'b here because the reference to x is\n"
"            // being passed to the scope 'b.\n"
msgstr ""

#: src/lifetimes.md:92
msgid "Example: references that outlive referents"
msgstr ""

#: src/lifetimes.md:94
msgid "Alright, let's look at some of those examples from before:"
msgstr ""

#: src/lifetimes.md:103
msgid "desugars to:"
msgstr ""

#: src/lifetimes.md:115
msgid ""
"This signature of `as_str` takes a reference to a u32 with _some_ lifetime, "
"and promises that it can produce a reference to a str that can live _just as "
"long_. Already we can see why this signature might be trouble. That "
"basically implies that we're going to find a str somewhere in the scope the "
"reference to the u32 originated in, or somewhere _even earlier_. That's a "
"bit of a tall order."
msgstr ""

#: src/lifetimes.md:122
msgid ""
"We then proceed to compute the string `s`, and return a reference to it. "
"Since the contract of our function says the reference must outlive `'a`, "
"that's the lifetime we infer for the reference. Unfortunately, `s` was "
"defined in the scope `'b`, so the only way this is sound is if `'b` contains "
"`'a` -- which is clearly false since `'a` must contain the function call "
"itself. We have therefore created a reference whose lifetime outlives its "
"referent, which is _literally_ the first thing we said that references can't "
"do. The compiler rightfully blows up in our face."
msgstr ""

#: src/lifetimes.md:131
msgid "To make this more clear, we can expand the example:"
msgstr ""

#: src/lifetimes.md:146
msgid ""
"// An anonymous scope is introduced because the borrow does not\n"
"            // need to last for the whole scope x is valid for. The return\n"
"            // of as_str must find a str somewhere before this function\n"
"            // call. Obviously not happening.\n"
msgstr ""

#: src/lifetimes.md:156
msgid "Shoot!"
msgstr ""

#: src/lifetimes.md:158
msgid "Of course, the right way to write this function is as follows:"
msgstr ""

#: src/lifetimes.md:166
msgid ""
"We must produce an owned value inside the function to return it! The only "
"way we could have returned an `&'a str` would have been if it was in a field "
"of the `&'a u32`, which is obviously not the case."
msgstr ""

#: src/lifetimes.md:170
msgid ""
"(Actually we could have also just returned a string literal, which as a "
"global can be considered to reside at the bottom of the stack; though this "
"limits our implementation _just a bit_.)"
msgstr ""

#: src/lifetimes.md:174
msgid "Example: aliasing a mutable reference"
msgstr ""

#: src/lifetimes.md:176
msgid "How about the other example:"
msgstr ""

#: src/lifetimes.md:190
msgid ""
"// 'b is as big as we need this borrow to be\n"
"        // (just need to get to `println!`)\n"
msgstr ""

#: src/lifetimes.md:194
msgid ""
"// Temporary scope because we don't need the\n"
"            // &mut to last any longer.\n"
msgstr ""

#: src/lifetimes.md:203
msgid ""
"The problem here is a bit more subtle and interesting. We want Rust to "
"reject this program for the following reason: We have a live shared "
"reference `x` to a descendant of `data` when we try to take a mutable "
"reference to `data` to `push`. This would create an aliased mutable "
"reference, which would violate the _second_ rule of references."
msgstr ""

#: src/lifetimes.md:209
msgid ""
"However this is _not at all_ how Rust reasons that this program is bad. Rust "
"doesn't understand that `x` is a reference to a subpath of `data`. It "
"doesn't understand `Vec` at all. What it _does_ see is that `x` has to live "
"for `'b` in order to be printed. The signature of `Index::index` "
"subsequently demands that the reference we take to `data` has to survive for "
"`'b`. When we try to call `push`, it then sees us try to make an `&'c mut "
"data`. Rust knows that `'c` is contained within `'b`, and rejects our "
"program because the `&'b data` must still be alive!"
msgstr ""

#: src/lifetimes.md:218
msgid ""
"Here we see that the lifetime system is much more coarse than the reference "
"semantics we're actually interested in preserving. For the most part, "
"_that's totally ok_, because it keeps us from spending all day explaining "
"our program to the compiler. However it does mean that several programs that "
"are totally correct with respect to Rust's _true_ semantics are rejected "
"because lifetimes are too dumb."
msgstr ""

#: src/lifetimes.md:225
msgid "The area covered by a lifetime"
msgstr ""

#: src/lifetimes.md:227
msgid ""
"A reference (sometimes called a _borrow_) is _alive_ from the place it is "
"created to its last use. The borrowed value needs to outlive only borrows "
"that are alive. This looks simple, but there are a few subtleties."
msgstr ""

#: src/lifetimes.md:231
msgid ""
"The following snippet compiles, because after printing `x`, it is no longer "
"needed, so it doesn't matter if it is dangling or aliased (even though the "
"variable `x` _technically_ exists to the very end of the scope)."
msgstr ""

#: src/lifetimes.md:238
msgid "// This is OK, x is no longer needed\n"
msgstr ""

#: src/lifetimes.md:243
msgid ""
"However, if the value has a destructor, the destructor is run at the end of "
"the scope. And running the destructor is considered a use ‒ obviously the "
"last one. So, this will _not_ compile."
msgstr ""

#: src/lifetimes.md:257 src/lifetime-mismatch.md:18 src/lifetime-mismatch.md:60
#: src/ffi.md:555 src/ffi.md:792
msgid "\"{:?}\""
msgstr ""

#: src/lifetimes.md:258
msgid "// Here, the destructor is run and therefore this'll fail to compile.\n"
msgstr ""

#: src/lifetimes.md:262
msgid ""
"One way to convince the compiler that `x` is no longer valid is by using "
"`drop(x)` before `data.push(4)`."
msgstr ""

#: src/lifetimes.md:264
msgid ""
"Furthermore, there might be multiple possible last uses of the borrow, for "
"example in each branch of a condition."
msgstr ""

#: src/lifetimes.md:273
msgid "// This is the last use of `x` in this branch\n"
msgstr ""

#: src/lifetimes.md:274
msgid "// So we can push here\n"
msgstr ""

#: src/lifetimes.md:276
msgid ""
"// There's no use of `x` in here, so effectively the last use is the\n"
"    // creation of x at the top of the example.\n"
msgstr ""

#: src/lifetimes.md:282
msgid ""
"And a lifetime can have a pause in it. Or you might look at it as two "
"distinct borrows just being tied to the same local variable. This often "
"happens around loops (writing a new value of a variable at the end of the "
"loop and using it for the last time at the top of the next iteration)."
msgstr ""

#: src/lifetimes.md:288
msgid "// This mut allows us to change where the reference points to\n"
msgstr ""

#: src/lifetimes.md:292
msgid "// Last use of this borrow\n"
msgstr ""

#: src/lifetimes.md:294
msgid "// We start a new borrow here\n"
msgstr ""

#: src/lifetimes.md:298
msgid ""
"Historically, Rust kept the borrow alive until the end of scope, so these "
"examples might fail to compile with older compilers. Also, there are still "
"some corner cases where Rust fails to properly shorten the live part of the "
"borrow and fails to compile even when it looks like it should. These'll be "
"solved over time."
msgstr ""

#: src/lifetime-mismatch.md:3
msgid "Given the following code:"
msgstr ""

#: src/lifetime-mismatch.md:22
msgid ""
"One might expect it to compile. We call `mutate_and_share`, which mutably "
"borrows `foo` temporarily, but then returns only a shared reference. "
"Therefore we would expect `foo.share()` to succeed as `foo` shouldn't be "
"mutably borrowed."
msgstr ""

#: src/lifetime-mismatch.md:26
msgid "However when we try to compile it:"
msgstr ""

#: src/lifetime-mismatch.md:28
msgid ""
"```text\n"
"error[E0502]: cannot borrow `foo` as immutable because it is also borrowed "
"as mutable\n"
"  --> src/main.rs:12:5\n"
"   |\n"
"11 |     let loan = foo.mutate_and_share();\n"
"   |                --- mutable borrow occurs here\n"
"12 |     foo.share();\n"
"   |     ^^^ immutable borrow occurs here\n"
"13 |     println!(\"{:?}\", loan);\n"
"```"
msgstr ""

#: src/lifetime-mismatch.md:39
msgid ""
"What happened? Well, we got the exact same reasoning as we did for [Example "
"2 in the previous section](lifetimes.html#example-aliasing-a-mutable-"
"reference). We desugar the program and we get the following:"
msgstr ""

#: src/lifetime-mismatch.md:66
msgid ""
"The lifetime system is forced to extend the `&mut foo` to have lifetime "
"`'c`, due to the lifetime of `loan` and `mutate_and_share`'s signature. Then "
"when we try to call `share`, it sees we're trying to alias that `&'c mut "
"foo` and blows up in our face!"
msgstr ""

#: src/lifetime-mismatch.md:71
msgid ""
"This program is clearly correct according to the reference semantics we "
"actually care about, but the lifetime system is too coarse-grained to handle "
"that."
msgstr ""

#: src/lifetime-mismatch.md:74
msgid "Improperly reduced borrows"
msgstr ""

#: src/lifetime-mismatch.md:76
msgid ""
"The following code fails to compile, because Rust sees that a variable, "
"`map`, is borrowed twice, and can not infer that the first borrow ceases to "
"be needed before the second one occurs. This is caused by Rust "
"conservatively falling back to using a whole scope for the first borrow. "
"This will eventually get fixed."
msgstr ""

#: src/lifetime-mismatch.md:99
msgid ""
"Because of the lifetime restrictions imposed, `&mut map`'s lifetime overlaps "
"other mutable borrows, resulting in a compile error:"
msgstr ""

#: src/lifetime-elision.md:3
msgid ""
"In order to make common patterns more ergonomic, Rust allows lifetimes to be "
"_elided_ in function signatures."
msgstr ""

#: src/lifetime-elision.md:6
msgid "A _lifetime position_ is anywhere you can write a lifetime in a type:"
msgstr ""

#: src/lifetime-elision.md:15
msgid "Lifetime positions can appear as either \"input\" or \"output\":"
msgstr ""

#: src/lifetime-elision.md:17
msgid ""
"For `fn` definitions, `fn` types, and the traits `Fn`, `FnMut`, and "
"`FnOnce`, input refers to the types of the formal arguments, while output "
"refers to result types. So `fn foo(s: &str) -> (&str, &str)` has elided one "
"lifetime in input position and two lifetimes in output position. Note that "
"the input positions of a `fn` method definition do not include the lifetimes "
"that occur in the method's `impl` header (nor lifetimes that occur in the "
"trait header, for a default method)."
msgstr ""

#: src/lifetime-elision.md:25
msgid ""
"For `impl` headers, all types are input. So `impl Trait<&T> for Struct<&T>` "
"has elided two lifetimes in input position, while `impl Struct<&T>` has "
"elided one."
msgstr ""

#: src/lifetime-elision.md:29
msgid "Elision rules are as follows:"
msgstr ""

#: src/lifetime-elision.md:31
msgid ""
"Each elided lifetime in input position becomes a distinct lifetime parameter."
msgstr ""

#: src/lifetime-elision.md:34
msgid ""
"If there is exactly one input lifetime position (elided or not), that "
"lifetime is assigned to _all_ elided output lifetimes."
msgstr ""

#: src/lifetime-elision.md:37
msgid ""
"If there are multiple input lifetime positions, but one of them is `&self` "
"or `&mut self`, the lifetime of `self` is assigned to _all_ elided output "
"lifetimes."
msgstr ""

#: src/lifetime-elision.md:40
msgid "Otherwise, it is an error to elide an output lifetime."
msgstr ""

#: src/lifetime-elision.md:42
msgid "Examples:"
msgstr ""

#: src/lifetime-elision.md:46 src/lifetime-elision.md:49
#: src/lifetime-elision.md:52 src/lifetime-elision.md:59
#: src/lifetime-elision.md:62 src/lifetime-elision.md:65
msgid "// elided\n"
msgstr ""

#: src/lifetime-elision.md:47 src/lifetime-elision.md:50
#: src/lifetime-elision.md:53 src/lifetime-elision.md:60
#: src/lifetime-elision.md:63 src/lifetime-elision.md:67
msgid "// expanded\n"
msgstr ""

#: src/lifetime-elision.md:55 src/lifetime-elision.md:57
msgid "// ILLEGAL\n"
msgstr ""

#: src/lifetime-elision.md:66
msgid "// elided (with `rust_2018_idioms`)\n"
msgstr ""

#: src/unbounded-lifetimes.md:3
msgid ""
"Unsafe code can often end up producing references or lifetimes out of thin "
"air. Such lifetimes come into the world as _unbounded_. The most common "
"source of this is taking a reference to a dereferenced raw pointer, which "
"produces a reference with an unbounded lifetime. Such a lifetime becomes as "
"big as context demands. This is in fact more powerful than simply becoming "
"`'static`, because for instance `&'static &'a T` will fail to typecheck, but "
"the unbound lifetime will perfectly mold into `&'a &'a T` as needed. However "
"for most intents and purposes, such an unbounded lifetime can be regarded as "
"`'static`."
msgstr ""

#: src/unbounded-lifetimes.md:12
msgid ""
"Almost no reference is `'static`, so this is probably wrong. `transmute` and "
"`transmute_copy` are the two other primary offenders. One should endeavor to "
"bound an unbounded lifetime as quickly as possible, especially across "
"function boundaries."
msgstr ""

#: src/unbounded-lifetimes.md:17
msgid ""
"Given a function, any output lifetimes that don't derive from inputs are "
"unbounded. For instance:"
msgstr ""

#: src/unbounded-lifetimes.md:27 src/subtyping.md:19 src/subtyping.md:84
#: src/subtyping.md:104 src/subtyping.md:186 src/subtyping.md:252
#: src/subtyping.md:322
msgid "\"hello\""
msgstr ""

#: src/unbounded-lifetimes.md:30
msgid "\"Invalid str: {}\""
msgstr ""

#: src/unbounded-lifetimes.md:30
msgid "// Invalid str: gӚ_`\n"
msgstr ""

#: src/unbounded-lifetimes.md:34
msgid ""
"The easiest way to avoid unbounded lifetimes is to use lifetime elision at "
"the function boundary. If an output lifetime is elided, then it _must_ be "
"bounded by an input lifetime. Of course it might be bounded by the _wrong_ "
"lifetime, but this will usually just cause a compiler error, rather than "
"allow memory safety to be trivially violated."
msgstr ""

#: src/unbounded-lifetimes.md:40
msgid ""
"Within a function, bounding lifetimes is more error-prone. The safest and "
"easiest way to bound a lifetime is to return it from a function with a bound "
"lifetime. However if this is unacceptable, the reference can be placed in a "
"location with a specific lifetime. Unfortunately it's impossible to name all "
"lifetimes involved in a function."
msgstr ""

#: src/hrtb.md:1
msgid "Higher-Rank Trait Bounds (HRTBs)"
msgstr ""

#: src/hrtb.md:3
msgid ""
"Rust's `Fn` traits are a little bit magic. For instance, we can write the "
"following code:"
msgstr ""

#: src/hrtb.md:28
msgid ""
"If we try to naively desugar this code in the same way that we did in the "
"[lifetimes section](lifetimes.html), we run into some trouble:"
msgstr ""

#: src/hrtb.md:33
msgid "// NOTE: `&'b data.0` and `'x: {` is not valid syntax!\n"
msgstr ""

#: src/hrtb.md:40
msgid "// where F: Fn(&'??? (u8, u16)) -> &'??? u8,\n"
msgstr ""

#: src/hrtb.md:57
msgid ""
"How on earth are we supposed to express the lifetimes on `F`'s trait bound? "
"We need to provide some lifetime there, but the lifetime we care about can't "
"be named until we enter the body of `call`! Also, that isn't some fixed "
"lifetime; `call` works with _any_ lifetime `&self` happens to have at that "
"point."
msgstr ""

#: src/hrtb.md:62
msgid ""
"This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we "
"desugar this is as follows:"
msgstr ""

#: src/hrtb.md:70
msgid "Alternatively:"
msgstr ""

#: src/hrtb.md:77
msgid ""
"(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable _real_ `Fn` "
"trait)"
msgstr ""

#: src/hrtb.md:80
msgid ""
"`for<'a>` can be read as \"for all choices of `'a`\", and basically produces "
"an _infinite list_ of trait bounds that F must satisfy. Intense. There "
"aren't many places outside of the `Fn` traits where we encounter HRTBs, and "
"even for those we have a nice magic sugar for the common cases."
msgstr ""

#: src/hrtb.md:85
msgid "In summary, we can rewrite the original code more explicitly as:"
msgstr ""

#: src/subtyping.md:3
msgid ""
"Rust uses lifetimes to track the relationships between borrows and "
"ownership. However, a naive implementation of lifetimes would be either too "
"restrictive, or permit undefined behavior."
msgstr ""

#: src/subtyping.md:7
msgid ""
"In order to allow flexible usage of lifetimes while also preventing their "
"misuse, Rust uses **subtyping** and **variance**."
msgstr ""

#: src/subtyping.md:10
msgid "Let's start with an example."
msgstr ""

#: src/subtyping.md:13
msgid "// Note: debug expects two parameters with the *same* lifetime\n"
msgstr ""

#: src/subtyping.md:15 src/subtyping.md:80 src/subtyping.md:233
msgid "\"a = {a:?} b = {b:?}\""
msgstr ""

#: src/subtyping.md:21 src/subtyping.md:86 src/subtyping.md:106
#: src/subtyping.md:188
msgid "\"world\""
msgstr ""

#: src/subtyping.md:22 src/subtyping.md:87
msgid "// 'world has a shorter lifetime than 'static\n"
msgstr ""

#: src/subtyping.md:28
msgid ""
"In a conservative implementation of lifetimes, since `hello` and `world` "
"have different lifetimes, we might see the following error:"
msgstr ""

#: src/subtyping.md:41
msgid ""
"This would be rather unfortunate. In this case, what we want is to accept "
"any type that lives _at least as long_ as `'world`. Let's try using "
"subtyping with our lifetimes."
msgstr ""

#: src/subtyping.md:45
msgid "Subtyping"
msgstr ""

#: src/subtyping.md:47
msgid "Subtyping is the idea that one type can be used in place of another."
msgstr ""

#: src/subtyping.md:49
msgid ""
"Let's define that `Sub` is a subtype of `Super` (we'll be using the notation "
"`Sub <: Super` throughout this chapter)."
msgstr ""

#: src/subtyping.md:51
msgid ""
"What this is suggesting to us is that the set of _requirements_ that `Super` "
"defines are completely satisfied by `Sub`. `Sub` may then have more "
"requirements."
msgstr ""

#: src/subtyping.md:54
msgid ""
"Now, in order to use subtyping with lifetimes, we need to define the "
"requirement of a lifetime:"
msgstr ""

#: src/subtyping.md:56
msgid "`'a` defines a region of code."
msgstr ""

#: src/subtyping.md:58
msgid ""
"Now that we have a defined set of requirements for lifetimes, we can define "
"how they relate to each other:"
msgstr ""

#: src/subtyping.md:60
msgid ""
"`'long <: 'short` if and only if `'long` defines a region of code that "
"**completely contains** `'short`."
msgstr ""

#: src/subtyping.md:62
msgid ""
"`'long` may define a region larger than `'short`, but that still fits our "
"definition."
msgstr ""

#: src/subtyping.md:64
msgid ""
"As we will see throughout the rest of this chapter, subtyping is a lot more "
"complicated and subtle than this, but this simple rule is a very good 99% "
"intuition. And unless you write unsafe code, the compiler will automatically "
"handle all the corner cases for you."
msgstr ""

#: src/subtyping.md:69
msgid ""
"But this is the Rustonomicon. We're writing unsafe code, so we need to "
"understand how this stuff really works, and how we can mess it up."
msgstr ""

#: src/subtyping.md:72
msgid ""
"Going back to our example above, we can say that `'static <: 'world`. For "
"now, let's also accept the idea that subtypes of lifetimes can be passed "
"through references (more on this in [Variance](#variance)), _e.g._ `&'static "
"str` is a subtype of `&'world str`, then we can \"downgrade\" `&'static str` "
"into a `&'world str`. With that, the example above will compile:"
msgstr ""

#: src/subtyping.md:88
msgid "// hello silently downgrades from `&'static str` into `&'world str`\n"
msgstr ""

#: src/subtyping.md:93
msgid "Variance"
msgstr ""

#: src/subtyping.md:95
msgid ""
"Above, we glossed over the fact that `'static <: 'b` implied that `&'static "
"T <: &'b T`. This uses a property known as _variance_. It's not always as "
"simple as this example, though. To understand that, let's try to extend this "
"example a bit:"
msgstr ""

#: src/subtyping.md:109 src/subtyping.md:191
msgid "\"{hello}\""
msgstr ""

#: src/subtyping.md:109 src/subtyping.md:333
msgid "// use after free 😿\n"
msgstr ""

#: src/subtyping.md:113
msgid ""
"In `assign`, we are setting the `hello` reference to point to `world`. But "
"then `world` goes out of scope, before the later use of `hello` in the "
"println!"
msgstr ""

#: src/subtyping.md:116
msgid "This is a classic use-after-free bug!"
msgstr ""

#: src/subtyping.md:118
msgid ""
"Our first instinct might be to blame the `assign` impl, but there's really "
"nothing wrong here. It shouldn't be surprising that we might want to assign "
"a `T` into a `T`."
msgstr ""

#: src/subtyping.md:121
msgid ""
"The problem is that we cannot assume that `&mut &'static str` and `&mut &'b "
"str` are compatible. This means that `&mut &'static str` **cannot** be a "
"_subtype_ of `&mut &'b str`, even if `'static` is a subtype of `'b`."
msgstr ""

#: src/subtyping.md:125
msgid ""
"Variance is the concept that Rust borrows to define relationships about "
"subtypes through their generic parameters."
msgstr ""

#: src/subtyping.md:127
msgid ""
"NOTE: For convenience we will define a generic type `F<T>` so that we can "
"easily talk about `T`. Hopefully this is clear in context."
msgstr ""

#: src/subtyping.md:130
msgid ""
"The type `F`'s _variance_ is how the subtyping of its inputs affects the "
"subtyping of its outputs. There are three kinds of variance in Rust. Given "
"two types `Sub` and `Super`, where `Sub` is a subtype of `Super`:"
msgstr ""

#: src/subtyping.md:134
msgid ""
"`F` is **covariant** if `F<Sub>` is a subtype of `F<Super>` (the subtype "
"property is passed through)"
msgstr ""

#: src/subtyping.md:135
msgid ""
"`F` is **contravariant** if `F<Super>` is a subtype of `F<Sub>` (the subtype "
"property is \"inverted\")"
msgstr ""

#: src/subtyping.md:136
msgid "`F` is **invariant** otherwise (no subtyping relationship exists)"
msgstr ""

#: src/subtyping.md:138
msgid ""
"If we remember from the above examples, it was ok for us to treat `&'a T` as "
"a subtype of `&'b T` if `'a <: 'b`, therefore we can say that `&'a T` is "
"_covariant_ over `'a`."
msgstr ""

#: src/subtyping.md:142
msgid ""
"Also, we saw that it was not ok for us to treat `&mut &'a U` as a subtype of "
"`&mut &'b U`, therefore we can say that `&mut T` is _invariant_ over `T`"
msgstr ""

#: src/subtyping.md:145
msgid "Here is a table of some other generic types and their variances:"
msgstr ""

#: src/subtyping.md:147
msgid "'a"
msgstr ""

#: src/subtyping.md:147
msgid "T"
msgstr ""

#: src/subtyping.md:147
msgid "U"
msgstr ""

#: src/subtyping.md:149
msgid "`&'a T `"
msgstr ""

#: src/subtyping.md:149 src/subtyping.md:150 src/subtyping.md:151
#: src/subtyping.md:152 src/subtyping.md:155 src/subtyping.md:156
msgid "covariant"
msgstr ""

#: src/subtyping.md:150
msgid "`&'a mut T`"
msgstr ""

#: src/subtyping.md:150 src/subtyping.md:153 src/subtyping.md:154
#: src/subtyping.md:157
msgid "invariant"
msgstr ""

#: src/subtyping.md:151
msgid "`Box<T>`"
msgstr ""

#: src/subtyping.md:152
msgid "`Vec<T>`"
msgstr ""

#: src/subtyping.md:153
msgid "`UnsafeCell<T>`"
msgstr ""

#: src/subtyping.md:154
msgid "`Cell<T>`"
msgstr ""

#: src/subtyping.md:155
msgid "`fn(T) -> U`"
msgstr ""

#: src/subtyping.md:155 src/phantom-data.md:251
msgid "**contra**variant"
msgstr ""

#: src/subtyping.md:156
msgid "`*const T`"
msgstr ""

#: src/subtyping.md:157
msgid "`*mut T`"
msgstr ""

#: src/subtyping.md:159
msgid "Some of these can be explained simply in relation to the others:"
msgstr ""

#: src/subtyping.md:161
msgid ""
"`Vec<T>` and all other owning pointers and collections follow the same logic "
"as `Box<T>`"
msgstr ""

#: src/subtyping.md:162
msgid ""
"`Cell<T>` and all other interior mutability types follow the same logic as "
"`UnsafeCell<T>`"
msgstr ""

#: src/subtyping.md:163
msgid ""
"`UnsafeCell<T>` having interior mutability gives it the same variance "
"properties as `&mut T`"
msgstr ""

#: src/subtyping.md:164
msgid "`*const T` follows the logic of `&T`"
msgstr ""

#: src/subtyping.md:165
msgid "`*mut T` follows the logic of `&mut T` (or `UnsafeCell<T>`)"
msgstr ""

#: src/subtyping.md:167
msgid ""
"For more types, see the [\"Variance\" section](../reference/"
"subtyping.html#variance) on the reference."
msgstr ""

#: src/subtyping.md:171
msgid ""
"NOTE: the _only_ source of contravariance in the language is the arguments "
"to a function, which is why it really doesn't come up much in practice. "
"Invoking contravariance involves higher-order programming with function "
"pointers that take references with specific lifetimes (as opposed to the "
"usual \"any lifetime\", which gets into higher rank lifetimes, which work "
"independently of subtyping)."
msgstr ""

#: src/subtyping.md:177
msgid ""
"Now that we have some more formal understanding of variance, let's go "
"through some more examples in more detail."
msgstr ""

#: src/subtyping.md:195
msgid "And what do we get when we run this?"
msgstr ""

#: src/subtyping.md:197
msgid ""
"```text\n"
"error[E0597]: `world` does not live long enough\n"
"  --> src/main.rs:9:28\n"
"   |\n"
"6  |     let mut hello: &'static str = \"hello\";\n"
"   |                    ------------ type annotation requires that `world` "
"is borrowed for `'static`\n"
"...\n"
"9  |         assign(&mut hello, &world);\n"
"   |                            ^^^^^^ borrowed value does not live long "
"enough\n"
"10 |     }\n"
"   |     - `world` dropped here while still borrowed\n"
"```"
msgstr ""

#: src/subtyping.md:210
msgid ""
"Good, it doesn't compile! Let's break down what's happening here in detail."
msgstr ""

#: src/subtyping.md:212
msgid "First let's look at the `assign` function:"
msgstr ""

#: src/subtyping.md:220
msgid ""
"All it does is take a mutable reference and a value and overwrite the "
"referent with it. What's important about this function is that it creates a "
"type equality constraint. It clearly says in its signature the referent and "
"the value must be the _exact same_ type."
msgstr ""

#: src/subtyping.md:224
msgid ""
"Meanwhile, in the caller we pass in `&mut &'static str` and `&'world str`."
msgstr ""

#: src/subtyping.md:226
msgid ""
"Because `&mut T` is invariant over `T`, the compiler concludes it can't "
"apply any subtyping to the first argument, and so `T` must be exactly "
"`&'static str`."
msgstr ""

#: src/subtyping.md:229
msgid "This is counter to the `&T` case:"
msgstr ""

#: src/subtyping.md:237
msgid ""
"where similarly `a` and `b` must have the same type `T`. But since `&'a T` "
"_is_ covariant over `'a`, we are allowed to perform subtyping. So the "
"compiler decides that `&'static str` can become `&'b str` if and only if "
"`&'static str` is a subtype of `&'b str`, which will hold if `'static <: "
"'b`. This is true, so the compiler is happy to continue compiling this code."
msgstr ""

#: src/subtyping.md:243
msgid ""
"As it turns out, the argument for why it's ok for Box (and Vec, HashMap, "
"etc.) to be covariant is pretty similar to the argument for why it's ok for "
"lifetimes to be covariant: as soon as you try to stuff them in something "
"like a mutable reference, they inherit invariance and you're prevented from "
"doing anything bad."
msgstr ""

#: src/subtyping.md:245
msgid ""
"However Box makes it easier to focus on the by-value aspect of references "
"that we partially glossed over."
msgstr ""

#: src/subtyping.md:247
msgid ""
"Unlike a lot of languages which allow values to be freely aliased at all "
"times, Rust has a very strict rule: if you're allowed to mutate or move a "
"value, you are guaranteed to be the only one with access to it."
msgstr ""

#: src/subtyping.md:249
msgid "Consider the following code:"
msgstr ""

#: src/subtyping.md:258
msgid ""
"There is no problem at all with the fact that we have forgotten that `hello` "
"was alive for `'static`, because as soon as we moved `hello` to a variable "
"that only knew it was alive for `'b`, **we destroyed the only thing in the "
"universe that remembered it lived for longer**!"
msgstr ""

#: src/subtyping.md:262
msgid "Only one thing left to explain: function pointers."
msgstr ""

#: src/subtyping.md:264
msgid ""
"To see why `fn(T) -> U` should be covariant over `U`, consider the following "
"signature:"
msgstr ""

#: src/subtyping.md:271
msgid ""
"This function claims to produce a `str` bound by some lifetime `'a`. As "
"such, it is perfectly valid to provide a function with the following "
"signature instead:"
msgstr ""

#: src/subtyping.md:279
msgid ""
"So when the function is called, all it's expecting is a `&str` which lives "
"at least the lifetime of `'a`, it doesn't matter if the value actually lives "
"longer."
msgstr ""

#: src/subtyping.md:282
msgid ""
"However, the same logic does not apply to _arguments_. Consider trying to "
"satisfy:"
msgstr ""

#: src/subtyping.md:289
msgid "with:"
msgstr ""

#: src/subtyping.md:296
msgid ""
"The first function can accept any string reference as long as it lives at "
"least for `'a`, but the second cannot accept a string reference that lives "
"for any duration less than `'static`, which would cause a conflict. "
"Covariance doesn't work here. But if we flip it around, it actually _does_ "
"work! If we need a function that can handle `&'static str`, a function that "
"can handle _any_ reference lifetime will surely work fine."
msgstr ""

#: src/subtyping.md:303
msgid "Let's see this in practice"
msgstr ""

#: src/subtyping.md:310
msgid "/// saves the input given into a thread local `Vec<&'static str>`\n"
msgstr ""

#: src/subtyping.md:315
msgid "/// Calls the function with it's input (must have the same lifetime!)\n"
msgstr ""

#: src/subtyping.md:322
msgid "// \"hello\" is 'static. Can call `store` fine\n"
msgstr ""

#: src/subtyping.md:325
msgid "\"smuggle\""
msgstr ""

#: src/subtyping.md:327
msgid ""
"// `&smuggle` is not static. If we were to call `store` with `&smuggle`,\n"
"        // we would have pushed an invalid lifetime into the `StaticVecs`.\n"
"        // Therefore, `fn(&'static str)` cannot be a subtype of `fn(&'a "
"str)`\n"
msgstr ""

#: src/subtyping.md:334
msgid "\"{v:?}\""
msgstr ""

#: src/subtyping.md:338
msgid ""
"And that's why function types, unlike anything else in the language, are "
"**contra**variant over their arguments."
msgstr ""

#: src/subtyping.md:341
msgid ""
"Now, this is all well and good for the types the standard library provides, "
"but how is variance determined for types that _you_ define? A struct, "
"informally speaking, inherits the variance of its fields. If a struct "
"`MyType` has a generic argument `A` that is used in a field `a`, then "
"MyType's variance over `A` is exactly `a`'s variance over `A`."
msgstr ""

#: src/subtyping.md:347
msgid "However if `A` is used in multiple fields:"
msgstr ""

#: src/subtyping.md:349
msgid "If all uses of `A` are covariant, then MyType is covariant over `A`"
msgstr ""

#: src/subtyping.md:350
msgid ""
"If all uses of `A` are contravariant, then MyType is contravariant over `A`"
msgstr ""

#: src/subtyping.md:351
msgid "Otherwise, MyType is invariant over `A`"
msgstr ""

#: src/subtyping.md:357
msgid "// covariant over 'a and A\n"
msgstr ""

#: src/subtyping.md:358
msgid "// covariant over 'b and invariant over B\n"
msgstr ""

#: src/subtyping.md:360
msgid "// covariant over C\n"
msgstr ""

#: src/subtyping.md:361
msgid "// invariant over D\n"
msgstr ""

#: src/subtyping.md:363
msgid "// covariant over E\n"
msgstr ""

#: src/subtyping.md:364
msgid "// covariant over F\n"
msgstr ""

#: src/subtyping.md:365
msgid "// invariant over G\n"
msgstr ""

#: src/subtyping.md:367
msgid "// would also be covariant over H except...\n"
msgstr ""

#: src/subtyping.md:368
msgid "// invariant over H, because invariance wins all conflicts\n"
msgstr ""

#: src/subtyping.md:370
msgid "// contravariant over In, covariant over Out\n"
msgstr ""

#: src/subtyping.md:372
msgid "// would be contravariant over Mixed except..\n"
msgstr ""

#: src/subtyping.md:373
msgid "// invariant over Mixed, because invariance wins all conflicts\n"
msgstr ""

#: src/dropck.md:3
msgid ""
"We have seen how lifetimes provide us some fairly simple rules for ensuring "
"that we never read dangling references. However up to this point we have "
"only ever interacted with the _outlives_ relationship in an inclusive "
"manner. That is, when we talked about `'a: 'b`, it was ok for `'a` to live "
"_exactly_ as long as `'b`. At first glance, this seems to be a meaningless "
"distinction. Nothing ever gets dropped at the same time as another, right? "
"This is why we used the following desugaring of `let` statements:"
msgstr ""

#: src/dropck.md:17
msgid "desugaring to:"
msgstr ""

#: src/dropck.md:29
msgid ""
"There are some more complex situations which are not possible to desugar "
"using scopes, but the order is still defined ‒ variables are dropped in the "
"reverse order of their definition, fields of structs and tuples in order of "
"their definition. There are some more details about order of drop in [RFC "
"1857](https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-"
"order.md)."
msgstr ""

#: src/dropck.md:34
msgid "Let's do this:"
msgstr ""

#: src/dropck.md:41
msgid ""
"The left vector is dropped first. But does it mean the right one strictly "
"outlives it in the eyes of the borrow checker? The answer to this question "
"is _no_. The borrow checker could track fields of tuples separately, but it "
"would still be unable to decide what outlives what in case of vector "
"elements, which are dropped manually via pure-library code the borrow "
"checker doesn't understand."
msgstr ""

#: src/dropck.md:48
msgid ""
"So why do we care? We care because if the type system isn't careful, it "
"could accidentally make dangling pointers. Consider the following simple "
"program:"
msgstr ""

#: src/dropck.md:68
msgid ""
"This program is totally sound and compiles today. The fact that `days` does "
"not strictly outlive `inspector` doesn't matter. As long as the `inspector` "
"is alive, so is `days`."
msgstr ""

#: src/dropck.md:72
msgid "However if we add a destructor, the program will no longer compile!"
msgstr ""

#: src/dropck.md:79
msgid "\"I was only {} days from retirement!\""
msgstr ""

#: src/dropck.md:94
msgid ""
"// Let's say `days` happens to get dropped first.\n"
"    // Then when Inspector is dropped, it will try to read free'd memory!\n"
msgstr ""

#: src/dropck.md:113
msgid ""
"You can try changing the order of fields or use a tuple instead of the "
"struct, it'll still not compile."
msgstr ""

#: src/dropck.md:116
msgid ""
"Implementing `Drop` lets the `Inspector` execute some arbitrary code during "
"its death. This means it can potentially observe that types that are "
"supposed to live as long as it does actually were destroyed first."
msgstr ""

#: src/dropck.md:120
msgid ""
"Interestingly, only generic types need to worry about this. If they aren't "
"generic, then the only lifetimes they can harbor are `'static`, which will "
"truly live _forever_. This is why this problem is referred to as _sound "
"generic drop_. Sound generic drop is enforced by the _drop checker_. As of "
"this writing, some of the finer details of how the drop checker (also called "
"dropck) validates types is totally up in the air. However The Big Rule is "
"the subtlety that we have focused on this whole section:"
msgstr ""

#: src/dropck.md:128
msgid ""
"**For a generic type to soundly implement drop, its generics arguments must "
"strictly outlive it.**"
msgstr ""

#: src/dropck.md:131
msgid ""
"Obeying this rule is (usually) necessary to satisfy the borrow checker; "
"obeying it is sufficient but not necessary to be sound. That is, if your "
"type obeys this rule then it's definitely sound to drop."
msgstr ""

#: src/dropck.md:136
msgid ""
"The reason that it is not always necessary to satisfy the above rule is that "
"some Drop implementations will not access borrowed data even though their "
"type gives them the capability for such access, or because we know the "
"specific drop order and the borrowed data is still fine even if the borrow "
"checker doesn't know that."
msgstr ""

#: src/dropck.md:142
msgid ""
"For example, this variant of the above `Inspector` example will never access "
"borrowed data:"
msgstr ""

#: src/dropck.md:150 src/dropck.md:178 src/dropck.md:239
msgid "\"Inspector(_, {}) knows when *not* to inspect.\""
msgstr ""

#: src/dropck.md:164 src/dropck.md:192 src/dropck.md:253
msgid "\"gadget\""
msgstr ""

#: src/dropck.md:165 src/dropck.md:193
msgid ""
"// Let's say `days` happens to get dropped first.\n"
"    // Even when Inspector is dropped, its destructor will not access the\n"
"    // borrowed `days`.\n"
msgstr ""

#: src/dropck.md:171
msgid "Likewise, this variant will also never access borrowed data:"
msgstr ""

#: src/dropck.md:199
msgid ""
"However, _both_ of the above variants are rejected by the borrow checker "
"during the analysis of `fn main`, saying that `days` does not live long "
"enough."
msgstr ""

#: src/dropck.md:203
msgid ""
"The reason is that the borrow checking analysis of `main` does not know "
"about the internals of each `Inspector`'s `Drop` implementation. As far as "
"the borrow checker knows while it is analyzing `main`, the body of an "
"inspector's destructor might access that borrowed data."
msgstr ""

#: src/dropck.md:208
msgid ""
"Therefore, the drop checker forces all borrowed data in a value to strictly "
"outlive that value."
msgstr ""

#: src/dropck.md:211
msgid "An Escape Hatch"
msgstr ""

#: src/dropck.md:213
msgid ""
"The precise rules that govern drop checking may be less restrictive in the "
"future."
msgstr ""

#: src/dropck.md:216
msgid ""
"The current analysis is deliberately conservative and trivial; it forces all "
"borrowed data in a value to outlive that value, which is certainly sound."
msgstr ""

#: src/dropck.md:219
msgid ""
"Future versions of the language may make the analysis more precise, to "
"reduce the number of cases where sound code is rejected as unsafe. This "
"would help address cases such as the two `Inspector`s above that know not to "
"inspect during destruction."
msgstr ""

#: src/dropck.md:224
msgid ""
"In the meantime, there is an unstable attribute that one can use to assert "
"(unsafely) that a generic type's destructor is _guaranteed_ to not access "
"any expired data, even if its type gives it the capability to do so."
msgstr ""

#: src/dropck.md:229
msgid ""
"That attribute is called `may_dangle` and was introduced in [RFC 1327]"
"(https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-"
"eyepatch.md). To deploy it on the `Inspector` from above, we would write:"
msgstr ""

#: src/dropck.md:257
msgid ""
"Use of this attribute requires the `Drop` impl to be marked `unsafe` because "
"the compiler is not checking the implicit assertion that no potentially "
"expired data (e.g. `self.0` above) is accessed."
msgstr ""

#: src/dropck.md:261
msgid ""
"The attribute can be applied to any number of lifetime and type parameters. "
"In the following example, we assert that we access no data behind a "
"reference of lifetime `'b` and that the only uses of `T` will be moves or "
"drops, but omit the attribute from `'a` and `U`, because we do access data "
"with that lifetime and that type:"
msgstr ""

#: src/dropck.md:275
msgid "\"Inspector({}, _, _, {})\""
msgstr ""

#: src/dropck.md:280
msgid ""
"It is sometimes obvious that no such access can occur, like the case above. "
"However, when dealing with a generic type parameter, such access can occur "
"indirectly. Examples of such indirect access are:"
msgstr ""

#: src/dropck.md:284
msgid "invoking a callback,"
msgstr ""

#: src/dropck.md:285
msgid "via a trait method call."
msgstr ""

#: src/dropck.md:287
msgid ""
"(Future changes to the language, such as impl specialization, may add other "
"avenues for such indirect access.)"
msgstr ""

#: src/dropck.md:290
msgid "Here is an example of invoking a callback:"
msgstr ""

#: src/dropck.md:297
msgid "// The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n"
msgstr ""

#: src/dropck.md:298 src/dropck.md:315
msgid "\"Inspector({}, {}) unwittingly inspects expired data.\""
msgstr ""

#: src/dropck.md:304
msgid "Here is an example of a trait method call:"
msgstr ""

#: src/dropck.md:313
msgid ""
"// There is a hidden call to `<T as Display>::fmt` below, which\n"
"        // could access a borrow e.g. if `T` is `&'a _`\n"
msgstr ""

#: src/dropck.md:321
msgid ""
"And of course, all of these accesses could be further hidden within some "
"other method invoked by the destructor, rather than being written directly "
"within it."
msgstr ""

#: src/dropck.md:325
msgid ""
"In all of the above cases where the `&'a u8` is accessed in the destructor, "
"adding the `#[may_dangle]` attribute makes the type vulnerable to misuse "
"that the borrow checker will not catch, inviting havoc. It is better to "
"avoid adding the attribute."
msgstr ""

#: src/dropck.md:331
msgid "A related side note about drop order"
msgstr ""

#: src/dropck.md:333
msgid ""
"While the drop order of fields inside a struct is defined, relying on it is "
"fragile and subtle. When the order matters, it is better to use the "
"[`ManuallyDrop`](../std/mem/struct.ManuallyDrop.html) wrapper."
msgstr ""

#: src/dropck.md:337
msgid "Is that all about drop checker?"
msgstr ""

#: src/dropck.md:339
msgid ""
"It turns out that when writing unsafe code, we generally don't need to worry "
"at all about doing the right thing for the drop checker. However there is "
"one special case that you need to worry about, which we will look at in the "
"next section."
msgstr ""

#: src/phantom-data.md:3
msgid ""
"When working with unsafe code, we can often end up in a situation where "
"types or lifetimes are logically associated with a struct, but not actually "
"part of a field. This most commonly occurs with lifetimes. For instance, the "
"`Iter` for `&'a [T]` is (approximately) defined as follows:"
msgstr ""

#: src/phantom-data.md:15
msgid ""
"However because `'a` is unused within the struct's body, it's _unbounded_. "
"[Because of the troubles this has historically caused](https://rust-"
"lang.github.io/rfcs/0738-variance.html#the-corner-case-unused-parameters-and-"
"parameters-that-are-only-used-unsafely), unbounded lifetimes and types are "
"_forbidden_ in struct definitions. Therefore we must somehow refer to these "
"types in the body. Correctly doing this is necessary to have correct "
"variance and drop checking."
msgstr ""

#: src/phantom-data.md:23
msgid ""
"We do this using `PhantomData`, which is a special marker type. "
"`PhantomData` consumes no space, but simulates a field of the given type for "
"the purpose of static analysis. This was deemed to be less error-prone than "
"explicitly telling the type-system the kind of variance that you want, while "
"also providing other useful things such as auto traits and the information "
"needed by drop check."
msgstr ""

#: src/phantom-data.md:29
msgid ""
"Iter logically contains a bunch of `&'a T`s, so this is exactly what we tell "
"the `PhantomData` to simulate:"
msgstr ""

#: src/phantom-data.md:42
msgid ""
"and that's it. The lifetime will be bounded, and your iterator will be "
"covariant over `'a` and `T`. Everything Just Works."
msgstr ""

#: src/phantom-data.md:45
msgid "Generic parameters and drop-checking"
msgstr ""

#: src/phantom-data.md:47
msgid "In the past, there used to be another thing to take into consideration."
msgstr ""

#: src/phantom-data.md:49
msgid "This very documentation used to say:"
msgstr ""

#: src/phantom-data.md:51
msgid ""
"Another important example is Vec, which is (approximately) defined as "
"follows:"
msgstr ""

#: src/phantom-data.md:55 src/phantom-data.md:81
msgid "// *const for variance!\n"
msgstr ""

#: src/phantom-data.md:61
msgid ""
"Unlike the previous example, it _appears_ that everything is exactly as we "
"want. Every generic argument to Vec shows up in at least one field. Good to "
"go!"
msgstr ""

#: src/phantom-data.md:65 src/leaking.md:116
msgid "Nope."
msgstr ""

#: src/phantom-data.md:67
msgid ""
"The drop checker will generously determine that `Vec<T>` does not own any "
"values of type T. This will in turn make it conclude that it doesn't need to "
"worry about Vec dropping any T's in its destructor for determining drop "
"check soundness. This will in turn allow people to create unsoundness using "
"Vec's destructor."
msgstr ""

#: src/phantom-data.md:73
msgid ""
"In order to tell the drop checker that we _do_ own values of type T, and "
"therefore may drop some T's when _we_ drop, we must add an extra "
"`PhantomData` saying exactly that:"
msgstr ""

#: src/phantom-data.md:88
msgid ""
"But ever since [RFC 1238](https://rust-lang.github.io/rfcs/1238-"
"nonparametric-dropck.html), **this is no longer true nor necessary**."
msgstr ""

#: src/phantom-data.md:91
msgid "If you were to write:"
msgstr ""

#: src/phantom-data.md:95
msgid "// `*const` for variance!\n"
msgstr ""

#: src/phantom-data.md:101 src/phantom-data.md:208 src/phantom-data.md:211
msgid "/* … */"
msgstr ""

#: src/phantom-data.md:104
msgid ""
"then the existence of that `impl<T> Drop for Vec<T>` makes it so Rust will "
"consider that that `Vec<T>` _owns_ values of type `T` (more precisely: may "
"use values of type `T` in its `Drop` implementation), and Rust will thus not "
"allow them to _dangle_ should a `Vec<T>` be dropped."
msgstr ""

#: src/phantom-data.md:109
msgid ""
"When a type already has a `Drop impl`, **adding an extra `_owns_T: "
"PhantomData<T>` field is thus _superfluous_ and accomplishes nothing**, "
"dropck-wise (it still affects variance and auto-traits)."
msgstr ""

#: src/phantom-data.md:113
msgid ""
"(advanced edge case: if the type containing the `PhantomData` has no `Drop` "
"impl at all, but still has drop glue (by having _another_ field with drop "
"glue), then the dropck/`#[may_dangle]` considerations mentioned herein do "
"apply as well: a `PhantomData<T>` field will then require `T` to be "
"droppable whenever the containing type goes out of scope)."
msgstr ""

#: src/phantom-data.md:120
msgid ""
"But this situation can sometimes lead to overly restrictive code. That's why "
"the standard library uses an unstable and `unsafe` attribute to opt back "
"into the old \"unchecked\" drop-checking behavior, that this very "
"documentation warned about: the `#[may_dangle]` attribute."
msgstr ""

#: src/phantom-data.md:125
msgid ""
"An exception: the special case of the standard library and its unstable "
"`#[may_dangle]`"
msgstr ""

#: src/phantom-data.md:127
msgid ""
"This section can be skipped if you are only writing your own library code; "
"but if you are curious about what the standard library does with the actual "
"`Vec` definition, you'll notice that it still needs to use a `_owns_T: "
"PhantomData<T>` field for soundness."
msgstr ""

#: src/phantom-data.md:133
msgid "Consider the following example:"
msgstr ""

#: src/phantom-data.md:138
msgid "\"Short-lived\""
msgstr ""

#: src/phantom-data.md:141
msgid "// <- `v` is dropped here\n"
msgstr ""

#: src/phantom-data.md:144
msgid ""
"with a classical `impl<T> Drop for Vec<T> {` definition, the above [is "
"denied](https://rust.godbolt.org/z/ans15Kqz3)."
msgstr ""

#: src/phantom-data.md:148
msgid ""
"Indeed, in this case we have a `Vec</* T = */ &'s str>` vector of `'s`\\-"
"lived references to `str`ings, but in the case of `let s: String`, it is "
"dropped before the `Vec` is, and thus `'s` **is expired** by the time the "
"`Vec` is dropped, and the `impl<'s> Drop for Vec<&'s str> {` is used."
msgstr ""

#: src/phantom-data.md:153
msgid ""
"This means that if such `Drop` were to be used, it would be dealing with an "
"_expired_, or _dangling_ lifetime `'s`. But this is contrary to Rust "
"principles, where by default all Rust references involved in a function "
"signature are non-dangling and valid to dereference."
msgstr ""

#: src/phantom-data.md:157
msgid "Hence why Rust has to conservatively deny this snippet."
msgstr ""

#: src/phantom-data.md:159
msgid ""
"And yet, in the case of the real `Vec`, the `Drop` impl does not care about "
"`&'s str`, _since it has no drop glue of its own_: it only wants to "
"deallocate the backing buffer."
msgstr ""

#: src/phantom-data.md:162
msgid ""
"In other words, it would be nice if the above snippet was somehow accepted, "
"by special casing `Vec`, or by relying on some special property of `Vec`: "
"`Vec` could try to _promise not to use the `&'s str`s it holds when being "
"dropped_."
msgstr ""

#: src/phantom-data.md:166
msgid ""
"This is the kind of `unsafe` promise that can be expressed with "
"`#[may_dangle]`:"
msgstr ""

#: src/phantom-data.md:172
msgid "or, more generally:"
msgstr ""

#: src/phantom-data.md:178
msgid ""
"is the `unsafe` way to opt out of this conservative assumption that Rust's "
"drop checker makes about type parameters of a dropped instance not being "
"allowed to dangle."
msgstr ""

#: src/phantom-data.md:181
msgid ""
"And when this is done, such as in the standard library, we need to be "
"careful in the case where `T` has drop glue of its own. In this instance, "
"imagine replacing the `&'s str`s with a `struct PrintOnDrop<'s> /* = */ (&'s "
"str);` which would have a `Drop` impl wherein the inner `&'s str` would be "
"dereferenced and printed to the screen."
msgstr ""

#: src/phantom-data.md:186
msgid ""
"Indeed, `Drop for Vec<T> {`, before deallocating the backing buffer, does "
"have to transitively drop each `T` item when it has drop glue; in the case "
"of `PrintOnDrop<'s>`, it means that `Drop for Vec<PrintOnDrop<'s>>` has to "
"transitively drop the `PrintOnDrop<'s>`s elements before deallocating the "
"backing buffer."
msgstr ""

#: src/phantom-data.md:191
msgid ""
"So when we said that `'s` `#[may_dangle]`, it was an excessively loose "
"statement. We'd rather want to say: \"`'s` may dangle provided it not be "
"involved in some transitive drop glue\". Or, more generally, \"`T` may "
"dangle provided it not be involved in some transitive drop glue\". This "
"\"exception to the exception\" is a pervasive situation whenever **we own a "
"`T`**. That's why Rust's `#[may_dangle]` is smart enough to know of this opt-"
"out, and will thus be disabled _when the generic parameter is held in an "
"owned fashion_ by the fields of the struct."
msgstr ""

#: src/phantom-data.md:198
msgid "Hence why the standard library ends up with:"
msgstr ""

#: src/phantom-data.md:201
msgid "// we pinky-swear not to use `T` when dropping a `Vec`…\n"
msgstr ""

#: src/phantom-data.md:207
msgid "/* … except here, that is, … */"
msgstr ""

#: src/phantom-data.md:210 src/phantom-data.md:212
msgid "// …\n"
msgstr ""

#: src/phantom-data.md:218
msgid ""
"// … except for the fact that a `Vec` owns `T` items and\n"
"    // may thus be dropping `T` items on drop!\n"
msgstr ""

#: src/phantom-data.md:222
msgid ""
"// `*const` for variance (but this does not express ownership of a `T` *per "
"se*)\n"
msgstr ""

#: src/phantom-data.md:232
msgid ""
"Raw pointers that own an allocation is such a pervasive pattern that the "
"standard library made a utility for itself called `Unique<T>` which:"
msgstr ""

#: src/phantom-data.md:235
msgid "wraps a `*const T` for variance"
msgstr ""

#: src/phantom-data.md:236
msgid "includes a `PhantomData<T>`"
msgstr ""

#: src/phantom-data.md:237
msgid "auto-derives `Send`/`Sync` as if T was contained"
msgstr ""

#: src/phantom-data.md:238
msgid "marks the pointer as `NonZero` for the null-pointer optimization"
msgstr ""

#: src/phantom-data.md:240
msgid "Table of `PhantomData` patterns"
msgstr ""

#: src/phantom-data.md:242
msgid "Here’s a table of all the wonderful ways `PhantomData` could be used:"
msgstr ""

#: src/phantom-data.md:244
msgid "Phantom type"
msgstr ""

#: src/phantom-data.md:244
msgid "variance of `'a`"
msgstr ""

#: src/phantom-data.md:244
msgid "variance of `T`"
msgstr ""

#: src/phantom-data.md:244
msgid "`Send`/`Sync`<br/>(or lack thereof)"
msgstr ""

#: src/phantom-data.md:244
msgid "dangling `'a` or `T` in drop glue<br/>(_e.g._, `#[may_dangle] Drop`)"
msgstr ""

#: src/phantom-data.md:246
msgid "`PhantomData<T>`"
msgstr ""

#: src/phantom-data.md:246 src/phantom-data.md:249 src/phantom-data.md:250
#: src/phantom-data.md:251 src/phantom-data.md:252 src/phantom-data.md:253
#: src/phantom-data.md:254
msgid "\\-"
msgstr ""

#: src/phantom-data.md:246 src/phantom-data.md:247 src/phantom-data.md:248
#: src/phantom-data.md:249 src/phantom-data.md:252
msgid "**cov**ariant"
msgstr ""

#: src/phantom-data.md:246 src/phantom-data.md:248
msgid "inherited"
msgstr ""

#: src/phantom-data.md:246
msgid "disallowed (\"owns `T`\")"
msgstr ""

#: src/phantom-data.md:247
msgid "`PhantomData<&'a T>`"
msgstr ""

#: src/phantom-data.md:247
msgid "`Send + Sync`<br/>requires<br/>`T : Sync`"
msgstr ""

#: src/phantom-data.md:247 src/phantom-data.md:248 src/phantom-data.md:249
#: src/phantom-data.md:250 src/phantom-data.md:251 src/phantom-data.md:252
#: src/phantom-data.md:253 src/phantom-data.md:254
msgid "allowed"
msgstr ""

#: src/phantom-data.md:248
msgid "`PhantomData<&'a mut T>`"
msgstr ""

#: src/phantom-data.md:248 src/phantom-data.md:250 src/phantom-data.md:253
#: src/phantom-data.md:254
msgid "**inv**ariant"
msgstr ""

#: src/phantom-data.md:249
msgid "`PhantomData<*const T>`"
msgstr ""

#: src/phantom-data.md:249 src/phantom-data.md:250
msgid "`!Send + !Sync`"
msgstr ""

#: src/phantom-data.md:250
msgid "`PhantomData<*mut T>`"
msgstr ""

#: src/phantom-data.md:251
msgid "`PhantomData<fn(T)>`"
msgstr ""

#: src/phantom-data.md:251 src/phantom-data.md:252 src/phantom-data.md:253
msgid "`Send + Sync`"
msgstr ""

#: src/phantom-data.md:252
msgid "`PhantomData<fn() -> T>`"
msgstr ""

#: src/phantom-data.md:253
msgid "`PhantomData<fn(T) -> T>`"
msgstr ""

#: src/phantom-data.md:254
msgid "`PhantomData<Cell<&'a ()>>`"
msgstr ""

#: src/phantom-data.md:254
msgid "`Send + !Sync`"
msgstr ""

#: src/phantom-data.md:256
msgid ""
"Note: opting out of the `Unpin` auto-trait requires the dedicated "
"[`PhantomPinned`](../core/marker/struct.PhantomPinned.html) type instead."
msgstr ""

#: src/borrow-splitting.md:3
msgid ""
"The mutual exclusion property of mutable references can be very limiting "
"when working with a composite structure. The borrow checker (a.k.a. "
"borrowck) understands some basic stuff, but will fall over pretty easily. It "
"does understand structs sufficiently to know that it's possible to borrow "
"disjoint fields of a struct simultaneously. So this works today:"
msgstr ""

#: src/borrow-splitting.md:23
msgid "\"{} {} {} {}\""
msgstr ""

#: src/borrow-splitting.md:26
msgid ""
"However borrowck doesn't understand arrays or slices in any way, so this "
"doesn't work:"
msgstr ""

#: src/borrow-splitting.md:33
msgid "\"{} {}\""
msgstr ""

#: src/borrow-splitting.md:36
msgid ""
"```text\n"
"error[E0499]: cannot borrow `x[..]` as mutable more than once at a time\n"
" --> src/lib.rs:4:18\n"
"  |\n"
"3 |     let a = &mut x[0];\n"
"  |                  ---- first mutable borrow occurs here\n"
"4 |     let b = &mut x[1];\n"
"  |                  ^^^^ second mutable borrow occurs here\n"
"5 |     println!(\"{} {}\", a, b);\n"
"6 | }\n"
"  | - first borrow ends here\n"
"\n"
"error: aborting due to previous error\n"
"```"
msgstr ""

#: src/borrow-splitting.md:51
msgid ""
"While it was plausible that borrowck could understand this simple case, it's "
"pretty clearly hopeless for borrowck to understand disjointness in general "
"container types like a tree, especially if distinct keys actually _do_ map "
"to the same value."
msgstr ""

#: src/borrow-splitting.md:56
msgid ""
"In order to \"teach\" borrowck that what we're doing is ok, we need to drop "
"down to unsafe code. For instance, mutable slices expose a `split_at_mut` "
"function that consumes the slice and returns two mutable slices. One for "
"everything to the left of the index, and one for everything to the right. "
"Intuitively we know this is safe because the slices don't overlap, and "
"therefore alias. However the implementation requires some unsafety:"
msgstr ""

#: src/borrow-splitting.md:83
msgid ""
"This is actually a bit subtle. So as to avoid ever making two `&mut`'s to "
"the same value, we explicitly construct brand-new slices through raw "
"pointers."
msgstr ""

#: src/borrow-splitting.md:86
msgid ""
"However more subtle is how iterators that yield mutable references work. The "
"iterator trait is defined as follows:"
msgstr ""

#: src/borrow-splitting.md:97
msgid ""
"Given this definition, Self::Item has _no_ connection to `self`. This means "
"that we can call `next` several times in a row, and hold onto all the "
"results _concurrently_. This is perfectly fine for by-value iterators, which "
"have exactly these semantics. It's also actually fine for shared references, "
"as they admit arbitrarily many references to the same thing (although the "
"iterator needs to be a separate object from the thing being shared)."
msgstr ""

#: src/borrow-splitting.md:104
msgid ""
"But mutable references make this a mess. At first glance, they might seem "
"completely incompatible with this API, as it would produce multiple mutable "
"references to the same object!"
msgstr ""

#: src/borrow-splitting.md:108
msgid ""
"However it actually _does_ work, exactly because iterators are one-shot "
"objects. Everything an IterMut yields will be yielded at most once, so we "
"don't actually ever yield multiple mutable references to the same piece of "
"data."
msgstr ""

#: src/borrow-splitting.md:112
msgid ""
"Perhaps surprisingly, mutable iterators don't require unsafe code to be "
"implemented for many types!"
msgstr ""

#: src/borrow-splitting.md:115
msgid "For instance here's a singly linked list:"
msgstr ""

#: src/borrow-splitting.md:150
msgid "Here's a mutable slice:"
msgstr ""

#: src/borrow-splitting.md:184
msgid "And here's a binary tree:"
msgstr ""

#: src/borrow-splitting.md:292
msgid ""
"All of these are completely safe and work on stable Rust! This ultimately "
"falls out of the simple struct case we saw before: Rust understands that you "
"can safely split a mutable reference into subfields. We can then encode "
"permanently consuming a reference via Options (or in the case of slices, "
"replacing with an empty slice)."
msgstr ""

#: src/conversions.md:3
msgid ""
"At the end of the day, everything is just a pile of bits somewhere, and type "
"systems are just there to help us use those bits right. There are two common "
"problems with typing bits: needing to reinterpret those exact bits as a "
"different type, and needing to change the bits to have equivalent meaning "
"for a different type. Because Rust encourages encoding important properties "
"in the type system, these problems are incredibly pervasive. As such, Rust "
"consequently gives you several ways to solve them."
msgstr ""

#: src/conversions.md:11
msgid ""
"First we'll look at the ways that Safe Rust gives you to reinterpret values. "
"The most trivial way to do this is to just destructure a value into its "
"constituent parts and then build a new type out of them. e.g."
msgstr ""

#: src/conversions.md:32
msgid ""
"But this is, at best, annoying. For common conversions, Rust provides more "
"ergonomic alternatives."
msgstr ""

#: src/coercions.md:3
msgid ""
"Types can implicitly be coerced to change in certain contexts. These changes "
"are generally just _weakening_ of types, largely focused around pointers and "
"lifetimes. They mostly exist to make Rust \"just work\" in more cases, and "
"are largely harmless."
msgstr ""

#: src/coercions.md:7
msgid ""
"For an exhaustive list of all the types of coercions, see the [Coercion "
"types](../reference/type-coercions.html#coercion-types) section on the "
"reference."
msgstr ""

#: src/coercions.md:9
msgid ""
"Note that we do not perform coercions when matching traits (except for "
"receivers, see the [next page](./dot-operator.html)). If there is an `impl` "
"for some type `U` and `T` coerces to `U`, that does not constitute an "
"implementation for `T`. For example, the following will not type check, even "
"though it is OK to coerce `t` to `&T` and there is an `impl` for `&T`:"
msgstr ""

#: src/coercions.md:26
msgid "which fails like as follows:"
msgstr ""

#: src/dot-operator.md:3
msgid ""
"The dot operator will perform a lot of magic to convert types. It will "
"perform auto-referencing, auto-dereferencing, and coercion until types "
"match. The detailed mechanics of method lookup are defined [here](https://"
"rustc-dev-guide.rust-lang.org/method-lookup.html), but here is a brief "
"overview that outlines the main steps."
msgstr ""

#: src/dot-operator.md:9
msgid ""
"Suppose we have a function `foo` that has a receiver (a `self`, `&self` or "
"`&mut self` parameter). If we call `value.foo()`, the compiler needs to "
"determine what type `Self` is before it can call the correct implementation "
"of the function. For this example, we will say that `value` has type `T`."
msgstr ""

#: src/dot-operator.md:15
msgid ""
"We will use [fully-qualified syntax](../book/ch19-03-advanced-"
"traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-"
"the-same-name) to be more clear about exactly which type we are calling a "
"function on."
msgstr ""

#: src/dot-operator.md:18
msgid ""
"First, the compiler checks if it can call `T::foo(value)` directly. This is "
"called a \"by value\" method call."
msgstr ""

#: src/dot-operator.md:20
msgid ""
"If it can't call this function (for example, if the function has the wrong "
"type or a trait isn't implemented for `Self`), then the compiler tries to "
"add in an automatic reference. This means that the compiler tries "
"`<&T>::foo(value)` and `<&mut T>::foo(value)`. This is called an \"autoref\" "
"method call."
msgstr ""

#: src/dot-operator.md:25
msgid ""
"If none of these candidates worked, it dereferences `T` and tries again. "
"This uses the `Deref` trait - if `T: Deref<Target = U>` then it tries again "
"with type `U` instead of `T`. If it can't dereference `T`, it can also try "
"_unsizing_ `T`. This just means that if `T` has a size parameter known at "
"compile time, it \"forgets\" it for the purpose of resolving methods. For "
"instance, this unsizing step can convert `[i32; 2]` into `[i32]` by "
"\"forgetting\" the size of the array."
msgstr ""

#: src/dot-operator.md:34
msgid "Here is an example of the method lookup algorithm:"
msgstr ""

#: src/dot-operator.md:41
msgid ""
"How does the compiler actually compute `array[0]` when the array is behind "
"so many indirections? First, `array[0]` is really just syntax sugar for the "
"[`Index`](../std/ops/trait.Index.html) trait - the compiler will convert "
"`array[0]` into `array.index(0)`. Now, the compiler checks to see if `array` "
"implements `Index`, so that it can call the function."
msgstr ""

#: src/dot-operator.md:48
msgid ""
"Then, the compiler checks if `Rc<Box<[T; 3]>>` implements `Index`, but it "
"does not, and neither do `&Rc<Box<[T; 3]>>` or `&mut Rc<Box<[T; 3]>>`. Since "
"none of these worked, the compiler dereferences the `Rc<Box<[T; 3]>>` into "
"`Box<[T; 3]>` and tries again. `Box<[T; 3]>`, `&Box<[T; 3]>`, and `&mut "
"Box<[T; 3]>` do not implement `Index`, so it dereferences again. `[T; 3]` "
"and its autorefs also do not implement `Index`. It can't dereference `[T; "
"3]`, so the compiler unsizes it, giving `[T]`. Finally, `[T]` implements "
"`Index`, so it can now call the actual `index` function."
msgstr ""

#: src/dot-operator.md:58
msgid ""
"Consider the following more complicated example of the dot operator at work:"
msgstr ""

#: src/dot-operator.md:66
msgid ""
"What type is `cloned`? First, the compiler checks if it can call by value. "
"The type of `value` is `&T`, and so the `clone` function has signature `fn "
"clone(&T) -> T`. It knows that `T: Clone`, so the compiler finds that "
"`cloned: T`."
msgstr ""

#: src/dot-operator.md:72
msgid ""
"What would happen if the `T: Clone` restriction was removed? It would not be "
"able to call by value, since there is no implementation of `Clone` for `T`. "
"So the compiler tries to call by autoref. In this case, the function has the "
"signature `fn clone(&&T) -> &T` since `Self = &T`. The compiler sees that "
"`&T: Clone`, and then deduces that `cloned: &T`."
msgstr ""

#: src/dot-operator.md:79
msgid ""
"Here is another example where the autoref behavior is used to create some "
"subtle effects:"
msgstr ""

#: src/dot-operator.md:94
msgid ""
"What types are `foo_cloned` and `bar_cloned`? We know that `Container<i32>: "
"Clone`, so the compiler calls `clone` by value to give `foo_cloned: "
"Container<i32>`. However, `bar_cloned` actually has type `&Container<T>`. "
"Surely this doesn't make sense - we added `#[derive(Clone)]` to `Container`, "
"so it must implement `Clone`! Looking closer, the code generated by the "
"`derive` macro is (roughly):"
msgstr ""

#: src/dot-operator.md:110
msgid ""
"The derived `Clone` implementation is [only defined where `T: Clone`](../std/"
"clone/trait.Clone.html#derivable), so there is no implementation for "
"`Container<T>: Clone` for a generic `T`. The compiler then looks to see if "
"`&Container<T>` implements `Clone`, which it does. So it deduces that "
"`clone` is called by autoref, and so `bar_cloned` has type `&Container<T>`."
msgstr ""

#: src/dot-operator.md:116
msgid ""
"We can fix this by implementing `Clone` manually without requiring `T: "
"Clone`:"
msgstr ""

#: src/dot-operator.md:126
msgid "Now, the type checker deduces that `bar_cloned: Container<T>`."
msgstr ""

#: src/casts.md:3
msgid ""
"Casts are a superset of coercions: every coercion can be explicitly invoked "
"via a cast. However some conversions require a cast. While coercions are "
"pervasive and largely harmless, these \"true casts\" are rare and "
"potentially dangerous. As such, casts must be explicitly invoked using the "
"`as` keyword: `expr as Type`."
msgstr ""

#: src/casts.md:8
msgid ""
"You can find an exhaustive list of [all the true casts](../reference/"
"expressions/operator-expr.html#type-cast-expressions) and [casting semantics]"
"(../reference/expressions/operator-expr.html#semantics) on the reference."
msgstr ""

#: src/casts.md:10
msgid "Safety of casting"
msgstr ""

#: src/casts.md:12
msgid ""
"True casts generally revolve around raw pointers and the primitive numeric "
"types. Even though they're dangerous, these casts are infallible at runtime. "
"If a cast triggers some subtle corner case no indication will be given that "
"this occurred. The cast will simply succeed. That said, casts must be valid "
"at the type level, or else they will be prevented statically. For instance, "
"`7u8 as bool` will not compile."
msgstr ""

#: src/casts.md:19
msgid ""
"That said, casts aren't `unsafe` because they generally can't violate memory "
"safety _on their own_. For instance, converting an integer to a raw pointer "
"can very easily lead to terrible things. However the act of creating the "
"pointer itself is safe, because actually using a raw pointer is already "
"marked as `unsafe`."
msgstr ""

#: src/casts.md:23
msgid "Some notes about casting"
msgstr ""

#: src/casts.md:25
msgid "Lengths when casting raw slices"
msgstr ""

#: src/casts.md:27
msgid ""
"Note that lengths are not adjusted when casting raw slices; `*const [u16] as "
"*const [u8]` creates a slice that only includes half of the original memory."
msgstr ""

#: src/casts.md:29
msgid "Transitivity"
msgstr ""

#: src/casts.md:31
msgid ""
"Casting is not transitive, that is, even if `e as U1 as U2` is a valid "
"expression, `e as U2` is not necessarily so."
msgstr ""

#: src/transmutes.md:3
msgid ""
"Get out of our way type system! We're going to reinterpret these bits or die "
"trying! Even though this book is all about doing things that are unsafe, I "
"really can't emphasize enough that you should deeply think about finding "
"Another Way than the operations covered in this section. This is really, "
"truly, the most horribly unsafe thing you can do in Rust. The guardrails "
"here are dental floss."
msgstr ""

#: src/transmutes.md:9
msgid ""
"[`mem::transmute<T, U>`](../std/mem/fn.transmute.html) takes a value of type "
"`T` and reinterprets it to have type `U`. The only restriction is that the "
"`T` and `U` are verified to have the same size. The ways to cause Undefined "
"Behavior with this are mind boggling."
msgstr ""

#: src/transmutes.md:14
msgid ""
"First and foremost, creating an instance of _any_ type with an invalid state "
"is going to cause arbitrary chaos that can't really be predicted. Do not "
"transmute `3` to `bool`. Even if you never _do_ anything with the `bool`. "
"Just don't."
msgstr ""

#: src/transmutes.md:19
msgid ""
"Transmute has an overloaded return type. If you do not specify the return "
"type it may produce a surprising type to satisfy inference."
msgstr ""

#: src/transmutes.md:22
msgid ""
"Transmuting an `&` to `&mut` is Undefined Behavior. While certain usages may "
"_appear_ safe, note that the Rust optimizer is free to assume that a shared "
"reference won't change through its lifetime and thus such transmutation will "
"run afoul of those assumptions. So:"
msgstr ""

#: src/transmutes.md:26
msgid "Transmuting an `&` to `&mut` is _always_ Undefined Behavior."
msgstr ""

#: src/transmutes.md:27
msgid "No you can't do it."
msgstr ""

#: src/transmutes.md:28
msgid "No you're not special."
msgstr ""

#: src/transmutes.md:30
msgid ""
"Transmuting to a reference without an explicitly provided lifetime produces "
"an [unbounded lifetime](./unbounded-lifetimes.md)."
msgstr ""

#: src/transmutes.md:33
msgid ""
"When transmuting between different compound types, you have to make sure "
"they are laid out the same way! If layouts differ, the wrong fields are "
"going to get filled with the wrong data, which will make you unhappy and can "
"also be Undefined Behavior (see above)."
msgstr ""

#: src/transmutes.md:38
msgid ""
"So how do you know if the layouts are the same? For `repr(C)` types and "
"`repr(transparent)` types, layout is precisely defined. But for your run-of-"
"the-mill `repr(Rust)`, it is not. Even different instances of the same "
"generic type can have wildly different layout. `Vec<i32>` and `Vec<u32>` "
"_might_ have their fields in the same order, or they might not. The details "
"of what exactly is and is not guaranteed for data layout are still being "
"worked out over [at the UCG WG](https://rust-lang.github.io/unsafe-code-"
"guidelines/layout.html)."
msgstr ""

#: src/transmutes.md:46
msgid ""
"[`mem::transmute_copy<T, U>`](../std/mem/fn.transmute_copy.html) somehow "
"manages to be _even more_ wildly unsafe than this. It copies `size_of<U>` "
"bytes out of an `&T` and interprets them as a `U`.  The size check that "
"`mem::transmute` has is gone (as it may be valid to copy out a prefix), "
"though it is Undefined Behavior for `U` to be larger than `T`."
msgstr ""

#: src/transmutes.md:52
msgid ""
"Also of course you can get all of the functionality of these functions using "
"raw pointer casts or `union`s, but without any of the lints or other basic "
"sanity checks. Raw pointer casts and `union`s do not magically avoid the "
"above rules."
msgstr ""

#: src/uninitialized.md:1
msgid "Working With Uninitialized Memory"
msgstr ""

#: src/uninitialized.md:3
msgid ""
"All runtime-allocated memory in a Rust program begins its life as "
"_uninitialized_. In this state the value of the memory is an indeterminate "
"pile of bits that may or may not even reflect a valid state for the type "
"that is supposed to inhabit that location of memory. Attempting to interpret "
"this memory as a value of _any_ type will cause Undefined Behavior. Do Not "
"Do This."
msgstr ""

#: src/uninitialized.md:9
msgid ""
"Rust provides mechanisms to work with uninitialized memory in checked (safe) "
"and unchecked (unsafe) ways."
msgstr ""

#: src/checked-uninit.md:1
msgid "Checked Uninitialized Memory"
msgstr ""

#: src/checked-uninit.md:3
msgid ""
"Like C, all stack variables in Rust are uninitialized until a value is "
"explicitly assigned to them. Unlike C, Rust statically prevents you from "
"ever reading them until you do:"
msgstr ""

#: src/checked-uninit.md:14
msgid ""
"```text\n"
"  |\n"
"3 |     println!(\"{}\", x);\n"
"  |                    ^ use of possibly uninitialized `x`\n"
"```"
msgstr ""

#: src/checked-uninit.md:20
msgid ""
"This is based off of a basic branch analysis: every branch must assign a "
"value to `x` before it is first used. For short, we also say that \"`x` is "
"init\" or \"`x` is uninit\"."
msgstr ""

#: src/checked-uninit.md:24
msgid ""
"Interestingly, Rust doesn't require the variable to be mutable to perform a "
"delayed initialization if every branch assigns exactly once. However the "
"analysis does not take advantage of constant analysis or anything like that. "
"So this compiles:"
msgstr ""

#: src/checked-uninit.md:43
msgid "but this doesn't:"
msgstr ""

#: src/checked-uninit.md:55
msgid ""
"```text\n"
"  |\n"
"6 |     println!(\"{}\", x);\n"
"  |                    ^ use of possibly uninitialized `x`\n"
"```"
msgstr ""

#: src/checked-uninit.md:61
msgid "while this does:"
msgstr ""

#: src/checked-uninit.md:70
msgid ""
"// Don't care that there are branches where it's not initialized\n"
"    // since we don't use the value in those branches\n"
msgstr ""

#: src/checked-uninit.md:75
msgid ""
"Of course, while the analysis doesn't consider actual values, it does have a "
"relatively sophisticated understanding of dependencies and control flow. For "
"instance, this works:"
msgstr ""

#: src/checked-uninit.md:83
msgid ""
"// Rust doesn't understand that this branch will be taken unconditionally,\n"
"    // because it relies on actual values.\n"
msgstr ""

#: src/checked-uninit.md:86
msgid ""
"// But it does understand that it will only be taken once because\n"
"        // we unconditionally break out of it. Therefore `x` doesn't\n"
"        // need to be marked as mutable.\n"
msgstr ""

#: src/checked-uninit.md:92
msgid ""
"// It also knows that it's impossible to get here without reaching the "
"break.\n"
"// And therefore that `x` must be initialized here!\n"
msgstr ""

#: src/checked-uninit.md:98
msgid ""
"If a value is moved out of a variable, that variable becomes logically "
"uninitialized if the type of the value isn't Copy. That is:"
msgstr ""

#: src/checked-uninit.md:105
msgid "// x is still valid because i32 is Copy\n"
msgstr ""

#: src/checked-uninit.md:106 src/checked-uninit.md:116
msgid "// y is now logically uninitialized because Box isn't Copy\n"
msgstr ""

#: src/checked-uninit.md:110
msgid ""
"However reassigning `y` in this example _would_ require `y` to be marked as "
"mutable, as a Safe Rust program could observe that the value of `y` changed:"
msgstr ""

#: src/checked-uninit.md:117
msgid "// reinitialize y\n"
msgstr ""

#: src/checked-uninit.md:121
msgid "Otherwise it's like `y` is a brand new variable."
msgstr ""

#: src/drop-flags.md:3
msgid ""
"The examples in the previous section introduce an interesting problem for "
"Rust. We have seen that it's possible to conditionally initialize, "
"deinitialize, and reinitialize locations of memory totally safely. For Copy "
"types, this isn't particularly notable since they're just a random pile of "
"bits. However types with destructors are a different story: Rust needs to "
"know whether to call a destructor whenever a variable is assigned to, or a "
"variable goes out of scope. How can it do this with conditional "
"initialization?"
msgstr ""

#: src/drop-flags.md:11
msgid ""
"Note that this is not a problem that all assignments need worry about. In "
"particular, assigning through a dereference unconditionally drops, and "
"assigning in a `let` unconditionally doesn't drop:"
msgstr ""

#: src/drop-flags.md:16
msgid "// let makes a fresh variable, so never need to drop\n"
msgstr ""

#: src/drop-flags.md:18
msgid "// Deref assumes the referent is initialized, so always drops\n"
msgstr ""

#: src/drop-flags.md:21
msgid ""
"This is only a problem when overwriting a previously initialized variable or "
"one of its subfields."
msgstr ""

#: src/drop-flags.md:24
msgid ""
"It turns out that Rust actually tracks whether a type should be dropped or "
"not _at runtime_. As a variable becomes initialized and uninitialized, a "
"_drop flag_ for that variable is toggled. When a variable might need to be "
"dropped, this flag is evaluated to determine if it should be dropped."
msgstr ""

#: src/drop-flags.md:29
msgid ""
"Of course, it is often the case that a value's initialization state can be "
"statically known at every point in the program. If this is the case, then "
"the compiler can theoretically generate more efficient code! For instance, "
"straight- line code has such _static drop semantics_:"
msgstr ""

#: src/drop-flags.md:35 src/drop-flags.md:37 src/drop-flags.md:48
#: src/drop-flags.md:65
msgid "// x was uninit; just overwrite.\n"
msgstr ""

#: src/drop-flags.md:36
msgid "// y was uninit; just overwrite and make x uninit.\n"
msgstr ""

#: src/drop-flags.md:38
msgid ""
"// y was init; Drop y, overwrite it, and make x uninit!\n"
"                         // y goes out of scope; y was init; Drop y!\n"
"                         // x goes out of scope; x was uninit; do nothing.\n"
msgstr ""

#: src/drop-flags.md:43
msgid ""
"Similarly, branched code where all branches have the same behavior with "
"respect to initialization has static drop semantics:"
msgstr ""

#: src/drop-flags.md:50 src/drop-flags.md:53
msgid "// x gets moved out; make x uninit.\n"
msgstr ""

#: src/drop-flags.md:55
msgid ""
"// x was uninit; just overwrite.\n"
"                            // x goes out of scope; x was init; Drop x!\n"
msgstr ""

#: src/drop-flags.md:59
msgid ""
"However code like this _requires_ runtime information to correctly Drop:"
msgstr ""

#: src/drop-flags.md:68
msgid ""
"// x goes out of scope; x might be uninit;\n"
"                            // check the flag!\n"
msgstr ""

#: src/drop-flags.md:72
msgid "Of course, in this case it's trivial to retrieve static drop semantics:"
msgstr ""

#: src/drop-flags.md:82
msgid ""
"The drop flags are tracked on the stack. In old Rust versions, drop flags "
"were stashed in a hidden field of types that implement `Drop`."
msgstr ""

#: src/unchecked-uninit.md:1
msgid "Unchecked Uninitialized Memory"
msgstr ""

#: src/unchecked-uninit.md:3
msgid ""
"One interesting exception to this rule is working with arrays. Safe Rust "
"doesn't permit you to partially initialize an array. When you initialize an "
"array, you can either set every value to the same thing with `let x = [val; "
"N]`, or you can specify each member individually with `let x = [val1, val2, "
"val3]`. Unfortunately this is pretty rigid, especially if you need to "
"initialize your array in a more incremental or dynamic way."
msgstr ""

#: src/unchecked-uninit.md:10
msgid ""
"Unsafe Rust gives us a powerful tool to handle this problem: [`MaybeUninit`]"
"(../core/mem/union.MaybeUninit.html). This type can be used to handle memory "
"that has not been fully initialized yet."
msgstr ""

#: src/unchecked-uninit.md:14
msgid ""
"With `MaybeUninit`, we can initialize an array element by element as follows:"
msgstr ""

#: src/unchecked-uninit.md:18
msgid ""
"// Size of the array is hard-coded but easy to change (meaning, changing "
"just\n"
"// the constant is sufficient). This means we can't use [a, b, c] syntax to\n"
"// initialize the array, though, as we would have to keep that in sync\n"
"// with `SIZE`!\n"
msgstr ""

#: src/unchecked-uninit.md:26
msgid ""
"// Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n"
"    // safe because the type we are claiming to have initialized here is a\n"
"    // bunch of `MaybeUninit`s, which do not require initialization.\n"
msgstr ""

#: src/unchecked-uninit.md:33
msgid ""
"// Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n"
"    // assignment instead of `ptr::write` does not cause the old\n"
"    // uninitialized value to be dropped.\n"
"    // Exception safety is not a concern because Box can't panic\n"
msgstr ""

#: src/unchecked-uninit.md:41
msgid ""
"// Everything is initialized. Transmute the array to the\n"
"    // initialized type.\n"
msgstr ""

#: src/unchecked-uninit.md:49
msgid "This code proceeds in three steps:"
msgstr ""

#: src/unchecked-uninit.md:51
msgid ""
"Create an array of `MaybeUninit<T>`. With current stable Rust, we have to "
"use unsafe code for this: we take some uninitialized piece of memory "
"(`MaybeUninit::uninit()`) and claim we have fully initialized it "
"([`assume_init()`](../core/mem/union.MaybeUninit.html#method.assume_init)). "
"This seems ridiculous, because we didn't! The reason this is correct is that "
"the array consists itself entirely of `MaybeUninit`, which do not actually "
"require initialization. For most other types, doing "
"`MaybeUninit::uninit().assume_init()` produces an invalid instance of said "
"type, so you got yourself some Undefined Behavior."
msgstr ""

#: src/unchecked-uninit.md:60
msgid ""
"Initialize the array. The subtle aspect of this is that usually, when we use "
"`=` to assign to a value that the Rust type checker considers to already be "
"initialized (like `x[i]`), the old value stored on the left-hand side gets "
"dropped. This would be a disaster. However, in this case, the type of the "
"left-hand side is `MaybeUninit<Box<u32>>`, and dropping that does not do "
"anything! See below for some more discussion of this `drop` issue."
msgstr ""

#: src/unchecked-uninit.md:67
msgid ""
"Finally, we have to change the type of our array to remove the "
"`MaybeUninit`. With current stable Rust, this requires a `transmute`. This "
"transmute is legal because in memory, `MaybeUninit<T>` looks the same as `T`."
msgstr ""

#: src/unchecked-uninit.md:71
msgid ""
"However, note that in general, `Container<MaybeUninit<T>>>` does _not_ look "
"the same as `Container<T>`! Imagine if `Container` was `Option`, and `T` was "
"`bool`, then `Option<bool>` exploits that `bool` only has two valid values, "
"but `Option<MaybeUninit<bool>>` cannot do that because the `bool` does not "
"have to be initialized."
msgstr ""

#: src/unchecked-uninit.md:77
msgid ""
"So, it depends on `Container` whether transmuting away the `MaybeUninit` is "
"allowed. For arrays, it is (and eventually the standard library will "
"acknowledge that by providing appropriate methods)."
msgstr ""

#: src/unchecked-uninit.md:81
msgid ""
"It's worth spending a bit more time on the loop in the middle, and in "
"particular the assignment operator and its interaction with `drop`. If we "
"wrote something like:"
msgstr ""

#: src/unchecked-uninit.md:86
msgid "// WRONG!\n"
msgstr ""

#: src/unchecked-uninit.md:89
msgid ""
"we would actually overwrite a `Box<u32>`, leading to `drop` of uninitialized "
"data, which would cause much sadness and pain."
msgstr ""

#: src/unchecked-uninit.md:92
msgid ""
"The correct alternative, if for some reason we cannot use "
"`MaybeUninit::new`, is to use the [`ptr`](../core/ptr/index.html) module. In "
"particular, it provides three functions that allow us to assign bytes to a "
"location in memory without dropping the old value: [`write`](../core/ptr/"
"fn.write.html), [`copy`](../std/ptr/fn.copy.html), and "
"[`copy_nonoverlapping`](../std/ptr/fn.copy_nonoverlapping.html)."
msgstr ""

#: src/unchecked-uninit.md:97
msgid ""
"`ptr::write(ptr, val)` takes a `val` and moves it into the address pointed "
"to by `ptr`."
msgstr ""

#: src/unchecked-uninit.md:99
msgid ""
"`ptr::copy(src, dest, count)` copies the bits that `count` T items would "
"occupy from src to dest. (this is equivalent to C's memmove -- note that the "
"argument order is reversed!)"
msgstr ""

#: src/unchecked-uninit.md:102
msgid ""
"`ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a "
"little faster on the assumption that the two ranges of memory don't overlap. "
"(this is equivalent to C's memcpy -- note that the argument order is "
"reversed!)"
msgstr ""

#: src/unchecked-uninit.md:106
msgid ""
"It should go without saying that these functions, if misused, will cause "
"serious havoc or just straight up Undefined Behavior. The only requirement "
"of these functions _themselves_ is that the locations you want to read and "
"write are allocated and properly aligned. However, the ways writing "
"arbitrary bits to arbitrary locations of memory can break things are "
"basically uncountable!"
msgstr ""

#: src/unchecked-uninit.md:112
msgid ""
"It's worth noting that you don't need to worry about `ptr::write`\\-style "
"shenanigans with types which don't implement `Drop` or contain `Drop` types, "
"because Rust knows not to try to drop them. This is what we relied on in the "
"above example."
msgstr ""

#: src/unchecked-uninit.md:117
msgid ""
"However when working with uninitialized memory you need to be ever-vigilant "
"for Rust trying to drop values you make like this before they're fully "
"initialized. Every control path through that variable's scope must "
"initialize the value before it ends, if it has a destructor. _[This includes "
"code panicking](unwinding.html)_. `MaybeUninit` helps a bit here, because it "
"does not implicitly drop its content - but all this really means in case of "
"a panic is that instead of a double-free of the not yet initialized parts, "
"you end up with a memory leak of the already initialized parts."
msgstr ""

#: src/unchecked-uninit.md:127
msgid ""
"Note that, to use the `ptr` methods, you need to first obtain a _raw "
"pointer_ to the data you want to initialize. It is illegal to construct a "
"_reference_ to uninitialized data, which implies that you have to be careful "
"when obtaining said raw pointer:"
msgstr ""

#: src/unchecked-uninit.md:132
msgid ""
"For an array of `T`, you can use `base_ptr.add(idx)` where `base_ptr: *mut "
"T` to compute the address of array index `idx`. This relies on how arrays "
"are laid out in memory."
msgstr ""

#: src/unchecked-uninit.md:135
msgid ""
"For a struct, however, in general we do not know how it is laid out, and we "
"also cannot use `&mut base_ptr.field` as that would be creating a reference. "
"So, you must carefully use the [raw reference](../reference/types/"
"pointer.html#r-type.pointer.raw.constructor) syntax. This creates a raw "
"pointer to the field without creating an intermediate reference:"
msgstr ""

#: src/unchecked-uninit.md:147
msgid ""
"// `&uninit.as_mut().field` would create a reference to an uninitialized "
"`bool`,\n"
"// and thus be Undefined Behavior!\n"
msgstr ""

#: src/unchecked-uninit.md:156
msgid ""
"One last remark: when reading old Rust code, you might stumble upon the "
"deprecated `mem::uninitialized` function.  That function used to be the only "
"way to deal with uninitialized memory on the stack, but it turned out to be "
"impossible to properly integrate with the rest of the language.  Always use "
"`MaybeUninit` instead in new code, and port old code over when you get the "
"opportunity."
msgstr ""

#: src/unchecked-uninit.md:163
msgid ""
"And that's about it for working with uninitialized memory! Basically nothing "
"anywhere expects to be handed uninitialized memory, so if you're going to "
"pass it around at all, be sure to be _really_ careful."
msgstr ""

#: src/obrm.md:1
msgid "The Perils Of Ownership Based Resource Management (OBRM)"
msgstr ""

#: src/obrm.md:3
msgid ""
"OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll "
"interact with a lot in Rust. Especially if you use the standard library."
msgstr ""

#: src/obrm.md:6
msgid ""
"Roughly speaking the pattern is as follows: to acquire a resource, you "
"create an object that manages it. To release the resource, you simply "
"destroy the object, and it cleans up the resource for you. The most common "
"\"resource\" this pattern manages is simply _memory_. `Box`, `Rc`, and "
"basically everything in `std::collections` is a convenience to enable "
"correctly managing memory. This is particularly important in Rust because we "
"have no pervasive GC to rely on for memory management. Which is the point, "
"really: Rust is about control. However we are not limited to just memory. "
"Pretty much every other system resource like a thread, file, or socket is "
"exposed through this kind of API."
msgstr ""

#: src/constructors.md:3
msgid ""
"There is exactly one way to create an instance of a user-defined type: name "
"it, and initialize all its fields at once:"
msgstr ""

#: src/constructors.md:25
msgid ""
"That's it. Every other way you make an instance of a type is just calling a "
"totally vanilla function that does some stuff and eventually bottoms out to "
"The One True Constructor."
msgstr ""

#: src/constructors.md:29
msgid ""
"Unlike C++, Rust does not come with a slew of built-in kinds of constructor. "
"There are no Copy, Default, Assignment, Move, or whatever constructors. The "
"reasons for this are varied, but it largely boils down to Rust's philosophy "
"of _being explicit_."
msgstr ""

#: src/constructors.md:34
msgid ""
"Move constructors are meaningless in Rust because we don't enable types to "
"\"care\" about their location in memory. Every type must be ready for it to "
"be blindly memcopied to somewhere else in memory. This means pure on-the-"
"stack-but- still-movable intrusive linked lists are simply not happening in "
"Rust (safely)."
msgstr ""

#: src/constructors.md:39
msgid ""
"Assignment and copy constructors similarly don't exist because move "
"semantics are the only semantics in Rust. At most `x = y` just moves the "
"bits of y into the x variable. Rust does provide two facilities for "
"providing C++'s copy- oriented semantics: `Copy` and `Clone`. Clone is our "
"moral equivalent of a copy constructor, but it's never implicitly invoked. "
"You have to explicitly call `clone` on an element you want to be cloned. "
"Copy is a special case of Clone where the implementation is just \"copy the "
"bits\". Copy types _are_ implicitly cloned whenever they're moved, but "
"because of the definition of Copy this just means not treating the old copy "
"as uninitialized -- a no-op."
msgstr ""

#: src/constructors.md:49
msgid ""
"While Rust provides a `Default` trait for specifying the moral equivalent of "
"a default constructor, it's incredibly rare for this trait to be used. This "
"is because variables [aren't implicitly initialized](uninitialized.html). "
"Default is basically only useful for generic programming. In concrete "
"contexts, a type will provide a static `new` method for any kind of "
"\"default\" constructor. This has no relation to `new` in other languages "
"and has no special meaning. It's just a naming convention."
msgstr ""

#: src/constructors.md:57
msgid "TODO: talk about \"placement new\"?"
msgstr ""

#: src/destructors.md:3
msgid ""
"What the language _does_ provide is full-blown automatic destructors through "
"the `Drop` trait, which provides the following method:"
msgstr ""

#: src/destructors.md:11
msgid "This method gives the type time to somehow finish what it was doing."
msgstr ""

#: src/destructors.md:13
msgid ""
"**After `drop` is run, Rust will recursively try to drop all of the fields "
"of `self`.**"
msgstr ""

#: src/destructors.md:16
msgid ""
"This is a convenience feature so that you don't have to write \"destructor "
"boilerplate\" to drop children. If a struct has no special logic for being "
"dropped other than dropping its children, then it means `Drop` doesn't need "
"to be implemented at all!"
msgstr ""

#: src/destructors.md:21
msgid "**There is no stable way to prevent this behavior in Rust 1.0.**"
msgstr ""

#: src/destructors.md:23
msgid ""
"Note that taking `&mut self` means that even if you could suppress recursive "
"Drop, Rust will prevent you from e.g. moving fields out of self. For most "
"types, this is totally fine."
msgstr ""

#: src/destructors.md:27
msgid ""
"For instance, a custom implementation of `Box` might write `Drop` like this:"
msgstr ""

#: src/destructors.md:50
msgid ""
"and this works fine because when Rust goes to drop the `ptr` field it just "
"sees a [Unique](phantom-data.html) that has no actual `Drop` implementation. "
"Similarly nothing can use-after-free the `ptr` because when drop exits, it "
"becomes inaccessible."
msgstr ""

#: src/destructors.md:54
msgid "However this wouldn't work:"
msgstr ""

#: src/destructors.md:80
msgid ""
"// Hyper-optimized: deallocate the box's contents for it\n"
"            // without `drop`ing the contents\n"
msgstr ""

#: src/destructors.md:90
msgid ""
"After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will "
"happily proceed to tell the box to Drop itself and everything will blow up "
"with use-after-frees and double-frees."
msgstr ""

#: src/destructors.md:94
msgid ""
"Note that the recursive drop behavior applies to all structs and enums "
"regardless of whether they implement Drop. Therefore something like"
msgstr ""

#: src/destructors.md:105
msgid ""
"will have the destructors of its `data1` and `data2` fields called whenever "
"it \"would\" be dropped, even though it itself doesn't implement Drop. We "
"say that such a type _needs Drop_, even though it is not itself Drop."
msgstr ""

#: src/destructors.md:109
msgid "Similarly,"
msgstr ""

#: src/destructors.md:118
msgid ""
"will have its inner Box field dropped if and only if an instance stores the "
"Next variant."
msgstr ""

#: src/destructors.md:121
msgid ""
"In general this works really nicely because you don't need to worry about "
"adding/removing drops when you refactor your data layout. Still there's "
"certainly many valid use cases for needing to do trickier things with "
"destructors."
msgstr ""

#: src/destructors.md:126
msgid ""
"The classic safe solution to overriding recursive drop and allowing moving "
"out of Self during `drop` is to use an Option:"
msgstr ""

#: src/destructors.md:153
msgid ""
"// Hyper-optimized: deallocate the box's contents for it\n"
"            // without `drop`ing the contents. Need to set the `box`\n"
"            // field as `None` to prevent Rust from trying to Drop it.\n"
msgstr ""

#: src/destructors.md:166
msgid ""
"However this has fairly odd semantics: you are saying that a field that "
"_should_ always be Some _may_ be None, just because of what happens in the "
"destructor. Of course this conversely makes a lot of sense: you can call "
"arbitrary methods on self during the destructor, and this should prevent you "
"from ever doing so after deinitializing the field. Not that it will prevent "
"you from producing any other arbitrarily invalid state in there."
msgstr ""

#: src/destructors.md:173
msgid ""
"On balance this is an ok choice. Certainly what you should reach for by "
"default. However, in the future we expect there to be a first-class way to "
"announce that a field shouldn't be automatically dropped."
msgstr ""

#: src/leaking.md:3
msgid ""
"Ownership-based resource management is intended to simplify composition. You "
"acquire resources when you create the object, and you release the resources "
"when it gets destroyed. Since destruction is handled for you, it means you "
"can't forget to release the resources, and it happens as soon as possible! "
"Surely this is perfect and all of our problems are solved."
msgstr ""

#: src/leaking.md:9
msgid ""
"Everything is terrible and we have new and exotic problems to try to solve."
msgstr ""

#: src/leaking.md:11
msgid ""
"Many people like to believe that Rust eliminates resource leaks. In "
"practice, this is basically true. You would be surprised to see a Safe Rust "
"program leak resources in an uncontrolled way."
msgstr ""

#: src/leaking.md:15
msgid ""
"However from a theoretical perspective this is absolutely not the case, no "
"matter how you look at it. In the strictest sense, \"leaking\" is so "
"abstract as to be unpreventable. It's quite trivial to initialize a "
"collection at the start of a program, fill it with tons of objects with "
"destructors, and then enter an infinite event loop that never refers to it. "
"The collection will sit around uselessly, holding on to its precious "
"resources until the program terminates (at which point all those resources "
"would have been reclaimed by the OS anyway)."
msgstr ""

#: src/leaking.md:23
msgid ""
"We may consider a more restricted form of leak: failing to drop a value that "
"is unreachable. Rust also doesn't prevent this. In fact Rust _has a function "
"for doing this_: `mem::forget`. This function consumes the value it is "
"passed _and then doesn't run its destructor_."
msgstr ""

#: src/leaking.md:28
msgid ""
"In the past `mem::forget` was marked as unsafe as a sort of lint against "
"using it, since failing to call a destructor is generally not a well-behaved "
"thing to do (though useful for some special unsafe code). However this was "
"generally determined to be an untenable stance to take: there are many ways "
"to fail to call a destructor in safe code. The most famous example is "
"creating a cycle of reference-counted pointers using interior mutability."
msgstr ""

#: src/leaking.md:35
msgid ""
"It is reasonable for safe code to assume that destructor leaks do not "
"happen, as any program that leaks destructors is probably wrong. However "
"_unsafe_ code cannot rely on destructors to be run in order to be safe. For "
"most types this doesn't matter: if you leak the destructor then the type is "
"by definition inaccessible, so it doesn't matter, right? For instance, if "
"you leak a `Box<u8>` then you waste some memory but that's hardly going to "
"violate memory-safety."
msgstr ""

#: src/leaking.md:42
msgid ""
"However where we must be careful with destructor leaks are _proxy_ types. "
"These are types which manage access to a distinct object, but don't actually "
"own it. Proxy objects are quite rare. Proxy objects you'll need to care "
"about are even rarer. However we'll focus on three interesting examples in "
"the standard library:"
msgstr ""

#: src/leaking.md:48
msgid "`vec::Drain`"
msgstr ""

#: src/leaking.md:49
msgid "`Rc`"
msgstr ""

#: src/leaking.md:50
msgid "`thread::scoped::JoinGuard`"
msgstr ""

#: src/leaking.md:54
msgid ""
"`drain` is a collections API that moves data out of the container without "
"consuming the container. This enables us to reuse the allocation of a `Vec` "
"after claiming ownership over all of its contents. It produces an iterator "
"(Drain) that returns the contents of the Vec by-value."
msgstr ""

#: src/leaking.md:59
msgid ""
"Now, consider Drain in the middle of iteration: some values have been moved "
"out, and others haven't. This means that part of the Vec is now full of "
"logically uninitialized data! We could backshift all the elements in the Vec "
"every time we remove a value, but this would have pretty catastrophic "
"performance consequences."
msgstr ""

#: src/leaking.md:65
msgid ""
"Instead, we would like Drain to fix the Vec's backing storage when it is "
"dropped. It should run itself to completion, backshift any elements that "
"weren't removed (drain supports subranges), and then fix Vec's `len`. It's "
"even unwinding-safe! Easy!"
msgstr ""

#: src/leaking.md:70
msgid "Now consider the following:"
msgstr ""

#: src/leaking.md:77
msgid "// start draining, vec can no longer be accessed\n"
msgstr ""

#: src/leaking.md:80
msgid "// pull out two elements and immediately drop them\n"
msgstr ""

#: src/leaking.md:84
msgid "// get rid of drainer, but don't call its destructor\n"
msgstr ""

#: src/leaking.md:87
msgid ""
"// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\n"
msgstr ""

#: src/leaking.md:92
msgid ""
"This is pretty clearly Not Good. Unfortunately, we're kind of stuck between "
"a rock and a hard place: maintaining consistent state at every step has an "
"enormous cost (and would negate any benefits of the API). Failing to "
"maintain consistent state gives us Undefined Behavior in safe code (making "
"the API unsound)."
msgstr ""

#: src/leaking.md:98
msgid ""
"So what can we do? Well, we can pick a trivially consistent state: set the "
"Vec's len to be 0 when we start the iteration, and fix it up if necessary in "
"the destructor. That way, if everything executes like normal we get the "
"desired behavior with minimal overhead. But if someone has the _audacity_ to "
"mem::forget us in the middle of the iteration, all that does is _leak even "
"more_ (and possibly leave the Vec in an unexpected but otherwise consistent "
"state). Since we've accepted that mem::forget is safe, this is definitely "
"safe. We call leaks causing more leaks a _leak amplification_."
msgstr ""

#: src/leaking.md:107
msgid "Rc"
msgstr ""

#: src/leaking.md:109
msgid ""
"Rc is an interesting case because at first glance it doesn't appear to be a "
"proxy value at all. After all, it manages the data it points to, and "
"dropping all the Rcs for a value will drop that value. Leaking an Rc doesn't "
"seem like it would be particularly dangerous. It will leave the refcount "
"permanently incremented and prevent the data from being freed or dropped, "
"but that seems just like Box, right?"
msgstr ""

#: src/leaking.md:118
msgid "Let's consider a simplified implementation of Rc:"
msgstr ""

#: src/leaking.md:134
msgid "// Wouldn't it be nice if heap::allocate worked like this?\n"
msgstr ""

#: src/leaking.md:157
msgid "// drop the data and then free it\n"
msgstr ""

#: src/leaking.md:166
msgid ""
"This code contains an implicit and subtle assumption: `ref_count` can fit in "
"a `usize`, because there can't be more than `usize::MAX` Rcs in memory. "
"However this itself assumes that the `ref_count` accurately reflects the "
"number of Rcs in memory, which we know is false with `mem::forget`. Using "
"`mem::forget` we can overflow the `ref_count`, and then get it down to 0 "
"with outstanding Rcs. Then we can happily use-after-free the inner data. Bad "
"Bad Not Good."
msgstr ""

#: src/leaking.md:173
msgid ""
"This can be solved by just checking the `ref_count` and doing _something_. "
"The standard library's stance is to just abort, because your program has "
"become horribly degenerate. Also _oh my gosh_ it's such a ridiculous corner "
"case."
msgstr ""

#: src/leaking.md:177
msgid "thread::scoped::JoinGuard"
msgstr ""

#: src/leaking.md:179
msgid ""
"Note: This API has already been removed from std, for more information you "
"may refer [issue #24292](https://github.com/rust-lang/rust/issues/24292)."
msgstr ""

#: src/leaking.md:182
msgid ""
"This section remains here because we think this example is still important, "
"regardless of whether it is part of std or not."
msgstr ""

#: src/leaking.md:185
msgid ""
"The thread::scoped API intended to allow threads to be spawned that "
"reference data on their parent's stack without any synchronization over that "
"data by ensuring the parent joins the thread before any of the shared data "
"goes out of scope."
msgstr ""

#: src/leaking.md:196
msgid ""
"Here `f` is some closure for the other thread to execute. Saying that `F: "
"Send + 'a` is saying that it closes over data that lives for `'a`, and it "
"either owns that data or the data was Sync (implying `&data` is Send)."
msgstr ""

#: src/leaking.md:200
msgid ""
"Because JoinGuard has a lifetime, it keeps all the data it closes over "
"borrowed in the parent thread. This means the JoinGuard can't outlive the "
"data that the other thread is working on. When the JoinGuard _does_ get "
"dropped it blocks the parent thread, ensuring the child terminates before "
"any of the closed-over data goes out of scope in the parent."
msgstr ""

#: src/leaking.md:206
msgid "Usage looked like:"
msgstr ""

#: src/leaking.md:214
msgid ""
"// Move the mutable reference into the closure, and execute\n"
"        // it on a different thread. The closure has a lifetime bound\n"
"        // by the lifetime of the mutable reference `x` we store in it.\n"
"        // The guard that is returned is in turn assigned the lifetime\n"
"        // of the closure, so it also mutably borrows `data` as `x` did.\n"
"        // This means we cannot access `data` until the guard goes away.\n"
msgstr ""

#: src/leaking.md:223
msgid "// store the thread's guard for later\n"
msgstr ""

#: src/leaking.md:226
msgid ""
"// All guards are dropped here, forcing the threads to join\n"
"    // (this thread blocks here until the others terminate).\n"
"    // Once the threads join, the borrow expires and the data becomes\n"
"    // accessible again in this thread.\n"
msgstr ""

#: src/leaking.md:230
msgid "// data is definitely mutated here.\n"
msgstr ""

#: src/leaking.md:234
msgid ""
"In principle, this totally works! Rust's ownership system perfectly ensures "
"it! ...except it relies on a destructor being called to be safe."
msgstr ""

#: src/leaking.md:242
msgid "// This is at best a data race. At worst, it's also a use-after-free.\n"
msgstr ""

#: src/leaking.md:245
msgid ""
"// Because the guard is forgotten, expiring the loan without blocking this\n"
"    // thread.\n"
msgstr ""

#: src/leaking.md:248
msgid ""
"// So the Box is dropped here while the scoped thread may or may not be "
"trying\n"
"// to access it.\n"
msgstr ""

#: src/leaking.md:253
msgid ""
"Dang. Here the destructor running was pretty fundamental to the API, and it "
"had to be scrapped in favor of a completely different design."
msgstr ""

#: src/unwinding.md:3
msgid "Rust has a _tiered_ error-handling scheme:"
msgstr ""

#: src/unwinding.md:5
msgid "If something might reasonably be absent, Option is used."
msgstr ""

#: src/unwinding.md:6
msgid "If something goes wrong and can reasonably be handled, Result is used."
msgstr ""

#: src/unwinding.md:7
msgid ""
"If something goes wrong and cannot reasonably be handled, the thread panics."
msgstr ""

#: src/unwinding.md:8
msgid "If something catastrophic happens, the program aborts."
msgstr ""

#: src/unwinding.md:10
msgid ""
"Option and Result are overwhelmingly preferred in most situations, "
"especially since they can be promoted into a panic or abort at the API "
"user's discretion. Panics cause the thread to halt normal execution and "
"unwind its stack, calling destructors as if every function instantly "
"returned."
msgstr ""

#: src/unwinding.md:15
msgid ""
"As of 1.0, Rust is of two minds when it comes to panics. In the long-long-"
"ago, Rust was much more like Erlang. Like Erlang, Rust had lightweight "
"tasks, and tasks were intended to kill themselves with a panic when they "
"reached an untenable state. Unlike an exception in Java or C++, a panic "
"could not be caught at any time. Panics could only be caught by the owner of "
"the task, at which point they had to be handled or _that_ task would itself "
"panic."
msgstr ""

#: src/unwinding.md:22
msgid ""
"Unwinding was important to this story because if a task's destructors "
"weren't called, it would cause memory and other system resources to leak. "
"Since tasks were expected to die during normal execution, this would make "
"Rust very poor for long-running systems!"
msgstr ""

#: src/unwinding.md:27
msgid ""
"As the Rust we know today came to be, this style of programming grew out of "
"fashion in the push for less-and-less abstraction. Light-weight tasks were "
"killed in the name of heavy-weight OS threads. Still, on stable Rust as of "
"1.0 panics can only be caught by the parent thread. This means catching a "
"panic requires spinning up an entire OS thread! This unfortunately stands in "
"conflict to Rust's philosophy of zero-cost abstractions."
msgstr ""

#: src/unwinding.md:34
msgid ""
"There is an API called [`catch_unwind`](https://doc.rust-lang.org/std/panic/"
"fn.catch_unwind.html) that enables catching a panic without spawning a "
"thread. Still, we would encourage you to only do this sparingly. In "
"particular, Rust's current unwinding implementation is heavily optimized for "
"the \"doesn't unwind\" case. If a program doesn't unwind, there should be no "
"runtime cost for the program being _ready_ to unwind. As a consequence, "
"actually unwinding will be more expensive than in e.g. Java. Don't build "
"your programs to unwind under normal circumstances. Ideally, you should only "
"panic for programming errors or _extreme_ problems."
msgstr ""

#: src/unwinding.md:43
msgid ""
"Rust's unwinding strategy is not specified to be fundamentally compatible "
"with any other language's unwinding. As such, unwinding into Rust from "
"another language, or unwinding into another language from Rust is Undefined "
"Behavior. You must _absolutely_ catch any panics at the FFI boundary! What "
"you do at that point is up to you, but _something_ must be done. If you fail "
"to do this, at best, your application will crash and burn. At worst, your "
"application _won't_ crash and burn, and will proceed with completely "
"clobbered state."
msgstr ""

#: src/exception-safety.md:3
msgid ""
"Although programs should use unwinding sparingly, there's a lot of code that "
"_can_ panic. If you unwrap a None, index out of bounds, or divide by 0, your "
"program will panic. On debug builds, every arithmetic operation can panic if "
"it overflows. Unless you are very careful and tightly control what code "
"runs, pretty much everything can unwind, and you need to be ready for it."
msgstr ""

#: src/exception-safety.md:9
msgid ""
"Being ready for unwinding is often referred to as _exception safety_ in the "
"broader programming world. In Rust, there are two levels of exception safety "
"that one may concern themselves with:"
msgstr ""

#: src/exception-safety.md:13
msgid ""
"In unsafe code, we _must_ be exception safe to the point of not violating "
"memory safety. We'll call this _minimal_ exception safety."
msgstr ""

#: src/exception-safety.md:16
msgid ""
"In safe code, it is _good_ to be exception safe to the point of your program "
"doing the right thing. We'll call this _maximal_ exception safety."
msgstr ""

#: src/exception-safety.md:19
msgid ""
"As is the case in many places in Rust, Unsafe code must be ready to deal "
"with bad Safe code when it comes to unwinding. Code that transiently creates "
"unsound states must be careful that a panic does not cause that state to be "
"used. Generally this means ensuring that only non-panicking code is run "
"while these states exist, or making a guard that cleans up the state in the "
"case of a panic. This does not necessarily mean that the state a panic "
"witnesses is a fully coherent state. We need only guarantee that it's a "
"_safe_ state."
msgstr ""

#: src/exception-safety.md:27
msgid ""
"Most Unsafe code is leaf-like, and therefore fairly easy to make exception-"
"safe. It controls all the code that runs, and most of that code can't panic. "
"However it is not uncommon for Unsafe code to work with arrays of "
"temporarily uninitialized data while repeatedly invoking caller-provided "
"code. Such code needs to be careful and consider exception safety."
msgstr ""

#: src/exception-safety.md:33
msgid "Vec::push_all"
msgstr ""

#: src/exception-safety.md:35
msgid ""
"`Vec::push_all` is a temporary hack to get extending a Vec by a slice "
"reliably efficient without specialization. Here's a simple implementation:"
msgstr ""

#: src/exception-safety.md:44
msgid "// can't overflow because we just reserved this\n"
msgstr ""

#: src/exception-safety.md:55
msgid ""
"We bypass `push` in order to avoid redundant capacity and `len` checks on "
"the Vec that we definitely know has capacity. The logic is totally correct, "
"except there's a subtle problem with our code: it's not exception-safe! "
"`set_len`, `add`, and `write` are all fine; `clone` is the panic bomb we "
"over-looked."
msgstr ""

#: src/exception-safety.md:60
msgid ""
"Clone is completely out of our control, and is totally free to panic. If it "
"does, our function will exit early with the length of the Vec set too large. "
"If the Vec is looked at or dropped, uninitialized memory will be read!"
msgstr ""

#: src/exception-safety.md:64
msgid ""
"The fix in this case is fairly simple. If we want to guarantee that the "
"values we _did_ clone are dropped, we can set the `len` every loop "
"iteration. If we just want to guarantee that uninitialized memory can't be "
"observed, we can set the `len` after the loop."
msgstr ""

#: src/exception-safety.md:69
msgid "BinaryHeap::sift_up"
msgstr ""

#: src/exception-safety.md:71
msgid ""
"Bubbling an element up a heap is a bit more complicated than extending a "
"Vec. The pseudocode is as follows:"
msgstr ""

#: src/exception-safety.md:81
msgid ""
"A literal transcription of this code to Rust is totally fine, but has an "
"annoying performance characteristic: the `self` element is swapped over and "
"over again uselessly. We would rather have the following:"
msgstr ""

#: src/exception-safety.md:94
msgid ""
"This code ensures that each element is copied as little as possible (it is "
"in fact necessary that elem be copied twice in general). However it now "
"exposes some exception safety trouble! At all times, there exists two copies "
"of one value. If we panic in this function something will be double-dropped. "
"Unfortunately, we also don't have full control of the code: that comparison "
"is user-defined!"
msgstr ""

#: src/exception-safety.md:101
msgid ""
"Unlike Vec, the fix isn't as easy here. One option is to break the user-"
"defined code and the unsafe code into two separate phases:"
msgstr ""

#: src/exception-safety.md:117
msgid ""
"If the user-defined code blows up, that's no problem anymore, because we "
"haven't actually touched the state of the heap yet. Once we do start messing "
"with the heap, we're working with only data and functions that we trust, so "
"there's no concern of panics."
msgstr ""

#: src/exception-safety.md:122
msgid ""
"Perhaps you're not happy with this design. Surely it's cheating! And we have "
"to do the complex heap traversal _twice_! Alright, let's bite the bullet. "
"Let's intermix untrusted and unsafe code _for reals_."
msgstr ""

#: src/exception-safety.md:126
msgid ""
"If Rust had `try` and `finally` like in Java, we could do the following:"
msgstr ""

#: src/exception-safety.md:139
msgid ""
"The basic idea is simple: if the comparison panics, we just toss the loose "
"element in the logically uninitialized index and bail out. Anyone who "
"observes the heap will see a potentially _inconsistent_ heap, but at least "
"it won't cause any double-drops! If the algorithm terminates normally, then "
"this operation happens to coincide precisely with how we finish up "
"regardless."
msgstr ""

#: src/exception-safety.md:145
msgid ""
"Sadly, Rust has no such construct, so we're going to need to roll our own! "
"The way to do this is to store the algorithm's state in a separate struct "
"with a destructor for the \"finally\" logic. Whether we panic or not, that "
"destructor will run and clean up after us."
msgstr ""

#: src/exception-safety.md:154
msgid "/// `elt` is always `Some` from new until drop.\n"
msgstr ""

#: src/exception-safety.md:187
msgid "// fill the hole again\n"
msgstr ""

#: src/exception-safety.md:198
msgid "// Take out the value at `pos` and create a hole.\n"
msgstr ""

#: src/exception-safety.md:206
msgid "// Hole will be unconditionally filled here; panic or not!\n"
msgstr ""

#: src/poisoning.md:3
msgid ""
"Although all unsafe code _must_ ensure it has minimal exception safety, not "
"all types ensure _maximal_ exception safety. Even if the type does, your "
"code may ascribe additional meaning to it. For instance, an integer is "
"certainly exception-safe, but has no semantics on its own. It's possible "
"that code that panics could fail to correctly update the integer, producing "
"an inconsistent program state."
msgstr ""

#: src/poisoning.md:10
msgid ""
"This is _usually_ fine, because anything that witnesses an exception is "
"about to get destroyed. For instance, if you send a Vec to another thread "
"and that thread panics, it doesn't matter if the Vec is in a weird state. It "
"will be dropped and go away forever. However some types are especially good "
"at smuggling values across the panic boundary."
msgstr ""

#: src/poisoning.md:16
msgid ""
"These types may choose to explicitly _poison_ themselves if they witness a "
"panic. Poisoning doesn't entail anything in particular. Generally it just "
"means preventing normal usage from proceeding. The most notable example of "
"this is the standard library's Mutex type. A Mutex will poison itself if one "
"of its MutexGuards (the thing it returns when a lock is obtained) is dropped "
"during a panic. Any future attempts to lock the Mutex will return an `Err` "
"or panic."
msgstr ""

#: src/poisoning.md:23
msgid ""
"Mutex poisons not for true safety in the sense that Rust normally cares "
"about. It poisons as a safety-guard against blindly using the data that "
"comes out of a Mutex that has witnessed a panic while locked. The data in "
"such a Mutex was likely in the middle of being modified, and as such may be "
"in an inconsistent or incomplete state. It is important to note that one "
"cannot violate memory safety with such a type if it is correctly written. "
"After all, it must be minimally exception-safe!"
msgstr ""

#: src/poisoning.md:30
msgid ""
"However if the Mutex contained, say, a BinaryHeap that does not actually "
"have the heap property, it's unlikely that any code that uses it will do "
"what the author intended. As such, the program should not proceed normally. "
"Still, if you're double-plus-sure that you can do _something_ with the "
"value, the Mutex exposes a method to get the lock anyway. It _is_ safe, "
"after all. Just maybe nonsense."
msgstr ""

#: src/concurrency.md:1
msgid "Concurrency and Parallelism"
msgstr ""

#: src/concurrency.md:3
msgid ""
"Rust as a language doesn't _really_ have an opinion on how to do concurrency "
"or parallelism. The standard library exposes OS threads and blocking sys-"
"calls because everyone has those, and they're uniform enough that you can "
"provide an abstraction over them in a relatively uncontroversial way. "
"Message passing, green threads, and async APIs are all diverse enough that "
"any abstraction over them tends to involve trade-offs that we weren't "
"willing to commit to for 1.0."
msgstr ""

#: src/concurrency.md:10
msgid ""
"However the way Rust models concurrency makes it relatively easy to design "
"your own concurrency paradigm as a library and have everyone else's code "
"Just Work with yours. Just require the right lifetimes and Send and Sync "
"where appropriate and you're off to the races. Or rather, off to the... "
"not... having... races."
msgstr ""

#: src/races.md:1
msgid "Data Races and Race Conditions"
msgstr ""

#: src/races.md:3
msgid "Safe Rust guarantees an absence of data races, which are defined as:"
msgstr ""

#: src/races.md:5
msgid "two or more threads concurrently accessing a location of memory"
msgstr ""

#: src/races.md:6
msgid "one or more of them is a write"
msgstr ""

#: src/races.md:7
msgid "one or more of them is unsynchronized"
msgstr ""

#: src/races.md:9
msgid ""
"A data race has Undefined Behavior, and is therefore impossible to perform "
"in Safe Rust. Data races are prevented _mostly_ through Rust's ownership "
"system alone: it's impossible to alias a mutable reference, so it's "
"impossible to perform a data race. Interior mutability makes this more "
"complicated, which is largely why we have the Send and Sync traits (see the "
"next section for more on this)."
msgstr ""

#: src/races.md:15
msgid "**However Rust does not prevent general race conditions.**"
msgstr ""

#: src/races.md:17
msgid ""
"This is mathematically impossible in situations where you do not control the "
"scheduler, which is true for the normal OS environment. If you do control "
"preemption, it _can be_ possible to prevent general races - this technique "
"is used by frameworks such as [RTIC](https://github.com/rtic-rs/rtic). "
"However, actually having control over scheduling is a very uncommon case."
msgstr ""

#: src/races.md:23
msgid ""
"For this reason, it is considered \"safe\" for Rust to get deadlocked or do "
"something nonsensical with incorrect synchronization: this is known as a "
"general race condition or resource race. Obviously such a program isn't very "
"good, but Rust of course cannot prevent all logic errors."
msgstr ""

#: src/races.md:28
msgid ""
"In any case, a race condition cannot violate memory safety in a Rust program "
"on its own. Only in conjunction with some other unsafe code can a race "
"condition actually violate memory safety. For instance, a correct program "
"looks like this:"
msgstr ""

#: src/races.md:37
msgid ""
"// Arc so that the memory the AtomicUsize is stored in still exists for\n"
"// the other thread to increment, even if we completely finish executing\n"
"// before it. Rust won't compile the program without it, because of the\n"
"// lifetime requirements of thread::spawn!\n"
msgstr ""

#: src/races.md:44 src/races.md:75
msgid "// `move` captures other_idx by-value, moving it into this thread\n"
msgstr ""

#: src/races.md:47 src/races.md:78
msgid ""
"// It's ok to mutate idx because this value\n"
"    // is an atomic, so it can't cause a Data Race.\n"
msgstr ""

#: src/races.md:51
msgid ""
"// Index with the value loaded from the atomic. This is safe because we\n"
"// read the atomic memory only once, and then pass a copy of that value\n"
"// to the Vec's indexing implementation. This indexing will be correctly\n"
"// bounds checked, and there's no chance of the value getting changed\n"
"// in the middle. However our program may panic if the thread we spawned\n"
"// managed to increment before this ran. A race condition because correct\n"
"// program execution (panicking is rarely correct) depends on order of\n"
"// thread execution.\n"
msgstr ""

#: src/races.md:63
msgid ""
"We can cause a race condition to violate memory safety if we instead do the "
"bound check in advance, and then unsafely access the data with an unchecked "
"value:"
msgstr ""

#: src/races.md:85
msgid ""
"// Incorrectly loading the idx after we did the bounds check.\n"
"        // It could have changed. This is a race condition, *and dangerous*\n"
"        // because we decided to do `get_unchecked`, which is `unsafe`.\n"
msgstr ""

#: src/send-and-sync.md:3
msgid ""
"Not everything obeys inherited mutability, though. Some types allow you to "
"have multiple aliases of a location in memory while mutating it. Unless "
"these types use synchronization to manage this access, they are absolutely "
"not thread-safe. Rust captures this through the `Send` and `Sync` traits."
msgstr ""

#: src/send-and-sync.md:8
msgid "A type is Send if it is safe to send it to another thread."
msgstr ""

#: src/send-and-sync.md:9
msgid ""
"A type is Sync if it is safe to share between threads (T is Sync if and only "
"if `&T` is Send)."
msgstr ""

#: src/send-and-sync.md:11
msgid ""
"Send and Sync are fundamental to Rust's concurrency story. As such, a "
"substantial amount of special tooling exists to make them work right. First "
"and foremost, they're [unsafe traits](safe-unsafe-meaning.html). This means "
"that they are unsafe to implement, and other unsafe code can assume that "
"they are correctly implemented. Since they're _marker traits_ (they have no "
"associated items like methods), correctly implemented simply means that they "
"have the intrinsic properties an implementor should have. Incorrectly "
"implementing Send or Sync can cause Undefined Behavior."
msgstr ""

#: src/send-and-sync.md:20
msgid ""
"Send and Sync are also automatically derived traits. This means that, unlike "
"every other trait, if a type is composed entirely of Send or Sync types, "
"then it is Send or Sync. Almost all primitives are Send and Sync, and as a "
"consequence pretty much all types you'll ever interact with are Send and "
"Sync."
msgstr ""

#: src/send-and-sync.md:25
msgid "Major exceptions include:"
msgstr ""

#: src/send-and-sync.md:27
msgid ""
"raw pointers are neither Send nor Sync (because they have no safety guards)."
msgstr ""

#: src/send-and-sync.md:28
msgid "`UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't)."
msgstr ""

#: src/send-and-sync.md:29
msgid ""
"`Rc` isn't Send or Sync (because the refcount is shared and unsynchronized)."
msgstr ""

#: src/send-and-sync.md:31
msgid ""
"`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable "
"unsynchronized shared mutable state. However raw pointers are, strictly "
"speaking, marked as thread-unsafe as more of a _lint_. Doing anything useful "
"with a raw pointer requires dereferencing it, which is already unsafe. In "
"that sense, one could argue that it would be \"fine\" for them to be marked "
"as thread safe."
msgstr ""

#: src/send-and-sync.md:38
msgid ""
"However it's important that they aren't thread-safe to prevent types that "
"contain them from being automatically marked as thread-safe. These types "
"have non-trivial untracked ownership, and it's unlikely that their author "
"was necessarily thinking hard about thread safety. In the case of `Rc`, we "
"have a nice example of a type that contains a `*mut` that is definitely not "
"thread-safe."
msgstr ""

#: src/send-and-sync.md:44
msgid ""
"Types that aren't automatically derived can simply implement them if desired:"
msgstr ""

#: src/send-and-sync.md:53
msgid ""
"In the _incredibly rare_ case that a type is inappropriately automatically "
"derived to be Send or Sync, then one can also unimplement Send and Sync:"
msgstr ""

#: src/send-and-sync.md:58
msgid "// I have some magic semantics for some synchronization primitive!\n"
msgstr ""

#: src/send-and-sync.md:66
msgid ""
"Note that _in and of itself_ it is impossible to incorrectly derive Send and "
"Sync. Only types that are ascribed special meaning by other unsafe code can "
"possibly cause trouble by being incorrectly Send or Sync."
msgstr ""

#: src/send-and-sync.md:70
msgid ""
"Most uses of raw pointers should be encapsulated behind a sufficient "
"abstraction that Send and Sync can be derived. For instance all of Rust's "
"standard collections are Send and Sync (when they contain Send and Sync "
"types) in spite of their pervasive use of raw pointers to manage allocations "
"and complex ownership. Similarly, most iterators into these collections are "
"Send and Sync because they largely behave like an `&` or `&mut` into the "
"collection."
msgstr ""

#: src/send-and-sync.md:77
msgid "Example"
msgstr ""

#: src/send-and-sync.md:79
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is implemented "
"as its own special intrinsic type by the compiler for [various reasons]"
"(https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-"
"special/), but we can implement something with similar-ish behavior "
"ourselves to see an example of when it is sound to implement Send and Sync. "
"Let's call it a `Carton`."
msgstr ""

#: src/send-and-sync.md:84
msgid ""
"We start by writing code to take a value allocated on the stack and transfer "
"it to the heap."
msgstr ""

#: src/send-and-sync.md:92 src/send-and-sync.md:228 src/ffi.md:255
#: src/ffi.md:386 src/ffi.md:688 src/ffi.md:690 src/ffi.md:692 src/ffi.md:699
#: src/ffi.md:820 src/ffi.md:837 src/ffi.md:870 src/ffi.md:905
#: src/beneath-std.md:57
msgid "\"C\""
msgstr ""

#: src/send-and-sync.md:104
msgid "// Allocate enough memory on the heap to store one T.\n"
msgstr ""

#: src/send-and-sync.md:105
msgid "\"Zero-sized types are out of the scope of this example\""
msgstr ""

#: src/send-and-sync.md:113
msgid "\"Failed to allocate or invalid alignment\""
msgstr ""

#: src/send-and-sync.md:116
msgid ""
"// NonNull is just a wrapper that enforces that the pointer isn't null.\n"
msgstr ""

#: src/send-and-sync.md:118
msgid ""
"// Safety: memptr is dereferenceable because we created it from a\n"
"            // reference and have exclusive access.\n"
msgstr ""

#: src/send-and-sync.md:121
msgid "\"Guaranteed non-null if posix_memalign returns 0\""
msgstr ""

#: src/send-and-sync.md:124
msgid ""
"// Move value from the stack to the location we allocated on the heap.\n"
msgstr ""

#: src/send-and-sync.md:126
msgid ""
"// Safety: If non-null, posix_memalign gives us a ptr that is valid\n"
"            // for writes and properly aligned.\n"
msgstr ""

#: src/send-and-sync.md:136
msgid ""
"This isn't very useful, because once our users give us a value they have no "
"way to access it. [`Box`](https://doc.rust-lang.org/std/boxed/"
"struct.Box.html) implements [`Deref`](https://doc.rust-lang.org/core/ops/"
"trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/core/ops/"
"trait.DerefMut.html) so that you can access the inner value. Let's do that."
msgstr ""

#: src/send-and-sync.md:151
msgid ""
"// Safety: The pointer is aligned, initialized, and dereferenceable\n"
"            //   by the logic in [`Self::new`]. We require readers to borrow "
"the\n"
"            //   Carton, and the lifetime of the return value is elided to "
"the\n"
"            //   lifetime of the input. This means the borrow checker will\n"
"            //   enforce that no one can mutate the contents of the Carton "
"until\n"
"            //   the reference returned is dropped.\n"
msgstr ""

#: src/send-and-sync.md:165
msgid ""
"// Safety: The pointer is aligned, initialized, and dereferenceable\n"
"            //   by the logic in [`Self::new`]. We require writers to "
"mutably\n"
"            //   borrow the Carton, and the lifetime of the return value is\n"
"            //   elided to the lifetime of the input. This means the borrow\n"
"            //   checker will enforce that no one else can access the "
"contents\n"
"            //   of the Carton until the mutable reference returned is "
"dropped.\n"
msgstr ""

#: src/send-and-sync.md:177
msgid ""
"Finally, let's think about whether our `Carton` is Send and Sync. Something "
"can safely be Send unless it shares mutable state with something else "
"without enforcing exclusive access to it. Each `Carton` has a unique "
"pointer, so we're good."
msgstr ""

#: src/send-and-sync.md:183
msgid ""
"// Safety: No one besides us has the raw pointer, so we can safely transfer "
"the\n"
"// Carton to another thread if T can be safely transferred.\n"
msgstr ""

#: src/send-and-sync.md:189
msgid ""
"What about Sync? For `Carton` to be Sync we have to enforce that you can't "
"write to something stored in a `&Carton` while that same something could be "
"read or written to from another `&Carton`. Since you need an `&mut Carton` "
"to write to the pointer, and the borrow checker enforces that mutable "
"references must be exclusive, there are no soundness issues making `Carton` "
"sync either."
msgstr ""

#: src/send-and-sync.md:197
msgid ""
"// Safety: Since there exists a public way to go from a `&Carton<T>` to a "
"`&T`\n"
"// in an unsynchronized fashion (such as `Deref`), then `Carton<T>` can't "
"be\n"
"// `Sync` if `T` isn't.\n"
"// Conversely, `Carton` itself does not use any interior mutability "
"whatsoever:\n"
"// all the mutations are performed through an exclusive reference (`&mut`). "
"This\n"
"// means it suffices that `T` be `Sync` for `Carton<T>` to be `Sync`:\n"
msgstr ""

#: src/send-and-sync.md:207
msgid ""
"When we assert our type is Send and Sync we usually need to enforce that "
"every contained type is Send and Sync. When writing custom types that behave "
"like standard library types we can assert that we have the same "
"requirements. For example, the following code asserts that a Carton is Send "
"if the same sort of Box would be Send, which in this case is the same as "
"saying T is Send."
msgstr ""

#: src/send-and-sync.md:218
msgid ""
"Right now `Carton<T>` has a memory leak, as it never frees the memory it "
"allocates. Once we fix that we have a new requirement we have to ensure we "
"meet to be Send: we need to know `free` can be called on a pointer that was "
"yielded by an allocation done on another thread. We can check this is true "
"in the docs for [`libc::free`](https://linux.die.net/man/3/free)."
msgstr ""

#: src/send-and-sync.md:239
msgid ""
"A nice example where this does not happen is with a MutexGuard: notice how "
"[it is not Send](https://doc.rust-lang.org/std/sync/"
"struct.MutexGuard.html#impl-Send-for-MutexGuard%3C'_,+T%3E). The "
"implementation of MutexGuard [uses libraries](https://github.com/rust-lang/"
"rust/issues/23465#issuecomment-82730326) that require you to ensure you "
"don't try to free a lock that you acquired in a different thread. If you "
"were able to Send a MutexGuard to another thread the destructor would run in "
"the thread you sent it to, violating the requirement. MutexGuard can still "
"be Sync because all you can send to another thread is an `&MutexGuard` and "
"dropping a reference does nothing."
msgstr ""

#: src/send-and-sync.md:248
msgid ""
"TODO: better explain what can or can't be Send or Sync. Sufficient to appeal "
"only to data races?"
msgstr ""

#: src/atomics.md:3
msgid ""
"Rust pretty blatantly just inherits the memory model for atomics from C++20. "
"This is not due to this model being particularly excellent or easy to "
"understand. Indeed, this model is quite complex and known to have [several "
"flaws](http://plv.mpi-sws.org/c11comp/popl15.pdf). Rather, it is a pragmatic "
"concession to the fact that _everyone_ is pretty bad at modeling atomics. At "
"very least, we can benefit from existing tooling and research around the C/C+"
"+ memory model. (You'll often see this model referred to as \"C/C++11\" or "
"just \"C11\". C just copies the C++ memory model; and C++11 was the first "
"version of the model but it has received some bugfixes since then.)"
msgstr ""

#: src/atomics.md:13
msgid ""
"Trying to fully explain the model in this book is fairly hopeless. It's "
"defined in terms of madness-inducing causality graphs that require a full "
"book to properly understand in a practical way. If you want all the nitty-"
"gritty details, you should check out the [C++ specification](https://"
"en.cppreference.com/w/cpp/atomic/memory_order). Still, we'll try to cover "
"the basics and some of the problems Rust developers face."
msgstr ""

#: src/atomics.md:20
msgid ""
"The C++ memory model is fundamentally about trying to bridge the gap between "
"the semantics we want, the optimizations compilers want, and the "
"inconsistent chaos our hardware wants. _We_ would like to just write "
"programs and have them do exactly what we said but, you know, fast. Wouldn't "
"that be great?"
msgstr ""

#: src/atomics.md:25
msgid "Compiler Reordering"
msgstr ""

#: src/atomics.md:27
msgid ""
"Compilers fundamentally want to be able to do all sorts of complicated "
"transformations to reduce data dependencies and eliminate dead code. In "
"particular, they may radically change the actual order of events, or make "
"events never occur! If we write something like:"
msgstr ""

#: src/atomics.md:39
msgid "The compiler may conclude that it would be best if your program did:"
msgstr ""

#: src/atomics.md:47
msgid ""
"This has inverted the order of events and completely eliminated one event. "
"From a single-threaded perspective this is completely unobservable: after "
"all the statements have executed we are in exactly the same state. But if "
"our program is multi-threaded, we may have been relying on `x` to actually "
"be assigned to 1 before `y` was assigned. We would like the compiler to be "
"able to make these kinds of optimizations, because they can seriously "
"improve performance. On the other hand, we'd also like to be able to depend "
"on our program _doing the thing we said_."
msgstr ""

#: src/atomics.md:56
msgid "Hardware Reordering"
msgstr ""

#: src/atomics.md:58
msgid ""
"On the other hand, even if the compiler totally understood what we wanted "
"and respected our wishes, our hardware might instead get us in trouble. "
"Trouble comes from CPUs in the form of memory hierarchies. There is indeed a "
"global shared memory space somewhere in your hardware, but from the "
"perspective of each CPU core it is _so very far away_ and _so very slow_. "
"Each CPU would rather work with its local cache of the data and only go "
"through all the anguish of talking to shared memory only when it doesn't "
"actually have that memory in cache."
msgstr ""

#: src/atomics.md:67
msgid ""
"After all, that's the whole point of the cache, right? If every read from "
"the cache had to run back to shared memory to double check that it hadn't "
"changed, what would the point be? The end result is that the hardware "
"doesn't guarantee that events that occur in some order on _one_ thread, "
"occur in the same order on _another_ thread. To guarantee this, we must "
"issue special instructions to the CPU telling it to be a bit less smart."
msgstr ""

#: src/atomics.md:74
msgid "For instance, say we convince the compiler to emit this logic:"
msgstr ""

#: src/atomics.md:85
msgid "Ideally this program has 2 possible final states:"
msgstr ""

#: src/atomics.md:87
msgid "`y = 3`: (thread 2 did the check before thread 1 completed)"
msgstr ""

#: src/atomics.md:88
msgid "`y = 6`: (thread 2 did the check after thread 1 completed)"
msgstr ""

#: src/atomics.md:90
msgid "However there's a third potential state that the hardware enables:"
msgstr ""

#: src/atomics.md:92
msgid ""
"`y = 2`: (thread 2 saw `x = 1`, but not `y = 3`, and then overwrote `y = 3`)"
msgstr ""

#: src/atomics.md:94
msgid ""
"It's worth noting that different kinds of CPU provide different guarantees. "
"It is common to separate hardware into two categories: strongly-ordered and "
"weakly-ordered. Most notably x86/64 provides strong ordering guarantees, "
"while ARM provides weak ordering guarantees. This has two consequences for "
"concurrent programming:"
msgstr ""

#: src/atomics.md:100
msgid ""
"Asking for stronger guarantees on strongly-ordered hardware may be cheap or "
"even free because they already provide strong guarantees unconditionally. "
"Weaker guarantees may only yield performance wins on weakly-ordered hardware."
msgstr ""

#: src/atomics.md:104
msgid ""
"Asking for guarantees that are too weak on strongly-ordered hardware is more "
"likely to _happen_ to work, even though your program is strictly incorrect. "
"If possible, concurrent algorithms should be tested on weakly-ordered "
"hardware."
msgstr ""

#: src/atomics.md:109
msgid "Data Accesses"
msgstr ""

#: src/atomics.md:111
msgid ""
"The C++ memory model attempts to bridge the gap by allowing us to talk about "
"the _causality_ of our program. Generally, this is by establishing a "
"_happens before_ relationship between parts of the program and the threads "
"that are running them. This gives the hardware and compiler room to optimize "
"the program more aggressively where a strict happens-before relationship "
"isn't established, but forces them to be more careful where one is "
"established. The way we communicate these relationships are through _data "
"accesses_ and _atomic accesses_."
msgstr ""

#: src/atomics.md:120
msgid ""
"Data accesses are the bread-and-butter of the programming world. They are "
"fundamentally unsynchronized and compilers are free to aggressively optimize "
"them. In particular, data accesses are free to be reordered by the compiler "
"on the assumption that the program is single-threaded. The hardware is also "
"free to propagate the changes made in data accesses to other threads as "
"lazily and inconsistently as it wants. Most critically, data accesses are "
"how data races happen. Data accesses are very friendly to the hardware and "
"compiler, but as we've seen they offer _awful_ semantics to try to write "
"synchronized code with. Actually, that's too weak."
msgstr ""

#: src/atomics.md:130
msgid ""
"**It is literally impossible to write correct synchronized code using only "
"data accesses.**"
msgstr ""

#: src/atomics.md:133
msgid ""
"Atomic accesses are how we tell the hardware and compiler that our program "
"is multi-threaded. Each atomic access can be marked with an _ordering_ that "
"specifies what kind of relationship it establishes with other accesses. In "
"practice, this boils down to telling the compiler and hardware certain "
"things they _can't_ do. For the compiler, this largely revolves around re-"
"ordering of instructions. For the hardware, this largely revolves around how "
"writes are propagated to other threads. The set of orderings Rust exposes "
"are:"
msgstr ""

#: src/atomics.md:141
msgid "Sequentially Consistent (SeqCst)"
msgstr ""

#: src/atomics.md:142
msgid "Release"
msgstr ""

#: src/atomics.md:143
msgid "Acquire"
msgstr ""

#: src/atomics.md:144 src/atomics.md:223
msgid "Relaxed"
msgstr ""

#: src/atomics.md:146
msgid "(Note: We explicitly do not expose the C++ _consume_ ordering)"
msgstr ""

#: src/atomics.md:148
msgid ""
"TODO: negative reasoning vs positive reasoning? TODO: \"can't forget to "
"synchronize\""
msgstr ""

#: src/atomics.md:151
msgid "Sequentially Consistent"
msgstr ""

#: src/atomics.md:153
msgid ""
"Sequentially Consistent is the most powerful of all, implying the "
"restrictions of all other orderings. Intuitively, a sequentially consistent "
"operation cannot be reordered: all accesses on one thread that happen before "
"and after a SeqCst access stay before and after it. A data-race-free program "
"that uses only sequentially consistent atomics and data accesses has the "
"very nice property that there is a single global execution of the program's "
"instructions that all threads agree on. This execution is also particularly "
"nice to reason about: it's just an interleaving of each thread's individual "
"executions. This does not hold if you start using the weaker atomic "
"orderings."
msgstr ""

#: src/atomics.md:163
msgid ""
"The relative developer-friendliness of sequential consistency doesn't come "
"for free. Even on strongly-ordered platforms sequential consistency involves "
"emitting memory fences."
msgstr ""

#: src/atomics.md:167
msgid ""
"In practice, sequential consistency is rarely necessary for program "
"correctness. However sequential consistency is definitely the right choice "
"if you're not confident about the other memory orders. Having your program "
"run a bit slower than it needs to is certainly better than it running "
"incorrectly! It's also mechanically trivial to downgrade atomic operations "
"to have a weaker consistency later on. Just change `SeqCst` to `Relaxed` and "
"you're done! Of course, proving that this transformation is _correct_ is a "
"whole other matter."
msgstr ""

#: src/atomics.md:175
msgid "Acquire-Release"
msgstr ""

#: src/atomics.md:177
msgid ""
"Acquire and Release are largely intended to be paired. Their names hint at "
"their use case: they're perfectly suited for acquiring and releasing locks, "
"and ensuring that critical sections don't overlap."
msgstr ""

#: src/atomics.md:181
msgid ""
"Intuitively, an acquire access ensures that every access after it stays "
"after it. However operations that occur before an acquire are free to be "
"reordered to occur after it. Similarly, a release access ensures that every "
"access before it stays before it. However operations that occur after a "
"release are free to be reordered to occur before it."
msgstr ""

#: src/atomics.md:187
msgid ""
"When thread A releases a location in memory and then thread B subsequently "
"acquires _the same_ location in memory, causality is established. Every "
"write (including non-atomic and relaxed atomic writes) that happened before "
"A's release will be observed by B after its acquisition. However no "
"causality is established with any other threads. Similarly, no causality is "
"established if A and B access _different_ locations in memory."
msgstr ""

#: src/atomics.md:194
msgid ""
"Basic use of release-acquire is therefore simple: you acquire a location of "
"memory to begin the critical section, and then release that location to end "
"it. For instance, a simple spinlock might look like:"
msgstr ""

#: src/atomics.md:204
msgid "// value answers \"am I locked?\"\n"
msgstr ""

#: src/atomics.md:206
msgid "// ... distribute lock to threads somehow ...\n"
msgstr ""

#: src/atomics.md:208
msgid "// Try to acquire the lock by setting it to true\n"
msgstr ""

#: src/atomics.md:210
msgid "// broke out of the loop, so we successfully acquired the lock!\n"
msgstr ""

#: src/atomics.md:212
msgid "// ... scary data accesses ...\n"
msgstr ""

#: src/atomics.md:214
msgid "// ok we're done, release the lock\n"
msgstr ""

#: src/atomics.md:219
msgid ""
"On strongly-ordered platforms most accesses have release or acquire "
"semantics, making release and acquire often totally free. This is not the "
"case on weakly-ordered platforms."
msgstr ""

#: src/atomics.md:225
msgid ""
"Relaxed accesses are the absolute weakest. They can be freely re-ordered and "
"provide no happens-before relationship. Still, relaxed operations are still "
"atomic. That is, they don't count as data accesses and any read-modify-write "
"operations done to them occur atomically. Relaxed operations are appropriate "
"for things that you definitely want to happen, but don't particularly "
"otherwise care about. For instance, incrementing a counter can be safely "
"done by multiple threads using a relaxed `fetch_add` if you're not using the "
"counter to synchronize any other accesses."
msgstr ""

#: src/atomics.md:234
msgid ""
"There's rarely a benefit in making an operation relaxed on strongly-ordered "
"platforms, since they usually provide release-acquire semantics anyway. "
"However relaxed operations can be cheaper on weakly-ordered platforms."
msgstr ""

#: src/vec/vec.md:1
msgid "Example: Implementing Vec"
msgstr ""

#: src/vec/vec.md:3
msgid ""
"To bring everything together, we're going to write `std::Vec` from scratch. "
"We will limit ourselves to stable Rust. In particular we won't use any "
"intrinsics that could make our code a little bit nicer or efficient because "
"intrinsics are permanently unstable. Although many intrinsics _do_ become "
"stabilized elsewhere (`std::ptr` and `std::mem` consist of many intrinsics)."
msgstr ""

#: src/vec/vec.md:9
msgid ""
"Ultimately this means our implementation may not take advantage of all "
"possible optimizations, though it will be by no means _naive_. We will "
"definitely get into the weeds over nitty-gritty details, even when the "
"problem doesn't _really_ merit it."
msgstr ""

#: src/vec/vec.md:14
msgid "You wanted advanced. We're gonna go advanced."
msgstr ""

#: src/vec/vec-layout.md:3
msgid ""
"First off, we need to come up with the struct layout. A Vec has three parts: "
"a pointer to the allocation, the size of the allocation, and the number of "
"elements that have been initialized."
msgstr ""

#: src/vec/vec-layout.md:7
msgid "Naively, this means we just want this design:"
msgstr ""

#: src/vec/vec-layout.md:18
msgid ""
"And indeed this would compile. Unfortunately, it would be too strict. The "
"compiler will give us too strict variance. So a `&Vec<&'static str>` "
"couldn't be used where a `&Vec<&'a str>` was expected. See [the chapter on "
"ownership and lifetimes](../ownership.html) for all the details on variance."
msgstr ""

#: src/vec/vec-layout.md:23
msgid ""
"As we saw in the ownership chapter, the standard library uses `Unique<T>` in "
"place of `*mut T` when it has a raw pointer to an allocation that it owns. "
"Unique is unstable, so we'd like to not use it if possible, though."
msgstr ""

#: src/vec/vec-layout.md:27
msgid ""
"As a recap, Unique is a wrapper around a raw pointer that declares that:"
msgstr ""

#: src/vec/vec-layout.md:29 src/arc-mutex/arc-layout.md:50
msgid "We are covariant over `T`"
msgstr ""

#: src/vec/vec-layout.md:30
msgid ""
"We may own a value of type `T` (this is not relevant for our example here, "
"but see [the chapter on PhantomData](../phantom-data.md) on why the real "
"`std::vec::Vec<T>` needs this)"
msgstr ""

#: src/vec/vec-layout.md:32
msgid "We are Send/Sync if `T` is Send/Sync"
msgstr ""

#: src/vec/vec-layout.md:33
msgid ""
"Our pointer is never null (so `Option<Vec<T>>` is null-pointer-optimized)"
msgstr ""

#: src/vec/vec-layout.md:35
msgid ""
"We can implement all of the above requirements in stable Rust. To do this, "
"instead of using `Unique<T>` we will use [`NonNull<T>`](../../std/ptr/"
"struct.NonNull.html), another wrapper around a raw pointer, which gives us "
"two of the above properties, namely it is covariant over `T` and is declared "
"to never be null. By implementing Send/Sync if `T` is, we get the same "
"results as using `Unique<T>`:"
msgstr ""

#: src/vec/vec-alloc.md:1
msgid "Allocating Memory"
msgstr ""

#: src/vec/vec-alloc.md:3
msgid ""
"Using `NonNull` throws a wrench in an important feature of Vec (and indeed "
"all of the std collections): creating an empty Vec doesn't actually allocate "
"at all. This is not the same as allocating a zero-sized memory block, which "
"is not allowed by the global allocator (it results in undefined behavior!). "
"So if we can't allocate, but also can't put a null pointer in `ptr`, what do "
"we do in `Vec::new`? Well, we just put some other garbage in there!"
msgstr ""

#: src/vec/vec-alloc.md:10
msgid ""
"This is perfectly fine because we already have `cap == 0` as our sentinel "
"for no allocation. We don't even need to handle it specially in almost any "
"code because we usually need to check if `cap > len` or `len > 0` anyway. "
"The recommended Rust value to put here is `mem::align_of::<T>()`. `NonNull` "
"provides a convenience for this: `NonNull::dangling()`. There are quite a "
"few places where we'll want to use `dangling` because there's no real "
"allocation to talk about but `null` would make the compiler do bad things."
msgstr ""

#: src/vec/vec-alloc.md:18
msgid "So:"
msgstr ""

#: src/vec/vec-alloc.md:26
msgid "\"We're not ready to handle ZSTs\""
msgstr ""

#: src/vec/vec-alloc.md:37
msgid ""
"I slipped in that assert there because zero-sized types will require some "
"special handling throughout our code, and I want to defer the issue for now. "
"Without this assert, some of our early drafts will do some Very Bad Things."
msgstr ""

#: src/vec/vec-alloc.md:41
msgid ""
"Next we need to figure out what to actually do when we _do_ want space. For "
"that, we use the global allocation functions [`alloc`](../../alloc/alloc/"
"fn.alloc.html), [`realloc`](../../alloc/alloc/fn.realloc.html), and "
"[`dealloc`](../../alloc/alloc/fn.dealloc.html) which are available in stable "
"Rust in [`std::alloc`](../../alloc/alloc/index.html). These functions are "
"expected to become deprecated in favor of the methods of "
"[`std::alloc::Global`](../../std/alloc/struct.Global.html) after this type "
"is stabilized."
msgstr ""

#: src/vec/vec-alloc.md:47
msgid ""
"We'll also need a way to handle out-of-memory (OOM) conditions. The standard "
"library provides a function [`alloc::handle_alloc_error`](../../alloc/alloc/"
"fn.handle_alloc_error.html), which will abort the program in a platform-"
"specific manner. The reason we abort and don't panic is because unwinding "
"can cause allocations to happen, and that seems like a bad thing to do when "
"your allocator just came back with \"hey I don't have any more memory\"."
msgstr ""

#: src/vec/vec-alloc.md:54
msgid ""
"Of course, this is a bit silly since most platforms don't actually run out "
"of memory in a conventional way. Your operating system will probably kill "
"the application by another means if you legitimately start using up all the "
"memory. The most likely way we'll trigger OOM is by just asking for "
"ludicrous quantities of memory at once (e.g. half the theoretical address "
"space). As such it's _probably_ fine to panic and nothing bad will happen. "
"Still, we're trying to be like the standard library as much as possible, so "
"we'll just kill the whole program."
msgstr ""

#: src/vec/vec-alloc.md:63
msgid "Okay, now we can write growing. Roughly, we want to have this logic:"
msgstr ""

#: src/vec/vec-alloc.md:74
msgid ""
"But Rust's only supported allocator API is so low level that we'll need to "
"do a fair bit of extra work. We also need to guard against some special "
"conditions that can occur with really large allocations or empty allocations."
msgstr ""

#: src/vec/vec-alloc.md:78
msgid ""
"In particular, `ptr::offset` will cause us a lot of trouble, because it has "
"the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough "
"to not have dealt with this instruction, here's the basic story with GEP: "
"alias analysis, alias analysis, alias analysis. It's super important to an "
"optimizing compiler to be able to reason about data dependencies and "
"aliasing."
msgstr ""

#: src/vec/vec-alloc.md:84
msgid "As a simple example, consider the following fragment of code:"
msgstr ""

#: src/vec/vec-alloc.md:92
msgid ""
"If the compiler can prove that `x` and `y` point to different locations in "
"memory, the two operations can in theory be executed in parallel (by e.g. "
"loading them into different registers and working on them independently). "
"However the compiler can't do this in general because if x and y point to "
"the same location in memory, the operations need to be done to the same "
"value, and they can't just be merged afterwards."
msgstr ""

#: src/vec/vec-alloc.md:99
msgid ""
"When you use GEP inbounds, you are specifically telling LLVM that the "
"offsets you're about to do are within the bounds of a single \"allocated\" "
"entity. The ultimate payoff being that LLVM can assume that if two pointers "
"are known to point to two disjoint objects, all the offsets of those "
"pointers are _also_ known to not alias (because you won't just end up in "
"some random place in memory). LLVM is heavily optimized to work with GEP "
"offsets, and inbounds offsets are the best of all, so it's important that we "
"use them as much as possible."
msgstr ""

#: src/vec/vec-alloc.md:108
msgid "So that's what GEP's about, how can it cause us trouble?"
msgstr ""

#: src/vec/vec-alloc.md:110
msgid ""
"The first problem is that we index into arrays with unsigned integers, but "
"GEP (and as a consequence `ptr::offset`) takes a signed integer. This means "
"that half of the seemingly valid indices into an array will overflow GEP and "
"actually go in the wrong direction! As such we must limit all allocations to "
"`isize::MAX` elements. This actually means we only need to worry about byte-"
"sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of "
"the system's memory. However in order to avoid subtle corner cases where "
"someone reinterprets some array of `< isize::MAX` objects as bytes, std "
"limits all allocations to `isize::MAX` bytes."
msgstr ""

#: src/vec/vec-alloc.md:120
msgid ""
"On all 64-bit targets that Rust currently supports we're artificially "
"limited to significantly less than all 64 bits of the address space (modern "
"x64 platforms only expose 48-bit addressing), so we can rely on just running "
"out of memory first. However on 32-bit targets, particularly those with "
"extensions to use more of the address space (PAE x86 or x32), it's "
"theoretically possible to successfully allocate more than `isize::MAX` bytes "
"of memory."
msgstr ""

#: src/vec/vec-alloc.md:127
msgid ""
"However since this is a tutorial, we're not going to be particularly optimal "
"here, and just unconditionally check, rather than use clever platform-"
"specific `cfg`s."
msgstr ""

#: src/vec/vec-alloc.md:131
msgid ""
"The other corner-case we need to worry about is empty allocations. There "
"will be two kinds of empty allocations we need to worry about: `cap = 0` for "
"all T, and `cap > 0` for zero-sized types."
msgstr ""

#: src/vec/vec-alloc.md:135
msgid ""
"These cases are tricky because they come down to what LLVM means by "
"\"allocated\". LLVM's notion of an allocation is significantly more abstract "
"than how we usually use it. Because LLVM needs to work with different "
"languages' semantics and custom allocators, it can't really intimately "
"understand allocation. Instead, the main idea behind allocation is \"doesn't "
"overlap with other stuff\". That is, heap allocations, stack allocations, "
"and globals don't randomly overlap. Yep, it's about alias analysis. As such, "
"Rust can technically play a bit fast and loose with the notion of an "
"allocation as long as it's _consistent_."
msgstr ""

#: src/vec/vec-alloc.md:145
msgid ""
"Getting back to the empty allocation case, there are a couple of places "
"where we want to offset by 0 as a consequence of generic code. The question "
"is then: is it consistent to do so? For zero-sized types, we have concluded "
"that it is indeed consistent to do a GEP inbounds offset by an arbitrary "
"number of elements. This is a runtime no-op because every element takes up "
"no space, and it's fine to pretend that there's infinite zero-sized types "
"allocated at `0x01`. No allocator will ever allocate that address, because "
"they won't allocate `0x00` and they generally allocate to some minimal "
"alignment higher than a byte. Also generally the whole first page of memory "
"is protected from being allocated anyway (a whole 4k, on many platforms)."
msgstr ""

#: src/vec/vec-alloc.md:156
msgid ""
"However what about for positive-sized types? That one's a bit trickier. In "
"principle, you can argue that offsetting by 0 gives LLVM no information: "
"either there's an element before the address or after it, but it can't know "
"which. However we've chosen to conservatively assume that it may do bad "
"things. As such we will guard against this case explicitly."
msgstr ""

#: src/vec/vec-alloc.md:162
msgid "_Phew_"
msgstr ""

#: src/vec/vec-alloc.md:164
msgid ""
"Ok with all the nonsense out of the way, let's actually allocate some memory:"
msgstr ""

#: src/vec/vec-alloc.md:175
msgid "// This can't overflow since self.cap <= isize::MAX.\n"
msgstr ""

#: src/vec/vec-alloc.md:178 src/vec/vec-zsts.md:57 src/vec/vec-final.md:41
msgid ""
"// `Layout::array` checks that the number of bytes is <= usize::MAX,\n"
"            // but this is redundant since old_layout.size() <= isize::MAX,\n"
"            // so the `unwrap` should never fail.\n"
msgstr ""

#: src/vec/vec-alloc.md:185 src/vec/vec-raw.md:39 src/vec/vec-zsts.md:64
#: src/vec/vec-final.md:48
msgid "// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n"
msgstr ""

#: src/vec/vec-alloc.md:186 src/vec/vec-raw.md:40 src/vec/vec-zsts.md:65
#: src/vec/vec-final.md:51
msgid "\"Allocation too large\""
msgstr ""

#: src/vec/vec-alloc.md:196 src/vec/vec-raw.md:50 src/vec/vec-zsts.md:75
#: src/vec/vec-final.md:62
msgid ""
"// If allocation fails, `new_ptr` will be null, in which case we abort.\n"
msgstr ""

#: src/vec/vec-push-pop.md:3
msgid ""
"Alright. We can initialize. We can allocate. Let's actually implement some "
"functionality! Let's start with `push`. All it needs to do is check if we're "
"full to grow, unconditionally write to the next index, and then increment "
"our length."
msgstr ""

#: src/vec/vec-push-pop.md:8
msgid ""
"To do the write we have to be careful not to evaluate the memory we want to "
"write to. At worst, it's truly uninitialized memory from the allocator. At "
"best it's the bits of some old value we popped off. Either way, we can't "
"just index to the memory and dereference it, because that will evaluate the "
"memory as a valid instance of T. Worse, `foo[idx] = x` will try to call "
"`drop` on the old value of `foo[idx]`!"
msgstr ""

#: src/vec/vec-push-pop.md:14
msgid ""
"The correct way to do this is with `ptr::write`, which just blindly "
"overwrites the target address with the bits of the value we provide. No "
"evaluation involved."
msgstr ""

#: src/vec/vec-push-pop.md:17
msgid ""
"For `push`, if the old len (before push was called) is 0, then we want to "
"write to the 0th index. So we should offset by the old len."
msgstr ""

#: src/vec/vec-push-pop.md:29
msgid "// Can't fail, we'll OOM first.\n"
msgstr ""

#: src/vec/vec-push-pop.md:34
msgid ""
"Easy! How about `pop`? Although this time the index we want to access is "
"initialized, Rust won't just let us dereference the location of memory to "
"move the value out, because that would leave the memory uninitialized! For "
"this we need `ptr::read`, which just copies out the bits from the target "
"address and interprets it as a value of type T. This will leave the memory "
"at this address logically uninitialized, even though there is in fact a "
"perfectly good instance of T there."
msgstr ""

#: src/vec/vec-push-pop.md:42
msgid ""
"For `pop`, if the old len is 1, for example, we want to read out of the 0th "
"index. So we should offset by the new len."
msgstr ""

#: src/vec/vec-dealloc.md:3
msgid ""
"Next we should implement Drop so that we don't massively leak tons of "
"resources. The easiest way is to just call `pop` until it yields None, and "
"then deallocate our buffer. Note that calling `pop` is unneeded if `T: !"
"Drop`. In theory we can ask Rust if `T` `needs_drop` and omit the calls to "
"`pop`. However in practice LLVM is _really_ good at removing simple side-"
"effect free code like this, so I wouldn't bother unless you notice it's not "
"being stripped (in this case it is)."
msgstr ""

#: src/vec/vec-dealloc.md:10
msgid ""
"We must not call `alloc::dealloc` when `self.cap == 0`, as in this case we "
"haven't actually allocated any memory."
msgstr ""

#: src/vec/vec-deref.md:3
msgid ""
"Alright! We've got a decent minimal stack implemented. We can push, we can "
"pop, and we can clean up after ourselves. However there's a whole mess of "
"functionality we'd reasonably want. In particular, we have a proper array, "
"but none of the slice functionality. That's actually pretty easy to solve: "
"we can implement `Deref<Target=[T]>`. This will magically make our Vec "
"coerce to, and behave like, a slice in all sorts of conditions."
msgstr ""

#: src/vec/vec-deref.md:10
msgid ""
"All we need is `slice::from_raw_parts`. It will correctly handle empty "
"slices for us. Later once we set up zero-sized type support it will also "
"Just Work for those too."
msgstr ""

#: src/vec/vec-deref.md:28
msgid "And let's do DerefMut too:"
msgstr ""

#: src/vec/vec-deref.md:43
msgid ""
"Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`, "
"`iter_mut`, and all other sorts of bells and whistles provided by slice. "
"Sweet!"
msgstr ""

#: src/vec/vec-insert-remove.md:3
msgid ""
"Something _not_ provided by slice is `insert` and `remove`, so let's do "
"those next."
msgstr ""

#: src/vec/vec-insert-remove.md:6
msgid ""
"Insert needs to shift all the elements at the target index to the right by "
"one. To do this we need to use `ptr::copy`, which is our version of C's "
"`memmove`. This copies some chunk of memory from one location to another, "
"correctly handling the case where the source and destination overlap (which "
"will definitely happen here)."
msgstr ""

#: src/vec/vec-insert-remove.md:12
msgid ""
"If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. "
"len+1]` using the old len."
msgstr ""

#: src/vec/vec-insert-remove.md:18
msgid ""
"// Note: `<=` because it's valid to insert after everything\n"
"    // which would be equivalent to push.\n"
msgstr ""

#: src/vec/vec-insert-remove.md:20 src/vec/vec-insert-remove.md:44
#: src/vec/vec-final.md:129 src/vec/vec-final.md:147
msgid "\"index out of bounds\""
msgstr ""

#: src/vec/vec-insert-remove.md:24
msgid "// ptr::copy(src, dest, len): \"copy from src to dest len elems\"\n"
msgstr ""

#: src/vec/vec-insert-remove.md:37
msgid ""
"Remove behaves in the opposite manner. We need to shift all the elements "
"from `[i+1 .. len + 1]` to `[i .. len]` using the _new_ len."
msgstr ""

#: src/vec/vec-insert-remove.md:43
msgid "// Note: `<` because it's *not* valid to remove after everything\n"
msgstr ""

#: src/vec/vec-into-iter.md:3
msgid ""
"Let's move on to writing iterators. `iter` and `iter_mut` have already been "
"written for us thanks to The Magic of Deref. However there's two interesting "
"iterators that Vec provides that slices can't: `into_iter` and `drain`."
msgstr ""

#: src/vec/vec-into-iter.md:7
msgid ""
"IntoIter consumes the Vec by-value, and can consequently yield its elements "
"by-value. In order to enable this, IntoIter needs to take control of Vec's "
"allocation."
msgstr ""

#: src/vec/vec-into-iter.md:11
msgid ""
"IntoIter needs to be DoubleEnded as well, to enable reading from both ends. "
"Reading from the back could just be implemented as calling `pop`, but "
"reading from the front is harder. We could call `remove(0)` but that would "
"be insanely expensive. Instead we're going to just use ptr::read to copy "
"values out of either end of the Vec without mutating the buffer at all."
msgstr ""

#: src/vec/vec-into-iter.md:17
msgid ""
"To do this we're going to use a very common C idiom for array iteration. "
"We'll make two pointers; one that points to the start of the array, and one "
"that points to one-element past the end. When we want an element from one "
"end, we'll read out the value pointed to at that end and move the pointer "
"over by one. When the two pointers are equal, we know we're done."
msgstr ""

#: src/vec/vec-into-iter.md:23
msgid ""
"Note that the order of read and offset are reversed for `next` and "
"`next_back` For `next_back` the pointer is always after the element it wants "
"to read next, while for `next` the pointer is always at the element it wants "
"to read next. To see why this is, consider the case where every element but "
"one has been yielded."
msgstr ""

#: src/vec/vec-into-iter.md:29
msgid "The array looks like this:"
msgstr ""

#: src/vec/vec-into-iter.md:36
msgid ""
"If E pointed directly at the element it wanted to yield next, it would be "
"indistinguishable from the case where there are no more elements to yield."
msgstr ""

#: src/vec/vec-into-iter.md:39
msgid ""
"Although we don't actually care about it during iteration, we also need to "
"hold onto the Vec's allocation information in order to free it once IntoIter "
"is dropped."
msgstr ""

#: src/vec/vec-into-iter.md:43
msgid "So we're going to use the following struct:"
msgstr ""

#: src/vec/vec-into-iter.md:55
msgid "And this is what we end up with for initialization:"
msgstr ""

#: src/vec/vec-into-iter.md:63
msgid "// Make sure not to drop Vec since that would free the buffer\n"
msgstr ""

#: src/vec/vec-into-iter.md:66
msgid "// Can't destructure Vec since it's Drop\n"
msgstr ""

#: src/vec/vec-into-iter.md:76
msgid "// can't offset off this pointer, it's not allocated!\n"
msgstr ""

#: src/vec/vec-into-iter.md:86
msgid "Here's iterating forward:"
msgstr ""

#: src/vec/vec-into-iter.md:112
msgid "And here's iterating backwards."
msgstr ""

#: src/vec/vec-into-iter.md:130
msgid ""
"Because IntoIter takes ownership of its allocation, it needs to implement "
"Drop to free it. However it also wants to implement Drop to drop any "
"elements it contains that weren't yielded."
msgstr ""

#: src/vec/vec-into-iter.md:139
msgid "// drop any remaining elements\n"
msgstr ""

#: src/vec/vec-raw.md:3
msgid ""
"We've actually reached an interesting situation here: we've duplicated the "
"logic for specifying a buffer and freeing its memory in Vec and IntoIter. "
"Now that we've implemented it and identified _actual_ logic duplication, "
"this is a good time to perform some logic compression."
msgstr ""

#: src/vec/vec-raw.md:8
msgid ""
"We're going to abstract out the `(ptr, cap)` pair and give them the logic "
"for allocating, growing, and freeing:"
msgstr ""

#: src/vec/vec-raw.md:23
msgid "\"TODO: implement ZST support\""
msgstr ""

#: src/vec/vec-raw.md:31 src/vec/vec-zsts.md:54 src/vec/vec-final.md:38
msgid "// This can't overflow because we ensure self.cap <= isize::MAX.\n"
msgstr ""

#: src/vec/vec-raw.md:34
msgid ""
"// Layout::array checks that the number of bytes is <= usize::MAX,\n"
"        // but this is redundant since old_layout.size() <= isize::MAX,\n"
"        // so the `unwrap` should never fail.\n"
msgstr ""

#: src/vec/vec-raw.md:71
msgid "And change Vec as follows:"
msgstr ""

#: src/vec/vec-raw.md:96
msgid ""
"// push/pop/insert/remove largely unchanged:\n"
"    // * `self.ptr.as_ptr() -> self.ptr()`\n"
"    // * `self.cap -> self.cap()`\n"
"    // * `self.grow() -> self.buf.grow()`\n"
msgstr ""

#: src/vec/vec-raw.md:105 src/vec/vec-final.md:180
msgid "// deallocation is handled by RawVec\n"
msgstr ""

#: src/vec/vec-raw.md:110
msgid "And finally we can really simplify IntoIter:"
msgstr ""

#: src/vec/vec-raw.md:115 src/vec/vec-drain.md:65 src/vec/vec-final.md:280
msgid "// we don't actually care about this. Just need it to live.\n"
msgstr ""

#: src/vec/vec-raw.md:119
msgid ""
"// next and next_back literally unchanged since they never referred to the "
"buf\n"
msgstr ""

#: src/vec/vec-raw.md:124
msgid ""
"// only need to ensure all our elements are read;\n"
"        // buffer will clean itself up afterwards.\n"
msgstr ""

#: src/vec/vec-raw.md:134
msgid ""
"// need to use ptr::read to unsafely move the buf out since it's\n"
"        // not Copy, and Vec implements Drop (so we can't destructure it).\n"
msgstr ""

#: src/vec/vec-raw.md:143
msgid "// can't offset off of a pointer unless it's part of an allocation\n"
msgstr ""

#: src/vec/vec-raw.md:154
msgid "Much better."
msgstr ""

#: src/vec/vec-drain.md:3
msgid ""
"Let's move on to Drain. Drain is largely the same as IntoIter, except that "
"instead of consuming the Vec, it borrows the Vec and leaves its allocation "
"untouched. For now we'll only implement the \"basic\" full-range version."
msgstr ""

#: src/vec/vec-drain.md:12
msgid ""
"// Need to bound the lifetime here, so we do it with `&'a mut Vec<T>`\n"
"    // because that's semantically what we contain. We're \"just\" calling\n"
"    // `pop()` and `remove(0)`.\n"
msgstr ""

#: src/vec/vec-drain.md:27
msgid ""
"\\-- wait, this is seeming familiar. Let's do some more compression. Both "
"IntoIter and Drain have the exact same structure, let's just factor it out."
msgstr ""

#: src/vec/vec-drain.md:38
msgid ""
"// unsafe to construct because it has no associated lifetimes.\n"
"    // This is necessary to store a RawValIter in the same struct as\n"
"    // its actual allocation. OK since it's a private implementation\n"
"    // detail.\n"
msgstr ""

#: src/vec/vec-drain.md:46
msgid ""
"// if `len = 0`, then this is not actually allocated memory.\n"
"                // Need to avoid offsetting because that will give wrong\n"
"                // information to LLVM via GEP.\n"
msgstr ""

#: src/vec/vec-drain.md:56
msgid "// Iterator and DoubleEndedIterator impls identical to IntoIter.\n"
msgstr ""

#: src/vec/vec-drain.md:60
msgid "And IntoIter becomes the following:"
msgstr ""

#: src/vec/vec-drain.md:104
msgid ""
"Note that I've left a few quirks in this design to make upgrading Drain to "
"work with arbitrary subranges a bit easier. In particular we _could_ have "
"RawValIter drain itself on drop, but that won't work right for a more "
"complex Drain. We also take a slice to simplify Drain initialization."
msgstr ""

#: src/vec/vec-drain.md:109
msgid "Alright, now Drain is really easy:"
msgstr ""

#: src/vec/vec-drain.md:140 src/vec/vec-final.md:165
msgid ""
"// this is a mem::forget safety thing. If Drain is forgotten, we just\n"
"        // leak the whole Vec's contents. Also we need to do this "
"*eventually*\n"
"        // anyway, so why not do it now?\n"
msgstr ""

#: src/vec/vec-drain.md:153
msgid ""
"For more details on the `mem::forget` problem, see the [section on leaks](../"
"leaking.html)."
msgstr ""

#: src/vec/vec-zsts.md:3
msgid ""
"It's time. We're going to fight the specter that is zero-sized types. Safe "
"Rust _never_ needs to care about this, but Vec is very intensive on raw "
"pointers and raw allocations, which are exactly the two things that care "
"about zero-sized types. We need to be careful of two things:"
msgstr ""

#: src/vec/vec-zsts.md:8
msgid ""
"The raw allocator API has undefined behavior if you pass in 0 for an "
"allocation size."
msgstr ""

#: src/vec/vec-zsts.md:10
msgid ""
"raw pointer offsets are no-ops for zero-sized types, which will break our C-"
"style pointer iterator."
msgstr ""

#: src/vec/vec-zsts.md:13
msgid ""
"Thankfully we abstracted out pointer-iterators and allocating handling into "
"`RawValIter` and `RawVec` respectively. How mysteriously convenient."
msgstr ""

#: src/vec/vec-zsts.md:16
msgid "Allocating Zero-Sized Types"
msgstr ""

#: src/vec/vec-zsts.md:18
msgid ""
"So if the allocator API doesn't support zero-sized allocations, what on "
"earth do we store as our allocation? `NonNull::dangling()` of course! Almost "
"every operation with a ZST is a no-op since ZSTs have exactly one value, and "
"therefore no state needs to be considered to store or load them. This "
"actually extends to `ptr::read` and `ptr::write`: they won't actually look "
"at the pointer at all. As such we never need to change the pointer."
msgstr ""

#: src/vec/vec-zsts.md:25
msgid ""
"Note however that our previous reliance on running out of memory before "
"overflow is no longer valid with zero-sized types. We must explicitly guard "
"against capacity overflow for zero-sized types."
msgstr ""

#: src/vec/vec-zsts.md:29
msgid ""
"Due to our current architecture, all this means is writing 3 guards, one in "
"each method of `RawVec`."
msgstr ""

#: src/vec/vec-zsts.md:36
msgid "// This branch should be stripped at compile time.\n"
msgstr ""

#: src/vec/vec-zsts.md:39 src/vec/vec-final.md:23
msgid ""
"// `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized "
"allocation\"\n"
msgstr ""

#: src/vec/vec-zsts.md:47 src/vec/vec-final.md:31
msgid ""
"// since we set the capacity to usize::MAX when T has size 0,\n"
"        // getting to here necessarily means the Vec is overfull.\n"
msgstr ""

#: src/vec/vec-zsts.md:49 src/vec/vec-final.md:33
msgid "\"capacity overflow\""
msgstr ""

#: src/vec/vec-zsts.md:100
msgid ""
"That's it. We support pushing and popping zero-sized types now. Our "
"iterators (that aren't provided by slice Deref) are still busted, though."
msgstr ""

#: src/vec/vec-zsts.md:103
msgid "Iterating Zero-Sized Types"
msgstr ""

#: src/vec/vec-zsts.md:105
msgid ""
"Zero-sized offsets are no-ops. This means that our current design will "
"always initialize `start` and `end` as the same value, and our iterators "
"will yield nothing. The current solution to this is to cast the pointers to "
"integers, increment, and then cast them back:"
msgstr ""

#: src/vec/vec-zsts.md:128
msgid ""
"Now we have a different bug. Instead of our iterators not running at all, "
"our iterators now run _forever_. We need to do the same trick in our "
"iterator impls. Also, our size_hint computation code will divide by 0 for "
"ZSTs. Since we'll basically be treating the two pointers as if they point to "
"bytes, we'll just map size 0 to divide by 1. Here's what `next` will be:"
msgstr ""

#: src/vec/vec-zsts.md:153
msgid ""
"Do you see the \"bug\"? No one else did! The original author only noticed "
"the problem when linking to this page years later. This code is kind of "
"dubious because abusing the iterator pointers to be _counters_ makes them "
"unaligned! Our _one job_ when using ZSTs is to keep pointers aligned! "
"_forehead slap_"
msgstr ""

#: src/vec/vec-zsts.md:158
msgid ""
"Raw pointers don't need to be aligned at all times, so the basic trick of "
"using pointers as counters is _fine_, but they _should_ definitely be "
"aligned when passed to `ptr::read`! This is _possibly_ needless pedantry "
"because `ptr::read` is a noop for a ZST, but let's be a _little_ more "
"responsible and read from `NonNull::dangling` on the ZST path."
msgstr ""

#: src/vec/vec-zsts.md:164
msgid ""
"(Alternatively you could call `read_unaligned` on the ZST path. Either is "
"fine, because either way we're making up a value from nothing and it all "
"compiles to doing nothing.)"
msgstr ""

#: src/vec/vec-zsts.md:216
msgid "And that's it. Iteration works!"
msgstr ""

#: src/vec/vec-final.md:1
msgid "The Final Code"
msgstr ""

#: src/vec/vec-final.md:20
msgid "// !0 is usize::MAX. This branch should be stripped at compile time.\n"
msgstr ""

#: src/vec/vec-final.md:115
msgid "// Can't overflow, we'll OOM first.\n"
msgstr ""

#: src/vec/vec-final.md:329
msgid "// pre-drain the iter\n"
msgstr ""

#: src/vec/vec-final.md:339
msgid "\"All tests finished OK\""
msgstr ""

#: src/arc-mutex/arc-and-mutex.md:3
msgid ""
"Knowing the theory is all fine and good, but the _best_ way to understand "
"something is to use it. To better understand atomics and interior "
"mutability, we'll be implementing versions of the standard library's `Arc` "
"and `Mutex` types."
msgstr ""

#: src/arc-mutex/arc-and-mutex.md:7
msgid "TODO: Write `Mutex` chapters."
msgstr ""

#: src/arc-mutex/arc.md:1
msgid "Implementing Arc"
msgstr ""

#: src/arc-mutex/arc.md:3
msgid ""
"In this section, we'll be implementing a simpler version of "
"`std::sync::Arc`. Similarly to [the implementation of `Vec` we made earlier]"
"(../vec/vec.md), we won't be taking advantage of as many optimizations, "
"intrinsics, or unstable code as the standard library may."
msgstr ""

#: src/arc-mutex/arc.md:8
msgid ""
"This implementation is loosely based on the standard library's "
"implementation (technically taken from `alloc::sync` in 1.49, as that's "
"where it's actually implemented), but it will not support weak references at "
"the moment as they make the implementation slightly more complex."
msgstr ""

#: src/arc-mutex/arc.md:13
msgid "Please note that this section is very work-in-progress at the moment."
msgstr ""

#: src/arc-mutex/arc-layout.md:3
msgid "Let's start by making the layout for our implementation of `Arc`."
msgstr ""

#: src/arc-mutex/arc-layout.md:5
msgid ""
"An `Arc<T>` provides thread-safe shared ownership of a value of type `T`, "
"allocated in the heap. Sharing implies immutability in Rust, so we don't "
"need to design anything that manages access to that value, right? Although "
"interior mutability types like Mutex allow Arc's users to create shared "
"mutability, Arc itself doesn't need to concern itself with these issues."
msgstr ""

#: src/arc-mutex/arc-layout.md:11
msgid ""
"However there _is_ one place where Arc needs to concern itself with "
"mutation: destruction. When all the owners of the Arc go away, we need to be "
"able to `drop` its contents and free its allocation. So we need a way for an "
"owner to know if it's the _last_ owner, and the simplest way to do that is "
"with a count of the owners -- Reference Counting."
msgstr ""

#: src/arc-mutex/arc-layout.md:17
msgid ""
"Unfortunately, this reference count is inherently shared mutable state, so "
"Arc _does_ need to think about synchronization. We _could_ use a Mutex for "
"this, but that's overkill. Instead, we'll use atomics. And since everyone "
"already needs a pointer to the T's allocation, we might as well put the "
"reference count in that same allocation."
msgstr ""

#: src/arc-mutex/arc-layout.md:23
msgid "Naively, it would look something like this:"
msgstr ""

#: src/arc-mutex/arc-layout.md:38
msgid ""
"This would compile, however it would be incorrect. First of all, the "
"compiler will give us too strict variance. For example, an `Arc<&'static "
"str>` couldn't be used where an `Arc<&'a str>` was expected. More "
"importantly, it will give incorrect ownership information to the drop "
"checker, as it will assume we don't own any values of type `T`. As this is a "
"structure providing shared ownership of a value, at some point there will be "
"an instance of this structure that entirely owns its data. See [the chapter "
"on ownership and lifetimes](../ownership.md) for all the details on variance "
"and drop check."
msgstr ""

#: src/arc-mutex/arc-layout.md:47
msgid ""
"To fix the first problem, we can use `NonNull<T>`. Note that `NonNull<T>` is "
"a wrapper around a raw pointer that declares that:"
msgstr ""

#: src/arc-mutex/arc-layout.md:51
msgid "Our pointer is never null"
msgstr ""

#: src/arc-mutex/arc-layout.md:53
msgid ""
"To fix the second problem, we can include a `PhantomData` marker containing "
"an `ArcInner<T>`. This will tell the drop checker that we have some notion "
"of ownership of a value of `ArcInner<T>` (which itself contains some `T`)."
msgstr ""

#: src/arc-mutex/arc-layout.md:57
msgid "With these changes we get our final structure:"
msgstr ""

#: src/arc-mutex/arc-base.md:3
msgid ""
"Now that we've decided the layout for our implementation of `Arc`, let's "
"create some basic code."
msgstr ""

#: src/arc-mutex/arc-base.md:6
msgid "Constructing the Arc"
msgstr ""

#: src/arc-mutex/arc-base.md:8
msgid "We'll first need a way to construct an `Arc<T>`."
msgstr ""

#: src/arc-mutex/arc-base.md:10
msgid ""
"This is pretty simple, as we just need to box the `ArcInner<T>` and get a "
"`NonNull<T>` pointer to it."
msgstr ""

#: src/arc-mutex/arc-base.md:17 src/arc-mutex/arc-base.md:119
#: src/arc-mutex/arc-final.md:23
msgid ""
"// We start the reference count at 1, as that first reference is the\n"
"        // current pointer.\n"
msgstr ""

#: src/arc-mutex/arc-base.md:24 src/arc-mutex/arc-base.md:126
#: src/arc-mutex/arc-final.md:30
msgid ""
"// It is okay to call `.unwrap()` here as we get a pointer from\n"
"            // `Box::into_raw` which is guaranteed to not be null.\n"
msgstr ""

#: src/arc-mutex/arc-base.md:35
msgid ""
"Since we're building a concurrency primitive, we'll need to be able to send "
"it across threads. Thus, we can implement the `Send` and `Sync` marker "
"traits. For more information on these, see [the section on `Send` and `Sync`]"
"(../send-and-sync.md)."
msgstr ""

#: src/arc-mutex/arc-base.md:40
msgid "This is okay because:"
msgstr ""

#: src/arc-mutex/arc-base.md:41
msgid ""
"You can only get a mutable reference to the value inside an `Arc` if and "
"only if it is the only `Arc` referencing that data (which only happens in "
"`Drop`)"
msgstr ""

#: src/arc-mutex/arc-base.md:43
msgid "We use atomics for the shared mutable reference counting"
msgstr ""

#: src/arc-mutex/arc-base.md:51
msgid ""
"We need to have the bound `T: Sync + Send` because if we did not provide "
"those bounds, it would be possible to share values that are thread-unsafe "
"across a thread boundary via an `Arc`, which could possibly cause data races "
"or unsoundness."
msgstr ""

#: src/arc-mutex/arc-base.md:56
msgid ""
"For example, if those bounds were not present, `Arc<Rc<u32>>` would be "
"`Sync` or `Send`, meaning that you could clone the `Rc` out of the `Arc` to "
"send it across a thread (without creating an entirely new `Rc`), which would "
"create data races as `Rc` is not thread-safe."
msgstr ""

#: src/arc-mutex/arc-base.md:61
msgid "Getting the `ArcInner`"
msgstr ""

#: src/arc-mutex/arc-base.md:63
msgid ""
"To dereference the `NonNull<T>` pointer into a `&T`, we can call "
"`NonNull::as_ref`. This is unsafe, unlike the typical `as_ref` function, so "
"we must call it like this:"
msgstr ""

#: src/arc-mutex/arc-base.md:72
msgid ""
"We'll be using this snippet a few times in this code (usually with an "
"associated `let` binding)."
msgstr ""

#: src/arc-mutex/arc-base.md:75
msgid ""
"This unsafety is okay because while this `Arc` is alive, we're guaranteed "
"that the inner pointer is valid."
msgstr ""

#: src/arc-mutex/arc-base.md:80
msgid ""
"Alright. Now we can make `Arc`s (and soon will be able to clone and destroy "
"them correctly), but how do we get to the data inside?"
msgstr ""

#: src/arc-mutex/arc-base.md:83
msgid "What we need now is an implementation of `Deref`."
msgstr ""

#: src/arc-mutex/arc-base.md:85
msgid "We'll need to import the trait:"
msgstr ""

#: src/arc-mutex/arc-base.md:92
msgid "And here's the implementation:"
msgstr ""

#: src/arc-mutex/arc-base.md:106
msgid ""
"Pretty simple, eh? This simply dereferences the `NonNull` pointer to the "
"`ArcInner<T>`, then gets a reference to the data inside."
msgstr ""

#: src/arc-mutex/arc-base.md:109
msgid "Code"
msgstr ""

#: src/arc-mutex/arc-base.md:111
msgid "Here's all the code from this section:"
msgstr ""

#: src/arc-mutex/arc-clone.md:3
msgid ""
"Now that we've got some basic code set up, we'll need a way to clone the "
"`Arc`."
msgstr ""

#: src/arc-mutex/arc-clone.md:5 src/arc-mutex/arc-drop.md:8
msgid "Basically, we need to:"
msgstr ""

#: src/arc-mutex/arc-clone.md:7
msgid "Increment the atomic reference count"
msgstr ""

#: src/arc-mutex/arc-clone.md:8
msgid "Construct a new instance of the `Arc` from the inner pointer"
msgstr ""

#: src/arc-mutex/arc-clone.md:10
msgid "First, we need to get access to the `ArcInner`:"
msgstr ""

#: src/arc-mutex/arc-clone.md:17
msgid "We can update the atomic reference count as follows:"
msgstr ""

#: src/arc-mutex/arc-clone.md:24
msgid ""
"But what ordering should we use here? We don't really have any code that "
"will need atomic synchronization when cloning, as we do not modify the "
"internal value while cloning. Thus, we can use a Relaxed ordering here, "
"which implies no happens-before relationship but is atomic. When `Drop`ping "
"the Arc, however, we'll need to atomically synchronize when decrementing the "
"reference count. This is described more in [the section on the `Drop` "
"implementation for `Arc`](arc-drop.md). For more information on atomic "
"relationships and Relaxed ordering, see [the section on atomics](../"
"atomics.md)."
msgstr ""

#: src/arc-mutex/arc-clone.md:33
msgid "Thus, the code becomes this:"
msgstr ""

#: src/arc-mutex/arc-clone.md:40
msgid "We'll need to add another import to use `Ordering`:"
msgstr ""

#: src/arc-mutex/arc-clone.md:46
msgid ""
"However, we have one problem with this implementation right now. What if "
"someone decides to `mem::forget` a bunch of Arcs? The code we have written "
"so far (and will write) assumes that the reference count accurately portrays "
"how many Arcs are in memory, but with `mem::forget` this is false. Thus, "
"when more and more Arcs are cloned from this one without them being "
"`Drop`ped and the reference count being decremented, we can overflow! This "
"will cause use-after-free which is **INCREDIBLY BAD!**"
msgstr ""

#: src/arc-mutex/arc-clone.md:54
msgid ""
"To handle this, we need to check that the reference count does not go over "
"some arbitrary value (below `usize::MAX`, as we're storing the reference "
"count as an `AtomicUsize`), and do _something_."
msgstr ""

#: src/arc-mutex/arc-clone.md:58
msgid ""
"The standard library's implementation decides to just abort the program (as "
"it is an incredibly unlikely case in normal code and if it happens, the "
"program is probably incredibly degenerate) if the reference count reaches "
"`isize::MAX` (about half of `usize::MAX`) on any thread, on the assumption "
"that there are probably not about 2 billion threads (or about **9 "
"quintillion** on some 64-bit machines) incrementing the reference count at "
"once. This is what we'll do."
msgstr ""

#: src/arc-mutex/arc-clone.md:65
msgid "It's pretty simple to implement this behavior:"
msgstr ""

#: src/arc-mutex/arc-clone.md:74
msgid "Then, we need to return a new instance of the `Arc`:"
msgstr ""

#: src/arc-mutex/arc-clone.md:84
msgid "Now, let's wrap this all up inside the `Clone` implementation:"
msgstr ""

#: src/arc-mutex/arc-clone.md:93 src/arc-mutex/arc-final.md:53
msgid ""
"// Using a relaxed ordering is alright here as we don't need any atomic\n"
"        // synchronization here as we're not modifying or accessing the "
"inner\n"
"        // data.\n"
msgstr ""

#: src/arc-mutex/arc-drop.md:3
msgid ""
"We now need a way to decrease the reference count and drop the data once it "
"is low enough, otherwise the data will live forever on the heap."
msgstr ""

#: src/arc-mutex/arc-drop.md:6
msgid "To do this, we can implement `Drop`."
msgstr ""

#: src/arc-mutex/arc-drop.md:10
msgid "Decrement the reference count"
msgstr ""

#: src/arc-mutex/arc-drop.md:11
msgid "If there is only one reference remaining to the data, then:"
msgstr ""

#: src/arc-mutex/arc-drop.md:12
msgid ""
"Atomically fence the data to prevent reordering of the use and deletion of "
"the data"
msgstr ""

#: src/arc-mutex/arc-drop.md:14
msgid "Drop the inner data"
msgstr ""

#: src/arc-mutex/arc-drop.md:16
msgid "First, we'll need to get access to the `ArcInner`:"
msgstr ""

#: src/arc-mutex/arc-drop.md:23
msgid ""
"Now, we need to decrement the reference count. To streamline our code, we "
"can also return if the returned value from `fetch_sub` (the value of the "
"reference count before decrementing it) is not equal to `1` (which happens "
"when we are not the last reference to the data)."
msgstr ""

#: src/arc-mutex/arc-drop.md:35
msgid ""
"We then need to create an atomic fence to prevent reordering of the use of "
"the data and deletion of the data. As described in [the standard library's "
"implementation of `Arc`](https://github.com/rust-lang/rust/blob/"
"e1884a8e3c3e813aada8254edfa120e85bf5ffca/library/alloc/src/sync.rs#L1440-"
"L1467):"
msgstr ""

#: src/arc-mutex/arc-drop.md:38
msgid ""
"This fence is needed to prevent reordering of use of the data and deletion "
"of the data. Because it is marked `Release`, the decreasing of the reference "
"count synchronizes with this `Acquire` fence. This means that use of the "
"data happens before decreasing the reference count, which happens before "
"this fence, which happens before the deletion of the data."
msgstr ""

#: src/arc-mutex/arc-drop.md:44
msgid ""
"As explained in the [Boost documentation](https://www.boost.org/doc/libs/"
"1_55_0/doc/html/atomic/usage_examples.html),"
msgstr ""

#: src/arc-mutex/arc-drop.md:46
msgid ""
"It is important to enforce any possible access to the object in one thread "
"(through an existing reference) to _happen before_ deleting the object in a "
"different thread. This is achieved by a \"release\" operation after dropping "
"a reference (any access to the object through this reference must obviously "
"happened before), and an \"acquire\" operation before deleting the object."
msgstr ""

#: src/arc-mutex/arc-drop.md:53
msgid ""
"In particular, while the contents of an Arc are usually immutable, it's "
"possible to have interior writes to something like a `Mutex<T>`. Since a "
"Mutex is not acquired when it is deleted, we can't rely on its "
"synchronization logic to make writes in thread A visible to a destructor "
"running in thread B."
msgstr ""

#: src/arc-mutex/arc-drop.md:58
msgid ""
"Also note that the Acquire fence here could probably be replaced with an "
"Acquire load, which could improve performance in highly-contended "
"situations. See [2](https://github.com/rust-lang/rust/pull/41714)."
msgstr ""

#: src/arc-mutex/arc-drop.md:66
msgid "To do this, we do the following:"
msgstr ""

#: src/arc-mutex/arc-drop.md:74
msgid ""
"Finally, we can drop the data itself. We use `Box::from_raw` to drop the "
"boxed `ArcInner<T>` and its data. This takes a `*mut T` and not a "
"`NonNull<T>`, so we must convert using `NonNull::as_ptr`."
msgstr ""

#: src/arc-mutex/arc-drop.md:83
msgid ""
"This is safe as we know we have the last pointer to the `ArcInner` and that "
"its pointer is valid."
msgstr ""

#: src/arc-mutex/arc-drop.md:86
msgid "Now, let's wrap this all up inside the `Drop` implementation:"
msgstr ""

#: src/arc-mutex/arc-drop.md:96 src/arc-mutex/arc-final.md:75
msgid ""
"// This fence is needed to prevent reordering of the use and deletion\n"
"        // of the data.\n"
msgstr ""

#: src/arc-mutex/arc-drop.md:99 src/arc-mutex/arc-final.md:78
msgid ""
"// This is safe as we know we have the last pointer to the `ArcInner`\n"
"        // and that its pointer is valid.\n"
msgstr ""

#: src/arc-mutex/arc-final.md:3
msgid "Here's the final code, with some added comments and re-ordered imports:"
msgstr ""

#: src/ffi.md:1
msgid "Foreign Function Interface"
msgstr ""

#: src/ffi.md:5
msgid ""
"This guide will use the [snappy](https://github.com/google/snappy) "
"compression/decompression library as an introduction to writing bindings for "
"foreign code. Rust is currently unable to call directly into a C++ library, "
"but snappy includes a C interface (documented in [`snappy-c.h`](https://"
"github.com/google/snappy/blob/master/snappy-c.h))."
msgstr ""

#: src/ffi.md:11
msgid "A note about libc"
msgstr ""

#: src/ffi.md:13
msgid ""
"Many of these examples use [the `libc` crate](https://crates.io/crates/"
"libc), which provides various type definitions for C types, among other "
"things. If you’re trying these examples yourself, you’ll need to add `libc` "
"to your `Cargo.toml`:"
msgstr ""

#: src/ffi.md:17
msgid ""
"```toml\n"
"[dependencies]\n"
"libc = \"0.2.0\"\n"
"```"
msgstr ""

#: src/ffi.md:24
msgid "Calling foreign functions"
msgstr ""

#: src/ffi.md:26
msgid ""
"The following is a minimal example of calling a foreign function which will "
"compile if snappy is installed:"
msgstr ""

#: src/ffi.md:33 src/ffi.md:66
msgid "\"snappy\""
msgstr ""

#: src/ffi.md:40
msgid "\"max compressed length of a 100 byte buffer: {}\""
msgstr ""

#: src/ffi.md:44
msgid ""
"The `extern` block is a list of function signatures in a foreign library, in "
"this case with the platform's C ABI. The `#[link(...)]` attribute is used to "
"instruct the linker to link against the snappy library so the symbols are "
"resolved."
msgstr ""

#: src/ffi.md:49
msgid ""
"Foreign functions are assumed to be unsafe so calls to them need to be "
"wrapped with `unsafe {}` as a promise to the compiler that everything "
"contained within truly is safe. C libraries often expose interfaces that "
"aren't thread-safe, and almost any function that takes a pointer argument "
"isn't valid for all possible inputs since the pointer could be dangling, and "
"raw pointers fall outside of Rust's safe memory model."
msgstr ""

#: src/ffi.md:56
msgid ""
"When declaring the argument types to a foreign function, the Rust compiler "
"cannot check if the declaration is correct, so specifying it correctly is "
"part of keeping the binding correct at runtime."
msgstr ""

#: src/ffi.md:60
msgid "The `extern` block can be extended to cover the entire snappy API:"
msgstr ""

#: src/ffi.md:86
msgid "Creating a safe interface"
msgstr ""

#: src/ffi.md:88
msgid ""
"The raw C API needs to be wrapped to provide memory safety and make use of "
"higher-level concepts like vectors. A library can choose to expose only the "
"safe, high-level interface and hide the unsafe internal details."
msgstr ""

#: src/ffi.md:92
msgid ""
"Wrapping the functions which expect buffers involves using the `slice::raw` "
"module to manipulate Rust vectors as pointers to memory. Rust's vectors are "
"guaranteed to be a contiguous block of memory. The length is the number of "
"elements currently contained, and the capacity is the total size in elements "
"of the allocated memory. The length is less than or equal to the capacity."
msgstr ""

#: src/ffi.md:109
msgid ""
"The `validate_compressed_buffer` wrapper above makes use of an `unsafe` "
"block, but it makes the guarantee that calling it is safe for all inputs by "
"leaving off `unsafe` from the function signature."
msgstr ""

#: src/ffi.md:113
msgid ""
"The `snappy_compress` and `snappy_uncompress` functions are more complex, "
"since a buffer has to be allocated to hold the output too."
msgstr ""

#: src/ffi.md:116
msgid ""
"The `snappy_max_compressed_length` function can be used to allocate a vector "
"with the maximum required capacity to hold the compressed output. The vector "
"can then be passed to the `snappy_compress` function as an output parameter. "
"An output parameter is also passed to retrieve the true length after "
"compression for setting the length."
msgstr ""

#: src/ffi.md:144
msgid ""
"Decompression is similar, because snappy stores the uncompressed size as "
"part of the compression format and `snappy_uncompressed_length` will "
"retrieve the exact buffer size required."
msgstr ""

#: src/ffi.md:173
msgid "// SNAPPY_INVALID_INPUT\n"
msgstr ""

#: src/ffi.md:179
msgid "Then, we can add some tests to show how to use them."
msgstr ""

#: src/ffi.md:237
msgid ""
"Foreign libraries often hand off ownership of resources to the calling code. "
"When this occurs, we must use Rust's destructors to provide safety and "
"guarantee the release of these resources (especially in the case of panic)."
msgstr ""

#: src/ffi.md:241
msgid ""
"For more about destructors, see the [Drop trait](../std/ops/trait.Drop.html)."
msgstr ""

#: src/ffi.md:243
msgid "Calling Rust code from C"
msgstr ""

#: src/ffi.md:245
msgid ""
"You may wish to compile Rust code in a way so that it can be called from C. "
"This is fairly easy, but requires a few things."
msgstr ""

#: src/ffi.md:248
msgid "Rust side"
msgstr ""

#: src/ffi.md:250
msgid ""
"First, we assume you have a lib crate named as `rust_from_c`. `lib.rs` "
"should have Rust code as following:"
msgstr ""

#: src/ffi.md:256
msgid "\"Hello from Rust!\""
msgstr ""

#: src/ffi.md:261
msgid ""
"The `extern \"C\"` makes this function adhere to the C calling convention, "
"as discussed below in \"[Foreign Calling Conventions](ffi.md#foreign-calling-"
"conventions)\". The `no_mangle` attribute turns off Rust's name mangling, so "
"that it has a well defined symbol to link to."
msgstr ""

#: src/ffi.md:264
msgid ""
"Then, to compile Rust code as a shared library that can be called from C, "
"add the following to your `Cargo.toml`:"
msgstr ""

#: src/ffi.md:266
msgid ""
"```toml\n"
"[lib]\n"
"crate-type = [\"cdylib\"]\n"
"```"
msgstr ""

#: src/ffi.md:271
msgid ""
"(NOTE: We could also use the `staticlib` crate type but it needs to tweak "
"some linking flags.)"
msgstr ""

#: src/ffi.md:273
msgid "Run `cargo build` and you're ready to go on the Rust side."
msgstr ""

#: src/ffi.md:277
msgid "C side"
msgstr ""

#: src/ffi.md:279
msgid ""
"We'll create a C file to call the `hello_from_rust` function and compile it "
"by `gcc`."
msgstr ""

#: src/ffi.md:281
msgid "C file should look like:"
msgstr ""

#: src/ffi.md:292
msgid ""
"We name the file as `call_rust.c` and place it on the crate root. Run the "
"following to compile:"
msgstr ""

#: src/ffi.md:299
msgid "`-l` and `-L` tell gcc to find our Rust library."
msgstr ""

#: src/ffi.md:301
msgid "Finally, we can call Rust code from C with `LD_LIBRARY_PATH` specified:"
msgstr ""

#: src/ffi.md:308
msgid ""
"That's it! For more realistic example, check the [`cbindgen`](https://"
"github.com/eqrion/cbindgen)."
msgstr ""

#: src/ffi.md:313
msgid "Callbacks from C code to Rust functions"
msgstr ""

#: src/ffi.md:315
msgid ""
"Some external libraries require the usage of callbacks to report back their "
"current state or intermediate data to the caller. It is possible to pass "
"functions defined in Rust to an external library. The requirement for this "
"is that the callback function is marked as `extern` with the correct calling "
"convention to make it callable from C code."
msgstr ""

#: src/ffi.md:321
msgid ""
"The callback function can then be sent through a registration call to the C "
"library and afterwards be invoked from there."
msgstr ""

#: src/ffi.md:324
msgid "A basic example is:"
msgstr ""

#: src/ffi.md:326 src/ffi.md:378
msgid "Rust code:"
msgstr ""

#: src/ffi.md:330 src/ffi.md:387
msgid "\"I'm called from C with value {0}\""
msgstr ""

#: src/ffi.md:333 src/ffi.md:394
msgid "\"extlib\""
msgstr ""

#: src/ffi.md:342
msgid "// Triggers the callback.\n"
msgstr ""

#: src/ffi.md:347 src/ffi.md:412
msgid "C code:"
msgstr ""

#: src/ffi.md:359
msgid "// Will call callback(7) in Rust.\n"
msgstr ""

#: src/ffi.md:363
msgid ""
"In this example Rust's `main()` will call `trigger_callback()` in C, which "
"would, in turn, call back to `callback()` in Rust."
msgstr ""

#: src/ffi.md:366
msgid "Targeting callbacks to Rust objects"
msgstr ""

#: src/ffi.md:368
msgid ""
"The former example showed how a global function can be called from C code. "
"However it is often desired that the callback is targeted to a special Rust "
"object. This could be the object that represents the wrapper for the "
"respective C object."
msgstr ""

#: src/ffi.md:373
msgid ""
"This can be achieved by passing a raw pointer to the object down to the C "
"library. The C library can then include the pointer to the Rust object in "
"the notification. This will allow the callback to unsafely access the "
"referenced Rust object."
msgstr ""

#: src/ffi.md:383
msgid "// Other members...\n"
msgstr ""

#: src/ffi.md:389
msgid ""
"// Update the value in RustObject with the value received from the "
"callback:\n"
msgstr ""

#: src/ffi.md:402
msgid "// Create the object that will be referenced in the callback:\n"
msgstr ""

#: src/ffi.md:426
msgid "// Will call callback(&rustObject, 7) in Rust.\n"
msgstr ""

#: src/ffi.md:430
msgid "Asynchronous callbacks"
msgstr ""

#: src/ffi.md:432
msgid ""
"In the previously given examples the callbacks are invoked as a direct "
"reaction to a function call to the external C library. The control over the "
"current thread is switched from Rust to C to Rust for the execution of the "
"callback, but in the end the callback is executed on the same thread that "
"called the function which triggered the callback."
msgstr ""

#: src/ffi.md:438
msgid ""
"Things get more complicated when the external library spawns its own threads "
"and invokes callbacks from there. In these cases access to Rust data "
"structures inside the callbacks is especially unsafe and proper "
"synchronization mechanisms must be used. Besides classical synchronization "
"mechanisms like mutexes, one possibility in Rust is to use channels (in "
"`std::sync::mpsc`) to forward data from the C thread that invoked the "
"callback into a Rust thread."
msgstr ""

#: src/ffi.md:446
msgid ""
"If an asynchronous callback targets a special object in the Rust address "
"space it is also absolutely necessary that no more callbacks are performed "
"by the C library after the respective Rust object gets destroyed. This can "
"be achieved by unregistering the callback in the object's destructor and "
"designing the library in a way that guarantees that no callback will be "
"performed after deregistration."
msgstr ""

#: src/ffi.md:453
msgid "Linking"
msgstr ""

#: src/ffi.md:455
msgid ""
"The `link` attribute on `extern` blocks provides the basic building block "
"for instructing rustc how it will link to native libraries. There are two "
"accepted forms of the link attribute today:"
msgstr ""

#: src/ffi.md:459
msgid "`#[link(name = \"foo\")]`"
msgstr ""

#: src/ffi.md:460
msgid "`#[link(name = \"foo\", kind = \"bar\")]`"
msgstr ""

#: src/ffi.md:462
msgid ""
"In both of these cases, `foo` is the name of the native library that we're "
"linking to, and in the second case `bar` is the type of native library that "
"the compiler is linking to. There are currently three known types of native "
"libraries:"
msgstr ""

#: src/ffi.md:467
msgid "Dynamic - `#[link(name = \"readline\")]`"
msgstr ""

#: src/ffi.md:468
msgid "Static - `#[link(name = \"my_build_dependency\", kind = \"static\")]`"
msgstr ""

#: src/ffi.md:469
msgid "Frameworks - `#[link(name = \"CoreFoundation\", kind = \"framework\")]`"
msgstr ""

#: src/ffi.md:471
msgid "Note that frameworks are only available on macOS targets."
msgstr ""

#: src/ffi.md:473
msgid ""
"The different `kind` values are meant to differentiate how the native "
"library participates in linkage. From a linkage perspective, the Rust "
"compiler creates two flavors of artifacts: partial (rlib/staticlib) and "
"final (dylib/binary). Native dynamic library and framework dependencies are "
"propagated to the final artifact boundary, while static library dependencies "
"are not propagated at all, because the static libraries are integrated "
"directly into the subsequent artifact."
msgstr ""

#: src/ffi.md:481
msgid "A few examples of how this model can be used are:"
msgstr ""

#: src/ffi.md:483
msgid ""
"A native build dependency. Sometimes some C/C++ glue is needed when writing "
"some Rust code, but distribution of the C/C++ code in a library format is a "
"burden. In this case, the code will be archived into `libfoo.a` and then the "
"Rust crate would declare a dependency via `#[link(name = \"foo\", kind = "
"\"static\")]`."
msgstr ""

#: src/ffi.md:489
msgid ""
"Regardless of the flavor of output for the crate, the native static library "
"will be included in the output, meaning that distribution of the native "
"static library is not necessary."
msgstr ""

#: src/ffi.md:493
msgid ""
"A normal dynamic dependency. Common system libraries (like `readline`) are "
"available on a large number of systems, and often a static copy of these "
"libraries cannot be found. When this dependency is included in a Rust crate, "
"partial targets (like rlibs) will not link to the library, but when the rlib "
"is included in a final target (like a binary), the native library will be "
"linked in."
msgstr ""

#: src/ffi.md:500
msgid ""
"On macOS, frameworks behave with the same semantics as a dynamic library."
msgstr ""

#: src/ffi.md:502
msgid "Unsafe blocks"
msgstr ""

#: src/ffi.md:504
msgid ""
"Some operations, like dereferencing raw pointers or calling functions that "
"have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks "
"isolate unsafety and are a promise to the compiler that the unsafety does "
"not leak out of the block."
msgstr ""

#: src/ffi.md:508
msgid ""
"Unsafe functions, on the other hand, advertise it to the world. An unsafe "
"function is written like this:"
msgstr ""

#: src/ffi.md:515
msgid ""
"This function can only be called from an `unsafe` block or another `unsafe` "
"function."
msgstr ""

#: src/ffi.md:517
msgid "Accessing foreign globals"
msgstr ""

#: src/ffi.md:519
msgid ""
"Foreign APIs often export a global variable which could do something like "
"track global state. In order to access these variables, you declare them in "
"`extern` blocks with the `static` keyword:"
msgstr ""

#: src/ffi.md:525 src/ffi.md:545
msgid "\"readline\""
msgstr ""

#: src/ffi.md:531
msgid "\"You have readline version {} installed.\""
msgstr ""

#: src/ffi.md:536
msgid ""
"Alternatively, you may need to alter global state provided by a foreign "
"interface. To do this, statics can be declared with `mut` so we can mutate "
"them."
msgstr ""

#: src/ffi.md:551
msgid "\"[my-awesome-shell] $\""
msgstr ""

#: src/ffi.md:562
msgid ""
"Note that all interaction with a `static mut` is unsafe, both reading and "
"writing. Dealing with global mutable state requires a great deal of care."
msgstr ""

#: src/ffi.md:565
msgid "Foreign calling conventions"
msgstr ""

#: src/ffi.md:567
msgid ""
"Most foreign code exposes a C ABI, and Rust uses the platform's C calling "
"convention by default when calling foreign functions. Some foreign "
"functions, most notably the Windows API, use other calling conventions. Rust "
"provides a way to tell the compiler which convention to use:"
msgstr ""

#: src/ffi.md:573
msgid "\"win32\""
msgstr ""

#: src/ffi.md:573
msgid "\"x86\""
msgstr ""

#: src/ffi.md:574
msgid "\"kernel32\""
msgstr ""

#: src/ffi.md:576
msgid "\"stdcall\""
msgstr ""

#: src/ffi.md:582
msgid ""
"This applies to the entire `extern` block. The list of supported ABI "
"constraints are:"
msgstr ""

#: src/ffi.md:585
msgid "`stdcall`"
msgstr ""

#: src/ffi.md:586
msgid "`aapcs`"
msgstr ""

#: src/ffi.md:587
msgid "`cdecl`"
msgstr ""

#: src/ffi.md:588
msgid "`fastcall`"
msgstr ""

#: src/ffi.md:589
msgid "`thiscall`"
msgstr ""

#: src/ffi.md:590
msgid ""
"`vectorcall` This is currently hidden behind the `abi_vectorcall` gate and "
"is subject to change."
msgstr ""

#: src/ffi.md:592
msgid "`Rust`"
msgstr ""

#: src/ffi.md:593
msgid "`rust-intrinsic`"
msgstr ""

#: src/ffi.md:594
msgid "`system`"
msgstr ""

#: src/ffi.md:595
msgid "`C`"
msgstr ""

#: src/ffi.md:596
msgid "`win64`"
msgstr ""

#: src/ffi.md:597
msgid "`sysv64`"
msgstr ""

#: src/ffi.md:599
msgid ""
"Most of the abis in this list are self-explanatory, but the `system` abi may "
"seem a little odd. This constraint selects whatever the appropriate ABI is "
"for interoperating with the target's libraries. For example, on win32 with a "
"x86 architecture, this means that the abi used would be `stdcall`. On "
"x86_64, however, windows uses the `C` calling convention, so `C` would be "
"used. This means that in our previous example, we could have used `extern "
"\"system\" { ... }` to define a block for all windows systems, not only x86 "
"ones."
msgstr ""

#: src/ffi.md:607
msgid "Interoperability with foreign code"
msgstr ""

#: src/ffi.md:609
msgid ""
"Rust guarantees that the layout of a `struct` is compatible with the "
"platform's representation in C only if the `#[repr(C)]` attribute is applied "
"to it. `#[repr(C, packed)]` can be used to lay out struct members without "
"padding. `#[repr(C)]` can also be applied to an enum."
msgstr ""

#: src/ffi.md:614
msgid ""
"Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which "
"point to the contained object. However, they should not be manually created "
"because they are managed by internal allocators. References can safely be "
"assumed to be non-nullable pointers directly to the type.  However, breaking "
"the borrow checking or mutability rules is not guaranteed to be safe, so "
"prefer using raw pointers (`*`) if that's needed because the compiler can't "
"make as many assumptions about them."
msgstr ""

#: src/ffi.md:622
msgid ""
"Vectors and strings share the same basic memory layout, and utilities are "
"available in the `vec` and `str` modules for working with C APIs. However, "
"strings are not terminated with `\\0`. If you need a NUL-terminated string "
"for interoperability with C, you should use the `CString` type in the "
"`std::ffi` module."
msgstr ""

#: src/ffi.md:628
msgid ""
"The [`libc` crate on crates.io](https://crates.io/crates/libc) includes type "
"aliases and function definitions for the C standard library in the `libc` "
"module, and Rust links against `libc` and `libm` by default."
msgstr ""

#: src/ffi.md:632
msgid "Variadic functions"
msgstr ""

#: src/ffi.md:634
msgid ""
"In C, functions can be 'variadic', meaning they accept a variable number of "
"arguments. This can be achieved in Rust by specifying `...` within the "
"argument list of a foreign function declaration:"
msgstr ""

#: src/ffi.md:649
msgid "Normal Rust functions can _not_ be variadic:"
msgstr ""

#: src/ffi.md:652
msgid "// This will not compile\n"
msgstr ""

#: src/ffi.md:657
msgid "The \"nullable pointer optimization\""
msgstr ""

#: src/ffi.md:659
msgid ""
"Certain Rust types are defined to never be `null`. This includes references "
"(`&T`, `&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" "
"fn()`). When interfacing with C, pointers that might be `null` are often "
"used, which would seem to require some messy `transmute`s and/or unsafe code "
"to handle conversions to/from Rust types. However, trying to construct/work "
"with these invalid values **is undefined behavior**, so you should use the "
"following workaround instead."
msgstr ""

#: src/ffi.md:666
msgid ""
"As a special case, an `enum` is eligible for the \"nullable pointer "
"optimization\" if it contains exactly two variants, one of which contains no "
"data and the other contains a field of one of the non-nullable types listed "
"above.  This means no extra space is required for a discriminant; rather, "
"the empty variant is represented by putting a `null` value into the non-"
"nullable field. This is called an \"optimization\", but unlike other "
"optimizations it is guaranteed to apply to eligible types."
msgstr ""

#: src/ffi.md:673
msgid ""
"The most common type that takes advantage of the nullable pointer "
"optimization is `Option<T>`, where `None` corresponds to `null`. So "
"`Option<extern \"C\" fn(c_int) -> c_int>` is a correct way to represent a "
"nullable function pointer using the C ABI (corresponding to the C type `int "
"(*)(int)`)."
msgstr ""

#: src/ffi.md:678
msgid ""
"Here is a contrived example. Let's say some C library has a facility for "
"registering a callback, which gets called in certain situations. The "
"callback is passed a function pointer and an integer and it is supposed to "
"run the function with the integer as a parameter. So we have function "
"pointers flying across the FFI boundary in both directions."
msgstr ""

#: src/ffi.md:689
msgid "/// Registers the callback.\n"
msgstr ""

#: src/ffi.md:695
msgid ""
"/// This fairly useless function receives a function pointer and an integer\n"
"/// from C, and returns the result of calling the function with the "
"integer.\n"
"/// In case no function is provided, it squares the integer by default.\n"
msgstr ""

#: src/ffi.md:713
msgid "And the code on the C side looks like this:"
msgstr ""

#: src/ffi.md:721
msgid "No `transmute` required!"
msgstr ""

#: src/ffi.md:723
msgid "FFI and unwinding"
msgstr ""

#: src/ffi.md:725
msgid ""
"It’s important to be mindful of unwinding when working with FFI. Most ABI "
"strings come in two variants, one with an `-unwind` suffix and one without. "
"The `Rust` ABI always permits unwinding, so there is no `Rust-unwind` ABI."
msgstr ""

#: src/ffi.md:729
msgid ""
"If you expect Rust `panic`s or foreign (e.g. C++) exceptions to cross an FFI "
"boundary, that boundary must use the appropriate `-unwind` ABI string. "
"Conversely, if you do not expect unwinding to cross an ABI boundary, use one "
"of the non-`unwind` ABI strings."
msgstr ""

#: src/ffi.md:734
msgid ""
"Note: Compiling with `panic=abort` will still cause `panic!` to immediately "
"abort the process, regardless of which ABI is specified by the function that "
"`panic`s."
msgstr ""

#: src/ffi.md:738
msgid ""
"If an unwinding operation does encounter an ABI boundary that is not "
"permitted to unwind, the behavior depends on the source of the unwinding "
"(Rust `panic` or a foreign exception):"
msgstr ""

#: src/ffi.md:742
msgid "`panic` will cause the process to safely abort."
msgstr ""

#: src/ffi.md:743
msgid "A foreign exception entering Rust will cause undefined behavior."
msgstr ""

#: src/ffi.md:745
msgid ""
"Note that the interaction of `catch_unwind` with foreign exceptions **is "
"undefined**, as is the interaction of `panic` with foreign exception-"
"catching mechanisms (notably C++'s `try`/`catch`)."
msgstr ""

#: src/ffi.md:749
msgid "Rust `panic` with `\"C-unwind\"`"
msgstr ""

#: src/ffi.md:754 src/ffi.md:783 src/ffi.md:789
msgid "\"C-unwind\""
msgstr ""

#: src/ffi.md:755
msgid "\"Uh oh\""
msgstr ""

#: src/ffi.md:759
msgid ""
"This function (when compiled with `panic=unwind`) is permitted to unwind C++ "
"stack frames."
msgstr ""

#: src/ffi.md:776
msgid "If the C++ frames have objects, their destructors will be called."
msgstr ""

#: src/ffi.md:778
msgid "C++ `throw` with `\"C-unwind\"`"
msgstr ""

#: src/ffi.md:784
msgid "// A C++ function that may throw an exception\n"
msgstr ""

#: src/ffi.md:796
msgid ""
"A C++ function with a `try` block may invoke `rust_passthrough` and `catch` "
"an exception thrown by `may_throw`."
msgstr ""

#: src/ffi.md:813
msgid ""
"If `may_throw` does throw an exception, `b` will be dropped. Otherwise, `5` "
"will be printed."
msgstr ""

#: src/ffi.md:816
msgid "`panic` can be stopped at an ABI boundary"
msgstr ""

#: src/ffi.md:825
msgid ""
"If `assert_nonzero` is called with the argument `0`, the runtime is "
"guaranteed to (safely) abort the process, whether or not compiled with "
"`panic=abort`."
msgstr ""

#: src/ffi.md:828
msgid "Catching `panic` preemptively"
msgstr ""

#: src/ffi.md:830
msgid ""
"If you are writing Rust code that may panic, and you don't wish to abort the "
"process if it panics, you must use [`catch_unwind`](../std/panic/"
"fn.catch_unwind.html):"
msgstr ""

#: src/ffi.md:839
msgid "\"Oops!\""
msgstr ""

#: src/ffi.md:850
msgid ""
"Please note that [`catch_unwind`](../std/panic/fn.catch_unwind.html) will "
"only catch unwinding panics, not those that abort the process. See the "
"documentation of [`catch_unwind`](../std/panic/fn.catch_unwind.html) for "
"more information."
msgstr ""

#: src/ffi.md:856
msgid "Representing opaque structs"
msgstr ""

#: src/ffi.md:858
msgid ""
"Sometimes, a C library wants to provide a pointer to something, but not let "
"you know the internal details of the thing it wants. A stable and simple way "
"is to use a `void *` argument:"
msgstr ""

#: src/ffi.md:866
msgid "We can represent this in Rust with the `c_void` type:"
msgstr ""

#: src/ffi.md:877
msgid ""
"This is a perfectly valid way of handling the situation. However, we can do "
"a bit better. To solve this, some C libraries will instead create a "
"`struct`, where the details and memory layout of the struct are private. "
"This gives some amount of type safety. These structures are called ‘opaque’. "
"Here’s an example, in C:"
msgstr ""

#: src/ffi.md:883
msgid ""
"/* Foo is a structure, but its contents are not part of the public interface "
"*/"
msgstr ""

#: src/ffi.md:889
msgid "To do this in Rust, let’s create our own opaque types:"
msgstr ""

#: src/ffi.md:912
msgid ""
"By including at least one private field and no constructor, we create an "
"opaque type that we can't instantiate outside of this module. (A struct with "
"no field could be instantiated by anyone.) We also want to use this type in "
"FFI, so we have to add `#[repr(C)]`. The marker ensures the compiler does "
"not mark the struct as `Send`, `Sync` and `Unpin` are not applied to the "
"struct. (`*mut u8` is not `Send` or `Sync`, `PhantomPinned` is not `Unpin`)"
msgstr ""

#: src/ffi.md:919
msgid ""
"But because our `Foo` and `Bar` types are different, we’ll get type safety "
"between the two of them, so we cannot accidentally pass a pointer to `Foo` "
"to `bar()`."
msgstr ""

#: src/ffi.md:923
msgid ""
"Notice that it is a really bad idea to use an empty enum as FFI type. The "
"compiler relies on empty enums being uninhabited, so handling values of type "
"`&Empty` is a huge footgun and can lead to buggy program behavior (by "
"triggering undefined behavior)."
msgstr ""

#: src/ffi.md:928
msgid ""
"**NOTE:** The simplest way would use \"extern types\". But it's currently "
"(as of June 2021) unstable and has some unresolved questions, see the [RFC "
"page](https://rust-lang.github.io/rfcs/1861-extern-types.html) and the "
"[tracking issue](https://github.com/rust-lang/rust/issues/43467) for more "
"details."
msgstr ""

#: src/beneath-std.md:3
msgid ""
"This section documents features that are normally provided by the `std` "
"crate and that `#![no_std]` developers have to deal with (i.e. provide) to "
"build `#![no_std]` binary crates."
msgstr ""

#: src/beneath-std.md:7
msgid "Using `libc`"
msgstr ""

#: src/beneath-std.md:9
msgid ""
"In order to build a `#[no_std]` executable we will need `libc` as a "
"dependency. We can specify this using our `Cargo.toml` file:"
msgstr ""

#: src/beneath-std.md:12
msgid ""
"```toml\n"
"[dependencies]\n"
"libc = { version = \"0.2.146\", default-features = false }\n"
"```"
msgstr ""

#: src/beneath-std.md:17
msgid ""
"Note that the default features have been disabled. This is a critical step - "
"**the default features of `libc` include the `std` crate and so must be "
"disabled.**"
msgstr ""

#: src/beneath-std.md:21
msgid ""
"Alternatively, we can use the unstable `rustc_private` private feature "
"together with an `extern crate libc;` declaration as shown in the examples "
"below. Note that windows-msvc targets do not require a libc, and "
"correspondingly there is no `libc` crate in their sysroot. We do not need "
"the `extern crate libc;` below, and having it on a windows-msvc target would "
"be a compile error."
msgstr ""

#: src/beneath-std.md:27
msgid "Writing an executable without `std`"
msgstr ""

#: src/beneath-std.md:29
msgid ""
"We will probably need a nightly version of the compiler to produce a `#!"
"[no_std]` executable because on many platforms, we have to provide the "
"`eh_personality` [lang item](https://doc.rust-lang.org/nightly/unstable-book/"
"language-features/lang-items.html), which is unstable."
msgstr ""

#: src/beneath-std.md:33
msgid ""
"You will need to define a symbol for the entry point that is suitable for "
"your target. For example, `main`, `_start`, `WinMain`, or whatever starting "
"point is relevant for your target. Additionally, you need to use the `#!"
"[no_main]` attribute to prevent the compiler from attempting to generate an "
"entry point itself."
msgstr ""

#: src/beneath-std.md:36
msgid ""
"Additionally, it's required to define a [panic handler function](panic-"
"handler.html)."
msgstr ""

#: src/beneath-std.md:43
msgid "// Necessary for `panic = \"unwind\"` builds on cfg(unix) platforms.\n"
msgstr ""

#: src/beneath-std.md:47
msgid "// Pull in the system libc library for what crt0.o likely requires.\n"
msgstr ""

#: src/beneath-std.md:54
msgid "// Entry point for this program.\n"
msgstr ""

#: src/beneath-std.md:56
msgid "// ensure that this symbol is included in the output as `main`\n"
msgstr ""

#: src/beneath-std.md:60
msgid ""
"// These functions are used by the compiler, but not for an empty program "
"like this.\n"
"// They are normally provided by `std`.\n"
msgstr ""

#: src/beneath-std.md:63
msgid "\"eh_personality\""
msgstr ""

#: src/beneath-std.md:69
msgid ""
"If you are working with a target that doesn't have binary releases of the "
"standard library available via rustup (this probably means you are building "
"the `core` crate yourself) and need compiler-rt intrinsics (i.e. you are "
"probably getting linker errors when building an executable: ``undefined "
"reference to `__aeabi_memcpy'``), you need to manually link to the "
"[`compiler_builtins` crate](https://crates.io/crates/compiler_builtins) to "
"get those intrinsics and solve the linker errors."
msgstr ""

#: src/panic-handler.md:3
msgid ""
"`#[panic_handler]` is used to define the behavior of `panic!` in `#!"
"[no_std]` applications. The `#[panic_handler]` attribute must be applied to "
"a function with signature `fn(&PanicInfo) -> !` and such function must "
"appear _once_ in the dependency graph of a binary / dylib / cdylib crate. "
"The API of `PanicInfo` can be found in the [API docs](../core/panic/"
"struct.PanicInfo.html)."
msgstr ""

#: src/panic-handler.md:10
msgid ""
"Given that `#![no_std]` applications have no _standard_ output and that some "
"`#![no_std]` applications, e.g. embedded applications, need different "
"panicking behaviors for development and for release it can be helpful to "
"have panic crates, crate that only contain a `#[panic_handler]`. This way "
"applications can easily swap the panicking behavior by simply linking to a "
"different panic crate."
msgstr ""

#: src/panic-handler.md:16
msgid ""
"Below is shown an example where an application has a different panicking "
"behavior depending on whether is compiled using the dev profile (`cargo "
"build`) or using the release profile (`cargo build --release`)."
msgstr ""

#: src/panic-handler.md:20
msgid ""
"`panic-semihosting` crate -- log panic messages to the host stderr using "
"semihosting:"
msgstr ""

#: src/panic-handler.md:30 src/panic-handler.md:82
msgid "// ..\n"
msgstr ""

#: src/panic-handler.md:46
msgid ""
"// logs \"panicked at '$reason', src/main.rs:27:4\" to the host stderr\n"
msgstr ""

#: src/panic-handler.md:53
msgid "`panic-halt` crate -- halt the thread on panic; messages are discarded:"
msgstr ""

#: src/panic-handler.md:67
msgid "`app` crate:"
msgstr ""

#: src/panic-handler.md:72
msgid "// dev profile\n"
msgstr ""

#: src/panic-handler.md:76
msgid "// release profile\n"
msgstr ""
