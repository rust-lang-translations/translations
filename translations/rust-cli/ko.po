msgid ""
msgstr ""
"Project-Id-Version: Command Line Applications in Rust\n"
"POT-Creation-Date: 2025-10-15T16:18:32+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:18:32+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:3
msgid "Getting started"
msgstr "시작하기"

#: src/SUMMARY.md:5
msgid "A command line app in 15 minutes"
msgstr "15분 만에 명령줄 앱 만들기"

#: src/SUMMARY.md:6 src/tutorial/setup.md:1
msgid "Project setup"
msgstr "프로젝트 설정"

#: src/SUMMARY.md:7
msgid "Parsing command line arguments"
msgstr "명령줄 인수 구문 분석"

#: src/SUMMARY.md:8
msgid "First implementation"
msgstr "첫 번째 구현"

#: src/SUMMARY.md:9 src/tutorial/errors.md:1
msgid "Nicer error reporting"
msgstr "더 나은 오류 보고"

#: src/SUMMARY.md:10
msgid "Output for humans and machines"
msgstr "사람과 기계를 위한 출력"

#: src/SUMMARY.md:11 src/tutorial/testing.md:1
msgid "Testing"
msgstr "테스트"

#: src/SUMMARY.md:12 src/tutorial/packaging.md:1
msgid "Packaging and distributing a Rust tool"
msgstr "Rust 도구 패키징 및 배포"

#: src/SUMMARY.md:13 src/in-depth/index.md:1
msgid "In-depth topics"
msgstr "심층 주제"

#: src/SUMMARY.md:14 src/in-depth/signals.md:1
msgid "Signal handling"
msgstr "신호 처리"

#: src/SUMMARY.md:15 src/in-depth/config-files.md:1
msgid "Using config files"
msgstr "구성 파일 사용"

#: src/SUMMARY.md:16 src/in-depth/exit-code.md:1
msgid "Exit codes"
msgstr "종료 코드"

#: src/SUMMARY.md:17 src/in-depth/human-communication.md:1
msgid "Communicating with humans"
msgstr "사람과 소통하기"

#: src/SUMMARY.md:18 src/in-depth/machine-communication.md:1
msgid "Communicating with machines"
msgstr "기계와 소통하기"

#: src/SUMMARY.md:19 src/in-depth/docs.md:1
msgid "Rendering documentation for your CLI apps"
msgstr "CLI 앱용 문서 렌더링"

#: src/SUMMARY.md:20 src/resources/index.md:1
msgid "Resources"
msgstr "리소스"

#: src/index.md:1
msgid "Command line apps in Rust"
msgstr "Rust의 명령줄 앱"

#: src/index.md:3
msgid "Rust is a statically compiled, fast language with great tooling and a rapidly growing ecosystem. That makes it a great fit for writing command line applications: They should be small, portable, and quick to run. Command line applications are also a great way to get started with learning Rust; or to introduce Rust to your team!"
msgstr "Rust는 정적으로 컴파일되고, 훌륭한 도구와 빠르게 성장하는 생태계를 갖춘 빠른 언어입니다. 따라서 명령줄 응용 프로그램을 작성하는 데 매우 적합합니다. 작고, 이식 가능하며, 빠르게 실행되어야 합니다. 명령줄 응용 프로그램은 Rust 학습을 시작하거나 팀에 Rust를 소개하는 좋은 방법이기도 합니다!"

#: src/index.md:9
msgid "Writing a program with a simple command line interface (CLI) is a great exercise for a beginner who is new to the language and wants to get a feel for it. There are many aspects to this topic, though, that often only reveal themselves later on."
msgstr "간단한 명령줄 인터페이스(CLI)를 사용하여 프로그램을 작성하는 것은 언어에 익숙하지 않고 감을 잡고 싶은 초보자에게 훌륭한 연습입니다. 그러나 이 주제에는 나중에야 드러나는 많은 측면이 있습니다."

#: src/index.md:15
msgid "This book is structured like this: We start with a quick tutorial, after which you'll end up with a working CLI tool. You'll be exposed to a few of the core concepts of Rust as well as the main aspects of CLI applications. What follows are chapters that go into more detail on some of these aspects."
msgstr "이 책은 다음과 같이 구성되어 있습니다. 빠른 튜토리얼로 시작하여 작동하는 CLI 도구를 완성하게 됩니다. Rust의 몇 가지 핵심 개념과 CLI 응용 프로그램의 주요 측면을 접하게 될 것입니다. 그 다음에는 이러한 측면 중 일부에 대해 더 자세히 설명하는 장이 이어집니다."

#: src/index.md:23
msgid "One last thing before we dive right into CLI applications: If you find an error in this book or want to help us write more content for it, you can find its source [in the CLI book repository](https://github.com/rust-cli/book). We'd love to hear your feedback! Thank you!"
msgstr "CLI 응용 프로그램에 바로 뛰어들기 전에 마지막으로 한 가지: 이 책에서 오류를 발견하거나 더 많은 콘텐츠를 작성하는 데 도움을 주고 싶다면 [CLI 책 리포지토리](https://github.com/rust-cli/book)에서 소스를 찾을 수 있습니다. 여러분의 피드백을 기다리겠습니다! 감사합니다!"

#: src/tutorial/index.md:1
msgid "Learning Rust by Writing a Command Line App in 15 Minutes"
msgstr "15분 만에 명령줄 앱을 작성하여 Rust 배우기"

#: src/tutorial/index.md:3
msgid "This tutorial will guide you through writing a CLI (command line interface) application in [Rust](https://rust-lang.org/). It will take you roughly fifteen minutes to get to a point where you have a running program (around chapter 1.3). After that, we'll continue to tweak our program until we reach a point where we can ship our little tool."
msgstr "이 튜토리얼은 [Rust](https://rust-lang.org/)로 CLI(명령줄 인터페이스) 응용 프로그램을 작성하는 과정을 안내합니다. 실행 중인 프로그램(1.3장 정도)을 갖게 되기까지 약 15분이 소요됩니다. 그 후에는 작은 도구를 출시할 수 있는 지점에 도달할 때까지 프로그램을 계속 수정할 것입니다."

#: src/tutorial/index.md:14
msgid "You’ll learn all the essentials about how to get going, and where to find more information. Feel free to skip parts you don't need to know right now or jump in at any point."
msgstr "시작하는 방법과 더 많은 정보를 찾을 수 있는 위치에 대한 모든 필수 사항을 배우게 됩니다. 지금 당장 알 필요가 없는 부분은 건너뛰거나 언제든지 뛰어들 수 있습니다."

#: src/tutorial/index.md:21
msgid "**Prerequisites:** This tutorial does not replace a general introduction to programming, and expects you to be familiar with a few common concepts. You should be comfortable with using a command line/terminal. If you already know a few other languages, this can be a good first contact with Rust."
msgstr "**전제 조건:** 이 튜토리얼은 프로그래밍에 대한 일반적인 소개를 대체하지 않으며 몇 가지 일반적인 개념에 익숙해야 합니다. 명령줄/터미널 사용에 익숙해야 합니다. 이미 다른 언어를 몇 가지 알고 있다면 Rust와의 좋은 첫 만남이 될 수 있습니다."

#: src/tutorial/index.md:28
msgid "**Getting help:** If you at any point feel overwhelmed or confused with the features used, have a look at the extensive official documentation that comes with Rust, first and foremost the book, The Rust Programming Language. It comes with most Rust installations (`rustup doc`), and is available online on [doc.rust-lang.org](https://doc.rust-lang.org)."
msgstr "**도움 받기:** 어느 시점에서든 사용된 기능에 압도되거나 혼란스러우면 Rust와 함께 제공되는 광범위한 공식 문서, 특히 The Rust Programming Language 책을 참조하세요. 대부분의 Rust 설치(`rustup doc`)와 함께 제공되며 [doc.rust-lang.org](https://doc.rust-lang.org)에서 온라인으로 볼 수 있습니다."

#: src/tutorial/index.md:39
msgid "You are also very welcome to ask questions – the Rust community is known to be friendly and helpful. Have a look at the [community page](https://www.rust-lang.org/community) to see a list of places where people discuss Rust."
msgstr "질문하는 것도 매우 환영합니다. Rust 커뮤니티는 친절하고 도움이 되는 것으로 알려져 있습니다. [커뮤니티 페이지](https://www.rust-lang.org/community)를 방문하여 사람들이 Rust에 대해 토론하는 장소 목록을 확인하세요."

#: src/tutorial/index.md:48
msgid "What kind of project do you want to write? How about we start with something simple: Let’s write a small `grep` clone. That is a tool that we can give a string and a path and it’ll print only the lines that contain the given string. Let’s call it `grrs` (pronounced “grass”)."
msgstr "어떤 종류의 프로젝트를 작성하고 싶으신가요? 간단한 것부터 시작해 봅시다. 작은 `grep` 클론을 작성해 봅시다. 즉, 문자열과 경로를 제공하면 주어진 문자열을 포함하는 줄만 인쇄하는 도구입니다. `grrs`(“그래스”로 발음)라고 부릅시다."

#: src/tutorial/index.md:55
msgid "In the end, we want to be able to run our tool like this:"
msgstr "결국에는 다음과 같이 도구를 실행할 수 있기를 원합니다."

#: src/tutorial/index.md:71
msgid "**Note:** This book is written for [Rust 2018](https://doc.rust-lang.org/edition-guide/index.html). The code examples can also be used on Rust 2015, but you might need to tweak them a bit; add `extern crate foo;` invocations, for example."
msgstr "**참고:** 이 책은 [Rust 2018](https://doc.rust-lang.org/edition-guide/index.html)용으로 작성되었습니다. 코드 예제는 Rust 2015에서도 사용할 수 있지만 약간 수정해야 할 수도 있습니다. 예를 들어 `extern crate foo;` 호출을 추가해야 합니다."

#: src/tutorial/index.md:77
msgid "Make sure you run Rust 1.31.0 (or later) and that you have `edition = \"2018\"` set in the `[package]` section of your `Cargo.toml` file."
msgstr "Rust 1.31.0 이상을 실행하고 `Cargo.toml` 파일의 `[package]` 섹션에 `edition = \"2018\"`이 설정되어 있는지 확인하세요."

#: src/tutorial/setup.md:3
msgid "If you haven’t already, [install Rust](https://www.rust-lang.org/tools/install) on your computer (it should only take a few minutes). After that, open a terminal and navigate to the directory you want to put your application code into."
msgstr "아직 설치하지 않았다면 컴퓨터에 [Rust를 설치](https://www.rust-lang.org/tools/install)하세요(몇 분밖에 걸리지 않습니다). 그런 다음 터미널을 열고 응용 프로그램 코드를 넣을 디렉토리로 이동합니다."

#: src/tutorial/setup.md:11
msgid "Start by running `cargo new grrs` in the directory you store your programming projects in. If you look at the newly created `grrs` directory, you’ll find a typical setup for a Rust project:"
msgstr "프로그래밍 프로젝트를 저장하는 디렉토리에서 `cargo new grrs`를 실행하여 시작합니다. 새로 생성된 `grrs` 디렉토리를 보면 Rust 프로젝트의 일반적인 설정을 찾을 수 있습니다."

#: src/tutorial/setup.md:17
msgid "A `Cargo.toml` file that contains metadata for our project, incl. a list of dependencies/external libraries we use."
msgstr "프로젝트에 대한 메타데이터를 포함하는 `Cargo.toml` 파일, 우리가 사용하는 의존성/외부 라이브러리 목록 포함."

#: src/tutorial/setup.md:19
msgid "A `src/main.rs` file that is the entry point for our (main) binary."
msgstr "(주) 바이너리의 진입점인 `src/main.rs` 파일."

#: src/tutorial/setup.md:21
msgid "If you can execute `cargo run` in the `grrs` directory and get a \"Hello World\", you’re all set up."
msgstr "`grrs` 디렉토리에서 `cargo run`을 실행하고 \"Hello World\"를 얻을 수 있다면 모든 설정이 완료된 것입니다."

#: src/tutorial/setup.md:24
msgid "What it might look like"
msgstr "어떻게 보일 수 있는지"

#: src/tutorial/cli-args.md:1
msgid "Parsing command-line arguments"
msgstr "명령줄 인수 구문 분석"

#: src/tutorial/cli-args.md:3
msgid "A typical invocation of our CLI tool will look like this:"
msgstr "CLI 도구의 일반적인 호출은 다음과 같습니다."

#: src/tutorial/cli-args.md:9
msgid "We expect our program to look at `test.txt` and print out the lines that contain `foobar`. But how do we get these two values?"
msgstr "우리는 프로그램이 `test.txt`를 보고 `foobar`를 포함하는 줄을 인쇄하기를 기대합니다. 하지만 이 두 값을 어떻게 얻을 수 있을까요?"

#: src/tutorial/cli-args.md:13
msgid "The text after the name of the program is often called the \"command-line arguments\", or \"command-line flags\" (especially when they look like `--this`). Internally, the operating system usually represents them as a list of strings – roughly speaking, they get separated by spaces."
msgstr "프로그램 이름 뒤의 텍스트는 종종 \"명령줄 인수\" 또는 \"명령줄 플래그\"(특히 `--this`처럼 보일 때)라고 합니다. 내부적으로 운영 체제는 일반적으로 이를 문자열 목록으로 나타냅니다. 대략적으로 말하면 공백으로 구분됩니다."

#: src/tutorial/cli-args.md:21
msgid "There are many ways to think about these arguments, and how to parse them into something more easy to work with. You will also need to tell the users of your program which arguments they need to give and in which format they are expected."
msgstr "이러한 인수에 대해 생각하고 더 쉽게 작업할 수 있는 것으로 구문 분석하는 방법에는 여러 가지가 있습니다. 또한 프로그램 사용자에게 어떤 인수를 어떤 형식으로 제공해야 하는지 알려야 합니다."

#: src/tutorial/cli-args.md:28
msgid "Getting the arguments"
msgstr "인수 가져오기"

#: src/tutorial/cli-args.md:30
msgid "The standard library contains the function `std::env::args()` (https://doc.rust-lang.org/1.39.0/std/env/fn.args.html) that gives you an [iterator](https://doc.rust-lang.org/1.39.0/std/iter/index.html) of the given arguments. The first entry (at index `0`) will be the name your program was called as (e.g. `grrs`), the ones that follow are what the user wrote afterwards."
msgstr "표준 라이브러리에는 주어진 인수의 [반복자](https://doc.rust-lang.org/1.39.0/std/iter/index.html)를 제공하는 `std::env::args()` (https://doc.rust-lang.org/1.39.0/std/env/fn.args.html) 함수가 포함되어 있습니다. 첫 번째 항목(인덱스 `0`)은 프로그램이 호출된 이름(예: `grrs`)이 되고, 그 뒤에 오는 항목은 사용자가 그 뒤에 쓴 것입니다."

#: src/tutorial/cli-args.md:38
msgid "Getting the raw arguments this way is quite easy (in file `src/main.rs`):"
msgstr "이러한 방식으로 원시 인수를 얻는 것은 매우 쉽습니다(`src/main.rs` 파일에서)."

#: src/tutorial/cli-args.md:42 src/tutorial/cli-args.md:111
msgid "no pattern given"
msgstr "패턴이 지정되지 않았습니다"

#: src/tutorial/cli-args.md:43 src/tutorial/cli-args.md:112
msgid "no path given"
msgstr "경로가 지정되지 않았습니다"

#: src/tutorial/cli-args.md:45 src/tutorial/cli-args.md:119
#: src/tutorial/cli-args.md:181 src/tutorial/cli-args.md:225
msgid "pattern: {:?}, path: {:?}"
msgstr "패턴: {:?}, 경로: {:?}"

#: src/tutorial/cli-args.md:49
msgid "We can run it using `cargo run`, passing arguments by writing them after `--`:"
msgstr "`cargo run`을 사용하여 실행할 수 있으며, `--` 뒤에 인수를 작성하여 전달합니다."

#: src/tutorial/cli-args.md:52 src/tutorial/cli-args.md:247
msgid "```console\n$ cargo run -- some-pattern some-file\n    Finished dev [unoptimized + debuginfo] target(s) in 0.11s\n     Running `target/debug/grrs some-pattern some-file`\npattern: \"some-pattern\", path: \"some-file\"\n```"
msgstr "```console\n$ cargo run -- some-pattern some-file\n    Finished dev [unoptimized + debuginfo] target(s) in 0.11s\n     Running `target/debug/grrs some-pattern some-file`\npattern: \"some-pattern\", path: \"some-file\"\n```"

#: src/tutorial/cli-args.md:59
msgid "CLI arguments as data type"
msgstr "데이터 유형으로서의 CLI 인수"

#: src/tutorial/cli-args.md:61
msgid "Instead of thinking about them as a bunch of text, it often pays off to think of CLI arguments as a custom data type that represents the inputs to your program."
msgstr "텍스트 뭉치로 생각하는 대신 CLI 인수를 프로그램에 대한 입력을 나타내는 사용자 지정 데이터 유형으로 생각하는 것이 종종 더 좋습니다."

#: src/tutorial/cli-args.md:65
msgid "Look at `grrs foobar test.txt`: There are two arguments, first the `pattern` (the string to look for), and then the `path` (the file to look in)."
msgstr "`grrs foobar test.txt`를 보세요. 두 개의 인수가 있습니다. 첫 번째는 `pattern`(찾을 문자열)이고 두 번째는 `path`(찾을 파일)입니다."

#: src/tutorial/cli-args.md:70
msgid "What more can we say about them? Well, for a start, both are required. We haven't talked about any default values, so we expect our users to always provide two values. Furthermore, we can say a bit about their types: The pattern is expected to be a string, while the second argument is expected to be a path to a file."
msgstr "그것들에 대해 더 무엇을 말할 수 있을까요? 음, 우선 둘 다 필요합니다. 기본값에 대해 이야기하지 않았으므로 사용자가 항상 두 값을 제공할 것으로 예상합니다. 또한 유형에 대해 약간 말할 수 있습니다. 패턴은 문자열이어야 하고 두 번째 인수는 파일 경로여야 합니다."

#: src/tutorial/cli-args.md:78
msgid "In Rust, it is common to structure programs around the data they handle, so this way of looking at CLI arguments fits very well. Let's start with this (in file `src/main.rs`, before `fn main() {`):"
msgstr "Rust에서는 처리하는 데이터를 중심으로 프로그램을 구성하는 것이 일반적이므로 이러한 CLI 인수를 보는 방식이 매우 적합합니다. 이것부터 시작해 봅시다(`src/main.rs` 파일에서 `fn main() {` 이전)."

#: src/tutorial/cli-args.md:89
msgid "This defines a new structure (a [`struct`](https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html)) that has two fields to store data in: `pattern`, and `path`."
msgstr "이것은 데이터를 저장할 두 개의 필드, 즉 `pattern`과 `path`를 가진 새로운 구조체([`struct`](https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html))를 정의합니다."

#: src/tutorial/cli-args.md:96
msgid "**Note:** [`PathBuf`](https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html) is like a [`String`](https://doc.rust-lang.org/1.39.0/std/string/struct.String.html) but for file system paths that work cross-platform."
msgstr "**참고:** [`PathBuf`](https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html)는 [`String`](https://doc.rust-lang.org/1.39.0/std/string/struct.String.html)과 같지만 크로스 플랫폼에서 작동하는 파일 시스템 경로용입니다."

#: src/tutorial/cli-args.md:104
msgid "Now, we still need to get the actual arguments our program got into this form. One option would be to manually parse the list of strings we get from the operating system and build the structure ourselves. It would look something like this:"
msgstr "이제 프로그램이 얻은 실제 인수를 이 형식으로 가져와야 합니다. 한 가지 옵션은 운영 체제에서 얻은 문자열 목록을 수동으로 구문 분석하고 구조를 직접 빌드하는 것입니다. 다음과 같이 보일 것입니다."

#: src/tutorial/cli-args.md:123
msgid "This works, but it's not very convenient. How would you deal with the requirement to support `--pattern=\"foo\"` or `--pattern \"foo\"`? How would you implement `--help`?"
msgstr "이것은 작동하지만 그다지 편리하지 않습니다. `--pattern=\"foo\"` 또는 `--pattern \"foo\"`를 지원해야 하는 요구 사항을 어떻게 처리하시겠습니까? `--help`를 어떻게 구현하시겠습니까?"

#: src/tutorial/cli-args.md:128
msgid "Parsing CLI arguments with Clap"
msgstr "Clap으로 CLI 인수 구문 분석"

#: src/tutorial/cli-args.md:130
msgid "A much nicer way is to use one of the many available libraries. The most popular library for parsing command-line arguments is called [`clap`](https://docs.rs/clap/). It has all the functionality you'd expect, including support for sub-commands, [shell completions](https://docs.rs/clap_complete/), and great help messages."
msgstr "더 좋은 방법은 사용 가능한 많은 라이브러리 중 하나를 사용하는 것입니다. 명령줄 인수를 구문 분석하는 가장 인기 있는 라이브러리는 [`clap`](https://docs.rs/clap/)입니다. 하위 명령, [셸 완성](https://docs.rs/clap_complete/) 및 훌륭한 도움말 메시지를 포함하여 기대하는 모든 기능을 갖추고 있습니다."

#: src/tutorial/cli-args.md:139
msgid "Let's first import `clap` by adding `clap = { version = \"4.0\", features = [\"derive\"] }` to the `[dependencies]` section of our `Cargo.toml` file."
msgstr "먼저 `Cargo.toml` 파일의 `[dependencies]` 섹션에 `clap = { version = \"4.0\", features = [\"derive\"] }`를 추가하여 `clap`을 가져옵니다."

#: src/tutorial/cli-args.md:143
msgid "Now, we can write `use clap::Parser;` in our code, and add `#[derive(Parser)]` right above our `struct Cli`. Let's also write some documentation comments along the way."
msgstr "이제 코드에 `use clap::Parser;`를 작성하고 `struct Cli` 바로 위에 `#[derive(Parser)]`를 추가할 수 있습니다. 그 과정에서 몇 가지 문서 주석도 작성해 봅시다."

#: src/tutorial/cli-args.md:147
msgid "It’ll look like this (in file `src/main.rs`, before `fn main() {`):"
msgstr "다음과 같이 보일 것입니다(`src/main.rs` 파일에서 `fn main() {` 이전)."

#: src/tutorial/cli-args.md:151 src/tutorial/cli-args.md:212
#: src/tutorial/impl-draft.md:54 src/tutorial/errors.md:261
#: src/in-depth/machine-communication.md:175
msgid "/// Search for a pattern in a file and display the lines that contain it.\n"
msgstr "/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.\n"

#: src/tutorial/cli-args.md:155 src/tutorial/cli-args.md:216
#: src/tutorial/impl-draft.md:58 src/tutorial/errors.md:265
msgid "/// The pattern to look for\n"
msgstr "/// 찾을 패턴\n"

#: src/tutorial/cli-args.md:157 src/tutorial/cli-args.md:218
#: src/tutorial/impl-draft.md:60 src/tutorial/errors.md:267
#: src/in-depth/machine-communication.md:267
msgid "/// The path to the file to read\n"
msgstr "/// 읽을 파일의 경로\n"

#: src/tutorial/cli-args.md:164
msgid "**Note:** There are a lot of custom attributes you can add to fields. For example, to say you want to use this field for the argument after `-o` or `--output`, you'd add `#[arg(short = 'o', long = \"output\")]`. For more information, see the [clap documentation](https://docs.rs/clap/)."
msgstr "**참고:** 필드에 추가할 수 있는 사용자 지정 속성이 많이 있습니다. 예를 들어 `-o` 또는 `--output` 뒤의 인수에 이 필드를 사용하려면 `#[arg(short = 'o', long = \"output\")]`를 추가합니다. 자세한 내용은 [clap 문서](https://docs.rs/clap/)를 참조하세요."

#: src/tutorial/cli-args.md:174
msgid "Right below the `Cli` struct our template contains its `main` function. When the program starts, it will call this function:"
msgstr "`Cli` 구조체 바로 아래에 템플릿에 `main` 함수가 포함되어 있습니다. 프로그램이 시작되면 이 함수를 호출합니다."

#: src/tutorial/cli-args.md:185
msgid "This will try to parse the arguments into our `Cli` struct."
msgstr "이렇게 하면 인수를 `Cli` 구조체로 구문 분석하려고 시도합니다."

#: src/tutorial/cli-args.md:187
msgid "But what if that fails? That's the beauty of this approach: Clap knows which fields to expect, and what their expected format is. It can automatically generate a nice `--help` message, as well as give some great errors to suggest you pass `--output` when you wrote `--putput`."
msgstr "하지만 실패하면 어떻게 될까요? 이것이 이 접근 방식의 장점입니다. Clap은 어떤 필드를 예상해야 하는지, 그리고 예상 형식이 무엇인지 알고 있습니다. `--help` 메시지를 자동으로 생성하고 `--putput`을 작성했을 때 `--output`을 전달하도록 제안하는 훌륭한 오류를 제공할 수 있습니다."

#: src/tutorial/cli-args.md:197
msgid "**Note:** The `parse` method is meant to be used in your `main` function. When it fails, it will print out an error or help message and immediately exit the program. Don't use it in other places!"
msgstr "**참고:** `parse` 메서드는 `main` 함수에서 사용하기 위한 것입니다. 실패하면 오류 또는 도움말 메시지를 인쇄하고 즉시 프로그램을 종료합니다. 다른 곳에서는 사용하지 마세요!"

#: src/tutorial/cli-args.md:206 src/tutorial/impl-draft.md:48
#: src/tutorial/errors.md:254
msgid "Wrapping up"
msgstr "마무리"

#: src/tutorial/cli-args.md:208 src/tutorial/impl-draft.md:50
#: src/tutorial/errors.md:256
msgid "Your code should now look like:"
msgstr "이제 코드는 다음과 같아야 합니다."

#: src/tutorial/cli-args.md:229
msgid "Running it without any arguments:"
msgstr "인수 없이 실행:"

#: src/tutorial/cli-args.md:245
msgid "Running it passing arguments:"
msgstr "인수를 전달하여 실행:"

#: src/tutorial/cli-args.md:254
msgid "The output demonstrates that our program successfully parsed the arguments into the `Cli` struct."
msgstr "출력은 프로그램이 인수를 `Cli` 구조체로 성공적으로 구문 분석했음을 보여줍니다."

#: src/tutorial/impl-draft.md:1
msgid "First implementation of _grrs_"
msgstr "_grrs_의 첫 번째 구현"

#: src/tutorial/impl-draft.md:3
msgid "After the last chapter on command line arguments, we have our input data, and we can start to write our actual tool. Our `main` function only contains this line right now:"
msgstr "명령줄 인수에 대한 마지막 장 이후에 입력 데이터가 있으므로 실제 도구를 작성하기 시작할 수 있습니다. 현재 `main` 함수에는 이 줄만 포함되어 있습니다."

#: src/tutorial/impl-draft.md:12
msgid "(We drop the `println` statement that we merely put there temporarily to demonstrate that our program works as expected.)"
msgstr "(프로그램이 예상대로 작동하는지 보여주기 위해 임시로 넣은 `println` 문은 삭제합니다.)"

#: src/tutorial/impl-draft.md:15
msgid "Let’s start by opening the file we got."
msgstr "받은 파일을 여는 것부터 시작합시다."

#: src/tutorial/impl-draft.md:18 src/tutorial/impl-draft.md:66
#: src/tutorial/testing.md:461
msgid "could not read file"
msgstr "파일을 읽을 수 없습니다"

#: src/tutorial/impl-draft.md:23
msgid "**Note:** See that [`.expect`](https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect) method here? This is a shortcut function that will make the program exit immediately when the value (in this case the input file) could not be read. It's not very pretty, and in the next chapter on [Nicer error reporting](./errors.html) we will look at how to improve this."
msgstr "**참고:** 여기에서 [`.expect`](https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect) 메서드를 보시겠습니까? 이것은 값(이 경우 입력 파일)을 읽을 수 없을 때 프로그램을 즉시 종료시키는 바로 가기 함수입니다. 그다지 예쁘지는 않으며 다음 장인 [더 나은 오류 보고](./errors.html)에서 이를 개선하는 방법을 살펴보겠습니다."

#: src/tutorial/impl-draft.md:37
msgid "Now, let’s iterate over the lines and print each one that contains our pattern:"
msgstr "이제 줄을 반복하고 패턴을 포함하는 각 줄을 인쇄해 봅시다."

#: src/tutorial/impl-draft.md:43 src/tutorial/impl-draft.md:70
#: src/tutorial/errors.md:279 src/tutorial/testing.md:117
#: src/tutorial/testing.md:130 src/tutorial/testing.md:219
#: src/in-depth/machine-communication.md:188
msgid "{}"
msgstr "{}"

#: src/tutorial/impl-draft.md:76
msgid "Give it a try: `cargo run -- main src/main.rs` should work now!"
msgstr "시도해 보세요. `cargo run -- main src/main.rs`가 이제 작동해야 합니다!"

#: src/tutorial/impl-draft.md:80
msgid "**Exercise for the reader:** This is not the best implementation: It will read the whole file into memory – however large the file may be. Find a way to optimize it! (One idea might be to use a [`BufReader`](https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html) instead of `read_to_string()`.)"
msgstr "**독자를 위한 연습:** 이것은 최상의 구현이 아닙니다. 파일이 아무리 크더라도 전체 파일을 메모리로 읽어들입니다. 최적화할 방법을 찾아보세요! (한 가지 아이디어는 `read_to_string()` 대신 [`BufReader`](https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html)를 사용하는 것일 수 있습니다.)"

#: src/tutorial/errors.md:3
msgid "We all can do nothing but accept the fact that errors will occur. And in contrast to many other languages, it's very hard not to notice and deal with this reality when using Rust: As it doesn't have exceptions, all possible error states are often encoded in the return types of functions."
msgstr "우리 모두는 오류가 발생할 것이라는 사실을 받아들일 수밖에 없습니다. 그리고 다른 많은 언어와 달리 Rust를 사용할 때 이 현실을 알아차리고 처리하지 않기가 매우 어렵습니다. 예외가 없기 때문에 모든 가능한 오류 상태는 종종 함수의 반환 유형에 인코딩됩니다."

#: src/tutorial/errors.md:10
msgid "Results"
msgstr "결과"

#: src/tutorial/errors.md:12
msgid "A function like [`read_to_string`](https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html) doesn't return a string. Instead, it returns a [`Result`](https://doc.rust-lang.org/1.39.0/std/result/index.html) that contains either a `String` or an error of some type (in this case [`std::io::Error`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html))."
msgstr "[`read_to_string`](https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html)와 같은 함수는 문자열을 반환하지 않습니다. 대신 `String` 또는 일부 유형의 오류(이 경우 [`std::io::Error`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html))를 포함하는 [`Result`](https://doc.rust-lang.org/1.39.0/std/result/index.html)를 반환합니다."

#: src/tutorial/errors.md:23
msgid "How do you know which it is? Since `Result` is an `enum`, you can use `match` to check which variant it is:"
msgstr "어느 것인지 어떻게 알 수 있습니까? `Result`는 `enum`이므로 `match`를 사용하여 어떤 변형인지 확인할 수 있습니다."

#: src/tutorial/errors.md:28 src/tutorial/errors.md:53
#: src/tutorial/errors.md:73 src/tutorial/errors.md:83
#: src/tutorial/errors.md:101 src/tutorial/errors.md:143
#: src/tutorial/errors.md:196 src/tutorial/errors.md:237
msgid "test.txt"
msgstr "test.txt"

#: src/tutorial/errors.md:30
msgid "File content: {}"
msgstr "파일 내용: {}"

#: src/tutorial/errors.md:31
msgid "Oh noes: {}"
msgstr "이런: {}"

#: src/tutorial/errors.md:37
msgid "**Note:** Not sure what enums are or how they work in Rust? [Check this chapter of the Rust book](https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html) to get up to speed."
msgstr "**참고:** 열거형이 무엇인지 또는 Rust에서 어떻게 작동하는지 잘 모르시겠습니까? [Rust 책의 이 장](https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html)을 확인하여 속도를 높이세요."

#: src/tutorial/errors.md:44
msgid "Unwrapping"
msgstr "언래핑"

#: src/tutorial/errors.md:46
msgid "Now, we were able to access the content of the file, but we can't really do anything with it after the `match` block. For this, we'll need to somehow deal with the error case. The challenge is that all arms of a `match` block need to return something of the same type. But there's a neat trick to get around that:"
msgstr "이제 파일 내용에 액세스할 수 있었지만 `match` 블록 이후에는 실제로 아무것도 할 수 없습니다. 이를 위해 오류 사례를 어떻게든 처리해야 합니다. 문제는 `match` 블록의 모든 암이 동일한 유형의 무언가를 반환해야 한다는 것입니다. 하지만 이를 해결할 수 있는 멋진 트릭이 있습니다."

#: src/tutorial/errors.md:56
msgid "Can't deal with {}, just exit here"
msgstr "{}를 처리할 수 없습니다. 여기서 종료합니다"

#: src/tutorial/errors.md:58 src/tutorial/errors.md:106
#: src/tutorial/errors.md:144 src/tutorial/errors.md:199
#: src/tutorial/errors.md:240
msgid "file content: {}"
msgstr "파일 내용: {}"

#: src/tutorial/errors.md:61
msgid "We can use the String in `content` after the match block. If `result` were an error, the String wouldn't exist. But since the program would exit before it ever reached a point where we use `content`, it's fine."
msgstr "`match` 블록 뒤에 `content`의 문자열을 사용할 수 있습니다. `result`가 오류였다면 문자열이 존재하지 않았을 것입니다. 하지만 프로그램이 `content`를 사용하는 지점에 도달하기 전에 종료되므로 괜찮습니다."

#: src/tutorial/errors.md:66
msgid "This may seem drastic, but it's very convenient. If your program needs to read that file and can't do anything if the file doesn't exist, exiting is a valid strategy. There's even a shortcut method on `Result`s, called `unwrap`:
"
msgstr "이것은 과감해 보일 수 있지만 매우 편리합니다. 프로그램이 해당 파일을 읽어야 하고 파일이 없으면 아무것도 할 수 없는 경우 종료하는 것이 유효한 전략입니다. `Result`에는 `unwrap`이라는 바로 가기 메서드도 있습니다."

#: src/tutorial/errors.md:76
msgid "No need to panic"
msgstr "패닉할 필요 없음"

#: src/tutorial/errors.md:78
msgid "Of course, aborting the program is not the only way to deal with errors. Instead of the `panic!`, we can also easily write `return`:"
msgstr "물론 프로그램을 중단하는 것이 오류를 처리하는 유일한 방법은 아닙니다. `panic!` 대신 `return`을 쉽게 작성할 수도 있습니다."

#: src/tutorial/errors.md:92
msgid "This, however changes the return type our function needs. Indeed, there was something hidden in our examples all this time: The function signature this code lives in. And in this last example with `return`, it becomes important. Here's the _full_ example:"
msgstr "그러나 이것은 우리 함수에 필요한 반환 유형을 변경합니다. 실제로 이번에는 우리 예제에 숨겨진 것이 있었습니다. 이 코드가 있는 함수 서명입니다. 그리고 `return`이 있는 이 마지막 예제에서는 중요해집니다. 다음은 _전체_ 예제입니다."

#: src/tutorial/errors.md:111
msgid "Our return type is a `Result`! This is why we can write `return Err(error);` in the second match arm. See how there is an `Ok(())` at the bottom? It's the default return value of the function and means \"Result is okay, and has no content\"."
msgstr "우리의 반환 유형은 `Result`입니다! 이것이 두 번째 `match` 암에 `return Err(error);`를 쓸 수 있는 이유입니다. 맨 아래에 `Ok(())`가 있는 것을 보시겠습니까? 이것은 함수의 기본 반환 값이며 \"결과가 정상이며 내용이 없습니다\"를 의미합니다."

#: src/tutorial/errors.md:119
msgid "**Note:** Why is this not written as `return Ok(());`? It easily could be – this is totally valid as well. The last expression of any block in Rust is its return value, and it is customary to omit needless `return`s."
msgstr "**참고:** 이것이 `return Ok(());`로 작성되지 않은 이유는 무엇입니까? 쉽게 그럴 수 있습니다. 이것도 완전히 유효합니다. Rust의 모든 블록의 마지막 표현식은 반환 값이며 불필요한 `return`을 생략하는 것이 일반적입니다."

#: src/tutorial/errors.md:127
msgid "Question Mark"
msgstr "물음표"

#: src/tutorial/errors.md:129
msgid "Just like calling `.unwrap()` is a shortcut for the `match` with `panic!` in the error arm, we have another shortcut for the `match` that `return`s in the error arm: `?`."
msgstr "`.unwrap()`를 호출하는 것이 오류 암에 `panic!`이 있는 `match`의 바로 가기인 것처럼, 오류 암에 `return`이 있는 `match`에 대한 또 다른 바로 가기가 있습니다. `?`입니다."

#: src/tutorial/errors.md:134
msgid "That's right, a question mark. You can append this operator to a value of type `Result`, and Rust will internally expand this to something very similar to the `match` we just wrote."
msgstr "맞습니다, 물음표입니다. 이 연산자를 `Result` 유형의 값에 추가할 수 있으며 Rust는 내부적으로 이를 우리가 방금 작성한 `match`와 매우 유사한 것으로 확장합니다."

#: src/tutorial/errors.md:139
msgid "Give it a try:"
msgstr "시도해 보세요."

#: src/tutorial/errors.md:149
msgid "Very concise!"
msgstr "매우 간결합니다!"

#: src/tutorial/errors.md:153
msgid "**Note:** There are a few more things happening here that are not required to understand to work with this. For example, the error type in our `main` function is `Box<dyn std::error::Error>`. But we've seen above that `read_to_string` returns a [`std::io::Error`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html). This works because `?` expands to code that  _converts_ error types."
msgstr "**참고:** 여기에는 이 작업을 이해하는 데 필요하지 않은 몇 가지 추가 사항이 있습니다. 예를 들어 `main` 함수의 오류 유형은 `Box<dyn std::error::Error>`입니다. 하지만 위에서 `read_to_string`이 [`std::io::Error`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html)를 반환하는 것을 보았습니다. 이것은 `?`가 오류 유형을 _변환_하는 코드로 확장되기 때문에 작동합니다."

#: src/tutorial/errors.md:161
msgid "`Box<dyn std::error::Error>` is also an interesting type. It's a `Box` that can contain _any_ type that implements the standard [`Error`](https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html) trait. This means that basically all errors can be put into this box, so we can use `?` on all of the usual functions that return `Result`s."
msgstr "`Box<dyn std::error::Error>`도 흥미로운 유형입니다. 표준 [`Error`](https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html) 특성을 구현하는 _모든_ 유형을 포함할 수 있는 `Box`입니다. 즉, 기본적으로 모든 오류를 이 상자에 넣을 수 있으므로 `Result`를 반환하는 모든 일반적인 함수에서 `?`를 사용할 수 있습니다."

#: src/tutorial/errors.md:171
msgid "Providing Context"
msgstr "컨텍스트 제공"

#: src/tutorial/errors.md:173
msgid "The errors you get when using `?` in your `main` function are okay, but they are not great. For example: When you run `std::fs::read_to_string(\"test.txt\")?` but the file `test.txt` doesn't exist, you get this output:"
msgstr "`main` 함수에서 `?`를 사용할 때 발생하는 오류는 괜찮지만 훌륭하지는 않습니다. 예를 들어 `std::fs::read_to_string(\"test.txt\")?`를 실행하지만 `test.txt` 파일이 없으면 다음과 같은 출력이 표시됩니다."

#: src/tutorial/errors.md:180
msgid "```text\nError: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```"
msgstr "```text\nError: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```"

#: src/tutorial/errors.md:184
msgid "In cases where your code doesn't literally contain the file name, it would be very hard to tell which file was `NotFound`. There are multiple ways to deal with this."
msgstr "코드에 파일 이름이 문자 그대로 포함되지 않은 경우 어떤 파일이 `NotFound`인지 알기가 매우 어려울 것입니다. 이를 처리하는 방법에는 여러 가지가 있습니다."

#: src/tutorial/errors.md:188
msgid "For example, we can create our own error type, and then use that to build a custom error message:"
msgstr "예를 들어, 자체 오류 유형을 만든 다음 이를 사용하여 사용자 지정 오류 메시지를 빌드할 수 있습니다."

#: src/tutorial/errors.md:198
msgid "Error reading `{}`: {}"
msgstr "`{}` 읽기 오류: {}"

#: src/tutorial/errors.md:204
msgid "Now, running this we'll get our custom error message:"
msgstr "이제 이것을 실행하면 사용자 지정 오류 메시지가 표시됩니다."

#: src/tutorial/errors.md:207
msgid "```text\nError: CustomError(\"Error reading `test.txt`: No such file or directory (os error 2)\")\n```"
msgstr "```text\nError: CustomError(\"Error reading `test.txt`: No such file or directory (os error 2)\")\n```"

#: src/tutorial/errors.md:211
msgid "Not very pretty, but we can easily adapt the debug output for our type later on."
msgstr "별로 예쁘지는 않지만 나중에 우리 유형에 대한 디버그 출력을 쉽게 조정할 수 있습니다."

#: src/tutorial/errors.md:214
msgid "This pattern is in fact very common. It has one problem, though: We don't store the original error, only its string representation. The often used [`anyhow`](https://docs.rs/anyhow) library has a neat solution for that: similar to our `CustomError` type, its [`Context`](https://docs.rs/anyhow/1.0/anyhow/trait.Context.html) trait can be used to add a description. Additionally, it also keeps the original error, so we get a \"chain\" of error messages pointing out the root cause."
msgstr "이 패턴은 실제로 매우 일반적입니다. 하지만 한 가지 문제가 있습니다. 원래 오류는 저장하지 않고 문자열 표현만 저장합니다. 자주 사용되는 [`anyhow`](https://docs.rs/anyhow) 라이브러리에는 이에 대한 깔끔한 해결책이 있습니다. `CustomError` 유형과 유사하게 [`Context`](https://docs.rs/anyhow/1.0/anyhow/trait.Context.html) 특성을 사용하여 설명을 추가할 수 있습니다. 또한 원래 오류도 유지하므로 근본 원인을 지적하는 오류 메시지의 \"체인\"을 얻을 수 있습니다."

#: src/tutorial/errors.md:227
msgid "Let's first import the `anyhow` crate by adding `anyhow = \"1.0\"` to the `[dependencies]` section of our `Cargo.toml` file."
msgstr "먼저 `Cargo.toml` 파일의 `[dependencies]` 섹션에 `anyhow = \"1.0\"`을 추가하여 `anyhow` 크레이트를 가져옵니다."

#: src/tutorial/errors.md:231
msgid "The full example will then look like this:"
msgstr "전체 예제는 다음과 같습니다."

#: src/tutorial/errors.md:239 src/tutorial/errors.md:275
#: src/tutorial/testing.md:259
msgid "could not read file `{}`"
msgstr "파일 `{}`을(를) 읽을 수 없습니다"

#: src/tutorial/errors.md:245
msgid "This will print an error:"
msgstr "오류가 인쇄됩니다."

#: src/tutorial/output.md:1
msgid "Output"
msgstr "출력"

#: src/tutorial/output.md:3
msgid "Printing \"Hello World\""
msgstr "\"Hello World\" 인쇄"

#: src/tutorial/output.md:6
msgid "Hello World"
msgstr "Hello World"

#: src/tutorial/output.md:9
msgid "Well, that was easy. Great, onto the next topic."
msgstr "음, 쉬웠습니다. 좋습니다, 다음 주제로 넘어갑시다."

#: src/tutorial/output.md:12
msgid "Using `println!`"
msgstr "`println!` 사용"

#: src/tutorial/output.md:14
msgid "You can pretty much print all the things you like with the `println!` macro. This macro has some pretty amazing capabilities, but also a special syntax. It expects you to write a string literal as the first parameter, that contains placeholders that will be filled in by the values of the parameters that follow as further arguments."
msgstr "`println!` 매크로를 사용하여 원하는 모든 것을 거의 인쇄할 수 있습니다. 이 매크로는 몇 가지 놀라운 기능을 가지고 있지만 특별한 구문도 있습니다. 첫 번째 매개변수로 문자열 리터럴을 작성해야 하며, 여기에는 추가 인수로 따르는 매개변수 값으로 채워질 자리 표시자가 포함됩니다."

#: src/tutorial/output.md:22
msgid "For example:"
msgstr "예를 들어:"

#: src/tutorial/output.md:26
msgid "My lucky number is {}."
msgstr "내 행운의 숫자는 {}."

#: src/tutorial/output.md:29 src/tutorial/output.md:50
msgid "will print"
msgstr "인쇄됩니다"

#: src/tutorial/output.md:35
msgid "The curly braces (`{}`) in the string above is one of these placeholders. This is the default placeholder type that tries to print the given value in a human readable way. For numbers and strings this works very well, but not all types can do that. This is why there is also a \"debug representation\", that you can get by filling the braces of the placeholder like this: `{:?}`."
msgstr "위 문자열의 중괄호(`{}`)는 이러한 자리 표시자 중 하나입니다. 이것은 주어진 값을 사람이 읽을 수 있는 방식으로 인쇄하려고 시도하는 기본 자리 표시자 유형입니다. 숫자와 문자열의 경우 매우 잘 작동하지만 모든 유형이 그렇게 할 수 있는 것은 아닙니다. 이것이 \"디버그 표현\"도 있는 이유이며, 자리 표시자의 중괄호를 다음과 같이 채워서 얻을 수 있습니다. `{:?}`."

#: src/tutorial/output.md:43
msgid "For example,"
msgstr "예를 들어,"

#: src/tutorial/output.md:47
msgid "The list is: {:?}"
msgstr "목록은 다음과 같습니다: {:?}"

#: src/tutorial/output.md:56
msgid "If you want your own data types to be printable for debugging and logging, you can in most cases add a `#[derive(Debug)]` above their definition."
msgstr "자체 데이터 유형을 디버깅 및 로깅을 위해 인쇄할 수 있도록 하려면 대부분의 경우 정의 위에 `#[derive(Debug)]`를 추가할 수 있습니다."

#: src/tutorial/output.md:61
msgid "**Note:** \"User-friendly\" printing is done using the [`Display`](https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html) trait, debug output (human-readable but targeted at developers) uses the [`Debug`](https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html) trait. You can find more information about the syntax you can use in `println!` in the [documentation for the `std::fmt` module](https://doc.rust-lang.org/1.39.0/std/fmt/index.html)."
msgstr "**참고:** \"사용자 친화적인\" 인쇄는 [`Display`](https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html) 특성을 사용하여 수행되며, 디버그 출력(사람이 읽을 수 있지만 개발자를 대상으로 함)은 [`Debug`](https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html) 특성을 사용합니다. `println!`에서 사용할 수 있는 구문에 대한 자세한 내용은 [`std::fmt` 모듈에 대한 문서](https://doc.rust-lang.org/1.39.0/std/fmt/index.html)에서 찾을 수 있습니다."

#: src/tutorial/output.md:73
msgid "Printing errors"
msgstr "오류 인쇄"

#: src/tutorial/output.md:75
msgid "Printing errors should be done via `stderr` to make it easier for users and other tools to pipe their outputs to files or more tools."
msgstr "오류 인쇄는 사용자와 다른 도구가 출력을 파일이나 더 많은 도구로 파이프할 수 있도록 `stderr`를 통해 수행해야 합니다."

#: src/tutorial/output.md:83
msgid "**Note:** On most operating systems, a program can write to two output streams, `stdout` and `stderr`. `stdout` is for the program's actual output, while `stderr` allows errors and other messages to be kept separate from `stdout`. That way, output can be stored to a file or piped to another program while errors are shown to the user."
msgstr "**참고:** 대부분의 운영 체제에서 프로그램은 `stdout`과 `stderr`라는 두 개의 출력 스트림에 쓸 수 있습니다. `stdout`은 프로그램의 실제 출력용이고, `stderr`는 오류 및 기타 메시지를 `stdout`과 분리하여 유지할 수 있도록 합니다. 이렇게 하면 오류가 사용자에게 표시되는 동안 출력을 파일에 저장하거나 다른 프로그램으로 파이프할 수 있습니다."

#: src/tutorial/output.md:94
msgid "In Rust this is achieved with `println!` and `eprintln!`, the former printing to `stdout` and the latter to `stderr`."
msgstr "Rust에서는 `println!`과 `eprintln!`을 사용하여 이를 달성합니다. 전자는 `stdout`에 인쇄하고 후자는 `stderr`에 인쇄합니다."

#: src/tutorial/output.md:100
msgid "This is information"
msgstr "이것은 정보입니다"

#: src/tutorial/output.md:101
msgid "This is an error! :("
msgstr "이것은 오류입니다! :("

#: src/tutorial/output.md:106
msgid "**Beware**: Printing [escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) can be dangerous, putting the user's terminal into a weird state. Always be careful when manually printing them!"
msgstr "**주의**: [이스케이프 코드](https://en.wikipedia.org/wiki/ANSI_escape_code)를 인쇄하는 것은 위험할 수 있으며 사용자의 터미널을 이상한 상태로 만들 수 있습니다. 수동으로 인쇄할 때는 항상 주의하세요!"

#: src/tutorial/output.md:112
msgid "Ideally you should be using a crate like `ansi_term` when dealing with raw escape codes to make your (and your user's) life easier."
msgstr "이상적으로는 원시 이스케이프 코드를 처리할 때 `ansi_term`과 같은 크레이트를 사용하여 자신(과 사용자)의 삶을 더 쉽게 만들어야 합니다."

#: src/tutorial/output.md:118
msgid "A note on printing performance"
msgstr "인쇄 성능에 대한 참고 사항"

#: src/tutorial/output.md:120
msgid "Printing to the terminal is surprisingly slow! If you call things like `println!` in a loop, it can easily become a bottleneck in an otherwise fast program. To speed this up, there are two things you can do."
msgstr "터미널에 인쇄하는 것은 놀라울 정도로 느립니다! 루프에서 `println!`과 같은 것을 호출하면 그렇지 않으면 빠른 프로그램에서 쉽게 병목 현상이 발생할 수 있습니다. 이를 가속화하기 위해 할 수 있는 두 가지가 있습니다."

#: src/tutorial/output.md:126
msgid "First, you might want to reduce the number of writes that actually \"flush\" to the terminal. `println!` tells the system to flush to the terminal _every_ time, because it is common to print each new line. If you don't need that, you can wrap your `stdout` handle in a [`BufWriter`](https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html) which by default buffers up to 8 kB. (You can still call `.flush()` on this `BufWriter` when you want to print immediately.)"
msgstr "첫째, 실제로 터미널로 \"플러시\"되는 쓰기 횟수를 줄이고 싶을 수 있습니다. `println!`은 각 새 줄을 인쇄하는 것이 일반적이므로 _매번_ 터미널로 플러시하도록 시스템에 지시합니다. 필요하지 않은 경우 `stdout` 핸들을 기본적으로 최대 8kB까지 버퍼링하는 [`BufWriter`](https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html)로 래핑할 수 있습니다. (즉시 인쇄하려면 이 `BufWriter`에서 `.flush()`를 계속 호출할 수 있습니다.)"

#: src/tutorial/output.md:140 src/tutorial/output.md:153
msgid "// get the global stdout entity\n"
msgstr "// 전역 stdout 엔터티 가져오기\n"

#: src/tutorial/output.md:141
msgid "// optional: wrap that handle in a buffer\n"
msgstr "// 선택 사항: 해당 핸들을 버퍼로 래핑\n"

#: src/tutorial/output.md:142 src/tutorial/output.md:155
msgid "foo: {}"
msgstr "foo: {}"

#: src/tutorial/output.md:142 src/tutorial/output.md:155
msgid "// add `?` if you care about errors here\n"
msgstr "// 여기에 오류가 있는 경우 `?` 추가\n"

#: src/tutorial/output.md:145
msgid "Second, it helps to acquire a lock on `stdout` (or `stderr`) and use `writeln!` to print to it directly. This prevents the system from locking and unlocking `stdout` over and over again."
msgstr "둘째, `stdout`(또는 `stderr`)에 대한 잠금을 획득하고 `writeln!`을 사용하여 직접 인쇄하는 것이 도움이 됩니다. 이렇게 하면 시스템이 `stdout`을 반복해서 잠그고 잠금 해제하는 것을 방지할 수 있습니다."

#: src/tutorial/output.md:154
msgid "// acquire a lock on it\n"
msgstr "// 잠금 획득\n"

#: src/tutorial/output.md:158
msgid "You can also combine the two approaches."
msgstr "두 가지 접근 방식을 결합할 수도 있습니다."

#: src/tutorial/output.md:162
msgid "Showing a progress bar"
msgstr "진행률 표시줄 표시"

#: src/tutorial/output.md:164
msgid "Some CLI applications run less than a second, others take minutes or hours. If you are writing one of the latter types of programs, you might want to show the user that something is happening. For this, you should try to print useful status updates, ideally in a form that can be easily consumed."
msgstr "일부 CLI 응용 프로그램은 1초 미만으로 실행되고 다른 응용 프로그램은 몇 분 또는 몇 시간이 걸립니다. 후자의 유형의 프로그램을 작성하는 경우 사용자에게 무언가 일어나고 있음을 보여주고 싶을 수 있습니다. 이를 위해 유용한 상태 업데이트를 인쇄해야 하며, 이상적으로는 쉽게 사용할 수 있는 형식으로 인쇄해야 합니다."

#: src/tutorial/output.md:171
msgid "Using the [indicatif](https://crates.io/crates/indicatif) crate, you can add progress bars and little spinners to your program. Here's a quick example:"
msgstr "[indicatif](https://crates.io/crates/indicatif) 크레이트를 사용하여 프로그램에 진행률 표시줄과 작은 스피너를 추가할 수 있습니다. 다음은 간단한 예입니다."

#: src/tutorial/output.md:181
msgid "[+] finished #{}"
msgstr "[+] 완료 #{}"

#: src/tutorial/output.md:184
msgid "done"
msgstr "완료"

#: src/tutorial/output.md:188
msgid "See the [documentation](https://docs.rs/indicatif) and [examples](https://github.com/console-rs/indicatif/tree/main/examples) for more information."
msgstr "자세한 내용은 [문서](https://docs.rs/indicatif) 및 [예제](https://github.com/console-rs/indicatif/tree/main/examples)를 참조하세요."

#: src/tutorial/output.md:196
msgid "Logging"
msgstr "로깅"

#: src/tutorial/output.md:198
msgid "To make it easier to understand what is happening in our program, we might want to add some log statements. This is usually easy while writing your application. But it will become super helpful when running this program again in half a year. In some regard, logging is the same as using `println!`, except that you can specify the importance of a message. The levels you can usually use are _error_, _warn_, _info_, _debug_, and _trace_ (_error_ has the highest priority, _trace_ the lowest)."
msgstr "프로그램에서 무슨 일이 일어나고 있는지 더 쉽게 이해하기 위해 몇 가지 로그 문을 추가하고 싶을 수 있습니다. 이것은 일반적으로 응용 프로그램을 작성하는 동안 쉽습니다. 하지만 반년 후에 이 프로그램을 다시 실행하면 매우 유용할 것입니다. 어떤 면에서 로깅은 `println!`을 사용하는 것과 동일하지만 메시지의 중요도를 지정할 수 있다는 점이 다릅니다. 일반적으로 사용할 수 있는 수준은 _error_, _warn_, _info_, _debug_ 및 _trace_입니다(_error_가 가장 높은 우선순위를 갖고 _trace_가 가장 낮음)."

#: src/tutorial/output.md:208
msgid "To add simple logging to your application, you'll need two things: The [log](https://crates.io/crates/log) crate (this contains macros named after the log level) and an _adapter_ that actually writes the log output somewhere useful. Having the ability to use log adapters is very flexible: You can, for example, use them to write logs not only to the terminal but also to [syslog](https://en.wikipedia.org/wiki/Syslog), or to a central log server."
msgstr "응용 프로그램에 간단한 로깅을 추가하려면 두 가지가 필요합니다. [log](https://crates.io/crates/log) 크레이트(로그 수준의 이름을 딴 매크로 포함)와 실제로 로그 출력을 유용한 곳에 쓰는 _어댑터_입니다. 로그 어댑터를 사용하는 기능은 매우 유연합니다. 예를 들어 터미널뿐만 아니라 [syslog](https://en.wikipedia.org/wiki/Syslog) 또는 중앙 로그 서버에도 로그를 쓰는 데 사용할 수 있습니다."

#: src/tutorial/output.md:218
msgid "Since we are right now only concerned with writing a CLI application, an easy adapter to use is [env_logger](https://crates.io/crates/env_logger). It's called \"env\" logger because you can use an environment variable to specify which parts of your application you want to log (and at which level you want to log them). It will prefix your log messages with a timestamp and the module where the log messages come from. Since libraries can also use `log`, you easily configure their log output, too."
msgstr "지금은 CLI 응용 프로그램을 작성하는 데만 관심이 있으므로 사용하기 쉬운 어댑터는 [env_logger](https://crates.io/crates/env_logger)입니다. 응용 프로그램의 어떤 부분을 기록할지(그리고 어떤 수준에서 기록할지) 지정하는 데 환경 변수를 사용할 수 있기 때문에 \"env\" 로거라고 합니다. 로그 메시지 앞에 타임스탬프와 로그 메시지가 온 모듈을 접두사로 붙입니다. 라이브러리도 `log`를 사용할 수 있으므로 로그 출력을 쉽게 구성할 수 있습니다."

#: src/tutorial/output.md:232
msgid "Here's a quick example:"
msgstr "다음은 간단한 예입니다."

#: src/tutorial/output.md:239
msgid "starting up"
msgstr "시작 중"

#: src/tutorial/output.md:240
msgid "oops, nothing implemented!"
msgstr "이런, 아무것도 구현되지 않았습니다!"

#: src/tutorial/output.md:244
msgid "Assuming you have this file as `src/bin/output-log.rs`, on Linux and macOS, you can run it like this:"
msgstr "이 파일을 `src/bin/output-log.rs`로 가지고 있다고 가정하면 Linux 및 macOS에서 다음과 같이 실행할 수 있습니다."

#: src/tutorial/output.md:254
msgid "In Windows PowerShell, you can run it like this:"
msgstr "Windows PowerShell에서는 다음과 같이 실행할 수 있습니다."

#: src/tutorial/output.md:255
msgid "```console\n$ $env:RUST_LOG=\"info\"\n$ cargo run --bin output-log\n    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\n     Running `target/debug/output-log.exe`\n[2018-11-30T20:25:52Z INFO  output_log] starting up\n[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!\n```"
msgstr "```console\n$ $env:RUST_LOG=\"info\"\n$ cargo run --bin output-log\n    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\n     Running `target/debug/output-log.exe`\n[2018-11-30T20:25:52Z INFO  output_log] starting up\n[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!\n```"

#: src/tutorial/output.md:264
msgid "In Windows CMD, you can run it like this:"
msgstr "Windows CMD에서는 다음과 같이 실행할 수 있습니다."

#: src/tutorial/output.md:274
msgid "`RUST_LOG` is the name of the environment variable you can use to set your log settings. `env_logger` also contains a builder so you can programmatically adjust these settings, and, for example, also show _info_ level messages by default."
msgstr "`RUST_LOG`는 로그 설정을 지정하는 데 사용할 수 있는 환경 변수의 이름입니다. `env_logger`에는 이러한 설정을 프로그래밍 방식으로 조정하고 예를 들어 기본적으로 _info_ 수준 메시지를 표시할 수 있는 빌더도 포함되어 있습니다."

#: src/tutorial/output.md:280
msgid "There are a lot of alternative logging adapters out there, and also alternatives or extensions to `log`. If you know your application will have a lot to log, make sure to review them, and make your users' life easier."
msgstr "대체 로깅 어댑터가 많이 있으며 `log`에 대한 대안 또는 확장도 있습니다. 응용 프로그램에 기록할 내용이 많다는 것을 알고 있다면 이를 검토하고 사용자의 삶을 더 쉽게 만드십시오."

#: src/tutorial/output.md:288
msgid "**Tip:** Experience has shown that even mildly useful CLI programs can end up being used for years to come. (Especially if they were meant as a temporary solution.) If your application doesn't work and someone (e.g., you, in the future) needs to figure out why, being able to pass `--verbose` to get additional log output can make the difference between minutes and hours of debugging. The [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) crate contains a quick way to add a `--verbose` to a project using `clap`. "
msgstr "**팁:** 경험에 따르면 약간 유용한 CLI 프로그램이라도 앞으로 몇 년 동안 사용될 수 있습니다. (특히 임시 해결책으로 의도된 경우) 응용 프로그램이 작동하지 않고 누군가(예: 미래의 당신)가 이유를 알아내야 하는 경우 `--verbose`를 전달하여 추가 로그 출력을 얻을 수 있으면 디버깅 시간이 몇 분에서 몇 시간으로 단축될 수 있습니다. [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) 크레이트에는 `clap`을 사용하는 프로젝트에 `--verbose`를 추가하는 빠른 방법이 포함되어 있습니다. "

#: src/tutorial/testing.md:3
msgid "Over decades of software development, people have discovered one truth: Untested software rarely works. (Many people would go as far as saying: \"Most tested software doesn't work either.\" But we are all optimists here, right?) So, to ensure that your program does what you expect it to do, it is wise to test it."
msgstr "수십 년간의 소프트웨어 개발을 통해 사람들은 한 가지 진실을 발견했습니다. 테스트되지 않은 소프트웨어는 거의 작동하지 않습니다. (많은 사람들은 \"대부분의 테스트된 소프트웨어도 작동하지 않는다\"고까지 말할 것입니다. 하지만 우리는 모두 여기서 낙관주의자입니다, 그렇죠?) 따라서 프로그램이 예상대로 작동하는지 확인하려면 테스트하는 것이 현명합니다."

#: src/tutorial/testing.md:12
msgid "One easy way to do that is to write a `README` file that describes what your program should do. And when you feel ready to make a new release, go through the `README` and ensure that the behavior is still as expected. You can make this a more rigorous exercise by also writing down how your program should react to erroneous inputs."
msgstr "이를 수행하는 한 가지 쉬운 방법은 프로그램이 수행해야 할 작업을 설명하는 `README` 파일을 작성하는 것입니다. 그리고 새 릴리스를 만들 준비가 되면 `README`를 살펴보고 동작이 여전히 예상대로인지 확인합니다. 프로그램이 잘못된 입력에 어떻게 반응해야 하는지 기록하여 이 연습을 더 엄격하게 만들 수도 있습니다."

#: src/tutorial/testing.md:21
msgid "Here's another fancy idea: Write that `README` before you write the code."
msgstr "여기 또 다른 멋진 아이디어가 있습니다. 코드를 작성하기 전에 `README`를 작성하세요."

#: src/tutorial/testing.md:26
msgid "**Note:** Have a look at [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development) (TDD) if you haven't heard of it."
msgstr "**참고:** [테스트 주도 개발](https://en.wikipedia.org/wiki/Test-driven_development)(TDD)에 대해 들어본 적이 없다면 살펴보세요."

#: src/tutorial/testing.md:36
msgid "Automated testing"
msgstr "자동화된 테스트"

#: src/tutorial/testing.md:38
msgid "Now, this is all fine and dandy, but doing all of this manually? That can take a lot of time. At the same time, many people have come to enjoy telling computers to do things for them. Let's talk about how to automate these tests."
msgstr "이제 이것은 모두 괜찮지만 이 모든 것을 수동으로 수행하시겠습니까? 시간이 많이 걸릴 수 있습니다. 동시에 많은 사람들이 컴퓨터에 일을 시키는 것을 즐기게 되었습니다. 이러한 테스트를 자동화하는 방법에 대해 이야기해 봅시다."

#: src/tutorial/testing.md:45
msgid "Rust has a built-in test framework, so let's start by writing a first test:"
msgstr "Rust에는 내장 테스트 프레임워크가 있으므로 첫 번째 테스트를 작성하는 것부터 시작하겠습니다."

#: src/tutorial/testing.md:59
msgid "You can put this snippet of code in pretty much any source file in your package and `cargo test` will find and run it. The key here is the `#[test]` attribute. It allows the build system to discover such functions and run them as tests, verifying that they don't panic."
msgstr "이 코드 조각을 패키지의 거의 모든 소스 파일에 넣을 수 있으며 `cargo test`가 이를 찾아 실행합니다. 여기서 핵심은 `#[test]` 속성입니다. 이를 통해 빌드 시스템이 이러한 함수를 검색하고 테스트로 실행하여 패닉이 발생하지 않는지 확인할 수 있습니다."

#: src/tutorial/testing.md:69
msgid "**Exercise for the reader:** Make this test work."
msgstr "**독자를 위한 연습:** 이 테스트가 작동하도록 만드세요."

#: src/tutorial/testing.md:72
msgid "You should end up with output like the following:"
msgstr "다음과 같은 출력이 표시되어야 합니다."

#: src/tutorial/testing.md:83
msgid "Now that we've seen _how_ we can write tests, we still need to figure out _what_ to test. As you've seen it's fairly easy to write assertions for functions. But a CLI application is often more than one function! Worse, it often deals with user input, reads files, and writes output."
msgstr "이제 테스트를 작성하는 _방법_을 보았으므로 _무엇_을 테스트해야 하는지 알아내야 합니다. 보시다시피 함수에 대한 어설션을 작성하는 것은 매우 쉽습니다. 하지만 CLI 응용 프로그램은 종종 하나 이상의 함수입니다! 더 나쁜 것은 종종 사용자 입력을 처리하고 파일을 읽고 출력을 쓴다는 것입니다."

#: src/tutorial/testing.md:92
msgid "Making your code testable"
msgstr "코드를 테스트 가능하게 만들기"

#: src/tutorial/testing.md:94
msgid "There are two complementary approaches to testing functionality: Testing the small units that you build your complete application from, these are called \"unit tests\". There is also testing the final application \"from the outside\" called \"black box tests\" or \"integration tests\". Let's begin with the first one."
msgstr "기능을 테스트하는 데는 두 가지 보완적인 접근 방식이 있습니다. 완전한 응용 프로그램을 구성하는 작은 단위를 테스트하는 것을 \"단위 테스트\"라고 합니다. 최종 응용 프로그램을 \"외부에서\" 테스트하는 것을 \"블랙박스 테스트\" 또는 \"통합 테스트\"라고도 합니다. 첫 번째부터 시작하겠습니다."

#: src/tutorial/testing.md:101
msgid "To figure out what we should test, let's see what our program features are. Mainly, `grrs` is supposed to print out the lines that match a given pattern. So, let's write unit tests for _exactly this_: We want to ensure that our most important piece of logic works, and we want to do it in a way that is not dependent on any of the setup code we have around it (that deals with CLI arguments, for example)."
msgstr "무엇을 테스트해야 하는지 알아보기 위해 프로그램 기능이 무엇인지 살펴보겠습니다. 주로 `grrs`는 주어진 패턴과 일치하는 줄을 인쇄해야 합니다. 따라서 _정확히 이것_에 대한 단위 테스트를 작성해 봅시다. 가장 중요한 로직이 작동하는지 확인하고 싶고, 주변에 있는 설정 코드(예: CLI 인수 처리)에 의존하지 않는 방식으로 수행하고 싶습니다."

#: src/tutorial/testing.md:110
msgid "Going back to our [first implementation](impl-draft.md) of `grrs`, we added this block of code to the `main` function:"
msgstr "`grrs`의 [첫 번째 구현](impl-draft.md)으로 돌아가서 `main` 함수에 이 코드 블록을 추가했습니다."

#: src/tutorial/testing.md:114
msgid "// ...\n"
msgstr "// ...\n"

#: src/tutorial/testing.md:122
msgid "Sadly, this is not very easy to test. First of all, it's in the main function, so we can't easily call it. This is easily fixed by moving this piece of code into a function:"
msgstr "안타깝게도 이것은 테스트하기가 쉽지 않습니다. 우선, `main` 함수에 있으므로 쉽게 호출할 수 없습니다. 이 코드 조각을 함수로 옮기면 쉽게 해결할 수 있습니다."

#: src/tutorial/testing.md:136
msgid "Now we can call this function in our test, and see what its output is:"
msgstr "이제 테스트에서 이 함수를 호출하고 출력이 무엇인지 확인할 수 있습니다."

#: src/tutorial/testing.md:142 src/tutorial/testing.md:243
msgid "lorem ipsum\ndolor sit amet"
msgstr "lorem ipsum\ndolor sit amet"

#: src/tutorial/testing.md:142 src/tutorial/testing.md:243
msgid "lorem"
msgstr "lorem"

#: src/tutorial/testing.md:143
msgid "// uhhhh\n"
msgstr "// 어...\n"

#: src/tutorial/testing.md:146
msgid "Or… can we? Right now, `find_matches` prints directly to `stdout`, i.e., the terminal. We can't easily capture this in a test! This is a problem that often comes up when writing tests after the implementation: We have written a function that is firmly integrated in the context it is used in."
msgstr "아니면... 할 수 있을까요? 지금 `find_matches`는 `stdout`, 즉 터미널에 직접 인쇄합니다. 테스트에서 이것을 쉽게 캡처할 수 없습니다! 이것은 구현 후에 테스트를 작성할 때 종종 발생하는 문제입니다. 우리는 사용되는 컨텍스트에 확고하게 통합된 함수를 작성했습니다."

#: src/tutorial/testing.md:156
msgid "**Note:** This is totally fine when writing small CLI applications. There's no need to make everything testable! It is important to think about which parts of your code you might want to write unit tests for, however. While we'll see that it's easy to change this function to be testable, this is not always the case."
msgstr "**참고:** 이것은 작은 CLI 응용 프로그램을 작성할 때 완전히 괜찮습니다. 모든 것을 테스트 가능하게 만들 필요는 없습니다! 그러나 코드의 어떤 부분에 대해 단위 테스트를 작성하고 싶은지 생각하는 것이 중요합니다. 이 함수를 테스트 가능하게 변경하는 것이 쉽다는 것을 알게 되겠지만 항상 그런 것은 아닙니다."

#: src/tutorial/testing.md:166
msgid "Alright, how can we make this testable? We'll need to capture the output somehow. Rust's standard library has some neat abstractions for dealing with I/O (input/output) and we'll make use of one called [`std::io::Write`](https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html). This is a [trait](https://doc.rust-lang.org/book/ch10-02-traits.html) that abstracts over things we can write to, which includes strings but also `stdout`."
msgstr "좋습니다, 어떻게 테스트 가능하게 만들 수 있을까요? 어떻게든 출력을 캡처해야 합니다. Rust의 표준 라이브러리에는 I/O(입력/출력)를 처리하기 위한 몇 가지 깔끔한 추상화가 있으며 [`std::io::Write`](https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html)라는 것을 사용할 것입니다. 이것은 문자열뿐만 아니라 `stdout`도 포함하여 우리가 쓸 수 있는 것들을 추상화하는 [특성](https://doc.rust-lang.org/book/ch10-02-traits.html)입니다."

#: src/tutorial/testing.md:177
msgid "If this is the first time you've heard \"trait\" in the context of Rust, you are in for a treat. Traits are one of the most powerful features of Rust. You can think of them like interfaces in Java, or type classes in Haskell (whatever you are more familiar with). They allow you to abstract over behavior that can be shared by different types. Code that uses traits can express ideas in very generic and flexible ways. This means it can also get difficult to read, though. Don't let that intimidate you: Even people who have used Rust for years don't always get what generic code does immediately. In that case, it helps to think of concrete uses. For example, in our case, the behavior that we abstract over is \"write to it\". Examples for the types that implement (\"impl\") it include: The terminal's standard output, files, a buffer in memory, or TCP network connections. (Scroll down in the [documentation for `std::io::Write`](https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html) to see a list of \"Implementors\".)"
msgstr "Rust의 맥락에서 \"특성\"이라는 말을 처음 들어본다면, 당신은 운이 좋습니다. 특성은 Rust의 가장 강력한 기능 중 하나입니다. Java의 인터페이스나 Haskell의 유형 클래스(어느 쪽이 더 익숙하든)와 같다고 생각할 수 있습니다. 이를 통해 다른 유형에서 공유할 수 있는 동작을 추상화할 수 있습니다. 특성을 사용하는 코드는 매우 일반적이고 유연한 방식으로 아이디어를 표현할 수 있습니다. 하지만 이것은 읽기 어려워질 수도 있다는 것을 의미합니다. 겁먹지 마세요. 수년 동안 Rust를 사용해 온 사람들조차도 제네릭 코드가 즉시 무엇을 하는지 항상 이해하지는 못합니다. 이 경우 구체적인 용도를 생각하는 것이 도움이 됩니다. 예를 들어, 우리의 경우 추상화하는 동작은 \"쓰기\"입니다. 이를 구현하는( \"impl\") 유형의 예로는 터미널의 표준 출력, 파일, 메모리의 버퍼 또는 TCP 네트워크 연결이 있습니다. ([`std::io::Write`에 대한 문서](https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html)에서 \"구현자\" 목록을 보려면 아래로 스크롤하세요.)"

#: src/tutorial/testing.md:206
msgid "With that knowledge, let's change our function to accept a third parameter. It should be of any type that implements `Write`. This way, we can then supply a simple string in our tests and make assertions on it. Here is how we can write this version of `find_matches`:"
msgstr "그 지식을 바탕으로 함수가 세 번째 매개변수를 받도록 변경해 봅시다. `Write`를 구현하는 모든 유형이어야 합니다. 이렇게 하면 테스트에서 간단한 문자열을 제공하고 이에 대한 어설션을 만들 수 있습니다. 다음은 이 버전의 `find_matches`를 작성하는 방법입니다."

#: src/tutorial/testing.md:225
msgid "The new parameter is `mut writer`, i.e., a mutable thing we call \"writer\". Its type is `impl std::io::Write`, which you can read as \"a placeholder for any type that implements the `Write` trait\". Also note how we replaced the `println!(…)` we used earlier with `writeln!(writer, …)`. `println!` works the same as `writeln!` but always uses standard output."
msgstr "새 매개변수는 `mut writer`, 즉 \"writer\"라고 부르는 변경 가능한 것입니다. 유형은 `impl std::io::Write`이며, 이는 \"`Write` 특성을 구현하는 모든 유형에 대한 자리 표시자\"로 읽을 수 있습니다. 또한 이전에 사용했던 `println!(…)`을 `writeln!(writer, …)`으로 바꾼 방법도 주목하세요. `println!`은 `writeln!`과 동일하게 작동하지만 항상 표준 출력을 사용합니다."

#: src/tutorial/testing.md:237
msgid "Now we can test for the output:"
msgstr "이제 출력을 테스트할 수 있습니다."

#: src/tutorial/testing.md:244
msgid "b\"lorem ipsum\n""
msgstr "b\"lorem ipsum\n""

#: src/tutorial/testing.md:248
msgid "To now use this in our application code, we have to change the call to `find_matches` in `main` by adding [`&mut std::io::stdout()`](https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html) as the third parameter. Here's an example of a main function that builds on what we've seen in the previous chapters and uses our extracted `find_matches` function:"
msgstr "이제 응용 프로그램 코드에서 이것을 사용하려면 `main`에서 `find_matches`에 대한 호출을 세 번째 매개변수로 [`&mut std::io::stdout()`](https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html)을 추가하여 변경해야 합니다. 다음은 이전 장에서 본 내용을 기반으로 하고 추출된 `find_matches` 함수를 사용하는 `main` 함수의 예입니다."

#: src/tutorial/testing.md:271
msgid "**Note:** Since `stdout` expects bytes (not strings), we use `std::io::Write` instead of `std::fmt::Write`. As a result, we give an empty vector as \"writer\" in our tests (its type will be inferred to `Vec<u8>`), in the `assert_eq!` we use a `b\"foo\"`. (The `b` prefix makes this a _byte string literal_ so its type is going to be `&[u8]` instead of `&str`)."
msgstr "**참고:** `stdout`은 바이트(문자열이 아님)를 예상하므로 `std::fmt::Write` 대신 `std::io::Write`를 사용합니다. 결과적으로 테스트에서 빈 벡터를 \"writer\"로 제공하고(유형은 `Vec<u8>`로 유추됨), `assert_eq!`에서는 `b\"foo\"`를 사용합니다. (`b` 접두사는 이것을 _바이트 문자열 리터럴_로 만들므로 유형은 `&str` 대신 `&[u8]`가 됩니다)."

#: src/tutorial/testing.md:285
msgid "**Note:** We could also make this function return a `String`, but that would change its behavior. Instead of writing to the terminal directly, it would then collect everything into a string, and dump all the results in one go at the end."
msgstr "**참고:** 이 함수가 `String`을 반환하도록 만들 수도 있지만 그렇게 하면 동작이 변경됩니다. 터미널에 직접 쓰는 대신 모든 것을 문자열로 수집하고 마지막에 모든 결과를 한 번에 덤프합니다."

#: src/tutorial/testing.md:296
msgid "**Exercise for the reader:** [`writeln!`](https://doc.rust-lang.org/1.39.0/std/macro.writeln.html) returns an [`io::Result`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html) because writing can fail, for example when the buffer is full and cannot be expanded. Add error handling to `find_matches`."
msgstr "**독자를 위한 연습:** [`writeln!`](https://doc.rust-lang.org/1.39.0/std/macro.writeln.html)은 예를 들어 버퍼가 가득 차서 확장할 수 없을 때 쓰기가 실패할 수 있기 때문에 [`io::Result`](https://doc.rust-lang.org/1.39.0/std/io/type.Result.html)를 반환합니다. `find_matches`에 오류 처리를 추가하세요."

#: src/tutorial/testing.md:307
msgid "We've just seen how to make this piece of code easily testable. We have"
msgstr "이 코드 조각을 쉽게 테스트할 수 있는 방법을 방금 보았습니다. 우리는"

#: src/tutorial/testing.md:310
msgid "identified one of the core pieces of our application,"
msgstr "우리 응용 프로그램의 핵심 부분 중 하나를 식별했습니다."

#: src/tutorial/testing.md:311
msgid "put it into its own function,"
msgstr "자체 함수에 넣었습니다."

#: src/tutorial/testing.md:312
msgid "and made it more flexible."
msgstr "그리고 더 유연하게 만들었습니다."

#: src/tutorial/testing.md:314
msgid "Even though the goal was to make it testable, the result we ended up with is actually a very idiomatic and reusable piece of Rust code. That's awesome!"
msgstr "목표는 테스트 가능하게 만드는 것이었지만, 우리가 얻은 결과는 실제로 매우 관용적이고 재사용 가능한 Rust 코드 조각입니다. 정말 멋집니다!"

#: src/tutorial/testing.md:319
msgid "Splitting your code into library and binary targets"
msgstr "코드를 라이브러리 및 바이너리 대상으로 분할"

#: src/tutorial/testing.md:321
msgid "We can do one more thing here. So far we've put everything we wrote into the `src/main.rs` file. This means our current project produces a single binary. But we can also make our code available as a library, like this:"
msgstr "여기서 한 가지 더 할 수 있습니다. 지금까지 작성한 모든 것을 `src/main.rs` 파일에 넣었습니다. 이것은 현재 프로젝트가 단일 바이너리를 생성한다는 것을 의미합니다. 하지만 다음과 같이 코드를 라이브러리로 사용할 수도 있습니다."

#: src/tutorial/testing.md:326
msgid "Put the `find_matches` function into a new `src/lib.rs`."
msgstr "`find_matches` 함수를 새 `src/lib.rs`에 넣습니다."

#: src/tutorial/testing.md:327
msgid "Add a `pub` in front of the `fn` (so it's `pub fn find_matches`) to make it something that users of our library can access."
msgstr "`fn` 앞에 `pub`를 추가하여(`pub fn find_matches`가 되도록) 라이브러리 사용자가 액세스할 수 있도록 합니다."

#: src/tutorial/testing.md:329
msgid "Remove `find_matches` from `src/main.rs`."
msgstr "`src/main.rs`에서 `find_matches`를 제거합니다."

#: src/tutorial/testing.md:330
msgid "In the `fn main`, prepend the call to `find_matches` with `grrs::`, so it's now `grrs::find_matches(…)`. This means it uses the function from the library we just wrote!"
msgstr "`fn main`에서 `find_matches`에 대한 호출 앞에 `grrs::`를 붙여 이제 `grrs::find_matches(…)`가 되도록 합니다. 이것은 방금 작성한 라이브러리의 함수를 사용한다는 것을 의미합니다!"

#: src/tutorial/testing.md:334
msgid "The way Rust deals with projects is quite flexible and it's a good idea to think about what to put into the library part of your crate early on. You can for example think about writing a library for your application-specific logic first and then use it in your CLI just like any other library. Or, if your project has multiple binaries, you can put the common functionality into the library part of that crate."
msgstr "Rust가 프로젝트를 처리하는 방식은 매우 유연하며 크레이트의 라이브러리 부분에 무엇을 넣을지 미리 생각하는 것이 좋습니다. 예를 들어, 응용 프로그램별 로직을 위한 라이브러리를 먼저 작성한 다음 다른 라이브러리처럼 CLI에서 사용할 수 있습니다. 또는 프로젝트에 여러 바이너리가 있는 경우 공통 기능을 해당 크레이트의 라이브러리 부분에 넣을 수 있습니다."

#: src/tutorial/testing.md:345
msgid "**Note:** Speaking of putting everything into a `src/main.rs`: If we continue to do that, it'll become difficult to read. The [module system](https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html) can help you structure and organize your code."
msgstr "**참고:** 모든 것을 `src/main.rs`에 넣는 것에 대해 말하자면, 계속 그렇게 하면 읽기 어려워질 것입니다. [모듈 시스템](https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)은 코드를 구조화하고 구성하는 데 도움이 될 수 있습니다."

#: src/tutorial/testing.md:356
msgid "Testing CLI applications by running them"
msgstr "실행하여 CLI 응용 프로그램 테스트"

#: src/tutorial/testing.md:358
msgid "Thus far, we've gone out of our way to test the _business logic_ of our application, which turned out to be the `find_matches` function. This is very valuable and is a great first step towards a well-tested code base. (Usually, these kinds of tests are called \"unit tests\".)"
msgstr "지금까지 우리는 응용 프로그램의 _비즈니스 로직_을 테스트하기 위해 많은 노력을 기울였으며, 이는 `find_matches` 함수로 판명되었습니다. 이것은 매우 가치가 있으며 잘 테스트된 코드 기반을 향한 훌륭한 첫 걸음입니다. (일반적으로 이러한 종류의 테스트를 \"단위 테스트\"라고 합니다.)"

#: src/tutorial/testing.md:366
msgid "There is a lot of code we aren't testing, though: Everything that we wrote to deal with the outside world! Imagine you wrote the main function, but accidentally left in a hard-coded string instead of using the argument of the user-supplied path. We should write tests for that, too! (This level of testing is often called \"integration testing\", or \"system testing\".)"
msgstr "하지만 테스트하지 않는 코드가 많이 있습니다. 외부 세계를 처리하기 위해 작성한 모든 것입니다! `main` 함수를 작성했지만 사용자 제공 경로의 인수를 사용하는 대신 하드 코딩된 문자열을 실수로 남겨 두었다고 상상해 보십시오. 이에 대한 테스트도 작성해야 합니다! (이 수준의 테스트는 종종 \"통합 테스트\" 또는 \"시스템 테스트\"라고 합니다.)"

#: src/tutorial/testing.md:375
msgid "At its core, we are still writing functions and annotating them with `#[test]`. It's just a matter of what we do inside these functions. For example, we'll want to use the main binary of our project, and run it like a regular program. We will also put these tests into a new file in a new directory: `tests/cli.rs`."
msgstr "핵심적으로 우리는 여전히 함수를 작성하고 `#[test]`로 주석을 답니다. 이러한 함수 내부에서 무엇을 하는지가 문제입니다. 예를 들어, 프로젝트의 주 바이너리를 사용하고 일반 프로그램처럼 실행하고 싶을 것입니다. 또한 이러한 테스트를 새 디렉토리의 새 파일인 `tests/cli.rs`에 넣을 것입니다."

#: src/tutorial/testing.md:386
msgid "**Note:** By convention, `cargo` will look for integration tests in the `tests/` directory. Similarly, it will look for benchmarks in `benches/`, and examples in `examples/`. These conventions also extend to your main source code: libraries have a `src/lib.rs` file, the main binary is `src/main.rs`, or, if there are multiple binaries, cargo expects them to be in `src/bin/<name>.rs`. Following these conventions will make your code base more discoverable by people used to reading Rust code."
msgstr "**참고:** 규칙에 따라 `cargo`는 `tests/` 디렉토리에서 통합 테스트를 찾습니다. 마찬가지로 `benches/`에서 벤치마크를, `examples/`에서 예제를 찾습니다. 이러한 규칙은 주 소스 코드에도 적용됩니다. 라이브러리에는 `src/lib.rs` 파일이 있고, 주 바이너리는 `src/main.rs`이거나, 여러 바이너리가 있는 경우 cargo는 `src/bin/<name>.rs`에 있을 것으로 예상합니다. 이러한 규칙을 따르면 Rust 코드를 읽는 데 익숙한 사람들이 코드 기반을 더 쉽게 찾을 수 있습니다."

#: src/tutorial/testing.md:402
msgid "To recall, `grrs` is a small tool that searches for a string in a file. We have previously tested that we can find a match. Let's think about what other functionality we can test."
msgstr "다시 말해, `grrs`는 파일에서 문자열을 검색하는 작은 도구입니다. 이전에 일치 항목을 찾을 수 있는지 테스트했습니다. 테스트할 수 있는 다른 기능에 대해 생각해 봅시다."

#: src/tutorial/testing.md:407
msgid "Here is what I came up with."
msgstr "제가 생각해 낸 것은 다음과 같습니다."

#: src/tutorial/testing.md:409
msgid "What happens when the file doesn't exist?"
msgstr "파일이 존재하지 않으면 어떻게 됩니까?"

#: src/tutorial/testing.md:410
msgid "What is the output when there is no match?"
msgstr "일치하는 항목이 없을 때 출력은 무엇입니까?"

#: src/tutorial/testing.md:411
msgid "Does our program exit with an error when we forget one (or both) arguments?"
msgstr "인수 중 하나(또는 둘 다)를 잊어버리면 프로그램이 오류와 함께 종료됩니까?"

#: src/tutorial/testing.md:413
msgid "These are all valid test cases. Additionally, we should also include one test case for the \"happy path\", i.e., we found at least one match and we print it."
msgstr "이것들은 모두 유효한 테스트 사례입니다. 또한 \"해피 패스\"에 대한 테스트 사례도 하나 포함해야 합니다. 즉, 하나 이상의 일치 항목을 찾았고 이를 인쇄합니다."

#: src/tutorial/testing.md:420
msgid "To make these kinds of tests easier, we're going to use the [`assert_cmd`](https://docs.rs/assert_cmd) crate. It has a bunch of neat helpers that allow us to run our main binary and see how it behaves. Further, we'll also add the [`predicates`](https://docs.rs/predicates) crate which helps us write assertions that `assert_cmd` can test against (and that have great error messages). We'll add those dependencies not to the main list, but to a \"dev dependencies\" section in our `Cargo.toml`. They are only required when developing the crate, not when using it."
msgstr "이러한 종류의 테스트를 더 쉽게 만들기 위해 [`assert_cmd`](https://docs.rs/assert_cmd) 크레이트를 사용할 것입니다. 여기에는 주 바이너리를 실행하고 동작 방식을 볼 수 있는 깔끔한 도우미가 많이 있습니다. 또한 `assert_cmd`가 테스트할 수 있는(그리고 훌륭한 오류 메시지가 있는) 어설션을 작성하는 데 도움이 되는 [`predicates`](https://docs.rs/predicates) 크레이트도 추가할 것입니다. 이러한 의존성은 주 목록이 아닌 `Cargo.toml`의 \"개발 의존성\" 섹션에 추가할 것입니다. 크레이트를 사용할 때가 아니라 개발할 때만 필요합니다."

#: src/tutorial/testing.md:435
msgid "```toml\n[dev-dependencies]\nassert_cmd = \"2.0.14\"\npredicates = \"3.1.0\"\n```"
msgstr "```toml\n[dev-dependencies]\nassert_cmd = \"2.0.14\"\npredicates = \"3.1.0\"\n```"

#: src/tutorial/testing.md:444
msgid "This sounds like a lot of setup. Nevertheless – let's dive right in and create our `tests/cli.rs` file:"
msgstr "설정이 많은 것 같습니다. 그럼에도 불구하고 바로 시작하여 `tests/cli.rs` 파일을 만들어 봅시다."

#: src/tutorial/testing.md:450
msgid "// Add methods on commands\n"
msgstr "// 명령에 메서드 추가\n"

#: src/tutorial/testing.md:451
msgid "// Used for writing assertions\n"
msgstr "// 어설션 작성에 사용\n"

#: src/tutorial/testing.md:452
msgid "// Run programs\n"
msgstr "// 프로그램 실행\n"

#: src/tutorial/testing.md:456 src/tutorial/testing.md:521
msgid "grrs"
msgstr "grrs"

#: src/tutorial/testing.md:458
msgid "foobar"
msgstr "foobar"

#: src/tutorial/testing.md:458
msgid "test/file/doesnt/exist"
msgstr "test/file/doesnt/exist"

#: src/tutorial/testing.md:467
msgid "You can run this test with `cargo test`, just like the tests we wrote above. It might take a little longer the first time, as `Command::cargo_bin(\"grrs\")` needs to compile your main binary."
msgstr "위에서 작성한 테스트와 마찬가지로 `cargo test`로 이 테스트를 실행할 수 있습니다. `Command::cargo_bin(\"grrs\")`가 주 바이너리를 컴파일해야 하므로 처음에는 시간이 조금 더 걸릴 수 있습니다."

#: src/tutorial/testing.md:473
msgid "Generating test files"
msgstr "테스트 파일 생성"

#: src/tutorial/testing.md:475
msgid "The test we've just seen only checks that our program writes an error message when the input file doesn't exist. That's an important test to have, but maybe not the most important one: Let's now test that we will actually print the matches we found in a file!"
msgstr "방금 본 테스트는 입력 파일이 없을 때 프로그램이 오류 메시지를 작성하는지 확인하는 것뿐입니다. 이것은 중요한 테스트이지만 가장 중요한 테스트는 아닐 수 있습니다. 이제 파일에서 찾은 일치 항목을 실제로 인쇄하는지 테스트해 봅시다!"

#: src/tutorial/testing.md:481
msgid "We'll need to have a file whose content we know, so that we can know what our program _should_ return and check this expectation in our code. One idea might be to add a file to the project with custom content and use that in our tests. Another would be to create temporary files in our tests. For this tutorial, we'll have a look at the latter approach. Mainly, because it is more flexible and will also work in other cases; for example, when you are testing programs that change the files."
msgstr "우리는 내용물을 아는 파일이 필요하므로 프로그램이 _반환해야_ 하는 것을 알고 코드에서 이 기대를 확인할 수 있습니다. 한 가지 아이디어는 사용자 지정 콘텐츠가 있는 파일을 프로젝트에 추가하고 테스트에서 사용하는 것입니다. 다른 하나는 테스트에서 임시 파일을 만드는 것입니다. 이 튜토리얼에서는 후자의 접근 방식을 살펴보겠습니다. 주로 더 유연하고 다른 경우에도 작동하기 때문입니다. 예를 들어 파일을 변경하는 프로그램을 테스트할 때입니다."

#: src/tutorial/testing.md:492
msgid "To create these temporary files, we'll be using the [`assert_fs`](https://docs.rs/assert_fs) crate. Let's add it to the `dev-dependencies` in our `Cargo.toml`:"
msgstr "이러한 임시 파일을 만들려면 [`assert_fs`](https://docs.rs/assert_fs) 크레이트를 사용할 것입니다. `Cargo.toml`의 `dev-dependencies`에 추가해 봅시다."

#: src/tutorial/testing.md:496
msgid "```toml\nassert_fs = \"1.1.1\"\n```"
msgstr "```toml\nassert_fs = \"1.1.1\"\n```"

#: src/tutorial/testing.md:502
msgid "Here is a new test case (that you can write below the other one) that first creates a temp file (a \"named\" one so we can get its path), fills it with some text, and then runs our program to see if we get the correct output. When the `file` goes out of scope (at the end of the function), the actual temporary file will automatically get deleted."
msgstr "다음은 다른 테스트 사례 아래에 작성할 수 있는 새 테스트 사례입니다. 먼저 임시 파일(경로를 얻을 수 있도록 \"이름이 지정된\" 파일)을 만들고 일부 텍스트로 채운 다음 프로그램을 실행하여 올바른 출력을 얻는지 확인합니다. `file`이 범위를 벗어나면(함수 끝에서) 실제 임시 파일이 자동으로 삭제됩니다."

#: src/tutorial/testing.md:518
msgid "sample.txt"
msgstr "sample.txt"

#: src/tutorial/testing.md:519
msgid "A test\nActual content\nMore content\nAnother test"
msgstr "테스트\n실제 내용\n더 많은 내용\n또 다른 테스트"

#: src/tutorial/testing.md:522
msgid "test"
msgstr "테스트"

#: src/tutorial/testing.md:525
msgid "A test\nAnother test"
msgstr "테스트\n또 다른 테스트"

#: src/tutorial/testing.md:533
msgid "**Exercise for the reader:** Add integration tests for passing an empty string as pattern. Adjust the program as needed."
msgstr "**독자를 위한 연습:** 빈 문자열을 패턴으로 전달하기 위한 통합 테스트를 추가하세요. 필요에 따라 프로그램을 조정하세요."

#: src/tutorial/testing.md:539
msgid "What to test?"
msgstr "무엇을 테스트해야 할까요?"

#: src/tutorial/testing.md:541
msgid "While it can certainly be fun to write integration tests, it will also take some time to write them, as well as to update them when your application's behavior changes. To make sure you use your time wisely, you should ask yourself what you should test."
msgstr "통합 테스트를 작성하는 것이 확실히 재미있을 수 있지만, 작성하는 데 시간이 걸리고 응용 프로그램의 동작이 변경될 때 업데이트하는 데도 시간이 걸립니다. 시간을 현명하게 사용하려면 무엇을 테스트해야 하는지 자문해야 합니다."

#: src/tutorial/testing.md:547
msgid "In general it's a good idea to write integration tests for all types of behavior that a user can observe. That means that you don't need to cover all edge cases: It usually suffices to have examples for the different types and rely on unit tests to cover the edge cases."
msgstr "일반적으로 사용자가 관찰할 수 있는 모든 유형의 동작에 대해 통합 테스트를 작성하는 것이 좋습니다. 즉, 모든 엣지 케이스를 다룰 필요는 없습니다. 일반적으로 다른 유형에 대한 예제를 갖고 단위 테스트에 의존하여 엣지 케이스를 다루는 것으로 충분합니다."

#: src/tutorial/testing.md:553
msgid "It is also a good idea not to focus your tests on things you can't actively control. It would be a bad idea to test the exact layout of `--help` as it is generated for you. Instead, you might just want to check that certain elements are present."
msgstr "또한 적극적으로 제어할 수 없는 것에 테스트를 집중하지 않는 것이 좋습니다. `--help`의 정확한 레이아웃은 자동으로 생성되므로 테스트하는 것은 좋지 않습니다. 대신 특정 요소가 있는지 확인하고 싶을 수 있습니다."

#: src/tutorial/testing.md:558
msgid "Depending on the nature of your program, you can also try to add more testing techniques. For example, if you have extracted parts of your program and find yourself writing a lot of example cases as unit tests while trying to come up with all the edge cases, you should look into [`proptest`](https://docs.rs/proptest). If you have a program which consumes arbitrary files and parses them, try to write a [fuzzer](https://rust-fuzz.github.io/book/introduction.html) to find bugs in edge cases."
msgstr "프로그램의 성격에 따라 더 많은 테스트 기술을 추가해 볼 수도 있습니다. 예를 들어, 프로그램의 일부를 추출하고 모든 엣지 케이스를 생각해 내려고 노력하면서 단위 테스트로 많은 예제 사례를 작성하는 자신을 발견하면 [`proptest`](https://docs.rs/proptest)를 살펴보아야 합니다. 임의의 파일을 사용하고 구문 분석하는 프로그램이 있는 경우 [퍼저](https://rust-fuzz.github.io/book/introduction.html)를 작성하여 엣지 케이스에서 버그를 찾아보십시오."

#: src/tutorial/testing.md:573
msgid "**Note:** You can find the full, runnable source code used in this chapter [in this book's repository](https://github.com/rust-cli/book/tree/master/src/tutorial/testing)."
msgstr "**참고:** 이 장에서 사용된 전체 실행 가능한 소스 코드는 [이 책의 리포지토리](https://github.com/rust-cli/book/tree/master/src/tutorial/testing)에서 찾을 수 있습니다."

#: src/tutorial/packaging.md:3
msgid "If you feel confident that your program is ready for other people to use, it is time to package and release it!"
msgstr "프로그램이 다른 사람들이 사용할 준비가 되었다고 확신한다면 패키징하고 출시할 시간입니다!"

#: src/tutorial/packaging.md:6
msgid "There are a few approaches, and we'll look at three of them from \"quickest to set up\" to \"most convenient for users\"."
msgstr "몇 가지 접근 방식이 있으며, \"가장 빠른 설정\"에서 \"사용자에게 가장 편리한\"까지 세 가지를 살펴보겠습니다."

#: src/tutorial/packaging.md:10
msgid "Quickest: `cargo publish`"
msgstr "가장 빠른 방법: `cargo publish`"

#: src/tutorial/packaging.md:12
msgid "The easiest way to publish your app is with cargo. Do you remember how we added external dependencies to our project? Cargo downloaded them from its default \"crate registry\", [crates.io](https://crates.io/). With `cargo publish`, you too can publish crates to [crates.io](https://crates.io/). And this works for all crates, including those with binary targets."
msgstr "앱을 게시하는 가장 쉬운 방법은 cargo를 사용하는 것입니다. 프로젝트에 외부 의존성을 추가한 방법을 기억하십니까? Cargo는 기본 \"크레이트 레지스트리\"인 [crates.io](https://crates.io/)에서 다운로드했습니다. `cargo publish`를 사용하면 [crates.io](https://crates.io/)에 크레이트를 게시할 수도 있습니다. 그리고 이것은 바이너리 대상이 있는 크레이트를 포함하여 모든 크레이트에서 작동합니다."

#: src/tutorial/packaging.md:20
msgid "Publishing a crate to [crates.io](https://crates.io/) is pretty straightforward: If you haven't already, create an account on [crates.io](https://crates.io/). Currently, this is done via authorizing you on GitHub, so you'll need to have a GitHub account (and be logged in there). Next, you log in using cargo on your local machine. For that, go to your [crates.io account page](https://crates.io/me), create a new token, and then run `cargo login <your-new-token>`. You only need to do this once per computer. You can learn more about this in cargo's [publishing guide](https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html)."
msgstr "[crates.io](https://crates.io/)에 크레이트를 게시하는 것은 매우 간단합니다. 아직 계정이 없다면 [crates.io](https://crates.io/)에서 계정을 만드세요. 현재 이것은 GitHub에서 인증을 통해 수행되므로 GitHub 계정이 있어야 합니다(그리고 거기에 로그인해야 함). 다음으로 로컬 컴퓨터에서 cargo를 사용하여 로그인합니다. 이를 위해 [crates.io 계정 페이지](https://crates.io/me)로 이동하여 새 토큰을 만든 다음 `cargo login <your-new-token>`을 실행합니다. 컴퓨터당 한 번만 수행하면 됩니다. 이에 대한 자세한 내용은 cargo의 [게시 가이드](https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html)에서 확인할 수 있습니다."

#: src/tutorial/packaging.md:34
msgid "Now that cargo as well as crates.io know you, you are ready to publish crates. Before you hastily go ahead and publish a new crate (version), it's a good idea to open your `Cargo.toml` once more and make sure you added the necessary metadata. You can find all the possible fields you can set in the documentation for [cargo's manifest format](https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html). Here's a quick overview of some common entries:"
msgstr "이제 cargo와 crates.io가 당신을 알았으므로 크레이트를 게시할 준비가 되었습니다. 서둘러 새 크레이트(버전)를 게시하기 전에 `Cargo.toml`을 다시 한 번 열고 필요한 메타데이터를 추가했는지 확인하는 것이 좋습니다. 설정할 수 있는 모든 가능한 필드는 [cargo의 매니페스트 형식](https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html)에 대한 문서에서 찾을 수 있습니다. 다음은 몇 가지 일반적인 항목에 대한 간략한 개요입니다."

#: src/tutorial/packaging.md:43
msgid "```toml\n[package]\nname = \"grrs\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your@email.com>\"]\nlicense = \"MIT OR Apache-2.0\"\ndescription = \"A tool to search files\"\nreadme = \"README.md\"\nhomepage = \"https://github.com/you/grrs\"\nrepository = \"https://github.com/you/grrs\"\nkeywords = [\"cli\", \"search\", \"demo\"]\ncategories = [\"command-line-utilities\"]\n```"
msgstr "```toml\n[package]\nname = \"grrs\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <your@email.com>\"]\nlicense = \"MIT OR Apache-2.0\"\ndescription = \"A tool to search files\"\nreadme = \"README.md\"\nhomepage = \"https://github.com/you/grrs\"\nrepository = \"https://github.com/you/grrs\"\nkeywords = [\"cli\", \"search\", \"demo\"]\ncategories = [\"command-line-utilities\"]\n```"

#: src/tutorial/packaging.md:59
msgid "**Note:** This example includes the mandatory license field with a common choice for Rust projects: The same license that is also used for the compiler itself. It also refers to a `README.md` file. It should include a quick description of what your project is about, and will be included not only on the crates.io page of your crate, but also what GitHub shows by default on repository pages."
msgstr "**참고:** 이 예제에는 Rust 프로젝트에 대한 일반적인 선택인 필수 라이선스 필드가 포함되어 있습니다. 컴파일러 자체에도 사용되는 동일한 라이선스입니다. 또한 `README.md` 파일을 참조합니다. 프로젝트에 대한 간략한 설명이 포함되어야 하며 크레이트의 crates.io 페이지뿐만 아니라 GitHub가 리포지토리 페이지에 기본적으로 표시하는 내용에도 포함됩니다."

#: src/tutorial/packaging.md:75
msgid "How to install a binary from crates.io"
msgstr "crates.io에서 바이너리를 설치하는 방법"

#: src/tutorial/packaging.md:77
msgid "We've seen how to publish a crate to crates.io, and you might be wondering how to install it. In contrast to libraries, which cargo will download and compile for you when you run `cargo build` (or a similar command), you'll need to tell it to explicitly install binaries."
msgstr "crates.io에 크레이트를 게시하는 방법을 보았고 설치하는 방법이 궁금할 것입니다. `cargo build`(또는 유사한 명령)를 실행할 때 cargo가 다운로드하고 컴파일하는 라이브러리와 달리 바이너리를 명시적으로 설치하도록 지시해야 합니다."

#: src/tutorial/packaging.md:84
msgid "This is done using `cargo install <crate-name>`. It will by default download the crate, compile all the binary targets it contains (in \"release\" mode, so it might take a while) and copy them into the `~/.cargo/bin/` directory. (Make sure that your shell knows to look there for binaries!)"
msgstr "이것은 `cargo install <crate-name>`을 사용하여 수행됩니다. 기본적으로 크레이트를 다운로드하고 포함된 모든 바이너리 대상( \"릴리스\" 모드이므로 시간이 걸릴 수 있음)을 컴파일하고 `~/.cargo/bin/` 디렉토리에 복사합니다. (셸이 바이너리를 찾기 위해 해당 위치를 보도록 해야 합니다!)"

#: src/tutorial/packaging.md:92
msgid "It's also possible to install crates from git repositories, only install specific binaries of a crate, and specify an alternative directory to install them to. Have a look at `cargo install --help` for details."
msgstr "git 리포지토리에서 크레이트를 설치하고, 크레이트의 특정 바이너리만 설치하고, 설치할 대체 디렉토리를 지정할 수도 있습니다. 자세한 내용은 `cargo install --help`를 참조하세요."

#: src/tutorial/packaging.md:98 src/tutorial/packaging.md:244
msgid "When to use it"
msgstr "사용 시기"

#: src/tutorial/packaging.md:100
msgid "`cargo install` is a simple way to install a binary crate. It's very convenient for Rust developers to use, but has some significant downsides: Since it will always compile your source from scratch, users of your tool will need to have Rust, cargo, and all other system dependencies your project requires to be installed on their machine. Compiling large Rust codebases can also take some time."
msgstr "`cargo install`은 바이너리 크레이트를 설치하는 간단한 방법입니다. Rust 개발자가 사용하기에 매우 편리하지만 몇 가지 중요한 단점이 있습니다. 항상 소스를 처음부터 컴파일하므로 도구 사용자는 컴퓨터에 Rust, cargo 및 프로젝트에 필요한 다른 모든 시스템 의존성을 설치해야 합니다. 큰 Rust 코드베이스를 컴파일하는 데도 시간이 걸릴 수 있습니다."

#: src/tutorial/packaging.md:109
msgid "It's best to use this for distributing tools that are targeted at other Rust developers. For example: A lot of cargo subcommands like `cargo-tree` or `cargo-outdated` can be installed with it."
msgstr "다른 Rust 개발자를 대상으로 하는 도구를 배포하는 데 사용하는 것이 가장 좋습니다. 예를 들어 `cargo-tree` 또는 `cargo-outdated`와 같은 많은 cargo 하위 명령을 설치할 수 있습니다."

#: src/tutorial/packaging.md:116
msgid "Distributing binaries"
msgstr "바이너리 배포"

#: src/tutorial/packaging.md:118
msgid "Rust is a language that compiles to native code and by default statically links all dependencies. When you run `cargo build` on your project that contains a binary called `grrs`, you'll end up with a binary file called `grrs`. Try it out: Using `cargo build`, it'll be `target/debug/grrs`, and when you run `cargo build --release`, it'll be `target/release/grrs`. Unless you use crates that explicitly need external libraries to be installed on the target system (like using the system's version of OpenSSL), this binary will only depend on common system libraries. That means, you take that one file, send it to people running the same operating system as you, and they'll be able to run it."
msgstr "Rust는 네이티브 코드로 컴파일되고 기본적으로 모든 의존성을 정적으로 연결하는 언어입니다. `grrs`라는 바이너리가 포함된 프로젝트에서 `cargo build`를 실행하면 `grrs`라는 바이너리 파일이 생성됩니다. 시도해 보세요. `cargo build`를 사용하면 `target/debug/grrs`가 되고, `cargo build --release`를 실행하면 `target/release/grrs`가 됩니다. 대상 시스템에 외부 라이브러리를 명시적으로 설치해야 하는 크레이트(예: 시스템의 OpenSSL 버전 사용)를 사용하지 않는 한 이 바이너리는 공통 시스템 라이브러리에만 의존합니다. 즉, 해당 파일을 가져와 동일한 운영 체제를 실행하는 사람들에게 보내면 실행할 수 있습니다."

#: src/tutorial/packaging.md:135
msgid "This is already very powerful! It works around two of the downsides we just saw for `cargo install`: There is no need to have Rust installed on the user's machine, and instead of it taking a minute to compile, they can instantly run the binary."
msgstr "이것은 이미 매우 강력합니다! 방금 본 `cargo install`의 두 가지 단점을 해결합니다. 사용자 컴퓨터에 Rust를 설치할 필요가 없으며 컴파일하는 데 1분이 걸리는 대신 즉시 바이너리를 실행할 수 있습니다."

#: src/tutorial/packaging.md:141
msgid "So, as we've seen, `cargo build` _already_ builds binaries for us. The only issue is, those are not guaranteed to work on all platforms. If you run `cargo build` on your Windows machine, you won't get a binary that works on a Mac by default. Is there a way to generate these binaries for all the interesting platforms automatically?"
msgstr "따라서 보시다시피 `cargo build`는 _이미_ 우리를 위해 바이너리를 빌드합니다. 유일한 문제는 모든 플랫폼에서 작동하도록 보장되지 않는다는 것입니다. Windows 컴퓨터에서 `cargo build`를 실행하면 기본적으로 Mac에서 작동하는 바이너리를 얻을 수 없습니다. 흥미로운 모든 플랫폼에 대해 이러한 바이너리를 자동으로 생성하는 방법이 있습니까?"

#: src/tutorial/packaging.md:151
msgid "Building binary releases on CI"
msgstr "CI에서 바이너리 릴리스 빌드"

#: src/tutorial/packaging.md:153
msgid "If your tool is open sourced and hosted on GitHub, it's quite easy to set up a free CI (continuous integration) service like [Travis CI](https://travis-ci.com/). (There are other services that also work on other platforms, but Travis is very popular.) This basically runs setup commands in a virtual machine each time you push changes to your repository. What those commands are, and the types of machines they run on, is configurable. For example: A good idea is to run `cargo test` on a machine with Rust and some common build tools installed. If this fails, you know there are issues in the most recent changes."
msgstr "도구가 오픈 소스이고 GitHub에서 호스팅되는 경우 [Travis CI](https://travis-ci.com/)와 같은 무료 CI(지속적 통합) 서비스를 설정하는 것이 매우 쉽습니다. (다른 플랫폼에서도 작동하는 다른 서비스가 있지만 Travis는 매우 인기가 있습니다.) 이것은 기본적으로 리포지토리에 변경 사항을 푸시할 때마다 가상 머신에서 설정 명령을 실행합니다. 이러한 명령이 무엇인지, 그리고 실행되는 컴퓨터 유형은 구성 가능합니다. 예를 들어 Rust와 몇 가지 일반적인 빌드 도구가 설치된 컴퓨터에서 `cargo test`를 실행하는 것이 좋습니다. 실패하면 가장 최근 변경 사항에 문제가 있음을 알 수 있습니다."

#: src/tutorial/packaging.md:172
msgid "We can also use this to build binaries and upload them to GitHub! Indeed, if we run `cargo build --release` and upload the binary somewhere, we should be all set, right? Not quite. We still need to make sure the binaries we build are compatible with as many systems as possible. For example, on Linux we can compile not for the current system, but instead for the `x86_64-unknown-linux-musl` target, to not depend on default system libraries. On macOS, we can set `MACOSX_DEPLOYMENT_TARGET` to `10.7` to only depend on system features present in versions 10.7 and older."
msgstr "이것을 사용하여 바이너리를 빌드하고 GitHub에 업로드할 수도 있습니다! 실제로 `cargo build --release`를 실행하고 바이너리를 어딘가에 업로드하면 모든 준비가 완료된 것일까요? 그렇지 않습니다. 빌드하는 바이너리가 가능한 한 많은 시스템과 호환되는지 확인해야 합니다. 예를 들어 Linux에서는 현재 시스템용으로 컴파일하는 대신 `x86_64-unknown-linux-musl` 대상을 위해 컴파일하여 기본 시스템 라이브러리에 의존하지 않도록 할 수 있습니다. macOS에서는 `MACOSX_DEPLOYMENT_TARGET`을 `10.7`로 설정하여 10.7 및 이전 버전에 있는 시스템 기능에만 의존하도록 할 수 있습니다."

#: src/tutorial/packaging.md:188
msgid "You can see one example of building binaries using this approach [here](https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91) for Linux and macOS and [here](https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml) for Windows (using AppVeyor)."
msgstr "Linux 및 macOS의 경우 [여기](https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91)에서, Windows(AppVeyor 사용)의 경우 [여기](https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml)에서 이 접근 방식을 사용하여 바이너리를 빌드하는 한 가지 예를 볼 수 있습니다."

#: src/tutorial/packaging.md:195
msgid "Another way is to use pre-built (Docker) images that contain all the tools we need to build binaries. This allows us to easily target more exotic platforms, too. The [trust](https://github.com/japaric/trust) project contains scripts that you can include in your project as well as instructions on how to set this up. It also includes support for Windows using AppVeyor."
msgstr "또 다른 방법은 바이너리를 빌드하는 데 필요한 모든 도구가 포함된 사전 빌드된 (Docker) 이미지를 사용하는 것입니다. 이를 통해 더 이국적인 플랫폼도 쉽게 타겟팅할 수 있습니다. [trust](https://github.com/japaric/trust) 프로젝트에는 프로젝트에 포함할 수 있는 스크립트와 이를 설정하는 방법에 대한 지침이 포함되어 있습니다. 또한 AppVeyor를 사용하는 Windows도 지원합니다."

#: src/tutorial/packaging.md:204
msgid "If you'd rather set this up locally and generate the release files on your own machine, still have a look at trust. It uses [cross](https://github.com/rust-embedded/cross) internally, which works similar to cargo but forwards commands to a cargo process inside a Docker container. The definitions of the images are also available in [cross' repository](https://github.com/rust-embedded/cross)."
msgstr "로컬에서 설정하고 자신의 컴퓨터에서 릴리스 파일을 생성하려는 경우에도 trust를 살펴보십시오. 내부적으로 [cross](https://github.com/rust-embedded/cross)를 사용하며, 이는 cargo와 유사하게 작동하지만 Docker 컨테이너 내부의 cargo 프로세스로 명령을 전달합니다. 이미지의 정의는 [cross의 리포지토리](https://github.com/rust-embedded/cross)에서도 사용할 수 있습니다."

#: src/tutorial/packaging.md:216
msgid "How to install these binaries"
msgstr "이러한 바이너리를 설치하는 방법"

#: src/tutorial/packaging.md:218
msgid "You point your users to your release page that might look something [like this one](https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1), and they can download the artifacts we've just created. The release artifacts we've just generated are nothing special: At the end, they are just archive files that contain our binaries! This means that users of your tool can download them with their browser, extract them (often happens automatically), and copy the binaries to a place they like."
msgstr "사용자를 [이것과 같은](https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1) 릴리스 페이지로 안내하면 방금 만든 아티팩트를 다운로드할 수 있습니다. 방금 생성한 릴리스 아티팩트는 특별한 것이 아닙니다. 결국 바이너리가 포함된 아카이브 파일일 뿐입니다! 즉, 도구 사용자는 브라우저로 다운로드하고 압축을 풀고(종종 자동으로 발생) 바이너리를 원하는 위치에 복사할 수 있습니다."

#: src/tutorial/packaging.md:230
msgid "This does require some experience with manually \"installing\" programs, so you want to add a section to your README file on how to install this program."
msgstr "이것은 수동으로 프로그램을 \"설치\"하는 데 약간의 경험이 필요하므로 이 프로그램을 설치하는 방법에 대한 섹션을 README 파일에 추가하고 싶을 것입니다."

#: src/tutorial/packaging.md:236
msgid "**Note:** If you used [trust](https://github.com/japaric/trust) to build your binaries and added them to GitHub releases, you can also tell people to run `curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name` if you think that makes it easier."
msgstr "**참고:** [trust](https://github.com/japaric/trust)를 사용하여 바이너리를 빌드하고 GitHub 릴리스에 추가한 경우 `curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name`을 실행하도록 사람들에게 알려줄 수도 있습니다. 이것이 더 쉽다고 생각한다면 말입니다."

#: src/tutorial/packaging.md:246
msgid "Having binary releases is a good idea in general, there's hardly any downside to it. It does not solve the problem of users having to manually install and update your tools, but they can quickly get the latest releases version without the need to install Rust."
msgstr "바이너리 릴리스를 갖는 것은 일반적으로 좋은 생각이며 단점이 거의 없습니다. 사용자가 도구를 수동으로 설치하고 업데이트해야 하는 문제를 해결하지는 않지만 Rust를 설치할 필요 없이 최신 릴리스 버전을 빠르게 얻을 수 있습니다."

#: src/tutorial/packaging.md:254
msgid "What to package in addition to your binaries"
msgstr "바이너리 외에 무엇을 패키징해야 할까요"

#: src/tutorial/packaging.md:256
msgid "Right now, when a user downloads our release builds, they will get a `.tar.gz` file that only contains binary files. So, in our example project, they will just get a single `grrs` file they can run. But there are some more files we already have in our repository that they might want to have. The README file that tells them how to use this tool, and the license file(s), for example. Since we already have them, they are easy to add."
msgstr "지금 사용자가 릴리스 빌드를 다운로드하면 바이너리 파일만 포함된 `.tar.gz` 파일을 받게 됩니다. 따라서 예제 프로젝트에서는 실행할 수 있는 단일 `grrs` 파일만 받게 됩니다. 하지만 리포지토리에 이미 가지고 있는 파일 중 사용자가 원할 수 있는 파일이 더 있습니다. 예를 들어 이 도구를 사용하는 방법을 알려주는 README 파일과 라이선스 파일이 있습니다. 이미 가지고 있으므로 추가하기 쉽습니다."

#: src/tutorial/packaging.md:270
msgid "There are some more interesting files that make sense especially for command-line tools, though: How about we also ship a man page in addition to that README file, and config files that add completions of the possible flags to your shell? You can write these by hand, but _clap_, the argument parsing library we use (which clap builds upon) has a way to generate all these files for us. See [this in-depth chapter](../in-depth/docs.html) for more details."
msgstr "하지만 특히 명령줄 도구에 의미 있는 더 흥미로운 파일이 있습니다. README 파일 외에 man 페이지와 셸에 가능한 플래그 완성을 추가하는 구성 파일도 함께 제공하는 것은 어떻습니까? 이것들을 수동으로 작성할 수 있지만, 우리가 사용하는 인수 구문 분석 라이브러리인 _clap_(clap이 기반으로 함)에는 이러한 모든 파일을 생성하는 방법이 있습니다. 자세한 내용은 [이 심층 장](../in-depth/docs.html)을 참조하세요."

#: src/tutorial/packaging.md:286
msgid "Getting your app into package repositories"
msgstr "앱을 패키지 리포지토리에 넣기"

#: src/tutorial/packaging.md:288
msgid "Both approaches we've seen so far are not how you typically install software on your machine. Especially command-line tools you install using global package managers on most operating systems. The advantages for users are quite obvious: There is no need to think about how to install your program, if it can be installed the same way as they install the other tools. These package managers also allow users to update their programs when a new version is available."
msgstr "지금까지 본 두 가지 접근 방식은 일반적으로 컴퓨터에 소프트웨어를 설치하는 방식이 아닙니다. 특히 대부분의 운영 체제에서 전역 패키지 관리자를 사용하여 설치하는 명령줄 도구입니다. 사용자를 위한 이점은 매우 분명합니다. 다른 도구를 설치하는 것과 동일한 방식으로 프로그램을 설치할 수 있다면 프로그램을 설치하는 방법에 대해 생각할 필요가 없습니다. 이러한 패키지 관리자는 또한 사용자가 새 버전을 사용할 수 있을 때 프로그램을 업데이트할 수 있도록 합니다."

#: src/tutorial/packaging.md:299
msgid "Sadly, supporting different systems means you'll have to look at how these different systems work. For some, it might be as easy as adding a file to your repository (e.g. adding a Formula file like [this](https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb) for macOS's `brew`), but for others you'll often need to send in patches yourself and add your tool to their repositories. There are helpful tools like [cargo-bundle](https://crates.io/crates/cargo-bundle), [cargo-deb](https://crates.io/crates/cargo-deb), and [cargo-aur](https://crates.io/crates/cargo-aur), but describing how they work and how to correctly package your tool for those different systems is beyond the scope of this chapter."
msgstr "안타깝게도 다른 시스템을 지원한다는 것은 이러한 다른 시스템이 어떻게 작동하는지 살펴봐야 한다는 것을 의미합니다. 일부의 경우 리포지토리에 파일을 추가하는 것만큼 쉬울 수 있습니다(예: macOS의 `brew`용으로 [이것](https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb)과 같은 Formula 파일 추가). 그러나 다른 경우에는 종종 직접 패치를 보내고 도구를 해당 리포지토리에 추가해야 합니다. [cargo-bundle](https://crates.io/crates/cargo-bundle), [cargo-deb](https://crates.io/crates/cargo-deb) 및 [cargo-aur](https://crates.io/crates/cargo-aur)와 같은 유용한 도구가 있지만, 작동 방식과 이러한 다른 시스템에 대해 도구를 올바르게 패키징하는 방법을 설명하는 것은 이 장의 범위를 벗어납니다."

#: src/tutorial/packaging.md:316
msgid "Instead, let's have a look at a tool that is written in Rust and that is available in many different package managers."
msgstr "대신 Rust로 작성되었고 많은 다른 패키지 관리자에서 사용할 수 있는 도구를 살펴보겠습니다."

#: src/tutorial/packaging.md:320
msgid "An example: ripgrep"
msgstr "예: ripgrep"

#: src/tutorial/packaging.md:322
msgid "[ripgrep](https://github.com/BurntSushi/ripgrep) is an alternative to `grep`/`ack`/`ag` and is written in Rust. It's quite successful and is packaged for many operating systems: Just look at [the \"Installation\" section](https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation) of its README!"
msgstr "[ripgrep](https://github.com/BurntSushi/ripgrep)은 `grep`/`ack`/`ag`의 대안이며 Rust로 작성되었습니다. 매우 성공적이며 많은 운영 체제용으로 패키징되었습니다. README의 [\"설치\" 섹션](https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation)을 살펴보세요!"

#: src/tutorial/packaging.md:326
msgid "Note that it lists a few different options how you can install it: It starts with a link to the GitHub releases which contain the binaries so you can download them directly; then it lists how to install it using a bunch of different package managers; finally, you can also install it using `cargo install`."
msgstr "설치 방법에 대한 몇 가지 다른 옵션을 나열합니다. 바이너리가 포함된 GitHub 릴리스에 대한 링크로 시작하여 직접 다운로드할 수 있습니다. 그런 다음 여러 다른 패키지 관리자를 사용하여 설치하는 방법을 나열합니다. 마지막으로 `cargo install`을 사용하여 설치할 수도 있습니다."

#: src/tutorial/packaging.md:332
msgid "This seems like a very good idea: Don't pick and choose one of the approaches presented here, but start with `cargo install`, add binary releases, and finally start distributing your tool using system package managers."
msgstr "이것은 매우 좋은 생각인 것 같습니다. 여기에 제시된 접근 방식 중 하나를 선택하지 말고 `cargo install`로 시작하여 바이너리 릴리스를 추가하고 마지막으로 시스템 패키지 관리자를 사용하여 도구를 배포하기 시작하십시오."

#: src/in-depth/index.md:3
msgid "A small collection of chapters covering some more details that you might care about when writing your command line application."
msgstr "명령줄 응용 프로그램을 작성할 때 신경 쓸 수 있는 몇 가지 세부 정보를 다루는 작은 장 모음입니다."

#: src/in-depth/signals.md:3
msgid "Processes like command line applications need to react to signals sent by the operating system. The most common example is probably <kbd>Ctrl</kbd>+<kbd>C</kbd>, the signal that typically tells a process to terminate. To handle signals in Rust programs you need to consider how you can receive these signals as well as how you can react to them."
msgstr "명령줄 응용 프로그램과 같은 프로세스는 운영 체제에서 보낸 신호에 반응해야 합니다. 가장 일반적인 예는 아마도 프로세스에 종료를 알리는 신호인 <kbd>Ctrl</kbd>+<kbd>C</kbd>일 것입니다. Rust 프로그램에서 신호를 처리하려면 이러한 신호를 수신하는 방법과 이에 반응하는 방법을 고려해야 합니다."

#: src/in-depth/signals.md:14
msgid "**Note:** If your applications does not need to gracefully shutdown, the default handling is fine (i.e. exit immediately and let the OS cleanup resources like open file handles). In that case: No need to do what this chapter tells you!"
msgstr "**참고:** 응용 프로그램이 정상적으로 종료될 필요가 없다면 기본 처리가 괜찮습니다(즉, 즉시 종료하고 OS가 열린 파일 핸들과 같은 리소스를 정리하도록 함). 이 경우: 이 장에서 설명하는 것을 할 필요가 없습니다!"

#: src/in-depth/signals.md:22
msgid "However, for applications that need to clean up after themselves, this chapter is very relevant! For example, if your application needs to properly close network connections (saying \"good bye\" to the processes at the other end), remove temporary files, or reset system settings, read on."
msgstr "그러나 자체적으로 정리해야 하는 응용 프로그램의 경우 이 장은 매우 관련성이 높습니다! 예를 들어, 응용 프로그램이 네트워크 연결을 제대로 닫아야 하는 경우(상대방 프로세스에 \"안녕\"이라고 말함), 임시 파일을 제거하거나 시스템 설정을 재설정해야 하는 경우 계속 읽으십시오."

#: src/in-depth/signals.md:35
msgid "Differences between operating systems"
msgstr "운영 체제 간의 차이점"

#: src/in-depth/signals.md:37
msgid "On Unix systems (like Linux, macOS, and FreeBSD) a process can receive [signals](https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html). It can either react to them in a default (OS-provided) way, catch the signal and handle them in a program-defined way, or ignore the signal entirely."
msgstr "Unix 시스템(Linux, macOS, FreeBSD 등)에서는 프로세스가 [신호](https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html)를 수신할 수 있습니다. 기본(OS 제공) 방식으로 반응하거나, 신호를 가로채 프로그램 정의 방식으로 처리하거나, 신호를 완전히 무시할 수 있습니다."

#: src/in-depth/signals.md:47
msgid "Windows does not have signals. You can use [Console Handlers](https://docs.microsoft.com/en-us/windows/console/console-control-handlers) to define callbacks that get executed when an event occurs. There is also [structured exception handling](https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling) which handles all the various types of system exceptions such as division by zero, invalid access exceptions, stack overflow, and so on"
msgstr "Windows에는 신호가 없습니다. 이벤트가 발생할 때 실행되는 콜백을 정의하기 위해 [콘솔 핸들러](https://docs.microsoft.com/en-us/windows/console/console-control-handlers)를 사용할 수 있습니다. 또한 0으로 나누기, 잘못된 액세스 예외, 스택 오버플로 등과 같은 다양한 유형의 시스템 예외를 처리하는 [구조적 예외 처리](https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling)도 있습니다."

#: src/in-depth/signals.md:56
msgid "First off: Handling Ctrl+C"
msgstr "먼저: Ctrl+C 처리"

#: src/in-depth/signals.md:58
msgid "The [ctrlc](https://crates.io/crates/ctrlc) crate does just what the name suggests: It allows you to react to the user pressing <kbd>Ctrl</kbd>+<kbd>C</kbd>, in a cross-platform way. The main way to use the crate is this:"
msgstr "[ctrlc](https://crates.io/crates/ctrlc) 크레이트는 이름에서 알 수 있듯이 크로스 플랫폼 방식으로 사용자가 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누르는 것에 반응할 수 있도록 합니다. 크레이트를 사용하는 주요 방법은 다음과 같습니다."

#: src/in-depth/signals.md:70
msgid "received Ctrl+C!"
msgstr "Ctrl+C 수신!"

#: src/in-depth/signals.md:72
msgid "Error setting Ctrl-C handler"
msgstr "Ctrl-C 핸들러 설정 오류"

#: src/in-depth/signals.md:74 src/in-depth/signals.md:119
msgid "// Following code does the actual work, and can be interrupted by pressing\n    // Ctrl-C. As an example: Let's wait a few seconds.\n"
msgstr "// 다음 코드는 실제 작업을 수행하며 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 눌러 중단할 수 있습니다.\n    // 예: 몇 초 동안 기다려 봅시다.\n"

#: src/in-depth/signals.md:80
msgid "This is, of course, not that helpful: It only prints a message but otherwise doesn't stop the program."
msgstr "물론 이것은 그다지 도움이 되지 않습니다. 메시지만 인쇄하고 프로그램은 중지하지 않습니다."

#: src/in-depth/signals.md:83
msgid "In a real-world program, it's a good idea to instead set a variable in the signal handler that you then check in various places in your program. For example, you can set an `Arc<AtomicBool>` (a boolean shareable between threads) in your signal handler, and in hot loops, or when waiting for a thread, you periodically check its value and break when it becomes true."
msgstr "실제 프로그램에서는 신호 핸들러에 변수를 설정하고 프로그램의 여러 위치에서 확인하는 것이 좋습니다. 예를 들어, 신호 핸들러에 `Arc<AtomicBool>`(스레드 간에 공유 가능한 부울)을 설정하고, 핫 루프에서 또는 스레드를 기다릴 때 주기적으로 해당 값을 확인하고 참이 되면 중단할 수 있습니다."

#: src/in-depth/signals.md:95
msgid "Handling other types of signals"
msgstr "다른 유형의 신호 처리"

#: src/in-depth/signals.md:97
msgid "The [ctrlc](https://crates.io/crates/ctrlc) crate only handles <kbd>Ctrl</kbd>+<kbd>C</kbd>, or, what on Unix systems would be called `SIGINT` (the \"interrupt\" signal). To react to more Unix signals, you should have a look at [signal-hook](https://crates.io/crates/signal-hook). Its design is described in [this blog post](https://vorner.github.io/2018/06/28/signal-hook.html), and it is currently the library with the widest community support."
msgstr "[ctrlc](https://crates.io/crates/ctrlc) 크레이트는 <kbd>Ctrl</kbd>+<kbd>C</kbd> 또는 Unix 시스템에서 `SIGINT`(\"인터럽트\" 신호)라고 하는 것만 처리합니다. 더 많은 Unix 신호에 반응하려면 [signal-hook](https://crates.io/crates/signal-hook)을 살펴보아야 합니다. 디자인은 [이 블로그 게시물](https://vorner.github.io/2018/06/28/signal-hook.html)에 설명되어 있으며 현재 가장 광범위한 커뮤니티 지원을 받는 라이브러리입니다."

#: src/in-depth/signals.md:104
msgid "Here's a simple example:"
msgstr "다음은 간단한 예입니다."

#: src/in-depth/signals.md:115
msgid "Received signal {:?}"
msgstr "수신된 신호 {:?}"

#: src/in-depth/signals.md:129
msgid "Using channels"
msgstr "채널 사용"

#: src/in-depth/signals.md:131
msgid "Instead of setting a variable and having other parts of the program check it, you can use channels: You create a channel into which the signal handler emits a value whenever the signal is received. In your application code you use this and other channels as synchronization points between threads. Using [crossbeam-channel](https://crates.io/crates/crossbeam-channel) it would look something like this:"
msgstr "변수를 설정하고 프로그램의 다른 부분이 확인하도록 하는 대신 채널을 사용할 수 있습니다. 신호 핸들러가 신호를 수신할 때마다 값을 방출하는 채널을 만듭니다. 응용 프로그램 코드에서는 이 채널과 다른 채널을 스레드 간의 동기화 지점으로 사용합니다. [crossbeam-channel](https://crates.io/crates/crossbeam-channel)을 사용하면 다음과 같이 보일 것입니다."

#: src/in-depth/signals.md:164
msgid "working!"
msgstr "작동 중!"

#: src/in-depth/signals.md:168
msgid "Goodbye!"
msgstr "안녕!"

#: src/in-depth/signals.md:178
msgid "Using futures and streams"
msgstr "퓨처 및 스트림 사용"

#: src/in-depth/signals.md:180
msgid "If you are using [tokio](https://tokio.rs/), you are most likely already writing your application with asynchronous patterns and an event-driven design. Instead of using crossbeam's channels directly, you can enable signal-hook's `tokio-support` feature. This allows you to call [`.into_async()`](https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async) on signal-hook's `Signals` types to get a new type that implements `futures::Stream`."
msgstr "[tokio](https://tokio.rs/)를 사용하고 있다면 비동기 패턴과 이벤트 기반 디자인으로 응용 프로그램을 작성하고 있을 가능성이 높습니다. crossbeam의 채널을 직접 사용하는 대신 signal-hook의 `tokio-support` 기능을 활성화할 수 있습니다. 이렇게 하면 signal-hook의 `Signals` 유형에서 [`.into_async()`](https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async)를 호출하여 `futures::Stream`을 구현하는 새 유형을 얻을 수 있습니다."

#: src/in-depth/signals.md:193
msgid "What to do when you receive another Ctrl+C while you're handling the first Ctrl+C"
msgstr "첫 번째 Ctrl+C를 처리하는 동안 다른 Ctrl+C를 수신하면 어떻게 해야 합니까?"

#: src/in-depth/signals.md:195
msgid "Most users will press <kbd>Ctrl</kbd>+<kbd>C</kbd>, and then give your program a few seconds to exit, or tell them what's going on. If that doesn't happen, they will press <kbd>Ctrl</kbd>+<kbd>C</kbd> again. The typical behavior is to have the application quit immediately."
msgstr "대부분의 사용자는 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누른 다음 프로그램이 종료될 때까지 몇 초 동안 기다리거나 무슨 일이 일어나고 있는지 알려줍니다. 그렇게 하지 않으면 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 다시 누릅니다. 일반적인 동작은 응용 프로그램을 즉시 종료하는 것입니다."

#: src/in-depth/config-files.md:3
msgid "Dealing with configurations can be annoying especially if you support multiple operating systems which all have their own places for short- and long-term files."
msgstr "구성을 처리하는 것은 특히 단기 및 장기 파일에 대한 자체 위치를 가진 여러 운영 체제를 지원하는 경우 성가실 수 있습니다."

#: src/in-depth/config-files.md:8
msgid "There are multiple solutions to this, some being more low-level than others."
msgstr "이에 대한 여러 가지 해결책이 있으며, 일부는 다른 것보다 더 저수준입니다."

#: src/in-depth/config-files.md:11
msgid "The easiest crate to use for this is [`confy`](https://docs.rs/confy/0.3.1/confy/). It asks you for the name of your application and requires you to specify the config layout via a `struct` (that is `Serialize`, `Deserialize`) and it will figure out the rest!"
msgstr "이를 위해 사용하기 가장 쉬운 크레이트는 [`confy`](https://docs.rs/confy/0.3.1/confy/)입니다. 응용 프로그램 이름을 묻고 `struct`( `Serialize`, `Deserialize`인)를 통해 구성 레이아웃을 지정하도록 요구하면 나머지는 알아서 처리합니다!"

#: src/in-depth/config-files.md:26
msgid "my_app"
msgstr "my_app"

#: src/in-depth/config-files.md:27
msgid "{:#?}"
msgstr "{:#?}"

#: src/in-depth/config-files.md:32
msgid "This is incredibly easy to use for which you of course surrender configurability. But if a simple config is all you want, this crate might be for you!"
msgstr "물론 구성 가능성을 포기하는 대신 사용하기가 매우 쉽습니다. 하지만 간단한 구성만 원한다면 이 크레이트가 적합할 수 있습니다!"

#: src/in-depth/config-files.md:39
msgid "Configuration environments"
msgstr "구성 환경"

#: src/in-depth/config-files.md:43
msgid "**TODO**"
msgstr "**TODO**"

#: src/in-depth/config-files.md:45
msgid "Evaluate crates that exist"
msgstr "기존 크레이트 평가"

#: src/in-depth/config-files.md:46
msgid "Cli-args + multiple configs + env variables"
msgstr "Cli-args + 여러 구성 + 환경 변수"

#: src/in-depth/config-files.md:47
msgid "Can [`configure`](https://docs.rs/configure/0.1.1/configure/) do all this? Is there a nice wrapper around it?"
msgstr "[`configure`](https://docs.rs/configure/0.1.1/configure/)가 이 모든 것을 할 수 있습니까? 멋진 래퍼가 있습니까?"

#: src/in-depth/exit-code.md:3
msgid "A program doesn't always succeed. And when an error occurs, you should make sure to emit the necessary information correctly. In addition to [telling the user about errors](human-communication.html), on most systems, when a process exits, it also emits an exit code (an integer between 0 and 255 is compatible with most platforms). You should try to emit the correct code for your program's state. For example, in the ideal case when your program succeeds, it should exit with `0`."
msgstr "프로그램이 항상 성공하는 것은 아닙니다. 오류가 발생하면 필요한 정보를 올바르게 내보내야 합니다. [사용자에게 오류 알리기](human-communication.html) 외에도 대부분의 시스템에서 프로세스가 종료될 때 종료 코드(0에서 255 사이의 정수는 대부분의 플랫폼과 호환됨)를 내보냅니다. 프로그램 상태에 대한 올바른 코드를 내보내야 합니다. 예를 들어 이상적인 경우 프로그램이 성공하면 `0`으로 종료해야 합니다."

#: src/in-depth/exit-code.md:18
msgid "When an error occurs, it gets a bit more complicated, though. In the wild, many tools exit with `1` when a common failure occurs. Currently, Rust sets an exit code of `101` when the process panicked. Beyond that, people have done many things in their programs."
msgstr "오류가 발생하면 좀 더 복잡해집니다. 실제로는 많은 도구가 일반적인 실패가 발생하면 `1`로 종료됩니다. 현재 Rust는 프로세스가 패닉할 때 `101`의 종료 코드를 설정합니다. 그 외에도 사람들은 프로그램에서 많은 작업을 수행했습니다."

#: src/in-depth/exit-code.md:24
msgid "So, what to do? The BSD ecosystem has collected a common definition for their exit codes (you can find them [here](https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html)). The Rust library [`exitcode`](https://crates.io/crates/exitcode) provides these same codes, ready to be used in your application. Please see its API documentation for the possible values to use."
msgstr "그래서 무엇을 해야 할까요? BSD 생태계는 종료 코드에 대한 일반적인 정의를 수집했습니다( [여기](https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html)에서 찾을 수 있음). Rust 라이브러리 [`exitcode`](https://crates.io/crates/exitcode)는 이러한 동일한 코드를 제공하며 응용 프로그램에서 사용할 준비가 되어 있습니다. 사용 가능한 값에 대한 API 문서를 참조하십시오."

#: src/in-depth/exit-code.md:31
msgid "After you add the `exitcode` dependency to your `Cargo.toml`, you can use it like this:"
msgstr "`Cargo.toml`에 `exitcode` 의존성을 추가한 후 다음과 같이 사용할 수 있습니다."

#: src/in-depth/exit-code.md:36
msgid "// ...actual work...\n"
msgstr "// ...실제 작업...\n"

#: src/in-depth/exit-code.md:39
msgid "Done!"
msgstr "완료!"

#: src/in-depth/exit-code.md:43 src/in-depth/exit-code.md:47
msgid "Error: {}"
msgstr "오류: {}"

#: src/in-depth/human-communication.md:3
msgid "Make sure to read [the chapter on CLI output](../tutorial/output.html) in the tutorial first. It covers how to write output to the terminal, while this chapter will talk about _what_ to output."
msgstr "먼저 튜토리얼의 [CLI 출력 장](../tutorial/output.html)을 읽으십시오. 터미널에 출력을 작성하는 방법을 다루고, 이 장에서는 _무엇_을 출력할지에 대해 이야기합니다."

#: src/in-depth/human-communication.md:10
msgid "When everything is fine"
msgstr "모든 것이 괜찮을 때"

#: src/in-depth/human-communication.md:12
msgid "It is useful to report on the application's progress even when everything is fine. Try to be informative and concise in these messages. Don't use overly technical terms in the logs. Remember: the application is not crashing so there's no reason for users to look up errors."
msgstr "모든 것이 괜찮을 때도 응용 프로그램의 진행 상황을 보고하는 것이 유용합니다. 이러한 메시지에서 유익하고 간결하게 작성하십시오. 로그에 지나치게 기술적인 용어를 사용하지 마십시오. 기억하세요: 응용 프로그램이 충돌하는 것이 아니므로 사용자가 오류를 찾아볼 이유가 없습니다."

#: src/in-depth/human-communication.md:20
msgid "Most importantly, be consistent in the style of communication. Use the same prefixes and sentence structure to make the logs easily skimmable."
msgstr "가장 중요하게는 통신 스타일을 일관되게 유지하십시오. 동일한 접두사와 문장 구조를 사용하여 로그를 쉽게 훑어볼 수 있도록 하십시오."

#: src/in-depth/human-communication.md:25
msgid "Try to let your application output tell a story about what it's doing and how it impacts the user. This can involve showing a timeline of steps involved or even a progress bar and indicator for long-running actions. The user should at no point get the feeling that the application is doing something mysterious that they cannot follow."
msgstr "응용 프로그램 출력이 무엇을 하고 있으며 사용자에게 어떤 영향을 미치는지에 대한 이야기를 들려주도록 노력하십시오. 여기에는 관련된 단계의 타임라인을 표시하거나 장기 실행 작업에 대한 진행률 표시줄 및 표시기를 표시하는 것이 포함될 수 있습니다. 사용자는 응용 프로그램이 따라갈 수 없는 신비한 작업을 수행하고 있다는 느낌을 받아서는 안 됩니다."

#: src/in-depth/human-communication.md:34
msgid "When it's hard to tell what's going on"
msgstr "무슨 일이 일어나고 있는지 알기 어려울 때"

#: src/in-depth/human-communication.md:36
msgid "When communicating non-nominal state it's important to be consistent. A heavily logging application that doesn't follow strict logging levels provides the same amount, or even less information than a non-logging application."
msgstr "비정상 상태를 전달할 때는 일관성을 유지하는 것이 중요합니다. 엄격한 로깅 수준을 따르지 않는 과도한 로깅 응용 프로그램은 로깅하지 않는 응용 프로그램과 동일하거나 더 적은 정보를 제공합니다."

#: src/in-depth/human-communication.md:41
msgid "Because of this, it's important to define the severity of events and messages that are related to it; then use consistent log levels for them. This way users can select the amount of logging themselves via `--verbose` flags or environment variables (like `RUST_LOG`)."
msgstr "이 때문에 이벤트의 심각도와 관련된 메시지를 정의하는 것이 중요합니다. 그런 다음 일관된 로그 수준을 사용하십시오. 이렇게 하면 사용자는 `--verbose` 플래그 또는 환경 변수( `RUST_LOG` 등)를 통해 로깅 양을 직접 선택할 수 있습니다."

#: src/in-depth/human-communication.md:49
msgid "The commonly used `log` crate [defines](https://docs.rs/log/0.4.4/log/enum.Level.html) the following levels (ordered by increasing severity):"
msgstr "일반적으로 사용되는 `log` 크레이트는 [다음과 같은 수준을 정의합니다](https://docs.rs/log/0.4.4/log/enum.Level.html)(심각도 증가 순서):"

#: src/in-depth/human-communication.md:53
msgid "trace"
msgstr "trace"

#: src/in-depth/human-communication.md:54
msgid "debug"
msgstr "debug"

#: src/in-depth/human-communication.md:55
msgid "info"
msgstr "info"

#: src/in-depth/human-communication.md:56
msgid "warning"
msgstr "warning"

#: src/in-depth/human-communication.md:57
msgid "error"
msgstr "error"

#: src/in-depth/human-communication.md:59
msgid "It's a good idea to think of _info_ as the default log level. Use it for, well, informative output. (Some applications that lean towards a more quiet output style might only show warnings and errors by default.)"
msgstr "_info_를 기본 로그 수준으로 생각하는 것이 좋습니다. 음, 유익한 출력에 사용하십시오. (더 조용한 출력 스타일을 선호하는 일부 응용 프로그램은 기본적으로 경고 및 오류만 표시할 수 있습니다.)"

#: src/in-depth/human-communication.md:64
msgid "Additionally, it's always a good idea to use similar prefixes and sentence structure across log messages, making it easy to use a tool like `grep` to filter for them. A message should provide enough context by itself to be useful in a filtered log while not being _too_ verbose at the same time."
msgstr "또한 로그 메시지 전반에 걸쳐 유사한 접두사와 문장 구조를 사용하는 것이 항상 좋습니다. 이렇게 하면 `grep`과 같은 도구를 사용하여 필터링하기 쉽습니다. 메시지는 필터링된 로그에서 유용할 만큼 충분한 컨텍스트를 제공해야 하며 동시에 _너무_ 장황하지 않아야 합니다."

#: src/in-depth/human-communication.md:74
msgid "Example log statements"
msgstr "예제 로그 문"

#: src/in-depth/human-communication.md:85
msgid "The following log output is taken from [wasm-pack](https://crates.io/crates/wasm-pack):"
msgstr "다음 로그 출력은 [wasm-pack](https://crates.io/crates/wasm-pack)에서 가져온 것입니다."

#: src/in-depth/human-communication.md:103
msgid "When panicking"
msgstr "패닉 시"

#: src/in-depth/human-communication.md:105
msgid "One aspect often forgotten is that your program also outputs something when it crashes. In Rust, \"crashes\" are most often \"panics\" (i.e., \"controlled crashing\" in contrast to \"the operating system killed the process\"). By default, when a panic occurs, a \"panic handler\" will print some information to the console."
msgstr "종종 잊혀지는 한 가지 측면은 프로그램이 충돌할 때도 무언가를 출력한다는 것입니다. Rust에서 \"충돌\"은 대부분 \"패닉\"입니다(즉, \"운영 체제가 프로세스를 종료\"하는 것과 대조되는 \"제어된 충돌\"). 기본적으로 패닉이 발생하면 \"패닉 핸들러\"가 콘솔에 일부 정보를 인쇄합니다."

#: src/in-depth/human-communication.md:114
msgid "For example, if you create a new binary project with `cargo new --bin foo` and replace the content of `fn main` with `panic!(\"Hello World\")`, you get this when you run your program:"
msgstr "예를 들어, `cargo new --bin foo`로 새 바이너리 프로젝트를 만들고 `fn main`의 내용을 `panic!(\"Hello World\")`로 바꾸면 프로그램을 실행할 때 다음과 같은 결과가 나옵니다."

#: src/in-depth/human-communication.md:125
msgid "This is useful information to you, the developer. (Surprise: the program crashed because of line 2 in your `main.rs` file). But for a user who doesn't even have access to the source code, this is not very valuable. In fact, it most likely is just confusing. That's why it's a good idea to add a custom panic handler, that provides a bit more end-user focused output."
msgstr "이것은 개발자인 당신에게 유용한 정보입니다. (놀랍게도 프로그램이 `main.rs` 파일의 2행 때문에 충돌했습니다). 하지만 소스 코드에 액세스할 수 없는 사용자에게는 그다지 가치가 없습니다. 사실, 혼란스러울 가능성이 높습니다. 그렇기 때문에 사용자에게 더 초점을 맞춘 출력을 제공하는 사용자 지정 패닉 핸들러를 추가하는 것이 좋습니다."

#: src/in-depth/human-communication.md:133
msgid "One library that does just that is called [human-panic](https://crates.io/crates/human-panic). To add it to your CLI project, you import it and call the `setup_panic!()` macro at the beginning of your `main` function:"
msgstr "정확히 그렇게 하는 라이브러리 중 하나는 [human-panic](https://crates.io/crates/human-panic)입니다. CLI 프로젝트에 추가하려면 가져와서 `main` 함수의 시작 부분에서 `setup_panic!()` 매크로를 호출합니다."

#: src/in-depth/human-communication.md:145
#: src/in-depth/machine-communication.md:191
#: src/in-depth/machine-communication.md:195
msgid "Hello world"
msgstr "Hello world"

#: src/in-depth/human-communication.md:149
msgid "This will now show a very friendly message, and tells the user what they can do:"
msgstr "이제 매우 친근한 메시지가 표시되며 사용자에게 무엇을 할 수 있는지 알려줍니다."

#: src/in-depth/human-communication.md:152
msgid "```console\nWell, this is embarrassing.\n\nfoo had a problem and crashed. To help us diagnose the problem you can send us a crash report.\n\nWe have generated a report file at \"/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml\". Submit an issue or email with the subject of \"foo Crash Report\" and include the report as an attachment.\n\n- Authors: Your Name <your.name@example.com>\n\nWe take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.\n\nThank you kindly!\n```"
msgstr "```console\nWell, this is embarrassing.\n\nfoo had a problem and crashed. To help us diagnose the problem you can send us a crash report.\n\nWe have generated a report file at \"/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml\". Submit an issue or email with the subject of \"foo Crash Report\" and include the report as an attachment.\n\n- Authors: Your Name <your.name@example.com>\n\nWe take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.\n\nThank you kindly!\n```"

#: src/in-depth/machine-communication.md:3
msgid "The power of command-line tools really comes to shine when you are able to combine them. This is not a new idea: In fact, this is a sentence from the [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy):"
msgstr "명령줄 도구의 힘은 결합할 수 있을 때 진정으로 빛을 발합니다. 이것은 새로운 아이디어가 아닙니다. 사실, 이것은 [Unix 철학](https://en.wikipedia.org/wiki/Unix_philosophy)의 문장입니다."

#: src/in-depth/machine-communication.md:8
msgid "Expect the output of every program to become the input to another, as yet unknown, program."
msgstr "모든 프로그램의 출력이 아직 알려지지 않은 다른 프로그램의 입력이 될 것으로 예상하십시오."

#: src/in-depth/machine-communication.md:12
msgid "If our programs fulfill this expectation, our users will be happy. To make sure this works well, we should provide not just pretty output for humans, but also a version tailored to what other programs need. Let's see how we can do this."
msgstr "우리 프로그램이 이 기대를 충족하면 사용자는 행복할 것입니다. 이것이 잘 작동하도록 하려면 사람들에게 보기 좋은 출력뿐만 아니라 다른 프로그램에 필요한 맞춤 버전도 제공해야 합니다. 이를 수행하는 방법을 살펴봅시다."

#: src/in-depth/machine-communication.md:21
msgid "**Note:** Make sure to read [the chapter on CLI output](../tutorial/output.html) in the tutorial first. It covers how to write output to the terminal, while this chapter will talk about _what_ to output."
msgstr "**참고:** 먼저 튜토리얼의 [CLI 출력 장](../tutorial/output.html)을 읽으십시오. 터미널에 출력을 작성하는 방법을 다루고, 이 장에서는 _무엇_을 출력할지에 대해 이야기합니다."

#: src/in-depth/machine-communication.md:30
msgid "Who's reading this?"
msgstr "누가 이것을 읽고 있습니까?"

#: src/in-depth/machine-communication.md:32
msgid "The first question to ask is: Is our output for a human in front of a colorful terminal, or for another program? To answer this, we can use the [IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) trait:"
msgstr "먼저 물어볼 질문은 다음과 같습니다. 우리의 출력은 화려한 터미널 앞의 사람을 위한 것인가요, 아니면 다른 프로그램을 위한 것인가요? 답하기 위해 [IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) 특성을 사용할 수 있습니다."

#: src/in-depth/machine-communication.md:44
msgid "I'm a terminal"
msgstr "나는 터미널입니다"

#: src/in-depth/machine-communication.md:46
msgid "I'm not"
msgstr "나는 그렇지 않습니다"

#: src/in-depth/machine-communication.md:50
msgid "Depending on who will read our output, we can then add extra information. Humans tend to like colors, for example, if you run `ls` in a random Rust project, you might see something like this:"
msgstr "출력을 읽을 사람에 따라 추가 정보를 추가할 수 있습니다. 예를 들어, 무작위 Rust 프로젝트에서 `ls`를 실행하면 다음과 같은 것을 볼 수 있습니다. 예를 들어 사람들은 색상을 좋아합니다."

#: src/in-depth/machine-communication.md:65
msgid "Because this style is made for humans, in most configurations it'll even print some of the names (like `src`) in color to show that they are directories. If you instead pipe this to a file, or a program like `cat`, `ls` will adapt its output. Instead of using columns that fit my terminal window it will print every entry on its own line. It will also not emit any colors."
msgstr "이 스타일은 사람들을 위해 만들어졌기 때문에 대부분의 구성에서는 `src`와 같은 일부 이름을 색상으로 표시하여 디렉토리임을 보여줍니다. 대신 파일이나 `cat`과 같은 프로그램으로 파이프하면 `ls`가 출력을 조정합니다. 터미널 창에 맞는 열을 사용하는 대신 각 항목을 자체 줄에 인쇄합니다. 색상도 출력하지 않습니다."

#: src/in-depth/machine-communication.md:92
msgid "Easy output formats for machines"
msgstr "기계를 위한 쉬운 출력 형식"

#: src/in-depth/machine-communication.md:94
msgid "Historically, the only type of output command-line tools produced were strings. This is usually fine for people in front of terminals, who are able to read text and reason about its meaning. Other programs usually don't have that ability, though: The only way for them to understand the output of a tool like `ls` is if the author of the program included a parser that happens to work for whatever `ls` outputs."
msgstr "역사적으로 명령줄 도구가 생성한 유일한 유형의 출력은 문자열이었습니다. 이것은 일반적으로 텍스트를 읽고 그 의미를 추론할 수 있는 터미널 앞의 사람들에게는 괜찮습니다. 그러나 다른 프로그램은 일반적으로 그 능력이 없습니다. `ls`와 같은 도구의 출력을 이해하는 유일한 방법은 프로그램 작성자가 `ls`가 출력하는 모든 것에 대해 작동하는 파서를 포함한 경우입니다."

#: src/in-depth/machine-communication.md:105
msgid "This often means that output was limited to what is easy to parse. Formats like TSV (tab-separated values), where each record is on its own line, and each line contains tab-separated content, are very popular. These simple formats based on lines of text allow tools like `grep` to be used on the output of tools like `ls`. `| grep Cargo` doesn't care if your lines are from `ls` or file, it will just filter line by line."
msgstr "이것은 종종 출력이 구문 분석하기 쉬운 것으로 제한된다는 것을 의미합니다. 각 레코드가 자체 줄에 있고 각 줄에 탭으로 구분된 콘텐츠가 포함된 TSV(탭으로 구분된 값)와 같은 형식은 매우 인기가 있습니다. 텍스트 줄을 기반으로 하는 이러한 간단한 형식은 `grep`과 같은 도구를 `ls`와 같은 도구의 출력에 사용할 수 있도록 합니다. `| grep Cargo`는 줄이 `ls`에서 왔는지 파일에서 왔는지 신경 쓰지 않고 줄별로 필터링합니다."

#: src/in-depth/machine-communication.md:117
msgid "The downside of this is that you can't use an easy `grep` invocation to filter all the directories that `ls` gave you. For that, each directory item would need to carry additional data."
msgstr "이것의 단점은 `ls`가 제공한 모든 디렉토리를 필터링하기 위해 간단한 `grep` 호출을 사용할 수 없다는 것입니다. 이를 위해서는 각 디렉토리 항목에 추가 데이터가 포함되어야 합니다."

#: src/in-depth/machine-communication.md:121
msgid "JSON output for machines"
msgstr "기계를 위한 JSON 출력"

#: src/in-depth/machine-communication.md:123
msgid "Tab-separated values is a simple way to output structured data but it requires the other program to know which fields to expect (and in which order) and it's difficult to output messages of different types. For example, let's say our program wanted to message the consumer that it is currently waiting for a download, and afterwards output a message describing the data it got. Those are very different kinds of messages and trying to unify them in a TSV output would require us to invent a way to differentiate them. Same when we wanted to print a message that contains two lists of items of varying lengths."
msgstr "탭으로 구분된 값은 구조화된 데이터를 출력하는 간단한 방법이지만 다른 프로그램이 어떤 필드를 예상해야 하는지(및 어떤 순서로) 알아야 하며 다른 유형의 메시지를 출력하기 어렵습니다. 예를 들어, 우리 프로그램이 소비자에게 현재 다운로드를 기다리고 있다고 메시지를 보내고 그 후 받은 데이터를 설명하는 메시지를 출력한다고 가정해 봅시다. 이것들은 매우 다른 종류의 메시지이며 TSV 출력에서 이를 통합하려고 하면 차별화할 방법을 발명해야 합니다. 가변 길이 항목의 두 목록을 포함하는 메시지를 인쇄하려고 할 때도 마찬가지입니다."

#: src/in-depth/machine-communication.md:138
msgid "Still, it's a good idea to choose a format that is easily parsable in most programming languages/environments. Thus, over the last years a lot of applications gained the ability to output their data in [JSON](https://www.json.org/). It's simple enough that parsers exist in practically every language yet powerful enough to be useful in a lot of cases. While its a text format that can be read by humans, a lot of people have also worked on implementations that are very fast at parsing JSON data and serializing data to JSON."
msgstr "그럼에도 불구하고 대부분의 프로그래밍 언어/환경에서 쉽게 구문 분석할 수 있는 형식을 선택하는 것이 좋습니다. 따라서 지난 몇 년 동안 많은 응용 프로그램이 [JSON](https://www.json.org/)으로 데이터를 출력하는 기능을 갖추게 되었습니다. 거의 모든 언어에 파서가 존재할 만큼 간단하지만 많은 경우에 유용할 만큼 강력합니다. 사람이 읽을 수 있는 텍스트 형식이지만 많은 사람들이 JSON 데이터를 구문 분석하고 데이터를 JSON으로 직렬화하는 데 매우 빠른 구현을 작업했습니다."

#: src/in-depth/machine-communication.md:152
msgid "In the description above, we've talked about \"messages\" being written by our program. This is a good way of thinking about the output: Your program doesn't necessarily only output one blob of data but may in fact emit a lot of different information while it is running. One easy way to support this approach when outputting JSON is to write one JSON document per message and to put each JSON document on new line (sometimes called [Line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON)). This can make implementations as simple as using a regular `println!`."
msgstr "위 설명에서 프로그램에서 작성하는 \"메시지\"에 대해 이야기했습니다. 이것은 출력을 생각하는 좋은 방법입니다. 프로그램이 반드시 하나의 데이터 덩어리만 출력하는 것이 아니라 실행 중에 많은 다른 정보를 방출할 수 있습니다. JSON을 출력할 때 이 접근 방식을 지원하는 한 가지 쉬운 방법은 메시지당 하나의 JSON 문서를 작성하고 각 JSON 문서를 새 줄에 넣는 것입니다(때로는 [줄 구분 JSON](https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON)이라고 함). 이렇게 하면 일반 `println!`을 사용하는 것처럼 구현을 간단하게 만들 수 있습니다."

#: src/in-depth/machine-communication.md:166
msgid "Here's a simple example, using the `json!` macro from [serde_json](https://crates.io/crates/serde_json) to quickly write valid JSON in your Rust source code:"
msgstr "다음은 [serde_json](https://crates.io/crates/serde_json)의 `json!` 매크로를 사용하여 Rust 소스 코드에 유효한 JSON을 빠르게 작성하는 간단한 예입니다."

#: src/in-depth/machine-communication.md:179
msgid "/// Output JSON instead of human readable messages\n"
msgstr "/// 사람이 읽을 수 있는 메시지 대신 JSON 출력\n"

#: src/in-depth/machine-communication.md:190
msgid "type"
msgstr "type"

#: src/in-depth/machine-communication.md:190
msgid "message"
msgstr "message"

#: src/in-depth/machine-communication.md:191
msgid "content"
msgstr "content"

#: src/in-depth/machine-communication.md:200
msgid "And here is the output:"
msgstr "그리고 여기 출력이 있습니다."

#: src/in-depth/machine-communication.md:202
msgid "```console\n$ cargo run -q\nHello world\n$ cargo run -q -- --json\n{\"type\":\"message\",\"content\":\"Hello world\"}\n```"
msgstr "```console\n$ cargo run -q\nHello world\n$ cargo run -q -- --json\n{\"type\":\"message\",\"content\":\"Hello world\"}\n```"

#: src/in-depth/machine-communication.md:209
msgid "(Running `cargo` with `-q` suppresses its usual output. The arguments after `--` are passed to our program.)"
msgstr "(`cargo`를 `-q`와 함께 실행하면 일반 출력이 억제됩니다. `--` 뒤의 인수는 프로그램에 전달됩니다.)"

#: src/in-depth/machine-communication.md:212
msgid "Practical example: ripgrep"
msgstr "실용적인 예: ripgrep"

#: src/in-depth/machine-communication.md:214
msgid "_[ripgrep](https://github.com/BurntSushi/ripgrep)_ is a replacement for _grep_ or _ag_, written in Rust. By default it will produce output like this:"
msgstr "_[ripgrep](https://github.com/BurntSushi/ripgrep)_은 _grep_ 또는 _ag_의 대안이며 Rust로 작성되었습니다. 기본적으로 다음과 같은 출력을 생성합니다."

#: src/in-depth/machine-communication.md:228
msgid "But given `--json` it will print:"
msgstr "하지만 `--json`을 제공하면 다음과 같이 인쇄됩니다."

#: src/in-depth/machine-communication.md:230
msgid "```console\n$ rg default --json\n{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"}}}
{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},\"lines\":{\"text\":\"    Output::default()\n\"},\"line_number\":37,\"absolute_offset\":761,\"submatches\":[{\"match\":{\"text\":\"default\"},\"start\":12,\"end\":19}]}}
{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},\"binary_offset\":null,\"stats\":{\"elapsed\":{\"secs\":0,\"nanos\":137622,\"human\":\"0.000138s\"},\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":6064,\"bytes_printed\":256,\"matched_lines\":1,\"matches\":1}}}
{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"}}}
{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},\"lines\":{\"text\":\"    Span::default()\n\"},\"line_number\":6,\"absolute_offset\":117,\"submatches\":[{\"match\":{\"text\":\"default\"},\"start\":10,\"end\":17}]}}
{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},\"binary_offset\":null,\"stats\":{\"elapsed\":{\"secs\":0,\"nanos\":22025,\"human\":\"0.000022s\"},\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":5221,\"bytes_printed\":277,\"matched_lines\":1,\"matches\":1}}}
{\"data\":{\"elapsed_total\":{\"human\":\"0.006995s\",\"nanos\":6994920,\"secs\":0},\"stats\":{\"bytes_printed\":533,\"bytes_searched\":11285,\"elapsed\":{\"human\":\"0.000160s\",\"nanos\":159647,\"secs\":0},\"matched_lines\":2,\"matches\":2,\"searches\":2,\"searches_with_match\":2}},\"type\":\"summary\"}\n```"
msgstr "```console\n$ rg default --json\n{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"}}}
{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},\"lines\":{\"text\":\"    Output::default()\n\"},\"line_number\":37,\"absolute_offset\":761,\"submatches\":[{\"match\":{\"text\":\"default\"},\"start\":12,\"end\":19}]}}
{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},\"binary_offset\":null,\"stats\":{\"elapsed\":{\"secs\":0,\"nanos\":137622,\"human\":\"0.000138s\"},\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":6064,\"bytes_printed\":256,\"matched_lines\":1,\"matches\":1}}}
{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"}}}
{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},\"lines\":{\"text\":\"    Span::default()\n\"},\"line_number\":6,\"absolute_offset\":117,\"submatches\":[{\"match\":{\"text\":\"default\"},\"start\":10,\"end\":17}]}}
{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},\"binary_offset\":null,\"stats\":{\"elapsed\":{\"secs\":0,\"nanos\":22025,\"human\":\"0.000022s\"},\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":5221,\"bytes_printed\":277,\"matched_lines\":1,\"matches\":1}}}
{\"data\":{\"elapsed_total\":{\"human\":\"0.006995s\",\"nanos\":6994920,\"secs\":0},\"stats\":{\"bytes_printed\":533,\"bytes_searched\":11285,\"elapsed\":{\"human\":\"0.000160s\",\"nanos\":159647,\"secs\":0},\"matched_lines\":2,\"matches\":2,\"searches\":2,\"searches_with_match\":2}},\"type\":\"summary\"}\n```"

#: src/in-depth/machine-communication.md:241
msgid "As you can see, each JSON document is an object (map) containing a `type` field. This would allow us to write a simple frontend for `rg` that reads these documents as they come in and show the matches (as well the files they are in) even while _ripgrep_ is still searching."
msgstr "보시다시피 각 JSON 문서는 `type` 필드를 포함하는 객체(맵)입니다. 이를 통해 `rg`에 대한 간단한 프런트엔드를 작성하여 문서를 수신하는 대로 읽고 _ripgrep_이 아직 검색 중일 때도 일치 항목(파일 포함)을 표시할 수 있습니다."

#: src/in-depth/machine-communication.md:250
msgid "**Note:** This is how Visual Studio Code uses _ripgrep_ for its code search."
msgstr "**참고:** 이것이 Visual Studio Code가 코드 검색에 _ripgrep_을 사용하는 방식입니다."

#: src/in-depth/machine-communication.md:255
msgid "How to deal with input piped into us"
msgstr "파이프된 입력을 처리하는 방법"

#: src/in-depth/machine-communication.md:257
msgid "Let's say we have a program that reads the number of words in a file:"
msgstr "파일의 단어 수를 읽는 프로그램이 있다고 가정해 봅시다."

#: src/in-depth/machine-communication.md:262
msgid "/// Count the number of lines in a file\n"
msgstr "/// 파일의 줄 수 계산\n"

#: src/in-depth/machine-communication.md:277
#: src/in-depth/machine-communication.md:343
msgid " "
msgstr " "

#: src/in-depth/machine-communication.md:280
msgid "Words in {}: {}"
msgstr "{}: {} 단어"

#: src/in-depth/machine-communication.md:284
msgid "It takes the path to a file, reads it line by line, and counts the number of words separated by a space."
msgstr "파일 경로를 가져와 줄별로 읽고 공백으로 구분된 단어 수를 계산합니다."

#: src/in-depth/machine-communication.md:287
msgid "When you run it, it outputs the total words in the file:"
msgstr "실행하면 파일의 총 단어 수가 출력됩니다."

#: src/in-depth/machine-communication.md:294
msgid "But what if we wanted to count the number of words piped into the program? Rust programs can read data passed in via stdin with the [Stdin struct](https://doc.rust-lang.org/std/io/struct.Stdin.html) which you can obtain via [the stdin function](https://doc.rust-lang.org/std/io/fn.stdin.html) from the standard library. Similar to reading the lines of a file, it can read the lines from stdin."
msgstr "하지만 프로그램으로 파이프된 단어 수를 세고 싶다면 어떻게 될까요? Rust 프로그램은 표준 라이브러리의 [stdin 함수](https://doc.rust-lang.org/std/io/fn.stdin.html)를 통해 얻을 수 있는 [Stdin 구조체](https://doc.rust-lang.org/std/io/struct.Stdin.html)를 사용하여 stdin을 통해 전달된 데이터를 읽을 수 있습니다. 파일 줄을 읽는 것과 유사하게 stdin에서 줄을 읽을 수 있습니다."

#: src/in-depth/machine-communication.md:301
msgid "Here's a program that counts the words of what's piped in via stdin"
msgstr "stdin을 통해 파이프된 단어를 계산하는 프로그램입니다."

#: src/in-depth/machine-communication.md:310
msgid "/// Count the number of lines in a file or stdin\n"
msgstr "/// 파일 또는 stdin의 줄 수 계산\n"

#: src/in-depth/machine-communication.md:315
msgid "/// The path to the file to read, use - to read from stdin (must not be a tty)\n"
msgstr "/// 읽을 파일의 경로, stdin에서 읽으려면 - 사용(tty여서는 안 됨)\n"

#: src/in-depth/machine-communication.md:325
msgid "-"
msgstr "-"

#: src/in-depth/machine-communication.md:331
msgid "<stdin>"
msgstr "<stdin>"

#: src/in-depth/machine-communication.md:337
msgid "Words from {}: {}"
msgstr "{}: {} 단어"

#: src/in-depth/machine-communication.md:349
msgid "If you run that program with text piped in, with `-` representing the intent to read from `stdin`, it'll output the word count:"
msgstr "`stdin`에서 읽으려는 의도를 나타내는 `-`를 사용하여 텍스트를 파이프한 프로그램으로 실행하면 단어 수가 출력됩니다."

#: src/in-depth/machine-communication.md:352
msgid "```console\n$ echo \"hi there friend\" | cargo run -- -\nWords from stdin: 3\n```"
msgstr "```console\n$ echo \"hi there friend\" | cargo run -- -\nWords from stdin: 3\n```"

#: src/in-depth/machine-communication.md:357
msgid "It requires that stdin is not interactive because we're expecting input that's piped through to the program, not text that's typed in at runtime. If stdin is a tty, it outputs the help docs so that it's clear why it doesn't work."
msgstr "런타임에 입력되는 텍스트가 아니라 프로그램으로 파이프되는 입력을 예상하기 때문에 stdin이 대화형이 아니어야 합니다. stdin이 tty인 경우 작동하지 않는 이유를 명확히 하기 위해 도움말 문서를 출력합니다."

#: src/in-depth/docs.md:3
msgid "Documentation for CLIs usually consists of a `--help` section in the command and a manual (`man`) page."
msgstr "CLI의 문서는 일반적으로 명령의 `--help` 섹션과 매뉴얼(`man`) 페이지로 구성됩니다."

#: src/in-depth/docs.md:7
msgid "Both can be automatically generated when using [`clap`](https://crates.io/crates/clap), via [`clap_mangen`](https://crates.io/crates/clap_mangen) crate."
msgstr "둘 다 [`clap`](https://crates.io/crates/clap)을 사용할 때 [`clap_mangen`](https://crates.io/crates/clap_mangen) 크레이트를 통해 자동으로 생성될 수 있습니다."

#: src/in-depth/docs.md:14
msgid "/// file to load\n"
msgstr "/// 로드할 파일\n"

#: src/in-depth/docs.md:16
msgid "/// how many lines to print\n"
msgstr "/// 인쇄할 줄 수\n"

#: src/in-depth/docs.md:22
msgid "Secondly, you need to use a `build.rs` to generate the manual file at compile time from the definition of your app in code."
msgstr "둘째, 코드로 앱을 정의한 후 컴파일 시간에 매뉴얼 파일을 생성하기 위해 `build.rs`를 사용해야 합니다."

#: src/in-depth/docs.md:27
msgid "There are a few things to keep in mind (such as how you want to package your binary) but for now we simply put the `man` file next to our `src` folder."
msgstr "명심해야 할 몇 가지 사항이 있습니다(바이너리를 패키징하는 방법 등). 하지만 지금은 `man` 파일을 `src` 폴더 옆에 두겠습니다."

#: src/in-depth/docs.md:36
msgid "src/cli.rs"
msgstr "src/cli.rs"

#: src/in-depth/docs.md:40
msgid "OUT_DIR"
msgstr "OUT_DIR"

#: src/in-depth/docs.md:47
msgid "head.1"
msgstr "head.1"

#: src/in-depth/docs.md:53
msgid "When you now compile your application there will be a `head.1` file in your project directory."
msgstr "이제 응용 프로그램을 컴파일하면 프로젝트 디렉토리에 `head.1` 파일이 생성됩니다."

#: src/in-depth/docs.md:57
msgid "If you open that in `man` you'll be able to admire your free documentation."
msgstr "`man`에서 열면 무료 문서를 감상할 수 있습니다."

#: src/resources/index.md:3
msgid "Collaboration / help"
msgstr "협업 / 도움"

#: src/resources/index.md:4
msgid "[cli-and-tui Discord Channel](https://discord.com/channels/273534239310479360/943315667430563862)"
msgstr "[cli-and-tui Discord 채널](https://discord.com/channels/273534239310479360/943315667430563862)"

#: src/resources/index.md:6
msgid "Crates referenced in this book"
msgstr "이 책에서 참조된 크레이트"

#: src/resources/index.md:8
msgid "[anyhow](https://crates.io/crates/anyhow) - provides `anyhow::Error` for easy error handling"
msgstr "[anyhow](https://crates.io/crates/anyhow) - 쉬운 오류 처리를 위한 `anyhow::Error` 제공"

#: src/resources/index.md:9
msgid "[assert_cmd](https://crates.io/crates/assert_cmd) - simplifies integration testing of CLIs"
msgstr "[assert_cmd](https://crates.io/crates/assert_cmd) - CLI 통합 테스트 단순화"

#: src/resources/index.md:10
msgid "[assert_fs](https://crates.io/crates/assert_fs) - Setup input files and test output files"
msgstr "[assert_fs](https://crates.io/crates/assert_fs) - 입력 파일 설정 및 출력 파일 테스트"

#: src/resources/index.md:11
msgid "[clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) - adds a `--verbose` flag to clap CLIs"
msgstr "[clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) - clap CLI에 `--verbose` 플래그 추가"

#: src/resources/index.md:12
msgid "[clap](https://crates.io/crates/clap) - command line argument parser"
msgstr "[clap](https://crates.io/crates/clap) - 명령줄 인수 파서"

#: src/resources/index.md:13
msgid "[confy](https://crates.io/crates/confy) - boilerplate-free configuration management"
msgstr "[confy](https://crates.io/crates/confy) - 보일러플레이트 없는 구성 관리"

#: src/resources/index.md:14
msgid "[crossbeam-channel](https://crates.io/crates/crossbeam-channel) - provides multi-producer multi-consumer channels for message passing"
msgstr "[crossbeam-channel](https://crates.io/crates/crossbeam-channel) - 메시지 전달을 위한 다중 생산자 다중 소비자 채널 제공"

#: src/resources/index.md:15
msgid "[ctrlc](https://crates.io/crates/ctrlc) - easy ctrl-c handler"
msgstr "[ctrlc](https://crates.io/crates/ctrlc) - 쉬운 ctrl-c 핸들러"

#: src/resources/index.md:16
msgid "[env_logger](https://crates.io/crates/env_logger) - implements a logger configurable via environment variables"
msgstr "[env_logger](https://crates.io/crates/env_logger) - 환경 변수를 통해 구성 가능한 로거 구현"

#: src/resources/index.md:17
msgid "[exitcode](https://crates.io/crates/exitcode) - system exit code constants"
msgstr "[exitcode](https://crates.io/crates/exitcode) - 시스템 종료 코드 상수"

#: src/resources/index.md:18
msgid "[human-panic](https://crates.io/crates/human-panic) - panic message handler"
msgstr "[human-panic](https://crates.io/crates/human-panic) - 패닉 메시지 핸들러"

#: src/resources/index.md:19
msgid "[indicatif](https://crates.io/crates/indicatif) - progress bars and spinners"
msgstr "[indicatif](https://crates.io/crates/indicatif) - 진행률 표시줄 및 스피너"

#: src/resources/index.md:20
msgid "[log](https://crates.io/crates/log) - provides logging abstracted over implementation"
msgstr "[log](https://crates.io/crates/log) - 구현에 추상화된 로깅 제공"

#: src/resources/index.md:21
msgid "[predicates](https://crates.io/crates/predicates) - implements boolean-valued predicate functions"
msgstr "[predicates](https://crates.io/crates/predicates) - 부울 값 술어 함수 구현"

#: src/resources/index.md:22
msgid "[proptest](https://crates.io/crates/proptest) - property testing framework"
msgstr "[proptest](https://crates.io/crates/proptest) - 속성 테스트 프레임워크"

#: src/resources/index.md:23
msgid "[serde_json](https://crates.io/crates/serde_json) - serialize/deserialize to JSON"
msgstr "[serde_json](https://crates.io/crates/serde_json) - JSON으로 직렬화/역직렬화"

#: src/resources/index.md:24
msgid "[signal-hook](https://crates.io/crates/signal-hook) - handles UNIX signals"
msgstr "[signal-hook](https://crates.io/crates/signal-hook) - UNIX 신호 처리"

#: src/resources/index.md:25
msgid "[tokio](https://crates.io/crates/tokio) - asynchronous runtime"
msgstr "[tokio](https://crates.io/crates/tokio) - 비동기 런타임"

#: src/resources/index.md:26
msgid "[wasm-pack](https://crates.io/crates/wasm-pack) - tool for building WebAssembly"
msgstr "[wasm-pack](https://crates.io/crates/wasm-pack) - WebAssembly 빌드 도구"

#: src/resources/index.md:28
msgid "Other crates"
msgstr "기타 크레이트"

#: src/resources/index.md:30
msgid "Due to the constantly-changing landscape of Rust crates, a good place to find crates is the [lib.rs](https://lib.rs) crate index, including:"
msgstr "Rust 크레이트의 끊임없이 변화하는 환경 때문에 크레이트를 찾을 수 있는 좋은 장소는 [lib.rs](https://lib.rs) 크레이트 인덱스이며, 다음을 포함합니다."

#: src/resources/index.md:32
msgid "[Command-line interface](https://lib.rs/command-line-interface)"
msgstr "[명령줄 인터페이스](https://lib.rs/command-line-interface)"

#: src/resources/index.md:33
msgid "[Configuration](https://lib.rs/config)"
msgstr "[구성](https://lib.rs/config)"

#: src/resources/index.md:34
msgid "[Database interfaces](https://lib.rs/database)"
msgstr "[데이터베이스 인터페이스](https://lib.rs/database)"

#: src/resources/index.md:35
msgid "[Encoding](https://lib.rs/encoding)"
msgstr "[인코딩](https://lib.rs/encoding)"

#: src/resources/index.md:36
msgid "[Filesystem](https://lib.rs/filesystem)"
msgstr "[파일 시스템](https://lib.rs/filesystem)"

#: src/resources/index.md:37
msgid "[HTTP Client](https://lib.rs/web-programming/http-client)"
msgstr "[HTTP 클라이언트](https://lib.rs/web-programming/http-client)"

#: src/resources/index.md:38
msgid "[Operating systems](https://lib.rs/os)"
msgstr "[운영 체제](https://lib.rs/os)"

#: src/resources/index.md:40
msgid "Other resources:"
msgstr "기타 리소스:"

#: src/resources/index.md:41
msgid "[Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)"
msgstr "[Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)"

#: src/resources/index.md:42
msgid "[rosetta-rs](https://github.com/rosetta-rs)"
msgstr "[rosetta-rs](https://github.com/rosetta-rs)"